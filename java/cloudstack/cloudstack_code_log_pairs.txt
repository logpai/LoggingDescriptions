public void create() throws ResourceAllocationException {	try {	StaticRoute result = _vpcService.createStaticRoute(getGatewayId(), getCidr());	setEntityId(result.getId());	setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

public void create() throws ResourceAllocationException {	try {	StaticRoute result = _vpcService.createStaticRoute(getGatewayId(), getCidr());	setEntityId(result.getId());	setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

========================= cloudstack sample_3535 =========================

return true;	}	List<ClusterVSMMapVO> clusterList = _clusterVSMDao.listByVSMId(vsmId);	if (clusterList != null) {	for (ClusterVSMMapVO record : clusterList) {	Long clusterId = record.getClusterId();	List<HostVO> hosts = _resourceMgr.listAllHostsInCluster(clusterId);	if (hosts != null && hosts.size() > 0) {	for (Host host : hosts) {	if (host.getType() == Host.Type.Routing) {	
non empty cluster with id still has a host that uses this vsm please empty the cluster first 

public CiscoNexusVSMDeviceVO getCiscoVSMbyClusId(long clusterId) {	ClusterVSMMapVO mapVO = _clusterVSMDao.findByClusterId(clusterId);	if (mapVO == null) {	
couldn t find a vsm associated with the specified cluster id 

========================= cloudstack sample_1271 =========================

public void registerShutdownHook() {	Map<String, ApplicationContext> contextMap= moduleDefinitionSet.getContextMap();	for (String appName : contextMap.keySet()) {	ApplicationContext contex = contextMap.get(appName);	if (contex instanceof ConfigurableApplicationContext) {	
registering shutdown hook for bean 

while (def != null) {	inherited.addAll(def.getInheritableContextLocations());	def = moduleDefinitionSet.getModuleDefinition(def.getParentName());	}	List<String> urlList = new ArrayList<String>();	for (Resource r : inherited) {	try {	String urlString = r.getURL().toExternalForm();	urlList.add(urlString);	} catch (IOException e) {	
failed to create url for 

========================= cloudstack sample_746 =========================

pstmt.setLong(1, msid);	} else {	pstmt.setString(1, role.toString());	pstmt.setLong(2, msid);	}	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	l.add(rs.getLong(1));	}	} catch (SQLException e) {	
caught sqlexception 

pstmt.setLong(1, zoneId);	} else {	pstmt.setLong(1, zoneId);	pstmt.setString(2, role.toString());	}	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	l.add(rs.getLong(1));	}	} catch (SQLException e) {	
unexpected exception 

========================= cloudstack sample_4618 =========================

public AgentResourceBase(long instanceId, AgentType agentType, SimulatorManager simMgr, String hostGuid) {	_instanceId = instanceId;	if (s_logger.isDebugEnabled()) {	
new routing host instantiated with guid 

public AgentResourceBase() {	if (s_logger.isDebugEnabled()) {	
deserializing simulated agent on reconnect 

private void reconnect(MockHost host) {	if (s_logger.isDebugEnabled()) {	
reconfiguring existing simulated host w name and guid 

protected String findScript(String script) {	
looking for in the classpath 

protected String findScript(String script) {	URL url = ClassLoader.getSystemResource(script);	File file = null;	if (url == null) {	file = new File("./" + script);	
looking for in 

========================= cloudstack sample_984 =========================

public String uploadPublicTemplate(long id, String url, String name, ImageFormat format, Long accountId, String descr, String cksum, String installPathPrefix, String userName, String passwd, long templateSizeInBytes) {	UUID uuid = UUID.randomUUID();	String jobId = uuid.toString();	String completePath = parentDir + File.separator + installPathPrefix;	
starting upload from 

public String uploadPublicTemplate(long id, String url, String name, ImageFormat format, Long accountId, String descr, String cksum, String installPathPrefix, String userName, String passwd, long templateSizeInBytes) {	UUID uuid = UUID.randomUUID();	String jobId = uuid.toString();	String completePath = parentDir + File.separator + installPathPrefix;	URI uri;	try {	uri = new URI(url);	} catch (URISyntaxException e) {	
uri is incorrect 

try {	uri = new URI(url);	} catch (URISyntaxException e) {	throw new CloudRuntimeException("URI is incorrect: " + url);	}	TemplateUploader tu;	if ((uri != null) && (uri.getScheme() != null)) {	if (uri.getScheme().equalsIgnoreCase("ftp")) {	tu = new FtpTemplateUploader(completePath, url, new Completion(jobId), templateSizeInBytes);	} else {	
scheme is not supported 

throw new CloudRuntimeException("URI is incorrect: " + url);	}	TemplateUploader tu;	if ((uri != null) && (uri.getScheme() != null)) {	if (uri.getScheme().equalsIgnoreCase("ftp")) {	tu = new FtpTemplateUploader(completePath, url, new Completion(jobId), templateSizeInBytes);	} else {	throw new CloudRuntimeException("Scheme is not supported " + url);	}	} else {	
unable to download from url 

public UploadAnswer handleUploadCommand(SecondaryStorageResource resource, UploadCommand cmd) {	
handling the upload 

public Answer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd) {	
handledeleteentitydownloadurlcommand path type 

public Answer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd) {	String path = cmd.getPath();	Script command = new Script("/bin/bash", s_logger);	command.add("-c");	String extractUrl = cmd.getExtractUrl();	command.add("unlink /var/www/html/userdata/" + extractUrl.substring(extractUrl.lastIndexOf(File.separator) + 1));	String result = command.execute();	if (result != null) {	
error in deleting symlink 

} catch (ClassNotFoundException e) {	throw new ConfigurationException("Unable to instantiate " + value);	} catch (InstantiationException e) {	throw new ConfigurationException("Unable to instantiate " + value);	} catch (IllegalAccessException e) {	throw new ConfigurationException("Unable to instantiate " + value);	}	}	String inSystemVM = (String)params.get("secondary.storage.vm");	if (inSystemVM != null && "true".equalsIgnoreCase(inSystemVM)) {	
uploadmanager starting additional services since we are inside system vm 

private void startAdditionalServices() {	Script command = new Script("rm", s_logger);	command.add("-rf");	command.add(extractMountPoint);	String result = command.execute();	if (result != null) {	
error in creating file error 

command.add("-rf");	command.add(extractMountPoint);	String result = command.execute();	if (result != null) {	return;	}	command = new Script("touch", s_logger);	command.add(extractMountPoint);	result = command.execute();	if (result != null) {	
error in creating file error 

case UNKNOWN: return;	case IN_PROGRESS: s_logger.info("Resuming jobId: " + jobId + ", status=" + status);	tu.setResume(true);	threadPool.execute(tu);	break;	case RECOVERABLE_ERROR: threadPool.execute(tu);	break;	case UPLOAD_FINISHED: tu.setUploadError("Upload success, starting install ");	String result = postUpload(jobId);	if (result != null) {	
failed post upload script 

threadPool.execute(tu);	break;	case RECOVERABLE_ERROR: threadPool.execute(tu);	break;	case UPLOAD_FINISHED: tu.setUploadError("Upload success, starting install ");	String result = postUpload(jobId);	if (result != null) {	tu.setStatus(Status.UNRECOVERABLE_ERROR);	tu.setUploadError("Failed post upload script: " + result);	} else {	
upload completed successfully at 

========================= cloudstack sample_5009 =========================

public boolean configDhcpForSubnet(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final DeployDestination dest, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	
config dhcp for subnets rules 

public boolean configDhcpForSubnet(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final DeployDestination dest, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	final DomainRouterVO router = routers.get(0);	if (router.getState() != State.Running) {	
failed to configure dhcp router not in running state 

public boolean applyDhcpEntry(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final DeployDestination dest, final DomainRouterVO router) throws ResourceUnavailableException {	
applying dhcp entry rules 

public boolean applyUserData(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final DeployDestination dest, final DomainRouterVO router) throws ResourceUnavailableException {	
applying userdata rules 

public boolean applyLoadBalancingRules(final Network network, final List<LoadBalancingRule> rules, final VirtualRouter router) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	
no lb rules to be applied for network 

public boolean applyLoadBalancingRules(final Network network, final List<LoadBalancingRule> rules, final VirtualRouter router) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	
applying load balancing rules 

public boolean applyFirewallRules(final Network network, final List<? extends FirewallRule> rules, final VirtualRouter router) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	
no firewall rules to be applied for network 

public boolean applyFirewallRules(final Network network, final List<? extends FirewallRule> rules, final VirtualRouter router) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	
applying firewall rules 

public boolean applyStaticNats(final Network network, final List<? extends StaticNat> rules, final VirtualRouter router) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	
no static nat rules to be applied for network 

public boolean applyStaticNats(final Network network, final List<? extends StaticNat> rules, final VirtualRouter router) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	
applying static nat rules 

public boolean associatePublicIP(final Network network, final List<? extends PublicIpAddress> ipAddress, final VirtualRouter router) throws ResourceUnavailableException {	if (ipAddress == null || ipAddress.isEmpty()) {	
no ip association rules to be applied for network 

public boolean associatePublicIP(final Network network, final List<? extends PublicIpAddress> ipAddress, final VirtualRouter router) throws ResourceUnavailableException {	if (ipAddress == null || ipAddress.isEmpty()) {	return true;	}	
applying ip rules 

public String[] applyVpnUsers(final Network network, final List<? extends VpnUser> users, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	
failed to add remove vpn users no router found for account and zone 

public String[] applyVpnUsers(final Network network, final List<? extends VpnUser> users, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	throw new ResourceUnavailableException("Unable to assign ip addresses, domR doesn't exist for network " + network.getId(), DataCenter.class, network.getDataCenterId());	}	
applying basic vpn rules 

public String[] applyVpnUsers(final Network network, final List<? extends VpnUser> users, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	throw new ResourceUnavailableException("Unable to assign ip addresses, domR doesn't exist for network " + network.getId(), DataCenter.class, network.getDataCenterId());	}	final BasicVpnRules vpnRules = new BasicVpnRules(network, users);	boolean agentResults = true;	for (final DomainRouterVO router : routers) {	if(router.getState() == State.Stopped || router.getState() == State.Stopping){	
the router is in the state so not applying the vpn rules will be applied once the router gets restarted 

if (routers == null || routers.isEmpty()) {	throw new ResourceUnavailableException("Unable to assign ip addresses, domR doesn't exist for network " + network.getId(), DataCenter.class, network.getDataCenterId());	}	final BasicVpnRules vpnRules = new BasicVpnRules(network, users);	boolean agentResults = true;	for (final DomainRouterVO router : routers) {	if(router.getState() == State.Stopped || router.getState() == State.Stopping){	continue;	}	else if (router.getState() != State.Running) {	
failed to add remove vpn users router not in running state 

public boolean savePasswordToRouter(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final VirtualRouter router) throws ResourceUnavailableException {	
save password to route rules 

public boolean saveSSHPublicKeyToRouter(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final VirtualRouter router, final String sshPublicKey) throws ResourceUnavailableException {	
save ssh pub key to route rules 

public boolean saveUserDataToRouter(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final VirtualRouter router) throws ResourceUnavailableException {	
save userdata to route rules 

public boolean applyRules(final Network network, final VirtualRouter router, final String typeString, final boolean isPodLevelException, final Long podId, final boolean failWhenDisconnect, final RuleApplierWrapper<RuleApplier> ruleApplierWrapper) throws ResourceUnavailableException {	if (router == null) {	
unable to apply virtual router doesn t exist in the network 

}	final RuleApplier ruleApplier = ruleApplierWrapper.getRuleType();	final DataCenter dc = _dcDao.findById(network.getDataCenterId());	final boolean isZoneBasic = dc.getNetworkType() == NetworkType.Basic;	assert !(!isZoneBasic && isPodLevelException || isZoneBasic && isPodLevelException && podId == null);	final List<VirtualRouter> connectedRouters = new ArrayList<VirtualRouter>();	final List<VirtualRouter> disconnectedRouters = new ArrayList<VirtualRouter>();	boolean result = true;	final String msg = "Unable to apply " + typeString + " on disconnected router ";	if (router.getState() == State.Running) {	
applying in network 

assert !(!isZoneBasic && isPodLevelException || isZoneBasic && isPodLevelException && podId == null);	final List<VirtualRouter> connectedRouters = new ArrayList<VirtualRouter>();	final List<VirtualRouter> disconnectedRouters = new ArrayList<VirtualRouter>();	boolean result = true;	final String msg = "Unable to apply " + typeString + " on disconnected router ";	if (router.getState() == State.Running) {	if (router.isStopPending()) {	if (_hostDao.findById(router.getHostId()).getState() == Status.Up) {	throw new ResourceUnavailableException("Unable to process due to the stop pending router " + router.getInstanceName() + " haven't been stopped after it's host coming back!", DataCenter.class, router.getDataCenterId());	}	
router is stop pending so not sending apply commands to the backend 

s_logger.warn(msg + router.getInstanceName(), e);	disconnectedRouters.add(router);	}	if (!result) {	if (isZoneBasic && isPodLevelException) {	throw new ResourceUnavailableException("Unable to apply " + typeString + " on router ", Pod.class, podId);	}	throw new ResourceUnavailableException("Unable to apply " + typeString + " on router ", DataCenter.class, router.getDataCenterId());	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	
router is in so not sending apply commands to the backend 

disconnectedRouters.add(router);	}	if (!result) {	if (isZoneBasic && isPodLevelException) {	throw new ResourceUnavailableException("Unable to apply " + typeString + " on router ", Pod.class, podId);	}	throw new ResourceUnavailableException("Unable to apply " + typeString + " on router ", DataCenter.class, router.getDataCenterId());	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	} else {	
unable to apply virtual router is not in the right state 

========================= cloudstack sample_2236 =========================

SolidFireUtil.SolidFireVolume sfNewVolume = SolidFireUtil.getSolidFireVolume(sfConnection, sfNewVolumeId);	updateSnapshotDetails(snapshotInfo.getId(), sfNewVolumeId, storagePoolId, sfVolumeSize, sfNewVolume.getIqn());	snapshotObjectTo.setPath("SfVolumeId=" + sfNewVolumeId);	}	storagePoolDao.update(storagePoolId, storagePool);	CreateObjectAnswer createObjectAnswer = new CreateObjectAnswer(snapshotObjectTo);	result = new CreateCmdResult(null, createObjectAnswer);	result.setResult(null);	}	catch (Exception ex) {	
failed to take cloudstack snapshot 

long volumeId = volumeInfo.getId();	SolidFireUtil.SolidFireConnection sfConnection = SolidFireUtil.getSolidFireConnection(storagePoolId, storagePoolDetailsDao);	deleteSolidFireVolume(sfConnection, volumeInfo);	volumeDetailsDao.removeDetails(volumeId);	StoragePoolVO storagePool = storagePoolDao.findById(storagePoolId);	long usedBytes = getUsedBytes(storagePool, volumeId);	storagePool.setUsedBytes(usedBytes < 0 ? 0 : usedBytes);	storagePoolDao.update(storagePoolId, storagePool);	}	catch (Exception ex) {	
failed to delete solidfire volume cloudstack volume id 

long sfVolumeId = Long.parseLong(snapshotDetails.getValue());	SolidFireUtil.deleteSolidFireVolume(sfConnection, sfVolumeId);	}	snapshotDetailsDao.removeDetails(csSnapshotId);	StoragePoolVO storagePool = storagePoolDao.findById(storagePoolId);	long usedBytes = getUsedBytes(storagePool);	storagePool.setUsedBytes(usedBytes < 0 ? 0 : usedBytes);	storagePoolDao.update(storagePoolId, storagePool);	}	catch (Exception ex) {	
issue in deletesnapshot snapshotinfo long cloudstack snapshot id 

long sfTemplateVolumeId = getVolumeIdFrom_iScsiPath(template.getInstallPath());	SolidFireUtil.deleteSolidFireVolume(sfConnection, sfTemplateVolumeId);	VMTemplateStoragePoolVO templatePoolRef = tmpltPoolDao.findByPoolTemplate(storagePoolId, template.getId());	tmpltPoolDao.remove(templatePoolRef.getId());	StoragePoolVO storagePool = storagePoolDao.findById(storagePoolId);	long usedBytes = getUsedBytes(storagePool);	storagePool.setUsedBytes(usedBytes < 0 ? 0 : usedBytes);	storagePoolDao.update(storagePoolId, storagePool);	}	catch (Exception ex) {	
failed to delete solidfire template volume cloudstack template id 

========================= cloudstack sample_1949 =========================

public boolean start() {	
startup cloudstack management server 

public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize) {	final Account caller = getCaller();	if (!_accountMgr.isRootAdmin(caller.getId())) {	if (s_logger.isDebugEnabled()) {	
caller is not a root admin permission denied to migrate the vm 

}	throw new PermissionDeniedException("No permission to migrate VM, Only Root Admin can migrate a VM!");	}	final VMInstanceVO vm = _vmInstanceDao.findById(vmId);	if (vm == null) {	final InvalidParameterValueException ex = new InvalidParameterValueException("Unable to find the VM with given id");	throw ex;	}	if (vm.getState() != State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is not running cannot migrate the vm 

throw ex;	}	if (vm.getState() != State.Running) {	if (s_logger.isDebugEnabled()) {	}	final InvalidParameterValueException ex = new InvalidParameterValueException("VM is not Running, cannot " + "migrate the vm with specified id");	ex.addProxyObject(vm.getUuid(), "vmId");	throw ex;	}	if(_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {	
live migration of gpu enabled vm is not supported 

}	final InvalidParameterValueException ex = new InvalidParameterValueException("VM is not Running, cannot " + "migrate the vm with specified id");	ex.addProxyObject(vm.getUuid(), "vmId");	throw ex;	}	if(_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {	return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List <? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());	}	if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM) && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC) && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {	if (s_logger.isDebugEnabled()) {	
is not xenserver vmware kvm ovm hyperv cannot migrate this vm 

}	throw new InvalidParameterValueException("Unsupported Hypervisor Type for VM migration, we support " + "XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only");	}	if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {	throw new InvalidParameterValueException("Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only");	}	final long srcHostId = vm.getHostId();	final Host srcHost = _hostDao.findById(srcHostId);	if (srcHost == null) {	if (s_logger.isDebugEnabled()) {	
unable to find the host with id of this vm 

iterator.remove();	}	}	}	}	}	plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);	} else {	final Long cluster = srcHost.getClusterId();	if (s_logger.isDebugEnabled()) {	
searching for all hosts in cluster for migrating vm 

suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);	} else {	suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);	}	if (suitableHosts != null && !suitableHosts.isEmpty()) {	break;	}	}	if (s_logger.isDebugEnabled()) {	if (suitableHosts.isEmpty()) {	
no suitable hosts found 

} else {	suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);	}	if (suitableHosts != null && !suitableHosts.isEmpty()) {	break;	}	}	if (s_logger.isDebugEnabled()) {	if (suitableHosts.isEmpty()) {	} else {	
hosts having capacity and suitable for migration 

public Pair<List<? extends StoragePool>, List<? extends StoragePool>> listStoragePoolsForMigrationOfVolume(final Long volumeId) {	final Account caller = getCaller();	if (!_accountMgr.isRootAdmin(caller.getId())) {	if (s_logger.isDebugEnabled()) {	
caller is not a root admin permission denied to migrate the volume 

}	final VolumeVO volume = _volumeDao.findById(volumeId);	if (volume == null) {	final InvalidParameterValueException ex = new InvalidParameterValueException("Unable to find volume with" + " specified id.");	ex.addProxyObject(volumeId.toString(), "volumeId");	throw ex;	}	final List<StoragePool> allPools = new ArrayList<StoragePool>();	final List<StoragePool> suitablePools = new ArrayList<StoragePool>();	if (!Volume.State.Ready.equals(volume.getState())) {	
volume must be in ready state for migration 

final InvalidParameterValueException ex = new InvalidParameterValueException("Unable to find volume with" + " specified id.");	ex.addProxyObject(volumeId.toString(), "volumeId");	throw ex;	}	final List<StoragePool> allPools = new ArrayList<StoragePool>();	final List<StoragePool> suitablePools = new ArrayList<StoragePool>();	if (!Volume.State.Ready.equals(volume.getState())) {	return new Pair<List<? extends StoragePool>, List<? extends StoragePool>>(allPools, suitablePools);	}	if (!_volumeMgr.volumeOnSharedStoragePool(volume)) {	
volume is on local storage it cannot be migrated to another pool 

}	if (!_volumeMgr.volumeOnSharedStoragePool(volume)) {	return new Pair<List<? extends StoragePool>, List<? extends StoragePool>>(allPools, suitablePools);	}	final Long instanceId = volume.getInstanceId();	VMInstanceVO vm = null;	if (instanceId != null) {	vm = _vmInstanceDao.findById(instanceId);	}	if (vm == null) {	
volume isn t attached to any vm looking for storage pools in the zone to which this volumes can be migrated 

if (!_volumeMgr.volumeOnSharedStoragePool(volume)) {	return new Pair<List<? extends StoragePool>, List<? extends StoragePool>>(allPools, suitablePools);	}	final Long instanceId = volume.getInstanceId();	VMInstanceVO vm = null;	if (instanceId != null) {	vm = _vmInstanceDao.findById(instanceId);	}	if (vm == null) {	} else if (vm.getState() != State.Running) {	
volume isn t attached to any running vm looking for storage pools in the cluster to which this volumes can be migrated 

return new Pair<List<? extends StoragePool>, List<? extends StoragePool>>(allPools, suitablePools);	}	final Long instanceId = volume.getInstanceId();	VMInstanceVO vm = null;	if (instanceId != null) {	vm = _vmInstanceDao.findById(instanceId);	}	if (vm == null) {	} else if (vm.getState() != State.Running) {	} else {	
volume is attached to any running vm looking for storage pools in the cluster to which this volumes can be migrated 

} else if (vm.getState() != State.Running) {	} else {	boolean storageMotionSupported = false;	final Long hostId = vm.getHostId();	if (hostId != null) {	final HostVO host = _hostDao.findById(hostId);	HypervisorCapabilitiesVO capabilities = null;	if (host != null) {	capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(host.getHypervisorType(), host.getHypervisorVersion());	} else {	
details of the host on which the vm to which volume is attached couldn t be retrieved 

if (hostId != null) {	final HostVO host = _hostDao.findById(hostId);	HypervisorCapabilitiesVO capabilities = null;	if (host != null) {	capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(host.getHypervisorType(), host.getHypervisorVersion());	} else {	}	if (capabilities != null) {	storageMotionSupported = capabilities.isStorageMotionSupported();	} else {	
capabilities for host couldn t be retrieved 

if (host != null) {	capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(host.getHypervisorType(), host.getHypervisorVersion());	} else {	}	if (capabilities != null) {	storageMotionSupported = capabilities.isStorageMotionSupported();	} else {	}	}	if (!storageMotionSupported) {	
volume is attached to a running vm and the hypervisor doesn t support storage motion 

if (scope != null && !scope.isEmpty()) {	final List<ConfigurationVO> configVOList = new ArrayList<ConfigurationVO>();	for (final ConfigurationVO param : result.first()) {	final ConfigurationVO configVo = _configDao.findByName(param.getName());	if (configVo != null) {	final ConfigKey<?> key = _configDepot.get(param.getName());	if (key != null) {	configVo.setValue(key.valueIn(id).toString());	configVOList.add(configVo);	} else {	
configdepot could not find parameter for scope 

for (final ConfigurationVO param : result.first()) {	final ConfigurationVO configVo = _configDao.findByName(param.getName());	if (configVo != null) {	final ConfigKey<?> key = _configDepot.get(param.getName());	if (key != null) {	configVo.setValue(key.valueIn(id).toString());	configVOList.add(configVo);	} else {	}	} else {	
configuration item not found in 

public Pair<String, Integer> getVncPort(final VirtualMachine vm) {	if (vm.getHostId() == null) {	
vm does not have host return for its vnc port 

public Pair<String, Integer> getVncPort(final VirtualMachine vm) {	if (vm.getHostId() == null) {	return new Pair<String, Integer>(null, -1);	}	if (s_logger.isTraceEnabled()) {	
trying to retrieve vnc port from agent about vm 

protected void runInContext() {	try {	final GlobalLock lock = GlobalLock.getInternLock("EventPurge");	if (lock == null) {	
couldn t get the global lock 

protected void runInContext() {	try {	final GlobalLock lock = GlobalLock.getInternLock("EventPurge");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	
couldn t lock the db 

if (lock == null) {	return;	}	if (!lock.lock(30)) {	return;	}	try {	final Calendar purgeCal = Calendar.getInstance();	purgeCal.add(Calendar.DAY_OF_YEAR, -_purgeDelay);	final Date purgeTime = purgeCal.getTime();	
deleting events older than 

return;	}	if (!lock.lock(30)) {	return;	}	try {	final Calendar purgeCal = Calendar.getInstance();	purgeCal.add(Calendar.DAY_OF_YEAR, -_purgeDelay);	final Date purgeTime = purgeCal.getTime();	final List<EventVO> oldEvents = _eventDao.listOlderEvents(purgeTime);	
found events to be purged 

}	try {	final Calendar purgeCal = Calendar.getInstance();	purgeCal.add(Calendar.DAY_OF_YEAR, -_purgeDelay);	final Date purgeTime = purgeCal.getTime();	final List<EventVO> oldEvents = _eventDao.listOlderEvents(purgeTime);	for (final EventVO event : oldEvents) {	_eventDao.expunge(event.getId());	}	} catch (final Exception e) {	
exception 

final Date purgeTime = purgeCal.getTime();	final List<EventVO> oldEvents = _eventDao.listOlderEvents(purgeTime);	for (final EventVO event : oldEvents) {	_eventDao.expunge(event.getId());	}	} catch (final Exception e) {	} finally {	lock.unlock();	}	} catch (final Exception e) {	
exception 

protected void runInContext() {	try {	final GlobalLock lock = GlobalLock.getInternLock("AlertPurge");	if (lock == null) {	
couldn t get the global lock 

protected void runInContext() {	try {	final GlobalLock lock = GlobalLock.getInternLock("AlertPurge");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	
couldn t lock the db 

if (lock == null) {	return;	}	if (!lock.lock(30)) {	return;	}	try {	final Calendar purgeCal = Calendar.getInstance();	purgeCal.add(Calendar.DAY_OF_YEAR, -_alertPurgeDelay);	final Date purgeTime = purgeCal.getTime();	
deleting alerts older than 

return;	}	if (!lock.lock(30)) {	return;	}	try {	final Calendar purgeCal = Calendar.getInstance();	purgeCal.add(Calendar.DAY_OF_YEAR, -_alertPurgeDelay);	final Date purgeTime = purgeCal.getTime();	final List<AlertVO> oldAlerts = _alertDao.listOlderAlerts(purgeTime);	
found events to be purged 

}	try {	final Calendar purgeCal = Calendar.getInstance();	purgeCal.add(Calendar.DAY_OF_YEAR, -_alertPurgeDelay);	final Date purgeTime = purgeCal.getTime();	final List<AlertVO> oldAlerts = _alertDao.listOlderAlerts(purgeTime);	for (final AlertVO alert : oldAlerts) {	_alertDao.expunge(alert.getId());	}	} catch (final Exception e) {	
exception 

final Date purgeTime = purgeCal.getTime();	final List<AlertVO> oldAlerts = _alertDao.listOlderAlerts(purgeTime);	for (final AlertVO alert : oldAlerts) {	_alertDao.expunge(alert.getId());	}	} catch (final Exception e) {	} finally {	lock.unlock();	}	} catch (final Exception e) {	
exception 

private String signRequest(final String request, final String key) {	try {	
request 

private String signRequest(final String request, final String key) {	try {	
key 

try {	if (key != null && request != null) {	final Mac mac = Mac.getInstance("HmacSHA1");	final SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "HmacSHA1");	mac.init(keySpec);	mac.update(request.getBytes());	final byte[] encryptedBytes = mac.doFinal();	return new String(Base64.encodeBase64(encryptedBytes));	}	} catch (final Exception ex) {	
unable to sign request 

if (cloudIdentifier == null) {	cloudIdentifier = "";	}	String signature = "";	try {	user = _accountMgr.getActiveUser(userId);	final String secretKey = user.getSecretKey();	final String input = cloudIdentifier;	signature = signRequest(input, secretKey);	} catch (final Exception e) {	
exception whilst creating a signature 

final Class<EventTypes> c = EventTypes.class;	final Field[] fields = c.getFields();	final String[] eventTypes = new String[fields.length];	try {	int i = 0;	for (final Field field : fields) {	eventTypes[i++] = field.get(eventObj).toString();	}	return eventTypes;	} catch (final IllegalArgumentException e) {	
error while listing event types 

final Field[] fields = c.getFields();	final String[] eventTypes = new String[fields.length];	try {	int i = 0;	for (final Field field : fields) {	eventTypes[i++] = field.get(eventObj).toString();	}	return eventTypes;	} catch (final IllegalArgumentException e) {	} catch (final IllegalAccessException e) {	
error while listing event types 

if (adminUser.getState() == Account.State.disabled) {	for (final UserAuthenticator authenticator : _userPasswordEncoders) {	encodedPassword = authenticator.encode(password);	if (encodedPassword != null) {	break;	}	}	adminUser.setPassword(encodedPassword);	adminUser.setState(Account.State.enabled);	_userDao.persist(adminUser);	
admin user enabled 

public void cleanupVMReservations() {	if (s_logger.isDebugEnabled()) {	
processing cleanupvmreservations 

========================= cloudstack sample_2373 =========================

apiKey = iter.next();	}	if (arg.equals("-action")) {	url = "Action=" + iter.next();	}	}	Properties prop = new Properties();	try {	prop.load(new FileInputStream("conf/tool.properties"));	} catch (IOException ex) {	
error reading from conf tool properties 

}	Properties prop = new Properties();	try {	prop.load(new FileInputStream("conf/tool.properties"));	} catch (IOException ex) {	System.exit(2);	}	host = prop.getProperty("host");	port = prop.getProperty("port");	if (url.equals("Action=SetCertificate") && certFileName == null) {	
please set path to certificate including file name with c option 

prop.load(new FileInputStream("conf/tool.properties"));	} catch (IOException ex) {	System.exit(2);	}	host = prop.getProperty("host");	port = prop.getProperty("port");	if (url.equals("Action=SetCertificate") && certFileName == null) {	System.exit(1);	}	if (secretKey == null) {	
please set secretkey with s option 

}	host = prop.getProperty("host");	port = prop.getProperty("port");	if (url.equals("Action=SetCertificate") && certFileName == null) {	System.exit(1);	}	if (secretKey == null) {	System.exit(1);	}	if (apiKey == null) {	
please set apikey with a option 

if (url.equals("Action=SetCertificate") && certFileName == null) {	System.exit(1);	}	if (secretKey == null) {	System.exit(1);	}	if (apiKey == null) {	System.exit(1);	}	if (host == null) {	
please set host in tool properties file 

if (secretKey == null) {	System.exit(1);	}	if (apiKey == null) {	System.exit(1);	}	if (host == null) {	System.exit(1);	}	if (port == null) {	
please set port in tool properties file 

}	Set c = param.entrySet();	Iterator it = c.iterator();	while (it.hasNext()) {	Map.Entry me = (Map.Entry)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	try {	temp = temp + key + "=" + URLEncoder.encode(value, "UTF-8") + "&";	} catch (Exception ex) {	
unable to set parameter for the command command 

public static void sendRequest(String url) {	try {	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	String is = method.getResponseBodyAsString();	
response code 

========================= cloudstack sample_438 =========================

public Pair<JobInfo.Status, String> handleVmWorkJob(VmWork work) throws Exception {	Method method = getHandlerMethod(work.getClass());	if (method != null) {	try {	
execute vm work job 

public Pair<JobInfo.Status, String> handleVmWorkJob(VmWork work) throws Exception {	Method method = getHandlerMethod(work.getClass());	if (method != null) {	try {	Object obj = method.invoke(_target, work);	
done executing vm work job 

public Pair<JobInfo.Status, String> handleVmWorkJob(VmWork work) throws Exception {	Method method = getHandlerMethod(work.getClass());	if (method != null) {	try {	Object obj = method.invoke(_target, work);	assert (obj instanceof Pair);	return (Pair<JobInfo.Status, String>)obj;	} catch (InvocationTargetException e) {	
invocation exception caused by 

public Pair<JobInfo.Status, String> handleVmWorkJob(VmWork work) throws Exception {	Method method = getHandlerMethod(work.getClass());	if (method != null) {	try {	Object obj = method.invoke(_target, work);	assert (obj instanceof Pair);	return (Pair<JobInfo.Status, String>)obj;	} catch (InvocationTargetException e) {	if (e.getCause() != null && e.getCause() instanceof Exception) {	
rethrow exception 

Object obj = method.invoke(_target, work);	assert (obj instanceof Pair);	return (Pair<JobInfo.Status, String>)obj;	} catch (InvocationTargetException e) {	if (e.getCause() != null && e.getCause() instanceof Exception) {	throw (Exception)e.getCause();	}	throw e;	}	} else {	
unable to find handler for vm work job 

========================= cloudstack sample_4927 =========================

pbd.plug(conn);	sr.scan(conn);	}	return sr;	} catch (final Exception ex) {	try {	if (pbd != null) {	pbd.destroy(conn);	}	} catch (final Exception e1) {	
failed to destroy pbd 

if (pbd != null) {	pbd.destroy(conn);	}	} catch (final Exception e1) {	}	try {	if (sr != null) {	sr.forget(conn);	}	} catch (final Exception e2) {	
failed to forget sr 

}	} catch (final Exception e) {	final String msg = "Catch Exception " + e.getClass().getName() + " for template due to " + e.toString();	s_logger.warn(msg, e);	return new CopyCmdAnswer(msg);	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e) {	
unable to destroy task due to 

task = snapshotvdi.copyAsync(conn, ssSR, previousSnapshotVdi, null);	hypervisorResource.waitForTask(conn, task, 1000, wait * 1000);	hypervisorResource.checkForSuccess(conn, task);	dvdi = Types.toVDI(task, conn);	ssSR.scan(conn);	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e) {	
unable to destroy task due to 

} catch (final Exception e) {	final String msg = "Exception in backupsnapshot stage due to " + e.toString();	s_logger.debug(msg);	throw new CloudRuntimeException(msg, e);	} finally {	try {	if (filesrcreated && ssSR != null) {	hypervisorResource.removeSR(conn, ssSR);	}	} catch (final Exception e) {	
exception in backupsnapshot cleanup stage due to 

protected String getVhdParent(final Connection conn, final String primaryStorageSRUuid, final String snapshotUuid, final Boolean isISCSI) {	final String parentUuid = hypervisorResource.callHostPlugin(conn, "cloud-plugin-storage", "getVhdParent", "primaryStorageSRUuid", primaryStorageSRUuid, "snapshotUuid", snapshotUuid, "isISCSI", isISCSI.toString());	if (parentUuid == null || parentUuid.isEmpty() || parentUuid.equalsIgnoreCase("None")) {	
unable to get parent of vhd in sr 

if (destStore instanceof SwiftTO) {	try {	final String container = "S-" + snapshotTO.getVolume().getVolumeId().toString();	final String destSnapshotName = swiftBackupSnapshot(conn, (SwiftTO) destStore, snapshotSr.getUuid(conn), snapshotBackupUuid, container, false, wait);	final String swiftPath = container + File.separator + destSnapshotName;	finalPath = swiftPath;	} finally {	try {	deleteSnapshotBackup(conn, localMountPoint, folder, secondaryStorageMountPath, snapshotBackupUuid);	} catch (final Exception e) {	
failed to delete snapshot on cache storages 

} else if (destStore instanceof S3TO) {	try {	finalPath = backupSnapshotToS3(conn, (S3TO) destStore, snapshotSr.getUuid(conn), folder, snapshotBackupUuid, isISCSI, wait);	if (finalPath == null) {	throw new CloudRuntimeException("S3 upload of snapshots " + snapshotBackupUuid + " failed");	}	} finally {	try {	deleteSnapshotBackup(conn, localMountPoint, folder, secondaryStorageMountPath, snapshotBackupUuid);	} catch (final Exception e) {	
failed to delete snapshot on cache storages 

}	}	} else {	finalPath = folder + File.separator + snapshotBackupUuid;	}	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e) {	
unable to destroy task due to 

final String volumeUuid = snapshotTO.getVolume().getPath();	destroySnapshotOnPrimaryStorageExceptThis(conn, volumeUuid, snapshotUuid);	final SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(finalPath);	newSnapshot.setPhysicalSize(physicalSize);	if (fullbackup) {	newSnapshot.setParentSnapshotPath(null);	} else {	newSnapshot.setParentSnapshotPath(prevBackupUuid);	}	
new snapshot details 

final String volumeUuid = snapshotTO.getVolume().getPath();	destroySnapshotOnPrimaryStorageExceptThis(conn, volumeUuid, snapshotUuid);	final SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(finalPath);	newSnapshot.setPhysicalSize(physicalSize);	if (fullbackup) {	newSnapshot.setParentSnapshotPath(null);	} else {	newSnapshot.setParentSnapshotPath(prevBackupUuid);	}	
new snapshot physical utilization 

if (secondaryStorageMountPath != null) {	hypervisorResource.deleteSecondaryStorageFolder(conn, secondaryStorageMountPath, installPath);	}	details = "Creating template from volume " + volumeUUID + " failed due to " + e.toString();	s_logger.error(details, e);	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e) {	
unable to destroy task due to 

details += " due to " + e.getMessage();	s_logger.warn(details, e);	} finally {	if (srcSr != null) {	hypervisorResource.skipOrRemoveSR(conn, srcSr);	}	if (!result && destVdi != null) {	try {	destVdi.destroy(conn);	} catch (final Exception e) {	
destroy dest vdi failed 

task = srcVdi.copyAsync(conn, secondaryStorage, null, null);	hypervisorResource.waitForTask(conn, task, 1000, wait * 1000);	hypervisorResource.checkForSuccess(conn, task);	final VDI destVdi = Types.toVDI(task, conn);	final String destVolumeUUID = destVdi.getUuid(conn);	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(destVolume.getPath() + File.separator + destVolumeUUID + ".vhd");	newVol.setSize(srcVolume.getSize());	return new CopyCmdAnswer(newVol);	} catch (final Exception e) {	
failed to copy volume to secondary 

newVol.setPath(destVolume.getPath() + File.separator + destVolumeUUID + ".vhd");	newVol.setSize(srcVolume.getSize());	return new CopyCmdAnswer(newVol);	} catch (final Exception e) {	return new CopyCmdAnswer("Failed to copy volume to secondary: " + e.toString());	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e) {	
unable to destroy task due to 

return new CopyCmdAnswer(newVol);	} catch (final Exception e) {	final String msg = "Catch Exception " + e.getClass().getName() + " due to " + e.toString();	s_logger.warn(msg, e);	return new CopyCmdAnswer(e.toString());	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e) {	
unable to destroy task due to 

try {	task.destroy(conn);	} catch (final Exception e) {	}	}	if (srcSr != null) {	hypervisorResource.removeSR(conn, srcSr);	}	}	}	
unsupported protocol 

final SnapshotObjectTO srcObj = (SnapshotObjectTO) srcData;	final TemplateObjectTO destObj = (TemplateObjectTO) destData;	final NfsTO srcStore = (NfsTO) srcObj.getDataStore();	final NfsTO destStore = (NfsTO) destObj.getDataStore();	URI srcUri = null;	URI destUri = null;	try {	srcUri = new URI(srcStore.getUrl());	destUri = new URI(destStore.getUrl());	} catch (final Exception e) {	
incorrect url 

}	final TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(destDir + "/" + templateFilename);	newTemplate.setFormat(Storage.ImageFormat.VHD);	newTemplate.setSize(destVdi.getVirtualSize(conn));	newTemplate.setPhysicalSize(destVdi.getPhysicalUtilisation(conn));	newTemplate.setName(destVdiUuid);	result = true;	return new CopyCmdAnswer(newTemplate);	} catch (final Exception e) {	
failed create template from snapshot 

result = true;	return new CopyCmdAnswer(newTemplate);	} catch (final Exception e) {	return new CopyCmdAnswer("Failed create template from snapshot " + e.toString());	} finally {	if (!result) {	if (destVdi != null) {	try {	destVdi.destroy(conn);	} catch (final Exception e) {	
clean up left over on dest storage failed 

final TemplateObjectTO templateObjTO = (TemplateObjectTO) cmd.getDestTO();	if (!(snapshotObjTO.getDataStore() instanceof PrimaryDataStoreTO) || !(templateObjTO.getDataStore() instanceof NfsTO)) {	return null;	}	NfsTO destStore = null;	URI destUri = null;	try {	destStore = (NfsTO) templateObjTO.getDataStore();	destUri = new URI(destStore.getUrl());	} catch (final Exception ex) {	
invalid uri 

final TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(destDir + "/" + templateFilename);	newTemplate.setFormat(Storage.ImageFormat.VHD);	newTemplate.setHypervisorType(HypervisorType.XenServer);	newTemplate.setSize(virtualSize);	newTemplate.setPhysicalSize(physicalSize);	newTemplate.setName(templateUuid);	result = true;	return new CopyCmdAnswer(newTemplate);	} catch (final BadServerResponse e) {	
failed to create a template from a snapshot due to incomprehensible server response 

newTemplate.setFormat(Storage.ImageFormat.VHD);	newTemplate.setHypervisorType(HypervisorType.XenServer);	newTemplate.setSize(virtualSize);	newTemplate.setPhysicalSize(physicalSize);	newTemplate.setName(templateUuid);	result = true;	return new CopyCmdAnswer(newTemplate);	} catch (final BadServerResponse e) {	return new CopyCmdAnswer("Failed to create a template from a snapshot: " + e.toString());	} catch (final XenAPIException e) {	
failed to create a template from a snapshot due to xenapi error 

newTemplate.setSize(virtualSize);	newTemplate.setPhysicalSize(physicalSize);	newTemplate.setName(templateUuid);	result = true;	return new CopyCmdAnswer(newTemplate);	} catch (final BadServerResponse e) {	return new CopyCmdAnswer("Failed to create a template from a snapshot: " + e.toString());	} catch (final XenAPIException e) {	return new CopyCmdAnswer("Failed to create a template from a snapshot: " + e.toString());	} catch (final XmlRpcException e) {	
failed to create a template from a snapshot due to rpc error 

} catch (final XenAPIException e) {	return new CopyCmdAnswer("Failed to create a template from a snapshot: " + e.toString());	} catch (final XmlRpcException e) {	return new CopyCmdAnswer("Failed to create a template from a snapshot: " + e.toString());	} finally {	if (!result) {	if (destVdi != null) {	try {	destVdi.destroy(conn);	} catch (final Exception e) {	
cleaned up leftover vdi on destination storage due to failure 

========================= cloudstack sample_1226 =========================

public final Answer execute(final CopyCommand cmd) {	
execute 

public Answer execute(DeleteCommand cmd) {	DataTO data = cmd.getData();	String msg;	
deleting object 

public CreateAnswer execute(CreateCommand cmd) {	
execute 

public CreateAnswer execute(CreateCommand cmd) {	StorageFilerTO primaryStorage = cmd.getPool();	DiskProfile disk = cmd.getDiskCharacteristics();	String fileName = UUID.randomUUID().toString() + ".raw";	String dst = primaryStorage.getPath() + "/" + primaryStorage.getUuid() + "/" + fileName;	try {	StoragePlugin store = new StoragePlugin(c);	if (cmd.getTemplateUrl() != null) {	
createcommand 

StorageFilerTO primaryStorage = cmd.getPool();	DiskProfile disk = cmd.getDiskCharacteristics();	String fileName = UUID.randomUUID().toString() + ".raw";	String dst = primaryStorage.getPath() + "/" + primaryStorage.getUuid() + "/" + fileName;	try {	StoragePlugin store = new StoragePlugin(c);	if (cmd.getTemplateUrl() != null) {	Linux host = new Linux(c);	host.copyFile(cmd.getTemplateUrl(), dst);	} else {	
createcommand 

if (cmd.getTemplateUrl() != null) {	Linux host = new Linux(c);	host.copyFile(cmd.getTemplateUrl(), dst);	} else {	store.storagePluginCreate(primaryStorage.getUuid(), primaryStorage.getHost(), dst, disk.getSize(), false);	}	FileProperties fp = store.storagePluginGetFileInfo( primaryStorage.getUuid(), primaryStorage.getHost(), dst);	VolumeTO volume = new VolumeTO(cmd.getVolumeId(), disk.getType(), primaryStorage.getType(), primaryStorage.getUuid(), primaryStorage.getPath(), fileName, fp.getName(), fp.getSize(), null);	return new CreateAnswer(cmd, volume);	} catch (Exception e) {	
createcommand failed 

public CopyCmdAnswer copyTemplateToPrimaryStorage(CopyCommand cmd) {	
execute copytemplatetoprimarystorage 

String primaryPoolUuid = destData.getDataStore().getUuid();	String destPath = config.getAgentOvmRepoPath() + "/" + ovmObject.deDash(primaryPoolUuid) + "/" + config.getTemplateDir();	String sourcePath = config.getAgentSecStoragePath() + "/" + secPoolUuid;	Linux host = new Linux(c);	String destUuid = destTemplate.getUuid();	String srcFile = sourcePath + "/" + srcData.getPath();	if (srcData.getPath().endsWith("/")) {	srcFile = sourcePath + "/" + srcData.getPath() + "/" + destUuid + ".raw";	}	String destFile = destPath + "/" + destUuid + ".raw";	
copyfrom to 

public Answer copyVolumeFromPrimaryToSecondary(CopyCommand cmd) {	
execute copyvolumefromprimarytosecondary 

public CopyCmdAnswer cloneVolumeFromBaseTemplate(CopyCommand cmd) {	
execute clonevolumefrombasetemplate 

public CopyCmdAnswer cloneVolumeFromBaseTemplate(CopyCommand cmd) {	try {	DataTO srcData = cmd.getSrcTO();	TemplateObjectTO src = (TemplateObjectTO) srcData;	String srcFile = getVirtualDiskPath(src.getUuid(), src.getDataStore().getUuid());	srcFile = srcFile.replace(config.getVirtualDiskDir(), config.getTemplateDir());	DataTO destData = cmd.getDestTO();	VolumeObjectTO dest = (VolumeObjectTO) destData;	String destFile = getVirtualDiskPath(dest.getUuid(), dest.getDataStore().getUuid());	Linux host = new Linux(c);	
copyfrom to 

public Answer createTemplateFromVolume(CopyCommand cmd) {	
execute createtemplatefromvolume 

public Answer copyVolumeFromImageCacheToPrimary(CopyCommand cmd) {	
execute copyvolumefromimagecachetoprimary 

public Answer createTemplateFromSnapshot(CopyCommand cmd) {	
execute createtemplatefromsnapshot 

public CopyCmdAnswer backupSnapshot(CopyCommand cmd) {	
execute backupsnapshot 

SnapshotObjectTO dest = (SnapshotObjectTO) destData;	String srcFile = getVirtualDiskPath(src.getPath(), src.getDataStore().getUuid());	String storeUrl = dest.getDataStore().getUrl();	String secPoolUuid = pool.setupSecondaryStorage(storeUrl);	String destDir = config.getAgentSecStoragePath() + "/" + secPoolUuid + "/" + dest.getPath();	String destFile =  destDir + "/" + src.getPath();	destFile = destFile.concat(".raw");	Linux host = new Linux(c);	CloudstackPlugin csp = new CloudstackPlugin(c);	csp.ovsMkdirs(destDir);	
copyfrom to 

public Answer execute(CreateObjectCommand cmd) {	
execute 

public Answer execute(CreateObjectCommand cmd) {	DataTO data = cmd.getData();	if (data.getObjectType() == DataObjectType.VOLUME) {	return createVolume(cmd);	} else if (data.getObjectType() == DataObjectType.SNAPSHOT) {	return createSnapshot(cmd);	} else if (data.getObjectType() == DataObjectType.TEMPLATE) {	
template object creation not supported 

public AttachAnswer attachIso(AttachCommand cmd) {	
execute attachiso 

public AttachAnswer dettachIso(DettachCommand cmd) {	
execute dettachiso 

private AttachAnswer attachDetach(Command cmd, String vmName, DiskTO disk, boolean isAttach) {	Xen xen = new Xen(c);	String doThis = (isAttach) ? "Attach" : "Dettach";	
volume type 

public AttachAnswer attachVolume(AttachCommand cmd) {	
execute attachvolume 

public AttachAnswer dettachVolume(DettachCommand cmd) {	
execute dettachvolume 

public Answer createVolume(CreateObjectCommand cmd) {	
execute createvolume 

FileProperties fp = sp.storagePluginCreate(poolUuid, host, file, size, false);	if (!fp.getName().equals(file)) {	return new CreateObjectAnswer("Filename mismatch: " + fp.getName() + " != " + file);	}	VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setName(volume.getName());	newVol.setSize(fp.getSize());	newVol.setPath(volume.getUuid());	return new CreateObjectAnswer(newVol);	} catch (Ovm3ResourceException | URISyntaxException e) {	
volume creation failed 

public Answer createSnapshot(CreateObjectCommand cmd) {	
execute createsnapshot 

return new CreateObjectAnswer( "Snapshot object creation not supported for running VMs." + snap.getVmName());	}	Linux host = new Linux(c);	String uuid = host.newUuid();	String src = vol.getPath() + "/" + vol.getUuid() + ".raw";	String dest = vol.getPath() + "/" + uuid + ".raw";	if (vol.getPath().contains(vol.getUuid())) {	src = getVirtualDiskPath(vol.getUuid(),data.getDataStore().getUuid());	dest = src.replace(vol.getUuid(), uuid);	}	
snapshot to 

public Answer deleteVolume(DeleteCommand cmd) {	
execute deletevolume 

public Answer deleteVolume(DeleteCommand cmd) {	DataTO data = cmd.getData();	VolumeObjectTO volume = (VolumeObjectTO) data;	try {	String poolUuid = data.getDataStore().getUuid();	String uuid = volume.getUuid();	String path = getVirtualDiskPath(uuid, poolUuid);	StoragePlugin sp = new StoragePlugin(c);	sp.storagePluginDestroy(poolUuid, path);	
volume deletion success 

public Answer deleteVolume(DeleteCommand cmd) {	DataTO data = cmd.getData();	VolumeObjectTO volume = (VolumeObjectTO) data;	try {	String poolUuid = data.getDataStore().getUuid();	String uuid = volume.getUuid();	String path = getVirtualDiskPath(uuid, poolUuid);	StoragePlugin sp = new StoragePlugin(c);	sp.storagePluginDestroy(poolUuid, path);	} catch (Ovm3ResourceException e) {	
volume deletion failed 

public CopyVolumeAnswer execute(CopyVolumeCommand cmd) {	
execute 

public CopyVolumeAnswer execute(CopyVolumeCommand cmd) {	String volumePath = cmd.getVolumePath();	String secondaryStorageURL = cmd.getSecondaryStorageURL();	int wait = cmd.getWait();	if (wait == 0) {	wait = 7200;	}	try {	Linux host = new Linux(c);	if (cmd.toSecondaryStorage()) {	
copy to secondary storage to 

String secondaryStorageURL = cmd.getSecondaryStorageURL();	int wait = cmd.getWait();	if (wait == 0) {	wait = 7200;	}	try {	Linux host = new Linux(c);	if (cmd.toSecondaryStorage()) {	host.copyFile(volumePath, secondaryStorageURL);	} else {	
copy from secondary storage to 

}	try {	Linux host = new Linux(c);	if (cmd.toSecondaryStorage()) {	host.copyFile(volumePath, secondaryStorageURL);	} else {	host.copyFile(secondaryStorageURL, volumePath);	}	return new CopyVolumeAnswer(cmd, true, null, null, null);	} catch (Ovm3ResourceException e) {	
copy volume failed 

public Answer execute(DestroyCommand cmd) {	
execute 

public Answer execute(DestroyCommand cmd) {	VolumeTO vol = cmd.getVolume();	String vmName = cmd.getVmName();	try {	StoragePlugin store = new StoragePlugin(c);	store.storagePluginDestroy(vol.getPoolUuid(), vol.getPath());	return new Answer(cmd, true, "Success");	} catch (Ovm3ResourceException e) {	
destroy volume failed for 

public CreatePrivateTemplateAnswer execute( final CreatePrivateTemplateFromVolumeCommand cmd) {	
execute 

int wait = cmd.getWait();	if (wait == 0) {	wait = 7200;	}	try {	String installPath = config.getAgentOvmRepoPath() + "/" + config.getTemplateDir() + "/" + accountId + "/" + templateId;	Linux host = new Linux(c);	host.copyFile(volumePath, installPath);	return new CreatePrivateTemplateAnswer(cmd, true, installPath);	} catch (Exception e) {	
create template failed 

public Answer createVolumeFromSnapshot(CopyCommand cmd) {	
execute createvolumefromsnapshot 

String primaryPoolUuid = destData.getDataStore().getUuid();	String destFile = getVirtualDiskPath(destVol.getUuid(), ovmObject.deDash(primaryPoolUuid));	Linux host = new Linux(c);	host.copyFile(srcFile, destFile);	VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setUuid(destVol.getUuid());	newVol.setPath(destVol.getUuid());	newVol.setFormat(ImageFormat.RAW);	return new CopyCmdAnswer(newVol);	} catch (Ovm3ResourceException e) {	
failed to createvolumefromsnapshot 

public Answer deleteSnapshot(DeleteCommand cmd) {	
execute deletesnapshot 

public Answer deleteSnapshot(DeleteCommand cmd) {	DataTO data = cmd.getData();	SnapshotObjectTO snap = (SnapshotObjectTO) data;	String storeUrl = data.getDataStore().getUrl();	String snapUuid = snap.getPath();	try {	String secPoolUuid = pool.setupSecondaryStorage(storeUrl);	String filePath = config.getAgentSecStoragePath() + "/" + secPoolUuid + "/" + snapUuid + ".raw";	StoragePlugin sp = new StoragePlugin(c);	sp.storagePluginDestroy(secPoolUuid, filePath);	
snapshot deletion success 

SnapshotObjectTO snap = (SnapshotObjectTO) data;	String storeUrl = data.getDataStore().getUrl();	String snapUuid = snap.getPath();	try {	String secPoolUuid = pool.setupSecondaryStorage(storeUrl);	String filePath = config.getAgentSecStoragePath() + "/" + secPoolUuid + "/" + snapUuid + ".raw";	StoragePlugin sp = new StoragePlugin(c);	sp.storagePluginDestroy(secPoolUuid, filePath);	return new Answer(cmd, true, "Deleted Snapshot " + filePath);	} catch (Ovm3ResourceException e) {	
snapshot deletion failed 

public Answer introduceObject(IntroduceObjectCmd cmd) {	
execute introduceobject 

public Answer forgetObject(ForgetObjectCmd cmd) {	
execute forgetobject 

public SnapshotAndCopyAnswer snapshotAndCopy(SnapshotAndCopyCommand cmd) {	
snapshotandcopyanswer snapshotandcopy snapshotandcopycommand not currently used for 

public ResignatureAnswer resignature(final ResignatureCommand cmd) {	
resignatureanswer resignature resignaturecommand not currently used for 

public Answer execute(AttachCommand cmd) {	
execute 

public Answer execute(DettachCommand cmd) {	
execute 

========================= cloudstack sample_838 =========================

public void execute() throws ResourceAllocationException, ResourceUnavailableException {	ApplicationLoadBalancerRule rule = null;	try {	CallContext.current().setEventDetails("Load Balancer Id: " + getEntityId());	rule = _entityMgr.findById(ApplicationLoadBalancerRule.class, getEntityId());	ApplicationLoadBalancerResponse lbResponse = _responseGenerator.createLoadBalancerContainerReponse(rule, _lbService.getLbInstances(getEntityId()));	setResponseObject(lbResponse);	lbResponse.setResponseName(getCommandName());	} catch (Exception ex) {	
failed to create load balancer due to exception 

public void create() {	try {	ApplicationLoadBalancerRule result = _appLbService.createApplicationLoadBalancer(getName(), getDescription(), getScheme(), getSourceIpNetworkId(), getSourceIp(), getSourcePort(), getInstancePort(), getAlgorithm(), getNetworkId(), getEntityOwnerId(), getDisplay());	this.setEntityId(result.getId());	this.setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException e) {	
exception 

public void create() {	try {	ApplicationLoadBalancerRule result = _appLbService.createApplicationLoadBalancer(getName(), getDescription(), getScheme(), getSourceIpNetworkId(), getSourceIp(), getSourcePort(), getInstancePort(), getAlgorithm(), getNetworkId(), getEntityOwnerId(), getDisplay());	this.setEntityId(result.getId());	this.setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException e) {	throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, e.getMessage());	} catch (InsufficientAddressCapacityException e) {	
exception 

public void create() {	try {	ApplicationLoadBalancerRule result = _appLbService.createApplicationLoadBalancer(getName(), getDescription(), getScheme(), getSourceIpNetworkId(), getSourceIp(), getSourcePort(), getInstancePort(), getAlgorithm(), getNetworkId(), getEntityOwnerId(), getDisplay());	this.setEntityId(result.getId());	this.setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException e) {	throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, e.getMessage());	} catch (InsufficientAddressCapacityException e) {	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, e.getMessage());	} catch (InsufficientVirtualNetworkCapacityException e) {	
exception 

========================= cloudstack sample_3431 =========================

throw new CloudRuntimeException("Exception while retrieving guest type for network " + networkId, e);	}	}	}	}	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while Moving private zone information to dedicated resources", e);	}	
done updating vm nic secondary ip account and domain ids 

private void moveCidrsToTheirOwnTable(Connection conn) {	
moving network acl item cidrs to a row per cidr 

private void moveCidrsToTheirOwnTable(Connection conn) {	String networkAclItemSql = "SELECT id, cidr FROM `cloud`.`network_acl_item`";	String networkAclItemCidrSql = "INSERT INTO `cloud`.`network_acl_item_cidrs` (network_acl_item_id, cidr) VALUES (?,?)";	try (PreparedStatement pstmtItem = conn.prepareStatement(networkAclItemSql);	ResultSet rsItems = pstmtItem.executeQuery();	PreparedStatement pstmtCidr = conn.prepareStatement(networkAclItemCidrSql);	) {	while(rsItems.next()) {	long itemId = rsItems.getLong(1);	String cidrList = rsItems.getString(2);	
moving to a row per cidr 

String[] cidrArray = cidrList.split(",");	pstmtCidr.setLong(1, itemId);	for (String cidr : cidrArray) {	pstmtCidr.setString(2, cidr);	pstmtCidr.executeUpdate();	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while Moving network acl item cidrs to a row per cidr", e);	}	
done moving network acl item cidrs to a row per cidr 

private void updateVlanUris(Connection conn) {	
updating vlan uris 

updatestatement.setString(1, vlanUri);	updatestatement.setLong(2, id);	updatestatement.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to update vlan URI " + vlanUri + " for vlan record " + id, e);	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to update vlan URIs ", e);	}	
done updateing vlan uris 

========================= cloudstack sample_4198 =========================

private void addIndexForAlert(Connection conn) {	List<String> indexList = new ArrayList<String>();	
dropping index i alert last sent if it exists 

private void addIndexForAlert(Connection conn) {	List<String> indexList = new ArrayList<String>();	indexList.add("i_alert__last_sent");	DbUpgradeUtils.dropKeysIfExist(conn, "alert", indexList, false);	try (PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`alert` ADD INDEX `i_alert__last_sent`(`last_sent`)");) {	pstmt.executeUpdate();	
added index i alert last sent for table alert 

private void addIndexForHostDetails(Connection conn) {	List<String> indexList = new ArrayList<String>();	
dropping index fk host details host id if it exists 

private void addIndexForHostDetails(Connection conn) {	List<String> indexList = new ArrayList<String>();	indexList.add("fk_host_details__host_id");	DbUpgradeUtils.dropKeysIfExist(conn, "host_details", indexList, false);	try (PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`host_details` ADD INDEX `fk_host_details__host_id`(`host_id`)");) {	pstmt.executeUpdate();	
added index fk host details host id for table host details 

private void upgradeEgressFirewallRules(Connection conn) {	PreparedStatement pstmt = null;	ResultSet rs = null;	ResultSet rsId = null;	ResultSet rsNw = null;	try {	pstmt = conn.prepareStatement("update `cloud`.`firewall_rules`" + "  set traffic_type='Ingress' where purpose='Firewall' and ip_address_id is not null and traffic_type is null");	
updating firewall ingress rule traffic type 

ResultSet rsNw = null;	try {	pstmt = conn.prepareStatement("update `cloud`.`firewall_rules`" + "  set traffic_type='Ingress' where purpose='Firewall' and ip_address_id is not null and traffic_type is null");	pstmt.executeUpdate();	pstmt = conn.prepareStatement("select network_id FROM `cloud`.`ntwk_service_map` where service='Firewall' and provider='VirtualRouter' ");	rs = pstmt.executeQuery();	while (rs.next()) {	long netId = rs.getLong(1);	pstmt = conn.prepareStatement("select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR guest_type='" + "Virtual') and traffic_type='Guest' and vpc_id is NULL and (state='implemented' OR state='Shutdown') and id=? ");	pstmt.setLong(1, netId);	
getting account id domain id from networks table 

pstmt = conn.prepareStatement("select network_id FROM `cloud`.`ntwk_service_map` where service='Firewall' and provider='VirtualRouter' ");	rs = pstmt.executeQuery();	while (rs.next()) {	long netId = rs.getLong(1);	pstmt = conn.prepareStatement("select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR guest_type='" + "Virtual') and traffic_type='Guest' and vpc_id is NULL and (state='implemented' OR state='Shutdown') and id=? ");	pstmt.setLong(1, netId);	rsNw = pstmt.executeQuery();	if (rsNw.next()) {	long accountId = rsNw.getLong(1);	long domainId = rsNw.getLong(2);	
adding default egress firewall rule for network 

rsNw = pstmt.executeQuery();	if (rsNw.next()) {	long accountId = rsNw.getLong(1);	long domainId = rsNw.getLong(2);	pstmt = conn.prepareStatement("INSERT INTO firewall_rules (uuid, state, protocol, purpose, account_id, domain_id, network_id, xid, created,  traffic_type) VALUES (?, 'Active', 'all', 'Firewall', ?, ?, ?, ?, now(), 'Egress')");	pstmt.setString(1, UUID.randomUUID().toString());	pstmt.setLong(2, accountId);	pstmt.setLong(3, domainId);	pstmt.setLong(4, netId);	pstmt.setString(5, UUID.randomUUID().toString());	
inserting default egress firewall rule 

private void fix22xKVMSnapshots(Connection conn) {	PreparedStatement pstmt = null;	ResultSet rs = null;	
updating kvm snapshots 

ResultSet rs = null;	try {	pstmt = conn.prepareStatement("select id, backup_snap_id from `cloud`.`snapshots` where hypervisor_type='KVM' and removed is null and backup_snap_id is not null");	rs = pstmt.executeQuery();	while (rs.next()) {	long id = rs.getLong(1);	String backUpPath = rs.getString(2);	int index = backUpPath.indexOf("snapshots" + File.separator);	if (index > 1) {	String correctedPath = File.separator + backUpPath.substring(index);	
updating snapshot with id original backup path updated backup path 

String backUpPath = rs.getString(2);	int index = backUpPath.indexOf("snapshots" + File.separator);	if (index > 1) {	String correctedPath = File.separator + backUpPath.substring(index);	pstmt = conn.prepareStatement("UPDATE `cloud`.`snapshots` set backup_snap_id=? where id = ?");	pstmt.setString(1, correctedPath);	pstmt.setLong(2, id);	pstmt.executeUpdate();	}	}	
done updating kvm snapshots 

========================= cloudstack sample_4177 =========================

protected boolean canHandle(NetworkOffering offering) {	if (isMyTrafficType(offering.getTrafficType()) && offering.isSystemOnly()) {	return true;	} else {	
it s not storage network offering skip it 

nic.setFormat(AddressFormat.Ip4);	nic.setIPv4Netmask(ip.getNetmask());	nic.setBroadcastType(BroadcastDomainType.Storage);	nic.setIPv4Gateway(ip.getGateway());	if (vlan != null) {	nic.setBroadcastUri(BroadcastDomainType.Storage.toUri(vlan));	} else {	nic.setBroadcastUri(null);	}	nic.setIsolationUri(null);	
allocated a storage nic for 

public boolean release(NicProfile nic, VirtualMachineProfile vm, String reservationId) {	Network nw = _nwDao.findById(nic.getNetworkId());	if (!_sNwMgr.isStorageIpRangeAvailable(nw.getDataCenterId())) {	return super.release(nic, vm, reservationId);	}	_sNwMgr.releaseIpAddress(nic.getIPv4Address());	
release an storage ip 

========================= cloudstack sample_2277 =========================

protected void populateConfiguration(Date date, Configurable configurable) {	if (_configured.contains(configurable)) return;	
retrieving keys from 

========================= cloudstack sample_496 =========================

if (!result) {	String errMsg = "Unable to set Temp-Key: " + tempKey;	s_logger.error(errMsg);	throw new CloudRuntimeException(errMsg);	}	String containerName = SwiftUtil.getContainerName(dataObject.getType().toString(), dataObject.getId());	String objectName = installPath.split("\\/")[1];	int urlExpirationInterval = Integer.parseInt(_configDao.getValue(Config.ExtractURLExpirationInterval.toString()));	URL swiftUrl = SwiftUtil.generateTempUrl(swiftTO, containerName, objectName, tempKey, urlExpirationInterval);	if (swiftUrl != null) {	
swift temp url 

========================= cloudstack sample_1908 =========================

defaultNic.setMacAddress(ip.getMacAddress());	defaultNic.setBroadcastType(BroadcastDomainType.Vlan);	defaultNic.setBroadcastUri(BroadcastDomainType.Vlan.toUri(ip.getVlanTag()));	defaultNic.setIsolationUri(IsolationType.Vlan.toUri(ip.getVlanTag()));	NicProfile publicNic = null;	Network publicNtwk = null;	try {	publicNtwk = networkModel.getNetwork(ip.getNetworkId());	publicNic = itMgr.addVmToNetwork(_router, publicNtwk, defaultNic);	} catch (ConcurrentOperationException e) {	
failed to add router to vlan in public network due to 

defaultNic.setBroadcastType(BroadcastDomainType.Vlan);	defaultNic.setBroadcastUri(BroadcastDomainType.Vlan.toUri(ip.getVlanTag()));	defaultNic.setIsolationUri(IsolationType.Vlan.toUri(ip.getVlanTag()));	NicProfile publicNic = null;	Network publicNtwk = null;	try {	publicNtwk = networkModel.getNetwork(ip.getNetworkId());	publicNic = itMgr.addVmToNetwork(_router, publicNtwk, defaultNic);	} catch (ConcurrentOperationException e) {	} catch (InsufficientCapacityException e) {	
failed to add router to vlan in public network due to 

defaultNic.setIsolationUri(IsolationType.Vlan.toUri(ip.getVlanTag()));	NicProfile publicNic = null;	Network publicNtwk = null;	try {	publicNtwk = networkModel.getNetwork(ip.getNetworkId());	publicNic = itMgr.addVmToNetwork(_router, publicNtwk, defaultNic);	} catch (ConcurrentOperationException e) {	} catch (InsufficientCapacityException e) {	} finally {	if (publicNic == null) {	
failed to add router to vlan in public network 

========================= cloudstack sample_2332 =========================

} else {	ip = _networkService.allocatePortableIP(_accountService.getAccount(getEntityOwnerId()), 1, getZoneId(), getNetworkId(), getVpcId());	}	if (ip != null) {	setEntityId(ip.getId());	setEntityUuid(ip.getUuid());	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to allocate IP address");	}	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3523 =========================

if (prefix) {	sb.append("prefix ");	}	if (requestlearn) {	sb.append("request-learn").append(" ");	}	if (mode != null) {	sb.append("mode ").append(mode).append(" ");	}	} else {	
haproxy stickiness policy for lb rule not applied cause invalid method 

if (httpbasedStickiness) {	result.addAll(dstWithCookieSubRule);	} else {	result.addAll(dstSubRule);	}	result.add(stickinessSubRule);	} else {	result.addAll(dstSubRule);	}	if (stickinessSubRule != null && !destsAvailable) {	
haproxy stickiness policy for lb rule not applied cause backends are unavailable 

private String generateStatsRule(final LoadBalancerConfigCommand lbCmd, final String ruleName, final String statsIp) {	final StringBuilder rule = new StringBuilder("\nlisten ").append(ruleName).append(" ").append(statsIp).append(":").append(lbCmd.lbStatsPort);	if (!lbCmd.keepAliveEnabled) {	
haproxy mode http enabled 

private String generateStatsRule(final LoadBalancerConfigCommand lbCmd, final String ruleName, final String statsIp) {	final StringBuilder rule = new StringBuilder("\nlisten ").append(ruleName).append(" ").append(statsIp).append(":").append(lbCmd.lbStatsPort);	if (!lbCmd.keepAliveEnabled) {	rule.append("\n\tmode http\n\toption httpclose");	}	rule.append("\n\tstats enable\n\tstats uri     ") .append(lbCmd.lbStatsUri) .append("\n\tstats realm   Haproxy\\ Statistics\n\tstats auth    ") .append(lbCmd.lbStatsAuth);	rule.append("\n");	final String result = rule.toString();	if (s_logger.isDebugEnabled()) {	
haproxystats rule 

public String[] generateConfiguration(final LoadBalancerConfigCommand lbCmd) {	final List<String> result = new ArrayList<String>();	final List<String> gSection = Arrays.asList(globalSection);	gSection.set(2, "\tmaxconn " + lbCmd.maxconn);	final String pipesLine = "\tmaxpipes " + Long.toString(Long.parseLong(lbCmd.maxconn) / 4);	gSection.set(3, pipesLine);	if (s_logger.isDebugEnabled()) {	for (final String s : gSection) {	
global section 

}	}	result.addAll(gSection);	result.add(blankLine);	final List<String> dSection = Arrays.asList(defaultsSection);	if (lbCmd.keepAliveEnabled) {	dSection.set(7, "\tno option forceclose");	}	if (s_logger.isDebugEnabled()) {	for (final String s : dSection) {	
default section 

========================= cloudstack sample_65 =========================

Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final List<PrivateIpVO> privateIps = _privateIpDao.listByNetworkId(networkId);	if (privateIps.size() > 1 || !privateIps.get(0).getIpAddress().equalsIgnoreCase(gateway.getIp4Address())) {	s_logger.debug("Not removing network id=" + gateway.getNetworkId() + " as it has private ip addresses for other gateways");	deleteNetwork = false;	}	final PrivateIpVO ip = _privateIpDao.findByIpAndVpcId(gateway.getVpcId(), gateway.getIp4Address());	if (ip != null) {	_privateIpDao.remove(ip.getId());	
deleted private ip 

final List<PrivateIpVO> privateIps = _privateIpDao.listByNetworkId(networkId);	if (privateIps.size() > 1 || !privateIps.get(0).getIpAddress().equalsIgnoreCase(gateway.getIp4Address())) {	s_logger.debug("Not removing network id=" + gateway.getNetworkId() + " as it has private ip addresses for other gateways");	deleteNetwork = false;	}	final PrivateIpVO ip = _privateIpDao.findByIpAndVpcId(gateway.getVpcId(), gateway.getIp4Address());	if (ip != null) {	_privateIpDao.remove(ip.getId());	}	_vpcGatewayDao.remove(gateway.getId());	
deleted private gateway 

========================= cloudstack sample_2349 =========================

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	
we currently don t handle conversion from to 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	return null;	}	String qcow2Path = templatePath + File.separator + templateName + "." + ImageFormat.QCOW2.getFileExtension();	if (!_storage.exists(qcow2Path)) {	
unable to find the file 

return null;	}	FormatInfo info = new FormatInfo();	info.format = ImageFormat.QCOW2;	info.filename = templateName + "." + ImageFormat.QCOW2.getFileExtension();	File qcow2File = _storage.getFile(qcow2Path);	info.size = _storage.getSize(qcow2Path);	try {	info.virtualSize = getTemplateVirtualSize(qcow2File);	} catch (IOException e) {	
unable to get virtual size from 

public long getVirtualSize(File file) throws IOException {	try {	long size = getTemplateVirtualSize(file);	return size;	} catch (Exception e) {	
ignored failed to get template virtual size for 

========================= cloudstack sample_402 =========================

public Network design(NetworkOffering offering, DeploymentPlan plan, Network network, Account owner) {	
design called with network 

public void updateNicProfile(NicProfile profile, Network network) {	
updatenicprofile called with network profile 

public NicProfile allocate(Network network, NicProfile nic, VirtualMachineProfile vm) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException, ConcurrentOperationException {	if (nic == null) {	nic = new NicProfile(Nic.ReservationStrategy.Create, null, null, null, null);	}	
allocate called with network nic vm 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException, ConcurrentOperationException {	
reserve called with network nic vm 

public boolean release(NicProfile nic, VirtualMachineProfile vm, String reservationId) {	
release called with nic vm 

public Network implement(Network network, NetworkOffering offering, DeployDestination destination, ReservationContext context) throws InsufficientVirtualNetworkCapacityException {	
implement called with network 

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	
deallocate called with network nic vm 

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	if (s_logger.isDebugEnabled()) {	
public network deallocate network networkid ip 

if (ip != null && nic.getReservationStrategy() != Nic.ReservationStrategy.Managed) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	_ipAddrMgr.markIpAsUnavailable(ip.getId());	_ipAddressDao.unassignIpAddress(ip.getId());	}	});	}	nic.deallocate();	if (s_logger.isDebugEnabled()) {	
deallocated nic 

public void shutdown(NetworkProfile network, NetworkOffering offering) {	
shutdown called with network 

public boolean trash(Network network, NetworkOffering offering) {	
trash called with network 

========================= cloudstack sample_1836 =========================

VolumeVO rootVolumeOfVm = rootVolumesOfVm.get(0);	StoragePoolVO rootDiskPool = _storagePoolDao.findById(rootVolumeOfVm.getPoolId());	clusterId = (rootDiskPool == null ? null : rootDiskPool.getClusterId());	}	}	while ((pool = findStoragePool(dskCh, dc, pod.first(), clusterId, hostId, vm, poolsToAvoid)) != null) {	break;	}	if (pool == null) {	if (s_logger.isDebugEnabled()) {	
could not find any storage pool to create volume in the pod cluster of the provided vm 

msg = addDetails.toString();	}	} else {	while ((pod = findPod(null, null, dc, account.getId(), podsToAvoid)) != null) {	podsToAvoid.add(pod.first().getId());	while ((pool = findStoragePool(dskCh, dc, pod.first(), null, null, null, poolsToAvoid)) != null) {	break;	}	if (pool != null) {	if (s_logger.isDebugEnabled()) {	
found a suitable pool for create volume 

long snapVolId = snapInfo.getVolumeId();	_snapshotSrv.syncVolumeSnapshotsToRegionStore(snapVolId, snapStore);	} catch (Exception ex) {	s_logger.warn(ex.getMessage(), ex);	}	}	AsyncCallFuture<VolumeApiResult> future = volService.createVolumeFromSnapshot(vol, store, snapInfo);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	
failed to create volume from snapshot 

}	}	AsyncCallFuture<VolumeApiResult> future = volService.createVolumeFromSnapshot(vol, store, snapInfo);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException("Failed to create volume from snapshot:" + result.getResult());	}	return result.getVolume();	} catch (InterruptedException e) {	
failed to create volume from snapshot 

AsyncCallFuture<VolumeApiResult> future = volService.createVolumeFromSnapshot(vol, store, snapInfo);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException("Failed to create volume from snapshot:" + result.getResult());	}	return result.getVolume();	} catch (InterruptedException e) {	throw new CloudRuntimeException("Failed to create volume from snapshot", e);	} catch (ExecutionException e) {	
failed to create volume from snapshot 

final HashSet<StoragePool> avoidPools = new HashSet<StoragePool>(avoids);	DiskProfile dskCh = createDiskCharacteristics(volume, template, dc, diskOffering);	dskCh.setHyperType(vm.getHypervisorType());	storageMgr.setDiskProfileThrottling(dskCh, null, diskOffering);	StoragePool destPool = findStoragePool(dskCh, dc, pod, clusterId, null, vm, avoidPools);	DataStore destStore = dataStoreMgr.getDataStore(destPool.getId(), DataStoreRole.Primary);	AsyncCallFuture<VolumeApiResult> future = volService.copyVolume(volume, destStore);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	
copy volume failed 

StoragePool destPool = findStoragePool(dskCh, dc, pod, clusterId, null, vm, avoidPools);	DataStore destStore = dataStoreMgr.getDataStore(destPool.getId(), DataStoreRole.Primary);	AsyncCallFuture<VolumeApiResult> future = volService.copyVolume(volume, destStore);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException("copy volume failed: " + result.getResult());	}	return result.getVolume();	} catch (InterruptedException e) {	
failed to copy volume 

AsyncCallFuture<VolumeApiResult> future = volService.copyVolume(volume, destStore);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException("copy volume failed: " + result.getResult());	}	return result.getVolume();	} catch (InterruptedException e) {	throw new CloudRuntimeException("Failed to copy volume", e);	} catch (ExecutionException e) {	
failed to copy volume 

dskCh = createDiskCharacteristics(volume, template, dc, diskOffering);	storageMgr.setDiskProfileThrottling(dskCh, null, diskOffering);	}	if (diskOffering != null && diskOffering.isCustomized()) {	dskCh.setSize(size);	}	dskCh.setHyperType(hyperType);	final HashSet<StoragePool> avoidPools = new HashSet<StoragePool>(avoids);	pool = findStoragePool(dskCh, dc, pod, clusterId, vm.getHostId(), vm, avoidPools);	if (pool == null) {	
unable to find suitable primary storage when creating volume 

if (diskOffering != null && diskOffering.isCustomized()) {	dskCh.setSize(size);	}	dskCh.setHyperType(hyperType);	final HashSet<StoragePool> avoidPools = new HashSet<StoragePool>(avoids);	pool = findStoragePool(dskCh, dc, pod, clusterId, vm.getHostId(), vm, avoidPools);	if (pool == null) {	throw new CloudRuntimeException("Unable to find suitable primary storage when creating volume " + volume.getName());	}	if (s_logger.isDebugEnabled()) {	
trying to create on 

if (isNotCreatedFromTemplate) {	future = volService.createVolumeAsync(volume, store);	} else {	TemplateInfo templ = tmplFactory.getTemplate(template.getId(), DataStoreRole.Image);	future = volService.createVolumeFromTemplateAsync(volume, store.getId(), templ);	}	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	if (result.getResult().contains("request template reload") && (i == 0)) {	
retry template re deploy for vmware 

} else {	TemplateInfo templ = tmplFactory.getTemplate(template.getId(), DataStoreRole.Image);	future = volService.createVolumeFromTemplateAsync(volume, store.getId(), templ);	}	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	if (result.getResult().contains("request template reload") && (i == 0)) {	continue;	} else {	
create volume failed 

VolumeApiResult result = future.get();	if (result.isFailed()) {	if (result.getResult().contains("request template reload") && (i == 0)) {	continue;	} else {	throw new CloudRuntimeException("create volume failed:" + result.getResult());	}	}	return result.getVolume();	} catch (InterruptedException e) {	
create volume failed 

if (result.getResult().contains("request template reload") && (i == 0)) {	continue;	} else {	throw new CloudRuntimeException("create volume failed:" + result.getResult());	}	}	return result.getVolume();	} catch (InterruptedException e) {	throw new CloudRuntimeException("create volume failed", e);	} catch (ExecutionException e) {	
create volume failed 

public DiskProfile allocateTemplatedVolume(Type type, String name, DiskOffering offering, Long rootDisksize, Long minIops, Long maxIops, VirtualMachineTemplate template, VirtualMachine vm, Account owner) {	assert (template.getFormat() != ImageFormat.ISO) : "ISO is not a template really....";	Long size = _tmpltMgr.getTemplateSize(template.getId(), vm.getDataCenterId());	if (rootDisksize != null ) {	rootDisksize = rootDisksize * 1024 * 1024 * 1024;	if (rootDisksize > size) {	
using root disk size of bytes for volume 

public DiskProfile allocateTemplatedVolume(Type type, String name, DiskOffering offering, Long rootDisksize, Long minIops, Long maxIops, VirtualMachineTemplate template, VirtualMachine vm, Account owner) {	assert (template.getFormat() != ImageFormat.ISO) : "ISO is not a template really....";	Long size = _tmpltMgr.getTemplateSize(template.getId(), vm.getDataCenterId());	if (rootDisksize != null ) {	rootDisksize = rootDisksize * 1024 * 1024 * 1024;	if (rootDisksize > size) {	size = rootDisksize;	} else {	
using root disk size of bytes for volume since specified root disk size of bytes is smaller than template 

protected VolumeVO switchVolume(final VolumeVO existingVolume, final VirtualMachineProfile vm) throws StorageUnavailableException {	Long templateIdToUse = null;	Long volTemplateId = existingVolume.getTemplateId();	long vmTemplateId = vm.getTemplateId();	if (volTemplateId != null && volTemplateId.longValue() != vmTemplateId) {	if (s_logger.isDebugEnabled()) {	
switchvolume old volume s templateid does not match the vm s templateid updating templateid in the new volume 

}	templateIdToUse = vmTemplateId;	}	final Long templateIdToUseFinal = templateIdToUse;	return Transaction.execute(new TransactionCallback<VolumeVO>() {	public VolumeVO doInTransaction(TransactionStatus status) {	VolumeVO newVolume = allocateDuplicateVolumeVO(existingVolume, templateIdToUseFinal);	try {	stateTransitTo(existingVolume, Volume.Event.DestroyRequested);	} catch (NoTransitionException e) {	
unable to destroy existing volume 

}	final Long templateIdToUseFinal = templateIdToUse;	return Transaction.execute(new TransactionCallback<VolumeVO>() {	public VolumeVO doInTransaction(TransactionStatus status) {	VolumeVO newVolume = allocateDuplicateVolumeVO(existingVolume, templateIdToUseFinal);	try {	stateTransitTo(existingVolume, Volume.Event.DestroyRequested);	} catch (NoTransitionException e) {	}	if (vm.getHypervisorType() == HypervisorType.VMware) {	
expunging volume from primary data store 

VolumeVO newVolume = allocateDuplicateVolumeVO(existingVolume, templateIdToUseFinal);	try {	stateTransitTo(existingVolume, Volume.Event.DestroyRequested);	} catch (NoTransitionException e) {	}	if (vm.getHypervisorType() == HypervisorType.VMware) {	AsyncCallFuture<VolumeApiResult> future = volService.expungeVolumeAsync(volFactory.getVolume(existingVolume.getId()));	try {	future.get();	} catch (Exception e) {	
failed to expunge volume 

public void cleanupVolumes(long vmId) throws ConcurrentOperationException {	if (s_logger.isDebugEnabled()) {	
cleaning storage for vm 

final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);	final List<VolumeVO> toBeExpunged = new ArrayList<VolumeVO>();	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	for (VolumeVO vol : volumesForVm) {	if (vol.getVolumeType().equals(Type.ROOT)) {	boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged || vol.getState() == Volume.State.Expunging);	if (!volumeAlreadyDestroyed) {	volService.destroyVolume(vol.getId());	} else {	
skipping destroy for the volume as its in state 

for (VolumeVO vol : volumesForVm) {	if (vol.getVolumeType().equals(Type.ROOT)) {	boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged || vol.getState() == Volume.State.Expunging);	if (!volumeAlreadyDestroyed) {	volService.destroyVolume(vol.getId());	} else {	}	toBeExpunged.add(vol);	} else {	if (s_logger.isDebugEnabled()) {	
detaching 

}	}	}	});	AsyncCallFuture<VolumeApiResult> future = null;	for (VolumeVO expunge : toBeExpunged) {	future = volService.expungeVolumeAsync(volFactory.getVolume(expunge.getId()));	try {	future.get();	} catch (InterruptedException e) {	
failed expunge volume 

}	}	});	AsyncCallFuture<VolumeApiResult> future = null;	for (VolumeVO expunge : toBeExpunged) {	future = volService.expungeVolumeAsync(volFactory.getVolume(expunge.getId()));	try {	future.get();	} catch (InterruptedException e) {	} catch (ExecutionException e) {	
failed expunge volume 

public Volume migrateVolume(Volume volume, StoragePool destPool) throws StorageUnavailableException {	VolumeInfo vol = volFactory.getVolume(volume.getId());	AsyncCallFuture<VolumeApiResult> future = volService.copyVolume(vol, (DataStore)destPool);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	
migrate volume failed 

if (result.isFailed()) {	throw new StorageUnavailableException("Migrate volume failed: " + result.getResult(), destPool.getId());	} else {	if (!_snapshotDao.listByVolumeId(vol.getId()).isEmpty()) {	_snapshotDao.updateVolumeIds(vol.getId(), result.getVolume().getId());	_snapshotDataStoreDao.updateVolumeIds(vol.getId(), result.getVolume().getId());	}	}	return result.getVolume();	} catch (InterruptedException e) {	
migrate volume failed 

} else {	if (!_snapshotDao.listByVolumeId(vol.getId()).isEmpty()) {	_snapshotDao.updateVolumeIds(vol.getId(), result.getVolume().getId());	_snapshotDataStoreDao.updateVolumeIds(vol.getId(), result.getVolume().getId());	}	}	return result.getVolume();	} catch (InterruptedException e) {	throw new CloudRuntimeException(e.getMessage());	} catch (ExecutionException e) {	
migrate volume failed 

protected Volume liveMigrateVolume(Volume volume, StoragePool destPool) {	VolumeInfo vol = volFactory.getVolume(volume.getId());	AsyncCallFuture<VolumeApiResult> future = volService.migrateVolume(vol, (DataStore)destPool);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	
migrate volume failed 

protected Volume liveMigrateVolume(Volume volume, StoragePool destPool) {	VolumeInfo vol = volFactory.getVolume(volume.getId());	AsyncCallFuture<VolumeApiResult> future = volService.migrateVolume(vol, (DataStore)destPool);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	return null;	}	return result.getVolume();	} catch (InterruptedException e) {	
migrate volume failed 

AsyncCallFuture<VolumeApiResult> future = volService.migrateVolume(vol, (DataStore)destPool);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	return null;	}	return result.getVolume();	} catch (InterruptedException e) {	return null;	} catch (ExecutionException e) {	
migrate volume failed 

}	if (destPool == null) {	throw new CloudRuntimeException("Failed to find the destination storage pool " + storagePool.getId());	}	volumeMap.put(volFactory.getVolume(volume.getId()), (DataStore)destPool);	}	AsyncCallFuture<CommandResult> future = volService.migrateVolumes(volumeMap, vmTo, srcHost, destHost);	try {	CommandResult result = future.get();	if (result.isFailed()) {	
failed to migrated vm along with its volumes 

}	volumeMap.put(volFactory.getVolume(volume.getId()), (DataStore)destPool);	}	AsyncCallFuture<CommandResult> future = volService.migrateVolumes(volumeMap, vmTo, srcHost, destHost);	try {	CommandResult result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException("Failed to migrated vm " + vm + " along with its volumes. ");	}	} catch (InterruptedException e) {	
failed to migrated vm along with its volumes 

volumeMap.put(volFactory.getVolume(volume.getId()), (DataStore)destPool);	}	AsyncCallFuture<CommandResult> future = volService.migrateVolumes(volumeMap, vmTo, srcHost, destHost);	try {	CommandResult result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException("Failed to migrated vm " + vm + " along with its volumes. ");	}	} catch (InterruptedException e) {	} catch (ExecutionException e) {	
failed to migrated vm along with its volumes 

public boolean storageMigration(VirtualMachineProfile vm, StoragePool destPool) throws StorageUnavailableException {	List<VolumeVO> vols = _volsDao.findUsableVolumesForInstance(vm.getId());	List<Volume> volumesNeedToMigrate = new ArrayList<Volume>();	for (VolumeVO volume : vols) {	if (volume.getState() != Volume.State.Ready) {	
volume is in state 

public boolean storageMigration(VirtualMachineProfile vm, StoragePool destPool) throws StorageUnavailableException {	List<VolumeVO> vols = _volsDao.findUsableVolumesForInstance(vm.getId());	List<Volume> volumesNeedToMigrate = new ArrayList<Volume>();	for (VolumeVO volume : vols) {	if (volume.getState() != Volume.State.Ready) {	throw new CloudRuntimeException("volume: " + volume.getId() + " is in " + volume.getState() + " state");	}	if (volume.getPoolId() == destPool.getId()) {	
volume is on the same storage pool 

for (VolumeVO volume : vols) {	if (volume.getState() != Volume.State.Ready) {	throw new CloudRuntimeException("volume: " + volume.getId() + " is in " + volume.getState() + " state");	}	if (volume.getPoolId() == destPool.getId()) {	continue;	}	volumesNeedToMigrate.add(volume);	}	if (volumesNeedToMigrate.isEmpty()) {	
no volume need to be migrated 

public void prepareForMigration(VirtualMachineProfile vm, DeployDestination dest) {	List<VolumeVO> vols = _volsDao.findUsableVolumesForInstance(vm.getId());	if (s_logger.isDebugEnabled()) {	
preparing volumes for 

assignedPool = _storagePoolDao.findById(vol.getPoolId());	}	if (assignedPool != null) {	Volume.State state = vol.getState();	if (state == Volume.State.Allocated || state == Volume.State.Creating) {	VolumeTask task = new VolumeTask(VolumeTaskType.RECREATE, vol, null);	tasks.add(task);	} else {	if (vol.isRecreatable()) {	if (s_logger.isDebugEnabled()) {	
volume will be recreated on storage pool assigned by deploymentplanner 

tasks.add(task);	} else {	if (vol.isRecreatable()) {	if (s_logger.isDebugEnabled()) {	}	VolumeTask task = new VolumeTask(VolumeTaskType.RECREATE, vol, null);	tasks.add(task);	} else {	if (assignedPool.getId() != vol.getPoolId()) {	if (s_logger.isDebugEnabled()) {	
mismatch in storage pool assigned by deploymentplanner and the one associated with volume 

}	VolumeTask task = new VolumeTask(VolumeTaskType.RECREATE, vol, null);	tasks.add(task);	} else {	if (assignedPool.getId() != vol.getPoolId()) {	if (s_logger.isDebugEnabled()) {	}	DiskOffering diskOffering = _entityMgr.findById(DiskOffering.class, vol.getDiskOfferingId());	if (diskOffering.getUseLocalStorage()) {	if (s_logger.isDebugEnabled()) {	
local volume cannot be recreated on storagepool assigned by deploymentplanner 

} else {	Boolean isHAOperation = (Boolean)vm.getParameter(VirtualMachineProfile.Param.HaOperation);	Boolean storageMigrationEnabled = true;	if (isHAOperation != null && isHAOperation) {	storageMigrationEnabled = StorageHAMigrationEnabled.value();	} else {	storageMigrationEnabled = StorageMigrationEnabled.value();	}	if(storageMigrationEnabled){	if (s_logger.isDebugEnabled()) {	
shared volume will be migrated on storage pool assigned by deploymentplanner 

VolumeTask task = new VolumeTask(VolumeTaskType.NOP, vol, pool);	tasks.add(task);	}	}	}	} else {	if (vol.getPoolId() == null) {	throw new StorageUnavailableException("Volume has no pool associate and also no storage pool assigned in DeployDestination, Unable to create " + vol, Volume.class, vol.getId());	}	if (s_logger.isDebugEnabled()) {	
no need to recreate the volume since it already has a pool assigned adding disk to vm 

private Pair<VolumeVO, DataStore> recreateVolume(VolumeVO vol, VirtualMachineProfile vm, DeployDestination dest) throws StorageUnavailableException {	VolumeVO newVol;	boolean recreate = RecreatableSystemVmEnabled.value();	DataStore destPool = null;	if (recreate && (dest.getStorageForDisks() == null || dest.getStorageForDisks().get(vol) == null)) {	destPool = dataStoreMgr.getDataStore(vol.getPoolId(), DataStoreRole.Primary);	
existing pool 

if (vol.getState() == Volume.State.Allocated || vol.getState() == Volume.State.Creating) {	newVol = vol;	} else {	newVol = switchVolume(vol, vm);	if (dest.getStorageForDisks() != null && dest.getStorageForDisks().containsKey(vol)) {	StoragePool poolWithOldVol = dest.getStorageForDisks().get(vol);	dest.getStorageForDisks().put(newVol, poolWithOldVol);	dest.getStorageForDisks().remove(vol);	}	if (s_logger.isDebugEnabled()) {	
created new volume for old volume 

AsyncCallFuture<VolumeApiResult> future = null;	if (templateId == null) {	DiskOffering diskOffering = _entityMgr.findById(DiskOffering.class, volume.getDiskOfferingId());	HypervisorType hyperType = vm.getVirtualMachine().getHypervisorType();	volService.updateHypervisorSnapshotReserveForVolume(diskOffering, volume.getId(), hyperType);	volume = volFactory.getVolume(newVol.getId(), destPool);	future = volService.createVolumeAsync(volume, destPool);	} else {	TemplateInfo templ = tmplFactory.getReadyTemplateOnImageStore(templateId, dest.getDataCenter().getId());	if (templ == null) {	
can t find ready template for data center 

}	else {	future = volService.createVolumeFromTemplateAsync(volume, destPool.getId(), templ);	}	}	VolumeApiResult result;	try {	result = future.get();	if (result.isFailed()) {	if (result.getResult().contains("request template reload") && (i == 0)) {	
retry template re deploy for vmware 

future = volService.createVolumeFromTemplateAsync(volume, destPool.getId(), templ);	}	}	VolumeApiResult result;	try {	result = future.get();	if (result.isFailed()) {	if (result.getResult().contains("request template reload") && (i == 0)) {	continue;	} else {	
unable to create 

}	StoragePoolVO storagePool = _storagePoolDao.findById(destPool.getId());	if (storagePool.isManaged()) {	long hostId = vm.getVirtualMachine().getHostId();	Host host = _hostDao.findById(hostId);	volService.grantAccess(volFactory.getVolume(newVol.getId()), host, destPool);	}	newVol = _volsDao.findById(newVol.getId());	break;	} catch (InterruptedException | ExecutionException e) {	
unable to create 

public void prepare(VirtualMachineProfile vm, DeployDestination dest) throws StorageUnavailableException, InsufficientStorageCapacityException, ConcurrentOperationException {	if (dest == null) {	if (s_logger.isDebugEnabled()) {	
deploydestination cannot be null cannot prepare volumes for the vm 

if (dest == null) {	if (s_logger.isDebugEnabled()) {	}	throw new CloudRuntimeException("Unable to prepare Volume for vm because DeployDestination is null, vm:" + vm);	}	if (_volsDao.findByInstanceAndType(vm.getId(), Volume.Type.ROOT).isEmpty()) {	throw new CloudRuntimeException("Unable to prepare volumes for vm as ROOT volume is missing");	}	List<VolumeVO> vols = _volsDao.findUsableVolumesForInstance(vm.getId());	if (s_logger.isDebugEnabled()) {	
checking if we need to prepare volumes for 

private void cleanupVolumeDuringAttachFailure(Long volumeId) {	VolumeVO volume = _volsDao.findById(volumeId);	if (volume == null) {	return;	}	if (volume.getState().equals(Volume.State.Creating)) {	
remove volume as it s leftover from last mgt server stop 

private void cleanupVolumeDuringMigrationFailure(Long volumeId, Long destPoolId) {	StoragePool destPool = (StoragePool)dataStoreMgr.getDataStore(destPoolId, DataStoreRole.Primary);	if (destPool == null) {	return;	}	VolumeVO volume = _volsDao.findById(volumeId);	if (volume.getState() == Volume.State.Migrating) {	VolumeVO duplicateVol = _volsDao.findByPoolIdName(destPoolId, volume.getName());	if (duplicateVol != null) {	
remove volume on storage pool 

StoragePool destPool = (StoragePool)dataStoreMgr.getDataStore(destPoolId, DataStoreRole.Primary);	if (destPool == null) {	return;	}	VolumeVO volume = _volsDao.findById(volumeId);	if (volume.getState() == Volume.State.Migrating) {	VolumeVO duplicateVol = _volsDao.findByPoolIdName(destPoolId, volume.getName());	if (duplicateVol != null) {	_volsDao.remove(duplicateVol.getId());	}	
change volume state to ready from migrating in case migration failure for vol 

private void cleanupVolumeDuringSnapshotFailure(Long volumeId, Long snapshotId) {	_snapshotSrv.cleanupVolumeDuringSnapshotFailure(volumeId, snapshotId);	VolumeVO volume = _volsDao.findById(volumeId);	if (volume.getState() == Volume.State.Snapshotting) {	
change volume state back to ready 

VmWorkAttachVolume work = VmWorkSerializer.deserialize(VmWorkAttachVolume.class, job.getCmdInfo());	cleanupVolumeDuringAttachFailure(work.getVolumeId());	} else if (job.getCmd().equalsIgnoreCase(VmWorkMigrateVolume.class.getName())) {	VmWorkMigrateVolume work = VmWorkSerializer.deserialize(VmWorkMigrateVolume.class, job.getCmdInfo());	cleanupVolumeDuringMigrationFailure(work.getVolumeId(), work.getDestPoolId());	} else if (job.getCmd().equalsIgnoreCase(VmWorkTakeVolumeSnapshot.class.getName())) {	VmWorkTakeVolumeSnapshot work = VmWorkSerializer.deserialize(VmWorkTakeVolumeSnapshot.class, job.getCmdInfo());	cleanupVolumeDuringSnapshotFailure(work.getVolumeId(), work.getSnapshotId());	}	} catch (Exception e) {	
clean up job failure will continue 

if (volume.getState() == Volume.State.Allocated) {	_volsDao.remove(volume.getId());	stateTransitTo(volume, Volume.Event.DestroyRequested);	} else {	volService.destroyVolume(volume.getId());	}	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_DELETE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName(), Volume.class.getName(), volume.getUuid(), volume.isDisplayVolume());	_resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType.volume, volume.isDisplay());	_resourceLimitMgr.recalculateResourceCount(volume.getAccountId(), volume.getDomainId(), ResourceType.primary_storage.getOrdinal());	} catch (Exception e) {	
failed to destroy volume 

public void updateVolumeDiskChain(long volumeId, String path, String chainInfo) {	VolumeVO vol = _volsDao.findById(volumeId);	boolean needUpdate = false;	if (vol.getPath() == null) return;	if (!vol.getPath().equalsIgnoreCase(path)) needUpdate = true;	if (chainInfo != null && (vol.getChainInfo() == null || !chainInfo.equalsIgnoreCase(vol.getChainInfo()))) needUpdate = true;	if (needUpdate) {	
update volume disk chain info vol 

========================= cloudstack sample_4767 =========================

String sql = LIST_PODS_HAVING_VMS_FOR_ACCOUNT;	try(PreparedStatement pstmt = txn.prepareStatement(sql)) {	pstmt.setLong(1, zoneId);	pstmt.setLong(2, accountId);	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	result.add(rs.getLong(1));	}	}	catch (Exception e) {	
listpodidshavingvmsforaccount exception 

while (rs.next()) {	result.add(rs.getLong(1));	}	}	catch (Exception e) {	throw new CloudRuntimeException("listPodIdsHavingVmsforAccount:Exception: " + e.getMessage(), e);	}	txn.commit();	return result;	} catch (Exception e) {	
listpodidshavingvmsforaccount exception 

} catch (Exception e) {	throw new CloudRuntimeException("listPodIdsHavingVmsforAccount:Exception: " + e.getMessage(), e);	}	finally {	try{	if (txn != null) {	txn.close();	}	}	catch (Exception e) {	
listvmdetails exception 

long vm_id = rs.getLong("vm_instance.id");	UserVmData uvm = userVmDataHash.get(vm_id);	if (uvm == null) {	uvm = new UserVmData();	uvm.setId(vm_id);	}	setUserVmData(uvm, rs);	}	}	catch (Exception e) {	
listvmdetails exception 

setUserVmData(uvm, rs);	}	}	catch (Exception e) {	throw new CloudRuntimeException("listVmDetails: Exception:" + e.getMessage(),e);	}	curr_index += VM_DETAILS_BATCH_SIZE;	}	}	catch (Exception e) {	
listvmdetails exception 

long vm_id = rs.getLong("vm_instance.id");	UserVmData uvm = userVmDataHash.get(vm_id);	if (uvm == null) {	uvm = new UserVmData();	uvm.setId(vm_id);	}	setUserVmData(uvm, rs);	}	}	catch (Exception e) {	
listvmdetails exception 

uvm.setId(vm_id);	}	setUserVmData(uvm, rs);	}	}	catch (Exception e) {	throw new CloudRuntimeException("listVmDetails: Exception:" + e.getMessage(),e);	}	}	catch (Exception e) {	
listvmdetails exception 

throw new CloudRuntimeException("listVmDetails: Exception:" + e.getMessage(),e);	}	}	catch (Exception e) {	throw new CloudRuntimeException("listVmDetails: Exception:" + e.getMessage(),e);	}	}	txn.commit();	return userVmDataHash;	} catch (Exception e) {	
listvmdetails exception 

} catch (Exception e) {	throw new CloudRuntimeException("listVmDetails:Exception : ", e);	}	finally {	try{	if (txn != null) {	txn.close();	}	}	catch (Exception e) {	
listvmdetails exception 

for(String name : vmNames) {	pstmt.setString(i, name);	i++;	}	try (ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	vmsDetailByNames.add(new Pair<Pair<String, VirtualMachine.Type>, Pair<Long, String>>(new Pair<String, VirtualMachine.Type>( rs.getString("vm_instance.instance_name"), VirtualMachine.Type.valueOf(rs.getString("vm_type"))), new Pair<Long, String>(rs.getLong("vm_instance.id"), rs.getString("user_vm_details.value"))));	}	}	} catch (SQLException e) {	
getvmsdetailsbynames exception in sql 

========================= cloudstack sample_4622 =========================

private static String getSwiftCLIPath() {	String swiftCLI = Script.findScript("scripts/storage/secondary", "swift");	if (swiftCLI == null) {	
can t find swift cli at scripts storage secondary swift 

swiftCmdBuilder.append(rFilename);	}	command.add(swiftCmdBuilder.toString());	OutputInterpreter.AllLinesParser parser = new OutputInterpreter.AllLinesParser();	String result = command.execute(parser);	if (result == null && parser.getLines() != null && !parser.getLines().equalsIgnoreCase("")) {	return parser.getLines().split("\\n");	} else {	if (result != null) {	String errMsg = "swiftList failed , err=" + result;	
failed to list 

command.add(swiftCmdBuilder.toString());	OutputInterpreter.AllLinesParser parser = new OutputInterpreter.AllLinesParser();	String result = command.execute(parser);	if (result == null && parser.getLines() != null && !parser.getLines().equalsIgnoreCase("")) {	return parser.getLines().split("\\n");	} else {	if (result != null) {	String errMsg = "swiftList failed , err=" + result;	} else {	String errMsg = "swiftList failed, no lines returns";	
failed to list 

========================= cloudstack sample_2826 =========================

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	if (s_logger.isInfoEnabled()) {	
we currently don t handle conversion from to vmdk 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	if (s_logger.isInfoEnabled()) {	}	return null;	}	
template processing templatepath templatename 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	if (s_logger.isInfoEnabled()) {	}	return null;	}	String templateFilePath = templatePath + File.separator + templateName + "." + ImageFormat.VMDK.getFileExtension();	if (!_storage.exists(templateFilePath)) {	if (s_logger.isInfoEnabled()) {	
unable to find the vmware template file 

public long getVirtualSize(File file) {	try {	long size = getTemplateVirtualSize(file.getParent(), file.getName());	return size;	} catch (Exception e) {	
ignored failed to get template virtual size for vmdk 

========================= cloudstack sample_394 =========================

public void sendCommand(RequestType reqType) {	if (getJobId() != null) {	if (s_logger.isTraceEnabled()) {	
sending progress command 

if (getJobId() != null) {	if (s_logger.isTraceEnabled()) {	}	try {	DownloadProgressCommand dcmd = new DownloadProgressCommand(getCommand(), getJobId(), reqType);	if (object.getType() == DataObjectType.VOLUME) {	dcmd.setResourceType(ResourceType.VOLUME);	}	_ssAgent.sendMessageAsync(dcmd, new UploadListener.Callback(_ssAgent.getId(), this));	} catch (Exception e) {	
send command failed 

downloadMonitor.handleVolumeSync(agent);	}	}*/ else if (cmd instanceof StartupSecondaryStorageCommand) {	try{	List<DataStore> imageStores = _storeMgr.getImageStoresByScope(new ZoneScope(agent.getDataCenterId()));	for (DataStore store : imageStores) {	_volumeSrv.handleVolumeSync(store);	_imageSrv.handleTemplateSync(store);	}	}catch (Exception e){	
caught exception while doing template volume sync 

public void scheduleTimeoutTask(long delay) {	if (_timeoutTask != null) _timeoutTask.cancel();	_timeoutTask = new TimeoutTask(this);	_timer.schedule(_timeoutTask, delay);	if (s_logger.isDebugEnabled()) {	
scheduling timeout at ms 

========================= cloudstack sample_2430 =========================

ImageStoreResponse storeResponse = null;	if (result != null) {	storeResponse = _responseGenerator.createImageStoreResponse(result);	storeResponse.setResponseName(getCommandName());	storeResponse.setObjectName("imagestore");	setResponseObject(storeResponse);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add secondary storage");	}	} catch (DiscoveryException ex) {	
exception 

========================= cloudstack sample_3221 =========================

int error = 0;	Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if (api.getResponseCode() != 200) {	error++;	
the command failed 

Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if (api.getResponseCode() != 200) {	error++;	} else {	
the command passsed 

}	}	Deploy deploy = new Deploy();	ArrayList<String> inputFile = new ArrayList<String>();	inputFile.add(file);	deploy.setInputFile(inputFile);	deploy.setTestCaseName("Management server deployment");	deploy.getParam().put("hostip", host);	deploy.getParam().put("apicommands", "../metadata/func/commands");	deploy.setCommands();	
starting deployment against host 

Deploy deploy = new Deploy();	ArrayList<String> inputFile = new ArrayList<String>();	inputFile.add(file);	deploy.setInputFile(inputFile);	deploy.setTestCaseName("Management server deployment");	deploy.getParam().put("hostip", host);	deploy.getParam().put("apicommands", "../metadata/func/commands");	deploy.setCommands();	boolean result = deploy.executeTest();	if (result == false) {	
deployment failed 

inputFile.add(file);	deploy.setInputFile(inputFile);	deploy.setTestCaseName("Management server deployment");	deploy.getParam().put("hostip", host);	deploy.getParam().put("apicommands", "../metadata/func/commands");	deploy.setCommands();	boolean result = deploy.executeTest();	if (result == false) {	System.exit(1);	} else {	
deployment is successful 

========================= cloudstack sample_455 =========================

public List<Class<?>> getCommands() {	List<Class<?>> cmdList = new ArrayList<Class<?>>();	cmdList.add(ListElastistorVolumeCmd.class);	cmdList.add(ListElastistorPoolCmd.class);	cmdList.add(ListElastistorInterfaceCmd.class);	
commands were registered successfully with elastistor volume api service cmdcount 

volumeResponse.setGraceAllowed(listVolumeResponse.getGraceallowed());	volumeResponse.setDeduplication(listVolumeResponse.getDeduplication());	volumeResponse.setCompression(listVolumeResponse.getCompression());	volumeResponse.setSync(listVolumeResponse.getSync());	volumeResponse.setObjectName("elastistorvolume");	volumeResponses.add(volumeResponse);	ListResponse<ListElastistorVolumeResponse> response = new ListResponse<ListElastistorVolumeResponse>();	response.setResponses(volumeResponses);	return response;	} catch (Throwable e) {	
unable to list elastistor volume 

elastistorPoolResponse.setState(listPools.getPools().getPool(i).getState());	elastistorPoolResponse.setControllerid(listPools.getPools().getPool(i).getControllerid());	elastistorPoolResponse.setGateway(listPools.getPools().getPool(i).getGateway());	elastistorPoolResponse.setObjectName("elastistorpool");	poolResponses.add(elastistorPoolResponse);	}	ListResponse<ListElastistorPoolResponse> response = new ListResponse<ListElastistorPoolResponse>();	response.setResponses(poolResponses);	return response;	} catch (Throwable e) {	
unable to list elastistor pools 

interfaceResponse.setId(listInterfacesResponse.getInterfaces().getInterface(i).getUuid());	interfaceResponse.setName(listInterfacesResponse.getInterfaces().getInterface(i).getName());	interfaceResponse.setStatus(listInterfacesResponse.getInterfaces().getInterface(i).getStatus());	interfaceResponse.setObjectName("elastistorInterface");	interfaceResponses.add(interfaceResponse);	}	ListResponse<ListElastistorInterfaceResponse> response = new ListResponse<ListElastistorInterfaceResponse>();	response.setResponses(interfaceResponses);	return response;	} catch (Throwable e) {	
unable to list elastistor interfaces 

========================= cloudstack sample_1924 =========================

private void validatePoolAndCluster() {	if (agentInOvm3Cluster) {	
clustering requires a pool setting pool to true 

private void validatePoolAndCluster() {	if (agentInOvm3Cluster) {	agentInOvm3Pool = true;	}	if (!NetUtils.isValidIp(ovm3PoolVip)) {	
no vip setting and to false 

========================= cloudstack sample_843 =========================

private void createSecurityGroups(Connection conn) {	
creating missing default security group as a part of upgrade 

columns.add("domain_router_id");	columns.add("vnet");	columns.add("dc_vlan");	columns.add("external_ip_address");	columns.add("external_mac_address");	columns.add("external_vlan_db_id");	tablesToModify.put("user_vm", columns);	columns = new ArrayList<String>();	columns.add("guest_ip_type");	tablesToModify.put("service_offering", columns);	
dropping columns that don t exist in version of the db 

indexes.put("user_vm_details", keys);	keys = new ArrayList<String>();	keys.add("id_2");	indexes.put("snapshots", keys);	keys = new ArrayList<String>();	keys.add("fk_remote_access_vpn__server_addr");	foreignKeys.put("remote_access_vpn", keys);	keys = new ArrayList<String>();	keys.add("fk_remote_access_vpn__server_addr_id");	indexes.put("remote_access_vpn", keys);	
dropping keys that don t exist in version of the db 

private void addMissingKeys(Connection conn) {	PreparedStatement pstmt = null;	try {	
adding missing foreign keys 

for (String key : keyToTableMap.keySet()) {	String tableName = keyToTableMap.get(key);	pstmt = conn.prepareStatement("SELECT * FROM information_schema.table_constraints a JOIN information_schema.key_column_usage b ON a.table_schema = b.table_schema AND a.constraint_name = b.constraint_name WHERE a.table_schema=database() AND a.constraint_type='FOREIGN KEY' and a.constraint_name=?");	pstmt.setString(1, key);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	continue;	}	pstmt = conn.prepareStatement("ALTER TABLE " + tableName + " ADD CONSTRAINT " + key + " FOREIGN KEY " + keyToStatementMap.get(key));	pstmt.executeUpdate();	
added missing key to table 

pstmt = conn.prepareStatement("SELECT * FROM information_schema.table_constraints a JOIN information_schema.key_column_usage b ON a.table_schema = b.table_schema AND a.constraint_name = b.constraint_name WHERE a.table_schema=database() AND a.constraint_type='FOREIGN KEY' and a.constraint_name=?");	pstmt.setString(1, key);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	continue;	}	pstmt = conn.prepareStatement("ALTER TABLE " + tableName + " ADD CONSTRAINT " + key + " FOREIGN KEY " + keyToStatementMap.get(key));	pstmt.executeUpdate();	rs.close();	}	
missing keys were added successfully as a part of to upgrade 

ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	continue;	}	pstmt = conn.prepareStatement("ALTER TABLE " + tableName + " ADD CONSTRAINT " + key + " FOREIGN KEY " + keyToStatementMap.get(key));	pstmt.executeUpdate();	rs.close();	}	pstmt.close();	} catch (SQLException e) {	
unable to add missing foreign key following statement was executed 

private void addMissingOvsAccount(Connection conn) {	try {	PreparedStatement pstmt = conn.prepareStatement("SELECT * from ovs_tunnel_account");	ResultSet rs = pstmt.executeQuery();	if (!rs.next()) {	
adding missing ovs tunnel account 

private void addMissingOvsAccount(Connection conn) {	try {	PreparedStatement pstmt = conn.prepareStatement("SELECT * from ovs_tunnel_account");	ResultSet rs = pstmt.executeQuery();	if (!rs.next()) {	pstmt = conn.prepareStatement("INSERT INTO `cloud`.`ovs_tunnel_account` (`from`, `to`, `account`, `key`, `port_name`, `state`) VALUES (0, 0, 0, 0, 'lock', 'SUCCESS')");	pstmt.executeUpdate();	}	} catch (SQLException e) {	
unable to add missing ovs tunnel account due to 

========================= cloudstack sample_4225 =========================

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	if (!vm.getType().isUsedBySystem()) {	
not a system vm unable to determine state of returning null 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	if (!vm.getType().isUsedBySystem()) {	}	if (s_logger.isDebugEnabled()) {	
testing if is alive 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	if (!vm.getType().isUsedBySystem()) {	}	if (s_logger.isDebugEnabled()) {	}	if (vm.getHostId() == null) {	
there s no host id for 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	if (!vm.getType().isUsedBySystem()) {	}	if (s_logger.isDebugEnabled()) {	}	if (vm.getHostId() == null) {	throw new UnknownVM();	}	HostVO vmHost = _hostDao.findById(vm.getHostId());	if (vmHost == null) {	
unable to retrieve the host by using id 

if (vm.getHostId() == null) {	throw new UnknownVM();	}	HostVO vmHost = _hostDao.findById(vm.getHostId());	if (vmHost == null) {	throw new UnknownVM();	}	List<? extends Nic> nics = _networkMgr.getNicsForTraffic(vm.getId(), TrafficType.Management);	if (nics.size() == 0) {	if (s_logger.isDebugEnabled()) {	
unable to find a management nic cannot ping this system vm unable to determine state of returning null 

for (Nic nic : nics) {	if (nic.getIPv4Address() == null) {	continue;	}	List<Long> otherHosts = findHostByPod(vmHost.getPodId(), vm.getHostId());	for (Long otherHost : otherHosts) {	Status vmState = testIpAddress(otherHost, nic.getIPv4Address());	assert vmState != null;	if (vmState == Status.Up) {	if (s_logger.isDebugEnabled()) {	
successfully pinged vm s private ip returning that the vm is up 

assert vmState != null;	if (vmState == Status.Up) {	if (s_logger.isDebugEnabled()) {	}	return Boolean.TRUE;	} else if (vmState == Status.Down) {	Status vmHostState = testIpAddress(otherHost, vmHost.getPrivateIpAddress());	assert vmHostState != null;	if (vmHostState == Status.Up) {	if (s_logger.isDebugEnabled()) {	
successfully pinged vm s host ip but could not ping vm returning that the vm is down 

assert vmHostState != null;	if (vmHostState == Status.Up) {	if (s_logger.isDebugEnabled()) {	}	return Boolean.FALSE;	}	}	}	}	if (s_logger.isDebugEnabled()) {	
unable to determine state of returning null 

========================= cloudstack sample_2488 =========================

public void decrRefCnt() {	if (refCnt > 0) {	refCnt--;	}	else{	
we should not try to decrement a zero reference count even though our code has guarded 

========================= cloudstack sample_4049 =========================

if (password != null && nic.isDefaultNic()) {	SavePasswordCommand cmd = new SavePasswordCommand(password, nic.getIPv4Address(), uservm.getHostName(), _networkMgr.getExecuteInSeqNtwkElmtCmd());	cmds.addCommand("password", cmd);	}	String serviceOffering = _serviceOfferingDao.findByIdIncludingRemoved(uservm.getServiceOfferingId()).getDisplayText();	String zoneName = _dcDao.findById(network.getDataCenterId()).getName();	cmds.addCommand( "vmdata", generateVmDataCommand(nic.getIPv4Address(), userData, serviceOffering, zoneName, nic.getIPv4Address(), uservm.getHostName(), uservm.getInstanceName(), uservm.getId(), uservm.getUuid(), sshPublicKey));	try {	_agentManager.send(dest.getHost().getId(), cmds);	} catch (OperationTimedoutException e) {	
unable to send vm data command to host 

String serviceOffering = _serviceOfferingDao.findByIdIncludingRemoved(uservm.getServiceOfferingId()).getDisplayText();	String zoneName = _dcDao.findById(network.getDataCenterId()).getName();	cmds.addCommand( "vmdata", generateVmDataCommand(nic.getIPv4Address(), userData, serviceOffering, zoneName, nic.getIPv4Address(), uservm.getHostName(), uservm.getInstanceName(), uservm.getId(), uservm.getUuid(), sshPublicKey));	try {	_agentManager.send(dest.getHost().getId(), cmds);	} catch (OperationTimedoutException e) {	return false;	}	Answer dataAnswer = cmds.getAnswer("vmdata");	if (dataAnswer != null && dataAnswer.getResult()) {	
sent vm data successfully to vm 

cmds.addCommand( "vmdata", generateVmDataCommand(nic.getIPv4Address(), userData, serviceOffering, zoneName, nic.getIPv4Address(), uservm.getHostName(), uservm.getInstanceName(), uservm.getId(), uservm.getUuid(), sshPublicKey));	try {	_agentManager.send(dest.getHost().getId(), cmds);	} catch (OperationTimedoutException e) {	return false;	}	Answer dataAnswer = cmds.getAnswer("vmdata");	if (dataAnswer != null && dataAnswer.getResult()) {	return true;	}	
failed to send vm data to vm 

========================= cloudstack sample_2308 =========================

public static void main(String[] args) {	begin = System.currentTimeMillis();	Runtime.getRuntime().addShutdownHook(new ShutdownThread(new ProxyLoadTemp()));	ConsoleProxy.proxyIp = "172-16-1-101";	try {	BufferedReader consoleInput = new BufferedReader(new FileReader("console.input"));	boolean eof = false;	
started reading file 

public static void main(String[] args) {	begin = System.currentTimeMillis();	Runtime.getRuntime().addShutdownHook(new ShutdownThread(new ProxyLoadTemp()));	ConsoleProxy.proxyIp = "172-16-1-101";	try {	BufferedReader consoleInput = new BufferedReader(new FileReader("console.input"));	boolean eof = false;	while (!eof) {	String line = consoleInput.readLine();	
line is 

public static void main(String[] args) {	begin = System.currentTimeMillis();	Runtime.getRuntime().addShutdownHook(new ShutdownThread(new ProxyLoadTemp()));	ConsoleProxy.proxyIp = "172-16-1-101";	try {	BufferedReader consoleInput = new BufferedReader(new FileReader("console.input"));	boolean eof = false;	while (!eof) {	String line = consoleInput.readLine();	if (line == null) {	
line is null 

try {	BufferedReader consoleInput = new BufferedReader(new FileReader("console.input"));	boolean eof = false;	while (!eof) {	String line = consoleInput.readLine();	if (line == null) {	eof = true;	} else {	String[] result = null;	try {	
starting parsing line 

BufferedReader consoleInput = new BufferedReader(new FileReader("console.input"));	boolean eof = false;	while (!eof) {	String line = consoleInput.readLine();	if (line == null) {	eof = true;	} else {	String[] result = null;	try {	result = parseLine(line, "[,]");	
line retrieved from the file is 

public void run() {	
program was running in threads 

public void run() {	for (int j = 0; j < proxyList.size(); j++) {	long av = 0;	if (proxyList.get(j).getConnectionsMade() != 0) {	av = proxyList.get(j).getResponseTime() / proxyList.get(j).getConnectionsMade();	}	
information for thread number of requests sent is average response time is milliseconds 

public void run() {	for (int j = 0; j < proxyList.size(); j++) {	long av = 0;	if (proxyList.get(j).getConnectionsMade() != 0) {	av = proxyList.get(j).getResponseTime() / proxyList.get(j).getConnectionsMade();	}	sum = sum + av;	}	ProxyLoadTemp.end = System.currentTimeMillis();	
summary for all threads average response time is milliseconds 

public void run() {	for (int j = 0; j < proxyList.size(); j++) {	long av = 0;	if (proxyList.get(j).getConnectionsMade() != 0) {	av = proxyList.get(j).getResponseTime() / proxyList.get(j).getConnectionsMade();	}	sum = sum + av;	}	ProxyLoadTemp.end = System.currentTimeMillis();	
test was running for seconds 

========================= cloudstack sample_443 =========================

eventDescription.put("id", vo.getUuid());	eventDescription.put("old-state", oldState.name());	eventDescription.put("new-state", newState.name());	eventDescription.put("status", status);	String eventDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").format(new Date());	eventDescription.put("eventDateTime", eventDate);	eventMsg.setDescription(eventDescription);	try {	s_eventBus.publish(eventMsg);	} catch (org.apache.cloudstack.framework.events.EventBusException e) {	
failed to publish state change event on the the event bus 

========================= cloudstack sample_2471 =========================

_ip = (String)params.get("ip");	_username = (String)params.get("username");	_password = (String)params.get("password");	_guid = (String)params.get("guid");	_privateNetworkName = (String)params.get("private.network.device");	_publicNetworkName = (String)params.get("public.network.device");	_guestNetworkName = (String)params.get("guest.network.device");	_agentUserName = (String)params.get("agentusername");	_agentPassword = (String)params.get("agentpassword");	} catch (Exception e) {	
configure failed 

}	if (_agentUserName == null) {	throw new ConfigurationException("Unable to get agent user name");	}	if (_agentPassword == null) {	throw new ConfigurationException("Unable to get agent password");	}	try {	setupServer();	} catch (Exception e) {	
setup server failed ip 

setupServer();	} catch (Exception e) {	throw new ConfigurationException("Unable to setup server");	}	_conn = new Connection(_ip, _agentUserName, _agentPassword);	try {	OvmHost.registerAsMaster(_conn);	OvmHost.registerAsVmServer(_conn);	_bridges = OvmBridge.getAllBridges(_conn);	} catch (XmlRpcException e) {	
get bridges failed 

if (_publicNetworkName != null && !_bridges.contains(_publicNetworkName)) {	throw new ConfigurationException("Cannot find bridge " + _publicNetworkName + " on host " + _ip + ", all bridges are:" + _bridges);	}	if (_guestNetworkName != null && !_bridges.contains(_guestNetworkName)) {	throw new ConfigurationException("Cannot find bridge " + _guestNetworkName + " on host " + _ip + ", all bridges are:" + _bridges);	}	s_isHeartBeat = false;	try {	_canBridgeFirewall = canBridgeFirewall();	} catch (XmlRpcException e) {	
failed to detect whether the host supports security groups 

if (_guestNetworkName != null && !_bridges.contains(_guestNetworkName)) {	throw new ConfigurationException("Cannot find bridge " + _guestNetworkName + " on host " + _ip + ", all bridges are:" + _bridges);	}	s_isHeartBeat = false;	try {	_canBridgeFirewall = canBridgeFirewall();	} catch (XmlRpcException e) {	_canBridgeFirewall = false;	}	_canBridgeFirewall = false;	
ovm host supports security groups ovm host doesn t support security groups 

_privateNetworkName = _publicNetworkName;	}	if (_guestNetworkName == null) {	_guestNetworkName = _privateNetworkName;	}	Map<String, String> d = cmd.getHostDetails();	d.put("public.network.device", _publicNetworkName);	d.put("private.network.device", _privateNetworkName);	d.put("guest.network.device", _guestNetworkName);	cmd.setHostDetails(d);	
add a ovm host s 

}	if (_guestNetworkName == null) {	_guestNetworkName = _privateNetworkName;	}	Map<String, String> d = cmd.getHostDetails();	d.put("public.network.device", _publicNetworkName);	d.put("private.network.device", _privateNetworkName);	d.put("guest.network.device", _guestNetworkName);	cmd.setHostDetails(d);	} catch (XmlRpcException e) {	
xml rpc exception 

}	File tmp = new File(configScriptPath);	File scriptDir = new File(tmp.getParent());	File[] scripts = scriptDir.listFiles();	for (int i = 0; i < scripts.length; i++) {	File script = scripts[i];	if (script.getName().equals("configureOvm.sh")) {	continue;	}	if (s_logger.isDebugEnabled()) {	
copying to on with permission 

public StartupCommand[] initialize() {	try {	StartupRoutingCommand cmd = new StartupRoutingCommand();	fillHostInfo(cmd);	cmd.setCaps("hvm");	return new StartupCommand[] {cmd};	} catch (Exception e) {	
ovm resource initializes failed 

public PingCommand getCurrentStatus(long id) {	try {	OvmHost.ping(_conn);	return new PingRoutingCommand(getType(), id, getHostVmStateReport());	} catch (XmlRpcException e) {	
check agent status failed 

protected ReadyAnswer execute(ReadyCommand cmd) {	try {	OvmHost.Details d = OvmHost.getDetails(_conn);	if (d.masterIp.equalsIgnoreCase(_ip)) {	return new ReadyAnswer(cmd);	} else {	
master ip changes to it should be 

protected ReadyAnswer execute(ReadyCommand cmd) {	try {	OvmHost.Details d = OvmHost.getDetails(_conn);	if (d.masterIp.equalsIgnoreCase(_ip)) {	return new ReadyAnswer(cmd);	} else {	return new ReadyAnswer(cmd, "I am not the master server");	}	} catch (XmlRpcException e) {	
xml rpc exception 

protected void createNfsSr(StorageFilerTO pool) throws XmlRpcException {	String mountPoint = String.format("%1$s:%2$s", pool.getHost(), pool.getPath());	OvmStoragePool.Details d = new OvmStoragePool.Details();	d.path = mountPoint;	d.type = OvmStoragePool.NFS;	d.uuid = pool.getUuid();	OvmStoragePool.create(_conn, d);	
created sr mount point s 

protected void createOCFS2Sr(StorageFilerTO pool) throws XmlRpcException {	OvmStoragePool.Details d = new OvmStoragePool.Details();	d.path = pool.getPath();	d.type = OvmStoragePool.OCFS2;	d.uuid = pool.getUuid();	OvmStoragePool.create(_conn, d);	
created sr mount point s 

private void setupHeartBeat(String poolUuid) {	try {	if (!s_isHeartBeat) {	OvmHost.setupHeartBeat(_conn, poolUuid, _ip);	s_isHeartBeat = true;	}	} catch (Exception e) {	
setup heart beat for failed 

createOCFS2Sr(pool);	} else {	return new Answer(cmd, false, "The pool type: " + pool.getType().name() + " is not supported.");	}	setupHeartBeat(pool.getUuid());	OvmStoragePool.Details d = OvmStoragePool.getDetailsByUuid(_conn, pool.getUuid());	Map<String, TemplateProp> tInfo = new HashMap<String, TemplateProp>();	ModifyStoragePoolAnswer answer = new ModifyStoragePoolAnswer(cmd, d.totalSpace, d.freeSpace, tInfo);	return answer;	} catch (Exception e) {	
modifystoragepoolcommand failed 

protected PrimaryStorageDownloadAnswer execute(final PrimaryStorageDownloadCommand cmd) {	try {	URI uri = new URI(cmd.getUrl());	String secondaryStoragePath = uri.getHost() + ":" + uri.getPath();	Pair<String, Long> res = OvmStoragePool.downloadTemplate(_conn, cmd.getPoolUuid(), secondaryStoragePath);	return new PrimaryStorageDownloadAnswer(res.first(), res.second());	} catch (Exception e) {	
primarystoragedownloadcommand failed 

try {	OvmVolume.Details vol = null;	if (cmd.getTemplateUrl() != null) {	vol = OvmVolume.createFromTemplate(_conn, primaryStorage.getUuid(), cmd.getTemplateUrl());	} else {	vol = OvmVolume.createDataDsik(_conn, primaryStorage.getUuid(), Long.toString(disk.getSize()), disk.getType() == Volume.Type.ROOT);	}	VolumeTO volume = new VolumeTO(cmd.getVolumeId(), disk.getType(), primaryStorage.getType(), primaryStorage.getUuid(), primaryStorage.getPath(), vol.name, vol.path, vol.size, null);	return new CreateAnswer(cmd, volume);	} catch (Exception e) {	
createcommand failed 

protected void cleanup(OvmVm.Details vm) {	try {	cleanupNetwork(vm.vifs);	} catch (XmlRpcException e) {	
clean up network for failed 

NicTO[] nics = vmSpec.getNics();	for (NicTO nic : nics) {	if (nic.isSecurityGroupEnabled()) {	if (vmSpec.getType().equals(VirtualMachine.Type.User)) {	defaultNetworkRulesForUserVm(vmName, vmSpec.getId(), nic);	}	}	}	return new StartAnswer(cmd);	} catch (Exception e) {	
start vm failed 

try {	Map<String, String> res = OvmHost.getPerformanceStats(_conn, _publicNetworkName);	Double cpuUtil = Double.parseDouble(res.get("cpuUtil"));	Double rxBytes = Double.parseDouble(res.get("rxBytes"));	Double txBytes = Double.parseDouble(res.get("txBytes"));	Double totalMemory = Double.parseDouble(res.get("totalMemory"));	Double freeMemory = Double.parseDouble(res.get("freeMemory"));	HostStatsEntry hostStats = new HostStatsEntry(cmd.getHostId(), cpuUtil, rxBytes, txBytes, "host", totalMemory, freeMemory, 0, 0);	return new GetHostStatsAnswer(cmd, hostStats);	} catch (Exception e) {	
get host stats of failed 

public StopAnswer execute(StopCommand cmd) {	String vmName = cmd.getVmName();	try {	OvmVm.Details vm = null;	try {	vm = OvmVm.getDetails(_conn, vmName);	} catch (XmlRpcException e) {	
unable to get details of vm treating it as stopped 

try {	vm = OvmVm.getDetails(_conn, vmName);	} catch (XmlRpcException e) {	return new StopAnswer(cmd, "success", true);	}	deleteAllNetworkRulesForVm(vmName);	OvmVm.stop(_conn, vmName);	cleanup(vm);	return new StopAnswer(cmd, "success", true);	} catch (Exception e) {	
stop failed 

public RebootAnswer execute(RebootCommand cmd) {	String vmName = cmd.getVmName();	try {	Map<String, String> res = OvmVm.reboot(_conn, vmName);	Integer vncPort = Integer.parseInt(res.get("vncPort"));	return new RebootAnswer(cmd, null, vncPort);	} catch (Exception e) {	
reboot failed 

private PowerState toPowerState(String vmName, String s) {	PowerState state = s_powerStateMaps.get(s);	if (state == null) {	
unkown state for 

protected GetStorageStatsAnswer execute(final GetStorageStatsCommand cmd) {	try {	OvmStoragePool.Details d = OvmStoragePool.getDetailsByUuid(_conn, cmd.getStorageId());	return new GetStorageStatsAnswer(cmd, d.totalSpace, d.usedSpace);	} catch (Exception e) {	
getstoragestatscommand on pool failed 

protected GetVmStatsAnswer execute(GetVmStatsCommand cmd) {	List<String> vmNames = cmd.getVmNames();	HashMap<String, VmStatsEntry> vmStatsNameMap = new HashMap<String, VmStatsEntry>();	for (String vmName : vmNames) {	try {	VmStatsEntry e = getVmStat(vmName);	vmStatsNameMap.put(vmName, e);	} catch (XmlRpcException e) {	
get vm stat for failed 

public Answer execute(DestroyCommand cmd) {	try {	OvmVolume.destroy(_conn, cmd.getVolume().getPoolUuid(), cmd.getVolume().getPath());	return new Answer(cmd, true, "Success");	} catch (Exception e) {	
destroy volume failed 

protected PrepareForMigrationAnswer execute(PrepareForMigrationCommand cmd) {	VirtualMachineTO vm = cmd.getVirtualMachine();	if (s_logger.isDebugEnabled()) {	
preparing host for migrating 

VirtualMachineTO vm = cmd.getVirtualMachine();	if (s_logger.isDebugEnabled()) {	}	NicTO[] nics = vm.getNics();	try {	for (NicTO nic : nics) {	getNetwork(nic);	}	return new PrepareForMigrationAnswer(cmd);	} catch (Exception e) {	
catch exception prepare for migration failed due to 

protected CheckVirtualMachineAnswer execute(final CheckVirtualMachineCommand cmd) {	final String vmName = cmd.getVmName();	try {	Map<String, String> res = OvmVm.register(_conn, vmName);	Integer vncPort = Integer.parseInt(res.get("vncPort"));	HashMap<String, PowerState> states = getAllVms();	PowerState vmPowerState = states.get(vmName);	if (vmPowerState == null) {	
check state of return null in checkvirtualmachinecommand 

try {	Map<String, String> res = OvmVm.register(_conn, vmName);	Integer vncPort = Integer.parseInt(res.get("vncPort"));	HashMap<String, PowerState> states = getAllVms();	PowerState vmPowerState = states.get(vmName);	if (vmPowerState == null) {	vmPowerState = PowerState.PowerOff;	}	return new CheckVirtualMachineAnswer(cmd, vmPowerState, vncPort);	} catch (Exception e) {	
check migration for failed 

protected GetVncPortAnswer execute(GetVncPortCommand cmd) {	try {	Integer vncPort = OvmVm.getVncPort(_conn, cmd.getName());	return new GetVncPortAnswer(cmd, _ip, vncPort);	} catch (Exception e) {	
get vnc port for failed 

protected Answer execute(PingTestCommand cmd) {	try {	if (cmd.getComputingHostIp() != null) {	OvmHost.pingAnotherHost(_conn, cmd.getComputingHostIp());	} else {	return new Answer(cmd, false, "why asks me to ping router???");	}	return new Answer(cmd, true, "success");	} catch (Exception e) {	
ping failed 

protected FenceAnswer execute(FenceCommand cmd) {	try {	Boolean res = OvmHost.fence(_conn, cmd.getHostIp());	return new FenceAnswer(cmd, res, res.toString());	} catch (Exception e) {	
fence failed 

protected Answer execute(AttachIsoCommand cmd) {	try {	URI iso = new URI(cmd.getIsoPath());	String isoPath = iso.getHost() + ":" + iso.getPath();	OvmVm.detachOrAttachIso(_conn, cmd.getVmName(), isoPath, cmd.isAttach());	return new Answer(cmd);	} catch (Exception e) {	
attach or detach iso for attach failed 

try {	OvmVif.Details vif = getVifFromVm(cmd.getVmName(), null);	String vifDeviceName = vif.name;	String bridgeName = vif.bridge;	result = addNetworkRules(cmd.getVmName(), Long.toString(cmd.getVmId()), cmd.getGuestIp(), cmd.getSignature(), String.valueOf(cmd.getSeqNum()), cmd.getGuestMac(), cmd.stringifyRules(), vifDeviceName, bridgeName);	} catch (XmlRpcException e) {	s_logger.error(e);	result = false;	}	if (!result) {	
failed to program network rules for vm 

protected OvmVif.Details getVifFromVm(String vmName, Integer deviceId) throws XmlRpcException {	List<OvmVif.Details> vifs = null;	try {	vifs = getInterfaces(vmName);	} catch (XmlRpcException e) {	
failed to get vifs for vm 

StringBuffer params = new StringBuffer();	for (Ternary<Integer, String, String> node : nodes) {	String param = String.format("%1$s:%2$s:%3$s", node.first(), node.second(), node.third());	params.append(param);	params.append(";");	}	try {	OvmStoragePool.prepareOCFS2Nodes(_conn, cmd.getClusterName(), params.toString());	return new Answer(cmd, true, "Success");	} catch (XmlRpcException e) {	
prepare nodes failed 

wait = 7200;	}	try {	URI uri;	uri = new URI(secondaryStorageUrl);	String secondaryStorageMountPath = uri.getHost() + ":" + uri.getPath();	String installPath = "template/tmpl/" + accountId + "/" + templateId;	Map<String, String> res = OvmStoragePool.createTemplateFromVolume(_conn, secondaryStorageMountPath, installPath, volumePath, wait);	return new CreatePrivateTemplateAnswer(cmd, true, null, res.get("installPath"), Long.parseLong(res.get("virtualSize")), Long.parseLong(res.get("physicalSize")), res.get("templateFileName"), ImageFormat.RAW);	} catch (Exception e) {	
create template failed 

}	try {	URI uri = new URI(secondaryStorageURL);	String secStorageMountPath = uri.getHost() + ":" + uri.getPath();	String volumeFolderOnSecStorage = "volumes/" + String.valueOf(cmd.getVolumeId());	String storagePoolUuid = cmd.getPool().getUuid();	Boolean toSec = cmd.toSecondaryStorage();	String res = OvmStoragePool.copyVolume(_conn, secStorageMountPath, volumeFolderOnSecStorage, volumePath, storagePoolUuid, toSec, wait);	return new CopyVolumeAnswer(cmd, true, null, null, res);	} catch (Exception e) {	
copy volume failed 

protected Answer execute(DeleteStoragePoolCommand cmd) {	try {	OvmStoragePool.delete(_conn, cmd.getPool().getUuid());	} catch (Exception e) {	
delete storage pool on host failed however we leave to user for cleanup and tell managment server it succeeded 

protected CheckNetworkAnswer execute(CheckNetworkCommand cmd) {	if (s_logger.isDebugEnabled()) {	
checking if network name setup is done on the resource 

private boolean isNetworkSetupByName(String nameTag) {	if (nameTag != null) {	if (s_logger.isDebugEnabled()) {	
looking for network setup by name 

========================= cloudstack sample_1123 =========================

pool = LibvirtConnection.getConnection().storagePoolLookupByUUIDString(storagePool._poolUUID);	if (pool != null) {	StoragePoolInfo spi = pool.getInfo();	if (spi.state != StoragePoolState.VIR_STORAGE_POOL_RUNNING) {	pool.create(0);	} else {	}	poolName = pool.getName();	}	} catch (LibvirtException e) {	
ignoring libvirt error 

}	poolName = pool.getName();	}	} catch (LibvirtException e) {	} finally {	try {	if (pool != null) {	pool.free();	}	} catch (LibvirtException e) {	
ignoring libvirt error 

========================= cloudstack sample_1089 =========================

if (allHosts.size() <= avLoad) {	s_logger.debug("Agent load = " + allHosts.size() + " for management server " + msId + " doesn't exceed average system agent load = " + avLoad + "; so it doesn't participate in agent rebalancing process");	return null;	}	sc = QueryBuilder.create(HostVO.class);	sc.and(sc.entity().getManagementServerId(), Op.EQ, msId);	sc.and(sc.entity().getType(), Op.EQ, Host.Type.Routing);	sc.and(sc.entity().getStatus(), Op.EQ, Status.Up);	List<HostVO> directHosts = sc.list();	if (directHosts.isEmpty()) {	
no direct agents in status exist for the management server so it doesn t participate in agent rebalancing process 

directHostsPerCluster = hostToClusterMap.get(clusterId);	}	directHostsPerCluster.add(directHost);	hostToClusterMap.put(clusterId, directHostsPerCluster);	}	hostToClusterMap = sortByClusterSize(hostToClusterMap);	int hostsToGive = allHosts.size() - avLoad;	int hostsLeftToGive = hostsToGive;	int hostsLeft = directHosts.size();	List<HostVO> hostsToReturn = new ArrayList<HostVO>();	
management server can give away as it currently owns and the average agent load in the system is finalyzing list of hosts to give away 

}	} else {	s_logger.debug("Taking all " + hostsInCluster.size() + " hosts: " + hostsInCluster + " from cluster id=" + cluster);	hostsToReturn.addAll(hostsInCluster);	hostsLeftToGive = hostsLeftToGive - hostsInCluster.size();	}	} else {	break;	}	}	
management server is ready to give away hosts 

========================= cloudstack sample_4771 =========================

private Answer retry(Command cmd, int numRetries) {	int numRetriesRemaining = numRetries - 1;	
retrying number of retries remaining 

private boolean shouldRetry(int numRetries) {	try {	if (numRetries > 0) {	login();	return true;	}	} catch (Exception e) {	
failed to log in to device at due to 

String vlanSelfIp = inline ? tagAddressWithRouteDomain(ip.getVlanGateway(), guestVlanTag) : ip.getVlanGateway();	String vlanNetmask = ip.getVlanNetmask();	deleteGuestVlan(guestVlanTag, vlanSelfIp, vlanNetmask, inline);	if (ip.isAdd()) {	addGuestVlan(guestVlanTag, vlanSelfIp, vlanNetmask, inline);	}	saveConfiguration();	results[i++] = ip.getPublicIp() + " - success";	}	} catch (ExecutionException e) {	
failed to execute ipassoccommand due to 

addPoolMember(virtualServerName, destIp, destination.getDestPort());	activePoolMembers.add(destIp + "-" + destination.getDestPort());	}	}	addVirtualServer(virtualServerName, lbProtocol, srcIp, srcPort, loadBalancer.getStickinessPolicies());	}	}	saveConfiguration();	return new Answer(cmd);	} catch (ExecutionException e) {	
failed to execute loadbalancerconfigcommand due to 

private void saveConfiguration() throws ExecutionException {	try {	_configSyncApi.save_configuration("", SystemConfigSyncSaveMode.SAVE_BASE_LEVEL_CONFIG);	_configSyncApi.save_configuration("", SystemConfigSyncSaveMode.SAVE_HIGH_LEVEL_CONFIG);	
successfully saved bigip configuration 

private void saveConfiguration() throws ExecutionException {	try {	_configSyncApi.save_configuration("", SystemConfigSyncSaveMode.SAVE_BASE_LEVEL_CONFIG);	_configSyncApi.save_configuration("", SystemConfigSyncSaveMode.SAVE_HIGH_LEVEL_CONFIG);	} catch (RemoteException e) {	
failed to save bigip configuration due to 

String vlanName = genVlanName(vlanTag);	List<String> allVlans = getStrippedVlans();	if (!allVlans.contains(vlanName)) {	String[] vlanNames = genStringArray(vlanName);	long[] vlanTags = genLongArray(vlanTag);	CommonEnabledState[] commonEnabledState = {CommonEnabledState.STATE_DISABLED};	NetworkingVLANMemberEntry[][] vlanMemberEntries = {{new NetworkingVLANMemberEntry()}};	vlanMemberEntries[0][0].setMember_type(NetworkingMemberType.MEMBER_INTERFACE);	vlanMemberEntries[0][0].setTag_state(NetworkingMemberTagType.MEMBER_TAGGED);	vlanMemberEntries[0][0].setMember_name(_privateInterface);	
creating a guest vlan with tag 

List<String> allVlans = getStrippedVlans();	if (!allVlans.contains(vlanName)) {	String[] vlanNames = genStringArray(vlanName);	long[] vlanTags = genLongArray(vlanTag);	CommonEnabledState[] commonEnabledState = {CommonEnabledState.STATE_DISABLED};	NetworkingVLANMemberEntry[][] vlanMemberEntries = {{new NetworkingVLANMemberEntry()}};	vlanMemberEntries[0][0].setMember_type(NetworkingMemberType.MEMBER_INTERFACE);	vlanMemberEntries[0][0].setTag_state(NetworkingMemberTagType.MEMBER_TAGGED);	vlanMemberEntries[0][0].setMember_name(_privateInterface);	_vlanApi.create(vlanNames, vlanTags, vlanMemberEntries, commonEnabledState, new long[] {10L}, new String[] {"00:00:00:00:00:00"});	
vlanname 

List<String> allVlans = getStrippedVlans();	if (!allVlans.contains(vlanName)) {	String[] vlanNames = genStringArray(vlanName);	long[] vlanTags = genLongArray(vlanTag);	CommonEnabledState[] commonEnabledState = {CommonEnabledState.STATE_DISABLED};	NetworkingVLANMemberEntry[][] vlanMemberEntries = {{new NetworkingVLANMemberEntry()}};	vlanMemberEntries[0][0].setMember_type(NetworkingMemberType.MEMBER_INTERFACE);	vlanMemberEntries[0][0].setTag_state(NetworkingMemberTagType.MEMBER_TAGGED);	vlanMemberEntries[0][0].setMember_name(_privateInterface);	_vlanApi.create(vlanNames, vlanTags, vlanMemberEntries, commonEnabledState, new long[] {10L}, new String[] {"00:00:00:00:00:00"});	
getstrippedvlans 

_vlanApi.create(vlanNames, vlanTags, vlanMemberEntries, commonEnabledState, new long[] {10L}, new String[] {"00:00:00:00:00:00"});	if (!getStrippedVlans().contains(vlanName)) {	throw new ExecutionException("Failed to create vlan with tag " + vlanTag);	}	}	if (inline) {	List<Long> allRouteDomains = getRouteDomains();	if (!allRouteDomains.contains(vlanTag)) {	long[] routeDomainIds = genLongArray(vlanTag);	String[][] vlanNames = new String[][] {genStringArray(genVlanName(vlanTag))};	
creating route domain 

}	}	}	List<String> allSelfIps = getSelfIps();	if (!allSelfIps.contains(vlanSelfIp)) {	String[] selfIpsToCreate = genStringArray(vlanSelfIp);	String[] vlans = genStringArray(vlanName);	String[] netmasks = genStringArray(vlanNetmask);	long[] unitIds = genLongArray(0L);	CommonEnabledState[] enabledStates = new CommonEnabledState[] {CommonEnabledState.STATE_DISABLED};	
creating self ip 

private void deleteGuestVlan(long vlanTag, String vlanSelfIp, String vlanNetmask, boolean inline) throws ExecutionException {	try {	deleteVirtualServersInGuestVlan(vlanSelfIp, vlanNetmask);	List<String> allSelfIps = getSelfIps();	if (allSelfIps.contains(vlanSelfIp)) {	
deleting self ip 

List<String> allSelfIps = getSelfIps();	if (allSelfIps.contains(vlanSelfIp)) {	_selfIpApi.delete_self_ip(genStringArray(vlanSelfIp));	if (getSelfIps().contains(vlanSelfIp)) {	throw new ExecutionException("Failed to delete self IP " + vlanSelfIp);	}	}	if (inline) {	List<Long> allRouteDomains = getRouteDomains();	if (allRouteDomains.contains(vlanTag)) {	
deleting route domain 

List<String> poolMembers = getMembers(virtualServerName);	for (String poolMemberName : poolMembers) {	String poolMemberIp = stripRouteDomainFromAddress(getIpAndPort(poolMemberName)[0]);	if (NetUtils.sameSubnet(vlanSelfIp, poolMemberIp, vlanNetmask)) {	virtualServersToDelete.add(virtualServerName);	break;	}	}	}	for (String virtualServerName : virtualServersToDelete) {	
found a virtual server for guest network with self ip that is active when the guest network is being destroyed 

private void addVirtualServer(String virtualServerName, LbProtocol protocol, String srcIp, int srcPort, StickinessPolicyTO[] stickyPolicies) throws ExecutionException {	try {	if (!virtualServerExists(virtualServerName)) {	
adding virtual server 

private void deleteVirtualServerAndDefaultPool(String virtualServerName) throws ExecutionException {	try {	if (virtualServerExists(virtualServerName)) {	List<String> poolMembers = getMembers(virtualServerName);	for (String poolMember : poolMembers) {	String[] destIpAndPort = getIpAndPort(poolMember);	deletePoolMember(virtualServerName, destIpAndPort[0], Integer.parseInt(destIpAndPort[1]));	}	
deleting virtual server 

private void addPool(String virtualServerName, LbAlgorithm algorithm) throws ExecutionException {	try {	if (!poolExists(virtualServerName)) {	if (algorithm.getPersistenceProfileName() != null) {	algorithm = LbAlgorithm.RoundRobin;	}	
adding pool for virtual server with algorithm 

private void deletePool(String virtualServerName) throws ExecutionException {	try {	if (poolExists(virtualServerName) && getMembers(virtualServerName).size() == 0) {	
deleting pool for virtual server 

private void addPoolMember(String virtualServerName, String destIp, int destPort) throws ExecutionException {	try {	String memberIdentifier = destIp + "-" + destPort;	if (poolExists(virtualServerName) && !memberExists(virtualServerName, memberIdentifier)) {	
adding member into pool for virtual server 

private void deletePoolMember(String virtualServerName, String destIp, int destPort) throws ExecutionException {	try {	String memberIdentifier = destIp + "-" + destPort;	List<String> lbPools = getAllStrippedLbPools();	if (lbPools.contains(virtualServerName) && memberExists(virtualServerName, memberIdentifier)) {	
deleting member from pool for virtual server 

boolean nodeNeeded = false;	done: for (String poolToCheck : lbPools) {	for (String memberInPool : getMembers(poolToCheck)) {	if (getIpAndPort(memberInPool)[0].equals(destIp)) {	nodeNeeded = true;	break done;	}	}	}	if (!nodeNeeded) {	
deleting node 

========================= cloudstack sample_1573 =========================

private Merovingian2(long msId) {	super(MerovingianMBean.class, false);	_msId = msId;	Connection conn = null;	try {	conn = TransactionLegacy.getStandaloneConnectionWithException();	conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);	conn.setAutoCommit(true);	_concierge = new ConnectionConcierge("LockMaster", conn, true);	} catch (SQLException e) {	
unable to get a new db connection 

conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);	conn.setAutoCommit(true);	_concierge = new ConnectionConcierge("LockMaster", conn, true);	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to initialize a connection to the database for locking purposes", e);	} finally {	if (_concierge == null && conn != null) {	try {	conn.close();	} catch (SQLException e) {	
closing connection failed after everything else 

public static synchronized Merovingian2 createLockMaster(long msId) {	assert s_instance == null : "No lock can serve two masters.  Either he will hate the one and love the other, or he will be devoted to the one and despise the other.";	s_instance = new Merovingian2(msId);	s_instance.cleanupThisServer();	try {	JmxUtil.registerMBean("Locks", "Locks", s_instance);	} catch (Exception e) {	
unable to register for jmx 

public boolean acquire(String key, int timeInSeconds) {	Thread th = Thread.currentThread();	String threadName = th.getName();	int threadId = System.identityHashCode(th);	if (s_logger.isTraceEnabled()) {	
acquiring lck with wait time of 

int count = owns(key);	if (count >= 1) {	return increment(key, threadName, threadId);	} else if (count == 0) {	if (doAcquire(key, threadName, threadId)) {	return true;	}	}	try {	if (s_logger.isTraceEnabled()) {	
sleeping more time while waiting for lck 

} else if (count == 0) {	if (doAcquire(key, threadName, threadId)) {	return true;	}	}	try {	if (s_logger.isTraceEnabled()) {	}	Thread.sleep(5000);	} catch (InterruptedException e) {	
ignored interupted while aquiring 

assert (rows <= 1) : "hmm...non unique key? " + pstmt;	if (s_logger.isTraceEnabled()) {	s_logger.trace("lck-" + key + (rows == 1 ? " acquired again" : " failed to acquire again"));	}	if (rows == 1) {	incrCount();	return true;	}	return false;	} catch (Exception e) {	
increment exception 

try(PreparedStatement pstmt = _concierge.conn().prepareStatement(ACQUIRE_SQL);) {	pstmt.setString(1, key);	pstmt.setLong(2, _msId);	pstmt.setString(3, threadName);	pstmt.setInt(4, threadId);	pstmt.setString(5, DateUtil.getDateDisplayString(_gmtTimeZone, new Date()));	try {	int rows = pstmt.executeUpdate();	if (rows == 1) {	if (s_logger.isTraceEnabled()) {	
acquired for lck 

}	incrCount();	return true;	}	} catch (SQLException e) {	if (!(e.getSQLState().equals("23000") && e.getErrorCode() == 1062)) {	throw new CloudRuntimeException("Unable to lock " + key + ".  Waited " + (InaccurateClock.getTime() - startTime), e);	}	}	} catch (SQLException e) {	
doacquire exception 

return true;	}	} catch (SQLException e) {	if (!(e.getSQLState().equals("23000") && e.getErrorCode() == 1062)) {	throw new CloudRuntimeException("Unable to lock " + key + ".  Waited " + (InaccurateClock.getTime() - startTime), e);	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to lock " + key + ".  Waited " + (InaccurateClock.getTime() - startTime), e);	}	
unable to acquire lck 

protected Map<String, String> isLocked(String key) {	try (PreparedStatement pstmt = _concierge.conn().prepareStatement(INQUIRE_SQL);){	pstmt.setString(1, key);	try(ResultSet rs = pstmt.executeQuery();) {	if (!rs.next()) {	return null;	}	return toLock(rs);	}catch (SQLException e) {	
islocked exception 

pstmt.setString(1, key);	try(ResultSet rs = pstmt.executeQuery();) {	if (!rs.next()) {	return null;	}	return toLock(rs);	}catch (SQLException e) {	throw new CloudRuntimeException("isLocked:Exception:"+e.getMessage(), e);	}	} catch (SQLException e) {	
islocked exception 

public void cleanupForServer(long msId) {	
cleaning up locks for 

public void cleanupForServer(long msId) {	try {	synchronized (_concierge.conn()) {	try(PreparedStatement pstmt = _concierge.conn().prepareStatement(CLEANUP_MGMT_LOCKS_SQL);) {	pstmt.setLong(1, msId);	int rows = pstmt.executeUpdate();	
released locks for 

public void cleanupForServer(long msId) {	try {	synchronized (_concierge.conn()) {	try(PreparedStatement pstmt = _concierge.conn().prepareStatement(CLEANUP_MGMT_LOCKS_SQL);) {	pstmt.setLong(1, msId);	int rows = pstmt.executeUpdate();	}catch (Exception e) {	
cleanupforserver exception 

try {	synchronized (_concierge.conn()) {	try(PreparedStatement pstmt = _concierge.conn().prepareStatement(CLEANUP_MGMT_LOCKS_SQL);) {	pstmt.setLong(1, msId);	int rows = pstmt.executeUpdate();	}catch (Exception e) {	throw new CloudRuntimeException("cleanupForServer:Exception:"+e.getMessage(), e);	}	}	} catch (Exception e) {	
cleanupforserver exception 

String threadName = th.getName();	int threadId = System.identityHashCode(th);	try (PreparedStatement pstmt = _concierge.conn().prepareStatement(DECREMENT_SQL);) {	pstmt.setString(1, key);	pstmt.setLong(2, _msId);	pstmt.setString(3, threadName);	pstmt.setLong(4, threadId);	int rows = pstmt.executeUpdate();	assert (rows <= 1) : "hmmm....keys not unique? " + pstmt;	if (s_logger.isTraceEnabled()) {	
lck released 

int rows = pstmt.executeUpdate();	assert (rows <= 1) : "hmmm....keys not unique? " + pstmt;	if (s_logger.isTraceEnabled()) {	}	if (rows == 1) {	try (PreparedStatement rel_sql_pstmt = _concierge.conn().prepareStatement(RELEASE_SQL);) {	rel_sql_pstmt.setString(1, key);	rel_sql_pstmt.setLong(2, _msId);	int result = rel_sql_pstmt.executeUpdate();	if (result == 1 && s_logger.isTraceEnabled()) {	
lck removed 

}	if (rows == 1) {	try (PreparedStatement rel_sql_pstmt = _concierge.conn().prepareStatement(RELEASE_SQL);) {	rel_sql_pstmt.setString(1, key);	rel_sql_pstmt.setLong(2, _msId);	int result = rel_sql_pstmt.executeUpdate();	if (result == 1 && s_logger.isTraceEnabled()) {	}	decrCount();	}catch (Exception e) {	
release exception 

}catch (Exception e) {	throw new CloudRuntimeException("release:Exception:"+ e.getMessage(), e);	}	} else if (rows < 1) {	String msg = ("Was unable to find lock for the key " + key + " and thread id " + threadId);	Exception e = new CloudRuntimeException(msg);	s_logger.warn(msg, e);	}	return rows == 1;	} catch (Exception e) {	
release exception 

protected List<Map<String, String>> getLocks(String sql, Long msId) {	try (PreparedStatement pstmt = _concierge.conn().prepareStatement(sql);) {	if (msId != null) {	pstmt.setLong(1, msId);	}	try(ResultSet rs = pstmt.executeQuery();) {	return toLocks(rs);	}catch (Exception e) {	
getlocks exception 

try (PreparedStatement pstmt = _concierge.conn().prepareStatement(sql);) {	if (msId != null) {	pstmt.setLong(1, msId);	}	try(ResultSet rs = pstmt.executeQuery();) {	return toLocks(rs);	}catch (Exception e) {	throw new CloudRuntimeException("getLocks:Exception:"+e.getMessage(), e);	}	} catch (Exception e) {	
getlocks exception 

public List<Map<String, String>> getLocksAcquiredBy(long msId, String threadName) {	try (PreparedStatement pstmt = _concierge.conn().prepareStatement(SELECT_THREAD_LOCKS_SQL);){	pstmt.setLong(1, msId);	pstmt.setString(2, threadName);	try (ResultSet rs =pstmt.executeQuery();) {	return toLocks(rs);	}	catch (Exception e) {	
getlocksacquiredby exception 

try (PreparedStatement pstmt = _concierge.conn().prepareStatement(SELECT_THREAD_LOCKS_SQL);){	pstmt.setLong(1, msId);	pstmt.setString(2, threadName);	try (ResultSet rs =pstmt.executeQuery();) {	return toLocks(rs);	}	catch (Exception e) {	throw new CloudRuntimeException("Can't get locks " + pstmt, e);	}	} catch (Exception e) {	
getlocksacquiredby exception 

Thread th = Thread.currentThread();	String threadName = th.getName();	int threadId = System.identityHashCode(th);	try (PreparedStatement pstmt = _concierge.conn().prepareStatement(CLEANUP_THREAD_LOCKS_SQL);) {	pstmt.setLong(1, _msId);	pstmt.setString(2, threadName);	pstmt.setInt(3, threadId);	int rows = pstmt.executeUpdate();	assert (false) : "Abandon hope, all ye who enter here....There were still " + rows + ":" + c + " locks not released when the transaction ended, check for lock not released or @DB is not added to the code that using the locks!";	} catch (Exception e) {	
cleanupthread exception 

public boolean releaseLockAsLastResortAndIReallyKnowWhatIAmDoing(String key) {	
releasing a lock from jmx lck 

public boolean releaseLockAsLastResortAndIReallyKnowWhatIAmDoing(String key) {	try (PreparedStatement pstmt = _concierge.conn().prepareStatement(RELEASE_LOCK_SQL);) {	pstmt.setString(1, key);	int rows = pstmt.executeUpdate();	return rows > 0;	} catch (Exception e) {	
releaselockaslastresortandireallyknowwhatiamdoing exception 

========================= cloudstack sample_551 =========================

public Answer execute(final OvsFetchInterfaceCommand command, final LibvirtComputingResource libvirtComputingResource) {	final String label = command.getLabel();	
will look for network with name label 

public Answer execute(final OvsFetchInterfaceCommand command, final LibvirtComputingResource libvirtComputingResource) {	final String label = command.getLabel();	try {	final String ipadd = Script.runSimpleBashScript("ifconfig " + label + " | grep 'inet addr:' | cut -d: -f2 | awk '{ print $1}'");	final String mask = Script.runSimpleBashScript("ifconfig " + label + " | grep 'inet addr:' | cut -d: -f4");	final String mac = Script.runSimpleBashScript("ifconfig " + label + " | grep HWaddr | awk -F \" \" '{print $5}'");	return new OvsFetchInterfaceAnswer(command, true, "Interface " + label + " retrieved successfully", ipadd, mask, mac);	} catch (final Exception e) {	
caught execption when fetching interface 

========================= cloudstack sample_1066 =========================

protected void init() throws IOException {	_selector = Selector.open();	Task task = null;	try {	_clientConnection = SocketChannel.open();	
connecting to 

_clientConnection = SocketChannel.open();	final InetSocketAddress peerAddr = new InetSocketAddress(_host, _port);	_clientConnection.connect(peerAddr);	_clientConnection.configureBlocking(false);	final SSLContext sslContext = Link.initSSLContext(true);	SSLEngine sslEngine = sslContext.createSSLEngine(_host, _port);	sslEngine.setUseClientMode(true);	sslEngine.setEnabledProtocols(SSLUtils.getSupportedProtocols(sslEngine.getEnabledProtocols()));	sslEngine.beginHandshake();	if (!Link.doHandshake(_clientConnection, sslEngine, true)) {	
ssl handshake failed while connecting to host port 

_clientConnection.configureBlocking(false);	final SSLContext sslContext = Link.initSSLContext(true);	SSLEngine sslEngine = sslContext.createSSLEngine(_host, _port);	sslEngine.setUseClientMode(true);	sslEngine.setEnabledProtocols(SSLUtils.getSupportedProtocols(sslEngine.getEnabledProtocols()));	sslEngine.beginHandshake();	if (!Link.doHandshake(_clientConnection, sslEngine, true)) {	_selector.close();	throw new IOException("SSL Handshake failed while connecting to host: " + _host + " port: " + _port);	}	
ssl handshake done 

_clientConnection.configureBlocking(false);	final SSLContext sslContext = Link.initSSLContext(true);	SSLEngine sslEngine = sslContext.createSSLEngine(_host, _port);	sslEngine.setUseClientMode(true);	sslEngine.setEnabledProtocols(SSLUtils.getSupportedProtocols(sslEngine.getEnabledProtocols()));	sslEngine.beginHandshake();	if (!Link.doHandshake(_clientConnection, sslEngine, true)) {	_selector.close();	throw new IOException("SSL Handshake failed while connecting to host: " + _host + " port: " + _port);	}	
connected to 

public void cleanUp() throws IOException {	super.cleanUp();	if (_clientConnection != null) {	_clientConnection.close();	}	
nioclient connection closed 

========================= cloudstack sample_2830 =========================

protected List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	
localstoragepoolallocator trying to find storage pool to fit the vm 

protected List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	if (!dskCh.useLocalStorage()) {	return null;	}	if (s_logger.isTraceEnabled()) {	List<StoragePoolVO> disabledPools = _storagePoolDao.findDisabledPoolsByScope(plan.getDataCenterId(), plan.getPodId(), plan.getClusterId(), ScopeType.HOST);	if (disabledPools != null && !disabledPools.isEmpty()) {	for (StoragePoolVO pool : disabledPools) {	
ignoring pool as it is in disabled state 

}	}	}	List<StoragePool> suitablePools = new ArrayList<StoragePool>();	if (plan.getHostId() != null) {	List<StoragePoolVO> hostTagsPools = _storagePoolDao.findLocalStoragePoolsByHostAndTags(plan.getHostId(), dskCh.getTags());	for (StoragePoolVO pool : hostTagsPools) {	if (pool != null && pool.isLocal()) {	StoragePool storagePool = (StoragePool)this.dataStoreMgr.getPrimaryDataStore(pool.getId());	if (filter(avoid, storagePool, dskCh, plan)) {	
found suitable local storage pool adding to list 

avoid.addPool(pool.getId());	}	}	List<StoragePoolVO> allPools = _storagePoolDao.findLocalStoragePoolsByTags(plan.getDataCenterId(), plan.getPodId(), plan.getClusterId(), null);	allPools.removeAll(availablePools);	for (StoragePoolVO pool : allPools) {	avoid.addPool(pool.getId());	}	}	if (s_logger.isDebugEnabled()) {	
localstoragepoolallocator returning suitable storage pools 

========================= cloudstack sample_4008 =========================

try {	Vlan result = _configService.createVlanAndPublicIpRange(this);	if (result != null) {	VlanIpRangeResponse response = _responseGenerator.createVlanIpRangeResponse(result);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create vlan ip range");	}	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3237 =========================

public boolean deleteFolder(String folder, ManagedObjectReference morDc) throws Exception {	ManagedObjectReference morFileManager = _context.getServiceContent().getFileManager();	ManagedObjectReference morTask = _context.getService().deleteDatastoreFileTask(morFileManager, folder, morDc);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware deletedatastorefile task failed due to 

try {	if (testExistence && !fileExists(fullPath)) {	String searchResult = searchFileInSubFolders(file.getFileName(), true);	if (searchResult == null) {	return true;	} else {	fullPath = searchResult;	}	}	} catch (Exception e) {	
unable to test file existence due to exception skip deleting of it 

}	} catch (Exception e) {	return true;	}	ManagedObjectReference morTask = _context.getService().deleteDatastoreFileTask(morFileManager, fullPath, morDc);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware deletedatastorefile task failed due to 

String srcFullPath = srcFilePath;	if (!DatastoreFile.isFullDatastorePath(srcFullPath)) srcFullPath = String.format("[%s] %s", srcDsName, srcFilePath);	String destFullPath = destFilePath;	if (!DatastoreFile.isFullDatastorePath(destFullPath)) destFullPath = String.format("[%s] %s", destDsName, destFilePath);	ManagedObjectReference morTask = _context.getService().copyDatastoreFileTask(morFileManager, srcFullPath, morSrcDc, destFullPath, morDestDc, forceOverwrite);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware copydatastorefile task failed due to 

String srcFullPath = srcFilePath;	if (!DatastoreFile.isFullDatastorePath(srcFullPath)) srcFullPath = String.format("[%s] %s", srcDsName, srcFilePath);	String destFullPath = destFilePath;	if (!DatastoreFile.isFullDatastorePath(destFullPath)) destFullPath = String.format("[%s] %s", destDsName, destFilePath);	ManagedObjectReference morTask = _context.getService().moveDatastoreFileTask(morFileManager, srcFullPath, morSrcDc, destFullPath, morDestDc, forceOverwrite);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware movedatgastorefile task failed due to 

public boolean fileExists(String fileFullPath) throws Exception {	DatastoreFile file = new DatastoreFile(fileFullPath);	DatastoreFile dirFile = new DatastoreFile(file.getDatastoreName(), file.getDir());	HostDatastoreBrowserMO browserMo = getHostDatastoreBrowserMO();	
search file on 

public boolean fileExists(String fileFullPath) throws Exception {	DatastoreFile file = new DatastoreFile(fileFullPath);	DatastoreFile dirFile = new DatastoreFile(file.getDatastoreName(), file.getDir());	HostDatastoreBrowserMO browserMo = getHostDatastoreBrowserMO();	HostDatastoreBrowserSearchResults results = browserMo.searchDatastore(dirFile.getPath(), file.getFileName(), true);	if (results != null) {	List<FileInfo> info = results.getFile();	if (info != null && info.size() > 0) {	
file exists on datastore 

DatastoreFile file = new DatastoreFile(fileFullPath);	DatastoreFile dirFile = new DatastoreFile(file.getDatastoreName(), file.getDir());	HostDatastoreBrowserMO browserMo = getHostDatastoreBrowserMO();	HostDatastoreBrowserSearchResults results = browserMo.searchDatastore(dirFile.getPath(), file.getFileName(), true);	if (results != null) {	List<FileInfo> info = results.getFile();	if (info != null && info.size() > 0) {	return true;	}	}	
file does not exist on datastore 

public boolean folderExists(String folderParentDatastorePath, String folderName) throws Exception {	HostDatastoreBrowserMO browserMo = getHostDatastoreBrowserMO();	HostDatastoreBrowserSearchResults results = browserMo.searchDatastore(folderParentDatastorePath, folderName, true);	if (results != null) {	List<FileInfo> info = results.getFile();	if (info != null && info.size() > 0) {	
folder exists on datastore 

public boolean folderExists(String folderParentDatastorePath, String folderName) throws Exception {	HostDatastoreBrowserMO browserMo = getHostDatastoreBrowserMO();	HostDatastoreBrowserSearchResults results = browserMo.searchDatastore(folderParentDatastorePath, folderName, true);	if (results != null) {	List<FileInfo> info = results.getFile();	if (info != null && info.size() > 0) {	return true;	}	}	
folder does not exist on datastore 

public String searchFileInSubFolders(String fileName, boolean caseInsensitive) throws Exception {	String datastorePath = "[" + getName() + "]";	String rootDirectoryFilePath = String.format("%s %s", datastorePath, fileName);	if (fileExists(rootDirectoryFilePath)) {	return rootDirectoryFilePath;	}	String parentFolderPath = null;	String absoluteFileName = null;	
searching file in 

String datastorePath = "[" + getName() + "]";	String rootDirectoryFilePath = String.format("%s %s", datastorePath, fileName);	if (fileExists(rootDirectoryFilePath)) {	return rootDirectoryFilePath;	}	String parentFolderPath = null;	String absoluteFileName = null;	HostDatastoreBrowserMO browserMo = getHostDatastoreBrowserMO();	ArrayList<HostDatastoreBrowserSearchResults> results = browserMo.searchDatastoreSubFolders("[" + getName() + "]", fileName, caseInsensitive);	if (results != null && results.size() > 1) {	
multiple files with name exists in datastore trying to choose first file found in search attempt 

} else if (results == null) {	String msg = "No file found with name " + fileName + " found in datastore " + datastorePath;	s_logger.error(msg);	throw new CloudException(msg);	}	for (HostDatastoreBrowserSearchResults result : results) {	List<FileInfo> info = result.getFile();	if (info != null && info.size() > 0) {	for (FileInfo fi : info) {	absoluteFileName = parentFolderPath = result.getFolderPath();	
found file in datastore at 

========================= cloudstack sample_2076 =========================

public void scheduleTimeoutTask(long delay) {	if (timeoutTask != null) timeoutTask.cancel();	timeoutTask = new TimeoutTask(this);	timer.schedule(timeoutTask, delay);	if (s_logger.isDebugEnabled()) {	
scheduling timeout at ms 

public void sendCommand(RequestType reqType) {	if (getJobId() != null) {	if (s_logger.isTraceEnabled()) {	
sending progress command 

}	try {	EndPoint ep = _epSelector.select(sserver);	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	return;	}	ep.sendMessageAsync(new UploadProgressCommand(getCommand(), getJobId(), reqType), new Callback(ep.getId(), this));	} catch (Exception e) {	
send command failed 

========================= cloudstack sample_2451 =========================

Type vmType = vm.getType();	boolean userVm = !(vmType.equals(VirtualMachine.Type.DomainRouter) || vmType.equals(VirtualMachine.Type.ConsoleProxy) || vmType.equals(VirtualMachine.Type.SecondaryStorageVm));	String nicDeviceType = details.get(VmDetailConstants.NIC_ADAPTER);	if (!userVm) {	if (nicDeviceType == null) {	details.put(VmDetailConstants.NIC_ADAPTER, _vmwareMgr.getSystemVMDefaultNicAdapterType());	} else {	try {	VirtualEthernetCardType.valueOf(nicDeviceType);	} catch (Exception e) {	
invalid nic device type is specified in vm details switch to default 

details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());	}	}	} else {	if (nicDeviceType == null) {	details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());	} else {	try {	VirtualEthernetCardType.valueOf(nicDeviceType);	} catch (Exception e) {	
invalid nic device type is specified in vm details switch to default 

}	if (!sbMacSequence.toString().isEmpty()) {	sbMacSequence.deleteCharAt(sbMacSequence.length() - 1);	String bootArgs = to.getBootArgs();	to.setBootArgs(bootArgs + " nic_macs=" + sbMacSequence.toString());	}	}	if (userVm) {	String nestedVirt = _configDao.getValue(Config.VmwareEnableNestedVirtualization.key());	if (nestedVirt != null) {	
nested virtualization requested adding flag to vm configuration 

private static String resolveNameInGuid(String guid) {	String tokens[] = guid.split("@");	assert (tokens.length == 2);	String vCenterIp = NetUtils.resolveToIp(tokens[1]);	if (vCenterIp == null) {	
fatal unable to resolve vcenter address please check your dns configuration 

public List<Command> finalizeExpungeNics(VirtualMachine vm, List<NicProfile> nics) {	List<Command> commands = new ArrayList<Command>();	List<NicVO> nicVOs = _nicDao.listByVmId(vm.getId());	for (NicVO nic : nicVOs) {	NetworkVO network = _networkDao.findById(nic.getNetworkId());	if (network.getBroadcastDomainType() == BroadcastDomainType.Lswitch) {	
nic is connected to an lswitch cleanup required 

========================= cloudstack sample_1292 =========================

BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);	Graphics2D g = bufferedImage.createGraphics();	synchronized (offlineImage) {	g.drawImage(offlineImage, 0, 0, width, height, 0, 0, width, height, null);	g.dispose();	}	byte[] imgBits = null;	try {	imgBits = ImageHelper.jpegFromImage(bufferedImage);	} catch (IOException e) {	
ignored read error on image 

for (TileInfo tile : tileList) {	Rectangle rc = tile.getTileRect();	g.drawImage(offlineImage, i * tileWidth, 0, i * tileWidth + rc.width, rc.height, rc.x, rc.y, rc.x + rc.width, rc.y + rc.height, null);	i++;	}	}	byte[] imgBits = null;	try {	imgBits = ImageHelper.jpegFromImage(bufferedImage);	} catch (IOException e) {	
ignored read error on image tiles 

========================= cloudstack sample_4993 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	BaremetalPxeVO vo = pxeMgr.addPxeServer(this);	BaremetalPxeResponse rsp = pxeMgr.getApiResponse(vo);	rsp.setResponseName(getCommandName());	this.setResponseObject(rsp);	} catch (Exception e) {	
unable to add external pxe server with url 

========================= cloudstack sample_875 =========================

public KVMStoragePoolManager(StorageLayer storagelayer, KVMHAMonitor monitor) {	this._haMonitor = monitor;	this._storageMapper.put("libvirt", new LibvirtStorageAdaptor(storagelayer));	this._storageMapper.put(StoragePoolType.ManagedNFS.toString(), new ManagedNfsStorageAdaptor(storagelayer));	Reflections reflections = new Reflections("com.cloud.hypervisor.kvm.storage");	Set<Class<? extends StorageAdaptor>> storageAdaptors = reflections.getSubTypesOf(StorageAdaptor.class);	for (Class<? extends StorageAdaptor> storageAdaptor : storageAdaptors) {	StorageAdaptorInfo info = storageAdaptor.getAnnotation(StorageAdaptorInfo.class);	if (info != null && info.storagePoolType() != null) {	if (this._storageMapper.containsKey(info.storagePoolType().toString())) {	
duplicate storageadaptor type not loading 

} else {	try {	this._storageMapper.put(info.storagePoolType().toString(), storageAdaptor.newInstance());	} catch (Exception ex) {	throw new CloudRuntimeException(ex.toString());	}	}	}	}	for (Map.Entry<String, StorageAdaptor> adaptors : this._storageMapper.entrySet()) {	
registered a storageadaptor for 

final String vmName = vmSpec.getName();	List<DiskTO> disks = Arrays.asList(vmSpec.getDisks());	for (DiskTO disk : disks) {	if (disk.getType() != Volume.Type.ISO) {	VolumeObjectTO vol = (VolumeObjectTO)disk.getData();	PrimaryDataStoreTO store = (PrimaryDataStoreTO)vol.getDataStore();	KVMStoragePool pool = getStoragePool(store.getPoolType(), store.getUuid());	StorageAdaptor adaptor = getStorageAdaptor(pool.getType());	result = adaptor.connectPhysicalDisk(vol.getPath(), pool, disk.getDetails());	if (!result) {	
failed to connect disks via vm spec for vm volume 

public boolean disconnectPhysicalDisksViaVmSpec(VirtualMachineTO vmSpec) {	if (vmSpec == null) {	
disconnectphysicaldiskviavmspec attempted to stop a vm that is not yet in our hash map 

public boolean disconnectPhysicalDisksViaVmSpec(VirtualMachineTO vmSpec) {	if (vmSpec == null) {	return true;	}	boolean result = true;	final String vmName = vmSpec.getName();	List<DiskTO> disks = Arrays.asList(vmSpec.getDisks());	for (DiskTO disk : disks) {	if (disk.getType() != Volume.Type.ISO) {	
disconnecting disk 

}	boolean result = true;	final String vmName = vmSpec.getName();	List<DiskTO> disks = Arrays.asList(vmSpec.getDisks());	for (DiskTO disk : disks) {	if (disk.getType() != Volume.Type.ISO) {	VolumeObjectTO vol = (VolumeObjectTO)disk.getData();	PrimaryDataStoreTO store = (PrimaryDataStoreTO)vol.getDataStore();	KVMStoragePool pool = getStoragePool(store.getPoolType(), store.getUuid());	if (pool == null) {	
pool of type was not found skipping disconnect logic 

if (disk.getType() != Volume.Type.ISO) {	VolumeObjectTO vol = (VolumeObjectTO)disk.getData();	PrimaryDataStoreTO store = (PrimaryDataStoreTO)vol.getDataStore();	KVMStoragePool pool = getStoragePool(store.getPoolType(), store.getUuid());	if (pool == null) {	continue;	}	StorageAdaptor adaptor = getStorageAdaptor(pool.getType());	boolean subResult = adaptor.disconnectPhysicalDisk(vol.getPath(), pool);	if (!subResult) {	
failed to disconnect disks via vm spec for vm volume 

KVMPhysicalDisk vol = null;	String errMsg = "";	while (cnt < retries) {	try {	KVMStoragePool pool = getStoragePool(type, poolUuid);	vol = pool.getPhysicalDisk(volName);	if (vol != null) {	break;	}	} catch (Exception e) {	
failed to find volume due to retry 

vol = pool.getPhysicalDisk(volName);	if (vol != null) {	break;	}	} catch (Exception e) {	errMsg = e.toString();	}	try {	Thread.sleep(30000);	} catch (InterruptedException e) {	
ignored interupted while trying to get storage pool 

========================= cloudstack sample_1011 =========================

host = iter.next();	}	if (arg.equals("-p")) {	password = iter.next();	}	if (arg.equals("-u")) {	url = iter.next();	}	}	if (host == null || host.equals("")) {	
did not receive a host back from test ignoring ssh test 

password = iter.next();	}	if (arg.equals("-u")) {	url = iter.next();	}	}	if (host == null || host.equals("")) {	System.exit(2);	}	if (password == null) {	
did not receive a password back from test ignoring ssh test 

url = iter.next();	}	}	if (host == null || host.equals("")) {	System.exit(2);	}	if (password == null) {	System.exit(2);	}	try {	
attempting to ssh into host 

}	if (host == null || host.equals("")) {	System.exit(2);	}	if (password == null) {	System.exit(2);	}	try {	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
user sshed successfully into host 

System.exit(2);	}	if (password == null) {	System.exit(2);	}	try {	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", password);	if (isAuthenticated == false) {	
authentication failed for root with password 

boolean isAuthenticated = conn.authenticateWithPassword("root", password);	if (isAuthenticated == false) {	System.exit(2);	}	String linuxCommand = "wget " + url;	Session sess = conn.openSession();	sess.execCommand(linuxCommand);	sess.close();	conn.close();	} catch (Exception e) {	
ssh test fail with error 

========================= cloudstack sample_463 =========================

protected void initialize() {	try {	DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();	docFactory.setNamespaceAware(true);	DocumentBuilder docBuilder = docFactory.newDocumentBuilder();	_docResponse = docBuilder.parse(new InputSource(new StringReader(_xmlResponse)));	if (_docResponse != null) {	parse(_docResponse.getDocumentElement());	}	} catch (ParserConfigurationException e) {	
error parsing the response 

try {	DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();	docFactory.setNamespaceAware(true);	DocumentBuilder docBuilder = docFactory.newDocumentBuilder();	_docResponse = docBuilder.parse(new InputSource(new StringReader(_xmlResponse)));	if (_docResponse != null) {	parse(_docResponse.getDocumentElement());	}	} catch (ParserConfigurationException e) {	} catch (SAXException e) {	
error parsing the response 

DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();	docFactory.setNamespaceAware(true);	DocumentBuilder docBuilder = docFactory.newDocumentBuilder();	_docResponse = docBuilder.parse(new InputSource(new StringReader(_xmlResponse)));	if (_docResponse != null) {	parse(_docResponse.getDocumentElement());	}	} catch (ParserConfigurationException e) {	} catch (SAXException e) {	} catch (IOException e) {	
error parsing the response 

_severity = ErrorSeverity.valueOf(node.getTextContent().trim());	} else if (node.getNodeName().equalsIgnoreCase("nf:error-path")) {	_path = node.getTextContent();	} else if (node.getNodeName().equalsIgnoreCase("nf:error-message")) {	_message = node.getTextContent();	} else if (node.getNodeName().equalsIgnoreCase("nf:error-info")) {	_info = node.getTextContent();	}	}	} catch (DOMException e) {	
error parsing the response 

protected void printResponse() {	try {	DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();	DocumentBuilder docBuilder = docFactory.newDocumentBuilder();	DOMImplementationLS ls = (DOMImplementationLS)docBuilder.getDOMImplementation();	LSSerializer lss = ls.createLSSerializer();	System.out.println(lss.writeToString(_docResponse));	} catch (ParserConfigurationException e) {	
error parsing the repsonse 

========================= cloudstack sample_2778 =========================

protected boolean canHandle(NetworkOffering offering, final NetworkType networkType, final PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && isMyIsolationMethod(physicalNetwork) && !offering.isSystemOnly()) {	return true;	} else {	
we only take care of guest networks of type in zone of type 

========================= cloudstack sample_2282 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException {	try {	StorageNetworkIpRange result = _storageNetworkService.createIpRange(this);	StorageNetworkIpRangeResponse response = _responseGenerator.createStorageNetworkIpRangeResponse(result);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} catch (Exception e) {	
create storage network ip range failed 

========================= cloudstack sample_3169 =========================

final XsLocalNetwork nativeNetworkForTraffic = xenServer610Resource.getNativeNetworkForTraffic(connection, TrafficType.Storage, null);	final Network network = nativeNetworkForTraffic.getNetwork();	final XsHost xsHost = xenServer610Resource.getHost();	final String uuid = xsHost.getUuid();	final Map<String, String> other = new HashMap<String, String>();	other.put("live", "true");	final Host host = Host.getByUuid(connection, uuid);	final Map<String, String> token = host.migrateReceive(connection, network, other);	return new MigrateWithStorageReceiveAnswer(command, volumeToSr, nicToNetwork, token);	} catch (final CloudRuntimeException e) {	
migration of vm with storage failed due to 

final XsHost xsHost = xenServer610Resource.getHost();	final String uuid = xsHost.getUuid();	final Map<String, String> other = new HashMap<String, String>();	other.put("live", "true");	final Host host = Host.getByUuid(connection, uuid);	final Map<String, String> token = host.migrateReceive(connection, network, other);	return new MigrateWithStorageReceiveAnswer(command, volumeToSr, nicToNetwork, token);	} catch (final CloudRuntimeException e) {	return new MigrateWithStorageReceiveAnswer(command, e);	} catch (final Exception e) {	
migration of vm with storage failed due to 

========================= cloudstack sample_1154 =========================

public void updateVMInstanceUserId(final Connection conn) {	
updating vm instance column user id using first user in vm instance s account id 

throw new CloudRuntimeException("Unable to update user ID " + userId + " on vm_instance id=" + vmId, e);	}	}	} catch (final SQLException e) {	throw new CloudRuntimeException("Unable to update user ID using accountId " + accountId + " on vm_instance id=" + vmId, e);	}	}	} catch (final SQLException e) {	throw new CloudRuntimeException("Unable to update user Ids for previously deployed VMs", e);	}	
done updating user ids for previously deployed vms 

private void addIndexForVMInstance(final Connection conn) {	final List<String> indexList = new ArrayList<String>();	
dropping index i vm instance instance name from vm instance table if it exists 

private void addIndexForVMInstance(final Connection conn) {	final List<String> indexList = new ArrayList<String>();	indexList.add("i_vm_instance__instance_name");	DbUpgradeUtils.dropKeysIfExist(conn, "vm_instance", indexList, false);	try (PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`vm_instance` ADD INDEX `i_vm_instance__instance_name`(`instance_name`)");) {	pstmt.executeUpdate();	
added index i vm instance instance name to vm instance table 

private void updateSystemVmTemplates(final Connection conn) {	
updating system vm template ids 

case Hyperv: hypervisorsListInUse.add(Hypervisor.HypervisorType.Hyperv);	break;	case LXC: hypervisorsListInUse.add(Hypervisor.HypervisorType.LXC);	break;	case Ovm3: hypervisorsListInUse.add(Hypervisor.HypervisorType.Ovm3);	break;	default: break;	}	}	} catch (final SQLException e) {	
updatesystemvmtemplates exception while getting hypervisor types from clusters 

{	put(Hypervisor.HypervisorType.XenServer, "8886f554a499ec5405b6f203d9d36460");	put(Hypervisor.HypervisorType.VMware, "4b415224fe00b258f66cad9fce9f73fc");	put(Hypervisor.HypervisorType.KVM, "c059b0d051e0cd6fbe9d5d4fc40c7e5d");	put(Hypervisor.HypervisorType.LXC, "c059b0d051e0cd6fbe9d5d4fc40c7e5d");	put(Hypervisor.HypervisorType.Hyperv, "53e24bddfa56ea3139ed37af4b519013");	put(Hypervisor.HypervisorType.Ovm3, "c8577d27b2daafb2d9a4ed307ce2f00f");	}	};	for (final Map.Entry<Hypervisor.HypervisorType, String> hypervisorAndTemplateName : NewTemplateNameList.entrySet()) {	
updating system vms 

};	for (final Map.Entry<Hypervisor.HypervisorType, String> hypervisorAndTemplateName : NewTemplateNameList.entrySet()) {	try (PreparedStatement pstmt = conn.prepareStatement("select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1")) {	long templateId = -1;	pstmt.setString(1, hypervisorAndTemplateName.getValue());	try (ResultSet rs = pstmt.executeQuery()) {	if (rs.next()) {	templateId = rs.getLong(1);	}	} catch (final SQLException e) {	
updatesystemvmtemplates exception while getting ids of templates 

templateId = rs.getLong(1);	}	} catch (final SQLException e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while getting ids of templates", e);	}	if (templateId != -1) {	try (PreparedStatement templ_type_pstmt = conn.prepareStatement("update `cloud`.`vm_template` set type='SYSTEM' where id = ?");) {	templ_type_pstmt.setLong(1, templateId);	templ_type_pstmt.executeUpdate();	} catch (final SQLException e) {	
updatesystemvmtemplates exception while updating template with id to be marked as system 

templ_type_pstmt.setLong(1, templateId);	templ_type_pstmt.executeUpdate();	} catch (final SQLException e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while updating template with id " + templateId + " to be marked as 'system'", e);	}	try (PreparedStatement update_templ_id_pstmt = conn .prepareStatement("update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ?");) {	update_templ_id_pstmt.setLong(1, templateId);	update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.getKey().toString());	update_templ_id_pstmt.executeUpdate();	} catch (final Exception e) {	
updatesystemvmtemplates exception while setting template for to 

update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.getKey().toString());	update_templ_id_pstmt.executeUpdate();	} catch (final Exception e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while setting template for " + hypervisorAndTemplateName.getKey().toString() + " to " + templateId, e);	}	try (PreparedStatement update_pstmt = conn.prepareStatement("UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?");) {	update_pstmt.setString(1, hypervisorAndTemplateName.getValue());	update_pstmt.setString(2, routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()));	update_pstmt.executeUpdate();	} catch (final SQLException e) {	
updatesystemvmtemplates exception while setting to 

update_pstmt.setString(2, routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()));	update_pstmt.executeUpdate();	} catch (final SQLException e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while setting " + routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()) + " to " + hypervisorAndTemplateName.getValue(), e);	}	try (PreparedStatement update_pstmt = conn.prepareStatement("UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?");) {	update_pstmt.setString(1, getUpgradedVersion());	update_pstmt.setString(2, "minreq.sysvmtemplate.version");	update_pstmt.executeUpdate();	} catch (final SQLException e) {	
updatesystemvmtemplates exception while setting minreq sysvmtemplate version to 

update_pstmt.setString(1, getUpgradedVersion());	update_pstmt.setString(2, "minreq.sysvmtemplate.version");	update_pstmt.executeUpdate();	} catch (final SQLException e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while setting 'minreq.sysvmtemplate.version' to 4.6.0", e);	}	} else {	if (hypervisorsListInUse.contains(hypervisorAndTemplateName.getKey())) {	throw new CloudRuntimeException(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + " SystemVm template not found. Cannot upgrade system Vms");	} else {	
systemvm template not found hypervisor is not used so not failing upgrade 

} else {	if (hypervisorsListInUse.contains(hypervisorAndTemplateName.getKey())) {	throw new CloudRuntimeException(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + " SystemVm template not found. Cannot upgrade system Vms");	} else {	try (PreparedStatement update_templ_url_pstmt = conn .prepareStatement("UPDATE `cloud`.`vm_template` SET url = ? , checksum = ? WHERE hypervisor_type = ? AND type = 'SYSTEM' AND removed is null order by id desc limit 1");) {	update_templ_url_pstmt.setString(1, newTemplateUrl.get(hypervisorAndTemplateName.getKey()));	update_templ_url_pstmt.setString(2, newTemplateChecksum.get(hypervisorAndTemplateName.getKey()));	update_templ_url_pstmt.setString(3, hypervisorAndTemplateName.getKey().toString());	update_templ_url_pstmt.executeUpdate();	} catch (final SQLException e) {	
updatesystemvmtemplates exception while updating url and checksum for hypervisor type 

update_templ_url_pstmt.setString(1, newTemplateUrl.get(hypervisorAndTemplateName.getKey()));	update_templ_url_pstmt.setString(2, newTemplateChecksum.get(hypervisorAndTemplateName.getKey()));	update_templ_url_pstmt.setString(3, hypervisorAndTemplateName.getKey().toString());	update_templ_url_pstmt.executeUpdate();	} catch (final SQLException e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type " + hypervisorAndTemplateName.getKey().toString(), e);	}	}	}	} catch (final SQLException e) {	
updatesystemvmtemplates exception while getting ids of templates 

update_templ_url_pstmt.executeUpdate();	} catch (final SQLException e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type " + hypervisorAndTemplateName.getKey().toString(), e);	}	}	}	} catch (final SQLException e) {	throw new CloudRuntimeException("updateSystemVmTemplates:Exception while getting ids of templates", e);	}	}	
updating system vm template ids complete 

========================= cloudstack sample_4182 =========================

public void testDropKey() throws Exception {	when(connectionMock.prepareStatement(contains("DROP KEY"))).thenReturn(preparedStatementMock);	Connection conn = connectionMock;	String tableName = "tableName";	String key = "key";	boolean isForeignKey = false;	dao.dropKey(conn, tableName, key, isForeignKey);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
successfully 

when(connectionMock.prepareStatement(contains("null DROP KEY"))).thenReturn(preparedStatementMock);	when(preparedStatementMock.executeUpdate()).thenThrow(sqlException);	Connection conn = connectionMock;	String tableName = null;	String key = "key";	boolean isForeignKey = false;	dao.dropKey(conn, tableName, key, isForeignKey);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
Exception 

when(connectionMock.prepareStatement(contains("DROP KEY null"))).thenReturn(preparedStatementMock);	when(preparedStatementMock.executeUpdate()).thenThrow(sqlException);	Connection conn = connectionMock;	String tableName = "tableName";	String key = null;	boolean isForeignKey = false;	dao.dropKey(conn, tableName, key, isForeignKey);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
Exception 

public void testDropKeyWhenKeysAreForeignKeys() throws Exception {	when(connectionMock.prepareStatement(contains("DROP FOREIGN KEY"))).thenReturn(preparedStatementMock);	Connection conn = connectionMock;	String tableName = "tableName";	String key = "key";	boolean isForeignKey = true;	dao.dropKey(conn, tableName, key, isForeignKey);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
successfully 

SQLException sqlException = new SQLException();	when(connectionMock.prepareStatement(any(String.class))).thenThrow(sqlException);	Connection conn = connectionMock;	String tableName = "tableName";	String key = "key";	boolean isForeignKey = false;	dao.dropKey(conn, tableName, key, isForeignKey);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(0)).executeUpdate();	verify(preparedStatementMock, times(0)).close();	
Exception 

when(connectionMock.prepareStatement(contains("DROP KEY"))).thenReturn(preparedStatementMock);	when(preparedStatementMock.executeUpdate()).thenThrow(sqlException);	Connection conn = connectionMock;	String tableName = "tableName";	String key = "key";	boolean isForeignKey = false;	dao.dropKey(conn, tableName, key, isForeignKey);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
Exception 

public void testDropPrimaryKey() throws Exception {	when(connectionMock.prepareStatement(contains("DROP PRIMARY KEY"))).thenReturn(preparedStatementMock);	Connection conn = connectionMock;	String tableName = "tableName";	dao.dropPrimaryKey(conn, tableName);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
successfully 

public void testDropPrimaryKeyWhenTableNameIsNull() throws Exception {	SQLException sqlException = new SQLException();	when(connectionMock.prepareStatement(contains("null DROP PRIMARY KEY"))).thenReturn(preparedStatementMock);	when(preparedStatementMock.executeUpdate()).thenThrow(sqlException);	Connection conn = connectionMock;	String tableName = null;	dao.dropPrimaryKey(conn, tableName);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
Exception 

public void testDropPrimaryKeyWhenPrepareStatementResultsInException() throws Exception {	SQLException sqlException = new SQLException();	when(connectionMock.prepareStatement(contains("DROP PRIMARY KEY"))).thenThrow(sqlException);	Connection conn = connectionMock;	String tableName = null;	dao.dropPrimaryKey(conn, tableName);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(0)).executeUpdate();	verify(preparedStatementMock, times(0)).close();	
Exception 

public void testDropPrimaryKeyWhenExecuteUpdateResultsInException() throws Exception {	SQLException sqlException = new SQLException();	when(connectionMock.prepareStatement(contains("DROP PRIMARY KEY"))).thenReturn(preparedStatementMock);	when(preparedStatementMock.executeUpdate()).thenThrow(sqlException);	Connection conn = connectionMock;	String tableName = null;	dao.dropPrimaryKey(conn, tableName);	verify(connectionMock, times(1)).prepareStatement(anyString());	verify(preparedStatementMock, times(1)).executeUpdate();	verify(preparedStatementMock, times(1)).close();	
Exception 

========================= cloudstack sample_4028 =========================

public boolean start() {	if (s_logger.isInfoEnabled()) {	
starting statement manager 

public boolean stop() {	if (s_logger.isInfoEnabled()) {	
stopping statement manager 

Date lastStatementDate = quotaAccount.getLastStatementDate();	if (interval != null) {	AccountVO account = _accountDao.findById(quotaAccount.getId());	if (account != null) {	if (lastStatementDate == null || getDifferenceDays(lastStatementDate, new Date()) >= s_LAST_STATEMENT_SENT_DAYS + 1) {	BigDecimal quotaUsage = _quotaUsage.findTotalQuotaUsage(account.getAccountId(), account.getDomainId(), null, interval[0].getTime(), interval[1].getTime());	s_logger.info("For account=" + quotaAccount.getId() + ", quota used = " + quotaUsage);	deferredQuotaEmailList.add(new DeferredQuotaEmail(account, quotaAccount, quotaUsage, QuotaConfig.QuotaEmailTemplateTypes.QUOTA_STATEMENT));	} else {	if (s_logger.isDebugEnabled()) {	
for the statement has been sent recently 

if (lastStatementDate == null || getDifferenceDays(lastStatementDate, new Date()) >= s_LAST_STATEMENT_SENT_DAYS + 1) {	BigDecimal quotaUsage = _quotaUsage.findTotalQuotaUsage(account.getAccountId(), account.getDomainId(), null, interval[0].getTime(), interval[1].getTime());	s_logger.info("For account=" + quotaAccount.getId() + ", quota used = " + quotaUsage);	deferredQuotaEmailList.add(new DeferredQuotaEmail(account, quotaAccount, quotaUsage, QuotaConfig.QuotaEmailTemplateTypes.QUOTA_STATEMENT));	} else {	if (s_logger.isDebugEnabled()) {	}	}	}	} else if (lastStatementDate != null) {	
for it is already more than days will send statement in next cycle 

} else {	if (s_logger.isDebugEnabled()) {	}	}	}	} else if (lastStatementDate != null) {	}	}	for (DeferredQuotaEmail emailToBeSent : deferredQuotaEmailList) {	if (s_logger.isDebugEnabled()) {	
attempting to send quota statement email to users of account 

========================= cloudstack sample_658 =========================

long aggBytesSent = rs.getLong(9);	long eventTimeMillis = rs.getLong(10);	if (hostId != 0) {	returnMap.put(zoneId + "-" + accountId + "-Host-" + hostId, new UsageNetworkVO(accountId, zoneId, hostId, hostType, networkId, bytesSent, bytesReceived, aggBytesReceived, aggBytesSent, eventTimeMillis));	} else {	returnMap.put(zoneId + "-" + accountId, new UsageNetworkVO(accountId, zoneId, hostId, hostType, networkId, bytesSent, bytesReceived, aggBytesReceived, aggBytesSent, eventTimeMillis));	}	}	return returnMap;	} catch (Exception ex) {	
error getting recent usage network stats 

String sql = DELETE_OLD_STATS;	PreparedStatement pstmt = null;	try {	txn.start();	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, maxEventTime);	pstmt.executeUpdate();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error deleting old usage network stats 

pstmt.setLong(7, usageNetwork.getBytesReceived());	pstmt.setLong(8, usageNetwork.getAggBytesReceived());	pstmt.setLong(9, usageNetwork.getAggBytesSent());	pstmt.setLong(10, usageNetwork.getEventTimeMillis());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving usage network to cloud usage db 

========================= cloudstack sample_4497 =========================

Callback[] callbacks = new Callback[] {NoOp.INSTANCE, new UpdateBuilder(this)};	_enhancer = new Enhancer();	_enhancer.setSuperclass(_entityBeanType);	_enhancer.setCallbackFilter(s_callbackFilter);	_enhancer.setCallbacks(callbacks);	_factory = (Factory)_enhancer.create();	_searchEnhancer = new Enhancer();	_searchEnhancer.setSuperclass(_entityBeanType);	_searchEnhancer.setCallback(new UpdateBuilder(this));	if (s_logger.isTraceEnabled()) {	
select sql 

_enhancer = new Enhancer();	_enhancer.setSuperclass(_entityBeanType);	_enhancer.setCallbackFilter(s_callbackFilter);	_enhancer.setCallbacks(callbacks);	_factory = (Factory)_enhancer.create();	_searchEnhancer = new Enhancer();	_searchEnhancer.setSuperclass(_entityBeanType);	_searchEnhancer.setCallback(new UpdateBuilder(this));	if (s_logger.isTraceEnabled()) {	s_logger.trace("Remove SQL: " + (_removeSql != null ? _removeSql.first() : "No remove sql"));	
select by id sql 

_enhancer = new Enhancer();	_enhancer.setSuperclass(_entityBeanType);	_enhancer.setCallbackFilter(s_callbackFilter);	_enhancer.setCallbacks(callbacks);	_factory = (Factory)_enhancer.create();	_searchEnhancer = new Enhancer();	_searchEnhancer.setSuperclass(_entityBeanType);	_searchEnhancer.setCallback(new UpdateBuilder(this));	if (s_logger.isTraceEnabled()) {	s_logger.trace("Remove SQL: " + (_removeSql != null ? _removeSql.first() : "No remove sql"));	
table references 

_enhancer = new Enhancer();	_enhancer.setSuperclass(_entityBeanType);	_enhancer.setCallbackFilter(s_callbackFilter);	_enhancer.setCallbacks(callbacks);	_factory = (Factory)_enhancer.create();	_searchEnhancer = new Enhancer();	_searchEnhancer.setSuperclass(_entityBeanType);	_searchEnhancer.setCallback(new UpdateBuilder(this));	if (s_logger.isTraceEnabled()) {	s_logger.trace("Remove SQL: " + (_removeSql != null ? _removeSql.first() : "No remove sql"));	
insert sqls 

_enhancer.setCallbacks(callbacks);	_factory = (Factory)_enhancer.create();	_searchEnhancer = new Enhancer();	_searchEnhancer.setSuperclass(_entityBeanType);	_searchEnhancer.setCallback(new UpdateBuilder(this));	if (s_logger.isTraceEnabled()) {	s_logger.trace("Remove SQL: " + (_removeSql != null ? _removeSql.first() : "No remove sql"));	for (final Pair<String, Attribute[]> insertSql : _insertSqls) {	s_logger.trace(insertSql.first());	}	
delete sqls 

_searchEnhancer.setSuperclass(_entityBeanType);	_searchEnhancer.setCallback(new UpdateBuilder(this));	if (s_logger.isTraceEnabled()) {	s_logger.trace("Remove SQL: " + (_removeSql != null ? _removeSql.first() : "No remove sql"));	for (final Pair<String, Attribute[]> insertSql : _insertSqls) {	s_logger.trace(insertSql.first());	}	for (final Pair<String, Attribute[]> deletSql : _deleteSqls) {	s_logger.trace(deletSql.first());	}	
collection sqls 

for (final Pair<Attribute, Object> value : join.getT().getValues()) {	prepareAttribute(count++, pstmt, value.first(), value.second());	}	}	for (JoinBuilder<SearchCriteria<?>> join : joins) {	if (join.getT().getJoins() != null) {	count = addJoinAttributes(count, pstmt, join.getT().getJoins());	}	}	if (s_logger.isTraceEnabled()) {	
join search statement is 

protected T toEntityBean(final ResultSet result, final boolean cache) throws SQLException {	final T entity = (T)_factory.newInstance(new Callback[] {NoOp.INSTANCE, new UpdateBuilder(this)});	toEntityBean(result, entity);	if (cache && _cache != null) {	try {	_cache.put(new Element(_idField.get(entity), entity));	} catch (final Exception e) {	
can t put it in the cache 

} catch (InstantiationException e1) {	throw new CloudRuntimeException("Unable to instantiate entity", e1);	} catch (IllegalAccessException e1) {	throw new CloudRuntimeException("Illegal Access", e1);	}	toEntityBean(result, entity);	if (cache && _cache != null) {	try {	_cache.put(new Element(_idField.get(entity), entity));	} catch (final Exception e) {	
can t put it in the cache 

protected void createCache(final Map<String, ? extends Object> params) {	final String value = (String)params.get("cache.size");	if (value != null) {	final CacheManager cm = CacheManager.create();	final int maxElements = NumbersUtil.parseInt(value, 0);	final int live = NumbersUtil.parseInt((String)params.get("cache.time.to.live"), 300);	final int idle = NumbersUtil.parseInt((String)params.get("cache.time.to.idle"), 300);	_cache = new Cache(getName(), maxElements, false, live == -1, live == -1 ? Integer.MAX_VALUE : live, idle);	cm.addCache(_cache);	
cache created 

========================= cloudstack sample_571 =========================

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (!super.configure(name, params)) {	
base class was unable to configure 

========================= cloudstack sample_988 =========================

ss.setRole(dataStore.getRole());	ss.setVolumeId(snapshotInfo.getVolumeId());	ss.setSize(snapshotInfo.getSize());	ss.setPhysicalSize(snapshotInfo.getSize());	SnapshotDataStoreVO snapshotDataStoreVO = snapshotDataStoreDao.findParent(dataStore.getRole(), dataStore.getId(), snapshotInfo.getVolumeId());	if (snapshotDataStoreVO != null) {	SnapshotVO parentSnap = snapshotDao.findById(snapshotDataStoreVO.getSnapshotId());	if (parentSnap != null) {	ss.setParentSnapshotId(snapshotDataStoreVO.getSnapshotId());	} else {	
find inconsistent db for snapshot 

public boolean delete(DataObject dataObj) {	long objId = dataObj.getId();	DataStore dataStore = dataObj.getDataStore();	if (dataStore.getRole() == DataStoreRole.Primary) {	if (dataObj.getType() == DataObjectType.TEMPLATE) {	VMTemplateStoragePoolVO destTmpltPool = templatePoolDao.findByPoolTemplate(dataStore.getId(), objId);	if (destTmpltPool != null) {	return templatePoolDao.remove(destTmpltPool.getId());	} else {	
template is not found on storage pool so no need to delete 

} else {	return true;	}	}	} else {	switch (dataObj.getType()) {	case TEMPLATE: TemplateDataStoreVO destTmpltStore = templateDataStoreDao.findByStoreTemplate(dataStore.getId(), objId);	if (destTmpltStore != null) {	return templateDataStoreDao.remove(destTmpltStore.getId());	} else {	
template is not found on image store so no need to delete 

case TEMPLATE: TemplateDataStoreVO destTmpltStore = templateDataStoreDao.findByStoreTemplate(dataStore.getId(), objId);	if (destTmpltStore != null) {	return templateDataStoreDao.remove(destTmpltStore.getId());	} else {	return true;	}	case SNAPSHOT: SnapshotDataStoreVO destSnapshotStore = snapshotDataStoreDao.findByStoreSnapshot(dataStore.getRole(), dataStore.getId(), objId);	if (destSnapshotStore != null) {	return snapshotDataStoreDao.remove(destSnapshotStore.getId());	} else {	
snapshot is not found on image store so no need to delete 

case SNAPSHOT: SnapshotDataStoreVO destSnapshotStore = snapshotDataStoreDao.findByStoreSnapshot(dataStore.getRole(), dataStore.getId(), objId);	if (destSnapshotStore != null) {	return snapshotDataStoreDao.remove(destSnapshotStore.getId());	} else {	return true;	}	case VOLUME: VolumeDataStoreVO destVolumeStore = volumeDataStoreDao.findByStoreVolume(dataStore.getId(), objId);	if (destVolumeStore != null) {	return volumeDataStoreDao.remove(destVolumeStore.getId());	} else {	
volume is not found on image store so no need to delete 

return true;	}	case VOLUME: VolumeDataStoreVO destVolumeStore = volumeDataStoreDao.findByStoreVolume(dataStore.getId(), objId);	if (destVolumeStore != null) {	return volumeDataStoreDao.remove(destVolumeStore.getId());	} else {	return true;	}	}	}	
unsupported data object 

public boolean deleteIfNotReady(DataObject dataObj) {	long objId = dataObj.getId();	DataStore dataStore = dataObj.getDataStore();	if (dataStore.getRole() == DataStoreRole.Primary) {	if (dataObj.getType() == DataObjectType.TEMPLATE) {	VMTemplateStoragePoolVO destTmpltPool = templatePoolDao.findByPoolTemplate(dataStore.getId(), objId);	if (destTmpltPool != null && destTmpltPool.getState() != ObjectInDataStoreStateMachine.State.Ready) {	return templatePoolDao.remove(destTmpltPool.getId());	} else {	
template is not found on storage pool so no need to delete 

}	return true;	}	} else {	switch (dataObj.getType()) {	case TEMPLATE: return true;	case SNAPSHOT: SnapshotDataStoreVO destSnapshotStore = snapshotDataStoreDao.findByStoreSnapshot(dataStore.getRole(), dataStore.getId(), objId);	if (destSnapshotStore != null && destSnapshotStore.getState() != ObjectInDataStoreStateMachine.State.Ready) {	return snapshotDataStoreDao.remove(destSnapshotStore.getId());	} else {	
snapshot is not found on image store so no need to delete 

case SNAPSHOT: SnapshotDataStoreVO destSnapshotStore = snapshotDataStoreDao.findByStoreSnapshot(dataStore.getRole(), dataStore.getId(), objId);	if (destSnapshotStore != null && destSnapshotStore.getState() != ObjectInDataStoreStateMachine.State.Ready) {	return snapshotDataStoreDao.remove(destSnapshotStore.getId());	} else {	return true;	}	case VOLUME: VolumeDataStoreVO destVolumeStore = volumeDataStoreDao.findByStoreVolume(dataStore.getId(), objId);	if (destVolumeStore != null && destVolumeStore.getState() != ObjectInDataStoreStateMachine.State.Ready) {	return volumeDataStoreDao.remove(destVolumeStore.getId());	} else {	
volume is not found on image store so no need to delete 

return true;	}	case VOLUME: VolumeDataStoreVO destVolumeStore = volumeDataStoreDao.findByStoreVolume(dataStore.getId(), objId);	if (destVolumeStore != null && destVolumeStore.getState() != ObjectInDataStoreStateMachine.State.Ready) {	return volumeDataStoreDao.remove(destVolumeStore.getId());	} else {	return true;	}	}	}	
unsupported data object no need to delete from object in store ref table 

case SNAPSHOT: vo = snapshotDataStoreDao.findByStoreSnapshot(role, dataStoreId, objId);	break;	case VOLUME: vo = volumeDataStoreDao.findByStoreVolume(dataStoreId, objId);	break;	}	} else if (type == DataObjectType.TEMPLATE && role == DataStoreRole.Primary) {	vo = templatePoolDao.findByPoolTemplate(dataStoreId, objId);	} else if (type == DataObjectType.SNAPSHOT && role == DataStoreRole.Primary) {	vo = snapshotDataStoreDao.findByStoreSnapshot(role, dataStoreId, objId);	} else {	
invalid data or store type 

========================= cloudstack sample_3997 =========================

public void run() {	NDC.push("Following thread has started" + Thread.currentThread().getName());	int retry = 0;	
the size of the array is 

public void run() {	NDC.push("Following thread has started" + Thread.currentThread().getName());	int retry = 0;	while (true) {	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt 

public void run() {	NDC.push("Following thread has started" + Thread.currentThread().getName());	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	for (VirtualMachine vm : this.virtualMachines) {	
attempting to ssh into linux host with retry attempt 

NDC.push("Following thread has started" + Thread.currentThread().getName());	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	for (VirtualMachine vm : this.virtualMachines) {	Connection conn = new Connection(this.publicIp);	conn.connect(null, 600000, 600000);	
sshed successfully into linux host 

while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	for (VirtualMachine vm : this.virtualMachines) {	Connection conn = new Connection(this.publicIp);	conn.connect(null, 600000, 600000);	boolean isAuthenticated = conn.authenticateWithPassword("root", "password");	if (isAuthenticated == false) {	
authentication failed 

Connection conn = new Connection(this.publicIp);	conn.connect(null, 600000, 600000);	boolean isAuthenticated = conn.authenticateWithPassword("root", "password");	if (isAuthenticated == false) {	}	Session sess = conn.openSession();	String fileName;	Random ran = new Random();	fileName = Math.abs(ran.nextInt()) + "-file";	String copyCommand = new String("./scpScript " + vm.getPrivateIp() + " " + fileName);	
executing 

String downloadCommand = new String("wget http: s_logger.info("Executing " + downloadCommand);	sess.execCommand(downloadCommand);	Thread.sleep(120000);	sess.close();	conn.close();	}	} catch (Exception ex) {	s_logger.error(ex);	retry++;	if (retry == retryNum) {	
performance guest network test failed with error 

========================= cloudstack sample_434 =========================

try {	Object[] result = waitForValues(task, new String[] { "info.state", "info.error" }, new String[] { "state" }, new Object[][] { new Object[] {	TaskInfoState.SUCCESS, TaskInfoState.ERROR } });	if (result[0].equals(TaskInfoState.SUCCESS)) {	retVal = true;	}	if (result[1] instanceof LocalizedMethodFault) {	throw new RuntimeException(((LocalizedMethodFault) result[1]).getLocalizedMessage());	}	} catch(WebServiceException we) {	
cancelling vcenter task because task failed with 

ManagedObjectReference mor = oc.getObj();	List<DynamicProperty> propary = oc.getPropSet();	if (type == null || type.equals(mor.getType())) {	if (propary.size() > 0) {	String propval = (String)propary.get(0).getVal();	if (propval != null && name.equalsIgnoreCase(propval)) return mor;	}	}	}	} catch (InvalidPropertyFaultMsg invalidPropertyException) {	
failed to get vmware managedobjectreference for name and type due to 

if (type == null || type.equals(mor.getType())) {	if (propary.size() > 0) {	String propval = (String)propary.get(0).getVal();	if (propval != null && name.equalsIgnoreCase(propval)) return mor;	}	}	}	} catch (InvalidPropertyFaultMsg invalidPropertyException) {	throw invalidPropertyException;	} catch (RuntimeFaultFaultMsg runtimeFaultException) {	
failed to get vmware managedobjectreference for name and type due to 

========================= cloudstack sample_2105 =========================

public Answer execute(final NetworkRulesSystemVmCommand command, final LibvirtComputingResource libvirtComputingResource) {	boolean success = false;	try {	final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(command.getVmName());	success = libvirtComputingResource.configureDefaultNetworkRulesForSystemVm(conn, command.getVmName());	} catch (final LibvirtException e) {	
ignoring libvirt error 

========================= cloudstack sample_1050 =========================

public void reset(Connection conn) {	try {	release();	} catch (Throwable th) {	
unable to release a connection 

try {	release();	} catch (Throwable th) {	}	_conn = conn;	try {	_conn.setAutoCommit(_autoCommit);	_conn.setHoldability(_holdability);	_conn.setTransactionIsolation(_isolationLevel);	} catch (SQLException e) {	
unable to release a connection 

} catch (Throwable th) {	}	_conn = conn;	try {	_conn.setAutoCommit(_autoCommit);	_conn.setHoldability(_holdability);	_conn.setTransactionIsolation(_isolationLevel);	} catch (SQLException e) {	}	s_mgr.register(_name, this);	
registering a database connection for 

protected String testValidity(String name, Connection conn) {	if (conn != null) {	synchronized (conn) {	try (PreparedStatement pstmt = conn.prepareStatement("SELECT 1");) {	pstmt.executeQuery();	} catch (Throwable th) {	
unable to keep the db connection for 

public String resetKeepAliveTask(int seconds) {	if (_executor != null) {	try {	_executor.shutdown();	} catch (Exception e) {	
unable to shutdown executor 

public String resetKeepAliveTask(int seconds) {	if (_executor != null) {	try {	_executor.shutdown();	} catch (Exception e) {	}	}	_executor = Executors.newScheduledThreadPool(1, new NamedThreadFactory("ConnectionConcierge"));	_executor.scheduleAtFixedRate(new ManagedContextRunnable() {	protected void runInContext() {	
connection concierge keep alive task 

========================= cloudstack sample_567 =========================

value = "com.cloud.storage.JavaStorageLayer";	}	try {	Class<StorageLayer> clazz = (Class<StorageLayer>)Class.forName(value);	_storage = ComponentContext.inject(clazz);	} catch (ClassNotFoundException e) {	throw new ConfigurationException("Unable to find class " + value);	}	}	if (!_storage.mkdirs(_parent)) {	
unable to create the directory 

try {	Class<StorageLayer> clazz = (Class<StorageLayer>)Class.forName(value);	_storage = ComponentContext.inject(clazz);	} catch (ClassNotFoundException e) {	throw new ConfigurationException("Unable to find class " + value);	}	}	if (!_storage.mkdirs(_parent)) {	throw new ConfigurationException("Unable to create the directory " + _parent);	}	
mount point established at 

========================= cloudstack sample_5013 =========================

Answer answer = _agentMgr.easySend(hostId, cmd);	if (answer == null) {	throw new CloudRuntimeException("Unable to get an answer to the modify storage pool command (" + storagePool.getId() + ")");	}	if (!answer.getResult()) {	String msg = "Unable to attach storage pool " + storagePool.getId() + " to host " + hostId;	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, storagePool.getDataCenterId(), storagePool.getPodId(), msg, msg);	throw new CloudRuntimeException("Unable to establish a connection from agent to storage pool " + storagePool.getId() + " due to " + answer.getDetails() + " (" + storagePool.getId() + ")");	}	assert (answer instanceof ModifyStoragePoolAnswer) : "ModifyStoragePoolAnswer expected ; Pool = " + storagePool.getId() + " Host = " + hostId;	
connection established between storage pool and host 

========================= cloudstack sample_1953 =========================

if (vmTemplate == null) {	throw new InvalidParameterValueException("Unable to find template id=" + templateId);	}	_accountMgr.checkAccess(CallContext.current().getCallingAccount(), AccessType.OperateEntry, true, vmTemplate);	if (storageId != null) {	StoragePoolVO pool = _poolDao.findById(storageId);	if (pool != null) {	if (pool.getStatus() == StoragePoolStatus.Up && pool.getDataCenterId() == zoneId) {	prepareTemplateInOneStoragePool(vmTemplate, pool);	} else {	
skip loading template into primary storage as either the pool zone is different from the requested zone or the pool is currently not available 

public void prepareIsoForVmProfile(VirtualMachineProfile profile) {	UserVmVO vm = _userVmDao.findById(profile.getId());	if (vm.getIsoId() != null) {	TemplateInfo template = prepareIso(vm.getIsoId(), vm.getDataCenterId());	if (template == null){	
failed to prepare iso on secondary or cache storage 

private void prepareTemplateInOneStoragePool(final VMTemplateVO template, final StoragePoolVO pool) {	
schedule to preload template into primary storage 

private void prepareTemplateInOneStoragePool(final VMTemplateVO template, final StoragePoolVO pool) {	_preloadExecutor.execute(new ManagedContextRunnable() {	protected void runInContext() {	try {	reallyRun();	} catch (Throwable e) {	
unexpected exception 

private void prepareTemplateInOneStoragePool(final VMTemplateVO template, final StoragePoolVO pool) {	_preloadExecutor.execute(new ManagedContextRunnable() {	protected void runInContext() {	try {	reallyRun();	} catch (Throwable e) {	}	}	private void reallyRun() {	
start to preload template into primary storage 

_preloadExecutor.execute(new ManagedContextRunnable() {	protected void runInContext() {	try {	reallyRun();	} catch (Throwable e) {	}	}	private void reallyRun() {	StoragePool pol = (StoragePool)_dataStoreMgr.getPrimaryDataStore(pool.getId());	prepareTemplateForCreate(template, pol);	
end of preloading template into primary storage 

public void prepareTemplateInAllStoragePools(final VMTemplateVO template, long zoneId) {	List<StoragePoolVO> pools = _poolDao.listByStatus(StoragePoolStatus.Up);	for (final StoragePoolVO pool : pools) {	if (pool.getDataCenterId() == zoneId) {	prepareTemplateInOneStoragePool(template, pool);	} else {	
skip loading template into primary storage as pool zone is different from the requested zone 

long poolId = pool.getId();	long templateId = template.getId();	VMTemplateStoragePoolVO templateStoragePoolRef = null;	TemplateDataStoreVO templateStoreRef = null;	templateStoragePoolRef = _tmpltPoolDao.findByPoolTemplate(poolId, templateId);	if (templateStoragePoolRef != null) {	templateStoragePoolRef.setMarkedForGC(false);	_tmpltPoolDao.update(templateStoragePoolRef.getId(), templateStoragePoolRef);	if (templateStoragePoolRef.getDownloadState() == Status.DOWNLOADED) {	if (s_logger.isDebugEnabled()) {	
template has already been downloaded to pool 

templateStoragePoolRef.setMarkedForGC(false);	_tmpltPoolDao.update(templateStoragePoolRef.getId(), templateStoragePoolRef);	if (templateStoragePoolRef.getDownloadState() == Status.DOWNLOADED) {	if (s_logger.isDebugEnabled()) {	}	return templateStoragePoolRef;	}	}	templateStoreRef = _tmplStoreDao.findByTemplateZoneDownloadStatus(templateId, pool.getDataCenterId(), VMTemplateStorageResourceAssoc.Status.DOWNLOADED);	if (templateStoreRef == null) {	
unable to find a secondary storage host who has completely downloaded the template 

templateStoreRef = _tmplStoreDao.findByTemplateZoneDownloadStatus(templateId, pool.getDataCenterId(), VMTemplateStorageResourceAssoc.Status.DOWNLOADED);	if (templateStoreRef == null) {	return null;	}	List<StoragePoolHostVO> vos = _poolHostDao.listByHostStatus(poolId, com.cloud.host.Status.Up);	if (vos == null || vos.isEmpty()) {	throw new CloudRuntimeException("Cannot download " + templateId + " to poolId " + poolId + " since there is no host in the Up state connected to this pool");	}	if (templateStoragePoolRef == null) {	if (s_logger.isDebugEnabled()) {	
downloading template to pool 

}	if (templateStoragePoolRef == null) {	if (s_logger.isDebugEnabled()) {	}	DataStore srcSecStore = _dataStoreMgr.getDataStore(templateStoreRef.getDataStoreId(), DataStoreRole.Image);	TemplateInfo srcTemplate = _tmplFactory.getTemplate(templateId, srcSecStore);	AsyncCallFuture<TemplateApiResult> future = _tmpltSvr.prepareTemplateOnPrimary(srcTemplate, pool);	try {	TemplateApiResult result = future.get();	if (result.isFailed()) {	
prepare template failed 

DataStore srcSecStore = _dataStoreMgr.getDataStore(templateStoreRef.getDataStoreId(), DataStoreRole.Image);	TemplateInfo srcTemplate = _tmplFactory.getTemplate(templateId, srcSecStore);	AsyncCallFuture<TemplateApiResult> future = _tmpltSvr.prepareTemplateOnPrimary(srcTemplate, pool);	try {	TemplateApiResult result = future.get();	if (result.isFailed()) {	return null;	}	return _tmpltPoolDao.findByPoolTemplate(poolId, templateId);	} catch (Exception ex) {	
failed to copy template from image store to primary storage 

public boolean resetTemplateDownloadStateOnPool(long templateStoragePoolRefId) {	VMTemplateStoragePoolVO templateStoragePoolRef = _tmpltPoolDao.acquireInLockTable(templateStoragePoolRefId, 1200);	if (templateStoragePoolRef == null) {	
resettemplatedownloadstateonpool failed unable to lock templatestorgepoolref 

if (dstTmpltStore != null && dstTmpltStore.getDownloadState() == Status.DOWNLOADED) {	return true;	}	if (dstTmpltStore != null && dstTmpltStore.getDownloadState() != Status.DOWNLOAD_IN_PROGRESS) {	_tmplStoreDao.removeByTemplateStore(tmpltId, dstSecStore.getId());	}	AsyncCallFuture<TemplateApiResult> future = _tmpltSvr.copyTemplate(srcTemplate, dstSecStore);	try {	TemplateApiResult result = future.get();	if (result.isFailed()) {	
copy template failed for image store 

TemplateApiResult result = future.get();	if (result.isFailed()) {	continue;	}	_tmpltDao.addTemplateToZone(template, dstZoneId);	if (account.getId() != Account.ACCOUNT_ID_SYSTEM) {	UsageEventUtils.publishUsageEvent(copyEventType, account.getId(), dstZoneId, tmpltId, null, null, null, srcTmpltStore.getPhysicalSize(), srcTmpltStore.getSize(), template.getClass().getName(), template.getUuid());	}	return true;	} catch (Exception ex) {	
failed to copy template to image store will try next one 

if (sourceZoneId != null) {	srcSecStore = getImageStore(sourceZoneId, templateId);	} else {	srcSecStore = getImageStore(templateId);	}	if (srcSecStore == null) {	throw new InvalidParameterValueException("There is no template " + templateId + " ready on image store.");	}	if (template.isCrossZones()) {	_tmpltSvr.syncTemplateToRegionStore(templateId, srcSecStore);	
template is cross zone don t need to copy 

if (sourceZone == null) {	throw new InvalidParameterValueException("Please specify a valid source zone.");	}	}	DataCenterVO dstZone = _dcDao.findById(destZoneId);	if (dstZone == null) {	throw new InvalidParameterValueException("Please specify a valid destination zone.");	}	DataStore dstSecStore = getImageStore(destZoneId, templateId);	if (dstSecStore != null) {	
there is template in secondary storage in zone don t need to copy 

public void evictTemplateFromStoragePool(VMTemplateStoragePoolVO templatePoolVO) {	VMTemplateStoragePoolVO templatePoolRef = _tmpltPoolDao.acquireInLockTable(templatePoolVO.getId());	if (templatePoolRef == null) {	
can t aquire the lock for template pool ref 

public void evictTemplateFromStoragePool(VMTemplateStoragePoolVO templatePoolVO) {	VMTemplateStoragePoolVO templatePoolRef = _tmpltPoolDao.acquireInLockTable(templatePoolVO.getId());	if (templatePoolRef == null) {	return;	}	PrimaryDataStore pool = (PrimaryDataStore)_dataStoreMgr.getPrimaryDataStore(templatePoolVO.getPoolId());	TemplateInfo template = _tmplFactory.getTemplate(templatePoolRef.getTemplateId(), pool);	try {	if (s_logger.isDebugEnabled()) {	
evicting 

}	PrimaryDataStore pool = (PrimaryDataStore)_dataStoreMgr.getPrimaryDataStore(templatePoolVO.getPoolId());	TemplateInfo template = _tmplFactory.getTemplate(templatePoolRef.getTemplateId(), pool);	try {	if (s_logger.isDebugEnabled()) {	}	if (pool.isManaged()) {	AsyncCallFuture<TemplateApiResult> future = _tmpltSvr.deleteTemplateOnPrimary(template, pool);	TemplateApiResult result = future.get();	if (result.isFailed()) {	
failed to delete template from storage pool 

TemplateInfo template = _tmplFactory.getTemplate(templatePoolRef.getTemplateId(), pool);	try {	if (s_logger.isDebugEnabled()) {	}	if (pool.isManaged()) {	AsyncCallFuture<TemplateApiResult> future = _tmpltSvr.deleteTemplateOnPrimary(template, pool);	TemplateApiResult result = future.get();	if (result.isFailed()) {	} else {	if (_tmpltPoolDao.remove(templatePoolVO.getId())) {	
successfully evicted template from storage pool 

if (result.isFailed()) {	} else {	if (_tmpltPoolDao.remove(templatePoolVO.getId())) {	}	}	} else {	DestroyCommand cmd = new DestroyCommand(pool, templatePoolVO);	Answer answer = _storageMgr.sendToPool(pool, cmd);	if (answer != null && answer.getResult()) {	if (_tmpltPoolDao.remove(templatePoolVO.getId())) {	
successfully evicted template from storage pool 

if (_tmpltPoolDao.remove(templatePoolVO.getId())) {	}	}	} else {	DestroyCommand cmd = new DestroyCommand(pool, templatePoolVO);	Answer answer = _storageMgr.sendToPool(pool, cmd);	if (answer != null && answer.getResult()) {	if (_tmpltPoolDao.remove(templatePoolVO.getId())) {	}	} else {	
will retry evict template from storage pool 

} else {	DestroyCommand cmd = new DestroyCommand(pool, templatePoolVO);	Answer answer = _storageMgr.sendToPool(pool, cmd);	if (answer != null && answer.getResult()) {	if (_tmpltPoolDao.remove(templatePoolVO.getId())) {	}	} else {	}	}	} catch (StorageUnavailableException | InterruptedException | ExecutionException e) {	
storage is unavailable currently will retry evicte template from storage pool 

public boolean templateIsDeleteable(VMTemplateHostVO templateHostRef) {	VMTemplateVO template = _tmpltDao.findByIdIncludingRemoved(templateHostRef.getTemplateId());	long templateId = template.getId();	HostVO secondaryStorageHost = _hostDao.findById(templateHostRef.getHostId());	long zoneId = secondaryStorageHost.getDataCenterId();	DataCenterVO zone = _dcDao.findById(zoneId);	List<VMInstanceVO> nonExpungedVms = _vmInstanceDao.listNonExpungedByZoneAndTemplate(zoneId, templateId);	if (!nonExpungedVms.isEmpty()) {	
template in zone is not deleteable because there are non expunged vms deployed from this template 

long templateId = template.getId();	HostVO secondaryStorageHost = _hostDao.findById(templateHostRef.getHostId());	long zoneId = secondaryStorageHost.getDataCenterId();	DataCenterVO zone = _dcDao.findById(zoneId);	List<VMInstanceVO> nonExpungedVms = _vmInstanceDao.listNonExpungedByZoneAndTemplate(zoneId, templateId);	if (!nonExpungedVms.isEmpty()) {	return false;	}	List<UserVmVO> userVmUsingIso = _userVmDao.listByIsoId(templateId);	if (!userVmUsingIso.isEmpty()) {	
iso in zone is not deleteable because it is attached to vms 

return false;	}	List<UserVmVO> userVmUsingIso = _userVmDao.listByIsoId(templateId);	if (!userVmUsingIso.isEmpty()) {	return false;	}	List<VolumeVO> volumes = _volumeDao.findByTemplateAndZone(templateId, zoneId);	for (VolumeVO volume : volumes) {	List<SnapshotVO> snapshots = _snapshotDao.listByVolumeIdVersion(volume.getId(), "2.1");	if (!snapshots.isEmpty()) {	
template in zone is not deleteable because there are snapshots using this template 

public boolean templateIsDeleteable(long templateId) {	List<UserVmJoinVO> userVmUsingIso = _userVmJoinDao.listActiveByIsoId(templateId);	if (!userVmUsingIso.isEmpty()) {	
iso is not deleteable because it is attached to vms 

public TemplateInfo prepareIso(long isoId, long dcId) {	TemplateInfo tmplt = _tmplFactory.getTemplate(isoId, DataStoreRole.Image, dcId);	if (tmplt == null || tmplt.getFormat() != ImageFormat.ISO) {	
iso does not exist in vm template table 

public TemplateInfo prepareIso(long isoId, long dcId) {	TemplateInfo tmplt = _tmplFactory.getTemplate(isoId, DataStoreRole.Image, dcId);	if (tmplt == null || tmplt.getFormat() != ImageFormat.ISO) {	return null;	}	if (tmplt.getDataStore() != null && !(tmplt.getDataStore().getTO() instanceof NfsTO)) {	Scope destScope = new ZoneScope(dcId);	TemplateInfo cacheData = (TemplateInfo)cacheMgr.createCacheObject(tmplt, destScope);	if (cacheData == null) {	
failed in copy iso from to cache storage 

UserVmVO vm = _userVmDao.findById(vmId);	if (vm == null) {	return false;	} else if (vm.getState() != State.Running) {	return true;	}	TemplateInfo tmplt = prepareIso(isoId, vm.getDataCenterId());	String vmName = vm.getInstanceName();	HostVO host = _hostDao.findById(vm.getHostId());	if (host == null) {	
host does not exist 

throw new InvalidParameterValueException("Unable to find project by id " + projectId);	}	if (!_projectMgr.canAccessProjectAccount(caller, project.getProjectAccountId())) {	throw new InvalidParameterValueException("Account " + caller + " can't access project id=" + projectId);	}	accountNames.add(_accountMgr.getAccount(project.getProjectAccountId()).getAccountName());	}	}	_accountMgr.checkAccess(caller, AccessType.OperateEntry, true, template);	if (template.getRemoved() != null) {	
unable to update permissions for with id as it is removed 

VolumeInfo volInfo = _volFactory.getVolume(volumeId);	future = _tmpltSvr.createTemplateFromVolumeAsync(volInfo, tmplInfo, store);	} else {	throw new CloudRuntimeException("Creating private Template need to specify snapshotId or volumeId");	}	CommandResult result = null;	try {	result = future.get();	if (result.isFailed()) {	privateTemplate = null;	
failed to create template 

_tmpltSvr.associateTemplateToZone(templateId, null);	} else {	VMTemplateZoneVO templateZone = new VMTemplateZoneVO(zoneId, templateId, new Date());	_tmpltZoneDao.persist(templateZone);	}	privateTemplate = _tmpltDao.findById(templateId);	TemplateDataStoreVO srcTmpltStore = _tmplStoreDao.findByStoreTemplate(store.getId(), templateId);	UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_TEMPLATE_CREATE, privateTemplate.getAccountId(), zoneId, privateTemplate.getId(), privateTemplate.getName(), null, privateTemplate.getSourceTemplateId(), srcTmpltStore.getPhysicalSize(), privateTemplate.getSize());	_usageEventDao.persist(usageEvent);	} catch (InterruptedException e) {	
failed to create template 

VMTemplateZoneVO templateZone = new VMTemplateZoneVO(zoneId, templateId, new Date());	_tmpltZoneDao.persist(templateZone);	}	privateTemplate = _tmpltDao.findById(templateId);	TemplateDataStoreVO srcTmpltStore = _tmplStoreDao.findByStoreTemplate(store.getId(), templateId);	UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_TEMPLATE_CREATE, privateTemplate.getAccountId(), zoneId, privateTemplate.getId(), privateTemplate.getName(), null, privateTemplate.getSourceTemplateId(), srcTmpltStore.getPhysicalSize(), privateTemplate.getSize());	_usageEventDao.persist(usageEvent);	} catch (InterruptedException e) {	throw new CloudRuntimeException("Failed to create template", e);	} catch (ExecutionException e) {	
failed to create template 

isExtractable = template != null && template.isExtractable() && template.getTemplateType() != Storage.TemplateType.SYSTEM;	if (volume.getIsoId() != null && volume.getIsoId() != 0) {	sourceTemplateId = volume.getIsoId();	} else if (volume.getTemplateId() != null) {	sourceTemplateId = volume.getTemplateId();	}	}	String templateTag = cmd.getTemplateTag();	if (templateTag != null) {	if (s_logger.isDebugEnabled()) {	
adding template tag 

}	}	String templateTag = cmd.getTemplateTag();	if (templateTag != null) {	if (s_logger.isDebugEnabled()) {	}	}	privateTemplate = new VMTemplateVO(nextTemplateId, name, ImageFormat.RAW, isPublic, featured, isExtractable, TemplateType.USER, null, requiresHvmValue, bitsValue, templateOwner.getId(), null, description, passwordEnabledValue, guestOS.getId(), true, hyperType, templateTag, cmd.getDetails(), false, isDynamicScalingEnabled);	if (sourceTemplateId != null) {	if (s_logger.isDebugEnabled()) {	
this template is getting created from other template setting source template id to 

========================= cloudstack sample_2369 =========================

if (privateNic == null) {	privateNic = "xenbr0";	}	final String storageNic = (String)params.get("storage.network.device");	final String storageNic2 = (String)params.get("storage.network.device.2");	_privateNic = getNetworkInterface(privateNic);	_publicNic = getNetworkInterface(publicNic);	_storageNic = getNetworkInterface(storageNic);	_storageNic2 = getNetworkInterface(storageNic2);	if (_privateNic == null) {	
nics are not specified in properties file db will try to autodiscover 

} catch (final SocketException e) {	throw new ConfigurationException("Private NIC is not configured");	}	while (nics.hasMoreElements()) {	final NetworkInterface nic = nics.nextElement();	final String nicName = nic.getName();	if ( !nic.isVirtual() && !nicName.startsWith("vnif") && !nicName.startsWith("vnbr") && !nicName.startsWith("peth") && !nicName.startsWith("vif") && !nicName.startsWith("virbr") && !nicName.contains(":")) {	final String[] info = NetUtils.getNicParams(nicName);	if (info != null && info[0] != null) {	_privateNic = nic;	
designating private to be nic 

while (nics.hasMoreElements()) {	final NetworkInterface nic = nics.nextElement();	final String nicName = nic.getName();	if ( !nic.isVirtual() && !nicName.startsWith("vnif") && !nicName.startsWith("vnbr") && !nicName.startsWith("peth") && !nicName.startsWith("vif") && !nicName.startsWith("virbr") && !nicName.contains(":")) {	final String[] info = NetUtils.getNicParams(nicName);	if (info != null && info[0] != null) {	_privateNic = nic;	break;	}	}	
skipping nic 

break;	}	}	}	if (_privateNic == null) {	throw new ConfigurationException("Private NIC is not configured");	}	}	String infos[] = NetUtils.getNetworkParams(_privateNic);	if (infos == null) {	
incorrect details for private nic during initialization of serverresourcebase 

protected NetworkInterface getNetworkInterface(String nicName) {	
retrieving network interface 

return null;	}	if (nicName.trim().length() == 0) {	return null;	}	nicName = nicName.trim();	NetworkInterface nic;	try {	nic = NetworkInterface.getByName(nicName);	if (nic == null) {	
unable to get network interface for 

}	nicName = nicName.trim();	NetworkInterface nic;	try {	nic = NetworkInterface.getByName(nicName);	if (nic == null) {	return null;	}	return nic;	} catch (final SocketException e) {	
unable to get network interface for 

protected void fillNetworkInformation(final StartupCommand cmd) {	String[] info = null;	if (_privateNic != null) {	info = NetUtils.getNetworkParams(_privateNic);	if (info != null) {	if (s_logger.isDebugEnabled()) {	
parameters for private nic 

if (info != null) {	if (s_logger.isDebugEnabled()) {	}	cmd.setPrivateIpAddress(info[0]);	cmd.setPrivateMacAddress(info[1]);	cmd.setPrivateNetmask(info[2]);	}	}	if (_storageNic != null) {	if (s_logger.isDebugEnabled()) {	
storage has its now nic 

cmd.setPrivateNetmask(info[2]);	}	}	if (_storageNic != null) {	if (s_logger.isDebugEnabled()) {	}	info = NetUtils.getNetworkParams(_storageNic);	}	if (info != null) {	if (s_logger.isDebugEnabled()) {	
parameters for storage nic 

if (s_logger.isDebugEnabled()) {	}	cmd.setStorageIpAddress(info[0]);	cmd.setStorageMacAddress(info[1]);	cmd.setStorageNetmask(info[2]);	}	if (_publicNic != null) {	info = NetUtils.getNetworkParams(_publicNic);	if (info != null) {	if (s_logger.isDebugEnabled()) {	
parameters for public nic 

}	cmd.setPublicIpAddress(info[0]);	cmd.setPublicMacAddress(info[1]);	cmd.setPublicNetmask(info[2]);	}	}	if (_storageNic2 != null) {	info = NetUtils.getNetworkParams(_storageNic2);	if (info != null) {	if (s_logger.isDebugEnabled()) {	
parameters for storage nic 

========================= cloudstack sample_422 =========================

public PingCommand getCurrentStatus(long id) {	if(!initTopologySyncDone && _latestTopology != null){	initTopologySyncDone = true;	if(_bigswitchBcfApi.isNatEnabled()){	try{	executeRequest(new SyncBcfTopologyCommand(true, true), _numRetries);	} catch(Exception e){	
bigswitch bcf sync error 

initTopologySyncDone = true;	if(_bigswitchBcfApi.isNatEnabled()){	try{	executeRequest(new SyncBcfTopologyCommand(true, true), _numRetries);	} catch(Exception e){	}	} else {	try{	executeRequest(new SyncBcfTopologyCommand(true, false), _numRetries);	} catch (Exception e){	
bigswitch bcf sync error 

} else {	try{	executeRequest(new SyncBcfTopologyCommand(true, false), _numRetries);	} catch (Exception e){	}	}	}	try {	ControlClusterStatus ccs = _bigswitchBcfApi.getControlClusterStatus();	if (!ccs.getStatus()) {	
controlcluster state is not ready 

return null;	}	if (ccs.isTopologySyncRequested()) {	if(_latestTopology != null) {	if(_bigswitchBcfApi.isNatEnabled()){	executeRequest(new SyncBcfTopologyCommand(true, true), _numRetries);	} else {	executeRequest(new SyncBcfTopologyCommand(true, false), _numRetries);	}	} else {	
topology sync needed but no topology history 

if(_latestTopology != null) {	if(_bigswitchBcfApi.isNatEnabled()){	executeRequest(new SyncBcfTopologyCommand(true, true), _numRetries);	} else {	executeRequest(new SyncBcfTopologyCommand(true, false), _numRetries);	}	} else {	}	}	} catch (BigSwitchBcfApiException e) {	
getcontrolclusterstatus failed 

if (cap.isTopologySyncRequested()) {	if(_latestTopology != null) {	if(_bigswitchBcfApi.isNatEnabled()){	executeRequest(new SyncBcfTopologyCommand(true, true), _numRetries);	} else {	executeRequest(new SyncBcfTopologyCommand(true, false), _numRetries);	}	}	}	} catch (BigSwitchBcfApiException e) {	
getcapabilities failed 

} else if (cmd instanceof UpdateBcfRouterCommand) {	_latestTopology = ((UpdateBcfRouterCommand) cmd).getTopology();	return executeRequest((UpdateBcfRouterCommand)cmd, numRetries);	} else if (cmd instanceof SyncBcfTopologyCommand) {	return executeRequest((SyncBcfTopologyCommand)cmd, numRetries);	} else if (cmd instanceof CacheBcfTopologyCommand) {	return executeRequest((CacheBcfTopologyCommand)cmd, numRetries);	} else if (cmd instanceof GetControllerDataCommand) {	return executeRequest((GetControllerDataCommand)cmd, numRetries);	}	
received unsupported command 

private Answer retry(Command cmd, int numRetries) {	
retrying number of retries remaining 

========================= cloudstack sample_1545 =========================

}	CallContext callingContext = null;	if (userId == null || accountId == null) {	callingContext = new CallContext(callingUser, callingAccount, contextId);	} else {	callingContext = new CallContext(userId, accountId, contextId);	}	s_currentContext.set(callingContext);	NDC.push("ctx-" + UuidUtils.first(contextId));	if (s_logger.isTraceEnabled()) {	
registered 

public static CallContext registerSystemCallContextOnceOnly() {	try {	CallContext context = s_currentContext.get();	if (context == null) {	return register(null, null, User.UID_SYSTEM, Account.ACCOUNT_ID_SYSTEM, UUID.randomUUID().toString());	}	assert context.getCallingUserId() == User.UID_SYSTEM : "You are calling a very specific method that registers a one time system context.  This method is meant for background threads that does processing.";	return context;	} catch (Exception e) {	
failed to register the system call context 

public static CallContext unregister() {	CallContext context = s_currentContext.get();	if (context == null) {	return null;	}	s_currentContext.remove();	if (s_logger.isTraceEnabled()) {	
unregistered 

if (s_logger.isTraceEnabled()) {	}	String contextId = context.getContextId();	String sessionIdOnStack = null;	String sessionIdPushedToNDC = "ctx-" + UuidUtils.first(contextId);	while ((sessionIdOnStack = NDC.pop()) != null) {	if (sessionIdOnStack.isEmpty() || sessionIdPushedToNDC.equals(sessionIdOnStack)) {	break;	}	if (s_logger.isTraceEnabled()) {	
popping from ndc 

========================= cloudstack sample_2914 =========================

private static String encodeString(String value) {	if (!ApiServer.isEncodeApiResponse()) {	return value;	}	try {	return new URLEncoder().encode(value).replaceAll("\\+", "%20");	} catch (Exception e) {	
unable to encode 

========================= cloudstack sample_2502 =========================

public boolean reconfigureNfsVersion(Integer nfsVersion){	try {	VmwareStorageProcessor processor = (VmwareStorageProcessor) this.processor;	processor.setNfsVersion(nfsVersion);	this._nfsVersion = nfsVersion;	return true;	} catch (Exception e){	
error while reconfiguring nfs version 

}	cacheTemplate.setDataStore(destDataStore);	TemplateObjectTO template = (TemplateObjectTO)answer.getNewData();	template.setDataStore(srcDataStore);	CopyCommand newCmd = new CopyCommand(template, destData, cmd.getWait(), cmd.executeInSequence());	Answer result = storageResource.defaultAction(newCmd);	try {	DeleteCommand deleteCommand = new DeleteCommand(template);	storageResource.defaultAction(deleteCommand);	} catch (Exception e) {	
failed to clean up staging area 

storageManager.createOva(parentPath + File.separator + dir, name);	newSnapshot.setPath(newSnapshot.getPath() + ".ova");	newSnapshot.setDataStore(cmd.getCacheTO().getDataStore());	CopyCommand newCmd = new CopyCommand(newSnapshot, destData, cmd.getWait(), cmd.executeInSequence());	Answer result = storageResource.defaultAction(newCmd);	try {	newSnapshot.setPath(path);	DeleteCommand deleteCommand = new DeleteCommand(newSnapshot);	storageResource.defaultAction(deleteCommand);	} catch (Exception e) {	
failed to clean up staging area 

========================= cloudstack sample_1284 =========================

public DataStore initialize(Map<String, Object> dsInfos) {	String url = (String)dsInfos.get("url");	String name = (String)dsInfos.get("name");	String providerName = (String)dsInfos.get("providerName");	ScopeType scope = (ScopeType)dsInfos.get("scope");	DataStoreRole role = (DataStoreRole)dsInfos.get("role");	Map<String, String> details = (Map<String, String>)dsInfos.get("details");	
trying to add a store with endpoint 

========================= cloudstack sample_1904 =========================

Integer c = 0;	for (final String entry : vmVifs) {	final String[] parts = entry.split(",");	final String[] macpart = parts[0].split("=");	assert macpart.length == 2 : "Invalid entry: " + entry;	if ("mac".equals(macpart[0]) && macpart[1].equals(mac)) {	return c;	}	c += 1;	}	
no vif matched mac in 

Integer c = 0;	for (final String entry : vmVifs) {	final String[] parts = entry.split(",");	final String[] ippart = parts[1].split("=");	assert ippart.length == 2 : "Invalid entry: " + entry;	if ("mac".equals(ippart[0]) && ippart[1].equals(ip)) {	return c;	}	c += 1;	}	
no vif matched ip in 

public Boolean addVif(Integer id, String bridge, String mac) {	if (getVifIdByMac(mac) > 0) {	
already nic with mac present 

public Boolean removeVif(String bridge, String mac) {	List<String> newVifs = new ArrayList<String>();	try {	String remove = "mac=" + mac + ",bridge=" + bridge;	for (String vif : getVmVifs()) {	if (vif.equals(remove)) {	
leaving out vif 

public Boolean removeVif(String bridge, String mac) {	List<String> newVifs = new ArrayList<String>();	try {	String remove = "mac=" + mac + ",bridge=" + bridge;	for (String vif : getVmVifs()) {	if (vif.equals(remove)) {	} else {	
keeping vif 

private Boolean addDiskToDisks(String image, String devName, String mode) {	for (String disk : vmDisks) {	if (disk.contains(image)) {	
already has disk 

public Boolean removeDisk(String image) {	for (String disk : vmDisks) {	if (disk.contains(image)) {	vmDisks.remove(disk);	vmParams.put("disk", vmDisks);	return true;	}	}	
no disk found corresponding to image 

private String getVmDiskDetailFromMap(int disk, String dest) {	Map<String, Object[]> o = (Map<String, Object[]>) vmParams .get("device");	if (o == null) {	
no devices found 

public Map<String, Vm> listVms() throws Ovm3ResourceException {	Object[] result = (Object[]) callWrapper("list_vms");	if (result == null) {	
no vm results on list vms 

public Boolean listVm(String repoId, String vmId) throws Ovm3ResourceException {	defVm.setVmParams((Map<String, Object>) callWrapper("list_vm", repoId, vmId));	if (defVm.getVmParams() == null) {	
no vm results on list vm 

public Vm getVmConfig(String vmName) throws Ovm3ResourceException {	defVm = getRunningVmConfig(vmName);	if (defVm == null) {	
unable to retrieve running config for 

public Vm getVmConfig(String repoId, String vmId) throws Ovm3ResourceException {	try {	Xen.Vm nVm = new Xen.Vm();	Map<String, Object[]> x = (Map<String, Object[]>) callWrapper( "get_vm_config", repoId, vmId);	if (x == null) {	
unable to find vm with id on repoid 

========================= cloudstack sample_863 =========================

private void dropTableColumnsIfExist(Connection conn) {	HashMap<String, List<String>> tablesToModify = new HashMap<String, List<String>>();	List<String> columns = new ArrayList<String>();	columns.add("account_id");	columns.add("domain_id");	tablesToModify.put("domain_router", columns);	
dropping columns that don t exist in version of the db 

private void dropKeysIfExist(Connection conn) {	HashMap<String, List<String>> foreignKeys = new HashMap<String, List<String>>();	HashMap<String, List<String>> indexes = new HashMap<String, List<String>>();	List<String> keys = new ArrayList<String>();	keys.add("fk_domain_router__account_id");	foreignKeys.put("domain_router", keys);	keys = new ArrayList<String>();	keys.add("i_domain_router__account_id");	indexes.put("domain_router", keys);	
dropping keys that don t exist in version of the db 

========================= cloudstack sample_4205 =========================

State newState = transition.getToState();	State oldState = transition.getCurrentState();	if (newState != State.Starting && newState != State.Error && newState != State.Expunging) {	return true;	}	if (vo.getHypervisorType() != HypervisorType.BareMetal) {	return true;	}	HostVO host = _hostDao.findById(vo.getHostId());	if (host == null) {	
skip oldstate to newstate transimtion 

if (vo.getHypervisorType() != HypervisorType.BareMetal) {	return true;	}	HostVO host = _hostDao.findById(vo.getHostId());	if (host == null) {	return true;	}	_hostDao.loadDetails(host);	if (newState == State.Starting) {	host.setDetail("vmName", vo.getInstanceName());	
add vmname vmName to host details 

}	HostVO host = _hostDao.findById(vo.getHostId());	if (host == null) {	return true;	}	_hostDao.loadDetails(host);	if (newState == State.Starting) {	host.setDetail("vmName", vo.getInstanceName());	} else {	if (host.getDetail("vmName") != null && host.getDetail("vmName").equalsIgnoreCase(vo.getInstanceName())) {	
remove vmname vmName from host details 

VMInstanceVO vm = vmq.find();	if (vm == null) {	throw new CloudRuntimeException(String.format("cannot find baremetal instance[name:%s]", vmName));	}	if (State.Starting != vm.getState()) {	throw new CloudRuntimeException(String.format("baremetal instance[name:%s, state:%s] is not in state of Starting", vmName, vm.getState()));	}	vm.setState(State.Running);	vm.setLastHostId(vm.getHostId());	vmDao.update(vm.getId(), vm);	
received baremetal provision done notification for vm id s name s running on host mac s ip s 

========================= cloudstack sample_926 =========================

protected void waitForTask2(final Connection c, final Task task, final long pollInterval, final long timeout) throws XenAPIException, XmlRpcException, TimeoutException {	final long beginTime = System.currentTimeMillis();	if (s_logger.isTraceEnabled()) {	
task sent to is pending completion with a ms timeout 

final Set<Event.Record> events = map.events;	if (events.size() == 0) {	final String msg = "No event for task " + task.toWireString();	s_logger.warn(msg);	task.cancel(c);	throw new TimeoutException(msg);	}	for (final Event.Record rec : events) {	if (!(rec.snapshot instanceof Task.Record)) {	if (s_logger.isDebugEnabled()) {	
skipping over 

}	for (final Event.Record rec : events) {	if (!(rec.snapshot instanceof Task.Record)) {	if (s_logger.isDebugEnabled()) {	}	continue;	}	final Task.Record taskRecord = (Task.Record)rec.snapshot;	if (taskRecord.status != Types.TaskStatusType.PENDING) {	if (s_logger.isDebugEnabled()) {	
task ref uuid is done 

}	continue;	}	final Task.Record taskRecord = (Task.Record)rec.snapshot;	if (taskRecord.status != Types.TaskStatusType.PENDING) {	if (s_logger.isDebugEnabled()) {	}	return;	} else {	if (s_logger.isDebugEnabled()) {	
task ref uuid progress 

public void run() {	setName("XS-Listener-" + _host.getIp());	while (!_stop) {	try {	final Connection conn = getConnection();	EventBatch results;	try {	results = Event.from(conn, _classes, _token, new Double(30));	} catch (final Exception e) {	
retrying the waiting on vm events due to 

results = Event.from(conn, _classes, _token, new Double(30));	} catch (final Exception e) {	continue;	}	_token = results.token;	final Set<Event.Record> events = results.events;	for (final Event.Record event : events) {	try {	if (!(event.snapshot instanceof VM.Record)) {	if (s_logger.isDebugEnabled()) {	
the snapshot is not a vm 

}	continue;	}	final VM.Record vm = (VM.Record)event.snapshot;	String hostUuid = null;	if (vm.residentOn != null && !vm.residentOn.toWireString().contains("OpaqueRef:NULL")) {	hostUuid = vm.residentOn.getUuid(conn);	}	recordChanges(conn, vm, hostUuid);	} catch (final Exception e) {	
skipping over 

final VM.Record vm = (VM.Record)event.snapshot;	String hostUuid = null;	if (vm.residentOn != null && !vm.residentOn.toWireString().contains("OpaqueRef:NULL")) {	hostUuid = vm.residentOn.getUuid(conn);	}	recordChanges(conn, vm, hostUuid);	} catch (final Exception e) {	}	}	} catch (final Throwable th) {	
exception caught in eventlistener thread 

public void start() {	if (_isMaster) {	final Connection conn = getConnection();	EventBatch results;	try {	results = Event.from(conn, _classes, _token, new Double(30));	} catch (final Exception e) {	
retrying the waiting on vm events due to 

public void start() {	if (_isMaster) {	final Connection conn = getConnection();	EventBatch results;	try {	results = Event.from(conn, _classes, _token, new Double(30));	} catch (final Exception e) {	throw new CloudRuntimeException("Unable to start a listener thread to listen to VM events", e);	}	_token = results.token;	
starting the event listener thread for 

========================= cloudstack sample_1142 =========================

public void run() {	while (true) {	try {	_managedContext.runWithContext(new Runnable() {	public void run() {	work();	}	});	} catch (final Throwable th) {	
sg work caught this throwable 

public void work() {	
checking the work queue 

public void work() {	List<SecurityGroupWork> workItems;	try {	workItems = _workQueue.getWork(1);	for (SecurityGroupWork work : workItems) {	if (s_logger.isTraceEnabled()) {	
processing 

public void work() {	List<SecurityGroupWork> workItems;	try {	workItems = _workQueue.getWork(1);	for (SecurityGroupWork work : workItems) {	if (s_logger.isTraceEnabled()) {	}	try {	VmRulesetLogVO rulesetLog = _rulesetLogDao.findByVmId(work.getInstanceId());	if (rulesetLog == null) {	
could not find ruleset log for vm 

}	try {	VmRulesetLogVO rulesetLog = _rulesetLogDao.findByVmId(work.getInstanceId());	if (rulesetLog == null) {	continue;	}	work.setLogsequenceNumber(rulesetLog.getLogsequence());	sendRulesetUpdates(work);	_mBean.logUpdateDetails(work.getInstanceId(), work.getLogsequenceNumber());	} catch (Exception e) {	
problem during sg work 

continue;	}	work.setLogsequenceNumber(rulesetLog.getLogsequence());	sendRulesetUpdates(work);	_mBean.logUpdateDetails(work.getInstanceId(), work.getLogsequenceNumber());	} catch (Exception e) {	work.setStep(Step.Error);	}	}	} catch (InterruptedException e1) {	
sg work caught interruptexception 

s_logger.trace("SecurityGroupManager v2: sent ruleset updates for " + vm.getInstanceName() + " curr queue size=" + _workQueue.size());	}	} catch (AgentUnavailableException e) {	s_logger.debug("Unable to send updates for vm: " + userVmId + "(agentid=" + agentId + ")");	_workTracker.handleException(agentId);	}	}	} else {	if (s_logger.isDebugEnabled()) {	if (vm != null) s_logger.debug("No rules sent to vm " + vm + "state=" + vm.getState());	
could not find vm no rules sent to vm 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	_mBean = new SecurityManagerMBeanImpl(this);	try {	JmxUtil.registerMBean("SecurityGroupManager", "SecurityGroupManagerImpl2", _mBean);	} catch (Exception e) {	
failed to register mbean 

public void enableAllVmsForScheduler() {	
cleared list of disabled vms jmx operation 

public void clearWorkQueue() {	_workQueue.clear();	
cleared the work queue possible jmx operation 

========================= cloudstack sample_2294 =========================

protected void runInContext() {	try {	download(_resume, _callback);	} catch (Exception e) {	
unable to complete download due to 

========================= cloudstack sample_398 =========================

try {	final Map<Pool, Pool.Record> poolRecs = Pool.getAllRecords(conn);	if (poolRecs.size() != 1) {	throw new CloudRuntimeException("There are " + poolRecs.size() + " pool for host :" + citrixResourceBase.getHost().getUuid());	}	final Host master = poolRecs.values().iterator().next().master;	citrixResourceBase.setupServer(conn, master);	final Host host = Host.getByUuid(conn, citrixResourceBase.getHost().getUuid());	citrixResourceBase.setupServer(conn, host);	if (!citrixResourceBase.setIptables(conn)) {	
set xenserver iptable failed 

citrixResourceBase.setupServer(conn, host);	if (!citrixResourceBase.setIptables(conn)) {	return null;	}	if (citrixResourceBase.isSecurityGroupEnabled()) {	final boolean canBridgeFirewall = citrixResourceBase.canBridgeFirewall(conn);	citrixResourceBase.setCanBridgeFirewall(canBridgeFirewall);	if (!canBridgeFirewall) {	final String msg = "Failed to configure brige firewall";	s_logger.warn(msg);	
check host for csp is installed or not and check network mode for bridge 

if (!r) {	return null;	}	citrixResourceBase.cleanupTemplateSR(conn);	try {	if (command.useMultipath()) {	host.addToOtherConfig(conn, "multipathing", "true");	host.addToOtherConfig(conn, "multipathhandle", "dmp");	}	} catch (final Types.MapDuplicateKey e) {	
multipath is already set 

try {	if (command.useMultipath()) {	host.addToOtherConfig(conn, "multipathing", "true");	host.addToOtherConfig(conn, "multipathhandle", "dmp");	}	} catch (final Types.MapDuplicateKey e) {	}	if (command.needSetup() ) {	final String result = citrixResourceBase.callHostPlugin(conn, "vmops", "setup_iscsi", "uuid", citrixResourceBase.getHost().getUuid());	if (!result.contains("> DONE <")) {	
unable to setup iscsi 

}	}	}	}	}	}	}	}	return new SetupAnswer(command, false);	} catch (final XmlRpcException e) {	
unable to setup 

}	}	}	}	}	}	return new SetupAnswer(command, false);	} catch (final XmlRpcException e) {	return new SetupAnswer(command, e.getMessage());	} catch (final XenAPIException e) {	
unable to setup 

}	}	}	}	return new SetupAnswer(command, false);	} catch (final XmlRpcException e) {	return new SetupAnswer(command, e.getMessage());	} catch (final XenAPIException e) {	return new SetupAnswer(command, e.getMessage());	} catch (final Exception e) {	
unable to setup 

========================= cloudstack sample_1210 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all volume usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageVolumeVO> usageUsageVols = s_usageVolumeDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate, false, 0);	if (usageUsageVols.isEmpty()) {	
no volume usage events for this period 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long volId, long zoneId, Long doId, Long templateId, long size) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long volId, long zoneId, Long doId, Long templateId, long size) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating volume usage record for vol usage startdate enddate for account 

========================= cloudstack sample_2650 =========================

public void runJob(AsyncJob job) {	try {	List<AsyncJobJoinMapVO> joinRecords = _joinMapDao.listJoinRecords(job.getId());	if (joinRecords.size() != 1) {	
asyncjob received wakeup call with un supported joining job number 

if (joinRecords.size() != 1) {	job.setSyncSource(null);	return;	}	AsyncJobJoinMapVO joinRecord = joinRecords.get(0);	VmWorkJobVO joinedJob = _workjobDao.findById(joinRecord.getJoinJobId());	Class<?> workClz = null;	try {	workClz = Class.forName(job.getCmd());	} catch (ClassNotFoundException e) {	
vm work class is not found 

assert (account != null);	VMInstanceVO vm = _instanceDao.findById(work.getVmId());	assert (vm != null);	CallContext.register(work.getUserId(), work.getAccountId(), job.getRelated());	try {	Method handler = getHandler(joinRecord.getWakeupHandler());	if (handler != null) {	handler.invoke(_vmMgr);	} else {	assert (false);	
unable to find wakeup handler when waking up job 

Method handler = getHandler(joinRecord.getWakeupHandler());	if (handler != null) {	handler.invoke(_vmMgr);	} else {	assert (false);	}	} finally {	CallContext.unregister();	}	} catch (Throwable e) {	
unexpected exception in waking up job 

private Method getHandler(String wakeupHandler) {	synchronized (_handlerMap) {	Class<?> clz = _vmMgr.getClass();	Method method = _handlerMap.get(wakeupHandler);	if (method != null) return method;	try {	method = clz.getMethod(wakeupHandler);	method.setAccessible(true);	} catch (SecurityException e) {	assert (false);	
unexpected exception 

Method method = _handlerMap.get(wakeupHandler);	if (method != null) return method;	try {	method = clz.getMethod(wakeupHandler);	method.setAccessible(true);	} catch (SecurityException e) {	assert (false);	return null;	} catch (NoSuchMethodException e) {	assert (false);	
unexpected exception 

========================= cloudstack sample_4784 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	ListResponse<UcsManagerResponse> response = mgr.listUcsManager(this);	response.setResponseName(getCommandName());	response.setObjectName("ucsmanager");	this.setResponseObject(response);	} catch (Exception e) {	
exception 

========================= cloudstack sample_1247 =========================

public void setCommands() {	File asyncCommands = null;	if (param.get("apicommands") == null) {	
unable to get the list of commands exiting 

try {	Properties pro = new Properties();	FileInputStream in = new FileInputStream(asyncCommands);	pro.load(in);	Enumeration<?> en = pro.propertyNames();	while (en.hasMoreElements()) {	String key = (String)en.nextElement();	commands.put(key, pro.getProperty(key));	}	} catch (Exception ex) {	
unable to find the file apicommands due to following exception 

public void setConn(String dbPassword) {	this.conn = null;	try {	Class.forName("com.mysql.jdbc.Driver");	this.conn = DriverManager.getConnection("jdbc:mysql: if (!this.conn.isValid(0)) {	
connection to db failed to establish 

public void setInputFile(ArrayList<String> fileNameInput) {	for (String fileName : fileNameInput) {	File file = new File(fileName);	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();	Document doc = null;	try {	DocumentBuilder builder = factory.newDocumentBuilder();	doc = builder.parse(file);	doc.getDocumentElement().normalize();	} catch (Exception ex) {	
unable to load due to 

========================= cloudstack sample_459 =========================

public Answer execute(final OvsSetupBridgeCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	citrixResourceBase.findOrCreateTunnelNetwork(conn, command.getBridgeName());	citrixResourceBase.configureTunnelNetwork(conn, command.getNetworkId(), command.getHostId(), command.getBridgeName());	
ovs bridge configured 

========================= cloudstack sample_1181 =========================

private void addF5LoadBalancer(Connection conn, long hostId, long physicalNetworkId) {	PreparedStatement pstmtUpdate = null;	try {	
adding big ip load balancer with host id in to physical network 

private void addSrxFirewall(Connection conn, long hostId, long physicalNetworkId) {	PreparedStatement pstmtUpdate = null;	try {	
adding srx firewall device with host id in to physical network 

private void addF5ServiceProvider(Connection conn, long physicalNetworkId, long zoneId) {	PreparedStatement pstmtUpdate = null;	try {	
adding physicalnetworkserviceprovider in to physical network 

private void addSrxServiceProvider(Connection conn, long physicalNetworkId, long zoneId) {	PreparedStatement pstmtUpdate = null;	try {	
adding physicalnetworkserviceprovider junipersrx 

private void encryptConfig(Connection conn) {	
encrypting config values 

pstmt.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt configuration values ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt configuration values ", e);	} finally {	closeAutoCloseable(rs);	closeAutoCloseable(pstmt);	}	
done encrypting config values 

========================= cloudstack sample_4229 =========================

public String encryptText(String text) {	if (text == null || text.isEmpty()) return text;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	
unexpected exception 

if (text == null || text.isEmpty()) return text;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	
unexpected exception 

Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	
unexpected exception 

cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	
unexpected exception 

return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	
unexpected exception 

return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	return null;	} catch (InvalidAlgorithmParameterException e) {	
unexpected exception 

public String decryptText(String encryptedText) {	if (encryptedText == null || encryptedText.isEmpty()) return encryptedText;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	
unexpected exception 

if (encryptedText == null || encryptedText.isEmpty()) return encryptedText;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	
unexpected exception 

Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	
unexpected exception 

cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	
unexpected exception 

return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	
unexpected exception 

return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	return null;	} catch (InvalidAlgorithmParameterException e) {	
unexpected exception 

========================= cloudstack sample_2257 =========================

protected Status testIpAddress(Long hostId, String testHostIp) {	try {	Answer pingTestAnswer = _agentMgr.send(hostId, new PingTestCommand(testHostIp));	if (pingTestAnswer == null) {	if (s_logger.isDebugEnabled()) {	
host returns unknown null answer 

protected Status testIpAddress(Long hostId, String testHostIp) {	try {	Answer pingTestAnswer = _agentMgr.send(hostId, new PingTestCommand(testHostIp));	if (pingTestAnswer == null) {	if (s_logger.isDebugEnabled()) {	}	return Status.Unknown;	}	if (pingTestAnswer.getResult()) {	if (s_logger.isDebugEnabled()) {	
host has been successfully pinged returning that host is up 

if (s_logger.isDebugEnabled()) {	}	return Status.Unknown;	}	if (pingTestAnswer.getResult()) {	if (s_logger.isDebugEnabled()) {	}	return Status.Up;	} else {	if (s_logger.isDebugEnabled()) {	
host cannot be pinged returning unknown i don t know state 

if (s_logger.isDebugEnabled()) {	}	return Status.Up;	} else {	if (s_logger.isDebugEnabled()) {	}	return Status.Unknown;	}	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	
host trapped agentunavailableexception returning unknown state 

if (s_logger.isDebugEnabled()) {	}	return Status.Unknown;	}	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	}	return Status.Unknown;	} catch (OperationTimedoutException e) {	if (s_logger.isDebugEnabled()) {	
host trapped operationtimedoutexception returning unknown state 

========================= cloudstack sample_2492 =========================

QuotaCreditsVO credits = new QuotaCreditsVO(accountId, domainId, new BigDecimal(amount), updatedBy);	credits.setUpdatedOn(despositedOn);	QuotaCreditsVO result = _quotaCreditsDao.saveCredits(credits);	final AccountVO account = _accountDao.findById(accountId);	if (account == null) {	throw new InvalidParameterValueException("Account does not exist with account id " + accountId);	}	final boolean lockAccountEnforcement = "true".equalsIgnoreCase(QuotaConfig.QuotaEnableEnforcement.value());	final BigDecimal currentAccountBalance = _quotaBalanceDao.lastQuotaBalance(accountId, domainId, startOfNextDay(new Date(despositedOn.getTime())));	if (s_logger.isDebugEnabled()) {	
addquotacredits depositing on adjusted date current balance 

throw new InvalidParameterValueException("Account does not exist with account id " + accountId);	}	final boolean lockAccountEnforcement = "true".equalsIgnoreCase(QuotaConfig.QuotaEnableEnforcement.value());	final BigDecimal currentAccountBalance = _quotaBalanceDao.lastQuotaBalance(accountId, domainId, startOfNextDay(new Date(despositedOn.getTime())));	if (s_logger.isDebugEnabled()) {	}	_quotaService.saveQuotaAccount(account, currentAccountBalance, despositedOn);	if (lockAccountEnforcement) {	if (currentAccountBalance.compareTo(new BigDecimal(0)) >= 0) {	if (account.getState() == Account.State.locked) {	
unlocking account due to positive balance 

if (s_logger.isDebugEnabled()) {	}	_quotaService.saveQuotaAccount(account, currentAccountBalance, despositedOn);	if (lockAccountEnforcement) {	if (currentAccountBalance.compareTo(new BigDecimal(0)) >= 0) {	if (account.getState() == Account.State.locked) {	_accountMgr.enableAccount(account.getAccountName(), domainId, accountId);	}	} else {	if (_quotaManager.isLockable(account) && account.getState() == Account.State.enabled && enforce) {	
locking account due to negative balance 

========================= cloudstack sample_789 =========================

public static VmwareContext getContext(String vCenterAddress, String vCenterUserName, String vCenterPassword) throws Exception {	VmwareContext context = s_pool.getContext(vCenterAddress, vCenterUserName);	if (context == null) {	context = create(vCenterAddress, vCenterUserName, vCenterPassword);	} else {	if (!context.validate() || (context.getVimClient().getVcenterSessionTimeout() != s_vmwareMgr.getVcenterSessionTimeout())) {	
validation of the context failed dispose and create a new one 

========================= cloudstack sample_1314 =========================

public void init(DaemonContext dc) throws DaemonInitException {	
initializing agentshell from jsvc 

public void init(String[] args) throws ConfigurationException {	File file = new File("/etc/cloudstack/agent/log4j-cloud.xml");	if (!file.exists()) {	file = PropertiesUtil.findConfigFile("log4j-cloud.xml");	}	if (null != file) {	DOMConfigurator.configureAndWatch(file.getAbsolutePath());	
agent started 

public void init(String[] args) throws ConfigurationException {	File file = new File("/etc/cloudstack/agent/log4j-cloud.xml");	if (!file.exists()) {	file = PropertiesUtil.findConfigFile("log4j-cloud.xml");	}	if (null != file) {	DOMConfigurator.configureAndWatch(file.getAbsolutePath());	} else {	
could not start the agent because the absolut path of the file cannot be determined 

}	if (null != file) {	DOMConfigurator.configureAndWatch(file.getAbsolutePath());	} else {	}	final Class<?> c = this.getClass();	_version = c.getPackage().getImplementationVersion();	if (_version == null) {	throw new CloudRuntimeException("Unable to find the implementation version of this agent");	}	
implementation version is 

final Class<?> c = this.getClass();	_version = c.getPackage().getImplementationVersion();	if (_version == null) {	throw new CloudRuntimeException("Unable to find the implementation version of this agent");	}	loadProperties();	parseCommand(args);	if (s_logger.isDebugEnabled()) {	List<String> properties = Collections.list((Enumeration<String>)_properties.propertyNames());	for (String property : properties) {	
found property 

if (_version == null) {	throw new CloudRuntimeException("Unable to find the implementation version of this agent");	}	loadProperties();	parseCommand(args);	if (s_logger.isDebugEnabled()) {	List<String> properties = Collections.list((Enumeration<String>)_properties.propertyNames());	for (String property : properties) {	}	}	
defaulting to using properties file for storage 

if (s_logger.isDebugEnabled()) {	List<String> properties = Collections.list((Enumeration<String>)_properties.propertyNames());	for (String property : properties) {	}	}	_storage = new PropertiesStorage();	_storage.configure("Storage", new HashMap<String, Object>());	for (Map.Entry<String, Object> cmdLineProp : getCmdLineProperties().entrySet()) {	_properties.put(cmdLineProp.getKey(), cmdLineProp.getValue());	}	
defaulting to the constant time backoff algorithm 

private void launchAgentFromTypeInfo() throws ConfigurationException {	String typeInfo = getProperty(null, "type");	if (typeInfo == null) {	
unable to retrieve the type 

String ipv6 = getProperty(null, "ipv6disabled");	if (ipv6 != null) {	ipv6disabled = Boolean.parseBoolean(ipv6);	}	boolean ipv6prefer = false;	String ipv6p = getProperty(null, "ipv6prefer");	if (ipv6p != null) {	ipv6prefer = Boolean.parseBoolean(ipv6p);	}	if (ipv6disabled) {	
preferring address family for agent connection 

ipv6disabled = Boolean.parseBoolean(ipv6);	}	boolean ipv6prefer = false;	String ipv6p = getProperty(null, "ipv6prefer");	if (ipv6p != null) {	ipv6prefer = Boolean.parseBoolean(ipv6p);	}	if (ipv6disabled) {	System.setProperty("java.net.preferIPv4Stack", "true");	if (ipv6prefer) {	
is set to true but is false not preferring for agent connection 

String ipv6p = getProperty(null, "ipv6prefer");	if (ipv6p != null) {	ipv6prefer = Boolean.parseBoolean(ipv6p);	}	if (ipv6disabled) {	System.setProperty("java.net.preferIPv4Stack", "true");	if (ipv6prefer) {	}	} else {	if (ipv6prefer) {	
preferring address family for agent connection 

ipv6prefer = Boolean.parseBoolean(ipv6p);	}	if (ipv6disabled) {	System.setProperty("java.net.preferIPv4Stack", "true");	if (ipv6prefer) {	}	} else {	if (ipv6prefer) {	System.setProperty("java.net.preferIPv6Addresses", "true");	} else {	
using default java settings for preference for agent connection 

if (Boolean.parseBoolean(getProperty(null, "developer"))) {	instance = UUID.randomUUID().toString();	} else {	instance = "";	}	} else {	instance += ".";	}	String pidDir = getProperty(null, "piddir");	final String run = "agent." + instance + "pid";	
checking to see if exists 

} else {	instance += ".";	}	String pidDir = getProperty(null, "piddir");	final String run = "agent." + instance + "pid";	ProcessUtil.pidCheck(pidDir, run);	launchAgent();	try {	while (!_exit) Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored agentshell was interupted 

}	String pidDir = getProperty(null, "piddir");	final String run = "agent." + instance + "pid";	ProcessUtil.pidCheck(pidDir, run);	launchAgent();	try {	while (!_exit) Thread.sleep(1000);	} catch (InterruptedException e) {	}	} catch (final ConfigurationException e) {	
unable to start agent 

ProcessUtil.pidCheck(pidDir, run);	launchAgent();	try {	while (!_exit) Thread.sleep(1000);	} catch (InterruptedException e) {	}	} catch (final ConfigurationException e) {	System.out.println("Unable to start agent: " + e.getMessage());	System.exit(ExitStatus.Configuration.value());	} catch (final Exception e) {	
unable to start agent 

public static void main(String[] args) {	try {	
initializing agentshell from main 

========================= cloudstack sample_2884 =========================

break;	case "tcp": aclRule = new TcpAclRule(ruleParts[4], "ACCEPT".equals(ruleParts[5]), Integer.parseInt(ruleParts[2]), Integer.parseInt(ruleParts[3]));	break;	case "udp": aclRule = new UdpAclRule(ruleParts[4], "ACCEPT".equals(ruleParts[5]), Integer.parseInt(ruleParts[2]), Integer.parseInt(ruleParts[3]));	break;	case "all": aclRule = new AllAclRule(ruleParts[4], "ACCEPT".equals(ruleParts[5]));	break;	default: try {	aclRule = new ProtocolAclRule(ruleParts[5], false, Integer.parseInt(ruleParts[1]));	} catch (final Exception e) {	
problem occured when reading the entries in the ruleparts array actual array size is but trying to read from index 

========================= cloudstack sample_336 =========================

public Answer execute(final OvsDestroyTunnelCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	try {	final Network nw = citrixResourceBase.findOrCreateTunnelNetwork(conn, command.getBridgeName());	if (nw == null) {	
unable to find tunnel network for gre key 

return new Answer(command, false, "No network found");	}	final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovstunnel", "destroy_tunnel", "bridge", bridge, "in_port", command.getInPortName());	if (result.equalsIgnoreCase("SUCCESS")) {	return new Answer(command, true, result);	} else {	return new Answer(command, false, result);	}	} catch (final Exception e) {	
caught execption when destroy ovs tunnel 

========================= cloudstack sample_1178 =========================

private void closeStream() {	if (verbose) System.out.println("[" + this + "] INFO: Closing stream.");	try {	os.close();	} catch (IOException e) {	
ignored io error on output 

private void closeStream() {	if (verbose) System.out.println("[" + this + "] INFO: Closing stream.");	try {	os.close();	} catch (IOException e) {	}	try {	sendEventToAllPads(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	
ignored error sending output close event 

========================= cloudstack sample_5091 =========================

sb.append(String.format(" %s=\"%s\"", key, val.toString()));	} else if (val instanceof XmlObject) {	children.add((XmlObject)val);	} else if (val instanceof List) {	children.addAll((Collection<? extends XmlObject>)val);	} else {	throw new CloudRuntimeException(String.format("unsupported element type[tag:%s, class: %s], only allowed type of [String, List<XmlObject>, Object]", key, val.getClass().getName()));	}	}	if (!children.isEmpty() && text != null) {	
element s cannot have both text s and child elements set text to null 

========================= cloudstack sample_2754 =========================

_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.SUCCEEDED, 0, ApiSerializerHelper.toSerializedString(cmdObj.getResponseObject()));	} catch (InvalidParameterValueException ipve) {	throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ipve.getMessage());	} finally {	CallContext.unregister();	}	} catch (Throwable e) {	String errorMsg = null;	int errorCode = ApiErrorCode.INTERNAL_ERROR.getHttpCode();	if (!(e instanceof ServerApiException)) {	
unexpected exception while executing 

========================= cloudstack sample_2611 =========================

DataStoreTO srcStoreTO = srcTO.getDataStore();	if (srcStoreTO instanceof NfsTO || srcStoreTO.getRole() == DataStoreRole.ImageCache) {	return false;	}	DataTO destTO = destData.getTO();	DataStoreTO destStoreTO = destTO.getDataStore();	if (destStoreTO instanceof NfsTO || destStoreTO.getRole() == DataStoreRole.ImageCache) {	return false;	}	if (s_logger.isDebugEnabled()) {	
needcachestorage true dest at dest role src role 

private Scope pickCacheScopeForCopy(DataObject srcData, DataObject destData) {	Scope srcScope = srcData.getDataStore().getScope();	Scope destScope = destData.getDataStore().getScope();	Scope selectedScope = null;	if (srcScope.getScopeId() != null) {	selectedScope = getZoneScope(srcScope);	} else if (destScope.getScopeId() != null) {	selectedScope = getZoneScope(destScope);	} else {	
cannot find a zone wide scope for movement that needs a cache storage 

s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if (cacheData != null) {	final Long cacheId = cacheData.getId();	final String cacheType = cacheData.getType().toString();	final String cacheUuid = cacheData.getUuid().toString();	if (srcData.getType() == DataObjectType.VOLUME && (destData.getType() == DataObjectType.VOLUME || destData.getType() == DataObjectType.TEMPLATE)) {	
delete cache id uuid 

final Long cacheId = cacheData.getId();	final String cacheType = cacheData.getType().toString();	final String cacheUuid = cacheData.getUuid().toString();	if (srcData.getType() == DataObjectType.VOLUME && (destData.getType() == DataObjectType.VOLUME || destData.getType() == DataObjectType.TEMPLATE)) {	cacheMgr.deleteCacheObject(srcForCopy);	} else {	if ((answer == null || !answer.getResult()) && srcForCopy.getRefCount() < 2) {	s_logger.warn("Copy may not be handled correctly by agent(id: " + (ep != null ? ep.getId() : "\"unspecified\"") + ")." + " Delete " + cacheType + " cache(id: " + cacheId + ", uuid: " + cacheUuid + ")");	cacheMgr.deleteCacheObject(srcForCopy);	} else {	
decrease reference count of cache id uuid 

if ((answer == null || !answer.getResult()) && srcForCopy.getRefCount() < 2) {	s_logger.warn("Copy may not be handled correctly by agent(id: " + (ep != null ? ep.getId() : "\"unspecified\"") + ")." + " Delete " + cacheType + " cache(id: " + cacheId + ", uuid: " + cacheUuid + ")");	cacheMgr.deleteCacheObject(srcForCopy);	} else {	cacheMgr.releaseCacheObject(srcForCopy);	}	}	}	return answer;	} catch (Exception e) {	
copy object failed 

Answer answer = null;	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	return answer;	} catch (Exception e) {	
failed to send to storage pool 

protected Answer copyVolumeBetweenPools(DataObject srcData, DataObject destData) {	String value = configDao.getValue(Config.CopyVolumeWait.key());	int _copyvolumewait = NumbersUtil.parseInt(value, Integer.parseInt(Config.CopyVolumeWait.getDefaultValue()));	Scope destScope = getZoneScope(destData.getDataStore().getScope());	DataStore cacheStore = cacheMgr.getCacheStorage(destScope);	if (cacheStore == null) {	ImageStoreEntity imageStore = (ImageStoreEntity)dataStoreMgr.getImageStore(destScope.getScopeId());	if (!imageStore.getProtocol().equalsIgnoreCase("nfs") && !imageStore.getProtocol().equalsIgnoreCase("cifs")) {	
can t find a nfs or cifs image store to satisfy the need for a staging store 

if (cacheStore == null) {	ImageStoreEntity imageStore = (ImageStoreEntity)dataStoreMgr.getImageStore(destScope.getScopeId());	if (!imageStore.getProtocol().equalsIgnoreCase("nfs") && !imageStore.getProtocol().equalsIgnoreCase("cifs")) {	return null;	}	DataObject objOnImageStore = imageStore.create(srcData);	objOnImageStore.processEvent(Event.CreateOnlyRequested);	Answer answer = copyObject(srcData, objOnImageStore);	if (answer == null || !answer.getResult()) {	if (answer != null) {	
copy to image store failed 

EndPoint ep = selector.select(objOnImageStore, destData);	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if (answer == null || !answer.getResult()) {	if (answer != null) {	
copy to primary store failed 

public void copyAsync(DataObject srcData, DataObject destData, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {	Answer answer = null;	String errMsg = null;	try {	
copyasync inspecting src type copyasync inspecting dest type 

}	} else if (srcData.getType() == DataObjectType.SNAPSHOT && destData.getType() == DataObjectType.SNAPSHOT) {	answer = copySnapshot(srcData, destData);	} else {	answer = copyObject(srcData, destData, destHost);	}	if (answer != null && !answer.getResult()) {	errMsg = answer.getDetails();	}	} catch (Exception e) {	
copy failed 

answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	}	if (cacheData != null) {	cacheMgr.deleteCacheObject(cacheData);	}	return answer;	} catch (Exception e) {	
copy snasphot failed 

========================= cloudstack sample_3903 =========================

public Boolean getRc() throws Ovm3ResourceException {	Object rc = returnCode.get("rc");	Long c = 1L;	if (rc instanceof Integer) {	c = new Long((Integer) rc);	} else if (rc instanceof Long) {	c = (Long) rc;	} else {	
incorrect return code 

public boolean dom0CheckPort(String ip, Integer port, Integer retries, Integer interval) throws Ovm3ResourceException {	Boolean x = false;	Integer sleep = interval;	try {	while (!x && retries > 0) {	x = nullIsFalseCallWrapper("check_dom0_port", ip, port, interval);	retries--;	Thread.sleep(sleep * 1000);	}	} catch (Exception e) {	
port check failed 

========================= cloudstack sample_859 =========================

public void execute() throws ServerApiException {	try {	LinkDomainToLdapResponse response = _ldapManager.linkDomainToLdap(domainId, type, name, accountType);	if(admin!=null) {	LdapUser ldapUser = null;	try {	ldapUser = _ldapManager.getUser(admin, type, name);	} catch (NoLdapUserMatchingQueryException e) {	
no ldap user matching username in the given group ou 

try {	ldapUser = _ldapManager.getUser(admin, type, name);	} catch (NoLdapUserMatchingQueryException e) {	}	if (ldapUser != null && !ldapUser.isDisabled()) {	Account account = _accountService.getActiveAccountByName(admin, domainId);	if (account == null) {	try {	UserAccount userAccount = _accountService.createUserAccount(admin, "", ldapUser.getFirstname(), ldapUser.getLastname(), ldapUser.getEmail(), null, admin, Account.ACCOUNT_TYPE_DOMAIN_ADMIN, RoleType.DomainAdmin.getId(), domainId, null, null, UUID.randomUUID().toString(), UUID.randomUUID().toString(), User.Source.LDAP);	response.setAdminId(String.valueOf(userAccount.getAccountId()));	
created an account with name in the given domain 

ldapUser = _ldapManager.getUser(admin, type, name);	} catch (NoLdapUserMatchingQueryException e) {	}	if (ldapUser != null && !ldapUser.isDisabled()) {	Account account = _accountService.getActiveAccountByName(admin, domainId);	if (account == null) {	try {	UserAccount userAccount = _accountService.createUserAccount(admin, "", ldapUser.getFirstname(), ldapUser.getLastname(), ldapUser.getEmail(), null, admin, Account.ACCOUNT_TYPE_DOMAIN_ADMIN, RoleType.DomainAdmin.getId(), domainId, null, null, UUID.randomUUID().toString(), UUID.randomUUID().toString(), User.Source.LDAP);	response.setAdminId(String.valueOf(userAccount.getAccountId()));	} catch (Exception e) {	
an exception occurred while creating account with name in domain 

}	if (ldapUser != null && !ldapUser.isDisabled()) {	Account account = _accountService.getActiveAccountByName(admin, domainId);	if (account == null) {	try {	UserAccount userAccount = _accountService.createUserAccount(admin, "", ldapUser.getFirstname(), ldapUser.getLastname(), ldapUser.getEmail(), null, admin, Account.ACCOUNT_TYPE_DOMAIN_ADMIN, RoleType.DomainAdmin.getId(), domainId, null, null, UUID.randomUUID().toString(), UUID.randomUUID().toString(), User.Source.LDAP);	response.setAdminId(String.valueOf(userAccount.getAccountId()));	} catch (Exception e) {	}	} else {	
an account with name already exists in the domain 

Account account = _accountService.getActiveAccountByName(admin, domainId);	if (account == null) {	try {	UserAccount userAccount = _accountService.createUserAccount(admin, "", ldapUser.getFirstname(), ldapUser.getLastname(), ldapUser.getEmail(), null, admin, Account.ACCOUNT_TYPE_DOMAIN_ADMIN, RoleType.DomainAdmin.getId(), domainId, null, null, UUID.randomUUID().toString(), UUID.randomUUID().toString(), User.Source.LDAP);	response.setAdminId(String.valueOf(userAccount.getAccountId()));	} catch (Exception e) {	}	} else {	}	} else {	
ldap user with username is disabled in the given group ou 

========================= cloudstack sample_1343 =========================

public Answer execute(final OvsSetTagAndFlowCommand command, final CitrixResourceBase citrixResourceBase) {	citrixResourceBase.setIsOvs(true);	final Connection conn = citrixResourceBase.getConnection();	try {	final Network nw = citrixResourceBase.setupvSwitchNetwork(conn);	final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_set_tag_and_flow", "bridge", bridge, "vmName", command.getVmName(), "tag", command.getTag(), "vlans", command.getVlans(), "seqno", command.getSeqNo());	
set flow for 

try {	final Network nw = citrixResourceBase.setupvSwitchNetwork(conn);	final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_set_tag_and_flow", "bridge", bridge, "vmName", command.getVmName(), "tag", command.getTag(), "vlans", command.getVlans(), "seqno", command.getSeqNo());	if (result != null && result.equalsIgnoreCase("SUCCESS")) {	return new OvsSetTagAndFlowAnswer(command, true, result);	} else {	return new OvsSetTagAndFlowAnswer(command, false, result);	}	} catch (final BadServerResponse e) {	
failed to set tag and flow 

final Network nw = citrixResourceBase.setupvSwitchNetwork(conn);	final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_set_tag_and_flow", "bridge", bridge, "vmName", command.getVmName(), "tag", command.getTag(), "vlans", command.getVlans(), "seqno", command.getSeqNo());	if (result != null && result.equalsIgnoreCase("SUCCESS")) {	return new OvsSetTagAndFlowAnswer(command, true, result);	} else {	return new OvsSetTagAndFlowAnswer(command, false, result);	}	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	
failed to set tag and flow 

final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_set_tag_and_flow", "bridge", bridge, "vmName", command.getVmName(), "tag", command.getTag(), "vlans", command.getVlans(), "seqno", command.getSeqNo());	if (result != null && result.equalsIgnoreCase("SUCCESS")) {	return new OvsSetTagAndFlowAnswer(command, true, result);	} else {	return new OvsSetTagAndFlowAnswer(command, false, result);	}	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
failed to set tag and flow 

========================= cloudstack sample_1206 =========================

protected List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	
zonewidestoragepoolallocator to find storage pool 

protected List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	if (dskCh.useLocalStorage()) {	return null;	}	if (s_logger.isTraceEnabled()) {	List<StoragePoolVO> disabledPools = _storagePoolDao.findDisabledPoolsByScope(plan.getDataCenterId(), null, null, ScopeType.ZONE);	if (disabledPools != null && !disabledPools.isEmpty()) {	for (StoragePoolVO pool : disabledPools) {	
ignoring pool as it is in disabled state 

protected List<StoragePool> reorderPoolsByNumberOfVolumes(DeploymentPlan plan, List<StoragePool> pools, Account account) {	if (account == null) {	return pools;	}	long dcId = plan.getDataCenterId();	List<Long> poolIdsByVolCount = _volumeDao.listZoneWidePoolIdsByVolumeCount(dcId, account.getAccountId());	if (s_logger.isDebugEnabled()) {	
list of pools in ascending order of number of volumes for account id is 

========================= cloudstack sample_4004 =========================

AssignIpAddressFromPodVlanSearch.and("vlanId", AssignIpAddressFromPodVlanSearch.entity().getVlanId(), Op.IN);	SearchBuilder<VlanVO> podVlanSearch = _vlanDao.createSearchBuilder();	podVlanSearch.and("type", podVlanSearch.entity().getVlanType(), Op.EQ);	podVlanSearch.and("networkId", podVlanSearch.entity().getNetworkId(), Op.EQ);	SearchBuilder<PodVlanMapVO> podVlanMapSB = _podVlanMapDao.createSearchBuilder();	podVlanMapSB.and("podId", podVlanMapSB.entity().getPodId(), Op.EQ);	AssignIpAddressFromPodVlanSearch.join("podVlanMapSB", podVlanMapSB, podVlanMapSB.entity().getVlanDbId(), AssignIpAddressFromPodVlanSearch.entity().getVlanId(), JoinType.INNER);	AssignIpAddressFromPodVlanSearch.join("vlan", podVlanSearch, podVlanSearch.entity().getId(), AssignIpAddressFromPodVlanSearch.entity().getVlanId(), JoinType.INNER);	AssignIpAddressFromPodVlanSearch.done();	Network.State.getStateMachine().registerListener(new NetworkStateListener(_configDao));	
network manager is configured 

public boolean applyRules(List<? extends FirewallRule> rules, FirewallRule.Purpose purpose, NetworkRuleApplier applier, boolean continueOnError) throws ResourceUnavailableException {	if (rules == null || rules.size() == 0) {	
there are no rules to forward to the network elements 

}	if (checkIfIpAssocRequired(network, false, publicIps)) {	applyIpAssociations(network, false, continueOnError, publicIps);	}	try {	applier.applyRules(network, purpose, rules);	} catch (ResourceUnavailableException e) {	if (!continueOnError) {	throw e;	}	
problems with applying rules but pushing on 

if (ip == null) {	return true;	}	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing ip id=" + addrId + "; sourceNat = " + ip.isSourceNat());	}	if (ip.getAssociatedWithNetworkId() != null) {	Network network = _networksDao.findById(ip.getAssociatedWithNetworkId());	try {	if (!applyIpAssociations(network, true)) {	
unable to apply ip address associations for 

s_logger.warn(errorMessage.toString());	InsufficientAddressCapacityException ex = new InsufficientAddressCapacityException("Insufficient address capacity", DataCenter.class, dcId);	ex.addProxyObject(ApiDBUtils.findZoneById(dcId).getUuid());	throw ex;	}	assert (addrs.size() == 1) : "Return size is incorrect: " + addrs.size();	if (!fetchFromDedicatedRange && VlanType.VirtualNetwork.equals(vlanUse)) {	try {	_resourceLimitMgr.checkResourceLimit(owner, ResourceType.public_ip);	} catch (ResourceAllocationException ex) {	
failed to allocate resource of type for account 

PublicIp ip = null;	try {	ip = Transaction.execute(new TransactionCallbackWithException<PublicIp, InsufficientAddressCapacityException>() {	public PublicIp doInTransaction(TransactionStatus status) throws InsufficientAddressCapacityException {	Account owner = _accountDao.acquireInLockTable(ownerId);	if (owner == null) {	ConcurrentOperationException ex = new ConcurrentOperationException("Unable to lock account");	throw ex;	}	if (s_logger.isDebugEnabled()) {	
lock account is acquired 

IPAddressVO publicIp = ip.ip();	markPublicIpAsAllocated(publicIp);	_ipAddressDao.update(publicIp.getId(), publicIp);	return ip;	}	});	return ip;	} finally {	if (owner != null) {	if (s_logger.isDebugEnabled()) {	
releasing lock account 

}	});	return ip;	} finally {	if (owner != null) {	if (s_logger.isDebugEnabled()) {	}	_accountDao.releaseFromLockTable(ownerId);	}	if (ip == null) {	
unable to get source nat ip address for account 

continue;	}	services.addAll(ipToServices.get(ip));	}	deployer.applyIps(network, ips, services);	} catch (ResourceUnavailableException e) {	success = false;	if (!continueOnError) {	throw e;	} else {	
resource is not available 

final boolean assign = false;	if (Grouping.AllocationState.Disabled == zone.getAllocationState() && !_accountMgr.isRootAdmin(caller.getId())) {	PermissionDeniedException ex = new PermissionDeniedException("Cannot perform this operation, " + "Zone is currently disabled");	ex.addProxyObject(zone.getUuid(), "zoneId");	throw ex;	}	PublicIp ip = null;	Account accountToLock = null;	try {	if (s_logger.isDebugEnabled()) {	
associate ip address called by the user account 

ex.addProxyObject(zone.getUuid(), "zoneId");	throw ex;	}	PublicIp ip = null;	Account accountToLock = null;	try {	if (s_logger.isDebugEnabled()) {	}	accountToLock = _accountDao.acquireInLockTable(ipOwner.getId());	if (accountToLock == null) {	
unable to lock account 

PublicIp ip = null;	Account accountToLock = null;	try {	if (s_logger.isDebugEnabled()) {	}	accountToLock = _accountDao.acquireInLockTable(ipOwner.getId());	if (accountToLock == null) {	throw new ConcurrentOperationException("Unable to acquire account lock");	}	if (s_logger.isDebugEnabled()) {	
associate ip address lock acquired 

ip = Transaction.execute(new TransactionCallbackWithException<PublicIp, InsufficientAddressCapacityException>() {	public PublicIp doInTransaction(TransactionStatus status) throws InsufficientAddressCapacityException {	PublicIp ip = fetchNewPublicIp(zone.getId(), null, null, ipOwner, vlanType, null, false, assign, null, isSystem, null, displayIp);	if (ip == null) {	InsufficientAddressCapacityException ex = new InsufficientAddressCapacityException("Unable to find available public IP addresses", DataCenter.class, zone .getId());	ex.addProxyObject(ApiDBUtils.findZoneById(zone.getId()).getUuid());	throw ex;	}	CallContext.current().setEventDetails("Ip Id: " + ip.getId());	Ip ipAddress = ip.getAddress();	
got to assign for account in zone 

throw ex;	}	CallContext.current().setEventDetails("Ip Id: " + ip.getId());	Ip ipAddress = ip.getAddress();	return ip;	}	});	} finally {	if (accountToLock != null) {	if (s_logger.isDebugEnabled()) {	
releasing lock account 

CallContext.current().setEventDetails("Ip Id: " + ip.getId());	Ip ipAddress = ip.getAddress();	return ip;	}	});	} finally {	if (accountToLock != null) {	if (s_logger.isDebugEnabled()) {	}	_accountDao.releaseFromLockTable(ipOwner.getId());	
associate ip address lock released 

_accountMgr.checkAccess(CallContext.current().getCallingAccount(), AccessType.UseEntry, false, network);	} else {	throw new InvalidParameterValueException("IP can be associated with guest network of 'shared' type only if " + "network services Source Nat, Static Nat, Port Forwarding, Load balancing, firewall are enabled in the network");	}	}	} else {	_accountMgr.checkAccess(caller, null, true, ipToAssoc);	}	owner = _accountMgr.getAccount(ipToAssoc.getAllocatedToAccountId());	} else {	
unable to find ip address by id 

}	}	} else {	_accountMgr.checkAccess(caller, null, true, ipToAssoc);	}	owner = _accountMgr.getAccount(ipToAssoc.getAllocatedToAccountId());	} else {	return null;	}	if (ipToAssoc.getAssociatedWithNetworkId() != null) {	
ip is already assocaited with network id 

} else {	return null;	}	if (ipToAssoc.getAssociatedWithNetworkId() != null) {	return ipToAssoc;	}	Network network = _networksDao.findById(networkId);	if (network != null) {	_accountMgr.checkAccess(owner, AccessType.UseEntry, false, network);	} else {	
unable to find ip address by id 

NetworkOffering offering = _networkOfferingDao.findById(network.getNetworkOfferingId());	boolean sharedSourceNat = offering.getSharedSourceNat();	boolean isSourceNat = false;	if (!sharedSourceNat) {	if (getExistingSourceNatInNetwork(owner.getId(), networkId) == null) {	if (network.getGuestType() == GuestType.Isolated && network.getVpcId() == null && !ipToAssoc.isPortable()) {	isSourceNat = true;	}	}	}	
associating ip to network 

}	}	IPAddressVO ip = _ipAddressDao.findById(ipId);	ip.setAssociatedWithNetworkId(networkId);	ip.setSourceNat(isSourceNat);	_ipAddressDao.update(ipId, ip);	boolean success = false;	try {	success = applyIpAssociations(network, false);	if (success) {	
successfully associated ip address to network 

}	IPAddressVO ip = _ipAddressDao.findById(ipId);	ip.setAssociatedWithNetworkId(networkId);	ip.setSourceNat(isSourceNat);	_ipAddressDao.update(ipId, ip);	boolean success = false;	try {	success = applyIpAssociations(network, false);	if (success) {	} else {	
failed to associate ip address to network 

try {	success = applyIpAssociations(network, false);	if (success) {	} else {	}	return ip;	} finally {	if (!success && releaseOnFailure) {	if (ip != null) {	try {	
failed to associate ip address so releasing ip from the database 

return ip;	} finally {	if (!success && releaseOnFailure) {	if (ip != null) {	try {	_ipAddressDao.markAsUnavailable(ip.getId());	if (!applyIpAssociations(network, true)) {	_ipAddressDao.unassignIpAddress(ip.getId());	}	} catch (Exception e) {	
unable to disassociate ip address for recovery 

if (zone.getNetworkType() == NetworkType.Advanced) {	if (network.getGuestType() == Network.GuestType.Shared) {	assert (isSharedNetworkOfferingWithServices(network.getNetworkOfferingId()));	_accountMgr.checkAccess(CallContext.current().getCallingAccount(), AccessType.UseEntry, false, network);	}	} else {	_accountMgr.checkAccess(caller, null, true, ipToAssoc);	}	owner = _accountMgr.getAccount(ipToAssoc.getAllocatedToAccountId());	} else {	
unable to find ip address by id 

if (services != null && !services.isEmpty()) {	throw new InvalidParameterValueException("IP " + ipToAssoc + " has services and rules associated in the network " + networkId);	}	}	IPAddressVO ip = _ipAddressDao.findById(ipId);	ip.setAssociatedWithNetworkId(null);	_ipAddressDao.update(ipId, ip);	try {	boolean success = applyIpAssociations(network, false);	if (success) {	
successfully associated ip address to network 

throw new InvalidParameterValueException("IP " + ipToAssoc + " has services and rules associated in the network " + networkId);	}	}	IPAddressVO ip = _ipAddressDao.findById(ipId);	ip.setAssociatedWithNetworkId(null);	_ipAddressDao.update(ipId, ip);	try {	boolean success = applyIpAssociations(network, false);	if (success) {	} else {	
failed to associate ip address to network 

if (createNetwork) {	if (requiredOfferings.get(0).getState() == NetworkOffering.State.Enabled) {	long physicalNetworkId = _networkModel.findPhysicalNetworkId(zoneId, requiredOfferings.get(0).getTags(), requiredOfferings.get(0).getTrafficType());	PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(physicalNetworkId);	if (physicalNetwork == null) {	throw new InvalidParameterValueException("Unable to find physical network with id: " + physicalNetworkId + " and tag: " + requiredOfferings.get(0).getTags());	}	s_logger.debug("Creating network for account " + owner + " from the network offering id=" + requiredOfferings.get(0).getId() + " as a part of createVlanIpRange process");	guestNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), owner.getAccountName() + "-network", owner.getAccountName() + "-network", null, null, null, null, owner, null, physicalNetwork, zoneId, ACLType.Account, null, null, null, null, true, null);	if (guestNetwork == null) {	
failed to create default virtual network for the account in zone 

boolean createNetwork = pair.first();	List<NetworkOfferingVO> requiredOfferings = pair.second();	Network guestNetwork = pair.third();	if (createNetwork && requiredOfferings.get(0).getIsPersistent()) {	DataCenter zone = _dcDao.findById(zoneId);	DeployDestination dest = new DeployDestination(zone, null, null, null);	Account callerAccount = CallContext.current().getCallingAccount();	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + guestNetwork, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, callerAccount);	
implementing network as a part of network provision for persistent network 

if (createNetwork && requiredOfferings.get(0).getIsPersistent()) {	DataCenter zone = _dcDao.findById(zoneId);	DeployDestination dest = new DeployDestination(zone, null, null, null);	Account callerAccount = CallContext.current().getCallingAccount();	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + guestNetwork, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, callerAccount);	try {	Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(guestNetwork.getId(), dest, context);	if (implementedNetwork == null || implementedNetwork.first() == null) {	
failed to implement the network 

Journal journal = new Journal.LogJournal("Implementing " + guestNetwork, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, callerAccount);	try {	Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(guestNetwork.getId(), dest, context);	if (implementedNetwork == null || implementedNetwork.first() == null) {	}	if (implementedNetwork != null) {	guestNetwork = implementedNetwork.second();	}	} catch (Exception ex) {	
failed to implement network elements and resources as a part of network provision due to 

public String acquireGuestIpAddress(Network network, String requestedIp) {	if (requestedIp != null && requestedIp.equals(network.getGateway())) {	
requested ip address is used as a gateway address in network 

public String acquireGuestIpAddress(Network network, String requestedIp) {	if (requestedIp != null && requestedIp.equals(network.getGateway())) {	return null;	}	Set<Long> availableIps = _networkModel.getAvailableIps(network, requestedIp);	if (availableIps == null || availableIps.isEmpty()) {	
there are no free ips in the network 

}	Set<Long> availableIps = _networkModel.getAvailableIps(network, requestedIp);	if (availableIps == null || availableIps.isEmpty()) {	return null;	}	Long[] array = availableIps.toArray(new Long[availableIps.size()]);	if (requestedIp != null) {	String[] cidr = network.getCidr().split("/");	boolean isSameCidr = NetUtils.sameSubnetCIDR(requestedIp, NetUtils.long2Ip(array[0]), Integer.parseInt(cidr[1]));	if (!isSameCidr) {	
requested ip address doesn t belong to the network cidr 

if (availableIps == null || availableIps.isEmpty()) {	return null;	}	Long[] array = availableIps.toArray(new Long[availableIps.size()]);	if (requestedIp != null) {	String[] cidr = network.getCidr().split("/");	boolean isSameCidr = NetUtils.sameSubnetCIDR(requestedIp, NetUtils.long2Ip(array[0]), Integer.parseInt(cidr[1]));	if (!isSameCidr) {	return null;	} else if (NetUtils.IsIpEqualToNetworkOrBroadCastIp(requestedIp, cidr[0], Integer.parseInt(cidr[1]))) {	
requested ip address is equal to the to the network broadcast ip of the network 

public boolean applyStaticNats(List<? extends StaticNat> staticNats, boolean continueOnError, boolean forRevoke) throws ResourceUnavailableException {	if (staticNats == null || staticNats.size() == 0) {	
there are no static nat rules for the network elements 

public boolean applyStaticNats(List<? extends StaticNat> staticNats, boolean continueOnError, boolean forRevoke) throws ResourceUnavailableException {	if (staticNats == null || staticNats.size() == 0) {	return true;	}	Network network = _networksDao.findById(staticNats.get(0).getNetworkId());	boolean success = true;	if (!_networkModel.areServicesSupportedInNetwork(network.getId(), Service.StaticNat)) {	
staticnat service is not supported in specified network id 

if (checkStaticNatIPAssocRequired(network, false, forRevoke, publicIps)) {	applyIpAssociations(network, false, continueOnError, publicIps);	}	StaticNatServiceProvider element = _networkMgr.getStaticNatProviderForNetwork(network);	try {	success = element.applyStaticNats(network, staticNats);	} catch (ResourceUnavailableException e) {	if (!continueOnError) {	throw e;	}	
problems with but pushing on 

public IpAddress assignSystemIp(long networkId, Account owner, boolean forElasticLb, boolean forElasticIp) throws InsufficientAddressCapacityException {	Network guestNetwork = _networksDao.findById(networkId);	NetworkOffering off = _entityMgr.findById(NetworkOffering.class, guestNetwork.getNetworkOfferingId());	IpAddress ip = null;	if ((off.getElasticLb() && forElasticLb) || (off.getElasticIp() && forElasticIp)) {	try {	
allocating system ip address for load balancer rule 

boolean ipv4 = false;	if (network.getGateway() != null) {	if (nic.getIPv4Address() == null) {	ipv4 = true;	PublicIp ip = null;	if (requestedIpv4 != null && vm.getType() == VirtualMachine.Type.DomainRouter) {	Nic placeholderNic = _networkModel.getPlaceholderNicForRouter(network, null);	if (placeholderNic != null) {	IPAddressVO userIp = _ipAddressDao.findByIpAndSourceNetworkId(network.getId(), placeholderNic.getIPv4Address());	ip = PublicIp.createFromAddrAndVlan(userIp, _vlanDao.findById(userIp.getVlanId()));	
nic got an ip address stored in placeholder nic for the network 

public void allocateNicValues(final NicProfile nic, final DataCenter dc, final VirtualMachineProfile vm, final Network network, final String requestedIpv4, final String requestedIpv6) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException {	Transaction.execute(new TransactionCallbackWithExceptionNoReturn<InsufficientAddressCapacityException>() {	public void doInTransactionWithoutResult(TransactionStatus status) throws InsufficientAddressCapacityException {	boolean ipv4 = false;	if (network.getGateway() != null) {	if (nic.getIPv4Address() == null) {	ipv4 = true;	if (requestedIpv4 != null && vm.getType() == VirtualMachine.Type.DomainRouter) {	
there won t be nic assignment for vr id in this network 

public String allocatePublicIpForGuestNic(Network network, Long podId, Account owner, String requestedIp) throws InsufficientAddressCapacityException {	PublicIp ip = assignPublicIpAddress(network.getDataCenterId(), podId, owner, VlanType.DirectAttached, network.getId(), requestedIp, false);	if (ip == null) {	
there is no free public ip address 

========================= cloudstack sample_2353 =========================

ClusterResponse clusterResponse = _responseGenerator.createClusterResponse(cluster, false);	clusterResponses.add(clusterResponse);	}	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add cluster");	}	response.setResponses(clusterResponses);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} catch (DiscoveryException ex) {	
exception 

}	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add cluster");	}	response.setResponses(clusterResponses);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} catch (DiscoveryException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ResourceInUseException ex) {	
exception 

========================= cloudstack sample_3112 =========================

public void allocate(final String vmInstanceName, final VirtualMachineTemplate template, final ServiceOffering serviceOffering, final DiskOfferingInfo rootDiskOfferingInfo, final List<DiskOfferingInfo> dataDiskOfferings, final LinkedHashMap<? extends Network, List<? extends NicProfile>> auxiliaryNetworks, final DeploymentPlan plan, final HypervisorType hyperType) throws InsufficientCapacityException {	final VMInstanceVO vm = _vmDao.findVMByInstanceName(vmInstanceName);	final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());	if (s_logger.isDebugEnabled()) {	
allocating entries for vm 

vm.setDataCenterId(plan.getDataCenterId());	if (plan.getPodId() != null) {	vm.setPodIdToDeployIn(plan.getPodId());	}	assert plan.getClusterId() == null && plan.getPoolId() == null : "We currently don't support cluster and pool preset yet";	final VMInstanceVO vmFinal = _vmDao.persist(vm);	final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmFinal, template, serviceOffering, null, null);	Transaction.execute(new TransactionCallbackWithExceptionNoReturn<InsufficientCapacityException>() {	public void doInTransactionWithoutResult(final TransactionStatus status) throws InsufficientCapacityException {	if (s_logger.isDebugEnabled()) {	
allocating nics for 

Transaction.execute(new TransactionCallbackWithExceptionNoReturn<InsufficientCapacityException>() {	public void doInTransactionWithoutResult(final TransactionStatus status) throws InsufficientCapacityException {	if (s_logger.isDebugEnabled()) {	}	try {	_networkMgr.allocate(vmProfile, auxiliaryNetworks);	} catch (final ConcurrentOperationException e) {	throw new CloudRuntimeException("Concurrent operation while trying to allocate resources for the VM", e);	}	if (s_logger.isDebugEnabled()) {	
allocating disks for 

volumeMgr.allocateTemplatedVolume(Type.ROOT, "ROOT-" + vmFinal.getId(), rootDiskOfferingInfo.getDiskOffering(), rootDiskOfferingInfo.getSize(), rootDiskOfferingInfo.getMinIops(), rootDiskOfferingInfo.getMaxIops(), template, vmFinal, owner);	}	if (dataDiskOfferings != null) {	for (final DiskOfferingInfo dataDiskOfferingInfo : dataDiskOfferings) {	volumeMgr.allocateRawVolume(Type.DATADISK, "DATA-" + vmFinal.getId(), dataDiskOfferingInfo.getDiskOffering(), dataDiskOfferingInfo.getSize(), dataDiskOfferingInfo.getMinIops(), dataDiskOfferingInfo.getMaxIops(), vmFinal, template, owner);	}	}	}	});	if (s_logger.isDebugEnabled()) {	
allocation completed for vm 

protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {	if (vm == null || vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	
unable to find vm or vm is destroyed 

protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {	if (vm == null || vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	}	return;	}	advanceStop(vm.getUuid(), false);	vm = _vmDao.findByUuid(vm.getUuid());	try {	if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {	
unable to destroy the vm because it is not in the correct state 

}	return;	}	advanceStop(vm.getUuid(), false);	vm = _vmDao.findByUuid(vm.getUuid());	try {	if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {	throw new CloudRuntimeException("Unable to destroy " + vm);	}	} catch (final NoTransitionException e) {	
unable to destroy the vm because it is not in the correct state 

advanceStop(vm.getUuid(), false);	vm = _vmDao.findByUuid(vm.getUuid());	try {	if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {	throw new CloudRuntimeException("Unable to destroy " + vm);	}	} catch (final NoTransitionException e) {	throw new CloudRuntimeException("Unable to destroy " + vm, e);	}	if (s_logger.isDebugEnabled()) {	
destroying vm 

if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {	throw new CloudRuntimeException("Unable to destroy " + vm);	}	} catch (final NoTransitionException e) {	throw new CloudRuntimeException("Unable to destroy " + vm, e);	}	if (s_logger.isDebugEnabled()) {	}	final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);	final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());	
cleaning up nics 

}	} catch (final NoTransitionException e) {	throw new CloudRuntimeException("Unable to destroy " + vm, e);	}	if (s_logger.isDebugEnabled()) {	}	final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);	final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());	final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());	_networkMgr.cleanupNics(profile);	
cleaning up hypervisor data structures ex srs in xenserver for managed storage 

final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();	if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {	final Commands cmds = new Commands(Command.OnError.Stop);	for (final Command volumeExpungeCommand : volumeExpungeCommands) {	cmds.addCommand(volumeExpungeCommand);	}	_agentMgr.send(hostId, cmds);	if (!cmds.isSuccessful()) {	for (final Answer answer : cmds.getAnswers()) {	if (!answer.getResult()) {	
failed to expunge vm due to 

}	if (nicExpungeCommands != null) {	for (final Command command : nicExpungeCommands) {	cmds.addCommand(command);	}	}	_agentMgr.send(hostId, cmds);	if (!cmds.isSuccessful()) {	for (final Answer answer : cmds.getAnswers()) {	if (!answer.getResult()) {	
failed to expunge vm due to 

if (!cmds.isSuccessful()) {	for (final Answer answer : cmds.getAnswers()) {	if (!answer.getResult()) {	throw new CloudRuntimeException("Unable to expunge " + vm + " due to " + answer.getDetails());	}	}	}	}	}	if (s_logger.isDebugEnabled()) {	
expunged 

protected boolean checkWorkItems(final VMInstanceVO vm, final State state) throws ConcurrentOperationException {	while (true) {	final ItWorkVO vo = _workDao.findByOutstandingWork(vm.getId(), state);	if (vo == null) {	if (s_logger.isDebugEnabled()) {	
unable to find work for vm and state 

protected boolean checkWorkItems(final VMInstanceVO vm, final State state) throws ConcurrentOperationException {	while (true) {	final ItWorkVO vo = _workDao.findByOutstandingWork(vm.getId(), state);	if (vo == null) {	if (s_logger.isDebugEnabled()) {	}	return true;	}	if (vo.getStep() == Step.Done) {	if (s_logger.isDebugEnabled()) {	
work for is 

return true;	}	if (vo.getStep() == Step.Done) {	if (s_logger.isDebugEnabled()) {	}	return true;	}	final VMInstanceVO instance = _vmDao.findById(vm.getId());	if (instance != null && instance.getState() == State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is already started in db 

}	return true;	}	final VMInstanceVO instance = _vmDao.findById(vm.getId());	if (instance != null && instance.getState() == State.Running) {	if (s_logger.isDebugEnabled()) {	}	return true;	}	if (vo.getSecondsTaskIsInactive() > VmOpCancelInterval.value()) {	
the task item for vm has been inactive for 

if (s_logger.isDebugEnabled()) {	}	return true;	}	if (vo.getSecondsTaskIsInactive() > VmOpCancelInterval.value()) {	return false;	}	try {	Thread.sleep(VmOpWaitInterval.value()*1000);	} catch (final InterruptedException e) {	
waiting for but is interrupted 

return true;	}	if (vo.getSecondsTaskIsInactive() > VmOpCancelInterval.value()) {	return false;	}	try {	Thread.sleep(VmOpWaitInterval.value()*1000);	} catch (final InterruptedException e) {	throw new ConcurrentOperationException("Waiting for " + vm + " but is interrupted");	}	
waiting some more to make sure there s no activity on 

}	return new Ternary<VMInstanceVO, ReservationContext, ItWorkVO>(null, null, work);	}	});	work = result.third();	if (result.first() != null) {	return result;	}	} catch (final NoTransitionException e) {	if (s_logger.isDebugEnabled()) {	
unable to transition into starting state due to 

final VMInstanceVO instance = _vmDao.findById(vmId);	if (instance == null) {	throw new ConcurrentOperationException("Unable to acquire lock on " + vm);	}	if (s_logger.isDebugEnabled()) {	s_logger.debug("Determining why we're unable to update the state to Starting for " + instance + ".  Retry=" + retry);	}	final State state = instance.getState();	if (state == State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is already started 

return null;	}	if (state.isTransitional()) {	if (!checkWorkItems(vm, state)) {	throw new ConcurrentOperationException("There are concurrent operations on " + vm);	} else {	continue;	}	}	if (state != State.Stopped) {	
vm is not in a state to be started 

if (start == null) {	return;	}	vm = start.first();	final ReservationContext ctx = start.second();	ItWorkVO work = start.third();	VMInstanceVO startedVm = null;	final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());	final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());	if (s_logger.isDebugEnabled()) {	
trying to deploy vm vm has dcid and podid 

final ReservationContext ctx = start.second();	ItWorkVO work = start.third();	VMInstanceVO startedVm = null;	final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());	final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());	if (s_logger.isDebugEnabled()) {	}	DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);	if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {	if (s_logger.isDebugEnabled()) {	
advancestart deploymentplan is provided using dcid podid clusterid hostid poolid 

ExcludeList avoids = null;	try {	final Journal journal = start.second().getJournal();	if (planToDeploy != null) {	avoids = planToDeploy.getAvoids();	}	if (avoids == null) {	avoids = new ExcludeList();	}	if (s_logger.isDebugEnabled()) {	
deploy avoids pods clusters hosts 

boolean reuseVolume = true;	final DataCenterDeployment originalPlan = plan;	int retry = StartRetry.value();	while (retry-- != 0) {	if (reuseVolume) {	final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());	for (final VolumeVO vol : vols) {	final Long volTemplateId = vol.getTemplateId();	if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {	if (s_logger.isDebugEnabled()) {	
of is ready but template ids don t match let the planner reassign a new pool 

for (final VolumeVO vol : vols) {	final Long volTemplateId = vol.getTemplateId();	if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {	if (s_logger.isDebugEnabled()) {	}	continue;	}	final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());	if (!pool.isInMaintenance()) {	if (s_logger.isDebugEnabled()) {	
root volume is ready need to place vm in volume s cluster 

if (s_logger.isDebugEnabled()) {	}	final long rootVolDcId = pool.getDataCenterId();	final Long rootVolPodId = pool.getPodId();	final Long rootVolClusterId = pool.getClusterId();	if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {	final Long clusterIdSpecified = planToDeploy.getClusterId();	if (clusterIdSpecified != null && rootVolClusterId != null) {	if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {	if (s_logger.isDebugEnabled()) {	
cannot satisfy the deployment plan passed in since the ready root volume is in different cluster volume s cluster cluster specified 

if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {	if (s_logger.isDebugEnabled()) {	}	throw new ResourceUnavailableException( "Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for " + vm, Cluster.class, clusterIdSpecified);	}	}	plan = new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(), vol.getPoolId(), null, ctx);	} else {	plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);	if (s_logger.isDebugEnabled()) {	
is ready changing deployment plan to use this pool s dcid podid and clusterid 

}	}	}	}	final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());	final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);	DeployDestination dest = null;	try {	dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);	} catch (final AffinityConflictException e2) {	
unable to create deployment affinity rules associted to the vm conflict 

StartAnswer startAnswer = null;	try {	if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {	throw new ConcurrentOperationException("Unable to update the state of the Virtual Machine "+vm.getUuid()+" oldstate: "+vm.getState()+ "Event :"+Event.OperationRetry);	}	} catch (final NoTransitionException e1) {	throw new ConcurrentOperationException(e1.getMessage());	}	try {	if (s_logger.isDebugEnabled()) {	
vm is being created in podid 

if (host_guid != null) {	final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);	if (finalHost == null) {	throw new CloudRuntimeException("Host Guid " + host_guid + " doesn't exist in DB, something went wrong while processing start answer: "+startAnswer);	}	destHostId = finalHost.getId();	}	if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {	syncDiskChainChange(startAnswer);	if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {	
unable to transition to a new state vm uuid vm oldstate event 

syncDiskChainChange(startAnswer);	if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {	throw new ConcurrentOperationException("Failed to deploy VM"+ vm.getUuid());	}	final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();	if (gpuDevice != null) {	_resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());	}	startedVm = vm;	if (s_logger.isDebugEnabled()) {	
start completed for vm 

final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();	if (gpuDevice != null) {	_resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());	}	startedVm = vm;	if (s_logger.isDebugEnabled()) {	}	return;	} else {	if (s_logger.isDebugEnabled()) {	
the guru did not like the answers so stopping 

throw new ExecutionException("Unable to stop this VM, "+vm.getUuid()+" so we are unable to retry the start operation");	}	throw new ExecutionException("Unable to start  VM:"+vm.getUuid()+" due to error in finalizeStart, not retrying");	}	}	s_logger.info("Unable to start VM on " + dest.getHost() + " due to " + (startAnswer == null ? " no start answer" : startAnswer.getDetails()));	if (startAnswer != null && startAnswer.getContextParam("stopRetry") != null) {	break;	}	} catch (OperationTimedoutException e) {	
unable to send the start command to host failed to start vm 

if (startAnswer != null && startAnswer.getContextParam("stopRetry") != null) {	break;	}	} catch (OperationTimedoutException e) {	if (e.isActive()) {	_haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);	}	canRetry = false;	throw new AgentUnavailableException("Unable to start " + vm.getHostName(), destHostId, e);	} catch (final ResourceUnavailableException e) {	
unable to contact resource 

if (e.isActive()) {	_haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);	}	canRetry = false;	throw new AgentUnavailableException("Unable to start " + vm.getHostName(), destHostId, e);	} catch (final ResourceUnavailableException e) {	if (!avoids.add(e)) {	if (e.getScope() == Volume.class || e.getScope() == Nic.class) {	throw e;	} else {	
unexpected resourceunavailableexception 

throw new AgentUnavailableException("Unable to start " + vm.getHostName(), destHostId, e);	} catch (final ResourceUnavailableException e) {	if (!avoids.add(e)) {	if (e.getScope() == Volume.class || e.getScope() == Nic.class) {	throw e;	} else {	throw e;	}	}	} catch (final InsufficientCapacityException e) {	
insufficient capacity 

throw e;	} else {	throw e;	}	}	} catch (final InsufficientCapacityException e) {	if (!avoids.add(e)) {	if (e.getScope() == Volume.class || e.getScope() == Nic.class) {	throw e;	} else {	
unexpected insufficientcapacityexception 

}	}	} catch (final InsufficientCapacityException e) {	if (!avoids.add(e)) {	if (e.getScope() == Volume.class || e.getScope() == Nic.class) {	throw e;	} else {	}	}	} catch (final ExecutionException e) {	
failed to start instance 

} catch (final InsufficientCapacityException e) {	if (!avoids.add(e)) {	if (e.getScope() == Volume.class || e.getScope() == Nic.class) {	throw e;	} else {	}	}	} catch (final ExecutionException e) {	throw new AgentUnavailableException("Unable to start instance due to " + e.getMessage(), destHostId, e);	} catch (final NoTransitionException e) {	
failed to start instance 

userVm.setDetail("platform", platform);	_userVmDao.saveDetails(userVm);	}	}	final GPUDeviceTO gpuDevice = stop.getGpuDevice();	if (gpuDevice != null) {	_resourceMgr.updateGPUDetails(vm.getHostId(), gpuDevice.getGroupDetails());	}	if (!answer.getResult()) {	final String details = answer.getDetails();	
unable to stop vm due to 

final GPUDeviceTO gpuDevice = stop.getGpuDevice();	if (gpuDevice != null) {	_resourceMgr.updateGPUDetails(vm.getHostId(), gpuDevice.getGroupDetails());	}	if (!answer.getResult()) {	final String details = answer.getDetails();	return false;	}	guru.finalizeStop(profile, answer);	} else {	
invalid answer received in response to a stopcommand for 

protected boolean cleanup(final VirtualMachineGuru guru, final VirtualMachineProfile profile, final ItWorkVO work, final Event event, final boolean cleanUpEvenIfUnableToStop) {	final VirtualMachine vm = profile.getVirtualMachine();	final State state = vm.getState();	
cleaning up resources for the vm in state 

protected boolean cleanup(final VirtualMachineGuru guru, final VirtualMachineProfile profile, final ItWorkVO work, final Event event, final boolean cleanUpEvenIfUnableToStop) {	final VirtualMachine vm = profile.getVirtualMachine();	final State state = vm.getState();	try {	if (state == State.Starting) {	if (work != null) {	final Step step = work.getStep();	if (step == Step.Starting && !cleanUpEvenIfUnableToStop) {	
unable to cleanup vm work state is incorrect 

try {	if (state == State.Starting) {	if (work != null) {	final Step step = work.getStep();	if (step == Step.Starting && !cleanUpEvenIfUnableToStop) {	return false;	}	if (step == Step.Started || step == Step.Starting || step == Step.Release) {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	
failed to stop vm in state as a part of cleanup process 

return false;	}	if (step == Step.Started || step == Step.Starting || step == Step.Release) {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	}	if (step != Step.Release && step != Step.Prepare && step != Step.Started && step != Step.Starting) {	
cleanup is not needed for vm work state is incorrect 

return false;	}	}	}	if (step != Step.Release && step != Step.Prepare && step != Step.Started && step != Step.Starting) {	return true;	}	} else {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	
failed to stop vm in state as a part of cleanup process 

} else {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	}	} else if (state == State.Stopping) {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	
failed to stop vm in state as a part of cleanup process 

}	} else if (state == State.Stopping) {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	} else if (state == State.Migrating) {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	
failed to stop vm in state as a part of cleanup process 

}	}	} else if (state == State.Migrating) {	if (vm.getHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	if (vm.getLastHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	
failed to stop vm in state as a part of cleanup process 

return false;	}	}	if (vm.getLastHostId() != null) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	} else if (state == State.Running) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	
failed to stop vm in state as a part of cleanup process 

}	}	} else if (state == State.Running) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	} finally {	try {	_networkMgr.release(profile, cleanUpEvenIfUnableToStop);	
successfully released network resources for the vm 

}	} else if (state == State.Running) {	if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	} finally {	try {	_networkMgr.release(profile, cleanUpEvenIfUnableToStop);	} catch (final Exception e) {	
unable to release some network resources 

if (!sendStop(guru, profile, cleanUpEvenIfUnableToStop, false)) {	return false;	}	}	} finally {	try {	_networkMgr.release(profile, cleanUpEvenIfUnableToStop);	} catch (final Exception e) {	}	volumeMgr.release(profile);	
successfully cleanued up resources for the vm in state 

private void advanceStop(final VMInstanceVO vm, final boolean cleanUpEvenIfUnableToStop) throws AgentUnavailableException, OperationTimedoutException, ConcurrentOperationException {	final State state = vm.getState();	if (state == State.Stopped) {	if (s_logger.isDebugEnabled()) {	
vm is already stopped 

private void advanceStop(final VMInstanceVO vm, final boolean cleanUpEvenIfUnableToStop) throws AgentUnavailableException, OperationTimedoutException, ConcurrentOperationException {	final State state = vm.getState();	if (state == State.Stopped) {	if (s_logger.isDebugEnabled()) {	}	return;	}	if (state == State.Destroyed || state == State.Expunging || state == State.Error) {	if (s_logger.isDebugEnabled()) {	
stopped called on but the state is 

return;	}	if (state == State.Destroyed || state == State.Expunging || state == State.Error) {	if (s_logger.isDebugEnabled()) {	}	return;	}	final ItWorkVO work = _workDao.findByOutstandingWork(vm.getId(), vm.getState());	if (work != null) {	if (s_logger.isDebugEnabled()) {	
found an outstanding work item for this vm with state work id 

}	final ItWorkVO work = _workDao.findByOutstandingWork(vm.getId(), vm.getState());	if (work != null) {	if (s_logger.isDebugEnabled()) {	}	}	final Long hostId = vm.getHostId();	if (hostId == null) {	if (!cleanUpEvenIfUnableToStop) {	if (s_logger.isDebugEnabled()) {	
hostid is null but this is not a forced stop cannot stop vm with state 

}	throw new CloudRuntimeException("Unable to stop " + vm);	}	try {	stateTransitTo(vm, Event.AgentReportStopped, null, null);	} catch (final NoTransitionException e) {	s_logger.warn(e.getMessage());	}	if (work != null) {	if (s_logger.isDebugEnabled()) {	
updating work item to done id 

try {	if (!stateTransitTo(vm, Event.StopRequested, vm.getHostId())) {	throw new ConcurrentOperationException("VM is being operated on.");	}	} catch (final NoTransitionException e1) {	if (!cleanUpEvenIfUnableToStop) {	throw new CloudRuntimeException("We cannot stop " + vm + " when it is in state " + vm.getState());	}	final boolean doCleanup = true;	if (s_logger.isDebugEnabled()) {	
unable to transition the state but we re moving on because it s forced stop 

if (!cleanUpEvenIfUnableToStop) {	throw new CloudRuntimeException("We cannot stop " + vm + " when it is in state " + vm.getState());	}	final boolean doCleanup = true;	if (s_logger.isDebugEnabled()) {	}	if (doCleanup) {	if (cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.StopRequested, cleanUpEvenIfUnableToStop)) {	try {	if (s_logger.isDebugEnabled() && work != null) {	
updating work item to done id 

}	if (doCleanup) {	if (cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.StopRequested, cleanUpEvenIfUnableToStop)) {	try {	if (s_logger.isDebugEnabled() && work != null) {	}	if (!changeState(vm, Event.AgentReportStopped, null, work, Step.Done)) {	throw new CloudRuntimeException("Unable to stop " + vm);	}	} catch (final NoTransitionException e) {	
unable to cleanup 

if (s_logger.isDebugEnabled() && work != null) {	}	if (!changeState(vm, Event.AgentReportStopped, null, work, Step.Done)) {	throw new CloudRuntimeException("Unable to stop " + vm);	}	} catch (final NoTransitionException e) {	throw new CloudRuntimeException("Unable to stop " + vm, e);	}	} else {	if (s_logger.isDebugEnabled()) {	
failed to cleanup vm 

}	vmGuru.finalizeStop(profile, answer);	final GPUDeviceTO gpuDevice = stop.getGpuDevice();	if (gpuDevice != null) {	_resourceMgr.updateGPUDetails(vm.getHostId(), gpuDevice.getGroupDetails());	}	} else {	throw new CloudRuntimeException("Invalid answer received in response to a StopCommand on " + vm.instanceName);	}	} catch (final AgentUnavailableException e) {	
unable to stop vm agent unavailable 

vmGuru.finalizeStop(profile, answer);	final GPUDeviceTO gpuDevice = stop.getGpuDevice();	if (gpuDevice != null) {	_resourceMgr.updateGPUDetails(vm.getHostId(), gpuDevice.getGroupDetails());	}	} else {	throw new CloudRuntimeException("Invalid answer received in response to a StopCommand on " + vm.instanceName);	}	} catch (final AgentUnavailableException e) {	} catch (final OperationTimedoutException e) {	
unable to stop vm operation timed out 

_resourceMgr.updateGPUDetails(vm.getHostId(), gpuDevice.getGroupDetails());	}	} else {	throw new CloudRuntimeException("Invalid answer received in response to a StopCommand on " + vm.instanceName);	}	} catch (final AgentUnavailableException e) {	} catch (final OperationTimedoutException e) {	} finally {	if (!stopped) {	if (!cleanUpEvenIfUnableToStop) {	
unable to stop vm 

throw new CloudRuntimeException("Invalid answer received in response to a StopCommand on " + vm.instanceName);	}	} catch (final AgentUnavailableException e) {	} catch (final OperationTimedoutException e) {	} finally {	if (!stopped) {	if (!cleanUpEvenIfUnableToStop) {	try {	stateTransitTo(vm, Event.OperationFailed, vm.getHostId());	} catch (final NoTransitionException e) {	
unable to transition the state 

} catch (final OperationTimedoutException e) {	} finally {	if (!stopped) {	if (!cleanUpEvenIfUnableToStop) {	try {	stateTransitTo(vm, Event.OperationFailed, vm.getHostId());	} catch (final NoTransitionException e) {	}	throw new CloudRuntimeException("Unable to stop " + vm);	} else {	
unable to actually stop but continue with release because it s a force stop 

stateTransitTo(vm, Event.OperationFailed, vm.getHostId());	} catch (final NoTransitionException e) {	}	throw new CloudRuntimeException("Unable to stop " + vm);	} else {	vmGuru.finalizeStop(profile, answer);	}	}	}	if (s_logger.isDebugEnabled()) {	
is stopped on the host proceeding to release resource held 

throw new CloudRuntimeException("Unable to stop " + vm);	} else {	vmGuru.finalizeStop(profile, answer);	}	}	}	if (s_logger.isDebugEnabled()) {	}	try {	_networkMgr.release(profile, cleanUpEvenIfUnableToStop);	
successfully released network resources for the vm 

} else {	vmGuru.finalizeStop(profile, answer);	}	}	}	if (s_logger.isDebugEnabled()) {	}	try {	_networkMgr.release(profile, cleanUpEvenIfUnableToStop);	} catch (final Exception e) {	
unable to release some network resources 

}	if (s_logger.isDebugEnabled()) {	}	try {	_networkMgr.release(profile, cleanUpEvenIfUnableToStop);	} catch (final Exception e) {	}	try {	if (vm.getHypervisorType() != HypervisorType.BareMetal) {	volumeMgr.release(profile);	
successfully released storage resources for the vm 

}	try {	_networkMgr.release(profile, cleanUpEvenIfUnableToStop);	} catch (final Exception e) {	}	try {	if (vm.getHypervisorType() != HypervisorType.BareMetal) {	volumeMgr.release(profile);	}	} catch (final Exception e) {	
unable to release storage resources 

}	try {	if (vm.getHypervisorType() != HypervisorType.BareMetal) {	volumeMgr.release(profile);	}	} catch (final Exception e) {	}	try {	if (work != null) {	if (s_logger.isDebugEnabled()) {	
updating the outstanding work item to done id 

protected boolean stateTransitTo(final VMInstanceVO vm, final VirtualMachine.Event e, final Long hostId, final String reservationId) throws NoTransitionException {	if (_vmSnapshotMgr.hasActiveVMSnapshotTasks(vm.getId())) {	
state transit with event failed due to has active vm snapshots tasks 

public boolean stateTransitTo(final VirtualMachine vm1, final VirtualMachine.Event e, final Long hostId) throws NoTransitionException {	final VMInstanceVO vm = (VMInstanceVO)vm1;	if (_vmSnapshotMgr.hasActiveVMSnapshotTasks(vm.getId())) {	
state transit with event failed due to has active vm snapshots tasks 

public void destroy(final String vmUuid) throws AgentUnavailableException, OperationTimedoutException, ConcurrentOperationException {	VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	if (vm == null || vm.getState() == State.Destroyed || vm.getState() == State.Expunging || vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	
unable to find vm or vm is destroyed 

public void destroy(final String vmUuid) throws AgentUnavailableException, OperationTimedoutException, ConcurrentOperationException {	VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	if (vm == null || vm.getState() == State.Destroyed || vm.getState() == State.Expunging || vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	}	return;	}	if (s_logger.isDebugEnabled()) {	
destroying vm 

VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	if (vm == null || vm.getState() == State.Destroyed || vm.getState() == State.Expunging || vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	}	return;	}	if (s_logger.isDebugEnabled()) {	}	advanceStop(vmUuid, VmDestroyForcestop.value());	if (!_vmSnapshotMgr.deleteAllVMSnapshots(vm.getId(), null)) {	
unable to delete all snapshots for 

}	if (s_logger.isDebugEnabled()) {	}	advanceStop(vmUuid, VmDestroyForcestop.value());	if (!_vmSnapshotMgr.deleteAllVMSnapshots(vm.getId(), null)) {	throw new CloudRuntimeException("Unable to delete vm snapshots for " + vm);	}	vm = _vmDao.findByUuid(vmUuid);	try {	if (!stateTransitTo(vm, VirtualMachine.Event.DestroyRequested, vm.getHostId())) {	
unable to destroy the vm because it is not in the correct state 

private void orchestrateStorageMigration(final String vmUuid, final StoragePool destPool) {	final VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	if (destPool == null) {	throw new CloudRuntimeException("Unable to migrate vm: missing destination storage pool");	}	try {	stateTransitTo(vm, VirtualMachine.Event.StorageMigrationRequested, null);	} catch (final NoTransitionException e) {	
unable to migrate vm 

Long srcHostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();	if (srcHostId != null) {	HostVO srcHost = _hostDao.findById(srcHostId);	srcClusterId = srcHost.getClusterId();	}	final Long destClusterId = destPool.getClusterId();	if (srcClusterId != null && destClusterId != null && ! srcClusterId.equals(destClusterId)) {	final String srcDcName = _clusterDetailsDao.getVmwareDcName(srcClusterId);	final String destDcName = _clusterDetailsDao.getVmwareDcName(destClusterId);	if (srcDcName != null && destDcName != null && !srcDcName.equals(destDcName)) {	
since vm s storage was successfully migrated across vmware datacenters unregistering vm from source host 

uvc.setCleanupVmFiles(true);	try {	_agentMgr.send(srcHostId, uvc);	} catch (final AgentUnavailableException | OperationTimedoutException e) {	throw new CloudRuntimeException("Failed to unregister VM: " + vm.getInstanceName() + " from source host: " + srcHostId + " after successfully migrating VM's storage across VMware Datacenters");	}	}	}	}	} else {	
storage migration failed 

_agentMgr.send(srcHostId, uvc);	} catch (final AgentUnavailableException | OperationTimedoutException e) {	throw new CloudRuntimeException("Failed to unregister VM: " + vm.getInstanceName() + " from source host: " + srcHostId + " after successfully migrating VM's storage across VMware Datacenters");	}	}	}	}	} else {	}	} catch (final ConcurrentOperationException e) {	
failed to migration 

throw new CloudRuntimeException("Failed to unregister VM: " + vm.getInstanceName() + " from source host: " + srcHostId + " after successfully migrating VM's storage across VMware Datacenters");	}	}	}	}	} else {	}	} catch (final ConcurrentOperationException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientVirtualNetworkCapacityException e) {	
failed to migration 

}	}	}	} else {	}	} catch (final ConcurrentOperationException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientVirtualNetworkCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientAddressCapacityException e) {	
failed to migration 

}	} else {	}	} catch (final ConcurrentOperationException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientVirtualNetworkCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientAddressCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientCapacityException e) {	
failed to migration 

}	} catch (final ConcurrentOperationException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientVirtualNetworkCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientAddressCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final StorageUnavailableException e) {	
failed to migration 

} catch (final InsufficientAddressCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final InsufficientCapacityException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} catch (final StorageUnavailableException e) {	throw new CloudRuntimeException("Failed to migration: " + e.toString());	} finally {	try {	stateTransitTo(vm, VirtualMachine.Event.AgentReportStopped, null);	} catch (final NoTransitionException e) {	
failed to change vm state 

private void orchestrateMigrate(final String vmUuid, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {	final VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	if (vm == null) {	if (s_logger.isDebugEnabled()) {	
unable to find the vm 

protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {	
migrating to 

protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {	final long dstHostId = dest.getHost().getId();	final Host fromHost = _hostDao.findById(srcHostId);	if (fromHost == null) {	
unable to find the host to migrate from 

protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {	final long dstHostId = dest.getHost().getId();	final Host fromHost = _hostDao.findById(srcHostId);	if (fromHost == null) {	throw new CloudRuntimeException("Unable to find the host to migrate from: " + srcHostId);	}	if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {	final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());	for (final VolumeVO volume : volumes) {	if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {	
source and destination host are not in same cluster and all volumes are not on zone wide primary store unable to migrate to host 

final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());	for (final VolumeVO volume : volumes) {	if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {	throw new CloudRuntimeException( "Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: " + dest.getHost().getId());	}	}	}	final VirtualMachineGuru vmGuru = getVmGuru(vm);	if (vm.getState() != State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is not running unable to migrate the vm 

if (pfma == null) {	_networkMgr.rollbackNicForMigration(vmSrc, profile);	work.setStep(Step.Done);	_workDao.update(work.getId(), work);	}	}	vm.setLastHostId(srcHostId);	try {	if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {	_networkMgr.rollbackNicForMigration(vmSrc, profile);	
migration cancelled because state has changed 

}	}	vm.setLastHostId(srcHostId);	try {	if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {	_networkMgr.rollbackNicForMigration(vmSrc, profile);	throw new ConcurrentOperationException("Migration cancelled because state has changed: " + vm);	}	} catch (final NoTransitionException e1) {	_networkMgr.rollbackNicForMigration(vmSrc, profile);	
migration cancelled because 

final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));	mc.setHostGuid(dest.getHost().getGuid());	try {	final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);	if (ma == null || !ma.getResult()) {	final String details = ma != null ? ma.getDetails() : "null answer returned";	throw new CloudRuntimeException(details);	}	} catch (final OperationTimedoutException e) {	if (e.isActive()) {	
active migration command so scheduling a restart for 

}	try {	if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {	throw new ConcurrentOperationException("Unable to change the state for " + vm);	}	} catch (final NoTransitionException e1) {	throw new ConcurrentOperationException("Unable to change state due to " + e1.getMessage());	}	try {	if (!checkVmOnHost(vm, dstHostId)) {	
unable to complete migration for 

throw new ConcurrentOperationException("Unable to change the state for " + vm);	}	} catch (final NoTransitionException e1) {	throw new ConcurrentOperationException("Unable to change state due to " + e1.getMessage());	}	try {	if (!checkVmOnHost(vm, dstHostId)) {	try {	_agentMgr.send(srcHostId, new Commands(cleanup(vm)), null);	} catch (final AgentUnavailableException e) {	
agentunavailableexception while cleanup on source host 

try {	if (!checkVmOnHost(vm, dstHostId)) {	try {	_agentMgr.send(srcHostId, new Commands(cleanup(vm)), null);	} catch (final AgentUnavailableException e) {	}	cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);	throw new CloudRuntimeException("Unable to complete migration for " + vm);	}	} catch (final OperationTimedoutException e) {	
error while checking the vm on host 

} catch (final AgentUnavailableException e) {	}	cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);	throw new CloudRuntimeException("Unable to complete migration for " + vm);	}	} catch (final OperationTimedoutException e) {	}	migrated = true;	} finally {	if (!migrated) {	
migration was unsuccessful cleaning up 

} catch (final OperationTimedoutException e) {	}	migrated = true;	} finally {	if (!migrated) {	_networkMgr.rollbackNicForMigration(vmSrc, profile);	_alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(), "Unable to migrate vm " + vm.getInstanceName() + " from host " + fromHost.getName() + " in zone " + dest.getDataCenter().getName() + " and pod " + dest.getPod().getName(), "Migrate Command failed.  Please check logs.");	try {	_agentMgr.send(dstHostId, new Commands(cleanup(vm)), null);	} catch (final AgentUnavailableException ae) {	
looks like the destination host is unavailable for cleanup 

private <T extends VMInstanceVO> void moveVmToMigratingState(final T vm, final Long hostId, final ItWorkVO work) throws ConcurrentOperationException {	try {	if (!changeState(vm, Event.MigrationRequested, hostId, work, Step.Migrating)) {	
migration cancelled because state has changed 

private <T extends VMInstanceVO> void moveVmToMigratingState(final T vm, final Long hostId, final ItWorkVO work) throws ConcurrentOperationException {	try {	if (!changeState(vm, Event.MigrationRequested, hostId, work, Step.Migrating)) {	throw new ConcurrentOperationException("Migration cancelled because state has changed: " + vm);	}	} catch (final NoTransitionException e) {	
migration cancelled because 

private <T extends VMInstanceVO> void moveVmOutofMigratingStateOnSuccess(final T vm, final Long hostId, final ItWorkVO work) throws ConcurrentOperationException {	try {	if (!changeState(vm, Event.OperationSucceeded, hostId, work, Step.Started)) {	
unable to change the state for 

private <T extends VMInstanceVO> void moveVmOutofMigratingStateOnSuccess(final T vm, final Long hostId, final ItWorkVO work) throws ConcurrentOperationException {	try {	if (!changeState(vm, Event.OperationSucceeded, hostId, work, Step.Started)) {	throw new ConcurrentOperationException("Unable to change the state for " + vm);	}	} catch (final NoTransitionException e) {	
unable to change state due to 

String vmName = vm.getInstanceName();	String configDriveIsoRootFolder = "/tmp";	String isoFile = configDriveIsoRootFolder + "/" + vmName + "/configDrive/" + vmName + ".iso";	profile.setVmData(vmData);	profile.setConfigDriveLabel(VmConfigDriveLabel.value());	profile.setConfigDriveIsoRootFolder(configDriveIsoRootFolder);	profile.setConfigDriveIsoFile(isoFile);	AttachOrDettachConfigDriveCommand dettachCommand = new AttachOrDettachConfigDriveCommand(vm.getInstanceName(), vmData, VmConfigDriveLabel.value(), false);	try {	_agentMgr.send(srcHost.getId(), dettachCommand);	
deleted config drive iso for vm in host 

String configDriveIsoRootFolder = "/tmp";	String isoFile = configDriveIsoRootFolder + "/" + vmName + "/configDrive/" + vmName + ".iso";	profile.setVmData(vmData);	profile.setConfigDriveLabel(VmConfigDriveLabel.value());	profile.setConfigDriveIsoRootFolder(configDriveIsoRootFolder);	profile.setConfigDriveIsoFile(isoFile);	AttachOrDettachConfigDriveCommand dettachCommand = new AttachOrDettachConfigDriveCommand(vm.getInstanceName(), vmData, VmConfigDriveLabel.value(), false);	try {	_agentMgr.send(srcHost.getId(), dettachCommand);	} catch (OperationTimedoutException e) {	
time out occured while exeuting command attachordettachconfigdrive 

try {	_agentMgr.send(srcHost.getId(), dettachCommand);	} catch (OperationTimedoutException e) {	}	}	}	volumeMgr.migrateVolumes(vm, to, srcHost, destHost, volumeToPoolMap);	moveVmOutofMigratingStateOnSuccess(vm, destHost.getId(), work);	try {	if (!checkVmOnHost(vm, destHostId)) {	
vm not found on destination host unable to complete migration for 

}	}	}	volumeMgr.migrateVolumes(vm, to, srcHost, destHost, volumeToPoolMap);	moveVmOutofMigratingStateOnSuccess(vm, destHost.getId(), work);	try {	if (!checkVmOnHost(vm, destHostId)) {	try {	_agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);	} catch (final AgentUnavailableException e) {	
agentunavailableexception while cleanup on source host 

try {	if (!checkVmOnHost(vm, destHostId)) {	try {	_agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);	} catch (final AgentUnavailableException e) {	}	cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);	throw new CloudRuntimeException("VM not found on desintation host. Unable to complete migration for " + vm);	}	} catch (final OperationTimedoutException e) {	
error while checking the vm is on host 

} catch (final AgentUnavailableException e) {	}	cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);	throw new CloudRuntimeException("VM not found on desintation host. Unable to complete migration for " + vm);	}	} catch (final OperationTimedoutException e) {	}	migrated = true;	} finally {	if (!migrated) {	
migration was unsuccessful cleaning up 

}	migrated = true;	} finally {	if (!migrated) {	_alertMgr.sendAlert(alertType, srcHost.getDataCenterId(), srcHost.getPodId(), "Unable to migrate vm " + vm.getInstanceName() + " from host " + srcHost.getName() + " in zone " + dc.getName() + " and pod " + dc.getName(), "Migrate Command failed.  Please check logs.");	try {	_agentMgr.send(destHostId, new Commands(cleanup(vm.getInstanceName())), null);	vm.setPodIdToDeployIn(srcHost.getPodId());	stateTransitTo(vm, Event.OperationFailed, srcHostId);	} catch (final AgentUnavailableException e) {	
looks like the destination host is unavailable for cleanup 

migrated = true;	} finally {	if (!migrated) {	_alertMgr.sendAlert(alertType, srcHost.getDataCenterId(), srcHost.getPodId(), "Unable to migrate vm " + vm.getInstanceName() + " from host " + srcHost.getName() + " in zone " + dc.getName() + " and pod " + dc.getName(), "Migrate Command failed.  Please check logs.");	try {	_agentMgr.send(destHostId, new Commands(cleanup(vm.getInstanceName())), null);	vm.setPodIdToDeployIn(srcHost.getPodId());	stateTransitTo(vm, Event.OperationFailed, srcHostId);	} catch (final AgentUnavailableException e) {	} catch (final NoTransitionException e) {	
error while transitioning vm from migrating to running state 

protected void cancelWorkItems(final long nodeId) {	final GlobalLock scanLock = GlobalLock.getInternLock("vmmgr.cancel.workitem");	try {	if (scanLock.lock(3)) {	try {	final List<ItWorkVO> works = _workDao.listWorkInProgressFor(nodeId);	for (final ItWorkVO work : works) {	
handling unfinished work item 

work.setManagementServerId(_nodeId);	work.setStep(Step.Done);	_workDao.update(work.getId(), work);	} else if (work.getType() == State.Migrating) {	_haMgr.scheduleMigration(vm);	work.setStep(Step.Done);	_workDao.update(work.getId(), work);	}	}	} catch (final Exception e) {	
error while handling 

public void migrateAway(final String vmUuid, final long srcHostId) throws InsufficientServerCapacityException {	final AsyncJobExecutionContext jobContext = AsyncJobExecutionContext.getCurrentExecutionContext();	if (jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {	VmWorkJobVO placeHolder = null;	final VirtualMachine vm = _vmDao.findByUuid(vmUuid);	placeHolder = createPlaceHolderWork(vm.getId());	try {	try {	orchestrateMigrateAway(vmUuid, srcHostId, null);	} catch (final InsufficientServerCapacityException e) {	
failed to deploy vm with original planner sending haplanner 

private void orchestrateMigrateAway(final String vmUuid, final long srcHostId, final DeploymentPlanner planner) throws InsufficientServerCapacityException {	final VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	if (vm == null) {	
unable to find a vm for 

private void orchestrateMigrateAway(final String vmUuid, final long srcHostId, final DeploymentPlanner planner) throws InsufficientServerCapacityException {	final VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	if (vm == null) {	throw new CloudRuntimeException("Unable to find " + vmUuid);	}	ServiceOfferingVO offeringVO = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());	final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, offeringVO, null, null);	final Long hostId = vm.getHostId();	if (hostId == null) {	
unable to migrate because the vm doesn t have a host id 

}	}	final DataCenterDeployment plan = new DataCenterDeployment(host.getDataCenterId(), host.getPodId(), host.getClusterId(), null, poolId, null);	final ExcludeList excludes = new ExcludeList();	excludes.addHost(hostId);	DeployDestination dest = null;	while (true) {	try {	dest = _dpMgr.planDeployment(profile, plan, excludes, planner);	} catch (final AffinityConflictException e2) {	
unable to create deployment affinity rules associted to the vm conflict 

excludes.addHost(hostId);	DeployDestination dest = null;	while (true) {	try {	dest = _dpMgr.planDeployment(profile, plan, excludes, planner);	} catch (final AffinityConflictException e2) {	throw new CloudRuntimeException("Unable to create deployment, affinity rules associted to the VM conflict");	}	if (dest != null) {	if (s_logger.isDebugEnabled()) {	
found destination for migrating to 

try {	dest = _dpMgr.planDeployment(profile, plan, excludes, planner);	} catch (final AffinityConflictException e2) {	throw new CloudRuntimeException("Unable to create deployment, affinity rules associted to the VM conflict");	}	if (dest != null) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
unable to find destination for migrating the vm 

} else {	if (s_logger.isDebugEnabled()) {	}	throw new InsufficientServerCapacityException("Unable to find a server to migrate to.", host.getClusterId());	}	excludes.addHost(dest.getHost().getId());	try {	migrate(vm, srcHostId, dest);	return;	} catch (final ResourceUnavailableException e) {	
unable to migrate to unavailable 

if (s_logger.isDebugEnabled()) {	}	throw new InsufficientServerCapacityException("Unable to find a server to migrate to.", host.getClusterId());	}	excludes.addHost(dest.getHost().getId());	try {	migrate(vm, srcHostId, dest);	return;	} catch (final ResourceUnavailableException e) {	} catch (final ConcurrentOperationException e) {	
unable to migrate vm due to 

try {	migrate(vm, srcHostId, dest);	return;	} catch (final ResourceUnavailableException e) {	} catch (final ConcurrentOperationException e) {	}	try {	advanceStop(vmUuid, true);	throw new CloudRuntimeException("Unable to migrate " + vm);	} catch (final ResourceUnavailableException e) {	
unable to stop vm due to 

return;	} catch (final ResourceUnavailableException e) {	} catch (final ConcurrentOperationException e) {	}	try {	advanceStop(vmUuid, true);	throw new CloudRuntimeException("Unable to migrate " + vm);	} catch (final ResourceUnavailableException e) {	throw new CloudRuntimeException("Unable to migrate " + vm);	} catch (final ConcurrentOperationException e) {	
unable to stop vm due to 

} catch (final ConcurrentOperationException e) {	}	try {	advanceStop(vmUuid, true);	throw new CloudRuntimeException("Unable to migrate " + vm);	} catch (final ResourceUnavailableException e) {	throw new CloudRuntimeException("Unable to migrate " + vm);	} catch (final ConcurrentOperationException e) {	throw new CloudRuntimeException("Unable to migrate " + vm);	} catch (final OperationTimedoutException e) {	
unable to stop vm due to 

protected void runInContext() {	
vm operation thread running 

protected void runInContext() {	try {	_workDao.cleanup(VmOpCleanupWait.value());	final Date cutDate = new Date(new Date().getTime() - 3600000);	_workJobDao.expungeCompletedWorkJobs(cutDate);	} catch (final Exception e) {	
vm operations failed due to 

try {	final Commands cmds = new Commands(Command.OnError.Stop);	cmds.addCommand(new RebootCommand(vm.getInstanceName(), getExecuteInSequence(vm.getHypervisorType())));	_agentMgr.send(host.getId(), cmds);	final Answer rebootAnswer = cmds.getAnswer(RebootAnswer.class);	if (rebootAnswer != null && rebootAnswer.getResult()) {	return;	}	s_logger.info("Unable to reboot VM " + vm + " on " + dest.getHost() + " due to " + (rebootAnswer == null ? " no reboot answer" : rebootAnswer.getDetails()));	} catch (final OperationTimedoutException e) {	
unable to send the reboot command to host for the vm due to operation timeout 

private void ensureVmRunningContext(final long hostId, VMInstanceVO vm, final Event cause) throws OperationTimedoutException, ResourceUnavailableException, NoTransitionException, InsufficientAddressCapacityException {	final VirtualMachineGuru vmGuru = getVmGuru(vm);	
vm state is starting on full sync so updating it to running 

private void ensureVmRunningContext(final long hostId, VMInstanceVO vm, final Event cause) throws OperationTimedoutException, ResourceUnavailableException, NoTransitionException, InsufficientAddressCapacityException {	final VirtualMachineGuru vmGuru = getVmGuru(vm);	vm = _vmDao.findById(vm.getId());	final ItWorkVO work = _workDao.findByOutstandingWork(vm.getId(), vm.getState());	if (work != null) {	if (s_logger.isDebugEnabled()) {	
found an outstanding work item for this vm in state work id 

final ItWorkVO work = _workDao.findByOutstandingWork(vm.getId(), vm.getState());	if (work != null) {	if (s_logger.isDebugEnabled()) {	}	}	try {	stateTransitTo(vm, cause, hostId);	} catch (final NoTransitionException e1) {	s_logger.warn(e1.getMessage());	}	
vm s state is starting on full sync so updating it to running 

}	vm = _vmDao.findById(vm.getId());	final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);	final List<NicVO> nics = _nicsDao.listByVmId(profile.getId());	for (final NicVO nic : nics) {	final Network network = _networkModel.getNetwork(nic.getNetworkId());	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), null, _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(profile.getHypervisorType(), network));	profile.addNic(nicProfile);	}	final Commands cmds = new Commands(Command.OnError.Stop);	
finalizing commands that need to be send to complete start process for the vm 

profile.addNic(nicProfile);	}	final Commands cmds = new Commands(Command.OnError.Stop);	if (vmGuru.finalizeCommandsOnStart(cmds, profile)) {	if (cmds.size() != 0) {	_agentMgr.send(vm.getHostId(), cmds);	}	if (vmGuru.finalizeStart(profile, vm.getHostId(), cmds, null)) {	stateTransitTo(vm, cause, vm.getHostId());	} else {	
unable to finish finialization for running vm 

final Commands cmds = new Commands(Command.OnError.Stop);	if (vmGuru.finalizeCommandsOnStart(cmds, profile)) {	if (cmds.size() != 0) {	_agentMgr.send(vm.getHostId(), cmds);	}	if (vmGuru.finalizeStart(profile, vm.getHostId(), cmds, null)) {	stateTransitTo(vm, cause, vm.getHostId());	} else {	}	} else {	
unable to finalize commands on start for vm 

_agentMgr.send(vm.getHostId(), cmds);	}	if (vmGuru.finalizeStart(profile, vm.getHostId(), cmds, null)) {	stateTransitTo(vm, cause, vm.getHostId());	} else {	}	} else {	}	if (work != null) {	if (s_logger.isDebugEnabled()) {	
updating outstanding work item to done id 

public void processConnect(final Host agent, final StartupCommand cmd, final boolean forRebalance) throws ConnectionException {	if (!(cmd instanceof StartupRoutingCommand)) {	return;	}	if(s_logger.isDebugEnabled()) {	
received startup command from hypervisor host host id 

public void processConnect(final Host agent, final StartupCommand cmd, final boolean forRebalance) throws ConnectionException {	if (!(cmd instanceof StartupRoutingCommand)) {	return;	}	if(s_logger.isDebugEnabled()) {	}	_syncMgr.resetHostSyncState(agent.getId());	if (forRebalance) {	
not processing listener as connect happens on rebalance process 

_syncMgr.resetHostSyncState(agent.getId());	if (forRebalance) {	return;	}	final Long clusterId = agent.getClusterId();	final long agentId = agent.getId();	if (agent.getHypervisorType() == HypervisorType.XenServer) {	final ClusterVMMetaDataSyncCommand syncVMMetaDataCmd = new ClusterVMMetaDataSyncCommand(ClusterVMMetaDataSyncInterval.value(), clusterId);	try {	final long seq_no = _agentMgr.send(agentId, new Commands(syncVMMetaDataCmd), this);	
cluster vm metadata sync started with jobid 

if (forRebalance) {	return;	}	final Long clusterId = agent.getClusterId();	final long agentId = agent.getId();	if (agent.getHypervisorType() == HypervisorType.XenServer) {	final ClusterVMMetaDataSyncCommand syncVMMetaDataCmd = new ClusterVMMetaDataSyncCommand(ClusterVMMetaDataSyncInterval.value(), clusterId);	try {	final long seq_no = _agentMgr.send(agentId, new Commands(syncVMMetaDataCmd), this);	} catch (final AgentUnavailableException e) {	
the cluster vm metadata sync process failed for cluster id with 

protected void runInContext() {	final GlobalLock lock = GlobalLock.getInternLock("TransitionChecking");	if (lock == null) {	
couldn t get the global lock 

protected void runInContext() {	final GlobalLock lock = GlobalLock.getInternLock("TransitionChecking");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	
couldn t lock the db 

final List<VMInstanceVO> instances = _vmDao.findVMInTransition(new Date(new Date().getTime() - AgentManager.Wait.value() * 1000), State.Starting, State.Stopping);	for (final VMInstanceVO instance : instances) {	final State state = instance.getState();	if (state == State.Stopping) {	_haMgr.scheduleStop(instance, instance.getHostId(), WorkType.CheckStop);	} else if (state == State.Starting) {	_haMgr.scheduleRestart(instance, true);	}	}	} catch (final Exception e) {	
caught the following exception on transition checking 

public void checkIfCanUpgrade(final VirtualMachine vmInstance, final ServiceOffering newServiceOffering) {	if (newServiceOffering == null) {	throw new InvalidParameterValueException("Invalid parameter, newServiceOffering can't be null");	}	if (!(vmInstance.getState().equals(State.Stopped) || vmInstance.getState().equals(State.Running))) {	
unable to upgrade virtual machine in state 

public void checkIfCanUpgrade(final VirtualMachine vmInstance, final ServiceOffering newServiceOffering) {	if (newServiceOffering == null) {	throw new InvalidParameterValueException("Invalid parameter, newServiceOffering can't be null");	}	if (!(vmInstance.getState().equals(State.Stopped) || vmInstance.getState().equals(State.Running))) {	throw new InvalidParameterValueException("Unable to upgrade virtual machine " + vmInstance.toString() + " " + " in state " + vmInstance.getState() + "; make sure the virtual machine is stopped/running");	}	if (!newServiceOffering.isDynamic() && vmInstance.getServiceOfferingId() == newServiceOffering.getId()) {	if (s_logger.isInfoEnabled()) {	
not upgrading vm since it already has the requested service offering 

private NicProfile orchestrateAddVmToNetwork(final VirtualMachine vm, final Network network, final NicProfile requested) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final CallContext cctx = CallContext.current();	
adding vm to network requested nic profile 

final ReservationContext context = new ReservationContextImpl(null, null, cctx.getCallingUser(), cctx.getCallingAccount());	final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmVO, null, null, null, null);	final DataCenter dc = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	final Host host = _hostDao.findById(vm.getHostId());	final DeployDestination dest = new DeployDestination(dc, null, null, host);	if (vm.getState() == State.Running) {	final NicProfile nic = _networkMgr.createNicForVm(network, requested, context, vmProfile, true);	final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vmProfile.getVirtualMachine().getHypervisorType());	final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);	final NicTO nicTO = toNicTO(nic, vmProfile.getVirtualMachine().getHypervisorType());	
plugging nic for vm in network 

final DeployDestination dest = new DeployDestination(dc, null, null, host);	if (vm.getState() == State.Running) {	final NicProfile nic = _networkMgr.createNicForVm(network, requested, context, vmProfile, true);	final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vmProfile.getVirtualMachine().getHypervisorType());	final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);	final NicTO nicTO = toNicTO(nic, vmProfile.getVirtualMachine().getHypervisorType());	boolean result = false;	try {	result = plugNic(network, nicTO, vmTO, context, dest);	if (result) {	
nic is plugged successfully for vm in network vm is a part of network now 

boolean result = false;	try {	result = plugNic(network, nicTO, vmTO, context, dest);	if (result) {	final long isDefault = nic.isDefaultNic() ? 1 : 0;	if(VirtualMachine.Type.User.equals(vmVO.getType())) {	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NETWORK_OFFERING_ASSIGN, vmVO.getAccountId(), vmVO.getDataCenterId(), vmVO.getId(), Long.toString(nic.getId()), network.getNetworkOfferingId(), null, isDefault, VirtualMachine.class.getName(), vmVO.getUuid(), vm.isDisplay());	}	return nic;	} else {	
failed to plug nic to the vm in network 

final long isDefault = nic.isDefaultNic() ? 1 : 0;	if(VirtualMachine.Type.User.equals(vmVO.getType())) {	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NETWORK_OFFERING_ASSIGN, vmVO.getAccountId(), vmVO.getDataCenterId(), vmVO.getId(), Long.toString(nic.getId()), network.getNetworkOfferingId(), null, isDefault, VirtualMachine.class.getName(), vmVO.getUuid(), vm.isDisplay());	}	return nic;	} else {	return null;	}	} finally {	if (!result) {	
removing nic from vm as nic plug failed on the backend 

return null;	}	} finally {	if (!result) {	_networkMgr.removeNic(vmProfile, _nicsDao.findById(nic.getId()));	}	}	} else if (vm.getState() == State.Stopped) {	return _networkMgr.createNicForVm(network, requested, context, vmProfile, false);	} else {	
unable to add vm to network 

final ReservationContext context = new ReservationContextImpl(null, null, cctx.getCallingUser(), cctx.getCallingAccount());	final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmVO, null, null, null, null);	final DataCenter dc = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	final Host host = _hostDao.findById(vm.getHostId());	final DeployDestination dest = new DeployDestination(dc, null, null, host);	final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vmProfile.getVirtualMachine().getHypervisorType());	final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), _networkModel.getNetworkRate(network.getId(), vm.getId()), _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));	if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	
un plugging nic for vm from network 

final DataCenter dc = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	final Host host = _hostDao.findById(vm.getHostId());	final DeployDestination dest = new DeployDestination(dc, null, null, host);	final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vmProfile.getVirtualMachine().getHypervisorType());	final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), _networkModel.getNetworkRate(network.getId(), vm.getId()), _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));	if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	final boolean result = unplugNic(network, nicTO, vmTO, context, dest);	if (result) {	
nic is unplugged successfully for vm in network 

final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vmProfile.getVirtualMachine().getHypervisorType());	final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), _networkModel.getNetworkRate(network.getId(), vm.getId()), _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));	if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	final boolean result = unplugNic(network, nicTO, vmTO, context, dest);	if (result) {	final long isDefault = nic.isDefaultNic() ? 1 : 0;	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NETWORK_OFFERING_REMOVE, vm.getAccountId(), vm.getDataCenterId(), vm.getId(), Long.toString(nic.getId()), network.getNetworkOfferingId(), null, isDefault, VirtualMachine.class.getName(), vm.getUuid(), vm.isDisplay());	} else {	
failed to unplug nic for the vm from network 

if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	final boolean result = unplugNic(network, nicTO, vmTO, context, dest);	if (result) {	final long isDefault = nic.isDefaultNic() ? 1 : 0;	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NETWORK_OFFERING_REMOVE, vm.getAccountId(), vm.getDataCenterId(), vm.getId(), Long.toString(nic.getId()), network.getNetworkOfferingId(), null, isDefault, VirtualMachine.class.getName(), vm.getUuid(), vm.isDisplay());	} else {	return false;	}	} else if (vm.getState() != State.Stopped) {	
unable to remove vm from network 

if (result) {	final long isDefault = nic.isDefaultNic() ? 1 : 0;	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NETWORK_OFFERING_REMOVE, vm.getAccountId(), vm.getDataCenterId(), vm.getId(), Long.toString(nic.getId()), network.getNetworkOfferingId(), null, isDefault, VirtualMachine.class.getName(), vm.getUuid(), vm.isDisplay());	} else {	return false;	}	} else if (vm.getState() != State.Stopped) {	throw new ResourceUnavailableException("Unable to remove vm " + vm + " from network, is not in the right state", DataCenter.class, vm.getDataCenterId());	}	_networkMgr.releaseNic(vmProfile, nic);	
successfully released nic for vm 

final DeployDestination dest = new DeployDestination(dc, null, null, host);	final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vmProfile.getVirtualMachine().getHypervisorType());	final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);	Nic nic = null;	if (broadcastUri != null) {	nic = _nicsDao.findByNetworkIdInstanceIdAndBroadcastUri(network.getId(), vm.getId(), broadcastUri.toString());	} else {	nic = _networkModel.getNicInNetwork(vm.getId(), network.getId());	}	if (nic == null) {	
could not get a nic with 

Nic nic = null;	if (broadcastUri != null) {	nic = _nicsDao.findByNetworkIdInstanceIdAndBroadcastUri(network.getId(), vm.getId(), broadcastUri.toString());	} else {	nic = _networkModel.getNicInNetwork(vm.getId(), network.getId());	}	if (nic == null) {	return false;	}	if (nic.isDefaultNic() && vm.getType() == VirtualMachine.Type.User) {	
failed to remove nic from in nic is default 

if (nic == null) {	return false;	}	if (nic.isDefaultNic() && vm.getType() == VirtualMachine.Type.User) {	throw new CloudRuntimeException("Failed to remove nic from " + vm + " in " + network + ", nic is default.");	}	final Nic lock = _nicsDao.acquireInLockTable(nic.getId());	if (lock == null) {	if (_nicsDao.findById(nic.getId()) == null) {	if (s_logger.isDebugEnabled()) {	
not need to remove the vm from network as the vm doesn t have nic in this network 

final Nic lock = _nicsDao.acquireInLockTable(nic.getId());	if (lock == null) {	if (_nicsDao.findById(nic.getId()) == null) {	if (s_logger.isDebugEnabled()) {	}	return true;	}	throw new ConcurrentOperationException("Unable to lock nic " + nic.getId());	}	if (s_logger.isDebugEnabled()) {	
lock is acquired for nic id as a part of remove vm from network 

return true;	}	throw new ConcurrentOperationException("Unable to lock nic " + nic.getId());	}	if (s_logger.isDebugEnabled()) {	}	try {	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), _networkModel.getNetworkRate(network.getId(), vm.getId()), _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));	if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	
un plugging nic for vm from network 

throw new ConcurrentOperationException("Unable to lock nic " + nic.getId());	}	if (s_logger.isDebugEnabled()) {	}	try {	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), _networkModel.getNetworkRate(network.getId(), vm.getId()), _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));	if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	final boolean result = unplugNic(network, nicTO, vmTO, context, dest);	if (result) {	
nic is unplugged successfully for vm in network 

}	if (s_logger.isDebugEnabled()) {	}	try {	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), _networkModel.getNetworkRate(network.getId(), vm.getId()), _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));	if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	final boolean result = unplugNic(network, nicTO, vmTO, context, dest);	if (result) {	} else {	
failed to unplug nic for the vm from network 

try {	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), _networkModel.getNetworkRate(network.getId(), vm.getId()), _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));	if (vm.getState() == State.Running) {	final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	final boolean result = unplugNic(network, nicTO, vmTO, context, dest);	if (result) {	} else {	return false;	}	} else if (vm.getState() != State.Stopped) {	
unable to remove vm from network 

final NicTO nicTO = toNicTO(nicProfile, vmProfile.getVirtualMachine().getHypervisorType());	final boolean result = unplugNic(network, nicTO, vmTO, context, dest);	if (result) {	} else {	return false;	}	} else if (vm.getState() != State.Stopped) {	throw new ResourceUnavailableException("Unable to remove vm " + vm + " from network, is not in the right state", DataCenter.class, vm.getDataCenterId());	}	_networkMgr.releaseNic(vmProfile, nic);	
successfully released nic for vm 

} else if (vm.getState() != State.Stopped) {	throw new ResourceUnavailableException("Unable to remove vm " + vm + " from network, is not in the right state", DataCenter.class, vm.getDataCenterId());	}	_networkMgr.releaseNic(vmProfile, nic);	_networkMgr.removeNic(vmProfile, nic);	return true;	} finally {	if (lock != null) {	_nicsDao.releaseFromLockTable(lock.getId());	if (s_logger.isDebugEnabled()) {	
lock is released for nic id as a part of remove vm from network 

throw new CloudRuntimeException("Unable to scale the vm because it doesn't have a host id");	}	final Host host = _hostDao.findById(srcHostId);	final DataCenterDeployment plan = new DataCenterDeployment(host.getDataCenterId(), host.getPodId(), host.getClusterId(), null, null, null);	excludes.addHost(vm.getHostId());	vm.setServiceOfferingId(newSvcOfferingId);	DeployDestination dest = null;	try {	dest = _dpMgr.planDeployment(profile, plan, excludes, null);	} catch (final AffinityConflictException e2) {	
unable to create deployment affinity rules associted to the vm conflict 

excludes.addHost(vm.getHostId());	vm.setServiceOfferingId(newSvcOfferingId);	DeployDestination dest = null;	try {	dest = _dpMgr.planDeployment(profile, plan, excludes, null);	} catch (final AffinityConflictException e2) {	throw new CloudRuntimeException("Unable to create deployment, affinity rules associted to the VM conflict");	}	if (dest != null) {	if (s_logger.isDebugEnabled()) {	
found for scaling the vm to 

if (s_logger.isDebugEnabled()) {	}	}	if (dest == null) {	throw new InsufficientServerCapacityException("Unable to find a server to scale the vm to.", host.getClusterId());	}	excludes.addHost(dest.getHost().getId());	try {	migrateForScale(vm.getUuid(), srcHostId, dest, oldSvcOfferingId);	} catch (final ResourceUnavailableException e) {	
unable to migrate to unavailable 

}	if (dest == null) {	throw new InsufficientServerCapacityException("Unable to find a server to scale the vm to.", host.getClusterId());	}	excludes.addHost(dest.getHost().getId());	try {	migrateForScale(vm.getUuid(), srcHostId, dest, oldSvcOfferingId);	} catch (final ResourceUnavailableException e) {	throw e;	} catch (final ConcurrentOperationException e) {	
unable to migrate vm due to 

private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId) throws ResourceUnavailableException, ConcurrentOperationException {	VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	
migrating to 

private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId) throws ResourceUnavailableException, ConcurrentOperationException {	VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	vm.getServiceOfferingId();	final long dstHostId = dest.getHost().getId();	final Host fromHost = _hostDao.findById(srcHostId);	if (fromHost == null) {	
unable to find the host to migrate from 

private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId) throws ResourceUnavailableException, ConcurrentOperationException {	VMInstanceVO vm = _vmDao.findByUuid(vmUuid);	vm.getServiceOfferingId();	final long dstHostId = dest.getHost().getId();	final Host fromHost = _hostDao.findById(srcHostId);	if (fromHost == null) {	throw new CloudRuntimeException("Unable to find the host to migrate from: " + srcHostId);	}	if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {	
source and destination host are not in same cluster unable to migrate to host 

throw new CloudRuntimeException("Unable to find the host to migrate from: " + srcHostId);	}	if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {	throw new CloudRuntimeException("Source and destination host are not in same cluster, unable to migrate to host: " + dest.getHost().getId());	}	final VirtualMachineGuru vmGuru = getVmGuru(vm);	final long vmId = vm.getId();	vm = _vmDao.findByUuid(vmUuid);	if (vm == null) {	if (s_logger.isDebugEnabled()) {	
unable to find the vm 

final VirtualMachineGuru vmGuru = getVmGuru(vm);	final long vmId = vm.getId();	vm = _vmDao.findByUuid(vmUuid);	if (vm == null) {	if (s_logger.isDebugEnabled()) {	}	throw new CloudRuntimeException("Unable to find a virtual machine with id " + vmId);	}	if (vm.getState() != State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is not running unable to migrate the vm 

throw new AgentUnavailableException("Operation timed out", dstHostId);	} finally {	if (pfma == null) {	work.setStep(Step.Done);	_workDao.update(work.getId(), work);	}	}	vm.setLastHostId(srcHostId);	try {	if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {	
migration cancelled because state has changed 

work.setStep(Step.Done);	_workDao.update(work.getId(), work);	}	}	vm.setLastHostId(srcHostId);	try {	if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {	throw new ConcurrentOperationException("Migration cancelled because state has changed: " + vm);	}	} catch (final NoTransitionException e1) {	
migration cancelled because 

try {	final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);	if (ma == null || !ma.getResult()) {	final String details = ma != null ? ma.getDetails() : "null answer returned";	final String msg = "Unable to migrate due to " + details;	s_logger.error(msg);	throw new CloudRuntimeException(msg);	}	} catch (final OperationTimedoutException e) {	if (e.isActive()) {	
active migration command so scheduling a restart for 

vm.setServiceOfferingId(oldSvcOfferingId);	if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {	throw new ConcurrentOperationException("Unable to change the state for " + vm);	}	vm.setServiceOfferingId(newServiceOfferingId);	} catch (final NoTransitionException e1) {	throw new ConcurrentOperationException("Unable to change state due to " + e1.getMessage());	}	try {	if (!checkVmOnHost(vm, dstHostId)) {	
unable to complete migration for 

}	vm.setServiceOfferingId(newServiceOfferingId);	} catch (final NoTransitionException e1) {	throw new ConcurrentOperationException("Unable to change state due to " + e1.getMessage());	}	try {	if (!checkVmOnHost(vm, dstHostId)) {	try {	_agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);	} catch (final AgentUnavailableException e) {	
agentunavailableexception while cleanup on source host 

try {	if (!checkVmOnHost(vm, dstHostId)) {	try {	_agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);	} catch (final AgentUnavailableException e) {	}	cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);	throw new CloudRuntimeException("Unable to complete migration for " + vm);	}	} catch (final OperationTimedoutException e) {	
error while checking the vm on host 

} catch (final AgentUnavailableException e) {	}	cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);	throw new CloudRuntimeException("Unable to complete migration for " + vm);	}	} catch (final OperationTimedoutException e) {	}	migrated = true;	} finally {	if (!migrated) {	
migration was unsuccessful cleaning up 

}	} catch (final OperationTimedoutException e) {	}	migrated = true;	} finally {	if (!migrated) {	_alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(), "Unable to migrate vm " + vm.getInstanceName() + " from host " + fromHost.getName() + " in zone " + dest.getDataCenter().getName() + " and pod " + dest.getPod().getName(), "Migrate Command failed.  Please check logs.");	try {	_agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);	} catch (final AgentUnavailableException ae) {	
looks like the destination host is unavailable for cleanup 

boolean result = true;	final VMInstanceVO router = _vmDao.findById(vm.getId());	if (router.getState() == State.Running) {	try {	final PlugNicCommand plugNicCmd = new PlugNicCommand(nic, vm.getName(), vm.getType(), vm.getDetails());	final Commands cmds = new Commands(Command.OnError.Stop);	cmds.addCommand("plugnic", plugNicCmd);	_agentMgr.send(dest.getHost().getId(), cmds);	final PlugNicAnswer plugNicAnswer = cmds.getAnswer(PlugNicAnswer.class);	if (!(plugNicAnswer != null && plugNicAnswer.getResult())) {	
unable to plug nic for vm 

cmds.addCommand("plugnic", plugNicCmd);	_agentMgr.send(dest.getHost().getId(), cmds);	final PlugNicAnswer plugNicAnswer = cmds.getAnswer(PlugNicAnswer.class);	if (!(plugNicAnswer != null && plugNicAnswer.getResult())) {	result = false;	}	} catch (final OperationTimedoutException e) {	throw new AgentUnavailableException("Unable to plug nic for router " + vm.getName() + " in network " + network, dest.getHost().getId(), e);	}	} else {	
unable to apply plugnic vm is not in the right state 

boolean result = true;	final VMInstanceVO router = _vmDao.findById(vm.getId());	if (router.getState() == State.Running) {	try {	final Commands cmds = new Commands(Command.OnError.Stop);	final UnPlugNicCommand unplugNicCmd = new UnPlugNicCommand(nic, vm.getName());	cmds.addCommand("unplugnic", unplugNicCmd);	_agentMgr.send(dest.getHost().getId(), cmds);	final UnPlugNicAnswer unplugNicAnswer = cmds.getAnswer(UnPlugNicAnswer.class);	if (!(unplugNicAnswer != null && unplugNicAnswer.getResult())) {	
unable to unplug nic from router 

cmds.addCommand("unplugnic", unplugNicCmd);	_agentMgr.send(dest.getHost().getId(), cmds);	final UnPlugNicAnswer unplugNicAnswer = cmds.getAnswer(UnPlugNicAnswer.class);	if (!(unplugNicAnswer != null && unplugNicAnswer.getResult())) {	result = false;	}	} catch (final OperationTimedoutException e) {	throw new AgentUnavailableException("Unable to unplug nic from rotuer " + router + " from network " + network, dest.getHost().getId(), e);	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	
vm is in so not sending unplug nic command to the backend 

_agentMgr.send(dest.getHost().getId(), cmds);	final UnPlugNicAnswer unplugNicAnswer = cmds.getAnswer(UnPlugNicAnswer.class);	if (!(unplugNicAnswer != null && unplugNicAnswer.getResult())) {	result = false;	}	} catch (final OperationTimedoutException e) {	throw new AgentUnavailableException("Unable to unplug nic from rotuer " + router + " from network " + network, dest.getHost().getId(), e);	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	} else {	
unable to apply unplug nic vm is not in the right state 

}	final Object jobResult = _jobMgr.unmarshallResultObject(outcome.getJob());	if (jobResult != null) {	if (jobResult instanceof ResourceUnavailableException) {	throw (ResourceUnavailableException)jobResult;	} else if (jobResult instanceof ConcurrentOperationException) {	throw (ConcurrentOperationException)jobResult;	} else if (jobResult instanceof InsufficientServerCapacityException) {	throw (InsufficientServerCapacityException)jobResult;	} else if (jobResult instanceof Throwable) {	
unhandled exception 

if (vm != null) {	switch (vm.getPowerState()) {	case PowerOn: handlePowerOnReportWithNoPendingJobsOnVM(vm);	break;	case PowerOff: case PowerReportMissing: handlePowerOffReportWithNoPendingJobsOnVM(vm);	break;	case PowerUnknown: default: assert false;	break;	}	} else {	
vm no longer exists when processing vm state report 

case PowerOn: handlePowerOnReportWithNoPendingJobsOnVM(vm);	break;	case PowerOff: case PowerReportMissing: handlePowerOffReportWithNoPendingJobsOnVM(vm);	break;	case PowerUnknown: default: assert false;	break;	}	} else {	}	} else {	
there is pending job or ha tasks working on the vm vm id postpone power change report by resetting power change counters 

private void handlePowerOnReportWithNoPendingJobsOnVM(final VMInstanceVO vm) {	switch (vm.getState()) {	
vm is at and we received a power on report while there is no pending jobs on it 

private void handlePowerOnReportWithNoPendingJobsOnVM(final VMInstanceVO vm) {	switch (vm.getState()) {	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	
unexpected vm state transition exception race condition 

private void handlePowerOnReportWithNoPendingJobsOnVM(final VMInstanceVO vm) {	switch (vm.getState()) {	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	
vm is sync ed to at running state according to power on report from hypervisor 

private void handlePowerOnReportWithNoPendingJobsOnVM(final VMInstanceVO vm) {	switch (vm.getState()) {	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (Starting -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	case Running: try {	if (vm.getHostId() != null && vm.getHostId().longValue() != vm.getPowerHostId().longValue()) {	
detected out of band vm migration from host to host 

stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (Starting -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	case Running: try {	if (vm.getHostId() != null && vm.getHostId().longValue() != vm.getPowerHostId().longValue()) {	}	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	
unexpected vm state transition exception race condition 

}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (Starting -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	case Running: try {	if (vm.getHostId() != null && vm.getHostId().longValue() != vm.getPowerHostId().longValue()) {	}	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	break;	
vm is at and we received a power on report while there is no pending jobs on it 

case Running: try {	if (vm.getHostId() != null && vm.getHostId().longValue() != vm.getPowerHostId().longValue()) {	}	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	break;	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	
unexpected vm state transition exception race condition 

}	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	break;	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (" + vm.getState() + " -> Running) from out-of-context transition. VM network environment may need to be reset");	
vm is sync ed to at running state according to power on report from hypervisor 

stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	break;	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (" + vm.getState() + " -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	
receive power on report when vm is in destroyed or expunging state vm state 

} catch (final NoTransitionException e) {	}	break;	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (" + vm.getState() + " -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	break;	
vm is at and we received a power on report while there is no pending jobs on it 

try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (" + vm.getState() + " -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	break;	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	
unexpected vm state transition exception race condition 

stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (" + vm.getState() + " -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	break;	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	
vm is sync ed to at running state according to power on report from hypervisor 

} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (" + vm.getState() + " -> Running) from out-of-context transition. VM network environment may need to be reset");	break;	break;	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOnReport, vm.getPowerHostId());	} catch (final NoTransitionException e) {	}	break;	
receive power on report when vm is in error or unexpected state vm state 

private void handlePowerOffReportWithNoPendingJobsOnVM(final VMInstanceVO vm) {	switch (vm.getState()) {	
vm is at and we received a power off report while there is no pending jobs on it 

private void handlePowerOffReportWithNoPendingJobsOnVM(final VMInstanceVO vm) {	switch (vm.getState()) {	if(vm.isHaEnabled() && vm.getState() == State.Running && vm.getHypervisorType() != HypervisorType.VMware && vm.getHypervisorType() != HypervisorType.Hyperv) {	
detected out of band stop of a ha enabled vm will schedule restart 

private void handlePowerOffReportWithNoPendingJobsOnVM(final VMInstanceVO vm) {	switch (vm.getState()) {	if(vm.isHaEnabled() && vm.getState() == State.Running && vm.getHypervisorType() != HypervisorType.VMware && vm.getHypervisorType() != HypervisorType.Hyperv) {	if(!_haMgr.hasPendingHaWork(vm.getId())) {	_haMgr.scheduleRestart(vm, true);	} else {	
vm already has an pending ha task working on it 

return;	}	final VirtualMachineGuru vmGuru = getVmGuru(vm);	final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);	if (!sendStop(vmGuru, profile, true, true)) {	return;	}	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOffReport, null);	} catch (final NoTransitionException e) {	
unexpected vm state transition exception race condition 

final VirtualMachineGuru vmGuru = getVmGuru(vm);	final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);	if (!sendStop(vmGuru, profile, true, true)) {	return;	}	try {	stateTransitTo(vm, VirtualMachine.Event.FollowAgentPowerOffReport, null);	} catch (final NoTransitionException e) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SYNC, vm.getDataCenterId(), vm.getPodIdToDeployIn(), VM_SYNC_ALERT_SUBJECT, "VM " + vm.getHostName() + "(" + vm.getInstanceName() + ") state is sync-ed (" + vm.getState() + " -> Stopped) from out-of-context transition.");	
vm is sync ed to at stopped state according to power off report from hypervisor 

private Pair<JobInfo.Status, String> orchestrateStart(final VmWorkStart work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateStart(final VmWorkStart work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	}	assert vm != null;	try{	orchestrateStart(vm.getUuid(), work.getParams(), work.getPlan(), _dpMgr.getDeploymentPlannerByName(work.getDeploymentPlanner()));	}	catch (CloudRuntimeException e){	
caught cloudruntimeexception returning job failed 

private Pair<JobInfo.Status, String> orchestrateStop(final VmWorkStop work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateMigrate(final VmWorkMigrate work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateMigrateAway(final VmWorkMigrateAway work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateMigrateAway(final VmWorkMigrateAway work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	}	assert vm != null;	try {	orchestrateMigrateAway(vm.getUuid(), work.getSrcHostId(), null);	} catch (final InsufficientServerCapacityException e) {	
failed to deploy vm with original planner sending haplanner 

private Pair<JobInfo.Status, String> orchestrateMigrateWithStorage(final VmWorkMigrateWithStorage work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateMigrateForScale(final VmWorkMigrateForScale work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateReboot(final VmWorkReboot work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateAddVmToNetwork(final VmWorkAddVmToNetwork work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateRemoveNicFromVm(final VmWorkRemoveNicFromVm work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateRemoveVmFromNetwork(final VmWorkRemoveVmFromNetwork work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateReconfigure(final VmWorkReconfigure work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

private Pair<JobInfo.Status, String> orchestrateStorageMigration(final VmWorkStorageMigration work) throws Exception {	final VMInstanceVO vm = _entityMgr.findById(VMInstanceVO.class, work.getVmId());	if (vm == null) {	
unable to find vm 

========================= cloudstack sample_4792 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all portforwardingrule usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsagePortForwardingRuleVO> usagePFs = s_usagePFRuleDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate, false, 0);	if (usagePFs.isEmpty()) {	
no port forwarding usage events for this period 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long pfId, long zoneId) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long pfId, long zoneId) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating usage record for port forwarding rule usage startdate enddate for account 

========================= cloudstack sample_2646 =========================

long maxAvailable = 0;	NetappVolumeVO selectedVol = null;	for (NetappVolumeVO vol : volumesOnPoolAscending) {	try {	long availableBytes = _netappMgr.returnAvailableVolumeSize(vol.getVolumeName(), vol.getUsername(), vol.getPassword(), vol.getIpAddress());	if (lunSizeGb <= bytesToGb(availableBytes) && availableBytes > maxAvailable) {	maxAvailable = availableBytes;	selectedVol = vol;	}	} catch (ServerException se) {	
ignoring failure to obtain volume size for volume 

NetappVolumeVO vol = (NetappVolumeVO)volumesOnPoolAscendingArray[pos];	long availableBytes;	try {	availableBytes = _netappMgr.returnAvailableVolumeSize(vol.getVolumeName(), vol.getUsername(), vol.getPassword(), vol.getIpAddress());	if (lunSizeGb <= bytesToGb(availableBytes)) {	return vol;	}	pos = (pos + 1) % volumesOnPoolAscendingArray.length;	counter++;	} catch (ServerException e) {	
ignoring failure to obtain volume size for volume 

========================= cloudstack sample_1969 =========================

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	_messageBus.subscribe(AccountManager.MESSAGE_ADD_ACCOUNT_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	HashMap<Long, Long> acctGroupMap = (HashMap<Long, Long>) obj;	for (Long accountId : acctGroupMap.keySet()) {	Long groupId = acctGroupMap.get(accountId);	
messagebus message new account added adding it to groupid 

}	}	}	}	}	});	_messageBus.subscribe(AccountManager.MESSAGE_REMOVE_ACCOUNT_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Long accountId = ((Long) obj);	if (accountId != null) {	
messagebus message account removed releasing the group associations 

Long accountId = ((Long) obj);	if (accountId != null) {	removeAccountFromIAMGroups(accountId);	}	}	});	_messageBus.subscribe(DomainManager.MESSAGE_ADD_DOMAIN_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Long domainId = ((Long) obj);	if (domainId != null) {	
messagebus message new domain created creating a new group 

if (domainId != null) {	Domain domain = _domainDao.findById(domainId);	_iamSrv.createIAMGroup("DomainGrp-" + domain.getUuid(), "Domain group", domain.getPath());	}	}	});	_messageBus.subscribe(DomainManager.MESSAGE_REMOVE_DOMAIN_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Long domainId = ((Long) obj);	if (domainId != null) {	
messagebus message domain removed removing the domain group 

for (IAMGroup group : groups) {	_iamSrv.deleteIAMGroup(group.getId());	}	}	}	});	_messageBus.subscribe(TemplateManager.MESSAGE_REGISTER_PUBLIC_TEMPLATE_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Long templateId = (Long)obj;	if (templateId != null) {	
messagebus message new public template registered grant permission to default root admin domain admin and normal user policies 

_iamSrv.addIAMPermissionToIAMPolicy(new Long(Account.ACCOUNT_TYPE_ADMIN + 1), VirtualMachineTemplate.class.getSimpleName(), PermissionScope.RESOURCE.toString(), templateId, "listTemplates", AccessType.UseEntry.toString(), Permission.Allow, false);	_iamSrv.addIAMPermissionToIAMPolicy(new Long(Account.ACCOUNT_TYPE_DOMAIN_ADMIN + 1), VirtualMachineTemplate.class.getSimpleName(), PermissionScope.RESOURCE.toString(), templateId, "listTemplates", AccessType.UseEntry.toString(), Permission.Allow, false);	_iamSrv.addIAMPermissionToIAMPolicy(new Long(Account.ACCOUNT_TYPE_NORMAL + 1), VirtualMachineTemplate.class.getSimpleName(), PermissionScope.RESOURCE.toString(), templateId, "listTemplates", AccessType.UseEntry.toString(), Permission.Allow, false);	}	}	});	_messageBus.subscribe(TemplateManager.MESSAGE_RESET_TEMPLATE_PERMISSION_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Long templateId = (Long)obj;	if (templateId != null) {	
messagebus message reset template permission 

resetTemplatePermission(templateId);	}	}	});	_messageBus.subscribe(EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Pair<Class<?>, Long> entity = (Pair<Class<?>, Long>)obj;	if (entity != null) {	String entityType = entity.first().getSimpleName();	Long entityId = entity.second();	
messagebus message delete an entity remove its related permission 

});	_messageBus.subscribe(EntityManager.MESSAGE_GRANT_ENTITY_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Map<String, Object> permit = (Map<String, Object>)obj;	if (permit != null) {	Class<?> entityType = (Class<?>)permit.get(ApiConstants.ENTITY_TYPE);	Long entityId = (Long)permit.get(ApiConstants.ENTITY_ID);	AccessType accessType = (AccessType)permit.get(ApiConstants.ACCESS_TYPE);	String action = (String)permit.get(ApiConstants.IAM_ACTION);	List<Long> acctIds = (List<Long>)permit.get(ApiConstants.ACCOUNTS);	
messagebus message grant accounts permission to an entity 

});	_messageBus.subscribe(EntityManager.MESSAGE_REVOKE_ENTITY_EVENT, new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	Map<String, Object> permit = (Map<String, Object>)obj;	if (permit != null) {	Class<?> entityType = (Class<?>)permit.get(ApiConstants.ENTITY_TYPE);	Long entityId = (Long)permit.get(ApiConstants.ENTITY_ID);	AccessType accessType = (AccessType)permit.get(ApiConstants.ACCESS_TYPE);	String action = (String)permit.get(ApiConstants.IAM_ACTION);	List<Long> acctIds = (List<Long>)permit.get(ApiConstants.ACCOUNTS);	
messagebus message revoke from accounts permission to an entity 

public boolean start() {	
populating iam group and account association for default accounts 

public void revokeEntityPermissioinFromAccounts(String entityType, Long entityId, AccessType accessType, String action, List<Long> accountIds) {	IAMPolicy policy = _iamSrv.getResourceGrantPolicy(entityType, entityId, accessType.toString(), action);	if (policy == null) {	
cannot find a policy associated with this entity permissioin to be revoked just return 

private void resetTemplatePermission(Long templateId){	_iamSrv.removeIAMPermissionFromIAMPolicy(new Long(Account.ACCOUNT_TYPE_DOMAIN_ADMIN + 1), VirtualMachineTemplate.class.getSimpleName(), PermissionScope.RESOURCE.toString(), templateId, "listTemplates");	_iamSrv.removeIAMPermissionFromIAMPolicy(new Long(Account.ACCOUNT_TYPE_NORMAL + 1), VirtualMachineTemplate.class.getSimpleName(), PermissionScope.RESOURCE.toString(), templateId, "listTemplates");	IAMPolicy policy = _iamSrv.getResourceGrantPolicy(VirtualMachineTemplate.class.getSimpleName(), templateId, AccessType.UseEntry.toString(), "listTemplates");	if ( policy == null ){	
no policy found for this template grant no detach to be done 

========================= cloudstack sample_5028 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all network usage events for account 

}	networkUsageByZone.put(key, new NetworkInfo(zoneId, usageNetwork.getHostId(), usageNetwork.getHostType(), usageNetwork.getNetworkId(), bytesSent, bytesReceived));	}	List<UsageVO> usageRecords = new ArrayList<UsageVO>();	for (String key : networkUsageByZone.keySet()) {	NetworkInfo networkInfo = networkUsageByZone.get(key);	long totalBytesSent = networkInfo.getBytesSent();	long totalBytesReceived = networkInfo.getBytesRcvd();	if ((totalBytesSent > 0L) || (totalBytesReceived > 0L)) {	if (s_logger.isDebugEnabled()) {	
creating usage record total bytes sent total bytes received for account in availability zone start end 

UsageVO usageRecord = new UsageVO(networkInfo.getZoneId(), account.getId(), account.getDomainId(), usageDesc, totalBytesSent + " bytes sent", UsageTypes.NETWORK_BYTES_SENT, new Double(totalBytesSent), hostId, networkInfo.getHostType(), networkInfo.getNetworkId(), startDate, endDate);	usageRecords.add(usageRecord);	usageDesc = "network bytes received";	if (networkInfo.getHostId() != 0) {	usageDesc += " for Host: " + networkInfo.getHostId();	}	usageRecord = new UsageVO(networkInfo.getZoneId(), account.getId(), account.getDomainId(), usageDesc, totalBytesReceived + " bytes received", UsageTypes.NETWORK_BYTES_RECEIVED, new Double(totalBytesReceived), hostId, networkInfo.getHostType(), networkInfo.getNetworkId(), startDate, endDate);	usageRecords.add(usageRecord);	} else {	if (s_logger.isDebugEnabled()) {	
no usage record bytes used generated for account 

========================= cloudstack sample_2647 =========================

protected List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	
clusterscopestoragepoolallocator looking for storage pool 

return null;	}	List<StoragePool> suitablePools = new ArrayList<StoragePool>();	long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	if (podId == null) {	return null;	}	if (dskCh.getTags() != null && dskCh.getTags().length != 0) {	
looking for pools in dc pod cluster having tags disabled pools will be ignored 

}	List<StoragePool> suitablePools = new ArrayList<StoragePool>();	long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	if (podId == null) {	return null;	}	if (dskCh.getTags() != null && dskCh.getTags().length != 0) {	} else {	
looking for pools in dc pod cluster disabled pools will be ignored 

if (podId == null) {	return null;	}	if (dskCh.getTags() != null && dskCh.getTags().length != 0) {	} else {	}	if (s_logger.isTraceEnabled()) {	List<StoragePoolVO> disabledPools = _storagePoolDao.findDisabledPoolsByScope(dcId, podId, clusterId, ScopeType.CLUSTER);	if (disabledPools != null && !disabledPools.isEmpty()) {	for (StoragePoolVO pool : disabledPools) {	
ignoring pool as it is in disabled state 

} else {	}	if (s_logger.isTraceEnabled()) {	List<StoragePoolVO> disabledPools = _storagePoolDao.findDisabledPoolsByScope(dcId, podId, clusterId, ScopeType.CLUSTER);	if (disabledPools != null && !disabledPools.isEmpty()) {	for (StoragePoolVO pool : disabledPools) {	}	}	}	List<StoragePoolVO> pools = _storagePoolDao.findPoolsByTags(dcId, podId, clusterId, dskCh.getTags());	
found pools matching tags 

List<StoragePoolVO> disabledPools = _storagePoolDao.findDisabledPoolsByScope(dcId, podId, clusterId, ScopeType.CLUSTER);	if (disabledPools != null && !disabledPools.isEmpty()) {	for (StoragePoolVO pool : disabledPools) {	}	}	}	List<StoragePoolVO> pools = _storagePoolDao.findPoolsByTags(dcId, podId, clusterId, dskCh.getTags());	List<StoragePoolVO> allPools = _storagePoolDao.findPoolsByTags(dcId, podId, clusterId, null);	allPools.removeAll(pools);	for (StoragePoolVO pool : allPools) {	
adding pool to avoid set since it did not match tags 

}	}	List<StoragePoolVO> pools = _storagePoolDao.findPoolsByTags(dcId, podId, clusterId, dskCh.getTags());	List<StoragePoolVO> allPools = _storagePoolDao.findPoolsByTags(dcId, podId, clusterId, null);	allPools.removeAll(pools);	for (StoragePoolVO pool : allPools) {	avoid.addPool(pool.getId());	}	if (pools.size() == 0) {	if (s_logger.isDebugEnabled()) {	
no storage pools available for volume allocation returning 

break;	}	StoragePool storagePool = (StoragePool)dataStoreMgr.getPrimaryDataStore(pool.getId());	if (filter(avoid, storagePool, dskCh, plan)) {	suitablePools.add(storagePool);	} else {	avoid.addPool(pool.getId());	}	}	if (s_logger.isDebugEnabled()) {	
clusterscopestoragepoolallocator returning suitable storage pools 

========================= cloudstack sample_4005 =========================

return false;	}	if (network.getVpcId() == null) {	return false;	}	if (!_networkMdl.isProviderEnabledInPhysicalNetwork(physicalNetworkId, Network.Provider.VPCVirtualRouter.getName())) {	return false;	}	if (service == null) {	if (!_networkMdl.isProviderForNetwork(getProvider(), network.getId())) {	
element is not a provider for the network 

}	if (!_networkMdl.isProviderEnabledInPhysicalNetwork(physicalNetworkId, Network.Provider.VPCVirtualRouter.getName())) {	return false;	}	if (service == null) {	if (!_networkMdl.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	} else {	if (!_networkMdl.isProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {	
element doesn t support service in the network 

public boolean implement(final Network network, final NetworkOffering offering, final DeployDestination dest, final ReservationContext context) throws ResourceUnavailableException, ConcurrentOperationException, InsufficientCapacityException {	final Long vpcId = network.getVpcId();	if (vpcId == null) {	
network is not associated with any vpc 

public boolean implement(final Network network, final NetworkOffering offering, final DeployDestination dest, final ReservationContext context) throws ResourceUnavailableException, ConcurrentOperationException, InsufficientCapacityException {	final Long vpcId = network.getVpcId();	if (vpcId == null) {	return false;	}	final Vpc vpc = _vpcMgr.getActiveVpc(vpcId);	if (vpc == null) {	
unable to find enabled vpc by id 

protected void configureGuestNetwork(final Network network, final List<DomainRouterVO> routers ) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	
adding vpc routers to guest network to be added 

protected void configureGuestNetwork(final Network network, final List<DomainRouterVO> routers ) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	for (final DomainRouterVO router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), network.getId())) {	final Map<VirtualMachineProfile.Param, Object> paramsForRouter = new HashMap<VirtualMachineProfile.Param, Object>(1);	if (network.getState() == State.Setup) {	paramsForRouter.put(VirtualMachineProfile.Param.ReProgramGuestNetworks, true);	}	if (!_vpcRouterMgr.addVpcRouterToGuestNetwork(router, network, paramsForRouter)) {	
failed to add vpc router to guest network 

protected void configureGuestNetwork(final Network network, final List<DomainRouterVO> routers ) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	for (final DomainRouterVO router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), network.getId())) {	final Map<VirtualMachineProfile.Param, Object> paramsForRouter = new HashMap<VirtualMachineProfile.Param, Object>(1);	if (network.getState() == State.Setup) {	paramsForRouter.put(VirtualMachineProfile.Param.ReProgramGuestNetworks, true);	}	if (!_vpcRouterMgr.addVpcRouterToGuestNetwork(router, network, paramsForRouter)) {	} else {	
successfully added vpc router to guest network 

public boolean prepare(final Network network, final NicProfile nic, final VirtualMachineProfile vm, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	final Long vpcId = network.getVpcId();	if (vpcId == null) {	
network is not associated with any vpc 

public boolean prepare(final Network network, final NicProfile nic, final VirtualMachineProfile vm, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	final Long vpcId = network.getVpcId();	if (vpcId == null) {	return false;	}	final Vpc vpc = _vpcMgr.getActiveVpc(vpcId);	if (vpc == null) {	
unable to find enabled vpc by id 

public boolean shutdown(final Network network, final ReservationContext context, final boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	final Long vpcId = network.getVpcId();	if (vpcId == null) {	
network doesn t belong to any vpc so skipping unplug nic part 

public boolean shutdown(final Network network, final ReservationContext context, final boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	final Long vpcId = network.getVpcId();	if (vpcId == null) {	return true;	}	boolean success = true;	final List<? extends VirtualRouter> routers = _routerDao.listByVpcId(vpcId);	for (final VirtualRouter router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), network.getId())) {	
router is not a part the network 

return true;	}	boolean success = true;	final List<? extends VirtualRouter> routers = _routerDao.listByVpcId(vpcId);	for (final VirtualRouter router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), network.getId())) {	continue;	}	success = success && _vpcRouterMgr.removeVpcRouterFromGuestNetwork(router, network);	if (!success) {	
failed to unplug nic in network for virtual router 

}	boolean success = true;	final List<? extends VirtualRouter> routers = _routerDao.listByVpcId(vpcId);	for (final VirtualRouter router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), network.getId())) {	continue;	}	success = success && _vpcRouterMgr.removeVpcRouterFromGuestNetwork(router, network);	if (!success) {	} else {	
successfully unplugged nic in network for virtual router 

public boolean destroy(final Network config, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	final Long vpcId = config.getVpcId();	if (vpcId == null) {	
network doesn t belong to any vpc so skipping unplug nic part 

public boolean destroy(final Network config, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	final Long vpcId = config.getVpcId();	if (vpcId == null) {	return true;	}	boolean success = true;	final List<? extends VirtualRouter> routers = _routerDao.listByVpcId(vpcId);	for (final VirtualRouter router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), config.getId())) {	
router is not a part the network 

return true;	}	boolean success = true;	final List<? extends VirtualRouter> routers = _routerDao.listByVpcId(vpcId);	for (final VirtualRouter router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), config.getId())) {	continue;	}	success = success && _vpcRouterMgr.removeVpcRouterFromGuestNetwork(router, config);	if (!success) {	
failed to unplug nic in network for virtual router 

}	boolean success = true;	final List<? extends VirtualRouter> routers = _routerDao.listByVpcId(vpcId);	for (final VirtualRouter router : routers) {	if (!_networkMdl.isVmPartOfNetwork(router.getId(), config.getId())) {	continue;	}	success = success && _vpcRouterMgr.removeVpcRouterFromGuestNetwork(router, config);	if (!success) {	} else {	
successfully unplugged nic in network for virtual router 

protected List<DomainRouterVO> getRouters(final Network network, final DeployDestination dest) {	List<DomainRouterVO> routers = super.getRouters(network, dest);	if (routers.size() > 0) {	return routers;	}	final Long vpcId = network.getVpcId();	if (vpcId == null) {	
network is not associated with any vpc 

List<DomainRouterVO> routers = super.getRouters(network, dest);	if (routers.size() > 0) {	return routers;	}	final Long vpcId = network.getVpcId();	if (vpcId == null) {	return routers;	}	final Vpc vpc = _vpcMgr.getActiveVpc(vpcId);	if (vpc == null) {	
unable to find enabled vpc by id 

return routers;	}	final Vpc vpc = _vpcMgr.getActiveVpc(vpcId);	if (vpc == null) {	return routers;	}	final RouterDeploymentDefinition routerDeploymentDefinition = routerDeploymentDefinitionBuilder.create() .setGuestNetwork(network) .setVpc(vpc) .setDeployDestination(dest) .setAccountOwner(_accountMgr.getAccount(vpc.getAccountId())) .build();	try {	routers = routerDeploymentDefinition.deployVirtualRouter();	} catch (final ConcurrentOperationException e) {	
error occurred when loading routers from routerdeploymentdefinition deployvirtualrouter 

}	final Vpc vpc = _vpcMgr.getActiveVpc(vpcId);	if (vpc == null) {	return routers;	}	final RouterDeploymentDefinition routerDeploymentDefinition = routerDeploymentDefinitionBuilder.create() .setGuestNetwork(network) .setVpc(vpc) .setDeployDestination(dest) .setAccountOwner(_accountMgr.getAccount(vpc.getAccountId())) .build();	try {	routers = routerDeploymentDefinition.deployVirtualRouter();	} catch (final ConcurrentOperationException e) {	} catch (final InsufficientCapacityException e) {	
error occurred when loading routers from routerdeploymentdefinition deployvirtualrouter 

final Vpc vpc = _vpcMgr.getActiveVpc(vpcId);	if (vpc == null) {	return routers;	}	final RouterDeploymentDefinition routerDeploymentDefinition = routerDeploymentDefinitionBuilder.create() .setGuestNetwork(network) .setVpc(vpc) .setDeployDestination(dest) .setAccountOwner(_accountMgr.getAccount(vpc.getAccountId())) .build();	try {	routers = routerDeploymentDefinition.deployVirtualRouter();	} catch (final ConcurrentOperationException e) {	} catch (final InsufficientCapacityException e) {	} catch (final ResourceUnavailableException e) {	
error occurred when loading routers from routerdeploymentdefinition deployvirtualrouter 

public boolean createPrivateGateway(final PrivateGateway gateway) throws ConcurrentOperationException, ResourceUnavailableException {	if (gateway.getType() != VpcGateway.Type.Private) {	
type of vpc gateway is not 

public boolean createPrivateGateway(final PrivateGateway gateway) throws ConcurrentOperationException, ResourceUnavailableException {	if (gateway.getType() != VpcGateway.Type.Private) {	return true;	}	final List<DomainRouterVO> routers = _vpcRouterMgr.getVpcRouters(gateway.getVpcId());	if (routers == null || routers.isEmpty()) {	s_logger.debug(getName() + " element doesn't need to create Private gateway on the backend; VPC virtual " + "router doesn't exist in the vpc id=" + gateway.getVpcId());	return true;	}	
adding vpc routers to guest network to be added 

final NetworkTopology networkTopology = networkTopologyContext.retrieveNetworkTopology(dcVO);	boolean result = true;	final Network network = _networkDao.findById(gateway.getNetworkId());	final boolean isPrivateGateway = true;	for (final DomainRouterVO domainRouterVO : routers) {	if (networkTopology.setupPrivateGateway(gateway, domainRouterVO)) {	try {	final List<NetworkACLItemVO> rules = _networkACLItemDao.listByACL(gateway.getNetworkACLId());	result = result && networkTopology.applyNetworkACLs(network, rules, domainRouterVO, isPrivateGateway);	} catch (final Exception ex) {	
failed to apply network acl id on gateway 

public boolean deletePrivateGateway(final PrivateGateway gateway) throws ConcurrentOperationException, ResourceUnavailableException {	if (gateway.getType() != VpcGateway.Type.Private) {	
type of vpc gateway is not 

public boolean deletePrivateGateway(final PrivateGateway gateway) throws ConcurrentOperationException, ResourceUnavailableException {	if (gateway.getType() != VpcGateway.Type.Private) {	return false;	}	final List<DomainRouterVO> routers = _vpcRouterMgr.getVpcRouters(gateway.getVpcId());	if (routers == null || routers.isEmpty()) {	s_logger.debug(getName() + " element doesn't need to delete Private gateway on the backend; VPC virtual " + "router doesn't exist in the vpc id=" + gateway.getVpcId());	return true;	}	
adding vpc routers to guest network to be added 

for (final Service service : services) {	if (!canHandle(network, service)) {	canHandle = false;	break;	}	}	boolean result = true;	if (canHandle) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
element doesn t need to associate ip addresses on the backend vpc virtual router doesn t exist in the network 

public boolean applyNetworkACLs(final Network network, final List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	boolean result = true;	if (canHandle(network, Service.NetworkACL)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to apply firewall rules on the backend virtual router doesn t exist in the network 

final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	return true;	}	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	final NetworkTopology networkTopology = networkTopologyContext.retrieveNetworkTopology(dcVO);	for (final DomainRouterVO domainRouterVO : routers) {	try {	result = result && networkTopology.applyNetworkACLs(network, rules, domainRouterVO, false);	} catch (final Exception ex) {	
failed to apply network acl in network 

public boolean applyStaticRoutes(final Vpc vpc, final List<StaticRouteProfile> routes) throws ResourceUnavailableException {	final List<DomainRouterVO> routers = _routerDao.listByVpcId(vpc.getId());	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to static routes on the backend virtual router doesn t exist in the vpc 

public boolean applyStaticRoutes(final Vpc vpc, final List<StaticRouteProfile> routes) throws ResourceUnavailableException {	final List<DomainRouterVO> routers = _routerDao.listByVpcId(vpc.getId());	if (routers == null || routers.isEmpty()) {	return true;	}	final DataCenterVO dcVO = _dcDao.findById(vpc.getZoneId());	final NetworkTopology networkTopology = networkTopologyContext.retrieveNetworkTopology(dcVO);	if (!networkTopology.applyStaticRoutes(routes, routers)) {	throw new CloudRuntimeException("Failed to apply static routes in vpc " + vpc);	} else {	
applied static routes on vpc 

public boolean applyACLItemsToPrivateGw(final PrivateGateway gateway, final List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	final Network network = _networkDao.findById(gateway.getNetworkId());	final boolean isPrivateGateway = true;	final List<DomainRouterVO> routers = _vpcRouterMgr.getVpcRouters(gateway.getVpcId());	if (routers == null || routers.isEmpty()) {	
virtual router element doesn t need to apply network acl rules on the backend virtual router doesn t exist in the network 

public boolean startSite2SiteVpn(final Site2SiteVpnConnection conn) throws ResourceUnavailableException {	final Site2SiteVpnGateway vpnGw = _vpnGatewayDao.findById(conn.getVpnGatewayId());	final IpAddress ip = _ipAddressDao.findById(vpnGw.getAddrId());	final Map<Capability, String> vpnCapabilities = capabilities.get(Service.Vpn);	if (!vpnCapabilities.get(Capability.VpnTypes).contains("s2svpn")) {	
try to start site site vpn on unsupported network element 

public boolean stopSite2SiteVpn(final Site2SiteVpnConnection conn) throws ResourceUnavailableException {	final Site2SiteVpnGateway vpnGw = _vpnGatewayDao.findById(conn.getVpnGatewayId());	final IpAddress ip = _ipAddressDao.findById(vpnGw.getAddrId());	final Map<Capability, String> vpnCapabilities = capabilities.get(Service.Vpn);	if (!vpnCapabilities.get(Capability.VpnTypes).contains("s2svpn")) {	
try to stop site site vpn on unsupported network element 

public String[] applyVpnUsers(final RemoteAccessVpn vpn, final List<? extends VpnUser> users) throws ResourceUnavailableException {	final Long vpcId = vpn.getVpcId();	if (vpcId == null) {	return null;	}	final List<DomainRouterVO> routers = _vpcRouterMgr.getVpcRouters(vpcId);	if (routers == null) {	
cannot apply vpn users on the backend virtual router doesn t exist in the network 

public boolean startVpn(final RemoteAccessVpn vpn) throws ResourceUnavailableException {	if (vpn.getVpcId() == null) {	return false;	}	final List<DomainRouterVO> routers = _vpcRouterMgr.getVpcRouters(vpn.getVpcId());	if (routers == null) {	
cannot apply vpn users on the backend virtual router doesn t exist in the network 

public boolean stopVpn(final RemoteAccessVpn vpn) throws ResourceUnavailableException {	if (vpn.getVpcId() == null) {	return false;	}	final List<DomainRouterVO> routers = _vpcRouterMgr.getVpcRouters(vpn.getVpcId());	if (routers == null) {	
cannot apply vpn users on the backend virtual router doesn t exist in the network 

========================= cloudstack sample_2305 =========================

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	if (vm.getType() != VirtualMachine.Type.User) {	if (s_logger.isDebugEnabled()) {	
not a user vm unable to determine state of returning null 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	if (vm.getType() != VirtualMachine.Type.User) {	if (s_logger.isDebugEnabled()) {	}	throw new UnknownVM();	}	if (s_logger.isDebugEnabled()) {	
testing if is alive 

}	UserVmVO userVm = _userVmDao.findById(vm.getId());	List<? extends Nic> nics = _networkMgr.getNicsForTraffic(userVm.getId(), TrafficType.Guest);	for (Nic nic : nics) {	if (nic.getIPv4Address() == null) {	continue;	}	List<VirtualRouter> routers = _vnaMgr.getRoutersForNetwork(nic.getNetworkId());	if (routers == null || routers.isEmpty()) {	if (s_logger.isDebugEnabled()) {	
unable to find a router in network to ping 

if (result != null) {	break;	}	}	if (result == null) {	continue;	}	return result;	}	if (s_logger.isDebugEnabled()) {	
returning null since we re unable to determine state of 

public Status isAgentAlive(Host agent) {	if (s_logger.isDebugEnabled()) {	
checking if agent is alive 

public Status isAgentAlive(Host agent) {	if (s_logger.isDebugEnabled()) {	}	if (agent.getPodId() == null) {	return null;	}	List<Long> otherHosts = findHostByPod(agent.getPodId(), agent.getId());	for (Long hostId : otherHosts) {	if (s_logger.isDebugEnabled()) {	
sending ping from to agent s host ip address 

return null;	}	List<Long> otherHosts = findHostByPod(agent.getPodId(), agent.getId());	for (Long hostId : otherHosts) {	if (s_logger.isDebugEnabled()) {	}	Status hostState = testIpAddress(hostId, agent.getPrivateIpAddress());	assert hostState != null;	if (hostState == Status.Up) {	if (s_logger.isDebugEnabled()) {	
ping from to agent s host ip address successful returning that agent is disconnected 

if (s_logger.isDebugEnabled()) {	}	Status hostState = testIpAddress(hostId, agent.getPrivateIpAddress());	assert hostState != null;	if (hostState == Status.Up) {	if (s_logger.isDebugEnabled()) {	}	return Status.Disconnected;	} else if (hostState == Status.Down) {	if (s_logger.isDebugEnabled()) {	
returning host state 

if (s_logger.isDebugEnabled()) {	}	return Status.Disconnected;	} else if (hostState == Status.Down) {	if (s_logger.isDebugEnabled()) {	}	return Status.Down;	}	}	if (s_logger.isDebugEnabled()) {	
could not reach agent could not reach agent s host returning that we don t have enough information 

if (vm.getHypervisorType() == HypervisorType.XenServer || vm.getHypervisorType() == HypervisorType.KVM) {	otherHosts.add(router.getHostId());	} else {	otherHosts = findHostByPod(router.getPodIdToDeployIn(), null);	}	for (Long hostId : otherHosts) {	try {	Answer pingTestAnswer = _agentMgr.easySend(hostId, new PingTestCommand(routerPrivateIp, privateIp));	if (pingTestAnswer != null && pingTestAnswer.getResult()) {	if (s_logger.isDebugEnabled()) {	
user vm s ip address has been successfully pinged from the virtual router returning that vm is alive 

for (Long hostId : otherHosts) {	try {	Answer pingTestAnswer = _agentMgr.easySend(hostId, new PingTestCommand(routerPrivateIp, privateIp));	if (pingTestAnswer != null && pingTestAnswer.getResult()) {	if (s_logger.isDebugEnabled()) {	}	return Boolean.TRUE;	}	} catch (Exception e) {	if (s_logger.isDebugEnabled()) {	
couldn t reach due to 

}	return Boolean.TRUE;	}	} catch (Exception e) {	if (s_logger.isDebugEnabled()) {	}	continue;	}	}	if (s_logger.isDebugEnabled()) {	
could not be pinged returning that it is unknown 

========================= cloudstack sample_2493 =========================

public Answer executeRequest(Command cmd) {	
begin executerequest cmd 

synchronized (this) {	try {	JmxUtil.registerMBean("VMware " + _morHyperHost.getValue(), "Command " + cmdSequence + "-" + cmd.getClass().getSimpleName(), mbean);	_cmdMBeans.add(mbean);	if (_cmdMBeans.size() >= MazCmdMBean) {	PropertyMapDynamicBean mbeanToRemove = _cmdMBeans.get(0);	_cmdMBeans.remove(0);	JmxUtil.unregisterMBean("VMware " + _morHyperHost.getValue(), "Command " + mbeanToRemove.getProp("Sequence") + "-" + mbeanToRemove.getProp("Name"));	}	} catch (Exception e) {	
unable to register jmx monitoring due to exception 

_cmdMBeans.remove(0);	JmxUtil.unregisterMBean("VMware " + _morHyperHost.getValue(), "Command " + mbeanToRemove.getProp("Sequence") + "-" + mbeanToRemove.getProp("Name"));	}	} catch (Exception e) {	}	}	} finally {	recycleServiceContext();	NDC.pop();	}	
end executerequest cmd 

protected void setCurrentNfsVersionInProcessorAndHandler() {	VmwareStorageSubsystemCommandHandler handler = (VmwareStorageSubsystemCommandHandler) storageHandler;	boolean success = handler.reconfigureNfsVersion(storageNfsVersion);	if (success){	
nfs version successfully set in vmwarestorageprocessor and vmwarestoragesubsystemcommandhandler 

protected void setCurrentNfsVersionInProcessorAndHandler() {	VmwareStorageSubsystemCommandHandler handler = (VmwareStorageSubsystemCommandHandler) storageHandler;	boolean success = handler.reconfigureNfsVersion(storageNfsVersion);	if (success){	} else {	
error while setting nfs version 

if (newSize < oldSize) {	throw new Exception("VMware doesn't support shrinking volume from larger size: " + oldSize/(1024*1024) + " GB to a smaller size: " + newSize/(1024*1024) + " GB");	} else if (newSize == oldSize) {	return new ResizeVolumeAnswer(cmd, true, "success", newSize*1024);	}	if (vmName.equalsIgnoreCase("none")) {	useWorkerVm = true;	vmName = getWorkerName(getServiceContext(), cmd, 0);	morDS = HypervisorHostHelper.findDatastoreWithBackwardsCompatibility(hyperHost, poolId);	dsMo = new DatastoreMO(hyperHost.getContext(), morDS);	
create worker vm 

}	}	vmMo = hyperHost.findVmOnPeerHyperHost(vmName);	if (vmMo == null) {	String msg = "VM " + vmName + " does not exist in VMware datacenter";	s_logger.error(msg);	throw new Exception(msg);	}	Pair<VirtualDisk, String> vdisk = vmMo.getDiskDevice(path);	if (vdisk == null) {	
resize volume done failed 

VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(disk);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.EDIT);	vmConfigSpec.getDeviceChange().add(deviceConfigSpec);	if (!vmMo.configureVm(vmConfigSpec)) {	throw new Exception("Failed to configure VM to resize disk. vmName: " + vmName);	}	return new ResizeVolumeAnswer(cmd, true, "success", newSize * 1024);	} catch (Exception e) {	
unable to resize volume 

if (!vmMo.configureVm(vmConfigSpec)) {	throw new Exception("Failed to configure VM to resize disk. vmName: " + vmName);	}	return new ResizeVolumeAnswer(cmd, true, "success", newSize * 1024);	} catch (Exception e) {	String error = "Failed to resize volume: " + e.getMessage();	return new ResizeVolumeAnswer(cmd, false, error);	} finally {	try {	if (useWorkerVm == true) {	
destroy worker vm after volume resize 

} catch (Exception e) {	String error = "Failed to resize volume: " + e.getMessage();	return new ResizeVolumeAnswer(cmd, false, error);	} finally {	try {	if (useWorkerVm == true) {	vmMo.detachDisk(vmdkDataStorePath, false);	vmMo.destroy();	}	} catch (Throwable e) {	
failed to destroy worker vm 

protected Answer execute(CheckNetworkCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource checknetworkcommand 

protected Answer execute(NetworkUsageCommand cmd) {	if (cmd.isForVpc()) {	return VPCNetworkUsage(cmd);	}	if (s_logger.isInfoEnabled()) {	
executing resource networkusagecommand 

args += "-r";	} else if (option.equals("vpn")) {	args += "-n";	} else if (option.equals("remove")) {	args += "-d";	} else {	return new NetworkUsageAnswer(cmd, "success", 0L, 0L);	}	ExecutionResult callResult = executeInVR(privateIp, "vpc_netusage.sh", args);	if (!callResult.isSuccess()) {	
unable to execute networkusage command on domr domr may not be ready yet failure due to 

args += "-d";	} else {	return new NetworkUsageAnswer(cmd, "success", 0L, 0L);	}	ExecutionResult callResult = executeInVR(privateIp, "vpc_netusage.sh", args);	if (!callResult.isSuccess()) {	}	if (option.equals("get") || option.equals("vpn")) {	String result = callResult.getDetails();	if (result == null || result.isEmpty()) {	
vpc network usage get returns empty 

public ExecutionResult createFileInVR(String routerIp, String filePath, String fileName, String content) {	VmwareManager mgr = getServiceContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	File keyFile = mgr.getSystemVMKeyFile();	try {	SshHelper.scpTo(routerIp, 3922, "root", keyFile, null, filePath, content.getBytes("UTF-8"), fileName, null);	} catch (Exception e) {	
fail to create file in vr 

private int findRouterEthDeviceIndex(String domrName, String routerIp, String mac) throws Exception {	VmwareManager mgr = getServiceContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	
findrouterethdeviceindex mac 

ArrayList<String> skipInterfaces = new ArrayList<String>(Arrays.asList("all", "default", "lo"));	long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick < 15000) {	Pair<Boolean, String> result = SshHelper.sshExecute(routerIp, DefaultDomRSshPort, "root", mgr.getSystemVMKeyFile(), null, "ls /proc/sys/net/ipv4/conf");	if (result.first()) {	String[] tokens = result.second().split("\\s+");	for (String token : tokens) {	if (!(skipInterfaces.contains(token))) {	String cmd = String.format("ip address show %s | grep link if (s_logger.isDebugEnabled()) s_logger.debug("Run domr script " + cmd);	Pair<Boolean, String> result2 = SshHelper.sshExecute(routerIp, DefaultDomRSshPort, "root", mgr.getSystemVMKeyFile(), null, cmd);	
result output 

String cmd = String.format("ip address show %s | grep link if (s_logger.isDebugEnabled()) s_logger.debug("Run domr script " + cmd);	Pair<Boolean, String> result2 = SshHelper.sshExecute(routerIp, DefaultDomRSshPort, "root", mgr.getSystemVMKeyFile(), null, cmd);	if (result2.first() && result2.second().trim().equalsIgnoreCase(mac.trim())) {	return Integer.parseInt(token.substring(3));	} else {	skipInterfaces.add(token);	}	}	}	}	
can not find intereface associated with mac guest os may still at loading state retry 

} else {	skipInterfaces.add(token);	}	}	}	}	try {	Thread.currentThread();	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while trying to get mac 

String routerName = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME);	String routerIp = getRouterSshControlIp(cmd);	try {	IpAddressTO[] ips = cmd.getIpAddresses();	for (IpAddressTO ip : ips) {	int ethDeviceNum = findRouterEthDeviceIndex(routerName, routerIp, ip.getVifMacAddress());	if (ethDeviceNum < 0) {	if (ip.isAdd()) {	throw new InternalErrorException("Failed to find DomR VIF to associate/disassociate IP with.");	} else {	
vif to deassociate ip with does not exist return success 

if (ethDeviceNum < 0) {	if (ip.isAdd()) {	throw new InternalErrorException("Failed to find DomR VIF to associate/disassociate IP with.");	} else {	continue;	}	}	ip.setNicDevId(ethDeviceNum);	}	} catch (Exception e) {	
prepare ip assoc failure on applying one ip due to exception 

private PlugNicAnswer execute(PlugNicCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource plugniccommand 

deviceNumber++;	NicTO nicTo = cmd.getNic();	VirtualDevice nic;	Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, false, cmd.getVMType());	String dvSwitchUuid = null;	if (VmwareHelper.isDvPortGroup(networkInfo.first())) {	ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();	DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);	ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());	dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);	
preparing nic device on dvswitch 

VirtualDevice nic;	Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, false, cmd.getVMType());	String dvSwitchUuid = null;	if (VmwareHelper.isDvPortGroup(networkInfo.first())) {	ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();	DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);	ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());	dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);	nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid, nicTo.getMac(), deviceNumber, deviceNumber + 1, true, true);	} else {	
preparing nic device on network 

VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(nic);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	vmConfigSpec.getDeviceChange().add(deviceConfigSpec);	setNuageVspVrIpInExtraConfig(vmConfigSpec.getExtraConfig(), nicTo, dvSwitchUuid);	if (!vmMo.configureVm(vmConfigSpec)) {	throw new Exception("Failed to configure devices when running PlugNicCommand");	}	return new PlugNicAnswer(cmd, true, "success");	} catch (Exception e) {	
unexpected exception 

private UnPlugNicAnswer execute(UnPlugNicCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource unplugniccommand 

VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(nic);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.REMOVE);	vmConfigSpec.getDeviceChange().add(deviceConfigSpec);	if (!vmMo.configureVm(vmConfigSpec)) {	throw new Exception("Failed to configure devices when running unplugNicCommand");	}	return new UnPlugNicAnswer(cmd, true, "success");	} catch (Exception e) {	
unexpected exception 

}	for (IpAddressTO ip : ips) {	URI broadcastUri = BroadcastDomainType.fromString(ip.getBroadcastUri());	if (BroadcastDomainType.getSchemeValue(broadcastUri) != BroadcastDomainType.Vlan) {	throw new InternalErrorException("Unable to assign a public IP to a VIF on network " + ip.getBroadcastUri());	}	String vlanId = BroadcastDomainType.getValue(broadcastUri);	String publicNeworkName = HypervisorHostHelper.getPublicNetworkNamePrefix(vlanId);	Pair<Integer, VirtualDevice> publicNicInfo = vmMo.getNicDeviceIndex(publicNeworkName);	if (s_logger.isDebugEnabled()) {	
find public nic index public network name index 

throw new InternalErrorException("Unable to assign a public IP to a VIF on network " + ip.getBroadcastUri());	}	String vlanId = BroadcastDomainType.getValue(broadcastUri);	String publicNeworkName = HypervisorHostHelper.getPublicNetworkNamePrefix(vlanId);	Pair<Integer, VirtualDevice> publicNicInfo = vmMo.getNicDeviceIndex(publicNeworkName);	if (s_logger.isDebugEnabled()) {	}	boolean addVif = false;	if (ip.isAdd() && publicNicInfo.first().intValue() == -1) {	if (s_logger.isDebugEnabled()) {	
plug new nic to associate to 

}	if (publicNicInfo.first().intValue() < 0) {	String msg = "Failed to find DomR VIF to associate/disassociate IP with.";	s_logger.error(msg);	throw new InternalErrorException(msg);	}	ip.setNicDevId(publicNicInfo.first().intValue());	ip.setNewNic(addVif);	}	} catch (Throwable e) {	
unexpected exception will shortcut rest of ipassoc commands 

public ExecutionResult executeInVR(String routerIP, String script, String args, Duration timeout) {	Pair<Boolean, String> result;	if (s_logger.isDebugEnabled()) {	
run command on vr script with args 

}	try {	VmwareManager mgr = getServiceContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	result = SshHelper.sshExecute(routerIP, DefaultDomRSshPort, "root", mgr.getSystemVMKeyFile(), null, "/opt/cloud/bin/" + script + " " + args, VRScripts.CONNECTION_TIMEOUT, VRScripts.CONNECTION_TIMEOUT, timeout);	} catch (Exception e) {	String msg = "Command failed due to " + VmwareHelper.getExceptionMessage(e);	s_logger.error(msg);	result = new Pair<Boolean, String>(false, msg);	}	if (s_logger.isDebugEnabled()) {	
execution result 

protected CheckSshAnswer execute(CheckSshCommand cmd) {	String vmName = cmd.getName();	String privateIp = cmd.getIp();	int cmdPort = cmd.getPort();	if (s_logger.isDebugEnabled()) {	
ping command port 

protected CheckSshAnswer execute(CheckSshCommand cmd) {	String vmName = cmd.getName();	String privateIp = cmd.getIp();	int cmdPort = cmd.getPort();	if (s_logger.isDebugEnabled()) {	}	try {	String result = connect(cmd.getName(), privateIp, cmdPort);	if (result != null) {	
can not ping system vm due to 

String privateIp = cmd.getIp();	int cmdPort = cmd.getPort();	if (s_logger.isDebugEnabled()) {	}	try {	String result = connect(cmd.getName(), privateIp, cmdPort);	if (result != null) {	return new CheckSshAnswer(cmd, "Can not ping System vm " + vmName + "due to:" + result);	}	} catch (Exception e) {	
can not ping system vm due to exception 

}	try {	String result = connect(cmd.getName(), privateIp, cmdPort);	if (result != null) {	return new CheckSshAnswer(cmd, "Can not ping System vm " + vmName + "due to:" + result);	}	} catch (Exception e) {	return new CheckSshAnswer(cmd, e);	}	if (s_logger.isDebugEnabled()) {	
ping command port succeeded for vm 

if (result != null) {	return new CheckSshAnswer(cmd, "Can not ping System vm " + vmName + "due to:" + result);	}	} catch (Exception e) {	return new CheckSshAnswer(cmd, e);	}	if (s_logger.isDebugEnabled()) {	}	if (VirtualMachineName.isValidRouterName(vmName)) {	if (s_logger.isDebugEnabled()) {	
execute network usage setup command on 

if (primaryStore.getUuid() != null && !primaryStore.getUuid().isEmpty()) {	validatedDisks.add(vol);	}	} else if (vol.getType() == Volume.Type.ISO) {	TemplateObjectTO templateTO = (TemplateObjectTO)vol.getData();	if (templateTO.getPath() != null && !templateTO.getPath().isEmpty()) {	validatedDisks.add(vol);	}	} else {	if (s_logger.isDebugEnabled()) {	
drop invalid disk option volumeto 

long reminder = requestedMaxMemoryInMb % hotaddIncrementSizeInMb;	if (reminder != 0) {	requestedMaxMemoryInMb = requestedMaxMemoryInMb + hotaddIncrementSizeInMb - reminder;	}	VmwareHelper.isFeatureLicensed(hyperHost, FeatureKeyConstants.HOTPLUG);	VmwareHelper.setVmScaleUpConfig(vmConfigSpec, vmSpec.getCpus(), vmSpec.getMaxSpeed(), vmSpec.getMinSpeed(), (int)requestedMaxMemoryInMb, ramMb, vmSpec.getLimitCpuUse());	if (!vmMo.configureVm(vmConfigSpec)) {	throw new Exception("Unable to execute ScaleVmCommand");	}	} catch (Exception e) {	
unexpected exception 

protected StartAnswer execute(StartCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource startcommand 

s_logger.error(msg);	throw new Exception(msg);	}	VirtualMachineDiskInfoBuilder diskInfoBuilder = null;	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);	DiskControllerType systemVmScsiControllerType = DiskControllerType.lsilogic;	int firstScsiControllerBusNum = 0;	int numScsiControllerForSystemVm = 1;	boolean hasSnapshot = false;	if (vmMo != null) {	
vm already exists tear down devices for reconfiguration 

ensureScsiDiskControllers(vmMo, systemVmScsiControllerType.toString(), numScsiControllerForSystemVm, firstScsiControllerBusNum);	} else {	ensureDiskControllers(vmMo, controllerInfo);	}	} else {	ManagedObjectReference morDc = hyperHost.getHyperHostDatacenter();	assert (morDc != null);	vmMo = hyperHost.findVmOnPeerHyperHost(vmInternalCSName);	if (vmMo != null) {	if (s_logger.isInfoEnabled()) {	
found vm at other host relocate to 

if (!hasSnapshot) vmMo.tearDownDevices(new Class<?>[] {VirtualDisk.class, VirtualEthernetCard.class});	else vmMo.tearDownDevices(new Class<?>[] {VirtualEthernetCard.class});	if (systemVm) {	ensureScsiDiskControllers(vmMo, systemVmScsiControllerType.toString(), numScsiControllerForSystemVm, firstScsiControllerBusNum);	} else {	ensureDiskControllers(vmMo, controllerInfo);	}	} else {	VirtualMachineMO existingVmInDc = dcMo.findVm(vmInternalCSName);	if (existingVmInDc != null) {	
found vm on a host in a different cluster unregistering the exisitng vm 

}	}	assert (vmSpec.getMinSpeed() != null) && (rootDiskDataStoreDetails != null);	boolean vmFolderExists = rootDiskDataStoreDetails.second().folderExists(String.format("[%s]", rootDiskDataStoreDetails.second().getName()), vmNameOnVcenter);	String vmxFileFullPath = dsRootVolumeIsOn.searchFileInSubFolders(vmNameOnVcenter + ".vmx", false);	if (vmFolderExists && vmxFileFullPath != null) {	registerVm(vmNameOnVcenter, dsRootVolumeIsOn);	vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);	if (vmMo != null) {	if (s_logger.isDebugEnabled()) {	
found registered vm at host 

if (coresPerSocket != null) {	String apiVersion = HypervisorHostHelper.getVcenterApiVersion(vmMo.getContext());	if (apiVersion.compareTo("5.0") >= 0) {	numCoresPerSocket = NumbersUtil.parseInt(coresPerSocket, 1);	vmConfigSpec.setNumCoresPerSocket(numCoresPerSocket);	}	}	vmConfigSpec.setMemoryHotAddEnabled(vmMo.isMemoryHotAddSupported(guestOsId));	String hostApiVersion = ((HostMO)hyperHost).getHostAboutInfo().getApiVersion();	if (numCoresPerSocket > 1 && hostApiVersion.compareTo("5.0") < 0) {	
dynamic scaling of cpu is not supported for virtual machines with multi core vcpus in case of esxi hosts and prior hence cpuhotadd will not be enabled for virtual machine 

ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);	if (morSecDs == null) {	String msg = "Failed to prepare secondary storage on host, secondary store url: " + secStoreUrl;	throw new Exception(msg);	}	DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, String.format("[%s] systemvm/%s", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);	deviceConfigSpecArray[i].setDevice(isoInfo.first());	if (isoInfo.second()) {	
prepare iso volume at new device 

String msg = "Failed to prepare secondary storage on host, secondary store url: " + secStoreUrl;	throw new Exception(msg);	}	DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, String.format("[%s] systemvm/%s", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);	deviceConfigSpecArray[i].setDevice(isoInfo.first());	if (isoInfo.second()) {	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	} else {	
prepare iso volume at existing device 

deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	} else {	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);	}	} else {	if (volIso != null) {	TemplateObjectTO iso = (TemplateObjectTO)volIso.getData();	if (iso.getPath() != null && !iso.getPath().isEmpty()) {	DataStoreTO imageStore = iso.getDataStore();	if (!(imageStore instanceof NfsTO)) {	
unsupported protocol 

}	NfsTO nfsImageStore = (NfsTO)imageStore;	String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();	Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);	assert (isoDatastoreInfo != null);	assert (isoDatastoreInfo.second() != null);	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber++, i + 1);	deviceConfigSpecArray[i].setDevice(isoInfo.first());	if (isoInfo.second()) {	
prepare iso volume at new device 

String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();	Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);	assert (isoDatastoreInfo != null);	assert (isoDatastoreInfo.second() != null);	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber++, i + 1);	deviceConfigSpecArray[i].setDevice(isoInfo.first());	if (isoInfo.second()) {	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	} else {	
prepare iso volume at existing device 

deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	} else {	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);	}	}	} else {	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);	deviceConfigSpecArray[i].setDevice(isoInfo.first());	if (isoInfo.second()) {	
prepare iso volume at existing device 

deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);	}	}	} else {	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);	deviceConfigSpecArray[i].setDevice(isoInfo.first());	if (isoInfo.second()) {	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	} else {	
prepare iso volume at existing device 

iScsiName = details.get(DiskTO.IQN);	}	String datastoreName = managed ? VmwareResource.getDatastoreName(iScsiName) : primaryStore.getUuid();	Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);	assert (volumeDsDetails != null);	String[] diskChain = syncDiskChain(dcMo, vmMo, vmSpec, vol, matchingExistingDisk, dataStoresDetails);	if(controllerKey == scsiControllerKey && VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) scsiUnitNumber++;	VirtualDevice device = VmwareHelper.prepareDiskDevice(vmMo, null, controllerKey, diskChain, volumeDsDetails.first(), (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) ? ((ideUnitNumber++) % VmwareHelper.MAX_IDE_CONTROLLER_COUNT) : scsiUnitNumber++, i + 1);	deviceConfigSpecArray[i].setDevice(device);	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	
prepare volume at new device 

i++;	} else {	if (controllerKey == scsiControllerKey && VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) scsiUnitNumber++;	if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) ideUnitNumber++;	else scsiUnitNumber++;	}	}	if (guestOsId.startsWith("darwin")) {	VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[] {VirtualUSBController.class});	if (devices.length == 0) {	
no usb controller device on vm start add usb controller device for mac os vm 

else scsiUnitNumber++;	}	}	if (guestOsId.startsWith("darwin")) {	VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[] {VirtualUSBController.class});	if (devices.length == 0) {	VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	deviceConfigSpecArray[i].setDevice(usbControllerDevice);	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	
prepare usb controller at new device 

}	if (guestOsId.startsWith("darwin")) {	VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[] {VirtualUSBController.class});	if (devices.length == 0) {	VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	deviceConfigSpecArray[i].setDevice(usbControllerDevice);	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	i++;	} else {	
usb controller device exists on vm start for mac os vm 

deviceConfigSpecArray[i].setDevice(usbControllerDevice);	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	i++;	} else {	}	}	VirtualDevice nic;	int nicMask = 0;	int nicCount = 0;	VirtualEthernetCardType nicDeviceType = VirtualEthernetCardType.valueOf(vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER));	
vm will be started with nic device type 

} else {	}	}	VirtualDevice nic;	int nicMask = 0;	int nicCount = 0;	VirtualEthernetCardType nicDeviceType = VirtualEthernetCardType.valueOf(vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER));	NiciraNvpApiVersion.logNiciraApiVersion();	Map<String, String> nicUuidToDvSwitchUuid = new HashMap<String, String>();	for (NicTO nicTo : sortNicsByDeviceId(nics)) {	
prepare nic device based on nicto 

boolean configureVServiceInNexus = (nicTo.getType() == TrafficType.Guest) && (vmSpec.getDetails().containsKey("ConfigureVServiceInNexus"));	VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();	Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, configureVServiceInNexus, vmType);	if ((nicTo.getBroadcastType() != BroadcastDomainType.Lswitch) || (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch && NiciraNvpApiVersion.isApiVersionLowerThan("4.2"))){	if (VmwareHelper.isDvPortGroup(networkInfo.first())) {	String dvSwitchUuid;	ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();	DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);	ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());	dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);	
preparing nic device on dvswitch 

String dvSwitchUuid;	ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();	DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);	ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());	dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);	nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid, nicTo.getMac(), nicUnitNumber++, i + 1, true, true);	if (nicTo.getUuid() != null) {	nicUuidToDvSwitchUuid.put(nicTo.getUuid(), dvSwitchUuid);	}	} else {	
preparing nic device on network 

} else {	nic = VmwareHelper.prepareNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), nicTo.getMac(), nicUnitNumber++, i + 1, true, true);	}	}	else{	nic = VmwareHelper.prepareNicOpaque(vmMo, nicDeviceType, networkInfo.second(), nicTo.getMac(), nicUnitNumber++, i + 1, true, true);	}	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	deviceConfigSpecArray[i].setDevice(nic);	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);	
prepare nic at new device 

throw new Exception("Failed to start VM. vmName: " + vmInternalCSName + " with hostname " + vmNameOnVcenter);	}	StartAnswer startAnswer = new StartAnswer(cmd);	startAnswer.setIqnToPath(iqnToPath);	if (existingVmName != null && existingVmFileLayout != null) {	deleteUnregisteredVmFiles(existingVmFileLayout, dcMo, true);	}	return startAnswer;	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

if (e instanceof RemoteException) {	invalidateServiceContext();	}	String msg = "StartCommand failed due to " + VmwareHelper.getExceptionMessage(e);	s_logger.warn(msg, e);	StartAnswer startAnswer = new StartAnswer(cmd, msg);	if(vmAlreadyExistsInVcenter) {	startAnswer.setContextParam("stopRetry", "true");	}	if (existingVmName != null && existingVmFileInfo != null) {	
since vm start failed registering back an existing vm that was unregistered 

protected void postVideoCardMemoryConfigBeforeStart(VirtualMachineMO vmMo, VirtualMachineTO vmSpec) {	String paramVRamSize = "svga.vramSize";	if (vmSpec.getDetails().containsKey(paramVRamSize)){	String value = vmSpec.getDetails().get(paramVRamSize);	try {	long svgaVmramSize = Long.parseLong(value);	setNewVRamSizeVmVideoCard(vmMo, svgaVmramSize);	}	catch (NumberFormatException e){	
unexpected value cannot parse to long due to 

String paramVRamSize = "svga.vramSize";	if (vmSpec.getDetails().containsKey(paramVRamSize)){	String value = vmSpec.getDetails().get(paramVRamSize);	try {	long svgaVmramSize = Long.parseLong(value);	setNewVRamSizeVmVideoCard(vmMo, svgaVmramSize);	}	catch (NumberFormatException e){	}	catch (Exception e){	
error while reconfiguring vm due to 

private void modifyVmVideoCardVRamSize(VirtualMachineVideoCard videoCard, VirtualMachineMO vmMo, long svgaVmramSize) throws Exception {	if (videoCard.getVideoRamSizeInKB().longValue() != svgaVmramSize){	
video card memory was set kb instead of kb 

private void modifyVmVideoCardVRamSize(VirtualMachineVideoCard videoCard, VirtualMachineMO vmMo, long svgaVmramSize) throws Exception {	if (videoCard.getVideoRamSizeInKB().longValue() != svgaVmramSize){	VirtualMachineConfigSpec newSizeSpecs = configSpecVideoCardNewVRamSize(videoCard, svgaVmramSize);	boolean res = vmMo.configureVm(newSizeSpecs);	if (res) {	
video card memory successfully updated to kb 

Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);	if (volumeDsDetails == null) {	throw new Exception("Primary datastore " + primaryStore.getUuid() + " is not mounted on host.");	}	DatastoreMO dsMo = volumeDsDetails.second();	if (diskInfo != null) {	String disks[] = diskInfo.getDiskChain();	for (int i = 0; i < disks.length; i++) {	DatastoreFile file = new DatastoreFile(disks[i]);	if (!isManaged && file.getDir() != null && file.getDir().isEmpty()) {	
perform run time datastore folder upgrade sync to vm folder 

if (volumeTO.getVolumeType() == Volume.Type.ROOT) {	datastoreDiskPath = VmwareStorageLayoutHelper.syncVolumeToVmDefaultFolder(dcMo, vmMo.getName(), dsMo, volumeTO.getName());	}	else {	datastoreDiskPath = dsMo.getDatastorePath(dsMo.getName() + ".vmdk");	}	} else {	datastoreDiskPath = VmwareStorageLayoutHelper.syncVolumeToVmDefaultFolder(dcMo, vmMo.getName(), dsMo, volumeTO.getPath());	}	if (!dsMo.fileExists(datastoreDiskPath)) {	
volume does not seem to exist on datastore out of sync path 

private static void configNestedHVSupport(VirtualMachineMO vmMo, VirtualMachineTO vmSpec, VirtualMachineConfigSpec vmConfigSpec) throws Exception {	VmwareContext context = vmMo.getContext();	if ("true".equals(vmSpec.getDetails().get(VmDetailConstants.NESTED_VIRTUALIZATION_FLAG))) {	
nested virtualization enabled in configuration checking hypervisor capability 

private static void configNestedHVSupport(VirtualMachineMO vmMo, VirtualMachineTO vmSpec, VirtualMachineConfigSpec vmConfigSpec) throws Exception {	VmwareContext context = vmMo.getContext();	if ("true".equals(vmSpec.getDetails().get(VmDetailConstants.NESTED_VIRTUALIZATION_FLAG))) {	ManagedObjectReference hostMor = vmMo.getRunningHost().getMor();	ManagedObjectReference computeMor = context.getVimClient().getMoRefProp(hostMor, "parent");	ManagedObjectReference environmentBrowser = context.getVimClient().getMoRefProp(computeMor, "environmentBrowser");	HostCapability hostCapability = context.getService().queryTargetCapabilities(environmentBrowser, hostMor);	Boolean nestedHvSupported = hostCapability.isNestedHVSupported();	if (nestedHvSupported == null) {	
hypervisor doesn t support nested virtualization unable to set config for vm 

private static void configNestedHVSupport(VirtualMachineMO vmMo, VirtualMachineTO vmSpec, VirtualMachineConfigSpec vmConfigSpec) throws Exception {	VmwareContext context = vmMo.getContext();	if ("true".equals(vmSpec.getDetails().get(VmDetailConstants.NESTED_VIRTUALIZATION_FLAG))) {	ManagedObjectReference hostMor = vmMo.getRunningHost().getMor();	ManagedObjectReference computeMor = context.getVimClient().getMoRefProp(hostMor, "parent");	ManagedObjectReference environmentBrowser = context.getVimClient().getMoRefProp(computeMor, "environmentBrowser");	HostCapability hostCapability = context.getService().queryTargetCapabilities(environmentBrowser, hostMor);	Boolean nestedHvSupported = hostCapability.isNestedHVSupported();	if (nestedHvSupported == null) {	} else if (nestedHvSupported.booleanValue()) {	
hypervisor supports nested virtualization enabling for vm 

if ("true".equals(vmSpec.getDetails().get(VmDetailConstants.NESTED_VIRTUALIZATION_FLAG))) {	ManagedObjectReference hostMor = vmMo.getRunningHost().getMor();	ManagedObjectReference computeMor = context.getVimClient().getMoRefProp(hostMor, "parent");	ManagedObjectReference environmentBrowser = context.getVimClient().getMoRefProp(computeMor, "environmentBrowser");	HostCapability hostCapability = context.getService().queryTargetCapabilities(environmentBrowser, hostMor);	Boolean nestedHvSupported = hostCapability.isNestedHVSupported();	if (nestedHvSupported == null) {	} else if (nestedHvSupported.booleanValue()) {	vmConfigSpec.setNestedHVEnabled(true);	} else {	
hypervisor doesn t support nested virtualization unable to set config for vm 

String vrIp = nicTo.getBroadcastUri().getPath().substring(1);	newVal = new OptionValue();	newVal.setKey("vsp.vr-ip." + nicTo.getMac());	newVal.setValue(vrIp);	extraOptions.add(newVal);	newVal = new OptionValue();	newVal.setKey("vsp.dvswitch." + nicTo.getMac());	newVal.setValue(dvSwitchUuid);	extraOptions.add(newVal);	if (s_logger.isDebugEnabled()) {	
nic with mac and broadcastdomaintype in network is traffic type so vsp vr ip is set in the extraconfig 

private static void postNvpConfigBeforeStart(VirtualMachineMO vmMo, VirtualMachineTO vmSpec) throws Exception {	int nicIndex = 0;	for (NicTO nicTo : sortNicsByDeviceId(vmSpec.getNics())) {	if (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch) {	
nic is connected to an nvp logicalswitch 

if (nicVirtualDevice == null) {	throw new Exception("Failed to find a VirtualDevice for nic " + nicIndex);	}	VirtualDeviceBackingInfo backing = nicVirtualDevice.getBacking();	if (backing instanceof VirtualEthernetCardDistributedVirtualPortBackingInfo) {	VirtualEthernetCardDistributedVirtualPortBackingInfo portInfo = (VirtualEthernetCardDistributedVirtualPortBackingInfo)backing;	DistributedVirtualSwitchPortConnection port = portInfo.getPort();	String portKey = port.getPortKey();	String portGroupKey = port.getPortgroupKey();	String dvSwitchUuid = port.getSwitchUuid();	
nic is connected to dvswitch pg port 

criteria.getPortgroupKey().add(portGroupKey);	List<DistributedVirtualPort> dvPorts = vmMo.getContext().getVimClient().getService().fetchDVPorts(dvSwitch, criteria);	DistributedVirtualPort vmDvPort = null;	List<Integer> usedVlans = new ArrayList<Integer>();	for (DistributedVirtualPort dvPort : dvPorts) {	if (portKey.equals(dvPort.getKey())) {	vmDvPort = dvPort;	}	VMwareDVSPortSetting settings = (VMwareDVSPortSetting)dvPort.getConfig().getSetting();	VmwareDistributedVirtualSwitchVlanIdSpec vlanId = (VmwareDistributedVirtualSwitchVlanIdSpec)settings.getVlan();	
found port with vlan 

}	}	if (vmDvPort == null) {	throw new Exception("Empty port list from dvSwitch for nic " + nicTo.toString());	}	DVPortConfigInfo dvPortConfigInfo = vmDvPort.getConfig();	VMwareDVSPortSetting settings = (VMwareDVSPortSetting)dvPortConfigInfo.getSetting();	VmwareDistributedVirtualSwitchVlanIdSpec vlanId = (VmwareDistributedVirtualSwitchVlanIdSpec)settings.getVlan();	BoolPolicy blocked = settings.getBlocked();	if (blocked.isValue() == Boolean.TRUE) {	
port is blocked set a vlanid and unblock 

edittedSettings.setVlan(vlanId);	dvPortConfigSpec.setSetting(edittedSettings);	dvPortConfigSpec.setOperation("edit");	dvPortConfigSpec.setKey(portKey);	List<DVPortConfigSpec> dvPortConfigSpecs = new ArrayList<DVPortConfigSpec>();	dvPortConfigSpecs.add(dvPortConfigSpec);	ManagedObjectReference task = vmMo.getContext().getVimClient().getService().reconfigureDVPortTask(dvSwitch, dvPortConfigSpecs);	if (!vmMo.getContext().getVimClient().waitForTask(task)) {	throw new Exception("Failed to configure the dvSwitch port for nic " + nicTo.toString());	}	
nic connected to vlan 

dvPortConfigSpec.setSetting(edittedSettings);	dvPortConfigSpec.setOperation("edit");	dvPortConfigSpec.setKey(portKey);	List<DVPortConfigSpec> dvPortConfigSpecs = new ArrayList<DVPortConfigSpec>();	dvPortConfigSpecs.add(dvPortConfigSpec);	ManagedObjectReference task = vmMo.getContext().getVimClient().getService().reconfigureDVPortTask(dvSwitch, dvPortConfigSpecs);	if (!vmMo.getContext().getVimClient().waitForTask(task)) {	throw new Exception("Failed to configure the dvSwitch port for nic " + nicTo.toString());	}	} else {	
port already configured and set to vlan 

dvPortConfigSpecs.add(dvPortConfigSpec);	ManagedObjectReference task = vmMo.getContext().getVimClient().getService().reconfigureDVPortTask(dvSwitch, dvPortConfigSpecs);	if (!vmMo.getContext().getVimClient().waitForTask(task)) {	throw new Exception("Failed to configure the dvSwitch port for nic " + nicTo.toString());	}	} else {	}	} else if (backing instanceof VirtualEthernetCardNetworkBackingInfo) {	} else if (backing instanceof VirtualEthernetCardOpaqueNetworkBackingInfo) {	} else {	
nic device backing is of type 

diskBackingFileBaseName = new DatastoreFile(volume.getPath()).getFileBaseName();	}	else {	ManagedObjectReference morDs = HypervisorHostHelper.findDatastoreWithBackwardsCompatibility(hyperHost, volume.getDataStore().getUuid());	DatastoreMO dsMo = new DatastoreMO(context, morDs);	dsName = dsMo.getName();	diskBackingFileBaseName = volume.getPath();	}	VirtualMachineDiskInfo diskInfo = diskInfoBuilder.getDiskInfoByBackingFileBaseName(diskBackingFileBaseName, dsName);	if (diskInfo != null) {	
found existing disk info from volume path 

String chainInfo = volume.getChainInfo();	if (chainInfo != null) {	VirtualMachineDiskInfo infoInChain = _gson.fromJson(chainInfo, VirtualMachineDiskInfo.class);	if (infoInChain != null) {	String[] disks = infoInChain.getDiskChain();	if (disks.length > 0) {	for (String diskPath : disks) {	DatastoreFile file = new DatastoreFile(diskPath);	diskInfo = diskInfoBuilder.getDiskInfoByBackingFileBaseName(file.getFileBaseName(), dsName);	if (diskInfo != null) {	
found existing disk from chain info 

DatastoreFile file = new DatastoreFile(diskPath);	diskInfo = diskInfoBuilder.getDiskInfoByBackingFileBaseName(file.getFileBaseName(), dsName);	if (diskInfo != null) {	return diskInfo;	}	}	}	if (diskInfo == null) {	diskInfo = diskInfoBuilder.getDiskInfoByDeviceBusName(infoInChain.getDiskDeviceBusName());	if (diskInfo != null) {	
found existing disk from from chain device bus information 

private int getDiskController(VirtualMachineDiskInfo matchingExistingDisk, DiskTO vol, VirtualMachineTO vmSpec, int ideControllerKey, int scsiControllerKey) {	int controllerKey;	if (matchingExistingDisk != null) {	
chose disk controller based on existing information 

private int getDiskController(VirtualMachineDiskInfo matchingExistingDisk, DiskTO vol, VirtualMachineTO vmSpec, int ideControllerKey, int scsiControllerKey) {	int controllerKey;	if (matchingExistingDisk != null) {	if (matchingExistingDisk.getDiskDeviceBusName().startsWith("ide")) return ideControllerKey;	else return scsiControllerKey;	}	if (vol.getType() == Volume.Type.ROOT) {	Map<String, String> vmDetails = vmSpec.getDetails();	if (vmDetails != null && vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER) != null) {	if (vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER).equalsIgnoreCase("scsi")) {	
chose disk controller for vol scsi based on root disk controller settings 

if (matchingExistingDisk != null) {	if (matchingExistingDisk.getDiskDeviceBusName().startsWith("ide")) return ideControllerKey;	else return scsiControllerKey;	}	if (vol.getType() == Volume.Type.ROOT) {	Map<String, String> vmDetails = vmSpec.getDetails();	if (vmDetails != null && vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER) != null) {	if (vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER).equalsIgnoreCase("scsi")) {	controllerKey = scsiControllerKey;	} else {	
chose disk controller for vol ide based on root disk controller settings 

}	if (vol.getType() == Volume.Type.ROOT) {	Map<String, String> vmDetails = vmSpec.getDetails();	if (vmDetails != null && vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER) != null) {	if (vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER).equalsIgnoreCase("scsi")) {	controllerKey = scsiControllerKey;	} else {	controllerKey = ideControllerKey;	}	} else {	
chose disk controller for vol scsi due to null root disk controller setting 

if (vmDetails != null && vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER) != null) {	if (vmDetails.get(VmDetailConstants.ROOT_DISK_CONTROLLER).equalsIgnoreCase("scsi")) {	controllerKey = scsiControllerKey;	} else {	controllerKey = ideControllerKey;	}	} else {	controllerKey = scsiControllerKey;	}	} else {	
chose disk controller for vol scsi 

private String getDiskController(VirtualMachineMO vmMo, VirtualMachineDiskInfo matchingExistingDisk, DiskTO vol, Pair<String, String> controllerInfo) throws Exception {	int controllerKey;	DiskControllerType controllerType = DiskControllerType.none;	if (matchingExistingDisk != null) {	String currentBusName = matchingExistingDisk.getDiskDeviceBusName();	if (currentBusName != null) {	
chose disk controller based on existing information 

controllerType = DiskControllerType.scsi;	}	}	if (controllerType == DiskControllerType.scsi || controllerType == DiskControllerType.none) {	Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();	controllerType = vmScsiControllerInfo.third();	}	return controllerType.toString();	}	if (vol.getType() == Volume.Type.ROOT) {	
chose disk controller for vol based on root disk controller settings at global configuration setting 

}	if (controllerType == DiskControllerType.scsi || controllerType == DiskControllerType.none) {	Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();	controllerType = vmScsiControllerInfo.third();	}	return controllerType.toString();	}	if (vol.getType() == Volume.Type.ROOT) {	return controllerInfo.first();	} else {	
chose disk controller for vol based on default data disk controller setting i e operating system recommended 

assert (diskChain.length > 0);	Map<String, String> details = vol.getDetails();	boolean managed = false;	if (details != null) {	managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));	}	DatastoreFile file = new DatastoreFile(diskChain[0]);	if (managed) {	DatastoreFile originalFile = new DatastoreFile(volumeTO.getPath());	if (!file.getFileBaseName().equalsIgnoreCase(originalFile.getFileBaseName())) {	
detected disk chain top file change on volume 

managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));	}	DatastoreFile file = new DatastoreFile(diskChain[0]);	if (managed) {	DatastoreFile originalFile = new DatastoreFile(volumeTO.getPath());	if (!file.getFileBaseName().equalsIgnoreCase(originalFile.getFileBaseName())) {	}	}	else {	if (!file.getFileBaseName().equalsIgnoreCase(volumeTO.getPath())) {	
detected disk chain top file change on volume 

private void deleteUnregisteredVmFiles(VirtualMachineFileLayoutEx vmFileLayout, DatacenterMO dcMo, boolean deleteDisks) throws Exception {	
deleting files associated with an existing vm that was unregistered 

private void deleteUnregisteredVmFiles(VirtualMachineFileLayoutEx vmFileLayout, DatacenterMO dcMo, boolean deleteDisks) throws Exception {	DatastoreFile vmFolder = null;	try {	List<VirtualMachineFileLayoutExFileInfo> fileInfo = vmFileLayout.getFile();	for (VirtualMachineFileLayoutExFileInfo file : fileInfo) {	DatastoreFile fileInDatastore = new DatastoreFile(file.getName());	if (file.getType().startsWith("disk") || file.getType().startsWith("digest")) continue;	else if (file.getType().equals("config")) vmFolder = new DatastoreFile(fileInDatastore.getDatastoreName(), fileInDatastore.getDir());	DatastoreMO dsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));	
deleting file 

if (file.getType().startsWith("disk") || file.getType().startsWith("digest")) continue;	else if (file.getType().equals("config")) vmFolder = new DatastoreFile(fileInDatastore.getDatastoreName(), fileInDatastore.getDir());	DatastoreMO dsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));	dsMo.deleteFile(file.getName(), dcMo.getMor(), true);	}	DatastoreMO vmFolderDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(vmFolder.getDatastoreName()));	String[] files = vmFolderDsMo.listDirContent(vmFolder.getPath());	if (deleteDisks) {	for (String file : files) {	String vmDiskFileFullPath = String.format("%s/%s", vmFolder.getPath(), file);	
deleting file 

}	DatastoreMO vmFolderDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(vmFolder.getDatastoreName()));	String[] files = vmFolderDsMo.listDirContent(vmFolder.getPath());	if (deleteDisks) {	for (String file : files) {	String vmDiskFileFullPath = String.format("%s/%s", vmFolder.getPath(), file);	vmFolderDsMo.deleteFile(vmDiskFileFullPath, dcMo.getMor(), true);	}	}	if (deleteDisks || files.length == 0) {	
deleting folder 

private String getVlanInfo(NicTO nicTo, String defaultVlan) {	if (nicTo.getBroadcastType() == BroadcastDomainType.Native) {	return defaultVlan;	} else if (nicTo.getBroadcastType() == BroadcastDomainType.Vlan || nicTo.getBroadcastType() == BroadcastDomainType.Pvlan) {	if (nicTo.getBroadcastUri() != null) {	if (nicTo.getBroadcastType() == BroadcastDomainType.Vlan) return BroadcastDomainType.getValue(nicTo.getBroadcastUri());	else return NetUtils.getPrimaryPvlanFromUri(nicTo.getBroadcastUri());	} else {	
broadcasttype is not claimed as vlan or pvlan but without vlan info in broadcast uri use vlan info from labeling 

else return NetUtils.getPrimaryPvlanFromUri(nicTo.getBroadcastUri());	} else {	return defaultVlan;	}	} else if (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch) {	return null;	} else if (nicTo.getBroadcastType() == BroadcastDomainType.Storage) {	URI broadcastUri = nicTo.getBroadcastUri();	if (broadcastUri != null) {	String vlanId = BroadcastDomainType.getValue(broadcastUri);	
using vlan from broadcast uri 

}	} else if (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch) {	return null;	} else if (nicTo.getBroadcastType() == BroadcastDomainType.Storage) {	URI broadcastUri = nicTo.getBroadcastUri();	if (broadcastUri != null) {	String vlanId = BroadcastDomainType.getValue(broadcastUri);	return vlanId;	}	}	
unrecognized broadcast type in vmwareresource type use vlan info from labeling 

private Pair<ManagedObjectReference, String> prepareNetworkFromNicInfo(HostMO hostMo, NicTO nicTo, boolean configureVServiceInNexus, VirtualMachine.Type vmType) throws Exception {	Ternary<String, String, String> switchDetails = getTargetSwitch(nicTo);	VirtualSwitchType switchType = VirtualSwitchType.getType(switchDetails.second());	String switchName = switchDetails.first();	String vlanToken = switchDetails.third();	String namePrefix = getNetworkNamePrefix(nicTo);	Pair<ManagedObjectReference, String> networkInfo = null;	
prepare network on with name prefix 

protected Answer execute(ReadyCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource readycommand 

}	try {	VmwareContext context = getServiceContext();	VmwareHypervisorHost hyperHost = getHyperHost(context);	if (hyperHost.isHyperHostConnected()) {	return new ReadyAnswer(cmd);	} else {	return new ReadyAnswer(cmd, "Host is not in connect state");	}	} catch (Exception e) {	
unexpected exception 

protected Answer execute(GetHostStatsCommand cmd) {	if (s_logger.isTraceEnabled()) {	
executing resource gethoststatscommand 

HostStatsEntry hostStats = new HostStatsEntry(cmd.getHostId(), 0, 0, 0, "host", 0, 0, 0, 0);	Answer answer = new GetHostStatsAnswer(cmd, hostStats);	try {	HostStatsEntry entry = getHyperHostStats(hyperHost);	if (entry != null) {	entry.setHostId(cmd.getHostId());	answer = new GetHostStatsAnswer(cmd, entry);	}	} catch (Exception e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

answer = new GetHostStatsAnswer(cmd, entry);	}	} catch (Exception e) {	if (e instanceof RemoteException) {	invalidateServiceContext();	}	String msg = "Unable to execute GetHostStatsCommand due to " + VmwareHelper.getExceptionMessage(e);	s_logger.error(msg, e);	}	if (s_logger.isTraceEnabled()) {	
gethoststats answer 

protected Answer execute(GetVmStatsCommand cmd) {	if (s_logger.isTraceEnabled()) {	
executing resource getvmstatscommand 

if (vmPowerStates.get(vmName) != null) {	vmNames.add(vmName);	}	}	}	if (vmNames != null) {	vmStatsMap = getVmStats(vmNames);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

}	}	}	if (vmNames != null) {	vmStatsMap = getVmStats(vmNames);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	invalidateServiceContext();	}	
unable to execute getvmstatscommand due to 

if (vmNames != null) {	vmStatsMap = getVmStats(vmNames);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	invalidateServiceContext();	}	}	Answer answer = new GetVmStatsAnswer(cmd, vmStatsMap);	if (s_logger.isTraceEnabled()) {	
report getvmstatsanswer 

protected Answer execute(CheckHealthCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource checkhealthcommand 

protected Answer execute(CheckHealthCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	try {	VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext());	if (hyperHost.isHyperHostConnected()) {	return new CheckHealthAnswer(cmd, true);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

}	try {	VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext());	if (hyperHost.isHyperHostConnected()) {	return new CheckHealthAnswer(cmd, true);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	invalidateServiceContext();	}	
unable to execute checkhealthcommand due to 

protected Answer execute(StopCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource stopcommand 

return new StopAnswer(cmd, msg, true);	} finally {	}	} else {	String msg = "VM " + cmd.getVmName() + " is no longer in vSphere";	s_logger.info(msg);	return new StopAnswer(cmd, msg, true);	}	} catch (Exception e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(RebootRouterCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource rebootroutercommand 

protected Answer execute(RebootCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource rebootcommand 

}	VmwareContext context = getServiceContext();	VmwareHypervisorHost hyperHost = getHyperHost(context);	try {	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(cmd.getVmName());	if (vmMo != null) {	try {	vmMo.rebootGuest();	return new RebootAnswer(cmd, "reboot succeeded", true);	} catch (ToolsUnavailableFaultMsg e) {	
vmware tools is not installed at guest os we will perform hard reset for reboot 

VmwareContext context = getServiceContext();	VmwareHypervisorHost hyperHost = getHyperHost(context);	try {	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(cmd.getVmName());	if (vmMo != null) {	try {	vmMo.rebootGuest();	return new RebootAnswer(cmd, "reboot succeeded", true);	} catch (ToolsUnavailableFaultMsg e) {	} catch (Exception e) {	
we are not able to perform gracefull guest reboot due to 

String msg = "Reboot failed in vSphere. vm: " + cmd.getVmName();	s_logger.warn(msg);	return new RebootAnswer(cmd, msg, false);	} else {	String msg = "Unable to find the VM in vSphere to reboot. vm: " + cmd.getVmName();	s_logger.warn(msg);	return new RebootAnswer(cmd, msg, false);	}	} catch (Exception e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(CheckVirtualMachineCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource checkvirtualmachinecommand 

PowerState powerState = PowerState.PowerUnknown;	Integer vncPort = null;	VmwareContext context = getServiceContext();	VmwareHypervisorHost hyperHost = getHyperHost(context);	try {	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmName);	if (vmMo != null) {	powerState = getVmPowerState(vmMo);	return new CheckVirtualMachineAnswer(cmd, powerState, vncPort);	} else {	
can not find vm to execute checkvirtualmachinecommand 

try {	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmName);	if (vmMo != null) {	powerState = getVmPowerState(vmMo);	return new CheckVirtualMachineAnswer(cmd, powerState, vncPort);	} else {	return new CheckVirtualMachineAnswer(cmd, powerState, vncPort);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

if (vmMo != null) {	powerState = getVmPowerState(vmMo);	return new CheckVirtualMachineAnswer(cmd, powerState, vncPort);	} else {	return new CheckVirtualMachineAnswer(cmd, powerState, vncPort);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	invalidateServiceContext();	}	
unexpected exception 

protected Answer execute(PrepareForMigrationCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource prepareformigrationcommand 

protected Answer execute(PrepareForMigrationCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	VirtualMachineTO vm = cmd.getVirtualMachine();	if (s_logger.isDebugEnabled()) {	
preparing host for migrating 

}	VirtualMachineTO vm = cmd.getVirtualMachine();	if (s_logger.isDebugEnabled()) {	}	final String vmName = vm.getName();	try {	VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext());	VmwareManager mgr = hyperHost.getContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	VirtualMachineMO vmMo = hyperHost.findVmOnPeerHyperHost(vmName);	if (vmMo == null) {	
vm was not found in the cluster of host looking for the vm in datacenter 

}	mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);	ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);	if (morSecDs == null) {	String msg = "Failed to prepare secondary storage on host, secondary store url: " + secStoreUrl;	throw new Exception(msg);	}	return new PrepareForMigrationAnswer(cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(MigrateCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource migratecommand 

ManagedObjectReference morTargetPhysicalHost = destHyperHost.findMigrationTarget(vmMo);	if (morTargetPhysicalHost == null) {	throw new Exception("Unable to find a target capable physical host");	}	if (!vmMo.migrate(destHyperHost.getHyperHostOwnerResourcePool(), morTargetPhysicalHost)) {	throw new Exception("Migration failed");	}	return new MigrateAnswer(cmd, true, "migration succeeded", null);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(MigrateWithStorageCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource migratewithstoragecommand 

vmMo = srcHyperHost.findVmOnPeerHyperHost(vmName);	if (vmMo == null) {	String msg = "VM " + vmName + " does not exist in VMware datacenter " + morDc.getValue();	s_logger.error(msg);	throw new Exception(msg);	}	vmName = vmMo.getName();	for (Pair<VolumeTO, StorageFilerTO> entry : volToFiler) {	volume = entry.first();	filerTo = entry.second();	
preparing spec for volume 

tgtDsHost = filerTo.getHost();	tgtDsPath = filerTo.getPath();	tgtDsPort = filerTo.getPort();	if (filerTo.getType().equals(StoragePoolType.NetworkFilesystem)) {	if (morDsAtSource == null) {	morDsAtSource = srcHyperHost.mountDatastore(false, tgtDsHost, tgtDsPort, tgtDsPath, tgtDsName);	if (morDsAtSource == null) {	throw new Exception("Unable to mount NFS datastore " + tgtDsHost + ":/" + tgtDsPath + " on " + _hostName);	}	mountedDatastoresAtSource.add(tgtDsName);	
mounted datastore on 

if (morDsAtSource == null) {	morDsAtSource = srcHyperHost.mountDatastore(false, tgtDsHost, tgtDsPort, tgtDsPath, tgtDsName);	if (morDsAtSource == null) {	throw new Exception("Unable to mount NFS datastore " + tgtDsHost + ":/" + tgtDsPath + " on " + _hostName);	}	mountedDatastoresAtSource.add(tgtDsName);	}	}	if (filerTo.getType().equals(StoragePoolType.VMFS)) {	if (morDsAtSource == null) {	
if host version is below then target vmfs datastore s need to manually mounted on source host for a successful live storage migration 

mountedDatastoresAtSource.add(tgtDsName);	}	}	if (filerTo.getType().equals(StoragePoolType.VMFS)) {	if (morDsAtSource == null) {	throw new Exception("Target VMFS datastore: " + tgtDsPath + " is not mounted on source host: " + _hostName);	}	DatastoreMO dsAtSourceMo = new DatastoreMO(getServiceContext(), morDsAtSource);	String srcHostValue = srcHyperHost.getMor().getValue();	if(!dsAtSourceMo.isAccessibleToHost(srcHostValue)) {	
if host version is below then target vmfs datastore s need to accessible to source host for a successful live storage migration 

mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);	ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnSpecificHost(secStoreUrl, tgtHyperHost);	if (morSecDs == null) {	String msg = "Failed to prepare secondary storage on host, secondary store url: " + secStoreUrl;	throw new Exception(msg);	}	if (srcHostApiVersion.compareTo("5.1") < 0) {	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during storage migration");	} else {	
successfully migrated storage of vm to target datastore s 

}	if (srcHostApiVersion.compareTo("5.1") < 0) {	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during storage migration");	} else {	}	ManagedObjectReference morPool = tgtHyperHost.getHyperHostOwnerResourcePool();	if (!vmMo.migrate(morPool, tgtHyperHost.getMor())) {	throw new Exception("VM migration to target host failed during storage migration");	} else {	
successfully migrated vm from to 

if (!vmMo.migrate(morPool, tgtHyperHost.getMor())) {	throw new Exception("VM migration to target host failed during storage migration");	} else {	}	} else {	relocateSpec.setHost(tgtHyperHost.getMor());	relocateSpec.setPool(tgtHyperHost.getHyperHostOwnerResourcePool());	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during storage migration");	} else {	
successfully migrated vm from to and its storage to target datastore s 

}	} else {	relocateSpec.setHost(tgtHyperHost.getMor());	relocateSpec.setPool(tgtHyperHost.getHyperHostOwnerResourcePool());	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during storage migration");	} else {	}	}	if (!vmMo.consolidateVmDisks()) {	
vm disk consolidation failed after storage migration yet proceeding with vm migration 

} else {	relocateSpec.setHost(tgtHyperHost.getMor());	relocateSpec.setPool(tgtHyperHost.getHyperHostOwnerResourcePool());	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during storage migration");	} else {	}	}	if (!vmMo.consolidateVmDisks()) {	} else {	
successfully consolidated disks of vm 

newVol.setPath(newPath);	newVol.setChainInfo(_gson.toJson(diskInfo));	volumeToList.add(newVol);	break;	}	}	}	return new MigrateWithStorageAnswer(cmd, volumeToList);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encountered remote exception at vcenter invalidating vmware session context 

return new MigrateWithStorageAnswer(cmd, volumeToList);	} catch (Throwable e) {	if (e instanceof RemoteException) {	invalidateServiceContext();	}	String msg = "MigrationCommand failed due to " + VmwareHelper.getExceptionMessage(e);	s_logger.warn(msg, e);	return new MigrateWithStorageAnswer(cmd, (Exception)e);	} finally {	for (String mountedDatastore : mountedDatastoresAtSource) {	
attempting to unmount datastore at 

invalidateServiceContext();	}	String msg = "MigrationCommand failed due to " + VmwareHelper.getExceptionMessage(e);	s_logger.warn(msg, e);	return new MigrateWithStorageAnswer(cmd, (Exception)e);	} finally {	for (String mountedDatastore : mountedDatastoresAtSource) {	try {	srcHyperHost.unmountDatastore(mountedDatastore);	} catch (Exception unmountEx) {	
failed to unmount datastore at seems the datastore is still being used by please unmount manually to cleanup 

}	String msg = "MigrationCommand failed due to " + VmwareHelper.getExceptionMessage(e);	s_logger.warn(msg, e);	return new MigrateWithStorageAnswer(cmd, (Exception)e);	} finally {	for (String mountedDatastore : mountedDatastoresAtSource) {	try {	srcHyperHost.unmountDatastore(mountedDatastore);	} catch (Exception unmountEx) {	}	
successfully unmounted datastore at 

private Answer execute(MigrateVolumeCommand cmd) {	String volumePath = cmd.getVolumePath();	StorageFilerTO poolTo = cmd.getPool();	if (s_logger.isInfoEnabled()) {	
executing resource migratevolumecommand 

diskLocator.setDiskId(diskDatastore.first().intValue());	diskLocator.setDatastore(diskDatastore.second());	diskLocators.add(diskLocator);	}	}	}	relocateSpec.getDisk().addAll(diskLocators);	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during volume migration");	} else {	
successfully migrated volume to target datastore 

diskLocators.add(diskLocator);	}	}	}	relocateSpec.getDisk().addAll(diskLocators);	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during volume migration");	} else {	}	if (!vmMo.consolidateVmDisks()) {	
vm disk consolidation failed after storage migration 

}	}	}	relocateSpec.getDisk().addAll(diskLocators);	if (!vmMo.changeDatastore(relocateSpec)) {	throw new Exception("Change datastore operation failed during volume migration");	} else {	}	if (!vmMo.consolidateVmDisks()) {	} else {	
successfully consolidated disks of vm 

protected Answer execute(ModifyStoragePoolCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource modifystoragepoolcommand 

long capacity = summary.getCapacity();	long available = summary.getFreeSpace();	Map<String, TemplateProp> tInfo = new HashMap<String, TemplateProp>();	ModifyStoragePoolAnswer answer = new ModifyStoragePoolAnswer(cmd, capacity, available, tInfo);	if (cmd.getAdd() && pool.getType() == StoragePoolType.VMFS) {	answer.setLocalDatastoreName(morDatastore.getValue());	}	return answer;	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(DeleteStoragePoolCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource deletestoragepoolcommand 

try {	if (cmd.getRemoveDatastore()) {	_storageProcessor.handleDatastoreAndVmdkDetach(cmd.getDetails().get(DeleteStoragePoolCommand.DATASTORE_NAME), cmd.getDetails().get(DeleteStoragePoolCommand.IQN), cmd.getDetails().get(DeleteStoragePoolCommand.STORAGE_HOST), Integer.parseInt(cmd.getDetails().get(DeleteStoragePoolCommand.STORAGE_PORT)));	return new Answer(cmd, true, "success");	}	else {	return new Answer(cmd, true, "success");	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(AttachIsoCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource attachisocommand 

String storeName = secondaryDsMo.getName();	String isoDatastorePath = String.format("[%s] %s%s", storeName, isoStorePathFromRoot, isoFileName);	if (cmd.isAttach()) {	vmMo.attachIso(isoDatastorePath, morSecondaryDs, true, false);	} else {	vmMo.detachIso(isoDatastorePath);	}	return new Answer(cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

private static String getSecondaryDatastoreUUID(String storeUrl) {	String uuid = null;	try{	uuid=UUID.nameUUIDFromBytes(storeUrl.getBytes("UTF-8")).toString();	}catch(UnsupportedEncodingException e){	
failed to create uuid from string bad storeurl or utf encoding error 

protected Answer execute(ValidateSnapshotCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource validatesnapshotcommand 

protected Answer execute(ManageSnapshotCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource managesnapshotcommand 

protected Answer execute(BackupSnapshotCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource backupsnapshotcommand 

protected Answer execute(BackupSnapshotCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	try {	VmwareContext context = getServiceContext();	VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	return mgr.getStorageManager().execute(this, cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(CreateVolumeFromSnapshotCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource createvolumefromsnapshotcommand 

}	String details = null;	boolean success = false;	String newVolumeName = UUID.randomUUID().toString();	try {	VmwareContext context = getServiceContext();	VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	return mgr.getStorageManager().execute(this, cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(CreatePrivateTemplateFromVolumeCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource createprivatetemplatefromvolumecommand 

protected Answer execute(CreatePrivateTemplateFromVolumeCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	try {	VmwareContext context = getServiceContext();	VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	return mgr.getStorageManager().execute(this, cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(CreatePrivateTemplateFromSnapshotCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource createprivatetemplatefromsnapshotcommand 

protected Answer execute(CreatePrivateTemplateFromSnapshotCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	try {	VmwareManager mgr = getServiceContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	return mgr.getStorageManager().execute(this, cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(GetStorageStatsCommand cmd) {	if (s_logger.isTraceEnabled()) {	
executing resource getstoragestatscommand 

VmwareHypervisorHost hyperHost = getHyperHost(context);	ManagedObjectReference morDs = HypervisorHostHelper.findDatastoreWithBackwardsCompatibility(hyperHost, cmd.getStorageId());	if (morDs != null) {	DatastoreMO datastoreMo = new DatastoreMO(context, morDs);	DatastoreSummary summary = datastoreMo.getSummary();	assert (summary != null);	long capacity = summary.getCapacity();	long free = summary.getFreeSpace();	long used = capacity - free;	if (s_logger.isDebugEnabled()) {	
datastore summary info storageid localpath pooltype capacity free used 

if (morDs != null) {	DatastoreMO datastoreMo = new DatastoreMO(context, morDs);	DatastoreSummary summary = datastoreMo.getSummary();	assert (summary != null);	long capacity = summary.getCapacity();	long free = summary.getFreeSpace();	long used = capacity - free;	if (s_logger.isDebugEnabled()) {	}	if (summary.getCapacity() <= 0) {	
something is wrong with vsphere nfs datastore rebooting esx esxi host should help 

if (summary.getCapacity() <= 0) {	}	return new GetStorageStatsAnswer(cmd, capacity, used);	} else {	String msg = "Could not find datastore for GetStorageStatsCommand storageId : " + cmd.getStorageId() + ", localPath: " + cmd.getLocalPath() + ", poolType: " + cmd.getPooltype();	s_logger.error(msg);	return new GetStorageStatsAnswer(cmd, msg);	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(GetVncPortCommand cmd) {	if (s_logger.isTraceEnabled()) {	
executing resource getvncportcommand 

if (s_logger.isTraceEnabled()) {	}	try {	VmwareContext context = getServiceContext();	VmwareHypervisorHost hyperHost = getHyperHost(context);	assert (hyperHost instanceof HostMO);	VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(cmd.getName());	if (vmMo == null) {	if (s_logger.isDebugEnabled()) {	
unable to find the owner vm for getvncportcommand on host try within datacenter 

if (vmMo == null) {	if (s_logger.isDebugEnabled()) {	}	vmMo = hyperHost.findVmOnPeerHyperHost(cmd.getName());	if (vmMo == null) {	throw new Exception("Unable to find VM in vSphere, vm: " + cmd.getName());	}	}	Pair<String, Integer> portInfo = vmMo.getVncPort(mgr.getManagementPortGroupByHost((HostMO)hyperHost));	if (s_logger.isTraceEnabled()) {	
found vnc port info vm host vnc port 

if (vmMo == null) {	throw new Exception("Unable to find VM in vSphere, vm: " + cmd.getName());	}	}	Pair<String, Integer> portInfo = vmMo.getVncPort(mgr.getManagementPortGroupByHost((HostMO)hyperHost));	if (s_logger.isTraceEnabled()) {	}	return new GetVncPortAnswer(cmd, portInfo.first(), portInfo.second());	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(SetupCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource setupcommand 

protected Answer execute(MaintainCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource maintaincommand 

protected Answer execute(PingTestCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource pingtestcommand 

if (s_logger.isInfoEnabled()) {	}	String controlIp = cmd.getRouterIp();	if (controlIp != null) {	String args = " -c 1 -n -q " + cmd.getPrivateIp();	try {	VmwareManager mgr = getServiceContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DefaultDomRSshPort, "root", mgr.getSystemVMKeyFile(), null, "/bin/ping" + args);	if (result.first()) return new Answer(cmd);	} catch (Exception e) {	
unable to execute ping command on domr domr may not be ready yet failure due to 

List<Pair<ManagedObjectReference, String>> hosts = clusterMo.getClusterHosts();	for (Pair<ManagedObjectReference, String> entry : hosts) {	HostMO hostInCluster = new HostMO(context, entry.first());	String hostIp = hostInCluster.getHostManagementIp(mgr.getManagementPortGroupName());	if (hostIp != null && hostIp.equals(cmd.getComputingHostIp())) {	if (hostInCluster.isHyperHostConnected()) return new Answer(cmd);	else return new Answer(cmd, false, "PingTestCommand failed");	}	}	} catch (Exception e) {	
unable to execute ping command on host failure due to 

protected Answer execute(CheckOnHostCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource checkonhostcommand 

protected Answer execute(ModifySshKeysCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource modifysshkeyscommand 

public PrimaryStorageDownloadAnswer execute(PrimaryStorageDownloadCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource primarystoragedownloadcommand 

public PrimaryStorageDownloadAnswer execute(PrimaryStorageDownloadCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	try {	VmwareContext context = getServiceContext();	VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	return (PrimaryStorageDownloadAnswer)mgr.getStorageManager().execute(this, cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(UnregisterVMCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource unregistervmcommand 

VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(cmd.getVmName());	if (vmMo != null) {	try {	VirtualMachineFileLayoutEx vmFileLayout = vmMo.getFileLayout();	context.getService().unregisterVM(vmMo.getMor());	if (cmd.getCleanupVmFiles()) {	deleteUnregisteredVmFiles(vmFileLayout, dataCenterMo, false);	}	return new Answer(cmd, true, "unregister succeeded");	} catch (Exception e) {	
we are not able to unregister vm 

String msg = "Expunge failed in vSphere. vm: " + cmd.getVmName();	s_logger.warn(msg);	return new Answer(cmd, false, msg);	} else {	String msg = "Unable to find the VM in vSphere to unregister, assume it is already removed. VM: " + cmd.getVmName();	s_logger.warn(msg);	return new Answer(cmd, true, msg);	}	} catch (Exception e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

protected Answer execute(UnregisterNicCommand cmd) {	
executing resource unregisterniccommand 

protected Answer execute(UnregisterNicCommand cmd) {	if (_guestTrafficInfo == null) {	return new Answer(cmd, false, "No Guest Traffic Info found, unable to determine where to clean up");	}	try {	if (_guestTrafficInfo.getVirtualSwitchType() != VirtualSwitchType.StandardVirtualSwitch) {	return new Answer(cmd, true, "Nothing to do");	}	
cleaning up portgroup on switch 

VmwareContext context = getServiceContext();	VmwareHypervisorHost host = getHyperHost(context);	ManagedObjectReference clusterMO = host.getHyperHostCluster();	List<ManagedObjectReference> hosts = (List<ManagedObjectReference>)context.getVimClient().getDynamicProperty(clusterMO, "host");	if (hosts == null) {	return new Answer(cmd, false, "No hosts in cluster, which is pretty weird");	}	for (ManagedObjectReference hostMOR : hosts) {	HostMO hostMo = new HostMO(context, hostMOR);	hostMo.deletePortGroup(cmd.getNicUuid().toString());	
removed portgroup from host 

if (hosts == null) {	return new Answer(cmd, false, "No hosts in cluster, which is pretty weird");	}	for (ManagedObjectReference hostMOR : hosts) {	HostMO hostMo = new HostMO(context, hostMOR);	hostMo.deletePortGroup(cmd.getNicUuid().toString());	}	return new Answer(cmd, true, "Unregistered resources for NIC " + cmd.getNicUuid());	} catch (Exception e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

public CopyVolumeAnswer execute(CopyVolumeCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource copyvolumecommand 

public CopyVolumeAnswer execute(CopyVolumeCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	try {	VmwareContext context = getServiceContext();	VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	return (CopyVolumeAnswer)mgr.getStorageManager().execute(this, cmd);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

public PingCommand getCurrentStatus(long id) {	try {	gcAndKillHungWorkerVMs();	VmwareContext context = getServiceContext();	VmwareHypervisorHost hyperHost = getHyperHost(context);	try {	if (!hyperHost.isHyperHostConnected()) {	return null;	}	} catch (Exception e) {	
unexpected exception 

private void gcAndKillHungWorkerVMs() {	try {	VmwareContext context = getServiceContext();	VmwareHypervisorHost hyperHost = getHyperHost(context);	VmwareManager mgr = hyperHost.getContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	if (hyperHost.isHyperHostConnected()) {	mgr.gcLeftOverVMs(context);	
scan hung worker vm to recycle 

} else if (prop.getName().equals(workerTagPropName)) {	CustomFieldStringValue val = (CustomFieldStringValue)prop.getVal();	workerTag = val.getValue();	}	}	VirtualMachineMO vmMo = new VirtualMachineMO(hyperHost.getContext(), oc.getObj());	if (!template && isWorker) {	boolean recycle = false;	recycle = mgr.needRecycle(workerTag);	if (recycle) {	
recycle pending worker vm 

if (recycle) {	vmMo.powerOff();	vmMo.detachAllDisks();	vmMo.destroy();	}	}	}	}	}	} else {	
host is no longer connected 

vmMo.destroy();	}	}	}	}	}	} else {	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

public StartupCommand[] initialize() {	try {	String hostApiVersion = "4.1";	VmwareContext context = getServiceContext();	try {	VmwareHypervisorHost hyperHost = getHyperHost(context);	assert (hyperHost instanceof HostMO);	if (!((HostMO)hyperHost).isHyperHostConnected()) {	
host is not in connected state 

String address = hostMo.getHostName();	StoragePoolInfo pInfo = new StoragePoolInfo(poolUuid, address, dsMo.getMor().getValue(), "", StoragePoolType.VMFS, dsSummary.getCapacity(), dsSummary.getFreeSpace());	StartupStorageCommand cmd = new StartupStorageCommand();	cmd.setName(poolUuid);	cmd.setPoolInfo(pInfo);	cmd.setGuid(poolUuid);	cmd.setResourceType(Storage.StorageResourceType.STORAGE_POOL);	cmd.setDataCenter(_dcId);	cmd.setPod(_pod);	cmd.setCluster(_cluster);	
add local storage startup command 

cmd.setName(poolUuid);	cmd.setPoolInfo(pInfo);	cmd.setGuid(poolUuid);	cmd.setResourceType(Storage.StorageResourceType.STORAGE_POOL);	cmd.setDataCenter(_dcId);	cmd.setPod(_pod);	cmd.setCluster(_cluster);	storageCmds.add(cmd);	}	} else {	
cluster host does not support local storage skip it 

VmwareContext serviceContext = getServiceContext();	Map<String, String> details = cmd.getHostDetails();	if (details == null) {	details = new HashMap<String, String>();	}	try {	fillHostHardwareInfo(serviceContext, cmd);	fillHostNetworkInfo(serviceContext, cmd);	fillHostDetailsInfo(serviceContext, details);	} catch (RuntimeFaultFaultMsg e) {	
runtimefault while retrieving host info 

if (details == null) {	details = new HashMap<String, String>();	}	try {	fillHostHardwareInfo(serviceContext, cmd);	fillHostNetworkInfo(serviceContext, cmd);	fillHostDetailsInfo(serviceContext, details);	} catch (RuntimeFaultFaultMsg e) {	throw new CloudRuntimeException("RuntimeFault while retrieving host info");	} catch (RemoteException e) {	
remoteexception while retrieving host info 

try {	fillHostHardwareInfo(serviceContext, cmd);	fillHostNetworkInfo(serviceContext, cmd);	fillHostDetailsInfo(serviceContext, details);	} catch (RuntimeFaultFaultMsg e) {	throw new CloudRuntimeException("RuntimeFault while retrieving host info");	} catch (RemoteException e) {	invalidateServiceContext();	throw new CloudRuntimeException("RemoteException while retrieving host info");	} catch (Exception e) {	
exception while retrieving host info 

HostMO host = (HostMO)hyperHost;	HostStorageSystemMO hostStorageSystem = host.getHostStorageSystemMO();	for (HostHostBusAdapter hba : hostStorageSystem.getStorageDeviceInfo().getHostBusAdapter()) {	if (hba instanceof HostInternetScsiHba) {	return ((HostInternetScsiHba)hba).getIScsiName();	}	}	}	}	catch (Exception ex) {	
could not locate an iqn for this host 

private void fillHostHardwareInfo(VmwareContext serviceContext, StartupRoutingCommand cmd) throws RuntimeFaultFaultMsg, RemoteException, Exception {	VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext());	VmwareHypervisorHostResourceSummary summary = hyperHost.getHyperHostResourceSummary();	if (s_logger.isInfoEnabled()) {	
startup report on host hardware info 

private void fillHostNetworkInfo(VmwareContext serviceContext, StartupRoutingCommand cmd) throws RuntimeFaultFaultMsg, RemoteException {	try {	VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext());	assert (hyperHost instanceof HostMO);	VmwareManager mgr = hyperHost.getContext().getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	VmwareHypervisorHostNetworkSummary summary = hyperHost.getHyperHostNetworkSummary(mgr.getManagementPortGroupByHost((HostMO)hyperHost));	if (summary == null) {	throw new Exception("No ESX(i) host found");	}	if (s_logger.isInfoEnabled()) {	
startup report on host network info 

int val = random.nextInt(maxVncPorts);	int startVal = val;	do {	if (!existingPorts.contains(5900 + val)) {	vncPort = 5900 + val;	break;	}	val = (++val) % maxVncPorts;	} while (val != startVal);	if (vncPort == 0) {	
we ve run out of range for ports between for the cluster we will try port range at 

vncPort = additionalRange.first() + val;	break;	}	val = (++val) % maxVncPorts;	} while (val != startVal);	}	if (vncPort == 0) {	throw new Exception("Unable to find an available VNC port on host");	}	if (s_logger.isInfoEnabled()) {	
configure vnc port for vm port host 

throw new Exception("Unable to find an available VNC port on host");	}	if (s_logger.isInfoEnabled()) {	}	return VmwareHelper.composeVncOptions(optionsToMerge, true, vncPassword, vncPort, keyboardLayout);	} finally {	try {	mgr.endExclusiveOperation();	} catch (Throwable e) {	assert (false);	
unexpected exception 

private VirtualMachineGuestOsIdentifier translateGuestOsIdentifier(String cpuArchitecture, String guestOs, String cloudGuestOs) {	if (cpuArchitecture == null) {	
cpu arch is not set default to guest os 

private VirtualMachineGuestOsIdentifier translateGuestOsIdentifier(String cpuArchitecture, String guestOs, String cloudGuestOs) {	if (cpuArchitecture == null) {	cpuArchitecture = "i386";	}	if(cloudGuestOs == null) {	
guest os mapping name is not set for guest os 

private VirtualMachineGuestOsIdentifier translateGuestOsIdentifier(String cpuArchitecture, String guestOs, String cloudGuestOs) {	if (cpuArchitecture == null) {	cpuArchitecture = "i386";	}	if(cloudGuestOs == null) {	}	VirtualMachineGuestOsIdentifier identifier = null;	try {	if (cloudGuestOs != null) {	identifier = VirtualMachineGuestOsIdentifier.fromValue(cloudGuestOs);	
using mapping name 

cpuArchitecture = "i386";	}	if(cloudGuestOs == null) {	}	VirtualMachineGuestOsIdentifier identifier = null;	try {	if (cloudGuestOs != null) {	identifier = VirtualMachineGuestOsIdentifier.fromValue(cloudGuestOs);	}	} catch (IllegalArgumentException e) {	
unable to find guest os identifier in vmware for mapping name continuing with defaults 

private HashMap<String, HostVmStateReportEntry> getHostVmStateReport() throws Exception {	VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext());	int key = ((HostMO)hyperHost).getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

private HashMap<String, PowerState> getVmStates() throws Exception {	VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext());	int key = ((HostMO)hyperHost).getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

if ("transmitted".equalsIgnoreCase(info.getNameInfo().getKey())) {	txPerfCounterInfo = info;	}	if ("received".equalsIgnoreCase(info.getNameInfo().getKey())) {	rxPerfCounterInfo = info;	}	}	}	int key = ((HostMO)hyperHost).getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

long[] stats = new long[2];	if (result != null) {	try {	String[] splitResult = result.split(":");	int i = 0;	while (i < splitResult.length - 1) {	stats[0] += Long.parseLong(splitResult[i++]);	stats[1] += Long.parseLong(splitResult[i++]);	}	} catch (Throwable e) {	
unable to parse return from script return of network usage command 

protected String connect(final String vmName, final String ipAddress, final int port) {	long startTick = System.currentTimeMillis();	int retry = _retry;	while (System.currentTimeMillis() - startTick <= _opsTimeout || --retry > 0) {	
trying to connect to 

long startTick = System.currentTimeMillis();	int retry = _retry;	while (System.currentTimeMillis() - startTick <= _opsTimeout || --retry > 0) {	try (SocketChannel sch = SocketChannel.open();) {	sch.configureBlocking(true);	sch.socket().setSoTimeout(5000);	InetSocketAddress addr = new InetSocketAddress(ipAddress, port);	sch.connect(addr);	return null;	} catch (IOException e) {	
could not connect to due to 

sch.configureBlocking(true);	sch.socket().setSoTimeout(5000);	InetSocketAddress addr = new InetSocketAddress(ipAddress, port);	sch.connect(addr);	return null;	} catch (IOException e) {	if (e instanceof ConnectException) {	try {	Thread.sleep(5000);	} catch (InterruptedException ex) {	
ignored interupted while waiting to retry connect after failure 

if (e instanceof ConnectException) {	try {	Thread.sleep(5000);	} catch (InterruptedException ex) {	}	}	}	try {	Thread.sleep(1000);	} catch (InterruptedException ex) {	
ignored interupted while waiting to retry connect 

Thread.sleep(5000);	} catch (InterruptedException ex) {	}	}	}	try {	Thread.sleep(1000);	} catch (InterruptedException ex) {	}	}	
unable to logon to 

private static String getRouterSshControlIp(NetworkElementCommand cmd) {	String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);	String routerGuestIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP);	String zoneNetworkType = cmd.getAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE);	if (routerGuestIp != null && zoneNetworkType != null && NetworkType.valueOf(zoneNetworkType) == NetworkType.Basic) {	
in basic zone mode use router s guest ip for ssh control guest ip 

private static String getRouterSshControlIp(NetworkElementCommand cmd) {	String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);	String routerGuestIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP);	String zoneNetworkType = cmd.getAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE);	if (routerGuestIp != null && zoneNetworkType != null && NetworkType.valueOf(zoneNetworkType) == NetworkType.Basic) {	return routerGuestIp;	}	
use router s private ip for ssh control ip 

_privateNetworkVSwitchName = (String)params.get("private.network.vswitch.name");	}	String value = (String)params.get("vmware.recycle.hung.wokervm");	if (value != null && value.equalsIgnoreCase("true")) _recycleHungWorker = true;	value = (String)params.get("vmware.root.disk.controller");	if (value != null && value.equalsIgnoreCase("scsi")) _rootDiskController = DiskControllerType.scsi;	else if (value != null && value.equalsIgnoreCase("ide")) _rootDiskController = DiskControllerType.ide;	else _rootDiskController = DiskControllerType.osdefault;	Integer intObj = (Integer)params.get("ports.per.dvportgroup");	if (intObj != null) _portsPerDvPortGroup = intObj.intValue();	
vmwareresource network configuration info private traffic over vswitch public traffic over guest traffic over 

value = (String)params.get("scripts.timeout");	int timeout = NumbersUtil.parseInt(value, 1440) * 1000;	storageNfsVersion = NfsSecondaryStorageResource.retrieveNfsVersionFromParams(params);	_storageProcessor = new VmwareStorageProcessor((VmwareHostService)this, _fullCloneFlag, (VmwareStorageMount)mgr, timeout, this, _shutdownWaitMs, null, storageNfsVersion);	storageHandler = new VmwareStorageSubsystemCommandHandler(_storageProcessor, storageNfsVersion);	_vrResource = new VirtualRoutingResource(this);	if (!_vrResource.configure(name, params)) {	throw new ConfigurationException("Unable to configure VirtualRoutingResource");	}	if (s_logger.isTraceEnabled()) {	
successfully configured vmwareresource 

_storageProcessor = new VmwareStorageProcessor((VmwareHostService)this, _fullCloneFlag, (VmwareStorageMount)mgr, timeout, this, _shutdownWaitMs, null, storageNfsVersion);	storageHandler = new VmwareStorageSubsystemCommandHandler(_storageProcessor, storageNfsVersion);	_vrResource = new VirtualRoutingResource(this);	if (!_vrResource.configure(name, params)) {	throw new ConfigurationException("Unable to configure VirtualRoutingResource");	}	if (s_logger.isTraceEnabled()) {	}	return true;	} catch (Exception e) {	
unexpected exception 

public VmwareContext getServiceContext(Command cmd) {	VmwareContext context = null;	if(s_serviceContext.get() != null) {	context = s_serviceContext.get();	String poolKey = VmwareContextPool.composePoolKey(_vCenterAddress, _username);	if(context.getPoolKey().equals(poolKey)) {	if (context.validate()) {	if (s_logger.isTraceEnabled()) {	
threadlocal context is still valid just reuse 

VmwareContext context = null;	if(s_serviceContext.get() != null) {	context = s_serviceContext.get();	String poolKey = VmwareContextPool.composePoolKey(_vCenterAddress, _username);	if(context.getPoolKey().equals(poolKey)) {	if (context.validate()) {	if (s_logger.isTraceEnabled()) {	}	return context;	} else {	
validation of the context failed dispose and use a new one 

String poolKey = VmwareContextPool.composePoolKey(_vCenterAddress, _username);	if(context.getPoolKey().equals(poolKey)) {	if (context.validate()) {	if (s_logger.isTraceEnabled()) {	}	return context;	} else {	invalidateServiceContext(context);	}	} else {	
threadlocal vmware context doesn t correspond to the right vcenter expected vmware context 

} else {	invalidateServiceContext(context);	}	} else {	}	}	try {	context = VmwareContextFactory.getContext(_vCenterAddress, _username, _password);	s_serviceContext.set(context);	} catch (Exception e) {	
unable to connect to vsphere server 

private static void recycleServiceContext() {	VmwareContext context = s_serviceContext.get();	if (s_logger.isTraceEnabled()) {	
reset threadlocal context to null 

private static void recycleServiceContext() {	VmwareContext context = s_serviceContext.get();	if (s_logger.isTraceEnabled()) {	}	s_serviceContext.set(null);	if (context != null) {	assert (context.getPool() != null);	if (s_logger.isTraceEnabled()) {	
recycling threadlocal context to pool 

public Answer execute(DestroyCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource destroycommand to evict template from storage pool 

public Answer execute(DestroyCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	try {	VmwareContext context = getServiceContext(null);	VmwareHypervisorHost hyperHost = getHyperHost(context, null);	VolumeTO vol = cmd.getVolume();	VirtualMachineMO vmMo = findVmOnDatacenter(context, hyperHost, vol);	if (vmMo != null && vmMo.isTemplate()) {	if (s_logger.isInfoEnabled()) {	
destroy template volume 

VmwareContext context = getServiceContext(null);	VmwareHypervisorHost hyperHost = getHyperHost(context, null);	VolumeTO vol = cmd.getVolume();	VirtualMachineMO vmMo = findVmOnDatacenter(context, hyperHost, vol);	if (vmMo != null && vmMo.isTemplate()) {	if (s_logger.isInfoEnabled()) {	}	vmMo.destroy();	} else {	if (s_logger.isInfoEnabled()) {	
template volume is not found no need to delete 

if (s_logger.isInfoEnabled()) {	}	vmMo.destroy();	} else {	if (s_logger.isInfoEnabled()) {	}	}	return new Answer(cmd, true, "Success");	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

========================= cloudstack sample_1315 =========================

String[] paramTokens = param.split("=");	if (paramTokens != null && paramTokens.length == 2) {	String name = param.split("=")[0];	String value = param.split("=")[1];	map.put(name, value);	} else if (paramTokens.length == 3) {	String name = paramTokens[0];	String value = paramTokens[1] + "=" + paramTokens[2];	map.put(name, value);	} else {	
invalid paramemter in url found param 

map.put(name, value);	} else {	}	}	if (map.get("token") != null) {	ConsoleProxyPasswordBasedEncryptor encryptor = new ConsoleProxyPasswordBasedEncryptor(ConsoleProxy.getEncryptorPassword());	ConsoleProxyClientParam param = encryptor.decryptObject(ConsoleProxyClientParam.class, map.get("token"));	guardUserInput(map);	if (param != null) {	if (param.getClientHostAddress() != null) {	
decode token host 

}	}	if (map.get("token") != null) {	ConsoleProxyPasswordBasedEncryptor encryptor = new ConsoleProxyPasswordBasedEncryptor(ConsoleProxy.getEncryptorPassword());	ConsoleProxyClientParam param = encryptor.decryptObject(ConsoleProxyClientParam.class, map.get("token"));	guardUserInput(map);	if (param != null) {	if (param.getClientHostAddress() != null) {	map.put("host", param.getClientHostAddress());	} else {	
decode token host info is not found 

if (map.get("token") != null) {	ConsoleProxyPasswordBasedEncryptor encryptor = new ConsoleProxyPasswordBasedEncryptor(ConsoleProxy.getEncryptorPassword());	ConsoleProxyClientParam param = encryptor.decryptObject(ConsoleProxyClientParam.class, map.get("token"));	guardUserInput(map);	if (param != null) {	if (param.getClientHostAddress() != null) {	map.put("host", param.getClientHostAddress());	} else {	}	if (param.getClientHostPort() != 0) {	
decode token port 

ConsoleProxyClientParam param = encryptor.decryptObject(ConsoleProxyClientParam.class, map.get("token"));	guardUserInput(map);	if (param != null) {	if (param.getClientHostAddress() != null) {	map.put("host", param.getClientHostAddress());	} else {	}	if (param.getClientHostPort() != 0) {	map.put("port", String.valueOf(param.getClientHostPort()));	} else {	
decode token port info is not found 

if (param != null) {	if (param.getClientHostAddress() != null) {	map.put("host", param.getClientHostAddress());	} else {	}	if (param.getClientHostPort() != 0) {	map.put("port", String.valueOf(param.getClientHostPort()));	} else {	}	if (param.getClientTag() != null) {	
decode token tag 

map.put("host", param.getClientHostAddress());	} else {	}	if (param.getClientHostPort() != 0) {	map.put("port", String.valueOf(param.getClientHostPort()));	} else {	}	if (param.getClientTag() != null) {	map.put("tag", param.getClientTag());	} else {	
decode token tag info is not found 

map.put("port", String.valueOf(param.getClientHostPort()));	} else {	}	if (param.getClientTag() != null) {	map.put("tag", param.getClientTag());	} else {	}	if (param.getClientHostPassword() != null) {	map.put("sid", param.getClientHostPassword());	} else {	
decode token sid info is not found 

} else {	}	if (param.getClientTunnelUrl() != null) map.put("consoleurl", param.getClientTunnelUrl());	if (param.getClientTunnelSession() != null) map.put("sessionref", param.getClientTunnelSession());	if (param.getTicket() != null) map.put("ticket", param.getTicket());	if (param.getLocale() != null) map.put("locale", param.getLocale());	if (param.getHypervHost() != null) map.put("hypervHost", param.getHypervHost());	if (param.getUsername() != null) map.put("username", param.getUsername());	if (param.getPassword() != null) map.put("password", param.getPassword());	} else {	
unable to decode token 

========================= cloudstack sample_4951 =========================

if ((networks != null) && !networks.isEmpty()) {	throw new CloudRuntimeException("Delete can not be done as there are networks using the firewall device ");	}	try {	externalFirewall.setResourceState(ResourceState.Maintenance);	_hostDao.update(hostId, externalFirewall);	_resourceMgr.deleteHost(hostId, false, false);	_externalFirewallDeviceDao.remove(fwDeviceId);	return true;	} catch (Exception e) {	
failed to delete external firewall device due to 

protected boolean freeFirewallForNetwork(Network network) {	GlobalLock deviceMapLock = GlobalLock.getInternLock("NetworkFirewallDeviceMap");	try {	if (deviceMapLock.lock(120)) {	try {	NetworkExternalFirewallVO fwDeviceForNetwork = _networkExternalFirewallDao.findByNetworkId(network.getId());	if (fwDeviceForNetwork != null) {	_networkExternalFirewallDao.remove(fwDeviceForNetwork.getId());	}	} catch (Exception exception) {	
failed to release firewall device for the network due to 

public boolean manageGuestNetworkWithExternalFirewall(boolean add, Network network) throws ResourceUnavailableException, InsufficientCapacityException {	if (network.getTrafficType() != TrafficType.Guest) {	
external firewall can only be used for add remove guest networks 

} finally {	deviceMapLock.unlock();	}	}	} finally {	deviceMapLock.releaseRef();	}	} else {	ExternalFirewallDeviceVO fwDeviceVO = getExternalFirewallForNetwork(network);	if (fwDeviceVO == null) {	
network shutdown requested on external firewall element which did not implement the network either network implement failed half way through or already network shutdown is completed 

cmd.setAccessDetail(NetworkElementCommand.GUEST_NETWORK_CIDR, guestVlanCidr);	cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));	Answer answer = _agentMgr.easySend(externalFirewall.getId(), cmd);	List<String> reservedIpAddressesForGuestNetwork = _nicDao.listIpAddressInNetwork(network.getId());	if (answer == null || !answer.getResult()) {	String action = add ? "implement" : "shutdown";	String answerDetails = (answer != null) ? answer.getDetails() : "answer was null";	String msg = "External firewall was unable to " + action + " the guest network on the external firewall in zone " + zone.getName() + " due to " + answerDetails;	s_logger.error(msg);	if (!add && (!reservedIpAddressesForGuestNetwork.contains(network.getGateway()))) {	
skip the shutdown of guest network on srx because it seems we didn t implement it as well 

InlineLoadBalancerNicMapVO mapping = _inlineLoadBalancerNicMapDao.findByNicId(nic.getId());	if (mapping != null) {	_nicDao.expunge(mapping.getNicId());	_inlineLoadBalancerNicMapDao.expunge(mapping.getId());	}	}	if (!add) {	List<NicVO> nics = _nicDao.listByNetworkId(network.getId());	for (NicVO nic : nics) {	if (nic.getVmType() == null && nic.getReservationStrategy().equals(ReservationStrategy.PlaceHolder) && nic.getIPv4Address().equals(network.getGateway())) {	
removing placeholder nic for the network 

public boolean applyFirewallRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {	long zoneId = network.getDataCenterId();	DataCenterVO zone = _dcDao.findById(zoneId);	ExternalFirewallDeviceVO fwDeviceVO = getExternalFirewallForNetwork(network);	if (fwDeviceVO == null) {	return true;	}	HostVO externalFirewall = _hostDao.findById(fwDeviceVO.getHostId());	assert (externalFirewall != null);	if (network.getState() == Network.State.Allocated) {	
external firewall was asked to apply firewall rules for network with id this network is not implemented skipping backend commands 

public boolean applyStaticNatRules(Network network, List<? extends StaticNat> rules) throws ResourceUnavailableException {	long zoneId = network.getDataCenterId();	DataCenterVO zone = _dcDao.findById(zoneId);	ExternalFirewallDeviceVO fwDeviceVO = getExternalFirewallForNetwork(network);	HostVO externalFirewall = _hostDao.findById(fwDeviceVO.getHostId());	assert (externalFirewall != null);	if (network.getState() == Network.State.Allocated) {	
external firewall was asked to apply firewall rules for network with id this network is not implemented skipping backend commands 

public boolean applyPortForwardingRules(Network network, List<? extends PortForwardingRule> rules) throws ResourceUnavailableException {	long zoneId = network.getDataCenterId();	DataCenterVO zone = _dcDao.findById(zoneId);	ExternalFirewallDeviceVO fwDeviceVO = getExternalFirewallForNetwork(network);	HostVO externalFirewall = _hostDao.findById(fwDeviceVO.getHostId());	assert (externalFirewall != null);	if (network.getState() == Network.State.Allocated) {	
external firewall was asked to apply firewall rules for network with id this network is not implemented skipping backend commands 

========================= cloudstack sample_2313 =========================

public boolean executeTest() {	int error = 0;	Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	
exiting the test command required for the future run failed with an error code command was sent with the url 

NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	return false;	} else if ((api.getResponseCode() != 200) && (api.getResponseType() != ResponseType.ERROR)) {	error++;	
command failed with an error code command was sent with url 

Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	return false;	} else if ((api.getResponseCode() != 200) && (api.getResponseType() != ResponseType.ERROR)) {	error++;	} else if ((api.getResponseCode() == 200) && (api.getResponseType() == ResponseType.ERROR)) {	error++;	
command which was supposed to failed passed the command was sent with url 

ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	return false;	} else if ((api.getResponseCode() != 200) && (api.getResponseType() != ResponseType.ERROR)) {	error++;	} else if ((api.getResponseCode() == 200) && (api.getResponseType() == ResponseType.ERROR)) {	error++;	} else {	if (api.setParam(this.getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use command was sent with url 

if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	return false;	} else if ((api.getResponseCode() != 200) && (api.getResponseType() != ResponseType.ERROR)) {	error++;	} else if ((api.getResponseCode() == 200) && (api.getResponseType() == ResponseType.ERROR)) {	error++;	} else {	if (api.setParam(this.getParam()) == false) {	return false;	}	
command passed 

========================= cloudstack sample_458 =========================

UserVm result;	result = _userVmService.startVirtualMachine(this);	if (result != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Restricted, "virtualmachine", result).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to start a vm");	}	} catch (ConcurrentOperationException ex) {	
exception 

if (result != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Restricted, "virtualmachine", result).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to start a vm");	}	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (StorageUnavailableException ex) {	
exception 

response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to start a vm");	}	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (StorageUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ExecutionException ex) {	
exception 

========================= cloudstack sample_3502 =========================

final VirtualMachineTO vmSpec = command.getVirtualMachine();	final String vmName = vmSpec.getName();	try {	final Connection conn = citrixResourceBase.getConnection();	final Set<VM> vms = VM.getByNameLabel(conn, vmName);	final Host host = Host.getByUuid(conn, citrixResourceBase.getHost().getUuid());	if (!citrixResourceBase.isDmcEnabled(conn, host)) {	throw new CloudRuntimeException("Unable to scale the vm: " + vmName + " as DMC - Dynamic memory control is not enabled for the XenServer:" + citrixResourceBase.getHost().getUuid() + " ,check your license and hypervisor version.");	}	if (vms == null || vms.size() == 0) {	
no running vm exists on xenserver 

========================= cloudstack sample_1180 =========================

private void updateUserStats(Connection conn) {	try ( PreparedStatement pstmt = conn.prepareStatement( "update cloud_usage.user_statistics uus set device_id = (select device_id from cloud.user_statistics us where uus.id = us.id)" );	) {	pstmt.executeUpdate();	
upgraded cloud usage user statistics with deviceid 

private void updateUserStats(Connection conn) {	try ( PreparedStatement pstmt = conn.prepareStatement( "update cloud_usage.user_statistics uus set device_id = (select device_id from cloud.user_statistics us where uus.id = us.id)" );	) {	pstmt.executeUpdate();	} catch (Exception e) {	throw new CloudRuntimeException("Failed to upgrade user stats: ", e);	}	try ( PreparedStatement pstmt1 = conn.prepareStatement( "update cloud_usage.usage_network un set host_id = " + "(select device_id from cloud_usage.user_statistics us where us.account_id = un.account_id and us.data_center_id = un.zone_id)");	) {	pstmt1.executeUpdate();	
upgraded cloud usage usage network with hostid 

private void updateUsageIpAddress(Connection conn) {	try ( PreparedStatement pstmt = conn.prepareStatement("update cloud_usage.usage_ip_address uip set id = " + "(select id from cloud.user_ip_address ip where uip.public_ip_address = ip.public_ip_address and ip.data_center_id = uip.zone_id)");	) {	pstmt.executeUpdate();	
upgraded cloud usage usage ip address with id 

========================= cloudstack sample_4228 =========================

ApiConnector api = controller.getApiAccessor();	for (ModelObject successor : successors()) {	successor.delete(controller);	}	try {	if (_fipPool != null) {	api.delete(_fipPool);	}	_fipPool = null;	} catch (IOException ex) {	
floating ip pool delete 

if (fipPool == null) {	fipPool = new FloatingIpPool();	fipPool.setName(_name);	fipPool.setParent(_vnModel.getVirtualNetwork());	}	}	if (_fipPool == null) {	try {	api.create(fipPool);	} catch (Exception ex) {	
floating ip pool create 

try {	api.create(fipPool);	} catch (Exception ex) {	throw new CloudRuntimeException("Failed to create floating ip pool", ex);	}	_fipPool = fipPool;	} else {	try {	api.update(fipPool);	} catch (IOException ex) {	
floating ip pool update 

========================= cloudstack sample_1883 =========================

public AgentControlAnswer onConsoleAccessAuthentication(ConsoleAccessAuthenticationCommand cmd) {	Long vmId = null;	String ticketInUrl = cmd.getTicket();	if (ticketInUrl == null) {	
access ticket could not be found you could be running an old version of console proxy vmid 

public AgentControlAnswer onConsoleAccessAuthentication(ConsoleAccessAuthenticationCommand cmd) {	Long vmId = null;	String ticketInUrl = cmd.getTicket();	if (ticketInUrl == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	if (s_logger.isDebugEnabled()) {	
console authentication ticket in url for is 

Long vmId = null;	String ticketInUrl = cmd.getTicket();	if (ticketInUrl == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	if (s_logger.isDebugEnabled()) {	}	if (!cmd.isReauthenticating()) {	String ticket = ConsoleProxyServlet.genAccessTicket(cmd.getHost(), cmd.getPort(), cmd.getSid(), cmd.getVmId());	if (s_logger.isDebugEnabled()) {	
console authentication ticket in minute boundary for is 

if (s_logger.isDebugEnabled()) {	}	if (!cmd.isReauthenticating()) {	String ticket = ConsoleProxyServlet.genAccessTicket(cmd.getHost(), cmd.getPort(), cmd.getSid(), cmd.getVmId());	if (s_logger.isDebugEnabled()) {	}	if (!ticket.equals(ticketInUrl)) {	Date now = new Date();	String minuteEarlyTicket = ConsoleProxyServlet.genAccessTicket(cmd.getHost(), cmd.getPort(), cmd.getSid(), cmd.getVmId(), new Date(now.getTime() - 60 * 1000));	if (s_logger.isDebugEnabled()) {	
console authentication ticket in minute boundary for is 

if (!cmd.isReauthenticating()) {	String ticket = ConsoleProxyServlet.genAccessTicket(cmd.getHost(), cmd.getPort(), cmd.getSid(), cmd.getVmId());	if (s_logger.isDebugEnabled()) {	}	if (!ticket.equals(ticketInUrl)) {	Date now = new Date();	String minuteEarlyTicket = ConsoleProxyServlet.genAccessTicket(cmd.getHost(), cmd.getPort(), cmd.getSid(), cmd.getVmId(), new Date(now.getTime() - 60 * 1000));	if (s_logger.isDebugEnabled()) {	}	if (!minuteEarlyTicket.equals(ticketInUrl)) {	
access ticket expired or has been modified vmid ticket in url tickets to check against 

String minuteEarlyTicket = ConsoleProxyServlet.genAccessTicket(cmd.getHost(), cmd.getPort(), cmd.getSid(), cmd.getVmId(), new Date(now.getTime() - 60 * 1000));	if (s_logger.isDebugEnabled()) {	}	if (!minuteEarlyTicket.equals(ticketInUrl)) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	}	}	if (cmd.getVmId() != null && cmd.getVmId().isEmpty()) {	if (s_logger.isDebugEnabled()) {	
invalid vm id sent from proxy happens when proxy session has terminated 

if (cmd.getVmId() != null && cmd.getVmId().isEmpty()) {	if (s_logger.isDebugEnabled()) {	}	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	VirtualMachine vm = _instanceDao.findByUuid(cmd.getVmId());	if (vm == null) {	vm = _instanceDao.findById(Long.parseLong(cmd.getVmId()));	}	if (vm == null) {	
invalid vm id sent from console access authentication 

return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	VirtualMachine vm = _instanceDao.findByUuid(cmd.getVmId());	if (vm == null) {	vm = _instanceDao.findById(Long.parseLong(cmd.getVmId()));	}	if (vm == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	if (vm.getHostId() == null) {	
vm lost host info failed authentication request 

vm = _instanceDao.findById(Long.parseLong(cmd.getVmId()));	}	if (vm == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	if (vm.getHostId() == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	HostVO host = _hostDao.findById(vm.getHostId());	if (host == null) {	
vm s host does not exist fail authentication request 

}	if (vm.getHostId() == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	HostVO host = _hostDao.findById(vm.getHostId());	if (host == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	String sid = cmd.getSid();	if (sid == null || !sid.equals(vm.getVncPassword())) {	
sid in url does not match stored sid 

if (host == null) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	String sid = cmd.getSid();	if (sid == null || !sid.equals(vm.getVncPassword())) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	if (cmd.isReauthenticating()) {	ConsoleAccessAuthenticationAnswer authenticationAnswer = new ConsoleAccessAuthenticationAnswer(cmd, true);	authenticationAnswer.setReauthenticating(true);	
re authentication request ask host for new console info 

if (sid == null || !sid.equals(vm.getVncPassword())) {	return new ConsoleAccessAuthenticationAnswer(cmd, false);	}	if (cmd.isReauthenticating()) {	ConsoleAccessAuthenticationAnswer authenticationAnswer = new ConsoleAccessAuthenticationAnswer(cmd, true);	authenticationAnswer.setReauthenticating(true);	GetVncPortAnswer answer = (GetVncPortAnswer)_agentMgr.easySend(vm.getHostId(), new GetVncPortCommand(vm.getId(), vm.getInstanceName()));	if (answer != null && answer.getResult()) {	Ternary<String, String, String> parsedHostInfo = ConsoleProxyServlet.parseHostInfo(answer.getAddress());	if (parsedHostInfo.second() != null && parsedHostInfo.third() != null) {	
re authentication result vm tunnel url tunnel session 

if (cmd.isReauthenticating()) {	ConsoleAccessAuthenticationAnswer authenticationAnswer = new ConsoleAccessAuthenticationAnswer(cmd, true);	authenticationAnswer.setReauthenticating(true);	GetVncPortAnswer answer = (GetVncPortAnswer)_agentMgr.easySend(vm.getHostId(), new GetVncPortCommand(vm.getId(), vm.getInstanceName()));	if (answer != null && answer.getResult()) {	Ternary<String, String, String> parsedHostInfo = ConsoleProxyServlet.parseHostInfo(answer.getAddress());	if (parsedHostInfo.second() != null && parsedHostInfo.third() != null) {	authenticationAnswer.setTunnelUrl(parsedHostInfo.second());	authenticationAnswer.setTunnelSession(parsedHostInfo.third());	} else {	
re authentication result vm host address port 

if (answer != null && answer.getResult()) {	Ternary<String, String, String> parsedHostInfo = ConsoleProxyServlet.parseHostInfo(answer.getAddress());	if (parsedHostInfo.second() != null && parsedHostInfo.third() != null) {	authenticationAnswer.setTunnelUrl(parsedHostInfo.second());	authenticationAnswer.setTunnelSession(parsedHostInfo.third());	} else {	authenticationAnswer.setHost(parsedHostInfo.first());	authenticationAnswer.setPort(answer.getPort());	}	} else {	
re authentication request failed 

public void startAgentHttpHandlerInVM(StartupProxyCommand startupCmd) {	StartConsoleProxyAgentHttpHandlerCommand cmd = null;	try {	SecureRandom random = SecureRandom.getInstance("SHA1PRNG");	byte[] randomBytes = new byte[16];	random.nextBytes(randomBytes);	String storePassword = Base64.encodeBase64String(randomBytes);	byte[] ksBits = null;	String consoleProxyUrlDomain = _configDao.getValue(Config.ConsoleProxyUrlDomain.key());	if (consoleProxyUrlDomain == null || consoleProxyUrlDomain.isEmpty()) {	
ssl is disabled for console proxy based on global config skip loading certificates 

} else {	ksBits = _ksMgr.getKeystoreBits(ConsoleProxyManager.CERTIFICATE_NAME, ConsoleProxyManager.CERTIFICATE_NAME, storePassword);	}	cmd = new StartConsoleProxyAgentHttpHandlerCommand(ksBits, storePassword);	cmd.setEncryptorPassword(getEncryptorPassword());	HostVO consoleProxyHost = findConsoleProxyHost(startupCmd);	assert (consoleProxyHost != null);	if (consoleProxyHost != null) {	Answer answer = _agentMgr.send(consoleProxyHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
console proxy agent reported that it failed to execute http handling startup command 

ksBits = _ksMgr.getKeystoreBits(ConsoleProxyManager.CERTIFICATE_NAME, ConsoleProxyManager.CERTIFICATE_NAME, storePassword);	}	cmd = new StartConsoleProxyAgentHttpHandlerCommand(ksBits, storePassword);	cmd.setEncryptorPassword(getEncryptorPassword());	HostVO consoleProxyHost = findConsoleProxyHost(startupCmd);	assert (consoleProxyHost != null);	if (consoleProxyHost != null) {	Answer answer = _agentMgr.send(consoleProxyHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	} else {	
successfully sent out command to start http handling in console proxy agent 

cmd.setEncryptorPassword(getEncryptorPassword());	HostVO consoleProxyHost = findConsoleProxyHost(startupCmd);	assert (consoleProxyHost != null);	if (consoleProxyHost != null) {	Answer answer = _agentMgr.send(consoleProxyHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	} else {	}	}	}catch (NoSuchAlgorithmException e) {	
unexpected exception in securerandom algorithm selection 

HostVO consoleProxyHost = findConsoleProxyHost(startupCmd);	assert (consoleProxyHost != null);	if (consoleProxyHost != null) {	Answer answer = _agentMgr.send(consoleProxyHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	} else {	}	}	}catch (NoSuchAlgorithmException e) {	} catch (AgentUnavailableException e) {	
unable to send http handling startup command to the console proxy resource for proxy 

assert (consoleProxyHost != null);	if (consoleProxyHost != null) {	Answer answer = _agentMgr.send(consoleProxyHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	} else {	}	}	}catch (NoSuchAlgorithmException e) {	} catch (AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	
unable to send http handling startup command time out to the console proxy resource for proxy 

if (consoleProxyHost != null) {	Answer answer = _agentMgr.send(consoleProxyHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	} else {	}	}	}catch (NoSuchAlgorithmException e) {	} catch (AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	} catch (OutOfMemoryError e) {	
unrecoverable outofmemory error exit and let it be re launched 

if (answer == null || !answer.getResult()) {	} else {	}	}	}catch (NoSuchAlgorithmException e) {	} catch (AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	} catch (OutOfMemoryError e) {	System.exit(1);	} catch (Exception e) {	
unexpected exception when sending http handling startup command time out to the console proxy resource for proxy 

private String getEncryptorPassword() {	String key;	String iv;	ConsoleProxyPasswordBasedEncryptor.KeyIVPair keyIvPair = null;	for (int i = 0; i < 2; i++) {	key = _keysMgr.getEncryptionKey();	iv = _keysMgr.getEncryptionIV();	keyIvPair = new ConsoleProxyPasswordBasedEncryptor.KeyIVPair(key, iv);	if (keyIvPair.getIvBytes() == null || keyIvPair.getIvBytes().length != 16 || keyIvPair.getKeyBytes() == null || keyIvPair.getKeyBytes().length != 16) {	
console access aes keyiv sanity check failed reset and regenerate 

========================= cloudstack sample_2485 =========================

throw new InvalidParameterValueException("Invalid network id is given");	}	if (network.getGuestType() == Network.GuestType.Shared) {	if (zone == null) {	throw new InvalidParameterValueException("Invalid zone Id is given");	}	if (zone.getNetworkType() == NetworkType.Advanced) {	if (isSharedNetworkOfferingWithServices(network.getNetworkOfferingId())) {	_accountMgr.checkAccess(caller, AccessType.UseEntry, false, network);	if (s_logger.isDebugEnabled()) {	
associate ip address called by the user account 

throw new InvalidParameterValueException("Invalid network id is given");	}	if (network.getGuestType() == Network.GuestType.Shared) {	if (zone == null) {	throw new InvalidParameterValueException("Invalid zone Id is given");	}	if (zone.getNetworkType() == NetworkType.Advanced) {	if (isSharedNetworkOfferingWithServices(network.getNetworkOfferingId())) {	_accountMgr.checkAccess(caller, AccessType.UseEntry, false, network);	if (s_logger.isDebugEnabled()) {	
associate ip address called by the user account 

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	_configs = _configDao.getConfiguration("Network", params);	_cidrLimit = NumbersUtil.parseInt(_configs.get(Config.NetworkGuestCidrLimit.key()), 22);	_allowSubdomainNetworkAccess = Boolean.valueOf(_configs.get(Config.SubDomainNetworkAccess.key()));	
network service is configured 

public boolean configureNicSecondaryIp(NicSecondaryIp secIp, boolean isZoneSgEnabled) {	boolean success = false;	if (isZoneSgEnabled) {	success = _securityGroupService.securityGroupRulesForVmSecIp(secIp.getNicId(), secIp.getIp4Address(), true);	
associated ip address to nic 

Network network = _networksDao.findById(networkId);	if (network == null) {	throw new InvalidParameterValueException("Invalid network id is given");	}	int maxAllowedIpsPerNic = NumbersUtil.parseInt(_configDao.getValue(Config.MaxNumberOfSecondaryIPsPerNIC.key()), 10);	Long nicWiseIpCount = _nicSecondaryIpDao.countByNicId(nicId);	if(nicWiseIpCount.intValue() >= maxAllowedIpsPerNic) {	s_logger.error("Maximum Number of Ips \"vm.network.nic.max.secondary.ipaddresses = \"" + maxAllowedIpsPerNic + " per Nic has been crossed for the nic " +  nicId + ".");	throw new InsufficientAddressCapacityException("Maximum Number of Ips per Nic has been crossed.", Nic.class, nicId);	}	
calling the ip allocation 

if (podId == null) {	throw new InvalidParameterValueException("vm pod id is null in Basic zone; can't decide the range for ip allocation");	}	}	try {	ipaddr = _ipAddrMgr.allocatePublicIpForGuestNic(network, podId, ipOwner, requestedIp);	if (ipaddr == null) {	throw new InvalidParameterValueException("Allocating ip to guest nic " + nicId + " failed");	}	} catch (InsufficientAddressCapacityException e) {	
allocating ip to guest nic failed 

}	try {	ipaddr = _ipAddrMgr.allocatePublicIpForGuestNic(network, podId, ipOwner, requestedIp);	if (ipaddr == null) {	throw new InvalidParameterValueException("Allocating ip to guest nic " + nicId + " failed");	}	} catch (InsufficientAddressCapacityException e) {	return null;	}	} else {	
addiptovmnic is not supported in this network 

} else {	return null;	}	if (ipaddr != null) {	final String addrFinal = ipaddr;	long id = Transaction.execute(new TransactionCallback<Long>() {	public Long doInTransaction(TransactionStatus status) {	boolean nicSecondaryIpSet = nicVO.getSecondaryIp();	if (!nicSecondaryIpSet) {	nicVO.setSecondaryIp(true);	
setting nics table 

}	if (ipaddr != null) {	final String addrFinal = ipaddr;	long id = Transaction.execute(new TransactionCallback<Long>() {	public Long doInTransaction(TransactionStatus status) {	boolean nicSecondaryIpSet = nicVO.getSecondaryIp();	if (!nicSecondaryIpSet) {	nicVO.setSecondaryIp(true);	_nicDao.update(nicId, nicVO);	}	
setting nic secondary ip table 

s_logger.debug("ip id = " + ipAddressId + " nic id = " + nicId);	List<NicSecondaryIpVO> ipList = _nicSecondaryIpDao.listByNicId(nicId);	boolean lastIp = false;	if (ipList.size() == 1) {	lastIp = true;	}	DataCenter dc = _dcDao.findById(network.getDataCenterId());	if (dc == null) {	throw new InvalidParameterValueException("Invalid zone Id is given");	}	
calling secondary ip release 

DataCenter dc = _dcDao.findById(network.getDataCenterId());	if (dc == null) {	throw new InvalidParameterValueException("Invalid zone Id is given");	}	if (dc.getNetworkType() == NetworkType.Advanced && network.getGuestType() == Network.GuestType.Isolated) {	String secondaryIp = secIpVO.getIp4Address();	List<FirewallRuleVO> fwRulesList =  _firewallDao.listByNetworkAndPurpose(network.getId(), Purpose.PortForwarding);	if (fwRulesList.size() != 0) {	for (FirewallRuleVO rule : fwRulesList) {	if (_portForwardingDao.findByIdAndIp(rule.getId(), secondaryIp) != null) {	
vm nic ip is associated with the port forwarding rule 

List<FirewallRuleVO> fwRulesList =  _firewallDao.listByNetworkAndPurpose(network.getId(), Purpose.PortForwarding);	if (fwRulesList.size() != 0) {	for (FirewallRuleVO rule : fwRulesList) {	if (_portForwardingDao.findByIdAndIp(rule.getId(), secondaryIp) != null) {	throw new InvalidParameterValueException("Can't remove the secondary ip " + secondaryIp + " is associate with the port forwarding rule");	}	}	}	IPAddressVO publicIpVO = _ipAddressDao.findByIpAndNetworkId(secIpVO.getNetworkId(), secondaryIp);	if (publicIpVO != null) {	
vm nic ip is associated with the static nat rule public ip address id 

if (_portForwardingDao.findByIdAndIp(rule.getId(), secondaryIp) != null) {	throw new InvalidParameterValueException("Can't remove the secondary ip " + secondaryIp + " is associate with the port forwarding rule");	}	}	}	IPAddressVO publicIpVO = _ipAddressDao.findByIpAndNetworkId(secIpVO.getNetworkId(), secondaryIp);	if (publicIpVO != null) {	throw new InvalidParameterValueException("Can' remove the ip " + secondaryIp + "is associate with static NAT rule public IP address id " + publicIpVO.getId());	}	if (_lbService.isLbRuleMappedToVmGuestIp(secondaryIp)) {	
vm nic ip is mapped to load balancing rule 

public void doInTransactionWithoutResult(TransactionStatus status) {	if (lastIp) {	nic.setSecondaryIp(false);	
setting nics secondary ip to false 

public void doInTransactionWithoutResult(TransactionStatus status) {	if (lastIp) {	nic.setSecondaryIp(false);	_nicDao.update(nicId, nic);	}	
revoving nic secondary ip entry 

}	if (gateway != null) {	try {	InetAddress gatewayAddress = InetAddress.getByName(gateway);	if (gatewayAddress instanceof Inet6Address) {	ipv6 = true;	} else {	ipv4 = true;	}	} catch (UnknownHostException e) {	
unable to convert gateway ip to a inetaddress 

}	}	if (startIP != null && endIP != null) {	if (!(gateway != null && netmask != null)) {	throw new InvalidParameterValueException("gateway and netmask should be defined when startIP/endIP are passed in");	}	}	if (gateway != null && netmask != null) {	if(NetUtils.isNetworkorBroadcastIP(gateway,netmask)) {	if (s_logger.isDebugEnabled()) {	
the gateway ip provided is and netmask is the ip is either broadcast or network ip 

if (ntwkOff.getIsPersistent()) {	try {	if (network.getState() == Network.State.Setup) {	s_logger.debug("Network id=" + network.getId() + " is already provisioned");	return network;	}	DeployDestination dest = new DeployDestination(zone, null, null, null);	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + network, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, caller);	
implementing network as a part of network provision for persistent network 

if (network.getState() == Network.State.Setup) {	s_logger.debug("Network id=" + network.getId() + " is already provisioned");	return network;	}	DeployDestination dest = new DeployDestination(zone, null, null, null);	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + network, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, caller);	Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(network.getId(), dest, context);	if (implementedNetwork == null || implementedNetwork.first() == null) {	
failed to provision the network 

}	DeployDestination dest = new DeployDestination(zone, null, null, null);	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + network, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, caller);	Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(network.getId(), dest, context);	if (implementedNetwork == null || implementedNetwork.first() == null) {	}	network = implementedNetwork.second();	} catch (ResourceUnavailableException ex) {	
failed to implement persistent guest network due to 

}	} else {	if (!NetUtils.isNetworkAWithinNetworkB(guestVmCidr, network.getCidr())) {	throw new InvalidParameterValueException("Invalid value of Guest VM CIDR. For IP Reservation, Guest VM CIDR  should be a subset of network CIDR :  " + network.getCidr());	}	}	String[] guestVmCidrPair = guestVmCidr.split("\\/");	Long size = Long.valueOf(guestVmCidrPair[1]);	List<NicVO> nicsPresent = _nicDao.listByNetworkId(networkId);	String cidrIpRange[] = NetUtils.getIpRangeFromCidr(guestVmCidrPair[0], size);	
the start ip of the specified guest vm cidr is and end ip is 

throw new InvalidParameterValueException("Invalid value of Guest VM CIDR. For IP Reservation, Guest VM CIDR  should be a subset of network CIDR :  " + network.getCidr());	}	}	String[] guestVmCidrPair = guestVmCidr.split("\\/");	Long size = Long.valueOf(guestVmCidrPair[1]);	List<NicVO> nicsPresent = _nicDao.listByNetworkId(networkId);	String cidrIpRange[] = NetUtils.getIpRangeFromCidr(guestVmCidrPair[0], size);	long startIp = NetUtils.ip2Long(cidrIpRange[0]);	long endIp = NetUtils.ip2Long(cidrIpRange[1]);	long range =  endIp - startIp + 1;	
the specified guest vm cidr has ips 

}	} else {	if (NetUtils.isSameIpRange(guestVmCidr, network.getNetworkCidr()) && !guestVmCidr.equals(network.getNetworkCidr())) {	throw new InvalidParameterValueException("The Start IP and End IP of guestvmcidr: " + guestVmCidr + " and Network CIDR: " + network.getNetworkCidr() + " are same, " + "even though both the cidrs appear to be different. As a precaution IP Reservation will not be affected. If you want to reset IP Reservation, " + "specify guestVmCidr to be: " + network.getNetworkCidr());	}	}	if (network.getNetworkCidr() == null) {	network.setNetworkCidr(network.getCidr());	}	if (network.getNetworkCidr().equals(guestVmCidr)) {	
guest vm cidr and network cidr both are same reservation will reset 

}	}	if (network.getNetworkCidr() == null) {	network.setNetworkCidr(network.getCidr());	}	if (network.getNetworkCidr().equals(guestVmCidr)) {	network.setNetworkCidr(null);	}	network.setCidr(guestVmCidr);	_networksDao.update(networkId, network);	
ip reservation has been applied the new cidr for guests vms is 

network.setCidr(guestVmCidr);	_networksDao.update(networkId, network);	}	ReservationContext context = new ReservationContextImpl(null, null, callerUser, callerAccount);	boolean validStateToShutdown = (network.getState() == Network.State.Implemented || network.getState() == Network.State.Setup || network.getState() == Network.State.Allocated);	if (restartNetwork) {	if (validStateToShutdown) {	if (!changeCidr) {	s_logger.debug("Shutting down elements and resources for network id=" + networkId + " as a part of network update");	if (!_networkMgr.shutdownNetworkElementsAndResources(context, true, network)) {	
failed to shutdown the network elements and resources as a part of network restart 

throw ex;	}	} else {	s_logger.debug("Shutting down network id=" + networkId + " as a part of network update");	if (NetUtils.isNetworkAWithinNetworkB(network.getCidr(), network.getNetworkCidr())) {	s_logger.warn("Existing IP reservation will become ineffective for the network with id =  " + networkId + " You need to reapply reservation after network reimplementation.");	network.setCidr(network.getNetworkCidr());	network.setNetworkCidr(null);	}	if (!_networkMgr.shutdownNetwork(network.getId(), context, true)) {	
failed to shutdown the network as a part of update to network with specified id 

if (networkOfferingChanged) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	network.setNetworkOfferingId(networkOfferingId);	_networksDao.update(networkId, network, newSvcProviders);	List<NicVO> nics = _nicDao.listByNetworkId(networkId);	for (NicVO nic : nics) {	long vmId = nic.getInstanceId();	VMInstanceVO vm = _vmDao.findById(vmId);	if (vm == null) {	
vm for nic not found with vm id 

}   else {	network.setNetworkOfferingId(networkOfferingId);	_networksDao.update(networkId, network, _networkMgr.finalizeServicesAndProvidersForNetwork(_entityMgr.findById(NetworkOffering.class, networkOfferingId), network.getPhysicalNetworkId()));	}	}   else {	_networksDao.update(networkId, network);	}	if (restartNetwork) {	if (network.getState() != Network.State.Allocated) {	DeployDestination dest = new DeployDestination(_dcDao.findById(network.getDataCenterId()), null, null, null);	
implementing the network elements and resources as a part of network update 

if (restartNetwork) {	if (network.getState() != Network.State.Allocated) {	DeployDestination dest = new DeployDestination(_dcDao.findById(network.getDataCenterId()), null, null, null);	try {	if (!changeCidr) {	_networkMgr.implementNetworkElementsAndResources(dest, context, network, _networkOfferingDao.findById(network.getNetworkOfferingId()));	} else {	_networkMgr.implementNetwork(network.getId(), dest, context);	}	} catch (Exception ex) {	
failed to implement network elements and resources as a part of network update due to 

throw e;	}	}	}	if (networkOfferingChanged && !oldNtwkOff.getIsPersistent() && networkOffering.getIsPersistent()) {	if (network.getState() == Network.State.Allocated) {	try {	DeployDestination dest = new DeployDestination(_dcDao.findById(network.getDataCenterId()), null, null, null);	_networkMgr.implementNetwork(network.getId(), dest, context);	} catch (Exception ex) {	
failed to implement network elements and resources as a part o f network update due to 

protected Set<Long> getAvailableIps(Network network, String requestedIp) {	String[] cidr = network.getCidr().split("/");	List<String> ips = _nicDao.listIpAddressInNetwork(network.getId());	Set<Long> usedIps = new TreeSet<Long>();	for (String ip : ips) {	if (requestedIp != null && requestedIp.equals(ip)) {	
requested ip address is already in use in network 

protected boolean canUpgrade(Network network, long oldNetworkOfferingId, long newNetworkOfferingId) {	NetworkOffering oldNetworkOffering = _networkOfferingDao.findByIdIncludingRemoved(oldNetworkOfferingId);	NetworkOffering newNetworkOffering = _networkOfferingDao.findById(newNetworkOfferingId);	if (oldNetworkOffering.getGuestType() != GuestType.Isolated) {	throw new InvalidParameterValueException("NetworkOfferingId can be upgraded only for the network of type " + GuestType.Isolated);	}	if (areServicesSupportedByNetworkOffering(oldNetworkOfferingId, Service.SecurityGroup) != areServicesSupportedByNetworkOffering(newNetworkOfferingId, Service.SecurityGroup)) {	
offerings and have different securitygroupproperty can t upgrade 

protected boolean canUpgrade(Network network, long oldNetworkOfferingId, long newNetworkOfferingId) {	NetworkOffering oldNetworkOffering = _networkOfferingDao.findByIdIncludingRemoved(oldNetworkOfferingId);	NetworkOffering newNetworkOffering = _networkOfferingDao.findById(newNetworkOfferingId);	if (oldNetworkOffering.getGuestType() != GuestType.Isolated) {	throw new InvalidParameterValueException("NetworkOfferingId can be upgraded only for the network of type " + GuestType.Isolated);	}	if (areServicesSupportedByNetworkOffering(oldNetworkOfferingId, Service.SecurityGroup) != areServicesSupportedByNetworkOffering(newNetworkOfferingId, Service.SecurityGroup)) {	return false;	}	if (oldNetworkOffering.getGuestType() != newNetworkOffering.getGuestType()) {	
network offerings and are of different types can t upgrade 

}	if (oldNetworkOffering.getGuestType() != newNetworkOffering.getGuestType()) {	return false;	}	if (newNetworkOffering.getTags() != null) {	if (oldNetworkOffering.getTags() == null) {	s_logger.debug("New network offering id=" + newNetworkOfferingId + " has tags and old network offering id=" + oldNetworkOfferingId + " doesn't, can't upgrade");	return false;	}	if (!StringUtils.areTagsEqual(oldNetworkOffering.getTags(), newNetworkOffering.getTags())) {	
network offerings and have different tags can t upgrade 

if (newNetworkOffering.getTags() != null) {	if (oldNetworkOffering.getTags() == null) {	s_logger.debug("New network offering id=" + newNetworkOfferingId + " has tags and old network offering id=" + oldNetworkOfferingId + " doesn't, can't upgrade");	return false;	}	if (!StringUtils.areTagsEqual(oldNetworkOffering.getTags(), newNetworkOffering.getTags())) {	return false;	}	}	if (oldNetworkOffering.getTrafficType() != newNetworkOffering.getTrafficType()) {	
network offerings and have different traffic types can t upgrade 

return false;	}	if (!StringUtils.areTagsEqual(oldNetworkOffering.getTags(), newNetworkOffering.getTags())) {	return false;	}	}	if (oldNetworkOffering.getTrafficType() != newNetworkOffering.getTrafficType()) {	return false;	}	if (oldNetworkOffering.getSpecifyVlan() != newNetworkOffering.getSpecifyVlan()) {	
network offerings and have different values for specifyvlan can t upgrade 

return false;	}	}	if (oldNetworkOffering.getTrafficType() != newNetworkOffering.getTrafficType()) {	return false;	}	if (oldNetworkOffering.getSpecifyVlan() != newNetworkOffering.getSpecifyVlan()) {	return false;	}	if (oldNetworkOffering.getSpecifyIpRanges() != newNetworkOffering.getSpecifyIpRanges()) {	
network offerings and have different values for specifyiprangess can t upgrade 

addDefaultVirtualRouterToPhysicalNetwork(pNetwork.getId());	if (pNetwork.getIsolationMethods().contains("GRE")) addDefaultOvsToPhysicalNetwork(pNetwork.getId());	addDefaultSecurityGroupProviderToPhysicalNetwork(pNetwork.getId());	addDefaultVpcVirtualRouterToPhysicalNetwork(pNetwork.getId());	addDefaultBaremetalProvidersToPhysicalNetwork(pNetwork.getId());	addDefaultInternalLbProviderToPhysicalNetwork(pNetwork.getId());	return pNetwork;	}	});	} catch (Exception ex) {	
exception 

private List<Pair<Integer, Integer>> validateVlanRange(PhysicalNetworkVO network, String[] listOfRanges) {	Integer StartVnet;	Integer EndVnet;	List<Pair<Integer, Integer>> vlanTokens = new ArrayList<Pair<Integer, Integer>>();	for (String vlanRange : listOfRanges) {	String[] VnetRange = vlanRange.split("-");	long minVnet = MIN_VLAN_ID;	long maxVnet = MAX_VLAN_ID;	
isolation methods 

String[] VnetRange = vlanRange.split("-");	long minVnet = MIN_VLAN_ID;	long maxVnet = MAX_VLAN_ID;	if (network.getIsolationMethods().contains("GRE")) {	minVnet = MIN_GRE_KEY;	maxVnet = MAX_GRE_KEY;	} else if (network.getIsolationMethods().contains("VXLAN")) {	minVnet = MIN_VXLAN_VNI;	maxVnet = MAX_VXLAN_VNI;	for (String vnet : VnetRange) {	
looking to see if vni already exists on another network in zone 

minVnet = MIN_GRE_KEY;	maxVnet = MAX_GRE_KEY;	} else if (network.getIsolationMethods().contains("VXLAN")) {	minVnet = MIN_VXLAN_VNI;	maxVnet = MAX_VXLAN_VNI;	for (String vnet : VnetRange) {	List<DataCenterVnetVO> vnis = _datacneterVnet.findVnet(network.getDataCenterId(), vnet);	if (vnis != null && !vnis.isEmpty()) {	for (DataCenterVnetVO vni : vnis) {	if (vni.getPhysicalNetworkId() != network.getId()) {	
vni already exists on another network in zone please specify a unique range 

if (VnetRange.length < 2) {	throw new InvalidParameterValueException("Please provide valid vnet range. vnet range should be a coma seperated list of vlan ranges. example 500-500,600-601" + rangeMessage);	}	if (VnetRange[0] == null || VnetRange[1] == null) {	throw new InvalidParameterValueException("Please provide valid vnet range" + rangeMessage);	}	try {	StartVnet = Integer.parseInt(VnetRange[0]);	EndVnet = Integer.parseInt(VnetRange[1]);	} catch (NumberFormatException e) {	
unable to parse vnet range 

for (NetworkVO network : networks) {	_networksDao.remove(network.getId());	}	}	_dcDao.deleteVnet(physicalNetworkId);	List<PhysicalNetworkServiceProviderVO> providers = _pNSPDao.listBy(physicalNetworkId);	for (PhysicalNetworkServiceProviderVO provider : providers) {	try {	deleteNetworkServiceProvider(provider.getId());	} catch (ResourceUnavailableException e) {	
unable to complete destroy of the physical network provider id 

}	}	_dcDao.deleteVnet(physicalNetworkId);	List<PhysicalNetworkServiceProviderVO> providers = _pNSPDao.listBy(physicalNetworkId);	for (PhysicalNetworkServiceProviderVO provider : providers) {	try {	deleteNetworkServiceProvider(provider.getId());	} catch (ResourceUnavailableException e) {	return false;	} catch (ConcurrentOperationException e) {	
unable to complete destroy of the physical network provider id 

throw new InvalidParameterValueException("Cannot dedicate guest vlan range. " + "Physical isolation type of network " + physicalNetworkId + " is not VLAN");	}	String[] vlanRange = vlan.split("-");	if (vlanRange.length != 2) {	throw new InvalidParameterValueException("Invalid format for parameter value vlan " + vlan + " .Vlan should be specified as 'startvlan-endvlan'");	}	try {	startVlan = Integer.parseInt(vlanRange[0]);	endVlan = Integer.parseInt(vlanRange[1]);	} catch (NumberFormatException e) {	
unable to parse guest vlan range 

private List<Integer> getVlanFromRange(String vlanRange) {	String[] vlanTokens = vlanRange.split("-");	List<Integer> tokens = new ArrayList<Integer>();	try {	int startVlan = Integer.parseInt(vlanTokens[0]);	int endVlan = Integer.parseInt(vlanTokens[1]);	tokens.add(startVlan);	tokens.add(endVlan);	} catch (NumberFormatException e) {	
unable to parse guest vlan range 

}	try {	PhysicalNetworkServiceProviderVO nsp = new PhysicalNetworkServiceProviderVO(physicalNetworkId, providerName);	nsp.setEnabledServices(services);	if (destinationPhysicalNetworkId != null) {	nsp.setDestinationPhysicalNetworkId(destinationPhysicalNetworkId);	}	nsp = _pNSPDao.persist(nsp);	return nsp;	} catch (Exception ex) {	
exception 

if (xenLabel == null) {	xenLabel = getDefaultXenNetworkLabel(trafficType);	}	PhysicalNetworkTrafficTypeVO pNetworktrafficType = new PhysicalNetworkTrafficTypeVO(physicalNetworkId, trafficType, xenLabel, kvmLabel, vmwareLabel, simulatorLabel, vlan, hypervLabel, ovm3Label);	pNetworktrafficType = _pNTrafficTypeDao.persist(pNetworktrafficType);	if (TrafficType.Public.equals(trafficType)){	List<String> isolationMethods = network.getIsolationMethods();	if ((isolationMethods.size() == 1 && isolationMethods.get(0).toLowerCase().equals("vxlan")) || (isolationMethod != null && isolationMethods.contains(isolationMethod) && isolationMethod.toLowerCase().equals("vxlan"))) {	NetworkVO publicNetwork = _networksDao.listByZoneAndTrafficType(network.getDataCenterId(),TrafficType.Public).get(0);	if (publicNetwork != null) {	
setting public network to broadcast type vxlan 

if ((isolationMethods.size() == 1 && isolationMethods.get(0).toLowerCase().equals("vxlan")) || (isolationMethod != null && isolationMethods.contains(isolationMethod) && isolationMethod.toLowerCase().equals("vxlan"))) {	NetworkVO publicNetwork = _networksDao.listByZoneAndTrafficType(network.getDataCenterId(),TrafficType.Public).get(0);	if (publicNetwork != null) {	publicNetwork.setBroadcastDomainType(BroadcastDomainType.Vxlan);	_networksDao.persist(publicNetwork);	}	}	}	return pNetworktrafficType;	} catch (Exception ex) {	
exception 

private PhysicalNetworkServiceProvider addDefaultOvsToPhysicalNetwork(long physicalNetworkId) {	PhysicalNetworkServiceProvider nsp = addProviderToPhysicalNetwork(physicalNetworkId, Network.Provider.Ovs.getName(), null, null);	NetworkElement networkElement = _networkModel.getElementImplementingProvider(Network.Provider.Ovs.getName());	if (networkElement == null) {	throw new CloudRuntimeException("Unable to find the Network Element implementing the Ovs Provider");	}	OvsProviderVO element = _ovsProviderDao.findByNspId(nsp.getId());	if (element != null) {	
there is already a ovs element with service provider id 

}	final NetworkOfferingVO ntwkOffFinal = ntwkOff;	try {	return Transaction.execute(new TransactionCallbackWithException<Network, Exception>() {	public Network doInTransaction(TransactionStatus status) throws ResourceAllocationException, InsufficientCapacityException {	DataCenterVO dc = _dcDao.lockRow(pNtwk.getDataCenterId(), true);	Network privateNetwork = _networksDao.getPrivateNetwork(uriString, cidr, networkOwnerId, pNtwk.getDataCenterId(), networkOfferingId);	if (privateNetwork == null) {	privateNetwork = _networkMgr.createGuestNetwork(ntwkOffFinal.getId(), networkName, displayText, gateway, cidr, uriString, null, owner, null, pNtwk, pNtwk.getDataCenterId(), ACLType.Account, null, vpcId, null, null, true, null);	if (privateNetwork != null) {	
successfully created guest network 

public Network doInTransaction(TransactionStatus status) throws ResourceAllocationException, InsufficientCapacityException {	DataCenterVO dc = _dcDao.lockRow(pNtwk.getDataCenterId(), true);	Network privateNetwork = _networksDao.getPrivateNetwork(uriString, cidr, networkOwnerId, pNtwk.getDataCenterId(), networkOfferingId);	if (privateNetwork == null) {	privateNetwork = _networkMgr.createGuestNetwork(ntwkOffFinal.getId(), networkName, displayText, gateway, cidr, uriString, null, owner, null, pNtwk, pNtwk.getDataCenterId(), ACLType.Account, null, vpcId, null, null, true, null);	if (privateNetwork != null) {	} else {	throw new CloudRuntimeException("Creating guest network failed");	}	} else {	
private network already exists 

if (privateIp != null) {	throw new InvalidParameterValueException("Private ip address " + startIp + " already used for private gateway" + " in zone " + _entityMgr.findById(DataCenter.class, pNtwk.getDataCenterId()).getName());	}	Long mac = dc.getMacAddress();	Long nextMac = mac + 1;	dc.setMacAddress(nextMac);	privateIp = new PrivateIpVO(startIp, privateNetwork.getId(), nextMac, vpcId, sourceNat);	_privateIpDao.persist(privateIp);	_dcDao.update(dc.getId(), dc);	}	
private network is created 

========================= cloudstack sample_2344 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all networkoffering usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageNetworkOfferingVO> usageNOs = s_usageNetworkOfferingDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate, false, 0);	if (usageNOs.isEmpty()) {	
no networkoffering usage events for this period 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long vmId, long noId, long zoneId, boolean isDefault) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long vmId, long noId, long zoneId, boolean isDefault) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating network offering usage record for vm usage startdate enddate for account 

========================= cloudstack sample_2651 =========================

} else {	s_logger.info("No credentials configured for host=" + hostAndPort.first() + ":" + hostAndPort.second());	}	} catch (IllegalArgumentException iae) {	errorString = iae.getMessage();	status = TemplateDownloader.Status.UNRECOVERABLE_ERROR;	inited = false;	} catch (Exception ex) {	errorString = "Unable to start download -- check url? ";	status = TemplateDownloader.Status.UNRECOVERABLE_ERROR;	
exception in constructor 

s_logger.info("No credentials configured for host=" + hostAndPort.first() + ":" + hostAndPort.second());	}	} catch (IllegalArgumentException iae) {	errorString = iae.getMessage();	status = TemplateDownloader.Status.UNRECOVERABLE_ERROR;	inited = false;	} catch (Exception ex) {	errorString = "Unable to start download -- check url? ";	status = TemplateDownloader.Status.UNRECOVERABLE_ERROR;	} catch (Throwable th) {	
throwable caught 

out.write(block, 0, bytes);	offset += bytes;	out.seek(offset);	totalBytes += bytes;	if (!verifiedFormat && (offset >= 1048576 || offset >= remoteSize)) {	String uripath = null;	try {	URI str = new URI(getDownloadUrl());	uripath = str.getPath();	} catch (URISyntaxException e) {	
invalid download url this should not happen since we have validated the url before 

uripath = str.getPath();	} catch (URISyntaxException e) {	}	String unsupportedFormat = ImageStoreUtil.checkTemplateFormat(file.getAbsolutePath(), uripath);	if (unsupportedFormat == null || !unsupportedFormat.isEmpty()) {	try {	request.abort();	out.close();	in.close();	} catch (Exception ex) {	
error on http connection 

try {	request.abort();	out.close();	in.close();	} catch (Exception ex) {	}	status = Status.UNRECOVERABLE_ERROR;	errorString = "Template content is unsupported, or mismatch between selected format and template content. Found  : " + unsupportedFormat;	return 0;	}	
verified format of downloading file is supported 

protected void runInContext() {	try {	download(resume, completionCallback);	} catch (Throwable t) {	
caught exception during download 

========================= cloudstack sample_399 =========================

public void testInjected() throws Exception {	
starting test to archive and delete alerts 

public void testInjected() throws Exception {	archiveAlerts();	deleteAlerts();	
archive delete alerts test passed 

========================= cloudstack sample_2128 =========================

public BigDecimal lastQuotaBalance(final Long accountId, final Long domainId, Date startDate) {	List<QuotaBalanceVO> quotaBalance = lastQuotaBalanceVO(accountId, domainId, startDate);	BigDecimal finalBalance = new BigDecimal(0);	if (quotaBalance.isEmpty()) {	
there are no balance entries on or before the requested date 

========================= cloudstack sample_663 =========================

final Connection conn = citrixResourceBase.getConnection();	String vmName = command.getVmName();	List<String[]> vmData = command.getVmData();	String label = command.getConfigDriveLabel();	Boolean isAttach = command.isAttach();	try {	Set<VM> vms = VM.getByNameLabel(conn, vmName);	for (VM vm : vms) {	if (isAttach) {	if (!citrixResourceBase.createAndAttachConfigDriveIsoForVM(conn, vm, vmData, label)) {	
failed to attach config drive iso to vm 

Boolean isAttach = command.isAttach();	try {	Set<VM> vms = VM.getByNameLabel(conn, vmName);	for (VM vm : vms) {	if (isAttach) {	if (!citrixResourceBase.createAndAttachConfigDriveIsoForVM(conn, vm, vmData, label)) {	}	} else {	Set<VDI> vdis = VDI.getByNameLabel(conn, vmName+".iso");	if (vdis != null && !vdis.isEmpty()) {	
deleting config drive for the vm 

VBD.Record vbdRec = vbd.getRecord(conn);	if (vbdRec.type.equals(Types.VbdType.CD) && !vbdRec.empty && !vbdRec.userdevice.equals(citrixResourceBase._attachIsoDeviceNum)) {	if (vbdRec.currentlyAttached) {	vbd.eject(conn);	}	vbd.destroy(conn);	}	}	vdi.destroy(conn);	}	
successfully dettached config drive iso from the vm 

vbd.eject(conn);	}	vbd.destroy(conn);	}	}	vdi.destroy(conn);	}	}	}	}catch (Types.XenAPIException ex) {	
failed to attach config drive iso to vm 

}	vbd.destroy(conn);	}	}	vdi.destroy(conn);	}	}	}	}catch (Types.XenAPIException ex) {	}catch (XmlRpcException ex) {	
failed to attach config drive iso to vm 

========================= cloudstack sample_1211 =========================

private String generateCopyUrl(String ipAddress, String uuid) {	String hostname = ipAddress;	String scheme = "http";	boolean _sslCopy = false;	String sslCfg = _configDao.getValue(Config.SecStorageEncryptCopy.toString());	String _ssvmUrlDomain = _configDao.getValue("secstorage.ssl.cert.domain");	if (sslCfg != null) {	_sslCopy = Boolean.parseBoolean(sslCfg);	}	if(_sslCopy && (_ssvmUrlDomain == null || _ssvmUrlDomain.isEmpty())){	
empty secondary storage url domain ignoring ssl 

========================= cloudstack sample_1905 =========================

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configPortProfileDetails(doc, name, type, binding, mode, vlanid, vdc, espName));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating add port profile message 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configPortProfileDetails(doc, name, type, binding, mode, vlanid, vdc, espName));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating add port profile message 

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configPortProfileDetails(doc, name, type, binding, mode, vlanid));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating add port profile message 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configPortProfileDetails(doc, name, type, binding, mode, vlanid));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating add port profile message 

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configPortProfileDetails(doc, name, mode, params));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating update port profile message 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configPortProfileDetails(doc, name, mode, params));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating update port profile message 

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(deletePortProfileDetails(doc, portName));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating delete port profile message 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(deletePortProfileDetails(doc, portName));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating delete port profile message 

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(policyMapDetails(doc, name, averageRate, maxRate, burstRate));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating policy map message 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(policyMapDetails(doc, name, averageRate, maxRate, burstRate));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating policy map message 

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(deletePolicyMapDetails(doc, name));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating delete policy map message 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(deletePolicyMapDetails(doc, name));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating delete policy map message 

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(serviceDetails(doc, policyMap, portProfile, attach));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating attach detach service policy message 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(serviceDetails(doc, policyMap, portProfile, attach));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating attach detach service policy message 

filter.appendChild(show);	Element portProfile = doc.createElement("port-profile");	show.appendChild(portProfile);	Element nameNode = doc.createElement("name");	portProfile.appendChild(nameNode);	Element profileName = doc.createElement("profile_name");	profileName.setTextContent(name);	nameNode.appendChild(profileName);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating the message to get port profile details 

show.appendChild(portProfile);	Element nameNode = doc.createElement("name");	portProfile.appendChild(nameNode);	Element profileName = doc.createElement("profile_name");	profileName.setTextContent(name);	nameNode.appendChild(profileName);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating the message to get port profile details 

get.appendChild(filter);	Element show = doc.createElement("show");	filter.appendChild(show);	Element policyMap = doc.createElement("policy-map");	show.appendChild(policyMap);	Element nameNode = doc.createElement("name");	nameNode.setTextContent(name);	policyMap.appendChild(nameNode);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating the message to get policy map details 

filter.appendChild(show);	Element policyMap = doc.createElement("policy-map");	show.appendChild(policyMap);	Element nameNode = doc.createElement("name");	nameNode.setTextContent(name);	policyMap.appendChild(nameNode);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating the message to get policy map details 

DocumentBuilder docBuilder = docFactory.newDocumentBuilder();	DOMImplementation domImpl = docBuilder.getDOMImplementation();	Document doc = domImpl.createDocument(s_namespace, "nc:hello", null);	Element capabilities = doc.createElement("nc:capabilities");	Element capability = doc.createElement("nc:capability");	capability.setTextContent("urn:ietf:params:xml:ns:netconf:base:1.0");	capabilities.appendChild(capability);	doc.getDocumentElement().appendChild(capabilities);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while creating hello message 

Document doc = domImpl.createDocument(s_namespace, "nc:hello", null);	Element capabilities = doc.createElement("nc:capabilities");	Element capability = doc.createElement("nc:capability");	capability.setTextContent("urn:ietf:params:xml:ns:netconf:base:1.0");	capabilities.appendChild(capability);	doc.getDocumentElement().appendChild(capabilities);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while creating hello message 

doc.getDocumentElement().appendChild(editConfig);	Element target = doc.createElement("nf:target");	Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configVServiceNodeDetails(doc, vlanId, ipAddr));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	
error while adding vservice node for vlan 

Element running = doc.createElement("nf:running");	target.appendChild(running);	editConfig.appendChild(target);	Element config = doc.createElement("nf:config");	config.appendChild(configVServiceNodeDetails(doc, vlanId, ipAddr));	editConfig.appendChild(config);	return serialize(domImpl, doc);	} catch (ParserConfigurationException e) {	return null;	} catch (DOMException e) {	
error while adding vservice node for vlan 

========================= cloudstack sample_2780 =========================

final Long roleId = RoleType.getByAccountType(accountType).getId();	if (roleId < 1L || roleId > 4L) {	s_logger.warn("Skipping role ID migration due to invalid role_id resolved for account id=" + accountId);	continue;	}	try (final PreparedStatement updateStatement = conn.prepareStatement("UPDATE `cloud`.`account` SET account.role_id = ? WHERE account.id = ? ;")) {	updateStatement.setLong(1, roleId);	updateStatement.setLong(2, accountId);	updateStatement.executeUpdate();	} catch (SQLException e) {	
failed to update cloud account role id for account id with exception 

updateStatement.setLong(1, roleId);	updateStatement.setLong(2, accountId);	updateStatement.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while updating cloud.account role_id", e);	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while migrating existing account table's role_id column to a role based on account type", e);	}	
done migrating existing accounts to use one of default roles based on account type 

private void setupRolesAndPermissionsForDynamicChecker(final Connection conn) {	final String alterTableSql = "ALTER TABLE `cloud`.`account` " + "ADD COLUMN `role_id` bigint(20) unsigned COMMENT 'role id for this account' AFTER `type`, " + "ADD KEY `fk_account__role_id` (`role_id`), " + "ADD CONSTRAINT `fk_account__role_id` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`);";	try (final PreparedStatement pstmt = conn.prepareStatement(alterTableSql)) {	pstmt.executeUpdate();	} catch (SQLException e) {	if (e.getMessage().contains("role_id")) {	
cloud account table already has the role id column skipping altering table and migration of accounts 

throw new CloudRuntimeException("Unable to create column role_id in table cloud.account", e);	}	}	try (final PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud_usage`.`account` ADD COLUMN `role_id` bigint(20) unsigned AFTER `type`")) {	pstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to create column role_id in table cloud_usage.account", e);	}	migrateAccountsToDefaultRoles(conn);	if (s_logger.isDebugEnabled()) {	
configuring default role api mappings use migrate dynamicroles py instead if you want to migrate rules from an existing commands properties file 

try (final PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud_usage`.`account` ADD COLUMN `role_id` bigint(20) unsigned AFTER `type`")) {	pstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to create column role_id in table cloud_usage.account", e);	}	migrateAccountsToDefaultRoles(conn);	if (s_logger.isDebugEnabled()) {	}	String script = Script.findScript("", "db/create-default-role-api-mappings.sql");	if (script == null) {	
unable to find default role api mapping sql file please configure api per role manually 

if (s_logger.isDebugEnabled()) {	}	String script = Script.findScript("", "db/create-default-role-api-mappings.sql");	if (script == null) {	return;	}	try(final FileReader reader = new FileReader(new File(script))) {	ScriptRunner runner = new ScriptRunner(conn, false, true);	runner.runScript(reader);	} catch (SQLException | IOException e) {	
unable to insert default api role mappings from file please configure api per role manually giving up 

========================= cloudstack sample_4204 =========================

public String get(String element) throws Ovm3ResourceException {	try {	initMaps();	} catch (Ovm3ResourceException e) {	
unable to discover host 

========================= cloudstack sample_862 =========================

FilenameFilter vhdsFilt = new FilenameFilter() {	public boolean accept(final File directory, final String fileName) {	return fileName.endsWith(".vhdx") || fileName.endsWith(".vhd");	}	};	for (File file : testPoolDir.listFiles(vhdsFilt)) {	if (file.getName().equals(testVolWorks.getName())) {	continue;	}	Assert.assertTrue("Should have deleted file " + file.getPath(), file.delete());	
cleaned up by delete file 

return fileName.endsWith(".vhdx") || fileName.endsWith(".vhd");	}	};	for (File file : testPoolDir.listFiles(vhdsFilt)) {	if (file.getName().equals(testVolWorks.getName())) {	continue;	}	Assert.assertTrue("Should have deleted file " + file.getPath(), file.delete());	}	s_testSampleVolumeTempURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeTempUUID);	
created 

}	};	for (File file : testPoolDir.listFiles(vhdsFilt)) {	if (file.getName().equals(testVolWorks.getName())) {	continue;	}	Assert.assertTrue("Should have deleted file " + file.getPath(), file.delete());	}	s_testSampleVolumeTempURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeTempUUID);	s_testSampleVolumeCorruptURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeCorruptUUID);	
created 

for (File file : testPoolDir.listFiles(vhdsFilt)) {	if (file.getName().equals(testVolWorks.getName())) {	continue;	}	Assert.assertTrue("Should have deleted file " + file.getPath(), file.delete());	}	s_testSampleVolumeTempURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeTempUUID);	s_testSampleVolumeCorruptURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeCorruptUUID);	createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleTemplateUUID);	s_testSampleTemplateURLJSON = s_testSampleTemplateUUID;	
created in local storage 

if (file.getName().equals(testVolWorks.getName())) {	continue;	}	Assert.assertTrue("Should have deleted file " + file.getPath(), file.delete());	}	s_testSampleVolumeTempURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeTempUUID);	s_testSampleVolumeCorruptURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeCorruptUUID);	createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleTemplateUUID);	s_testSampleTemplateURLJSON = s_testSampleTemplateUUID;	createTestDiskImageFromExistingImage(testVolWorks, testSecondarStoreDir.getAbsolutePath(), "af39aa7f-2b12-37e1-86d3-e23f2f005101.vhdx");	
created vhdx in secondary nfs storage 

}	Assert.assertTrue("Should have deleted file " + file.getPath(), file.delete());	}	s_testSampleVolumeTempURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeTempUUID);	s_testSampleVolumeCorruptURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeCorruptUUID);	createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleTemplateUUID);	s_testSampleTemplateURLJSON = s_testSampleTemplateUUID;	createTestDiskImageFromExistingImage(testVolWorks, testSecondarStoreDir.getAbsolutePath(), "af39aa7f-2b12-37e1-86d3-e23f2f005101.vhdx");	s_testLocalStorePathJSON = s_gson.toJson(s_testLocalStorePath);	String agentIp = (String)params.get("ipaddress");	
test using agent ip address 

s_testSampleVolumeTempURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeTempUUID);	s_testSampleVolumeCorruptURIJSON = createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleVolumeCorruptUUID);	createTestDiskImageFromExistingImage(testVolWorks, s_testLocalStorePath, s_testSampleTemplateUUID);	s_testSampleTemplateURLJSON = s_testSampleTemplateUUID;	createTestDiskImageFromExistingImage(testVolWorks, testSecondarStoreDir.getAbsolutePath(), "af39aa7f-2b12-37e1-86d3-e23f2f005101.vhdx");	s_testLocalStorePathJSON = s_gson.toJson(s_testLocalStorePath);	String agentIp = (String)params.get("ipaddress");	params.put("agentIp", agentIp);	setTestJsonResult(params);	s_hypervresource.configure("hypervresource", params);	
setup complete sample storagepool at sample template at 

defaultStartRoutCmd.setCluster("1");	defaultStartRoutCmd.setGuid("1");	defaultStartRoutCmd.setName("1");	defaultStartRoutCmd.setPrivateIpAddress("1");	defaultStartRoutCmd.setStorageIpAddress("1");	defaultStartRoutCmd.setCpus(12);	defaultStartRoutCmd.setVersion("4.2.0");	StartupCommand scmd = defaultStartRoutCmd;	Command[] cmds = {scmd};	String cmdsStr = s_gson.toJson(cmds);	
commands tojson is 

defaultStartRoutCmd.setGuid("1");	defaultStartRoutCmd.setName("1");	defaultStartRoutCmd.setPrivateIpAddress("1");	defaultStartRoutCmd.setStorageIpAddress("1");	defaultStartRoutCmd.setCpus(12);	defaultStartRoutCmd.setVersion("4.2.0");	StartupCommand scmd = defaultStartRoutCmd;	Command[] cmds = {scmd};	String cmdsStr = s_gson.toJson(cmds);	Command[] result = s_gson.fromJson(cmdsStr, Command[].class);	
commands fromjson is 

defaultStartRoutCmd.setGuid("1");	defaultStartRoutCmd.setName("1");	defaultStartRoutCmd.setPrivateIpAddress("1");	defaultStartRoutCmd.setStorageIpAddress("1");	defaultStartRoutCmd.setCpus(12);	defaultStartRoutCmd.setVersion("4.2.0");	StartupCommand scmd = defaultStartRoutCmd;	Command[] cmds = {scmd};	String cmdsStr = s_gson.toJson(cmds);	Command[] result = s_gson.fromJson(cmdsStr, Command[].class);	
commands first element has type 

public final void testJson() {	StartupStorageCommand sscmd = null;	com.cloud.agent.api.StoragePoolInfo pi = new com.cloud.agent.api.StoragePoolInfo("test123", "192.168.0.1", "c:\\", "c:\\", StoragePoolType.Filesystem, 100L, 50L);	sscmd = new StartupStorageCommand();	sscmd.setPoolInfo(pi);	sscmd.setGuid(pi.getUuid());	sscmd.setDataCenter("foo");	sscmd.setResourceType(Storage.StorageResourceType.STORAGE_POOL);	
startupstoragecommand fromjson is 

public final void testCreateStoragePoolCommand() {	String folderName = "." + File.separator + "Dummy";	StoragePoolVO pool = createTestStoragePoolVO(folderName);	CreateStoragePoolCommand cmd = new CreateStoragePoolCommand(true, pool);	
testcreatestoragepoolcommand sending 

public final void testModifyStoragePoolCommand2() {	String folderName = "." + File.separator + "Dummy";	File folder = new File(folderName);	if (!folder.exists()) {	if (!folder.mkdir()) {	Assert.assertTrue(false);	}	}	
createing pool at 

public final StoragePoolVO createTestStoragePoolVO(final String folderName) {	File folder = new File(folderName);	if (!folder.exists()) {	if (!folder.mkdir()) {	Assert.assertTrue(false);	}	}	
createing pool at 

public final void testInitialize() {	StartupCommand[] startCmds = s_hypervresource.initialize();	Command[] cmds = new Command[] {startCmds[0], startCmds[1]};	String result = s_gson.toJson(cmds);	if (result == null) {	result = "NULL";	}	
testinitialize returned 

public final void testInitialize() {	StartupCommand[] startCmds = s_hypervresource.initialize();	Command[] cmds = new Command[] {startCmds[0], startCmds[1]};	String result = s_gson.toJson(cmds);	if (result == null) {	result = "NULL";	}	
testinitialize expected 

public final void testCreateCommand() {	String sample = "{\"volId\":10,\"pool\":{\"id\":201,\"uuid\":\"" + s_testLocalStoreUUID + "\",\"host\":\"10.70.176.29\"" + ",\"path\":" + s_testLocalStorePathJSON + ",\"port\":0,\"type\":\"Filesystem\"}," + "\"diskCharacteristics\":{\"size\":0," + "\"tags\":[],\"type\":\"ROOT\",\"name\":\"ROOT-9\"," + "\"useLocalStorage\":true,\"recreatable\":true," + "\"diskOfferingId\":11," + "\"volumeId\":10,\"hyperType\":\"Hyperv\"}," + "\"templateUrl\":" + s_testSampleTemplateURLJSON + ",\"contextMap\":{},\"wait\":0}";	File destDir = new File(s_testLocalStorePath);	Assert.assertTrue(destDir.isDirectory());	File testSampleTemplateURLFile = new File(s_testLocalStorePath + File.separator + s_gson.fromJson(s_testSampleTemplateURLJSON, String.class));	Assert.assertTrue("The template that create should make" + " volumes from is missing from path " + testSampleTemplateURLFile.getPath(), testSampleTemplateURLFile.exists());	int fileCount = destDir.listFiles().length;	
test local store has files 

private StartAnswer simpleVmStart(final String sample) {	StartCommand cmd = s_gson.fromJson(sample, StartCommand.class);	
startcommand sample 

public final void testGetStorageStatsCommand() {	String sample = "{\"id\":\"" + s_testLocalStoreUUID + "\",\"localPath\":" + s_testLocalStorePathJSON + "," + "\"pooltype\":\"Filesystem\"," + "\"contextMap\":{},\"wait\":0}";	
sample json 

public final void agentTerminate() {	OutputStream scriptInput = s_agentProc.getOutputStream();	OutputStreamWriter siw = new OutputStreamWriter(scriptInput);	try {	BufferedWriter writer = new BufferedWriter(siw);	writer.write("\r\n");	writer.flush();	writer.close();	} catch (IOException ex) {	
error closing agent at message 

private void agentCreation() {	try {	List<String> exeArgs = new ArrayList<String>();	exeArgs.add(s_agentExecutable);	exeArgs.add("--console");	ProcessBuilder builder = new ProcessBuilder(exeArgs);	builder.redirectErrorStream(true);	s_agentProc = builder.start();	Thread.sleep(4000);	} catch (Exception ex) {	
error calling starting aget at message 

public static Properties loadProperties() throws ConfigurationException {	Properties properties = new Properties();	final File file = PropertiesUtil.findConfigFile("agent.properties");	if (file == null) {	throw new ConfigurationException("Unable to find agent.properties.");	}	
agent properties found at 

========================= cloudstack sample_927 =========================

protected void runInContext() {	try {	work();	} catch (Throwable th) {	
problem with sg work 

protected void runInContext() {	try {	cleanupFinishedWork();	cleanupUnfinishedWork();	} catch (Throwable th) {	
problem with sg cleanup 

public void scheduleRulesetUpdateToHosts(final List<Long> affectedVms, final boolean updateSeqno, Long delayMs) {	if (affectedVms.size() == 0) {	return;	}	if (delayMs == null) {	delayMs = new Long(100l);	}	Collections.sort(affectedVms);	if (s_logger.isTraceEnabled()) {	
security group mgr scheduling ruleset updates for vms 

return;	}	if (delayMs == null) {	delayMs = new Long(100l);	}	Collections.sort(affectedVms);	if (s_logger.isTraceEnabled()) {	}	boolean locked = _workLock.lock(_globalWorkLockTimeout);	if (!locked) {	
security group mgr failed to acquire global work lock 

delayMs = new Long(100l);	}	Collections.sort(affectedVms);	if (s_logger.isTraceEnabled()) {	}	boolean locked = _workLock.lock(_globalWorkLockTimeout);	if (!locked) {	return;	}	if (s_logger.isTraceEnabled()) {	
security group mgr acquired global work lock 

if (!locked) {	return;	}	if (s_logger.isTraceEnabled()) {	}	try {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	for (Long vmId : affectedVms) {	if (s_logger.isTraceEnabled()) {	
security group mgr scheduling ruleset update for 

_workDao.update(work.getId(), work);	}	}	});	for (Long vmId : affectedVms) {	_executorPool.schedule(new WorkerThread(), delayMs, TimeUnit.MILLISECONDS);	}	} finally {	_workLock.unlock();	if (s_logger.isTraceEnabled()) {	
security group mgr released global work lock 

s_logger.warn("Could not acquire lock on network security group: id= " + securityGroupId);	return null;	}	List<SecurityGroupRuleVO> newRules = new ArrayList<SecurityGroupRuleVO>();	try {	for (final SecurityGroupVO ngVO : authorizedGroups2) {	final Long ngId = ngVO.getId();	if (ngVO.getId() != securityGroup.getId()) {	final SecurityGroupVO tmpGrp = _securityGroupDao.lockRow(ngId, false);	if (tmpGrp == null) {	
failed to acquire lock on security group 

SecurityGroupRuleVO securityGroupRule = _securityGroupRuleDao.findByProtoPortsAndCidr(securityGroup.getId(), protocolFinal, startPortOrTypeFinal, endPortOrCodeFinal, cidr);	if ((securityGroupRule != null) && (securityGroupRule.getRuleType() == ruleType)) {	continue;	}	securityGroupRule = new SecurityGroupRuleVO(ruleType, securityGroup.getId(), startPortOrTypeFinal, endPortOrCodeFinal, protocolFinal, cidr);	securityGroupRule = _securityGroupRuleDao.persist(securityGroupRule);	newRules.add(securityGroupRule);	}	}	if (s_logger.isDebugEnabled()) {	
added rules to security group 

}	securityGroupRule = new SecurityGroupRuleVO(ruleType, securityGroup.getId(), startPortOrTypeFinal, endPortOrCodeFinal, protocolFinal, cidr);	securityGroupRule = _securityGroupRuleDao.persist(securityGroupRule);	newRules.add(securityGroupRule);	}	}	if (s_logger.isDebugEnabled()) {	}	return newRules;	} catch (Exception e) {	
exception caught when adding security group rules 

_securityGroupDao.releaseFromLockTable(securityGroup.getId());	}	}	}	});	try {	final ArrayList<Long> affectedVms = new ArrayList<Long>();	affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(securityGroup.getId()));	scheduleRulesetUpdateToHosts(affectedVms, true, null);	} catch (Exception e) {	
can t update rules on host ignore 

private boolean revokeSecurityGroupRule(final Long id, SecurityRuleType type) {	Account caller = CallContext.current().getCallingAccount();	final SecurityGroupRuleVO rule = _securityGroupRuleDao.findById(id);	if (rule == null) {	
unable to find security rule with id 

private boolean revokeSecurityGroupRule(final Long id, SecurityRuleType type) {	Account caller = CallContext.current().getCallingAccount();	final SecurityGroupRuleVO rule = _securityGroupRuleDao.findById(id);	if (rule == null) {	throw new InvalidParameterValueException("Unable to find security rule with id " + id);	}	if (type != rule.getRuleType()) {	
mismatch in rule type for security rule with id 

}	SecurityGroup securityGroup = _securityGroupDao.findById(rule.getSecurityGroupId());	_accountMgr.checkAccess(caller, AccessType.OperateEntry, true, securityGroup);	long securityGroupId = rule.getSecurityGroupId();	Boolean result = Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	SecurityGroupVO groupHandle = null;	try {	groupHandle = _securityGroupDao.acquireInLockTable(rule.getSecurityGroupId());	if (groupHandle == null) {	
could not acquire lock on security group id 

long securityGroupId = rule.getSecurityGroupId();	Boolean result = Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	SecurityGroupVO groupHandle = null;	try {	groupHandle = _securityGroupDao.acquireInLockTable(rule.getSecurityGroupId());	if (groupHandle == null) {	return false;	}	_securityGroupRuleDao.remove(id);	
revokesecuritygrouprule succeeded for security rule id 

public Boolean doInTransaction(TransactionStatus status) {	SecurityGroupVO groupHandle = null;	try {	groupHandle = _securityGroupDao.acquireInLockTable(rule.getSecurityGroupId());	if (groupHandle == null) {	return false;	}	_securityGroupRuleDao.remove(id);	return true;	} catch (Exception e) {	
exception caught when deleting security rules 

_securityGroupDao.releaseFromLockTable(groupHandle.getId());	}	}	}	});	try {	final ArrayList<Long> affectedVms = new ArrayList<Long>();	affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(securityGroupId));	scheduleRulesetUpdateToHosts(affectedVms, true, null);	} catch (Exception e) {	
can t update rules for host ignore 

public void work() {	if (s_logger.isTraceEnabled()) {	
checking the database 

public void work() {	if (s_logger.isTraceEnabled()) {	}	final SecurityGroupWorkVO work = _workDao.take(_serverId);	if (work == null) {	if (s_logger.isTraceEnabled()) {	
security group work no work found 

}	final SecurityGroupWorkVO work = _workDao.take(_serverId);	if (work == null) {	if (s_logger.isTraceEnabled()) {	}	return;	}	final Long userVmId = work.getInstanceId();	if (work.getStep() == Step.Done) {	if (s_logger.isDebugEnabled()) {	
security group work found a job in done state rescheduling for vm 

}	final Long userVmId = work.getInstanceId();	if (work.getStep() == Step.Done) {	if (s_logger.isDebugEnabled()) {	}	ArrayList<Long> affectedVms = new ArrayList<Long>();	affectedVms.add(userVmId);	scheduleRulesetUpdateToHosts(affectedVms, false, _timeBetweenCleanups * 1000l);	return;	}	
working on 

Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	UserVm vm = null;	Long seqnum = null;	boolean locked = false;	try {	vm = _userVMDao.acquireInLockTable(work.getInstanceId());	if (vm == null) {	vm = _userVMDao.findById(work.getInstanceId());	if (vm == null) {	
vm is removed 

public boolean addInstanceToGroups(final Long userVmId, final List<Long> groups) {	if (!isVmSecurityGroupEnabled(userVmId)) {	
user vm is not security group enabled not adding it to security group 

s_logger.trace("No security groups found for vm id=" + userVmId + ", returning");	return;	}	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	UserVm userVm = _userVMDao.acquireInLockTable(userVmId);	if (userVm == null) {	s_logger.warn("Failed to acquire lock on user vm id=" + userVmId);	}	int n = _securityGroupVMMapDao.deleteVM(userVmId);	
disassociated network groups from uservm 

ArrayList<Long> affectedVms = new ArrayList<Long>();	for (String vmName : newGroupStates.keySet()) {	Long vmId = newGroupStates.get(vmName).first();	Long seqno = newGroupStates.get(vmName).second();	VmRulesetLogVO log = _rulesetLogDao.findByVmId(vmId);	if (log != null && log.getLogsequence() != seqno) {	affectedVms.add(vmId);	}	}	if (affectedVms.size() > 0) {	
network group full sync for agent found vms out of sync 

public void cleanupFinishedWork() {	Date before = new Date(System.currentTimeMillis() - 6 * 3600 * 1000l);	int numDeleted = _workDao.deleteFinishedWork(before);	if (numDeleted > 0) {	
network group work cleanup deleted finished work items older than 

private void cleanupUnfinishedWork() {	Date before = new Date(System.currentTimeMillis() - 2 * _timeBetweenCleanups * 1000l);	List<SecurityGroupWorkVO> unfinished = _workDao.findUnfinishedWork(before);	if (unfinished.size() > 0) {	
network group work cleanup found unfinished work items older than 

List<SecurityGroupWorkVO> unfinished = _workDao.findUnfinishedWork(before);	if (unfinished.size() > 0) {	ArrayList<Long> affectedVms = new ArrayList<Long>();	for (SecurityGroupWorkVO work : unfinished) {	affectedVms.add(work.getInstanceId());	work.setStep(Step.Error);	_workDao.update(work.getId(), work);	}	scheduleRulesetUpdateToHosts(affectedVms, false, null);	} else {	
network group work cleanup found no unfinished work items older than 

private void processScheduledWork() {	List<SecurityGroupWorkVO> scheduled = _workDao.findScheduledWork();	int numJobs = scheduled.size();	if (numJobs > 0) {	
security group work found scheduled jobs 

SecurityGroupVO currentNetworkGroup = _securityGroupDao.findById(nG.getSecurityGroupId());	networkGroupNames.append(currentNetworkGroup.getName());	if (j < (size - 1)) {	networkGroupNames.append(",");	j++;	}	}	}	return networkGroupNames.toString();	} catch (Exception e) {	
error trying to get network groups for a vm 

public boolean postStateTransitionEvent(StateMachine2.Transition<State, Event> transition, VirtualMachine vm, boolean status, Object opaque) {	if (!status) {	return false;	}	State oldState = transition.getCurrentState();	State newState = transition.getToState();	Event event = transition.getEvent();	if (VirtualMachine.State.isVmStarted(oldState, event, newState)) {	if (s_logger.isTraceEnabled()) {	
security group mgr handling start of vm id 

}	State oldState = transition.getCurrentState();	State newState = transition.getToState();	Event event = transition.getEvent();	if (VirtualMachine.State.isVmStarted(oldState, event, newState)) {	if (s_logger.isTraceEnabled()) {	}	handleVmStarted((VMInstanceVO)vm);	} else if (VirtualMachine.State.isVmStopped(oldState, event, newState)) {	if (s_logger.isTraceEnabled()) {	
security group mgr handling stop of vm id 

if (VirtualMachine.State.isVmStarted(oldState, event, newState)) {	if (s_logger.isTraceEnabled()) {	}	handleVmStarted((VMInstanceVO)vm);	} else if (VirtualMachine.State.isVmStopped(oldState, event, newState)) {	if (s_logger.isTraceEnabled()) {	}	handleVmStopped((VMInstanceVO)vm);	} else if (VirtualMachine.State.isVmMigrated(oldState, event, newState)) {	if (s_logger.isTraceEnabled()) {	
security group mgr handling migration of vm id 

}	NicVO nic = _nicDao.findById(nicId);	long vmId = nic.getInstanceId();	UserVm vm = _userVMDao.findById(vmId);	if (vm == null || vm.getType() != VirtualMachine.Type.User) {	throw new InvalidParameterValueException("Can't configure the SG ipset, arprules rules for the non existing or non user vm");	}	_accountMgr.checkAccess(caller, null, false, vm);	List<SecurityGroupVO> vmSgGrps = getSecurityGroupsForVm(vmId);	if (vmSgGrps.isEmpty()) {	
vm is not in any security group 

if (vm == null || vm.getType() != VirtualMachine.Type.User) {	throw new InvalidParameterValueException("Can't configure the SG ipset, arprules rules for the non existing or non user vm");	}	_accountMgr.checkAccess(caller, null, false, vm);	List<SecurityGroupVO> vmSgGrps = getSecurityGroupsForVm(vmId);	if (vmSgGrps.isEmpty()) {	return true;	}	Network network = _networkModel.getNetwork(nic.getNetworkId());	if (!_networkModel.isSecurityGroupSupportedInNetwork(network)) {	
network is not enabled with security group service so not applying sg rules for secondary ip 

Network network = _networkModel.getNetwork(nic.getNetworkId());	if (!_networkModel.isSecurityGroupSupportedInNetwork(network)) {	return true;	}	String vmMac = vm.getPrivateMacAddress();	String vmName = vm.getInstanceName();	if (vmMac == null || vmName == null) {	throw new InvalidParameterValueException("vm name or vm mac can't be null");	}	NetworkRulesVmSecondaryIpCommand cmd = new NetworkRulesVmSecondaryIpCommand(vmName, vmMac, secondaryIp, ruleAction);	
asking agent to configure rules for vm secondary ip 

========================= cloudstack sample_2295 =========================

getUploadListener().log("handleTimeout, updateMs=" + updateMs + ", curr state= " + getName(), Level.TRACE);	}	String newState = getName();	if (updateMs > 5 * UploadListener.STATUS_POLL_INTERVAL) {	newState = Status.UPLOAD_ERROR.toString();	getUploadListener().log("timeout: transitioning to upload error state, currstate=" + getName(), Level.DEBUG);	} else if (updateMs > 3 * UploadListener.STATUS_POLL_INTERVAL) {	getUploadListener().cancelStatusTask();	getUploadListener().scheduleImmediateStatusCheck(RequestType.GET_STATUS);	getUploadListener().scheduleTimeoutTask(3 * UploadListener.STATUS_POLL_INTERVAL);	
first timeout checking again 

========================= cloudstack sample_2446 =========================

private static String encodeParam(String value) {	if (!ApiServer.isEncodeApiResponse()) {	return value;	}	try {	return new URLEncoder().encode(value).replaceAll("\\+", "%20");	} catch (Exception e) {	
unable to encode 

========================= cloudstack sample_2503 =========================

public static int getCSErrCode(String exceptionName) {	if (ExceptionErrorCodeMap.containsKey(exceptionName)) {	return ExceptionErrorCodeMap.get(exceptionName);	} else {	
could not find exception in error code list for exceptions 

========================= cloudstack sample_2850 =========================

sql = SUBTRACT_ALLOCATED_SQL;	}	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, allocatedAmount);	pstmt.setLong(2, hostId);	pstmt.setShort(3, capacityType);	pstmt.executeUpdate();	txn.commit();	} catch (Exception e) {	txn.rollback();	
exception updating capacity for host 

pstmt.setString(i, capacityState);	i = i + 1;	for (int j=0 ; j < resourceIdList.size(); j++, i++) {	pstmt.setLong(i, resourceIdList.get(j));	}	for(int j=0; j < capacityType.length; i++, j++ ) {	pstmt.setShort(i, capacityType[j]);	}	pstmt.executeUpdate();	} catch (Exception e) {	
error updating capacityvo 

try {	pstmt = txn.prepareAutoCloseStatement(sql.toString());	pstmt.setLong(1, computeRequested);	pstmt.setLong(2, clusterId);	pstmt.setShort(3, capacityType);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	return rs.getFloat(1);	}	} catch (Exception e) {	
error checking cluster threshold 

========================= cloudstack sample_4603 =========================

private boolean canHandle(Network network, Service service) {	DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if ((zone.getNetworkType() == NetworkType.Advanced && !(network.getGuestType() == Network.GuestType.Isolated || network.getGuestType() == Network.GuestType.Shared)) || (zone.getNetworkType() == NetworkType.Basic && network.getGuestType() != Network.GuestType.Shared)) {	s_logger.trace("Element " + getProvider().getName() + "is not handling network type = " + network.getGuestType());	return false;	}	if (service == null) {	if (!_networkManager.isProviderForNetwork(getProvider(), network.getId())) {	
element is not a provider for the network 

if ((zone.getNetworkType() == NetworkType.Advanced && !(network.getGuestType() == Network.GuestType.Isolated || network.getGuestType() == Network.GuestType.Shared)) || (zone.getNetworkType() == NetworkType.Basic && network.getGuestType() != Network.GuestType.Shared)) {	s_logger.trace("Element " + getProvider().getName() + "is not handling network type = " + network.getGuestType());	return false;	}	if (service == null) {	if (!_networkManager.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	} else {	if (!_networkManager.isProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {	
element doesn t support service in the network 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ResourceUnavailableException, ConcurrentOperationException, InsufficientNetworkCapacityException {	DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	
not handling network implement in zone of type 

DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	return false;	}	if (!canHandle(network, null)) {	return false;	}	try {	return manageGuestNetworkWithExternalFirewall(true, network);	} catch (InsufficientCapacityException capacityException) {	
fail to implement the junipersrx for network 

public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ResourceUnavailableException, ConcurrentOperationException {	DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	
not handling network shutdown in zone of type 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Firewall)) {	
srx must be used as firewall service provider in the network 

========================= cloudstack sample_1401 =========================

public boolean isVmAlive(com.cloud.vm.VirtualMachine vm, Host host) throws UnknownVM {	
isvmalive on 

public Status isAgentAlive(Host agent) {	
isagentalive 

for (HostVO neighbor : neighbors) {	if (neighbor.getId() == agent.getId() || neighbor.getHypervisorType() != Hypervisor.HypervisorType.Ovm3) {	continue;	}	try {	Answer answer = agentMgr.easySend(neighbor.getId(), cmd);	if (answer != null) {	return answer.getResult() ? Status.Down : Status.Up;	}	} catch (Exception e) {	
failed to send command to host 

========================= cloudstack sample_835 =========================

Answer answer = agentMgr.easySend(hostId, cmd);	if (answer == null) {	throw new CloudRuntimeException("Unable to get an answer to the modify storage pool command for storage pool: " + storagePool.getId());	}	if (!answer.getResult()) {	String msg = "Unable to attach storage pool " + storagePool.getId() + " to the host " + hostId;	alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, storagePool.getDataCenterId(), storagePool.getPodId(), msg, msg);	throw new CloudRuntimeException(msg);	}	assert (answer instanceof ModifyStoragePoolAnswer) : "ModifyStoragePoolAnswer not returned from ModifyStoragePoolCommand; Storage pool = " + storagePool.getId() + "; Host = " + hostId;	
connection established between storage pool and host 

========================= cloudstack sample_1952 =========================

public Object callTimeoutInSec(String method, Object[] params, int timeout, boolean debug) throws XmlRpcException {	TimingOutCallback callback = new TimingOutCallback(timeout * 1000);	Object[] mParams = new Object[params.length + 1];	mParams[0] = method;	for (int i = 0; i < params.length; i++) {	mParams[i + 1] = params[i];	}	if (debug) {	
call ovm agent 

========================= cloudstack sample_1114 =========================

public void dropKey(Connection conn, String tableName, String key, boolean isForeignKey) {	String alter_sql_str;	if (isForeignKey) {	alter_sql_str = "ALTER TABLE " + tableName + " DROP FOREIGN KEY " + key;	} else {	alter_sql_str = "ALTER TABLE " + tableName + " DROP KEY " + key;	}	try(PreparedStatement pstmt = conn.prepareStatement(alter_sql_str);) {	pstmt.executeUpdate();	
key is dropped successfully from the table 

public void dropKey(Connection conn, String tableName, String key, boolean isForeignKey) {	String alter_sql_str;	if (isForeignKey) {	alter_sql_str = "ALTER TABLE " + tableName + " DROP FOREIGN KEY " + key;	} else {	alter_sql_str = "ALTER TABLE " + tableName + " DROP KEY " + key;	}	try(PreparedStatement pstmt = conn.prepareStatement(alter_sql_str);) {	pstmt.executeUpdate();	} catch (SQLException e) {	
ignored sql exception when trying to drop foreign key on table exception 

public void dropPrimaryKey(Connection conn, String tableName) {	try(PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE " + tableName + " DROP PRIMARY KEY ");) {	pstmt.executeUpdate();	
primary key is dropped successfully from the table 

public void dropPrimaryKey(Connection conn, String tableName) {	try(PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE " + tableName + " DROP PRIMARY KEY ");) {	pstmt.executeUpdate();	} catch (SQLException e) {	
ignored sql exception when trying to drop primary key on table exception 

public void dropColumn(Connection conn, String tableName, String columnName) {	try (PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE " + tableName + " DROP COLUMN " + columnName);){	pstmt.executeUpdate();	
column is dropped successfully from the table 

public void dropColumn(Connection conn, String tableName, String columnName) {	try (PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE " + tableName + " DROP COLUMN " + columnName);){	pstmt.executeUpdate();	} catch (SQLException e) {	
unable to drop column due to exception 

public boolean columnExists(Connection conn, String tableName, String columnName) {	boolean columnExists = false;	try (PreparedStatement pstmt = conn.prepareStatement("SELECT " + columnName + " FROM " + tableName);){	pstmt.executeQuery();	columnExists = true;	} catch (SQLException e) {	
field doesn t exist in ignoring exception 

========================= cloudstack sample_4195 =========================

private boolean refreshVnmcConnection() {	boolean ret = false;	try {	ret = _connection.login();	} catch (ExecutionException ex) {	
login to vnmc failed 

private Answer execute(ConfigureNexusVsmForAsaCommand cmd, int numRetries) {	String vlanId = Long.toString(cmd.getVlanId());	NetconfHelper helper = null;	List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	params.add(new Pair<OperationType, String>(OperationType.addvlanid, vlanId));	try {	helper = new NetconfHelper(cmd.getVsmIp(), cmd.getVsmUsername(), cmd.getVsmPassword());	
connected to cisco vsm 

private Answer execute(ConfigureNexusVsmForAsaCommand cmd, int numRetries) {	String vlanId = Long.toString(cmd.getVlanId());	NetconfHelper helper = null;	List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	params.add(new Pair<OperationType, String>(OperationType.addvlanid, vlanId));	try {	helper = new NetconfHelper(cmd.getVsmIp(), cmd.getVsmUsername(), cmd.getVsmPassword());	helper.addVServiceNode(vlanId, cmd.getIpAddress());	
created vservice node for asa appliance in cisco vsm for vlan 

private Answer execute(ConfigureNexusVsmForAsaCommand cmd, int numRetries) {	String vlanId = Long.toString(cmd.getVlanId());	NetconfHelper helper = null;	List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	params.add(new Pair<OperationType, String>(OperationType.addvlanid, vlanId));	try {	helper = new NetconfHelper(cmd.getVsmIp(), cmd.getVsmUsername(), cmd.getVsmPassword());	helper.addVServiceNode(vlanId, cmd.getIpAddress());	helper.updatePortProfile(cmd.getAsaInPortProfile(), SwitchPortMode.access, params);	
updated inside port profile for asa appliance in cisco vsm with new vlan 

========================= cloudstack sample_1682 =========================

pstmt.setLong(4, usage.getSecurityGroupId());	pstmt.executeUpdate();	}	}catch (SQLException e) {	throw new CloudException("Error updating UsageSecurityGroupVO:"+e.getMessage(), e);	}	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usagesecuritygroupvo 

if (deletedTS != null) {	deletedDate = DateUtil.parseDateString(s_gmtTimeZone, deletedTS);	}	usageRecords.add(new UsageSecurityGroupVO(zoneId, acctId, dId, vmId, sgId, createdDate, deletedDate));	}	}catch (SQLException e) {	throw new CloudException("Error getting usage records"+e.getMessage(), e);	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4480 =========================

public boolean start() {	if (isSAMLPluginEnabled()) {	
saml auth plugin loaded 

public boolean start() {	if (isSAMLPluginEnabled()) {	return setup();	} else {	
saml auth plugin not enabled so not loading 

protected boolean initSP() {	KeystoreVO keyStoreVO = _ksDao.findByName(SAMLPluginConstants.SAMLSP_KEYPAIR);	if (keyStoreVO == null) {	try {	KeyPair keyPair = SAMLUtils.generateRandomKeyPair();	_ksDao.save(SAMLPluginConstants.SAMLSP_KEYPAIR, SAMLUtils.savePrivateKey(keyPair.getPrivate()), SAMLUtils.savePublicKey(keyPair.getPublic()), "samlsp-keypair");	keyStoreVO = _ksDao.findByName(SAMLPluginConstants.SAMLSP_KEYPAIR);	
no saml keystore found created and saved a new service provider keypair 

protected boolean initSP() {	KeystoreVO keyStoreVO = _ksDao.findByName(SAMLPluginConstants.SAMLSP_KEYPAIR);	if (keyStoreVO == null) {	try {	KeyPair keyPair = SAMLUtils.generateRandomKeyPair();	_ksDao.save(SAMLPluginConstants.SAMLSP_KEYPAIR, SAMLUtils.savePrivateKey(keyPair.getPrivate()), SAMLUtils.savePublicKey(keyPair.getPublic()), "samlsp-keypair");	keyStoreVO = _ksDao.findByName(SAMLPluginConstants.SAMLSP_KEYPAIR);	} catch (NoSuchProviderException | NoSuchAlgorithmException e) {	
unable to create and save saml keypair 

if (x509VO == null) {	try {	spX509Key = SAMLUtils.generateRandomX509Certificate(spKeyPair);	ByteArrayOutputStream bos = new ByteArrayOutputStream();	ObjectOutput out = new ObjectOutputStream(bos);	out.writeObject(spX509Key);	out.flush();	_ksDao.save(SAMLPluginConstants.SAMLSP_X509CERT, Base64.encodeBase64String(bos.toByteArray()), "", "samlsp-x509cert");	bos.close();	} catch (NoSuchAlgorithmException | NoSuchProviderException | CertificateEncodingException | SignatureException | InvalidKeyException | IOException e) {	
saml plugin won t be able to use signed authentication 

bos.close();	} catch (NoSuchAlgorithmException | NoSuchProviderException | CertificateEncodingException | SignatureException | InvalidKeyException | IOException e) {	}	} else {	try {	ByteArrayInputStream bi = new ByteArrayInputStream(Base64.decodeBase64(x509VO.getCertificate()));	ObjectInputStream si = new ObjectInputStream(bi);	spX509Key = (X509Certificate) si.readObject();	bi.close();	} catch (IOException | ClassNotFoundException ignored) {	
saml plugin won t be able to use signed authentication failed to load certificate from database 

private void addIdpToMap(EntityDescriptor descriptor, Map<String, SAMLProviderMetadata> idpMap) {	SAMLProviderMetadata idpMetadata = new SAMLProviderMetadata();	idpMetadata.setEntityId(descriptor.getEntityID());	
adding idp to the list of discovered idps 

}	}	}	X509Certificate unspecifiedKey = null;	if (idpDescriptor.getKeyDescriptors() != null) {	for (KeyDescriptor kd : idpDescriptor.getKeyDescriptors()) {	if (kd.getUse() == UsageType.SIGNING) {	try {	idpMetadata.setSigningCertificate(KeyInfoHelper.getCertificates(kd.getKeyInfo()).get(0));	} catch (CertificateException ignored) {	
ignored encountered invalid certificate signing 

if (kd.getUse() == UsageType.SIGNING) {	try {	idpMetadata.setSigningCertificate(KeyInfoHelper.getCertificates(kd.getKeyInfo()).get(0));	} catch (CertificateException ignored) {	}	}	if (kd.getUse() == UsageType.ENCRYPTION) {	try {	idpMetadata.setEncryptionCertificate(KeyInfoHelper.getCertificates(kd.getKeyInfo()).get(0));	} catch (CertificateException ignored) {	
ignored encountered invalid certificate encryption 

if (kd.getUse() == UsageType.ENCRYPTION) {	try {	idpMetadata.setEncryptionCertificate(KeyInfoHelper.getCertificates(kd.getKeyInfo()).get(0));	} catch (CertificateException ignored) {	}	}	if (kd.getUse() == UsageType.UNSPECIFIED) {	try {	unspecifiedKey = KeyInfoHelper.getCertificates(kd.getKeyInfo()).get(0);	} catch (CertificateException ignored) {	
ignored encountered invalid certificate 

}	}	}	if (idpMetadata.getSigningCertificate() == null && unspecifiedKey != null) {	idpMetadata.setSigningCertificate(unspecifiedKey);	}	if (idpMetadata.getEncryptionCertificate() == null && unspecifiedKey != null) {	idpMetadata.setEncryptionCertificate(unspecifiedKey);	}	if (idpMap.containsKey(idpMetadata.getEntityId())) {	
duplicate idp metadata found with entity id 

public void run() {	if (_idpMetaDataProvider == null) {	return;	}	
starting saml idp metadata refresh task 

public void run() {	if (_idpMetaDataProvider == null) {	return;	}	Map <String, SAMLProviderMetadata> metadataMap = new HashMap<String, SAMLProviderMetadata>();	try {	discoverAndAddIdp(_idpMetaDataProvider.getMetadata(), metadataMap);	_idpMetadataMap = metadataMap;	expireTokens();	
finished refreshing saml metadata and expiring old auth tokens 

public void run() {	if (_idpMetaDataProvider == null) {	return;	}	Map <String, SAMLProviderMetadata> metadataMap = new HashMap<String, SAMLProviderMetadata>();	try {	discoverAndAddIdp(_idpMetaDataProvider.getMetadata(), metadataMap);	_idpMetadataMap = metadataMap;	expireTokens();	} catch (MetadataProviderException e) {	
saml metadata refresh task failed with exception 

private boolean setup() {	if (!initSP()) {	
saml plugin failed to initialize please fix the configuration and restart management server 

if (SAMLTimeout.value() != null && SAMLTimeout.value() > SAMLPluginConstants.SAML_REFRESH_INTERVAL) {	_refreshInterval = SAMLTimeout.value();	}	try {	DefaultBootstrap.bootstrap();	if (idpMetaDataUrl.startsWith("http")) {	_idpMetaDataProvider = new HTTPMetadataProvider(_timer, client, idpMetaDataUrl);	} else {	File metadataFile = PropertiesUtil.findConfigFile(idpMetaDataUrl);	if (metadataFile == null) {	
provided metadata is not a url unable to locate metadata file from local path 

try {	DefaultBootstrap.bootstrap();	if (idpMetaDataUrl.startsWith("http")) {	_idpMetaDataProvider = new HTTPMetadataProvider(_timer, client, idpMetaDataUrl);	} else {	File metadataFile = PropertiesUtil.findConfigFile(idpMetaDataUrl);	if (metadataFile == null) {	return false;	}	else{	
provided metadata is not a url trying to read metadata file from local path 

}	else{	_idpMetaDataProvider = new FilesystemMetadataProvider(_timer, metadataFile);	}	}	_idpMetaDataProvider.setRequireValidMetadata(true);	_idpMetaDataProvider.setParserPool(new BasicParserPool());	_idpMetaDataProvider.initialize();	_timer.scheduleAtFixedRate(new MetadataRefreshTask(), 0, _refreshInterval * 1000);	} catch (MetadataProviderException e) {	
unable to read idp metadata url error 

}	else{	_idpMetaDataProvider = new FilesystemMetadataProvider(_timer, metadataFile);	}	}	_idpMetaDataProvider.setRequireValidMetadata(true);	_idpMetaDataProvider.setParserPool(new BasicParserPool());	_idpMetaDataProvider.initialize();	_timer.scheduleAtFixedRate(new MetadataRefreshTask(), 0, _refreshInterval * 1000);	} catch (MetadataProviderException e) {	
authentication may be unavailable 

_idpMetaDataProvider = new FilesystemMetadataProvider(_timer, metadataFile);	}	}	_idpMetaDataProvider.setRequireValidMetadata(true);	_idpMetaDataProvider.setParserPool(new BasicParserPool());	_idpMetaDataProvider.initialize();	_timer.scheduleAtFixedRate(new MetadataRefreshTask(), 0, _refreshInterval * 1000);	} catch (MetadataProviderException e) {	return false;	} catch (ConfigurationException | FactoryConfigurationError e) {	
opensaml bootstrapping failed error 

}	_idpMetaDataProvider.setRequireValidMetadata(true);	_idpMetaDataProvider.setParserPool(new BasicParserPool());	_idpMetaDataProvider.initialize();	_timer.scheduleAtFixedRate(new MetadataRefreshTask(), 0, _refreshInterval * 1000);	} catch (MetadataProviderException e) {	return false;	} catch (ConfigurationException | FactoryConfigurationError e) {	return false;	} catch (NullPointerException e) {	
unable to setup saml auth plugin due to nullpointerexception please check the saml global settings 

========================= cloudstack sample_1378 =========================

public static DecodedDataObject decode(String url) throws URISyntaxException {	URI uri = new URI(url);	Map<String, String> params = getParameters(uri);	DecodedDataStore store = new DecodedDataStore(params.get(EncodingType.ROLE.toString()), params.get(EncodingType.STOREUUID.toString()), params.get(EncodingType.PROVIDERNAME.toString()), uri.getScheme(), uri.getScheme() + uri.getHost() + uri.getPath(), uri.getHost(), uri.getPath());	Long size = null;	try {	size = Long.parseLong(params.get(EncodingType.SIZE.toString()));	} catch (NumberFormatException e) {	
ignored number not recognised 

========================= cloudstack sample_2807 =========================

public VmwareContext(VmwareClient client, String address) {	assert (client != null) : "Invalid parameter in constructing VmwareContext object";	_vimClient = client;	_serverAddress = address;	registerOutstandingContext();	
new vmwarecontext object current outstanding count 

pSpec.getPathSet().add("name");	TraversalSpec clusterHostTraversal = new TraversalSpec();	clusterHostTraversal.setType("ClusterComputeResource");	clusterHostTraversal.setPath("host");	clusterHostTraversal.setName("folderChildrenTraversal");	oSpec = new ObjectSpec();	oSpec.setObj(mor);	oSpec.setSkip(Boolean.TRUE);	oSpec.getSelectSet().add(clusterHostTraversal);	} else {	
invalid inventory path path element can only be datacenter and folder 

for (ObjectContent oc : ocs) {	String name = oc.getPropSet().get(0).getVal().toString();	if (name.equalsIgnoreCase(token) || name.equalsIgnoreCase("host")) {	mor = oc.getObj();	found = true;	if (name.equalsIgnoreCase("host")) i--;	break;	}	}	if (!found) {	
path element points to an un existing inventory entity 

mor = oc.getObj();	found = true;	if (name.equalsIgnoreCase("host")) i--;	break;	}	}	if (!found) {	return null;	}	} else {	
path element points to an un existing inventory entity 

public ManagedObjectReference getDatastoreMorByPath(String inventoryPath) throws Exception {	assert (inventoryPath != null);	String[] tokens;	if (inventoryPath.startsWith("/")) tokens = inventoryPath.substring(1).split("/");	else tokens = inventoryPath.split("/");	if (tokens == null || tokens.length != 2) {	
invalid datastore inventory path path 

public ManagedObjectReference getDatastoreMorByPath(String inventoryPath) throws Exception {	assert (inventoryPath != null);	String[] tokens;	if (inventoryPath.startsWith("/")) tokens = inventoryPath.substring(1).split("/");	else tokens = inventoryPath.split("/");	if (tokens == null || tokens.length != 2) {	return null;	}	DatacenterMO dcMo = new DatacenterMO(this, tokens[0]);	if (dcMo.getMor() == null) {	
unable to locate the datacenter specified in path 

in = new FileInputStream(localFile);	byte[] buf = new byte[ChunkSize];	int len = 0;	while ((len = in.read(buf)) > 0) {	out.write(buf, 0, len);	}	out.flush();	br = new BufferedReader(new InputStreamReader(conn.getInputStream(), getCharSetFromConnection(conn)));	String line;	while ((line = br.readLine()) != null) {	
upload response 

private Charset getCharSetFromConnection(HttpURLConnection conn) {	String charsetName = conn.getContentEncoding();	Charset charset;	try {	charset = Charset.forName(charsetName);	} catch (IllegalArgumentException e) {	
illegal unsupported null charset name from connection charsetname from connection is 

public long downloadVmdkFile(String urlString, String localFileName, long totalBytesDownloaded, ActionDelegate<Long> progressUpdater) throws Exception {	HttpURLConnection conn = getRawHTTPConnection(urlString);	String cookie = _vimClient.getServiceCookie();	if (cookie == null) {	
no cookie is found in vwware web service request context 

public void uploadResourceContent(String urlString, byte[] content) throws Exception {	HttpURLConnection conn = getHTTPConnection(urlString, "PUT");	OutputStream out = conn.getOutputStream();	out.write(content);	out.flush();	BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), getCharSetFromConnection(conn)));	String line;	while ((in.ready()) && (line = in.readLine()) != null) {	
upload response 

assert (relativePath != null);	assert (datastoreName != null);	StringBuffer sb = new StringBuffer();	sb.append("https: sb.append(_serverAddress);	sb.append("/folder/");	sb.append(relativePath);	try {	sb.append("?dcPath=").append(URLEncoder.encode(dcName, "UTF-8"));	sb.append("&dsName=").append(URLEncoder.encode(datastoreName, "UTF-8"));	} catch (UnsupportedEncodingException e) {	
unable to encode url dcpath dsname 

public HttpURLConnection getHTTPConnection(String urlString, String httpMethod) throws Exception {	String cookie = _vimClient.getServiceCookie();	if (cookie == null) {	
no cookie is found in vmware web service request context 

private static void connectWithRetry(HttpURLConnection conn) throws Exception {	boolean connected = false;	for (int i = 0; i < MAX_CONNECT_RETRY && !connected; i++) {	try {	conn.connect();	connected = true;	
connected conn retry 

private static void connectWithRetry(HttpURLConnection conn) throws Exception {	boolean connected = false;	for (int i = 0; i < MAX_CONNECT_RETRY && !connected; i++) {	try {	conn.connect();	connected = true;	} catch (Exception e) {	
unable to connect conn message retry 

private static void connectWithRetry(HttpURLConnection conn) throws Exception {	boolean connected = false;	for (int i = 0; i < MAX_CONNECT_RETRY && !connected; i++) {	try {	conn.connect();	connected = true;	} catch (Exception e) {	try {	Thread.sleep(CONNECT_RETRY_INTERVAL);	} catch (InterruptedException ex) {	
ignored interupted while connecting 

public void close() {	clearStockObjects();	try {	
disconnecting vmware session 

public void close() {	clearStockObjects();	try {	_vimClient.disconnect();	} catch(SOAPFaultException sfe) {	
tried to disconnect a session that is no longer valid 

public void close() {	clearStockObjects();	try {	_vimClient.disconnect();	} catch(SOAPFaultException sfe) {	} catch (Exception e) {	
unexpected exception 

========================= cloudstack sample_2104 =========================

public void onFramebufferUpdate(int x, int y, int w, int h) {	
frame buffer update 

private String prepareAjaxImage(List<TileInfo> tiles, boolean init) {	byte[] imgBits;	if (init) imgBits = getFrameBufferJpeg();	else imgBits = getTilesMergedJpeg(tiles, tracker.getTileWidth(), tracker.getTileHeight());	if (imgBits == null) {	
unable to generate jpeg image 

private String prepareAjaxImage(List<TileInfo> tiles, boolean init) {	byte[] imgBits;	if (init) imgBits = getFrameBufferJpeg();	else imgBits = getTilesMergedJpeg(tiles, tracker.getTileWidth(), tracker.getTileHeight());	if (imgBits == null) {	} else {	
generated jpeg image size 

private boolean waitForViewerReady() {	long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick < 5000) {	if (getFrameBufferCavas() != null) return true;	try {	Thread.sleep(100);	} catch (InterruptedException e) {	
ignored console proxy was interupted while waiting for viewer to become ready 

updateFrontEndActivityTime();	if (!waitForViewerReady()) return onAjaxClientConnectFailed();	synchronized (this) {	ajaxSessionId++;	framebufferResized = false;	}	int tileWidth = tracker.getTileWidth();	int tileHeight = tracker.getTileHeight();	int width = tracker.getTrackWidth();	int height = tracker.getTrackHeight();	
ajax client start frame buffer w 

public String onAjaxClientUpdate() {	updateFrontEndActivityTime();	if (!waitForViewerReady()) return onAjaxClientDisconnected();	synchronized (tileDirtyEvent) {	if (!dirtyFlag) {	try {	tileDirtyEvent.wait(3000);	} catch (InterruptedException e) {	
ignored console proxy ajax update was interupted while waiting for viewer to become ready 

========================= cloudstack sample_5004 =========================

TransactionLegacy txn = TransactionLegacy.currentTxn();	;	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement(PROXY_ASSIGNMENT_MATRIX);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	l.add(new Pair<Long, Integer>(rs.getLong(1), rs.getInt(2)));	}	} catch (SQLException e) {	
caught sqlexception 

pstmt = txn.prepareAutoCloseStatement(STORAGE_POOL_HOST_INFO);	} else {	pstmt = txn.prepareAutoCloseStatement(SHARED_STORAGE_POOL_HOST_INFO);	}	pstmt.setLong(1, dcId);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	l.add(new Pair<Long, Integer>(rs.getLong(1), rs.getInt(2)));	}	} catch (SQLException e) {	
caught sqlexception 

;	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement(GET_PROXY_LOAD);	pstmt.setLong(1, proxyVmId);	ResultSet rs = pstmt.executeQuery();	if (rs != null && rs.first()) {	return rs.getInt(1);	}	} catch (SQLException e) {	
caught sqlexception 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement(GET_PROXY_ACTIVE_LOAD);	pstmt.setLong(1, proxyVmId);	ResultSet rs = pstmt.executeQuery();	if (rs != null && rs.first()) {	return rs.getInt(1);	}	} catch (SQLException e) {	
caught sqlexception 

pstmt = txn.prepareAutoCloseStatement(sql);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	ConsoleProxyLoadInfo info = new ConsoleProxyLoadInfo();	info.setId(rs.getLong(1));	info.setName(rs.getString(2));	info.setCount(rs.getInt(3));	l.add(info);	}	} catch (SQLException e) {	
exception 

;	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement("SELECT c.id FROM console_proxy c, vm_instance v, host h " + "WHERE c.id=v.id AND v.state='Running' AND v.host_id=h.id AND h.mgmt_server_id=?");	pstmt.setLong(1, msid);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	l.add(rs.getLong(1));	}	} catch (SQLException e) {	
caught sqlexception 

========================= cloudstack sample_4615 =========================

String signature = TestClientWithAPI.signRequest(requestToSign, this.secretKey);	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = this.developerServer + "?command=associateIpAddress" + "&apiKey=" + encodedApiKey + "&zoneId=" + encodedZoneId + "&signature=" + encodedSignature;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"ipaddress"});	this.getPublicIp().add(values.get("ipaddress"));	
ip address is ipaddress 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"ipaddress"});	this.getPublicIp().add(values.get("ipaddress"));	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorcode", "description"});	
associate ip test failed with errorcode errorCode and description description 

HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"ipaddress"});	this.getPublicIp().add(values.get("ipaddress"));	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorcode", "description"});	} else {	
internal error processing request 

public void registerUser() throws HttpException, IOException {	String encodedUsername = URLEncoder.encode(this.userName, "UTF-8");	String encodedPassword = URLEncoder.encode(this.password, "UTF-8");	String url = server + "?command=register&username=" + encodedUsername + "&domainid=1";	
registering with url 

HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> requestKeyValues = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"apikey", "secretkey"});	this.setApiKey(requestKeyValues.get("apikey"));	this.setSecretKey(requestKeyValues.get("secretkey"));	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorcode", "description"});	
registration failed with errorcode errorCode and description description 

int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> requestKeyValues = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"apikey", "secretkey"});	this.setApiKey(requestKeyValues.get("apikey"));	this.setSecretKey(requestKeyValues.get("secretkey"));	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorcode", "description"});	} else {	
internal error processing request 

========================= cloudstack sample_435 =========================

txn.start();	String sql = DELETE_USAGE_INSTANCE_SQL;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, instance.getAccountId());	pstmt.setLong(2, instance.getVmInstanceId());	pstmt.setInt(3, instance.getUsageType());	pstmt.executeUpdate();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error deleting usage vm instance with vmid for account with id 

if (r_startDate != null) {	instanceStartDate = DateUtil.parseDateString(s_gmtTimeZone, r_startDate);	}	if (r_endDate != null) {	instanceEndDate = DateUtil.parseDateString(s_gmtTimeZone, r_endDate);	}	UsageVMInstanceVO usageInstance = new UsageVMInstanceVO(r_usageType, r_zoneId, r_accountId, r_vmId, r_vmName, r_soId, r_tId, r_cpuSpeed, r_cpuCores, r_memory, hypervisorType, instanceStartDate, instanceEndDate);	usageInstances.add(usageInstance);	}	} catch (Exception ex) {	
error retrieving usage vm instances for account id 

========================= cloudstack sample_4479 =========================

rsSeq.close();	pstmt2.close();	pstmt2 = conn.prepareStatement(advanceNetworkSequenceSql);	pstmt2.executeUpdate();	pstmt2.close();	String uuid = UUID.randomUUID().toString();	String broadcastDomainRange = "POD";	if ("Advanced".equals(networkType)) {	broadcastDomainRange = "ZONE";	}	
adding physicalnetwork for zone id 

String sql = "INSERT INTO `cloud`.`physical_network` (id, uuid, data_center_id, vnet, broadcast_domain_range, state, name) VALUES (?,?,?,?,?,?,?)";	pstmtUpdate = conn.prepareStatement(sql);	pstmtUpdate.setLong(1, physicalNetworkId);	pstmtUpdate.setString(2, uuid);	pstmtUpdate.setLong(3, zoneId);	pstmtUpdate.setString(4, vnet);	pstmtUpdate.setString(5, broadcastDomainRange);	pstmtUpdate.setString(6, "Enabled");	zoneName = zoneName + "-pNtwk" + physicalNetworkId;	pstmtUpdate.setString(7, zoneName);	
statement is 

protected void addTrafficType(Connection conn, long physicalNetworkId, String trafficType, String xenPublicLabel, String kvmPublicLabel, String vmwarePublicLabel) {	PreparedStatement pstmtUpdate = null;	try {	
adding physicalnetwork traffic types 

protected void addDefaultVRProvider(Connection conn, long physicalNetworkId, long zoneId) {	PreparedStatement pstmtUpdate = null, pstmt2 = null;	try {	
adding physicalnetworkserviceprovider virtualrouter 

========================= cloudstack sample_4183 =========================

public void execute() {	boolean result = false;	try {	result = _autoScaleService.deleteCounter(getId());	} catch (ResourceInUseException ex) {	
exception 

boolean result = false;	try {	result = _autoScaleService.deleteCounter(getId());	} catch (ResourceInUseException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_IN_USE_ERROR, ex.getMessage());	}	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	this.setResponseObject(response);	} else {	
failed to delete counter with id 

========================= cloudstack sample_3216 =========================

public boolean processInitialConnect(StartupCommand[] cmd) throws ConnectionException {	try {	authorizeAgent(cmd);	} catch (AgentAuthnException e) {	throw new ConnectionException(true, "Failed to authenticate/authorize", e);	}	
authorized agent with guid 

========================= cloudstack sample_2407 =========================

public InaccurateClock() {	super(InaccurateClockMBean.class, false);	time = System.currentTimeMillis();	restart();	try {	JmxUtil.registerMBean("InaccurateClock", "InaccurateClock", this);	} catch (Exception e) {	
unable to initialize inaccurate clock 

public String turnOff() {	if (s_executor != null) {	try {	s_executor.shutdown();	} catch (Throwable th) {	
unable to shutdown the executor 

public void run() {	try {	time = System.currentTimeMillis();	} catch (Throwable th) {	
unable to time 

========================= cloudstack sample_2811 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	ListResponse<BaremetalPxeResponse> response = new ListResponse<BaremetalPxeResponse>();	List<BaremetalPxeResponse> pxeResponses = _pxeMgr.listPxeServers(this);	response.setResponses(pxeResponses);	response.setResponseName(getCommandName());	response.setObjectName("baremetalpxeservers");	this.setResponseObject(response);	} catch (Exception e) {	
exception happened while executing listpingpxeserverscmd 

========================= cloudstack sample_874 =========================

}	if (arg.equals("-z")) {	zoneId = iter.next();	}	if (arg.equals("-so")) {	serviceOfferingId = iter.next();	}	}	final String server = host + ":" + port + "/";	final String developerServer = host + ":" + devPort + apiUrl;	
starting test against server with thread s 

}	if (arg.equals("-z")) {	zoneId = iter.next();	}	if (arg.equals("-so")) {	serviceOfferingId = iter.next();	}	}	final String server = host + ":" + port + "/";	final String developerServer = host + ":" + devPort + apiUrl;	
clean up is enabled each test will wait ms before cleaning up 

for (int i = 0; i < numThreads; i++) {	new Thread(new Runnable() {	public void run() {	do {	String username = null;	try {	long now = System.currentTimeMillis();	Random ran = new Random();	username = Math.abs(ran.nextInt()) + "-user";	NDC.push(username);	
starting test for the user 

long now = System.currentTimeMillis();	Random ran = new Random();	username = Math.abs(ran.nextInt()) + "-user";	NDC.push(username);	int response = executeDeployment(server, developerServer, username);	boolean success = false;	String reason = null;	if (response == 200) {	success = true;	if (internet) {	
deploy successful waiting minute before ssh tests 

Random ran = new Random();	username = Math.abs(ran.nextInt()) + "-user";	NDC.push(username);	int response = executeDeployment(server, developerServer, username);	boolean success = false;	String reason = null;	if (response == 200) {	success = true;	if (internet) {	Thread.sleep(300000L);	
begin linux ssh test for account 

NDC.push(username);	int response = executeDeployment(server, developerServer, username);	boolean success = false;	String reason = null;	if (response == 200) {	success = true;	if (internet) {	Thread.sleep(300000L);	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get());	if (reason == null) {	
linux ssh test successful for account 

if (response == 200) {	success = true;	if (internet) {	Thread.sleep(300000L);	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get());	if (reason == null) {	}	}	if (reason == null) {	if (internet) {	
windows ssh test successful for account 

success = true;	if (internet) {	Thread.sleep(300000L);	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get());	if (reason == null) {	}	}	if (reason == null) {	if (internet) {	} else {	
deploy test successful now cleaning up 

if (internet) {	Thread.sleep(300000L);	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get());	if (reason == null) {	}	}	if (reason == null) {	if (internet) {	} else {	if (cleanUp) {	
waiting ms before cleaning up vms 

if (internet) {	} else {	if (cleanUp) {	Thread.sleep(sleepTime);	} else {	success = true;	}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	
events and usage records command finished with response code 

if (cleanUp) {	Thread.sleep(sleepTime);	} else {	success = true;	}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	
skipping events and usage records for this user usageiterator and number of threads 

success = true;	}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	
sending cleanup command 

}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	
cleanup command finished with response code 

if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	
sending stop domr destroy vm command 

int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username);	
stop destroy command finished with response code 

usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = (stopResponseCode == 200);	}	} else {	
ssh test failed for account with reason stopping vms 

}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = (stopResponseCode == 200);	}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	
stop command finished with response code 

success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = (stopResponseCode == 200);	}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	} else {	
deploy test failed with reason stopping vms 

} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = (stopResponseCode == 200);	}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	
stop command finished with response code 

}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	if (success) {	
completed test for user in seconds 

} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	if (success) {	} else {	
failed test for user in seconds with reason 

int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	if (success) {	} else {	}	
sleeping for seconds before starting next iteration 

}	} else {	int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	if (success) {	} else {	}	Thread.sleep(wait);	} catch (Exception e) {	
error in thread 

int stopResponseCode = executeStop(server, developerServer, username);	success = false;	}	if (success) {	} else {	}	Thread.sleep(wait);	} catch (Exception e) {	try {	int stopResponseCode = executeStop(server, developerServer, username);	
stop response code 

success = false;	}	if (success) {	} else {	}	Thread.sleep(wait);	} catch (Exception e) {	try {	int stopResponseCode = executeStop(server, developerServer, username);	} catch (Exception e1) {	
ignored error executing stop during stress test 

public static Map<String, List<String>> getMultipleValuesFromXML(InputStream is, String[] tagNames) {	Map<String, List<String>> returnValues = new HashMap<String, List<String>>();	try {	DocumentBuilder docBuilder = factory.newDocumentBuilder();	Document doc = docBuilder.parse(is);	Element rootElement = doc.getDocumentElement();	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	
no tag in xml response returning null 

public static Map<String, String> getSingleValueFromXML(InputStream is, String[] tagNames) {	Map<String, String> returnValues = new HashMap<String, String>();	try {	DocumentBuilder docBuilder = factory.newDocumentBuilder();	Document doc = docBuilder.parse(is);	Element rootElement = doc.getDocumentElement();	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	
no tag in xml response returning null 

Document doc = docBuilder.parse(is);	Element rootElement = doc.getDocumentElement();	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	} else {	returnValues.put(tagNames[i], targetNodes.item(0).getTextContent());	}	}	} catch (Exception ex) {	
error processing xml 

public static Map<String, String> getSingleValueFromXML(Element rootElement, String[] tagNames) {	Map<String, String> returnValues = new HashMap<String, String>();	if (rootElement == null) {	
root element is null can t get single value from xml 

public static Map<String, String> getSingleValueFromXML(Element rootElement, String[] tagNames) {	Map<String, String> returnValues = new HashMap<String, String>();	if (rootElement == null) {	return null;	}	try {	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	
no tag in xml response returning null 

}	try {	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	} else {	returnValues.put(tagNames[i], targetNodes.item(0).getTextContent());	}	}	} catch (Exception ex) {	
error processing xml 

private static String executeRegistration(String server, String username, String password) throws HttpException, IOException {	String url = server + "?command=registerUserKeys&id=" + s_userId.get().toString();	
registering 

String returnValue = null;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> requestKeyValues = getSingleValueFromXML(is, new String[] {"apikey", "secretkey"});	s_apiKey.set(requestKeyValues.get("apikey"));	returnValue = requestKeyValues.get("secretkey");	} else {	
registration failed with error code 

url = server + "?command=createUser&username=" + encodedUsername + "&password=" + encodedPassword + "&firstname=Test&lastname=Test&email=test@vmops.com&domainId=1&accounttype=0&account=" + accountName;	}	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	long userId = -1;	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id", "account"});	String userIdStr = userIdValues.get("id");	
created user with id 

long userId = -1;	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id", "account"});	String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = Long.parseLong(userIdStr);	s_userId.set(userId);	s_account.set(userIdValues.get("account"));	if (userId == -1) {	
create user failed to retrieve a valid user id aborting depolyment test 

String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = Long.parseLong(userIdStr);	s_userId.set(userId);	s_account.set(userIdValues.get("account"));	if (userId == -1) {	return -1;	}	}	} else {	
create user test failed for user with error code 

s_account.set(userIdValues.get("account"));	if (userId == -1) {	return -1;	}	}	} else {	return responseCode;	}	s_secretKey.set(executeRegistration(server, username, username));	if (s_secretKey.get() == null) {	
failed to retrieve secret key during registration skipping user 

return -1;	}	}	} else {	return responseCode;	}	s_secretKey.set(executeRegistration(server, username, username));	if (s_secretKey.get() == null) {	return -1;	} else {	
got secret key 

return -1;	}	}	} else {	return responseCode;	}	s_secretKey.set(executeRegistration(server, username, username));	if (s_secretKey.get() == null) {	return -1;	} else {	
got api key 

requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createSecurityGroup&name=" + encodedUsername + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = getSingleValueFromXML(is, new String[] {"id"});	if (values.get("id") == null) {	
create network rule response code 

String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createSecurityGroup&name=" + encodedUsername + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = getSingleValueFromXML(is, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
create security group response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = getSingleValueFromXML(is, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	}	} else {	
create security group failed with error code following url was sent 

}	String encodedCidr = URLEncoder.encode("192.168.1.143/32", "UTF-8");	url = server + "?command=authorizeSecurityGroupIngress&cidrlist=" + encodedCidr + "&endport=22&" + "securitygroupname=" + encodedUsername + "&protocol=tcp&startport=22&account=" + networkAccount + "&domainid=1";	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
authorise security group ingress response code 

url = server + "?command=authorizeSecurityGroupIngress&cidrlist=" + encodedCidr + "&endport=22&" + "securitygroupname=" + encodedUsername + "&protocol=tcp&startport=22&account=" + networkAccount + "&domainid=1";	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
authorise security group ingress response code 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	}	} else {	
authorise security group ingress failed with error code following url was sent 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=deployVirtualMachine&securitygrouplist=" + encodedUsername + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	
deploy linux vm response code 

url = developerServer + "?command=deployVirtualMachine&securitygrouplist=" + encodedUsername + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	
deploy linux vm response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long linuxVMId = Long.parseLong(values.get("id"));	
got linux virtual machine id 

Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long linuxVMId = Long.parseLong(values.get("id"));	s_linuxVmId.set(values.get("id"));	s_linuxIP.set(values.get("ipaddress"));	s_linuxPassword.set("rs-ccb35ea5");	}	} else {	
deploy linux vm failed with error code following url was sent 

s_linuxVmId.set(values.get("id"));	s_linuxIP.set(values.get("ipaddress"));	s_linuxPassword.set("rs-ccb35ea5");	}	} else {	return responseCode;	}	}	{	url = server + "?command=createVolume&diskofferingid=" + diskOfferingId + "&zoneid=" + zoneId + "&name=newvolume&account=" + s_account.get() + "&domainid=1";	
creating volume 

{	url = server + "?command=createVolume&diskofferingid=" + diskOfferingId + "&zoneid=" + zoneId + "&name=newvolume&account=" + s_account.get() + "&domainid=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
create volume response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
create volume response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	String volumeId = values.get("id");	
got volume id 

InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	String volumeId = values.get("id");	s_newVolume.set(volumeId);	}	} else {	
create volume failed with error code following url was sent 

} else {	String volumeId = values.get("id");	s_newVolume.set(volumeId);	}	} else {	return responseCode;	}	}	{	url = server + "?command=attachVolume&id=" + s_newVolume.get() + "&virtualmachineid=" + s_linuxVmId.get();	
attaching volume with id to the vm 

}	} else {	return responseCode;	}	}	{	url = server + "?command=attachVolume&id=" + s_newVolume.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
attach data volume response code 

{	url = server + "?command=attachVolume&id=" + s_newVolume.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
attach volume response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
attach volume response code 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	}	} else {	
attach volume failed with error code following url was sent 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=deployVirtualMachine&securitygrouplist=" + encodedUsername + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	
deploy linux vm response code 

url = developerServer + "?command=deployVirtualMachine&securitygrouplist=" + encodedUsername + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	
deploy linux vm response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long linuxVMId = Long.parseLong(values.get("id"));	
got linux virtual machine id 

InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long linuxVMId = Long.parseLong(values.get("id"));	s_linuxVmId1.set(values.get("id"));	}	} else {	
deploy linux vm failed with error code following url was sent 

} else {	long linuxVMId = Long.parseLong(values.get("id"));	s_linuxVmId1.set(values.get("id"));	}	} else {	return responseCode;	}	}	{	url = server + "?command=createVolume&diskofferingid=" + diskOfferingId1 + "&zoneid=" + zoneId + "&name=newvolume1&account=" + s_account.get() + "&domainid=1";	
creating volume 

{	url = server + "?command=createVolume&diskofferingid=" + diskOfferingId1 + "&zoneid=" + zoneId + "&name=newvolume1&account=" + s_account.get() + "&domainid=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
create volume response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
create volume response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	String volumeId = values.get("id");	
got volume id 

InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	String volumeId = values.get("id");	s_newVolume1.set(volumeId);	}	} else {	
create volume failed with error code following url was sent 

} else {	String volumeId = values.get("id");	s_newVolume1.set(volumeId);	}	} else {	return responseCode;	}	}	{	url = server + "?command=attachVolume&id=" + s_newVolume1.get() + "&virtualmachineid=" + s_linuxVmId1.get();	
attaching volume with id to the vm 

}	} else {	return responseCode;	}	}	{	url = server + "?command=attachVolume&id=" + s_newVolume1.get() + "&virtualmachineid=" + s_linuxVmId1.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
attach data volume response code 

{	url = server + "?command=attachVolume&id=" + s_newVolume1.get() + "&virtualmachineid=" + s_linuxVmId1.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
attach volume response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
attach volume response code 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	}	} else {	
attach volume failed with error code following url was sent 

private static int executeCleanup(String server, String developerServer, String username) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	
cleaning up resources for user with url 

private static int executeCleanup(String server, String developerServer, String username) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
get user response code 

String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userInfo = getSingleValueFromXML(is, new String[] {"username", "id", "account"});	if (!username.equals(userInfo.get("username"))) {	
get user failed to retrieve requested user aborting cleanup test following url was sent 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userInfo = getSingleValueFromXML(is, new String[] {"username", "id", "account"});	if (!username.equals(userInfo.get("username"))) {	return -1;	}	} else {	
get user failed with error code following url was sent 

return -1;	}	} else {	return responseCode;	}	{	url = server + "?command=updateUser&id=" + userId + "&firstname=delete&lastname=me";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
update user response code 

return responseCode;	}	{	url = server + "?command=updateUser&id=" + userId + "&firstname=delete&lastname=me";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	
update user success success 

}	{	url = server + "?command=updateUser&id=" + userId + "&firstname=delete&lastname=me";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	} else {	
update user failed with error code following url was sent 

}	String encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String requestToSign = "apikey=" + encodedApiKey + "&command=rebootVirtualMachine&id=" + s_linuxVmId.get();	requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=rebootVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
reboot vm response code 

String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=rebootVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	
vm was rebooted with the status success 

String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=rebootVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	} else {	
vm test failed with error code following url was sent 

return responseCode;	}	requestToSign = "apikey=" + encodedApiKey + "&command=stopVirtualMachine&id=" + s_linuxVmId.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
stop vm response code 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	
vm was stopped with the status success 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	} else {	
stop vm test failed with error code following url was sent 

return responseCode;	}	requestToSign = "apikey=" + encodedApiKey + "&command=startVirtualMachine&id=" + s_linuxVmId.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=startVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
start vm response code 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=startVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"id"});	if (success.get("id") == null) {	
start linux vm response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"id"});	if (success.get("id") == null) {	return 401;	} else {	
start vm response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"id"});	if (success.get("id") == null) {	return 401;	} else {	}	
vm was started with the status success 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"id"});	if (success.get("id") == null) {	return 401;	} else {	}	} else {	
start vm test failed with error code following url was sent 

} else {	}	} else {	return responseCode;	}	{	url = server + "?command=deleteUser&id=" + userId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
delete user response code 

return responseCode;	}	{	url = server + "?command=deleteUser&id=" + userId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	
deleted user successfully 

}	{	url = server + "?command=deleteUser&id=" + userId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	
delete user failed with error code following url was sent 

private static int executeEventsAndBilling(String server, String developerServer) throws HttpException, IOException {	String url = server + "?command=listEvents&page=1&account=" + s_account.get();	
getting events for the account 

private static int executeEventsAndBilling(String server, String developerServer) throws HttpException, IOException {	String url = server + "?command=listEvents&page=1&account=" + s_account.get();	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
get events response code 

private static int executeEventsAndBilling(String server, String developerServer) throws HttpException, IOException {	String url = server + "?command=listEvents&page=1&account=" + s_account.get();	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, List<String>> eventDescriptions = getMultipleValuesFromXML(is, new String[] {"description"});	List<String> descriptionText = eventDescriptions.get("description");	if (descriptionText == null) {	
no events retrieved 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, List<String>> eventDescriptions = getMultipleValuesFromXML(is, new String[] {"description"});	List<String> descriptionText = eventDescriptions.get("description");	if (descriptionText == null) {	} else {	for (String text : descriptionText) {	
event 

if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, List<String>> eventDescriptions = getMultipleValuesFromXML(is, new String[] {"description"});	List<String> descriptionText = eventDescriptions.get("description");	if (descriptionText == null) {	} else {	for (String text : descriptionText) {	}	}	} else {	
list events failed with error code following url was sent 

private static int executeStop(String server, String developerServer, String username) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	
stopping resources for user 

private static int executeStop(String server, String developerServer, String username) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
get user response code 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id"});	String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = userIdStr;	if (userId == null) {	
get user failed to retrieve a valid user id aborting depolyment test following url was sent 

InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id"});	String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = userIdStr;	if (userId == null) {	return -1;	}	}	} else {	
get user failed with error code following url was sent 

} else {	return responseCode;	}	{	String encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String requestToSign = "apikey=" + encodedApiKey + "&command=listVirtualMachines";	requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listVirtualMachines&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	
listing all virtual machines for the user with url 

String encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String requestToSign = "apikey=" + encodedApiKey + "&command=listVirtualMachines";	requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listVirtualMachines&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	String[] vmIds = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list virtual machines response code 

if (vmIdList != null) {	vmIds = new String[vmIdList.size()];	vmIdList.toArray(vmIds);	String vmIdLogStr = "";	if ((vmIds != null) && (vmIds.length > 0)) {	vmIdLogStr = vmIds[0];	for (int i = 1; i < vmIds.length; i++) {	vmIdLogStr = vmIdLogStr + "," + vmIds[i];	}	}	
got virtual machine ids 

String vmIdLogStr = "";	if ((vmIds != null) && (vmIds.length > 0)) {	vmIdLogStr = vmIds[0];	for (int i = 1; i < vmIds.length; i++) {	vmIdLogStr = vmIdLogStr + "," + vmIds[i];	}	}	}	}	} else {	
list virtual machines test failed with error code following url was sent 

if (vmIds != null) {	for (String vmId : vmIds) {	requestToSign = "apikey=" + encodedApiKey + "&command=stopVirtualMachine&id=" + vmId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + vmId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
StopVirtualMachine response code 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + vmId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	
stopvirtualmachine success success 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + vmId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	} else {	
stop virtual machine test failed with error code following url was sent 

public static String signRequest(String request, String key) {	try {	Mac mac = Mac.getInstance("HmacSHA1");	SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "HmacSHA1");	mac.init(keySpec);	mac.update(request.getBytes());	byte[] encryptedBytes = mac.doFinal();	return Base64.encodeBase64String(encryptedBytes);	} catch (Exception ex) {	
unable to sign request 

private static String sshWinTest(String host) {	if (host == null) {	
did not receive a host back from test ignoring win ssh test 

private static String sshWinTest(String host) {	if (host == null) {	return null;	}	int retry = 1;	while (true) {	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt account is 

private static String sshWinTest(String host) {	if (host == null) {	return null;	}	int retry = 1;	while (true) {	try {	if (retry > 0) {	Thread.sleep(300000);	}	
attempting to ssh into windows host with retry attempt for account 

return null;	}	int retry = 1;	while (true) {	try {	if (retry > 0) {	Thread.sleep(300000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
user sshed successfully into windows host 

if (retry > 0) {	Thread.sleep(300000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean success = false;	boolean isAuthenticated = conn.authenticateWithPassword("Administrator", "password");	if (isAuthenticated == false) {	return "Authentication failed";	} else {	
authentication is successfull 

conn.connect(null, 60000, 60000);	boolean success = false;	boolean isAuthenticated = conn.authenticateWithPassword("Administrator", "password");	if (isAuthenticated == false) {	return "Authentication failed";	} else {	}	try {	SCPClient scp = new SCPClient(conn);	scp.put("wget.exe", "wget.exe", "C:\\Users\\Administrator", "0777");	
successfully put wget exe file 

boolean success = false;	boolean isAuthenticated = conn.authenticateWithPassword("Administrator", "password");	if (isAuthenticated == false) {	return "Authentication failed";	} else {	}	try {	SCPClient scp = new SCPClient(conn);	scp.put("wget.exe", "wget.exe", "C:\\Users\\Administrator", "0777");	} catch (Exception ex) {	
unable to put wget exe 

if (isAuthenticated == false) {	return "Authentication failed";	} else {	}	try {	SCPClient scp = new SCPClient(conn);	scp.put("wget.exe", "wget.exe", "C:\\Users\\Administrator", "0777");	} catch (Exception ex) {	}	if (conn == null) {	
connection is null 

if (conn == null) {	}	Session sess = conn.openSession();	s_logger.info("User + " + s_account.get() + " executing : wget http: sess.execCommand("wget http: InputStream stdout = sess.getStdout();	InputStream stderr = sess.getStderr();	byte[] buffer = new byte[8192];	while (true) {	if ((stdout.available() == 0) && (stderr.available() == 0)) {	int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);	if ((conditions & ChannelCondition.TIMEOUT) != 0) {	
timeout while waiting for data from peer 

private static String sshTest(String host, String password) {	int i = 0;	if (host == null) {	
did not receive a host back from test ignoring ssh test 

private static String sshTest(String host, String password) {	int i = 0;	if (host == null) {	return null;	}	if (password == null) {	
did not receive a password back from test ignoring ssh test 

return null;	}	if (password == null) {	return null;	}	String result = null;	int retry = 0;	while (true) {	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt account is 

if (password == null) {	return null;	}	String result = null;	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	
attempting to ssh into linux host with retry attempt account is 

}	String result = null;	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
user sshed successfully into linux host 

int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", password);	if (isAuthenticated == false) {	
authentication failed for root with password 

}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", password);	if (isAuthenticated == false) {	return "Authentication failed";	}	boolean success = false;	String linuxCommand = null;	if (i % 10 == 0) linuxCommand = "rm -rf *; wget http: else linuxCommand = "wget http: Session sess = conn.openSession();	
user executing 

String linuxCommand = null;	if (i % 10 == 0) linuxCommand = "rm -rf *; wget http: else linuxCommand = "wget http: Session sess = conn.openSession();	sess.execCommand(linuxCommand);	InputStream stdout = sess.getStdout();	InputStream stderr = sess.getStderr();	byte[] buffer = new byte[8192];	while (true) {	if ((stdout.available() == 0) && (stderr.available() == 0)) {	int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);	if ((conditions & ChannelCondition.TIMEOUT) != 0) {	
timeout while waiting for data from peer 

conn.close();	if (!success) {	retry++;	if (retry == MAX_RETRY_LINUX) {	result = "SSH Linux Network test fail";	}	}	return result;	} catch (Exception e) {	retry++;	
ssh linux network test fail with error 

public static Element queryAsyncJobResult(String host, InputStream inputStream) {	Element returnBody = null;	Map<String, String> values = getSingleValueFromXML(inputStream, new String[] {"jobid"});	String jobId = values.get("jobid");	if (jobId == null) {	
unable to get a jobid 

DocumentBuilder builder = factory.newDocumentBuilder();	Document doc = builder.parse(is);	returnBody = doc.getDocumentElement();	doc.getDocumentElement().normalize();	Element jobStatusTag = (Element)returnBody.getElementsByTagName("jobstatus").item(0);	String jobStatus = jobStatusTag.getTextContent();	if (jobStatus.equals("0")) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while during async job result query 

========================= cloudstack sample_462 =========================

} else if ("cir".equalsIgnoreCase(currentNode)) {	_policyMap.committedRate = Integer.parseInt(value.trim());	} else if ("bc".equalsIgnoreCase(currentNode)) {	_policyMap.burstRate = Integer.parseInt(value.trim());	} else if ("pir".equalsIgnoreCase(currentNode)) {	_policyMap.peakRate = Integer.parseInt(value.trim());	}	}	}	} catch (DOMException e) {	
error parsing the response 

========================= cloudstack sample_2779 =========================

protected boolean canHandle(NetworkOffering offering, DataCenter dc) {	if (dc.getNetworkType() == NetworkType.Basic && isMyTrafficType(offering.getTrafficType())) {	return true;	} else {	
we only take care of guest direct pod based networks 

List<PodVlanMapVO> podRefs = _podVlanDao.listPodVlanMapsByPod(pod.getId());	String podRangeGateway = null;	if (!podRefs.isEmpty()) {	podRangeGateway = _vlanDao.findById(podRefs.get(0).getVlanDbId()).getVlanGateway();	}	if (vm.getType() == VirtualMachine.Type.DomainRouter) {	Nic placeholderNic = _networkModel.getPlaceholderNicForRouter(network, pod.getId());	if (placeholderNic != null) {	IPAddressVO userIp = _ipAddressDao.findByIpAndSourceNetworkId(network.getId(), placeholderNic.getIPv4Address());	ip = PublicIp.createFromAddrAndVlan(userIp, _vlanDao.findById(userIp.getVlanId()));	
nic got an ip address stored in placeholder nic for the network and gateway 

if (ip.getVlanTag() != null && ip.getVlanTag().equalsIgnoreCase(Vlan.UNTAGGED)) {	nic.setIsolationUri(IsolationType.Ec2.toUri(Vlan.UNTAGGED));	nic.setBroadcastUri(BroadcastDomainType.Vlan.toUri(Vlan.UNTAGGED));	nic.setBroadcastType(BroadcastDomainType.Native);	}	nic.setReservationId(String.valueOf(ip.getVlanTag()));	nic.setMacAddress(ip.getMacAddress());	if (vm.getType() == VirtualMachine.Type.DomainRouter) {	Nic placeholderNic = _networkModel.getPlaceholderNicForRouter(network, pod.getId());	if (placeholderNic == null) {	
saving placeholder nic with address for the network 

========================= cloudstack sample_2283 =========================

} else {	throw new CloudRuntimeException("The object " + entry.second() + " passed is not of type Network.");	}	}	task = vmToMigrate.assertCanMigrateAsync(connection, token, true, vdiMap, vifMap, other);	try {	final long timeout = xenServer610Resource.getMigrateWait() * 1000L;	xenServer610Resource.waitForTask(connection, task, 1000, timeout);	xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	
error while checking if vm can be migrated 

xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	throw new CloudRuntimeException("Error while checking if vm " + vmName + " can be migrated.", e);	}	task = vmToMigrate.migrateSendAsync(connection, token, true, vdiMap, vifMap, other);	try {	final long timeout = xenServer610Resource.getMigrateWait() * 1000L;	xenServer610Resource.waitForTask(connection, task, 1000, timeout);	xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	
error while migrating vm 

try {	final long timeout = xenServer610Resource.getMigrateWait() * 1000L;	xenServer610Resource.waitForTask(connection, task, 1000, timeout);	xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	throw new CloudRuntimeException("Error while migrating vm " + vmName, e);	}	final Set<VolumeTO> volumeToSet = null;	return new MigrateWithStorageSendAnswer(command, volumeToSet);	} catch (final CloudRuntimeException e) {	
migration of vm with storage failed due to 

xenServer610Resource.waitForTask(connection, task, 1000, timeout);	xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	throw new CloudRuntimeException("Error while migrating vm " + vmName, e);	}	final Set<VolumeTO> volumeToSet = null;	return new MigrateWithStorageSendAnswer(command, volumeToSet);	} catch (final CloudRuntimeException e) {	return new MigrateWithStorageSendAnswer(command, e);	} catch (final Exception e) {	
migration of vm with storage failed due to 

return new MigrateWithStorageSendAnswer(command, volumeToSet);	} catch (final CloudRuntimeException e) {	return new MigrateWithStorageSendAnswer(command, e);	} catch (final Exception e) {	return new MigrateWithStorageSendAnswer(command, e);	} finally {	if (task != null) {	try {	task.destroy(connection);	} catch (final Exception e) {	
unable to destroy task on host due to 

========================= cloudstack sample_1155 =========================

public final void processConnect(final Host agent, final StartupCommand cmd, final boolean forRebalance) throws ConnectionException {	if (!(cmd instanceof StartupRoutingCommand)) {	return;	}	StartupRoutingCommand startup = (StartupRoutingCommand)cmd;	if (startup.getHypervisorType() != HypervisorType.Hyperv) {	
not hyper v hypervisor so moving on 

return;	}	long agentId = agent.getId();	HostVO host = _hostDao.findById(agentId);	ClusterVO cluster = _clusterDao.findById(host.getClusterId());	if (cluster.getGuid() == null) {	cluster.setGuid(startup.getPool());	_clusterDao.update(cluster.getId(), cluster);	}	if (s_logger.isDebugEnabled()) {	
setting up host 

_hostDao.update(host.getId(), host);	if (answer.needReconnect()) {	throw new ConnectionException(false, "Reinitialize agent after setup.");	}	return;	} else {	String reason = answer.getDetails();	if (reason == null) {	reason = " details were null";	}	
unable to setup agent due to 

throw new ConnectionException(false, "Reinitialize agent after setup.");	}	return;	} else {	String reason = answer.getDetails();	if (reason == null) {	reason = " details were null";	}	}	} catch (AgentUnavailableException e) {	
unable to setup agent because it became unavailable 

}	return;	} else {	String reason = answer.getDetails();	if (reason == null) {	reason = " details were null";	}	}	} catch (AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	
unable to setup agent because it timed out 

public final Map<? extends ServerResource, Map<String, String>> find(final long dcId, final Long podId, final Long clusterId, final URI uri, final String username, final String password, final List<String> hostTags) throws DiscoveryException {	if (s_logger.isInfoEnabled()) {	
discover host dc zone pod cluster uri host 

public final Map<? extends ServerResource, Map<String, String>> find(final long dcId, final Long podId, final Long clusterId, final URI uri, final String username, final String password, final List<String> hostTags) throws DiscoveryException {	if (s_logger.isInfoEnabled()) {	}	if (podId == null) {	if (s_logger.isInfoEnabled()) {	
no pod is assigned skipping the discovery in hyperv discoverer 

if (s_logger.isInfoEnabled()) {	}	if (podId == null) {	if (s_logger.isInfoEnabled()) {	}	return null;	}	ClusterVO cluster = _clusterDao.findById(clusterId);	if (cluster == null) {	if (s_logger.isInfoEnabled()) {	
no cluster in database for cluster id 

return null;	}	ClusterVO cluster = _clusterDao.findById(clusterId);	if (cluster == null) {	if (s_logger.isInfoEnabled()) {	}	return null;	}	if (cluster.getHypervisorType() != HypervisorType.Hyperv) {	if (s_logger.isInfoEnabled()) {	
cluster is not for hyperv hypervisors 

s_logger.debug(msg);	return null;	}	try {	String hostname = uri.getHost();	InetAddress ia = InetAddress.getByName(hostname);	String agentIp = ia.getHostAddress();	String uuidSeed = agentIp;	String guidWithTail = calcServerResourceGuid(uuidSeed) + "-HypervResource";	if (_resourceMgr.findHostByGuid(guidWithTail) != null) {	
skipping because is already in the database 

}	try {	String hostname = uri.getHost();	InetAddress ia = InetAddress.getByName(hostname);	String agentIp = ia.getHostAddress();	String uuidSeed = agentIp;	String guidWithTail = calcServerResourceGuid(uuidSeed) + "-HypervResource";	if (_resourceMgr.findHostByGuid(guidWithTail) != null) {	return null;	}	
Creating hypervdummyresourcebase for zone pod cluster 

if (pingAns == null || !pingAns.getResult()) {	String errMsg = "Agent not running, or no route to agent on at " + uri;	s_logger.debug(errMsg);	throw new DiscoveryException(errMsg);	}	Map<HypervDirectConnectResource, Map<String, String>> resources = new HashMap<HypervDirectConnectResource, Map<String, String>>();	resources.put(resource, details);	return resources;	} catch (ConfigurationException e) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, dcId, podId, "Unable to add " + uri.getHost(), "Error is " + e.getMessage());	
unable to instantiate 

s_logger.debug(errMsg);	throw new DiscoveryException(errMsg);	}	Map<HypervDirectConnectResource, Map<String, String>> resources = new HashMap<HypervDirectConnectResource, Map<String, String>>();	resources.put(resource, details);	return resources;	} catch (ConfigurationException e) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, dcId, podId, "Unable to add " + uri.getHost(), "Error is " + e.getMessage());	} catch (UnknownHostException e) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, dcId, podId, "Unable to add " + uri.getHost(), "Error is " + e.getMessage());	
unable to instantiate 

public final HostVO createHostVOForDirectConnectAgent(final HostVO host, final StartupCommand[] startup, final ServerResource resource, final Map<String, String> details, final List<String> hostTags) {	StartupCommand firstCmd = startup[0];	if (!(firstCmd instanceof StartupRoutingCommand)) {	return null;	}	StartupRoutingCommand ssCmd = ((StartupRoutingCommand)firstCmd);	if (ssCmd.getHypervisorType() != HypervisorType.Hyperv) {	return null;	}	
host connected with hypervisor type checking cidr 

========================= cloudstack sample_931 =========================

public void execute() {	UserVm result;	if (getStartVm()) {	try {	CallContext.current().setEventDetails("Vm Id: " + getEntityId());	result = _userVmService.startVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	
exception 

public void execute() {	UserVm result;	if (getStartVm()) {	try {	CallContext.current().setEventDetails("Vm Id: " + getEntityId());	result = _userVmService.startVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

setEntityId(vm.getId());	setEntityUuid(vm.getUuid());	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to deploy vm");	}	} catch (InsufficientCapacityException ex) {	s_logger.info(ex);	s_logger.trace(ex.getMessage(), ex);	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, ex.getMessage());	} catch (ResourceUnavailableException ex) {	
exception 

} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to deploy vm");	}	} catch (InsufficientCapacityException ex) {	s_logger.info(ex);	s_logger.trace(ex.getMessage(), ex);	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, ex.getMessage());	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	}  catch (ConcurrentOperationException ex) {	
exception 

}	} catch (InsufficientCapacityException ex) {	s_logger.info(ex);	s_logger.trace(ex.getMessage(), ex);	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, ex.getMessage());	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	}  catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ResourceAllocationException ex) {	
exception 

========================= cloudstack sample_3492 =========================

pstmt.setString(1, instance.getDownloadState().toString());	pstmt.setInt(2, instance.getDownloadPercent());	pstmt.setString(3, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), now));	pstmt.setString(4, instance.getErrorString());	pstmt.setString(5, instance.getLocalDownloadPath());	pstmt.setString(6, instance.getJobId());	pstmt.setLong(7, instance.getHostId());	pstmt.setLong(8, instance.getTemplateId());	pstmt.executeUpdate();	} catch (Exception e) {	
exception 

String sql = DOWNLOADS_STATE_DC;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, datacenterId);	pstmt.setLong(2, templateId);	pstmt.setString(3, downloadState.toString());	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	result.add(toEntityBean(rs, false));	}	} catch (Exception e) {	
exception 

pstmt.setLong(1, datacenterId);	pstmt.setLong(2, podId);	pstmt.setLong(3, templateId);	pstmt.setString(4, downloadState.toString());	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (SQLException e) {	
listbytemplatestatus exception 

pstmt.setLong(3, templateId);	pstmt.setString(4, downloadState.toString());	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (SQLException e) {	}	} catch (Exception e) {	
listbytemplatestatus exception 

========================= cloudstack sample_4584 =========================

public void execute(){	UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	
exception 

public void execute(){	UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

public void execute(){	UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ManagementServerException ex) {	
exception 

UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ManagementServerException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (VirtualMachineMigrationException ex) {	
exception 

========================= cloudstack sample_3241 =========================

public Answer execute(FindL2GatewayServiceCommand command, NiciraNvpResource niciraNvpResource) {	final GatewayServiceConfig config = command.getGatewayServiceConfig();	final String uuid = config.getUuid();	final String type = config.getType();	final NiciraNvpApi niciraNvpApi = niciraNvpResource.getNiciraNvpApi();	
looking for gateway service of type 

final String type = config.getType();	final NiciraNvpApi niciraNvpApi = niciraNvpResource.getNiciraNvpApi();	try {	List<L2GatewayServiceConfig> lstGW = niciraNvpApi.findL2GatewayServiceByUuidAndType(uuid, type);	if (lstGW.size() == 0) {	return new FindL2GatewayServiceAnswer(command, false, "L2 Gateway Service not found", null);	} else {	return new FindL2GatewayServiceAnswer(command, true, "L2 Gateway Service " + lstGW.get(0).getDisplayName()+ " found", lstGW.get(0).getUuid());	}	} catch (NiciraNvpApiException e) {	
error finding gateway service due to 

========================= cloudstack sample_1769 =========================

matchedCurrentParam = true;	break;	}	}	if (!matchedCurrentParam && !((String)actualParamName).equalsIgnoreCase("expires") && !((String)actualParamName).equalsIgnoreCase("signatureversion")) {	errorMsg.append(" ").append(actualParamName);	foundUnknownParam= true;	}	}	if (foundUnknownParam) {	
received unknown parameters for command s s 

========================= cloudstack sample_2515 =========================

public void testInjected() {	
done testing injection of service elements into firewall manager 

========================= cloudstack sample_2145 =========================

public boolean start() {	if (s_logger.isInfoEnabled()) {	
starting alert manager 

public boolean stop() {	if (s_logger.isInfoEnabled()) {	
stopping alert manager 

BigDecimal thresholdBalance = quotaAccount.getQuotaMinBalance();	if (accountBalance != null) {	AccountVO account = _accountDao.findById(quotaAccount.getId());	if (account == null) continue;	if (s_logger.isDebugEnabled()) {	s_logger.debug("checkAndSendQuotaAlertEmails: Check id=" + account.getId() + " bal=" + accountBalance + ", alertDate=" + alertDate + ", lockable=" + lockable);	}	if (accountBalance.compareTo(zeroBalance) < 0) {	if (_lockAccountEnforcement && (lockable == 1)) {	if (_quotaManager.isLockable(account)) {	
locking account due to quota 

if (s_logger.isDebugEnabled()) {	s_logger.debug("checkAndSendQuotaAlertEmails: Check id=" + account.getId() + " bal=" + accountBalance + ", alertDate=" + alertDate + ", lockable=" + lockable);	}	if (accountBalance.compareTo(zeroBalance) < 0) {	if (_lockAccountEnforcement && (lockable == 1)) {	if (_quotaManager.isLockable(account)) {	lockAccount(account.getId());	}	}	if (alertDate == null || (balanceDate.after(alertDate) && getDifferenceDays(alertDate, new Date()) > 1)) {	
sending alert due to quota 

if (_lockAccountEnforcement && (lockable == 1)) {	if (_quotaManager.isLockable(account)) {	lockAccount(account.getId());	}	}	if (alertDate == null || (balanceDate.after(alertDate) && getDifferenceDays(alertDate, new Date()) > 1)) {	deferredQuotaEmailList.add(new DeferredQuotaEmail(account, quotaAccount, QuotaConfig.QuotaEmailTemplateTypes.QUOTA_EMPTY));	}	} else if (accountBalance.compareTo(thresholdBalance) < 0) {	if (alertDate == null || (balanceDate.after(alertDate) && getDifferenceDays(alertDate, new Date()) > 1)) {	
sending alert due to quota below threshold 

}	} else if (accountBalance.compareTo(thresholdBalance) < 0) {	if (alertDate == null || (balanceDate.after(alertDate) && getDifferenceDays(alertDate, new Date()) > 1)) {	deferredQuotaEmailList.add(new DeferredQuotaEmail(account, quotaAccount, QuotaConfig.QuotaEmailTemplateTypes.QUOTA_LOW));	}	}	}	}	for (DeferredQuotaEmail emailToBeSent : deferredQuotaEmailList) {	if (s_logger.isDebugEnabled()) {	
checkandsendquotaalertemails attempting to send quota alert email to users of account 

optionMap.put("accountName", account.getAccountName());	optionMap.put("accountID", account.getUuid());	optionMap.put("accountUsers", userNames);	optionMap.put("domainName", accountDomain.getName());	optionMap.put("domainID", accountDomain.getUuid());	optionMap.put("quotaBalance", QuotaConfig.QuotaCurrencySymbol.value() + " " + balance.toString());	if (emailType == QuotaEmailTemplateTypes.QUOTA_STATEMENT) {	optionMap.put("quotaUsage", QuotaConfig.QuotaCurrencySymbol.value() + " " + usage.toString());	}	if (s_logger.isDebugEnabled()) {	
accountName accountID accountUsers domainName domainID 

}	final StrSubstitutor templateEngine = new StrSubstitutor(optionMap);	final String subject = templateEngine.replace(emailTemplate.getTemplateSubject());	final String body = templateEngine.replace(emailTemplate.getTemplateBody());	try {	_emailQuotaAlert.sendQuotaAlert(emailRecipients, subject, body);	emailToBeSent.sentSuccessfully(_quotaAcc);	} catch (Exception e) {	s_logger.error(String.format("Unable to send quota alert email (subject=%s; body=%s) to account %s (%s) recipients (%s) due to error (%s)", subject, body, account.getAccountName(), account.getUuid(), emailRecipients, e));	if (s_logger.isDebugEnabled()) {	
Exception 

final String body = templateEngine.replace(emailTemplate.getTemplateBody());	try {	_emailQuotaAlert.sendQuotaAlert(emailRecipients, subject, body);	emailToBeSent.sentSuccessfully(_quotaAcc);	} catch (Exception e) {	s_logger.error(String.format("Unable to send quota alert email (subject=%s; body=%s) to account %s (%s) recipients (%s) due to error (%s)", subject, body, account.getAccountName(), account.getUuid(), emailRecipients, e));	if (s_logger.isDebugEnabled()) {	}	}	} else {	
no quota email template found for type s cannot send quota alert email to account s s 

Account account = _accountDao.findById(accountId);	if (account != null) {	if (account.getState() == State.locked) {	return true;	} else if (account.getState() == State.enabled) {	AccountVO acctForUpdate = _accountDao.createForUpdate();	acctForUpdate.setState(State.locked);	success = _accountDao.update(Long.valueOf(accountId), acctForUpdate);	} else {	if (s_logger.isInfoEnabled()) {	
attempting to lock a non enabled account current state is accountid locking failed 

return true;	} else if (account.getState() == State.enabled) {	AccountVO acctForUpdate = _accountDao.createForUpdate();	acctForUpdate.setState(State.locked);	success = _accountDao.update(Long.valueOf(accountId), acctForUpdate);	} else {	if (s_logger.isInfoEnabled()) {	}	}	} else {	
failed to lock account account not found 

AccountVO acctForUpdate = _accountDao.createForUpdate();	acctForUpdate.setState(State.locked);	success = _accountDao.update(Long.valueOf(accountId), acctForUpdate);	} else {	if (s_logger.isInfoEnabled()) {	}	}	} else {	}	} catch (Exception e) {	
exception occured while locking account by quota alert manager 

public void sendQuotaAlert(List<String> emails, String subject, String body) throws MessagingException, UnsupportedEncodingException {	if (_smtpSession == null) {	
unable to create smtp session 

}	SMTPMessage msg = new SMTPMessage(_smtpSession);	msg.setSender(new InternetAddress(_emailSender, _emailSender));	msg.setFrom(new InternetAddress(_emailSender, _emailSender));	for (String email : emails) {	if (email != null && !email.isEmpty()) {	try {	InternetAddress address = new InternetAddress(email, email);	msg.addRecipient(Message.RecipientType.TO, address);	} catch (Exception pokemon) {	
exception in creating address for 

========================= cloudstack sample_679 =========================

public DatacenterMO(VmwareContext context, String dcName) throws Exception {	super(context, null);	_mor = _context.getVimClient().getDecendentMoRef(_context.getRootFolder(), "Datacenter", dcName);	if (_mor == null) {	
unable to locate dc 

public VirtualMachineMO findVm(String vmName) throws Exception {	int key = getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

public VirtualMachineMO checkIfVmAlreadyExistsInVcenter(String vmNameOnVcenter, String vmNameInCS) throws Exception {	int key = getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

========================= cloudstack sample_2098 =========================

int header = dataRemaining;	int headRemaining = 4;	pkgBuf.flip();	if (processedLen < totalLen) {	header = header | HEADER_FLAG_FOLLOWING;	}	headBuf.putInt(header);	headBuf.flip();	while (headRemaining > 0) {	if (s_logger.isTraceEnabled()) {	
writing header 

headBuf.putInt(header);	headBuf.flip();	while (headRemaining > 0) {	if (s_logger.isTraceEnabled()) {	}	long count = ch.write(headBuf);	headRemaining -= count;	}	while (dataRemaining > 0) {	if (s_logger.isTraceEnabled()) {	
writing data 

public byte[] read(SocketChannel ch) throws IOException {	if (_readHeader) {	if (_readBuffer.position() == 0) {	_readBuffer.limit(4);	}	if (ch.read(_readBuffer) == -1) {	throw new IOException("Connection closed with -1 on reading size.");	}	if (_readBuffer.hasRemaining()) {	
need to read the rest of the packet length 

if (ch.read(_readBuffer) == -1) {	throw new IOException("Connection closed with -1 on reading size.");	}	if (_readBuffer.hasRemaining()) {	return null;	}	_readBuffer.flip();	int header = _readBuffer.getInt();	int readSize = (short)header;	if (s_logger.isTraceEnabled()) {	
packet length is 

}	if ((header & HEADER_FLAG_FOLLOWING) != 0) {	_gotFollowingPacket = true;	} else {	_gotFollowingPacket = false;	}	_readBuffer.clear();	_readHeader = false;	if (_readBuffer.capacity() < readSize) {	if (s_logger.isTraceEnabled()) {	
resizing the byte buffer from 

}	_readBuffer = ByteBuffer.allocate(readSize);	}	_readBuffer.limit(readSize);	}	if (ch.read(_readBuffer) == -1) {	throw new IOException("Connection closed with -1 on read.");	}	if (_readBuffer.hasRemaining()) {	if (s_logger.isTraceEnabled()) {	
still has 

}	appBuf.flip();	if (_plaintextBuffer.remaining() < appBuf.limit()) {	ByteBuffer newBuffer = ByteBuffer.allocate(_plaintextBuffer.capacity() + appBuf.limit() * 5);	_plaintextBuffer.flip();	newBuffer.put(_plaintextBuffer);	_plaintextBuffer = newBuffer;	}	_plaintextBuffer.put(appBuf);	if (s_logger.isTraceEnabled()) {	
done with packet 

}	_readBuffer.clear();	_readHeader = true;	if (!_gotFollowingPacket) {	_plaintextBuffer.flip();	byte[] result = new byte[_plaintextBuffer.limit()];	_plaintextBuffer.get(result);	return result;	} else {	if (s_logger.isTraceEnabled()) {	
waiting for more packets 

ByteBuffer[] item = new ByteBuffer[data.length + 1];	int remaining = 0;	for (int i = 0; i < data.length; i++) {	remaining += data[i].remaining();	item[i + 1] = data[i];	}	item[0] = ByteBuffer.allocate(4);	item[0].putInt(remaining);	item[0].flip();	if (s_logger.isTraceEnabled()) {	
sending packet of length 

public boolean write(SocketChannel ch) throws IOException {	ByteBuffer[] data = null;	while ((data = _writeQueue.poll()) != null) {	if (data.length == 0) {	if (s_logger.isTraceEnabled()) {	
closing connection requested 

final String pass = DbProperties.getDbProperties().getProperty("db.cloud.keyStorePassphrase");	char[] passphrase = "vmops.com".toCharArray();	if (pass != null) {	passphrase = pass.toCharArray();	}	String confPath = confFile.getParent();	String keystorePath = confPath + keystoreFile;	if (new File(keystorePath).exists()) {	stream = new FileInputStream(keystorePath);	} else {	
ssl fail to find the generated keystore loading fail safe one to continue 

tms = tmf.getTrustManagers();	} else {	ks.load(null, null);	kmf.init(ks, null);	tms = new TrustManager[1];	tms[0] = new TrustAllManager();	}	sslContext = SSLUtils.getSSLContext();	sslContext.init(kmf.getKeyManagers(), tms, null);	if (s_logger.isTraceEnabled()) {	
ssl sslcontext has been initialized 

if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {	return false;	}	if (socketChannel.read(peerNetData) < 0) {	if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {	return false;	}	try {	sslEngine.closeInbound();	} catch (SSLException e) {	
this ssl engine was forced to close inbound due to end of stream 

}	sslEngine.closeOutbound();	return true;	}	peerNetData.flip();	SSLEngineResult result = null;	try {	result = sslEngine.unwrap(peerNetData, peerAppData);	peerNetData.compact();	} catch (SSLException sslException) {	
ssl error occurred while processing unwrap data 

private static boolean doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine, ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData, final int netBufferSize) throws IOException {	if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null || myAppData == null || netBufferSize < 0) {	return false;	}	myNetData.clear();	SSLEngineResult result = null;	try {	result = sslEngine.wrap(myAppData, myNetData);	} catch (SSLException sslException) {	
ssl error occurred while processing wrap data 

case BUFFER_OVERFLOW: myNetData = enlargeBuffer(myNetData, netBufferSize);	break;	case BUFFER_UNDERFLOW: throw new SSLException("Buffer underflow occurred after a wrap. We should not reach here.");	case CLOSED: try {	myNetData.flip();	while (myNetData.hasRemaining()) {	socketChannel.write(myNetData);	}	peerNetData.clear();	} catch (Exception e) {	
failed to send server s close message due to socket channel s failure 

final int netBufferSize = sslEngine.getSession().getPacketBufferSize();	ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);	ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);	ByteBuffer myNetData = ByteBuffer.allocate(netBufferSize);	ByteBuffer peerNetData = ByteBuffer.allocate(netBufferSize);	final long startTimeMills = System.currentTimeMillis();	HandshakeStatus handshakeStatus = sslEngine.getHandshakeStatus();	while (handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED && handshakeStatus != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {	final long timeTaken = System.currentTimeMillis() - startTimeMills;	if (timeTaken > 15000L) {	
ssl handshake has taken more than to connect to please investigate this connection 

return false;	}	break;	case NEED_WRAP: if (!doHandshakeWrap(socketChannel, sslEngine,  myAppData, myNetData, peerNetData, netBufferSize)) {	return false;	}	break;	case NEED_TASK: Runnable task;	while ((task = sslEngine.getDelegatedTask()) != null) {	if (s_logger.isTraceEnabled()) {	
ssl running delegated task 

========================= cloudstack sample_2831 =========================

protected void runInContext() {	List<VolumeDataStoreVO> volumeDataStores = _volumeDataStoreDao.listByVolumeState(Volume.State.NotUploaded, Volume.State.UploadInProgress);	for (VolumeDataStoreVO volumeDataStore : volumeDataStores) {	try {	DataStore dataStore = storeMgr.getDataStore(volumeDataStore.getDataStoreId(), DataStoreRole.Image);	EndPoint ep = _epSelector.select(dataStore, volumeDataStore.getExtractUrl());	if (ep == null) {	
there is no secondary storage vm for image store 

List<VolumeDataStoreVO> volumeDataStores = _volumeDataStoreDao.listByVolumeState(Volume.State.NotUploaded, Volume.State.UploadInProgress);	for (VolumeDataStoreVO volumeDataStore : volumeDataStores) {	try {	DataStore dataStore = storeMgr.getDataStore(volumeDataStore.getDataStoreId(), DataStoreRole.Image);	EndPoint ep = _epSelector.select(dataStore, volumeDataStore.getExtractUrl());	if (ep == null) {	continue;	}	VolumeVO volume = _volumeDao.findById(volumeDataStore.getVolumeId());	if (volume == null) {	
volume with id not found 

continue;	}	Host host = _hostDao.findById(ep.getId());	UploadStatusCommand cmd = new UploadStatusCommand(volume.getUuid(), EntityType.Volume);	if (host != null && host.getManagementServerId() != null) {	if (_nodeId == host.getManagementServerId().longValue()) {	Answer answer = null;	try {	answer = ep.sendMessage(cmd);	} catch (CloudRuntimeException e) {	
unable to get upload status for volume error details 

UploadStatusCommand cmd = new UploadStatusCommand(volume.getUuid(), EntityType.Volume);	if (host != null && host.getManagementServerId() != null) {	if (_nodeId == host.getManagementServerId().longValue()) {	Answer answer = null;	try {	answer = ep.sendMessage(cmd);	} catch (CloudRuntimeException e) {	answer = new UploadStatusAnswer(cmd, UploadStatus.UNKNOWN, e.getMessage());	}	if (answer == null || !(answer instanceof UploadStatusAnswer)) {	
no or invalid answer corresponding to uploadstatuscommand for volume 

if (answer == null || !(answer instanceof UploadStatusAnswer)) {	continue;	}	handleVolumeStatusResponse((UploadStatusAnswer)answer, volume, volumeDataStore);	}	} else {	String error = "Volume " + volume.getUuid() + " failed to upload as SSVM is either destroyed or SSVM agent not in 'Up' state";	handleVolumeStatusResponse(new UploadStatusAnswer(cmd, UploadStatus.ERROR, error), volume, volumeDataStore);	}	} catch (Throwable th) {	
exception while checking status for uploaded volume error details 

continue;	}	handleVolumeStatusResponse((UploadStatusAnswer)answer, volume, volumeDataStore);	}	} else {	String error = "Volume " + volume.getUuid() + " failed to upload as SSVM is either destroyed or SSVM agent not in 'Up' state";	handleVolumeStatusResponse(new UploadStatusAnswer(cmd, UploadStatus.ERROR, error), volume, volumeDataStore);	}	} catch (Throwable th) {	if (s_logger.isTraceEnabled()) {	
exception details 

if (s_logger.isTraceEnabled()) {	}	}	}	List<TemplateDataStoreVO> templateDataStores = _templateDataStoreDao.listByTemplateState(VirtualMachineTemplate.State.NotUploaded, VirtualMachineTemplate.State.UploadInProgress);	for (TemplateDataStoreVO templateDataStore : templateDataStores) {	try {	DataStore dataStore = storeMgr.getDataStore(templateDataStore.getDataStoreId(), DataStoreRole.Image);	EndPoint ep = _epSelector.select(dataStore, templateDataStore.getExtractUrl());	if (ep == null) {	
there is no secondary storage vm for image store 

List<TemplateDataStoreVO> templateDataStores = _templateDataStoreDao.listByTemplateState(VirtualMachineTemplate.State.NotUploaded, VirtualMachineTemplate.State.UploadInProgress);	for (TemplateDataStoreVO templateDataStore : templateDataStores) {	try {	DataStore dataStore = storeMgr.getDataStore(templateDataStore.getDataStoreId(), DataStoreRole.Image);	EndPoint ep = _epSelector.select(dataStore, templateDataStore.getExtractUrl());	if (ep == null) {	continue;	}	VMTemplateVO template = _templateDao.findById(templateDataStore.getTemplateId());	if (template == null) {	
template with id not found 

continue;	}	Host host = _hostDao.findById(ep.getId());	UploadStatusCommand cmd = new UploadStatusCommand(template.getUuid(), EntityType.Template);	if (host != null && host.getManagementServerId() != null) {	if (_nodeId == host.getManagementServerId().longValue()) {	Answer answer = null;	try {	answer = ep.sendMessage(cmd);	} catch (CloudRuntimeException e) {	
unable to get upload status for template error details 

UploadStatusCommand cmd = new UploadStatusCommand(template.getUuid(), EntityType.Template);	if (host != null && host.getManagementServerId() != null) {	if (_nodeId == host.getManagementServerId().longValue()) {	Answer answer = null;	try {	answer = ep.sendMessage(cmd);	} catch (CloudRuntimeException e) {	answer = new UploadStatusAnswer(cmd, UploadStatus.UNKNOWN, e.getMessage());	}	if (answer == null || !(answer instanceof UploadStatusAnswer)) {	
no or invalid answer corresponding to uploadstatuscommand for template 

if (answer == null || !(answer instanceof UploadStatusAnswer)) {	continue;	}	handleTemplateStatusResponse((UploadStatusAnswer)answer, template, templateDataStore);	}	} else {	String error = "Template " + template.getUuid() + " failed to upload as SSVM is either destroyed or SSVM agent not in 'Up' state";	handleTemplateStatusResponse(new UploadStatusAnswer(cmd, UploadStatus.ERROR, error), template, templateDataStore);	}	} catch (Throwable th) {	
exception while checking status for uploaded template error details 

continue;	}	handleTemplateStatusResponse((UploadStatusAnswer)answer, template, templateDataStore);	}	} else {	String error = "Template " + template.getUuid() + " failed to upload as SSVM is either destroyed or SSVM agent not in 'Up' state";	handleTemplateStatusResponse(new UploadStatusAnswer(cmd, UploadStatus.ERROR, error), template, templateDataStore);	}	} catch (Throwable th) {	if (s_logger.isTraceEnabled()) {	
exception details 

tmpVolumeDataStore.setPhysicalSize(answer.getPhysicalSize());	tmpVolumeDataStore.setSize(answer.getVirtualSize());	tmpVolumeDataStore.setDownloadPercent(100);	VolumeVO volumeUpdate = _volumeDao.createForUpdate();	volumeUpdate.setSize(answer.getVirtualSize());	_volumeDao.update(tmpVolume.getId(), volumeUpdate);	stateMachine.transitTo(tmpVolume, Event.OperationSucceeded, null, _volumeDao);	_resourceLimitMgr.incrementResourceCount(volume.getAccountId(), Resource.ResourceType.secondary_storage, answer.getVirtualSize());	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_UPLOAD, tmpVolume.getAccountId(), tmpVolumeDataStore.getDataStoreId(), tmpVolume.getId(), tmpVolume.getName(), null, null, tmpVolumeDataStore.getPhysicalSize(), tmpVolumeDataStore.getSize(), Volume.class.getName(), tmpVolume.getUuid());	if (s_logger.isDebugEnabled()) {	
volume uploaded successfully 

stateMachine.transitTo(tmpVolume, Event.OperationTimeout, null, _volumeDao);	msg = "Volume " + tmpVolume.getUuid() + " failed to upload due to operation timed out";	s_logger.error(msg);	sendAlert = true;	}	}	break;	}	_volumeDataStoreDao.update(tmpVolumeDataStore.getId(), tmpVolumeDataStore);	} catch (NoTransitionException e) {	
unexpected error 

templateUpdate.setSize(answer.getVirtualSize());	_templateDao.update(tmpTemplate.getId(), templateUpdate);	stateMachine.transitTo(tmpTemplate, VirtualMachineTemplate.Event.OperationSucceeded, null, _templateDao);	_resourceLimitMgr.incrementResourceCount(template.getAccountId(), Resource.ResourceType.secondary_storage, answer.getVirtualSize());	String etype = EventTypes.EVENT_TEMPLATE_CREATE;	if (tmpTemplate.getFormat() == Storage.ImageFormat.ISO) {	etype = EventTypes.EVENT_ISO_CREATE;	}	UsageEventUtils.publishUsageEvent(etype, tmpTemplate.getAccountId(), tmpTemplateDataStore.getDataStoreId(), tmpTemplate.getId(), tmpTemplate.getName(), null, null, tmpTemplateDataStore.getPhysicalSize(), tmpTemplateDataStore.getSize(), VirtualMachineTemplate.class.getName(), tmpTemplate.getUuid());	if (s_logger.isDebugEnabled()) {	
template uploaded successfully 

stateMachine.transitTo(tmpTemplate, VirtualMachineTemplate.Event.OperationTimeout, null, _templateDao);	msg = "Template " + tmpTemplate.getUuid() + " failed to upload due to operation timed out";	s_logger.error(msg);	sendAlert = true;	}	}	break;	}	_templateDataStoreDao.update(tmpTemplateDataStore.getId(), tmpTemplateDataStore);	} catch (NoTransitionException e) {	
unexpected error 

========================= cloudstack sample_2427 =========================

public CheckRouterAnswer checkRouter(final CheckRouterCommand cmd) {	final String router_name = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME);	final MockVm vm = _mockVmDao.findByVmName(router_name);	final String args = vm.getBootargs();	if (args.indexOf("router_pr=100") > 0) {	
router priority is for master 

public CheckRouterAnswer checkRouter(final CheckRouterCommand cmd) {	final String router_name = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME);	final MockVm vm = _mockVmDao.findByVmName(router_name);	final String args = vm.getBootargs();	if (args.indexOf("router_pr=100") > 0) {	final CheckRouterAnswer ans = new CheckRouterAnswer(cmd, "Status: MASTER", true);	ans.setState(VirtualRouter.RedundantState.MASTER);	return ans;	} else {	
router priority is for backup 

try {	txn.start();	final String vmName = cmd.getVmName();	final MockVMVO vm = _mockVmDao.findByVmName(vmName);	if (vm == null) {	return new ScaleVmAnswer(cmd, false, "Can't find VM " + vmName);	}	vm.setCpu(cmd.getCpus() * cmd.getMaxSpeed());	vm.setMemory(cmd.getMaxRam());	_mockVmDao.update(vm.getId(), vm);	
scaled up vm 

public Answer plugSecondaryIp(final NetworkRulesVmSecondaryIpCommand cmd) {	
plugged secondary ip to vm 

public Answer createVmSnapshot(final CreateVMSnapshotCommand cmd) {	final String vmName = cmd.getVmName();	final String vmSnapshotName = cmd.getTarget().getSnapshotName();	
created snapshot for vm 

public Answer deleteVmSnapshot(final DeleteVMSnapshotCommand cmd) {	final String vm = cmd.getVmName();	final String snapshotName = cmd.getTarget().getSnapshotName();	if (_mockVmDao.findByVmName(cmd.getVmName()) == null) {	return new DeleteVMSnapshotAnswer(cmd, false, "No VM by name " + cmd.getVmName());	}	
removed snapshot of vm 

public Answer revertVmSnapshot(final RevertToVMSnapshotCommand cmd) {	final String vm = cmd.getVmName();	final String snapshot = cmd.getTarget().getSnapshotName();	final MockVMVO vmVo = _mockVmDao.findByVmName(cmd.getVmName());	if (vmVo == null) {	return new RevertToVMSnapshotAnswer(cmd, false, "No VM by name " + cmd.getVmName());	}	
reverted to snapshot of vm 

========================= cloudstack sample_946 =========================

static public Connect getConnection(String hypervisorURI) throws LibvirtException {	
looking for libvirtd connection at 

static public Connect getConnection(String hypervisorURI) throws LibvirtException {	Connect conn = s_connections.get(hypervisorURI);	if (conn == null) {	
no existing libvirtd connection found opening a new one 

static public Connect getConnection(String hypervisorURI) throws LibvirtException {	Connect conn = s_connections.get(hypervisorURI);	if (conn == null) {	conn = new Connect(hypervisorURI, false);	
successfully connected to libvirt at 

static public Connect getConnection(String hypervisorURI) throws LibvirtException {	Connect conn = s_connections.get(hypervisorURI);	if (conn == null) {	conn = new Connect(hypervisorURI, false);	s_connections.put(hypervisorURI, conn);	} else {	try {	conn.getVersion();	} catch (LibvirtException e) {	
connection with libvirtd is broken 

static public Connect getConnection(String hypervisorURI) throws LibvirtException {	Connect conn = s_connections.get(hypervisorURI);	if (conn == null) {	conn = new Connect(hypervisorURI, false);	s_connections.put(hypervisorURI, conn);	} else {	try {	conn.getVersion();	} catch (LibvirtException e) {	
opening a new libvirtd connection to 

static public Connect getConnectionByVmName(String vmName) throws LibvirtException {	HypervisorType[] hypervisors = new HypervisorType[] {HypervisorType.KVM, Hypervisor.HypervisorType.LXC};	for (HypervisorType hypervisor : hypervisors) {	try {	Connect conn = LibvirtConnection.getConnectionByType(hypervisor.toString());	if (conn.domainLookupByName(vmName) != null) {	return conn;	}	} catch (Exception e) {	
can not find connection for instance continuing 

HypervisorType[] hypervisors = new HypervisorType[] {HypervisorType.KVM, Hypervisor.HypervisorType.LXC};	for (HypervisorType hypervisor : hypervisors) {	try {	Connect conn = LibvirtConnection.getConnectionByType(hypervisor.toString());	if (conn.domainLookupByName(vmName) != null) {	return conn;	}	} catch (Exception e) {	}	}	
can not find a connection for instance assuming the default connection 

========================= cloudstack sample_1088 =========================

public boolean checkAccess(Account caller, ControlledEntity entity, AccessType accessType, String action) throws PermissionDeniedException {	if (caller == null) {	throw new InvalidParameterValueException("Caller cannot be passed as NULL to IAM!");	}	if (entity == null && action == null) {	throw new InvalidParameterValueException("Entity and action cannot be both NULL in checkAccess!");	}	String accessKey = buildAccessCacheKey(caller, entity, accessType, action);	CheckAccessResult allowDeny = (CheckAccessResult)_iamSrv.getFromIAMCache(accessKey);	if (allowDeny != null) {	
iam access check for from cache 

========================= cloudstack sample_5024 =========================

public Pair<Boolean, UserAuthenticator.ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	
retrieving user 

public Pair<Boolean, UserAuthenticator.ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	
username or password cannot be empty 

if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	boolean isValidUser = false;	UserAccount user = this._userAccountDao.getUserAccount(username, domainId);	if (user != null) {	isValidUser = true;	} else {	
unable to find user with in domain 

if (user != null) {	isValidUser = true;	} else {	}	byte[] salt = new byte[0];	int rounds = s_rounds;	try {	if (isValidUser) {	String[] storedPassword = user.getPassword().split(":");	if ((storedPassword.length != 3) || (!StringUtils.isNumeric(storedPassword[2]))) {	
the stored password for isn t in the right format for this authenticator 

public String encode(String password) {	try {	return encode(password, makeSalt(), s_rounds);	} catch (NoSuchAlgorithmException e) {	throw new CloudRuntimeException("Unable to hash password", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable to hash password", e);	} catch (InvalidKeySpecException e) {	
exception in encryptutil createkey 

========================= cloudstack sample_1319 =========================

public boolean implementVpc(Vpc vpc, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
networkelement implementvpc 

public boolean shutdownVpc(Vpc vpc, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
networkelement shutdownvpc 

public boolean createPrivateGateway(PrivateGateway gateway) throws ConcurrentOperationException, ResourceUnavailableException {	
networkelement createprivategateway 

public boolean deletePrivateGateway(PrivateGateway privateGateway) throws ConcurrentOperationException, ResourceUnavailableException {	
networkelement deleteprivategateway 

public boolean applyStaticRoutes(Vpc vpc, List<StaticRouteProfile> routes) throws ResourceUnavailableException {	
networkelement applystaticroutes 

public boolean applyNetworkACLs(Network net, List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	
networkelement applynetworkacls 

public boolean applyNetworkACLs(Network net, List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	
no rules to apply 

NetworkPolicyModel policyModel = _manager.getDatabase().lookupNetworkPolicy(acl.getUuid());	if (policyModel == null) {	policyModel = new NetworkPolicyModel(acl.getUuid(), acl.getName());	net.juniper.contrail.api.types.Project project;	try {	project = _manager.getVncProject(net.getDomainId(), net.getAccountId());	if (project == null) {	project = _manager.getDefaultVncProject();	}	} catch (IOException ex) {	
read project 

s_logger.error(e);	e.printStackTrace();	return false;	}	try {	if (!policyModel.verify(_manager.getModelController())) {	policyModel.update(_manager.getModelController());	}	_manager.getDatabase().getNetworkPolicys().add(policyModel);	} catch (Exception ex) {	
network policy update 

public boolean applyACLItemsToPrivateGw(PrivateGateway privateGateway, List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	
networkelement applyaclitemstoprivategw 

========================= cloudstack sample_1876 =========================

scriptCommand.add("configure_ovs_bridge_for_routing_policies");	scriptCommand.add("--bridge", command.getBridgeName());	scriptCommand.add("--config", command.getVpcConfigInJson());	final String result = scriptCommand.execute();	if (result.equalsIgnoreCase("SUCCESS")) {	return new Answer(command, true, result);	} else {	return new Answer(command, false, result);	}	} catch  (final Exception e) {	
caught exception while updating host with latest vpc topology 

========================= cloudstack sample_1030 =========================

volume.setUuid(esvolume.getUuid());	volume.setPath(null);	_volumeDao.update(volume.getId(), volume);	long capacityBytes = storagePool.getCapacityBytes();	long usedBytes = storagePool.getUsedBytes();	Long inbytes = volume.getSize();	usedBytes += inbytes;	storagePool.setCapacityIops(capacityIops);	storagePool.setUsedBytes(usedBytes > capacityBytes ? capacityBytes : usedBytes);	_storagePoolDao.update(storagePoolId, storagePool);	
elastistor volume creation complete 

public void resize(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {	
resize elastistor volume started 

ResizeVolumePayload resizeParameter = (ResizeVolumePayload) vol.getpayload();	CreateCmdResult result = new CreateCmdResult(null, null);	StoragePoolVO poolVO = _storagePoolDao.findById(pool.getId());	if (!(poolVO.isManaged())) {	super.resize(data, callback);	return;	}	try {	status = ElastistorUtil.updateElastistorVolumeSize(vol.getUuid(), resizeParameter.newSize);	} catch (Throwable e) {	
resize elastistor volume failed please contact elastistor admin 

public void takeSnapshot(SnapshotInfo snapshot, AsyncCompletionCallback<CreateCmdResult> callback) {	CreateCmdResult result = null;	try {	
taking elastistor volume snapshot 

public void takeSnapshot(SnapshotInfo snapshot, AsyncCompletionCallback<CreateCmdResult> callback) {	CreateCmdResult result = null;	try {	SnapshotObjectTO snapshotTO = (SnapshotObjectTO)snapshot.getTO();	String volumeid = snapshotTO.getVolume().getUuid();	String snapshotname = snapshotTO.getName();	Answer answer = ElastistorUtil.createElastistorVolumeSnapshot(volumeid, snapshotname);	if(answer.getResult() == false){	
elastistor volume snapshot failed 

public void takeSnapshot(SnapshotInfo snapshot, AsyncCompletionCallback<CreateCmdResult> callback) {	CreateCmdResult result = null;	try {	SnapshotObjectTO snapshotTO = (SnapshotObjectTO)snapshot.getTO();	String volumeid = snapshotTO.getVolume().getUuid();	String snapshotname = snapshotTO.getName();	Answer answer = ElastistorUtil.createElastistorVolumeSnapshot(volumeid, snapshotname);	if(answer.getResult() == false){	throw new CloudRuntimeException("elastistor volume snapshot failed");	}else{	
elastistor volume snapshot succesfull 

if(answer.getResult() == false){	throw new CloudRuntimeException("elastistor volume snapshot failed");	}else{	snapshotTO.setPath(answer.getDetails());	CreateObjectAnswer createObjectAnswer = new CreateObjectAnswer(snapshotTO);	result = new CreateCmdResult(null, createObjectAnswer);	result.setResult(null);	}	}	catch (Throwable e) {	
failed to take snapshot 

========================= cloudstack sample_1933 =========================

queueSizeLimit = _createSnapshotQueueSizeLimit;	} else {	queueSizeLimit = 1L;	}	if (queueSizeLimit != null) {	if (!execute) {	_asyncMgr.syncAsyncJobExecution((AsyncJob)asyncCmd.getJob(), asyncCmd.getSyncObjType(), asyncCmd.getSyncObjId().longValue(), queueSizeLimit);	return;	}	} else {	
the queue size is unlimited skipping the synchronizing 

========================= cloudstack sample_2523 =========================

public synchronized void persist(String key, String value) {	_properties.setProperty(key, value);	FileOutputStream output = null;	try {	output = new FileOutputStream(_file);	_properties.store(output, _name);	output.flush();	output.close();	} catch (IOException e) {	
uh oh 

_name = name;	String path = (String)params.get("path");	if (path == null) {	path = "agent.properties";	}	File file = PropertiesUtil.findConfigFile(path);	if (file == null) {	file = new File(path);	try {	if (!file.createNewFile()) {	
unable to create file 

path = "agent.properties";	}	File file = PropertiesUtil.findConfigFile(path);	if (file == null) {	file = new File(path);	try {	if (!file.createNewFile()) {	return false;	}	} catch (IOException e) {	
unable to create file 

return false;	}	} catch (IOException e) {	return false;	}	}	try {	PropertiesUtil.loadFromFile(_properties, file);	_file = file;	} catch (FileNotFoundException e) {	
how did we get here 

} catch (IOException e) {	return false;	}	}	try {	PropertiesUtil.loadFromFile(_properties, file);	_file = file;	} catch (FileNotFoundException e) {	return false;	} catch (IOException e) {	
ioexception 

========================= cloudstack sample_2870 =========================

File file = new File(s_fileName);	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();	DocumentBuilder builder = factory.newDocumentBuilder();	Document doc = builder.parse(file);	doc.getDocumentElement().normalize();	Element root = doc.getDocumentElement();	setGlobalParams(root);	setComponent(root);	for (int i = 0; i < s_numThreads; i++) {	if (s_numThreads > 1) {	
starting stress test in threads 

DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();	DocumentBuilder builder = factory.newDocumentBuilder();	Document doc = builder.parse(file);	doc.getDocumentElement().normalize();	Element root = doc.getDocumentElement();	setGlobalParams(root);	setComponent(root);	for (int i = 0; i < s_numThreads; i++) {	if (s_numThreads > 1) {	} else {	
starting functional test 

}	} else {	Random ran = new Random();	Integer randomNumber = Math.abs(ran.nextInt(s_keys.size()));	try {	String key = s_keys.get(randomNumber);	Class<?> c = Class.forName(s_componentMap.get(key));	TestCase component = (TestCase)c.newInstance();	executeTest(key, c, component);	} catch (Exception e) {	
error in thread 

}	NodeList inputFileNameLst = itemElement.getElementsByTagName("filename");	s_inputFile.put(s_testCaseName, new ArrayList<String>());	for (int k = 0; k < inputFileNameLst.getLength(); k++) {	String inputFileName = ((Element)inputFileNameLst.item(k)).getTextContent();	s_inputFile.get(s_testCaseName).add(inputFileName);	}	}	}	if (s_isSanity == true && s_componentMap.size() == 0) {	
failure failed to load sanity test component verify that the test is uncommented in adapter xml 

for (int k = 0; k < inputFileNameLst.getLength(); k++) {	String inputFileName = ((Element)inputFileNameLst.item(k)).getTextContent();	s_inputFile.get(s_testCaseName).add(inputFileName);	}	}	}	if (s_isSanity == true && s_componentMap.size() == 0) {	System.exit(1);	}	if (s_isRegression == true && s_componentMap.size() != 2) {	
failure failed to load sanity test or regression test components verify that these tests are uncommented in adapter xml 

public static boolean executeTest(String key, Class<?> c, TestCase component) {	boolean finalResult = false;	try {	
starting key test 

component.setConn(s_globalParameters.get("dbPassword"));	component.setCommands();	if (s_inputFile.get(key) != null) {	component.setInputFile(s_inputFile.get(key));	}	if (key != null) {	component.setTestCaseName(s_testCaseName);	}	s_result.set(component.executeTest());	if (s_result.get().toString().equals("false")) {	
failure test key failed 

component.setInputFile(s_inputFile.get(key));	}	if (key != null) {	component.setTestCaseName(s_testCaseName);	}	s_result.set(component.executeTest());	if (s_result.get().toString().equals("false")) {	s_failure++;	} else {	finalResult = true;	
success test key passed 

if (key != null) {	component.setTestCaseName(s_testCaseName);	}	s_result.set(component.executeTest());	if (s_result.get().toString().equals("false")) {	s_failure++;	} else {	finalResult = true;	}	} catch (Exception ex) {	
error during test execution 

========================= cloudstack sample_454 =========================

public Answer execute(final CheckSshCommand command, final LibvirtComputingResource libvirtComputingResource) {	final String vmName = command.getName();	final String privateIp = command.getIp();	final int cmdPort = command.getPort();	if (s_logger.isDebugEnabled()) {	
ping command port 

final String vmName = command.getName();	final String privateIp = command.getIp();	final int cmdPort = command.getPort();	if (s_logger.isDebugEnabled()) {	}	final VirtualRoutingResource virtRouterResource = libvirtComputingResource.getVirtRouterResource();	if (!virtRouterResource.connect(privateIp, cmdPort)) {	return new CheckSshAnswer(command, "Can not ping System vm " + vmName + " because of a connection failure");	}	if (s_logger.isDebugEnabled()) {	
ping command port succeeded for vm 

========================= cloudstack sample_1026 =========================

) {	if(selectResultSet.next()) {	serviceOfferingId = selectResultSet.getLong("id");	}	updatePstmt.setInt(1, newRamSize);	updatePstmt.setLong(2, serviceOfferingId);	updatePstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to upgrade ram_size of service offering for secondary storage vm. ", e);	}	
done upgrading ram for service offering of secondary storage vm to 

pstmt_insert_ldap_hostname_port.executeUpdate();	}	}	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to insert ldap configuration values ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable to insert ldap configuration values ", e);	}	
done encrypting ldap config values 

private void encryptImageStoreDetails(Connection conn) {	
encrypting image store details 

updatePstmt.setBytes(1, encryptedValue.getBytes("UTF-8"));	updatePstmt.setLong(2, id);	updatePstmt.executeUpdate();	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt image_store_details values ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt image_store_details values ", e);	}	
done encrypting image store details 

========================= cloudstack sample_4224 =========================

public Answer execute(NetworkUsageCommand cmd) {	if (cmd.isForVpc()) {	return vpcNetworkUsage(cmd);	}	if (LOGGER.isInfoEnabled()) {	
executing resource networkusagecommand 

long[] stats = new long[2];	if (result != null) {	try {	String[] splitResult = result.split(":");	int i = 0;	while (i < splitResult.length - 1) {	stats[0] += (Long.parseLong(splitResult[i++]));	stats[1] += (Long.parseLong(splitResult[i++]));	}	} catch (Exception e) {	
unable to parse return from script return of network usage command 

args += "-r";	} else if ("vpn".equals(option)) {	args += "-n";	} else if ("remove".equals(option)) {	args += "-d";	} else {	return new NetworkUsageAnswer(cmd, SUCCESS, 0L, 0L);	}	ExecutionResult callResult = vrr.executeInVR(privateIp, "vpc_netusage.sh", args);	if (!callResult.isSuccess()) {	
unable to execute networkusage command on domr domr may not be ready yet failure due to 

args += "-d";	} else {	return new NetworkUsageAnswer(cmd, SUCCESS, 0L, 0L);	}	ExecutionResult callResult = vrr.executeInVR(privateIp, "vpc_netusage.sh", args);	if (!callResult.isSuccess()) {	}	if ("get".equals(option) || "vpn".equals(option)) {	String result = callResult.getDetails();	if (result == null || result.isEmpty()) {	
vpc network usage get returns empty 

String msg = "Port " + cmdPort + " not reachable for " + vmName + ": " + config.getAgentHostname();	LOGGER.info(msg);	return new CheckSshAnswer(cmd, msg);	}	} catch (Exception e) {	String msg = "Can not reach port " + cmdPort + " on System vm " + vmName + ": " + config.getAgentHostname() + " due to exception: " + e;	LOGGER.error(msg);	return new CheckSshAnswer(cmd, msg);	}	if (LOGGER.isDebugEnabled()) {	
ping succeeded for vm 

========================= cloudstack sample_842 =========================

public Network design(final NetworkOffering offering, final DeploymentPlan plan, final Network userSpecified, final Account owner) {	final PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	final DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	
refusing to design this network 

public Network design(final NetworkOffering offering, final DeploymentPlan plan, final Network userSpecified, final Account owner) {	final PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	final DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	return null;	}	final List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

public Network design(final NetworkOffering offering, final DeploymentPlan plan, final Network userSpecified, final Account owner) {	final PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	final DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	return null;	}	final List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	return null;	}	
nicira nvp found on physical network 

public Network design(final NetworkOffering offering, final DeploymentPlan plan, final Network userSpecified, final Account owner) {	final PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	final DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	return null;	}	final List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	return null;	}	
physical isolation type is supported asking guestnetworkguru to design this network 

}	String name = network.getName();	if (name == null || name.isEmpty()) {	name = ((NetworkVO) network).getUuid();	}	if (name.length() > MAX_NAME_LENGTH) {	name = name.substring(0, MAX_NAME_LENGTH - 1);	}	final List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

final NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	final HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	hostDao.loadDetails(niciraNvpHost);	final String transportzoneuuid = niciraNvpHost.getDetail("transportzoneuuid");	final String transportzoneisotype = niciraNvpHost.getDetail("transportzoneisotype");	if (offering.getGuestType().equals(GuestType.Shared)) {	try {	checkL2GatewayServiceSharedNetwork(niciraNvpHost);	}	catch (Exception e){	
gateway service issue 

try {	checkL2GatewayServiceSharedNetwork(niciraNvpHost);	}	catch (Exception e){	return null;	}	}	final CreateLogicalSwitchCommand cmd = new CreateLogicalSwitchCommand(transportzoneuuid, transportzoneisotype, name, context.getDomain().getName() + "-" + context.getAccount().getAccountName());	final CreateLogicalSwitchAnswer answer = (CreateLogicalSwitchAnswer) agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
createlogicalswitchcommand failed 

public void shutdown(final NetworkProfile profile, final NetworkOffering offering) {	final NetworkVO networkObject = networkDao.findById(profile.getId());	if (networkObject.getBroadcastDomainType() != BroadcastDomainType.Lswitch || networkObject.getBroadcastUri() == null) {	
broadcasturi is empty or incorrect for guestnetwork 

public void shutdown(final NetworkProfile profile, final NetworkOffering offering) {	final NetworkVO networkObject = networkDao.findById(profile.getId());	if (networkObject.getBroadcastDomainType() != BroadcastDomainType.Lswitch || networkObject.getBroadcastUri() == null) {	return;	}	final List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(networkObject.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

}	final NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	final HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	String logicalSwitchUuid = BroadcastDomainType.getValue(networkObject.getBroadcastUri());	if (offering.getGuestType().equals(GuestType.Shared)){	sharedNetworksCleanup(networkObject, logicalSwitchUuid, niciraNvpHost);	}	final DeleteLogicalSwitchCommand cmd = new DeleteLogicalSwitchCommand(logicalSwitchUuid);	final DeleteLogicalSwitchAnswer answer = (DeleteLogicalSwitchAnswer) agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
deletelogicalswitchcommand failed 

========================= cloudstack sample_1708 =========================

public FormatInfo process(String templatePath, ImageFormat format, String templateName) {	if (format != null) {	
we currently don t handle conversion from to tar 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) {	if (format != null) {	return null;	}	String tarPath = templatePath + File.separator + templateName + "." + ImageFormat.TAR.getFileExtension();	if (!_storage.exists(tarPath)) {	
unable to find the tar file 

========================= cloudstack sample_395 =========================

mergeConfigs(configs, params);	}	String aggregationRange = configs.get("usage.stats.job.aggregation.range");	String timeZoneStr = configs.get("usage.aggregation.timezone");	if (timeZoneStr == null) {	timeZoneStr = "GMT";	}	_usageTimezone = TimeZone.getTimeZone(timeZoneStr);	_aggregationDuration = Integer.parseInt(aggregationRange);	if (_aggregationDuration < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) {	
usage stats job aggregation range is to small using the minimum value of 

public boolean start() {	if (s_logger.isInfoEnabled()) {	
starting quota manager 

public boolean stop() {	if (s_logger.isInfoEnabled()) {	
stopping quota manager 

if (lastRealBalanceEntry != null){	aggrUsage = aggrUsage.add(lastRealBalanceEntry.getCreditBalance());	}	if (s_logger.isDebugEnabled()) {	s_logger.debug("Last balance entry  " + lastRealBalanceEntry + " AggrUsage=" + aggrUsage);	}	aggrUsage = aggrUsage.add(aggregateCreditBetweenDates(account, lastRealBalanceEntry.getUpdatedOn(), endDate));	}	for (QuotaUsageVO entry : quotaListForAccount) {	if (s_logger.isDebugEnabled()) {	
usage entry found 

private QuotaBalanceVO saveQuotaBalance(final AccountVO account, final BigDecimal aggrUsage, final Date endDate) {	QuotaBalanceVO newBalance = new QuotaBalanceVO(account.getAccountId(), account.getDomainId(), aggrUsage, endDate);	if (s_logger.isDebugEnabled()) {	
saving balance 

private BigDecimal aggregateCreditBetweenDates(final AccountVO account, final Date startDate, final Date endDate) {	BigDecimal aggrUsage = new BigDecimal(0);	List<QuotaBalanceVO> creditsReceived = null;	creditsReceived = _quotaBalanceDao.findCreditBalance(account.getAccountId(), account.getDomainId(), startDate, endDate);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Credit entries count " + creditsReceived.size() + " on Before Date=" + endDate);	}	if (creditsReceived != null) {	for (QuotaBalanceVO credit : creditsReceived) {	if (s_logger.isDebugEnabled()) {	
credit entry found 

========================= cloudstack sample_680 =========================

ImageStoreResponse storeResponse = null;	if (result != null ) {	storeResponse = _responseGenerator.createImageStoreResponse(result);	storeResponse.setResponseName(getCommandName());	storeResponse.setObjectName("imagestore");	setResponseObject(storeResponse);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add secondary storage");	}	} catch (DiscoveryException ex) {	
exception 

========================= cloudstack sample_3220 =========================

protected boolean canHandle(NetworkOffering offering, NetworkType networkType, PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && isMyIsolationMethod(physicalNetwork)) {	return true;	} else {	
we only take care of guest networks of type in zone of type using isolation method mido 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	
design called 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	if (physnet == null || physnet.getIsolationMethods() == null || !physnet.getIsolationMethods().contains("MIDO")) {	
refusing to design this network the physical isolation type is not mido 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	if (physnet == null || physnet.getIsolationMethods() == null || !physnet.getIsolationMethods().contains("MIDO")) {	return null;	}	
physical isolation type is mido asking guestnetworkguru to design this network 

public Network implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException {	assert (network.getState() == Network.State.Implementing) : "Why are we implementing " + network;	
implement called network 

AccountVO acc = _accountDao.findById(network.getAccountId());	String accountUUIDStr = acc.getUuid();	String routerName = "";	if (network.getVpcId() != null) {	routerName = "VPC" + String.valueOf(network.getVpcId());	} else {	routerName = String.valueOf(network.getId());	}	String broadcastUriStr = accountUUIDStr + "." + String.valueOf(network.getId()) + ":" + routerName;	implemented.setBroadcastUri(Networks.BroadcastDomainType.Mido.toUri(broadcastUriStr));	
broadcast uri set to 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException {	
reserve called with network nic vm 

public boolean release(NicProfile nic, VirtualMachineProfile vm, String reservationId) {	
release called with nic vm 

public void shutdown(NetworkProfile profile, NetworkOffering offering) {	
shutdown called 

public boolean trash(Network network, NetworkOffering offering) {	
trash called with network 

========================= cloudstack sample_1837 =========================

final MockConfigurationVO config = _mockConfigDao.findByNameBottomUP(host.getDataCenterId(), host.getPodId(), host.getClusterId(), host.getId(), cmdName);	if (config != null && (config.getCount() == null || config.getCount().intValue() > 0)) {	final Map<String, String> configParameters = config.getParameters();	for (final Map.Entry<String, String> entry : configParameters.entrySet()) {	if (entry.getKey().equalsIgnoreCase("enabled")) {	info.setEnabled(Boolean.parseBoolean(entry.getValue()));	} else if (entry.getKey().equalsIgnoreCase("timeout")) {	try {	info.setTimeout(Integer.valueOf(entry.getValue()));	} catch (final NumberFormatException e) {	
invalid timeout parameter 

try {	info.setTimeout(Integer.valueOf(entry.getValue()));	} catch (final NumberFormatException e) {	}	}	if (entry.getKey().equalsIgnoreCase("wait")) {	try {	final int wait = Integer.valueOf(entry.getValue());	Thread.sleep(wait);	} catch (final NumberFormatException e) {	
invalid wait parameter 

info.setTimeout(Integer.valueOf(entry.getValue()));	} catch (final NumberFormatException e) {	}	}	if (entry.getKey().equalsIgnoreCase("wait")) {	try {	final int wait = Integer.valueOf(entry.getValue());	Thread.sleep(wait);	} catch (final NumberFormatException e) {	} catch (final InterruptedException e) {	
thread is interrupted 

answer = _mockVmMgr.scaleVm((ScaleVmCommand)cmd);	} else if (cmd instanceof PvlanSetupCommand) {	answer = _mockNetworkMgr.setupPVLAN((PvlanSetupCommand)cmd);	} else if (cmd instanceof StorageSubSystemCommand) {	answer = storageHandler.handleStorageCommands((StorageSubSystemCommand)cmd);	} else if (cmd instanceof FenceCommand) {	answer = _mockVmMgr.fence((FenceCommand)cmd);	} else if (cmd instanceof GetRouterAlertsCommand || cmd instanceof VpnUsersCfgCommand || cmd instanceof RemoteAccessVpnCfgCommand || cmd instanceof SetMonitorServiceCommand || cmd instanceof AggregationControlCommand || cmd instanceof SecStorageFirewallCfgCommand) {	answer = new Answer(cmd);	} else {	
simulator does not implement command of type 

}	}	if (config != null && config.getCount() != null && config.getCount().intValue() > 0) {	if (answer != null) {	config.setCount(config.getCount().intValue() - 1);	_mockConfigDao.update(config.getId(), config);	}	}	return answer;	} catch (final Exception e) {	
failed execute cmd 

========================= cloudstack sample_950 =========================

public void handle(HttpExchange t) throws IOException {	try {	Thread.currentThread().setName("Cmd Thread " + Thread.currentThread().getId() + " " + t.getRemoteAddress());	
cmdhandler 

Thread.currentThread().setName("Cmd Thread " + Thread.currentThread().getId() + " " + t.getRemoteAddress());	doHandle(t);	} catch (Exception e) {	s_logger.error(e.toString(), e);	String response = "Not found";	t.sendResponseHeaders(404, response.length());	OutputStream os = t.getResponseBody();	os.write(response.getBytes());	os.close();	} catch (OutOfMemoryError e) {	
unrecoverable outofmemory error exit and let it be re launched 

public void doHandle(HttpExchange t) throws Exception {	String path = t.getRequestURI().getPath();	int i = path.indexOf("/", 1);	String cmd = path.substring(i + 1);	
get cmd request for 

========================= cloudstack sample_4967 =========================

public Answer execute(ConfigureSharedNetworkVlanIdCommand command, NiciraNvpResource niciraNvpResource) {	final String logicalSwitchUuid = command.getLogicalSwitchUuid();	final String l2GatewayServiceUuid = command.getL2GatewayServiceUuid();	long vlanId = command.getVlanId();	final List<NiciraNvpTag> tags = new ArrayList<NiciraNvpTag>();	tags.add(new NiciraNvpTag("cs_account", command.getOwnerName()));	final long networkId = command.getNetworkId();	
connecting logical switch to gateway service vlan id network 

public Answer execute(ConfigureSharedNetworkVlanIdCommand command, NiciraNvpResource niciraNvpResource) {	final String logicalSwitchUuid = command.getLogicalSwitchUuid();	final String l2GatewayServiceUuid = command.getL2GatewayServiceUuid();	long vlanId = command.getVlanId();	final List<NiciraNvpTag> tags = new ArrayList<NiciraNvpTag>();	tags.add(new NiciraNvpTag("cs_account", command.getOwnerName()));	final long networkId = command.getNetworkId();	final NiciraNvpApi niciraNvpApi = niciraNvpResource.getNiciraNvpApi();	
creating logical switch port in logical switch 

final NiciraNvpApi niciraNvpApi = niciraNvpResource.getNiciraNvpApi();	LogicalSwitchPort lSwitchPort = null;	try {	lSwitchPort = new LogicalSwitchPort();	lSwitchPort.setAdminStatusEnabled(true);	lSwitchPort.setDisplayName(niciraNvpResource.truncate(networkId + "-l2Gateway-port", NAME_MAX_LEN));	lSwitchPort.setTags(tags);	lSwitchPort = niciraNvpApi.createLogicalSwitchPort(logicalSwitchUuid, lSwitchPort);	}	catch (NiciraNvpApiException e){	
could not create logical switch port on logical switch due to retrying 

try {	lSwitchPort = new LogicalSwitchPort();	lSwitchPort.setAdminStatusEnabled(true);	lSwitchPort.setDisplayName(niciraNvpResource.truncate(networkId + "-l2Gateway-port", NAME_MAX_LEN));	lSwitchPort.setTags(tags);	lSwitchPort = niciraNvpApi.createLogicalSwitchPort(logicalSwitchUuid, lSwitchPort);	}	catch (NiciraNvpApiException e){	return handleException(e, command, niciraNvpResource);	}	
logical switch port successfully created in logical switch 

try {	lSwitchPort = new LogicalSwitchPort();	lSwitchPort.setAdminStatusEnabled(true);	lSwitchPort.setDisplayName(niciraNvpResource.truncate(networkId + "-l2Gateway-port", NAME_MAX_LEN));	lSwitchPort.setTags(tags);	lSwitchPort = niciraNvpApi.createLogicalSwitchPort(logicalSwitchUuid, lSwitchPort);	}	catch (NiciraNvpApiException e){	return handleException(e, command, niciraNvpResource);	}	
attaching logical switch port on vlan using 

return handleException(e, command, niciraNvpResource);	}	try {	final L2GatewayAttachment attachment = new L2GatewayAttachment(l2GatewayServiceUuid);	if (command.getVlanId() != 0) {	attachment.setVlanId(command.getVlanId());	}	niciraNvpApi.updateLogicalSwitchPortAttachment(logicalSwitchUuid, lSwitchPort.getUuid(), attachment);	}	catch (NiciraNvpApiException e){	
could not attach logical switch port to logical switch port due to errorcode 

final L2GatewayAttachment attachment = new L2GatewayAttachment(l2GatewayServiceUuid);	if (command.getVlanId() != 0) {	attachment.setVlanId(command.getVlanId());	}	niciraNvpApi.updateLogicalSwitchPortAttachment(logicalSwitchUuid, lSwitchPort.getUuid(), attachment);	}	catch (NiciraNvpApiException e){	cleanup(logicalSwitchUuid, lSwitchPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
logical switch port successfully attached on vlan using 

final L2GatewayAttachment attachment = new L2GatewayAttachment(l2GatewayServiceUuid);	if (command.getVlanId() != 0) {	attachment.setVlanId(command.getVlanId());	}	niciraNvpApi.updateLogicalSwitchPortAttachment(logicalSwitchUuid, lSwitchPort.getUuid(), attachment);	}	catch (NiciraNvpApiException e){	cleanup(logicalSwitchUuid, lSwitchPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
successfully connected logical switch to gateway service vlan id network through logical switch port 

private Answer handleException(NiciraNvpApiException e, ConfigureSharedNetworkVlanIdCommand command, NiciraNvpResource niciraNvpResource) {	if (HttpStatusCodeHelper.isConflict(e.getErrorCode())){	
there s been a conflict in nsx side aborting implementation 

private Answer handleException(NiciraNvpApiException e, ConfigureSharedNetworkVlanIdCommand command, NiciraNvpResource niciraNvpResource) {	if (HttpStatusCodeHelper.isConflict(e.getErrorCode())){	return new ConfigureSharedNetworkVlanIdAnswer(command, false, "FAILED: There's been a conflict in NSX side");	}	else {	
error code retrying 

========================= cloudstack sample_1773 =========================

public void requestSiteOutput(final TransportEndpointSite site) {	_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	try {	site.processOutput();	site.ackOutputProcessSignal();	} catch (Throwable e) {	
unhandled exception 

========================= cloudstack sample_614 =========================

}	}	}	try {	FirewallRule result = _firewallService.createIngressFirewallRule(this);	if (result != null) {	setEntityId(result.getId());	setEntityUuid(result.getUuid());	}	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

}	}	}	try {	FirewallRule result = _firewallService.createIngressFirewallRule(this);	if (result != null) {	setEntityId(result.getId());	setEntityUuid(result.getUuid());	}	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

========================= cloudstack sample_3467 =========================

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	if (s_logger.isDebugEnabled()) {	
public network deallocate network networkid ip 

if (ip != null && nic.getReservationStrategy() != ReservationStrategy.Managed) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	_ipAddrMgr.markIpAsUnavailable(ip.getId());	_ipAddressDao.unassignIpAddress(ip.getId());	}	});	}	nic.deallocate();	if (s_logger.isDebugEnabled()) {	
deallocated nic 

========================= cloudstack sample_2276 =========================

List<Site2SiteVpnConnectionVO> conns = _vpnConnectionDao.listByVpcId(vpcId);	for (Site2SiteVpnConnectionVO conn : conns) {	if (conn == null) {	continue;	}	if (conn.getState() == Site2SiteVpnConnection.State.Disconnected) {	try {	startVpnConnection(conn.getId());	} catch (ResourceUnavailableException e) {	Site2SiteCustomerGatewayVO gw = _customerGatewayDao.findById(conn.getCustomerGatewayId());	
fail to re initiate vpn connection which connect to 

========================= cloudstack sample_2299 =========================

if (attributeStatements == null || attributeStatements.size() < 1 || attributeKey == null) {	return null;	}	for (AttributeStatement attributeStatement : attributeStatements) {	if (attributeStatement == null || attributeStatements.size() < 1) {	continue;	}	for (Attribute attribute : attributeStatement.getAttributes()) {	if (attribute.getAttributeValues() != null && attribute.getAttributeValues().size() > 0) {	String value = attribute.getAttributeValues().get(0).getDOM().getTextContent();	
saml attribute name friendly name value 

String redirectUrl = "";	try {	DefaultBootstrap.bootstrap();	AuthnRequest authnRequest = SAMLUtils.buildAuthnRequestObject(authnId, spMetadata.getEntityId(), idpMetadata.getSsoUrl(), spMetadata.getSsoUrl());	PrivateKey privateKey = null;	if (spMetadata.getKeyPair() != null) {	privateKey = spMetadata.getKeyPair().getPrivate();	}	redirectUrl = idpMetadata.getSsoUrl() + "?" + SAMLUtils.generateSAMLRequestSignature("SAMLRequest=" + SAMLUtils.encodeSAMLRequest(authnRequest), privateKey, signatureAlgorithm);	} catch (ConfigurationException | FactoryConfigurationError | MarshallingException | IOException | NoSuchAlgorithmException | InvalidKeyException | java.security.SignatureException e) {	
saml authnrequest message building error 

public static KeyFactory getKeyFactory() {	KeyFactory keyFactory = null;	try {	Security.addProvider(new BouncyCastleProvider());	keyFactory = KeyFactory.getInstance("RSA", "BC");	} catch (NoSuchAlgorithmException | NoSuchProviderException e) {	
unable to create keyfactory 

public static String savePublicKey(PublicKey key) {	try {	KeyFactory keyFactory = SAMLUtils.getKeyFactory();	if (keyFactory == null) return null;	X509EncodedKeySpec spec = keyFactory.getKeySpec(key, X509EncodedKeySpec.class);	return new String(org.bouncycastle.util.encoders.Base64.encode(spec.getEncoded()), Charset.forName("UTF-8"));	} catch (InvalidKeySpecException e) {	
unable to create keyfactory 

public static String savePrivateKey(PrivateKey key) {	try {	KeyFactory keyFactory = SAMLUtils.getKeyFactory();	if (keyFactory == null) return null;	PKCS8EncodedKeySpec spec = keyFactory.getKeySpec(key, PKCS8EncodedKeySpec.class);	return new String(org.bouncycastle.util.encoders.Base64.encode(spec.getEncoded()), Charset.forName("UTF-8"));	} catch (InvalidKeySpecException e) {	
unable to create keyfactory 

public static PublicKey loadPublicKey(String publicKey) {	byte[] sigBytes = org.bouncycastle.util.encoders.Base64.decode(publicKey);	X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);	KeyFactory keyFact = SAMLUtils.getKeyFactory();	if (keyFact == null) return null;	try {	return keyFact.generatePublic(x509KeySpec);	} catch (InvalidKeySpecException e) {	
unable to create privatekey from privatekey string 

public static PrivateKey loadPrivateKey(String privateKey) {	byte[] sigBytes = org.bouncycastle.util.encoders.Base64.decode(privateKey);	PKCS8EncodedKeySpec pkscs8KeySpec = new PKCS8EncodedKeySpec(sigBytes);	KeyFactory keyFact = SAMLUtils.getKeyFactory();	if (keyFact == null) return null;	try {	return keyFact.generatePrivate(pkscs8KeySpec);	} catch (InvalidKeySpecException e) {	
unable to create privatekey from privatekey string 

========================= cloudstack sample_1374 =========================

){	long poolId = rs.getLong(1);	pstmt.setLong(1, poolId);	try(ResultSet dhrs = sel_pstmt.executeQuery();) {	String help = formatDuplicateHostToReadText(poolId, dhrs);	helpInfo.append(help);	helpInfo.append("\n");	noDuplicate = false;	}	catch (Exception e) {	
checkduplicatehostwiththesamelocalstorage exception 

String help = formatDuplicateHostToReadText(poolId, dhrs);	helpInfo.append(help);	helpInfo.append("\n");	noDuplicate = false;	}	catch (Exception e) {	throw new CloudRuntimeException("checkDuplicateHostWithTheSameLocalStorage: Exception :" + e.getMessage(),e);	}	}	catch (Exception e) {	
checkduplicatehostwiththesamelocalstorage exception 

}	catch (Exception e) {	throw new CloudRuntimeException("checkDuplicateHostWithTheSameLocalStorage: Exception :" + e.getMessage(),e);	}	}	catch (Exception e) {	throw new CloudRuntimeException("checkDuplicateHostWithTheSameLocalStorage: Exception :" + e.getMessage(),e);	}	}	if (noDuplicate) {	
no duplicate hosts with the same local storage found in database 

throw new CloudRuntimeException("checkDuplicateHostWithTheSameLocalStorage: Exception :" + e.getMessage(),e);	}	}	if (noDuplicate) {	} else {	s_logger.error(helpInfo.toString());	}	txn.commit();	return noDuplicate;	}catch (Exception e) {	
checkduplicatehostwiththesamelocalstorage exception 

} else {	s_logger.error(helpInfo.toString());	}	txn.commit();	return noDuplicate;	}catch (Exception e) {	throw new CloudRuntimeException("checkDuplicateHostWithTheSameLocalStorage: Exception :" + e.getMessage(),e);	}	}	catch (Exception e) {	
checkduplicatehostwiththesamelocalstorage exception 

}	catch (Exception e) {	throw new CloudRuntimeException("checkDuplicateHostWithTheSameLocalStorage: Exception :" + e.getMessage(),e);	}	finally {	try {	if (txn != null) {	txn.close();	}	}catch(Exception e) {	
checkduplicatehostwiththesamelocalstorage exception 

private boolean check21to22PremiumUprage(Connection conn) throws SQLException {	try (PreparedStatement pstmt = conn.prepareStatement("show tables in cloud_usage");	ResultSet rs = pstmt.executeQuery();) {	int num = 0;	while (rs.next()) {	String tableName = rs.getString(1);	if (tableName.equalsIgnoreCase("usage_event") || tableName.equalsIgnoreCase("usage_port_forwarding") || tableName.equalsIgnoreCase("usage_network_offering")) {	num++;	
checking table found 

private boolean isColumnExisted(Connection conn, String dbName, String tableName, String column) throws SQLException {	try (PreparedStatement pstmt = conn.prepareStatement(String.format("describe %1$s.%2$s", dbName, tableName));	ResultSet rs = pstmt.executeQuery();) {	boolean found = false;	while (rs.next()) {	if (column.equalsIgnoreCase(rs.getString(1))) {	
column s s s found 

}	boolean hasUsage = false;	while (rs.next()) {	String dbName = rs.getString(1);	if (dbName.equalsIgnoreCase("cloud_usage")) {	hasUsage = true;	break;	}	}	if (!hasUsage) {	
no cloud usage found in database no need to check missed premium upgrade 

if (dbName.equalsIgnoreCase("cloud_usage")) {	hasUsage = true;	break;	}	}	if (!hasUsage) {	txn.commit();	return true;	}	if (!check21to22PremiumUprage(conn)) {	
premium upgrade missed 

}	if (!hasUsage) {	txn.commit();	return true;	}	if (!check21to22PremiumUprage(conn)) {	txn.commit();	return false;	}	if (!check221to222PremiumUprage(conn)) {	
premium upgrade missed 

}	if (!check21to22PremiumUprage(conn)) {	txn.commit();	return false;	}	if (!check221to222PremiumUprage(conn)) {	txn.commit();	return false;	}	if (!check222to224PremiumUpgrade(conn)) {	
premium upgrade missed 

txn.commit();	return false;	}	if (!check222to224PremiumUpgrade(conn)) {	txn.commit();	return false;	}	txn.commit();	return true;	} catch (Exception e) {	
exception 

if (!check222to224PremiumUpgrade(conn)) {	txn.commit();	return false;	}	txn.commit();	return true;	} catch (Exception e) {	throw new CloudRuntimeException("checkMissedPremiumUpgradeFor228: Exception:" + e.getMessage(), e);	}	}catch (Exception e) {	
exception 

}	}catch (Exception e) {	throw new CloudRuntimeException("checkMissedPremiumUpgradeFor228: Exception:" + e.getMessage(),e);	}	finally {	try {	if (txn != null) {	txn.close();	}	}catch(Exception e) {	
exception 

public void check() {	GlobalLock lock = GlobalLock.getInternLock("DatabaseIntegrity");	try {	
grabbing lock to check for database integrity 

public void check() {	GlobalLock lock = GlobalLock.getInternLock("DatabaseIntegrity");	try {	if (!lock.lock(20 * 60)) {	throw new CloudRuntimeException("Unable to acquire lock to check for database integrity.");	}	try {	
performing database integrity check 

GlobalLock lock = GlobalLock.getInternLock("DatabaseIntegrity");	try {	if (!lock.lock(20 * 60)) {	throw new CloudRuntimeException("Unable to acquire lock to check for database integrity.");	}	try {	if (!checkDuplicateHostWithTheSameLocalStorage()) {	throw new CloudRuntimeException("checkDuplicateHostWithTheSameLocalStorage detected error");	}	if (!checkMissedPremiumUpgradeFor228()) {	
your current database version is management server detected some missed premium upgrade please contact cloudstack support and attach log file thank you 

public boolean start() {	try {	check();	} catch (Exception e) {	
system integrity check exception 

========================= cloudstack sample_4176 =========================

StoragePoolVO vo = dataStoreDao.findById(pdsv.getId());	if (vo.getScope() == ScopeType.CLUSTER) {	return new ClusterScope(vo.getClusterId(), vo.getPodId(), vo.getDataCenterId());	} else if (vo.getScope() == ScopeType.ZONE) {	return new ZoneScope(vo.getDataCenterId());	} else if (vo.getScope() == ScopeType.HOST) {	List<StoragePoolHostVO> poolHosts = poolHostDao.listByPoolId(vo.getId());	if (poolHosts.size() > 0) {	return new HostScope(poolHosts.get(0).getHostId(), vo.getClusterId(), vo.getDataCenterId());	}	
can t find a local storage in pool host table 

public DataObject create(DataObject obj, boolean createEntryInTempSpoolRef) {	if (obj.getType() == DataObjectType.TEMPLATE && (!isManaged() || (createEntryInTempSpoolRef && canCloneVolume()))) {	try {	String templateIdPoolIdString = "templateId:" + obj.getId() + "poolId:" + getId();	VMTemplateStoragePoolVO templateStoragePoolRef;	GlobalLock lock = GlobalLock.getInternLock(templateIdPoolIdString);	if (!lock.lock(5)) {	
couldn t lock the db on the string 

String templateIdPoolIdString = "templateId:" + obj.getId() + "poolId:" + getId();	VMTemplateStoragePoolVO templateStoragePoolRef;	GlobalLock lock = GlobalLock.getInternLock(templateIdPoolIdString);	if (!lock.lock(5)) {	return null;	}	try {	templateStoragePoolRef = templatePoolDao.findByPoolTemplate(getId(), obj.getId());	if (templateStoragePoolRef == null) {	if (s_logger.isDebugEnabled()) {	
not found in template spool ref persisting it 

try {	templateStoragePoolRef = templatePoolDao.findByPoolTemplate(getId(), obj.getId());	if (templateStoragePoolRef == null) {	if (s_logger.isDebugEnabled()) {	}	templateStoragePoolRef = new VMTemplateStoragePoolVO(getId(), obj.getId());	templateStoragePoolRef = templatePoolDao.persist(templateStoragePoolRef);	}	} catch (Throwable t) {	if (s_logger.isDebugEnabled()) {	
failed to insert to template spool ref 

templateStoragePoolRef = templatePoolDao.persist(templateStoragePoolRef);	}	} catch (Throwable t) {	if (s_logger.isDebugEnabled()) {	}	templateStoragePoolRef = templatePoolDao.findByPoolTemplate(getId(), obj.getId());	if (templateStoragePoolRef == null) {	throw new CloudRuntimeException("Failed to create template storage pool entry");	} else {	if (s_logger.isDebugEnabled()) {	
another thread already inserts to template spool ref 

throw new CloudRuntimeException("Failed to create template storage pool entry");	} else {	if (s_logger.isDebugEnabled()) {	}	}	} finally {	lock.unlock();	lock.releaseRef();	}	} catch (Exception e) {	
caught exception 

========================= cloudstack sample_3963 =========================

public void testGetIp6FromRange() {	assertEquals(NetUtils.getIp6FromRange("1234:5678::1-1234:5678::1"), "1234:5678::1");	for (int i = 0; i < 5; i++) {	final String ip = NetUtils.getIp6FromRange("1234:5678::1-1234:5678::2");	assertThat(ip, anyOf(equalTo("1234:5678::1"), equalTo("1234:5678::2")));	
ip is 

assertEquals(NetUtils.getIp6FromRange("1234:5678::1-1234:5678::1"), "1234:5678::1");	for (int i = 0; i < 5; i++) {	final String ip = NetUtils.getIp6FromRange("1234:5678::1-1234:5678::2");	assertThat(ip, anyOf(equalTo("1234:5678::1"), equalTo("1234:5678::2")));	}	String ipString = null;	final IPv6Address ipStart = IPv6Address.fromString("1234:5678::1");	final IPv6Address ipEnd = IPv6Address.fromString("1234:5678::ffff:ffff:ffff:ffff");	for (int i = 0; i < 10; i++) {	ipString = NetUtils.getIp6FromRange(ipStart.toString() + "-" + ipEnd.toString());	
ip is 

========================= cloudstack sample_2671 =========================

public Boolean fenceOff(VirtualMachine vm, Host host) {	if (host.getHypervisorType() != HypervisorType.Ovm3) {	
don t know how to fence non hosts 

public Boolean fenceOff(VirtualMachine vm, Host host) {	if (host.getHypervisorType() != HypervisorType.Ovm3) {	return null;	} else {	
fencing on host with params 

}	List<HostVO> hosts = resourceMgr.listAllHostsInCluster(host .getClusterId());	FenceCommand fence = new FenceCommand(vm, host);	for (HostVO h : hosts) {	if (h.getHypervisorType() == HypervisorType.Ovm3 && h.getStatus() == Status.Up && h.getId() != host.getId()) {	FenceAnswer answer;	try {	answer = (FenceAnswer) agentMgr.send(h.getId(), fence);	} catch (AgentUnavailableException | OperationTimedoutException e) {	if (LOGGER.isDebugEnabled()) {	
moving on to the next host because is unavailable 

if (LOGGER.isDebugEnabled()) {	}	continue;	}	if (answer != null && answer.getResult()) {	return true;	}	}	}	if (LOGGER.isDebugEnabled()) {	
unable to fence off on 

========================= cloudstack sample_839 =========================

public void onSuccess(SampleStoragePrepareAnswer result) {	
storageprepare return result 

public void onFailure(RpcException e) {	
storageprepare failed 

========================= cloudstack sample_585 =========================

public boolean addVpcRouterToGuestNetwork(final VirtualRouter router, final Network network, final Map<VirtualMachineProfile.Param, Object> params) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (network.getTrafficType() != TrafficType.Guest) {	
network is not of type 

if (network.getTrafficType() != TrafficType.Guest) {	return false;	}	boolean result = true;	try {	_routerDao.addRouterToGuestNetwork(router, network);	final NicProfile guestNic = _itMgr.addVmToNetwork(router, network, null);	if (guestNic != null) {	result = setupVpcGuestNetwork(network, router, true, guestNic);	} else {	
failed to add router to guest network 

final NicProfile guestNic = _itMgr.addVmToNetwork(router, network, null);	if (guestNic != null) {	result = setupVpcGuestNetwork(network, router, true, guestNic);	} else {	result = false;	}	if (result && params.get(Param.ReProgramGuestNetworks) != null && (Boolean) params.get(Param.ReProgramGuestNetworks) == true) {	sendNetworkRulesToRouter(router.getId(), network.getId());	}	} catch (final Exception ex) {	
failed to add router to network due to 

} else {	result = false;	}	if (result && params.get(Param.ReProgramGuestNetworks) != null && (Boolean) params.get(Param.ReProgramGuestNetworks) == true) {	sendNetworkRulesToRouter(router.getId(), network.getId());	}	} catch (final Exception ex) {	result = false;	} finally {	if (!result) {	
removing the router from network as a part of cleanup 

result = false;	}	if (result && params.get(Param.ReProgramGuestNetworks) != null && (Boolean) params.get(Param.ReProgramGuestNetworks) == true) {	sendNetworkRulesToRouter(router.getId(), network.getId());	}	} catch (final Exception ex) {	result = false;	} finally {	if (!result) {	if (removeVpcRouterFromGuestNetwork(router, network)) {	
removed the router from network as a part of cleanup 

}	if (result && params.get(Param.ReProgramGuestNetworks) != null && (Boolean) params.get(Param.ReProgramGuestNetworks) == true) {	sendNetworkRulesToRouter(router.getId(), network.getId());	}	} catch (final Exception ex) {	result = false;	} finally {	if (!result) {	if (removeVpcRouterFromGuestNetwork(router, network)) {	} else {	
failed to remove the router from network as a part of cleanup 

sendNetworkRulesToRouter(router.getId(), network.getId());	}	} catch (final Exception ex) {	result = false;	} finally {	if (!result) {	if (removeVpcRouterFromGuestNetwork(router, network)) {	} else {	}	} else {	
succesfully added router to guest network 

public boolean removeVpcRouterFromGuestNetwork(final VirtualRouter router, final Network network) throws ConcurrentOperationException, ResourceUnavailableException {	if (network.getTrafficType() != TrafficType.Guest) {	
network is not of type 

public boolean removeVpcRouterFromGuestNetwork(final VirtualRouter router, final Network network) throws ConcurrentOperationException, ResourceUnavailableException {	if (network.getTrafficType() != TrafficType.Guest) {	return false;	}	boolean result = true;	try {	if (!_networkModel.isVmPartOfNetwork(router.getId(), network.getId())) {	
router is not a part of the guest network 

if (network.getTrafficType() != TrafficType.Guest) {	return false;	}	boolean result = true;	try {	if (!_networkModel.isVmPartOfNetwork(router.getId(), network.getId())) {	return result;	}	result = setupVpcGuestNetwork(network, router, false, _networkModel.getNicProfile(router, network.getId(), null));	if (!result) {	
failed to destroy guest network config on router 

protected boolean setupVpcGuestNetwork(final Network network, final VirtualRouter router, final boolean add, final NicProfile guestNic) throws ConcurrentOperationException, ResourceUnavailableException {	boolean result = true;	if (router.getState() == State.Running) {	final SetupGuestNetworkCommand setupCmd = _commandSetupHelper.createSetupGuestNetworkCommand((DomainRouterVO) router, add, guestNic);	final Commands cmds = new Commands(Command.OnError.Stop);	cmds.addCommand("setupguestnetwork", setupCmd);	_nwHelper.sendCommandsToRouter(router, cmds);	final Answer setupAnswer = cmds.getAnswer("setupguestnetwork");	final String setup = add ? "set" : "destroy";	if (!(setupAnswer != null && setupAnswer.getResult())) {	
unable to guest network on router 

final Commands cmds = new Commands(Command.OnError.Stop);	cmds.addCommand("setupguestnetwork", setupCmd);	_nwHelper.sendCommandsToRouter(router, cmds);	final Answer setupAnswer = cmds.getAnswer("setupguestnetwork");	final String setup = add ? "set" : "destroy";	if (!(setupAnswer != null && setupAnswer.getResult())) {	result = false;	}	return result;	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	
router is in so not sending setup guest network command to the backend 

_nwHelper.sendCommandsToRouter(router, cmds);	final Answer setupAnswer = cmds.getAnswer("setupguestnetwork");	final String setup = add ? "set" : "destroy";	if (!(setupAnswer != null && setupAnswer.getResult())) {	result = false;	}	return result;	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	return true;	} else {	
unable to setup guest network on virtual router is not in the right state 

String defaultDns1 = null;	String defaultDns2 = null;	final Iterator<NicProfile> it = profile.getNics().iterator();	while (it.hasNext()) {	final NicProfile nic = it.next();	if (nic.getTrafficType() == TrafficType.Public || nic.getTrafficType() == TrafficType.Guest) {	if (nic.getTrafficType() == TrafficType.Public) {	defaultDns1 = nic.getIPv4Dns1();	defaultDns2 = nic.getIPv4Dns2();	}	
removing nic of type from the nics passed on vm start the nic will be plugged later 

final Vpc vpc = _entityMgr.findById(Vpc.class, vpcId);	buf.append(" vpccidr=" + vpc.getCidr() + " domain=" + vpc.getNetworkDomain());	buf.append(" dns1=").append(defaultDns1);	if (defaultDns2 != null) {	buf.append(" dns2=").append(defaultDns2);	}	VpcGatewayVO privateGatewayForVpc = _vpcGatewayDao.getPrivateGatewayForVpc(domainRouterVO.getVpcId());	if (privateGatewayForVpc != null) {	String ip4Address = privateGatewayForVpc.getIp4Address();	buf.append(" privategateway=").append(ip4Address);	
set privategateway field in cmd line json to 

details = vmTO.getDetails();	}	}	final boolean isVpc = domainRouterVO.getVpcId() != null;	if (!isVpc) {	return super.finalizeCommandsOnStart(cmds, profile);	}	if (domainRouterVO.getState() == State.Starting || domainRouterVO.getState() == State.Running) {	final NicProfile controlNic = getControlNic(profile);	if (controlNic == null) {	
control network doesn t exist for the router 

_commandSetupHelper.createVpcAssociatePrivateIPCommands(domainRouterVO, privateIps, cmds, true);	final Long privateGwAclId = _vpcGatewayDao.getNetworkAclIdForPrivateIp(ipVO.getVpcId(), ipVO.getNetworkId(), ipVO.getIpAddress());	if (privateGwAclId != null) {	final List<NetworkACLItemVO> networkACLs = _networkACLItemDao.listByACL(privateGwAclId);	s_logger.debug("Found " + networkACLs.size() + " network ACLs to apply as a part of VPC VR " + domainRouterVO + " start for private gateway ip = " + ipVO.getIpAddress());	_commandSetupHelper.createNetworkACLsCommands(networkACLs, domainRouterVO, cmds, ipVO.getNetworkId(), true);	}	}	}	} catch (final Exception ex) {	
failed to add router to network due to exception 

final List<StaticRouteProfile> staticRouteProfiles = new ArrayList<StaticRouteProfile>(routes.size());	final Map<Long, VpcGateway> gatewayMap = new HashMap<Long, VpcGateway>();	for (final StaticRoute route : routes) {	VpcGateway gateway = gatewayMap.get(route.getVpcGatewayId());	if (gateway == null) {	gateway = _entityMgr.findById(VpcGateway.class, route.getVpcGatewayId());	gatewayMap.put(gateway.getId(), gateway);	}	staticRouteProfiles.add(new StaticRouteProfile(route, gateway));	}	
found static routes to apply as a part of vpc route start 

final PrivateIpVO ipVO = _privateIpDao.findByIpAndSourceNetworkId(privateNic.getNetworkId(), privateNic.getIPv4Address());	final Network network = _networkDao.findById(privateNic.getNetworkId());	final String netmask = NetUtils.getCidrNetmask(network.getCidr());	final PrivateIpAddress ip = new PrivateIpAddress(ipVO, network.getBroadcastUri().toString(), network.getGateway(), netmask, privateNic.getMacAddress());	final List<PrivateIpAddress> privateIps = new ArrayList<PrivateIpAddress>(1);	privateIps.add(ip);	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createVpcAssociatePrivateIPCommands(router, privateIps, cmds, add);	try {	if (_nwHelper.sendCommandsToRouter(router, cmds)) {	
successfully applied ip association for ip in vpc network 

final String netmask = NetUtils.getCidrNetmask(network.getCidr());	final PrivateIpAddress ip = new PrivateIpAddress(ipVO, network.getBroadcastUri().toString(), network.getGateway(), netmask, privateNic.getMacAddress());	final List<PrivateIpAddress> privateIps = new ArrayList<PrivateIpAddress>(1);	privateIps.add(ip);	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createVpcAssociatePrivateIPCommands(router, privateIps, cmds, add);	try {	if (_nwHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	
failed to associate ip address in vpc network 

privateIps.add(ip);	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createVpcAssociatePrivateIPCommands(router, privateIps, cmds, add);	try {	if (_nwHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	return false;	}	} catch (final Exception ex) {	
failed to send add delete private network commands to rotuer 

try {	if (_nwHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	return false;	}	} catch (final Exception ex) {	return false;	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	
router is in so not sending setup private network command to the backend 

if (_nwHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	return false;	}	} catch (final Exception ex) {	return false;	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	} else {	
unable to setup private gateway virtual router is not in the right state 

public boolean destroyPrivateGateway(final PrivateGateway gateway, final VirtualRouter router) throws ConcurrentOperationException, ResourceUnavailableException {	boolean result = true;	if (!_networkModel.isVmPartOfNetwork(router.getId(), gateway.getNetworkId())) {	
router doesn t have nic for gateway so no need to removed it 

public boolean destroyPrivateGateway(final PrivateGateway gateway, final VirtualRouter router) throws ConcurrentOperationException, ResourceUnavailableException {	boolean result = true;	if (!_networkModel.isVmPartOfNetwork(router.getId(), gateway.getNetworkId())) {	return result;	}	final Network privateNetwork = _networkModel.getNetwork(gateway.getNetworkId());	final NicProfile nicProfile = _networkModel.getNicProfile(router, privateNetwork.getId(), null);	
releasing private ip for gateway from 

public boolean destroyPrivateGateway(final PrivateGateway gateway, final VirtualRouter router) throws ConcurrentOperationException, ResourceUnavailableException {	boolean result = true;	if (!_networkModel.isVmPartOfNetwork(router.getId(), gateway.getNetworkId())) {	return result;	}	final Network privateNetwork = _networkModel.getNetwork(gateway.getNetworkId());	final NicProfile nicProfile = _networkModel.getNicProfile(router, privateNetwork.getId(), null);	result = setupVpcPrivateNetwork(router, false, nicProfile);	if (!result) {	
failed to release private ip for gateway on router 

if (!_networkModel.isVmPartOfNetwork(router.getId(), gateway.getNetworkId())) {	return result;	}	final Network privateNetwork = _networkModel.getNetwork(gateway.getNetworkId());	final NicProfile nicProfile = _networkModel.getNicProfile(router, privateNetwork.getId(), null);	result = setupVpcPrivateNetwork(router, false, nicProfile);	if (!result) {	return false;	}	if (!_networkACLMgr.revokeACLItemsForPrivateGw(gateway)) {	
failed to delete network acl items on from router 

}	final Network privateNetwork = _networkModel.getNetwork(gateway.getNetworkId());	final NicProfile nicProfile = _networkModel.getNicProfile(router, privateNetwork.getId(), null);	result = setupVpcPrivateNetwork(router, false, nicProfile);	if (!result) {	return false;	}	if (!_networkACLMgr.revokeACLItemsForPrivateGw(gateway)) {	return false;	}	
removing router from private network as a part of delete private gateway 

final Network privateNetwork = _networkModel.getNetwork(gateway.getNetworkId());	final NicProfile nicProfile = _networkModel.getNicProfile(router, privateNetwork.getId(), null);	result = setupVpcPrivateNetwork(router, false, nicProfile);	if (!result) {	return false;	}	if (!_networkACLMgr.revokeACLItemsForPrivateGw(gateway)) {	return false;	}	result = result && _itMgr.removeVmFromNetwork(router, privateNetwork, null);	
private gateawy is removed from router 

protected void finalizeIpAssocForNetwork(final Commands cmds, final VirtualRouter domainRouterVO, final Provider provider, final Long guestNetworkId, final Map<String, String> vlanMacAddress) {	if (domainRouterVO.getVpcId() == null) {	super.finalizeIpAssocForNetwork(cmds, domainRouterVO, provider, guestNetworkId, vlanMacAddress);	return;	}	if (domainRouterVO.getState() == State.Starting || domainRouterVO.getState() == State.Running) {	final ArrayList<? extends PublicIpAddress> publicIps = getPublicIpsToApply(domainRouterVO, provider, guestNetworkId, IpAddress.State.Releasing);	if (publicIps != null && !publicIps.isEmpty()) {	
found ip s to apply as a part of domr start 

public boolean startSite2SiteVpn(final Site2SiteVpnConnection conn, final VirtualRouter router) throws ResourceUnavailableException {	if (router.getState() != State.Running) {	
unable to apply site to site vpn configuration virtual router is not in the right state 

public boolean stopSite2SiteVpn(final Site2SiteVpnConnection conn, final VirtualRouter router) throws ResourceUnavailableException {	if (router.getState() != State.Running) {	
unable to apply site to site vpn configuration virtual router is not in the right state 

final Nic nic = _nicDao.findByNetworkIdInstanceIdAndBroadcastUri(publicNtwkId, router.getId(), broadcastUri.toString());	if (nic == null && nicsToPlug.get(ip.getVlanTag()) == null) {	nicsToPlug.put(ip.getVlanTag(), ip);	s_logger.debug("Need to plug the nic for ip=" + ip + "; vlan=" + ip.getVlanTag() + " in public network id =" + publicNtwkId);	} else {	final PublicIpAddress nicToUnplug = nicsToUnplug.get(ip.getVlanTag());	if (nicToUnplug != null) {	final NicVO nicVO = _nicDao.findByIp4AddressAndNetworkIdAndInstanceId(publicNtwkId, router.getId(), nicToUnplug.getAddress().addr());	nicVO.setIPv4Address(ip.getAddress().addr());	_nicDao.update(nicVO.getId(), nicVO);	
updated the nic with the new ip address 

public boolean startRemoteAccessVpn(final RemoteAccessVpn vpn, final VirtualRouter router) throws ResourceUnavailableException {	if (router.getState() != State.Running) {	
unable to apply remote access vpn configuration virtual router is not in the right state 

public boolean startRemoteAccessVpn(final RemoteAccessVpn vpn, final VirtualRouter router) throws ResourceUnavailableException {	if (router.getState() != State.Running) {	throw new ResourceUnavailableException("Unable to apply remote access VPN configuration," + " virtual router is not in the right state", DataCenter.class, router.getDataCenterId());	}	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);	try {	_agentMgr.send(router.getHostId(), cmds);	} catch (final OperationTimedoutException e) {	
failed to start remote access vpn 

}	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);	try {	_agentMgr.send(router.getHostId(), cmds);	} catch (final OperationTimedoutException e) {	throw new AgentUnavailableException("Unable to send commands to virtual router ", router.getHostId(), e);	}	Answer answer = cmds.getAnswer("users");	if (!answer.getResult()) {	
unable to start vpn unable add users to vpn in zone for account on domr due to 

_agentMgr.send(router.getHostId(), cmds);	} catch (final OperationTimedoutException e) {	throw new AgentUnavailableException("Unable to send commands to virtual router ", router.getHostId(), e);	}	Answer answer = cmds.getAnswer("users");	if (!answer.getResult()) {	throw new ResourceUnavailableException("Unable to start vpn: Unable to add users to vpn in zone " + router.getDataCenterId() + " for account " + vpn.getAccountId() + " on domR: " + router.getInstanceName() + " due to " + answer.getDetails(), DataCenter.class, router.getDataCenterId());	}	answer = cmds.getAnswer("startVpn");	if (!answer.getResult()) {	
unable to start vpn in zone for account on domr due to 

public boolean stopRemoteAccessVpn(final RemoteAccessVpn vpn, final VirtualRouter router) throws ResourceUnavailableException {	boolean result = true;	if (router.getState() == State.Running) {	final Commands cmds = new Commands(Command.OnError.Continue);	_commandSetupHelper.createApplyVpnCommands(false, vpn, router, cmds);	result = result && _nwHelper.sendCommandsToRouter(router, cmds);	} else if (router.getState() == State.Stopped) {	
router is in stopped state not sending deleteremoteaccessvpn command to it 

public boolean stopRemoteAccessVpn(final RemoteAccessVpn vpn, final VirtualRouter router) throws ResourceUnavailableException {	boolean result = true;	if (router.getState() == State.Running) {	final Commands cmds = new Commands(Command.OnError.Continue);	_commandSetupHelper.createApplyVpnCommands(false, vpn, router, cmds);	result = result && _nwHelper.sendCommandsToRouter(router, cmds);	} else if (router.getState() == State.Stopped) {	} else {	
failed to delete remote access vpn domr is not in right state 

========================= cloudstack sample_2364 =========================

while(rs.next()) {	SyncQueueItemVO item = new SyncQueueItemVO();	item.setId(rs.getLong(1));	item.setQueueId(rs.getLong(2));	item.setContentType(rs.getString(3));	item.setContentId(rs.getLong(4));	item.setCreated(DateUtil.parseDateString(TimeZone.getTimeZone("GMT"), rs.getString(5)));	l.add(item);	}	} catch (SQLException e) {	
unexpected sql exception 

SyncQueueItemVO item = new SyncQueueItemVO();	item.setId(rs.getLong(1));	item.setQueueId(rs.getLong(2));	item.setContentType(rs.getString(3));	item.setContentId(rs.getLong(4));	item.setCreated(DateUtil.parseDateString(TimeZone.getTimeZone("GMT"), rs.getString(5)));	l.add(item);	}	} catch (SQLException e) {	} catch (Throwable e) {	
unexpected exception 

========================= cloudstack sample_710 =========================

return;	}	try {	vlan.destroy(conn);	final Host host = Host.getByUuid(conn, _host.getUuid());	host.forgetDataSourceArchives(conn, "pif_" + bridge + "_tx");	host.forgetDataSourceArchives(conn, "pif_" + bridge + "_rx");	host.forgetDataSourceArchives(conn, "pif_" + device + "." + vlannum + "_tx");	host.forgetDataSourceArchives(conn, "pif_" + device + "." + vlannum + "_rx");	} catch (final XenAPIException e) {	
catch failed to destory vlan on host due to 

public Boolean checkHeartbeat(final String hostuuid) {	final com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_host.getIp(), 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final String shcmd = "/opt/cloud/bin/check_heartbeat.sh " + hostuuid + " " + Integer.toString(_heartbeatInterval * 2);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, shcmd)) {	
heart beat is gone so dead 

final com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_host.getIp(), 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final String shcmd = "/opt/cloud/bin/check_heartbeat.sh " + hostuuid + " " + Integer.toString(_heartbeatInterval * 2);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, shcmd)) {	return false;	}	
heart beat is still going 

sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final String shcmd = "/opt/cloud/bin/check_heartbeat.sh " + hostuuid + " " + Integer.toString(_heartbeatInterval * 2);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, shcmd)) {	return false;	}	return true;	} catch (final Exception e) {	
health check failed due to catch exception 

========================= cloudstack sample_1227 =========================

pstmt.setLong(3, usage.getUserId());	pstmt.executeUpdate();	}	}catch (SQLException e) {	throw new CloudException("Error updating UsageVPNUserVO"+e.getMessage(), e);	}	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usagevpnuservo 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (deletedTS != null) {	deletedDate = DateUtil.parseDateString(s_gmtTimeZone, deletedTS);	}	usageRecords.add(new UsageVPNUserVO(zoneId, acctId, dId, userId, userName, createdDate, deletedDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4475 =========================

private Map<AgentResourceBase, Map<String, String>> createAgentResources(Map<String, Object> params) {	try {	
creating simulator resources 

private Map<AgentResourceBase, Map<String, String>> createAgentResources(Map<String, Object> params) {	try {	return _mockAgentMgr.createServerResources(params);	} catch (Exception ex) {	
caught exception at agent resource creation 

========================= cloudstack sample_985 =========================

public SslCertResponse uploadSslCert(final UploadSslCertCmd certCmd) {	Preconditions.checkNotNull(certCmd);	final String cert = certCmd.getCert();	final String key = certCmd.getKey();	final String password = certCmd.getPassword();	final String chain = certCmd.getChain();	validate(cert, key, password, chain);	
certificate validation succeeded 

}	if (lbRuleId != null) {	final LoadBalancer lb = _entityMgr.findById(LoadBalancerVO.class, lbRuleId);	if (lb == null) {	throw new InvalidParameterValueException("Found no loadbalancer with id: " + lbRuleId);	}	_accountMgr.checkAccess(caller, SecurityChecker.AccessType.UseEntry, true, lb);	LoadBalancerCertMapVO lbCertMapRule;	lbCertMapRule = _lbCertDao.findByLbRuleId(lbRuleId);	if (lbCertMapRule == null) {	
no certificate bound to loadbalancer id 

========================= cloudstack sample_2237 =========================

public void setUp() {	
setting up benchmark test 

protected void stopClient() {	for (NioClient client : clients) {	client.stop();	}	for (NioClient maliciousClient : maliciousClients) {	maliciousClient.stop();	}	
clients stopped 

protected void stopServer() {	server.stop();	
server stopped 

public void testConnection() {	while (!isTestsDone()) {	try {	
tests done waiting for completion 

public void testConnection() {	while (!isTestsDone()) {	try {	Thread.sleep(1000);	} catch (final InterruptedException e) {	Assert.fail(e.getMessage());	}	}	
tests done 

protected void doServerProcess(final byte[] data) {	oneMoreTestDone();	Assert.assertArrayEquals(testBytes, data);	
verify data received by server done 

protected void init() throws IOException {	_selector = Selector.open();	try {	_clientConnection = SocketChannel.open();	
connecting to 

public void doTask(final Task task) {	
malicious client received task 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	
client received connect task 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	try {	
sending data to server 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	try {	task.getLink().send(getTestBytes());	} catch (ClosedChannelException e) {	LOGGER.error(e.getMessage());	e.printStackTrace();	}	} else if (task.getType() == Task.Type.DATA) {	
client received data task 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	try {	task.getLink().send(getTestBytes());	} catch (ClosedChannelException e) {	LOGGER.error(e.getMessage());	e.printStackTrace();	}	} else if (task.getType() == Task.Type.DATA) {	} else if (task.getType() == Task.Type.DISCONNECT) {	
client received disconnect task 

try {	task.getLink().send(getTestBytes());	} catch (ClosedChannelException e) {	LOGGER.error(e.getMessage());	e.printStackTrace();	}	} else if (task.getType() == Task.Type.DATA) {	} else if (task.getType() == Task.Type.DISCONNECT) {	stopClient();	} else if (task.getType() == Task.Type.OTHER) {	
client received other task 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	
server received connect task 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	} else if (task.getType() == Task.Type.DATA) {	
server received data task 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	} else if (task.getType() == Task.Type.DATA) {	doServerProcess(task.getData());	} else if (task.getType() == Task.Type.DISCONNECT) {	
server received disconnect task 

public void doTask(final Task task) {	if (task.getType() == Task.Type.CONNECT) {	} else if (task.getType() == Task.Type.DATA) {	doServerProcess(task.getData());	} else if (task.getType() == Task.Type.DISCONNECT) {	stopServer();	} else if (task.getType() == Task.Type.OTHER) {	
server received other task 

========================= cloudstack sample_2667 =========================

domainResourceLimitMap.put(Resource.ResourceType.template, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainTemplates.key())));	domainResourceLimitMap.put(Resource.ResourceType.user_vm, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainUserVms.key())));	domainResourceLimitMap.put(Resource.ResourceType.volume, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainVolumes.key())));	domainResourceLimitMap.put(Resource.ResourceType.network, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainNetworks.key())));	domainResourceLimitMap.put(Resource.ResourceType.vpc, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainVpcs.key())));	domainResourceLimitMap.put(Resource.ResourceType.cpu, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainCpus.key())));	domainResourceLimitMap.put(Resource.ResourceType.memory, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainMemory.key())));	domainResourceLimitMap.put(Resource.ResourceType.primary_storage, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainPrimaryStorage.key())));	domainResourceLimitMap.put(Resource.ResourceType.secondary_storage, Long.parseLong(_configDao.getValue(Config.DefaultMaxDomainSecondaryStorage.key())));	} catch (NumberFormatException e) {	
numberformatexception during configuration 

public void incrementResourceCount(long accountId, ResourceType type, Long... delta) {	if (accountId == Account.ACCOUNT_ID_SYSTEM) {	
not incrementing resource count for system accounts returning 

public void decrementResourceCount(long accountId, ResourceType type, Long... delta) {	if (accountId == Account.ACCOUNT_ID_SYSTEM) {	
not decrementing resource count for system accounts returning 

try {	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean result = true;	Set<Long> rowsToLock = _resourceCountDao.listAllRowsToUpdate(accountId, ResourceOwnerType.Account, type);	SearchCriteria<ResourceCountVO> sc = ResourceCountSearch.create();	sc.setParameters("id", rowsToLock.toArray());	List<ResourceCountVO> rowsToUpdate = _resourceCountDao.lockRows(sc, null, true);	for (ResourceCountVO rowToUpdate : rowsToUpdate) {	if (!_resourceCountDao.updateById(rowToUpdate.getId(), increment, delta)) {	
unable to update resource count for the row 

protected void runInContext() {	
running resource count check periodic task 

========================= cloudstack sample_2372 =========================

while (iter.hasNext()) {	String arg = iter.next();	if (arg.equals("-u")) {	url = iter.next();	}	}	Properties prop = new Properties();	try {	prop.load(new FileInputStream("../conf/tool.properties"));	} catch (IOException ex) {	
error reading from conf tool properties 

Properties prop = new Properties();	try {	prop.load(new FileInputStream("../conf/tool.properties"));	} catch (IOException ex) {	System.exit(2);	}	host = prop.getProperty("host");	secretkey = prop.getProperty("secretkey");	port = prop.getProperty("port");	if (host == null) {	
please set host in tool properties file 

} catch (IOException ex) {	System.exit(2);	}	host = prop.getProperty("host");	secretkey = prop.getProperty("secretkey");	port = prop.getProperty("port");	if (host == null) {	System.exit(1);	}	if (port == null) {	
please set port in tool properties file 

host = prop.getProperty("host");	secretkey = prop.getProperty("secretkey");	port = prop.getProperty("port");	if (host == null) {	System.exit(1);	}	if (port == null) {	System.exit(1);	}	if (url == null) {	
please specify url with u option 

if (host == null) {	System.exit(1);	}	if (port == null) {	System.exit(1);	}	if (url == null) {	System.exit(1);	}	if (secretkey == null) {	
please set secretkey in tool properties file 

if (port == null) {	System.exit(1);	}	if (url == null) {	System.exit(1);	}	if (secretkey == null) {	System.exit(1);	}	if (prop.get("apikey") == null) {	
please set apikey in tool properties file 

if (url == null) {	System.exit(1);	}	if (secretkey == null) {	System.exit(1);	}	if (prop.get("apikey") == null) {	System.exit(1);	}	if (prop.get("accesspoint") == null) {	
please set apikey in tool properties file 

}	Set c = param.entrySet();	Iterator it = c.iterator();	while (it.hasNext()) {	Map.Entry me = (Map.Entry)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	try {	temp = temp + key + "=" + URLEncoder.encode(value, "UTF-8") + "&";	} catch (Exception ex) {	
unable to set parameter for the command command 

========================= cloudstack sample_439 =========================

String jarPath = filePath.substring(0, filePath.indexOf("!")).substring(filePath.indexOf(":") + 1);	if (jarPath.indexOf(":") >= 0) jarPath = jarPath.substring(1);	classes.addAll(getFromJARFile(jarPath, path));	} else {	classes.addAll(getFromDirectory(new File(filePath), packageName));	}	}	}	}	} catch (IOException e) {	
encountered ioexception 

if (jarPath.indexOf(":") >= 0) jarPath = jarPath.substring(1);	classes.addAll(getFromJARFile(jarPath, path));	} else {	classes.addAll(getFromDirectory(new File(filePath), packageName));	}	}	}	}	} catch (IOException e) {	} catch (ClassNotFoundException e) {	
ignored class not found 

static Set<Class<?>> getFromDirectory(File directory, String packageName) throws ClassNotFoundException {	Set<Class<?>> classes = new HashSet<Class<?>>();	if (directory.exists()) {	for (String file : directory.list()) {	if (file.endsWith(".class")) {	String name = packageName + '.' + stripFilenameExtension(file);	try {	Class<?> clazz = Class.forName(name);	classes.add(clazz);	} catch (ClassNotFoundException e) {	
ignored class not found in directory 

Set<Class<?>> classes = new HashSet<Class<?>>();	if (directory.exists()) {	for (String file : directory.list()) {	if (file.endsWith(".class")) {	String name = packageName + '.' + stripFilenameExtension(file);	try {	Class<?> clazz = Class.forName(name);	classes.add(clazz);	} catch (ClassNotFoundException e) {	} catch (Exception e) {	
encountered unexpect exception 

jarEntry = jarFile.getNextJarEntry();	if (jarEntry != null) {	String className = jarEntry.getName();	if (className.endsWith(".class")) {	className = stripFilenameExtension(className);	if (className.startsWith(packageName)) {	try {	Class<?> clz = Class.forName(className.replace('/', '.'));	classes.add(clz);	} catch (ClassNotFoundException | NoClassDefFoundError e) {	
unable to load class from jar file 

========================= cloudstack sample_593 =========================

public Integer call() throws Exception {	return process.waitFor();	}	});	try {	retVal = processFuture.get(timeOut.getStandardSeconds(), TimeUnit.SECONDS);	} catch (ExecutionException e) {	retVal = -2;	stdError = e.getMessage();	if (LOG.isTraceEnabled()) {	
failed to complete the requested command due to execution error 

retVal = processFuture.get(timeOut.getStandardSeconds(), TimeUnit.SECONDS);	} catch (ExecutionException e) {	retVal = -2;	stdError = e.getMessage();	if (LOG.isTraceEnabled()) {	}	} catch (TimeoutException e) {	retVal = -1;	stdError = "Operation timed out, aborted";	if (LOG.isTraceEnabled()) {	
failed to complete the requested command within timeout 

if (LOG.isTraceEnabled()) {	}	} finally {	if (Strings.isNullOrEmpty(stdError)) {	stdOutput = CharStreams.toString(new InputStreamReader(process.getInputStream()));	stdError = CharStreams.toString(new InputStreamReader(process.getErrorStream()));	}	process.destroy();	}	if (LOG.isTraceEnabled()) {	
process standard output 

if (LOG.isTraceEnabled()) {	}	} finally {	if (Strings.isNullOrEmpty(stdError)) {	stdOutput = CharStreams.toString(new InputStreamReader(process.getInputStream()));	stdError = CharStreams.toString(new InputStreamReader(process.getErrorStream()));	}	process.destroy();	}	if (LOG.isTraceEnabled()) {	
process standard error output 

if (Strings.isNullOrEmpty(stdError)) {	stdOutput = CharStreams.toString(new InputStreamReader(process.getInputStream()));	stdError = CharStreams.toString(new InputStreamReader(process.getErrorStream()));	}	process.destroy();	}	if (LOG.isTraceEnabled()) {	}	} catch (IOException | InterruptedException e) {	stdError = e.getMessage();	
exception caught error running commands 

========================= cloudstack sample_2722 =========================

public void testDedicateGuestVlanRange() throws Exception {	
running tests for dedicateguestvlanrange api 

public void testReleaseDedicatedGuestVlanRange() throws Exception {	
running tests for releasededicatedguestvlanrange api 

========================= cloudstack sample_2149 =========================

if (parameterAnnotation.required()) {	throw new ServerApiException(ApiErrorCode.PARAM_ERROR, "Unable to execute API command " + cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + " due to missing parameter " + parameterAnnotation.name());	}	continue;	}	try {	validateField(paramObj, parameterAnnotation);	setFieldValue(field, cmd, paramObj, parameterAnnotation);	} catch (final IllegalArgumentException argEx) {	if (s_logger.isDebugEnabled()) {	
unable to execute api command due to invalid value for parameter 

}	try {	validateField(paramObj, parameterAnnotation);	setFieldValue(field, cmd, paramObj, parameterAnnotation);	} catch (final IllegalArgumentException argEx) {	if (s_logger.isDebugEnabled()) {	}	throw new ServerApiException(ApiErrorCode.PARAM_ERROR, "Unable to execute API command " + cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + " due to invalid value " + paramObj + " for parameter " + parameterAnnotation.name());	} catch (final ParseException parseEx) {	if (s_logger.isDebugEnabled()) {	
invalid date parameter passed to command 

if (s_logger.isDebugEnabled()) {	}	throw new ServerApiException(ApiErrorCode.PARAM_ERROR, "Unable to execute API command " + cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + " due to invalid value " + paramObj + " for parameter " + parameterAnnotation.name());	} catch (final ParseException parseEx) {	if (s_logger.isDebugEnabled()) {	}	throw new ServerApiException(ApiErrorCode.PARAM_ERROR, "Unable to parse date " + paramObj + " for command " + cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + ", please pass dates in the format mentioned in the api documentation");	} catch (final InvalidParameterValueException invEx) {	throw new ServerApiException(ApiErrorCode.PARAM_ERROR, "Unable to execute API command " + cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + " due to invalid value. " + invEx.getMessage());	} catch (final CloudRuntimeException cloudEx) {	
CloudRuntimeException 

entitiesToAccess.put(entityObj, checkAccess.accessType());	break;	}	}	break;	default: break;	}	}	}	} catch (final IllegalArgumentException e) {	
error initializing command field is not accessible 

}	}	break;	default: break;	}	}	}	} catch (final IllegalArgumentException e) {	throw new CloudRuntimeException("Internal error initializing parameters for command " + cmd.getCommandName() + " [field " + field.getName() + " is not accessible]");	} catch (final IllegalAccessException e) {	
error initializing command field is not accessible 

break;	case UUID: final Long internalId = translateUuidToInternalId(paramObj.toString(), annotation);	field.set(cmdObj, internalId);	break;	case LONG: field.set(cmdObj, Long.valueOf(paramObj.toString()));	break;	case SHORT: field.set(cmdObj, Short.valueOf(paramObj.toString()));	break;	case STRING: if ((paramObj != null)) {	if (paramObj.toString().length() > annotation.length()) {	
value greater than max allowed length for param 

field.set(cmdObj, paramObj.toString());	}	}	break;	case TZDATE: field.set(cmdObj, DateUtil.parseTZDateString(paramObj.toString()));	break;	case MAP: default: field.set(cmdObj, paramObj);	break;	}	} catch (final IllegalAccessException ex) {	
error initializing command field is not accessible 

========================= cloudstack sample_2519 =========================

System.setProperty("javax.xml.parsers.DocumentBuilderFactory", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");	System.setProperty("javax.xml.parsers.SAXParserFactory", "com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl");	File file = PropertiesUtil.findConfigFile("log4j-cloud.xml");	if (file != null) {	System.out.println("Log4j configuration from : " + file.getAbsolutePath());	DOMConfigurator.configureAndWatch(file.getAbsolutePath(), 10000);	} else {	System.out.println("Configure log4j with default properties");	}	if (args.length < 1) {	
error starting database config missing initial data file 

if (args.length < 1) {	} else {	try {	DatabaseConfig config = ComponentContext.inject(DatabaseConfig.class);	config.doVersionCheck();	config.doConfig();	System.exit(0);	} catch (Exception ex) {	System.out.print("Error Caught");	ex.printStackTrace();	
error 

public void doInTransactionWithoutResult(TransactionStatus status) throws Exception {	saxParser.parse(configFile, handler);	saveVMTemplate();	saveRootDomain();	saveDefaultConfiguations();	}	});	pzc.checkAllPodCidrSubnets();	} catch (Exception ex) {	System.out.print("ERROR IS" + ex);	
error 

stmt.setLong(1, id);	stmt.setString(2, name);	stmt.setLong(3, dataCenterId);	stmt.setLong(4, podId);	stmt.setString(5, hypervisor);	stmt.setString(6, "CloudManaged");	stmt.setString(7, "Enabled");	stmt.executeUpdate();	} catch (SQLException ex) {	System.out.println("Error creating cluster: " + ex.getMessage());	
error creating cluster 

stmt.setLong(8, 0);	stmt.setString(9, hostAddress);	stmt.setString(10, hostPath);	stmt.setDate(11, new Date(new java.util.Date().getTime()));	stmt.setLong(12, podId);	stmt.setString(13, Status.Up.toString());	stmt.setLong(14, clusterId);	stmt.executeUpdate();	} catch (SQLException ex) {	System.out.println("Error creating storage pool: " + ex.getMessage());	
error creating storage pool 

stmt.setInt(11, firewall);	stmt.setInt(12, sourceNat);	stmt.setInt(13, lb);	stmt.setInt(14, staticNat);	stmt.setInt(15, pf);	stmt.setInt(16, userData);	stmt.setInt(17, securityGroup);	stmt.executeUpdate();	} catch (SQLException ex) {	System.out.println("Error creating physical network service provider: " + ex.getMessage());	
error creating physical network service provider 

try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql1);	stmt.setLong(1, id);	stmt.setLong(2, nspId);	stmt.setString(3, uuid);	stmt.setString(4, type);	stmt.setInt(5, 1);	stmt.executeUpdate();	} catch (SQLException ex) {	System.out.println("Error creating virtual router provider: " + ex.getMessage());	
error creating virtual router provider 

Long bytesWriteRate = Long.parseLong(_currentObjectParams.get("bytesWriteRate"));	if ((bytesWriteRate != null) && (bytesWriteRate > 0)) serviceOffering.setBytesWriteRate(bytesWriteRate);	Long iopsReadRate = Long.parseLong(_currentObjectParams.get("iopsReadRate"));	if ((iopsReadRate != null) && (iopsReadRate > 0)) serviceOffering.setIopsReadRate(iopsReadRate);	Long iopsWriteRate = Long.parseLong(_currentObjectParams.get("iopsWriteRate"));	if ((iopsWriteRate != null) && (iopsWriteRate > 0)) serviceOffering.setIopsWriteRate(iopsWriteRate);	ServiceOfferingDaoImpl dao = ComponentContext.inject(ServiceOfferingDaoImpl.class);	try {	dao.persist(serviceOffering);	} catch (Exception e) {	
error creating service offering 

try {	dao.persist(serviceOffering);	} catch (Exception e) {	}	String insertSql = "INSERT INTO `cloud`.`service_offering` (id, name, cpu, ram_size, speed, nw_rate, mc_rate, created, ha_enabled, mirrored, display_text, guest_ip_type, use_local_storage) " + "VALUES (" + id + ",'" + name + "'," + cpu + "," + ramSize + "," + speed + "," + nwRate + "," + mcRate + ",now()," + ha + "," + mirroring + ",'" + displayText + "','" + guestIpType + "','" + useLocalStorage + "')";	Transaction txn = Transaction.currentTxn();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating service offering 

Long bytesWriteRate = Long.parseLong(_currentObjectParams.get("bytesWriteRate"));	if (bytesWriteRate != null && (bytesWriteRate > 0)) diskOffering.setBytesWriteRate(bytesWriteRate);	Long iopsReadRate = Long.parseLong(_currentObjectParams.get("iopsReadRate"));	if (iopsReadRate != null && (iopsReadRate > 0)) diskOffering.setIopsReadRate(iopsReadRate);	Long iopsWriteRate = Long.parseLong(_currentObjectParams.get("iopsWriteRate"));	if (iopsWriteRate != null && (iopsWriteRate > 0)) diskOffering.setIopsWriteRate(iopsWriteRate);	DiskOfferingDaoImpl offering = ComponentContext.inject(DiskOfferingDaoImpl.class);	try {	offering.persist(diskOffering);	} catch (Exception e) {	
error creating disk offering 

offering.persist(diskOffering);	} catch (Exception e) {	}	String insertSql = "INSERT INTO `cloud`.`disk_offering` (id, domain_id, name, display_text, disk_size, mirrored, tags) " + "VALUES (" + id + "," + domainId + ",'" + name + "','" + displayText + "'," + diskSpace + "," + mirroring + ", ? )";	Transaction txn = Transaction.currentTxn();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.setString(1, tags);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating disk offering 

stmt = txn.prepareAutoCloseStatement(insertNWRateSql);	stmt.setString(1, _networkThrottlingRate);	stmt.executeUpdate();	}	if (saveMulticastThrottlingRate) {	stmt = txn.prepareAutoCloseStatement(insertMCRateSql);	stmt.setString(1, _multicastThrottlingRate);	stmt.executeUpdate();	}	} catch (SQLException ex) {	
error saving network and multicast throttling rates to all service offerings 

int requiresHvm = 0;	int bits = 64;	long createdByUserId = 1;	int isReady = 1;	String insertSql = "INSERT INTO `cloud`.`vm_template` (id, unique_name, name, public, path, created, type, hvm, bits, created_by, ready) " + "VALUES (" + id + ",'" + uniqueName + "','" + name + "'," + isPublic + ",'" + path + "',now(),'" + type + "'," + requiresHvm + "," + bits + "," + createdByUserId + "," + isReady + ")";	Transaction txn = Transaction.open();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating vm template 

name = "Console Proxy Template";	isPublic = 0;	path = "template/private/u000000/os/consoleproxy";	type = "ext3";	insertSql = "INSERT INTO `cloud`.`vm_template` (id, unique_name, name, public, path, created, type, hvm, bits, created_by, ready) " + "VALUES (" + id + ",'" + uniqueName + "','" + name + "'," + isPublic + ",'" + path + "',now(),'" + type + "'," + requiresHvm + "," + bits + "," + createdByUserId + "," + isReady + ")";	Transaction txn = Transaction.currentTxn();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating vm template 

protected void saveUser() {	final String insertSystemAccount = "INSERT INTO `cloud`.`account` (id, account_name, type, domain_id) VALUES (1, 'system', '1', '1')";	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSystemAccount);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating system account 

PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSystemAccount);	stmt.executeUpdate();	} catch (SQLException ex) {	}	final String insertSystemUser = "INSERT INTO `cloud`.`user` (id, username, password, account_id, firstname, lastname, created)" + " VALUES (1, 'system', RAND(), 1, 'system', 'cloud', now())";	txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSystemUser);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating system user 

String lastname = _currentObjectParams.get("lastname");	String password = _currentObjectParams.get("password");	String email = _currentObjectParams.get("email");	if (email == null || email.equals("")) {	printError("An email address for each user is required.");	}	MessageDigest md5 = null;	try {	md5 = MessageDigest.getInstance("MD5");	} catch (NoSuchAlgorithmException e) {	
error saving user 

}	sb.append(pwStr);	final String insertAdminAccount = "INSERT INTO `cloud`.`account` (id, account_name, type, domain_id) VALUES (?, ?, '1', '1')";	txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertAdminAccount);	stmt.setLong(1, id);	stmt.setString(2, username);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating account 

try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertUser);	stmt.setLong(1, id);	stmt.setString(2, username);	stmt.setString(3, sb.toString());	stmt.setString(4, firstname);	stmt.setString(5, lastname);	stmt.setString(6, email);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating user 

stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.setString(1, instance);	stmt.setString(2, component);	stmt.setString(3, name);	stmt.setString(4, value);	stmt.setString(5, description);	stmt.setString(6, category);	stmt.executeUpdate();	}	} catch (SQLException ex) {	
error creating configuration 

private boolean checkIpAddressRange(String ipAddressRange) {	String[] ipAddressRangeArray = ipAddressRange.split("\\-");	String startIP = ipAddressRangeArray[0];	String endIP = null;	if (ipAddressRangeArray.length > 1) {	endIP = ipAddressRangeArray[1];	}	if (!IPRangeConfig.validIP(startIP)) {	
the private ip address is invalid 

String[] ipAddressRangeArray = ipAddressRange.split("\\-");	String startIP = ipAddressRangeArray[0];	String endIP = null;	if (ipAddressRangeArray.length > 1) {	endIP = ipAddressRangeArray[1];	}	if (!IPRangeConfig.validIP(startIP)) {	return false;	}	if (!IPRangeConfig.validOrBlankIP(endIP)) {	
the private ip address is invalid 

if (ipAddressRangeArray.length > 1) {	endIP = ipAddressRangeArray[1];	}	if (!IPRangeConfig.validIP(startIP)) {	return false;	}	if (!IPRangeConfig.validOrBlankIP(endIP)) {	return false;	}	if (!IPRangeConfig.validIPRange(startIP, endIP)) {	
the ip range is invalid 

protected void saveRootDomain() {	String insertSql = "insert into `cloud`.`domain` (id, name, parent, owner, path, level) values (1, 'ROOT', NULL, 2, '/', 0)";	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
error creating root domain 

PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	}	String updateSql = "update account set domain_id = 1 where id = 2";	Transaction txn = Transaction.currentTxn();	try {	PreparedStatement stmt = txn.prepareStatement(updateSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
error updating admin user 

} catch (SQLException ex) {	} finally {	txn.close();	}	updateSql = "update account set domain_id = 1 where id = 1";	Transaction txn = Transaction.currentTxn();	try {	PreparedStatement stmt = txn.prepareStatement(updateSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
error updating system user 

========================= cloudstack sample_2260 =========================

String dns = pxeNic.getIPv4Dns1();	if (dns == null) {	dns = pxeNic.getIPv4Dns2();	}	try {	String tpl = profile.getTemplate().getUrl();	assert tpl != null : "How can a null template get here!!!";	PreparePxeServerCommand cmd = new PreparePxeServerCommand(ip, mac, mask, gateway, dns, tpl, profile.getVirtualMachine().getInstanceName(), dest.getHost().getName());	PreparePxeServerAnswer ans = (PreparePxeServerAnswer)_agentMgr.send(pxeServerId, cmd);	if (!ans.getResult()) {	
unable tot program pxe server because 

String tpl = profile.getTemplate().getUrl();	assert tpl != null : "How can a null template get here!!!";	PreparePxeServerCommand cmd = new PreparePxeServerCommand(ip, mac, mask, gateway, dns, tpl, profile.getVirtualMachine().getInstanceName(), dest.getHost().getName());	PreparePxeServerAnswer ans = (PreparePxeServerAnswer)_agentMgr.send(pxeServerId, cmd);	if (!ans.getResult()) {	return false;	}	IpmISetBootDevCommand bootCmd = new IpmISetBootDevCommand(BootDev.pxe);	Answer anw = _agentMgr.send(dest.getHost().getId(), bootCmd);	if (!anw.getResult()) {	
unable to set host to pxe boot because 

PreparePxeServerAnswer ans = (PreparePxeServerAnswer)_agentMgr.send(pxeServerId, cmd);	if (!ans.getResult()) {	return false;	}	IpmISetBootDevCommand bootCmd = new IpmISetBootDevCommand(BootDev.pxe);	Answer anw = _agentMgr.send(dest.getHost().getId(), bootCmd);	if (!anw.getResult()) {	}	return anw.getResult();	} catch (Exception e) {	
cannot prepare pxe server 

String gateway = nic.getIPv4Gateway();	String dns = dc.getDns1();	if (dns == null) {	dns = dc.getDns2();	}	try {	PrepareCreateTemplateCommand cmd = new PrepareCreateTemplateCommand(ip, mac, mask, gateway, dns, templateUrl);	Answer ans = _agentMgr.send(pxeServerId, cmd);	return ans.getResult();	} catch (Exception e) {	
prepare for creating baremetal template failed 

========================= cloudstack sample_897 =========================

PreparedStatement pstmt = null;	String sql = GET_SECHOST_ID;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, volumeId);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	return rs.getLong(1);	}	} catch (Exception ex) {	
ignored caught something while getting sec host id 

String sql = GET_LAST_SNAPSHOT;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, volumeId);	pstmt.setString(2, role.toString());	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	return rs.getLong(1);	}	} catch (Exception ex) {	
error getting last snapshot 

PreparedStatement pstmt = null;	String sql = UPDATE_SNAPSHOT_VERSION;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setString(1, to);	pstmt.setLong(2, volumeId);	pstmt.setString(3, from);	pstmt.executeUpdate();	return 1;	} catch (Exception ex) {	
error getting last snapshot 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	String sql = UPDATE_SECHOST_ID;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, secHostId);	pstmt.setLong(2, dcId);	pstmt.executeUpdate();	return 1;	} catch (Exception ex) {	
error set secondary storage host id 

========================= cloudstack sample_4583 =========================

public void execute() {	
getsolidfirevolumesizecmd execute method invoked 

========================= cloudstack sample_2007 =========================

Map<String, Object> mapValue = null;	final String indexStr = key.substring(arrayStartIndex + 1, arrayEndIndex);	int index = 0;	boolean parsedIndex = false;	try {	if (indexStr != null) {	index = Integer.parseInt(indexStr);	parsedIndex = true;	}	} catch (final NumberFormatException nfe) {	
invalid parameter received unable to parse object array returning an error 

========================= cloudstack sample_2512 =========================

public void handle(HttpExchange t) throws IOException {	try {	Thread.currentThread().setName("JPG Thread " + Thread.currentThread().getId() + " " + t.getRemoteAddress());	
screenhandler 

public void handle(HttpExchange t) throws IOException {	try {	Thread.currentThread().setName("JPG Thread " + Thread.currentThread().getId() + " " + t.getRemoteAddress());	long startTick = System.currentTimeMillis();	doHandle(t);	
process time ms 

public void handle(HttpExchange t) throws IOException {	try {	Thread.currentThread().setName("JPG Thread " + Thread.currentThread().getId() + " " + t.getRemoteAddress());	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IllegalArgumentException e) {	String response = "Bad query string";	
request uri 

Thread.currentThread().setName("JPG Thread " + Thread.currentThread().getId() + " " + t.getRemoteAddress());	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IllegalArgumentException e) {	String response = "Bad query string";	t.sendResponseHeaders(200, response.length());	OutputStream os = t.getResponseBody();	os.write(response.getBytes());	os.close();	} catch (OutOfMemoryError e) {	
unrecoverable outofmemory error exit and let it be re launched 

doHandle(t);	} catch (IllegalArgumentException e) {	String response = "Bad query string";	t.sendResponseHeaders(200, response.length());	OutputStream os = t.getResponseBody();	os.write(response.getBytes());	os.close();	} catch (OutOfMemoryError e) {	System.exit(1);	} catch (Throwable e) {	
unexpected exception while handing thumbnail request 

String queries = t.getRequestURI().getQuery();	Map<String, String> queryMap = getQueryMap(queries);	int width = 0;	int height = 0;	String ws = queryMap.get("w");	String hs = queryMap.get("h");	try {	width = Integer.parseInt(ws);	height = Integer.parseInt(hs);	} catch (NumberFormatException ex) {	
cannot parse width or height 

javax.imageio.ImageIO.write(img, "jpg", bos);	byte[] bs = bos.toByteArray();	Headers hds = t.getResponseHeaders();	hds.set("Content-Type", "image/jpeg");	hds.set("Cache-Control", "no-cache");	hds.set("Cache-Control", "no-store");	t.sendResponseHeaders(200, bs.length);	OutputStream os = t.getResponseBody();	os.write(bs);	os.close();	
cannot get console sent error jpg response for 

javax.imageio.ImageIO.write(img, "jpg", bos);	byte[] bs = bos.toByteArray();	Headers hds = t.getResponseHeaders();	hds.set("Content-Type", "image/jpeg");	hds.set("Cache-Control", "no-cache");	hds.set("Cache-Control", "no-store");	t.sendResponseHeaders(200, bs.length);	OutputStream os = t.getResponseBody();	os.write(bs);	os.close();	
console not ready sent dummy jpg response 

g.fillRect(0, 0, w, h);	g.setColor(Color.WHITE);	try {	g.setFont(new Font(null, Font.PLAIN, 12));	FontMetrics fm = g.getFontMetrics();	int textWidth = fm.stringWidth(text);	int startx = (w - textWidth) / 2;	if (startx < 0) startx = 0;	g.drawString(text, startx, h / 2);	} catch (Throwable e) {	
problem in generating text to thumnail image return blank image 

========================= cloudstack sample_4995 =========================

public StorageVol getVolume(StoragePool pool, String volName) {	StorageVol vol = null;	try {	vol = pool.storageVolLookupByName(volName);	} catch (LibvirtException e) {	
could not find volume 

public StorageVol getVolume(StoragePool pool, String volName) {	StorageVol vol = null;	try {	vol = pool.storageVolLookupByName(volName);	} catch (LibvirtException e) {	}	if (vol == null) {	try {	
refreshing storage pool 

public StorageVol getVolume(StoragePool pool, String volName) {	StorageVol vol = null;	try {	vol = pool.storageVolLookupByName(volName);	} catch (LibvirtException e) {	}	if (vol == null) {	try {	refreshPool(pool);	} catch (LibvirtException e) {	
failed to refresh storage pool 

vol = pool.storageVolLookupByName(volName);	} catch (LibvirtException e) {	}	if (vol == null) {	try {	refreshPool(pool);	} catch (LibvirtException e) {	}	try {	vol = pool.storageVolLookupByName(volName);	
found volume in storage pool after refreshing the pool 

public void storagePoolRefresh(StoragePool pool) {	try {	synchronized (getStoragePool(pool.getUUIDString())) {	refreshPool(pool);	}	} catch (LibvirtException e) {	
refresh storage pool failed 

LibvirtStoragePoolDef spd = new LibvirtStoragePoolDef(fsType, uuid, uuid, host, path, targetPath);	_storageLayer.mkdir(targetPath);	StoragePool sp = null;	try {	s_logger.debug(spd.toString());	sp = conn.storagePoolCreateXML(spd.toString(), 0);	return sp;	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	
attempting to unmount old mount libvirt is unaware of at 

StoragePool sp = null;	try {	s_logger.debug(spd.toString());	sp = conn.storagePoolCreateXML(spd.toString(), 0);	return sp;	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	
succeeded in unmounting 

s_logger.debug(spd.toString());	sp = conn.storagePoolCreateXML(spd.toString(), 0);	return sp;	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	sp = conn.storagePoolCreateXML(spd.toString(), 0);	
succeeded in redefining storage 

return sp;	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	sp = conn.storagePoolCreateXML(spd.toString(), 0);	return sp;	} catch (LibvirtException l) {	
target was already mounted unmounted it but failed to redefine storage 

s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	sp = conn.storagePoolCreateXML(spd.toString(), 0);	return sp;	} catch (LibvirtException l) {	}	} else {	
failed in unmounting and redefining storage 

String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	sp = conn.storagePoolCreateXML(spd.toString(), 0);	return sp;	} catch (LibvirtException l) {	}	} else {	}	} else {	
internal error occurred when attempting to mount specified path may be invalid 

if (sp != null) {	try {	if (sp.isPersistent() == 1) {	sp.destroy();	sp.undefine();	} else {	sp.destroy();	}	sp.free();	} catch (LibvirtException l) {	
failed to undefine storage pool with 

private StoragePool createSharedStoragePool(Connect conn, String uuid, String host, String path) {	String mountPoint = path;	if (!_storageLayer.exists(mountPoint)) {	
does not exists check local storage path in agent properties 

if (sp != null) {	try {	if (sp.isPersistent() == 1) {	sp.destroy();	sp.undefine();	} else {	sp.destroy();	}	sp.free();	} catch (LibvirtException l) {	
failed to define shared mount point storage pool with 

if (sp != null) {	try {	if (sp.isPersistent() == 1) {	sp.destroy();	sp.undefine();	} else {	sp.destroy();	}	sp.free();	} catch (LibvirtException l) {	
failed to define clvm storage pool with 

Secret s = null;	String[] userInfoTemp = userInfo.split(":");	if (userInfoTemp.length == 2) {	LibvirtSecretDef sd = new LibvirtSecretDef(Usage.CEPH, uuid);	sd.setCephName(userInfoTemp[0] + "@" + host + ":" + port + "/" + path);	try {	s_logger.debug(sd.toString());	s = conn.secretDefineXML(sd.toString());	s.setValue(Base64.decodeBase64(userInfoTemp[1]));	} catch (LibvirtException e) {	
failed to define the libvirt secret 

try {	s_logger.debug(sd.toString());	s = conn.secretDefineXML(sd.toString());	s.setValue(Base64.decodeBase64(userInfoTemp[1]));	} catch (LibvirtException e) {	if (s != null) {	try {	s.undefine();	s.free();	} catch (LibvirtException l) {	
failed to undefine the libvirt secret 

}	spd = new LibvirtStoragePoolDef(PoolType.RBD, uuid, uuid, host, port, path, userInfoTemp[0], AuthenticationType.CEPH, uuid);	} else {	spd = new LibvirtStoragePoolDef(PoolType.RBD, uuid, uuid, host, port, path, "");	}	try {	s_logger.debug(spd.toString());	sp = conn.storagePoolCreateXML(spd.toString(), 0);	return sp;	} catch (LibvirtException e) {	
failed to create rbd storage pool 

if (sp != null) {	try {	if (sp.isPersistent() == 1) {	sp.destroy();	sp.undefine();	} else {	sp.destroy();	}	sp.free();	} catch (LibvirtException l) {	
failed to undefine rbd storage pool 

sp.undefine();	} else {	sp.destroy();	}	sp.free();	} catch (LibvirtException l) {	}	}	if (s != null) {	try {	
failed to create the rbd storage pool cleaning up the libvirt secret 

}	sp.free();	} catch (LibvirtException l) {	}	}	if (s != null) {	try {	s.undefine();	s.free();	} catch (LibvirtException se) {	
failed to remove the libvirt secret 

public KVMStoragePool getStoragePool(String uuid, boolean refreshInfo) {	
trying to fetch storage pool from libvirt 

public KVMStoragePool getStoragePool(String uuid, boolean refreshInfo) {	StoragePool storage = null;	try {	Connect conn = LibvirtConnection.getConnection();	storage = conn.storagePoolLookupByUUIDString(uuid);	if (storage.getInfo().state != StoragePoolState.VIR_STORAGE_POOL_RUNNING) {	
storage pool is not in running state attempting to start it 

pool.setSourceDir(spd.getSourceDir());	String authUsername = spd.getAuthUserName();	if (authUsername != null) {	Secret secret = conn.secretLookupByUUIDString(spd.getSecretUUID());	String secretValue = new String(Base64.encodeBase64(secret.getByteValue()), Charset.defaultCharset());	pool.setAuthUsername(authUsername);	pool.setAuthSecret(secretValue);	}	}	if (refreshInfo) {	
asking libvirt to refresh storage pool 

pool.setAuthUsername(authUsername);	pool.setAuthSecret(secretValue);	}	}	if (refreshInfo) {	pool.refresh();	}	pool.setCapacity(storage.getInfo().capacity);	pool.setUsed(storage.getInfo().allocation);	pool.setAvailable(storage.getInfo().available);	
succesfully refreshed pool capacity used available 

}	}	if (refreshInfo) {	pool.refresh();	}	pool.setCapacity(storage.getInfo().capacity);	pool.setUsed(storage.getInfo().allocation);	pool.setAvailable(storage.getInfo().available);	return pool;	} catch (LibvirtException e) {	
could not find storage pool in libvirt 

} else {	disk.setFormat(pool.getDefaultFormat());	}	} else if (voldef.getFormat() == LibvirtStorageVolumeDef.VolumeFormat.QCOW2) {	disk.setFormat(PhysicalDiskFormat.QCOW2);	} else if (voldef.getFormat() == LibvirtStorageVolumeDef.VolumeFormat.RAW) {	disk.setFormat(PhysicalDiskFormat.RAW);	}	return disk;	} catch (LibvirtException e) {	
failed to get physical disk 

public KVMStoragePool createStoragePool(String name, String host, int port, String path, String userInfo, StoragePoolType type) {	
attempting to create storage pool in libvirt 

try {	conn = LibvirtConnection.getConnection();	} catch (LibvirtException e) {	throw new CloudRuntimeException(e.toString());	}	try {	sp = conn.storagePoolLookupByUUIDString(name);	if (sp != null && sp.isActive() == 0) {	sp.undefine();	sp = null;	
found existing defined storage pool it wasn t running so we undefined it 

} catch (LibvirtException e) {	throw new CloudRuntimeException(e.toString());	}	try {	sp = conn.storagePoolLookupByUUIDString(name);	if (sp != null && sp.isActive() == 0) {	sp.undefine();	sp = null;	}	if (sp != null) {	
found existing defined storage pool using it 

try {	sp = conn.storagePoolLookupByUUIDString(name);	if (sp != null && sp.isActive() == 0) {	sp.undefine();	sp = null;	}	if (sp != null) {	}	} catch (LibvirtException e) {	sp = null;	
storage pool was not found running in libvirt need to create it 

}	if (sp != null) {	}	} catch (LibvirtException e) {	sp = null;	}	if (path.endsWith("/")) {	path = path.substring(0, path.length() - 1);	}	if (sp == null) {	
didn t find an existing storage pool by uuid checking for pools with duplicate paths 

} catch (LibvirtException e) {	sp = null;	}	if (path.endsWith("/")) {	path = path.substring(0, path.length() - 1);	}	if (sp == null) {	try {	String[] poolnames = conn.listStoragePools();	for (String poolname : poolnames) {	
checking path of existing pool against pool we want to create 

path = path.substring(0, path.length() - 1);	}	if (sp == null) {	try {	String[] poolnames = conn.listStoragePools();	for (String poolname : poolnames) {	StoragePool p = conn.storagePoolLookupByName(poolname);	LibvirtStoragePoolDef pdef = getStoragePoolDef(conn, p);	String targetPath = pdef.getTargetPath();	if (targetPath != null && targetPath.equals(path)) {	
storage pool utilizing path already exists as pool undefining so we can re define with correct name 

if (targetPath != null && targetPath.equals(path)) {	if (p.isPersistent() == 1) {	p.destroy();	p.undefine();	} else {	p.destroy();	}	}	}	} catch (LibvirtException e) {	
failure in attempting to see if an existing storage pool might be using the path of the pool to be created 

if (p.isPersistent() == 1) {	p.destroy();	p.undefine();	} else {	p.destroy();	}	}	}	} catch (LibvirtException e) {	}	
attempting to create storage pool 

p.destroy();	}	}	}	} catch (LibvirtException e) {	}	if (type == StoragePoolType.NetworkFilesystem) {	try {	sp = createNetfsStoragePool(PoolType.NETFS, conn, name, host, path);	} catch (LibvirtException e) {	
failed to create netfs mount 

try {	sp = createNetfsStoragePool(PoolType.NETFS, conn, name, host, path);	} catch (LibvirtException e) {	s_logger.error(e.getStackTrace());	throw new CloudRuntimeException(e.toString());	}	} else if (type == StoragePoolType.Gluster) {	try {	sp = createNetfsStoragePool(PoolType.GLUSTERFS, conn, name, host, path);	} catch (LibvirtException e) {	
failed to create glusterfs mount 

sp = createRBDStoragePool(conn, name, host, port, userInfo, path);	} else if (type == StoragePoolType.CLVM) {	sp = createCLVMStoragePool(conn, name, host, path);	}	}	if (sp == null) {	throw new CloudRuntimeException("Failed to create storage pool: " + name);	}	try {	if (sp.isActive() == 0) {	
attempting to activate pool 

public boolean deleteStoragePool(String uuid) {	
attempting to remove storage pool from libvirt 

try {	conn = LibvirtConnection.getConnection();	} catch (LibvirtException e) {	throw new CloudRuntimeException(e.toString());	}	StoragePool sp = null;	Secret s = null;	try {	sp = conn.storagePoolLookupByUUIDString(uuid);	} catch (LibvirtException e) {	
storage pool doesn t exist in libvirt assuming it is already removed 

StoragePool sp = null;	Secret s = null;	try {	sp = conn.storagePoolLookupByUUIDString(uuid);	} catch (LibvirtException e) {	return true;	}	try {	s = conn.secretLookupByUUIDString(uuid);	} catch (LibvirtException e) {	
storage pool has no corresponding secret not removing any secret 

sp.destroy();	sp.undefine();	} else {	sp.destroy();	}	sp.free();	if (s != null) {	s.undefine();	s.free();	}	
storage pool was succesfully removed from libvirt 

}	sp.free();	if (s != null) {	s.undefine();	s.free();	}	return true;	} catch (LibvirtException e) {	if (e.toString().contains("exit status 16")) {	String targetPath = _mountPoint + File.separator + uuid;	
deletestoragepool removed pool from libvirt but libvirt had trouble unmounting the pool trying umount location again in a few seconds 

if (s != null) {	s.undefine();	s.free();	}	return true;	} catch (LibvirtException e) {	if (e.toString().contains("exit status 16")) {	String targetPath = _mountPoint + File.separator + uuid;	String result = Script.runSimpleBashScript("sleep 5 && umount " + targetPath);	if (result == null) {	
succeeded in unmounting 

s.free();	}	return true;	} catch (LibvirtException e) {	if (e.toString().contains("exit status 16")) {	String targetPath = _mountPoint + File.separator + uuid;	String result = Script.runSimpleBashScript("sleep 5 && umount " + targetPath);	if (result == null) {	return true;	}	
failed to unmount 

public KVMPhysicalDisk createPhysicalDisk(String name, KVMStoragePool pool, PhysicalDiskFormat format, Storage.ProvisioningType provisioningType, long size) {	
attempting to create volume in pool with size 

Map<String, String> options = new HashMap<String, String>();	if (pool.getType() == StoragePoolType.NetworkFilesystem){	options.put("preallocation", QemuImg.PreallocationType.getPreallocationType(provisioningType).toString());	}	try{	qemu.create(destFile, options);	Map<String, String> info = qemu.info(destFile);	virtualSize = Long.parseLong(info.get(new String("virtual_size")));	actualSize = new File(destFile.getFileName()).length();	} catch (QemuImgException e) {	
failed to create due to a failed executing of qemu img 

private KVMPhysicalDisk createPhysicalDiskOnRBD(String name, KVMStoragePool pool, PhysicalDiskFormat format, Storage.ProvisioningType provisioningType, long size) {	String volPath = null;	try {	
creating rbd image with size 

private KVMPhysicalDisk createPhysicalDiskOnRBD(String name, KVMStoragePool pool, PhysicalDiskFormat format, Storage.ProvisioningType provisioningType, long size) {	String volPath = null;	try {	Rados r = new Rados(pool.getAuthUserName());	r.confSet("mon_host", pool.getSourceHost() + ":" + pool.getSourcePort());	r.confSet("key", pool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

public boolean deletePhysicalDisk(String uuid, KVMStoragePool pool, Storage.ImageFormat format) {	
attempting to remove volume from pool 

public boolean deletePhysicalDisk(String uuid, KVMStoragePool pool, Storage.ImageFormat format) {	if (pool.getType() == StoragePoolType.RBD) {	try {	
unprotecting and removing rbd snapshots of image prior to removing the image 

public boolean deletePhysicalDisk(String uuid, KVMStoragePool pool, Storage.ImageFormat format) {	if (pool.getType() == StoragePoolType.RBD) {	try {	Rados r = new Rados(pool.getAuthUserName());	r.confSet("mon_host", pool.getSourceHost() + ":" + pool.getSourcePort());	r.confSet("key", pool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

if (pool.getType() == StoragePoolType.RBD) {	try {	Rados r = new Rados(pool.getAuthUserName());	r.confSet("mon_host", pool.getSourceHost() + ":" + pool.getSourcePort());	r.confSet("key", pool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(pool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(uuid);	
fetching list of snapshots of rbd image 

r.confSet("key", pool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(pool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(uuid);	List<RbdSnapInfo> snaps = image.snapList();	try {	for (RbdSnapInfo snap : snaps) {	if (image.snapIsProtected(snap.name)) {	
unprotecting snapshot 

r.connect();	IoCTX io = r.ioCtxCreate(pool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(uuid);	List<RbdSnapInfo> snaps = image.snapList();	try {	for (RbdSnapInfo snap : snaps) {	if (image.snapIsProtected(snap.name)) {	image.snapUnprotect(snap.name);	} else {	
snapshot is not protected 

IoCTX io = r.ioCtxCreate(pool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(uuid);	List<RbdSnapInfo> snaps = image.snapList();	try {	for (RbdSnapInfo snap : snaps) {	if (image.snapIsProtected(snap.name)) {	image.snapUnprotect(snap.name);	} else {	}	
removing snapshot 

RbdImage image = rbd.open(uuid);	List<RbdSnapInfo> snaps = image.snapList();	try {	for (RbdSnapInfo snap : snaps) {	if (image.snapIsProtected(snap.name)) {	image.snapUnprotect(snap.name);	} else {	}	image.snapRemove(snap.name);	}	
succesfully unprotected and removed any remaining snapshots of continuing to remove the rbd image 

List<RbdSnapInfo> snaps = image.snapList();	try {	for (RbdSnapInfo snap : snaps) {	if (image.snapIsProtected(snap.name)) {	image.snapUnprotect(snap.name);	} else {	}	image.snapRemove(snap.name);	}	} catch (RbdException e) {	
failed to remove snapshot with exception rbd error 

for (RbdSnapInfo snap : snaps) {	if (image.snapIsProtected(snap.name)) {	image.snapUnprotect(snap.name);	} else {	}	image.snapRemove(snap.name);	}	} catch (RbdException e) {	throw new CloudRuntimeException(e.toString() + " - " + ErrorCode.getErrorMessage(e.getReturnValue()));	} finally {	
closing image and destroying context 

}	image.snapRemove(snap.name);	}	} catch (RbdException e) {	throw new CloudRuntimeException(e.toString() + " - " + ErrorCode.getErrorMessage(e.getReturnValue()));	} finally {	rbd.close(image);	r.ioCtxDestroy(io);	}	} catch (RadosException e) {	
failed to remove snapshot with exception rbd error 

}	} catch (RbdException e) {	throw new CloudRuntimeException(e.toString() + " - " + ErrorCode.getErrorMessage(e.getReturnValue()));	} finally {	rbd.close(image);	r.ioCtxDestroy(io);	}	} catch (RadosException e) {	throw new CloudRuntimeException(e.toString() + " - " + ErrorCode.getErrorMessage(e.getReturnValue()));	} catch (RbdException e) {	
failed to remove snapshot with exception rbd error 

}	} catch (RadosException e) {	throw new CloudRuntimeException(e.toString() + " - " + ErrorCode.getErrorMessage(e.getReturnValue()));	} catch (RbdException e) {	throw new CloudRuntimeException(e.toString() + " - " + ErrorCode.getErrorMessage(e.getReturnValue()));	}	}	LibvirtStoragePool libvirtPool = (LibvirtStoragePool)pool;	try {	StorageVol vol = getVolume(libvirtPool.getPool(), uuid);	
instructing libvirt to remove volume from pool 

public KVMPhysicalDisk createDiskFromTemplate(KVMPhysicalDisk template, String name, PhysicalDiskFormat format, Storage.ProvisioningType provisioningType, long size, KVMStoragePool destPool, int timeout) {	
creating volume from template in pool with size 

if (size > template.getVirtualSize()) {	destFile.setSize(size);	} else {	destFile.setSize(template.getVirtualSize());	}	QemuImg qemu = new QemuImg(timeout);	Map<String, String> options = new HashMap<String, String>();	qemu.convert(sourceFile, destFile, options);	}	} catch (QemuImgException e) {	
failed to create due to a failed executing of qemu img 

}	QemuImg qemu = new QemuImg(timeout);	QemuImgFile srcFile;	QemuImgFile destFile = new QemuImgFile(KVMPhysicalDisk.RBDStringBuilder(destPool.getSourceHost(), destPool.getSourcePort(), destPool.getAuthUserName(), destPool.getAuthSecret(), disk.getPath()));	destFile.setFormat(format);	if (srcPool.getType() != StoragePoolType.RBD) {	srcFile = new QemuImgFile(template.getPath(), template.getFormat());	try{	qemu.convert(srcFile, destFile);	} catch (QemuImgException e) {	
failed to create due to a failed executing of qemu img 

destFile.setFormat(format);	if (srcPool.getType() != StoragePoolType.RBD) {	srcFile = new QemuImgFile(template.getPath(), template.getFormat());	try{	qemu.convert(srcFile, destFile);	} catch (QemuImgException e) {	}	} else {	try {	if ((srcPool.getSourceHost().equals(destPool.getSourceHost())) && (srcPool.getSourceDir().equals(destPool.getSourceDir()))) {	
trying to perform a rbd clone layering since we are operating in the same storage pool 

} catch (QemuImgException e) {	}	} else {	try {	if ((srcPool.getSourceHost().equals(destPool.getSourceHost())) && (srcPool.getSourceDir().equals(destPool.getSourceDir()))) {	Rados r = new Rados(srcPool.getAuthUserName());	r.confSet("mon_host", srcPool.getSourceHost() + ":" + srcPool.getSourcePort());	r.confSet("key", srcPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

if ((srcPool.getSourceHost().equals(destPool.getSourceHost())) && (srcPool.getSourceDir().equals(destPool.getSourceDir()))) {	Rados r = new Rados(srcPool.getAuthUserName());	r.confSet("mon_host", srcPool.getSourceHost() + ":" + srcPool.getSourcePort());	r.confSet("key", srcPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(srcPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage srcImage = rbd.open(template.getName());	if (srcImage.isOldFormat()) {	
the source image is rbd format we have to perform a regular copy bytes 

r.confSet("mon_host", srcPool.getSourceHost() + ":" + srcPool.getSourcePort());	r.confSet("key", srcPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(srcPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage srcImage = rbd.open(template.getName());	if (srcImage.isOldFormat()) {	rbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage destImage = rbd.open(disk.getName());	
starting to copy to in ceph pool 

r.confSet("key", srcPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(srcPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage srcImage = rbd.open(template.getName());	if (srcImage.isOldFormat()) {	rbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage destImage = rbd.open(disk.getName());	rbd.copy(srcImage, destImage);	
finished copying to in ceph pool 

r.connect();	IoCTX io = r.ioCtxCreate(srcPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage srcImage = rbd.open(template.getName());	if (srcImage.isOldFormat()) {	rbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage destImage = rbd.open(disk.getName());	rbd.copy(srcImage, destImage);	rbd.close(destImage);	} else {	
the source image is rbd format we will perform a rbd clone using snapshot 

r.connect();	IoCTX io = r.ioCtxCreate(srcPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage srcImage = rbd.open(template.getName());	if (srcImage.isOldFormat()) {	rbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage destImage = rbd.open(disk.getName());	rbd.copy(srcImage, destImage);	rbd.close(destImage);	} else {	
checking if rbd snapshot exists prior to attempting a clone operation 

IoCTX io = r.ioCtxCreate(srcPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage srcImage = rbd.open(template.getName());	if (srcImage.isOldFormat()) {	rbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage destImage = rbd.open(disk.getName());	rbd.copy(srcImage, destImage);	rbd.close(destImage);	} else {	List<RbdSnapInfo> snaps = srcImage.snapList();	
found snapshots on rbd image 

if (srcImage.isOldFormat()) {	rbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage destImage = rbd.open(disk.getName());	rbd.copy(srcImage, destImage);	rbd.close(destImage);	} else {	List<RbdSnapInfo> snaps = srcImage.snapList();	boolean snapFound = false;	for (RbdSnapInfo snap : snaps) {	if (rbdTemplateSnapName.equals(snap.name)) {	
rbd snapshot already exists 

} else {	List<RbdSnapInfo> snaps = srcImage.snapList();	boolean snapFound = false;	for (RbdSnapInfo snap : snaps) {	if (rbdTemplateSnapName.equals(snap.name)) {	snapFound = true;	break;	}	}	if (!snapFound) {	
creating rbd snapshot on image 

List<RbdSnapInfo> snaps = srcImage.snapList();	boolean snapFound = false;	for (RbdSnapInfo snap : snaps) {	if (rbdTemplateSnapName.equals(snap.name)) {	snapFound = true;	break;	}	}	if (!snapFound) {	srcImage.snapCreate(rbdTemplateSnapName);	
protecting rbd snapshot on image 

if (rbdTemplateSnapName.equals(snap.name)) {	snapFound = true;	break;	}	}	if (!snapFound) {	srcImage.snapCreate(rbdTemplateSnapName);	srcImage.snapProtect(rbdTemplateSnapName);	}	rbd.clone(template.getName(), rbdTemplateSnapName, io, disk.getName(), rbdFeatures, rbdOrder);	
succesfully cloned to 

}	if (!snapFound) {	srcImage.snapCreate(rbdTemplateSnapName);	srcImage.snapProtect(rbdTemplateSnapName);	}	rbd.clone(template.getName(), rbdTemplateSnapName, io, disk.getName(), rbdFeatures, rbdOrder);	if (disk.getVirtualSize() > template.getVirtualSize()) {	RbdImage diskImage = rbd.open(disk.getName());	diskImage.resize(disk.getVirtualSize());	rbd.close(diskImage);	
resized to 

rbd.clone(template.getName(), rbdTemplateSnapName, io, disk.getName(), rbdFeatures, rbdOrder);	if (disk.getVirtualSize() > template.getVirtualSize()) {	RbdImage diskImage = rbd.open(disk.getName());	diskImage.resize(disk.getVirtualSize());	rbd.close(diskImage);	}	}	rbd.close(srcImage);	r.ioCtxDestroy(io);	} else {	
both the source and destination are rbd but not the same ceph cluster performing a copy 

}	}	rbd.close(srcImage);	r.ioCtxDestroy(io);	} else {	Rados rSrc = new Rados(srcPool.getAuthUserName());	rSrc.confSet("mon_host", srcPool.getSourceHost() + ":" + srcPool.getSourcePort());	rSrc.confSet("key", srcPool.getAuthSecret());	rSrc.confSet("client_mount_timeout", "30");	rSrc.connect();	
succesfully connected to source ceph cluster at mon host 

Rados rSrc = new Rados(srcPool.getAuthUserName());	rSrc.confSet("mon_host", srcPool.getSourceHost() + ":" + srcPool.getSourcePort());	rSrc.confSet("key", srcPool.getAuthSecret());	rSrc.confSet("client_mount_timeout", "30");	rSrc.connect();	Rados rDest = new Rados(destPool.getAuthUserName());	rDest.confSet("mon_host", destPool.getSourceHost() + ":" + destPool.getSourcePort());	rDest.confSet("key", destPool.getAuthSecret());	rDest.confSet("client_mount_timeout", "30");	rDest.connect();	
succesfully connected to source ceph cluster at mon host 

rSrc.connect();	Rados rDest = new Rados(destPool.getAuthUserName());	rDest.confSet("mon_host", destPool.getSourceHost() + ":" + destPool.getSourcePort());	rDest.confSet("key", destPool.getAuthSecret());	rDest.confSet("client_mount_timeout", "30");	rDest.connect();	IoCTX sIO = rSrc.ioCtxCreate(srcPool.getSourceDir());	Rbd sRbd = new Rbd(sIO);	IoCTX dIO = rDest.ioCtxCreate(destPool.getSourceDir());	Rbd dRbd = new Rbd(dIO);	
creating on the destination cluster mon host in pool 

rDest.confSet("key", destPool.getAuthSecret());	rDest.confSet("client_mount_timeout", "30");	rDest.connect();	IoCTX sIO = rSrc.ioCtxCreate(srcPool.getSourceDir());	Rbd sRbd = new Rbd(sIO);	IoCTX dIO = rDest.ioCtxCreate(destPool.getSourceDir());	Rbd dRbd = new Rbd(dIO);	dRbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage srcImage = sRbd.open(template.getName());	RbdImage destImage = dRbd.open(disk.getName());	
copying from ceph cluster mon host to on cluster mon host 

dRbd.create(disk.getName(), disk.getVirtualSize(), rbdFeatures, rbdOrder);	RbdImage srcImage = sRbd.open(template.getName());	RbdImage destImage = dRbd.open(disk.getName());	sRbd.copy(srcImage, destImage);	sRbd.close(srcImage);	dRbd.close(destImage);	rSrc.ioCtxDestroy(sIO);	rDest.ioCtxDestroy(dIO);	}	} catch (RadosException e) {	
failed to perform a rados action on the ceph cluster the error was 

RbdImage destImage = dRbd.open(disk.getName());	sRbd.copy(srcImage, destImage);	sRbd.close(srcImage);	dRbd.close(destImage);	rSrc.ioCtxDestroy(sIO);	rDest.ioCtxDestroy(dIO);	}	} catch (RadosException e) {	disk = null;	} catch (RbdException e) {	
failed to perform a rbd action on the ceph cluster the error was 

public KVMPhysicalDisk copyPhysicalDisk(KVMPhysicalDisk disk, String name, KVMStoragePool destPool, int timeout) {	With RBD you can't run qemu-img convert with an existing RBD image as destination qemu-img will exit with the error that the destination already exists. So for RBD we don't create the image, but let qemu-img do that for us. We then create a KVMPhysicalDisk object that we can return It is however very unlikely that the destPool will be RBD, since it isn't supported for Secondary Storage KVMStoragePool srcPool = disk.getPool();	PhysicalDiskFormat sourceFormat = disk.getFormat();	String sourcePath = disk.getPath();	KVMPhysicalDisk newDisk;	
copyphysicaldisk disk size virtualsize format 

}	} else {	destFile = new QemuImgFile(destPath, destFormat);	try {	qemu.convert(srcFile, destFile);	Map<String, String> destInfo = qemu.info(destFile);	Long virtualSize = Long.parseLong(destInfo.get(new String("virtual_size")));	newDisk.setVirtualSize(virtualSize);	newDisk.setSize(virtualSize);	} catch (QemuImgException e) {	
failed to convert to the error was 

qemu.convert(srcFile, destFile);	Map<String, String> destInfo = qemu.info(destFile);	Long virtualSize = Long.parseLong(destInfo.get(new String("virtual_size")));	newDisk.setVirtualSize(virtualSize);	newDisk.setSize(virtualSize);	} catch (QemuImgException e) {	newDisk = null;	}	}	} catch (QemuImgException e) {	
failed to fetch the information of file the error was 

newDisk.setSize(virtualSize);	} catch (QemuImgException e) {	newDisk = null;	}	}	} catch (QemuImgException e) {	newDisk = null;	}	}	} else if ((srcPool.getType() != StoragePoolType.RBD) && (destPool.getType() == StoragePoolType.RBD)) {	
the source image is not rbd but the destination is we will convert into rbd format 

} catch (QemuImgException e) {	newDisk = null;	}	}	} else if ((srcPool.getType() != StoragePoolType.RBD) && (destPool.getType() == StoragePoolType.RBD)) {	try {	srcFile = new QemuImgFile(sourcePath, sourceFormat);	String rbdDestPath = destPool.getSourceDir() + "/" + name;	String rbdDestFile = KVMPhysicalDisk.RBDStringBuilder(destPool.getSourceHost(), destPool.getSourcePort(), destPool.getAuthUserName(), destPool.getAuthSecret(), rbdDestPath);	destFile = new QemuImgFile(rbdDestFile, destFormat);	
starting copy from source image to rbd image 

newDisk = null;	}	}	} else if ((srcPool.getType() != StoragePoolType.RBD) && (destPool.getType() == StoragePoolType.RBD)) {	try {	srcFile = new QemuImgFile(sourcePath, sourceFormat);	String rbdDestPath = destPool.getSourceDir() + "/" + name;	String rbdDestFile = KVMPhysicalDisk.RBDStringBuilder(destPool.getSourceHost(), destPool.getSourcePort(), destPool.getAuthUserName(), destPool.getAuthSecret(), rbdDestPath);	destFile = new QemuImgFile(rbdDestFile, destFormat);	qemu.convert(srcFile, destFile);	
succesfully converted source image to rbd image 

srcFile = new QemuImgFile(sourcePath, sourceFormat);	String rbdDestPath = destPool.getSourceDir() + "/" + name;	String rbdDestFile = KVMPhysicalDisk.RBDStringBuilder(destPool.getSourceHost(), destPool.getSourcePort(), destPool.getAuthUserName(), destPool.getAuthSecret(), rbdDestPath);	destFile = new QemuImgFile(rbdDestFile, destFormat);	qemu.convert(srcFile, destFile);	Rados r = new Rados(destPool.getAuthUserName());	r.confSet("mon_host", destPool.getSourceHost() + ":" + destPool.getSourcePort());	r.confSet("key", destPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

r.confSet("mon_host", destPool.getSourceHost() + ":" + destPool.getSourcePort());	r.confSet("key", destPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(destPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(name);	RbdImageInfo rbdInfo = image.stat();	newDisk.setSize(rbdInfo.size);	newDisk.setVirtualSize(rbdInfo.size);	
after copy the resulting rbd image is bytes long 

r.connect();	IoCTX io = r.ioCtxCreate(destPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(name);	RbdImageInfo rbdInfo = image.stat();	newDisk.setSize(rbdInfo.size);	newDisk.setVirtualSize(rbdInfo.size);	rbd.close(image);	r.ioCtxDestroy(io);	} catch (QemuImgException e) {	
failed to convert from to the error was 

Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(name);	RbdImageInfo rbdInfo = image.stat();	newDisk.setSize(rbdInfo.size);	newDisk.setVirtualSize(rbdInfo.size);	rbd.close(image);	r.ioCtxDestroy(io);	} catch (QemuImgException e) {	newDisk = null;	} catch (RadosException e) {	
a ceph rados operation failed the error was 

RbdImageInfo rbdInfo = image.stat();	newDisk.setSize(rbdInfo.size);	newDisk.setVirtualSize(rbdInfo.size);	rbd.close(image);	r.ioCtxDestroy(io);	} catch (QemuImgException e) {	newDisk = null;	} catch (RadosException e) {	newDisk = null;	} catch (RbdException e) {	
a ceph rbd operation failed the error was 

newDisk = null;	}	} else {	We let Qemu-Img do the work here. Although we could work with librbd and have that do the cloning it doesn't benefit us. It's better to keep the current code in place which works srcFile = new QemuImgFile(KVMPhysicalDisk.RBDStringBuilder(srcPool.getSourceHost(), srcPool.getSourcePort(), srcPool.getAuthUserName(), srcPool.getAuthSecret(), sourcePath));	srcFile.setFormat(sourceFormat);	destFile = new QemuImgFile(destPath);	destFile.setFormat(destFormat);	try {	qemu.convert(srcFile, destFile);	} catch (QemuImgException e) {	
failed to convert to the error was 

========================= cloudstack sample_1017 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	BaremetalDhcpVO vo = mgr.addDchpServer(this);	BaremetalDhcpResponse response = mgr.generateApiResponse(vo);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} catch (Exception e) {	
unable to add external dhcp server with url 

========================= cloudstack sample_873 =========================

final Connection conn = xcpServerResource.getConnection();	if (command.getOption() != null && command.getOption().equals("create")) {	final String result = xcpServerResource.networkUsage(conn, command.getPrivateIP(), "create", null);	final NetworkUsageAnswer answer = new NetworkUsageAnswer(command, result, 0L, 0L);	return answer;	}	final long[] stats = xcpServerResource.getNetworkStats(conn, command.getPrivateIP());	final NetworkUsageAnswer answer = new NetworkUsageAnswer(command, "", stats[0], stats[1]);	return answer;	} catch (final Exception ex) {	
failed to get network usage stats due to 

========================= cloudstack sample_1152 =========================

public boolean processAnswers(long agentId, long seq, Answer[] answers) {	HostVO host = _hostDao.findById(agentId);	if (host != null) {	if ((host.getManagementServerId() == null) || (mgmtSrvrId != host.getManagementServerId())) {	
not the owner not collecting direct network usage from trafficmonitor 

public boolean processAnswers(long agentId, long seq, Answer[] answers) {	HostVO host = _hostDao.findById(agentId);	if (host != null) {	if ((host.getManagementServerId() == null) || (mgmtSrvrId != host.getManagementServerId())) {	return false;	}	} else {	
agent not found not collecting direct network usage from trafficmonitor 

private boolean collectDirectNetworkUsage(final HostVO host) {	
direct network usage stats collector is running 

private boolean collectDirectNetworkUsage(final HostVO host) {	final long zoneId = host.getDataCenterId();	final DetailVO lastCollectDetail = _detailsDao.findDetail(host.getId(), "last_collection");	if (lastCollectDetail == null) {	
last collection time not available skipping direct usage collection for traffic monitor 

final DetailVO lastCollectDetail = _detailsDao.findDetail(host.getId(), "last_collection");	if (lastCollectDetail == null) {	return false;	}	Date lastCollection = new Date(Long.parseLong(lastCollectDetail.getValue()));	List<IPAddressVO> allocatedIps = listAllocatedDirectIps(zoneId);	Calendar rightNow = Calendar.getInstance();	rightNow.add(Calendar.HOUR_OF_DAY, -2);	final Date now = rightNow.getTime();	if (lastCollection.after(now)) {	
current time is less than hours after last collection time skipping direct network usage collection 

String msg = "Unable to get network usage stats from " + host.getId() + " due to: " + details + ".";	s_logger.error(msg);	return false;	} else {	for (UsageIPAddressVO usageIp : fullDurationIpUsage) {	String publicIp = usageIp.getAddress();	long[] bytesSentRcvd = answer.get(publicIp);	Long bytesSent = bytesSentRcvd[0];	Long bytesRcvd = bytesSentRcvd[1];	if (bytesSent == null || bytesRcvd == null) {	
incorrect bytes for ip 

} else {	for (UsageIPAddressVO usageIp : fullDurationIpUsage) {	String publicIp = usageIp.getAddress();	long[] bytesSentRcvd = answer.get(publicIp);	Long bytesSent = bytesSentRcvd[0];	Long bytesRcvd = bytesSentRcvd[1];	if (bytesSent == null || bytesRcvd == null) {	continue;	}	if (bytesSent == 0L && bytesRcvd == 0L) {	
ignore zero bytes for ip 

String details = (answer != null) ? answer.getDetails() : "details unavailable";	String msg = "Unable to get network usage stats from " + host.getId() + " due to: " + details + ".";	s_logger.error(msg);	return false;	} else {	String publicIp = usageIp.getAddress();	long[] bytesSentRcvd = answer.get(publicIp);	Long bytesSent = bytesSentRcvd[0];	Long bytesRcvd = bytesSentRcvd[1];	if (bytesSent == null || bytesRcvd == null) {	
incorrect bytes for ip 

return false;	} else {	String publicIp = usageIp.getAddress();	long[] bytesSentRcvd = answer.get(publicIp);	Long bytesSent = bytesSentRcvd[0];	Long bytesRcvd = bytesSentRcvd[1];	if (bytesSent == null || bytesRcvd == null) {	continue;	}	if (bytesSent == 0L && bytesRcvd == 0L) {	
ignore zero bytes for ip 

if (bytesSent == 0L && bytesRcvd == 0L) {	continue;	}	UserStatisticsVO stats = new UserStatisticsVO(usageIp.getAccountId(), zoneId, null, null, null, null);	stats.setCurrentBytesSent(bytesSent);	stats.setCurrentBytesReceived(bytesRcvd);	collectedStats.add(stats);	}	}	if (collectedStats.size() == 0) {	
no new direct network stats no need to persist 

public boolean processDisconnect(long agentId, Status state) {	if (s_logger.isDebugEnabled()) {	
disconnected called on with status 

public void processConnect(Host agent, StartupCommand cmd, boolean forRebalance) {	if (cmd instanceof StartupTrafficMonitorCommand) {	long agentId = agent.getId();	
sending recurringnetworkusagecommand to 

public void processConnect(Host agent, StartupCommand cmd, boolean forRebalance) {	if (cmd instanceof StartupTrafficMonitorCommand) {	long agentId = agent.getId();	RecurringNetworkUsageCommand watch = new RecurringNetworkUsageCommand(_interval);	try {	_agentMgr.send(agentId, new Commands(watch), this);	} catch (AgentUnavailableException e) {	
can not process connect for host 

========================= cloudstack sample_2284 =========================

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	_systemAccount = _accountDao.findById(Account.ACCOUNT_ID_SYSTEM);	if (_systemAccount == null) {	throw new ConfigurationException("Unable to find the system account using " + Account.ACCOUNT_ID_SYSTEM);	}	_systemUser = _userDao.findById(User.UID_SYSTEM);	if (_systemUser == null) {	throw new ConfigurationException("Unable to find the system user using " + User.UID_SYSTEM);	}	CallContext.register(_systemUser, _systemAccount);	
mockaccountmanager initialization successful 

========================= cloudstack sample_1851 =========================

long secHostId = rs1.getLong(1);	pstmt = conn.prepareStatement("update snapshots set sechost_id=? where data_center_id=?");	pstmt.setLong(1, secHostId);	pstmt.setLong(2, dcId);	pstmt.executeUpdate();	}	}	pstmt = conn.prepareStatement("update disk_offering set disk_size = disk_size * 1024 * 1024 where disk_size <= 2 * 1024 * 1024 and disk_size != 0");	pstmt.executeUpdate();	} catch (SQLException e) {	
failed to db migration for multiple secondary storages 

private void updateDomainLevelNetworks(Connection conn) {	
updating domain level specific networks 

rs = pstmt.executeQuery();	if (rs.next()) {	s_logger.debug("Setting network id=" + networkId + " as domain specific shared network");	pstmt = conn.prepareStatement("UPDATE networks set is_domain_specific=1 where id=?");	pstmt.setLong(1, networkId);	pstmt.executeUpdate();	}	rs.close();	pstmt.close();	}	
successfully updated domain level specific networks 

if (rs.next()) {	s_logger.debug("Setting network id=" + networkId + " as domain specific shared network");	pstmt = conn.prepareStatement("UPDATE networks set is_domain_specific=1 where id=?");	pstmt.setLong(1, networkId);	pstmt.executeUpdate();	}	rs.close();	pstmt.close();	}	} catch (SQLException e) {	
failed to set domain specific shared networks due to 

private void updateVolumeUsageRecords(Connection conn) {	try {	
inserting missing usage event records for destroyed volumes 

long accountId = rs.getLong(2);	long zoneId = rs.getLong(3);	String volumeName = rs.getString(4);	pstmt = conn.prepareStatement("insert into usage_event (type, account_id, created, zone_id, resource_name, resource_id) values ('VOLUME.DELETE', ?, now(), ?, ?, ?)");	pstmt.setLong(1, accountId);	pstmt.setLong(2, zoneId);	pstmt.setString(3, volumeName);	pstmt.setLong(4, volumeId);	pstmt.executeUpdate();	}	
successfully inserted missing usage event records for destroyed volumes 

long zoneId = rs.getLong(3);	String volumeName = rs.getString(4);	pstmt = conn.prepareStatement("insert into usage_event (type, account_id, created, zone_id, resource_name, resource_id) values ('VOLUME.DELETE', ?, now(), ?, ?, ?)");	pstmt.setLong(1, accountId);	pstmt.setLong(2, zoneId);	pstmt.setString(3, volumeName);	pstmt.setLong(4, volumeId);	pstmt.executeUpdate();	}	} catch (SQLException e) {	
failed to insert missing delete usage records 

========================= cloudstack sample_4184 =========================

private void initDriver() {	isDriverEnabled = true;	final OutOfBandManagementDriverResponse output = IPMITOOL.executeCommands(Arrays.asList(IpmiToolPath.value(), "-V"));	if (output.isSuccess() && output.getResult().startsWith("ipmitool version")) {	isIpmiToolBinAvailable = true;	
outofbandmanagementdriver ipmitool initialized 

private void initDriver() {	isDriverEnabled = true;	final OutOfBandManagementDriverResponse output = IPMITOOL.executeCommands(Arrays.asList(IpmiToolPath.value(), "-V"));	if (output.isSuccess() && output.getResult().startsWith("ipmitool version")) {	isIpmiToolBinAvailable = true;	} else {	isIpmiToolBinAvailable = false;	
outofbandmanagementdriver ipmitool failed initialization with error standard output 

========================= cloudstack sample_1386 =========================

try {	txn.start();	String sql = REMOVE_BY_USERID_PFID;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, accountId);	pstmt.setLong(2, pfId);	pstmt.executeUpdate();	txn.commit();	} catch (Exception e) {	txn.rollback();	
error removing usageportforwardingrulevo 

pstmt.setLong(3, usage.getId());	pstmt.executeUpdate();	}	}catch (SQLException e) {	throw new CloudException("Error updating UsagePortForwardingRuleVO:"+e.getMessage(), e);	}	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usageportforwardingrulevo 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (deletedTS != null) {	deletedDate = DateUtil.parseDateString(s_gmtTimeZone, deletedTS);	}	usageRecords.add(new UsagePortForwardingRuleVO(pfId, zoneId, acctId, dId, createdDate, deletedDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4491 =========================

throw new ServerApiException(ApiErrorCode.PARAM_ERROR, _apiServer.getSerializedApiError(ApiErrorCode.PARAM_ERROR.getHttpCode(), "User account is not allowed to switch to the requested account", params, responseType));	}	try {	if (_apiServer.verifyUser(nextUserAccount.getId())) {	final LoginCmdResponse loginResponse = (LoginCmdResponse) _apiServer.loginUser(session, nextUserAccount.getUsername(), nextUserAccount.getUsername() + nextUserAccount.getSource().toString(), nextUserAccount.getDomainId(), null, remoteAddress, params);	SAMLUtils.setupSamlUserCookies(loginResponse, resp);	resp.sendRedirect(SAML2AuthManager.SAMLCloudStackRedirectionUrl.value());	return ApiResponseSerializer.toSerializedString(loginResponse, responseType);	}	} catch (CloudAuthenticationException | IOException exception) {	
failed to switch to request saml user account due to 

public void setAuthenticators(List<PluggableAPIAuthenticator> authenticators) {	for (PluggableAPIAuthenticator authManager: authenticators) {	if (authManager != null && authManager instanceof SAML2AuthManager) {	_samlAuthManager = (SAML2AuthManager) authManager;	}	}	if (_samlAuthManager == null) {	
no suitable pluggable authentication manager found for listandswitchsamlaccount cmd 

========================= cloudstack sample_1369 =========================

private void addSourceIdColumn(Connection conn) {	boolean insertField = false;	try {	PreparedStatement pstmt;	try {	pstmt = conn.prepareStatement("SELECT source_id FROM `cloud_usage`.`usage_storage`");	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	
the source id field already exist not adding it 

PreparedStatement pstmt;	try {	pstmt = conn.prepareStatement("SELECT source_id FROM `cloud_usage`.`usage_storage`");	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	}	} catch (Exception e) {	insertField = true;	}	if (insertField) {	
adding source id to usage storage 

pstmt = conn.prepareStatement("SELECT source_id FROM `cloud_usage`.`usage_storage`");	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	}	} catch (Exception e) {	insertField = true;	}	if (insertField) {	pstmt = conn.prepareStatement("ALTER TABLE `cloud_usage`.`usage_storage` ADD COLUMN `source_id` bigint unsigned");	pstmt.executeUpdate();	
column source id was added successfully to usage storage table 

}	} catch (Exception e) {	insertField = true;	}	if (insertField) {	pstmt = conn.prepareStatement("ALTER TABLE `cloud_usage`.`usage_storage` ADD COLUMN `source_id` bigint unsigned");	pstmt.executeUpdate();	pstmt.close();	}	} catch (SQLException e) {	
failed to add source id to usage storage due to 

private void addNetworkIdsToUserStats(Connection conn) {	
adding network ids to user stats 

pstmt = conn.prepareStatement(stmt);	pstmt.setLong(1, networkId);	pstmt.setString(2, publicIpAddress);	pstmt.executeUpdate();	}	}	rs2.close();	}	rs.close();	pstmt.close();	
successfully added network ids to user stats 

========================= cloudstack sample_4242 =========================

selenium.select("add_iso_zone", "label=" + iso_zone);	String iso_os_type = System.getProperty("add_iso_os_type", "Fedora 11");	selenium.select("add_iso_os_type", "label=" + iso_os_type);	selenium.click(" Thread.sleep(3000);	int i = 1;	try {	for (;; i++) {	System.out.println("i=   " + i);	selenium.click(" }	} catch (Exception ex) {	
ignored error during clicking test on iso 

for (;; i++) {	System.out.println("i=   " + i);	selenium.click(" }	} catch (Exception ex) {	}	for (int second = 0;; second++) {	if (second >= 60) fail("timeout");	try {	if (selenium.isVisible(" break;	} catch (Exception e) {	
ignored error during visibility test of iso 

selenium.click(" Thread.sleep(3000);	selenium.click(" Thread.sleep(3000);	}	}	selenium.click("link=Delete ISO");	selenium.click(" for (int second = 0;; second++) {	if (second >= 60) fail("timeout");	try {	if (selenium.isVisible("after_action_info_container_on_top")) break;	} catch (Exception e) {	
ignored error checking visibility after test completion for iso 

========================= cloudstack sample_432 =========================

for (NfsStoragePool pool : _pools) {	Script cmd = new Script(s_heartBeatPath, _heartBeatCheckerTimeout, s_logger);	cmd.add("-i", pool._poolIp);	cmd.add("-p", pool._poolMountSourcePath);	cmd.add("-m", pool._mountDestPath);	cmd.add("-h", _hostIP);	cmd.add("-r");	cmd.add("-t", String.valueOf(_heartBeatUpdateFreq / 1000));	OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();	String result = cmd.execute(parser);	
pool 

for (NfsStoragePool pool : _pools) {	Script cmd = new Script(s_heartBeatPath, _heartBeatCheckerTimeout, s_logger);	cmd.add("-i", pool._poolIp);	cmd.add("-p", pool._poolMountSourcePath);	cmd.add("-m", pool._mountDestPath);	cmd.add("-h", _hostIP);	cmd.add("-r");	cmd.add("-t", String.valueOf(_heartBeatUpdateFreq / 1000));	OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();	String result = cmd.execute(parser);	
reture 

for (NfsStoragePool pool : _pools) {	Script cmd = new Script(s_heartBeatPath, _heartBeatCheckerTimeout, s_logger);	cmd.add("-i", pool._poolIp);	cmd.add("-p", pool._poolMountSourcePath);	cmd.add("-m", pool._mountDestPath);	cmd.add("-h", _hostIP);	cmd.add("-r");	cmd.add("-t", String.valueOf(_heartBeatUpdateFreq / 1000));	OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();	String result = cmd.execute(parser);	
parser 

Script cmd = new Script(s_heartBeatPath, _heartBeatCheckerTimeout, s_logger);	cmd.add("-i", pool._poolIp);	cmd.add("-p", pool._poolMountSourcePath);	cmd.add("-m", pool._mountDestPath);	cmd.add("-h", _hostIP);	cmd.add("-r");	cmd.add("-t", String.valueOf(_heartBeatUpdateFreq / 1000));	OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();	String result = cmd.execute(parser);	if (result == null && parser.getLine().contains("> DEAD <")) {	
read heartbeat failed 

========================= cloudstack sample_1105 =========================

public String execute(OutputInterpreter interpreter) {	String[] command = _command.toArray(new String[_command.size()]);	if (_logger.isDebugEnabled()) {	
executing 

public String execute(OutputInterpreter interpreter) {	String[] command = _command.toArray(new String[_command.size()]);	if (_logger.isDebugEnabled()) {	}	try {	ProcessBuilder pb = new ProcessBuilder(command);	pb.redirectErrorStream(true);	if (_workDir != null) pb.directory(new File(_workDir));	_process = pb.start();	if (_process == null) {	
unable to execute 

future = s_executors.schedule(this, _timeout, TimeUnit.MILLISECONDS);	}	Task task = null;	if (interpreter != null && interpreter.drain()) {	task = new Task(interpreter, ir);	s_executors.execute(task);	}	while (true) {	try {	if (_process.waitFor() == 0) {	
execution is successful 

if (interpreter != null) {	return interpreter.drain() ? task.getResult() : interpreter.interpret(ir);	} else {	return String.valueOf(_process.exitValue());	}	} else {	break;	}	} catch (InterruptedException e) {	if (!_isTimeOut) {	
we are interrupted but it s not a timeout just continue 

break;	}	} catch (InterruptedException e) {	if (!_isTimeOut) {	continue;	}	TimedOutLogger log = new TimedOutLogger(_process);	Task timedoutTask = new Task(log, ir);	timedoutTask.run();	if (!_passwordCommand) {	
timed out output is 

}	} catch (InterruptedException e) {	if (!_isTimeOut) {	continue;	}	TimedOutLogger log = new TimedOutLogger(_process);	Task timedoutTask = new Task(log, ir);	timedoutTask.run();	if (!_passwordCommand) {	} else {	
timed out 

} else {	}	return ERR_TIMEOUT;	} finally {	if (future != null) {	future.cancel(false);	}	Thread.interrupted();	}	}	
exit value is 

if (interpreter != null) {	error = interpreter.processError(reader);	} else {	error = String.valueOf(_process.exitValue());	}	if (_logger.isDebugEnabled()) {	_logger.debug(error);	}	return error;	} catch (SecurityException ex) {	
security exception not running as root 

} else {	error = String.valueOf(_process.exitValue());	}	if (_logger.isDebugEnabled()) {	_logger.debug(error);	}	return error;	} catch (SecurityException ex) {	return stackTraceAsString(ex);	} catch (Exception ex) {	
exception 

public String call() {	try {	
checking exit value of process 

public String call() {	try {	_process.exitValue();	
script ran within the alloted time 

public String call() {	try {	_process.exitValue();	} catch (IllegalThreadStateException e) {	
interrupting script 

public static String findScript(String path, String script) {	
looking for in the classpath 

public static String findScript(String path, String script) {	URL url = ClassLoader.getSystemResource(script);	
system resource 

public static String findScript(String path, String script) {	URL url = ClassLoader.getSystemResource(script);	File file = null;	if (url != null) {	file = new File(url.getFile());	s_logger.debug("Absolute path =  " + file.getAbsolutePath());	return file.getAbsolutePath();	}	if (path == null) {	
no search path specified unable to look for 

}	if (path == null) {	return null;	}	path = path.replace("/", File.separator);	if (path.endsWith(File.separator)) {	url = Script.class.getClassLoader().getResource(path + script);	} else {	url = Script.class.getClassLoader().getResource(path + File.separator + script);	}	
classpath resource 

url = Script.class.getClassLoader().getResource(path + script);	} else {	url = Script.class.getClassLoader().getResource(path + File.separator + script);	}	if (url != null) {	try {	file = new File(new URI(url.toString()).getPath());	s_logger.debug("Absolute path =  " + file.getAbsolutePath());	return file.getAbsolutePath();	} catch (URISyntaxException e) {	
unable to convert to a uri 

} catch (URISyntaxException e) {	}	}	if (path.endsWith(File.separator)) {	path = path.substring(0, path.lastIndexOf(File.separator));	}	if (path.startsWith(File.separator)) {	file = new File(path + File.separator + script);	return file.exists() ? file.getAbsolutePath() : null;	}	
looking for 

for (int i = 0; i < 3; i++) {	if (i == 0) {	String cp = Script.class.getResource(Script.class.getSimpleName() + ".class").toExternalForm();	int begin = cp.indexOf(File.separator);	if (begin < 0) begin = cp.indexOf('/');	int endBang = cp.lastIndexOf("!");	int end = cp.lastIndexOf(File.separator, endBang);	if (end < 0) end = cp.lastIndexOf('/', endBang);	if (end < 0) cp = cp.substring(begin);	else cp = cp.substring(begin, end);	
current binaries reside at 

String cp = Script.class.getResource(Script.class.getSimpleName() + ".class").toExternalForm();	int begin = cp.indexOf(File.separator);	if (begin < 0) begin = cp.indexOf('/');	int endBang = cp.lastIndexOf("!");	int end = cp.lastIndexOf(File.separator, endBang);	if (end < 0) end = cp.lastIndexOf('/', endBang);	if (end < 0) cp = cp.substring(begin);	else cp = cp.substring(begin, end);	search = cp;	} else if (i == 1) {	
searching in environment properties 

int endBang = cp.lastIndexOf("!");	int end = cp.lastIndexOf(File.separator, endBang);	if (end < 0) end = cp.lastIndexOf('/', endBang);	if (end < 0) cp = cp.substring(begin);	else cp = cp.substring(begin, end);	search = cp;	} else if (i == 1) {	try {	final File propsFile = PropertiesUtil.findConfigFile("environment.properties");	if (propsFile == null) {	
environment properties could not be opened 

search = cp;	} else if (i == 1) {	try {	final File propsFile = PropertiesUtil.findConfigFile("environment.properties");	if (propsFile == null) {	} else {	final Properties props = PropertiesUtil.loadFromFile(propsFile);	search = props.getProperty("paths.script");	}	} catch (IOException e) {	
environment properties could not be opened 

try {	final File propsFile = PropertiesUtil.findConfigFile("environment.properties");	if (propsFile == null) {	} else {	final Properties props = PropertiesUtil.loadFromFile(propsFile);	search = props.getProperty("paths.script");	}	} catch (IOException e) {	continue;	}	
environment properties says scripts should be in 

final File propsFile = PropertiesUtil.findConfigFile("environment.properties");	if (propsFile == null) {	} else {	final Properties props = PropertiesUtil.loadFromFile(propsFile);	search = props.getProperty("paths.script");	}	} catch (IOException e) {	continue;	}	} else {	
searching in the current directory 

} catch (IOException e) {	continue;	}	} else {	search = ".";	}	search += File.separatorChar + path + File.separator;	do {	search = search.substring(0, search.lastIndexOf(File.separator));	file = new File(search + File.separator + script);	
looking for in 

} while (!file.exists() && search.lastIndexOf(File.separator) != -1);	if (file.exists()) {	return file.getAbsolutePath();	}	}	search = System.getProperty("paths.script");	search += File.separatorChar + path + File.separator;	do {	search = search.substring(0, search.lastIndexOf(File.separator));	file = new File(search + File.separator + script);	
looking for in 

}	search = System.getProperty("paths.script");	search += File.separatorChar + path + File.separator;	do {	search = search.substring(0, search.lastIndexOf(File.separator));	file = new File(search + File.separator + script);	} while (!file.exists() && search.lastIndexOf(File.separator) != -1);	if (file.exists()) {	return file.getAbsolutePath();	}	
unable to find script 

========================= cloudstack sample_2800 =========================

details.put(SolidFireUtil.CLUSTER_ADMIN_PASSWORD, clusterAdminPassword);	long lMinIops = 100;	long lMaxIops = 15000;	long lBurstIops = 15000;	try {	String minIops = SolidFireUtil.getValue(SolidFireUtil.MIN_IOPS, url);	if (minIops != null && minIops.trim().length() > 0) {	lMinIops = Long.parseLong(minIops);	}	} catch (Exception ex) {	
ignored error getting min iops 

lMinIops = Long.parseLong(minIops);	}	} catch (Exception ex) {	}	try {	String maxIops = SolidFireUtil.getValue(SolidFireUtil.MAX_IOPS, url);	if (maxIops != null && maxIops.trim().length() > 0) {	lMaxIops = Long.parseLong(maxIops);	}	} catch (Exception ex) {	
ignored error getting max iops 

lMaxIops = Long.parseLong(maxIops);	}	} catch (Exception ex) {	}	try {	String burstIops = SolidFireUtil.getValue(SolidFireUtil.BURST_IOPS, url);	if (burstIops != null && burstIops.trim().length() > 0) {	lBurstIops = Long.parseLong(burstIops);	}	} catch (Exception ex) {	
ignored error getting burst iops 

}	if (!success) {	throw new CloudRuntimeException("Unable to create storage in cluster " + primaryDataStoreInfo.getClusterId());	}	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO host : allHosts) {	try {	_storageMgr.connectHostToSharedPool(host.getId(), primaryDataStoreInfo.getId());	poolHosts.add(host);	} catch (Exception e) {	
unable to establish a connection between and 

}	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO host : allHosts) {	try {	_storageMgr.connectHostToSharedPool(host.getId(), primaryDataStoreInfo.getId());	poolHosts.add(host);	} catch (Exception e) {	}	}	if (poolHosts.isEmpty()) {	
no host can access storage pool on cluster 

storagePoolDetail = _storagePoolDetailsDao.findDetail(storagePool.getId(), SolidFireUtil.IQN);	details.put(DeleteStoragePoolCommand.IQN, storagePoolDetail.getValue());	storagePoolDetail = _storagePoolDetailsDao.findDetail(storagePool.getId(), SolidFireUtil.STORAGE_VIP);	details.put(DeleteStoragePoolCommand.STORAGE_HOST, storagePoolDetail.getValue());	storagePoolDetail = _storagePoolDetailsDao.findDetail(storagePool.getId(), SolidFireUtil.STORAGE_PORT);	details.put(DeleteStoragePoolCommand.STORAGE_PORT, storagePoolDetail.getValue());	deleteCmd.setDetails(details);	}	final Answer answer = _agentMgr.easySend(host.getHostId(), deleteCmd);	if (answer != null && answer.getResult()) {	
successfully deleted storage pool using host id 

}	final Answer answer = _agentMgr.easySend(host.getHostId(), deleteCmd);	if (answer != null && answer.getResult()) {	HostVO hostVO = _hostDao.findById(host.getHostId());	if (hostVO != null) {	clusterId = hostVO.getClusterId();	}	break;	}	else {	
failed to delete storage pool using host id 

========================= cloudstack sample_1955 =========================

XmlRpcStreamConfig config = new XmlRpcHttpRequestConfigImpl();	XmlRpcClient client = new XmlRpcClient();	client.setTypeFactory(new RpcTypeFactory(client));	XmlRpcResponseParser parser = new XmlRpcResponseParser( (XmlRpcStreamRequestConfig) config, client.getTypeFactory());	XMLReader xr = SAXParsers.newXMLReader();	xr.setContentHandler(parser);	try {	String result = null;	if (getMethodResponse(method) != null) {	result = getMethodResponse(method);	
methodresponse call 

XmlRpcStreamConfig config = new XmlRpcHttpRequestConfigImpl();	XmlRpcClient client = new XmlRpcClient();	client.setTypeFactory(new RpcTypeFactory(client));	XmlRpcResponseParser parser = new XmlRpcResponseParser( (XmlRpcStreamRequestConfig) config, client.getTypeFactory());	XMLReader xr = SAXParsers.newXMLReader();	xr.setContentHandler(parser);	try {	String result = null;	if (getMethodResponse(method) != null) {	result = getMethodResponse(method);	
methodresponse reply 

XmlRpcResponseParser parser = new XmlRpcResponseParser( (XmlRpcStreamRequestConfig) config, client.getTypeFactory());	XMLReader xr = SAXParsers.newXMLReader();	xr.setContentHandler(parser);	try {	String result = null;	if (getMethodResponse(method) != null) {	result = getMethodResponse(method);	}	if (result == null && multiRes.size() >= 0) {	result = getResult();	
getresult call 

XmlRpcResponseParser parser = new XmlRpcResponseParser( (XmlRpcStreamRequestConfig) config, client.getTypeFactory());	XMLReader xr = SAXParsers.newXMLReader();	xr.setContentHandler(parser);	try {	String result = null;	if (getMethodResponse(method) != null) {	result = getMethodResponse(method);	}	if (result == null && multiRes.size() >= 0) {	result = getResult();	
getresult reply 

========================= cloudstack sample_832 =========================

public Boolean fenceOff(VirtualMachine vm, Host host) {	if (host.getHypervisorType() != HypervisorType.Simulator) {	
don t know how to fence non simulator hosts 

continue;	}	if( h.getId() == host.getId() ) {	continue;	}	FenceAnswer answer = null;	try {	answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	
moving on to the next host because is unavailable 

}	FenceAnswer answer = null;	try {	answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	}	continue;	} catch (OperationTimedoutException e) {	if (s_logger.isDebugEnabled()) {	
moving on to the next host because is unavailable 

if (s_logger.isDebugEnabled()) {	}	continue;	}	if (answer != null && answer.getResult()) {	return true;	}	}	}	if (s_logger.isDebugEnabled()) {	
unable to fence off on 

========================= cloudstack sample_977 =========================

public static void unregister() {	LogContext context = s_currentContext.get();	if (context != null) {	s_currentContext.remove();	if (s_logger.isTraceEnabled()) {	
unregistered 

========================= cloudstack sample_2912 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	vlanMgr.deleteRct(this);	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} catch (Exception e) {	
unable to add baremetal rct s 

========================= cloudstack sample_865 =========================

public void alterAddColumnToCloudUsage(final Connection conn) {	final String alterTableSql = "ALTER TABLE `cloud_usage`.`cloud_usage` ADD COLUMN `quota_calculated` tinyint(1) DEFAULT 0 NOT NULL COMMENT 'quota calculation status'";	try (PreparedStatement pstmt = conn.prepareStatement(alterTableSql)) {	pstmt.executeUpdate();	
altered cloud usage cloud usage table and added column quota calculated 

public void alterAddColumnToCloudUsage(final Connection conn) {	final String alterTableSql = "ALTER TABLE `cloud_usage`.`cloud_usage` ADD COLUMN `quota_calculated` tinyint(1) DEFAULT 0 NOT NULL COMMENT 'quota calculation status'";	try (PreparedStatement pstmt = conn.prepareStatement(alterTableSql)) {	pstmt.executeUpdate();	} catch (SQLException e) {	if (e.getMessage().contains("quota_calculated")) {	
cloud usage cloud usage table already has a column called quota calculated 

========================= cloudstack sample_4203 =========================

public String createEntityExtractUrl(DataStore store, String key, ImageFormat format, DataObject dataObject) {	S3TO s3 = (S3TO)getStoreTO(store);	if(s_logger.isDebugEnabled()) {	
generating pre signed entity extraction url for object 

========================= cloudstack sample_1902 =========================

public void processEvent(ObjectInDataStoreStateMachine.Event event) {	try {	objectInStoreMgr.update(this, event);	} catch (Exception e) {	
failed to update state 

if (snapshotTO.getPhysicalSize() != null) {	snapshotStore.setPhysicalSize(snapshotTO.getPhysicalSize());	}	if (snapshotTO.getParentSnapshotPath() == null) {	snapshotStore.setParentSnapshotId(0L);	}	snapshotStoreDao.update(snapshotStore.getId(), snapshotStore);	if (snapshotTO.getVolume() != null && snapshotTO.getVolume().getPath() != null) {	VolumeVO vol = volumeDao.findByUuid(snapshotTO.getVolume().getUuid());	if (vol != null) {	
update volume path change due to snapshot operation volume path 

if (snapshotTO.getParentSnapshotPath() == null) {	snapshotStore.setParentSnapshotId(0L);	}	snapshotStoreDao.update(snapshotStore.getId(), snapshotStore);	if (snapshotTO.getVolume() != null && snapshotTO.getVolume().getPath() != null) {	VolumeVO vol = volumeDao.findByUuid(snapshotTO.getVolume().getUuid());	if (vol != null) {	vol.setPath(snapshotTO.getVolume().getPath());	volumeDao.update(vol.getId(), vol);	} else {	
cound t find the original volume with uuid 

========================= cloudstack sample_3895 =========================

pstmt.setString(2, version);	pstmt.setString(3, serviceIP);	pstmt.setInt(4, servicePort);	pstmt.setString(5, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), lastUpdate));	pstmt.setLong(6, runid);	pstmt.setString(7, ManagementServerHost.State.Up.toString());	pstmt.setLong(8, id);	pstmt.executeUpdate();	txn.commit();	} catch (Exception e) {	
unexpected exception 

public boolean remove(Long id) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	txn.start();	ManagementServerHostVO msHost = findById(id);	msHost.setState(ManagementServerHost.State.Down);	super.remove(id);	txn.commit();	return true;	} catch (Exception e) {	
unexpected exception 

PreparedStatement pstmt = null;	try {	txn.start();	pstmt = txn.prepareAutoCloseStatement("update mshost set last_update=?, removed=null, alert_count=0 where id=? and runid=?");	pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), lastUpdate));	pstmt.setLong(2, id);	pstmt.setLong(3, runid);	int count = pstmt.executeUpdate();	txn.commit();	if (count < 1) {	
invalid cluster session detected runid is no longer valid 

pstmt = txn.prepareAutoCloseStatement("update mshost set last_update=?, removed=null, alert_count=0 where id=? and runid=?");	pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), lastUpdate));	pstmt.setLong(2, id);	pstmt.setLong(3, runid);	int count = pstmt.executeUpdate();	txn.commit();	if (count < 1) {	throw new CloudRuntimeException("Invalid cluster session detected, runId " + runid + " is no longer valid", new ClusterInvalidSessionException("runId " + runid + " is no longer valid"));	}	} catch (Exception e) {	
unexpected exception 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	int changedRows = 0;	try {	txn.start();	pstmt = txn.prepareAutoCloseStatement("update mshost set alert_count=alert_count+1 where id=? and alert_count=0");	pstmt.setLong(1, id);	changedRows = pstmt.executeUpdate();	txn.commit();	} catch (Exception e) {	
unexpected exception 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement("update mshost set state=?, last_update=? where id=? and runid=?");	pstmt.setString(1, state.toString());	pstmt.setString(2, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), lastUpdate));	pstmt.setLong(3, id);	pstmt.setLong(4, runId);	int count = pstmt.executeUpdate();	if (count < 1) {	
invalid cluster session detected runid is no longer valid 

========================= cloudstack sample_473 =========================

CallContext.current().setEventDetails("VM Id: " + getVirtualMachineId() + " to host Id: " + getHostId());	VirtualMachine migratedVm = _userVmService.migrateVirtualMachine(getVirtualMachineId(), destinationHost);	if (migratedVm != null) {	SystemVmResponse response = _responseGenerator.createSystemVmResponse(migratedVm);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate the system vm");	}	} catch (ResourceUnavailableException ex) {	
exception 

if (migratedVm != null) {	SystemVmResponse response = _responseGenerator.createSystemVmResponse(migratedVm);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate the system vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	
exception 

response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate the system vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (ManagementServerException e) {	
exception 

} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate the system vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (ManagementServerException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (VirtualMachineMigrationException e) {	
exception 

========================= cloudstack sample_3179 =========================

public Boolean fenceOff(VirtualMachine vm, Host host) {	if (host.getHypervisorType() != HypervisorType.XenServer) {	
don t know how to fence non xenserver hosts 

FenceAnswer answer;	try {	Answer ans = _agentMgr.send(h.getId(), fence);	if (!(ans instanceof FenceAnswer)) {	s_logger.debug("Answer is not fenceanswer.  Result = " + ans.getResult() + "; Details = " + ans.getDetails());	continue;	}	answer = (FenceAnswer)ans;	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	
moving on to the next host because is unavailable 

s_logger.debug("Answer is not fenceanswer.  Result = " + ans.getResult() + "; Details = " + ans.getDetails());	continue;	}	answer = (FenceAnswer)ans;	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	}	continue;	} catch (OperationTimedoutException e) {	if (s_logger.isDebugEnabled()) {	
moving on to the next host because is unavailable 

if (s_logger.isDebugEnabled()) {	}	continue;	}	if (answer != null && answer.getResult()) {	return true;	}	}	}	if (s_logger.isDebugEnabled()) {	
unable to fence off on 

========================= cloudstack sample_1144 =========================

public DeployDestination plan(VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid) throws InsufficientServerCapacityException {	VirtualMachine vm = vmProfile.getVirtualMachine();	ServiceOffering offering = vmProfile.getServiceOffering();	String hostTag = null;	String haVmTag = (String)vmProfile.getParameter(VirtualMachineProfile.Param.HaTag);	if (vm.getLastHostId() != null && haVmTag == null) {	HostVO h = _hostDao.findById(vm.getLastHostId());	DataCenter dc = _dcDao.findById(h.getDataCenterId());	Pod pod = _podDao.findById(h.getPodId());	Cluster c = _clusterDao.findById(h.getClusterId());	
start baremetal vm on last stayed host 

for (HostVO h : hosts) {	_hostDao.loadDetails(h);	if (h.getDetail("hostTag") != null && h.getDetail("hostTag").equalsIgnoreCase(hostTag)) {	target = h;	break;	}	}	}	}	if (target == null) {	
cannot find host with tag use capacity from service offering 

s_logger.warn("Cannot find HA host with tag " + haVmTag + " in cluster id=" + cluster.getId() + ", pod id=" + cluster.getPodId() + ", data center id=" + cluster.getDataCenterId());	return null;	}	for (HostVO h : hosts) {	long cluster_id = h.getClusterId();	ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, "cpuOvercommitRatio");	ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, "memoryOvercommitRatio");	Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());	Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());	if (_capacityMgr.checkIfHostHasCapacity(h.getId(), cpu_requested, ram_requested, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {	
find host has enough capacity 

========================= cloudstack sample_920 =========================

pstmt.setLong(4, usage.getNetworkOfferingId());	pstmt.executeUpdate();	}	}catch (SQLException e) {	throw new CloudException("Error updating UsageNetworkOfferingVO:"+e.getMessage(), e);	}	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usagenetworkofferingvo 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (deletedTS != null) {	deletedDate = DateUtil.parseDateString(s_gmtTimeZone, deletedTS);	}	usageRecords.add(new UsageNetworkOfferingVO(zoneId, acctId, dId, vmId, noId, nicId, isDefault, createdDate, deletedDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4501 =========================

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	
retrieving user 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	
username or password cannot be empty 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	UserAccount user = _userAccountDao.getUserAccount(username, domainId);	if (user == null) {	
unable to find user with in domain 

if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	UserAccount user = _userAccountDao.getUserAccount(username, domainId);	if (user == null) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	if (!user.getPassword().equals(password)) {	
password does not match 

========================= cloudstack sample_1353 =========================

public String[] getSupportedCipherSuites() {	String[] ciphers = null;	try {	ciphers = SSLUtils.getSupportedCiphers();	} catch (NoSuchAlgorithmException e) {	
securesslsocketfactory getdefaultciphersuites found no cipher suites 

========================= cloudstack sample_2713 =========================

public long download(boolean resume, DownloadCompleteCallback callback) {	if (_status == Status.ABORTED || _status == Status.UNRECOVERABLE_ERROR || _status == Status.DOWNLOAD_FINISHED) {	return 0;	}	_start = System.currentTimeMillis();	_resume = resume;	File src;	try {	src = new File(new URI(_downloadUrl));	} catch (URISyntaxException e1) {	
invalid uri 

FileOutputStream fos = null;	try {	if (_storage != null) {	dst.createNewFile();	_storage.setWorldReadableAndWriteable(dst);	}	ByteBuffer buffer = ByteBuffer.allocate(1024 * 512);	try {	fis = new FileInputStream(src);	} catch (FileNotFoundException e) {	
unable to find 

try {	fis = new FileInputStream(src);	} catch (FileNotFoundException e) {	_errorString = "Unable to find " + _downloadUrl;	return -1;	}	fic = fis.getChannel();	try {	fos = new FileOutputStream(dst);	} catch (FileNotFoundException e) {	
unable to find 

_totalBytes = 0;	_status = TemplateDownloader.Status.IN_PROGRESS;	try {	while (_status != Status.ABORTED && fic.read(buffer) != -1) {	buffer.flip();	int count = foc.write(buffer);	_totalBytes += count;	buffer.clear();	}	} catch (IOException e) {	
unable to download 

return _totalBytes;	} catch (Exception e) {	_status = TemplateDownloader.Status.UNRECOVERABLE_ERROR;	_errorString = e.getMessage();	return 0;	} finally {	if (fic != null) {	try {	fic.close();	} catch (IOException e) {	
ignore error while closing file input channel 

if (fic != null) {	try {	fic.close();	} catch (IOException e) {	}	}	if (foc != null) {	try {	foc.close();	} catch (IOException e) {	
ignore error while closing file output channel 

if (foc != null) {	try {	foc.close();	} catch (IOException e) {	}	}	if (fis != null) {	try {	fis.close();	} catch (IOException e) {	
ignore error while closing file input stream 

if (fis != null) {	try {	fis.close();	} catch (IOException e) {	}	}	if (fos != null) {	try {	fos.close();	} catch (IOException e) {	
ignore error while closing file output stream 

========================= cloudstack sample_408 =========================

} else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Lswitch) {	logicalSwitchUuid = Networks.BroadcastDomainType.getValue(nic.getBroadcastUri());	} else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Pvlan) {	vlanId = NetUtils.getPrimaryPvlanFromUri(nic.getBroadcastUri());	}	String trafficLabel = nic.getName();	Integer networkRateKBps = (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) ? nic.getNetworkRateMbps().intValue() * 128 : 0;	if (nic.getType() == Networks.TrafficType.Guest) {	if ((nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan || nic.getBroadcastType() == Networks.BroadcastDomainType.Pvlan) && !vlanId.equalsIgnoreCase("untagged")) {	if (trafficLabel != null && !trafficLabel.isEmpty()) {	
creating a vlan dev and bridge for guest traffic per traffic label 

} else {	throw new InternalErrorException("no traffic label ");	}	}	} else if (nic.getType() == Networks.TrafficType.Control) {	createControlNetwork();	intf.defBridgeNet(_bridges.get("linklocal"), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter));	} else if (nic.getType() == Networks.TrafficType.Public) {	if ((nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan) && (vNetId != null) && (protocol != null) && (!vNetId.equalsIgnoreCase("untagged")) || (nic.getBroadcastType() == Networks.BroadcastDomainType.Vxlan)) {	if (trafficLabel != null && !trafficLabel.isEmpty()) {	
creating a vnet dev and bridge for public traffic per traffic label 

vNetId = oldStyleBrNameMatcher.group(1);	} else if (brNameMatcher.find()) {	if (brNameMatcher.group(1) != null || !brNameMatcher.group(1).isEmpty()) {	pName = brNameMatcher.group(1);	} else {	pName = "undefined";	}	vNetId = brNameMatcher.group(2);	}	if (vNetId == null || vNetId.isEmpty()) {	
unable to get a vnet id from name 

} else {	scriptPath = _modifyVlanPath;	}	final Script command = new Script(scriptPath, _timeout, s_logger);	command.add("-o", "delete");	command.add("-v", vNetId);	command.add("-p", pName);	command.add("-b", brName);	final String result = command.execute();	if (result != null) {	
delete bridge failed 

========================= cloudstack sample_1095 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all vminstance usage events for account 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long vmId, String vmName, long zoneId, long serviceOfferingId, long templateId, String hypervisorType, Long cpuCores, Long cpuSpeed, Long memory) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long vmId, String vmName, long zoneId, long serviceOfferingId, long templateId, String hypervisorType, Long cpuCores, Long cpuSpeed, Long memory) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating vm usage record for vm type usage startdate enddate for account 

========================= cloudstack sample_2656 =========================

NicResponse resp = _responseGenerator.createNicResponse(r);	resp.setObjectName("nic");	resList.add(resp);	}	response.setResponses(resList);	}	response.setResponses(resList);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} catch (Exception e) {	
failed to list secondary ip address per nic 

========================= cloudstack sample_3505 =========================

registerNewNuageVspDevice(cmsIdConfig, nuageVspDevice.getId() + ":" + cmsId);	detail = new DetailVO(host.getId(), "nuagevspcmsid", cmsId);	_hostDetailsDao.persist(detail);	resourceConfiguration.nuageVspCmsId(cmsId);	resource.configure(cmd.getHostName(), Maps.<String, Object>newHashMap(resourceConfiguration.build()));	if (matchingNuageVspDevice == null) {	auditDomainsOnVsp((HostVO) host, true, false);	}	return nuageVspDevice;	} catch (ConfigurationException e) {	
failed to configure nuage vsd resource 

_hostDetailsDao.persist(detail);	resourceConfiguration.nuageVspCmsId(cmsId);	resource.configure(cmd.getHostName(), Maps.<String, Object>newHashMap(resourceConfiguration.build()));	if (matchingNuageVspDevice == null) {	auditDomainsOnVsp((HostVO) host, true, false);	}	return nuageVspDevice;	} catch (ConfigurationException e) {	throw new CloudRuntimeException("Failed to configure Nuage VSD resource " + cmd.getHostName(), e);	} catch (ExecutionException ee) {	
failed to add nuage vsp device 

}	if (command.getApiRetryInterval() != null && resourceConfiguration.retryInterval() != null) {	final int apiRetryInterval = Integer.parseInt(resourceConfiguration.retryInterval());	if (command.getApiRetryInterval() != apiRetryInterval) {	resourceConfiguration.retryInterval(String.valueOf(command.getApiRetryInterval()));	updateRequired = true;	}	}	if (!updateRequired) {	if (s_logger.isDebugEnabled()) {	
no change in the nuagevsp device parameters none of the nuagevsp device parameters are modified 

_hostDao.loadDetails(host);	boolean validateDomains = true;	List<NuageVspDeviceVO> nuageVspDevices = _nuageVspDao.listByHost(host.getId());	if (!CollectionUtils.isEmpty(nuageVspDevices)) {	for (NuageVspDeviceVO nuageVspDevice : nuageVspDevices) {	ConfigurationVO cmsIdConfig = _configDao.findByName("nuagevsp.cms.id");	String nuageVspCmsId = findNuageVspCmsIdForDevice(nuageVspDevice.getId(), cmsIdConfig);	SyncNuageVspCmsIdCommand syncCmd = new SyncNuageVspCmsIdCommand(SyncType.AUDIT, nuageVspCmsId);	SyncNuageVspCmsIdAnswer answer = (SyncNuageVspCmsIdAnswer) _agentMgr.easySend(nuageVspDevice.getHostId(), syncCmd);	if (answer != null && !answer.getSuccess()) {	
nuage vsp device with id is configured with an unknown cms id 

defaultNuageVspSharedSGNetworkOffering.setState(NetworkOffering.State.Enabled);	defaultNuageVspSharedSGNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultNuageVspSharedSGNetworkOffering);	Map<Network.Service, Network.Provider> defaultNuageVspSharedSGNetworkOfferingProviders = new HashMap<Network.Service, Network.Provider>();	defaultNuageVspSharedSGNetworkOfferingProviders.put(Network.Service.Dhcp, Network.Provider.NuageVsp);	defaultNuageVspSharedSGNetworkOfferingProviders.put(Network.Service.SecurityGroup, Network.Provider.NuageVsp);	defaultNuageVspSharedSGNetworkOfferingProviders.put(Network.Service.Connectivity, Network.Provider.NuageVsp);	for (Network.Service service : defaultNuageVspSharedSGNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultNuageVspSharedSGNetworkOffering.getId(), service, defaultNuageVspSharedSGNetworkOfferingProviders.get(service));	_networkOfferingServiceMapDao.persist(offService);	if (s_logger.isTraceEnabled()) {	
added service for the nuagevsp network offering 

private void initNuageVspVpcOffering() {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	VpcOffering offering = _vpcOffDao.findByUniqueName(nuageVPCOfferingName);	if (offering == null) {	if (s_logger.isDebugEnabled()) {	
creating default nuage vpc offering 

protected VpcOffering createVpcOffering(final String name, final String displayText, final Map<Network.Service, Set<Network.Provider>> svcProviderMap, final boolean isDefault, final VpcOffering.State state, final Long serviceOfferingId) {	return Transaction.execute(new TransactionCallback<VpcOffering>() {	public VpcOffering doInTransaction(TransactionStatus status) {	VpcOfferingVO offering = new VpcOfferingVO(name, displayText, isDefault, serviceOfferingId, false, false);	if (state != null) {	offering.setState(state);	}	if (s_logger.isDebugEnabled()) {	
adding vpc offering s 

}	offering = _vpcOffDao.persist(offering);	if (svcProviderMap != null) {	for (Network.Service service : svcProviderMap.keySet()) {	Set<Network.Provider> providers = svcProviderMap.get(service);	if (providers != null && !providers.isEmpty()) {	for (Network.Provider provider : providers) {	VpcOfferingServiceMapVO offService = new VpcOfferingServiceMapVO(offering.getId(), service, provider);	_vpcOffSvcMapDao.persist(offService);	if (s_logger.isTraceEnabled()) {	
added service for the vpc offering s with provider s 

protected void updateVpcOffering(final VpcOffering offering, final Map<Network.Service, Set<Network.Provider>> svcProviderMap) {	Transaction.execute(new TransactionCallback<VpcOffering>() {	public VpcOffering doInTransaction(TransactionStatus status) {	if (s_logger.isDebugEnabled()) {	
updating vpc offering s 

} else if (!currentSvcProviderMap.get(service).contains(provider)) {	currentSvcProviderMap.get(service).add(provider);	}	}	for (Network.Service service : svcProviderMap.keySet()) {	for (Network.Provider provider : svcProviderMap.get(service)) {	if (currentSvcProviderMap.get(service) == null || !currentSvcProviderMap.get(service).contains(provider)) {	VpcOfferingServiceMapVO offService = new VpcOfferingServiceMapVO(offering.getId(), service, provider);	_vpcOffSvcMapDao.persist(offService);	if (s_logger.isDebugEnabled()) {	
added service for the vpc offering s 

========================= cloudstack sample_1492 =========================

try {	final Network nw = citrixResourceBase.setupvSwitchNetwork(conn);	final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_delete_flow", "bridge", bridge, "vmName", command.getVmName());	if (result.equalsIgnoreCase("SUCCESS")) {	return new Answer(command, true, "success to delete flows for " + command.getVmName());	} else {	return new Answer(command, false, result);	}	} catch (final BadServerResponse e) {	
failed to delete flow 

final Network nw = citrixResourceBase.setupvSwitchNetwork(conn);	final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_delete_flow", "bridge", bridge, "vmName", command.getVmName());	if (result.equalsIgnoreCase("SUCCESS")) {	return new Answer(command, true, "success to delete flows for " + command.getVmName());	} else {	return new Answer(command, false, result);	}	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	
failed to delete flow 

final String bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_delete_flow", "bridge", bridge, "vmName", command.getVmName());	if (result.equalsIgnoreCase("SUCCESS")) {	return new Answer(command, true, "success to delete flows for " + command.getVmName());	} else {	return new Answer(command, false, result);	}	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
failed to delete flow 

========================= cloudstack sample_1168 =========================

if (purposes == null) {	purposes = new HashSet<Purpose>();	}	purposes.add(Purpose.StaticNat);	}	if (purposes == null || purposes.isEmpty()) {	continue;	} else {	if (postApplyRules) {	if (ip.isSourceNat()) {	
not releasing ip as it is in use for sourcenat 

hasFreeIps = _ipAddressDao.countFreeIPsInNetwork(network.getId()) > 0;	}	if (!hasFreeIps) {	return false;	}	if (network.getIp6Gateway() != null) {	hasFreeIps = isIP6AddressAvailableInNetwork(network.getId());	}	} else {	if (network.getCidr() == null) {	
network has null cidr 

if (_ipAddressDao.countFreeIpsInVlan(vlan.getId()) > 0) {	ret_network = nw;	break;	}	}	if (ret_network != null) {	break;	}	}	if (ret_network == null) {	
can not find network with security group enabled with free ips 

public NetworkVO getNetworkWithSecurityGroupEnabled(Long zoneId) {	List<NetworkVO> networks = _networksDao.listByZoneSecurityGroup(zoneId);	if (networks == null || networks.isEmpty()) {	return null;	}	if (networks.size() > 1) {	
there are multiple network with security group enabled select one of them 

List<NicVO> nics = _nicDao.listByVmId(vmId);	Nic defaultNic = null;	if (nics != null) {	for (Nic nic : nics) {	if (nic.isDefaultNic()) {	defaultNic = nic;	break;	}	}	} else {	
unable to find default network for the vm vm doesn t have any nics 

for (Nic nic : nics) {	if (nic.isDefaultNic()) {	defaultNic = nic;	break;	}	}	} else {	return null;	}	if (defaultNic == null) {	
unable to find default network for the vm vm doesn t have default nic 

public UserDataServiceProvider getUserDataUpdateProvider(Network network) {	String userDataProvider = _ntwkSrvcDao.getProviderForServiceInNetwork(network.getId(), Service.UserData);	if (userDataProvider == null) {	
network doesn t support service 

public boolean isSecurityGroupSupportedInNetwork(Network network) {	if (network.getTrafficType() != TrafficType.Guest) {	
security group can be enabled for guest networks only and network has a diff traffic type 

break;	case Hyperv: label = mgmtTraffic.getHypervNetworkLabel();	break;	case Ovm3: label = mgmtTraffic.getOvm3NetworkLabel();	break;	}	return label;	}	} catch (Exception ex) {	if (s_logger.isDebugEnabled()) {	
failed to retrive the default label for management traffic zone hypervisor due to 

break;	case Hyperv: label = storageTraffic.getHypervNetworkLabel();	break;	case Ovm3: label = storageTraffic.getOvm3NetworkLabel();	break;	}	return label;	}	} catch (Exception ex) {	if (s_logger.isDebugEnabled()) {	
failed to retrive the default label for storage traffic zone hypervisor due to 

physicalNetworkId = getNonGuestNetworkPhysicalNetworkId(network, effectiveTrafficType);	} else {	NetworkOffering offering = _entityMgr.findById(NetworkOffering.class, network.getNetworkOfferingId());	physicalNetworkId = network.getPhysicalNetworkId();	if (physicalNetworkId == null) {	physicalNetworkId = findPhysicalNetworkId(network.getDataCenterId(), offering.getTags(), offering.getTrafficType());	}	}	if (physicalNetworkId == null) {	assert (false) : "Can't get the physical network";	
can t get the physical network 

break;	case Hyperv: label = publicTraffic.getHypervNetworkLabel();	break;	case Ovm3: label = publicTraffic.getOvm3NetworkLabel();	break;	}	return label;	}	} catch (Exception ex) {	if (s_logger.isDebugEnabled()) {	
failed to retrieve the default label for public traffic zone hypervisor due to 

break;	case Hyperv: label = guestTraffic.getHypervNetworkLabel();	break;	case Ovm3: label = guestTraffic.getOvm3NetworkLabel();	break;	}	return label;	}	} catch (Exception ex) {	if (s_logger.isDebugEnabled()) {	
failed to retrive the default label for management traffic zone hypervisor due to 

public Set<Long> getAvailableIps(Network network, String requestedIp) {	String[] cidr = network.getCidr().split("/");	List<String> ips = getUsedIpsInNetwork(network);	Set<Long> usedIps = new TreeSet<Long>();	for (String ip : ips) {	if (requestedIp != null && requestedIp.equals(ip)) {	
requested ip address is already in use in network 

SearchBuilder<VlanVO> virtualNetworkVlanSB = _vlanDao.createSearchBuilder();	virtualNetworkVlanSB.and("vlanType", virtualNetworkVlanSB.entity().getVlanType(), Op.EQ);	IpAddressSearch.join("virtualNetworkVlanSB", virtualNetworkVlanSB, IpAddressSearch.entity().getVlanId(), virtualNetworkVlanSB.entity().getId(), JoinBuilder.JoinType.INNER);	IpAddressSearch.done();	NicForTrafficTypeSearch = _nicDao.createSearchBuilder();	SearchBuilder<NetworkVO> networkSearch = _networksDao.createSearchBuilder();	NicForTrafficTypeSearch.join("network", networkSearch, networkSearch.entity().getId(), NicForTrafficTypeSearch.entity().getNetworkId(), JoinType.INNER);	NicForTrafficTypeSearch.and("instance", NicForTrafficTypeSearch.entity().getInstanceId(), Op.EQ);	networkSearch.and("traffictype", networkSearch.entity().getTrafficType(), Op.EQ);	NicForTrafficTypeSearch.done();	
network model is configured 

public boolean start() {	for (NetworkElement element : networkElements) {	Map<Service, Map<Capability, String>> capabilities = element.getCapabilities();	Provider implementedProvider = element.getProvider();	if (implementedProvider != null) {	if (s_providerToNetworkElementMap.containsKey(implementedProvider.getName())) {	
cannot start networkmodel provider networkelement must be a one to one map multiple networkelements found for provider 

public boolean start() {	for (NetworkElement element : networkElements) {	Map<Service, Map<Capability, String>> capabilities = element.getCapabilities();	Provider implementedProvider = element.getProvider();	if (implementedProvider != null) {	if (s_providerToNetworkElementMap.containsKey(implementedProvider.getName())) {	continue;	}	
add provider element map entry 

List<Provider> providers = s_serviceToImplementedProvidersMap.get(service);	providers.add(implementedProvider);	} else {	List<Provider> providers = new ArrayList<Provider>();	providers.add(implementedProvider);	s_serviceToImplementedProvidersMap.put(service, providers);	}	}	}	}	
started network model 

} else {	cloudIdentifier = "CloudStack-{" + cloudIdentifier + "}";	}	vmData.add(new String[]{"metadata", "cloud-identifier", cloudIdentifier});	if (password != null && !password.isEmpty() && !password.equals("saved_password")) {	if (isWindows) {	MessageDigest md5 = null;	try {	md5 = MessageDigest.getInstance("MD5");	} catch (NoSuchAlgorithmException e) {	
unexpected exception 

========================= cloudstack sample_2314 =========================

public static HttpMethodRetryHandler getHttpMethodRetryHandler(final int retryCount) {	if (LOGGER.isDebugEnabled()) {	
initializing new httpmethodretryhandler with retry count 

public static void setProxy(Proxy proxy, HttpClient httpClient) {	if (proxy != null && httpClient != null) {	if (LOGGER.isDebugEnabled()) {	
setting proxy with host and port for host 

public static void setCredentials(String username, String password, HttpClient httpClient) {	if (username != null && password != null && httpClient != null) {	if (LOGGER.isDebugEnabled()) {	
setting credentials with username for host 

public static int executeMethod(HttpClient httpClient, HttpMethod httpMethod) {	try {	return httpClient.executeMethod(httpMethod);	} catch (IOException e) {	
exception while executing httpmethod on url 

========================= cloudstack sample_2744 =========================

public void update(ModelController controller) throws InternalErrorException, IOException {	if (!_netActive || !_nicActive) {	
vm interface update netactive nicactive 

}	api.read(vmi);	int ipCount = 0;	for (ModelObject successor : successors()) {	if (successor.getClass() == InstanceIpModel.class) {	ipCount++;	}	successor.update(controller);	}	if (ipCount == 0) {	
virtual machine interface has no instance ip 

========================= cloudstack sample_1884 =========================

public String xmlToString(String path, Document xmlDocument) throws Ovm3ResourceException {	XPathFactory factory = javax.xml.xpath.XPathFactory.newInstance();	XPath xPath = factory.newXPath();	try {	XPathExpression xPathExpression = xPath.compile(path);	NodeList nodeList = (NodeList) xPathExpression.evaluate(xmlDocument, XPathConstants.NODESET);	return nodeList.item(0).getTextContent();	} catch (NullPointerException e) {	
got no items back from parsing returning null 

========================= cloudstack sample_849 =========================

public NiciraNvpTag(String scope, String tag) {	this.scope = scope;	if (tag.length() > 40) {	
tag tag too long truncating to characters 

public void setTag(String tag) {	if (tag.length() > 40) {	
tag tag too long truncating to characters 

========================= cloudstack sample_1742 =========================

protected void runInContext() {	if (s_logger.isInfoEnabled()) {	
checking health of usage server 

TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);	try {	Date lastHeartbeat = _usageJobDao.getLastHeartbeat();	if (lastHeartbeat != null) {	long sinceLastHeartbeat = System.currentTimeMillis() - lastHeartbeat.getTime();	if (sinceLastHeartbeat <= (10 * 60 * 1000)) {	isRunning = true;	}	}	if (s_logger.isDebugEnabled()) {	
usage server running heartbeat 

txn.close();	TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);	swap.close();	}	if (!isRunning) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER, 0, new Long(0), "No usage server process running", "No usage server process has been detected, some attention is required");	} else {	_alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER, 0, 0);	}	} catch (Exception ex) {	
error while monitoring usage job 

========================= cloudstack sample_2494 =========================

protected Pair<List<Long>, Map<Long, Double>> listClustersByUserDispersion(long id, boolean isZone, long accountId) {	if (s_logger.isDebugEnabled()) {	
applying userdispersion heuristic to clusters for account 

protected Pair<List<Long>, Map<Long, Double>> listClustersByUserDispersion(long id, boolean isZone, long accountId) {	if (s_logger.isDebugEnabled()) {	}	Pair<List<Long>, Map<Long, Double>> clusterIdsVmCountInfo;	if (isZone) {	clusterIdsVmCountInfo = vmInstanceDao.listClusterIdsInZoneByVmCount(id, accountId);	} else {	clusterIdsVmCountInfo = vmInstanceDao.listClusterIdsInPodByVmCount(id, accountId);	}	if (s_logger.isTraceEnabled()) {	
list of clusters in ascending order of number of vms 

protected Pair<List<Long>, Map<Long, Double>> listPodsByUserDispersion(long dataCenterId, long accountId) {	if (s_logger.isDebugEnabled()) {	
applying userdispersion heuristic to pods for account 

protected Pair<List<Long>, Map<Long, Double>> listPodsByUserDispersion(long dataCenterId, long accountId) {	if (s_logger.isDebugEnabled()) {	}	Pair<List<Long>, Map<Long, Double>> podIdsVmCountInfo = vmInstanceDao.listPodIdsInZoneByVmCount(dataCenterId, accountId);	if (s_logger.isTraceEnabled()) {	
list of pods in ascending order of number of vms 

private List<Long> orderByApplyingWeights(Pair<List<Long>, Map<Long, Double>> capacityInfo, Pair<List<Long>, Map<Long, Double>> vmCountInfo, long accountId) {	List<Long> capacityOrderedIds = capacityInfo.first();	List<Long> vmCountOrderedIds = vmCountInfo.first();	Map<Long, Double> capacityMap = capacityInfo.second();	Map<Long, Double> vmCountMap = vmCountInfo.second();	if (s_logger.isTraceEnabled()) {	
capacity id list capacitymap 

private List<Long> orderByApplyingWeights(Pair<List<Long>, Map<Long, Double>> capacityInfo, Pair<List<Long>, Map<Long, Double>> vmCountInfo, long accountId) {	List<Long> capacityOrderedIds = capacityInfo.first();	List<Long> vmCountOrderedIds = vmCountInfo.first();	Map<Long, Double> capacityMap = capacityInfo.second();	Map<Long, Double> vmCountMap = vmCountInfo.second();	if (s_logger.isTraceEnabled()) {	}	if (s_logger.isTraceEnabled()) {	
vm count id list vmcountmap 

List<Long> vmCountOrderedIds = vmCountInfo.first();	Map<Long, Double> capacityMap = capacityInfo.second();	Map<Long, Double> vmCountMap = vmCountInfo.second();	if (s_logger.isTraceEnabled()) {	}	if (s_logger.isTraceEnabled()) {	}	List<Long> idsReorderedByWeights = new ArrayList<Long>();	float capacityWeight = (1.0f - _userDispersionWeight);	if (s_logger.isDebugEnabled()) {	
applying userdispersionweight 

}	if (s_logger.isTraceEnabled()) {	}	List<Long> idsReorderedByWeights = new ArrayList<Long>();	float capacityWeight = (1.0f - _userDispersionWeight);	if (s_logger.isDebugEnabled()) {	}	LinkedHashMap<Long, Double> normalisedVmCountIdMap = new LinkedHashMap<Long, Double>();	Long totalVmsOfAccount = vmInstanceDao.countRunningByAccount(accountId);	if (s_logger.isDebugEnabled()) {	
total vms for account 

} else {	List<Long> idList = new ArrayList<Long>();	idList.add(id);	sortedMap.put(totalWeight, idList);	}	}	for (List<Long> idList : sortedMap.values()) {	idsReorderedByWeights.addAll(idList);	}	if (s_logger.isTraceEnabled()) {	
reordered id list 

========================= cloudstack sample_760 =========================

private Socket _getSocket() throws IOException {	if (useSSL) {	SSLContext context = null;	try {	context = SSLUtils.getSSLContext("SunJSSE");	} catch (NoSuchAlgorithmException e) {	
unexpected exception 

private Socket _getSocket() throws IOException {	if (useSSL) {	SSLContext context = null;	try {	context = SSLUtils.getSSLContext("SunJSSE");	} catch (NoSuchAlgorithmException e) {	} catch (NoSuchProviderException e) {	
unexpected exception 

} catch (NoSuchProviderException e) {	}	if (context == null) throw new IOException("Unable to setup SSL context");	SSLSocket ssl = null;	try {	context.init(null, trustAllCerts, new SecureRandom());	SocketFactory factory = new SecureSSLSocketFactory(context);	ssl = (SSLSocket)factory.createSocket(host, port);	ssl.setEnabledProtocols(SSLUtils.getSupportedProtocols(ssl.getEnabledProtocols()));	} catch (IOException e) {	
ioexception 

if (context == null) throw new IOException("Unable to setup SSL context");	SSLSocket ssl = null;	try {	context.init(null, trustAllCerts, new SecureRandom());	SocketFactory factory = new SecureSSLSocketFactory(context);	ssl = (SSLSocket)factory.createSocket(host, port);	ssl.setEnabledProtocols(SSLUtils.getSupportedProtocols(ssl.getEnabledProtocols()));	} catch (IOException e) {	throw e;	} catch (KeyManagementException e) {	
keymanagementexception 

SSLSocket ssl = null;	try {	context.init(null, trustAllCerts, new SecureRandom());	SocketFactory factory = new SecureSSLSocketFactory(context);	ssl = (SSLSocket)factory.createSocket(host, port);	ssl.setEnabledProtocols(SSLUtils.getSupportedProtocols(ssl.getEnabledProtocols()));	} catch (IOException e) {	throw e;	} catch (KeyManagementException e) {	} catch (NoSuchAlgorithmException e) {	
nosuchalgorithmexception 

========================= cloudstack sample_4956 =========================

private void closeStream() {	if (verbose) System.out.println("[" + this + "] INFO: Closing stream.");	try {	is.close();	} catch (IOException e) {	
ignored io error on input stream 

private void closeStream() {	if (verbose) System.out.println("[" + this + "] INFO: Closing stream.");	try {	is.close();	} catch (IOException e) {	}	try {	sendEventToAllPads(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	
ignored error sending an event to all pods 

========================= cloudstack sample_5097 =========================

if (!EncryptionSecretKeyChecker.useEncryption() || (plain == null) || plain.isEmpty()) {	return plain;	}	if (s_encryptor == null) {	initialize();	}	String encryptedString = null;	try {	encryptedString = s_encryptor.encrypt(plain);	} catch (EncryptionOperationNotPossibleException e) {	
error while encrypting 

if (!EncryptionSecretKeyChecker.useEncryption() || (encrypted == null) || encrypted.isEmpty()) {	return encrypted;	}	if (s_encryptor == null) {	initialize();	}	String plain = null;	try {	plain = s_encryptor.decrypt(encrypted);	} catch (EncryptionOperationNotPossibleException e) {	
error while decrypting 

========================= cloudstack sample_2752 =========================

for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	NodeList commandName = fstElmnt.getElementsByTagName("name");	Element commandElmnt = (Element)commandName.item(0);	NodeList commandNm = commandElmnt.getChildNodes();	if (commandNm.item(0).getNodeValue().equals("mysqlupdate")) {	NodeList mysqlList = fstElmnt.getElementsByTagName("mysqlcommand");	for (int j = 0; j < mysqlList.getLength(); j++) {	Element itemVariableElement = (Element)mysqlList.item(j);	
executing mysql command 

return false;	}	}	}	else if (commandNm.item(0).getNodeValue().equals("agentcommand")) {	NodeList commandList = fstElmnt.getElementsByTagName("commandname");	Element commandElement = (Element)commandList.item(0);	NodeList ipList = fstElmnt.getElementsByTagName("ip");	for (int j = 0; j < ipList.getLength(); j++) {	Element itemVariableElement = (Element)ipList.item(j);	
attempting to ssh into agent 

}	else if (commandNm.item(0).getNodeValue().equals("agentcommand")) {	NodeList commandList = fstElmnt.getElementsByTagName("commandname");	Element commandElement = (Element)commandList.item(0);	NodeList ipList = fstElmnt.getElementsByTagName("ip");	for (int j = 0; j < ipList.getLength(); j++) {	Element itemVariableElement = (Element)ipList.item(j);	try {	Connection conn = new Connection(itemVariableElement.getTextContent());	conn.connect(null, 60000, 60000);	
sshed successfully into agent 

NodeList commandList = fstElmnt.getElementsByTagName("commandname");	Element commandElement = (Element)commandList.item(0);	NodeList ipList = fstElmnt.getElementsByTagName("ip");	for (int j = 0; j < ipList.getLength(); j++) {	Element itemVariableElement = (Element)ipList.item(j);	try {	Connection conn = new Connection(itemVariableElement.getTextContent());	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", "password");	if (isAuthenticated == false) {	
authentication failed for root with password 

for (int j = 0; j < ipList.getLength(); j++) {	Element itemVariableElement = (Element)ipList.item(j);	try {	Connection conn = new Connection(itemVariableElement.getTextContent());	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", "password");	if (isAuthenticated == false) {	return false;	}	Session sess = conn.openSession();	
executing 

} catch (Exception ex) {	s_logger.error(ex);	return false;	}	}	}	else {	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	
test case failed command that was supposed to fail passed the command was sent with the following url 

}	}	else {	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	
test case passed empty response was returned as expected command was sent with url 

}	else {	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	
test case failed empty response was expected command was sent with url 

error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	}	} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use the command was sent with url 

if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	}	} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	
test case passed command was sent with the url 

} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	
command failed with an error code command was sent with url 

if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	
the command is required for the future use so exiging 

} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	return false;	}	error++;	} else if (api.getTestCaseInfo() != null) {	
test case passed command that was supposed to fail failed command was sent with url 

return false;	}	error++;	} else if (api.getTestCaseInfo() != null) {	}	}	}	HashMap<String, Integer> expectedEvents = new HashMap<String, Integer>();	expectedEvents.put("VM.START", 1);	boolean eventResult = ApiCommand.verifyEvents(expectedEvents, "INFO", "http: "&type=VM.START");	
test case listevent command verification result is 

}	error++;	} else if (api.getTestCaseInfo() != null) {	}	}	}	HashMap<String, Integer> expectedEvents = new HashMap<String, Integer>();	expectedEvents.put("VM.START", 1);	boolean eventResult = ApiCommand.verifyEvents(expectedEvents, "INFO", "http: "&type=VM.START");	eventResult = ApiCommand.verifyEvents(".. this.getParam().get("erroruseraccount"));	
listevent command verification result is 

========================= cloudstack sample_449 =========================

pstmt = conn.prepareStatement("update network_offerings set concurrent_connections=? where id=?");	pstmt.setInt(1, maxconnections);	pstmt.setLong(2, network_offering_id);	pstmt.executeUpdate();	}	}	}	pstmt = conn.prepareStatement("drop table `cloud`.`network_details`");	pstmt.executeUpdate();	} catch (SQLException e) {	
ignored error during network offering update 

========================= cloudstack sample_4239 =========================

public Answer execute(final CheckSshCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	final String vmName = command.getName();	final String privateIp = command.getIp();	final int cmdPort = command.getPort();	if (s_logger.isDebugEnabled()) {	
ping command port 

}	try {	final String result = citrixResourceBase.connect(conn, command.getName(), privateIp, cmdPort);	if (result != null) {	return new CheckSshAnswer(command, "Can not ping System vm " + vmName + "due to:" + result);	}	} catch (final Exception e) {	return new CheckSshAnswer(command, e);	}	if (s_logger.isDebugEnabled()) {	
ping command port succeeded for vm 

========================= cloudstack sample_1191 =========================

public void releaseIpAddress(String ipAddress, long dcId, long instanceId) {	if (s_logger.isDebugEnabled()) {	
releasing ip address data center 

========================= cloudstack sample_4669 =========================

public void execute() {	CallContext.current().setEventDetails("AutoScale VM Profile Id: " + getId());	boolean result = _autoScaleService.deleteAutoScaleVmProfile(id);	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	
failed to delete autoscale vm profile 

========================= cloudstack sample_3456 =========================

eventName = "EVENT_CANCEL_MAINTENANCE_AFTER";	} else if (event.equals(ResourceListener.EVENT_PREPARE_MAINTENANCE_BEFORE)) {	l.processPrepareMaintenaceEventBefore((Long)params[0]);	eventName = "EVENT_PREPARE_MAINTENANCE_BEFORE";	} else if (event.equals(ResourceListener.EVENT_PREPARE_MAINTENANCE_AFTER)) {	l.processPrepareMaintenaceEventAfter((Long)params[0]);	eventName = "EVENT_PREPARE_MAINTENANCE_AFTER";	} else {	throw new CloudRuntimeException("Unknown resource event:" + event);	}	
sent resource event to listener 

throw ex;	}	if (clusterName == null || clusterName.isEmpty()) {	throw new InvalidParameterValueException("Please specify cluster name");	}	if (cmd.getHypervisor() == null || cmd.getHypervisor().isEmpty()) {	throw new InvalidParameterValueException("Please specify a hypervisor");	}	final Hypervisor.HypervisorType hypervisorType = Hypervisor.HypervisorType.getType(cmd.getHypervisor());	if (hypervisorType == null) {	
unable to resolve to a valid supported hypervisor type 

resources = discoverer.find(dcId, podId, cluster.getId(), uri, username, password, null);	if (resources != null) {	for (final Map.Entry<? extends ServerResource, Map<String, String>> entry : resources.entrySet()) {	final ServerResource resource = entry.getKey();	final HostVO host = (HostVO)createHostAndAgent(resource, entry.getValue(), true, null, false);	if (host != null) {	hosts.add(host);	}	discoverer.postDiscovery(hosts, _nodeId);	}	
external cluster has been successfully discovered by 

final ServerResource resource = entry.getKey();	final HostVO host = (HostVO)createHostAndAgent(resource, entry.getValue(), true, null, false);	if (host != null) {	hosts.add(host);	}	discoverer.postDiscovery(hosts, _nodeId);	}	success = true;	return result;	}	
unable to find the server resources at 

final URI cifsUri = new URI(url);	final String warnMsg = UriUtils.getCifsUriParametersProblems(cifsUri);	if (warnMsg != null) {	throw new InvalidParameterValueException(warnMsg);	}	}	} catch (final URISyntaxException e) {	throw new InvalidParameterValueException(url + " is not a valid uri");	}	final List<HostVO> hosts = new ArrayList<HostVO>();	
trying to add a new host at in data center 

continue;	}	isHypervisorTypeSupported = true;	Map<? extends ServerResource, Map<String, String>> resources = null;	processResourceEvent(ResourceListener.EVENT_DISCOVER_BEFORE, dcId, podId, clusterId, uri, username, password, hostTags);	try {	resources = discoverer.find(dcId, podId, clusterId, uri, username, password, hostTags);	} catch (final DiscoveryException e) {	throw e;	} catch (final Exception e) {	
exception in host discovery process with discoverer skip to another discoverer if there is any 

for (final Map.Entry<? extends ServerResource, Map<String, String>> entry : resources.entrySet()) {	final ServerResource resource = entry.getKey();	if (resource instanceof KvmDummyResourceBase) {	final Map<String, String> details = entry.getValue();	final String guid = details.get("guid");	final List<HostVO> kvmHosts = listAllUpAndEnabledHosts(Host.Type.Routing, clusterId, podId, dcId);	for (final HostVO host : kvmHosts) {	if (host.getGuid().equalsIgnoreCase(guid)) {	if (hostTags != null) {	if (s_logger.isTraceEnabled()) {	
adding host tags for kvm host tags 

if (deferAgentCreation) {	host = (HostVO)createHostAndAgentDeferred(resource, entry.getValue(), true, hostTags, false);	} else {	host = (HostVO)createHostAndAgent(resource, entry.getValue(), true, hostTags, false);	}	if (host != null) {	hosts.add(host);	}	discoverer.postDiscovery(hosts, _nodeId);	}	
server resources successfully discovered by 

discoverer.postDiscovery(hosts, _nodeId);	}	return hosts;	}	}	if (!isHypervisorTypeSupported) {	final String msg = "Do not support HypervisorType " + hypervisorType + " for " + url;	s_logger.warn(msg);	throw new DiscoveryException(msg);	}	
unable to find the server resources at 

final List<HostVO> hosts = listAllHostsInCluster(clusterId);	if (hosts.size() == 0) {	final ClusterVO cluster = _clusterDao.findById(clusterId);	cluster.setGuid(null);	_clusterDao.update(clusterId, cluster);	}	}	try {	resourceStateTransitTo(host, ResourceState.Event.DeleteHost, _nodeId);	} catch (final NoTransitionException e) {	
cannot transmit host to enabled state 

public boolean deleteCluster(final DeleteClusterCmd cmd) {	try {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final ClusterVO cluster = _clusterDao.lockRow(cmd.getId(), true);	if (cluster == null) {	if (s_logger.isDebugEnabled()) {	
cluster does not even exist delete call is ignored 

final ClusterVO cluster = _clusterDao.lockRow(cmd.getId(), true);	if (cluster == null) {	if (s_logger.isDebugEnabled()) {	}	throw new CloudRuntimeException("Cluster: " + cmd.getId() + " does not exist");	}	final Hypervisor.HypervisorType hypervisorType = cluster.getHypervisorType();	final List<HostVO> hosts = listAllHostsInCluster(cmd.getId());	if (hosts.size() > 0) {	if (s_logger.isDebugEnabled()) {	
cluster still has hosts can t remove 

final Hypervisor.HypervisorType hypervisorType = cluster.getHypervisorType();	final List<HostVO> hosts = listAllHostsInCluster(cmd.getId());	if (hosts.size() > 0) {	if (s_logger.isDebugEnabled()) {	}	throw new CloudRuntimeException("Cluster: " + cmd.getId() + " cannot be removed. Cluster still has hosts");	}	final List<StoragePoolVO> storagePools = _storagePoolDao.listPoolsByCluster(cmd.getId());	if (storagePools.size() > 0) {	if (s_logger.isDebugEnabled()) {	
cluster still has storage pools can t remove 

if (dr != null) {	_dedicatedDao.remove(dr.getId());	}	}	}	});	return true;	} catch (final CloudRuntimeException e) {	throw e;	} catch (final Throwable t) {	
unable to delete cluster 

public Cluster updateCluster(final Cluster clusterToUpdate, final String clusterType, final String hypervisor, final String allocationState, final String managedstate) {	final ClusterVO cluster = (ClusterVO)clusterToUpdate;	boolean doUpdate = false;	if (hypervisor != null && !hypervisor.isEmpty()) {	final Hypervisor.HypervisorType hypervisorType = Hypervisor.HypervisorType.getType(hypervisor);	if (hypervisorType == null) {	
unable to resolve to a valid supported hypervisor type 

}	}	Cluster.ClusterType newClusterType = null;	if (clusterType != null && !clusterType.isEmpty()) {	try {	newClusterType = Cluster.ClusterType.valueOf(clusterType);	} catch (final IllegalArgumentException ex) {	throw new InvalidParameterValueException("Unable to resolve " + clusterType + " to a supported type");	}	if (newClusterType == null) {	
unable to resolve to a valid supported cluster type 

}	}	Grouping.AllocationState newAllocationState = null;	if (allocationState != null && !allocationState.isEmpty()) {	try {	newAllocationState = Grouping.AllocationState.valueOf(allocationState);	} catch (final IllegalArgumentException ex) {	throw new InvalidParameterValueException("Unable to resolve Allocation State '" + allocationState + "' to a supported state");	}	if (newAllocationState == null) {	
unable to resolve to a valid supported allocation state 

}	Managed.ManagedState newManagedState = null;	final Managed.ManagedState oldManagedState = cluster.getManagedState();	if (managedstate != null && !managedstate.isEmpty()) {	try {	newManagedState = Managed.ManagedState.valueOf(managedstate);	} catch (final IllegalArgumentException ex) {	throw new InvalidParameterValueException("Unable to resolve Managed State '" + managedstate + "' to a supported state");	}	if (newManagedState == null) {	
unable to resolve managed state to a supported state 

private boolean doMaintain(final long hostId) {	final HostVO host = _hostDao.findById(hostId);	final MaintainAnswer answer = (MaintainAnswer)_agentMgr.easySend(hostId, new MaintainCommand());	if (answer == null || !answer.getResult()) {	
unable to send maintaincommand to host 

public Host maintain(final PrepareForMaintenanceCmd cmd) {	final Long hostId = cmd.getId();	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	
unable to find host 

if (host.getType() != Host.Type.Storage) {	final List<VMInstanceVO> vos = _vmDao.listByHostId(hostId);	final List<VMInstanceVO> vosMigrating = _vmDao.listVmsMigratingFromHost(hostId);	if (vos.isEmpty() && vosMigrating.isEmpty()) {	resourceStateTransitTo(host, ResourceState.Event.InternalEnterMaintenance, _nodeId);	hostInMaintenance = true;	ActionEventUtils.onCompletedActionEvent(CallContext.current().getCallingUserId(), CallContext.current().getCallingAccountId(), EventVO.LEVEL_INFO, EventTypes.EVENT_MAINTENANCE_PREPARE, "completed maintenance for host " + hostId, 0);	}	}	} catch (final NoTransitionException e) {	
cannot transmit host to maintenance state 

}	} else {	if (guestOSDetail != null) {	_hostDetailsDao.remove(guestOSDetail.getId());	}	}	}	final List<String> hostTags = cmd.getHostTags();	if (hostTags != null) {	if (s_logger.isDebugEnabled()) {	
updating host tags to 

if (result != null && singleTaker) {	break;	}	} else if (event == ResourceStateAdapter.Event.DELETE_HOST) {	try {	result = adapter.deleteHost((HostVO)args[0], (Boolean)args[1], (Boolean)args[2]);	if (result != null) {	break;	}	} catch (final UnableDeleteHostException e) {	
adapter says unable to delete host 

public void checkCIDR(final HostPodVO pod, final DataCenterVO dc, final String serverPrivateIP, final String serverPrivateNetmask) throws IllegalArgumentException {	if (serverPrivateIP == null) {	return;	}	final String cidrAddress = pod.getCidrAddress();	final long cidrSize = pod.getCidrSize();	final String cidrSubnet = NetUtils.getCidrSubNet(cidrAddress, cidrSize);	final String serverSubnet = NetUtils.getSubNet(serverPrivateIP, serverPrivateNetmask);	if (!cidrSubnet.equals(serverSubnet)) {	
the private ip address of the server is not compatible with the cidr of pod and zone 

}	}	}	long dcId = -1;	DataCenterVO dc = _dcDao.findByName(dataCenter);	if (dc == null) {	try {	dcId = Long.parseLong(dataCenter);	dc = _dcDao.findById(dcId);	} catch (final NumberFormatException e) {	
cannot parse into long 

if (dc == null) {	throw new IllegalArgumentException("Host " + startup.getPrivateIpAddress() + " sent incorrect data center: " + dataCenter);	}	dcId = dc.getId();	HostPodVO p = _podDao.findByName(pod, dcId);	if (p == null) {	try {	final long podId = Long.parseLong(pod);	p = _podDao.findById(podId);	} catch (final NumberFormatException e) {	
cannot parse into long 

_hostDao.update(host.getId(), host);	}	if (startup instanceof StartupRoutingCommand) {	final StartupRoutingCommand ssCmd = (StartupRoutingCommand)startup;	updateSupportsClonedVolumes(host, ssCmd.getSupportsClonedVolumes());	}	try {	resourceStateTransitTo(host, ResourceState.Event.InternalCreated, _nodeId);	_agentMgr.agentStatusTransitTo(host, Status.Event.AgentConnected, _nodeId);	} catch (final Exception e) {	
cannot transmit host to creating state 

updateSupportsClonedVolumes(host, ssCmd.getSupportsClonedVolumes());	}	try {	resourceStateTransitTo(host, ResourceState.Event.InternalCreated, _nodeId);	_agentMgr.agentStatusTransitTo(host, Status.Event.AgentConnected, _nodeId);	} catch (final Exception e) {	_agentMgr.agentStatusTransitTo(host, Status.Event.Error, _nodeId);	try {	resourceStateTransitTo(host, ResourceState.Event.Error, _nodeId);	} catch (final NoTransitionException e1) {	
cannot transmit host to error state 

private Host createHostAndAgent(final ServerResource resource, final Map<String, String> details, final boolean old, final List<String> hostTags, final boolean forRebalance) {	HostVO host = null;	StartupCommand[] cmds = null;	boolean hostExists = false;	boolean created = false;	try {	cmds = resource.initialize();	if (cmds == null) {	
unable to fully initialize the agent because no startupcommands are returned 

if (s_logger.isDebugEnabled()) {	new Request(-1l, -1l, cmds, true, false).logD("Startup request from directly connected host: ", true);	}	if (old) {	final StartupCommand firstCmd = cmds[0];	host = findHostByGuid(firstCmd.getGuid());	if (host == null) {	host = findHostByGuid(firstCmd.getGuidWithoutResource());	}	if (host != null && host.getRemoved() == null) {	
found the host by guid old host reconnected as new 

return null;	}	}	boolean newHost = getNewHost(cmds) == null;	host = createHostVO(cmds, resource, details, hostTags, ResourceStateAdapter.Event.CREATE_HOST_VO_FOR_DIRECT_CONNECT);	if (host != null) {	created = _agentMgr.handleDirectConnectAgent(host, cmds, resource, forRebalance, newHost);	host = _hostDao.findById(host.getId());	}	} catch (final Exception e) {	
unable to connect due to 

private Host createHostAndAgentDeferred(final ServerResource resource, final Map<String, String> details, final boolean old, final List<String> hostTags, final boolean forRebalance) {	HostVO host = null;	StartupCommand[] cmds = null;	boolean hostExists = false;	boolean deferAgentCreation = true;	boolean created = false;	try {	cmds = resource.initialize();	if (cmds == null) {	
unable to fully initialize the agent because no startupcommands are returned 

if (s_logger.isDebugEnabled()) {	new Request(-1l, -1l, cmds, true, false).logD("Startup request from directly connected host: ", true);	}	if (old) {	final StartupCommand firstCmd = cmds[0];	host = findHostByGuid(firstCmd.getGuid());	if (host == null) {	host = findHostByGuid(firstCmd.getGuidWithoutResource());	}	if (host != null && host.getRemoved() == null) {	
found the host by guid old host reconnected as new 

host = _hostDao.findById(host.getId());	} else {	host = _hostDao.findById(host.getId());	_agentMgr.agentStatusTransitTo(host, Status.Event.AgentDisconnected, _nodeId);	host = _hostDao.findById(host.getId());	host.setLastPinged(0);	_hostDao.update(host.getId(), host);	}	}	} catch (final Exception e) {	
unable to connect due to 

public HostVO fillRoutingHostVO(final HostVO host, final StartupRoutingCommand ssCmd, final HypervisorType hyType, Map<String, String> details, final List<String> hostTags) {	if (host.getPodId() == null) {	
host sent incorrect pod pod id is null 

public void deleteRoutingHost(final HostVO host, final boolean isForced, final boolean forceDestroyStorage) throws UnableDeleteHostException {	if (host.getType() != Host.Type.Routing) {	throw new CloudRuntimeException("Non-Routing host gets in deleteRoutingHost, id is " + host.getId());	}	if (s_logger.isDebugEnabled()) {	
deleting host guid 

}	if (s_logger.isDebugEnabled()) {	}	if (forceDestroyStorage) {	final StoragePoolVO storagePool = _storageMgr.findLocalStorageOnHost(host.getId());	if (storagePool != null) {	if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.ErrorInMaintenance) {	try {	final StoragePool pool = _storageSvr.preparePrimaryStorageForMaintenance(storagePool.getId());	if (pool == null) {	
failed to set primary storage into maintenance mode 

if (forceDestroyStorage) {	final StoragePoolVO storagePool = _storageMgr.findLocalStorageOnHost(host.getId());	if (storagePool != null) {	if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.ErrorInMaintenance) {	try {	final StoragePool pool = _storageSvr.preparePrimaryStorageForMaintenance(storagePool.getId());	if (pool == null) {	throw new UnableDeleteHostException("Failed to set primary storage into maintenance mode");	}	} catch (final Exception e) {	
failed to set primary storage into maintenance mode due to 

private boolean doCancelMaintenance(final long hostId) {	HostVO host;	host = _hostDao.findById(hostId);	if (host == null || host.getRemoved() != null) {	
unable to find host 

s_logger.warn("Unable to cancel migration because the vm is being migrated: " + vm + ", hostId = " + hostId);	vms_migrating = true;	}	}	try {	resourceStateTransitTo(host, ResourceState.Event.AdminCancelMaintenance, _nodeId);	_agentMgr.pullAgentOutMaintenance(hostId);	if ((host.getHypervisorType() == HypervisorType.KVM && !vms_migrating) || host.getHypervisorType() == HypervisorType.LXC) {	final boolean sshToAgent = Boolean.parseBoolean(_configDao.getValue(Config.KvmSshToAgentEnabled.key()));	if (!sshToAgent) {	
configuration tells us not to ssh into agents please restart the agent manually 

_agentMgr.pullAgentOutMaintenance(hostId);	if ((host.getHypervisorType() == HypervisorType.KVM && !vms_migrating) || host.getHypervisorType() == HypervisorType.LXC) {	final boolean sshToAgent = Boolean.parseBoolean(_configDao.getValue(Config.KvmSshToAgentEnabled.key()));	if (!sshToAgent) {	return true;	}	_hostDao.loadDetails(host);	final String password = host.getDetail("password");	final String username = host.getDetail("username");	if (password == null || username == null) {	
can t find password username 

return true;	}	_hostDao.loadDetails(host);	final String password = host.getDetail("password");	final String username = host.getDetail("username");	if (password == null || username == null) {	return false;	}	final com.trilead.ssh2.Connection connection = SSHCmdHelper.acquireAuthorizedConnection(host.getPrivateIpAddress(), 22, username, password);	if (connection == null) {	
failed to connect to host 

return false;	}	try {	SSHCmdHelper.sshExecuteCmdOneShot(connection, "service cloudstack-agent restart");	} catch (final SshException e) {	return false;	}	}	return true;	} catch (final NoTransitionException e) {	
cannot transmit host to enabled state 

private boolean doUmanageHost(final long hostId) {	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	
cannot find host assuming it has been deleted skip umanage 

public boolean updateClusterPassword(final UpdateHostPasswordCmd command) {	final boolean shouldUpdateHostPasswd = command.getUpdatePasswdOnHost();	final List<HostVO> hosts = listAllHostsInCluster(command.getClusterId());	for (final HostVO host : hosts) {	try {	final Boolean result = propagateResourceEvent(host.getId(), ResourceState.Event.UpdatePassword);	if (result != null) {	return result;	}	} catch (final AgentUnavailableException e) {	
agent is not availbale 

public boolean updateHostPassword(final UpdateHostPasswordCmd command) {	try {	final Boolean result = propagateResourceEvent(command.getHostId(), ResourceState.Event.UpdatePassword);	if (result != null) {	return result;	}	} catch (final AgentUnavailableException e) {	
agent is not availbale 

public Boolean propagateResourceEvent(final long agentId, final ResourceState.Event event) throws AgentUnavailableException {	final String msPeer = getPeerName(agentId);	if (msPeer == null) {	return null;	}	if (s_logger.isDebugEnabled()) {	
propagating agent change request event to agent 

if (s_logger.isDebugEnabled()) {	}	final Command[] cmds = new Command[1];	cmds[0] = new PropagateResourceEventCommand(agentId, event);	final String AnsStr = _clusterMgr.execute(msPeer, agentId, _gson.toJson(cmds), true);	if (AnsStr == null) {	throw new AgentUnavailableException(agentId);	}	final Answer[] answers = _gson.fromJson(AnsStr, Answer[].class);	if (s_logger.isDebugEnabled()) {	
result for agent change is 

public boolean maintenanceFailed(final long hostId) {	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	if (s_logger.isDebugEnabled()) {	
cant not find host 

public boolean maintenanceFailed(final long hostId) {	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	if (s_logger.isDebugEnabled()) {	}	return false;	} else {	try {	return resourceStateTransitTo(host, ResourceState.Event.UnableToMigrate, _nodeId);	} catch (final NoTransitionException e) {	
no next resource state for host while current state is with event 

public boolean isGPUDeviceAvailable(final long hostId, final String groupName, final String vgpuType) {	if(!listAvailableGPUDevice(hostId, groupName, vgpuType).isEmpty()) {	return true;	} else {	if (s_logger.isDebugEnabled()) {	
host id does not have gpu device available 

public boolean releaseHostReservation(final Long hostId) {	try {	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(final TransactionStatus status) {	final PlannerHostReservationVO reservationEntry = _plannerHostReserveDao.findByHostId(hostId);	if (reservationEntry != null) {	final long id = reservationEntry.getId();	final PlannerHostReservationVO hostReservation = _plannerHostReserveDao.lockRow(id, true);	if (hostReservation == null) {	if (s_logger.isDebugEnabled()) {	
host reservation for host does not even exist release reservartion call is ignored 

if (hostReservation == null) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	hostReservation.setResourceUsage(null);	_plannerHostReserveDao.persist(hostReservation);	return true;	}	if (s_logger.isDebugEnabled()) {	
host reservation for host does not even exist release reservartion call is ignored 

return true;	}	if (s_logger.isDebugEnabled()) {	}	return false;	}	});	} catch (final CloudRuntimeException e) {	throw e;	} catch (final Throwable t) {	
unable to release host reservation for host 

========================= cloudstack sample_2617 =========================

DataStore dataStore = dataObject.getDataStore();	if (dataStore.getRole() == DataStoreRole.Primary) {	Map<String, String> mapCapabilities = dataStore.getDriver().getCapabilities();	if (mapCapabilities == null) {	return false;	}	if (dataObject instanceof VolumeInfo || dataObject instanceof  SnapshotInfo) {	String value = mapCapabilities.get(DataStoreCapabilities.STORAGE_SYSTEM_SNAPSHOT.toString());	Boolean supportsStorageSystemSnapshots = Boolean.valueOf(value);	if (supportsStorageSystemSnapshots) {	
using storagesystemdatamotionstrategy dataobject is a volume or snapshot and the storage system supports snapshots 

if (dataObject instanceof VolumeInfo || dataObject instanceof  SnapshotInfo) {	String value = mapCapabilities.get(DataStoreCapabilities.STORAGE_SYSTEM_SNAPSHOT.toString());	Boolean supportsStorageSystemSnapshots = Boolean.valueOf(value);	if (supportsStorageSystemSnapshots) {	return true;	}	} else if (dataObject instanceof TemplateInfo) {	String value = mapCapabilities.get(DataStoreCapabilities.CAN_CREATE_VOLUME_FROM_VOLUME.toString());	Boolean canCloneVolume = Boolean.valueOf(value);	if (canCloneVolume) {	
using storagesystemdatamotionstrategy dataobject is a template and the storage system can create a volume from a volume 

}	try {	if (StringUtils.isEmpty(errMsg)) {	snapshotInfo.processEvent(Event.OperationSuccessed);	}	else {	snapshotInfo.processEvent(Event.OperationFailed);	}	}	catch (Exception ex) {	
error processing snapshot event 

}	try {	VolumeDetailVO volumeDetail = new VolumeDetailVO(volumeInfo.getId(), "cloneOfTemplate", String.valueOf(templateInfo.getId()), false);	volumeDetail = volumeDetailsDao.persist(volumeDetail);	AsyncCallFuture<VolumeApiResult> future = _volumeService.createVolumeAsync(volumeInfo, volumeInfo.getDataStore());	VolumeApiResult result = future.get();	if (volumeDetail != null) {	volumeDetailsDao.remove(volumeDetail.getId());	}	if (result.isFailed()) {	
failed to create a volume 

}	DiskOfferingVO diskOffering = _diskOfferingDao.findByIdIncludingRemoved(volumeInfo.getDiskOfferingId());	SnapshotVO snapshot = _snapshotDao.findById(snapshotInfo.getId());	_volumeService.updateHypervisorSnapshotReserveForVolume(diskOffering, volumeInfo.getId(), snapshot.getHypervisorType());	AsyncCallFuture<VolumeApiResult> future = _volumeService.createVolumeAsync(volumeInfo, volumeInfo.getDataStore());	VolumeApiResult result = future.get();	if (volumeDetail != null) {	volumeDetailsDao.remove(volumeDetail.getId());	}	if (result.isFailed()) {	
failed to create a volume 

========================= cloudstack sample_3905 =========================

public void pushBack(ByteBuffer buf) {	
info buffer pushed back 

public void sendData(ByteBuffer buf) {	if (!hold && pullMode) throw new RuntimeException("[" + this + "] ERROR: link is not in push mode.");	
info incoming buffer 

if (!hold && pullMode) throw new RuntimeException("[" + this + "] ERROR: link is not in push mode.");	if (buf == null && cacheBuffer == null) return;	if (cacheBuffer != null && buf != null) {	buf = cacheBuffer.join(buf);	cacheBuffer.unref();	cacheBuffer = buf;	}	if (buf != null) cacheBuffer = buf;	while (cacheBuffer != null) {	if (paused || hold) {	
info transfer is paused data in cache buffer 

buf = cacheBuffer.join(buf);	cacheBuffer.unref();	cacheBuffer = buf;	}	if (buf != null) cacheBuffer = buf;	while (cacheBuffer != null) {	if (paused || hold) {	return;	}	if (expectedPacketSize > 0 && cacheBuffer.length < expectedPacketSize) {	
info transfer is suspended because available data is less than expected packet size expected packet size data in cache buffer 

public void sendEvent(Event event, Direction direction) {	
info event is received 

public ByteBuffer pull(boolean block) {	if (!pullMode) throw new RuntimeException("[" + this + "] ERROR: This link is not in pull mode.");	if (hold) throw new RuntimeException("[" + this + "] ERROR: This link is already on hold, waiting for data to be pulled in. Circular reference?");	if (paused) {	
info cannot pull link is paused 

public ByteBuffer pull(boolean block) {	if (!pullMode) throw new RuntimeException("[" + this + "] ERROR: This link is not in pull mode.");	if (hold) throw new RuntimeException("[" + this + "] ERROR: This link is already on hold, waiting for data to be pulled in. Circular reference?");	if (paused) {	if (block) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	
ignored interupted during pull 

if (paused) {	if (block) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	}	}	return null;	}	if (cacheBuffer != null && (expectedPacketSize == 0 || (expectedPacketSize > 0 && cacheBuffer.length >= expectedPacketSize))) {	
info data pulled from cache buffer 

cacheBuffer = null;	return tmp;	}	try {	hold = true;	source.poll(block);	} finally {	hold = false;	}	if (cacheBuffer != null && (expectedPacketSize == 0 || (expectedPacketSize > 0 && cacheBuffer.length >= expectedPacketSize))) {	
info data pulled from source 

public void run() {	while (!started) {	delay();	}	sendEvent(Event.LINK_SWITCH_TO_PULL_MODE, Direction.IN);	
info starting pull loop 

delay();	}	sendEvent(Event.LINK_SWITCH_TO_PULL_MODE, Direction.IN);	while (!shutdown) {	ByteBuffer data = pull(false);	if (data != null) sink.handleData(data, this);	if (!shutdown && data == null) {	delay();	}	}	
info pull loop finished 

public void setPullMode() {	
info switching to pull mode 

========================= cloudstack sample_5078 =========================

ruleData.setTags(tagResponse);	if (vsg.getRuleType() == SecurityRuleType.IngressRule) {	ruleData.setObjectName("ingressrule");	sgResponse.addSecurityGroupIngressRule(ruleData);	} else {	ruleData.setObjectName("egressrule");	sgResponse.addSecurityGroupEgressRule(ruleData);	}	}	List<SecurityGroupVMMapVO> securityGroupVmMap = _securityGroupVMMapDao.listBySecurityGroup(vsg.getId());	
newsecuritygroupresponse virtualmachine count 

========================= cloudstack sample_2569 =========================

HostVO host = null;	TransactionLegacy txn = TransactionLegacy.currentTxn();	try(PreparedStatement pstmt = txn.prepareStatement(sql);) {	pstmt.setLong(1, poolId);	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	host = hostDao.findById(id);	}	}catch (SQLException e) {	
can t find endpoint 

try(PreparedStatement pstmt = txn.prepareStatement(sql);) {	pstmt.setLong(1, poolId);	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	host = hostDao.findById(id);	}	}catch (SQLException e) {	}	} catch (SQLException e) {	
can t find endpoint 

String publicIp = uri.getHost();	if(scheme.equalsIgnoreCase("https")){	publicIp = publicIp.split("\\.")[0];	publicIp = publicIp.replace("-",".");	}	host = hostDao.findByPublicIp(publicIp);	if(host != null){	return RemoteHostEndPoint.getHypervisorHostEndPoint(host);	}	} catch (URISyntaxException e) {	
received urisyntaxexception for url 

if(scheme.equalsIgnoreCase("https")){	publicIp = publicIp.split("\\.")[0];	publicIp = publicIp.replace("-",".");	}	host = hostDao.findByPublicIp(publicIp);	if(host != null){	return RemoteHostEndPoint.getHypervisorHostEndPoint(host);	}	} catch (URISyntaxException e) {	}	
coudn t find ssvm for url 

========================= cloudstack sample_4002 =========================

final KVMPhysicalDisk snapshotDisk = primaryPool.getPhysicalDisk(command.getVolumePath());	final String manageSnapshotPath = libvirtComputingResource.manageSnapshotPath();	final int cmdsTimeout = libvirtComputingResource.getCmdsTimeout();	if (primaryPool.getType() == StoragePoolType.RBD) {	try {	final Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	final IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	final Rbd rbd = new Rbd(io);	final RbdImage image = rbd.open(snapshotDisk.getName(), snapshotName);	final File fh = new File(snapshotDestPath);	try(BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fh));) {	final int chunkSize = 4194304;	long offset = 0;	
backuping up rbd snapshot to 

long offset = 0;	while (true) {	final byte[] buf = new byte[chunkSize];	final int bytes = image.read(offset, buf, chunkSize);	if (bytes <= 0) {	break;	}	bos.write(buf, 0, bytes);	offset += bytes;	}	
completed backing up rbd snapshot to bytes written 

while (true) {	final byte[] buf = new byte[chunkSize];	final int bytes = image.read(offset, buf, chunkSize);	if (bytes <= 0) {	break;	}	bos.write(buf, 0, bytes);	offset += bytes;	}	}catch(final IOException ex) {	
backupsnapshotanswer exception 

if (bytes <= 0) {	break;	}	bos.write(buf, 0, bytes);	offset += bytes;	}	}catch(final IOException ex) {	}	r.ioCtxDestroy(io);	} catch (final RadosException e) {	
a rados operation failed the error was 

}	bos.write(buf, 0, bytes);	offset += bytes;	}	}catch(final IOException ex) {	}	r.ioCtxDestroy(io);	} catch (final RadosException e) {	return new BackupSnapshotAnswer(command, false, e.toString(), null, true);	} catch (final RbdException e) {	
a rbd operation on failed the error was 

return new BackupSnapshotAnswer(command, false, e.toString(), null, true);	}	} else {	final Script scriptCommand = new Script(manageSnapshotPath, cmdsTimeout, s_logger);	scriptCommand.add("-b", snapshotDisk.getPath());	scriptCommand.add("-n", snapshotName);	scriptCommand.add("-p", snapshotDestPath);	scriptCommand.add("-t", snapshotName);	final String result = scriptCommand.execute();	if (result != null) {	
failed to backup snaptshot 

return new BackupSnapshotAnswer(command, false, result, null, true);	}	}	DomainState state = null;	Domain vm = null;	if (vmName != null) {	try {	vm = libvirtComputingResource.getDomain(conn, command.getVmName());	state = vm.getInfo().state;	} catch (final LibvirtException e) {	
ignoring libvirt error 

state = vm.getInfo().state;	if (state == DomainState.VIR_DOMAIN_PAUSED) {	vm.resume();	}	} else {	final Script scriptCommand = new Script(manageSnapshotPath, cmdsTimeout, s_logger);	scriptCommand.add("-d", snapshotDisk.getPath());	scriptCommand.add("-n", snapshotName);	final String result = scriptCommand.execute();	if (result != null) {	
failed to backup snapshot 

========================= cloudstack sample_1083 =========================

PreparedStatement stmtInsert = txn.prepareAutoCloseStatement(pstmt);	int argIndex = 1;	for (Long vmId : vmIds) {	stmtInsert.setLong(argIndex++, vmId);	}	numUpdated = stmtInsert.executeUpdate();	i = maxTries;	} catch (SQLTransactionRollbackException e1) {	if (i < maxTries - 1) {	int delayMs = (i + 1) * 1000;	
caught a deadlock exception while inserting security group rule log retrying in 

stmtInsert.setLong(argIndex++, vmId);	}	numUpdated = stmtInsert.executeUpdate();	i = maxTries;	} catch (SQLTransactionRollbackException e1) {	if (i < maxTries - 1) {	int delayMs = (i + 1) * 1000;	try {	Thread.sleep(delayMs);	} catch (InterruptedException ie) {	
ignored interupted while inserting security group rule log 

}	numUpdated = stmtInsert.executeUpdate();	i = maxTries;	} catch (SQLTransactionRollbackException e1) {	if (i < maxTries - 1) {	int delayMs = (i + 1) * 1000;	try {	Thread.sleep(delayMs);	} catch (InterruptedException ie) {	}	
caught another deadlock exception while retrying inserting security group rule log giving up 

} catch (SQLTransactionRollbackException e1) {	if (i < maxTries - 1) {	int delayMs = (i + 1) * 1000;	try {	Thread.sleep(delayMs);	} catch (InterruptedException ie) {	}	}	}	if (s_logger.isTraceEnabled()) {	
inserted or updated rows 

if (numStmts > 0) {	String pstmt = cachedPrepStmtStrings.get(stmtSize);	for (int i = 0; i < numStmts; i++) {	List<Long> vmIds = new ArrayList<Long>();	for (int argIndex = 1; argIndex <= stmtSize; argIndex++) {	Long vmId = workIter.next();	vmIds.add(vmId);	}	int numUpdated = executeWithRetryOnDeadlock(txn, pstmt, vmIds);	if (s_logger.isTraceEnabled()) {	
inserted or updated rows 

}	int numUpdated = executeWithRetryOnDeadlock(txn, pstmt, vmIds);	if (s_logger.isTraceEnabled()) {	}	if (numUpdated > 0) count += stmtSize;	}	remaining = remaining - numStmts * stmtSize;	}	}	} catch (SQLException sqe) {	
failed to execute multi insert 

stmtInsert.setLong(1, vmId);	stmtInsert.addBatch();	count++;	if (count % 16 == 0) {	queryResult = stmtInsert.executeBatch();	stmtInsert.clearBatch();	}	}	queryResult = stmtInsert.executeBatch();	txn.commit();	
updated or inserted log items 

stmtInsert.addBatch();	count++;	if (count % 16 == 0) {	queryResult = stmtInsert.executeBatch();	stmtInsert.clearBatch();	}	}	queryResult = stmtInsert.executeBatch();	txn.commit();	} catch (SQLException e) {	
failed to execute batch update statement for ruleset log 

txn.commit();	} catch (SQLException e) {	txn.rollback();	success = false;	}	if (!success && queryResult != null) {	Long[] arrayItems = new Long[workItems.size()];	workItems.toArray(arrayItems);	for (int i = 0; i < queryResult.length; i++) {	if (queryResult[i] < 0) {	
batch query update failed for vm 

========================= cloudstack sample_4281 =========================

public void updateExternalLoadBalancerNetworkUsageStats(long loadBalancerRuleId) {	LoadBalancerVO lb = _loadBalancerDao.findById(loadBalancerRuleId);	if (lb == null) {	if (s_logger.isDebugEnabled()) {	
cannot update usage stats lb rule is not found 

LoadBalancerVO lb = _loadBalancerDao.findById(loadBalancerRuleId);	if (lb == null) {	if (s_logger.isDebugEnabled()) {	}	return;	}	long networkId = lb.getNetworkId();	Network network = _networkDao.findById(networkId);	if (network == null) {	if (s_logger.isDebugEnabled()) {	
cannot update usage stats network is not found 

long networkId = lb.getNetworkId();	Network network = _networkDao.findById(networkId);	if (network == null) {	if (s_logger.isDebugEnabled()) {	}	return;	}	ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);	if (lbDeviceVO == null) {	if (s_logger.isDebugEnabled()) {	
cannot update usage stats no external lb device found 

if (lbAnswer == null || !lbAnswer.getResult()) {	String details = (lbAnswer != null) ? lbAnswer.getDetails() : "details unavailable";	String msg = "Unable to get external load balancer stats for network" + networkId + " due to: " + details + ".";	s_logger.error(msg);	return;	}	}	long accountId = lb.getAccountId();	AccountVO account = _accountDao.findById(accountId);	if (account == null) {	
skipping stats update for external lb for account with id 

String loadBalancingIpAddress = nic.getIPv4Address();	bytesSentAndReceived = lbAnswer.ipBytes.get(loadBalancingIpAddress);	if (bytesSentAndReceived != null) {	bytesSentAndReceived[0] = 0;	}	}	} else {	bytesSentAndReceived = lbAnswer.ipBytes.get(publicIp);	}	if (bytesSentAndReceived == null) {	
didn t get an external network usage answer for public ip 

UserStatisticsVO userStats;	userStats = _userStatsDao.lock(accountId, zone.getId(), networkId, publicIp, externalLoadBalancer.getId(), externalLoadBalancer.getType().toString());	if (userStats != null) {	long oldNetBytesSent = userStats.getNetBytesSent();	long oldNetBytesReceived = userStats.getNetBytesReceived();	long oldCurrentBytesSent = userStats.getCurrentBytesSent();	long oldCurrentBytesReceived = userStats.getCurrentBytesReceived();	String warning = "Received an external network stats byte count that was less than the stored value. Zone ID: " + userStats.getDataCenterId() + ", account ID: " + userStats.getAccountId() + ".";	userStats.setCurrentBytesSent(newCurrentBytesSent);	if (oldCurrentBytesSent > newCurrentBytesSent) {	
stored bytes sent new bytes sent 

long oldNetBytesReceived = userStats.getNetBytesReceived();	long oldCurrentBytesSent = userStats.getCurrentBytesSent();	long oldCurrentBytesReceived = userStats.getCurrentBytesReceived();	String warning = "Received an external network stats byte count that was less than the stored value. Zone ID: " + userStats.getDataCenterId() + ", account ID: " + userStats.getAccountId() + ".";	userStats.setCurrentBytesSent(newCurrentBytesSent);	if (oldCurrentBytesSent > newCurrentBytesSent) {	userStats.setNetBytesSent(oldNetBytesSent + oldCurrentBytesSent);	}	userStats.setCurrentBytesReceived(newCurrentBytesReceived);	if (oldCurrentBytesReceived > newCurrentBytesReceived) {	
stored bytes received new bytes received 

String warning = "Received an external network stats byte count that was less than the stored value. Zone ID: " + userStats.getDataCenterId() + ", account ID: " + userStats.getAccountId() + ".";	userStats.setCurrentBytesSent(newCurrentBytesSent);	if (oldCurrentBytesSent > newCurrentBytesSent) {	userStats.setNetBytesSent(oldNetBytesSent + oldCurrentBytesSent);	}	userStats.setCurrentBytesReceived(newCurrentBytesReceived);	if (oldCurrentBytesReceived > newCurrentBytesReceived) {	userStats.setNetBytesReceived(oldNetBytesReceived + oldCurrentBytesReceived);	}	if (_userStatsDao.update(userStats.getId(), userStats)) {	
successfully updated stats for 

userStats.setCurrentBytesSent(newCurrentBytesSent);	if (oldCurrentBytesSent > newCurrentBytesSent) {	userStats.setNetBytesSent(oldNetBytesSent + oldCurrentBytesSent);	}	userStats.setCurrentBytesReceived(newCurrentBytesReceived);	if (oldCurrentBytesReceived > newCurrentBytesReceived) {	userStats.setNetBytesReceived(oldNetBytesReceived + oldCurrentBytesReceived);	}	if (_userStatsDao.update(userStats.getId(), userStats)) {	} else {	
failed to update stats for 

userStats.setNetBytesSent(oldNetBytesSent + oldCurrentBytesSent);	}	userStats.setCurrentBytesReceived(newCurrentBytesReceived);	if (oldCurrentBytesReceived > newCurrentBytesReceived) {	userStats.setNetBytesReceived(oldNetBytesReceived + oldCurrentBytesReceived);	}	if (_userStatsDao.update(userStats.getId(), userStats)) {	} else {	}	} else {	
unable to find user stats entry for 

protected void runInContext() {	if(_hostDao.listByType(Host.Type.ExternalFirewall).isEmpty() && _hostDao.listByType(Host.Type.ExternalLoadBalancer).isEmpty()){	
external devices are not used skipping external device usage collection 

GlobalLock scanLock = GlobalLock.getInternLock("ExternalDeviceNetworkUsageManagerImpl");	try {	if (scanLock.lock(20)) {	try {	runExternalDeviceNetworkUsageTask();	} finally {	scanLock.unlock();	}	}	} catch (Exception e) {	
problems while getting external device usage 

protected void runExternalDeviceNetworkUsageTask() {	
external devices stats collector is running 

if (domainRoutersInZone == null) {	continue;	}	Map<Long, ExternalNetworkResourceUsageAnswer> lbDeviceUsageAnswerMap = new HashMap<Long, ExternalNetworkResourceUsageAnswer>();	Map<Long, ExternalNetworkResourceUsageAnswer> fwDeviceUsageAnswerMap = new HashMap<Long, ExternalNetworkResourceUsageAnswer>();	List<Long> accountsProcessed = new ArrayList<Long>();	for (DomainRouterVO domainRouter : domainRoutersInZone) {	long accountId = domainRouter.getAccountId();	if (accountsProcessed.contains(new Long(accountId))) {	if (s_logger.isTraceEnabled()) {	
networks for account are already processed for external network usage so skipping usage check 

}	continue;	}	long zoneId = zone.getId();	List<NetworkVO> networksForAccount = _networkDao.listByZoneAndGuestType(accountId, zoneId, Network.GuestType.Isolated, false);	if (networksForAccount == null) {	continue;	}	for (NetworkVO network : networksForAccount) {	if (!_networkModel.networkIsConfiguredForExternalNetworking(zoneId, network.getId())) {	
network is not configured for external networking so skipping usage check 

s_logger.error(msg);	} else {	fwDeviceUsageAnswerMap.put(fwDeviceId, firewallAnswer);	}	} catch (Exception e) {	String msg = "Unable to get external firewall stats for network" + zone.getName();	s_logger.error(msg, e);	}	} else {	if (s_logger.isTraceEnabled()) {	
reusing usage answer for device id for network 

s_logger.error(msg);	} else {	lbDeviceUsageAnswerMap.put(lbDeviceId, lbAnswer);	}	} catch (Exception e) {	String msg = "Unable to get external load balancer stats for " + zone.getName();	s_logger.error(msg, e);	}	} else {	if (s_logger.isTraceEnabled()) {	
reusing usage answer for device id for network 

}	lbAnswer = lbDeviceUsageAnswerMap.get(lbDeviceId);	}	}	}	if (firewallAnswer == null && lbAnswer == null) {	continue;	}	AccountVO account = _accountDao.findById(accountId);	if (account == null) {	
skipping stats update for account with id 

private boolean updateBytes(UserStatisticsVO userStats, long newCurrentBytesSent, long newCurrentBytesReceived) {	long oldNetBytesSent = userStats.getNetBytesSent();	long oldNetBytesReceived = userStats.getNetBytesReceived();	long oldCurrentBytesSent = userStats.getCurrentBytesSent();	long oldCurrentBytesReceived = userStats.getCurrentBytesReceived();	String warning = "Received an external network stats byte count that was less than the stored value. Zone ID: " + userStats.getDataCenterId() + ", account ID: " + userStats.getAccountId() + ".";	userStats.setCurrentBytesSent(newCurrentBytesSent);	if (oldCurrentBytesSent > newCurrentBytesSent) {	
stored bytes sent new bytes sent 

long oldNetBytesReceived = userStats.getNetBytesReceived();	long oldCurrentBytesSent = userStats.getCurrentBytesSent();	long oldCurrentBytesReceived = userStats.getCurrentBytesReceived();	String warning = "Received an external network stats byte count that was less than the stored value. Zone ID: " + userStats.getDataCenterId() + ", account ID: " + userStats.getAccountId() + ".";	userStats.setCurrentBytesSent(newCurrentBytesSent);	if (oldCurrentBytesSent > newCurrentBytesSent) {	userStats.setNetBytesSent(oldNetBytesSent + oldCurrentBytesSent);	}	userStats.setCurrentBytesReceived(newCurrentBytesReceived);	if (oldCurrentBytesReceived > newCurrentBytesReceived) {	
stored bytes received new bytes received 

String loadBalancingIpAddress = nic.getIPv4Address();	bytesSentAndReceived = answer.ipBytes.get(loadBalancingIpAddress);	if (bytesSentAndReceived != null) {	bytesSentAndReceived[0] = 0;	}	}	} else {	bytesSentAndReceived = answer.ipBytes.get(publicIp);	}	if (bytesSentAndReceived == null) {	
didn t get an external network usage answer for public ip 

bytesSentAndReceived = answer.ipBytes.get(publicIp);	}	if (bytesSentAndReceived == null) {	} else {	newCurrentBytesSent += bytesSentAndReceived[0];	newCurrentBytesReceived += bytesSentAndReceived[1];	}	} else {	URI broadcastURI = network.getBroadcastUri();	if (broadcastURI == null) {	
not updating stats for guest network with id because the network is not implemented 

newCurrentBytesReceived += bytesSentAndReceived[1];	}	} else {	URI broadcastURI = network.getBroadcastUri();	if (broadcastURI == null) {	return true;	} else {	long vlanTag = Integer.parseInt(BroadcastDomainType.getValue(broadcastURI));	long[] bytesSentAndReceived = answer.guestVlanBytes.get(String.valueOf(vlanTag));	if (bytesSentAndReceived == null) {	
didn t get an external network usage answer for guest vlan 

} else {	newCurrentBytesSent += bytesSentAndReceived[0];	newCurrentBytesReceived += bytesSentAndReceived[1];	}	}	}	UserStatisticsVO userStats;	try {	userStats = _userStatsDao.lock(accountId, zoneId, networkId, publicIp, hostId, host.getType().toString());	} catch (Exception e) {	
unable to find user stats entry for 

}	}	}	UserStatisticsVO userStats;	try {	userStats = _userStatsDao.lock(accountId, zoneId, networkId, publicIp, hostId, host.getType().toString());	} catch (Exception e) {	return false;	}	if (updateBytes(userStats, newCurrentBytesSent, newCurrentBytesReceived)) {	
successfully updated stats for 

}	UserStatisticsVO userStats;	try {	userStats = _userStatsDao.lock(accountId, zoneId, networkId, publicIp, hostId, host.getType().toString());	} catch (Exception e) {	return false;	}	if (updateBytes(userStats, newCurrentBytesSent, newCurrentBytesReceived)) {	return true;	} else {	
failed to update stats for 

String publicIp = _networkModel.getIp(loadBalancer.getSourceIpAddressId()).getAddress().addr();	if (!createOrUpdateStatsEntry(create, accountId, zoneId, network.getId(), publicIp, externalLoadBalancer.getId(), lbAnswer, inline)) {	throw new CloudRuntimeException(networkErrorMsg + ", load balancing rule public IP = " + publicIp);	}	}	}	}	});	return true;	} catch (Exception e) {	
exception 

========================= cloudstack sample_2355 =========================

private void updateUserStats(Connection conn) {	try ( PreparedStatement pstmt = conn.prepareStatement( "update cloud_usage.user_statistics uus, cloud.user_statistics us set uus.network_id = us.network_id where uus.id = us.id" );	) {	pstmt.executeUpdate();	
upgraded cloud usage user statistics with networkid 

private void updateUserStats(Connection conn) {	try ( PreparedStatement pstmt = conn.prepareStatement( "update cloud_usage.user_statistics uus, cloud.user_statistics us set uus.network_id = us.network_id where uus.id = us.id" );	) {	pstmt.executeUpdate();	} catch (Exception e) {	throw new CloudRuntimeException("Failed to upgrade user stats: ", e);	}	try ( PreparedStatement pstmt1 = conn.prepareStatement("update cloud_usage.usage_network un, cloud_usage.user_statistics us set un.network_id = " + "us.network_id where us.account_id = un.account_id and us.data_center_id = un.zone_id and us.device_id = un.host_id");	) {	pstmt1.executeUpdate();	
upgraded cloud usage usage network with networkid 

========================= cloudstack sample_4219 =========================

public void run() {	try {	Answer answer = agentMgr.send(hostId, cmd);	callback.complete(answer);	} catch (Throwable e) {	
send command failed 

========================= cloudstack sample_3925 =========================

if (httpClient != null) {	try {	httpClient.getConnectionManager().shutdown();	} catch (Exception t) {	logger.debug(t.getMessage());	}	}	}	String responseString = sb.toString();	if (logger.isDebugEnabled()) {	
nexentastor appliance response 

========================= cloudstack sample_1918 =========================

public void clearAlert(AlertType alertType, long dataCenterId, long podId) {	try {	if (_emailAlert != null) {	_emailAlert.clearAlert(alertType.getType(), dataCenterId, podId);	}	} catch (Exception ex) {	
problem clearing email alert 

public void sendAlert(AlertType alertType, long dataCenterId, Long podId, String subject, String body) {	AlertGenerator.publishAlertOnEventBus(alertType.getName(), dataCenterId, podId, subject, body);	try {	if (_emailAlert != null) {	_emailAlert.sendAlert(alertType, dataCenterId, podId, null, subject, body);	} else {	
alerttype 

public void sendAlert(AlertType alertType, long dataCenterId, Long podId, String subject, String body) {	AlertGenerator.publishAlertOnEventBus(alertType.getName(), dataCenterId, podId, subject, body);	try {	if (_emailAlert != null) {	_emailAlert.sendAlert(alertType, dataCenterId, podId, null, subject, body);	} else {	} catch (Exception ex) {	
problem sending email alert 

public void recalculateCapacity() {	try {	if (s_logger.isDebugEnabled()) {	
recalculating system capacity 

public void recalculateCapacity() {	try {	if (s_logger.isDebugEnabled()) {	
executing cpu ram capacity update 

try {	if (s_logger.isDebugEnabled()) {	}	List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);	if (hosts != null) {	for (HostVO host : hosts) {	_capacityMgr.updateCapacityForHost(host);	}	}	if (s_logger.isDebugEnabled()) {	
done executing cpu ram capacity update 

try {	if (s_logger.isDebugEnabled()) {	}	List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);	if (hosts != null) {	for (HostVO host : hosts) {	_capacityMgr.updateCapacityForHost(host);	}	}	if (s_logger.isDebugEnabled()) {	
executing storage capacity update 

List<StoragePoolVO> storagePools = _storagePoolDao.listAll();	for (StoragePoolVO pool : storagePools) {	long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);	if (pool.isShared()) {	_storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);	} else {	_storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);	}	}	if (s_logger.isDebugEnabled()) {	
done executing storage capacity update 

List<StoragePoolVO> storagePools = _storagePoolDao.listAll();	for (StoragePoolVO pool : storagePools) {	long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);	if (pool.isShared()) {	_storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);	} else {	_storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);	}	}	if (s_logger.isDebugEnabled()) {	
executing capacity updates for public ip and vlans 

long dcId = datacenter.getId();	if (datacenter.getNetworkType() == NetworkType.Advanced) {	createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());	}	createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());	if (datacenter.getNetworkType() == NetworkType.Advanced) {	createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());	}	}	if (s_logger.isDebugEnabled()) {	
done capacity updates for public ip and vlans 

long dcId = datacenter.getId();	if (datacenter.getNetworkType() == NetworkType.Advanced) {	createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());	}	createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());	if (datacenter.getNetworkType() == NetworkType.Advanced) {	createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());	}	}	if (s_logger.isDebugEnabled()) {	
executing capacity updates for private ip 

}	if (s_logger.isDebugEnabled()) {	}	List<HostPodVO> pods = _podDao.listAll();	for (HostPodVO pod : pods) {	long podId = pod.getId();	long dcId = pod.getDataCenterId();	createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));	}	if (s_logger.isDebugEnabled()) {	
done executing capacity updates for private ip 

}	if (s_logger.isDebugEnabled()) {	}	List<HostPodVO> pods = _podDao.listAll();	for (HostPodVO pod : pods) {	long podId = pod.getId();	long dcId = pod.getDataCenterId();	createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));	}	if (s_logger.isDebugEnabled()) {	
done recalculating system capacity 

}	List<HostPodVO> pods = _podDao.listAll();	for (HostPodVO pod : pods) {	long podId = pod.getId();	long dcId = pod.getDataCenterId();	createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));	}	if (s_logger.isDebugEnabled()) {	}	} catch (Throwable t) {	
caught exception in recalculating capacity 

protected void runInContext() {	try {	
running capacity checker 

protected void runInContext() {	try {	checkForAlerts();	
done running capacity checker 

protected void runInContext() {	try {	checkForAlerts();	} catch (Throwable t) {	
exception in capacitychecker 

alertType = AlertManager.AlertType.ALERT_TYPE_VLAN;	break;	}	try {	if (s_logger.isDebugEnabled()) {	s_logger.debug(msgSubject);	s_logger.debug(msgContent);	}	_emailAlert.sendAlert(alertType, dc.getId(), podId, clusterId, msgSubject, msgContent);	} catch (Exception ex) {	
exception in capacitychecker 

public EmailAlert(String[] recipientList, String smtpHost, int smtpPort, int smtpConnectionTimeout, int smtpTimeout, boolean smtpUseAuth, final String smtpUsername, final String smtpPassword, String emailSender, boolean smtpDebug) {	if (recipientList != null) {	_recipientList = new InternetAddress[recipientList.length];	for (int i = 0; i < recipientList.length; i++) {	try {	_recipientList[i] = new InternetAddress(recipientList[i], recipientList[i]);	} catch (Exception ex) {	
exception creating address for 

newAlert.setSubject(subject);	newAlert.setClusterId(clusterId);	newAlert.setPodId(podId);	newAlert.setDataCenterId(dataCenterId);	newAlert.setSentCount(1);	newAlert.setLastSent(new Date());	newAlert.setName(alertType.getName());	_alertDao.persist(newAlert);	} else {	if (s_logger.isDebugEnabled()) {	
have already sent emails for alert type skipping send email 

private void sendMessage(final SMTPTransport smtpTrans, final SMTPMessage msg) {	_executor.execute(new Runnable() {	public void run() {	try {	smtpTrans.connect();	smtpTrans.sendMessage(msg, msg.getAllRecipients());	smtpTrans.close();	} catch (SendFailedException e) {	
failed to send email alert 

private void sendMessage(final SMTPTransport smtpTrans, final SMTPMessage msg) {	_executor.execute(new Runnable() {	public void run() {	try {	smtpTrans.connect();	smtpTrans.sendMessage(msg, msg.getAllRecipients());	smtpTrans.close();	} catch (SendFailedException e) {	} catch (MessagingException e) {	
failed to send email alert 

========================= cloudstack sample_2267 =========================

protected void startContexts() {	withModule(new WithModule() {	public void with(ModuleDefinition def, Stack<ModuleDefinition> parents) {	try {	ApplicationContext context = getApplicationContext(def.getName());	try {	Runnable runnable = context.getBean("moduleStartup", Runnable.class);	
starting module 

protected ApplicationContext loadContext(ModuleDefinition def, ApplicationContext parent) {	ResourceApplicationContext context = new ResourceApplicationContext();	context.setApplicationName("/" + def.getName());	Resource[] resources = getConfigResources(def.getName());	context.setConfigResources(resources);	context.setParent(parent);	context.setClassLoader(def.getClassLoader());	long start = System.currentTimeMillis();	if (log.isInfoEnabled()) {	for (Resource resource : resources) {	
loading module context from 

Resource[] resources = getConfigResources(def.getName());	context.setConfigResources(resources);	context.setParent(parent);	context.setClassLoader(def.getClassLoader());	long start = System.currentTimeMillis();	if (log.isInfoEnabled()) {	for (Resource resource : resources) {	}	}	context.refresh();	
loaded module context in ms 

protected void printHierarchy() {	withModule(new WithModule() {	public void with(ModuleDefinition def, Stack<ModuleDefinition> parents) {	
module hierarchy s s 

protected void withModule(ModuleDefinition def, Stack<ModuleDefinition> parents, WithModule with) {	if (def == null) return;	if (!shouldLoad(def)) {	
excluding context based on configuration 

========================= cloudstack sample_740 =========================

NamingEnumeration<SearchResult> result = context.search(_ldapConfiguration.getBaseDn(), generateGroupSearchFilter(groupName), controls);	final List<LdapUser> users = new ArrayList<LdapUser>();	if (result.hasMoreElements()) {	Attribute attribute = result.nextElement().getAttributes().get(attributeName);	NamingEnumeration<?> values = attribute.getAll();	while (values.hasMoreElements()) {	String userdn = String.valueOf(values.nextElement());	try{	users.add(getUserForDn(userdn, context));	} catch (NamingException e){	
userdn not found exception message 

}	Control[] contextControls = context.getResponseControls();	if (contextControls != null) {	for (Control control : contextControls) {	if (control instanceof PagedResultsResponseControl) {	PagedResultsResponseControl prrc = (PagedResultsResponseControl) control;	cookie = prrc.getCookie();	}	}	} else {	
no controls were sent from the ldap server 

========================= cloudstack sample_1332 =========================

public boolean isFrontEndAlive() {	if (workerDone || System.currentTimeMillis() - getClientLastFrontEndActivityTime() > ConsoleProxy.VIEWER_LINGER_SECONDS * 1000) {	
front end has been idle for too long 

public void initClient(ConsoleProxyClientParam param) {	setClientParam(param);	client = new VncClient(this);	worker = new Thread(new Runnable() {	public void run() {	String tunnelUrl = getClientParam().getClientTunnelUrl();	String tunnelSession = getClientParam().getClientTunnelSession();	try {	if (tunnelUrl != null && !tunnelUrl.isEmpty() && tunnelSession != null && !tunnelSession.isEmpty()) {	URI uri = new URI(tunnelUrl);	
connect to vnc server via tunnel url session 

worker = new Thread(new Runnable() {	public void run() {	String tunnelUrl = getClientParam().getClientTunnelUrl();	String tunnelSession = getClientParam().getClientTunnelSession();	try {	if (tunnelUrl != null && !tunnelUrl.isEmpty() && tunnelSession != null && !tunnelSession.isEmpty()) {	URI uri = new URI(tunnelUrl);	ConsoleProxy.ensureRoute(uri.getHost());	client.connectTo( uri.getHost(), uri.getPort(), uri.getPath() + "?" + uri.getQuery(), tunnelSession, "https".equalsIgnoreCase(uri.getScheme()), getClientHostPassword());	} else {	
connect to vnc server directly host port 

try {	if (tunnelUrl != null && !tunnelUrl.isEmpty() && tunnelSession != null && !tunnelSession.isEmpty()) {	URI uri = new URI(tunnelUrl);	ConsoleProxy.ensureRoute(uri.getHost());	client.connectTo( uri.getHost(), uri.getPort(), uri.getPath() + "?" + uri.getQuery(), tunnelSession, "https".equalsIgnoreCase(uri.getScheme()), getClientHostPassword());	} else {	ConsoleProxy.ensureRoute(getClientHostAddress());	client.connectTo(getClientHostAddress(), getClientHostPort(), getClientHostPassword());	}	} catch (UnknownHostException e) {	
unexpected exception 

if (tunnelUrl != null && !tunnelUrl.isEmpty() && tunnelSession != null && !tunnelSession.isEmpty()) {	URI uri = new URI(tunnelUrl);	ConsoleProxy.ensureRoute(uri.getHost());	client.connectTo( uri.getHost(), uri.getPort(), uri.getPath() + "?" + uri.getQuery(), tunnelSession, "https".equalsIgnoreCase(uri.getScheme()), getClientHostPassword());	} else {	ConsoleProxy.ensureRoute(getClientHostAddress());	client.connectTo(getClientHostAddress(), getClientHostPort(), getClientHostPassword());	}	} catch (UnknownHostException e) {	} catch (IOException e) {	
unexpected exception 

URI uri = new URI(tunnelUrl);	ConsoleProxy.ensureRoute(uri.getHost());	client.connectTo( uri.getHost(), uri.getPort(), uri.getPath() + "?" + uri.getQuery(), tunnelSession, "https".equalsIgnoreCase(uri.getScheme()), getClientHostPassword());	} else {	ConsoleProxy.ensureRoute(getClientHostAddress());	client.connectTo(getClientHostAddress(), getClientHostPort(), getClientHostPassword());	}	} catch (UnknownHostException e) {	} catch (IOException e) {	} catch (Throwable e) {	
unexpected exception 

ConsoleProxy.ensureRoute(uri.getHost());	client.connectTo( uri.getHost(), uri.getPort(), uri.getPath() + "?" + uri.getQuery(), tunnelSession, "https".equalsIgnoreCase(uri.getScheme()), getClientHostPassword());	} else {	ConsoleProxy.ensureRoute(getClientHostAddress());	client.connectTo(getClientHostAddress(), getClientHostPort(), getClientHostPassword());	}	} catch (UnknownHostException e) {	} catch (IOException e) {	} catch (Throwable e) {	}	
receiver thread stopped 

public void onClientClose() {	
received client close indication remove viewer from map 

========================= cloudstack sample_4999 =========================

public Command[] getCommands() {	if (_cmds == null) {	try {	StringReader reader = new StringReader(_content);	JsonReader jsonReader = new JsonReader(reader);	jsonReader.setLenient(true);	_cmds = s_gson.fromJson(jsonReader, (Type)Command[].class);	} catch (RuntimeException e) {	
caught problem with 

}	ByteBuffer retBuff = ByteBuffer.allocate(length);	int len = 0;	try {	GZIPInputStream in = new GZIPInputStream(byteIn);	while ((len = in.read(byteArrayIn)) > 0) {	retBuff.put(byteArrayIn, 0, len);	}	in.close();	} catch (IOException e) {	
fail to decompress the request 

} else {	array = new byte[buffer.capacity()];	buffer.get(array);	}	try {	GZIPOutputStream out = new GZIPOutputStream(byteOut, length);	out.write(array);	out.finish();	out.close();	} catch (IOException e) {	
fail to compress the request 

========================= cloudstack sample_75 =========================

TemplateResponse response = new TemplateResponse();	if (listResponse != null && !listResponse.isEmpty()) {	response = listResponse.get(0);	}	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to copy template");	}	} catch (StorageUnavailableException ex) {	
exception 

========================= cloudstack sample_3421 =========================

public void waitBeforeRetry() {	Thread current = Thread.currentThread();	try {	_asleep.put(current.getName(), current);	Thread.sleep(_time);	} catch (InterruptedException e) {	
thread interrupted while waiting for retry 

========================= cloudstack sample_2725 =========================

public Answer execute(final MaintainCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	try {	final XsHost xsHost = citrixResourceBase.getHost();	final String uuid = xsHost.getUuid();	final Host host = Host.getByUuid(conn, uuid);	final Host.Record hr = host.getRecord(conn);	if (hr == null) {	
host record is null 

final Iterator<String> it = hr.tags.iterator();	while (it.hasNext()) {	final String tag = it.next();	if (tag.contains("cloud")) {	it.remove();	}	}	host.setTags(conn, hr.tags);	return new MaintainAnswer(command);	} catch (final XenAPIException e) {	
unable to put server in maintainence mode 

final String tag = it.next();	if (tag.contains("cloud")) {	it.remove();	}	}	host.setTags(conn, hr.tags);	return new MaintainAnswer(command);	} catch (final XenAPIException e) {	return new MaintainAnswer(command, false, e.getMessage());	} catch (final XmlRpcException e) {	
unable to put server in maintainence mode 

========================= cloudstack sample_1220 =========================

private void dropKeysIfExists(Connection conn) {	HashMap<String, List<String>> uniqueKeys = new HashMap<String, List<String>>();	List<String> keys = new ArrayList<String>();	keys.add("i_host__allocation_state");	uniqueKeys.put("host", keys);	
droping i host allocation state key in host table 

private void changeEngine(Connection conn) {	
fixing engine and row format for op lock and op nwgrp work tables 

private void changeEngine(Connection conn) {	String sqlOpLock = "ALTER TABLE `cloud`.`op_lock` ENGINE=MEMORY, ROW_FORMAT = FIXED";	try ( PreparedStatement pstmt = conn.prepareStatement(sqlOpLock);	) {	pstmt.executeUpdate();	} catch (Exception e) {	
failed do execute the statement moving on as it s not critical fix 

try ( PreparedStatement pstmt = conn.prepareStatement(sqlOpLock);	) {	pstmt.executeUpdate();	} catch (Exception e) {	}	String sqlOpNwgrpWork = "ALTER TABLE `cloud`.`op_nwgrp_work` ENGINE=MEMORY, ROW_FORMAT = FIXED";	try  ( PreparedStatement pstmt = conn.prepareStatement(sqlOpNwgrpWork);	) {	pstmt.executeUpdate();	} catch (Exception e) {	
failed do execute the statement moving on as it s not critical fix 

========================= cloudstack sample_4188 =========================

success = success && _firewallService.applyIngressFirewallRules(getSourceIpAddressId(), callerContext.getCallingAccount());	}	rule = _entityMgr.findById(LoadBalancer.class, getEntityId());	LoadBalancerResponse lbResponse = new LoadBalancerResponse();	if (rule != null) {	lbResponse = _responseGenerator.createLoadBalancerResponse(rule);	setResponseObject(lbResponse);	}	lbResponse.setResponseName(getCommandName());	} catch (Exception ex) {	
failed to create lb rule due to exception 

public void create() {	if (cidrlist != null) {	throw new InvalidParameterValueException( "Parameter cidrList is deprecated; if you need to open firewall rule for the specific CIDR, please refer to createFirewallRule command");	}	try {	LoadBalancer result = _lbService.createPublicLoadBalancerRule(getXid(), getName(), getDescription(), getSourcePortStart(), getSourcePortEnd(), getDefaultPortStart(), getDefaultPortEnd(), getSourceIpAddressId(), getProtocol(), getAlgorithm(), getNetworkId(), getEntityOwnerId(), getOpenFirewall(), getLbProtocol(), isDisplay());	this.setEntityId(result.getId());	this.setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException e) {	
exception 

if (cidrlist != null) {	throw new InvalidParameterValueException( "Parameter cidrList is deprecated; if you need to open firewall rule for the specific CIDR, please refer to createFirewallRule command");	}	try {	LoadBalancer result = _lbService.createPublicLoadBalancerRule(getXid(), getName(), getDescription(), getSourcePortStart(), getSourcePortEnd(), getDefaultPortStart(), getDefaultPortEnd(), getSourceIpAddressId(), getProtocol(), getAlgorithm(), getNetworkId(), getEntityOwnerId(), getOpenFirewall(), getLbProtocol(), isDisplay());	this.setEntityId(result.getId());	this.setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException e) {	throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, e.getMessage());	} catch (InsufficientAddressCapacityException e) {	
exception 

========================= cloudstack sample_3437 =========================

logger.info("HEADER: Content-Length=" + contentLength);	QueryStringDecoder decoderQuery = new QueryStringDecoder(uri);	Map<String, List<String>> uriAttributes = decoderQuery.parameters();	uuid = uriAttributes.get("uuid").get(0);	logger.info("URI: uuid=" + uuid);	UploadEntity uploadEntity = null;	try {	storageResource.validatePostUploadRequest(signature, metadata, expires, hostname, contentLength, uuid);	uploadEntity = storageResource.createUploadEntity(uuid, metadata, contentLength);	} catch (InvalidParameterValueException ex) {	
post request validation failed 

try {	storageResource.validatePostUploadRequest(signature, metadata, expires, hostname, contentLength, uuid);	uploadEntity = storageResource.createUploadEntity(uuid, metadata, contentLength);	} catch (InvalidParameterValueException ex) {	responseContent.append(ex.getMessage());	writeResponse(ctx.channel(), HttpResponseStatus.BAD_REQUEST);	requestProcessed = true;	return;	}	if (uploadEntity == null) {	
unable to create upload entity an exception occurred 

requestProcessed = true;	return;	}	if (uploadEntity == null) {	responseContent.append("Internal Server Error");	writeResponse(ctx.channel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);	requestProcessed = true;	return;	}	DiskFileUpload.baseDirectory = uploadEntity.getInstallPathPrefix();	
base directory 

if (uploadEntity == null) {	responseContent.append("Internal Server Error");	writeResponse(ctx.channel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);	requestProcessed = true;	return;	}	DiskFileUpload.baseDirectory = uploadEntity.getInstallPathPrefix();	try {	decoder = new HttpPostRequestDecoder(factory, request);	} catch (ErrorDataDecoderException | IncompatibleDataDecoderException e) {	
exception while initialising the decoder 

DiskFileUpload.baseDirectory = uploadEntity.getInstallPathPrefix();	try {	decoder = new HttpPostRequestDecoder(factory, request);	} catch (ErrorDataDecoderException | IncompatibleDataDecoderException e) {	responseContent.append(e.getMessage());	writeResponse(ctx.channel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);	requestProcessed = true;	return;	}	} else {	
received a get request 

requestProcessed = true;	return;	}	}	if (decoder != null) {	if (msg instanceof HttpContent) {	HttpContent chunk = (HttpContent) msg;	try {	decoder.offer(chunk);	} catch (ErrorDataDecoderException e) {	
data decoding exception 

private HttpResponseStatus readFileUploadData() throws IOException {	while (decoder.hasNext()) {	InterfaceHttpData data = decoder.next();	if (data != null) {	try {	
body fileupload 

========================= cloudstack sample_5019 =========================

String routerControlIpAddress = null;	final List<NicVO> nics = nicDao.listByVmId(routerId);	for (final NicVO n : nics) {	final NetworkVO nc = networkDao.findById(n.getNetworkId());	if (nc != null && nc.getTrafficType() == TrafficType.Control) {	routerControlIpAddress = n.getIPv4Address();	break;	}	}	if (routerControlIpAddress == null) {	
unable to find router s control ip in its attached nics routerid 

========================= cloudstack sample_2363 =========================

ImageStoreResponse storeResponse = null;	if (result != null ) {	storeResponse = _responseGenerator.createImageStoreResponse(result);	storeResponse.setResponseName(getCommandName());	storeResponse.setObjectName("secondarystorage");	setResponseObject(storeResponse);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add secondary storage");	}	} catch (DiscoveryException ex) {	
exception 

========================= cloudstack sample_3122 =========================

try {	String sql = ACTIVE_AND_RECENTLY_DELETED_SEARCH + " LIMIT " + startIndex + "," + limit;	PreparedStatement pstmt = null;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), minRemovedDate));	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	vmDiskStats.add(toEntityBean(rs, false));	}	} catch (Exception ex) {	
error saving vm disk stats to cloud usage db 

List<VmDiskStatisticsVO> vmDiskStats = new ArrayList<VmDiskStatisticsVO>();	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement pstmt = null;	pstmt = txn.prepareAutoCloseStatement(UPDATED_VM_NETWORK_STATS_SEARCH);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	vmDiskStats.add(toEntityBean(rs, false));	}	} catch (Exception ex) {	
error lisitng updated vm disk stats 

========================= cloudstack sample_4521 =========================

List<BaremetalRctResponse> rctResponses = new ArrayList<>();	BaremetalRctResponse rsp = vlanMgr.listRct();	if (rsp != null) {	rctResponses.add(rsp);	}	response.setResponses(rctResponses);	response.setResponseName(getCommandName());	response.setObjectName("baremetalrcts");	this.setResponseObject(response);	} catch (Exception e) {	
exception happened while executing listbaremetalrctcmd 

========================= cloudstack sample_869 =========================

protected ReadyAnswer execute(ReadyCommand cmd) {	
external dhcp resource is ready 

========================= cloudstack sample_886 =========================

private static Method getGetMethod(Object o, String propName) {	Method method = null;	String methodName = getGetMethodName("get", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	
security exception in getting responseobject get method for property 

private static Method getGetMethod(Object o, String propName) {	Method method = null;	String methodName = getGetMethodName("get", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	} catch (NoSuchMethodException e1) {	if (s_logger.isTraceEnabled()) {	
responseobject does not have method for property will check is prefixed method to see if it is boolean property 

} catch (SecurityException e1) {	} catch (NoSuchMethodException e1) {	if (s_logger.isTraceEnabled()) {	}	}	if (method != null) return method;	methodName = getGetMethodName("is", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	
security exception in getting responseobject get method for property 

} catch (NoSuchMethodException e1) {	if (s_logger.isTraceEnabled()) {	}	}	if (method != null) return method;	methodName = getGetMethodName("is", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	} catch (NoSuchMethodException e1) {	
responseobject does not have method for property 

========================= cloudstack sample_2508 =========================

public LdapConfigurationResponse addConfiguration(final String hostname, final int port) throws InvalidParameterValueException {	LdapConfigurationVO configuration = _ldapConfigurationDao.findByHostname(hostname);	if (configuration == null) {	LdapContext context = null;	try {	final String providerUrl = "ldap: context = _ldapContextFactory.createBindContext(providerUrl);	configuration = new LdapConfigurationVO(hostname, port);	_ldapConfigurationDao.persist(configuration);	
added new ldap server with hostname 

public LdapConfigurationResponse addConfiguration(final String hostname, final int port) throws InvalidParameterValueException {	LdapConfigurationVO configuration = _ldapConfigurationDao.findByHostname(hostname);	if (configuration == null) {	LdapContext context = null;	try {	final String providerUrl = "ldap: context = _ldapContextFactory.createBindContext(providerUrl);	configuration = new LdapConfigurationVO(hostname, port);	_ldapConfigurationDao.persist(configuration);	return new LdapConfigurationResponse(hostname, port);	} catch (NamingException | IOException e) {	
namingexception while doing an ldap bind 

public boolean canAuthenticate(final String principal, final String password) {	try {	final LdapContext context = _ldapContextFactory.createUserContext(principal, password);	closeContext(context);	return true;	} catch (NamingException | IOException e) {	
exception while doing an ldap bind for user 

public boolean canAuthenticate(final String principal, final String password) {	try {	final LdapContext context = _ldapContextFactory.createUserContext(principal, password);	closeContext(context);	return true;	} catch (NamingException | IOException e) {	
failed to authenticate user incorrect password 

public LdapConfigurationResponse deleteConfiguration(final String hostname) throws InvalidParameterValueException {	final LdapConfigurationVO configuration = _ldapConfigurationDao.findByHostname(hostname);	if (configuration == null) {	throw new InvalidParameterValueException("Cannot find configuration with hostname " + hostname);	} else {	_ldapConfigurationDao.remove(configuration.getId());	
removed ldap server with hostname 

public LdapUser getUser(final String username) throws NoLdapUserMatchingQueryException {	LdapContext context = null;	try {	context = _ldapContextFactory.createBindContext();	final String escapedUsername = LdapUtils.escapeLDAPSearchFilter(username);	return _ldapUserManagerFactory.getInstance(_ldapConfiguration.getLdapProvider()).getUser(escapedUsername, context);	} catch (NamingException | IOException e) {	
ldap exception 

public LdapUser getUser(final String username, final String type, final String name) throws NoLdapUserMatchingQueryException {	LdapContext context = null;	try {	context = _ldapContextFactory.createBindContext();	final String escapedUsername = LdapUtils.escapeLDAPSearchFilter(username);	return _ldapUserManagerFactory.getInstance(_ldapConfiguration.getLdapProvider()).getUser(escapedUsername, type, name, context);	} catch (NamingException | IOException e) {	
ldap exception 

public List<LdapUser> getUsers() throws NoLdapUserMatchingQueryException {	LdapContext context = null;	try {	context = _ldapContextFactory.createBindContext();	return _ldapUserManagerFactory.getInstance(_ldapConfiguration.getLdapProvider()).getUsers(context);	} catch (NamingException | IOException e) {	
ldap exception 

public List<LdapUser> getUsersInGroup(String groupName) throws NoLdapUserMatchingQueryException {	LdapContext context = null;	try {	context = _ldapContextFactory.createBindContext();	return _ldapUserManagerFactory.getInstance(_ldapConfiguration.getLdapProvider()).getUsersInGroup(groupName, context);	} catch (NamingException | IOException e) {	
ldap namingexception 

public List<LdapUser> searchUsers(final String username) throws NoLdapUserMatchingQueryException {	LdapContext context = null;	try {	context = _ldapContextFactory.createBindContext();	final String escapedUsername = LdapUtils.escapeLDAPSearchFilter(username);	return _ldapUserManagerFactory.getInstance(_ldapConfiguration.getLdapProvider()).getUsers("*" + escapedUsername + "*", context);	} catch (NamingException | IOException e) {	
ldap exception 

========================= cloudstack sample_1324 =========================

s_logger.error(errorString);	} finally {	try {	if (inputStream != null) {	inputStream.close();	}	if (outputStream != null) {	outputStream.close();	}	} catch (IOException ioe) {	
caught exception while closing the resources 

public void run() {	try {	upload(completionCallback);	} catch (Throwable t) {	
caught exception during upload 

public boolean stopUpload() {	switch (getStatus()) {	case IN_PROGRESS: try {	if (outputStream != null) {	outputStream.close();	}	if (inputStream != null) {	inputStream.close();	}	} catch (IOException e) {	
caught exception while closing the resources 

========================= cloudstack sample_404 =========================

public boolean delete(DataObject obj) {	AsyncCallFuture<CommandResult> future = new AsyncCallFuture<CommandResult>();	this.driver.deleteAsync(obj.getDataStore(), obj, future);	try {	future.get();	} catch (InterruptedException e) {	
failed delete obj 

public boolean delete(DataObject obj) {	AsyncCallFuture<CommandResult> future = new AsyncCallFuture<CommandResult>();	this.driver.deleteAsync(obj.getDataStore(), obj, future);	try {	future.get();	} catch (InterruptedException e) {	return false;	} catch (ExecutionException e) {	
failed delete obj 

========================= cloudstack sample_3948 =========================

public boolean isReady(PhysicalNetworkServiceProvider provider) {	PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(provider.getPhysicalNetworkId());	assert (physicalNetwork != null);	if (fetchSspClients(physicalNetwork.getId(), physicalNetwork.getDataCenterId(), false).size() > 0) {	return true;	}	
ssp api endpoint not found 

public boolean canHandle(PhysicalNetwork physicalNetwork) {	if (physicalNetwork != null) {	if (fetchSspClients(physicalNetwork.getId(), physicalNetwork.getDataCenterId(), true).size() > 0) {	return true;	}	
enabled ssp api endpoint not found 

public boolean canHandle(PhysicalNetwork physicalNetwork) {	if (physicalNetwork != null) {	if (fetchSspClients(physicalNetwork.getId(), physicalNetwork.getDataCenterId(), true).size() > 0) {	return true;	}	} else {	
physicalnetwork is null 

private boolean canHandle(Network network) {	if (canHandle(_physicalNetworkDao.findById(network.getPhysicalNetworkId()))) {	if (!_ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), Service.Connectivity, getProvider())) {	
ssp is implicitly active for 

if (cmd.getUsername() == null || cmd.getPassword() == null) {	throw new InvalidParameterValueException("Initial credential required for zone: " + zoneId);	}	credential = new SspCredentialVO();	credential.setZoneId(zoneId);	credential.setUsername(cmd.getUsername());	credential.setPassword(cmd.getPassword());	_sspCredentialDao.persist(credential);	} else {	if (cmd.getUsername() != null || cmd.getPassword() != null) {	
tenant credential already configured for zone 

if (tenantUuid == null) {	if (cmd.getTenantUuid() == null) {	throw new InvalidParameterValueException("Initial tenant uuid required for zone: " + zoneId);	}	SspTenantVO tenant = new SspTenantVO();	tenant.setZoneId(zoneId);	tenant.setUuid(cmd.getTenantUuid());	_sspTenantDao.persist(tenant);	} else {	if (cmd.getTenantUuid() != null) {	
tenant uuid already configured for zone 

hostname = url.getHost();	} catch (MalformedURLException e1) {	throw new CloudRuntimeException("Invalid url " + cmd.getUrl());	}	List<HostVO> hosts = _resourceMgr.listAllHostsInOneZoneByType(Host.Type.L2Networking, zoneId);	for (HostVO host : hosts) {	assert (credential != null);	_hostDao.loadDetails(host);	if ("v1Api".equals(host.getDetail("sspHost"))) {	if (normalizedUrl.equals(host.getDetail("url"))) {	
ssp host already registered 

public boolean deleteSspHost(DeleteSspCmd cmd) {	
deleteStratosphereSsp 

public boolean createNetwork(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) {	if (_sspUuidDao.findUuidByNetwork(network) != null) {	
network already has ssp tenantnetwork uuid 

SspUuidVO uuid = new SspUuidVO();	uuid.setUuid(sspNet.uuid);	uuid.setObjClass(SspUuidVO.objClassNetwork);	uuid.setObjId(network.getId());	_sspUuidDao.persist(uuid);	return true;	}	processed = true;	}	if (processed) {	
could not allocate an uuid for network 

uuid.setObjClass(SspUuidVO.objClassNetwork);	uuid.setObjId(network.getId());	_sspUuidDao.persist(uuid);	return true;	}	processed = true;	}	if (processed) {	return false;	} else {	
skipping createnetwork for 

if (tenantNetworkUuid != null) {	boolean processed = false;	for (SspClient client : fetchSspClients(network.getPhysicalNetworkId(), network.getDataCenterId(), true)) {	if (client.deleteTenantNetwork(tenantNetworkUuid)) {	_sspUuidDao.removeUuid(tenantNetworkUuid);	processed = true;	break;	}	}	if (!processed) {	
ssp api tenant network deletion failed 

for (SspClient client : fetchSspClients(network.getPhysicalNetworkId(), network.getDataCenterId(), true)) {	if (client.deleteTenantNetwork(tenantNetworkUuid)) {	_sspUuidDao.removeUuid(tenantNetworkUuid);	processed = true;	break;	}	}	if (!processed) {	}	} else {	
silently skipping deletenetwork for 

public boolean createNicEnv(Network network, NicProfile nic, DeployDestination dest, ReservationContext context) {	String tenantNetworkUuid = _sspUuidDao.findUuidByNetwork(network);	if (tenantNetworkUuid == null) {	
skipping createnicenv for nic on 

public boolean createNicEnv(Network network, NicProfile nic, DeployDestination dest, ReservationContext context) {	String tenantNetworkUuid = _sspUuidDao.findUuidByNetwork(network);	if (tenantNetworkUuid == null) {	return true;	}	String reservationId = context.getReservationId();	List<SspUuidVO> tenantPortUuidVos = _sspUuidDao.listUUidVoByNicProfile(nic);	for (SspUuidVO tenantPortUuidVo : tenantPortUuidVos) {	if (reservationId.equals(tenantPortUuidVo.getReservationId())) {	
skipping because reservation found 

SspUuidVO uuid = new SspUuidVO();	uuid.setUuid(tenantPortUuid);	uuid.setObjClass(SspUuidVO.objClassNicProfile);	uuid.setObjId(nic.getId());	uuid.setReservationId(reservationId);	_sspUuidDao.persist(uuid);	break;	}	}	if (tenantPortUuid == null) {	
createnicenv failed for nic on 

for (SspClient client : fetchSspClients(network.getPhysicalNetworkId(), network.getDataCenterId(), true)) {	SspClient.TenantPort sspPort = client.updateTenantVifBinding(tenantPortUuid, dest.getHost().getPrivateIpAddress());	if (sspPort != null) {	if (sspPort.vlanId != null) {	nic.setBroadcastType(BroadcastDomainType.Vlan);	nic.setBroadcastUri(BroadcastDomainType.Vlan.toUri(String.valueOf(sspPort.vlanId)));	}	return true;	}	}	
updating vif failed 

public boolean deleteNicEnv(Network network, NicProfile nic, ReservationContext context) {	if (context == null) {	
reservationcontext was null for 

String tenantPortUuid = deleteTarget.getUuid();	boolean processed = false;	for (SspClient client : fetchSspClients(network.getPhysicalNetworkId(), network.getDataCenterId(), true)) {	SspClient.TenantPort sspPort = client.updateTenantVifBinding(tenantPortUuid, null);	if (sspPort != null) {	processed = true;	break;	}	}	if (!processed) {	
ssp api nic detach failed 

}	processed = false;	for (SspClient client : fetchSspClients(network.getPhysicalNetworkId(), network.getDataCenterId(), true)) {	if (client.deleteTenantPort(tenantPortUuid)) {	_sspUuidDao.removeUuid(tenantPortUuid);	processed = true;	break;	}	}	if (!processed) {	
ssp api tenant port deletion failed 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
implement 

public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	
shutdown 

public boolean prepare(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
prepare 

public boolean release(Network network, NicProfile nic, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
release 

public boolean destroy(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
destroy 

public boolean shutdownProviderInstances(PhysicalNetworkServiceProvider provider, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
shutdownProviderInstances 

public boolean canEnableIndividualServices() {	
canEnableIndividualServices 

public boolean verifyServicesCombination(Set<Service> services) {	
verifyservicescombination 

public boolean prepareMigration(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) {	try {	prepare(network, nic, vm, dest, context);	} catch (ConcurrentOperationException e) {	
prepareformigration failed 

public boolean prepareMigration(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) {	try {	prepare(network, nic, vm, dest, context);	} catch (ConcurrentOperationException e) {	return false;	} catch (ResourceUnavailableException e) {	
prepareformigration failed 

public boolean prepareMigration(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) {	try {	prepare(network, nic, vm, dest, context);	} catch (ConcurrentOperationException e) {	return false;	} catch (ResourceUnavailableException e) {	return false;	} catch (InsufficientCapacityException e) {	
prepareformigration failed 

public void rollbackMigration(NicProfile nic, Network network, VirtualMachineProfile vm, ReservationContext src, ReservationContext dst) {	try {	release(network, nic, vm, dst);	} catch (ConcurrentOperationException e) {	
rollbackmigration failed 

public void rollbackMigration(NicProfile nic, Network network, VirtualMachineProfile vm, ReservationContext src, ReservationContext dst) {	try {	release(network, nic, vm, dst);	} catch (ConcurrentOperationException e) {	} catch (ResourceUnavailableException e) {	
rollbackmigration failed 

public void commitMigration(NicProfile nic, Network network, VirtualMachineProfile vm, ReservationContext src, ReservationContext dst) {	try {	release(network, nic, vm, src);	} catch (ConcurrentOperationException e) {	
commitmigration failed 

public void commitMigration(NicProfile nic, Network network, VirtualMachineProfile vm, ReservationContext src, ReservationContext dst) {	try {	release(network, nic, vm, src);	} catch (ConcurrentOperationException e) {	} catch (ResourceUnavailableException e) {	
commitmigration failed 

========================= cloudstack sample_1426 =========================

public FormatInfo process(String templatePath, ImageFormat format, String templateName) {	if (format != null) {	
we don t handle conversion from to iso 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) {	if (format != null) {	return null;	}	String isoPath = templatePath + File.separator + templateName + "." + ImageFormat.ISO.getFileExtension();	if (!_storage.exists(isoPath)) {	
unable to find the iso file 

========================= cloudstack sample_392 =========================

public void testDedicatePublicIpRange() throws Exception {	
running tests for dedicatepubliciprange api 

public void testReleasePublicIpRange() throws Exception {	
running tests for dedicatepubliciprange api 

========================= cloudstack sample_2123 =========================

public void onEntry(String prevState, DownloadEvent event, Object evtObj) {	super.onEntry(prevState, event, evtObj);	if (event == DownloadEvent.DISCONNECT) {	getDownloadListener().logDisconnect();	getDownloadListener().cancelStatusTask();	getDownloadListener().cancelTimeoutTask();	DownloadAnswer answer = new DownloadAnswer("Storage agent or storage VM disconnected", Status.DOWNLOAD_ERROR);	getDownloadListener().callback(answer);	
entering download error state because the storage host disconnected 

super.onEntry(prevState, event, evtObj);	if (event == DownloadEvent.DISCONNECT) {	getDownloadListener().logDisconnect();	getDownloadListener().cancelStatusTask();	getDownloadListener().cancelTimeoutTask();	DownloadAnswer answer = new DownloadAnswer("Storage agent or storage VM disconnected", Status.DOWNLOAD_ERROR);	getDownloadListener().callback(answer);	} else if (event == DownloadEvent.TIMEOUT_CHECK) {	DownloadAnswer answer = new DownloadAnswer("Timeout waiting for response from storage host", Status.DOWNLOAD_ERROR);	getDownloadListener().callback(answer);	
entering download error state timeout waiting for response from storage host 

========================= cloudstack sample_2436 =========================

Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	}	ArrayList<String> port = new ArrayList<String>();	for (int j = 1; j < 1000; j++) {	port.add(Integer.toString(j));	}	for (String portValue : port) {	try {	
public port is 

port.add(Integer.toString(j));	}	for (String portValue : port) {	try {	String url = "http: "&privatePort=22&protocol=tcp&isForward=true&securityGroupId=1&account=admin";	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode != 200) {	error++;	
can t create portforwarding network rule for the public port request was sent with url 

========================= cloudstack sample_453 =========================

String msg = "";	if (e instanceof Types.BadAsyncResult) {	final String licenseKeyWord = "LICENCE_RESTRICTION";	final Types.BadAsyncResult errorResult = (Types.BadAsyncResult)e;	if (errorResult.shortDescription != null && errorResult.shortDescription.contains(licenseKeyWord)) {	msg = licenseKeyWord;	}	} else {	msg = e.toString();	}	
creating vm snapshot failed due to 

msg = licenseKeyWord;	}	} else {	msg = e.toString();	}	return new CreateVMSnapshotAnswer(command, false, msg);	} finally {	try {	if (!success) {	if (vmSnapshot != null) {	
delete exsisting vm snapshot after making volumeto failed 

}	vmSnapshot.destroy(conn);	}	}	if (vmState == VmPowerState.HALTED) {	if (vm != null) {	vm.destroy(conn);	}	}	} catch (final Exception e2) {	
delete snapshot error due to 

========================= cloudstack sample_1164 =========================

public void create() {	try {	GlobalLoadBalancerRule gslbRule = _gslbService.createGlobalLoadBalancerRule(this);	this.setEntityId(gslbRule.getId());	this.setEntityUuid(gslbRule.getUuid());	CallContext.current().setEventDetails("Rule Id: " + getEntityId());	} catch (Exception ex) {	
exception 

========================= cloudstack sample_3509 =========================

public void configureNetworking() throws ConfigurationException {	try {	Network net = new Network(c);	String controlIface = config.getAgentControlNetworkName();	if (controlIface != null && net.getInterfaceByName(controlIface) == null) {	
starting 

public void configureNetworking() throws ConfigurationException {	try {	Network net = new Network(c);	String controlIface = config.getAgentControlNetworkName();	if (controlIface != null && net.getInterfaceByName(controlIface) == null) {	net.startOvsLocalConfig(controlIface);	int contCount = 0;	while (net.getInterfaceByName(controlIface) == null) {	
waiting for 

net.startOvsLocalConfig(controlIface);	int contCount = 0;	while (net.getInterfaceByName(controlIface) == null) {	Thread.sleep(1 * 1000);	if (contCount > 9) {	throw new ConfigurationException("Unable to configure " + controlIface + " on host " + config.getAgentHostname());	}	contCount++;	}	} else {	
already have 

throw new ConfigurationException("Unable to configure " + controlIface + " on host " + config.getAgentHostname());	}	contCount++;	}	} else {	}	net.ovsIpConfig(controlIface, "static", NetUtils.getLinkLocalGateway(), NetUtils.getLinkLocalNetMask());	CloudstackPlugin cSp = new CloudstackPlugin(c);	cSp.ovsControlInterface(controlIface, NetUtils.getLinkLocalCIDR());	} catch (InterruptedException e) {	
interrupted 

private boolean isNetworkSetupByName(String nameTag) {	if (nameTag != null) {	
looking for network setup by name 

private boolean isNetworkSetupByName(String nameTag) {	if (nameTag != null) {	try {	Network net = new Network(c);	net.getInterfaceList();	if (net.getBridgeByName(nameTag) != null) {	
found bridge with name 

private boolean isNetworkSetupByName(String nameTag) {	if (nameTag != null) {	try {	Network net = new Network(c);	net.getInterfaceList();	if (net.getBridgeByName(nameTag) != null) {	return true;	}	} catch (Ovm3ResourceException e) {	
unxpected error looking for name 

try {	Network net = new Network(c);	net.getInterfaceList();	if (net.getBridgeByName(nameTag) != null) {	return true;	}	} catch (Ovm3ResourceException e) {	return false;	}	}	
no bridge with name 

public CheckNetworkAnswer execute(CheckNetworkCommand cmd) {	
checking if network name setup is done on 

if (cmd.getComputingHostIp() != null) {	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (!cSp.ping(cmd.getComputingHostIp())) {	return new Answer(cmd, false, "ping failed");	}	} else {	return new Answer(cmd, false, "why asks me to ping a router???");	}	return new Answer(cmd, true, "success");	} catch (Ovm3ResourceException e) {	
ping failed 

LOGGER.error(msg);	throw new CloudRuntimeException(msg);	}	Network net = new Network(c);	String brName = networkName + "." + vlanId.toString();	try {	String physInterface = net.getPhysicalByBridgeName(networkName);	if (net.getInterfaceByName(brName) == null) {	net.startOvsVlanBridge(brName, physInterface, vlanId);	} else {	
interface already exists 

========================= cloudstack sample_845 =========================

public void releaseIpAddress(String ipAddress, long dcId, Long instanceId) {	if (s_logger.isDebugEnabled()) {	
releasing ip address data center 

========================= cloudstack sample_4673 =========================

public boolean hostAdded(long hostId) {	
hostadded long invoked 

public boolean hostConnect(long hostId, long poolId) {	
hostconnect long long invoked 

public boolean hostDisconnected(long hostId, long poolId) {	
hostdisconnected long long invoked 

public boolean hostAboutToBeRemoved(long hostId) {	
hostabouttoberemoved long invoked 

public boolean hostRemoved(long hostId, long clusterId) {	
hostremoved long invoked 

========================= cloudstack sample_1922 =========================

public void addToVMInterface(VMInterfaceModel vmiModel) {	_vmiModel = vmiModel;	if (vmiModel != null) {	vmiModel.addSuccessor(this);	
vmimodel has ip addresses 

========================= cloudstack sample_1888 =========================

public InetAddress getIPAddr(String macAddr, String vmName) {	String ipAddr = _ipAddresses.poll();	if (ipAddr == null) {	
no ip addresses left in queue 

if (ipAddr == null) {	return null;	}	try {	InetAddress inetAddr = InetAddress.getByName(ipAddr);	_macIpMap.put(macAddr.toLowerCase(), ipAddr);	_vmIpMap.put(vmName, inetAddr);	s_logger.info("Got ip address " + ipAddr + " for vm " + vmName + " mac=" + macAddr.toLowerCase());	return inetAddr;	} catch (UnknownHostException e) {	
failed to get inetaddress for 

macAddr = entry.getKey();	break;	}	}	ipAddr = _macIpMap.remove(macAddr);	s_logger.info("Cleaning up for mac address: " + macAddr + " ip=" + ipAddr + " inetAddr=" + inetAddr);	if (ipAddr != null) {	_ipAddresses.offer(ipAddr);	}	} catch (Exception e) {	
failed to cleanup 

========================= cloudstack sample_2877 =========================

public void createOva(String path, String name) {	Script commandSync = new Script(true, "sync", 0, s_logger);	commandSync.execute();	Script command = new Script(false, "tar", 0, s_logger);	command.setWorkDir(path);	command.add("-cf", name + ".ova");	command.add(name + ".ovf");	command.add(name + "-disk0.vmdk");	
package ova with commmand 

public void configure(Map<String, Object> params) {	
configure vmwarestoragemanagerimpl 

public String createOvaForTemplate(TemplateObjectTO template) {	DataStoreTO storeTO = template.getDataStore();	if (!(storeTO instanceof NfsTO)) {	
can only handle nfs storage while creating ova from template 

}	NfsTO nfsStore = (NfsTO)storeTO;	String secStorageUrl = nfsStore.getUrl();	assert (secStorageUrl != null);	String installPath = template.getPath();	String secondaryMountPoint = _mountService.getMountPoint(secStorageUrl, _nfsVersion);	String installFullPath = secondaryMountPoint + "/" + installPath;	try {	if (installFullPath.endsWith(".ova")) {	if (new File(installFullPath).exists()) {	
ova file found at 

createOVAFromMetafile(installFullPath + ".meta");	} else {	String msg = "Unable to find OVA or OVA MetaFile to prepare template.";	s_logger.error(msg);	throw new Exception(msg);	}	}	return installPath;	}	} catch (Throwable e) {	
failed to create ova 

public String createOvaForVolume(VolumeObjectTO volume) {	DataStoreTO storeTO = volume.getDataStore();	if (!(storeTO instanceof NfsTO)) {	
can only handle nfs storage when create ova from volume 

String secStorageUrl = nfsStore.getUrl();	assert (secStorageUrl != null);	String installPath = volume.getPath();	int index = installPath.lastIndexOf(File.separator);	String volumeUuid = installPath.substring(index + 1);	String secondaryMountPoint = _mountService.getMountPoint(secStorageUrl, _nfsVersion);	String volumePath = installPath + File.separator + volumeUuid + ".ova";	String installFullPath = secondaryMountPoint + "/" + installPath;	try {	if (new File(secondaryMountPoint + File.separator + volumePath).exists()) {	
ova already exists 

commandSync.execute();	Script command = new Script(false, "tar", 0, s_logger);	command.setWorkDir(installFullPath);	command.add("-cf", volumeUuid + ".ova");	command.add(volumeUuid + ".ovf");	command.add(volumeUuid + "-disk0.vmdk");	command.execute();	return volumePath;	}	} catch (Throwable e) {	
exception for createvolumeova 

}	VmwareContext context = hostService.getServiceContext(cmd);	try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	String templateUuidName = UUID.nameUUIDFromBytes((templateName + "@" + cmd.getPoolUuid() + "-" + hyperHost.getMor().getValue()).getBytes("UTF-8")).toString();	templateUuidName = templateUuidName.replace("-", "");	DatacenterMO dcMo = new DatacenterMO(context, hyperHost.getHyperHostDatacenter());	VirtualMachineMO templateMo = VmwareHelper.pickOneVmOnRunningHost(dcMo.findVmByNameAndLabel(templateUuidName), true);	if (templateMo == null) {	if (s_logger.isInfoEnabled()) {	
template is not setup yet setup template from secondary storage with uuid name 

DatacenterMO dcMo = new DatacenterMO(context, hyperHost.getHyperHostDatacenter());	VirtualMachineMO templateMo = VmwareHelper.pickOneVmOnRunningHost(dcMo.findVmByNameAndLabel(templateUuidName), true);	if (templateMo == null) {	if (s_logger.isInfoEnabled()) {	}	ManagedObjectReference morDs = HypervisorHostHelper.findDatastoreWithBackwardsCompatibility(hyperHost, cmd.getPoolUuid());	assert (morDs != null);	DatastoreMO primaryStorageDatastoreMo = new DatastoreMO(context, morDs);	copyTemplateFromSecondaryToPrimary(hyperHost, primaryStorageDatastoreMo, secondaryStorageUrl, mountPoint, templateName, templateUuidName, cmd.getNfsVersion());	} else {	
template has already been setup skip the template setup process in primary storage 

String snapshotBackupUuid = null;	VmwareContext context = hostService.getServiceContext(cmd);	VirtualMachineMO vmMo = null;	try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	morDs = HypervisorHostHelper.findDatastoreWithBackwardsCompatibility(hyperHost, cmd.getPool().getUuid());	try {	vmMo = hyperHost.findVmOnHyperHost(cmd.getVmName());	if (vmMo == null) {	if (s_logger.isDebugEnabled()) {	
unable to find owner vm for backupsnapshotcommand on host will try within datacenter 

if (snapshotMor != null) {	vmMo.removeSnapshot(snapshotUuid, false);	}	}	try {	if (workerVm != null) {	workerVm.detachAllDisks();	workerVm.destroy();	}	} catch (Throwable e) {	
failed to destroy worker vm 

workerVm.detachAllDisks();	workerVm.destroy();	}	} catch (Throwable e) {	}	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

String volumePath = cmd.getVolumePath();	Long accountId = cmd.getAccountId();	Long templateId = cmd.getTemplateId();	String details = null;	VmwareContext context = hostService.getServiceContext(cmd);	try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(cmd.getVmName());	if (vmMo == null) {	if (s_logger.isDebugEnabled()) {	
unable to find the owner vm for createprivatetemplatefromvolumecommand on host try within datacenter 

s_logger.error(msg);	throw new Exception(msg);	}	}	Ternary<String, Long, Long> result = createTemplateFromVolume(vmMo, accountId, templateId, cmd.getUniqueName(), secondaryStoragePoolURL, volumePath, hostService.getWorkerName(context, cmd, 0), cmd.getNfsVersion());	return new CreatePrivateTemplateAnswer(cmd, true, null, result.first(), result.third(), result.second(), cmd.getUniqueName(), ImageFormat.OVA);	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

String details;	String uniqeName = UUID.randomUUID().toString();	VmwareContext context = hostService.getServiceContext(cmd);	try {	Ternary<String, Long, Long> result = createTemplateFromSnapshot(accountId, newTemplateId, uniqeName, secondaryStorageUrl, volumeId, backedUpSnapshotUuid, cmd.getNfsVersion());	return new CreatePrivateTemplateAnswer(cmd, true, null, result.first(), result.third(), result.second(), uniqeName, ImageFormat.OVA);	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

}	DatastoreMO primaryDsMo = new DatastoreMO(hyperHost.getContext(), morPrimaryDs);	details = createVolumeFromSnapshot(hyperHost, primaryDsMo, newVolumeName, accountId, volumeId, secondaryStorageUrl, backedUpSnapshotUuid, cmd.getNfsVersion());	if (details == null) {	success = true;	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

private void copyTemplateFromSecondaryToPrimary(VmwareHypervisorHost hyperHost, DatastoreMO datastoreMo, String secondaryStorageUrl, String templatePathAtSecondaryStorage, String templateName, String templateUuid, Integer nfsVersion) throws Exception {	
executing copytemplatefromsecondarytoprimary secondarystorage templatepathatsecondarystorage templatename 

private void copyTemplateFromSecondaryToPrimary(VmwareHypervisorHost hyperHost, DatastoreMO datastoreMo, String secondaryStorageUrl, String templatePathAtSecondaryStorage, String templateName, String templateUuid, Integer nfsVersion) throws Exception {	String secondaryMountPoint = _mountService.getMountPoint(secondaryStorageUrl, nfsVersion);	
secondary storage mount point 

private void copyTemplateFromSecondaryToPrimary(VmwareHypervisorHost hyperHost, DatastoreMO datastoreMo, String secondaryStorageUrl, String templatePathAtSecondaryStorage, String templateName, String templateUuid, Integer nfsVersion) throws Exception {	String secondaryMountPoint = _mountService.getMountPoint(secondaryStorageUrl, nfsVersion);	String srcOVAFileName = secondaryMountPoint + "/" + templatePathAtSecondaryStorage + templateName + "." + ImageFormat.OVA.getFileExtension();	String srcFileName = getOVFFilePath(srcOVAFileName);	if (srcFileName == null) {	Script command = new Script("tar", 0, s_logger);	command.add("--no-same-owner");	command.add("-xf", srcOVAFileName);	command.setWorkDir(secondaryMountPoint + "/" + templatePathAtSecondaryStorage);	
executing command 

result = command.execute();	if (result != null) {	String msg = "unable to copy snapshot " + snapshotFullOVAName + " to " + installFullPath;	s_logger.error(msg);	throw new Exception(msg);	}	command = new Script("tar", 0, s_logger);	command.add("--no-same-owner");	command.add("-xf", installFullOVAName);	command.setWorkDir(installFullPath);	
executing command 

if (new File(snapshotFullOvfName).exists()) {	command = new Script(false, "cp", _timeout, s_logger);	command.add(snapshotFullOvfName);	command.add(installFullPath);	result = command.execute();	if (result != null) {	String msg = "unable to copy snapshot " + snapshotFullOvfName + " to " + installFullPath;	s_logger.error(msg);	throw new Exception(msg);	}	
vmdkfile parent dir 

result = command.execute();	if (result != null) {	String msg = "unable to copy snapshot " + snapshotFullOvfName + " to " + installFullPath;	s_logger.error(msg);	throw new Exception(msg);	}	File snapshotdir = new File(snapshotFullVMDKName);	File[] ssfiles = snapshotdir.listFiles();	for (int i = 0; i < ssfiles.length; i++) {	String vmdkfile = ssfiles[i].getName();	
vmdk file name 

snapshotFullVMDKName += vmdkfile;	templateVMDKName += vmdkfile;	break;	}	}	if (snapshotFullVMDKName != null) {	command = new Script(false, "cp", _timeout, s_logger);	command.add(snapshotFullVMDKName);	command.add(installFullPath);	result = command.execute();	
copy vmdk file 

File ovafile = new File(srcOVAFileName);	String srcOVFFileName = secondaryMountPoint + "/" + secStorageDir + "/" + backupName + ".ovf";	File ovfFile = new File(srcOVFFileName);	if (!ovfFile.exists()) {	srcOVFFileName = getOVFFilePath(srcOVAFileName);	if (srcOVFFileName == null && ovafile.exists()) {	Script command = new Script("tar", 0, s_logger);	command.add("--no-same-owner");	command.add("-xf", srcOVAFileName);	command.setWorkDir(secondaryMountPoint + "/" + secStorageDir + "/" + snapshotDir);	
executing command 

private String createOVAFromMetafile(String metafileName) throws Exception {	File ova_metafile = new File(metafileName);	Properties props = null;	String ovaFileName = "";	
creating ova using metafile 

private String createOVAFromMetafile(String metafileName) throws Exception {	File ova_metafile = new File(metafileName);	Properties props = null;	String ovaFileName = "";	try (FileInputStream strm = new FileInputStream(ova_metafile);) {	
loading properties from ova meta file 

private String createOVAFromMetafile(String metafileName) throws Exception {	File ova_metafile = new File(metafileName);	Properties props = null;	String ovaFileName = "";	try (FileInputStream strm = new FileInputStream(ova_metafile);) {	props = new Properties();	props.load(strm);	ovaFileName = props.getProperty("ova.filename");	
ovafilename 

private String createOVAFromMetafile(String metafileName) throws Exception {	File ova_metafile = new File(metafileName);	Properties props = null;	String ovaFileName = "";	try (FileInputStream strm = new FileInputStream(ova_metafile);) {	props = new Properties();	props.load(strm);	ovaFileName = props.getProperty("ova.filename");	String ovfFileName = props.getProperty("ovf");	
ovffilename 

int diskNum = Integer.parseInt(props.getProperty("numDisks"));	if (diskNum <= 0) {	String msg = "VMDK disk file number is 0. Error";	s_logger.error(msg);	throw new Exception(msg);	}	String[] disks = new String[diskNum];	for (int i = 0; i < diskNum; i++) {	String diskNameKey = "disk1.name";	disks[i] = props.getProperty(diskNameKey);	
diskname 

String msg = "VMDK disk file number is 0. Error";	s_logger.error(msg);	throw new Exception(msg);	}	String[] disks = new String[diskNum];	for (int i = 0; i < diskNum; i++) {	String diskNameKey = "disk1.name";	disks[i] = props.getProperty(diskNameKey);	}	String exportDir = ova_metafile.getParent();	
exportdir 

String msg = "VMDK disk file number is 0. Error";	s_logger.error(msg);	throw new Exception(msg);	}	String[] disks = new String[diskNum];	for (int i = 0; i < diskNum; i++) {	String diskNameKey = "disk1.name";	disks[i] = props.getProperty(diskNameKey);	}	String exportDir = ova_metafile.getParent();	
sync file system before we package ova before tar 

String msg = "VMDK disk file number is 0. Error";	s_logger.error(msg);	throw new Exception(msg);	}	String[] disks = new String[diskNum];	for (int i = 0; i < diskNum; i++) {	String diskNameKey = "disk1.name";	disks[i] = props.getProperty(diskNameKey);	}	String exportDir = ova_metafile.getParent();	
ova ovf vmdk 

Script commandSync = new Script(true, "sync", 0, s_logger);	commandSync.execute();	Script command = new Script(false, "tar", 0, s_logger);	command.setWorkDir(exportDir);	command.add("-cf", ovaFileName);	command.add(ovfFileName);	for (String diskName : disks) {	command.add(diskName);	}	command.execute();	
package ova for template in dir cmd 

commandSync.execute();	Script command = new Script(false, "tar", 0, s_logger);	command.setWorkDir(exportDir);	command.add("-cf", ovaFileName);	command.add(ovfFileName);	for (String diskName : disks) {	command.add(diskName);	}	command.execute();	if ((new File(exportDir + File.separator + ovaFileName)).exists()) {	
ova file is created and ready to extract 

}	command.execute();	if ((new File(exportDir + File.separator + ovaFileName)).exists()) {	return ovaFileName;	} else {	String msg = exportDir + File.separator + ovaFileName + " is not created as expected";	s_logger.error(msg);	throw new Exception(msg);	}	} catch (Exception e) {	
exception while creating ova using metafile 

VirtualMachineMO vmMo = null;	VmwareContext context = hostService.getServiceContext(cmd);	try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	ManagedObjectReference taskmgr = context.getServiceContent().getTaskManager();	List<ManagedObjectReference> tasks = context.getVimClient().getDynamicProperty(taskmgr, "recentTask");	for (ManagedObjectReference taskMor : tasks) {	TaskInfo info = (TaskInfo)(context.getVimClient().getDynamicProperty(taskMor, "info"));	if (info.getEntityName().equals(cmd.getVmName()) && StringUtils.isNotBlank(info.getName()) && info.getName().equalsIgnoreCase("CreateSnapshot_Task")) {	if (!(info.getState().equals(TaskInfoState.SUCCESS) || info.getState().equals(TaskInfoState.ERROR))) {	
there is already a vm snapshot task running wait for it 

vmMo = hyperHost.findVmOnHyperHost(vmName);	if (vmMo == null) {	vmMo = hyperHost.findVmOnPeerHyperHost(vmName);	}	if (vmMo == null) {	String msg = "Unable to find VM for CreateVMSnapshotCommand";	s_logger.info(msg);	return new CreateVMSnapshotAnswer(cmd, false, msg);	} else {	if (vmMo.getSnapshotMor(vmSnapshotName) != null) {	
vm snapshot already exists 

if (vmMo.getSnapshotMor(vmSnapshotName) != null) {	} else if (!vmMo.createSnapshot(vmSnapshotName, vmSnapshotDesc, snapshotMemory, quiescevm)) {	return new CreateVMSnapshotAnswer(cmd, false, "Unable to create snapshot due to esxi internal failed");	}	Map<String, String> mapNewDisk = getNewDiskMap(vmMo);	setVolumeToPathAndSize(volumeTOs, mapNewDisk, context, hyperHost, cmd.getVmName());	return new CreateVMSnapshotAnswer(cmd, cmd.getTarget(), volumeTOs);	}	} catch (Exception e) {	String msg = e.getMessage();	
failed to create snapshot for vm due to 

setVolumeToPathAndSize(volumeTOs, mapNewDisk, context, hyperHost, cmd.getVmName());	return new CreateVMSnapshotAnswer(cmd, cmd.getTarget(), volumeTOs);	}	} catch (Exception e) {	String msg = e.getMessage();	try {	if (vmMo.getSnapshotMor(vmSnapshotName) != null) {	vmMo.removeSnapshot(vmSnapshotName, false);	}	} catch (Exception e1) {	
ignored error during snapshot remove 

private ManagedObjectReference getDatastoreAsManagedObjectReference(String baseName, VmwareHypervisorHost hyperHost, DataStoreTO store)  throws Exception {	try {	ManagedObjectReference morDs = hyperHost.findDatastoreByName(baseName);	if (morDs != null) {	return morDs;	}	}	catch (Exception ex) {	
ignored error getting managed object refference 

vmMo = hyperHost.findVmOnHyperHost(vmName);	if (vmMo == null) {	vmMo = hyperHost.findVmOnPeerHyperHost(vmName);	}	if (vmMo == null) {	String msg = "Unable to find VM for RevertToVMSnapshotCommand";	s_logger.debug(msg);	return new DeleteVMSnapshotAnswer(cmd, false, msg);	} else {	if (vmMo.getSnapshotMor(vmSnapshotName) == null) {	
can not find the snapshot assume it is already removed 

return new DeleteVMSnapshotAnswer(cmd, false, msg);	} else {	if (vmMo.getSnapshotMor(vmSnapshotName) == null) {	} else {	if (!vmMo.removeSnapshot(vmSnapshotName, false)) {	String msg = "delete vm snapshot " + vmSnapshotName + " due to error occured in vmware";	s_logger.error(msg);	return new DeleteVMSnapshotAnswer(cmd, false, msg);	}	}	
snapshot is removed 

s_logger.error(msg);	return new DeleteVMSnapshotAnswer(cmd, false, msg);	}	}	Map<String, String> mapNewDisk = getNewDiskMap(vmMo);	setVolumeToPathAndSize(listVolumeTo, mapNewDisk, context, hyperHost, cmd.getVmName());	return new DeleteVMSnapshotAnswer(cmd, listVolumeTo);	}	} catch (Exception e) {	String msg = e.getMessage();	
failed to delete vm snapshot of vm due to 

VirtualMachine.PowerState vmState = VirtualMachine.PowerState.PowerOn;	VirtualMachineMO vmMo = null;	VmwareContext context = hostService.getServiceContext(cmd);	try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	ManagedObjectReference taskmgr = context.getServiceContent().getTaskManager();	List<ManagedObjectReference> tasks = context.getVimClient().getDynamicProperty(taskmgr, "recentTask");	for (ManagedObjectReference taskMor : tasks) {	TaskInfo info = (TaskInfo)(context.getVimClient().getDynamicProperty(taskMor, "info"));	if (info.getEntityName().equals(cmd.getVmName()) && StringUtils.isNotBlank(info.getName()) && info.getName().equalsIgnoreCase("RevertToSnapshot_Task")) {	
there is already a vm snapshot task running wait for it 

========================= cloudstack sample_1308 =========================

}	Gson gson = ApiGsonHelper.getBuilder().create();	Object obj = gson.fromJson(content, clz);	if (nameField != null) {	((ResponseObject)obj).setObjectName(nameField);	}	return obj;	}	return null;	} catch (RuntimeException e) {	
caught runtime exception when doing gson deserialization on 

========================= cloudstack sample_2524 =========================

Event event = new Event(eventSource, eventCategory, eventType, resourceType, resourceUUID);	event.setDescription(new String(body));	subscriber.onEvent(event);	}	}	});	Ternary<String, Channel, EventSubscriber> queueDetails = s_subscribers.get(queueName);	queueDetails.second(channel);	s_subscribers.put(queueName, queueDetails);	} catch (AlreadyClosedException closedException) {	
connection to amqp service is lost subscription will be active after reconnection 

event.setDescription(new String(body));	subscriber.onEvent(event);	}	}	});	Ternary<String, Channel, EventSubscriber> queueDetails = s_subscribers.get(queueName);	queueDetails.second(channel);	s_subscribers.put(queueName, queueDetails);	} catch (AlreadyClosedException closedException) {	} catch (ConnectException connectException) {	
connection to amqp service is lost subscription will be active after reconnection 

private synchronized Connection getConnection() throws Exception {	if (s_connection == null) {	try {	return createConnection();	} catch (Exception e) {	
failed to create a connection to amqp server due to 

private synchronized void closeConnection() {	try {	if (s_connection != null) {	s_connection.close();	}	} catch (Exception e) {	
failed to close connection to amqp server due to 

private synchronized void abortConnection() {	if (s_connection == null) return;	try {	s_connection.abort();	} catch (Exception e) {	
failed to abort connection due to 

private Channel createChannel(Connection connection) throws Exception {	try {	return connection.createChannel();	} catch (java.io.IOException exception) {	
failed to create a channel due to 

private void createExchange(Channel channel, String exchangeName) throws Exception {	try {	channel.exchangeDeclare(exchangeName, "topic", true);	} catch (java.io.IOException exception) {	
failed to create exchange on rabbitmq server 

private void publishEventToExchange(Channel channel, String exchangeName, String routingKey, String eventDescription) throws Exception {	try {	byte[] messageBodyBytes = eventDescription.getBytes();	channel.basicPublish(exchangeName, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);	} catch (Exception e) {	
failed to publish event on exchange of message broker due to 

public synchronized boolean stop() {	if (s_connection.isOpen()) {	for (String subscriberId : s_subscribers.keySet()) {	Ternary<String, Channel, EventSubscriber> subscriberDetails = s_subscribers.get(subscriberId);	Channel channel = subscriberDetails.second();	String queueName = subscriberId;	try {	channel.queueDelete(queueName);	channel.abort();	} catch (IOException ioe) {	
failed to delete queue on amqp server due to 

public void handleBlocked(String reason) throws IOException {	
rabbitmq connection is blocked with reason 

public void handleUnblocked() throws IOException {	
rabbitmq connection in unblocked 

public void shutdownCompleted(ShutdownSignalException shutdownSignalException) {	if (!shutdownSignalException.isInitiatedByApplication()) {	for (String subscriberId : s_subscribers.keySet()) {	Ternary<String, Channel, EventSubscriber> subscriberDetails = s_subscribers.get(subscriberId);	subscriberDetails.second(null);	s_subscribers.put(subscriberId, subscriberDetails);	}	abortConnection();	
connection has been shutdown by amqp server attempting to reconnect 

Event event = new Event(eventSource, eventCategory, eventType, resourceType, resourceUUID);	event.setDescription(new String(body));	subscriber.onEvent(event);	}	}	});	subscriberDetails.second(channel);	s_subscribers.put(subscriberId, subscriberDetails);	}	} catch (Exception e) {	
failed to recreate queues and binding for the subscribers due to 

========================= cloudstack sample_2031 =========================

tagsToRemove.add(resourceTag);	}	}	if (tagsToRemove.isEmpty()) {	throw new InvalidParameterValueException("Unable to find tags by parameters specified");	}	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	for (ResourceTag tagToRemove : tagsToRemove) {	_resourceTagDao.remove(tagToRemove.getId());	
removed the tag 

========================= cloudstack sample_2461 =========================

public synchronized List<UsageEventVO> getRecentEvents(Date endDate) {	long recentEventId = getMostRecentEventId();	long maxEventId = getMaxEventId(endDate);	TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);	String sql = COPY_EVENTS;	if (recentEventId == 0) {	if (s_logger.isDebugEnabled()) {	
no recent event date copying all events 

pstmt = txn.prepareAutoCloseStatement(sql);	int i = 1;	if (recentEventId != 0) {	pstmt.setLong(i++, recentEventId);	}	pstmt.setLong(i++, maxEventId);	pstmt.executeUpdate();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error copying events from cloud db to usage db 

txn.commit();	} catch (Exception ex) {	txn.rollback();	throw new CloudRuntimeException(ex.getMessage());	} finally {	txn.close();	}	sql = COPY_EVENT_DETAILS;	if (recentEventId == 0) {	if (s_logger.isDebugEnabled()) {	
no recent event date copying all event detailss 

pstmt = txn.prepareAutoCloseStatement(sql);	int i = 1;	if (recentEventId != 0) {	pstmt.setLong(i++, recentEventId);	}	pstmt.setLong(i++, maxEventId);	pstmt.executeUpdate();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error copying event details from cloud db to usage db 

try {	List<UsageEventVO> latestEvents = getLatestEvent();	if (latestEvents != null && latestEvents.size() == 1) {	UsageEventVO latestEvent = latestEvents.get(0);	if (latestEvent != null) {	return latestEvent.getId();	}	}	return 0;	} catch (Exception ex) {	
error getting most recent event id 

private List<UsageEventVO> findRecentEvents(Date endDate) {	TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);	try {	return listLatestEvents(endDate);	} catch (Exception ex) {	
error getting most recent event date 

try {	String sql = MAX_EVENT;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), endDate));	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	return Long.valueOf(rs.getLong(1));	}	return 0;	} catch (Exception ex) {	
error getting max event id 

========================= cloudstack sample_4720 =========================

getNewIp = true;	}	}	}	if (getNewIp) {	getBaremetalIp(nic, dest.getPod(), vm, network, intentIp);	}	DataCenter dc = _dcDao.findById(network.getDataCenterId());	nic.setIPv4Dns1(dc.getDns1());	nic.setIPv4Dns2(dc.getDns2());	
allocated a nic for 

private void getBaremetalIp(NicProfile nic, Pod pod, VirtualMachineProfile vm, Network network, String requiredIp) throws InsufficientAddressCapacityException, ConcurrentOperationException {	DataCenter dc = _dcDao.findById(pod.getDataCenterId());	if (nic.getIPv4Address() == null) {	
requiring ip address s 

========================= cloudstack sample_916 =========================

public void run() {	while (true) {	Script myScript = new Script("wget");	myScript.add(command);	myScript.execute();	long begin = System.currentTimeMillis();	WgetInt process = new WgetInt();	String response = myScript.execute(process);	long end = process.getEnd();	if (response != null) {	
content lenght is incorrect 

String response = myScript.execute(process);	long end = process.getEnd();	if (response != null) {	}	long duration = (end - begin);	this.connectionsMade++;	this.responseTime = this.responseTime + duration;	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted 

========================= cloudstack sample_445 =========================

final Answer answer = agentMgr.easySend(hostId, cmd);	if (answer == null) {	throw new CloudRuntimeException("Unable to get an answer to the modify storage pool command" + pool.getId());	}	if (!answer.getResult()) {	String msg = "Unable to attach storage pool" + poolId + " to the host" + hostId;	alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST,pool.getDataCenterId(), pool.getPodId(), msg, msg);	throw new CloudRuntimeException("Unable establish connection from storage head to storage pool " + pool.getId() + " due to " + answer.getDetails() + pool.getId());	}	assert (answer instanceof ModifyStoragePoolAnswer) : "Well, now why won't you actually return the ModifyStoragePoolAnswer when it's ModifyStoragePoolCommand? Pool=" + pool.getId() + "Host=" + hostId;	
connection established between host 

========================= cloudstack sample_1934 =========================

private boolean canHandle(Network config, Service service) {	DataCenter zone = _dcDao.findById(config.getDataCenterId());	boolean handleInAdvanceZone = (zone.getNetworkType() == NetworkType.Advanced && (config.getGuestType() == Network.GuestType.Isolated || config.getGuestType() == Network.GuestType.Shared) && config.getTrafficType() == TrafficType.Guest);	boolean handleInBasicZone = (zone.getNetworkType() == NetworkType.Basic && config.getGuestType() == Network.GuestType.Shared && config.getTrafficType() == TrafficType.Guest);	if (!(handleInAdvanceZone || handleInBasicZone)) {	
not handling network with type and traffic type in zone of type 

public boolean implement(Network guestConfig, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ResourceUnavailableException, ConcurrentOperationException, InsufficientNetworkCapacityException {	if (!canHandle(guestConfig, Service.Lb)) {	return false;	}	if (_ntwkSrvcDao.canProviderSupportServiceInNetwork(guestConfig.getId(), Service.StaticNat, Network.Provider.Netscaler) && !isBasicZoneNetwok(guestConfig)) {	
netscaler provider can not be static nat service provider for the network and traffic type 

public boolean verifyServicesCombination(Set<Service> services) {	Set<Service> netscalerServices = new HashSet<Service>();	netscalerServices.add(Service.Lb);	netscalerServices.add(Service.StaticNat);	if (services != null && !services.isEmpty() && !netscalerServices.containsAll(services)) {	
netscaler network element can only support lb and static nat services and service combination is not supported 

public boolean verifyServicesCombination(Set<Service> services) {	Set<Service> netscalerServices = new HashSet<Service>();	netscalerServices.add(Service.Lb);	netscalerServices.add(Service.StaticNat);	if (services != null && !services.isEmpty() && !netscalerServices.containsAll(services)) {	StringBuffer buff = new StringBuffer();	for (Service service : services) {	buff.append(service.getName());	buff.append(" ");	}	
netscaler network element can only support lb and static nat services and service combination is not supported 

public boolean verifyServicesCombination(Set<Service> services) {	Set<Service> netscalerServices = new HashSet<Service>();	netscalerServices.add(Service.Lb);	netscalerServices.add(Service.StaticNat);	if (services != null && !services.isEmpty() && !netscalerServices.containsAll(services)) {	StringBuffer buff = new StringBuffer();	for (Service service : services) {	buff.append(service.getName());	buff.append(" ");	}	
netscaler network element can only support lb and static nat services and service combination is not supported 

String errMsg = "Failed to configure INAT rule on NetScaler device " + lbDevice.getHostId();	s_logger.error(errMsg);	throw new ResourceUnavailableException(errMsg, this.getClass(), 0);	}	}	return true;	}	}	return true;	} catch (Exception e) {	
failed to configure staticnat rule due to 

public List<LoadBalancerTO> getElasticLBRulesHealthCheck(Network network, List<LoadBalancingRule> loadBalancingRules) throws ResourceUnavailableException {	HealthCheckLBConfigAnswer answer = null;	if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {	return null;	}	String errMsg = null;	ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);	if (lbDeviceVO == null) {	
there is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning 

public List<LoadBalancerTO> updateHealthChecks(Network network, List<LoadBalancingRule> lbrules) {	if (canHandle(network, Service.Lb) && canHandleLbRules(lbrules)) {	try {	if (isBasicZoneNetwok(network)) {	return getElasticLBRulesHealthCheck(network, lbrules);	} else {	return getLBHealthChecks(network, lbrules);	}	} catch (ResourceUnavailableException e) {	
error in getting the lb rules from netscaler 

if (canHandle(network, Service.Lb) && canHandleLbRules(lbrules)) {	try {	if (isBasicZoneNetwok(network)) {	return getElasticLBRulesHealthCheck(network, lbrules);	} else {	return getLBHealthChecks(network, lbrules);	}	} catch (ResourceUnavailableException e) {	}	} else {	
network cannot handle to lb service 

private boolean canHandleLbRules(List<LoadBalancingRule> rules) {	Map<Capability, String> lbCaps = this.getCapabilities().get(Service.Lb);	if (!lbCaps.isEmpty()) {	String schemeCaps = lbCaps.get(Capability.LbSchemes);	if (schemeCaps != null) {	for (LoadBalancingRule rule : rules) {	if (!schemeCaps.contains(rule.getScheme().toString())) {	
scheme is not supported by the provider 

========================= cloudstack sample_1467 =========================

public DataCenterVO findByTokenOrIdOrName(String tokenOrIdOrName) {	DataCenterVO result = findByToken(tokenOrIdOrName);	if (result == null) {	result = findByName(tokenOrIdOrName);	if (result == null) {	try {	Long dcId = Long.parseLong(tokenOrIdOrName);	return findById(dcId);	} catch (NumberFormatException nfe) {	
cannot parse into long 

========================= cloudstack sample_4665 =========================

String preSharedKey = selectResultSet.getString(2);	try (PreparedStatement updateStatement = conn.prepareStatement("UPDATE cloud.keystore ks SET ks.key = ? WHERE ks.id = ?");) {	updateStatement.setString(1, DBEncryptionUtil.encrypt(preSharedKey));	updateStatement.setLong(2, keyId);	updateStatement.executeUpdate();	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while encrypting key column in keystore table", e);	}	
done encrypting keystore s key column 

}	try (PreparedStatement updateStatement = conn.prepareStatement("UPDATE `cloud`.`remote_access_vpn` SET ipsec_psk=? WHERE id=?");) {	updateStatement.setString(1, DBEncryptionUtil.encrypt(preSharedKey));	updateStatement.setLong(2, rowId);	updateStatement.executeUpdate();	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to update the remote_access_vpn's preshared key ipsec_psk column", e);	}	
done encrypting remote access vpn s ipsec psk column 

}	preparedStatement.setLong(2, id);	preparedStatement.executeUpdate();	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt storage pool user info ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt storage pool user info ", e);	}	
done encrypting storage pool s user info column 

private void updateUserVmDetailsWithNicAdapterType(Connection conn) {	try (PreparedStatement insertPstmt = conn.prepareStatement("INSERT INTO `cloud`.`user_vm_details`(vm_id,name,value,display) select v.id as vm_id, details.name, details.value, details.display from `cloud`.`vm_instance` as v, `cloud`.`vm_template_details` as details  where v.removed is null and v.vm_template_id=details.template_id and details.name='nicAdapter' and details.template_id in (select id from `cloud`.`vm_template` where hypervisor_type = 'vmware') and v.id not in (select vm_id from `cloud`.`user_vm_details` where name='nicAdapter');");) {	insertPstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Failed to update user_vm_details table with nicAdapter entries by copying from vm_template_detail table", e);	}	
done updated user vm details table with nicadapter entries by copying from vm template detail table this affects only vm templates with hypervisor type as vmware 

private void upgradeVMWareLocalStorage(Connection conn) {	try (PreparedStatement updatePstmt = conn.prepareStatement("UPDATE storage_pool SET pool_type='VMFS',host_address=@newaddress WHERE (@newaddress:=concat('VMFS datastore: ', path)) IS NOT NULL AND scope = 'HOST' AND pool_type = 'LVM' AND id IN (SELECT * FROM (SELECT storage_pool.id FROM storage_pool,cluster WHERE storage_pool.cluster_id = cluster.id AND cluster.hypervisor_type='VMware') AS t);");) {	updatePstmt.executeUpdate();	
done upgraded vmware local storage pool type to vmfs and host address to the vmfs format 

========================= cloudstack sample_4235 =========================

public Boolean fenceOff(VirtualMachine vm, Host host) {	VirtualMachine.Type type = vm.getType();	if (type != VirtualMachine.Type.ConsoleProxy && type != VirtualMachine.Type.DomainRouter && type != VirtualMachine.Type.SecondaryStorageVm) {	if (s_logger.isDebugEnabled()) {	
don t know how to fence off 

VirtualMachine.Type type = vm.getType();	if (type != VirtualMachine.Type.ConsoleProxy && type != VirtualMachine.Type.DomainRouter && type != VirtualMachine.Type.SecondaryStorageVm) {	if (s_logger.isDebugEnabled()) {	}	return null;	}	List<VolumeVO> vols = _volsDao.findByInstance(vm.getId());	for (VolumeVO vol : vols) {	if (!vol.isRecreatable()) {	if (s_logger.isDebugEnabled()) {	
unable to fence off volumes that are not recreatable 

}	List<VolumeVO> vols = _volsDao.findByInstance(vm.getId());	for (VolumeVO vol : vols) {	if (!vol.isRecreatable()) {	if (s_logger.isDebugEnabled()) {	}	return null;	}	if (vol.getPoolType().isShared()) {	if (s_logger.isDebugEnabled()) {	
unable to fence off volumes that are shared 

========================= cloudstack sample_2498 =========================

ImageStoreResponse storeResponse = null;	if (result != null) {	storeResponse = _responseGenerator.createImageStoreResponse(result);	storeResponse.setResponseName(getCommandName());	storeResponse.setObjectName("secondarystorage");	setResponseObject(storeResponse);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add Swift secondary storage");	}	} catch (DiscoveryException ex) {	
exception 

========================= cloudstack sample_3266 =========================

public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {	if ((certificates != null) && LOG.isDebugEnabled()) {	
server certificate chain 

========================= cloudstack sample_2709 =========================

public boolean prepare(final Network network, final NicProfile nic, final VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!isTypeSupported(vm.getType())) {	
globodns only manages records for vms of type user consoleproxy and domainrouter vm is 

public boolean release(final Network network, NicProfile nic, final VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	if (!isTypeSupported(vm.getType())) {	
globodns only manages records for vms of type user consoleproxy and domainrouter vm is 

========================= cloudstack sample_1826 =========================

HostResponse hostResponse = _responseGenerator.createHostResponse(host);	hostResponses.add(hostResponse);	}	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add host");	}	response.setResponses(hostResponses);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} catch (DiscoveryException ex) {	
exception 

========================= cloudstack sample_3118 =========================

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	
ping timeout is 

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	final int threads = DirectAgentLoadSize.value();	_nodeId = ManagementServerNode.getManagementServerId();	
configuring agentmanagerimpl management server node id msid 

final int threads = DirectAgentLoadSize.value();	_nodeId = ManagementServerNode.getManagementServerId();	final long lastPing = (System.currentTimeMillis() >> 10) - (long) (PingTimeout.value() * PingInterval.value());	_hostDao.markHostsAsDisconnected(_nodeId, lastPing);	registerForHostEvents(new BehindOnPingListener(), true, true, false);	registerForHostEvents(new SetHostParamsListener(), true, true, false);	_executor = new ThreadPoolExecutor(threads, threads, 60l, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("AgentTaskPool"));	_connectExecutor = new ThreadPoolExecutor(100, 500, 60l, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("AgentConnectTaskPool"));	_connectExecutor.allowCoreThreadTimeOut(true);	_connection = new NioServer("AgentManager", Port.value(), Workers.value() + 10, this);	
listening on with workers 

final long lastPing = (System.currentTimeMillis() >> 10) - (long) (PingTimeout.value() * PingInterval.value());	_hostDao.markHostsAsDisconnected(_nodeId, lastPing);	registerForHostEvents(new BehindOnPingListener(), true, true, false);	registerForHostEvents(new SetHostParamsListener(), true, true, false);	_executor = new ThreadPoolExecutor(threads, threads, 60l, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("AgentTaskPool"));	_connectExecutor = new ThreadPoolExecutor(100, 500, 60l, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("AgentConnectTaskPool"));	_connectExecutor.allowCoreThreadTimeOut(true);	_connection = new NioServer("AgentManager", Port.value(), Workers.value() + 10, this);	_directAgentExecutor = new ScheduledThreadPoolExecutor(DirectAgentPoolSize.value(), new NamedThreadFactory("DirectAgent"));	_cronJobExecutor = new ScheduledThreadPoolExecutor(DirectAgentPoolSize.value(), new NamedThreadFactory("DirectAgentCronJob"));	
created directagentattache pool with size 

}	}	if (commands) {	if (priority) {	_cmdMonitors.add(0, new Pair<Integer, Listener>(_monitorId, listener));	} else {	_cmdMonitors.add(new Pair<Integer, Listener>(_monitorId, listener));	}	}	if (s_logger.isDebugEnabled()) {	
registering listener with id 

public void unregisterForHostEvents(final int id) {	
deregistering 

private AgentControlAnswer handleControlCommand(final AgentAttache attache, final AgentControlCommand cmd) {	AgentControlAnswer answer = null;	for (final Pair<Integer, Listener> listener : _cmdMonitors) {	answer = listener.second().processControlCommand(attache.getId(), cmd);	if (answer != null) {	return answer;	}	}	
no handling of agent control command sent from 

public void handleCommands(final AgentAttache attache, final long sequence, final Command[] cmds) {	for (final Pair<Integer, Listener> listener : _cmdMonitors) {	final boolean processed = listener.second().processCommands(attache.getId(), sequence, cmds);	if (s_logger.isTraceEnabled()) {	
seqa processed not processed by 

public Answer send(final Long hostId, final Command cmd) throws AgentUnavailableException, OperationTimedoutException {	final Commands cmds = new Commands(Command.OnError.Stop);	cmds.addCommand(cmd);	send(hostId, cmds, cmd.getWait());	final Answer[] answers = cmds.getAnswers();	if (answers != null && !(answers[0] instanceof UnsupportedAnswer)) {	return answers[0];	}	if (answers != null && answers[0] instanceof UnsupportedAnswer) {	
unsupported command 

protected Status investigate(final AgentAttache agent) {	final Long hostId = agent.getId();	final HostVO host = _hostDao.findById(hostId);	if (host != null && host.getType() != null && !host.getType().isVirtual()) {	if (s_logger.isDebugEnabled()) {	
checking if agent is alive 

protected Status investigate(final AgentAttache agent) {	final Long hostId = agent.getId();	final HostVO host = _hostDao.findById(hostId);	if (host != null && host.getType() != null && !host.getType().isVirtual()) {	if (s_logger.isDebugEnabled()) {	}	final Answer answer = easySend(hostId, new CheckHealthCommand());	if (answer != null && answer.getResult()) {	final Status status = Status.Up;	if (s_logger.isDebugEnabled()) {	
agent responded to checkheathcommand reporting that agent is 

protected AgentAttache getAttache(final Long hostId) throws AgentUnavailableException {	if (hostId == null) {	return null;	}	final AgentAttache agent = findAttache(hostId);	if (agent == null) {	
unable to find agent for 

public void removeAgent(final AgentAttache attache, final Status nextState) {	if (attache == null) {	return;	}	final long hostId = attache.getId();	if (s_logger.isDebugEnabled()) {	
remove agent 

boolean conflict = false;	synchronized (_agents) {	removed = _agents.remove(hostId);	if (removed != null && removed != attache) {	conflict = true;	_agents.put(hostId, removed);	removed = attache;	}	}	if (conflict) {	
agent for host is created when it is being disconnected 

removed = attache;	}	}	if (conflict) {	}	if (removed != null) {	removed.disconnect(nextState);	}	for (final Pair<Integer, Listener> monitor : _hostMonitors) {	if (s_logger.isDebugEnabled()) {	
sending disconnect to listener 

public void notifyMonitorsOfNewlyAddedHost(long hostId) {	for (final Pair<Integer, Listener> monitor : _hostMonitors) {	if (s_logger.isDebugEnabled()) {	
sending host added to listener 

protected AgentAttache notifyMonitorsOfConnection(final AgentAttache attache, final StartupCommand[] cmd, final boolean forRebalance) throws ConnectionException {	final long hostId = attache.getId();	final HostVO host = _hostDao.findById(hostId);	for (final Pair<Integer, Listener> monitor : _hostMonitors) {	if (s_logger.isDebugEnabled()) {	
sending connect to listener 

for (final Pair<Integer, Listener> monitor : _hostMonitors) {	if (s_logger.isDebugEnabled()) {	}	for (int i = 0; i < cmd.length; i++) {	try {	monitor.second().processConnect(host, cmd[i], forRebalance);	} catch (final Exception e) {	if (e instanceof ConnectionException) {	final ConnectionException ce = (ConnectionException) e;	if (ce.isSetupError()) {	
monitor says there is an error in the connect process for due to 

for (int i = 0; i < cmd.length; i++) {	try {	monitor.second().processConnect(host, cmd[i], forRebalance);	} catch (final Exception e) {	if (e instanceof ConnectionException) {	final ConnectionException ce = (ConnectionException) e;	if (ce.isSetupError()) {	handleDisconnectWithoutInvestigation(attache, Event.AgentDisconnected, true, true);	throw ce;	} else {	
monitor says not to continue the connect process for due to 

handleDisconnectWithoutInvestigation(attache, Event.AgentDisconnected, true, true);	throw ce;	} else {	handleDisconnectWithoutInvestigation(attache, Event.ShutdownRequested, true, true);	return attache;	}	} else if (e instanceof HypervisorVersionChangedException) {	handleDisconnectWithoutInvestigation(attache, Event.ShutdownRequested, true, true);	throw new CloudRuntimeException("Unable to connect " + attache.getId(), e);	} else {	
monitor says there is an error in the connect process for due to 

public boolean start() {	startDirectlyConnectedHosts();	if (_connection != null) {	try {	_connection.start();	} catch (final NioConnectionException e) {	
error when connecting to the nioserver 

private ServerResource loadResourcesWithoutHypervisor(final HostVO host) {	final String resourceName = host.getResource();	ServerResource resource = null;	try {	final Class<?> clazz = Class.forName(resourceName);	final Constructor<?> constructor = clazz.getConstructor();	resource = (ServerResource) constructor.newInstance();	} catch (final ClassNotFoundException e) {	
unable to find class 

private ServerResource loadResourcesWithoutHypervisor(final HostVO host) {	final String resourceName = host.getResource();	ServerResource resource = null;	try {	final Class<?> clazz = Class.forName(resourceName);	final Constructor<?> constructor = clazz.getConstructor();	resource = (ServerResource) constructor.newInstance();	} catch (final ClassNotFoundException e) {	} catch (final InstantiationException e) {	
unablet to instantiate class 

private ServerResource loadResourcesWithoutHypervisor(final HostVO host) {	final String resourceName = host.getResource();	ServerResource resource = null;	try {	final Class<?> clazz = Class.forName(resourceName);	final Constructor<?> constructor = clazz.getConstructor();	resource = (ServerResource) constructor.newInstance();	} catch (final ClassNotFoundException e) {	} catch (final InstantiationException e) {	} catch (final IllegalAccessException e) {	
illegal access 

final String resourceName = host.getResource();	ServerResource resource = null;	try {	final Class<?> clazz = Class.forName(resourceName);	final Constructor<?> constructor = clazz.getConstructor();	resource = (ServerResource) constructor.newInstance();	} catch (final ClassNotFoundException e) {	} catch (final InstantiationException e) {	} catch (final IllegalAccessException e) {	} catch (final SecurityException e) {	
security error on 

ServerResource resource = null;	try {	final Class<?> clazz = Class.forName(resourceName);	final Constructor<?> constructor = clazz.getConstructor();	resource = (ServerResource) constructor.newInstance();	} catch (final ClassNotFoundException e) {	} catch (final InstantiationException e) {	} catch (final IllegalAccessException e) {	} catch (final SecurityException e) {	} catch (final NoSuchMethodException e) {	
nosuchmethodexception error on 

try {	final Class<?> clazz = Class.forName(resourceName);	final Constructor<?> constructor = clazz.getConstructor();	resource = (ServerResource) constructor.newInstance();	} catch (final ClassNotFoundException e) {	} catch (final InstantiationException e) {	} catch (final IllegalAccessException e) {	} catch (final SecurityException e) {	} catch (final NoSuchMethodException e) {	} catch (final IllegalArgumentException e) {	
illegalargumentexception error on 

final Class<?> clazz = Class.forName(resourceName);	final Constructor<?> constructor = clazz.getConstructor();	resource = (ServerResource) constructor.newInstance();	} catch (final ClassNotFoundException e) {	} catch (final InstantiationException e) {	} catch (final IllegalAccessException e) {	} catch (final SecurityException e) {	} catch (final NoSuchMethodException e) {	} catch (final IllegalArgumentException e) {	} catch (final InvocationTargetException e) {	
invocationtargetexception error on 

}	if (guid != null && !guid.isEmpty()) {	params.put("pool", guid);	}	}	params.put("ipaddress", host.getPrivateIpAddress());	params.put("secondary.storage.vm", "false");	try {	resource.configure(host.getName(), params);	} catch (final ConfigurationException e) {	
unable to configure resource due to 

}	}	params.put("ipaddress", host.getPrivateIpAddress());	params.put("secondary.storage.vm", "false");	try {	resource.configure(host.getName(), params);	} catch (final ConfigurationException e) {	return null;	}	if (!resource.start()) {	
unable to start the resource 

protected boolean loadDirectlyConnectedHost(final HostVO host, final boolean forRebalance) {	boolean initialized = false;	ServerResource resource = null;	try {	final Discoverer discoverer = _resourceMgr.getMatchingDiscover(host.getHypervisorType());	if (discoverer == null) {	
could not to find a discoverer to load the resource for hypervisor type 

boolean initialized = false;	ServerResource resource = null;	try {	final Discoverer discoverer = _resourceMgr.getMatchingDiscover(host.getHypervisorType());	if (discoverer == null) {	resource = loadResourcesWithoutHypervisor(host);	} else {	resource = discoverer.reloadResource(host);	}	if (resource == null) {	
unable to load the resource 

protected AgentAttache createAttacheForDirectConnect(final Host host, final ServerResource resource) throws ConnectionException {	
create directagentattache for 

public boolean stop() {	if (_connection != null) {	_connection.stop();	}	
disconnecting agents 

public boolean stop() {	if (_connection != null) {	_connection.stop();	}	synchronized (_agents) {	for (final AgentAttache agent : _agents.values()) {	final HostVO host = _hostDao.findById(agent.getId());	if (host == null) {	if (s_logger.isDebugEnabled()) {	
cant not find host 

protected boolean handleDisconnectWithoutInvestigation(final AgentAttache attache, final Status.Event event, final boolean transitState, final boolean removeAgent) {	final long hostId = attache.getId();	
host is disconnecting with event 

protected boolean handleDisconnectWithoutInvestigation(final AgentAttache attache, final Status.Event event, final boolean transitState, final boolean removeAgent) {	final long hostId = attache.getId();	Status nextStatus = null;	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	
can t find host with 

protected boolean handleDisconnectWithoutInvestigation(final AgentAttache attache, final Status.Event event, final boolean transitState, final boolean removeAgent) {	final long hostId = attache.getId();	Status nextStatus = null;	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	nextStatus = Status.Removed;	} else {	final Status currentStatus = host.getStatus();	if (currentStatus == Status.Down || currentStatus == Status.Alert || currentStatus == Status.Removed) {	if (s_logger.isDebugEnabled()) {	
host is already 

nextStatus = currentStatus;	} else {	try {	nextStatus = currentStatus.getNextStatus(event);	} catch (final NoTransitionException e) {	final String err = "Cannot find next status for " + event + " as current status is " + currentStatus + " for agent " + hostId;	s_logger.debug(err);	throw new CloudRuntimeException(err);	}	if (s_logger.isDebugEnabled()) {	
the next status of agent is current status is 

} catch (final NoTransitionException e) {	final String err = "Cannot find next status for " + event + " as current status is " + currentStatus + " for agent " + hostId;	s_logger.debug(err);	throw new CloudRuntimeException(err);	}	if (s_logger.isDebugEnabled()) {	}	}	}	if (s_logger.isDebugEnabled()) {	
deregistering link for with state 

protected boolean handleDisconnectWithInvestigation(final AgentAttache attache, Status.Event event) {	final long hostId = attache.getId();	HostVO host = _hostDao.findById(hostId);	if (host != null) {	Status nextStatus = null;	try {	nextStatus = host.getStatus().getNextStatus(event);	} catch (final NoTransitionException ne) {	
caught exception while getting agent s next status 

protected boolean handleDisconnectWithInvestigation(final AgentAttache attache, Status.Event event) {	final long hostId = attache.getId();	HostVO host = _hostDao.findById(hostId);	if (host != null) {	Status nextStatus = null;	try {	nextStatus = host.getStatus().getNextStatus(event);	} catch (final NoTransitionException ne) {	}	if (nextStatus == Status.Alert) {	
investigating why host has disconnected with event 

if (host != null) {	Status nextStatus = null;	try {	nextStatus = host.getStatus().getNextStatus(event);	} catch (final NoTransitionException ne) {	}	if (nextStatus == Status.Alert) {	Status determinedState = investigate(attache);	if (determinedState == null) {	if ((System.currentTimeMillis() >> 10) - host.getLastPinged() > AlertWait.value()) {	
agent state cannot be determined for more than seconds will go to alert state 

try {	nextStatus = host.getStatus().getNextStatus(event);	} catch (final NoTransitionException ne) {	}	if (nextStatus == Status.Alert) {	Status determinedState = investigate(attache);	if (determinedState == null) {	if ((System.currentTimeMillis() >> 10) - host.getLastPinged() > AlertWait.value()) {	determinedState = Status.Alert;	} else {	
agent state cannot be determined do nothing 

if (nextStatus == Status.Alert) {	Status determinedState = investigate(attache);	if (determinedState == null) {	if ((System.currentTimeMillis() >> 10) - host.getLastPinged() > AlertWait.value()) {	determinedState = Status.Alert;	} else {	return false;	}	}	final Status currentStatus = host.getStatus();	
the agent from host state determined is 

}	final Status currentStatus = host.getStatus();	if (determinedState == Status.Down) {	final String message = "Host is down: " + host.getId() + "-" + host.getName() + ". Starting HA on the VMs";	s_logger.error(message);	if (host.getType() != Host.Type.SecondaryStorage && host.getType() != Host.Type.ConsoleProxy) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Host down, " + host.getId(), message);	}	event = Status.Event.HostDown;	} else if (determinedState == Status.Up) {	
agent is determined to be up and running 

final String message = "Host is down: " + host.getId() + "-" + host.getName() + ". Starting HA on the VMs";	s_logger.error(message);	if (host.getType() != Host.Type.SecondaryStorage && host.getType() != Host.Type.ConsoleProxy) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Host down, " + host.getId(), message);	}	event = Status.Event.HostDown;	} else if (determinedState == Status.Up) {	agentStatusTransitTo(host, Status.Event.Ping, _nodeId);	return false;	} else if (determinedState == Status.Disconnected) {	
agent is disconnected but the host is still up 

if (host.getType() != Host.Type.SecondaryStorage && host.getType() != Host.Type.ConsoleProxy) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Host down, " + host.getId(), message);	}	event = Status.Event.HostDown;	} else if (determinedState == Status.Up) {	agentStatusTransitTo(host, Status.Event.Ping, _nodeId);	return false;	} else if (determinedState == Status.Disconnected) {	if (currentStatus == Status.Disconnected) {	if ((System.currentTimeMillis() >> 10) - host.getLastPinged() > AlertWait.value()) {	
host has been disconnected past the wait time it should be disconnected 

}	event = Status.Event.HostDown;	} else if (determinedState == Status.Up) {	agentStatusTransitTo(host, Status.Event.Ping, _nodeId);	return false;	} else if (determinedState == Status.Disconnected) {	if (currentStatus == Status.Disconnected) {	if ((System.currentTimeMillis() >> 10) - host.getLastPinged() > AlertWait.value()) {	event = Status.Event.WaitedTooLong;	} else {	
host has been determined to be disconnected but it hasn t passed the wait time yet 

event = Status.Event.AgentDisconnected;	}	} else {	final DataCenterVO dcVO = _dcDao.findById(host.getDataCenterId());	final HostPodVO podVO = _podDao.findById(host.getPodId());	final String podName = podVO != null ? podVO.getName() : "NO POD";	final String hostDesc = "name: " + host.getName() + " (id:" + host.getId() + "), availability zone: " + dcVO.getName() + ", pod: " + podName;	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Host in ALERT state, " + hostDesc, "In availability zone " + host.getDataCenterId() + ", host is in alert state: " + host.getId() + "-" + host.getName());	}	} else {	
the next status of agent is not alert no need to investigate what happened 

protected void runInContext() {	try {	if (_investigate == true) {	handleDisconnectWithInvestigation(_attache, _event);	} else {	handleDisconnectWithoutInvestigation(_attache, _event, true, false);	}	} catch (final Exception e) {	
exception caught while handling disconnect 

public Answer easySend(final Long hostId, final Command cmd) {	try {	final Host h = _hostDao.findById(hostId);	if (h == null || h.getRemoved() != null) {	
host with id doesn t exist 

public Answer easySend(final Long hostId, final Command cmd) {	try {	final Host h = _hostDao.findById(hostId);	if (h == null || h.getRemoved() != null) {	return null;	}	final Status status = h.getStatus();	if (!status.equals(Status.Up) && !status.equals(Status.Connecting)) {	
can not send command due to host is not up 

final Host h = _hostDao.findById(hostId);	if (h == null || h.getRemoved() != null) {	return null;	}	final Status status = h.getStatus();	if (!status.equals(Status.Up) && !status.equals(Status.Connecting)) {	return null;	}	final Answer answer = send(hostId, cmd);	if (answer == null) {	
send returns null answer 

}	final Status status = h.getStatus();	if (!status.equals(Status.Up) && !status.equals(Status.Connecting)) {	return null;	}	final Answer answer = send(hostId, cmd);	if (answer == null) {	return null;	}	if (s_logger.isDebugEnabled() && answer.getDetails() != null) {	
details from executing 

if (answer == null) {	return null;	}	if (s_logger.isDebugEnabled() && answer.getDetails() != null) {	}	return answer;	} catch (final AgentUnavailableException e) {	s_logger.warn(e.getMessage());	return null;	} catch (final OperationTimedoutException e) {	
operation timed out 

}	if (s_logger.isDebugEnabled() && answer.getDetails() != null) {	}	return answer;	} catch (final AgentUnavailableException e) {	s_logger.warn(e.getMessage());	return null;	} catch (final OperationTimedoutException e) {	return null;	} catch (final Exception e) {	
exception while sending 

public boolean reconnect(final long hostId) {	HostVO host;	host = _hostDao.findById(hostId);	if (host == null || host.getRemoved() != null) {	
unable to find host 

public boolean reconnect(final long hostId) {	HostVO host;	host = _hostDao.findById(hostId);	if (host == null || host.getRemoved() != null) {	return false;	}	if (host.getStatus() == Status.Disconnected) {	
host is already disconnected no work to be done 

}	if (host.getStatus() == Status.Disconnected) {	return true;	}	if (host.getStatus() != Status.Up && host.getStatus() != Status.Alert && host.getStatus() != Status.Rebalancing) {	s_logger.info("Unable to disconnect host because it is not in the correct state: host=" + hostId + "; Status=" + host.getStatus());	return false;	}	final AgentAttache attache = findAttache(hostId);	if (attache == null) {	
unable to disconnect host because it is not connected to this server 

public void notifyMonitorsOfHostAboutToBeRemoved(long hostId) {	for (final Pair<Integer, Listener> monitor : _hostMonitors) {	if (s_logger.isDebugEnabled()) {	
sending host about to be removed to listener 

public void notifyMonitorsOfRemovedHost(long hostId, long clusterId) {	for (final Pair<Integer, Listener> monitor : _hostMonitors) {	if (s_logger.isDebugEnabled()) {	
sending host removed to listener 

public boolean executeUserRequest(final long hostId, final Event event) throws AgentUnavailableException {	if (event == Event.AgentDisconnected) {	if (s_logger.isDebugEnabled()) {	
received agent disconnect event for host 

protected AgentAttache createAttacheForConnect(final HostVO host, final Link link) throws ConnectionException {	
create connectedagentattache for 

AgentAttache attache = null;	ReadyCommand ready = null;	try {	final HostVO host = _resourceMgr.createHostVOForConnectedAgent(startup);	if (host != null) {	ready = new ReadyCommand(host.getDataCenterId(), host.getId());	attache = createAttacheForConnect(host, link);	attache = notifyMonitorsOfConnection(attache, startup, false);	}	} catch (final Exception e) {	
failed to handle host connection 

}	}	try {	if (attache == null) {	final Request readyRequest = new Request(-1, -1, ready, false);	link.send(readyRequest.getBytes());	} else {	easySend(attache.getId(), ready);	}	} catch (final Exception e) {	
failed to send ready command 

protected void runInContext() {	try {	if (s_logger.isDebugEnabled()) {	
simulating start for resource id 

protected void runInContext() {	try {	if (s_logger.isDebugEnabled()) {	}	if (tapLoadingAgents(id, TapAgentsAction.Add)) {	try {	final AgentAttache agentattache = findAttache(id);	if (agentattache == null) {	
creating agent for host 

protected void runInContext() {	try {	if (s_logger.isDebugEnabled()) {	}	if (tapLoadingAgents(id, TapAgentsAction.Add)) {	try {	final AgentAttache agentattache = findAttache(id);	if (agentattache == null) {	_resourceMgr.createHostAndAgent(id, resource, details, false, null, false);	
completed creating agent for host 

protected void runInContext() {	try {	if (s_logger.isDebugEnabled()) {	}	if (tapLoadingAgents(id, TapAgentsAction.Add)) {	try {	final AgentAttache agentattache = findAttache(id);	if (agentattache == null) {	_resourceMgr.createHostAndAgent(id, resource, details, false, null, false);	} else {	
agent already created in another thread for host ignore this 

try {	final AgentAttache agentattache = findAttache(id);	if (agentattache == null) {	_resourceMgr.createHostAndAgent(id, resource, details, false, null, false);	} else {	}	} finally {	tapLoadingAgents(id, TapAgentsAction.Del);	}	} else {	
agent creation already getting processed in another thread for host ignore this 

if (agentattache == null) {	_resourceMgr.createHostAndAgent(id, resource, details, false, null, false);	} else {	}	} finally {	tapLoadingAgents(id, TapAgentsAction.Del);	}	} else {	}	} catch (final Exception e) {	
unable to simulate start on resource name 

protected void runInContext() {	_request.logD("Processing the first command ");	final StartupCommand[] startups = new StartupCommand[_cmds.length];	for (int i = 0; i < _cmds.length; i++) {	startups[i] = (StartupCommand) _cmds[i];	}	final AgentAttache attache = handleConnectedAgent(_link, startups, _request);	if (attache == null) {	
unable to create attache for agent 

if (cmd instanceof StartupRoutingCommand || cmd instanceof StartupProxyCommand || cmd instanceof StartupSecondaryStorageCommand || cmd instanceof StartupStorageCommand) {	answers[i] = new StartupAnswer((StartupCommand) cmds[i], 0, getPingInterval());	break;	}	}	Response response = null;	response = new Response(request, answers[0], _nodeId, -1);	try {	link.send(response.toBytes());	} catch (final ClosedChannelException e) {	
failed to send startupanswer 

protected void processRequest(final Link link, final Request request) {	final AgentAttache attache = (AgentAttache) link.attachment();	final Command[] cmds = request.getCommands();	Command cmd = cmds[0];	boolean logD = true;	if (attache == null) {	if (!(cmd instanceof StartupCommand)) {	
throwing away a request because it came through as the first command on a connect 

request.logD("Scheduling the first command ");	connectAgent(link, cmds, request);	}	return;	}	final long hostId = attache.getId();	final String hostName = attache.getName();	if (s_logger.isDebugEnabled()) {	if (cmd instanceof PingRoutingCommand) {	logD = false;	
ping from 

request.logD("Scheduling the first command ");	connectAgent(link, cmds, request);	}	return;	}	final long hostId = attache.getId();	final String hostName = attache.getName();	if (s_logger.isDebugEnabled()) {	if (cmd instanceof PingRoutingCommand) {	logD = false;	
seqa processing 

}	return;	}	final long hostId = attache.getId();	final String hostName = attache.getName();	if (s_logger.isDebugEnabled()) {	if (cmd instanceof PingRoutingCommand) {	logD = false;	} else if (cmd instanceof PingCommand) {	logD = false;	
ping from 

}	return;	}	final long hostId = attache.getId();	final String hostName = attache.getName();	if (s_logger.isDebugEnabled()) {	if (cmd instanceof PingRoutingCommand) {	logD = false;	} else if (cmd instanceof PingCommand) {	logD = false;	
seqa processing 

return;	}	final long hostId = attache.getId();	final String hostName = attache.getName();	if (s_logger.isDebugEnabled()) {	if (cmd instanceof PingRoutingCommand) {	logD = false;	} else if (cmd instanceof PingCommand) {	logD = false;	} else {	
seqa processing 

answer = new StartupAnswer(startup, attache.getId(), getPingInterval());	} else if (cmd instanceof StartupSecondaryStorageCommand) {	final StartupSecondaryStorageCommand startup = (StartupSecondaryStorageCommand) cmd;	answer = new StartupAnswer(startup, attache.getId(), getPingInterval());	} else if (cmd instanceof StartupStorageCommand) {	final StartupStorageCommand startup = (StartupStorageCommand) cmd;	answer = new StartupAnswer(startup, attache.getId(), getPingInterval());	} else if (cmd instanceof ShutdownCommand) {	final ShutdownCommand shutdown = (ShutdownCommand) cmd;	final String reason = shutdown.getReason();	
host has informed us that it is shutting down with reason and detail 

}	} else {	s_logger.debug("Not processing " + PingRoutingCommand.class.getSimpleName() + " for agent id=" + cmdHostId + "; can't find the host in the DB");	}	}	answer = new PingAnswer((PingCommand) cmd);	} else if (cmd instanceof ReadyAnswer) {	final HostVO host = _hostDao.findById(attache.getId());	if (host == null) {	if (s_logger.isDebugEnabled()) {	
cant not find host 

if (host == null) {	if (s_logger.isDebugEnabled()) {	}	}	answer = new Answer(cmd);	} else {	answer = new Answer(cmd);	}	}	} catch (final Throwable th) {	
caught 

}	}	} catch (final Throwable th) {	answer = new Answer(cmd, false, th.getMessage());	}	answers[i] = answer;	}	final Response response = new Response(request, answers, _nodeId, attache.getId());	if (s_logger.isDebugEnabled()) {	if (logD) {	
seqa sending 

}	} catch (final Throwable th) {	answer = new Answer(cmd, false, th.getMessage());	}	answers[i] = answer;	}	final Response response = new Response(request, answers, _nodeId, attache.getId());	if (s_logger.isDebugEnabled()) {	if (logD) {	} else {	
seqa sending 

}	final Response response = new Response(request, answers, _nodeId, attache.getId());	if (s_logger.isDebugEnabled()) {	if (logD) {	} else {	}	}	try {	link.send(response.toBytes());	} catch (final ClosedChannelException e) {	
unable to send response because connection is closed 

protected void processResponse(final Link link, final Response response) {	final AgentAttache attache = (AgentAttache) link.attachment();	if (attache == null) {	
unable to process 

protected void processResponse(final Link link, final Response response) {	final AgentAttache attache = (AgentAttache) link.attachment();	if (attache == null) {	} else if (!attache.processAnswers(response.getSequence(), response)) {	
host seq response is not processed 

s_logger.error(message);	throw new TaskExecutionException(message, e);	}	} else if (type == Task.Type.CONNECT) {	} else if (type == Task.Type.DISCONNECT) {	final Link link = task.getLink();	final AgentAttache attache = (AgentAttache) link.attachment();	if (attache != null) {	disconnectWithInvestigation(attache, Event.AgentDisconnected);	} else {	
connection from closed but no cleanup was done 

protected boolean isHostOwnerSwitched(final long hostId) {	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	
can t find the host 

private void disconnectInternal(final long hostId, final Status.Event event, final boolean invstigate) {	final AgentAttache attache = findAttache(hostId);	if (attache != null) {	if (!invstigate) {	disconnectWithoutInvestigation(attache, event);	} else {	disconnectWithInvestigation(attache, event);	}	} else {	if (tapLoadingAgents(hostId, TapAgentsAction.Contains)) {	
host is being loaded so no disconnects needed 

public void pingBy(final long agentId) {	if (_pingMap.replace(agentId, InaccurateClock.getTimeInSeconds()) == null) {	
pingmap for agent will not be updated because agent is no longer in the pingmap 

protected void runInContext() {	
agent monitor is started 

protected void runInContext() {	try {	final List<Long> behindAgents = findAgentsBehindOnPing();	for (final Long agentId : behindAgents) {	final QueryBuilder<HostVO> sc = QueryBuilder.create(HostVO.class);	sc.and(sc.entity().getId(), Op.EQ, agentId);	final HostVO h = sc.find();	if (h != null) {	final ResourceState resourceState = h.getResourceState();	if (resourceState == ResourceState.Disabled || resourceState == ResourceState.Maintenance || resourceState == ResourceState.ErrorInMaintenance) {	
ping timeout but agent is in resource state of so no investigation 

final QueryBuilder<HostVO> sc = QueryBuilder.create(HostVO.class);	sc.and(sc.entity().getId(), Op.EQ, agentId);	final HostVO h = sc.find();	if (h != null) {	final ResourceState resourceState = h.getResourceState();	if (resourceState == ResourceState.Disabled || resourceState == ResourceState.Maintenance || resourceState == ResourceState.ErrorInMaintenance) {	disconnectWithoutInvestigation(agentId, Event.ShutdownRequested);	} else {	final HostVO host = _hostDao.findById(agentId);	if (host != null && (host.getType() == Host.Type.ConsoleProxy || host.getType() == Host.Type.SecondaryStorageVM || host.getType() == Host.Type.SecondaryStorageCmdExecutor)) {	
disconnect agent for cpvm ssvm due to physical connection close host 

final HostVO h = sc.find();	if (h != null) {	final ResourceState resourceState = h.getResourceState();	if (resourceState == ResourceState.Disabled || resourceState == ResourceState.Maintenance || resourceState == ResourceState.ErrorInMaintenance) {	disconnectWithoutInvestigation(agentId, Event.ShutdownRequested);	} else {	final HostVO host = _hostDao.findById(agentId);	if (host != null && (host.getType() == Host.Type.ConsoleProxy || host.getType() == Host.Type.SecondaryStorageVM || host.getType() == Host.Type.SecondaryStorageCmdExecutor)) {	disconnectWithoutInvestigation(agentId, Event.ShutdownRequested);	} else {	
ping timeout for agent do invstigation 

final List<HostVO> hosts = sc.list();	for (final HostVO host : hosts) {	if (_resourceMgr.checkAndMaintain(host.getId())) {	final DataCenterVO dcVO = _dcDao.findById(host.getDataCenterId());	final HostPodVO podVO = _podDao.findById(host.getPodId());	final String hostDesc = "name: " + host.getName() + " (id:" + host.getId() + "), availability zone: " + dcVO.getName() + ", pod: " + podVO.getName();	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Migration Complete for host " + hostDesc, "Host [" + hostDesc + "] is ready for maintenance");	}	}	} catch (final Throwable th) {	
caught the following exception 

for (final HostVO host : hosts) {	if (_resourceMgr.checkAndMaintain(host.getId())) {	final DataCenterVO dcVO = _dcDao.findById(host.getDataCenterId());	final HostPodVO podVO = _podDao.findById(host.getPodId());	final String hostDesc = "name: " + host.getName() + " (id:" + host.getId() + "), availability zone: " + dcVO.getName() + ", pod: " + podVO.getName();	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Migration Complete for host " + hostDesc, "Host [" + hostDesc + "] is ready for maintenance");	}	}	} catch (final Throwable th) {	}	
agent monitor is leaving the building 

protected List<Long> findAgentsBehindOnPing() {	final List<Long> agentsBehind = new ArrayList<Long>();	final long cutoffTime = InaccurateClock.getTimeInSeconds() - getTimeout();	for (final Map.Entry<Long, Long> entry : _pingMap.entrySet()) {	if (entry.getValue() < cutoffTime) {	agentsBehind.add(entry.getKey());	}	}	if (agentsBehind.size() > 0) {	
found the following agents behind on ping 

public void processConnect(final Host host, final StartupCommand cmd, final boolean forRebalance) {	if (cmd instanceof StartupRoutingCommand) {	if (((StartupRoutingCommand)cmd).getHypervisorType() == HypervisorType.KVM || ((StartupRoutingCommand)cmd).getHypervisorType() == HypervisorType.LXC) {	Map<String, String> params = new HashMap<String, String>();	params.put("router.aggregation.command.each.timeout", _configDao.getValue("router.aggregation.command.each.timeout"));	try {	SetHostParamsCommand cmds = new SetHostParamsCommand(params);	Commands c = new Commands(cmds);	send(host.getId(), c, this);	} catch (AgentUnavailableException e) {	
failed to send host params on host 

========================= cloudstack sample_4777 =========================

public Long persistCustomCertToDb(String certStr, CertificateVO cert, Long managementServerId) {	try {	cert.setCertificate(certStr);	cert.setUpdated("Y");	update(cert.getId(), cert);	return cert.getId();	} catch (Exception e) {	
unable to read the certificate 

========================= cloudstack sample_4262 =========================

}	}	final VolumeTO volume = new VolumeTO(command.getVolumeId(), dskch.getType(), pool.getType(), pool.getUuid(), pool.getPath(), vol.getName(), vol.getName(), disksize, null);	volume.setBytesReadRate(dskch.getBytesReadRate());	volume.setBytesWriteRate(dskch.getBytesWriteRate());	volume.setIopsReadRate(dskch.getIopsReadRate());	volume.setIopsWriteRate(dskch.getIopsWriteRate());	volume.setCacheMode(dskch.getCacheMode());	return new CreateAnswer(command, volume);	} catch (final CloudRuntimeException e) {	
failed to create volume 

========================= cloudstack sample_1060 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	
execute 

========================= cloudstack sample_1430 =========================

protected void init() throws IOException {	_selector = SelectorProvider.provider().openSelector();	_serverSocket = ServerSocketChannel.open();	_serverSocket.configureBlocking(false);	_localAddr = new InetSocketAddress(_port);	_serverSocket.socket().bind(_localAddr);	_serverSocket.register(_selector, SelectionKey.OP_ACCEPT, null);	
nioconnection started and listening on 

public void cleanUp() throws IOException {	super.cleanUp();	if (_serverSocket != null) {	_serverSocket.close();	}	
nioconnection stopped on 

========================= cloudstack sample_2836 =========================

try {	Site2SiteVpnConnection result = _s2sVpnService.resetVpnConnection(this);	if (result != null) {	Site2SiteVpnConnectionResponse response = _responseGenerator.createSite2SiteVpnConnectionResponse(result);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to reset site to site VPN connection");	}	} catch (ResourceUnavailableException ex) {	
exception 

========================= cloudstack sample_3374 =========================

Assert.assertEquals("unexpected parameter exception", "string 'bla:2' has an unknown BroadcastDomainType.", e.getMessage());	invalid = true;	}	try {	networkService.createPrivateNetwork("bla", "fake", 1, "mido: } catch (InvalidParameterValueException e) {	Assert.assertEquals("unexpected parameter exception", "unsupported type of broadcastUri specified: mido: unsupported = true;	}	Assert.assertEquals("'bla' should not be accepted as scheme", true, invalid);	Assert.assertEquals("'mido' should not yet be supported as scheme", true, unsupported);	} catch (ResourceAllocationException e) {	
no resources 

}	try {	networkService.createPrivateNetwork("bla", "fake", 1, "mido: } catch (InvalidParameterValueException e) {	Assert.assertEquals("unexpected parameter exception", "unsupported type of broadcastUri specified: mido: unsupported = true;	}	Assert.assertEquals("'bla' should not be accepted as scheme", true, invalid);	Assert.assertEquals("'mido' should not yet be supported as scheme", true, unsupported);	} catch (ResourceAllocationException e) {	fail("no resources");	} catch (ConcurrentOperationException e) {	
another one is in the way 

networkService.createPrivateNetwork("bla", "fake", 1, "mido: } catch (InvalidParameterValueException e) {	Assert.assertEquals("unexpected parameter exception", "unsupported type of broadcastUri specified: mido: unsupported = true;	}	Assert.assertEquals("'bla' should not be accepted as scheme", true, invalid);	Assert.assertEquals("'mido' should not yet be supported as scheme", true, unsupported);	} catch (ResourceAllocationException e) {	fail("no resources");	} catch (ConcurrentOperationException e) {	fail("another one is in the way");	} catch (InsufficientCapacityException e) {	
no capacity 

========================= cloudstack sample_2135 =========================

eventDescription.put("resource", resourceName);	eventDescription.put("id", vo.getUuid());	eventDescription.put("old-state", oldState.name());	eventDescription.put("new-state", newState.name());	String eventDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").format(new Date());	eventDescription.put("eventDateTime", eventDate);	eventMsg.setDescription(eventDescription);	try {	s_eventBus.publish(eventMsg);	} catch (EventBusException e) {	
failed to state change event on the the event bus 

========================= cloudstack sample_2420 =========================

private void heartbeat() {	synchronized (this) {	for (Map.Entry<Long, ActiveTaskRecord> entry : _activeTasks.entrySet()) {	if (entry.getValue().millisSinceLastJobHeartbeat() > _inactivityWarningThresholdMs) {	
task job has been pending for seconds 

public void registerActiveTask(long runNumber, long jobId) {	synchronized (this) {	
add job into job monitoring 

public void unregisterActiveTask(long runNumber) {	synchronized (this) {	ActiveTaskRecord record = _activeTasks.get(runNumber);	assert (record != null);	if (record != null) {	
remove job from job monitoring 

public void unregisterByJobId(long jobId) {	synchronized (this) {	Iterator<Map.Entry<Long, ActiveTaskRecord>> it = _activeTasks.entrySet().iterator();	while (it.hasNext()) {	Map.Entry<Long, ActiveTaskRecord> entry = it.next();	if (entry.getValue().getJobId() == jobId) {	
remove job from job monitoring due to job cancelling 

========================= cloudstack sample_691 =========================

public boolean powerOn() throws Exception {	if (getResetSafePowerState() == VirtualMachinePowerState.POWERED_ON) return true;	ManagedObjectReference morTask = _context.getService().powerOnVMTask(_mor, null);	final Boolean[] flags = {false};	final VirtualMachineMO vmMo = this;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	
vm question monitor started 

ManagedObjectReference morTask = _context.getService().powerOnVMTask(_mor, null);	final Boolean[] flags = {false};	final VirtualMachineMO vmMo = this;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	
question id 

ManagedObjectReference morTask = _context.getService().powerOnVMTask(_mor, null);	final Boolean[] flags = {false};	final VirtualMachineMO vmMo = this;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	
question text 

Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isInfoEnabled()) {	
msg id 

Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isInfoEnabled()) {	
msg text 

while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isInfoEnabled()) {	}	if ("msg.uuid.altered".equalsIgnoreCase(msg.getId())) {	
found that vm has a pending question that we need to answer programmatically question id we will automatically answer as moved it to address out of band ha for the vm 

if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isInfoEnabled()) {	}	if ("msg.uuid.altered".equalsIgnoreCase(msg.getId())) {	vmMo.answerVM(question.getId(), "1");	break;	}	}	}	
these are the choices we can have just in case 

if ("msg.uuid.altered".equalsIgnoreCase(msg.getId())) {	vmMo.answerVM(question.getId(), "1");	break;	}	}	}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	
choice option key 

if ("msg.uuid.altered".equalsIgnoreCase(msg.getId())) {	vmMo.answerVM(question.getId(), "1");	break;	}	}	}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	
choice option label 

}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	}	}	}	}	} catch (Throwable e) {	
unexpected exception 

if (s_logger.isTraceEnabled()) {	}	}	}	}	} catch (Throwable e) {	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while dealing with vm questions 

}	}	}	} catch (Throwable e) {	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	
vm question monitor stopped 

}	}	}	});	try {	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware poweronvm task failed due to 

public boolean safePowerOff(int shutdownWaitMs) throws Exception {	if (getResetSafePowerState() == VirtualMachinePowerState.POWERED_OFF) return true;	if (isVMwareToolsRunning()) {	try {	String vmName = getName();	
try gracefully shut down vm 

if (getResetSafePowerState() == VirtualMachinePowerState.POWERED_OFF) return true;	if (isVMwareToolsRunning()) {	try {	String vmName = getName();	shutdown();	long startTick = System.currentTimeMillis();	while (getResetSafePowerState() != VirtualMachinePowerState.POWERED_OFF && System.currentTimeMillis() - startTick < shutdownWaitMs) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while powering of vm 

String vmName = getName();	shutdown();	long startTick = System.currentTimeMillis();	while (getResetSafePowerState() != VirtualMachinePowerState.POWERED_OFF && System.currentTimeMillis() - startTick < shutdownWaitMs) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	if (getResetSafePowerState() != VirtualMachinePowerState.POWERED_OFF) {	
can not gracefully shutdown vm within seconds we will perform force power off on vm 

try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	if (getResetSafePowerState() != VirtualMachinePowerState.POWERED_OFF) {	return powerOffNoCheck();	}	return true;	} catch (Exception e) {	
failed to do guest os graceful shutdown due to 

private boolean powerOffNoCheck() throws Exception {	ManagedObjectReference morTask = _context.getService().powerOffVMTask(_mor);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	long startTick = System.currentTimeMillis();	while (getResetSafePowerState() != VirtualMachinePowerState.POWERED_OFF && System.currentTimeMillis() - startTick < 5000) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while powering of vm unconditionaly 

long startTick = System.currentTimeMillis();	while (getResetSafePowerState() != VirtualMachinePowerState.POWERED_OFF && System.currentTimeMillis() - startTick < 5000) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	return true;	} else {	if (getResetSafePowerState() == VirtualMachinePowerState.POWERED_OFF) {	
current power off task failed however vm has been switched to the state we are expecting for 

try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	return true;	} else {	if (getResetSafePowerState() == VirtualMachinePowerState.POWERED_OFF) {	return true;	}	
vmware poweroffvm task failed due to 

public VirtualMachinePowerState getResetSafePowerState() throws Exception {	VirtualMachinePowerState powerState = VirtualMachinePowerState.POWERED_OFF;	for (int i = 0; i < 3; i++) {	powerState = (VirtualMachinePowerState)getContext().getVimClient().getDynamicProperty(_mor, "runtime.powerState");	if (powerState == VirtualMachinePowerState.POWERED_OFF) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while pausing after power off 

public boolean reset() throws Exception {	ManagedObjectReference morTask = _context.getService().resetVMTask(_mor);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware resetvm task failed due to 

public boolean migrate(ManagedObjectReference morRp, ManagedObjectReference morTargetHost) throws Exception {	ManagedObjectReference morTask = _context.getService().migrateVMTask(_mor, morRp, morTargetHost, VirtualMachineMovePriority.DEFAULT_PRIORITY, null);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware migratevm task failed due to 

public boolean changeDatastore(VirtualMachineRelocateSpec relocateSpec) throws Exception {	ManagedObjectReference morTask = _context.getVimClient().getService().relocateVMTask(_mor, relocateSpec, VirtualMachineMovePriority.DEFAULT_PRIORITY);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware relocatevm task to change datastore failed due to 

public boolean changeHost(VirtualMachineRelocateSpec relocateSpec) throws Exception {	ManagedObjectReference morTask = _context.getService().relocateVMTask(_mor, relocateSpec, VirtualMachineMovePriority.DEFAULT_PRIORITY);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware relocatevm task to change host failed due to 

public boolean relocate(ManagedObjectReference morTargetHost) throws Exception {	VirtualMachineRelocateSpec relocateSpec = new VirtualMachineRelocateSpec();	relocateSpec.setHost(morTargetHost);	ManagedObjectReference morTask = _context.getService().relocateVMTask(_mor, relocateSpec, null);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware relocatevm task failed due to 

ManagedObjectReference morSnapshot = null;	long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick < apiTimeout) {	morSnapshot = getSnapshotMor(snapshotName);	if (morSnapshot != null) {	break;	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while waiting for snapshot to be done 

morSnapshot = getSnapshotMor(snapshotName);	if (morSnapshot != null) {	break;	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	if (morSnapshot == null) {	
we ve been waiting for over milli seconds for snapshot mor to be appearing in vcenter after createsnapshot task is done but it is still not there 

break;	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	if (morSnapshot == null) {	return false;	}	
waited for seconds for snapshot object to appear in vcenter 

try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	if (morSnapshot == null) {	return false;	}	return true;	} else {	
vmware createsnapshot task failed due to 

public boolean removeSnapshot(String snapshotName, boolean removeChildren) throws Exception {	ManagedObjectReference morSnapshot = getSnapshotMor(snapshotName);	if (morSnapshot == null) {	
unable to find snapshot 

ManagedObjectReference morSnapshot = getSnapshotMor(snapshotName);	if (morSnapshot == null) {	return false;	}	ManagedObjectReference morTask = _context.getService().removeSnapshotTask(morSnapshot, removeChildren, true);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware removesnapshot task failed due to 

public boolean revertToSnapshot(String snapshotName) throws Exception {	ManagedObjectReference morSnapshot = getSnapshotMor(snapshotName);	if (morSnapshot == null) {	
unable to find snapshot 

ManagedObjectReference morSnapshot = getSnapshotMor(snapshotName);	if (morSnapshot == null) {	return false;	}	ManagedObjectReference morTask = _context.getService().revertToSnapshotTask(morSnapshot, _mor, null);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware revert to snapshot failed due to 

public boolean removeAllSnapshots() throws Exception {	VirtualMachineSnapshotInfo snapshotInfo = getSnapshotInfo();	if (snapshotInfo != null && snapshotInfo.getRootSnapshotList() != null) {	List<VirtualMachineSnapshotTree> tree = snapshotInfo.getRootSnapshotList();	for (VirtualMachineSnapshotTree treeNode : tree) {	ManagedObjectReference morTask = _context.getService().removeSnapshotTask(treeNode.getSnapshot(), true, true);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	} else {	
vmware removesnapshot task failed due to 

public SnapshotDescriptor getSnapshotDescriptor() throws Exception {	Pair<DatacenterMO, String> dcPair = getOwnerDatacenter();	String dsPath = getSnapshotDescriptorDatastorePath();	assert (dsPath != null);	String url = getContext().composeDatastoreBrowseUrl(dcPair.second(), dsPath);	byte[] content = getContext().getResourceContent(url);	if (content == null || content.length < 1) {	
snapshot descriptor file vsd does not exist anymore 

cloneSpec.setPowerOn(false);	cloneSpec.setTemplate(false);	relocSpec.setDatastore(morDs);	relocSpec.setPool(morResourcePool);	ManagedObjectReference morTask = _context.getService().cloneVMTask(_mor, morFolder, cloneName, cloneSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware clonevm task failed due to 

cloneSpec.setPowerOn(false);	cloneSpec.setTemplate(false);	cloneSpec.setLocation(rSpec);	cloneSpec.setSnapshot(morBaseSnapshot);	ManagedObjectReference morTask = _context.getService().cloneVMTask(_mor, morFolder, cloneName, cloneSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware clonevm task failed due to 

public List<NetworkDetails> getNetworksWithDetails() throws Exception {	List<NetworkDetails> networks = new ArrayList<NetworkDetails>();	int gcTagKey = getCustomFieldKey("Network", CustomFieldConstants.CLOUD_GC);	if (gcTagKey == 0) {	gcTagKey = getCustomFieldKey("DistributedVirtualPortgroup", CustomFieldConstants.CLOUD_GC_DVP);	
the custom key for dvportgroup is 

if (prop.getName().equals("name")) name = prop.getVal().toString();	else if (prop.getName().equals("vm")) morVms = (ArrayOfManagedObjectReference)prop.getVal();	else if (prop.getName().startsWith("value[")) {	CustomFieldStringValue val = (CustomFieldStringValue)prop.getVal();	if (val != null) gcTagValue = val.getValue();	}	}	NetworkDetails details = new NetworkDetails(name, oc.getObj(), (morVms != null ? morVms.getManagedObjectReference().toArray( new ManagedObjectReference[morVms.getManagedObjectReference().size()]) : null), gcTagValue);	networks.add(details);	}	
retrieved networks with key 

public boolean setVncConfigInfo(boolean enableVnc, String vncPassword, int vncPort, String keyboard) throws Exception {	VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();	OptionValue[] vncOptions = VmwareHelper.composeVncOptions(null, enableVnc, vncPassword, vncPort, keyboard);	vmConfigSpec.getExtraConfig().addAll(Arrays.asList(vncOptions));	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, vmConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware reconfigvm task failed due to 

public boolean configureVm(VirtualMachineConfigSpec vmConfigSpec) throws Exception {	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, vmConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware reconfigvm task failed due to 

deviceConfigSpec.setFileOperation(deviceTernary.third());	deviceConfigSpecArray[i++] = deviceConfigSpec;	}	configSpec.getDeviceChange().addAll(Arrays.asList(deviceConfigSpecArray));	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, configSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware reconfigvm task failed due to 

public void createDisk(String vmdkDatastorePath, VirtualDiskType diskType, VirtualDiskMode diskMode, String rdmDeviceName, int sizeInMb, ManagedObjectReference morDs, int controllerKey) throws Exception {	
vcenter api trace createdisk target mor vmdkdatastorepath sizeinmb disktype diskmode rdmdevicename datastore controllerkey 

newDisk.setCapacityInKB(sizeInMb * 1024);	VirtualMachineConfigSpec reConfigSpec = new VirtualMachineConfigSpec();	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setFileOperation(VirtualDeviceConfigSpecFileOperation.CREATE);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace createdisk done failed 

deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setFileOperation(VirtualDeviceConfigSpecFileOperation.CREATE);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Unable to create disk " + vmdkDatastorePath + " due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	
vcenter api trace createdisk done successfully 

public void updateVmdkAdapter(String vmdkFileName, String newAdapterType) throws Exception {	Pair<VmdkFileDescriptor, byte[]> vmdkInfo = getVmdkFileInfo(vmdkFileName);	VmdkFileDescriptor vmdkFileDescriptor = vmdkInfo.first();	boolean isVmfsSparseFile = vmdkFileDescriptor.isVmfsSparseFile();	if (!isVmfsSparseFile) {	String currentAdapterType = vmdkFileDescriptor.getAdapterType();	if (!currentAdapterType.equalsIgnoreCase(newAdapterType)) {	
updating adapter type to for vmdk file 

Pair<VmdkFileDescriptor, byte[]> vmdkInfo = getVmdkFileInfo(vmdkFileName);	VmdkFileDescriptor vmdkFileDescriptor = vmdkInfo.first();	boolean isVmfsSparseFile = vmdkFileDescriptor.isVmfsSparseFile();	if (!isVmfsSparseFile) {	String currentAdapterType = vmdkFileDescriptor.getAdapterType();	if (!currentAdapterType.equalsIgnoreCase(newAdapterType)) {	Pair<DatacenterMO, String> dcInfo = getOwnerDatacenter();	byte[] newVmdkContent = vmdkFileDescriptor.changeVmdkAdapterType(vmdkInfo.second(), newAdapterType);	String vmdkUploadUrl = getContext().composeDatastoreBrowseUrl(dcInfo.first().getName(), vmdkFileName);	getContext().uploadResourceContent(vmdkUploadUrl, newVmdkContent);	
updated vmdk file 

public void updateAdapterTypeIfRequired(String vmdkFileName) throws Exception {	Pair<VmdkFileDescriptor, byte[]> vmdkInfo = getVmdkFileInfo(vmdkFileName);	VmdkFileDescriptor vmdkFileDescriptor = vmdkInfo.first();	boolean isVmfsSparseFile = vmdkFileDescriptor.isVmfsSparseFile();	if (!isVmfsSparseFile) {	String currentAdapterTypeStr = vmdkFileDescriptor.getAdapterType();	if (s_logger.isTraceEnabled()) {	
detected adapter type for vmdk file 

Pair<VmdkFileDescriptor, byte[]> vmdkInfo = getVmdkFileInfo(vmdkFileName);	VmdkFileDescriptor vmdkFileDescriptor = vmdkInfo.first();	boolean isVmfsSparseFile = vmdkFileDescriptor.isVmfsSparseFile();	if (!isVmfsSparseFile) {	String currentAdapterTypeStr = vmdkFileDescriptor.getAdapterType();	if (s_logger.isTraceEnabled()) {	}	VmdkAdapterType currentAdapterType = VmdkAdapterType.getType(currentAdapterTypeStr);	if (currentAdapterType == VmdkAdapterType.none) {	VmdkAdapterType newAdapterType = VmdkAdapterType.lsilogic;	
updating adapter type to from for vmdk file 

String currentAdapterTypeStr = vmdkFileDescriptor.getAdapterType();	if (s_logger.isTraceEnabled()) {	}	VmdkAdapterType currentAdapterType = VmdkAdapterType.getType(currentAdapterTypeStr);	if (currentAdapterType == VmdkAdapterType.none) {	VmdkAdapterType newAdapterType = VmdkAdapterType.lsilogic;	Pair<DatacenterMO, String> dcInfo = getOwnerDatacenter();	byte[] newVmdkContent = vmdkFileDescriptor.changeVmdkAdapterType(vmdkInfo.second(), newAdapterType.toString());	String vmdkUploadUrl = getContext().composeDatastoreBrowseUrl(dcInfo.first().getName(), vmdkFileName);	getContext().uploadResourceContent(vmdkUploadUrl, newVmdkContent);	
updated vmdk file 

public void attachDisk(String[] vmdkDatastorePathChain, ManagedObjectReference morDs, String diskController) throws Exception {	
vcenter api trace attachdisk target mor vmdkdatastorepath datastore 

}	updateVmdkAdapter(vmdkFileName, vmdkAdapterType.toString());	VirtualMachineConfigSpec reConfigSpec = new VirtualMachineConfigSpec();	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace attachdisk done failed 

deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Failed to attach disk due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	}	
vcenter api trace attachdisk done successfully 

public void attachDisk(String[] vmdkDatastorePathChain, ManagedObjectReference morDs) throws Exception {	
vcenter api trace attachdisk target mor vmdkdatastorepath datastore 

synchronized (_mor.getValue().intern()) {	VirtualDevice newDisk = VmwareHelper.prepareDiskDevice(this, null, getScsiDeviceControllerKey(), vmdkDatastorePathChain, morDs, -1, 1);	VirtualMachineConfigSpec reConfigSpec = new VirtualMachineConfigSpec();	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace attachdisk done failed 

deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Failed to attach disk due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	}	
vcenter api trace attachdisk done successfully 

public void attachDisk(Pair<String, ManagedObjectReference>[] vmdkDatastorePathChain, int controllerKey) throws Exception {	
vcenter api trace attachdisk target mor vmdkdatastorepath 

synchronized (_mor.getValue().intern()) {	VirtualDevice newDisk = VmwareHelper.prepareDiskDevice(this, controllerKey, vmdkDatastorePathChain, -1, 1);	VirtualMachineConfigSpec reConfigSpec = new VirtualMachineConfigSpec();	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace attachdisk done failed 

deviceConfigSpec.setDevice(newDisk);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Failed to attach disk due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	}	
vcenter api trace attachdisk done successfully 

public List<Pair<String, ManagedObjectReference>> detachDisk(String vmdkDatastorePath, boolean deleteBackingFile) throws Exception {	
vcenter api trace detachdisk target mor vmdkdatastorepath deletebacking 

public List<Pair<String, ManagedObjectReference>> detachDisk(String vmdkDatastorePath, boolean deleteBackingFile) throws Exception {	Pair<VirtualDisk, String> deviceInfo = getDiskDevice(vmdkDatastorePath);	if (deviceInfo == null) {	
vcenter api trace detachdisk done failed 

VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(deviceInfo.first());	if (deleteBackingFile) {	deviceConfigSpec.setFileOperation(VirtualDeviceConfigSpecFileOperation.DESTROY);	}	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.REMOVE);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace detachdisk done failed 

ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Failed to detach disk due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	SnapshotDescriptor snapshotDescriptor = null;	try {	snapshotDescriptor = getSnapshotDescriptor();	} catch (Exception e) {	
unable to retrieve snapshot descriptor will skip updating snapshot reference 

for (Pair<String, ManagedObjectReference> pair : chain) {	DatastoreFile dsFile = new DatastoreFile(pair.first());	snapshotDescriptor.removeDiskReferenceFromSnapshot(dsFile.getFileName());	}	Pair<DatacenterMO, String> dcPair = getOwnerDatacenter();	String dsPath = getSnapshotDescriptorDatastorePath();	assert (dsPath != null);	String url = getContext().composeDatastoreBrowseUrl(dcPair.second(), dsPath);	getContext().uploadResourceContent(url, snapshotDescriptor.getVmsdContent());	}	
vcenter api trace detachdisk done successfully 

public void detachAllDisks() throws Exception {	
vcenter api trace detachalldisk target mor 

VirtualDeviceConfigSpec[] deviceConfigSpecArray = new VirtualDeviceConfigSpec[disks.length];	for (int i = 0; i < disks.length; i++) {	deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();	deviceConfigSpecArray[i].setDevice(disks[i]);	deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.REMOVE);	}	reConfigSpec.getDeviceChange().addAll(Arrays.asList(deviceConfigSpecArray));	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace detachalldisk done failed 

deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.REMOVE);	}	reConfigSpec.getDeviceChange().addAll(Arrays.asList(deviceConfigSpecArray));	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Failed to detach disk due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	}	
vcenter api trace detachalldisk done successfully 

public void attachIso(String isoDatastorePath, ManagedObjectReference morDs, boolean connect, boolean connectAtBoot) throws Exception {	
vcenter api trace attachiso target mor isodatastorepath datastore connect connectatboot 

deviceConfigSpec.setDevice(cdRom);	if (newCdRom) {	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	} else {	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.EDIT);	}	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace detachiso done failed 

} else {	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.EDIT);	}	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Failed to attach ISO due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	
vcenter api trace detachiso done successfully 

public void detachIso(String isoDatastorePath) throws Exception {	
vcenter api trace detachiso target mor isodatastorepath 

public void detachIso(String isoDatastorePath) throws Exception {	VirtualDevice device = getIsoDevice();	if (device == null) {	
vcenter api trace detachiso done failed 

VirtualMachineConfigSpec reConfigSpec = new VirtualMachineConfigSpec();	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	deviceConfigSpec.setDevice(device);	deviceConfigSpec.setOperation(VirtualDeviceConfigSpecOperation.EDIT);	reConfigSpec.getDeviceChange().add(deviceConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	final Boolean[] flags = {false};	final VirtualMachineMO vmMo = this;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	
vm question monitor started 

final Boolean[] flags = {false};	final VirtualMachineMO vmMo = this;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (s_logger.isTraceEnabled()) {	
question id 

final Boolean[] flags = {false};	final VirtualMachineMO vmMo = this;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (s_logger.isTraceEnabled()) {	
question text 

while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (s_logger.isTraceEnabled()) {	}	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isTraceEnabled()) {	
msg id 

while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (s_logger.isTraceEnabled()) {	}	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isTraceEnabled()) {	
msg text 

VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	if (s_logger.isTraceEnabled()) {	}	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isTraceEnabled()) {	}	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msg.getId())) {	
found that vm has a pending question that we need to answer programmatically question id for safe operation we will automatically decline it 

if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msg.getId())) {	vmMo.answerVM(question.getId(), "1");	break;	}	}	} else if (question.getText() != null) {	String text = question.getText();	String msgId;	String msgText;	if (s_logger.isDebugEnabled()) {	
question text 

} else if (question.getText() != null) {	String text = question.getText();	String msgId;	String msgText;	if (s_logger.isDebugEnabled()) {	}	String[] tokens = text.split(":");	msgId = tokens[0];	msgText = tokens[1];	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msgId)) {	
found that vm has a pending question that we need to answer programmatically question id message id message text for safe operation we will automatically decline it 

msgId = tokens[0];	msgText = tokens[1];	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msgId)) {	vmMo.answerVM(question.getId(), "1");	}	}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	
choice option key 

msgId = tokens[0];	msgText = tokens[1];	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msgId)) {	vmMo.answerVM(question.getId(), "1");	}	}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	
choice option label 

}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	}	}	}	}	} catch (Throwable e) {	
unexpected exception 

if (s_logger.isTraceEnabled()) {	}	}	}	}	} catch (Throwable e) {	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while handling vm question about iso detach 

}	}	}	} catch (Throwable e) {	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	
vm question monitor stopped 

try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	}	});	try {	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	
vcenter api trace detachiso done failed 

}	}	}	});	try {	boolean result = _context.getVimClient().waitForTask(morTask);	if (!result) {	throw new Exception("Failed to detachIso due to " + TaskMO.getTaskFailureInfo(_context, morTask));	}	_context.waitForTaskProgressDone(morTask);	
vcenter api trace detachiso done successfully 

public Pair<VmdkFileDescriptor, byte[]> getVmdkFileInfo(String vmdkDatastorePath) throws Exception {	
vcenter api trace getvmdkfileinfo target mor vmdkdatastorepath 

public Pair<VmdkFileDescriptor, byte[]> getVmdkFileInfo(String vmdkDatastorePath) throws Exception {	Pair<DatacenterMO, String> dcPair = getOwnerDatacenter();	String url = getContext().composeDatastoreBrowseUrl(dcPair.second(), vmdkDatastorePath);	byte[] content = getContext().getResourceContent(url);	VmdkFileDescriptor descriptor = new VmdkFileDescriptor();	descriptor.parse(content);	Pair<VmdkFileDescriptor, byte[]> result = new Pair<VmdkFileDescriptor, byte[]>(descriptor, content);	if (s_logger.isTraceEnabled()) {	
vcenter api trace getvmdkfileinfo done 

public Pair<VmdkFileDescriptor, byte[]> getVmdkFileInfo(String vmdkDatastorePath) throws Exception {	Pair<DatacenterMO, String> dcPair = getOwnerDatacenter();	String url = getContext().composeDatastoreBrowseUrl(dcPair.second(), vmdkDatastorePath);	byte[] content = getContext().getResourceContent(url);	VmdkFileDescriptor descriptor = new VmdkFileDescriptor();	descriptor.parse(content);	Pair<VmdkFileDescriptor, byte[]> result = new Pair<VmdkFileDescriptor, byte[]>(descriptor, content);	if (s_logger.isTraceEnabled()) {	
vmdk file descriptor 

String hostName = hostMo.getHostName();	String vmName = getVmName();	DatacenterMO dcMo = new DatacenterMO(_context, hostMo.getHyperHostDatacenter());	if (runtimeInfo.getPowerState() != VirtualMachinePowerState.POWERED_OFF) {	String msg = "Unable to export VM because it is not at powerdOff state. vmName: " + vmName + ", host: " + hostName;	s_logger.error(msg);	throw new Exception(msg);	}	ManagedObjectReference morLease = _context.getService().exportVm(getMor());	if (morLease == null) {	
exportvm failed 

try {	if (state == HttpNfcLeaseState.READY) {	final HttpNfcLeaseMO.ProgressReporter progressReporter = leaseMo.createProgressReporter();	boolean success = false;	List<String> fileNames = new ArrayList<String>();	try {	HttpNfcLeaseInfo leaseInfo = leaseMo.getLeaseInfo();	final long totalBytes = leaseInfo.getTotalDiskCapacityInKB() * 1024;	long totalBytesDownloaded = 0;	List<HttpNfcLeaseDeviceUrl> deviceUrls = leaseInfo.getDeviceUrl();	
volss copy vmdk and ovf file starts 

for (int i = 0; i < deviceUrls.size(); i++) {	String deviceId = deviceUrls.get(i).getKey();	String deviceUrlStr = deviceUrls.get(i).getUrl();	String orgDiskFileName = deviceUrlStr.substring(deviceUrlStr.lastIndexOf("/") + 1);	String diskFileName = String.format("%s-disk%d%s", exportName, i, VmwareHelper.getFileExtension(orgDiskFileName, ".vmdk"));	String diskUrlStr = deviceUrlStr.replace("*", hostName);	diskUrlStr = HypervisorHostHelper.resolveHostNameInUrl(dcMo, diskUrlStr);	String diskLocalPath = exportDir + File.separator + diskFileName;	fileNames.add(diskLocalPath);	if (s_logger.isInfoEnabled()) {	
download vmdk file for export url 

String diskFileName = String.format("%s-disk%d%s", exportName, i, VmwareHelper.getFileExtension(orgDiskFileName, ".vmdk"));	String diskUrlStr = deviceUrlStr.replace("*", hostName);	diskUrlStr = HypervisorHostHelper.resolveHostNameInUrl(dcMo, diskUrlStr);	String diskLocalPath = exportDir + File.separator + diskFileName;	fileNames.add(diskLocalPath);	if (s_logger.isInfoEnabled()) {	}	long lengthOfDiskFile = _context.downloadVmdkFile(diskUrlStr, diskLocalPath, totalBytesDownloaded, new ActionDelegate<Long>() {	public void action(Long param) {	if (s_logger.isTraceEnabled()) {	
download progress 

}	OvfCreateDescriptorParams ovfDescParams = new OvfCreateDescriptorParams();	ovfDescParams.getOvfFiles().addAll(Arrays.asList(ovfFiles));	OvfCreateDescriptorResult ovfCreateDescriptorResult = _context.getService().createDescriptor(morOvf, getMor(), ovfDescParams);	String ovfPath = exportDir + File.separator + exportName + ".ovf";	fileNames.add(ovfPath);	OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(ovfPath),"UTF-8");	out.write(ovfCreateDescriptorResult.getOvfDescriptor());	out.close();	if (packToOva) {	
sync file system before we package ova 

if (packToOva) {	Script commandSync = new Script(true, "sync", 0, s_logger);	commandSync.execute();	Script command = new Script(false, "tar", 0, s_logger);	command.setWorkDir(exportDir);	command.add("-cf", exportName + ".ova");	command.add(exportName + ".ovf");	for (String name : fileNames) {	command.add((new File(name).getName()));	}	
package ova with commmand 

command.setWorkDir(exportDir);	command.add("-cf", exportName + ".ova");	command.add(exportName + ".ovf");	for (String name : fileNames) {	command.add((new File(name).getName()));	}	command.execute();	if ((new File(exportDir + File.separator + exportName + ".ova")).exists()) {	success = true;	} else {	
ova is not created as expected 

}	command.execute();	if ((new File(exportDir + File.separator + exportName + ".ova")).exists()) {	success = true;	} else {	}	} else {	success = true;	}	}	
volss copy vmdk and ovf file finishes 

command.execute();	if ((new File(exportDir + File.separator + exportName + ".ova")).exists()) {	success = true;	} else {	}	} else {	success = true;	}	}	} catch (Throwable e) {	
unexpected exception 

Pair<VmdkFileDescriptor, byte[]> vmdkInfo = getVmdkFileInfo(srcVmdkFullDsPath);	String srcVmdkBaseFilePath = DatastoreFile.getCompanionDatastorePath(srcVmdkFullDsPath, vmdkInfo.first().getBaseFileName());	destFileName = destName + (snapshotInfo.length - i - 1) + ".vmdk";	if (vmdkInfo.first().getParentFileName() != null) {	destBaseFileName = destName + (snapshotInfo.length - i - 1) + "-delta.vmdk";	destParentFileName = destName + (snapshotInfo.length - i - 2) + ".vmdk";	} else {	destBaseFileName = destName + (snapshotInfo.length - i - 1) + "-flat.vmdk";	destParentFileName = null;	}	
copy vmdk base file to 

if (vmdkInfo.first().getParentFileName() != null) {	destBaseFileName = destName + (snapshotInfo.length - i - 1) + "-delta.vmdk";	destParentFileName = destName + (snapshotInfo.length - i - 2) + ".vmdk";	} else {	destBaseFileName = destName + (snapshotInfo.length - i - 1) + "-flat.vmdk";	destParentFileName = null;	}	srcDsInfo.first().copyDatastoreFile(srcVmdkBaseFilePath, dcMo.getMor(), morDestDs, destDsDirectory + "/" + destBaseFileName, dcMo.getMor(), true);	byte[] newVmdkContent = VmdkFileDescriptor.changeVmdkContentBaseInfo(vmdkInfo.second(), destBaseFileName, destParentFileName);	String vmdkUploadUrl = getContext().composeDatastoreBrowseUrl(dcMo.getName(), destDsDirectory + "/" + destFileName);	
upload vmdk content file to 

DatacenterMO dcMo = getOwnerDatacenter().first();	if (disks != null) {	for (VirtualDevice disk : disks) {	List<Pair<String, ManagedObjectReference>> vmdkFiles = getDiskDatastorePathChain((VirtualDisk)disk, followDiskChain);	for (Pair<String, ManagedObjectReference> fileItem : vmdkFiles) {	DatastoreMO srcDsMo = new DatastoreMO(_context, fileItem.second());	DatastoreFile srcFile = new DatastoreFile(fileItem.first());	DatastoreFile destFile = new DatastoreFile(destDsMo.getName(), destDsDir, srcFile.getFileName());	Pair<VmdkFileDescriptor, byte[]> vmdkDescriptor = null;	vmdkDescriptor = getVmdkFileInfo(fileItem.first());	
copy vm disk file to 

DatastoreMO srcDsMo = new DatastoreMO(_context, fileItem.second());	DatastoreFile srcFile = new DatastoreFile(fileItem.first());	DatastoreFile destFile = new DatastoreFile(destDsMo.getName(), destDsDir, srcFile.getFileName());	Pair<VmdkFileDescriptor, byte[]> vmdkDescriptor = null;	vmdkDescriptor = getVmdkFileInfo(fileItem.first());	srcDsMo.copyDatastoreFile(fileItem.first(), dcMo.getMor(), destDsMo.getMor(), destFile.getPath(), dcMo.getMor(), true);	if (vmdkDescriptor != null) {	String vmdkBaseFileName = vmdkDescriptor.first().getBaseFileName();	String baseFilePath = srcFile.getCompanionPath(vmdkBaseFileName);	destFile = new DatastoreFile(destDsMo.getName(), destDsDir, vmdkBaseFileName);	
copy vm disk file to 

DatacenterMO dcMo = getOwnerDatacenter().first();	if (disks != null) {	for (VirtualDevice disk : disks) {	List<Pair<String, ManagedObjectReference>> vmdkFiles = getDiskDatastorePathChain((VirtualDisk)disk, followDiskChain);	for (Pair<String, ManagedObjectReference> fileItem : vmdkFiles) {	DatastoreMO srcDsMo = new DatastoreMO(_context, fileItem.second());	DatastoreFile srcFile = new DatastoreFile(fileItem.first());	DatastoreFile destFile = new DatastoreFile(destDsMo.getName(), destDsDir, srcFile.getFileName());	Pair<VmdkFileDescriptor, byte[]> vmdkDescriptor = null;	vmdkDescriptor = getVmdkFileInfo(fileItem.first());	
move vm disk file to 

DatastoreMO srcDsMo = new DatastoreMO(_context, fileItem.second());	DatastoreFile srcFile = new DatastoreFile(fileItem.first());	DatastoreFile destFile = new DatastoreFile(destDsMo.getName(), destDsDir, srcFile.getFileName());	Pair<VmdkFileDescriptor, byte[]> vmdkDescriptor = null;	vmdkDescriptor = getVmdkFileInfo(fileItem.first());	srcDsMo.moveDatastoreFile(fileItem.first(), dcMo.getMor(), destDsMo.getMor(), destFile.getPath(), dcMo.getMor(), true);	if (vmdkDescriptor != null) {	String vmdkBaseFileName = vmdkDescriptor.first().getBaseFileName();	String baseFilePath = srcFile.getCompanionPath(vmdkBaseFileName);	destFile = new DatastoreFile(destDsMo.getName(), destDsDir, vmdkBaseFileName);	
move vm disk file to 

scsiController.setKey(busNum - VmwareHelper.MAX_SCSI_CONTROLLER_COUNT);	VirtualDeviceConfigSpec scsiControllerSpec = new VirtualDeviceConfigSpec();	scsiControllerSpec.setDevice(scsiController);	scsiControllerSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	vmConfig.getDeviceChange().add(scsiControllerSpec);	busNum++;	}	if (configureVm(vmConfig)) {	throw new Exception("Unable to add Scsi controllers to the VM " + getName());	} else {	
successfully added scsi controllers 

public boolean isPvScsiSupported() throws Exception {	int virtualHardwareVersion;	virtualHardwareVersion = getVirtualHardwareVersion();	if (virtualHardwareVersion < 7) {	
the virtual hardware version of the vm is which doesn t support pv scsi controller type for virtual harddisks please upgrade this vm s virtual hardware version to or later 

scsiController.setKey(busNum - VmwareHelper.MAX_SCSI_CONTROLLER_COUNT);	VirtualDeviceConfigSpec scsiControllerSpec = new VirtualDeviceConfigSpec();	scsiControllerSpec.setDevice(scsiController);	scsiControllerSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	vmConfig.getDeviceChange().add(scsiControllerSpec);	busNum++;	}	if (configureVm(vmConfig)) {	throw new Exception("Unable to add Scsi controllers to the VM " + getName());	} else {	
successfully added scsi controllers 

public Pair<VirtualDisk, String> getDiskDevice(String vmdkDatastorePath) throws Exception {	List<VirtualDevice> devices = _context.getVimClient().getDynamicProperty(_mor, "config.hardware.device");	ArrayList<Pair<VirtualDisk, String>> partialMatchingDiskDevices = new ArrayList<Pair<VirtualDisk, String>>();	DatastoreFile dsSrcFile = new DatastoreFile(vmdkDatastorePath);	String srcBaseName = dsSrcFile.getFileBaseName();	String trimmedSrcBaseName = VmwareHelper.trimSnapshotDeltaPostfix(srcBaseName);	
look for disk device info for volume with base name 

public Pair<VirtualDisk, String> getDiskDevice(String vmdkDatastorePath) throws Exception {	List<VirtualDevice> devices = _context.getVimClient().getDynamicProperty(_mor, "config.hardware.device");	ArrayList<Pair<VirtualDisk, String>> partialMatchingDiskDevices = new ArrayList<Pair<VirtualDisk, String>>();	DatastoreFile dsSrcFile = new DatastoreFile(vmdkDatastorePath);	String srcBaseName = dsSrcFile.getFileBaseName();	String trimmedSrcBaseName = VmwareHelper.trimSnapshotDeltaPostfix(srcBaseName);	if (devices != null && devices.size() > 0) {	for (VirtualDevice device : devices) {	if (device instanceof VirtualDisk) {	
test against disk device controller key unit number 

DatastoreFile dsSrcFile = new DatastoreFile(vmdkDatastorePath);	String srcBaseName = dsSrcFile.getFileBaseName();	String trimmedSrcBaseName = VmwareHelper.trimSnapshotDeltaPostfix(srcBaseName);	if (devices != null && devices.size() > 0) {	for (VirtualDevice device : devices) {	if (device instanceof VirtualDisk) {	VirtualDeviceBackingInfo backingInfo = ((VirtualDisk)device).getBacking();	if (backingInfo instanceof VirtualDiskFlatVer2BackingInfo) {	VirtualDiskFlatVer2BackingInfo diskBackingInfo = (VirtualDiskFlatVer2BackingInfo)backingInfo;	do {	
test against disk backing 

if (backingBaseName.contains(trimmedSrcBaseName)) {	String deviceNumbering = getDeviceBusName(devices, device);	partialMatchingDiskDevices.add(new Pair<VirtualDisk, String>((VirtualDisk)device, deviceNumbering));	}	diskBackingInfo = diskBackingInfo.getParent();	} while (diskBackingInfo != null);	}	}	}	}	
no disk device with an exact match found for volume look for disk device info against trimmed base name 

}	}	}	}	if (partialMatchingDiskDevices != null) {	if (partialMatchingDiskDevices.size() == 1) {	VirtualDiskFlatVer2BackingInfo matchingDiskBackingInfo = (VirtualDiskFlatVer2BackingInfo)partialMatchingDiskDevices.get(0).first().getBacking();	s_logger.info("Disk backing : " + matchingDiskBackingInfo.getFileName() + " matches ==> " + partialMatchingDiskDevices.get(0).second());	return partialMatchingDiskDevices.get(0);	} else if (partialMatchingDiskDevices.size() > 1) {	
disk device info lookup for volume failed as multiple disk devices were found to match volume s trimmed base name 

}	if (partialMatchingDiskDevices != null) {	if (partialMatchingDiskDevices.size() == 1) {	VirtualDiskFlatVer2BackingInfo matchingDiskBackingInfo = (VirtualDiskFlatVer2BackingInfo)partialMatchingDiskDevices.get(0).first().getBacking();	s_logger.info("Disk backing : " + matchingDiskBackingInfo.getFileName() + " matches ==> " + partialMatchingDiskDevices.get(0).second());	return partialMatchingDiskDevices.get(0);	} else if (partialMatchingDiskDevices.size() > 1) {	return null;	}	}	
disk device info lookup for volume failed as no matching disk device found 

public String getDiskCurrentTopBackingFileInChain(String deviceBusName) throws Exception {	List<VirtualDevice> devices = _context.getVimClient().getDynamicProperty(_mor, "config.hardware.device");	if (devices != null && devices.size() > 0) {	for (VirtualDevice device : devices) {	if (device instanceof VirtualDisk) {	
test against disk device controller key unit number 

for (VirtualDevice device : devices) {	if (device instanceof VirtualDisk) {	VirtualDeviceConfigSpec deviceConfigSpec = new VirtualDeviceConfigSpec();	VirtualDiskFlatVer2BackingInfo diskBackingInfo = (VirtualDiskFlatVer2BackingInfo)device.getBacking();	DatastoreFile dsBackingFile = new DatastoreFile(diskBackingInfo.getFileName());	String backingBaseName = dsBackingFile.getFileBaseName();	String deviceNumbering = getDeviceBusName(devices, device);	if (backingBaseName.equalsIgnoreCase(vmdkBaseName) || (deviceBusName != null && deviceBusName.equals(deviceNumbering))) {	continue;	} else {	
detach from 

reConfigSpec.getDeviceChange().add(deviceConfigSpec);	}	}	}	if (detachedDiskFiles.size() > 0) {	ManagedObjectReference morTask = _context.getService().reconfigVMTask(_mor, reConfigSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	} else {	
unable to reconfigure the vm to detach disks 

int index = 0;	String attachedNetworkSummary;	String dvPortGroupName;	for (VirtualDevice nic : nics) {	attachedNetworkSummary = ((VirtualEthernetCard)nic).getDeviceInfo().getSummary();	if (attachedNetworkSummary.startsWith(networkNamePrefix)) {	return new Pair<Integer, VirtualDevice>(new Integer(index), nic);	} else if (attachedNetworkSummary.endsWith("DistributedVirtualPortBackingInfo.summary") || attachedNetworkSummary.startsWith("DVSwitch")) {	dvPortGroupName = getDvPortGroupName((VirtualEthernetCard)nic);	if (dvPortGroupName != null && dvPortGroupName.startsWith(networkNamePrefix)) {	
found a dvportgroup already associated with public nic 

public boolean unmountToolsInstaller() throws Exception {	final Boolean[] flags = {false};	final VirtualMachineMO vmMo = this;	final boolean[] encounterQuestion = new boolean[1];	encounterQuestion[0] = false;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	
vm question monitor started 

encounterQuestion[0] = false;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	encounterQuestion[0] = true;	if (s_logger.isTraceEnabled()) {	
question id 

encounterQuestion[0] = false;	Future<?> future = MonitorServiceExecutor.submit(new Runnable() {	public void run() {	while (!flags[0]) {	try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	encounterQuestion[0] = true;	if (s_logger.isTraceEnabled()) {	
question text 

try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	encounterQuestion[0] = true;	if (s_logger.isTraceEnabled()) {	}	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isTraceEnabled()) {	
msg id 

try {	VirtualMachineRuntimeInfo runtimeInfo = vmMo.getRuntimeInfo();	VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	encounterQuestion[0] = true;	if (s_logger.isTraceEnabled()) {	}	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isTraceEnabled()) {	
msg text 

VirtualMachineQuestionInfo question = runtimeInfo.getQuestion();	if (question != null) {	encounterQuestion[0] = true;	if (s_logger.isTraceEnabled()) {	}	if (question.getMessage() != null) {	for (VirtualMachineMessage msg : question.getMessage()) {	if (s_logger.isTraceEnabled()) {	}	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msg.getId())) {	
found that vm has a pending question that we need to answer programmatically question id for safe operation we will automatically decline it 

if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msg.getId())) {	vmMo.answerVM(question.getId(), "1");	break;	}	}	} else if (question.getText() != null) {	String text = question.getText();	String msgId;	String msgText;	if (s_logger.isDebugEnabled()) {	
question text 

} else if (question.getText() != null) {	String text = question.getText();	String msgId;	String msgText;	if (s_logger.isDebugEnabled()) {	}	String[] tokens = text.split(":");	msgId = tokens[0];	msgText = tokens[1];	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msgId)) {	
found that vm has a pending question that we need to answer programmatically question id message id message text for safe operation we will automatically decline it 

msgId = tokens[0];	msgText = tokens[1];	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msgId)) {	vmMo.answerVM(question.getId(), "1");	}	}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	
choice option key 

msgId = tokens[0];	msgText = tokens[1];	if ("msg.cdromdisconnect.locked".equalsIgnoreCase(msgId)) {	vmMo.answerVM(question.getId(), "1");	}	}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	
choice option label 

}	ChoiceOption choice = question.getChoice();	if (choice != null) {	for (ElementDescription info : choice.getChoiceInfo()) {	if (s_logger.isTraceEnabled()) {	}	}	}	}	} catch (Throwable e) {	
unexpected exception 

if (s_logger.isTraceEnabled()) {	}	}	}	}	} catch (Throwable e) {	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while handling vm question about umount tools install 

}	}	}	} catch (Throwable e) {	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	
vm question monitor stopped 

}	}	});	try {	_context.getService().unmountToolsInstaller(_mor);	} finally {	flags[0] = true;	future.cancel(true);	}	if (encounterQuestion[0]) {	
cdrom is locked by vm failed to detach the iso 

});	try {	_context.getService().unmountToolsInstaller(_mor);	} finally {	flags[0] = true;	future.cancel(true);	}	if (encounterQuestion[0]) {	return false;	} else {	
successfully unmounted tools installer from vm 

public int getNumberOfVirtualDisks() throws Exception {	List<VirtualDevice> devices = (List<VirtualDevice>)_context.getVimClient().getDynamicProperty(_mor, "config.hardware.device");	
counting disk devices attached to vm 

public boolean consolidateVmDisks() throws Exception {	ManagedObjectReference morTask = _context.getService().consolidateVMDisksTask(_mor);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware consolidatevmdisks task failed due to 

========================= cloudstack sample_2071 =========================

public boolean processAnswers(long agentId, long seq, Answer[] answers) {	for (Answer answer : answers) {	if (answer.getResult() == false) {	
unable to execute sync command 

public boolean processAnswers(long agentId, long seq, Answer[] answers) {	for (Answer answer : answers) {	if (answer.getResult() == false) {	} else {	
sync command executed 

public boolean processDisconnect(long agentId, Status state) {	
Disconnecting 

========================= cloudstack sample_2421 =========================

try {	StoragePool result = _storageService.createPool(this);	if (result != null) {	StoragePoolResponse response = _responseGenerator.createStoragePoolResponse(result);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add storage pool");	}	} catch (ResourceUnavailableException ex1) {	
exception 

if (result != null) {	StoragePoolResponse response = _responseGenerator.createStoragePoolResponse(result);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add storage pool");	}	} catch (ResourceUnavailableException ex1) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex1.getMessage());	} catch (ResourceInUseException ex2) {	
exception 

response.setResponseName(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add storage pool");	}	} catch (ResourceUnavailableException ex1) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex1.getMessage());	} catch (ResourceInUseException ex2) {	throw new ServerApiException(ApiErrorCode.RESOURCE_IN_USE_ERROR, ex2.getMessage());	} catch (UnknownHostException ex3) {	
exception 

========================= cloudstack sample_3230 =========================

public boolean configure(final String name, final Map<String, Object> xmlParams) throws ConfigurationException {	_peers = new HashMap<String, SocketChannel>(7);	_sslEngines = new HashMap<String, SSLEngine>(7);	_nodeId = ManagementServerNode.getManagementServerId();	
configuring clusteragentmanagerimpl management server node id msid 

public boolean start() {	if (!super.start()) {	return false;	}	_timer.schedule(new DirectAgentScanTimerTask(), STARTUP_DELAY, ScanInterval.value());	if (s_logger.isDebugEnabled()) {	
scheduled direct agent scan task to run at an interval of seconds 

public void scheduleHostScanTask() {	_timer.schedule(new DirectAgentScanTimerTask(), 0);	if (s_logger.isDebugEnabled()) {	
scheduled a direct agent scan task 

private void scanDirectAgentToLoad() {	if (s_logger.isTraceEnabled()) {	
begin scanning directly connected hosts 

private void scanDirectAgentToLoad() {	if (s_logger.isTraceEnabled()) {	}	final long cutSeconds = (System.currentTimeMillis() >> 10) - getTimeout();	final List<HostVO> hosts = _hostDao.findAndUpdateDirectAgentToLoad(cutSeconds, LoadSize.value().longValue(), _nodeId);	final List<HostVO> appliances = _hostDao.findAndUpdateApplianceToLoad(cutSeconds, _nodeId);	if (hosts != null) {	hosts.addAll(appliances);	if (hosts.size() > 0) {	
found unmanaged direct hosts processing connect for them 

final List<HostVO> appliances = _hostDao.findAndUpdateApplianceToLoad(cutSeconds, _nodeId);	if (hosts != null) {	hosts.addAll(appliances);	if (hosts.size() > 0) {	for (final HostVO host : hosts) {	try {	final AgentAttache agentattache = findAttache(host.getId());	if (agentattache != null) {	if (agentattache.forForward()) {	if (s_logger.isInfoEnabled()) {	
is detected down but we have a forward attache running disconnect this one before launching the host 

if (agentattache != null) {	if (agentattache.forForward()) {	if (s_logger.isInfoEnabled()) {	}	removeAgent(agentattache, Status.Disconnected);	} else {	continue;	}	}	if (s_logger.isDebugEnabled()) {	
loading directly connected host 

}	removeAgent(agentattache, Status.Disconnected);	} else {	continue;	}	}	if (s_logger.isDebugEnabled()) {	}	loadDirectlyConnectedHost(host, false);	} catch (final Throwable e) {	
can not load directly connected host due to 

}	if (s_logger.isDebugEnabled()) {	}	loadDirectlyConnectedHost(host, false);	} catch (final Throwable e) {	}	}	}	}	if (s_logger.isTraceEnabled()) {	
end scanning directly connected hosts 

protected void runInContext() {	try {	runDirectAgentScanTimerTask();	} catch (final Throwable e) {	
unexpected exception 

protected AgentAttache createAttache(final long id) {	
create forwarding clusteredagentattache for 

protected AgentAttache createAttache(final long id) {	final HostVO host = _hostDao.findById(id);	final AgentAttache attache = new ClusteredAgentAttache(this, id, host.getName());	AgentAttache old = null;	synchronized (_agents) {	old = _agents.get(id);	_agents.put(id, attache);	}	if (old != null) {	if (s_logger.isDebugEnabled()) {	
remove stale agent attache from current management server 

protected AgentAttache createAttacheForConnect(final HostVO host, final Link link) {	
create clusteredagentattache for 

protected AgentAttache createAttacheForDirectConnect(final Host host, final ServerResource resource) {	
create clustereddirectagentattache for 

public boolean executeUserRequest(final long hostId, final Event event) throws AgentUnavailableException {	if (event == Event.AgentDisconnected) {	if (s_logger.isDebugEnabled()) {	
received agent disconnect event for host 

public boolean reconnect(final long hostId) {	Boolean result;	try {	result = propagateAgentEvent(hostId, Event.ShutdownRequested);	if (result != null) {	return result;	}	} catch (final AgentUnavailableException e) {	
cannot propagate agent reconnect because agent is not available 

public void notifyNodesInCluster(final AgentAttache attache) {	
notifying other nodes of to disconnect 

public void notifyNodesInClusterToScheduleHostScanTask() {	if (s_logger.isDebugEnabled()) {	
notifying other ms nodes to run host scan task 

public void closePeer(final String peerName) {	synchronized (_peers) {	final SocketChannel ch = _peers.get(peerName);	if (ch != null) {	try {	ch.close();	} catch (final IOException e) {	
unable to close peer socket connection to 

public SocketChannel connectToPeer(final String peerName, final SocketChannel prevCh) {	synchronized (_peers) {	final SocketChannel ch = _peers.get(peerName);	SSLEngine sslEngine = null;	if (prevCh != null) {	try {	prevCh.close();	} catch (final Exception e) {	
ignored failed to get close resource for previous channel socket 

SSLEngine sslEngine = null;	if (prevCh != null) {	try {	prevCh.close();	} catch (final Exception e) {	}	}	if (ch == null || ch == prevCh) {	final ManagementServerHost ms = _clusterMgr.getPeer(peerName);	if (ms == null) {	
unable to find peer 

try {	final SSLContext sslContext = Link.initSSLContext(true);	sslEngine = sslContext.createSSLEngine(ip, Port.value());	sslEngine.setUseClientMode(true);	sslEngine.setEnabledProtocols(SSLUtils.getSupportedProtocols(sslEngine.getEnabledProtocols()));	sslEngine.beginHandshake();	if (!Link.doHandshake(ch1, sslEngine, true)) {	ch1.close();	throw new IOException("SSL handshake failed!");	}	
ssl handshake done 

sslEngine.beginHandshake();	if (!Link.doHandshake(ch1, sslEngine, true)) {	ch1.close();	throw new IOException("SSL handshake failed!");	}	} catch (final Exception e) {	ch1.close();	throw new IOException("SSL: Fail to init SSL! " + e);	}	if (s_logger.isDebugEnabled()) {	
connection to peer opened ip 

}	if (s_logger.isDebugEnabled()) {	}	_peers.put(peerName, ch1);	_sslEngines.put(peerName, sslEngine);	return ch1;	} catch (final IOException e) {	try {	ch1.close();	} catch (final IOException ex) {	
failed to close failed peer socket 

if (s_logger.isDebugEnabled()) {	}	_peers.put(peerName, ch1);	_sslEngines.put(peerName, sslEngine);	return ch1;	} catch (final IOException e) {	try {	ch1.close();	} catch (final IOException ex) {	}	
unable to connect to peer management server ip due to 

return ch1;	} catch (final IOException e) {	try {	ch1.close();	} catch (final IOException ex) {	}	return null;	}	}	if (s_logger.isTraceEnabled()) {	
found open channel for peer 

protected AgentAttache getAttache(final Long hostId) throws AgentUnavailableException {	assert hostId != null : "Who didn't check their id value?";	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	throw new AgentUnavailableException("Can't find the host ", hostId);	}	AgentAttache agent = findAttache(hostId);	if (agent == null || !agent.forForward()) {	if (isHostOwnerSwitched(host)) {	if (s_logger.isDebugEnabled()) {	
host has switched to another management server need to update agent map with a forwarding agent attache 

public boolean stop() {	if (_peers != null) {	for (final SocketChannel ch : _peers.values()) {	try {	
closing 

public boolean stop() {	if (_peers != null) {	for (final SocketChannel ch : _peers.values()) {	try {	ch.close();	} catch (final IOException e) {	
ignored error on closing channel 

protected void doTask(final Task task) throws TaskExecutionException {	final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);	try {	if (task.getType() != Task.Type.DATA) {	super.doTask(task);	return;	}	final byte[] data = task.getData();	final Version ver = Request.getVersion(data);	if (ver.ordinal() != Version.v1.ordinal() && ver.ordinal() != Version.v3.ordinal()) {	
wrong version for clustered agent request 

}	}	return;	} else {	if (Request.isRequest(data)) {	super.doTask(task);	} else {	final Response response = Response.parse(data);	final AgentAttache attache = findAttache(response.getAgentId());	if (attache == null) {	
seqa unable to find attache to forward 

} else {	if (Request.isRequest(data)) {	super.doTask(task);	} else {	final Response response = Response.parse(data);	final AgentAttache attache = findAttache(response.getAgentId());	if (attache == null) {	return;	}	if (!attache.processAnswers(response.getSequence(), response)) {	
seqa response is not processed 

public void onManagementNodeLeft(final List<? extends ManagementServerHost> nodeList, final long selfNodeId) {	for (final ManagementServerHost vo : nodeList) {	
marking hosts as disconnected on management server 

public void onManagementNodeLeft(final List<? extends ManagementServerHost> nodeList, final long selfNodeId) {	for (final ManagementServerHost vo : nodeList) {	final long lastPing = (System.currentTimeMillis() >> 10) - getTimeout();	_hostDao.markHostsAsDisconnected(vo.getMsid(), lastPing);	outOfBandManagementDao.expireOutOfBandManagementOwnershipByServer(vo.getMsid());	
deleting entries from op host transfer table for management server 

public AgentLoadBalancerTask() {	
agent load balancer task created 

public synchronized boolean cancel() {	if (!cancelled) {	cancelled = true;	
agent load balancer task cancelled 

protected synchronized void runInContext() {	try {	if (!cancelled) {	startRebalanceAgents();	if (s_logger.isInfoEnabled()) {	
the agent load balancer task is now being cancelled 

protected synchronized void runInContext() {	try {	if (!cancelled) {	startRebalanceAgents();	if (s_logger.isInfoEnabled()) {	}	cancelled = true;	}	} catch (final Throwable e) {	
unexpected exception 

public void startRebalanceAgents() {	
management server is asking other peers to rebalance their agents 

final List<ManagementServerHostVO> allMS = _mshostDao.listBy(ManagementServerHost.State.Up);	final QueryBuilder<HostVO> sc = QueryBuilder.create(HostVO.class);	sc.and(sc.entity().getManagementServerId(), Op.NNULL);	sc.and(sc.entity().getType(), Op.EQ, Host.Type.Routing);	final List<HostVO> allManagedAgents = sc.list();	int avLoad = 0;	if (!allManagedAgents.isEmpty() && !allMS.isEmpty()) {	avLoad = allManagedAgents.size() / allMS.size();	} else {	if (s_logger.isDebugEnabled()) {	
there are no hosts to rebalance in the system current number of active management server nodes in the system is number of managed agents is 

int avLoad = 0;	if (!allManagedAgents.isEmpty() && !allMS.isEmpty()) {	avLoad = allManagedAgents.size() / allMS.size();	} else {	if (s_logger.isDebugEnabled()) {	}	return;	}	if (avLoad == 0L) {	if (s_logger.isDebugEnabled()) {	
as calculated average load is less than rounding it to 

avLoad = 1;	}	for (final ManagementServerHostVO node : allMS) {	if (node.getMsid() != _nodeId) {	List<HostVO> hostsToRebalance = new ArrayList<HostVO>();	for (final AgentLoadBalancerPlanner lbPlanner : _lbPlanners) {	hostsToRebalance = lbPlanner.getHostsToRebalance(node.getMsid(), avLoad);	if (hostsToRebalance != null && !hostsToRebalance.isEmpty()) {	break;	} else {	
agent load balancer planner found no hosts to be rebalanced from management server 

if (node.getMsid() != _nodeId) {	List<HostVO> hostsToRebalance = new ArrayList<HostVO>();	for (final AgentLoadBalancerPlanner lbPlanner : _lbPlanners) {	hostsToRebalance = lbPlanner.getHostsToRebalance(node.getMsid(), avLoad);	if (hostsToRebalance != null && !hostsToRebalance.isEmpty()) {	break;	} else {	}	}	if (hostsToRebalance != null && !hostsToRebalance.isEmpty()) {	
found hosts to rebalance from management server 

break;	} else {	}	}	if (hostsToRebalance != null && !hostsToRebalance.isEmpty()) {	for (final HostVO host : hostsToRebalance) {	final long hostId = host.getId();	s_logger.debug("Asking management server " + node.getMsid() + " to give away host id=" + hostId);	boolean result = true;	if (_hostTransferDao.findById(hostId) != null) {	
somebody else is already rebalancing host id 

result = false;	}	} catch (final Exception ex) {	s_logger.warn("Failed to get host id=" + hostId + " from management server " + node.getMsid(), ex);	result = false;	} finally {	if (transfer != null) {	final HostTransferMapVO transferState = _hostTransferDao.findByIdAndFutureOwnerId(transfer.getId(), _nodeId);	if (!result && transferState != null && transferState.getState() == HostTransferState.TransferRequested) {	if (s_logger.isDebugEnabled()) {	
removing mapping from op host transfer as it failed to be set to transfer mode 

final HostTransferMapVO transferState = _hostTransferDao.findByIdAndFutureOwnerId(transfer.getId(), _nodeId);	if (!result && transferState != null && transferState.getState() == HostTransferState.TransferRequested) {	if (s_logger.isDebugEnabled()) {	}	_hostTransferDao.remove(transfer.getId());	}	}	}	}	} else {	
found no hosts to rebalance from the management server 

private Answer[] sendRebalanceCommand(final long peer, final long agentId, final long currentOwnerId, final long futureOwnerId, final Event event) {	final TransferAgentCommand transfer = new TransferAgentCommand(agentId, currentOwnerId, futureOwnerId, event);	final Commands commands = new Commands(Command.OnError.Stop);	commands.addCommand(transfer);	final Command[] cmds = commands.toCommands();	try {	if (s_logger.isDebugEnabled()) {	
forwarding to 

final Command[] cmds = commands.toCommands();	try {	if (s_logger.isDebugEnabled()) {	}	final String peerName = Long.toString(peer);	final String cmdStr = _gson.toJson(cmds);	final String ansStr = _clusterMgr.execute(peerName, agentId, cmdStr, true);	final Answer[] answers = _gson.fromJson(ansStr, Answer[].class);	return answers;	} catch (final Exception e) {	
caught exception while talking to 

public Boolean propagateAgentEvent(final long agentId, final Event event) throws AgentUnavailableException {	final String msPeer = getPeerName(agentId);	if (msPeer == null) {	return null;	}	if (s_logger.isDebugEnabled()) {	
propagating agent change request event to agent 

if (s_logger.isDebugEnabled()) {	}	final Command[] cmds = new Command[1];	cmds[0] = new ChangeAgentCommand(agentId, event);	final String ansStr = _clusterMgr.execute(msPeer, agentId, _gson.toJson(cmds), true);	if (ansStr == null) {	throw new AgentUnavailableException(agentId);	}	final Answer[] answers = _gson.fromJson(ansStr, Answer[].class);	if (s_logger.isDebugEnabled()) {	
result for agent change is 

private Runnable getTransferScanTask() {	return new ManagedContextRunnable() {	protected void runInContext() {	try {	if (s_logger.isTraceEnabled()) {	
clustered agent transfer scan check management server id 

private Runnable getTransferScanTask() {	return new ManagedContextRunnable() {	protected void runInContext() {	try {	if (s_logger.isTraceEnabled()) {	}	synchronized (_agentToTransferIds) {	if (_agentToTransferIds.size() > 0) {	
found agents to transfer 

continue;	}	if (transferMap.getInitialOwner() != _nodeId || attache == null || attache.forForward()) {	s_logger.debug("Management server " + _nodeId + " doesn't own host id=" + hostId + " any more, skipping rebalance for the host");	iterator.remove();	_hostTransferDao.completeAgentTransfer(hostId);	continue;	}	final ManagementServerHostVO ms = _mshostDao.findByMsid(transferMap.getFutureOwner());	if (ms != null && ms.getState() != ManagementServerHost.State.Up) {	
can t transfer host as it s future owner is not in up state skipping rebalance for the host 

}	if (attache.getQueueSize() == 0 && attache.getNonRecurringListenersSize() == 0) {	iterator.remove();	try {	_executor.execute(new RebalanceTask(hostId, transferMap.getInitialOwner(), transferMap.getFutureOwner()));	} catch (final RejectedExecutionException ex) {	s_logger.warn("Failed to submit rebalance task for host id=" + hostId + "; postponing the execution");	continue;	}	} else {	
agent can t be transfered yet as its request queue size is and listener queue size is 

_executor.execute(new RebalanceTask(hostId, transferMap.getInitialOwner(), transferMap.getFutureOwner()));	} catch (final RejectedExecutionException ex) {	s_logger.warn("Failed to submit rebalance task for host id=" + hostId + "; postponing the execution");	continue;	}	} else {	}	}	} else {	if (s_logger.isTraceEnabled()) {	
found no agents to be transfered by the management server 

}	} else {	}	}	} else {	if (s_logger.isTraceEnabled()) {	}	}	}	} catch (final Throwable e) {	
problem with the clustered agent transfer scan check 

private boolean setToWaitForRebalance(final long hostId, final long currentOwnerId, final long futureOwnerId) {	
adding agent to the list of agents to transfer 

protected boolean rebalanceHost(final long hostId, final long currentOwnerId, final long futureOwnerId) throws AgentUnavailableException {	boolean result = true;	if (currentOwnerId == _nodeId) {	if (!startRebalance(hostId)) {	
failed to start agent rebalancing 

if (!startRebalance(hostId)) {	finishRebalance(hostId, futureOwnerId, Event.RebalanceFailed);	return false;	}	try {	final Answer[] answer = sendRebalanceCommand(futureOwnerId, hostId, currentOwnerId, futureOwnerId, Event.StartAgentRebalance);	if (answer == null || !answer[0].getResult()) {	result = false;	}	} catch (final Exception ex) {	
host failed to connect to the management server as a part of rebalance process 

s_logger.debug("Successfully transfered host id=" + hostId + " to management server " + futureOwnerId);	finishRebalance(hostId, futureOwnerId, Event.RebalanceCompleted);	} else {	s_logger.warn("Failed to transfer host id=" + hostId + " to management server " + futureOwnerId);	finishRebalance(hostId, futureOwnerId, Event.RebalanceFailed);	}	} else if (futureOwnerId == _nodeId) {	final HostVO host = _hostDao.findById(hostId);	try {	if (s_logger.isDebugEnabled()) {	
disconnecting host as a part of rebalance process without notification 

final HostVO host = _hostDao.findById(hostId);	try {	if (s_logger.isDebugEnabled()) {	}	final AgentAttache attache = findAttache(hostId);	if (attache != null) {	result = handleDisconnect(attache, Event.AgentDisconnected, false, false, true);	}	if (result) {	if (s_logger.isDebugEnabled()) {	
loading directly connected host to the management server as a part of rebalance process 

}	final AgentAttache attache = findAttache(hostId);	if (attache != null) {	result = handleDisconnect(attache, Event.AgentDisconnected, false, false, true);	}	if (result) {	if (s_logger.isDebugEnabled()) {	}	result = loadDirectlyConnectedHost(host, true);	} else {	
failed to disconnect as a part of rebalance process without notification 

if (attache != null) {	result = handleDisconnect(attache, Event.AgentDisconnected, false, false, true);	}	if (result) {	if (s_logger.isDebugEnabled()) {	}	result = loadDirectlyConnectedHost(host, true);	} else {	}	} catch (final Exception ex) {	
failed to load directly connected host to the management server as a part of rebalance process due to 

if (result) {	if (s_logger.isDebugEnabled()) {	}	result = loadDirectlyConnectedHost(host, true);	} else {	}	} catch (final Exception ex) {	result = false;	}	if (result) {	
successfully loaded directly connected host to the management server as a part of rebalance process 

if (s_logger.isDebugEnabled()) {	}	result = loadDirectlyConnectedHost(host, true);	} else {	}	} catch (final Exception ex) {	result = false;	}	if (result) {	} else {	
failed to load directly connected host to the management server as a part of rebalance process 

protected void finishRebalance(final long hostId, final long futureOwnerId, final Event event) {	final boolean success = event == Event.RebalanceCompleted ? true : false;	if (s_logger.isDebugEnabled()) {	
finishing rebalancing for the agent with event 

if (attache == null || !(attache instanceof ClusteredAgentAttache)) {	s_logger.debug("Unable to find forward attache for the host id=" + hostId + ", assuming that the agent disconnected already");	_hostTransferDao.completeAgentTransfer(hostId);	return;	}	final ClusteredAgentAttache forwardAttache = (ClusteredAgentAttache)attache;	if (success) {	forwardAttache.setTransferMode(false);	Request requestToTransfer = forwardAttache.getRequestToTransfer();	while (requestToTransfer != null) {	
forwarding request held in transfer attache from the management server to 

if (success) {	forwardAttache.setTransferMode(false);	Request requestToTransfer = forwardAttache.getRequestToTransfer();	while (requestToTransfer != null) {	final boolean routeResult = routeToPeer(Long.toString(futureOwnerId), requestToTransfer.getBytes());	if (!routeResult) {	logD(requestToTransfer.getBytes(), "Failed to route request to peer");	}	requestToTransfer = forwardAttache.getRequestToTransfer();	}	
management server completed agent rebalance to 

while (requestToTransfer != null) {	final boolean routeResult = routeToPeer(Long.toString(futureOwnerId), requestToTransfer.getBytes());	if (!routeResult) {	logD(requestToTransfer.getBytes(), "Failed to route request to peer");	}	requestToTransfer = forwardAttache.getRequestToTransfer();	}	} else {	failRebalance(hostId);	}	
management server completed agent rebalance 

protected void failRebalance(final long hostId) {	try {	
management server failed to rebalance agent 

protected boolean startRebalance(final long hostId) {	final HostVO host = _hostDao.findById(hostId);	if (host == null || host.getRemoved() != null) {	
unable to find host record fail start rebalancing process 

final HostVO host = _hostDao.findById(hostId);	if (host == null || host.getRemoved() != null) {	return false;	}	synchronized (_agents) {	final ClusteredDirectAgentAttache attache = (ClusteredDirectAgentAttache)_agents.get(hostId);	if (attache != null && attache.getQueueSize() == 0 && attache.getNonRecurringListenersSize() == 0) {	handleDisconnectWithoutInvestigation(attache, Event.StartAgentRebalance, true, true);	final ClusteredAgentAttache forwardAttache = (ClusteredAgentAttache)createAttache(hostId);	if (forwardAttache == null) {	
unable to create a forward attache for the host as a part of rebalance process 

handleDisconnectWithoutInvestigation(attache, Event.StartAgentRebalance, true, true);	final ClusteredAgentAttache forwardAttache = (ClusteredAgentAttache)createAttache(hostId);	if (forwardAttache == null) {	return false;	}	s_logger.debug("Putting agent id=" + hostId + " to transfer mode");	forwardAttache.setTransferMode(true);	_agents.put(hostId, forwardAttache);	} else {	if (attache == null) {	
attache for the agent no longer exists on management server can t start host rebalancing 

private String handleScheduleHostScanTaskCommand(final ScheduleHostScanTaskCommand cmd) {	if (s_logger.isDebugEnabled()) {	
intercepting resource manager command 

private String handleScheduleHostScanTaskCommand(final ScheduleHostScanTaskCommand cmd) {	if (s_logger.isDebugEnabled()) {	}	try {	scheduleHostScanTask();	} catch (final Exception e) {	
exception happened while trying to schedule host scan task on mgmt server ignoring as regular host scan happens at fixed interval anyways 

public String dispatch(final ClusterServicePdu pdu) {	if (s_logger.isDebugEnabled()) {	
dispatch json 

public String dispatch(final ClusterServicePdu pdu) {	if (s_logger.isDebugEnabled()) {	}	Command[] cmds = null;	try {	cmds = _gson.fromJson(pdu.getJsonPackage(), Command[].class);	} catch (final Throwable e) {	assert false;	
excection in gson decoding 

}	Command[] cmds = null;	try {	cmds = _gson.fromJson(pdu.getJsonPackage(), Command[].class);	} catch (final Throwable e) {	assert false;	}	if (cmds.length == 1 && cmds[0] instanceof ChangeAgentCommand) {	final ChangeAgentCommand cmd = (ChangeAgentCommand)cmds[0];	if (s_logger.isDebugEnabled()) {	
intercepting command for agent change agent event 

assert false;	}	if (cmds.length == 1 && cmds[0] instanceof ChangeAgentCommand) {	final ChangeAgentCommand cmd = (ChangeAgentCommand)cmds[0];	if (s_logger.isDebugEnabled()) {	}	boolean result = false;	try {	result = executeAgentUserRequest(cmd.getAgentId(), cmd.getEvent());	if (s_logger.isDebugEnabled()) {	
result is 

if (cmds.length == 1 && cmds[0] instanceof ChangeAgentCommand) {	final ChangeAgentCommand cmd = (ChangeAgentCommand)cmds[0];	if (s_logger.isDebugEnabled()) {	}	boolean result = false;	try {	result = executeAgentUserRequest(cmd.getAgentId(), cmd.getEvent());	if (s_logger.isDebugEnabled()) {	}	} catch (final AgentUnavailableException e) {	
agent is unavailable 

}	} catch (final AgentUnavailableException e) {	return null;	}	final Answer[] answers = new Answer[1];	answers[0] = new ChangeAgentAnswer(cmd, result);	return _gson.toJson(answers);	} else if (cmds.length == 1 && cmds[0] instanceof TransferAgentCommand) {	final TransferAgentCommand cmd = (TransferAgentCommand)cmds[0];	if (s_logger.isDebugEnabled()) {	
intercepting command for agent rebalancing agent event 

answers[0] = new ChangeAgentAnswer(cmd, result);	return _gson.toJson(answers);	} else if (cmds.length == 1 && cmds[0] instanceof TransferAgentCommand) {	final TransferAgentCommand cmd = (TransferAgentCommand)cmds[0];	if (s_logger.isDebugEnabled()) {	}	boolean result = false;	try {	result = rebalanceAgent(cmd.getAgentId(), cmd.getEvent(), cmd.getCurrentOwner(), cmd.getFutureOwner());	if (s_logger.isDebugEnabled()) {	
result is 

} else if (cmds.length == 1 && cmds[0] instanceof TransferAgentCommand) {	final TransferAgentCommand cmd = (TransferAgentCommand)cmds[0];	if (s_logger.isDebugEnabled()) {	}	boolean result = false;	try {	result = rebalanceAgent(cmd.getAgentId(), cmd.getEvent(), cmd.getCurrentOwner(), cmd.getFutureOwner());	if (s_logger.isDebugEnabled()) {	}	} catch (final AgentUnavailableException e) {	
agent is unavailable 

if (s_logger.isDebugEnabled()) {	}	boolean result = false;	try {	result = rebalanceAgent(cmd.getAgentId(), cmd.getEvent(), cmd.getCurrentOwner(), cmd.getFutureOwner());	if (s_logger.isDebugEnabled()) {	}	} catch (final AgentUnavailableException e) {	return null;	} catch (final OperationTimedoutException e) {	
operation timed out 

} catch (final AgentUnavailableException e) {	return null;	} catch (final OperationTimedoutException e) {	return null;	}	final Answer[] answers = new Answer[1];	answers[0] = new Answer(cmd, result, null);	return _gson.toJson(answers);	} else if (cmds.length == 1 && cmds[0] instanceof PropagateResourceEventCommand) {	final PropagateResourceEventCommand cmd = (PropagateResourceEventCommand)cmds[0];	
intercepting command to propagate event for host 

return null;	}	final Answer[] answers = new Answer[1];	answers[0] = new Answer(cmd, result, null);	return _gson.toJson(answers);	} else if (cmds.length == 1 && cmds[0] instanceof PropagateResourceEventCommand) {	final PropagateResourceEventCommand cmd = (PropagateResourceEventCommand)cmds[0];	boolean result = false;	try {	result = _resourceMgr.executeUserRequest(cmd.getHostId(), cmd.getEvent());	
result is 

}	final Answer[] answers = new Answer[1];	answers[0] = new Answer(cmd, result, null);	return _gson.toJson(answers);	} else if (cmds.length == 1 && cmds[0] instanceof PropagateResourceEventCommand) {	final PropagateResourceEventCommand cmd = (PropagateResourceEventCommand)cmds[0];	boolean result = false;	try {	result = _resourceMgr.executeUserRequest(cmd.getHostId(), cmd.getEvent());	} catch (final AgentUnavailableException ex) {	
agent is unavailable 

answers[0] = new Answer(cmd, result, null);	return _gson.toJson(answers);	} else if (cmds.length == 1 && cmds[0] instanceof ScheduleHostScanTaskCommand) {	final ScheduleHostScanTaskCommand cmd = (ScheduleHostScanTaskCommand)cmds[0];	final String response = handleScheduleHostScanTaskCommand(cmd);	return response;	}	try {	final long startTick = System.currentTimeMillis();	if (s_logger.isDebugEnabled()) {	
dispatch json 

return response;	}	try {	final long startTick = System.currentTimeMillis();	if (s_logger.isDebugEnabled()) {	}	final Answer[] answers = sendToAgent(pdu.getAgentId(), cmds, pdu.isStopOnError());	if (answers != null) {	final String jsonReturn = _gson.toJson(answers);	if (s_logger.isDebugEnabled()) {	
completed dispatching json in ms return result 

if (s_logger.isDebugEnabled()) {	}	final Answer[] answers = sendToAgent(pdu.getAgentId(), cmds, pdu.isStopOnError());	if (answers != null) {	final String jsonReturn = _gson.toJson(answers);	if (s_logger.isDebugEnabled()) {	}	return jsonReturn;	} else {	if (s_logger.isDebugEnabled()) {	
completed dispatching json in ms return null result 

if (answers != null) {	final String jsonReturn = _gson.toJson(answers);	if (s_logger.isDebugEnabled()) {	}	return jsonReturn;	} else {	if (s_logger.isDebugEnabled()) {	}	}	} catch (final AgentUnavailableException e) {	
agent is unavailable 

final String jsonReturn = _gson.toJson(answers);	if (s_logger.isDebugEnabled()) {	}	return jsonReturn;	} else {	if (s_logger.isDebugEnabled()) {	}	}	} catch (final AgentUnavailableException e) {	} catch (final OperationTimedoutException e) {	
timed out 

private Runnable getAgentRebalanceScanTask() {	return new ManagedContextRunnable() {	protected void runInContext() {	try {	if (s_logger.isTraceEnabled()) {	
agent rebalance task check management server id 

sc.and(sc.entity().getType(), Op.EQ, Host.Type.Routing);	final List<HostVO> allManagedRoutingAgents = sc.list();	sc = QueryBuilder.create(HostVO.class);	sc.and(sc.entity().getType(), Op.EQ, Host.Type.Routing);	final List<HostVO> allAgents = sc.list();	final double allHostsCount = allAgents.size();	final double managedHostsCount = allManagedRoutingAgents.size();	if (allHostsCount > 0.0) {	final double load = managedHostsCount / allHostsCount;	if (load > ConnectedAgentThreshold.value()) {	
scheduling agent rebalancing task as the average agent load is more than the threshold 

sc.and(sc.entity().getType(), Op.EQ, Host.Type.Routing);	final List<HostVO> allAgents = sc.list();	final double allHostsCount = allAgents.size();	final double managedHostsCount = allManagedRoutingAgents.size();	if (allHostsCount > 0.0) {	final double load = managedHostsCount / allHostsCount;	if (load > ConnectedAgentThreshold.value()) {	scheduleRebalanceAgents();	_agentLbHappened = true;	} else {	
not scheduling agent rebalancing task as the average load has not crossed the threshold 

if (allHostsCount > 0.0) {	final double load = managedHostsCount / allHostsCount;	if (load > ConnectedAgentThreshold.value()) {	scheduleRebalanceAgents();	_agentLbHappened = true;	} else {	}	}	}	} catch (final Throwable e) {	
problem with the clustered agent transfer scan check 

public void rescan() {	if (s_logger.isDebugEnabled()) {	
scheduling a host scan task 

public void rescan() {	if (s_logger.isDebugEnabled()) {	}	scheduleHostScanTask();	if (s_logger.isDebugEnabled()) {	
notifying all peer ms to schedule host scan task 

========================= cloudstack sample_4776 =========================

public Answer execute(final RebootCommand command, final LibvirtComputingResource libvirtComputingResource) {	final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	try {	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(command.getVmName());	final String result = libvirtComputingResource.rebootVM(conn, command.getVmName());	if (result == null) {	Integer vncPort = null;	try {	vncPort = libvirtComputingResource.getVncPort(conn, command.getVmName());	} catch (final LibvirtException e) {	
ignoring libvirt error 

========================= cloudstack sample_1061 =========================

protected boolean canHandle(NetworkOffering offering, final NetworkType networkType, final PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && isMyIsolationMethod(physicalNetwork) && _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering( offering.getId(), Service.Connectivity)) {	return true;	} else {	
we only take care of guest networks of type in zone of type 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan .getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	
refusing to design this network 

public Network implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException {	assert (network.getState() == State.Implementing) : "Why are we implementing " + network;	long dcId = dest.getDataCenter().getId();	NetworkType nwType = dest.getDataCenter().getNetworkType();	Long physicalNetworkId = network.getPhysicalNetworkId();	if (physicalNetworkId == null) {	physicalNetworkId = _networkModel.findPhysicalNetworkId(dcId, offering.getTags(), offering.getTrafficType());	}	PhysicalNetworkVO physnet = _physicalNetworkDao .findById(physicalNetworkId);	if (!canHandle(offering, nwType, physnet)) {	
refusing to design this network 

public void shutdown(NetworkProfile profile, NetworkOffering offering) {	NetworkVO networkObject = _networkDao.findById(profile.getId());	if (networkObject.getBroadcastDomainType() != BroadcastDomainType.Vswitch || networkObject.getBroadcastUri() == null) {	
broadcasturi is empty or incorrect for guestnetwork 

========================= cloudstack sample_1431 =========================

public SecondaryStorageVmVO startSecStorageVm(long secStorageVmId) {	try {	SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findById(secStorageVmId);	_itMgr.advanceStart(secStorageVm.getUuid(), null, null);	return _secStorageVmDao.findById(secStorageVm.getId());	} catch (StorageUnavailableException e) {	
exception while trying to start secondary storage vm 

public SecondaryStorageVmVO startSecStorageVm(long secStorageVmId) {	try {	SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findById(secStorageVmId);	_itMgr.advanceStart(secStorageVm.getUuid(), null, null);	return _secStorageVmDao.findById(secStorageVm.getId());	} catch (StorageUnavailableException e) {	return null;	} catch (InsufficientCapacityException e) {	
exception while trying to start secondary storage vm 

public SecondaryStorageVmVO startSecStorageVm(long secStorageVmId) {	try {	SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findById(secStorageVmId);	_itMgr.advanceStart(secStorageVm.getUuid(), null, null);	return _secStorageVmDao.findById(secStorageVm.getId());	} catch (StorageUnavailableException e) {	return null;	} catch (InsufficientCapacityException e) {	return null;	} catch (ResourceUnavailableException e) {	
exception while trying to start secondary storage vm 

SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findById(secStorageVmId);	_itMgr.advanceStart(secStorageVm.getUuid(), null, null);	return _secStorageVmDao.findById(secStorageVm.getId());	} catch (StorageUnavailableException e) {	return null;	} catch (InsufficientCapacityException e) {	return null;	} catch (ResourceUnavailableException e) {	return null;	} catch (Exception e) {	
exception while trying to start secondary storage vm 

public boolean generateSetupCommand(Long ssHostId) {	HostVO cssHost = _hostDao.findById(ssHostId);	Long zoneId = cssHost.getDataCenterId();	if (cssHost.getType() == Host.Type.SecondaryStorageVM) {	SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findByInstanceName(cssHost.getName());	if (secStorageVm == null) {	
secondary storage vm doesn t exist 

setupCmd.setPostUploadKey(postUploadKey);	Answer answer = _agentMgr.easySend(ssHostId, setupCmd);	if (answer != null && answer.getResult()) {	SecStorageSetupAnswer an = (SecStorageSetupAnswer)answer;	if (an.get_dir() != null) {	ImageStoreVO svo = _imageStoreDao.findById(ssStore.getId());	svo.setParent(an.get_dir());	_imageStoreDao.update(ssStore.getId(), svo);	}	if (s_logger.isDebugEnabled()) {	
successfully programmed secondary storage in secondary storage vm 

SecStorageSetupAnswer an = (SecStorageSetupAnswer)answer;	if (an.get_dir() != null) {	ImageStoreVO svo = _imageStoreDao.findById(ssStore.getId());	svo.setParent(an.get_dir());	_imageStoreDao.update(ssStore.getId(), svo);	}	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
successfully programmed secondary storage in secondary storage vm 

}	else if( cssHost.getType() == Host.Type.SecondaryStorage ) {	List<SecondaryStorageVmVO> alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, zoneId, State.Running);	String secUrl = cssHost.getStorageUrl();	SecStorageSetupCommand setupCmd = new SecStorageSetupCommand(secUrl, null);	for ( SecondaryStorageVmVO ssVm : alreadyRunning ) {	HostVO host = _resourceMgr.findHostByName(ssVm.getInstanceName());	Answer answer = _agentMgr.easySend(host.getId(), setupCmd);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	
successfully programmed secondary storage in secondary storage vm 

String secUrl = cssHost.getStorageUrl();	SecStorageSetupCommand setupCmd = new SecStorageSetupCommand(secUrl, null);	for ( SecondaryStorageVmVO ssVm : alreadyRunning ) {	HostVO host = _resourceMgr.findHostByName(ssVm.getInstanceName());	Answer answer = _agentMgr.easySend(host.getId(), setupCmd);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
successfully programmed secondary storage in secondary storage vm 

public boolean generateVMSetupCommand(Long ssAHostId) {	HostVO ssAHost = _hostDao.findById(ssAHostId);	if (ssAHost.getType() != Host.Type.SecondaryStorageVM) {	return false;	}	SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findByInstanceName(ssAHost.getName());	if (secStorageVm == null) {	
secondary storage vm doesn t exist 

}	}	setupCmd.setAllowedInternalSites(allowedCidrs.toArray(new String[allowedCidrs.size()]));	}	String copyPasswd = _configDao.getValue("secstorage.copy.password");	setupCmd.setCopyPassword(copyPasswd);	setupCmd.setCopyUserName(TemplateConstants.DEFAULT_HTTP_AUTH_USER);	Answer answer = _agentMgr.easySend(ssAHostId, setupCmd);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	
successfully programmed http auth into 

String copyPasswd = _configDao.getValue("secstorage.copy.password");	setupCmd.setCopyPassword(copyPasswd);	setupCmd.setCopyUserName(TemplateConstants.DEFAULT_HTTP_AUTH_USER);	Answer answer = _agentMgr.easySend(ssAHostId, setupCmd);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	}	return true;	} else {	if (s_logger.isDebugEnabled()) {	
failed to program http auth into secondary storage vm 

public boolean generateFirewallConfiguration(Long ssAHostId) {	if (ssAHostId == null) {	return true;	}	HostVO ssAHost = _hostDao.findById(ssAHostId);	SecondaryStorageVmVO thisSecStorageVm = _secStorageVmDao.findByInstanceName(ssAHost.getName());	if (thisSecStorageVm == null) {	
secondary storage vm doesn t exist 

sc.and(sc.entity().getType(), Op.EQ, Host.Type.SecondaryStorageVM);	sc.and(sc.entity().getStatus(), Op.IN, Status.Up, Status.Connecting);	List<HostVO> ssvms = sc.list();	for (HostVO ssvm : ssvms) {	if (ssvm.getId() == ssAHostId) {	continue;	}	Answer answer = _agentMgr.easySend(ssvm.getId(), thiscpc);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	
successfully programmed firewall rules into ssvm 

for (HostVO ssvm : ssvms) {	if (ssvm.getId() == ssAHostId) {	continue;	}	Answer answer = _agentMgr.easySend(ssvm.getId(), thiscpc);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
failed to program firewall rules into secondary storage vm 

SecStorageFirewallCfgCommand allSSVMIpList = new SecStorageFirewallCfgCommand(false);	for (HostVO ssvm : ssvms) {	if (ssvm.getId() == ssAHostId) {	continue;	}	allSSVMIpList.addPortConfig(ssvm.getPublicIpAddress(), copyPort, true, TemplateConstants.DEFAULT_TMPLT_COPY_INTF);	}	Answer answer = _agentMgr.easySend(ssAHostId, allSSVMIpList);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	
successfully programmed firewall rules into 

continue;	}	allSSVMIpList.addPortConfig(ssvm.getPublicIpAddress(), copyPort, true, TemplateConstants.DEFAULT_TMPLT_COPY_INTF);	}	Answer answer = _agentMgr.easySend(ssAHostId, allSSVMIpList);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
failed to program firewall rules into secondary storage vm 

public SecondaryStorageVmVO startNew(long dataCenterId, SecondaryStorageVm.Role role) {	if (!isSecondaryStorageVmRequired(dataCenterId)) {	if (s_logger.isDebugEnabled()) {	
secondary storage vm not required in zone acc to zone config 

public SecondaryStorageVmVO startNew(long dataCenterId, SecondaryStorageVm.Role role) {	if (!isSecondaryStorageVmRequired(dataCenterId)) {	if (s_logger.isDebugEnabled()) {	}	return null;	}	if (s_logger.isDebugEnabled()) {	
assign secondary storage vm from a newly started instance for request from data center 

if (s_logger.isDebugEnabled()) {	}	return null;	}	if (s_logger.isDebugEnabled()) {	}	Map<String, Object> context = createSecStorageVmInstance(dataCenterId, role);	long secStorageVmId = (Long)context.get("secStorageVmId");	if (secStorageVmId == 0) {	if (s_logger.isTraceEnabled()) {	
creating secondary storage vm instance failed data center id 

if (s_logger.isTraceEnabled()) {	}	return null;	}	SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findById(secStorageVmId);	if (secStorageVm != null) {	SubscriptionMgr.getInstance().notifySubscribers(ALERT_SUBJECT, this, new SecStorageVmAlertEventArgs(SecStorageVmAlertEventArgs.SSVM_CREATED, dataCenterId, secStorageVmId, secStorageVm, null));	return secStorageVm;	} else {	if (s_logger.isDebugEnabled()) {	
unable to allocate secondary storage vm storage remove the secondary storage vm record from db secondary storage vm id 

LinkedHashMap<Network, List<? extends NicProfile>> networks = new LinkedHashMap<Network, List<? extends NicProfile>>(offerings.size() + 1);	NicProfile defaultNic = new NicProfile();	defaultNic.setDefaultNic(true);	defaultNic.setDeviceId(2);	try {	networks.put(_networkMgr.setupNetwork(systemAcct, _networkOfferingDao.findById(defaultNetwork.getNetworkOfferingId()), plan, null, null, false).get(0), new ArrayList<NicProfile>(Arrays.asList(defaultNic)));	for (NetworkOffering offering : offerings) {	networks.put(_networkMgr.setupNetwork(systemAcct, offering, plan, null, null, false).get(0), new ArrayList<NicProfile>());	}	} catch (ConcurrentOperationException e) {	
unable to setup due to concurrent operation 

if (serviceOffering == null) {	serviceOffering = _offeringDao.findDefaultSystemOffering(ServiceOffering.ssvmDefaultOffUniqueName, ConfigurationManagerImpl.SystemVMUseLocalStorage.valueIn(dataCenterId));	}	SecondaryStorageVmVO secStorageVm = new SecondaryStorageVmVO(id, serviceOffering.getId(), name, template.getId(), template.getHypervisorType(), template.getGuestOSId(), dataCenterId, systemAcct.getDomainId(), systemAcct.getId(), _accountMgr.getSystemUser().getId(), role, serviceOffering.getOfferHA());	secStorageVm.setDynamicallyScalable(template.isDynamicallyScalable());	secStorageVm = _secStorageVmDao.persist(secStorageVm);	try {	_itMgr.allocate(name, template, serviceOffering, networks, plan, null);	secStorageVm = _secStorageVmDao.findById(secStorageVm.getId());	} catch (InsufficientCapacityException e) {	
InsufficientCapacity 

public SecondaryStorageVmVO assignSecStorageVmFromRunningPool(long dataCenterId, SecondaryStorageVm.Role role) {	if (s_logger.isTraceEnabled()) {	
assign secondary storage vm from running pool for request from data center 

public SecondaryStorageVmVO assignSecStorageVmFromRunningPool(long dataCenterId, SecondaryStorageVm.Role role) {	if (s_logger.isTraceEnabled()) {	}	SecondaryStorageVmAllocator allocator = getCurrentAllocator();	assert (allocator != null);	List<SecondaryStorageVmVO> runningList = _secStorageVmDao.getSecStorageVmListInStates(role, dataCenterId, State.Running);	if (runningList != null && runningList.size() > 0) {	if (s_logger.isTraceEnabled()) {	
running secondary storage vm pool size 

public SecondaryStorageVmVO assignSecStorageVmFromRunningPool(long dataCenterId, SecondaryStorageVm.Role role) {	if (s_logger.isTraceEnabled()) {	}	SecondaryStorageVmAllocator allocator = getCurrentAllocator();	assert (allocator != null);	List<SecondaryStorageVmVO> runningList = _secStorageVmDao.getSecStorageVmListInStates(role, dataCenterId, State.Running);	if (runningList != null && runningList.size() > 0) {	if (s_logger.isTraceEnabled()) {	for (SecondaryStorageVmVO secStorageVm : runningList) {	
running secstoragevm instance 

List<SecondaryStorageVmVO> runningList = _secStorageVmDao.getSecStorageVmListInStates(role, dataCenterId, State.Running);	if (runningList != null && runningList.size() > 0) {	if (s_logger.isTraceEnabled()) {	for (SecondaryStorageVmVO secStorageVm : runningList) {	}	}	Map<Long, Integer> loadInfo = new HashMap<Long, Integer>();	return allocator.allocSecondaryStorageVm(runningList, loadInfo, dataCenterId);	} else {	if (s_logger.isTraceEnabled()) {	
empty running secstoragevm pool for now in data center 

private void allocCapacity(long dataCenterId, SecondaryStorageVm.Role role) {	if (s_logger.isTraceEnabled()) {	
allocate secondary storage vm standby capacity for data center 

private void allocCapacity(long dataCenterId, SecondaryStorageVm.Role role) {	if (s_logger.isTraceEnabled()) {	}	if (!isSecondaryStorageVmRequired(dataCenterId)) {	if (s_logger.isDebugEnabled()) {	
secondary storage vm not required in zone according to zone config 

}	return;	}	SecondaryStorageVmVO secStorageVm = null;	String errorString = null;	try {	boolean secStorageVmFromStoppedPool = false;	secStorageVm = assignSecStorageVmFromStoppedPool(dataCenterId, role);	if (secStorageVm == null) {	if (s_logger.isInfoEnabled()) {	
no stopped secondary storage vm is available need to allocate a new secondary storage vm 

try {	secStorageVm = startNew(dataCenterId, role);	for (UploadVO upload : _uploadDao.listAll()) {	_uploadDao.expunge(upload.getId());	}	} finally {	_allocLock.unlock();	}	} else {	if (s_logger.isInfoEnabled()) {	
unable to acquire synchronization lock for secondary storage vm allocation wait for next scan 

} finally {	_allocLock.unlock();	}	} else {	if (s_logger.isInfoEnabled()) {	}	return;	}	} else {	if (s_logger.isInfoEnabled()) {	
found a stopped secondary storage vm starting it vm id 

GlobalLock secStorageVmLock = GlobalLock.getInternLock(getSecStorageVmLockName(secStorageVmId));	try {	if (secStorageVmLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_SYNC)) {	try {	secStorageVm = startSecStorageVm(secStorageVmId);	} finally {	secStorageVmLock.unlock();	}	} else {	if (s_logger.isInfoEnabled()) {	
unable to acquire synchronization lock for starting secondary storage vm id 

} else {	if (s_logger.isInfoEnabled()) {	}	return;	}	} finally {	secStorageVmLock.releaseRef();	}	if (secStorageVm == null) {	if (s_logger.isInfoEnabled()) {	
unable to start secondary storage vm for standby capacity vm id will recycle it and start a new one 

}	if (secStorageVm == null) {	if (s_logger.isInfoEnabled()) {	}	if (secStorageVmFromStoppedPool) {	destroySecStorageVm(secStorageVmId);	}	} else {	SubscriptionMgr.getInstance().notifySubscribers(ALERT_SUBJECT, this, new SecStorageVmAlertEventArgs(SecStorageVmAlertEventArgs.SSVM_UP, dataCenterId, secStorageVmId, secStorageVm, null));	if (s_logger.isInfoEnabled()) {	
secondary storage vm is started 

public boolean isZoneReady(Map<Long, ZoneHostInfo> zoneHostInfoMap, long dataCenterId) {	ZoneHostInfo zoneHostInfo = zoneHostInfoMap.get(dataCenterId);	if (zoneHostInfo != null && (zoneHostInfo.getFlags() & RunningHostInfoAgregator.ZoneHostInfo.ROUTING_HOST_MASK) != 0) {	VMTemplateVO template = _templateDao.findSystemVMReadyTemplate(dataCenterId, HypervisorType.Any);	if (template == null) {	if (s_logger.isDebugEnabled()) {	
system vm template is not ready at data center wait until it is ready to launch secondary storage vm 

ZoneHostInfo zoneHostInfo = zoneHostInfoMap.get(dataCenterId);	if (zoneHostInfo != null && (zoneHostInfo.getFlags() & RunningHostInfoAgregator.ZoneHostInfo.ROUTING_HOST_MASK) != 0) {	VMTemplateVO template = _templateDao.findSystemVMReadyTemplate(dataCenterId, HypervisorType.Any);	if (template == null) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	List<DataStore> stores = _dataStoreMgr.getImageStoresByScope(new ZoneScope(dataCenterId));	if (stores.size() < 1) {	
no image store added in zone wait until it is ready to launch secondary storage vm 

}	return false;	}	List<DataStore> stores = _dataStoreMgr.getImageStoresByScope(new ZoneScope(dataCenterId));	if (stores.size() < 1) {	return false;	}	DataStore store = templateMgr.getImageStore(dataCenterId, template.getId());	if (store == null) {	if (s_logger.isDebugEnabled()) {	
no secondary storage available in zone wait until it is ready to launch secondary storage vm 

boolean useLocalStorage = false;	Boolean useLocal = ConfigurationManagerImpl.SystemVMUseLocalStorage.valueIn(dataCenterId);	if (useLocal != null) {	useLocalStorage = useLocal.booleanValue();	}	List<Pair<Long, Integer>> l = _storagePoolHostDao.getDatacenterStoragePoolHostInfo(dataCenterId, !useLocalStorage);	if (l != null && l.size() > 0 && l.get(0).second().intValue() > 0) {	return true;	} else {	if (s_logger.isDebugEnabled()) {	
primary storage is not ready wait until it is ready to launch secondary storage vm dcid if you want to use local storage to start ssvm need to set to true 

public boolean start() {	if (s_logger.isInfoEnabled()) {	
start secondary storage vm manager 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (s_logger.isInfoEnabled()) {	
start configuring secondary storage vm manager 

boolean _useServiceVM = false;	if ("true".equalsIgnoreCase(useServiceVM)) {	_useServiceVM = true;	}	String sslcopy = _configDao.getValue("secstorage.encrypt.copy");	if ("true".equalsIgnoreCase(sslcopy)) {	_useSSlCopy = true;	}	String ssvmUrlDomain = _configDao.getValue("secstorage.ssl.cert.domain");	if(_useSSlCopy && (ssvmUrlDomain == null || ssvmUrlDomain.isEmpty())){	
empty secondary storage url domain explicitly disabling ssl 

} else if (uri.getHost() == null) {	errMsg = "host can not be null";	valid = false;	} else if (uri.getPort() == -1) {	_httpProxy = _httpProxy + ":3128";	}	} catch (URISyntaxException e) {	errMsg = e.toString();	} finally {	if (!valid) {	
ssvm http proxy is invalid 

}	} catch (URISyntaxException e) {	errMsg = e.toString();	} finally {	if (!valid) {	throw new ConfigurationException("ssvm http proxy " + _httpProxy + "is invalid: " + errMsg);	}	}	}	if (s_logger.isInfoEnabled()) {	
secondary storage vm manager is configured 

s_logger.debug(msg);	return false;	}	} finally {	secStorageVmLock.releaseRef();	}	}	return true;	} catch (ResourceUnavailableException e) {	if (s_logger.isDebugEnabled()) {	
stopping secondary storage vm faled exception 

public boolean rebootSecStorageVm(long secStorageVmId) {	final SecondaryStorageVmVO secStorageVm = _secStorageVmDao.findById(secStorageVmId);	if (secStorageVm == null || secStorageVm.getState() == State.Destroyed) {	return false;	}	if (secStorageVm.getState() == State.Running && secStorageVm.getHostId() != null) {	final RebootCommand cmd = new RebootCommand(secStorageVm.getInstanceName(), _itMgr.getExecuteInSequence(secStorageVm.getHypervisorType()));	final Answer answer = _agentMgr.easySend(secStorageVm.getHostId(), cmd);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	
successfully reboot secondary storage vm 

HostVO host = _hostDao.findByTypeNameAndZoneId(ssvm.getDataCenterId(), ssvm.getHostName(), Host.Type.SecondaryStorageVM);	if (host != null) {	s_logger.debug("Removing host entry for ssvm id=" + vmId);	_hostDao.remove(host.getId());	_tmplStoreDao.expireDnldUrlsForZone(host.getDataCenterId());	_volumeStoreDao.expireDnldUrlsForZone(host.getDataCenterId());	return true;	}	return false;	} catch (ResourceUnavailableException e) {	
unable to expunge 

StringBuilder buf = profile.getBootArgsBuilder();	buf.append(" template=domP type=secstorage");	buf.append(" host=").append(ApiServiceConfiguration.ManagementHostIPAdr.value());	buf.append(" port=").append(_mgmtPort);	buf.append(" name=").append(profile.getVirtualMachine().getHostName());	buf.append(" zone=").append(dest.getDataCenter().getId());	buf.append(" pod=").append(dest.getPod().getId());	buf.append(" guid=").append(profile.getVirtualMachine().getHostName());	buf.append(" workers=").append(_configDao.getValue("workers"));	if (_configDao.isPremium()) {	
vmware hypervisor configured telling the ssvm to load the premiumsecondarystorageresource 

buf.append(" internaldns2=").append(dc.getInternalDns2());	}	buf.append(" dns1=").append(dc.getDns1());	if (dc.getDns2() != null) {	buf.append(" dns2=").append(dc.getDns2());	}	Integer nfsVersion = imageStoreDetailsUtil != null ? imageStoreDetailsUtil.getNfsVersion(secStore.getId()) : null;	buf.append(" nfsVersion=").append(nfsVersion);	String bootArgs = buf.toString();	if (s_logger.isDebugEnabled()) {	
boot args for 

NicProfile controlNic = null;	for (NicProfile nic : profile.getNics()) {	if (nic.getTrafficType() == TrafficType.Management) {	managementNic = nic;	} else if (nic.getTrafficType() == TrafficType.Control && nic.getIPv4Address() != null) {	controlNic = nic;	}	}	if (controlNic == null) {	if (managementNic == null) {	
management network doesn t exist for the secondarystoragevm 

public boolean finalizeStart(VirtualMachineProfile profile, long hostId, Commands cmds, ReservationContext context) {	CheckSshAnswer answer = (CheckSshAnswer)cmds.getAnswer("checkSsh");	if (!answer.getResult()) {	
unable to ssh to the vm 

}	try {	_rulesMgr.getSystemIpAndEnableStaticNatForVm(profile.getVirtualMachine(), false);	IPAddressVO ipaddr = _ipAddressDao.findByAssociatedVmId(profile.getVirtualMachine().getId());	if (ipaddr != null && ipaddr.getSystem()) {	SecondaryStorageVmVO secVm = _secStorageVmDao.findById(profile.getId());	secVm.setPublicIpAddress(ipaddr.getAddress().addr());	_secStorageVmDao.update(secVm.getId(), secVm);	}	} catch (Exception ex) {	
failed to get system ip and enable static nat for the vm due to exception 

public void finalizeStop(VirtualMachineProfile profile, Answer answer) {	IPAddressVO ip = _ipAddressDao.findByAssociatedVmId(profile.getId());	if (ip != null && ip.getSystem()) {	CallContext ctx = CallContext.current();	try {	_rulesMgr.disableStaticNat(ip.getId(), ctx.getCallingAccount(), ctx.getCallingUserId(), true);	} catch (Exception ex) {	
failed to disable static nat and release system ip as a part of vm stop due to exception 

public boolean isPoolReadyForScan(Long pool) {	long dataCenterId = pool.longValue();	if (!isZoneReady(_zoneHostInfoMap, dataCenterId)) {	if (s_logger.isDebugEnabled()) {	
zone is not ready to launch secondary storage vm yet 

public boolean isPoolReadyForScan(Long pool) {	long dataCenterId = pool.longValue();	if (!isZoneReady(_zoneHostInfoMap, dataCenterId)) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	if (s_logger.isDebugEnabled()) {	
zone is ready to launch secondary storage vm 

========================= cloudstack sample_5022 =========================

public ListResponse<HostResponse> searchForServers(ListHostsCmd cmd) {	
searching for hosts 

public ListResponse<HostResponse> searchForServers(ListHostsCmd cmd) {	Pair<List<HostJoinVO>, Integer> hosts = searchForServersInternal(cmd);	ListResponse<HostResponse> response = new ListResponse<HostResponse>();	
generating response 

List<Long> domainIds = null;	if ((_accountMgr.isNormalUser(account.getId()) || _accountMgr.isDomainAdmin(account.getId())) || account.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {	if (isRecursive) {	if (account.getType() == Account.ACCOUNT_TYPE_NORMAL) throw new InvalidParameterValueException("Only ROOT admins and Domain admins can list disk offerings with isrecursive=true");	DomainVO domainRecord = _domainDao.findById(account.getDomainId());	sc.addAnd("domainPath", SearchCriteria.Op.LIKE, domainRecord.getPath() + "%");	} else {	domainIds = new ArrayList<Long>();	DomainVO domainRecord = _domainDao.findById(account.getDomainId());	if ( domainRecord == null ){	
could not find the domainid for account 

if (caller.getType() == Account.ACCOUNT_TYPE_NORMAL) throw new InvalidParameterValueException("Only ROOT admins and Domain admins can list service offerings with isrecursive=true");	DomainVO domainRecord = _domainDao.findById(caller.getDomainId());	sc.addAnd("domainPath", SearchCriteria.Op.LIKE, domainRecord.getPath() + "%");	} else {	List<Long> domainIds = new ArrayList<Long>();	DomainVO domainRecord;	if (vmId != null) {	UserVmVO vmInstance = _userVmDao.findById(vmId);	domainRecord = _domainDao.findById(vmInstance.getDomainId());	if ( domainRecord == null ){	
could not find the domainid for vmid 

DomainVO domainRecord;	if (vmId != null) {	UserVmVO vmInstance = _userVmDao.findById(vmId);	domainRecord = _domainDao.findById(vmInstance.getDomainId());	if ( domainRecord == null ){	throw new CloudAuthenticationException("Could not find the domainId for vmId:" + vmId);	}	} else {	domainRecord = _domainDao.findById(caller.getDomainId());	if ( domainRecord == null ){	
could not find the domainid for account 

if (_accountMgr.isNormalUser(account.getId())) {	SearchCriteria<DataCenterJoinVO> sdc = _dcJoinDao.createSearchCriteria();	sdc.addOr("accountId", SearchCriteria.Op.EQ, account.getId());	sdc.addOr("accountId", SearchCriteria.Op.NULL);	sc.addAnd("accountId", SearchCriteria.Op.SC, sdc);	}	} else if (_accountMgr.isNormalUser(account.getId())) {	List<Long> domainIds = new ArrayList<Long>();	DomainVO domainRecord = _domainDao.findById(account.getDomainId());	if (domainRecord == null) {	
could not find the domainid for account 

sdc2.addOr("accountId", SearchCriteria.Op.NULL);	sc.addAnd("accountId", SearchCriteria.Op.SC, sdc2);	List<Long> dedicatedZoneIds = removeDedicatedZoneNotSuitabe(domainIds);	if (!dedicatedZoneIds.isEmpty()) {	sdc.addAnd("id", SearchCriteria.Op.NIN, dedicatedZoneIds.toArray(new Object[dedicatedZoneIds.size()]));	}	} else if (_accountMgr.isDomainAdmin(account.getId()) || account.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {	List<Long> domainIds = new ArrayList<Long>();	DomainVO domainRecord = _domainDao.findById(account.getDomainId());	if (domainRecord == null) {	
could not find the domainid for account 

if (ids != null && !ids.isEmpty()){	sb.and("idIN", sb.entity().getId(), SearchCriteria.Op.IN);	}	SearchCriteria<TemplateJoinVO> sc = sb.create();	if (templateId != null) {	template = _templateDao.findByIdIncludingRemoved(templateId);	if (template == null) {	throw new InvalidParameterValueException("Please specify a valid template ID.");	}	if (isIso && template.getFormat() != ImageFormat.ISO) {	
template id is not an iso 

template = _templateDao.findByIdIncludingRemoved(templateId);	if (template == null) {	throw new InvalidParameterValueException("Please specify a valid template ID.");	}	if (isIso && template.getFormat() != ImageFormat.ISO) {	InvalidParameterValueException ex = new InvalidParameterValueException( "Specified Template Id is not an ISO");	ex.addProxyObject(template.getUuid(), "templateId");	throw ex;	}	if (!isIso && template.getFormat() == ImageFormat.ISO) {	
incorrect format of the template id 

========================= cloudstack sample_2533 =========================

public void execute() {	Vpc vpc = null;	try {	if (isStart()) {	_vpcService.startVpc(getEntityId(), true);	} else {	s_logger.debug("Not starting VPC as " + ApiConstants.START + "=false was passed to the API");	}	vpc = _entityMgr.findById(Vpc.class, getEntityId());	} catch (ResourceUnavailableException ex) {	
exception 

try {	if (isStart()) {	_vpcService.startVpc(getEntityId(), true);	} else {	s_logger.debug("Not starting VPC as " + ApiConstants.START + "=false was passed to the API");	}	vpc = _entityMgr.findById(Vpc.class, getEntityId());	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3288 =========================

public ConsoleProxyInfo assignProxy(long dataCenterId, long userVmId) {	UserVmVO userVm = _userVmDao.findById(userVmId);	if (userVm == null) {	
user vm no longer exists return a null proxy for user vm 

if (allocatedHost == null) {	for (HostVO hv : hosts) {	if (hv.getType() == Host.Type.ConsoleProxy && hv.getPodId().equals(host.getPodId())) {	allocatedHost = hv;	break;	}	}	}	if (allocatedHost == null) {	if (s_logger.isDebugEnabled()) {	
failed to find a console proxy at host and in the pod to user vm 

break;	}	}	}	if (allocatedHost == null) {	if (s_logger.isDebugEnabled()) {	}	return null;	}	if (s_logger.isDebugEnabled()) {	
assign standalone console proxy running at to user vm with public ip 

if (allocatedHost == null) {	if (s_logger.isDebugEnabled()) {	}	return null;	}	if (s_logger.isDebugEnabled()) {	}	String publicIp = allocatedHost.getPublicIpAddress();	if (publicIp == null) {	if (s_logger.isDebugEnabled()) {	
host does not have public interface we will return its private ip for cosole proxy 

if (s_logger.isDebugEnabled()) {	}	publicIp = allocatedHost.getPrivateIpAddress();	}	int urlPort = _consoleProxyUrlPort;	if (allocatedHost.getProxyPort() != null && allocatedHost.getProxyPort().intValue() > 0) {	urlPort = allocatedHost.getProxyPort().intValue();	}	return new ConsoleProxyInfo(_sslEnabled, publicIp, _consoleProxyPort, urlPort, _consoleProxyUrlDomain);	} else {	
host that vm is running is no longer available console access to vm will be temporarily unavailable 

========================= cloudstack sample_2476 =========================

protected boolean canHandle(NetworkOffering offering, NetworkType networkType, PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && isMyIsolationMethod(physicalNetwork)) {	return true;	} else {	
we only take care of guest networks of type in zone of type 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	if (physnet == null || physnet.getIsolationMethods() == null || !physnet.getIsolationMethods().contains("BCF_SEGMENT")) {	
refusing to design this network the physical isolation type is not bcf segment 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	if (physnet == null || physnet.getIsolationMethods() == null || !physnet.getIsolationMethods().contains("BCF_SEGMENT")) {	return null;	}	List<BigSwitchBcfDeviceVO> devices = _bigswitchBcfDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	
no bigswitch controller on physical network 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	if (physnet == null || physnet.getIsolationMethods() == null || !physnet.getIsolationMethods().contains("BCF_SEGMENT")) {	return null;	}	List<BigSwitchBcfDeviceVO> devices = _bigswitchBcfDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	return null;	}	for (BigSwitchBcfDeviceVO d: devices){	
bigswitch controller found on physical network 

PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	if (physnet == null || physnet.getIsolationMethods() == null || !physnet.getIsolationMethods().contains("BCF_SEGMENT")) {	return null;	}	List<BigSwitchBcfDeviceVO> devices = _bigswitchBcfDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	return null;	}	for (BigSwitchBcfDeviceVO d: devices){	}	
physical isolation type is bcf segment asking guestnetworkguru to design this network 

public void shutdown(NetworkProfile profile, NetworkOffering offering) {	NetworkVO networkObject = _networkDao.findById(profile.getId());	if (networkObject.getBroadcastDomainType() != BroadcastDomainType.Vlan || networkObject.getBroadcastUri() == null) {	
broadcasturi is empty or incorrect for guestnetwork 

if(network.getVpcId()!=null){	vpc = _vpcDao.acquireInLockTable(network.getVpcId());	}	String networkId = network.getUuid();	String tenantId;	String tenantName;	if (vpc != null) {	tenantId = vpc.getUuid();	tenantName = vpc.getName();	boolean released = _vpcDao.releaseFromLockTable(vpc.getId());	
bcf guru release lock vpc id released 

public void rollbackMigration(NicProfile nic, Network network, VirtualMachineProfile vm, ReservationContext src, ReservationContext dst) {	
bcf guru rollback migration 

public void commitMigration(NicProfile nic, Network network, VirtualMachineProfile vm, ReservationContext src, ReservationContext dst) {	
bcf guru commit migration 

========================= cloudstack sample_1523 =========================

public Answer execute(final ClusterVMMetaDataSyncCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	try {	final Pool pool = Pool.getByUuid(conn, citrixResourceBase.getHost().getPool());	final Pool.Record poolr = pool.getRecord(conn);	final Host.Record hostr = poolr.master.getRecord(conn);	if (!citrixResourceBase.getHost().getUuid().equals(hostr.uuid)) {	return new ClusterVMMetaDataSyncAnswer(command.getClusterId(), null);	}	} catch (final Throwable e) {	
check for master failed failing the cluster sync vmmetadata command 

========================= cloudstack sample_1173 =========================

out.writeBytes("INSERT INTO `vmops`.`user_ip_address` (ip_address, data_center_id) VALUES ('" + i + "." + j + "." + k + "." + l + "'," + dcId + ");\r\n");	}	}	}	}	out.writeBytes("\r\n");	out.flush();	out.close();	}	} catch (Exception e) {	
ignored error during ip insert generator 

========================= cloudstack sample_444 =========================

try {	configProps.load(inputFile);	} catch (IOException e) {	s_logger.error(e.getMessage());	throw new ConfigurationException(e.getMessage());	} finally {	closeAutoCloseable(inputFile, "error closing config file");	}	_mgmtCidr = configProps.getProperty("management.cidr");	_mgmtGateway = configProps.getProperty("management.gateway");	
management network gateway 

========================= cloudstack sample_1870 =========================

public boolean configure(Map<String, Object> params) {	
will configure elastistor s lifecycle driver listener global configurations 

public boolean configure(Map<String, Object> params) {	lifecycle = ComponentContext.inject(ElastistorPrimaryDataStoreLifeCycle.class);	driver = ComponentContext.inject(ElastistorPrimaryDataStoreDriver.class);	listener = ComponentContext.inject(ElastistorHostListener.class);	setCloudbyteGlobalConfiguration();	ElastistorUtil.setConfigurationDao(configurationDao);	
successfully configured elastistor s lifecycle driver listener global configurations 

========================= cloudstack sample_1935 =========================

public Answer execute(final DestroyCommand command, final LibvirtComputingResource libvirtComputingResource) {	final VolumeTO vol = command.getVolume();	try {	final KVMStoragePoolManager storagePoolMgr = libvirtComputingResource.getStoragePoolMgr();	final KVMStoragePool pool = storagePoolMgr.getStoragePool(vol.getPoolType(), vol.getPoolUuid());	pool.deletePhysicalDisk(vol.getPath(), null);	return new Answer(command, true, "Success");	} catch (final CloudRuntimeException e) {	
failed to delete volume 

========================= cloudstack sample_1036 =========================

if (ADDRESS.equals(key)) {	match = iface.getValue().getAddress();	}	if ("Name".equals(key)) {	match = iface.getKey();	}	if (match != null && match.equals(val)) {	return iface.getValue();	}	}	
unable to find interface by value 

public Network.Interface getBridgeByName(String name) throws Ovm3ResourceException {	if (getNetIface("Name", name) != null && getNetIface("Name", name).getIfType().contentEquals(BRIDGE)) {	return getNetIface("Name", name);	}	
unable to find bridge by name 

public Network.Interface getBridgeByIp(String ip) throws Ovm3ResourceException {	if (getNetIface(ADDRESS, ip) != null && getNetIface(ADDRESS, ip).getIfType().contentEquals(BRIDGE)) {	return getNetIface(ADDRESS, ip);	}	
unable to find bridge by ip 

========================= cloudstack sample_852 =========================

xenGuestLabel = DBEncryptionUtil.decrypt(xenGuestLabel);	if (xenGuestLabel != null) {	PreparedStatement pstmt5 = conn.prepareStatement("SELECT count(*) FROM `cloud`.`physical_network_traffic_types` pntt JOIN `cloud`.`physical_network` pn ON pntt.physical_network_id = pn.id WHERE pntt.traffic_type ='Guest' AND pn.data_center_id = ? AND pntt.xen_network_label = ?");	pstmt5.setLong(1, zoneId);	pstmt5.setString(2, xenGuestLabel);	ResultSet rsSameLabel = pstmt5.executeQuery();	if (rsSameLabel.next()) {	Long sameLabelcount = rsSameLabel.getLong(1);	if (sameLabelcount > 0) {	s_logger.error("There are untagged networks for which we need to add a physical network with Xen traffic label = 'xen.guest.network.device' config value, which is: " + xenGuestLabel);	
however already there are physical networks setup with same traffic label cannot upgrade 

}	}	}	long physicalNetworkId = addPhysicalNetworkToZone(conn, zoneId, zoneName, networkType, null, domainId);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, null, null);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, true);	PreparedStatement pstmt3 = conn.prepareStatement("SELECT n.id FROM networks n WHERE n.physical_network_id IS NULL AND n.traffic_type = 'Guest' and n.data_center_id = ? and n.removed is null");	pstmt3.setLong(1, zoneId);	ResultSet rsNet = pstmt3.executeQuery();	
adding physicalnetwork to vlan 

}	}	}	long physicalNetworkId = addPhysicalNetworkToZone(conn, zoneId, zoneName, networkType, null, domainId);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, null, null);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, true);	PreparedStatement pstmt3 = conn.prepareStatement("SELECT n.id FROM networks n WHERE n.physical_network_id IS NULL AND n.traffic_type = 'Guest' and n.data_center_id = ? and n.removed is null");	pstmt3.setLong(1, zoneId);	ResultSet rsNet = pstmt3.executeQuery();	
adding physicalnetwork to user ip address 

}	}	}	long physicalNetworkId = addPhysicalNetworkToZone(conn, zoneId, zoneName, networkType, null, domainId);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, null, null);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, true);	PreparedStatement pstmt3 = conn.prepareStatement("SELECT n.id FROM networks n WHERE n.physical_network_id IS NULL AND n.traffic_type = 'Guest' and n.data_center_id = ? and n.removed is null");	pstmt3.setLong(1, zoneId);	ResultSet rsNet = pstmt3.executeQuery();	
adding physicalnetwork to networks 

}	rs.close();	pstmt.close();	boolean multiplePhysicalNetworks = false;	pstmt = conn.prepareStatement("SELECT count(*) FROM `cloud`.`physical_network_traffic_types` pntt JOIN `cloud`.`physical_network` pn ON pntt.physical_network_id = pn.id WHERE pntt.traffic_type ='Guest' and pn.data_center_id = ?");	pstmt.setLong(1, zoneId);	rs = pstmt.executeQuery();	if (rs.next()) {	Long count = rs.getLong(1);	if (count > 1) {	
there are physical networks setup 

rs.close();	pstmt.close();	if (multiplePhysicalNetworks) {	PreparedStatement pstmt4 = conn.prepareStatement("SELECT v.id, v.vnet, v.reservation_id, v.physical_network_id as vpid, n.id, n.physical_network_id as npid FROM `cloud`.`op_dc_vnet_alloc` v JOIN `cloud`.`networks` n ON CONCAT('vlan: pstmt4.setLong(1, zoneId);	ResultSet rsVNet = pstmt4.executeQuery();	if (rsVNet.next()) {	String vnet = rsVNet.getString(2);	String networkId = rsVNet.getString(5);	String vpid = rsVNet.getString(4);	String npid = rsVNet.getString(6);	
guest vnet assignment is set wrongly cannot upgrade until that is corrected example vnet has physical network id but the guest network that uses it has physical network id 

pstmt.executeUpdate();	pstmt.close();	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while cloning NetworkOffering", e);	} finally {	closeAutoCloseable(rs);	try {	pstmt = conn.prepareStatement("DROP TEMPORARY TABLE `cloud`.`network_offerings2`");	pstmt.executeUpdate();	} catch (SQLException e) {	
ignored 

private void addHostDetailsUniqueKey(Connection conn) {	
checking if host details unique key exists if not we will add it 

private void addHostDetailsUniqueKey(Connection conn) {	try ( PreparedStatement pstmt = conn.prepareStatement("SHOW INDEX FROM `cloud`.`host_details` WHERE KEY_NAME = 'uk_host_id_name'");	ResultSet rs = pstmt.executeQuery();	) {	if (rs.next()) {	
unique key already exists on host details not adding new one 

private void addHostDetailsUniqueKey(Connection conn) {	try ( PreparedStatement pstmt = conn.prepareStatement("SHOW INDEX FROM `cloud`.`host_details` WHERE KEY_NAME = 'uk_host_id_name'");	ResultSet rs = pstmt.executeQuery();	) {	if (rs.next()) {	} else {	PreparedStatement pstmtUpdate = conn.prepareStatement("ALTER IGNORE TABLE `cloud`.`host_details` ADD CONSTRAINT UNIQUE KEY `uk_host_id_name` (`host_id`, `name`)");	pstmtUpdate.executeUpdate();	
unique key did not exist on host details added new one 

private void addVpcProvider(Connection conn) {	
adding vpc provider to all physical networks in the system 

pstmt.setLong(1, providerId);	pstmt.executeUpdate();	s_logger.debug("Added VPC Virtual router provider for physical network id=" + pNtwkId);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable add VPC physical network service provider ", e);	} finally {	closeAutoCloseable(rs);	closeAutoCloseable(pstmt);	}	
done adding vpc physical network service providers to all physical networks 

private void updateRouterNetworkRef(Connection conn) {	
updating router network ref 

pstmt2.setLong(1, routerId);	pstmt2.setLong(2, networkId);	pstmt2.setString(3, networkType);	pstmt2.executeUpdate();	}	s_logger.debug("Added reference for router id=" + routerId + " and network id=" + networkId);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Failed to update the router/network reference ", e);	}	
done updating router network references 

private void addF5LoadBalancer(Connection conn, long hostId, long physicalNetworkId) {	
adding big ip load balancer with host id in to physical network 

private void addSrxFirewall(Connection conn, long hostId, long physicalNetworkId) {	
adding srx firewall device with host id in to physical network 

private void addF5ServiceProvider(Connection conn, long physicalNetworkId, long zoneId) {	
adding physicalnetworkserviceprovider in to physical network 

private void addSrxServiceProvider(Connection conn, long physicalNetworkId, long zoneId) {	
adding physicalnetworkserviceprovider junipersrx 

pstmt.setLong(2, networkOfferingId);	rs = pstmt.executeQuery();	while (rs.next()) {	networkId = rs.getLong(1);	String insertLbMapping = "INSERT INTO `cloud`.`network_external_lb_device_map` (uuid, network_id, external_load_balancer_device_id, created) VALUES ( ?, ?, ?, now())";	pstmtUpdate = conn.prepareStatement(insertLbMapping);	pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, f5DeviceId);	pstmtUpdate.executeUpdate();	
successfully added entry in network external lb device map for network and device id 

pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, f5DeviceId);	pstmtUpdate.executeUpdate();	String insertFwMapping = "INSERT INTO `cloud`.`network_external_firewall_device_map` (uuid, network_id, external_firewall_device_id, created) VALUES ( ?, ?, ?, now())";	pstmtUpdate = conn.prepareStatement(insertFwMapping);	pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, srxDevivceId);	pstmtUpdate.executeUpdate();	
successfully added entry in network external firewall device map for network and srx device id 

pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, f5DeviceId);	pstmtUpdate.executeUpdate();	String insertFwMapping = "INSERT INTO `cloud`.`network_external_firewall_device_map` (uuid, network_id, external_firewall_device_id, created) VALUES ( ?, ?, ?, now())";	pstmtUpdate = conn.prepareStatement(insertFwMapping);	pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, srxDevivceId);	pstmtUpdate.executeUpdate();	}	
updating the host details for and srx devices 

if (!(camlCaseName.equalsIgnoreCase("numRetries") || camlCaseName.equalsIgnoreCase("publicZone") || camlCaseName.equalsIgnoreCase("privateZone") || camlCaseName.equalsIgnoreCase("publicInterface") || camlCaseName.equalsIgnoreCase("privateInterface") || camlCaseName.equalsIgnoreCase("usageInterface"))) {	continue;	}	String lowerCaseName = camlCaseName.toLowerCase();	pstmt = conn.prepareStatement("update `cloud`.`host_details` set name=? where host_id=? AND name=?");	pstmt.setString(1, lowerCaseName);	pstmt.setLong(2, hostId);	pstmt.setString(3, camlCaseName);	pstmt.executeUpdate();	}	
successfully updated host details for and srx devices 

pstmt.setLong(2, hostId);	pstmt.setString(3, camlCaseName);	pstmt.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	} finally {	closeAutoCloseable(rs);	closeAutoCloseable(pstmt);	}	
successfully upgraded networks using and srx devices to have a entry in the network external lb device map and network external firewall device map 

private void encryptConfig(Connection conn) {	
encrypting config values 

String encryptedValue = DBEncryptionUtil.encrypt(value);	pstmt1.setBytes(1, encryptedValue.getBytes("UTF-8"));	pstmt1.setString(2, name);	pstmt1.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt configuration values ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt configuration values ", e);	}	
done encrypting config values 

private void encryptClusterDetails(Connection conn) {	
encrypting cluster details 

String encryptedValue = DBEncryptionUtil.encrypt(value);	pstmt1.setBytes(1, encryptedValue.getBytes("UTF-8"));	pstmt1.setLong(2, id);	pstmt1.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt cluster_details values ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt cluster_details values ", e);	}	
done encrypting cluster details 

========================= cloudstack sample_4234 =========================

apiCommand.setAsync(isAsync);	Set<Field> fields = ReflectUtil.getAllFieldsForClass(clas, new Class<?>[] {BaseCmd.class, BaseAsyncCmd.class, BaseAsyncCreateCmd.class});	request = setRequestFields(fields);	Class<?> responseClas = impl.responseObject();	Field[] responseFields = responseClas.getDeclaredFields();	response = setResponseFields(responseFields, responseClas);	apiCommand.setRequest(request);	apiCommand.setResponse(response);	out.writeObject(apiCommand);	} else {	
command is not exposed in api doc 

continue;	}	try(FileInputStream in = new FileInputStream(files[i].getPath());) {	out.putNextEntry(new ZipEntry(files[i].getPath().substring(pathToDir.length())));	int len;	while ((len = in.read(tmpBuf)) > 0) {	out.write(tmpBuf, 0, len);	}	out.closeEntry();	}catch(IOException ex) {	
adddir exception 

xs.alias("alert", Alert.class);	try(ObjectOutputStream out = xs.createObjectOutputStream(new FileWriter(dirName + "/alert_types.xml"), "alerts");) {	for (Field f : AlertManager.class.getFields()) {	if (f.getClass().isAssignableFrom(Number.class)) {	String name = f.getName().substring(11);	Alert alert = new Alert(name, f.getInt(null));	out.writeObject(alert);	}	}	} catch (IOException e) {	
failed to create output stream to write an alert types 

try(ObjectOutputStream out = xs.createObjectOutputStream(new FileWriter(dirName + "/alert_types.xml"), "alerts");) {	for (Field f : AlertManager.class.getFields()) {	if (f.getClass().isAssignableFrom(Number.class)) {	String name = f.getName().substring(11);	Alert alert = new Alert(name, f.getInt(null));	out.writeObject(alert);	}	}	} catch (IOException e) {	} catch (IllegalAccessException e) {	
failed to read alert fields 

========================= cloudstack sample_2525 =========================

Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	ServiceOffering offering = vmProfile.getServiceOffering();	List<Host> suitableHosts = new ArrayList<Host>();	List<Host> hostsCopy = new ArrayList<Host>(hosts);	if (type == Host.Type.Storage) {	return suitableHosts;	}	String hostTag = offering.getHostTag();	if (hostTag != null) {	
looking for hosts in dc pod cluster having host tag 

Long clusterId = plan.getClusterId();	ServiceOffering offering = vmProfile.getServiceOffering();	List<Host> suitableHosts = new ArrayList<Host>();	List<Host> hostsCopy = new ArrayList<Host>(hosts);	if (type == Host.Type.Storage) {	return suitableHosts;	}	String hostTag = offering.getHostTag();	if (hostTag != null) {	} else {	
looking for hosts in dc pod cluster 

}	String hostTag = offering.getHostTag();	if (hostTag != null) {	} else {	}	if (hostTag != null) {	hostsCopy.retainAll(_hostDao.listByHostTag(type, clusterId, podId, dcId, hostTag));	} else {	hostsCopy.retainAll(_resourceMgr.listAllUpAndEnabledHosts(type, clusterId, podId, dcId));	}	
random allocator found hosts 

}	Collections.shuffle(hostsCopy);	for (Host host : hostsCopy) {	if (suitableHosts.size() == returnUpTo) {	break;	}	if (!avoid.shouldAvoid(host)) {	suitableHosts.add(host);	} else {	if (s_logger.isDebugEnabled()) {	
host name hostid is in avoid set skipping this and trying other available hosts 

break;	}	if (!avoid.shouldAvoid(host)) {	suitableHosts.add(host);	} else {	if (s_logger.isDebugEnabled()) {	}	}	}	if (s_logger.isDebugEnabled()) {	
random host allocator returning suitable hosts 

long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	ServiceOffering offering = vmProfile.getServiceOffering();	List<Host> suitableHosts = new ArrayList<Host>();	if (type == Host.Type.Storage) {	return suitableHosts;	}	String hostTag = offering.getHostTag();	if (hostTag != null) {	
looking for hosts in dc pod cluster having host tag 

Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	ServiceOffering offering = vmProfile.getServiceOffering();	List<Host> suitableHosts = new ArrayList<Host>();	if (type == Host.Type.Storage) {	return suitableHosts;	}	String hostTag = offering.getHostTag();	if (hostTag != null) {	} else {	
looking for hosts in dc pod cluster 

String hostTag = offering.getHostTag();	if (hostTag != null) {	} else {	}	List<? extends Host> hosts = new ArrayList<HostVO>();	if (hostTag != null) {	hosts = _hostDao.listByHostTag(type, clusterId, podId, dcId, hostTag);	} else {	hosts = _resourceMgr.listAllUpAndEnabledHosts(type, clusterId, podId, dcId);	}	
random allocator found hosts 

}	Collections.shuffle(hosts);	for (Host host : hosts) {	if (suitableHosts.size() == returnUpTo) {	break;	}	if (!avoid.shouldAvoid(host)) {	suitableHosts.add(host);	} else {	if (s_logger.isDebugEnabled()) {	
host name hostid is in avoid set skipping this and trying other available hosts 

break;	}	if (!avoid.shouldAvoid(host)) {	suitableHosts.add(host);	} else {	if (s_logger.isDebugEnabled()) {	}	}	}	if (s_logger.isDebugEnabled()) {	
random host allocator returning suitable hosts 

========================= cloudstack sample_2030 =========================

public boolean share(VMInstanceVO vm, List<VolumeVO> vols, HostVO host, boolean cancelPreviousShare) throws StorageUnavailableException {	List<VolumeVO> rootVolForGivenVm = _volsDao.findByInstanceAndType(vm.getId(), Type.ROOT);	if (rootVolForGivenVm != null && rootVolForGivenVm.size() > 0) {	boolean isPoolAvailable = isPoolAvailable(rootVolForGivenVm.get(0).getPoolId());	if (!isPoolAvailable) {	throw new StorageUnavailableException("Can not share " + vm, rootVolForGivenVm.get(0).getPoolId());	}	}	for (VolumeVO vol : vols) {	if (vol.getRemoved() != null) {	
volume id is removed cannot share on this instance 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	Map<String, String> configs = _configDao.getConfiguration("management-server", params);	_storagePoolAcquisitionWaitSeconds = NumbersUtil.parseInt(configs.get("pool.acquisition.wait.seconds"), 1800);	
pool acquisition wait seconds is configured as seconds 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	Map<String, String> configs = _configDao.getConfiguration("management-server", params);	_storagePoolAcquisitionWaitSeconds = NumbersUtil.parseInt(configs.get("pool.acquisition.wait.seconds"), 1800);	_agentMgr.registerForHostEvents(new StoragePoolMonitor(this, _storagePoolDao, _dataStoreProviderMgr), true, false, true);	String value = _configDao.getValue(Config.StorageTemplateCleanupEnabled.key());	_templateCleanupEnabled = (value == null ? true : Boolean.parseBoolean(value));	
storage cleanup enabled interval delay template cleanup enabled 

public boolean start() {	if (StorageCleanupEnabled.value()) {	Random generator = new Random();	int initialDelay = generator.nextInt(StorageCleanupInterval.value());	_executor.scheduleWithFixedDelay(new StorageGarbageCollector(), initialDelay, StorageCleanupInterval.value(), TimeUnit.SECONDS);	} else {	
storage cleanup is not enabled so the storage cleanup thread is not being scheduled 

}	StoragePoolVO pool = _storagePoolDao.findPoolByHostPath(host.getDataCenterId(), host.getPodId(), hostAddress, pInfo.getHostPath(), pInfo.getUuid());	if (pool == null && host.getHypervisorType() == HypervisorType.VMware) {	if (pInfo.getHostPath().length() > 0) {	pool = _storagePoolDao.findPoolByHostPath(host.getDataCenterId(), host.getPodId(), hostAddress, "", pInfo.getUuid());	}	}	if (pool == null) {	pool = _storagePoolDao.findPoolByHostPath(host.getDataCenterId(), host.getPodId(), hostAddress, null, pInfo.getUuid());	if (pool != null) {	
found a storage pool but with different hostpath still treat it as the same pool 

store = lifeCycle.initialize(params);	} else {	store = _dataStoreMgr.getDataStore(pool.getId(), DataStoreRole.Primary);	}	pool = _storagePoolDao.findById(store.getId());	if (pool.getStatus() != StoragePoolStatus.Maintenance && pool.getStatus() != StoragePoolStatus.Removed) {	HostScope scope = new HostScope(host.getId(), host.getClusterId(), host.getDataCenterId());	lifeCycle.attachHost(store, scope, pInfo);	}	} catch (Exception e) {	
unable to setup the local storage pool for 

try {	store = lifeCycle.initialize(params);	if (scopeType == ScopeType.CLUSTER) {	ClusterScope clusterScope = new ClusterScope(clusterId, podId, zoneId);	lifeCycle.attachCluster(store, clusterScope);	} else if (scopeType == ScopeType.ZONE) {	ZoneScope zoneScope = new ZoneScope(zoneId);	lifeCycle.attachZone(store, zoneScope, hypervisorType);	}	} catch (Exception e) {	
failed to add data store 

} else if (scopeType == ScopeType.ZONE) {	ZoneScope zoneScope = new ZoneScope(zoneId);	lifeCycle.attachZone(store, zoneScope, hypervisorType);	}	} catch (Exception e) {	try {	if (store != null) {	lifeCycle.deleteDataStore(store);	}	} catch (Exception ex) {	
failed to clean up storage pool 

public boolean deletePool(DeletePoolCmd cmd) {	Long id = cmd.getId();	boolean forced = cmd.isForced();	StoragePoolVO sPool = _storagePoolDao.findById(id);	if (sPool == null) {	
unable to find pool 

public boolean deletePool(DeletePoolCmd cmd) {	Long id = cmd.getId();	boolean forced = cmd.isForced();	StoragePoolVO sPool = _storagePoolDao.findById(id);	if (sPool == null) {	throw new InvalidParameterValueException("Unable to find pool by id " + id);	}	if (sPool.getStatus() != StoragePoolStatus.Maintenance) {	
unable to delete storage id due to it is not in maintenance state 

Long id = cmd.getId();	boolean forced = cmd.isForced();	StoragePoolVO sPool = _storagePoolDao.findById(id);	if (sPool == null) {	throw new InvalidParameterValueException("Unable to find pool by id " + id);	}	if (sPool.getStatus() != StoragePoolStatus.Maintenance) {	throw new InvalidParameterValueException("Unable to delete storage due to it is not in Maintenance state, id: " + id);	}	if (sPool.isLocal()) {	
unable to delete local storage id 

Pair<Long, Long> nonDstrdVlms = _volsDao.getNonDestroyedCountAndTotalByPool(id);	if (nonDstrdVlms.first() > 0) {	throw new CloudRuntimeException("Cannot delete pool " + sPool.getName() + " as there are associated " + "non-destroyed vols for this pool");	}	List<VolumeVO> vols = _volsDao.listVolumesToBeDestroyed();	for (VolumeVO vol : vols) {	AsyncCallFuture<VolumeApiResult> future = volService.expungeVolumeAsync(volFactory.getVolume(vol.getId()));	try {	future.get();	} catch (InterruptedException e) {	
expunge volume failed 

if (nonDstrdVlms.first() > 0) {	throw new CloudRuntimeException("Cannot delete pool " + sPool.getName() + " as there are associated " + "non-destroyed vols for this pool");	}	List<VolumeVO> vols = _volsDao.listVolumesToBeDestroyed();	for (VolumeVO vol : vols) {	AsyncCallFuture<VolumeApiResult> future = volService.expungeVolumeAsync(volFactory.getVolume(vol.getId()));	try {	future.get();	} catch (InterruptedException e) {	} catch (ExecutionException e) {	
expunge volume failed 

}	}	} else {	if (vlms.first() > 0) {	throw new CloudRuntimeException("Cannot delete pool " + sPool.getName() + " as there are associated volumes for this pool");	}	}	StoragePoolVO lock = _storagePoolDao.acquireInLockTable(sPool.getId());	if (lock == null) {	if (s_logger.isDebugEnabled()) {	
failed to acquire lock when deleting primarydatastorevo with id 

throw new CloudRuntimeException("Cannot delete pool " + sPool.getName() + " as there are associated volumes for this pool");	}	}	StoragePoolVO lock = _storagePoolDao.acquireInLockTable(sPool.getId());	if (lock == null) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	_storagePoolDao.releaseFromLockTable(lock.getId());	
released lock for storage pool 

public void connectHostToSharedPool(long hostId, long poolId) throws StorageUnavailableException, StorageConflictException {	StoragePool pool = (StoragePool)_dataStoreMgr.getDataStore(poolId, DataStoreRole.Primary);	assert (pool.isShared()) : "Now, did you actually read the name of this method?";	
adding pool to host 

public void createCapacityEntry(StoragePoolVO storagePool, short capacityType, long allocated) {	SearchCriteria<CapacityVO> capacitySC = _capacityDao.createSearchCriteria();	capacitySC.addAnd("hostOrPoolId", SearchCriteria.Op.EQ, storagePool.getId());	capacitySC.addAnd("dataCenterId", SearchCriteria.Op.EQ, storagePool.getDataCenterId());	capacitySC.addAnd("capacityType", SearchCriteria.Op.EQ, capacityType);	List<CapacityVO> capacities = _capacityDao.search(capacitySC, null);	long totalOverProvCapacity;	if (storagePool.getPoolType() == StoragePoolType.NetworkFilesystem || storagePool.getPoolType() == StoragePoolType.VMFS) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(storagePool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(storagePool.getCapacityBytes())).longValue();	
found storage pool of type with overprovisioning factor 

public void createCapacityEntry(StoragePoolVO storagePool, short capacityType, long allocated) {	SearchCriteria<CapacityVO> capacitySC = _capacityDao.createSearchCriteria();	capacitySC.addAnd("hostOrPoolId", SearchCriteria.Op.EQ, storagePool.getId());	capacitySC.addAnd("dataCenterId", SearchCriteria.Op.EQ, storagePool.getDataCenterId());	capacitySC.addAnd("capacityType", SearchCriteria.Op.EQ, capacityType);	List<CapacityVO> capacities = _capacityDao.search(capacitySC, null);	long totalOverProvCapacity;	if (storagePool.getPoolType() == StoragePoolType.NetworkFilesystem || storagePool.getPoolType() == StoragePoolType.VMFS) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(storagePool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(storagePool.getCapacityBytes())).longValue();	
total over provisioned capacity calculated is 

SearchCriteria<CapacityVO> capacitySC = _capacityDao.createSearchCriteria();	capacitySC.addAnd("hostOrPoolId", SearchCriteria.Op.EQ, storagePool.getId());	capacitySC.addAnd("dataCenterId", SearchCriteria.Op.EQ, storagePool.getDataCenterId());	capacitySC.addAnd("capacityType", SearchCriteria.Op.EQ, capacityType);	List<CapacityVO> capacities = _capacityDao.search(capacitySC, null);	long totalOverProvCapacity;	if (storagePool.getPoolType() == StoragePoolType.NetworkFilesystem || storagePool.getPoolType() == StoragePoolType.VMFS) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(storagePool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(storagePool.getCapacityBytes())).longValue();	} else {	
found storage pool of type 

capacitySC.addAnd("dataCenterId", SearchCriteria.Op.EQ, storagePool.getDataCenterId());	capacitySC.addAnd("capacityType", SearchCriteria.Op.EQ, capacityType);	List<CapacityVO> capacities = _capacityDao.search(capacitySC, null);	long totalOverProvCapacity;	if (storagePool.getPoolType() == StoragePoolType.NetworkFilesystem || storagePool.getPoolType() == StoragePoolType.VMFS) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(storagePool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(storagePool.getCapacityBytes())).longValue();	} else {	totalOverProvCapacity = storagePool.getCapacityBytes();	}	
total over provisioned capacity of the pool id is 

_capacityDao.persist(capacity);	} else {	CapacityVO capacity = capacities.get(0);	if (capacity.getTotalCapacity() != totalOverProvCapacity || allocated != capacity.getUsedCapacity() || capacity.getCapacityState() != capacityState) {	capacity.setTotalCapacity(totalOverProvCapacity);	capacity.setUsedCapacity(allocated);	capacity.setCapacityState(capacityState);	_capacityDao.update(capacity.getId(), capacity);	}	}	
successfully set capacity for capacity type datacenterid hostorpoolid podid 

for (Long hostId : hostIds) {	try {	List<Answer> answers = new ArrayList<Answer>();	Command[] cmdArray = cmds.toCommands();	for (Command cmd : cmdArray) {	long targetHostId = _hvGuruMgr.getGuruProcessedCommandTargetHost(hostId, cmd);	answers.add(_agentMgr.send(targetHostId, cmd));	}	return new Pair<Long, Answer[]>(hostId, answers.toArray(new Answer[answers.size()]));	} catch (AgentUnavailableException e) {	
unable to send storage pool command to via 

try {	List<Answer> answers = new ArrayList<Answer>();	Command[] cmdArray = cmds.toCommands();	for (Command cmd : cmdArray) {	long targetHostId = _hvGuruMgr.getGuruProcessedCommandTargetHost(hostId, cmd);	answers.add(_agentMgr.send(targetHostId, cmd));	}	return new Pair<Long, Answer[]>(hostId, answers.toArray(new Answer[answers.size()]));	} catch (AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	
unable to send storage pool command to via 

public void cleanupStorage(boolean recurring) {	GlobalLock scanLock = GlobalLock.getInternLock("storagemgr.cleanup");	try {	if (scanLock.lock(3)) {	try {	if (_templateCleanupEnabled) {	List<StoragePoolVO> storagePools = _storagePoolDao.listAll();	for (StoragePoolVO pool : storagePools) {	try {	List<VMTemplateStoragePoolVO> unusedTemplatesInPool = _tmpltMgr.getUnusedTemplatesInPool(pool);	
storage pool garbage collector found templates to clean up in storage pool 

try {	if (scanLock.lock(3)) {	try {	if (_templateCleanupEnabled) {	List<StoragePoolVO> storagePools = _storagePoolDao.listAll();	for (StoragePoolVO pool : storagePools) {	try {	List<VMTemplateStoragePoolVO> unusedTemplatesInPool = _tmpltMgr.getUnusedTemplatesInPool(pool);	for (VMTemplateStoragePoolVO templatePoolVO : unusedTemplatesInPool) {	if (templatePoolVO.getDownloadState() != VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {	
storage pool garbage collector is skipping template with id on pool because it is not completely downloaded 

for (StoragePoolVO pool : storagePools) {	try {	List<VMTemplateStoragePoolVO> unusedTemplatesInPool = _tmpltMgr.getUnusedTemplatesInPool(pool);	for (VMTemplateStoragePoolVO templatePoolVO : unusedTemplatesInPool) {	if (templatePoolVO.getDownloadState() != VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {	continue;	}	if (!templatePoolVO.getMarkedForGC()) {	templatePoolVO.setMarkedForGC(true);	_vmTemplatePoolDao.update(templatePoolVO.getId(), templatePoolVO);	
storage pool garbage collector has marked template with id on pool for garbage collection 

continue;	}	if (!templatePoolVO.getMarkedForGC()) {	templatePoolVO.setMarkedForGC(true);	_vmTemplatePoolDao.update(templatePoolVO.getId(), templatePoolVO);	continue;	}	_tmpltMgr.evictTemplateFromStoragePool(templatePoolVO);	}	} catch (Exception e) {	
problem cleaning up primary storage pool 

} catch (Exception e) {	}	}	}	cleanupSecondaryStorage(recurring);	List<VolumeVO> vols = _volsDao.listVolumesToBeDestroyed(new Date(System.currentTimeMillis() - ((long) StorageCleanupDelay.value() << 10)));	for (VolumeVO vol : vols) {	try {	volService.expungeVolumeAsync(volFactory.getVolume(vol.getId()));	} catch (Exception e) {	
unable to destroy volume 

}	List<SnapshotVO> snapshots = _snapshotDao.listAllByStatus(Snapshot.State.Error);	for (SnapshotVO snapshotVO : snapshots) {	try {	List<SnapshotDataStoreVO> storeRefs = _snapshotStoreDao.findBySnapshotId(snapshotVO.getId());	for (SnapshotDataStoreVO ref : storeRefs) {	_snapshotStoreDao.expunge(ref.getId());	}	_snapshotDao.expunge(snapshotVO.getId());	} catch (Exception e) {	
unable to destroy snapshot 

_snapshotStoreDao.expunge(ref.getId());	}	_snapshotDao.expunge(snapshotVO.getId());	} catch (Exception e) {	}	}	List<VolumeDataStoreVO> volumeDataStores = _volumeDataStoreDao.listByVolumeState(Volume.State.UploadError, Volume.State.UploadAbandoned);	for (VolumeDataStoreVO volumeDataStore : volumeDataStores) {	VolumeVO volume = _volumeDao.findById(volumeDataStore.getVolumeId());	if (volume == null) {	
uploaded volume with id not found so cannot be destroyed 

List<VolumeDataStoreVO> volumeDataStores = _volumeDataStoreDao.listByVolumeState(Volume.State.UploadError, Volume.State.UploadAbandoned);	for (VolumeDataStoreVO volumeDataStore : volumeDataStores) {	VolumeVO volume = _volumeDao.findById(volumeDataStore.getVolumeId());	if (volume == null) {	continue;	}	try {	DataStore dataStore = _dataStoreMgr.getDataStore(volumeDataStore.getDataStoreId(), DataStoreRole.Image);	EndPoint ep = _epSelector.select(dataStore, volumeDataStore.getExtractUrl());	if (ep == null) {	
there is no secondary storage vm for image store cannot destroy uploaded volume 

try {	DataStore dataStore = _dataStoreMgr.getDataStore(volumeDataStore.getDataStoreId(), DataStoreRole.Image);	EndPoint ep = _epSelector.select(dataStore, volumeDataStore.getExtractUrl());	if (ep == null) {	continue;	}	Host host = _hostDao.findById(ep.getId());	if (host != null && host.getManagementServerId() != null) {	if (_serverId == host.getManagementServerId().longValue()) {	if (!volService.destroyVolume(volume.getId())) {	
unable to destroy uploaded volume 

}	Host host = _hostDao.findById(ep.getId());	if (host != null && host.getManagementServerId() != null) {	if (_serverId == host.getManagementServerId().longValue()) {	if (!volService.destroyVolume(volume.getId())) {	continue;	}	_resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType.volume, volume.isDisplayVolume());	VolumeInfo volOnSecondary = volFactory.getVolume(volume.getId(), DataStoreRole.Image);	if (volOnSecondary != null) {	
expunging volume uploaded using http post from secondary data store 

if (_serverId == host.getManagementServerId().longValue()) {	if (!volService.destroyVolume(volume.getId())) {	continue;	}	_resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType.volume, volume.isDisplayVolume());	VolumeInfo volOnSecondary = volFactory.getVolume(volume.getId(), DataStoreRole.Image);	if (volOnSecondary != null) {	AsyncCallFuture<VolumeApiResult> future = volService.expungeVolumeAsync(volOnSecondary);	VolumeApiResult result = future.get();	if (!result.isSuccess()) {	
failed to expunge volume from the image store due to 

VolumeInfo volOnSecondary = volFactory.getVolume(volume.getId(), DataStoreRole.Image);	if (volOnSecondary != null) {	AsyncCallFuture<VolumeApiResult> future = volService.expungeVolumeAsync(volOnSecondary);	VolumeApiResult result = future.get();	if (!result.isSuccess()) {	}	}	}	}	} catch (Throwable th) {	
unable to destroy uploaded volume error details 

}	}	}	} catch (Throwable th) {	}	}	List<TemplateDataStoreVO> templateDataStores = _templateStoreDao.listByTemplateState(VirtualMachineTemplate.State.UploadError, VirtualMachineTemplate.State.UploadAbandoned);	for (TemplateDataStoreVO templateDataStore : templateDataStores) {	VMTemplateVO template = _templateDao.findById(templateDataStore.getTemplateId());	if (template == null) {	
uploaded template with id not found so cannot be destroyed 

List<TemplateDataStoreVO> templateDataStores = _templateStoreDao.listByTemplateState(VirtualMachineTemplate.State.UploadError, VirtualMachineTemplate.State.UploadAbandoned);	for (TemplateDataStoreVO templateDataStore : templateDataStores) {	VMTemplateVO template = _templateDao.findById(templateDataStore.getTemplateId());	if (template == null) {	continue;	}	try {	DataStore dataStore = _dataStoreMgr.getDataStore(templateDataStore.getDataStoreId(), DataStoreRole.Image);	EndPoint ep = _epSelector.select(dataStore, templateDataStore.getExtractUrl());	if (ep == null) {	
there is no secondary storage vm for image store cannot destroy uploaded template 

EndPoint ep = _epSelector.select(dataStore, templateDataStore.getExtractUrl());	if (ep == null) {	continue;	}	Host host = _hostDao.findById(ep.getId());	if (host != null && host.getManagementServerId() != null) {	if (_serverId == host.getManagementServerId().longValue()) {	AsyncCallFuture<TemplateApiResult> future = _imageSrv.deleteTemplateAsync(tmplFactory.getTemplate(template.getId(), dataStore));	TemplateApiResult result = future.get();	if (!result.isSuccess()) {	
failed to delete template from the image store due to 

_templateStoreDao.removeByTemplateStore(template.getId(), dataStore.getId());	List<DataStore> imageStores = _tmpltMgr.getImageStoreByTemplate(template.getId(), null);	if (imageStores == null || imageStores.size() == 0) {	template.setState(VirtualMachineTemplate.State.Inactive);	_templateDao.update(template.getId(), template);	_resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);	}	}	}	} catch (Throwable th) {	
unable to destroy uploaded template error details 

public void cleanupSecondaryStorage(boolean recurring) {	try {	List<DataStore> imageStores = _dataStoreMgr.getImageStoresByScope(new ZoneScope(null));	for (DataStore store : imageStores) {	try {	long storeId = store.getId();	List<TemplateDataStoreVO> destroyedTemplateStoreVOs = _templateStoreDao.listDestroyed(storeId);	
secondary storage garbage collector found templates to cleanup on template store ref for store 

public void cleanupSecondaryStorage(boolean recurring) {	try {	List<DataStore> imageStores = _dataStoreMgr.getImageStoresByScope(new ZoneScope(null));	for (DataStore store : imageStores) {	try {	long storeId = store.getId();	List<TemplateDataStoreVO> destroyedTemplateStoreVOs = _templateStoreDao.listDestroyed(storeId);	for (TemplateDataStoreVO destroyedTemplateStoreVO : destroyedTemplateStoreVOs) {	if (s_logger.isDebugEnabled()) {	
deleting template store db entry 

for (DataStore store : imageStores) {	try {	long storeId = store.getId();	List<TemplateDataStoreVO> destroyedTemplateStoreVOs = _templateStoreDao.listDestroyed(storeId);	for (TemplateDataStoreVO destroyedTemplateStoreVO : destroyedTemplateStoreVOs) {	if (s_logger.isDebugEnabled()) {	}	_templateStoreDao.remove(destroyedTemplateStoreVO.getId());	}	} catch (Exception e) {	
problem cleaning up templates in template store ref for store 

if (s_logger.isDebugEnabled()) {	}	_templateStoreDao.remove(destroyedTemplateStoreVO.getId());	}	} catch (Exception e) {	}	}	for (DataStore store : imageStores) {	try {	List<SnapshotDataStoreVO> destroyedSnapshotStoreVOs = _snapshotStoreDao.listDestroyed(store.getId());	
secondary storage garbage collector found snapshots to cleanup on snapshot store ref for store 

}	} catch (Exception e) {	}	}	for (DataStore store : imageStores) {	try {	List<SnapshotDataStoreVO> destroyedSnapshotStoreVOs = _snapshotStoreDao.listDestroyed(store.getId());	for (SnapshotDataStoreVO destroyedSnapshotStoreVO : destroyedSnapshotStoreVOs) {	SnapshotInfo snap = snapshotFactory.getSnapshot(destroyedSnapshotStoreVO.getSnapshotId(), store);	if (snap.getChild() != null) {	
skip snapshot on store because it has child 

}	for (DataStore store : imageStores) {	try {	List<SnapshotDataStoreVO> destroyedSnapshotStoreVOs = _snapshotStoreDao.listDestroyed(store.getId());	for (SnapshotDataStoreVO destroyedSnapshotStoreVO : destroyedSnapshotStoreVOs) {	SnapshotInfo snap = snapshotFactory.getSnapshot(destroyedSnapshotStoreVO.getSnapshotId(), store);	if (snap.getChild() != null) {	continue;	}	if (s_logger.isDebugEnabled()) {	
deleting snapshot store db entry 

if (s_logger.isDebugEnabled()) {	}	_snapshotDao.remove(destroyedSnapshotStoreVO.getSnapshotId());	SnapshotDataStoreVO snapshotOnPrimary = _snapshotStoreDao.findBySnapshot(destroyedSnapshotStoreVO.getSnapshotId(), DataStoreRole.Primary);	if (snapshotOnPrimary != null) {	_snapshotStoreDao.remove(snapshotOnPrimary.getId());	}	_snapshotStoreDao.remove(destroyedSnapshotStoreVO.getId());	}	} catch (Exception e2) {	
problem cleaning up snapshots in snapshot store ref for store 

_snapshotStoreDao.remove(snapshotOnPrimary.getId());	}	_snapshotStoreDao.remove(destroyedSnapshotStoreVO.getId());	}	} catch (Exception e2) {	}	}	for (DataStore store : imageStores) {	try {	List<VolumeDataStoreVO> destroyedStoreVOs = _volumeStoreDao.listDestroyed(store.getId());	
secondary storage garbage collector found volumes to cleanup on volume store ref for store 

_snapshotStoreDao.remove(destroyedSnapshotStoreVO.getId());	}	} catch (Exception e2) {	}	}	for (DataStore store : imageStores) {	try {	List<VolumeDataStoreVO> destroyedStoreVOs = _volumeStoreDao.listDestroyed(store.getId());	for (VolumeDataStoreVO destroyedStoreVO : destroyedStoreVOs) {	if (s_logger.isDebugEnabled()) {	
deleting volume store db entry 

}	for (DataStore store : imageStores) {	try {	List<VolumeDataStoreVO> destroyedStoreVOs = _volumeStoreDao.listDestroyed(store.getId());	for (VolumeDataStoreVO destroyedStoreVO : destroyedStoreVOs) {	if (s_logger.isDebugEnabled()) {	}	_volumeStoreDao.remove(destroyedStoreVO.getId());	}	} catch (Exception e2) {	
problem cleaning up volumes in volume store ref for store 

List<VolumeDataStoreVO> destroyedStoreVOs = _volumeStoreDao.listDestroyed(store.getId());	for (VolumeDataStoreVO destroyedStoreVO : destroyedStoreVOs) {	if (s_logger.isDebugEnabled()) {	}	_volumeStoreDao.remove(destroyedStoreVO.getId());	}	} catch (Exception e2) {	}	}	} catch (Exception e3) {	
problem cleaning up secondary storage db entries 

protected void runInContext() {	try {	
storage garbage collection thread is running 

protected void runInContext() {	try {	cleanupStorage(true);	} catch (Exception e) {	
caught the following exception 

public void onManagementNodeLeft(List<? extends ManagementServerHost> nodeList, long selfNodeId) {	for (ManagementServerHost vo : nodeList) {	if (vo.getMsid() == _serverId) {	
cleaning up storage maintenance jobs associated with management server 

throw new InvalidParameterValueException(newUrl + " is not a valid uri");	}	String oldUrl = secHost.getStorageUrl();	URI oldUri = null;	try {	oldUri = new URI(UriUtils.encodeURIComponent(oldUrl));	if (!oldUri.getScheme().equalsIgnoreCase(uri.getScheme())) {	throw new InvalidParameterValueException("can not change old scheme:" + oldUri.getScheme() + " to " + uri.getScheme());	}	} catch (URISyntaxException e) {	
failed to get uri from 

double storageUsedThreshold = CapacityManager.StorageCapacityDisableThreshold.valueIn(pool.getDataCenterId());	if (sc != null) {	long totalSize = pool.getCapacityBytes();	StorageStats stats = sc.getStoragePoolStats(pool.getId());	if (stats == null) {	stats = sc.getStorageStats(pool.getId());	}	if (stats != null) {	double usedPercentage = ((double)stats.getByteUsed() / (double)totalSize);	if (s_logger.isDebugEnabled()) {	
checking pool for storage totalsize usedbytes usedpct disable threshold 

StorageStats stats = sc.getStoragePoolStats(pool.getId());	if (stats == null) {	stats = sc.getStorageStats(pool.getId());	}	if (stats != null) {	double usedPercentage = ((double)stats.getByteUsed() / (double)totalSize);	if (s_logger.isDebugEnabled()) {	}	if (usedPercentage >= storageUsedThreshold) {	if (s_logger.isDebugEnabled()) {	
insufficient space on pool since its usage percentage has crossed the pool storage capacity disablethreshold 

public boolean storagePoolHasEnoughIops(List<Volume> requestedVolumes, StoragePool pool) {	if (requestedVolumes == null || requestedVolumes.isEmpty() || pool == null) {	return false;	}	if (pool.getCapacityIops() == null) {	
storage pool does not supply iops capacity assuming enough capacity 

public boolean storagePoolHasEnoughSpace(List<Volume> volumes, StoragePool pool, Long clusterId) {	if (volumes == null || volumes.isEmpty()) {	return false;	}	if (!checkUsagedSpace(pool)) {	return false;	}	if(s_logger.isDebugEnabled()) {	
destination pool id 

volService.updateHypervisorSnapshotReserveForVolume(getDiskOfferingVO(volumeVO), volumeVO.getId(), getHypervisorType(volumeVO));	volumeVO = _volumeDao.findById(volume.getId());	}	if (volume.getTemplateId() != null) {	VMTemplateVO tmpl = _templateDao.findByIdIncludingRemoved(volume.getTemplateId());	if (tmpl != null && !ImageFormat.ISO.equals(tmpl.getFormat())) {	allocatedSizeWithTemplate = _capacityMgr.getAllocatedPoolCapacity(poolVO, tmpl);	}	}	if (s_logger.isDebugEnabled()) {	
pool id for the volume with id is 

totalAskingSize += getBytesRequiredForTemplate(tmpl, pool);	}	}	}	}	}	long totalOverProvCapacity;	if (pool.getPoolType() == StoragePoolType.NetworkFilesystem || pool.getPoolType() == StoragePoolType.VMFS || pool.getPoolType() == StoragePoolType.Filesystem) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(pool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(pool.getCapacityBytes())).longValue();	
found storage pool of type with overprovisioning factor 

totalAskingSize += getBytesRequiredForTemplate(tmpl, pool);	}	}	}	}	}	long totalOverProvCapacity;	if (pool.getPoolType() == StoragePoolType.NetworkFilesystem || pool.getPoolType() == StoragePoolType.VMFS || pool.getPoolType() == StoragePoolType.Filesystem) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(pool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(pool.getCapacityBytes())).longValue();	
total over provisioned capacity calculated is 

}	}	}	}	long totalOverProvCapacity;	if (pool.getPoolType() == StoragePoolType.NetworkFilesystem || pool.getPoolType() == StoragePoolType.VMFS || pool.getPoolType() == StoragePoolType.Filesystem) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(pool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(pool.getCapacityBytes())).longValue();	} else {	totalOverProvCapacity = pool.getCapacityBytes();	
found storage pool of type 

}	}	}	long totalOverProvCapacity;	if (pool.getPoolType() == StoragePoolType.NetworkFilesystem || pool.getPoolType() == StoragePoolType.VMFS || pool.getPoolType() == StoragePoolType.Filesystem) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(pool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(pool.getCapacityBytes())).longValue();	} else {	totalOverProvCapacity = pool.getCapacityBytes();	}	
total capacity of the pool id is 

}	long totalOverProvCapacity;	if (pool.getPoolType() == StoragePoolType.NetworkFilesystem || pool.getPoolType() == StoragePoolType.VMFS || pool.getPoolType() == StoragePoolType.Filesystem) {	BigDecimal overProvFactor = getStorageOverProvisioningFactor(pool.getId());	totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(pool.getCapacityBytes())).longValue();	} else {	totalOverProvCapacity = pool.getCapacityBytes();	}	double storageAllocatedThreshold = CapacityManager.StorageAllocatedCapacityDisableThreshold.valueIn(pool.getDataCenterId());	if (s_logger.isDebugEnabled()) {	
checking pool for volume allocation maxsize totalallocatedsize askingsize allocated disable threshold 

totalOverProvCapacity = overProvFactor.multiply(new BigDecimal(pool.getCapacityBytes())).longValue();	} else {	totalOverProvCapacity = pool.getCapacityBytes();	}	double storageAllocatedThreshold = CapacityManager.StorageAllocatedCapacityDisableThreshold.valueIn(pool.getDataCenterId());	if (s_logger.isDebugEnabled()) {	}	double usedPercentage = (allocatedSizeWithTemplate + totalAskingSize) / (double)(totalOverProvCapacity);	if (usedPercentage > storageAllocatedThreshold) {	if (s_logger.isDebugEnabled()) {	
insufficient un allocated capacity on for volume allocation since its allocated percentage has crossed the allocated pool storage allocated capacity disablethreshold skipping this pool 

if (s_logger.isDebugEnabled()) {	}	double usedPercentage = (allocatedSizeWithTemplate + totalAskingSize) / (double)(totalOverProvCapacity);	if (usedPercentage > storageAllocatedThreshold) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	if (totalOverProvCapacity < (allocatedSizeWithTemplate + totalAskingSize)) {	if (s_logger.isDebugEnabled()) {	
insufficient un allocated capacity on for volume allocation not enough storage maxsize totalallocatedsize askingsize 

params.put("details", details);	params.put("scope", scopeType);	params.put("providerName", storeProvider.getName());	params.put("role", DataStoreRole.Image);	DataStoreLifeCycle lifeCycle = storeProvider.getDataStoreLifeCycle();	DataStore store;	try {	store = lifeCycle.initialize(params);	} catch (Exception e) {	if(s_logger.isDebugEnabled()) {	
failed to add data store 

params.put("name", cmd.getUrl());	params.put("details", cmd.getDetails());	params.put("scope", scopeType);	params.put("providerName", storeProvider.getName());	params.put("role", DataStoreRole.ImageCache);	DataStoreLifeCycle lifeCycle = storeProvider.getDataStoreLifeCycle();	DataStore store = null;	try {	store = lifeCycle.initialize(params);	} catch (Exception e) {	
failed to add data store 

public void run() {	try {	
download url garbage collection thread is running 

public void run() {	try {	cleanupDownloadUrls();	} catch (Exception e) {	
caught the following exception 

HashSet<Long> activeVolumeIds = new HashSet<Long>();	for(VolumeDataStoreVO volumeOnImageStore : volumesOnImageStoreList){	long volumeId = volumeOnImageStore.getVolumeId();	try {	long downloadUrlCurrentAgeInSecs = DateUtil.getTimeDifference(DateUtil.now(), volumeOnImageStore.getExtractUrlCreated());	if(downloadUrlCurrentAgeInSecs < _downloadUrlExpirationInterval){	activeVolumeIds.add(volumeId);	continue;	}	expiredVolumeIds.add(volumeId);	
removing download url for volume id 

long downloadUrlCurrentAgeInSecs = DateUtil.getTimeDifference(DateUtil.now(), volumeOnImageStore.getExtractUrlCreated());	if(downloadUrlCurrentAgeInSecs < _downloadUrlExpirationInterval){	activeVolumeIds.add(volumeId);	continue;	}	expiredVolumeIds.add(volumeId);	ImageStoreEntity secStore = (ImageStoreEntity) _dataStoreMgr.getDataStore(volumeOnImageStore.getDataStoreId(), DataStoreRole.Image);	secStore.deleteExtractUrl(volumeOnImageStore.getInstallPath(), volumeOnImageStore.getExtractUrl(), Upload.Type.VOLUME);	_volumeStoreDao.expunge(volumeOnImageStore.getId());	}catch(Throwable th){	
caught exception while deleting download url for volume id 

_volumeDao.remove(volumeId);	}	}	List<TemplateDataStoreVO> templatesOnImageStoreList = _templateStoreDao.listTemplateDownloadUrls();	for(TemplateDataStoreVO templateOnImageStore : templatesOnImageStoreList){	try {	long downloadUrlCurrentAgeInSecs = DateUtil.getTimeDifference(DateUtil.now(), templateOnImageStore.getExtractUrlCreated());	if(downloadUrlCurrentAgeInSecs < _downloadUrlExpirationInterval){	continue;	}	
removing download url for template id 

long downloadUrlCurrentAgeInSecs = DateUtil.getTimeDifference(DateUtil.now(), templateOnImageStore.getExtractUrlCreated());	if(downloadUrlCurrentAgeInSecs < _downloadUrlExpirationInterval){	continue;	}	ImageStoreEntity secStore = (ImageStoreEntity) _dataStoreMgr.getDataStore(templateOnImageStore.getDataStoreId(), DataStoreRole.Image);	secStore.deleteExtractUrl(templateOnImageStore.getInstallPath(), templateOnImageStore.getExtractUrl(), Upload.Type.TEMPLATE);	templateOnImageStore.setExtractUrl(null);	templateOnImageStore.setExtractUrlCreated(null);	_templateStoreDao.update(templateOnImageStore.getId(), templateOnImageStore);	}catch(Throwable th){	
caught exception while deleting download url for template id 

========================= cloudstack sample_2460 =========================

public void check(Properties dbProps) throws IOException {	String encryptionType = dbProps.getProperty("db.cloud.encryption.type");	
encryption type 

public void check(Properties dbProps) throws IOException {	String encryptionType = dbProps.getProperty("db.cloud.encryption.type");	if (encryptionType == null || encryptionType.equals("none")) {	return;	}	if (s_useEncryption) {	
encryption already enabled is check called twice 

throw new CloudRuntimeException("Secret key is null or empty in file " + s_keyFile);	}	} else if (encryptionType.equals("env")) {	secretKey = System.getenv(s_envKey);	if (secretKey == null || secretKey.isEmpty()) {	throw new CloudRuntimeException("Environment variable " + s_envKey + " is not set or empty");	}	} else if (encryptionType.equals("web")) {	int port = 8097;	try (ServerSocket serverSocket = new ServerSocket(port);) {	
waiting for admin to send secret key on port 

========================= cloudstack sample_2749 =========================

public boolean executeTest() {	int error = 0;	Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	
test case failed command that was supposed to fail passed the command was sent with the following url 

NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use the command was sent with url 

Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	}	if (api.verifyParam() == false) {	
test failed verification for returned parameters failed the command was sent with url 

api.sendCommand(this.getClient(), this.getConn());	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	}	if (api.verifyParam() == false) {	error++;	} else {	
test passed 

error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	}	if (api.verifyParam() == false) {	error++;	} else {	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	
test case failed with an error code command was sent with url 

} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	}	if (api.verifyParam() == false) {	error++;	} else {	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	
the command is required for the future use so exiging 

if (api.verifyParam() == false) {	error++;	} else {	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	return false;	}	error++;	} else if (api.getTestCaseInfo() != null) {	
test case passed 

========================= cloudstack sample_452 =========================

final String msg = "VM " + vmName + " is runing on host " + host;	s_logger.debug(msg);	return new StartAnswer(command, msg, host);	} else {	final String msg = "There is already a VM having the same name " + vmName + " vm record " + vRec.toString();	s_logger.warn(msg);	return new StartAnswer(command, msg);	}	}	}	
the vm is in starting state 

final String msg = "There is already a VM having the same name " + vmName + " vm record " + vRec.toString();	s_logger.warn(msg);	return new StartAnswer(command, msg);	}	}	}	final Host host = Host.getByUuid(conn, citrixResourceBase.getHost().getUuid());	vm = citrixResourceBase.createVmFromTemplate(conn, vmSpec, host);	final GPUDeviceTO gpuDevice = vmSpec.getGpuDevice();	if (gpuDevice != null) {	
creating vgpu for of vgpu type in gpu group for vm 

}	citrixResourceBase.startVM(conn, host, vm, vmName);	if (citrixResourceBase.isOvs()) {	for (final NicTO nic : vmSpec.getNics()) {	if (nic.getBroadcastType() == Networks.BroadcastDomainType.Vswitch) {	final HashMap<String, String> args = citrixResourceBase.parseDefaultOvsRuleComamnd(BroadcastDomainType.getValue(nic.getBroadcastUri()));	final OvsSetTagAndFlowCommand flowCmd = new OvsSetTagAndFlowCommand(args.get("vmName"), args.get("tag"), args.get("vlans"), args.get("seqno"), Long.parseLong(args.get("vmId")));	final CitrixRequestWrapper citrixRequestWrapper = CitrixRequestWrapper.getInstance();	final OvsSetTagAndFlowAnswer r = (OvsSetTagAndFlowAnswer) citrixRequestWrapper.execute(flowCmd, citrixResourceBase);	if (!r.getResult()) {	
failed to set flow for vm 

citrixResourceBase.startVM(conn, host, vm, vmName);	if (citrixResourceBase.isOvs()) {	for (final NicTO nic : vmSpec.getNics()) {	if (nic.getBroadcastType() == Networks.BroadcastDomainType.Vswitch) {	final HashMap<String, String> args = citrixResourceBase.parseDefaultOvsRuleComamnd(BroadcastDomainType.getValue(nic.getBroadcastUri()));	final OvsSetTagAndFlowCommand flowCmd = new OvsSetTagAndFlowCommand(args.get("vmName"), args.get("tag"), args.get("vlans"), args.get("seqno"), Long.parseLong(args.get("vmId")));	final CitrixRequestWrapper citrixRequestWrapper = CitrixRequestWrapper.getInstance();	final OvsSetTagAndFlowAnswer r = (OvsSetTagAndFlowAnswer) citrixRequestWrapper.execute(flowCmd, citrixResourceBase);	if (!r.getResult()) {	} else {	
success to set flow for vm 

boolean secGrpEnabled = false;	for (final NicTO nic : nics) {	if (nic.isSecurityGroupEnabled() || nic.getIsolationUri() != null && nic.getIsolationUri().getScheme().equalsIgnoreCase(IsolationType.Ec2.toString())) {	secGrpEnabled = true;	break;	}	}	if (secGrpEnabled) {	result = citrixResourceBase.callHostPlugin(conn, "vmops", "default_network_rules_systemvm", "vmName", vmName);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	
failed to program default network rules for 

for (final NicTO nic : nics) {	if (nic.isSecurityGroupEnabled() || nic.getIsolationUri() != null && nic.getIsolationUri().getScheme().equalsIgnoreCase(IsolationType.Ec2.toString())) {	secGrpEnabled = true;	break;	}	}	if (secGrpEnabled) {	result = citrixResourceBase.callHostPlugin(conn, "vmops", "default_network_rules_systemvm", "vmName", vmName);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	} else {	
programmed default network rules for 

if (nicSecIps != null) {	for (final String ip : nicSecIps) {	sb.append(ip).append(":");	}	secIpsStr = sb.toString();	} else {	secIpsStr = "0:";	}	result = citrixResourceBase.callHostPlugin(conn, "vmops", "default_network_rules", "vmName", vmName, "vmIP", nic.getIp(), "vmMAC", nic.getMac(), "vmID", Long.toString(vmSpec.getId()), "secIps", secIpsStr);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	
failed to program default network rules for on nic with ip mac 

for (final String ip : nicSecIps) {	sb.append(ip).append(":");	}	secIpsStr = sb.toString();	} else {	secIpsStr = "0:";	}	result = citrixResourceBase.callHostPlugin(conn, "vmops", "default_network_rules", "vmName", vmName, "vmIP", nic.getIp(), "vmMAC", nic.getMac(), "vmID", Long.toString(vmSpec.getId()), "secIps", secIpsStr);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	} else {	
programmed default network rules for on nic with ip mac 

}	}	}	}	}	state = VmPowerState.RUNNING;	final StartAnswer startAnswer = new StartAnswer(command);	startAnswer.setIqnToPath(iqnToPath);	return startAnswer;	} catch (final Exception e) {	
catch exception due to 

final StartAnswer startAnswer = new StartAnswer(command);	startAnswer.setIqnToPath(iqnToPath);	return startAnswer;	} catch (final Exception e) {	final String msg = citrixResourceBase.handleVmStartFailure(conn, vmName, vm, "", e);	final StartAnswer startAnswer = new StartAnswer(command, msg);	startAnswer.setIqnToPath(iqnToPath);	return startAnswer;	} finally {	if (state != VmPowerState.HALTED) {	
the vm is in state 

startAnswer.setIqnToPath(iqnToPath);	return startAnswer;	} catch (final Exception e) {	final String msg = citrixResourceBase.handleVmStartFailure(conn, vmName, vm, "", e);	final StartAnswer startAnswer = new StartAnswer(command, msg);	startAnswer.setIqnToPath(iqnToPath);	return startAnswer;	} finally {	if (state != VmPowerState.HALTED) {	} else {	
the vm is in stopped state detected problem during startup 

========================= cloudstack sample_1165 =========================

public File getSystemVMKeyFile(String filename) {	String keyPath = Script.findScript("", "scripts/vm/systemvm/" + filename);	File keyFile = null;	if (keyPath != null) {	
found sshkey 

public File getSystemVMKeyFile(String filename) {	String keyPath = Script.findScript("", "scripts/vm/systemvm/" + filename);	File keyFile = null;	if (keyPath != null) {	keyFile = new File(keyPath);	}	if (keyFile == null || !keyFile.exists()) {	String key = "client/target/generated-webapp/WEB-INF/classes/scripts/vm/systemvm/" + filename;	
findscript failed going for generated 

File keyFile = null;	if (keyPath != null) {	keyFile = new File(keyPath);	}	if (keyFile == null || !keyFile.exists()) {	String key = "client/target/generated-webapp/WEB-INF/classes/scripts/vm/systemvm/" + filename;	keyFile = new File(key);	}	if (keyFile == null || !keyFile.exists()) {	String key = "/usr/share/cloudstack-common/scripts/vm/systemvm/" + filename;	
generated key retrieval failed 

public void fillHostInfo(StartupRoutingCommand cmd) {	try {	Linux host = new Linux(c);	if (!host.getOvmVersion().startsWith("3.2.") && !host.getOvmVersion().startsWith("3.3.")) {	
hypervisor not supported 

public void fillHostInfo(StartupRoutingCommand cmd) {	try {	Linux host = new Linux(c);	if (!host.getOvmVersion().startsWith("3.2.") && !host.getOvmVersion().startsWith("3.3.")) {	throw new CloudRuntimeException( "OVM 3.2. or 3.3. are only supported, not " + host.getOvmVersion());	} else {	
hypervisor version 

config.setAgentStorageNetworkName(config .getAgentPrivateNetworkName());	}	Map<String, String> d = cmd.getHostDetails();	d.put("public.network.device", config.getAgentPublicNetworkName());	d.put("private.network.device", config.getAgentPrivateNetworkName());	d.put("guest.network.device", config.getAgentGuestNetworkName());	d.put("storage.network.device", config.getAgentStorageNetworkName());	d.put("ismaster", config.getAgentIsMaster().toString());	d.put("hasmaster", config.getAgentHasMaster().toString());	cmd.setHostDetails(d);	
add an host 

public Boolean setupServer(String key) throws IOException {	
setup all bits on agent 

String prepareCmd = String.format(config.getAgentScriptsDir() + "/" + config.getAgentScript() + " --ssl=" + c.getUseSsl() + " " + "--port=" + c.getPort());	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, prepareCmd)) {	throw new ConfigurationException("Failed to insert module on " + config.getAgentHostname());	} else {	Thread.sleep(5000);	}	CloudstackPlugin cSp = new CloudstackPlugin(c);	cSp.ovsUploadSshKey(config.getAgentSshKeyFileName(), FileUtils.readFileToString(getSystemVMKeyFile(key)));	cSp.dom0CheckStorageHealthCheck(config.getAgentScriptsDir(), config.getAgentCheckStorageScript(), config.getCsHostGuid(), config.getAgentStorageCheckTimeout(), config.getAgentStorageCheckInterval());	} catch (Exception es) {	
unexpected exception 

private Map<String, Xen.Vm> getAllVms() throws Ovm3ResourceException {	try {	Xen vms = new Xen(c);	return vms.getRunningVmConfigs();	} catch (Exception e) {	
getting vm list from failed 

} else {	ns = State.Stopped;	}	} else if (as.contains("c")) {	ns = State.Error;	} else if (as.contains("d")) {	ns = State.Stopping;	} else {	ns = State.Unknown;	}	
state for based on 

private Map<String, State> syncState(Map<String, State> vmStateMap) throws Ovm3ResourceException {	Map<String, State> newStates;	Map<String, State> oldStates = null;	final Map<String, State> changes = new HashMap<String, State>();	try {	newStates = getAllVmStates(vmStateMap);	} catch (Ovm3ResourceException e) {	
full sync failed 

} catch (Ovm3ResourceException e) {	throw e;	}	synchronized (vmStateMap) {	oldStates = new HashMap<String, State>(vmStateMap.size());	oldStates.putAll(vmStateMap);	for (final Map.Entry<String, State> entry : newStates.entrySet()) {	final String vmName = entry.getKey();	State newState = entry.getValue();	final State oldState = oldStates.remove(vmName);	
state for old new 

throw e;	}	synchronized (vmStateMap) {	oldStates = new HashMap<String, State>(vmStateMap.size());	oldStates.putAll(vmStateMap);	for (final Map.Entry<String, State> entry : newStates.entrySet()) {	final String vmName = entry.getKey();	State newState = entry.getValue();	final State oldState = oldStates.remove(vmName);	if (newState == State.Stopped && oldState != State.Stopping && oldState != null && oldState != State.Stopped) {	
getting power state 

final String vmName = entry.getKey();	State newState = entry.getValue();	final State oldState = oldStates.remove(vmName);	if (newState == State.Stopped && oldState != State.Stopping && oldState != null && oldState != State.Stopped) {	newState = State.Running;	}	if (LOGGER.isTraceEnabled()) {	LOGGER.trace("VM " + vmName + ": ovm has state " + newState + " and we have state " + (oldState != null ? oldState.toString() : "null"));	}	if (newState == State.Migrating) {	
is migrating skipping state check 

newState = State.Running;	}	if (LOGGER.isTraceEnabled()) {	LOGGER.trace("VM " + vmName + ": ovm has state " + newState + " and we have state " + (oldState != null ? oldState.toString() : "null"));	}	if (newState == State.Migrating) {	continue;	}	if (oldState == null) {	vmStateMap.put(vmName, newState);	
new state without old state 

if (newState == State.Migrating) {	continue;	}	if (oldState == null) {	vmStateMap.put(vmName, newState);	changes.put(vmName, newState);	} else if (oldState == State.Starting) {	if (newState == State.Running) {	vmStateMap.put(vmName, newState);	} else if (newState == State.Stopped) {	
ignoring vm because of a lag in starting the vm 

if (oldState == null) {	vmStateMap.put(vmName, newState);	changes.put(vmName, newState);	} else if (oldState == State.Starting) {	if (newState == State.Running) {	vmStateMap.put(vmName, newState);	} else if (newState == State.Stopped) {	}	} else if (oldState == State.Migrating) {	if (newState == State.Running) {	
detected that a migrating vm is now running 

} else if (newState == State.Stopped) {	}	} else if (oldState == State.Migrating) {	if (newState == State.Running) {	vmStateMap.put(vmName, newState);	}	} else if (oldState == State.Stopping) {	if (newState == State.Stopped) {	vmStateMap.put(vmName, newState);	} else if (newState == State.Running) {	
ignoring vm because of a lag in stopping the vm 

vmStateMap.put(vmName, newState);	if (newState == State.Stopped) {	}	changes.put(vmName, newState);	}	}	for (final Map.Entry<String, State> entry : oldStates.entrySet()) {	final String vmName = entry.getKey();	final State oldState = entry.getValue();	if (oldState == State.Stopping) {	
removing vm in transition state stopping 

}	changes.put(vmName, newState);	}	}	for (final Map.Entry<String, State> entry : oldStates.entrySet()) {	final String vmName = entry.getKey();	final State oldState = entry.getValue();	if (oldState == State.Stopping) {	vmStateMap.remove(vmName);	} else if (oldState == State.Starting) {	
removing vm in transition state starting 

}	}	for (final Map.Entry<String, State> entry : oldStates.entrySet()) {	final String vmName = entry.getKey();	final State oldState = entry.getValue();	if (oldState == State.Stopping) {	vmStateMap.remove(vmName);	} else if (oldState == State.Starting) {	vmStateMap.remove(vmName);	} else if (oldState == State.Stopped) {	
stopped vm removing 

for (final Map.Entry<String, State> entry : oldStates.entrySet()) {	final String vmName = entry.getKey();	final State oldState = entry.getValue();	if (oldState == State.Stopping) {	vmStateMap.remove(vmName);	} else if (oldState == State.Starting) {	vmStateMap.remove(vmName);	} else if (oldState == State.Stopped) {	vmStateMap.remove(vmName);	} else if (oldState == State.Migrating) {	
ignoring vm in migrating state 

final State oldState = entry.getValue();	if (oldState == State.Stopping) {	vmStateMap.remove(vmName);	} else if (oldState == State.Starting) {	vmStateMap.remove(vmName);	} else if (oldState == State.Stopped) {	vmStateMap.remove(vmName);	} else if (oldState == State.Migrating) {	} else {	State state = State.Stopping;	
vm is now missing from server so removing it 

public Map<String, HostVmStateReportEntry> hostVmStateReport() throws Ovm3ResourceException {	final Map<String, HostVmStateReportEntry> vmStates = new HashMap<String, HostVmStateReportEntry>();	for (final Map.Entry<String, State> vm : vmStateMap.entrySet()) {	
vm state 

public CheckHealthAnswer execute(CheckHealthCommand cmd) {	Common test = new Common(c);	String ping = "put";	String pong;	try {	pong = test.echo(ping);	} catch (Ovm3ResourceException e) {	
checkhealth went wrong 

String ping = "put";	String pong;	try {	pong = test.echo(ping);	} catch (Ovm3ResourceException e) {	return new CheckHealthAnswer(cmd, false);	}	if (ping.contentEquals(pong)) {	return new CheckHealthAnswer(cmd, true);	}	
checkhealth did not receive but got from 

public boolean masterCheck() {	if ("".equals(config.getOvm3PoolVip())) {	
no cluster vip not checking for master 

public boolean masterCheck() {	if ("".equals(config.getOvm3PoolVip())) {	return false;	}	try {	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (cSp.dom0HasIp(config.getOvm3PoolVip())) {	
is a master already has vip 

public boolean masterCheck() {	if ("".equals(config.getOvm3PoolVip())) {	return false;	}	try {	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (cSp.dom0HasIp(config.getOvm3PoolVip())) {	config.setAgentIsMaster(true);	} else if (cSp.ping(config.getOvm3PoolVip())) {	
has a master someone has vip 

if ("".equals(config.getOvm3PoolVip())) {	return false;	}	try {	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (cSp.dom0HasIp(config.getOvm3PoolVip())) {	config.setAgentIsMaster(true);	} else if (cSp.ping(config.getOvm3PoolVip())) {	config.setAgentHasMaster(true);	} else {	
becomes a master no one has vip 

try {	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (cSp.dom0HasIp(config.getOvm3PoolVip())) {	config.setAgentIsMaster(true);	} else if (cSp.ping(config.getOvm3PoolVip())) {	config.setAgentHasMaster(true);	} else {	config.setAgentIsMaster(true);	}	} catch (Ovm3ResourceException e) {	
can t reach master 

public ReadyAnswer execute(ReadyCommand cmd) {	try {	Linux host = new Linux(c);	Pool pool = new Pool(c);	if (!host.getIsMaster() && config.getAgentInOvm3Cluster()) {	if (pool.getPoolMasterVip().equalsIgnoreCase(c.getIp())) {	return new ReadyAnswer(cmd);	} else {	
master ip changes to it should be 

try {	Linux host = new Linux(c);	Pool pool = new Pool(c);	if (!host.getIsMaster() && config.getAgentInOvm3Cluster()) {	if (pool.getPoolMasterVip().equalsIgnoreCase(c.getIp())) {	return new ReadyAnswer(cmd);	} else {	return new ReadyAnswer(cmd, "I am not the master server");	}	} else if (host.getIsMaster()) {	
master not clustered 

Pool pool = new Pool(c);	if (!host.getIsMaster() && config.getAgentInOvm3Cluster()) {	if (pool.getPoolMasterVip().equalsIgnoreCase(c.getIp())) {	return new ReadyAnswer(cmd);	} else {	return new ReadyAnswer(cmd, "I am not the master server");	}	} else if (host.getIsMaster()) {	return new ReadyAnswer(cmd);	} else {	
no master not clustered 

return new ReadyAnswer(cmd);	} else {	return new ReadyAnswer(cmd, "I am not the master server");	}	} else if (host.getIsMaster()) {	return new ReadyAnswer(cmd);	} else {	return new ReadyAnswer(cmd);	}	} catch (CloudRuntimeException | Ovm3ResourceException e) {	
xml rpc exception 

public CheckVirtualMachineAnswer execute( final CheckVirtualMachineCommand cmd) {	
checkvirtualmachinecommand 

public CheckVirtualMachineAnswer execute( final CheckVirtualMachineCommand cmd) {	String vmName = cmd.getVmName();	try {	CloudstackPlugin plug = new CloudstackPlugin(c);	Integer vncPort = Integer.valueOf(plug.getVncPort(vmName));	if (vncPort == 0) {	
no vnc port for 

public CheckVirtualMachineAnswer execute( final CheckVirtualMachineCommand cmd) {	String vmName = cmd.getVmName();	try {	CloudstackPlugin plug = new CloudstackPlugin(c);	Integer vncPort = Integer.valueOf(plug.getVncPort(vmName));	if (vncPort == 0) {	}	Map<String, State> states = getAllVmStates(vmStateMap);	State vmState = states.get(vmName);	if (vmState == null) {	
check state of return null in checkvirtualmachinecommand 

Map<String, State> states = getAllVmStates(vmStateMap);	State vmState = states.get(vmName);	if (vmState == null) {	vmState = State.Stopped;	}	synchronized (vmStateMap) {	vmStateMap.put(vmName, State.Running);	}	return new CheckVirtualMachineAnswer(cmd, convertStateToPower(vmState), vncPort);	} catch (Ovm3ResourceException e) {	
check migration for failed 

public MaintainAnswer execute(MaintainCommand cmd) {	
MaintainCommand 

CloudstackPlugin cSp = new CloudstackPlugin(c);	Map<String, String> stats = cSp.ovsDom0Stats(config .getAgentPublicNetworkName());	Double cpuUtil = Double.parseDouble(stats.get("cpu"));	Double rxBytes = Double.parseDouble(stats.get("rx"));	Double txBytes = Double.parseDouble(stats.get("tx"));	Double totalMemory = Double.parseDouble(stats.get("total"));	Double freeMemory = Double.parseDouble(stats.get("free"));	HostStatsEntry hostStats = new HostStatsEntry(cmd.getHostId(), cpuUtil, rxBytes, txBytes, "host", totalMemory, freeMemory, 0, 0);	return new GetHostStatsAnswer(cmd, hostStats);	} catch (Exception e) {	
unable to get host stats for 

public FenceAnswer execute(FenceCommand cmd) {	
FenceCommand 

public FenceAnswer execute(FenceCommand cmd) {	try {	Boolean res = false;	return new FenceAnswer(cmd, res, res.toString());	} catch (Exception e) {	
unable to fence 

public CheckOnHostAnswer execute(CheckOnHostCommand cmd) {	
CheckOnHostCommand 

========================= cloudstack sample_844 =========================

public void delete(ModelController controller) throws IOException {	ApiConnector api = controller.getApiAccessor();	for (ModelObject successor : successors()) {	successor.delete(controller);	}	try {	api.delete(FloatingIp.class, _uuid);	} catch (IOException ex) {	
floating ip delete 

fip.setAddress(_addr);	fip.setName(_name);	fip.setParent(_fipPoolModel.getFloatingIpPool());	}	}	IPAddressVO ipAddrVO = controller.getIPAddressDao().findById(_id);	assert ipAddrVO != null : "can not find address object in db";	Long vmId = ipAddrVO.getAssociatedWithVmId();	Long networkId = ipAddrVO.getAssociatedWithNetworkId();	if (vmId == null || networkId == null) {	
floating ip is not yet associated to either vm or network 

assert vm != null : "can not find vm in db";	VirtualMachineModel vmModel = manager.getDatabase().lookupVirtualMachine(vm.getUuid());	assert vmModel != null : "can not find vm model";	VMInterfaceModel vmiModel = vmModel.getVMInterface(nic.getUuid());	assert vmiModel != null && vmiModel.getVMInterface() != null : "can not find virtual machine interface";	fip.setVirtualMachineInterface(vmiModel.getVMInterface());	if (_fip == null) {	try {	api.create(fip);	} catch (Exception ex) {	
floating ip create 

try {	api.create(fip);	} catch (Exception ex) {	throw new CloudRuntimeException("Failed to create floating ip", ex);	}	_fip = fip;	} else {	try {	api.update(fip);	} catch (IOException ex) {	
floating ip update 

========================= cloudstack sample_1889 =========================

private String getRestartPriorityForVM(VirtualMachineMO vmMo) throws Exception {	if (vmMo == null) {	
failed to get restart priority for vm invalid vm object reference 

private String getRestartPriorityForVM(VirtualMachineMO vmMo) throws Exception {	if (vmMo == null) {	return null;	}	ManagedObjectReference vmMor = vmMo.getMor();	if (vmMor == null || !vmMor.getType().equals("VirtualMachine")) {	
failed to get restart priority for vm invalid vm object reference 

private String getRestartPriorityForVM(VirtualMachineMO vmMo) throws Exception {	if (vmMo == null) {	return null;	}	ManagedObjectReference vmMor = vmMo.getMor();	if (vmMor == null || !vmMor.getType().equals("VirtualMachine")) {	return null;	}	ClusterConfigInfoEx configInfo = getClusterConfigInfo();	if (configInfo == null) {	
failed to get restart priority for vm no cluster config information 

ClusterDasVmConfigInfo dasVmConfigInfo = dasVmConfig.get(dasVmConfigIndex);	if (dasVmConfigInfo != null && dasVmConfigInfo.getKey().getValue().equals(vmMor.getValue())) {	DasVmPriority dasVmPriority = dasVmConfigInfo.getRestartPriority();	if (dasVmPriority != null) {	return dasVmPriority.value();	} else {	return ClusterDasVmSettingsRestartPriority.CLUSTER_RESTART_PRIORITY.value();	}	}	}	
vm uses default restart priority in the cluster 

public void setRestartPriorityForVM(VirtualMachineMO vmMo, String priority) throws Exception {	if (vmMo == null || StringUtils.isBlank(priority)) {	return;	}	if (!isHAEnabled()) {	
couldn t set restart priority for vm ha disabled in the cluster 

public void setRestartPriorityForVM(VirtualMachineMO vmMo, String priority) throws Exception {	if (vmMo == null || StringUtils.isBlank(priority)) {	return;	}	if (!isHAEnabled()) {	return;	}	ManagedObjectReference vmMor = vmMo.getMor();	if (vmMor == null || !vmMor.getType().equals("VirtualMachine")) {	
failed to set restart priority for vm invalid vm object reference 

clusterDasVmConfigSpec.setOperation((StringUtils.isNotBlank(currentVmRestartPriority)) ? ArrayUpdateOperation.EDIT : ArrayUpdateOperation.ADD);	clusterDasVmConfigSpec.setInfo(clusterDasVmConfigInfo);	ClusterConfigSpecEx clusterConfigSpecEx = new ClusterConfigSpecEx();	ClusterDasConfigInfo clusterDasConfigInfo = new ClusterDasConfigInfo();	clusterConfigSpecEx.setDasConfig(clusterDasConfigInfo);	clusterConfigSpecEx.getDasVmConfigSpec().add(clusterDasVmConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigureComputeResourceTask(_mor, clusterConfigSpecEx, true);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	
vcenter api trace setrestartpriority done successfully 

clusterDasVmConfigSpec.setInfo(clusterDasVmConfigInfo);	ClusterConfigSpecEx clusterConfigSpecEx = new ClusterConfigSpecEx();	ClusterDasConfigInfo clusterDasConfigInfo = new ClusterDasConfigInfo();	clusterConfigSpecEx.setDasConfig(clusterDasConfigInfo);	clusterConfigSpecEx.getDasVmConfigSpec().add(clusterDasVmConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigureComputeResourceTask(_mor, clusterConfigSpecEx, true);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	} else {	
vcenter api trace setrestartpriority done failed 

clusterDasVmConfigSpec.setInfo(clusterDasVmConfigInfo);	ClusterConfigSpecEx clusterConfigSpecEx = new ClusterConfigSpecEx();	ClusterDasConfigInfo clusterDasConfigInfo = new ClusterDasConfigInfo();	clusterConfigSpecEx.setDasConfig(clusterDasConfigInfo);	clusterConfigSpecEx.getDasVmConfigSpec().add(clusterDasVmConfigSpec);	ManagedObjectReference morTask = _context.getService().reconfigureComputeResourceTask(_mor, clusterConfigSpecEx, true);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	} else {	
set restart priority failed for vm due to 

public VirtualMachineMO findVmOnHyperHost(String name) throws Exception {	int key = getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

public VirtualMachineMO findVmOnPeerHyperHost(String name) throws Exception {	int key = getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

public ObjectContent[] getVmPropertiesOnHyperHost(String[] propertyPaths) throws Exception {	
vcenter api trace retrieveproperties for vm properties target mor properties 

ObjectSpec oSpec = new ObjectSpec();	oSpec.setObj(getMor());	oSpec.setSkip(Boolean.TRUE);	oSpec.getSelectSet().add(cluster2HostFolderTraversal);	PropertyFilterSpec pfSpec = new PropertyFilterSpec();	pfSpec.getPropSet().add(pSpec);	pfSpec.getObjectSet().add(oSpec);	List<PropertyFilterSpec> pfSpecArr = new ArrayList<PropertyFilterSpec>();	pfSpecArr.add(pfSpec);	List<ObjectContent> properties = _context.getService().retrieveProperties(_context.getPropertyCollector(), pfSpecArr);	
vcenter api trace retrieveproperties done 

public ObjectContent[] getDatastorePropertiesOnHyperHost(String[] propertyPaths) throws Exception {	
vcenter api trace retrieveproperties on datastore properties target mor properties 

ObjectSpec oSpec = new ObjectSpec();	oSpec.setObj(_mor);	oSpec.setSkip(Boolean.TRUE);	oSpec.getSelectSet().add(cluster2DatastoreTraversal);	PropertyFilterSpec pfSpec = new PropertyFilterSpec();	pfSpec.getPropSet().add(pSpec);	pfSpec.getObjectSet().add(oSpec);	List<PropertyFilterSpec> pfSpecArr = new ArrayList<PropertyFilterSpec>();	pfSpecArr.add(pfSpec);	List<ObjectContent> properties = _context.getService().retrieveProperties(_context.getPropertyCollector(), pfSpecArr);	
vcenter api trace retrieveproperties done 

public ObjectContent[] getHostPropertiesOnCluster(String[] propertyPaths) throws Exception {	
vcenter api trace retrieveproperties on host properties target mor properties 

ObjectSpec oSpec = new ObjectSpec();	oSpec.setObj(_mor);	oSpec.setSkip(Boolean.TRUE);	oSpec.getSelectSet().add(cluster2HostTraversal);	PropertyFilterSpec pfSpec = new PropertyFilterSpec();	pfSpec.getPropSet().add(pSpec);	pfSpec.getObjectSet().add(oSpec);	List<PropertyFilterSpec> pfSpecArr = new ArrayList<PropertyFilterSpec>();	pfSpecArr.add(pfSpec);	List<ObjectContent> properties = _context.getService().retrieveProperties(_context.getPropertyCollector(), pfSpecArr);	
vcenter api trace retrieveproperties done 

public boolean createVm(VirtualMachineConfigSpec vmSpec) throws Exception {	
vcenter api trace createvm task target mor virtualmachineconfigspec 

public boolean createVm(VirtualMachineConfigSpec vmSpec) throws Exception {	assert (vmSpec != null);	DatacenterMO dcMo = new DatacenterMO(_context, getHyperHostDatacenter());	ManagedObjectReference morPool = getHyperHostOwnerResourcePool();	ManagedObjectReference morTask = _context.getService().createVMTask(dcMo.getVmFolder(), vmSpec, morPool, null);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	
vcenter api trace createvm task done successfully 

public boolean createVm(VirtualMachineConfigSpec vmSpec) throws Exception {	assert (vmSpec != null);	DatacenterMO dcMo = new DatacenterMO(_context, getHyperHostDatacenter());	ManagedObjectReference morPool = getHyperHostOwnerResourcePool();	ManagedObjectReference morTask = _context.getService().createVMTask(dcMo.getVmFolder(), vmSpec, morPool, null);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware createvm task failed due to 

assert (vmSpec != null);	DatacenterMO dcMo = new DatacenterMO(_context, getHyperHostDatacenter());	ManagedObjectReference morPool = getHyperHostOwnerResourcePool();	ManagedObjectReference morTask = _context.getService().createVMTask(dcMo.getVmFolder(), vmSpec, morPool, null);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	}	
vcenter api trace createvm task done failed 

public void importVmFromOVF(String ovfFilePath, String vmName, DatastoreMO dsMo, String diskOption) throws Exception {	
vcenter api trace importvmfromovf target mor ovffilepath vmname datastore diskoption 

public void importVmFromOVF(String ovfFilePath, String vmName, DatastoreMO dsMo, String diskOption) throws Exception {	ManagedObjectReference morRp = getHyperHostOwnerResourcePool();	assert (morRp != null);	
vcenter api trace importvmfromovf resource pool 

public void importVmFromOVF(String ovfFilePath, String vmName, DatastoreMO dsMo, String diskOption) throws Exception {	ManagedObjectReference morRp = getHyperHostOwnerResourcePool();	assert (morRp != null);	HypervisorHostHelper.importVmFromOVF(this, ovfFilePath, vmName, dsMo, diskOption, morRp, null);	
vcenter api trace importvmfromovf done 

public boolean createBlankVm(String vmName, String vmInternalCSName, int cpuCount, int cpuSpeedMHz, int cpuReservedMHz, boolean limitCpuUse, int memoryMB, int memoryReserveMB, String guestOsIdentifier, ManagedObjectReference morDs, boolean snapshotDirToParent, Pair<String, String> controllerInfo, Boolean systemVm) throws Exception {	
vcenter api trace createblankvm target mor vmname cpucount cpuspeedmhz cpureservedmhz limitcpu memorymb guestos datastore snapshotdirtoparent 

public boolean createBlankVm(String vmName, String vmInternalCSName, int cpuCount, int cpuSpeedMHz, int cpuReservedMHz, boolean limitCpuUse, int memoryMB, int memoryReserveMB, String guestOsIdentifier, ManagedObjectReference morDs, boolean snapshotDirToParent, Pair<String, String> controllerInfo, Boolean systemVm) throws Exception {	boolean result = HypervisorHostHelper.createBlankVm(this, vmName, vmInternalCSName, cpuCount, cpuSpeedMHz, cpuReservedMHz, limitCpuUse, memoryMB, memoryReserveMB, guestOsIdentifier, morDs, snapshotDirToParent, controllerInfo, systemVm);	
vcenter api trace createblankvm done 

public ManagedObjectReference mountDatastore(boolean vmfsDatastore, String poolHostAddress, int poolHostPort, String poolPath, String poolUuid) throws Exception {	
vcenter api trace mountdatastore target mor vmfs poolhost poolhostport poolpath pooluuid 

for (ManagedObjectReference morHost : hosts) {	HostMO hostMo = new HostMO(_context, morHost);	morDs = hostMo.mountDatastore(vmfsDatastore, poolHostAddress, poolHostPort, poolPath, poolUuid);	if (morDsFirst == null) morDsFirst = morDs;	assert (morDsFirst.getValue().equals(morDs.getValue()));	}	}	if (morDs == null) {	String msg = "Failed to mount datastore in all hosts within the cluster";	s_logger.error(msg);	
vcenter api trace mountdatastore done failed 

morDs = hostMo.mountDatastore(vmfsDatastore, poolHostAddress, poolHostPort, poolPath, poolUuid);	if (morDsFirst == null) morDsFirst = morDs;	assert (morDsFirst.getValue().equals(morDs.getValue()));	}	}	if (morDs == null) {	String msg = "Failed to mount datastore in all hosts within the cluster";	s_logger.error(msg);	throw new Exception(msg);	}	
vcenter api trace mountdatastore done successfully 

public void unmountDatastore(String poolUuid) throws Exception {	
vcenter api trace unmountdatastore target mor pooluuid 

public void unmountDatastore(String poolUuid) throws Exception {	List<ManagedObjectReference> hosts = _context.getVimClient().getDynamicProperty(_mor, "host");	if (hosts != null && hosts.size() > 0) {	for (ManagedObjectReference morHost : hosts) {	HostMO hostMo = new HostMO(_context, morHost);	hostMo.unmountDatastore(poolUuid);	}	}	
vcenter api trace unmountdatastore done 

public ManagedObjectReference findDatastore(String poolUuid) throws Exception {	
vcenter api trace finddatastore target mor pooluuid 

ObjectContent[] ocs = getDatastorePropertiesOnHyperHost(new String[] {"name", String.format("value[%d]", key)});	if (ocs != null) {	for (ObjectContent oc : ocs) {	if (oc.getPropSet().get(0).getVal().equals(poolUuid)) return oc.getObj();	if (oc.getPropSet().size() > 1) {	DynamicProperty prop = oc.getPropSet().get(1);	if (prop != null && prop.getVal() != null) {	if (prop.getVal() instanceof CustomFieldStringValue) {	String val = ((CustomFieldStringValue)prop.getVal()).getValue();	if (val.equalsIgnoreCase(poolUuid)) {	
vcenter api trace finddatastore done successfully 

if (prop.getVal() instanceof CustomFieldStringValue) {	String val = ((CustomFieldStringValue)prop.getVal()).getValue();	if (val.equalsIgnoreCase(poolUuid)) {	return oc.getObj();	}	}	}	}	}	}	
vcenter api trace finddatastore done failed 

public ManagedObjectReference findDatastoreByExportPath(String exportPath) throws Exception {	
vcenter api trace finddatastorebyexportpath target mor exportpath 

if (ocs != null && ocs.length > 0) {	for (ObjectContent oc : ocs) {	DatastoreInfo dsInfo = (DatastoreInfo)oc.getPropSet().get(0).getVal();	if (dsInfo != null && dsInfo instanceof NasDatastoreInfo) {	NasDatastoreInfo info = (NasDatastoreInfo)dsInfo;	if (info != null) {	String vmwareUrl = info.getUrl();	if (vmwareUrl.charAt(vmwareUrl.length() - 1) == '/') vmwareUrl = vmwareUrl.substring(0, vmwareUrl.length() - 1);	URI uri = new URI(vmwareUrl);	if (uri.getPath().equals("/" + exportPath)) {	
vcenter api trace finddatastorebyexportpath done successfully 

String vmwareUrl = info.getUrl();	if (vmwareUrl.charAt(vmwareUrl.length() - 1) == '/') vmwareUrl = vmwareUrl.substring(0, vmwareUrl.length() - 1);	URI uri = new URI(vmwareUrl);	if (uri.getPath().equals("/" + exportPath)) {	return oc.getObj();	}	}	}	}	}	
vcenter api trace finddatastorebyexportpath done failed 

public ManagedObjectReference findMigrationTarget(VirtualMachineMO vmMo) throws Exception {	
vcenter api trace findmigrationtarget target mor vm 

public ManagedObjectReference findMigrationTarget(VirtualMachineMO vmMo) throws Exception {	List<ClusterHostRecommendation> candidates = recommendHostsForVm(vmMo);	if (candidates != null && candidates.size() > 0) {	
vcenter api trace findmigrationtarget done successfully 

public ManagedObjectReference findMigrationTarget(VirtualMachineMO vmMo) throws Exception {	List<ClusterHostRecommendation> candidates = recommendHostsForVm(vmMo);	if (candidates != null && candidates.size() > 0) {	return candidates.get(0).getHost();	}	
vcenter api trace findmigrationtarget done failed 

public VmwareHypervisorHostResourceSummary getHyperHostResourceSummary() throws Exception {	
vcenter api trace gethyperhostresourcesummary target mor 

if (hosts != null && hosts.size() > 0) {	for (ManagedObjectReference morHost : hosts) {	HostMO hostMo = new HostMO(_context, morHost);	HostHardwareSummary hardwareSummary = hostMo.getHostHardwareSummary();	if (hardwareSummary.getNumCpuCores() * hardwareSummary.getNumCpuThreads() > cpuNumInCpuThreads) cpuNumInCpuThreads = hardwareSummary.getNumCpuCores() * hardwareSummary.getNumCpuThreads();	}	}	summary.setCpuCount(cpuNumInCpuThreads);	summary.setCpuSpeed(vmwareSummary.getTotalCpu());	summary.setMemoryBytes(vmwareSummary.getTotalMemory());	
vcenter api trace gethyperhostresourcesummary done 

public VmwareHypervisorHostNetworkSummary getHyperHostNetworkSummary(String esxServiceConsolePort) throws Exception {	
vcenter api trace gethyperhostnetworksummary target mor mgmtportgroup 

public VmwareHypervisorHostNetworkSummary getHyperHostNetworkSummary(String esxServiceConsolePort) throws Exception {	List<ManagedObjectReference> hosts = _context.getVimClient().getDynamicProperty(_mor, "host");	if (hosts != null && hosts.size() > 0) {	VmwareHypervisorHostNetworkSummary summary = new HostMO(_context, hosts.get(0)).getHyperHostNetworkSummary(esxServiceConsolePort);	
vcenter api trace gethyperhostresourcesummary done successfully 

public VmwareHypervisorHostNetworkSummary getHyperHostNetworkSummary(String esxServiceConsolePort) throws Exception {	List<ManagedObjectReference> hosts = _context.getVimClient().getDynamicProperty(_mor, "host");	if (hosts != null && hosts.size() > 0) {	VmwareHypervisorHostNetworkSummary summary = new HostMO(_context, hosts.get(0)).getHyperHostNetworkSummary(esxServiceConsolePort);	return summary;	}	
vcenter api trace gethyperhostresourcesummary done failed 

public ComputeResourceSummary getHyperHostHardwareSummary() throws Exception {	
vcenter api trace gethyperhosthardwaresummary target mor 

public ComputeResourceSummary getHyperHostHardwareSummary() throws Exception {	ClusterComputeResourceSummary hardwareSummary = (ClusterComputeResourceSummary)_context.getVimClient().getDynamicProperty(_mor, "summary");	
vcenter api trace gethyperhosthardwaresummary done 

String diskController = null;	List<GuestOsDescriptor> guestDescriptors = vmConfigOption.getGuestOSDescriptor();	for (GuestOsDescriptor descriptor : guestDescriptors) {	if (guestOsId != null && guestOsId.equalsIgnoreCase(descriptor.getId())) {	guestOsDescriptor = descriptor;	break;	}	}	if (guestOsDescriptor != null) {	diskController = VmwareHelper.getRecommendedDiskControllerFromDescriptor(guestOsDescriptor);	
retrieved recommended disk controller for guest os in cluster 

========================= cloudstack sample_2088 =========================

currentReadBytes = stderr.read(buffer);	sbResult.append(new String(buffer, 0, currentReadBytes));	}	}	String result = sbResult.toString();	if (StringUtils.isBlank(result)) {	try {	result = IOUtils.toString(stdout, StandardCharsets.UTF_8);	}	catch (IOException e) {	
couldn t get content of input stream due to 

String result = sbResult.toString();	if (StringUtils.isBlank(result)) {	try {	result = IOUtils.toString(stdout, StandardCharsets.UTF_8);	}	catch (IOException e) {	return new Pair<Boolean, String>(false, result);	}	}	if (sess.getExitStatus() == null) {	
ssh execution of command s has no exit status set result output s 

result = IOUtils.toString(stdout, StandardCharsets.UTF_8);	}	catch (IOException e) {	return new Pair<Boolean, String>(false, result);	}	}	if (sess.getExitStatus() == null) {	return new Pair<Boolean, String>(false, result);	}	if (sess.getExitStatus() != null && sess.getExitStatus().intValue() != 0) {	
ssh execution of command s has an error status code in return result output s 

========================= cloudstack sample_2821 =========================

if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if (answer == null || !answer.getResult()) {	String errMsg = answer == null ? null : answer.getDetails();	if (errMsg != null) {	
failed to forget object 

========================= cloudstack sample_4019 =========================

dvPortGroupList = new ArrayList<String>();	}	dvPortGroupList.add(dvPortGroupName);	} else {	dvPortGroupList = new ArrayList<String>();	dvPortGroupList.add(dvPortGroupName);	s_dvPortGroupCacheMap.put(dvSwitchInstance, dvPortGroupList);	}	}	if (s_logger.isTraceEnabled()) {	
created dvportgroup dvportgroup cache is 

dvPortGroupList.add(dvPortGroupName);	} else {	dvPortGroupList = new ArrayList<String>();	dvPortGroupList.add(dvPortGroupName);	s_dvPortGroupCacheMap.put(dvSwitchInstance, dvPortGroupList);	}	}	if (s_logger.isTraceEnabled()) {	}	} else if (s_logger.isDebugEnabled()) {	
detected dvportgroup already present not attempting to create again 

========================= cloudstack sample_2067 =========================

public long download(boolean resume, DownloadCompleteCallback callback) {	if (!status.equals(Status.NOT_STARTED)) {	
template download is already started not starting again template 

}	InputStream inputStream;	try {	inputStream = new BufferedInputStream(getMethod.getResponseBodyAsStream());	} catch (IOException e) {	errorString = "Exception occurred while opening InputStream for template " + downloadUrl;	LOGGER.warn(errorString);	status = Status.UNRECOVERABLE_ERROR;	return 0;	}	
starting download from to bucket and size bytes 

objectMetadata.setContentType(contentTypeHeader.getValue());	}	PutObjectRequest putObjectRequest = new PutObjectRequest(s3TO.getBucketName(), s3Key, inputStream, objectMetadata);	if (s3TO.getEnableRRS()) {	putObjectRequest.withStorageClass(StorageClass.ReducedRedundancy);	}	Upload upload = S3Utils.putObject(s3TO, putObjectRequest);	upload.addProgressListener(new ProgressListener() {	public void progressChanged(ProgressEvent progressEvent) {	totalBytes += progressEvent.getBytesTransferred();	
template download from to bucket transferred in seconds 

} else if (progressEvent.getEventType() == ProgressEventType.TRANSFER_CANCELED_EVENT) {	status = Status.ABORTED;	} else if (progressEvent.getEventType() == ProgressEventType.TRANSFER_FAILED_EVENT) {	status = Status.UNRECOVERABLE_ERROR;	}	}	});	try {	upload.waitForCompletion();	} catch (InterruptedException e) {	
interruption occurred while waiting for upload of to complete 

status = Status.UNRECOVERABLE_ERROR;	}	}	});	try {	upload.waitForCompletion();	} catch (InterruptedException e) {	}	downloadTime = new Date().getTime() - start.getTime();	if (status == Status.DOWNLOAD_FINISHED) {	
template download from to bucket transferred in seconds completed successfully 

}	}	});	try {	upload.waitForCompletion();	} catch (InterruptedException e) {	}	downloadTime = new Date().getTime() - start.getTime();	if (status == Status.DOWNLOAD_FINISHED) {	} else {	
template download from to bucket transferred in seconds completed with status 

public void cleanupAfterError() {	
cleanup after error trying to remove object 

========================= cloudstack sample_405 =========================

public static Connection getConnectionForGlobalLocks(String name, boolean forLock) {	synchronized (s_connectionForGlobalLocks) {	if (forLock) {	if (s_connectionForGlobalLocks.get(name) != null) {	
sanity check failed global lock name is already in use 

public static boolean getGlobalLock(String name, int timeoutSeconds) {	Connection conn = getConnectionForGlobalLocks(name, true);	if (conn == null) {	
unable to acquire db connection for global lock system 

return false;	}	try (PreparedStatement pstmt = conn.prepareStatement("SELECT COALESCE(GET_LOCK(?, ?),0)");) {	pstmt.setString(1, name);	pstmt.setInt(2, timeoutSeconds);	try (ResultSet rs = pstmt.executeQuery();) {	if (rs != null && rs.first()) {	if (rs.getInt(1) > 0) {	return true;	} else {	
get lock timed out on lock 

pstmt.setInt(2, timeoutSeconds);	try (ResultSet rs = pstmt.executeQuery();) {	if (rs != null && rs.first()) {	if (rs.getInt(1) > 0) {	return true;	} else {	}	}	}	} catch (SQLException e) {	
get lock throws exception 

try (ResultSet rs = pstmt.executeQuery();) {	if (rs != null && rs.first()) {	if (rs.getInt(1) > 0) {	return true;	} else {	}	}	}	} catch (SQLException e) {	} catch (Throwable e) {	
get lock throws exception 

public static boolean releaseGlobalLock(String name) {	try (Connection conn = getConnectionForGlobalLocks(name, false);) {	if (conn == null) {	
unable to acquire db connection for global lock system 

if (conn == null) {	assert (false);	return false;	}	try (PreparedStatement pstmt = conn.prepareStatement("SELECT COALESCE(RELEASE_LOCK(?), 0)");) {	pstmt.setString(1, name);	try (ResultSet rs = pstmt.executeQuery();) {	if (rs != null && rs.first()) {	return rs.getInt(1) > 0;	}	
releasegloballock release lock returns unexpected result 

}	try (PreparedStatement pstmt = conn.prepareStatement("SELECT COALESCE(RELEASE_LOCK(?), 0)");) {	pstmt.setString(1, name);	try (ResultSet rs = pstmt.executeQuery();) {	if (rs != null && rs.first()) {	return rs.getInt(1) > 0;	}	}	}	} catch (SQLException e) {	
release lock throws exception 

try (PreparedStatement pstmt = conn.prepareStatement("SELECT COALESCE(RELEASE_LOCK(?), 0)");) {	pstmt.setString(1, name);	try (ResultSet rs = pstmt.executeQuery();) {	if (rs != null && rs.first()) {	return rs.getInt(1) > 0;	}	}	}	} catch (SQLException e) {	} catch (Throwable e) {	
release lock throws exception 

========================= cloudstack sample_540 =========================

public Answer execute(final OvsCreateTunnelCommand command, final LibvirtComputingResource libvirtComputingResource) {	final String bridge = command.getNetworkName();	try {	if (!libvirtComputingResource.findOrCreateTunnelNetwork(bridge)) {	
error during bridge setup 

scriptCommand.add("--key", command.getKey().toString());	scriptCommand.add("--src_host", command.getFrom().toString());	scriptCommand.add("--dst_host", command.getTo().toString());	final String result = scriptCommand.execute();	if (result != null) {	return new OvsCreateTunnelAnswer(command, true, result, null, bridge);	} else {	return new OvsCreateTunnelAnswer(command, false, result, bridge);	}	} catch (final Exception e) {	
caught execption when creating ovs tunnel 

========================= cloudstack sample_1077 =========================

for (final Map.Entry<Long, ClusterServiceRequestPdu> entry : _outgoingPdusWaitingForAck.entrySet()) {	if (entry.getValue().getDestPeer().equalsIgnoreCase(strPeer)) {	candidates.add(entry.getValue());	}	}	for (final ClusterServiceRequestPdu pdu : candidates) {	_outgoingPdusWaitingForAck.remove(pdu.getSequenceId());	}	}	for (final ClusterServiceRequestPdu pdu : candidates) {	
cancel cluster request pdu to peer pdu 

try {	final ClusterServicePdu pdu = popOutgoingClusterPdu(1000);	if (pdu == null) {	continue;	}	ClusterService peerService = null;	for (int i = 0; i < 2; i++) {	try {	peerService = getPeerService(pdu.getDestPeer());	} catch (final RemoteException e) {	
unable to get cluster service on peer 

}	ClusterService peerService = null;	for (int i = 0; i < 2; i++) {	try {	peerService = getPeerService(pdu.getDestPeer());	} catch (final RemoteException e) {	}	if (peerService != null) {	try {	if (s_logger.isDebugEnabled()) {	
cluster pdu agent pdu seq pdu ack seq json 

}	if (peerService != null) {	try {	if (s_logger.isDebugEnabled()) {	}	final Profiler profiler = new Profiler();	profiler.start();	final String strResult = peerService.execute(pdu);	profiler.stop();	if (s_logger.isDebugEnabled()) {	
cluster pdu completed time ms agent pdu seq pdu ack seq json 

final String strResult = peerService.execute(pdu);	profiler.stop();	if (s_logger.isDebugEnabled()) {	}	if ("true".equals(strResult)) {	break;	}	} catch (final RemoteException e) {	invalidatePeerService(pdu.getDestPeer());	if (s_logger.isInfoEnabled()) {	
exception on remote execution peer iteration exception message 

break;	}	} catch (final RemoteException e) {	invalidatePeerService(pdu.getDestPeer());	if (s_logger.isInfoEnabled()) {	}	}	}	}	} catch (final Throwable e) {	
unexcpeted exception 

_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	if (pdu.getPduType() == ClusterServicePdu.PDU_TYPE_RESPONSE) {	final ClusterServiceRequestPdu requestPdu = popRequestPdu(pdu.getAckSequenceId());	if (requestPdu != null) {	requestPdu.setResponseResult(pdu.getJsonPackage());	synchronized (requestPdu) {	requestPdu.notifyAll();	}	} else {	
original request has already been cancelled pdu 

responsePdu.setSourcePeer(pdu.getDestPeer());	responsePdu.setDestPeer(pdu.getSourcePeer());	responsePdu.setAckSequenceId(pdu.getSequenceId());	responsePdu.setJsonPackage(result);	addOutgoingClusterPdu(responsePdu);	}	}	}	});	} catch (final Throwable e) {	
unexcpeted exception 

public void broadcast(final long agentId, final String cmds) {	final Date cutTime = DateUtil.currentGMTTime();	final List<ManagementServerHostVO> peers = _mshostDao.getActiveList(new Date(cutTime.getTime() - HeartbeatThreshold.value()));	for (final ManagementServerHostVO peer : peers) {	final String peerName = Long.toString(peer.getMsid());	if (getSelfPeerName().equals(peerName)) {	continue;	}	try {	if (s_logger.isDebugEnabled()) {	
forwarding to 

for (final ManagementServerHostVO peer : peers) {	final String peerName = Long.toString(peer.getMsid());	if (getSelfPeerName().equals(peerName)) {	continue;	}	try {	if (s_logger.isDebugEnabled()) {	}	executeAsync(peerName, agentId, cmds, true);	} catch (final Exception e) {	
caught exception while talkign to 

pdu.setStopOnError(stopOnError);	registerRequestPdu(pdu);	addOutgoingClusterPdu(pdu);	synchronized (pdu) {	try {	pdu.wait();	} catch (final InterruptedException e) {	}	}	if (s_logger.isDebugEnabled()) {	
completed result 

public void registerListener(final ClusterManagerListener listener) {	synchronized (_listeners) {	
register cluster listener 

public void unregisterListener(final ClusterManagerListener listener) {	synchronized (_listeners) {	
unregister cluster listener 

public void notifyNodeJoined(final List<ManagementServerHostVO> nodeList) {	if (s_logger.isDebugEnabled()) {	
notify management server node join to listeners 

public void notifyNodeJoined(final List<ManagementServerHostVO> nodeList) {	if (s_logger.isDebugEnabled()) {	for (final ManagementServerHostVO mshost : nodeList) {	
joining node ip msid 

public void notifyNodeLeft(final List<ManagementServerHostVO> nodeList) {	if (s_logger.isDebugEnabled()) {	
notify management server node left to listeners 

public void notifyNodeLeft(final List<ManagementServerHostVO> nodeList) {	if (s_logger.isDebugEnabled()) {	}	for (final ManagementServerHostVO mshost : nodeList) {	if (s_logger.isDebugEnabled()) {	
leaving node ip msid 

public void notifyNodeIsolated() {	if (s_logger.isDebugEnabled()) {	
notify management server node isolation to listeners 

final TransactionLegacy txn = TransactionLegacy.open("ClusterHeartbeat");	try {	final Profiler profiler = new Profiler();	final Profiler profilerHeartbeatUpdate = new Profiler();	final Profiler profilerPeerScan = new Profiler();	try {	profiler.start();	profilerHeartbeatUpdate.start();	txn.transitToUserManagedConnection(getHeartbeatConnection());	if (s_logger.isTraceEnabled()) {	
cluster manager heartbeat update id 

try {	profiler.start();	profilerHeartbeatUpdate.start();	txn.transitToUserManagedConnection(getHeartbeatConnection());	if (s_logger.isTraceEnabled()) {	}	_mshostDao.update(_mshostId, _runId, DateUtil.currentGMTTime());	profilerHeartbeatUpdate.stop();	profilerPeerScan.start();	if (s_logger.isTraceEnabled()) {	
cluster manager peer scan id 

if (!_peerScanInited) {	_peerScanInited = true;	initPeerScan();	}	peerScan();	profilerPeerScan.stop();	} finally {	profiler.stop();	if (profiler.getDurationInMillis() >= HeartbeatInterval.value()) {	if (s_logger.isDebugEnabled()) {	
management server heartbeat takes too long to finish profiler profilerheartbeatupdate profilerpeerscan 

peerScan();	profilerPeerScan.stop();	} finally {	profiler.stop();	if (profiler.getDurationInMillis() >= HeartbeatInterval.value()) {	if (s_logger.isDebugEnabled()) {	}	}	}	} catch (final CloudRuntimeException e) {	
runtime db exception 

profilerPeerScan.stop();	} finally {	profiler.stop();	if (profiler.getDurationInMillis() >= HeartbeatInterval.value()) {	if (s_logger.isDebugEnabled()) {	}	}	}	} catch (final CloudRuntimeException e) {	if (e.getCause() instanceof ClusterInvalidSessionException) {	
invalid cluster session found fence it 

} catch (final CloudRuntimeException e) {	if (e.getCause() instanceof ClusterInvalidSessionException) {	queueNotification(new ClusterManagerMessage(ClusterManagerMessage.MessageType.nodeIsolated));	}	if (isRootCauseConnectionRelated(e.getCause())) {	invalidHeartbeatConnection();	}	} catch (final ActiveFencingException e) {	queueNotification(new ClusterManagerMessage(ClusterManagerMessage.MessageType.nodeIsolated));	} catch (final Throwable e) {	
unexpected exception in cluster heartbeat 

private void invalidHeartbeatConnection() {	if (_heartbeatConnection != null) {	final Connection conn = TransactionLegacy.getStandaloneConnection();	if (conn != null) {	_heartbeatConnection.reset(conn);	} else {	
db communication problem detected fence it 

while ((msg = getNextNotificationMessage()) != null) {	try {	switch (msg.getMessageType()) {	case nodeAdded: if (msg.getNodes() != null && msg.getNodes().size() > 0) {	final Profiler profiler = new Profiler();	profiler.start();	notifyNodeJoined(msg.getNodes());	profiler.stop();	if (profiler.getDurationInMillis() > 1000) {	if (s_logger.isDebugEnabled()) {	
notifying management server join event took ms 

switch (msg.getMessageType()) {	case nodeAdded: if (msg.getNodes() != null && msg.getNodes().size() > 0) {	final Profiler profiler = new Profiler();	profiler.start();	notifyNodeJoined(msg.getNodes());	profiler.stop();	if (profiler.getDurationInMillis() > 1000) {	if (s_logger.isDebugEnabled()) {	}	} else {	
notifying management server join event took ms 

}	}	break;	case nodeRemoved: if (msg.getNodes() != null && msg.getNodes().size() > 0) {	final Profiler profiler = new Profiler();	profiler.start();	notifyNodeLeft(msg.getNodes());	profiler.stop();	if (profiler.getDurationInMillis() > 1000) {	if (s_logger.isDebugEnabled()) {	
notifying management server leave event took ms 

break;	case nodeRemoved: if (msg.getNodes() != null && msg.getNodes().size() > 0) {	final Profiler profiler = new Profiler();	profiler.start();	notifyNodeLeft(msg.getNodes());	profiler.stop();	if (profiler.getDurationInMillis() > 1000) {	if (s_logger.isDebugEnabled()) {	}	} else {	
notifying management server leave event took ms 

} else {	}	}	break;	case nodeIsolated: notifyNodeIsolated();	break;	default: assert false;	break;	}	} catch (final Throwable e) {	
unexpected exception during cluster notification 

private void initPeerScan() {	final Date cutTime = DateUtil.currentGMTTime();	final List<ManagementServerHostVO> inactiveList = _mshostDao.getInactiveList(new Date(cutTime.getTime() - HeartbeatThreshold.value()));	final List<Long> orphanList = _mshostDao.listOrphanMsids();	if (orphanList.size() > 0) {	for (final Long orphanMsid : orphanList) {	
add orphan management server msid found in host table to initial clustering notification orphan msid 

private void initPeerScan() {	final Date cutTime = DateUtil.currentGMTTime();	final List<ManagementServerHostVO> inactiveList = _mshostDao.getInactiveList(new Date(cutTime.getTime() - HeartbeatThreshold.value()));	final List<Long> orphanList = _mshostDao.listOrphanMsids();	if (orphanList.size() > 0) {	for (final Long orphanMsid : orphanList) {	inactiveList.add(new ManagementServerHostVO(orphanMsid, 0, "orphan", 0, new Date()));	}	} else {	
we are good no orphan management server msid in host table is found 

final List<ManagementServerHostVO> inactiveList = _mshostDao.getInactiveList(new Date(cutTime.getTime() - HeartbeatThreshold.value()));	final List<Long> orphanList = _mshostDao.listOrphanMsids();	if (orphanList.size() > 0) {	for (final Long orphanMsid : orphanList) {	inactiveList.add(new ManagementServerHostVO(orphanMsid, 0, "orphan", 0, new Date()));	}	} else {	}	if (inactiveList.size() > 0) {	if (s_logger.isInfoEnabled()) {	
found inactive management server node based on timestamp 

final List<Long> orphanList = _mshostDao.listOrphanMsids();	if (orphanList.size() > 0) {	for (final Long orphanMsid : orphanList) {	inactiveList.add(new ManagementServerHostVO(orphanMsid, 0, "orphan", 0, new Date()));	}	} else {	}	if (inactiveList.size() > 0) {	if (s_logger.isInfoEnabled()) {	for (final ManagementServerHostVO host : inactiveList) {	
management server node msid name service ip version 

} else {	}	if (inactiveList.size() > 0) {	if (s_logger.isInfoEnabled()) {	for (final ManagementServerHostVO host : inactiveList) {	}	}	final List<ManagementServerHostVO> downHostList = new ArrayList<ManagementServerHostVO>();	for (final ManagementServerHostVO host : inactiveList) {	if (!pingManagementNode(host)) {	
management node is detected inactive by timestamp and also not pingable 

final List<ManagementServerHostVO> downHostList = new ArrayList<ManagementServerHostVO>();	for (final ManagementServerHostVO host : inactiveList) {	if (!pingManagementNode(host)) {	downHostList.add(host);	}	}	if (downHostList.size() > 0) {	queueNotification(new ClusterManagerMessage(ClusterManagerMessage.MessageType.nodeRemoved, downHostList));	}	} else {	
no inactive management server node found 

if (_mshostPeerDao.countStateSeenInPeers(_mshostId, _runId, ManagementServerHost.State.Down) > 0) {	final String msg = "We have detected that at least one management server peer reports that this management server is down, perform active fencing to avoid split-brain situation";	s_logger.error(msg);	throw new ActiveFencingException(msg);	}	for (final Map.Entry<Long, ManagementServerHostVO> entry : _activePeers.entrySet()) {	final ManagementServerHostVO current = getInListById(entry.getKey(), currentList);	if (current == null) {	if (entry.getKey().longValue() != _mshostId.longValue()) {	if (s_logger.isDebugEnabled()) {	
detected management node left id nodeip 

if (current == null) {	if (entry.getKey().longValue() != _mshostId.longValue()) {	if (s_logger.isDebugEnabled()) {	}	removedNodeList.add(entry.getValue());	}	} else {	if (current.getRunid() == 0) {	if (entry.getKey().longValue() != _mshostId.longValue()) {	if (s_logger.isDebugEnabled()) {	
detected management node left because of invalidated session id nodeip 

} else {	if (current.getRunid() == 0) {	if (entry.getKey().longValue() != _mshostId.longValue()) {	if (s_logger.isDebugEnabled()) {	}	invalidatedNodeList.add(entry.getValue());	}	} else {	if (entry.getValue().getRunid() != current.getRunid()) {	if (s_logger.isDebugEnabled()) {	
detected management node left and rejoined quickly id nodeip 

}	profilerSyncClusterInfo.stop();	final Profiler profilerInvalidatedNodeList = new Profiler();	profilerInvalidatedNodeList.start();	if (invalidatedNodeList.size() > 0) {	for (final ManagementServerHostVO mshost : invalidatedNodeList) {	_activePeers.remove(mshost.getId());	try {	JmxUtil.unregisterMBean("ClusterManager", "Node " + mshost.getId());	} catch (final Exception e) {	
unable to deregiester cluster node from jmx monitoring due to exception 

}	queueNotification(new ClusterManagerMessage(ClusterManagerMessage.MessageType.nodeRemoved, invalidatedNodeList));	}	profilerInvalidatedNodeList.stop();	final Profiler profilerRemovedList = new Profiler();	profilerRemovedList.start();	final Iterator<ManagementServerHostVO> it = removedNodeList.iterator();	while (it.hasNext()) {	final ManagementServerHostVO mshost = it.next();	if (!pingManagementNode(mshost)) {	
management node is detected inactive by timestamp and also not pingable 

final Profiler profilerRemovedList = new Profiler();	profilerRemovedList.start();	final Iterator<ManagementServerHostVO> it = removedNodeList.iterator();	while (it.hasNext()) {	final ManagementServerHostVO mshost = it.next();	if (!pingManagementNode(mshost)) {	_activePeers.remove(mshost.getId());	try {	JmxUtil.unregisterMBean("ClusterManager", "Node " + mshost.getId());	} catch (final Exception e) {	
unable to deregiester cluster node from jmx monitoring due to exception 

final Iterator<ManagementServerHostVO> it = removedNodeList.iterator();	while (it.hasNext()) {	final ManagementServerHostVO mshost = it.next();	if (!pingManagementNode(mshost)) {	_activePeers.remove(mshost.getId());	try {	JmxUtil.unregisterMBean("ClusterManager", "Node " + mshost.getId());	} catch (final Exception e) {	}	} else {	
management node is detected inactive by timestamp but is pingable 

}	if (removedNodeList.size() > 0) {	queueNotification(new ClusterManagerMessage(ClusterManagerMessage.MessageType.nodeRemoved, removedNodeList));	}	profilerRemovedList.stop();	final List<ManagementServerHostVO> newNodeList = new ArrayList<ManagementServerHostVO>();	for (final ManagementServerHostVO mshost : currentList) {	if (!_activePeers.containsKey(mshost.getId())) {	_activePeers.put(mshost.getId(), mshost);	if (s_logger.isDebugEnabled()) {	
detected management node joined id nodeip 

final List<ManagementServerHostVO> newNodeList = new ArrayList<ManagementServerHostVO>();	for (final ManagementServerHostVO mshost : currentList) {	if (!_activePeers.containsKey(mshost.getId())) {	_activePeers.put(mshost.getId(), mshost);	if (s_logger.isDebugEnabled()) {	}	newNodeList.add(mshost);	try {	JmxUtil.registerMBean("ClusterManager", "Node " + mshost.getId(), new ClusterManagerMBeanImpl(this, mshost));	} catch (final Exception e) {	
unable to regiester cluster node into jmx monitoring due to exception 

} catch (final Exception e) {	}	}	}	if (newNodeList.size() > 0) {	queueNotification(new ClusterManagerMessage(ClusterManagerMessage.MessageType.nodeAdded, newNodeList));	}	profiler.stop();	if (profiler.getDurationInMillis() >= HeartbeatInterval.value()) {	if (s_logger.isDebugEnabled()) {	
peer scan takes too long to finish profiler profilerqueryactivelist profilersyncclusterinfo profilerinvalidatednodelist profilerremovedlist 

public boolean start() {	if (s_logger.isInfoEnabled()) {	
starting cluster manager msid 

mshost.setName(NetUtils.getHostName());	mshost.setVersion(version);	mshost.setServiceIP(_clusterNodeIP);	mshost.setServicePort(_currentServiceAdapter.getServicePort());	mshost.setLastUpdateTime(DateUtil.currentGMTTime());	mshost.setRemoved(null);	mshost.setAlertCount(0);	mshost.setState(ManagementServerHost.State.Up);	_mshostDao.persist(mshost);	if (s_logger.isInfoEnabled()) {	
new instance of management server msid runid is being started 

mshost.setLastUpdateTime(DateUtil.currentGMTTime());	mshost.setRemoved(null);	mshost.setAlertCount(0);	mshost.setState(ManagementServerHost.State.Up);	_mshostDao.persist(mshost);	if (s_logger.isInfoEnabled()) {	}	} else {	_mshostDao.update(mshost.getId(), _runId, NetUtils.getHostName(), version, _clusterNodeIP, _currentServiceAdapter.getServicePort(), DateUtil.currentGMTTime());	if (s_logger.isInfoEnabled()) {	
management server runid is being started 

} else {	_mshostDao.update(mshost.getId(), _runId, NetUtils.getHostName(), version, _clusterNodeIP, _currentServiceAdapter.getServicePort(), DateUtil.currentGMTTime());	if (s_logger.isInfoEnabled()) {	}	}	return mshost;	}	});	_mshostId = mshost.getId();	if (s_logger.isInfoEnabled()) {	
management server host id is being started at 

return mshost;	}	});	_mshostId = mshost.getId();	if (s_logger.isInfoEnabled()) {	}	_mshostPeerDao.clearPeerInfo(_mshostId);	_heartbeatScheduler.scheduleAtFixedRate(getHeartbeatTask(), HeartbeatInterval.value(), HeartbeatInterval.value(), TimeUnit.MILLISECONDS);	_notificationExecutor.submit(getNotificationTask());	if (s_logger.isInfoEnabled()) {	
cluster manager was started successfully 

public boolean stop() {	if (s_logger.isInfoEnabled()) {	
stopping cluster manager msid 

_mshostDao.update(_mshostId, mshost);	}	_heartbeatScheduler.shutdownNow();	_executor.shutdownNow();	try {	_heartbeatScheduler.awaitTermination(EXECUTOR_SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);	_executor.awaitTermination(EXECUTOR_SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);	} catch (final InterruptedException e) {	}	if (s_logger.isInfoEnabled()) {	
cluster manager is stopped 

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	if (s_logger.isInfoEnabled()) {	
start configuring cluster manager 

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	if (s_logger.isInfoEnabled()) {	}	final Properties dbProps = DbProperties.getDbProperties();	_clusterNodeIP = dbProps.getProperty("cluster.node.IP");	if (_clusterNodeIP == null) {	_clusterNodeIP = "127.0.0.1";	}	_clusterNodeIP = _clusterNodeIP.trim();	if (s_logger.isInfoEnabled()) {	
cluster node ip 

_executor.execute(getClusterPduNotificationTask());	if (_serviceAdapters == null) {	throw new ConfigurationException("Unable to get cluster service adapters");	}	_currentServiceAdapter = _serviceAdapters.get(0);	if (_currentServiceAdapter == null) {	throw new ConfigurationException("Unable to set current cluster service adapter");	}	checkConflicts();	if (s_logger.isInfoEnabled()) {	
cluster manager is configured 

private boolean pingManagementNode(final ManagementServerHostVO mshost) {	final String targetIp = mshost.getServiceIP();	if ("127.0.0.1".equals(targetIp) || "0.0.0.0".equals(targetIp)) {	
ping management node cluster service can not be performed on self 

private boolean pingManagementNode(final ManagementServerHostVO mshost) {	final String targetIp = mshost.getServiceIP();	if ("127.0.0.1".equals(targetIp) || "0.0.0.0".equals(targetIp)) {	return false;	}	int retry = 10;	while (--retry > 0) {	SocketChannel sch = null;	try {	
trying to connect to 

SocketChannel sch = null;	try {	sch = SocketChannel.open();	sch.configureBlocking(true);	sch.socket().setSoTimeout(5000);	final InetSocketAddress addr = new InetSocketAddress(targetIp, mshost.getServicePort());	sch.connect(addr);	return true;	} catch (final IOException e) {	if (e instanceof ConnectException) {	
unable to ping management server at due to connectexception 

sch.close();	} catch (final IOException e) {	}	}	}	try {	Thread.sleep(1000);	} catch (final InterruptedException ex) {	}	}	
unable to ping management server at after retries 

========================= cloudstack sample_491 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	BaremetalRctResponse rsp = vlanMgr.addRct(this);	this.setResponseObject(rsp);	} catch (Exception e) {	
unable to add baremetal rct s 

========================= cloudstack sample_868 =========================

protected void fillHostInfo(final Connection conn, final StartupRoutingCommand cmd) {	super.fillHostInfo(conn, cmd);	try {	final HashMap<String, HashMap<String, VgpuTypesInfo>> groupDetails = getGPUGroupDetails(conn);	cmd.setGpuGroupDetails(groupDetails);	if (groupDetails != null && !groupDetails.isEmpty()) {	cmd.setHostTags("GPU");	}	} catch (final Exception e) {	if (s_logger.isDebugEnabled()) {	
error while getting gpu device info from host 

public void createVGPU(final Connection conn, final StartCommand cmd, final VM vm, final GPUDeviceTO gpuDevice) throws XenAPIException, XmlRpcException {	if (s_logger.isDebugEnabled()) {	
creating vgpu of vgpu type in gpu group for vm 

while (iter.hasNext()) {	final VGPUType entry = iter.next();	if (entry.getModelName(conn).equals(gpuDevice.getVgpuType())) {	vgpuType = entry;	}	}	final String device = "0";	final Map<String, String> other_config = new HashMap<String, String>();	VGPU.create(conn, vm, gpuGroup, device, other_config, vgpuType);	if (s_logger.isDebugEnabled()) {	
created vgpu of vgpu type for vm 

========================= cloudstack sample_1149 =========================

if (assignToVpcNtwk) {	_networkModel.checkIpForService(ipAddress, Service.StaticNat, networkId);	s_logger.debug("The ip is not associated with the VPC network id=" + networkId + ", so assigning");	try {	ipAddress = _ipAddrMgr.associateIPToGuestNetwork(ipId, networkId, false);	} catch (Exception ex) {	s_logger.warn("Failed to associate ip id=" + ipId + " to VPC network id=" + networkId + " as " + "a part of enable static nat");	return false;	}	}  else if (ipAddress.isPortable()) {	
portable ip is not associated with the network yet so associate ip with the network 

}	ipAddress.setOneToOneNat(true);	ipAddress.setAssociatedWithVmId(vmId);	ipAddress.setVmIp(dstIp);	if (_ipAddressDao.update(ipAddress.getId(), ipAddress)) {	s_logger.trace("Enabling static nat for ip address " + ipAddress + " and vm id=" + vmId + " on the backend");	if (applyStaticNatForIp(ipId, false, caller, false)) {	performedIpAssoc = false;	return true;	} else {	
failed to enable static nat rule for ip address on the backend 

if (applyStaticNatForIp(ipId, false, caller, false)) {	performedIpAssoc = false;	return true;	} else {	ipAddress.setOneToOneNat(isOneToOneNat);	ipAddress.setAssociatedWithVmId(associatedWithVmId);	ipAddress.setVmIp(null);	_ipAddressDao.update(ipAddress.getId(), ipAddress);	}	} else {	
failed to update ip address in the db as a part of enablestaticnat 

if (networkId != null) {	Network guestNetwork = _networkModel.getNetwork(networkId);	NetworkOffering offering = _entityMgr.findById(NetworkOffering.class, guestNetwork.getNetworkOfferingId());	if (offering.getElasticIp()) {	reassignStaticNat = true;	}	}	if (!reassignStaticNat) {	throw new InvalidParameterValueException("Failed to enable static nat on the  ip " + ipAddress.getAddress()+" with Id " +ipAddress.getUuid()+" as the vm " +vm.getInstanceName() + " with Id " + vm.getUuid() +" is already associated with another public ip " + oldIP.getAddress() +" with id "+ oldIP.getUuid());	}	
disassociating static nat for ip 

return true;	}	if (caller != null) {	_accountMgr.checkAccess(caller, null, true, rules.toArray(new PortForwardingRuleVO[rules.size()]));	}	try {	if (!_firewallMgr.applyRules(rules, continueOnError, true)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to apply port forwarding rules for ip due to 

staticNatRules.add(buildStaticNatRule(rule, forRevoke));	}	if (caller != null) {	_accountMgr.checkAccess(caller, null, true, staticNatRules.toArray(new StaticNatRule[staticNatRules.size()]));	}	try {	if (!_firewallMgr.applyRules(staticNatRules, continueOnError, true)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to apply static nat rules for ip due to 

return true;	}	if (caller != null) {	_accountMgr.checkAccess(caller, null, true, rules.toArray(new PortForwardingRuleVO[rules.size()]));	}	try {	if (!_firewallMgr.applyRules(rules, continueOnError, true)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to apply port forwarding rules for network due to 

_accountMgr.checkAccess(caller, null, true, rules.toArray(new FirewallRule[rules.size()]));	}	for (FirewallRuleVO rule : rules) {	staticNatRules.add(buildStaticNatRule(rule, false));	}	try {	if (!_firewallMgr.applyRules(staticNatRules, continueOnError, true)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to apply static nat rules for network due to 

List<StaticNat> staticNats = new ArrayList<StaticNat>();	for (IPAddressVO ip : ips) {	StaticNatImpl staticNat = new StaticNatImpl(ip.getAllocatedToAccountId(), ip.getAllocatedInDomainId(), networkId, ip.getId(), ip.getVmIp(), false);	staticNats.add(staticNat);	}	try {	if (!_ipAddrMgr.applyStaticNats(staticNats, continueOnError, false)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to create static nat for network due to 

s_logger.debug("Revoking all " + Purpose.Firewall + "rules as a part of disabling static nat for public IP id=" + ipId);	if (!_firewallMgr.revokeFirewallRulesForIp(ipId, callerUserId, caller)) {	s_logger.warn("Unable to revoke all the firewall rules for ip id=" + ipId + " as a part of disable statis nat");	success = false;	}	} catch (ResourceUnavailableException e) {	s_logger.warn("Unable to revoke all firewall rules for ip id=" + ipId + " as a part of ip release", e);	success = false;	}	if (!revokeAllPFAndStaticNatRulesForIp(ipId, callerUserId, caller)) {	
unable to revoke all static nat rules for ip 

boolean isIpSystem = ipAddress.getSystem();	ipAddress.setOneToOneNat(false);	ipAddress.setAssociatedWithVmId(null);	ipAddress.setVmIp(null);	if (isIpSystem && !releaseIpIfElastic) {	ipAddress.setSystem(false);	}	_ipAddressDao.update(ipAddress.getId(), ipAddress);	_vpcMgr.unassignIPFromVpcNetwork(ipAddress.getId(), networkId);	if (isIpSystem && releaseIpIfElastic && !_ipAddrMgr.handleSystemIpRelease(ipAddress)) {	
failed to release system ip address 

if (isIpSystem && !releaseIpIfElastic) {	ipAddress.setSystem(false);	}	_ipAddressDao.update(ipAddress.getId(), ipAddress);	_vpcMgr.unassignIPFromVpcNetwork(ipAddress.getId(), networkId);	if (isIpSystem && releaseIpIfElastic && !_ipAddrMgr.handleSystemIpRelease(ipAddress)) {	success = false;	}	return true;	} else {	
failed to disable one to one nat for the ip address id 

protected boolean applyStaticNatForIp(long sourceIpId, boolean continueOnError, Account caller, boolean forRevoke) {	IpAddress sourceIp = _ipAddressDao.findById(sourceIpId);	List<StaticNat> staticNats = createStaticNatForIp(sourceIp, caller, forRevoke);	if (staticNats != null && !staticNats.isEmpty()) {	try {	if (!_ipAddrMgr.applyStaticNats(staticNats, continueOnError, forRevoke)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to create static nat rule due to 

public boolean applyStaticNatForNetwork(long networkId, boolean continueOnError, Account caller, boolean forRevoke) {	List<? extends IpAddress> staticNatIps = _ipAddressDao.listStaticNatPublicIps(networkId);	List<StaticNat> staticNats = new ArrayList<StaticNat>();	for (IpAddress staticNatIp : staticNatIps) {	staticNats.addAll(createStaticNatForIp(staticNatIp, caller, forRevoke));	}	if (staticNats != null && !staticNats.isEmpty()) {	if (forRevoke) {	
found static nats to disable for network id 

staticNats.addAll(createStaticNatForIp(staticNatIp, caller, forRevoke));	}	if (staticNats != null && !staticNats.isEmpty()) {	if (forRevoke) {	}	try {	if (!_ipAddrMgr.applyStaticNats(staticNats, continueOnError, forRevoke)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to create static nat rule due to 

if (forRevoke) {	}	try {	if (!_ipAddrMgr.applyStaticNats(staticNats, continueOnError, forRevoke)) {	return false;	}	} catch (ResourceUnavailableException ex) {	return false;	}	} else {	
found static nat rules to apply for network id 

List<? extends Nic> nics = _nicDao.listByVmId(vm.getId());	for (Nic nic : nics) {	Network guestNetwork = _networkModel.getNetwork(nic.getNetworkId());	NetworkOffering offering = _entityMgr.findById(NetworkOffering.class, guestNetwork.getNetworkOfferingId());	if (offering.getElasticIp()) {	boolean isSystemVM = (vm.getType() == Type.ConsoleProxy || vm.getType() == Type.SecondaryStorageVm);	if (!isSystemVM && !offering.getAssociatePublicIP()) {	continue;	}	if (_ipAddressDao.findByAssociatedVmId(vm.getId()) != null && !getNewIp) {	
vm already has ip associated with it in guest network 

Network guestNetwork = _networkModel.getNetwork(nic.getNetworkId());	NetworkOffering offering = _entityMgr.findById(NetworkOffering.class, guestNetwork.getNetworkOfferingId());	if (offering.getElasticIp()) {	boolean isSystemVM = (vm.getType() == Type.ConsoleProxy || vm.getType() == Type.SecondaryStorageVm);	if (!isSystemVM && !offering.getAssociatePublicIP()) {	continue;	}	if (_ipAddressDao.findByAssociatedVmId(vm.getId()) != null && !getNewIp) {	continue;	}	
allocating system ip and enabling static nat for it for the vm in guest network 

if (!isSystemVM && !offering.getAssociatePublicIP()) {	continue;	}	if (_ipAddressDao.findByAssociatedVmId(vm.getId()) != null && !getNewIp) {	continue;	}	IpAddress ip = _ipAddrMgr.assignSystemIp(guestNetwork.getId(), _accountMgr.getAccount(vm.getAccountId()), false, true);	if (ip == null) {	throw new CloudRuntimeException("Failed to allocate system ip for vm " + vm + " in guest network " + guestNetwork);	}	
allocated system ip now enabling static nat on it for vm 

if (_ipAddressDao.findByAssociatedVmId(vm.getId()) != null && !getNewIp) {	continue;	}	IpAddress ip = _ipAddrMgr.assignSystemIp(guestNetwork.getId(), _accountMgr.getAccount(vm.getAccountId()), false, true);	if (ip == null) {	throw new CloudRuntimeException("Failed to allocate system ip for vm " + vm + " in guest network " + guestNetwork);	}	try {	success = enableStaticNat(ip.getId(), vm.getId(), guestNetwork.getId(), isSystemVM, null);	} catch (NetworkRuleConflictException ex) {	
failed to enable static nat as a part of enabling elasticip and staticnat for vm in guest network due to exception 

}	IpAddress ip = _ipAddrMgr.assignSystemIp(guestNetwork.getId(), _accountMgr.getAccount(vm.getAccountId()), false, true);	if (ip == null) {	throw new CloudRuntimeException("Failed to allocate system ip for vm " + vm + " in guest network " + guestNetwork);	}	try {	success = enableStaticNat(ip.getId(), vm.getId(), guestNetwork.getId(), isSystemVM, null);	} catch (NetworkRuleConflictException ex) {	success = false;	} catch (ResourceUnavailableException ex) {	
failed to enable static nat as a part of enabling elasticip and staticnat for vm in guest network due to exception 

throw new CloudRuntimeException("Failed to allocate system ip for vm " + vm + " in guest network " + guestNetwork);	}	try {	success = enableStaticNat(ip.getId(), vm.getId(), guestNetwork.getId(), isSystemVM, null);	} catch (NetworkRuleConflictException ex) {	success = false;	} catch (ResourceUnavailableException ex) {	success = false;	}	if (!success) {	
failed to enable static nat on system ip for the vm releasing the ip 

success = enableStaticNat(ip.getId(), vm.getId(), guestNetwork.getId(), isSystemVM, null);	} catch (NetworkRuleConflictException ex) {	success = false;	} catch (ResourceUnavailableException ex) {	success = false;	}	if (!success) {	_ipAddrMgr.handleSystemIpRelease(ip);	throw new CloudRuntimeException("Failed to enable static nat on system ip for the vm " + vm);	} else {	
succesfully enabled static nat on system ip for the vm 

public List<FirewallRuleVO> listAssociatedRulesForGuestNic(Nic nic) {	
checking if pf staticnat loadbalancer rules are configured for nic 

public List<FirewallRuleVO> listAssociatedRulesForGuestNic(Nic nic) {	List<FirewallRuleVO> result = new ArrayList<FirewallRuleVO>();	result.addAll(_portForwardingDao.listByNetworkAndDestIpAddr(nic.getIPv4Address(), nic.getNetworkId()));	if(result.size() > 0) {	
found portforwarding rule configured for the nic in the network 

public List<FirewallRuleVO> listAssociatedRulesForGuestNic(Nic nic) {	List<FirewallRuleVO> result = new ArrayList<FirewallRuleVO>();	result.addAll(_portForwardingDao.listByNetworkAndDestIpAddr(nic.getIPv4Address(), nic.getNetworkId()));	if(result.size() > 0) {	}	List<FirewallRuleVO> staticNatRules = _firewallDao.listStaticNatByVmId(nic.getInstanceId());	for (FirewallRuleVO rule : staticNatRules) {	if (rule.getNetworkId() == nic.getNetworkId()) {	result.add(rule);	
found rule configured 

if (rule.getNetworkId() == nic.getNetworkId()) {	result.add(rule);	}	}	List<? extends IpAddress> staticNatIps = _ipAddressDao.listStaticNatPublicIps(nic.getNetworkId());	for (IpAddress ip : staticNatIps) {	if (ip.getVmIp() != null && ip.getVmIp().equals(nic.getIPv4Address())) {	VMInstanceVO vm = _vmInstanceDao.findById(nic.getInstanceId());	FirewallRuleVO staticNatRule = new FirewallRuleVO(null, ip.getId(), 0, 65535, NetUtils.ALL_PROTO.toString(), nic.getNetworkId(), vm.getAccountId(), vm.getDomainId(), Purpose.StaticNat, null, null, null, null, null);	result.add(staticNatRule);	
found rule configured 

VMInstanceVO vm = _vmInstanceDao.findById(nic.getInstanceId());	FirewallRuleVO staticNatRule = new FirewallRuleVO(null, ip.getId(), 0, 65535, NetUtils.ALL_PROTO.toString(), nic.getNetworkId(), vm.getAccountId(), vm.getDomainId(), Purpose.StaticNat, null, null, null, null, null);	result.add(staticNatRule);	}	}	List<LoadBalancerVMMapVO> lbMapList = _loadBalancerVMMapDao.listByInstanceId(nic.getInstanceId());	for (LoadBalancerVMMapVO lb : lbMapList) {	FirewallRuleVO lbRule = _firewallDao.findById(lb.getLoadBalancerId());	if (lbRule.getNetworkId() == nic.getNetworkId()) {	result.add(lbRule);	
found rule configured 

========================= cloudstack sample_2335 =========================

public void disjoinJob(long joinedJobId) throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {	assert (_job != null);	AsyncJobJoinMapVO record = s_joinMapDao.getJoinRecord(_job.getId(), joinedJobId);	s_jobMgr.disjoinJob(_job.getId(), joinedJobId);	if (record.getJoinStatus() == JobInfo.Status.FAILED) {	if (record.getJoinResult() != null) {	Object exception = JobSerializerHelper.fromObjectSerializedString(record.getJoinResult());	if (exception != null && exception instanceof Exception) {	if (exception instanceof InsufficientCapacityException) {	
job failed with insufficientcapacityexception 

AsyncJobJoinMapVO record = s_joinMapDao.getJoinRecord(_job.getId(), joinedJobId);	s_jobMgr.disjoinJob(_job.getId(), joinedJobId);	if (record.getJoinStatus() == JobInfo.Status.FAILED) {	if (record.getJoinResult() != null) {	Object exception = JobSerializerHelper.fromObjectSerializedString(record.getJoinResult());	if (exception != null && exception instanceof Exception) {	if (exception instanceof InsufficientCapacityException) {	throw (InsufficientCapacityException)exception;	}	else if (exception instanceof ConcurrentOperationException) {	
job failed with concurrentoperationexception 

if (record.getJoinResult() != null) {	Object exception = JobSerializerHelper.fromObjectSerializedString(record.getJoinResult());	if (exception != null && exception instanceof Exception) {	if (exception instanceof InsufficientCapacityException) {	throw (InsufficientCapacityException)exception;	}	else if (exception instanceof ConcurrentOperationException) {	throw (ConcurrentOperationException)exception;	}	else if (exception instanceof ResourceUnavailableException) {	
job failed with resourceunavailableexception 

if (exception instanceof InsufficientCapacityException) {	throw (InsufficientCapacityException)exception;	}	else if (exception instanceof ConcurrentOperationException) {	throw (ConcurrentOperationException)exception;	}	else if (exception instanceof ResourceUnavailableException) {	throw (ResourceUnavailableException)exception;	}	else {	
job failed with exception 

throw (ConcurrentOperationException)exception;	}	else if (exception instanceof ResourceUnavailableException) {	throw (ResourceUnavailableException)exception;	}	else {	throw new RuntimeException((Exception)exception);	}	}	} else {	
job failed without providing an error object 

public static AsyncJobExecutionContext getCurrentExecutionContext() {	AsyncJobExecutionContext context = s_currentExectionContext.get();	if (context == null) {	
job is executed without a context setup psudo job for the executing thread 

========================= cloudstack sample_700 =========================

public Response processSAMLResponse(String responseMessage) {	Response responseObject = null;	try {	DefaultBootstrap.bootstrap();	responseObject = SAMLUtils.decodeSAMLResponse(responseMessage);	} catch (ConfigurationException | FactoryConfigurationError | ParserConfigurationException | SAXException | IOException | UnmarshallingException e) {	
samlresponse processing error 

}	session.setAttribute(SAMLPluginConstants.SAML_IDPID, issuer.getValue());	Signature sig = processedSAMLResponse.getSignature();	if (idpMetadata.getSigningCertificate() != null && sig != null) {	BasicX509Credential credential = new BasicX509Credential();	credential.setEntityCertificate(idpMetadata.getSigningCertificate());	SignatureValidator validator = new SignatureValidator(credential);	try {	validator.validate(sig);	} catch (ValidationException e) {	
saml response s signature failed to be validated by idp signing key 

EncryptedKeyResolver keyResolver = new InlineEncryptedKeyResolver();	Decrypter decrypter = new Decrypter(null, keyInfoResolver, keyResolver);	decrypter.setRootInNewDocument(true);	List<EncryptedAssertion> encryptedAssertions = processedSAMLResponse.getEncryptedAssertions();	if (encryptedAssertions != null) {	for (EncryptedAssertion encryptedAssertion : encryptedAssertions) {	Assertion assertion = null;	try {	assertion = decrypter.decrypt(encryptedAssertion);	} catch (DecryptionException e) {	
saml encryptedassertion error 

continue;	}	Signature encSig = assertion.getSignature();	if (idpMetadata.getSigningCertificate() != null && encSig != null) {	BasicX509Credential sigCredential = new BasicX509Credential();	sigCredential.setEntityCertificate(idpMetadata.getSigningCertificate());	SignatureValidator validator = new SignatureValidator(sigCredential);	try {	validator.validate(encSig);	} catch (ValidationException e) {	
saml response s signature failed to be validated by idp signing key 

throw new ServerApiException(ApiErrorCode.ACCOUNT_ERROR, _apiServer.getSerializedApiError(ApiErrorCode.ACCOUNT_ERROR.getHttpCode(), "Your authenticated user is not authorized for SAML Single Sign-On, please contact your administrator", params, responseType));	}	try {	if (_apiServer.verifyUser(userAccount.getId())) {	LoginCmdResponse loginResponse = (LoginCmdResponse) _apiServer.loginUser(session, userAccount.getUsername(), userAccount.getUsername() + userAccount.getSource().toString(), userAccount.getDomainId(), null, remoteAddress, params);	SAMLUtils.setupSamlUserCookies(loginResponse, resp);	resp.sendRedirect(SAML2AuthManager.SAMLCloudStackRedirectionUrl.value());	return ApiResponseSerializer.toSerializedString(loginResponse, responseType);	}	} catch (CloudAuthenticationException | IOException exception) {	
saml login failed to log in the user due to 

public void setAuthenticators(List<PluggableAPIAuthenticator> authenticators) {	for (PluggableAPIAuthenticator authManager: authenticators) {	if (authManager != null && authManager instanceof SAML2AuthManager) {	_samlAuthManager = (SAML2AuthManager) authManager;	}	}	if (_samlAuthManager == null) {	
no suitable pluggable authentication manager found for login cmd 

========================= cloudstack sample_1372 =========================

volEvent = Event.MigrationCopySucceeded;	} else if (event == ObjectInDataStoreStateMachine.Event.OperationFailed) {	volEvent = Volume.Event.OperationFailed;	} else if (event == ObjectInDataStoreStateMachine.Event.MigrationCopyFailed) {	volEvent = Event.MigrationCopyFailed;	} else if (event == ObjectInDataStoreStateMachine.Event.ResizeRequested) {	volEvent = Volume.Event.ResizeRequested;	}	stateTransit(volEvent);	} catch (Exception e) {	
failed to update state 

public void processEventOnly(ObjectInDataStoreStateMachine.Event event) {	try {	objectInStoreMgr.update(this, event);	} catch (Exception e) {	
failed to update state 

========================= cloudstack sample_3965 =========================

protected void unlock() {	if (tableLockId != null) {	vpcDao.releaseFromLockTable(tableLockId);	if (logger.isDebugEnabled()) {	
lock is released for vpc id as a part of router startup in 

========================= cloudstack sample_2227 =========================

public static void pidCheck(String pidDir, String run) throws ConfigurationException {	String dir = pidDir == null ? "/var/run" : pidDir;	try {	final File propsFile = PropertiesUtil.findConfigFile("environment.properties");	if (propsFile == null) {	
environment properties could not be opened 

final File propsFile = PropertiesUtil.findConfigFile("environment.properties");	if (propsFile == null) {	} else {	final Properties props = PropertiesUtil.loadFromFile(propsFile);	dir = props.getProperty("paths.pid");	if (dir == null) {	dir = pidDir == null ? "/var/run" : pidDir;	}	}	} catch (IOException e) {	
environment properties could not be opened 

========================= cloudstack sample_2732 =========================

final NicVO router_guest_nic = _nicDao.findByNtwkIdAndInstanceId(network.getId(), router.getId());	final String cidr = NetUtils.getCidrFromGatewayAndNetmask(router_guest_nic.getIPv4Gateway(), router_guest_nic.getIPv4Netmask());	final String[] cidrPair = cidr.split("\\/");	final String cidrAddress = cidrPair[0];	final long cidrSize = Long.parseLong(cidrPair[1]);	final String startIpOfSubnet = NetUtils.getIpRangeStartIpFromCidr(cidrAddress, cidrSize);	ipList.add(new DhcpTO(router_guest_nic.getIPv4Address(), router_guest_nic.getIPv4Gateway(), router_guest_nic.getIPv4Netmask(), startIpOfSubnet));	for (final NicIpAliasVO ipAliasVO : ipAliasVOList) {	final DhcpTO DhcpTO = new DhcpTO(ipAliasVO.getIp4Address(), ipAliasVO.getGateway(), ipAliasVO.getNetmask(), ipAliasVO.getStartIpOfSubnet());	if (s_logger.isTraceEnabled()) {	
configdnsmasq adding ip 

final List<UserVmVO> vms = _userVmDao.listByNetworkIdAndStates(guestNetworkId, VirtualMachine.State.Running, VirtualMachine.State.Migrating, VirtualMachine.State.Stopping);	final DataCenterVO dc = _dcDao.findById(router.getDataCenterId());	for (final UserVmVO vm : vms) {	boolean createVmData = true;	if (dc.getNetworkType() == NetworkType.Basic && router.getPodIdToDeployIn().longValue() != vm.getPodIdToDeployIn().longValue()) {	createVmData = false;	}	if (createVmData) {	final NicVO nic = _nicDao.findByNtwkIdAndInstanceId(guestNetworkId, vm.getId());	if (nic != null) {	
creating user data entry for vm on domr 

public void createDhcpEntryCommandsForVMs(final DomainRouterVO router, final Commands cmds, final long guestNetworkId) {	final List<UserVmVO> vms = _userVmDao.listByNetworkIdAndStates(guestNetworkId, VirtualMachine.State.Running, VirtualMachine.State.Migrating, VirtualMachine.State.Stopping);	final DataCenterVO dc = _dcDao.findById(router.getDataCenterId());	String dnsBasicZoneUpdates = _configDao.getValue(Config.DnsBasicZoneUpdates.key());	for (final UserVmVO vm : vms) {	if (dc.getNetworkType() == NetworkType.Basic && router.getPodIdToDeployIn().longValue() != vm.getPodIdToDeployIn().longValue() && dnsBasicZoneUpdates.equalsIgnoreCase("pod")) {	continue;	}	final NicVO nic = _nicDao.findByNtwkIdAndInstanceId(guestNetworkId, vm.getId());	if (nic != null) {	
creating dhcp entry for vm on domr 

========================= cloudstack sample_2362 =========================

pstmt.setString(3, usage.getAddress());	pstmt.executeUpdate();	}	}catch(SQLException e) {	throw new CloudException("update:Exception:"+e.getMessage(), e);	}	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usageipaddressvo 

if (assignedTS != null) {	assignedDate = DateUtil.parseDateString(s_gmtTimeZone, assignedTS);	}	if (releasedTS != null) {	releasedDate = DateUtil.parseDateString(s_gmtTimeZone, releasedTS);	}	usageRecords.add(new UsageIPAddressVO(id, acctId, dId, zId, addr, isSourceNat, isSystem, assignedDate, releasedDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4473 =========================

public void execute() {	
volss createsnapshotcmd starts 

========================= cloudstack sample_3359 =========================

public void createAsync(DataStore dataStore, DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {	CreateContext<CreateCmdResult> context = new CreateContext<CreateCmdResult>(callback, data);	AsyncCallbackDispatcher<BaseImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher.create(this);	caller.setContext(context);	if (data.getType() == DataObjectType.TEMPLATE) {	caller.setCallback(caller.getTarget().createTemplateAsyncCallback(null, null));	if (s_logger.isDebugEnabled()) {	
downloading template to data store 

AsyncCallbackDispatcher<BaseImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher.create(this);	caller.setContext(context);	if (data.getType() == DataObjectType.TEMPLATE) {	caller.setCallback(caller.getTarget().createTemplateAsyncCallback(null, null));	if (s_logger.isDebugEnabled()) {	}	_downloadMonitor.downloadTemplateToStorage(data, caller);	} else if (data.getType() == DataObjectType.VOLUME) {	caller.setCallback(caller.getTarget().createVolumeAsyncCallback(null, null));	if (s_logger.isDebugEnabled()) {	
downloading volume to data store 

protected Void createTemplateAsyncCallback(AsyncCallbackDispatcher<? extends BaseImageStoreDriverImpl, DownloadAnswer> callback, CreateContext<CreateCmdResult> context) {	if (s_logger.isDebugEnabled()) {	
performing image store createtemplate async callback 

protected Void createTemplateAsyncCallback(AsyncCallbackDispatcher<? extends BaseImageStoreDriverImpl, DownloadAnswer> callback, CreateContext<CreateCmdResult> context) {	if (s_logger.isDebugEnabled()) {	}	DownloadAnswer answer = callback.getResult();	DataObject obj = context.data;	DataStore store = obj.getDataStore();	TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(), obj.getId());	if (tmpltStoreVO != null) {	if (tmpltStoreVO.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {	if (s_logger.isDebugEnabled()) {	
template is already in downloaded state ignore further incoming downloadanswer 

String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if (answer != null && !answer.getResult()) {	result.setResult(answer.getDetails());	}	} catch (Exception ex) {	
unable to destoy 

========================= cloudstack sample_3973 =========================

CallContext.current().setEventDetails(getEventDescription());	String uploadUrl = _templateService.extract(this);	if (uploadUrl != null) {	ExtractResponse response = _responseGenerator.createExtractResponse(id, zoneId, getEntityOwnerId(), mode, uploadUrl);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to extract template");	}	} catch (InternalErrorException ex) {	
exception 

========================= cloudstack sample_3420 =========================

break;	}	case RfbConstants.SERVER_CUT_TEXT: {	serverCutText(is);	break;	}	default: throw new RuntimeException("Unknown server packet type: " + messageType + ".");	}	}	} catch (Throwable e) {	
unexpected exception 

break;	}	default: throw new RuntimeException("Unknown server packet type: " + messageType + ".");	}	}	} catch (Throwable e) {	if (connectionAlive) {	closeConnection();	}	} finally {	
receiving thread exit processing shutdown connection 

private void serverCutText(DataInputStream is) throws IOException {	ServerCutText clipboardContent = new ServerCutText(is);	StringSelection contents = new StringSelection(clipboardContent.getContent());	Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);	
server clipboard buffer 

========================= cloudstack sample_4977 =========================

String sql = DOWNLOADS_STATE_DC;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, datacenterId);	pstmt.setLong(2, templateId);	pstmt.setString(3, downloadState.toString());	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	result.add(toEntityBean(rs, false));	}	} catch (Exception e) {	
exception 

pstmt.setLong(1, datacenterId);	pstmt.setLong(2, podId);	pstmt.setLong(3, templateId);	pstmt.setString(4, downloadState.toString());	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (Exception e) {	
exception 

pstmt.setLong(3, templateId);	pstmt.setString(4, downloadState.toString());	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (Exception e) {	}	} catch (Exception e) {	
exception 

String sql = HOST_TEMPLATE_SEARCH;	try(PreparedStatement pstmt = txn.prepareStatement(sql);) {	pstmt.setLong(1, hostId);	pstmt.setLong(2, templateId);	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (Exception e) {	
exception 

pstmt.setLong(1, hostId);	pstmt.setLong(2, templateId);	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (Exception e) {	}	} catch (Exception e) {	
exception 

========================= cloudstack sample_4561 =========================

public HttpServer createHttpServerInstance(int port) throws IOException {	
create http server instance at port 

public SSLServerSocket createSSLServerSocket(int port) throws IOException {	
ssl server socket is not supported in consoleproxybaseserverfactoryimpl 

========================= cloudstack sample_4998 =========================

public String getCurrentVersion() {	try (Connection conn = TransactionLegacy.getStandaloneConnection();) {	
checking to see if the database is at a version before it was the version table is created 

) {	if (!rs.next()) {	try (PreparedStatement pstmt_nics = conn.prepareStatement("SHOW TABLES LIKE 'nics'");	ResultSet rs_nics = pstmt_nics.executeQuery();	) {	if (!rs_nics.next()) {	try (PreparedStatement pstmt_domain = conn.prepareStatement("SELECT domain_id FROM account_vlan_map LIMIT 1"); ){	pstmt_domain.executeQuery();	return "2.1.8";	} catch (final SQLException e) {	
assuming the exception means domain id is not there 

) {	if (!rs.next()) {	try (PreparedStatement pstmt_nics = conn.prepareStatement("SHOW TABLES LIKE 'nics'");	ResultSet rs_nics = pstmt_nics.executeQuery();	) {	if (!rs_nics.next()) {	try (PreparedStatement pstmt_domain = conn.prepareStatement("SELECT domain_id FROM account_vlan_map LIMIT 1"); ){	pstmt_domain.executeQuery();	return "2.1.8";	} catch (final SQLException e) {	
no version table and no nics table returning 

pstmt_domain.executeQuery();	return "2.1.8";	} catch (final SQLException e) {	return "2.1.7";	}	} else {	try (PreparedStatement pstmt_static_nat = conn.prepareStatement("SELECT is_static_nat from firewall_rules");	ResultSet rs_static_nat = pstmt_static_nat.executeQuery();){	return "2.2.1";	} catch (final SQLException e) {	
assuming the exception means static nat field doesn t exist in firewall rules table returning version 

sc.setParameters("step", Step.Complete);	Filter filter = new Filter(VersionVO.class, "id", false, 0l, 1l);	final List<String> upgradedVersions = customSearch(sc, filter);	if (upgradedVersions.isEmpty()) {	filter = new Filter(VersionVO.class, "id", false, 0l, 1l);	sc = CurrentVersionSearch.create();	final List<String> vers = customSearch(sc, filter);	if (!vers.isEmpty()) {	throw new CloudRuntimeException("Version table contains records for which upgrade wasn't completed");	}	
version table exists but it s empty have to confirm that version is 

}	try (PreparedStatement pstmt = conn.prepareStatement("SHOW TABLES LIKE 'nics'");	ResultSet rs = pstmt.executeQuery();){	if (!rs.next()) {	throw new CloudRuntimeException("Unable to determine the current version, version table exists and empty, nics table doesn't exist");	} else {	try (PreparedStatement pstmt_static_nat = conn.prepareStatement("SELECT is_static_nat from firewall_rules"); ) {	pstmt_static_nat.executeQuery();	throw new CloudRuntimeException("Unable to determine the current version, version table exists and empty, " + "nics table doesn't exist, is_static_nat field exists in firewall_rules table");	} catch (final SQLException e) {	
assuming the exception means static nat field doesn t exist in firewall rules table returning version 

========================= cloudstack sample_4218 =========================

public ListenerThread(HttpRequestHandler requestHandler, int port) {	_executor = Executors.newCachedThreadPool(new NamedThreadFactory("Cluster-Listener"));	try {	_serverSocket = new ServerSocket(port);	} catch (IOException ioex) {	
error initializing cluster service servlet container 

public void stopRunning() {	if (_serverSocket != null) {	try {	_serverSocket.close();	} catch (IOException e) {	
ignored error on closing server socket 

public void run() {	
cluster service servlet container listening on port 

while (_serverSocket != null) {	try {	Socket socket = _serverSocket.accept();	final DefaultHttpServerConnection conn = new DefaultHttpServerConnection();	conn.bind(socket, _params);	_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && conn.isOpen()) {	
dispatching cluster request from 

try {	Socket socket = _serverSocket.accept();	final DefaultHttpServerConnection conn = new DefaultHttpServerConnection();	conn.bind(socket, _params);	_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && conn.isOpen()) {	_httpService.handleRequest(conn, context);	
cluster request from is processed 

final DefaultHttpServerConnection conn = new DefaultHttpServerConnection();	conn.bind(socket, _params);	_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && conn.isOpen()) {	_httpService.handleRequest(conn, context);	}	} catch (ConnectionClosedException ex) {	
client closed connection 

conn.bind(socket, _params);	_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && conn.isOpen()) {	_httpService.handleRequest(conn, context);	}	} catch (ConnectionClosedException ex) {	} catch (IOException ex) {	
i o error 

_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && conn.isOpen()) {	_httpService.handleRequest(conn, context);	}	} catch (ConnectionClosedException ex) {	} catch (IOException ex) {	} catch (HttpException ex) {	
unrecoverable http protocol violation 

while (!Thread.interrupted() && conn.isOpen()) {	_httpService.handleRequest(conn, context);	}	} catch (ConnectionClosedException ex) {	} catch (IOException ex) {	} catch (HttpException ex) {	} finally {	try {	conn.shutdown();	} catch (IOException ignore) {	
unexpected exception 

} catch (HttpException ex) {	} finally {	try {	conn.shutdown();	} catch (IOException ignore) {	}	}	}	});	} catch (Throwable e) {	
unexpected exception 

conn.shutdown();	} catch (IOException ignore) {	}	}	}	});	} catch (Throwable e) {	try {	Thread.sleep(1000);	} catch (InterruptedException e1) {	
ignored interupted while waiting to retry running the servlet container 

}	});	} catch (Throwable e) {	try {	Thread.sleep(1000);	} catch (InterruptedException e1) {	}	}	}	_executor.shutdown();	
cluster service servlet container shutdown 

========================= cloudstack sample_487 =========================

protected boolean processHostStartup(StartupRoutingCommand startup) throws ConnectionException {	boolean found = false;	Type type = Host.Type.Routing;	final Map<String, String> hostDetails = startup.getHostDetails();	HostVO server = _hostDao.findByGuid(startup.getGuid());	if (server == null) {	server = _hostDao.findByGuid(startup.getGuidWithoutResource());	}	if (server != null && server.getRemoved() == null) {	if (s_logger.isDebugEnabled()) {	
found the host by guid 

protected void updateComputeHost(final HostVO host, final StartupCommand startup, final Host.Type type) throws AgentAuthnException {	String zoneToken = startup.getDataCenter();	if (zoneToken == null) {	
no zone token passed in cannot not find zone for the agent 

zone = _zoneDao.findById(zoneId);	if (zone == null) {	throw new AgentAuthnException("Could not find zone for agent with token " + zoneToken);	}	} catch (NumberFormatException nfe) {	throw new AgentAuthnException("Could not find zone for agent with token " + zoneToken);	}	}	}	if (s_logger.isDebugEnabled()) {	
successfully loaded the datacenter from the zone token passed in 

}	}	if (s_logger.isDebugEnabled()) {	}	long zoneId = zone.getId();	ResourceDetail maxHostsInZone = _zoneDetailsDao.findDetail(zoneId, ZoneConfig.MaxHosts.key());	if (maxHostsInZone != null) {	long maxHosts = Long.parseLong(maxHostsInZone.getValue());	long currentCountOfHosts = _hostDao.countRoutingHostsByDataCenter(zoneId);	if (s_logger.isDebugEnabled()) {	
number of hosts in zone max hosts limit 

long maxHosts = Long.parseLong(maxHostsInZone.getValue());	long currentCountOfHosts = _hostDao.countRoutingHostsByDataCenter(zoneId);	if (s_logger.isDebugEnabled()) {	}	if (currentCountOfHosts >= maxHosts) {	throw new AgentAuthnException("Number of running Routing hosts in the Zone:" + zone.getName() + " is already at the max limit:" + maxHosts + ", cannot start one more host");	}	}	HostPodVO pod = null;	if (startup.getPrivateIpAddress() == null) {	
no private ip address passed in for the agent cannot not find pod for agent 

}	if (currentCountOfHosts >= maxHosts) {	throw new AgentAuthnException("Number of running Routing hosts in the Zone:" + zone.getName() + " is already at the max limit:" + maxHosts + ", cannot start one more host");	}	}	HostPodVO pod = null;	if (startup.getPrivateIpAddress() == null) {	throw new AgentAuthnException("No private IP address passed in for the agent, cannot not find pod for agent");	}	if (startup.getPrivateNetmask() == null) {	
no netmask passed in for the agent cannot not find pod for agent 

}	HostPodVO pod = null;	if (startup.getPrivateIpAddress() == null) {	throw new AgentAuthnException("No private IP address passed in for the agent, cannot not find pod for agent");	}	if (startup.getPrivateNetmask() == null) {	throw new AgentAuthnException("No netmask passed in for the agent, cannot not find pod for agent");	}	if (host.getPodId() != null) {	if (s_logger.isDebugEnabled()) {	
pod is already created for this agent looks like agent is reconnecting 

if (startup.getPrivateNetmask() == null) {	throw new AgentAuthnException("No netmask passed in for the agent, cannot not find pod for agent");	}	if (host.getPodId() != null) {	if (s_logger.isDebugEnabled()) {	}	pod = _podDao.findById(host.getPodId());	if (!checkCIDR(type, pod, startup.getPrivateIpAddress(), startup.getPrivateNetmask())) {	pod = null;	if (s_logger.isDebugEnabled()) {	
subnet of pod does not match the subnet of the agent not using this pod 

if (!checkCIDR(type, pod, startup.getPrivateIpAddress(), startup.getPrivateNetmask())) {	pod = null;	if (s_logger.isDebugEnabled()) {	}	} else {	updatePodNetmaskIfNeeded(pod, startup.getPrivateNetmask());	}	}	if (pod == null) {	if (s_logger.isDebugEnabled()) {	
trying to detect the pod to use from the agent s ip address and netmask passed in 

for (HostPodVO hostPod : podsInZone) {	if (checkCIDR(type, hostPod, startup.getPrivateIpAddress(), startup.getPrivateNetmask())) {	pod = hostPod;	updatePodNetmaskIfNeeded(pod, startup.getPrivateNetmask());	podFound = true;	break;	}	}	if (!podFound) {	if (s_logger.isDebugEnabled()) {	
creating a new pod since no default pod found that matches the agent s ip address and netmask passed in 

pod = hostPod;	updatePodNetmaskIfNeeded(pod, startup.getPrivateNetmask());	podFound = true;	break;	}	}	if (!podFound) {	if (s_logger.isDebugEnabled()) {	}	if (startup.getGatewayIpAddress() == null) {	
no gateway ip address passed in for the agent cannot create a new pod for the agent 

pod = _configurationManager.createPod(-1, podName, zoneId, gateway, cidr, startIp, endIp, null, true);	} catch (Exception e) {	throw new CloudRuntimeException("Unable to create new Pod " + podName + " in Zone: " + zoneId, e);	}	}	}	final StartupRoutingCommand scc = (StartupRoutingCommand)startup;	ClusterVO cluster = null;	if (host.getClusterId() != null) {	if (s_logger.isDebugEnabled()) {	
cluster is already created for this agent looks like agent is reconnecting 

}	cluster = _clusterDao.findById(host.getClusterId());	}	if (cluster == null) {	String clusterName = "Cluster-" + startup.getPrivateIpAddress();	ClusterVO existingCluster = _clusterDao.findBy(clusterName, pod.getId());	if (existingCluster != null) {	cluster = existingCluster;	} else {	if (s_logger.isDebugEnabled()) {	
creating a new cluster for this agent with name in pod in zone 

cluster = new ClusterVO(zoneId, pod.getId(), clusterName);	cluster.setHypervisorType(scc.getHypervisorType().toString());	try {	cluster = _clusterDao.persist(cluster);	} catch (Exception e) {	throw new CloudRuntimeException("Unable to create cluster " + clusterName + " in pod " + pod.getId() + " and data center " + zoneId, e);	}	}	}	if (s_logger.isDebugEnabled()) {	
detected zone pod cluster 

}	boolean found = false;	Type type = Host.Type.LocalSecondaryStorage;	final Map<String, String> hostDetails = startup.getHostDetails();	HostVO server = _hostDao.findByGuid(startup.getGuid());	if (server == null) {	server = _hostDao.findByGuid(startup.getGuidWithoutResource());	}	if (server != null && server.getRemoved() == null) {	if (s_logger.isDebugEnabled()) {	
found the host by guid 

protected void updateSecondaryHost(final HostVO host, final StartupStorageCommand startup, final Host.Type type) throws AgentAuthnException {	String zoneToken = startup.getDataCenter();	if (zoneToken == null) {	
no zone token passed in cannot not find zone for the agent 

zone = _zoneDao.findById(zoneId);	if (zone == null) {	throw new AgentAuthnException("Could not find zone for agent with token " + zoneToken);	}	} catch (NumberFormatException nfe) {	throw new AgentAuthnException("Could not find zone for agent with token " + zoneToken);	}	}	}	if (s_logger.isDebugEnabled()) {	
successfully loaded the datacenter from the zone token passed in 

} catch (NumberFormatException nfe) {	throw new AgentAuthnException("Could not find zone for agent with token " + zoneToken);	}	}	}	if (s_logger.isDebugEnabled()) {	}	HostPodVO pod = findPod(startup, zone.getId(), Host.Type.Routing);	Long podId = null;	if (pod != null) {	
found pod for the secondary storage host 

========================= cloudstack sample_2636 =========================

public void onSSVMAlert(Object sender, SecStorageVmAlertEventArgs args) {	
received secondary storage vm alert 

public void onSSVMAlert(Object sender, SecStorageVmAlertEventArgs args) {	DataCenterVO dc = _dcDao.findById(args.getZoneId());	SecondaryStorageVmVO secStorageVm = args.getSecStorageVm();	if (secStorageVm == null && args.getSecStorageVmId() != 0) secStorageVm = _ssvmDao.findById(args.getSecStorageVmId());	if (secStorageVm == null && args.getType() != SecStorageVmAlertEventArgs.SSVM_CREATE_FAILURE) {	throw new CloudRuntimeException("Invalid alert arguments, secStorageVm must be set");	}	switch (args.getType()) {	
new secondary storage vm created zone secstoragevm public ip private ip 

public void onSSVMAlert(Object sender, SecStorageVmAlertEventArgs args) {	DataCenterVO dc = _dcDao.findById(args.getZoneId());	SecondaryStorageVmVO secStorageVm = args.getSecStorageVm();	if (secStorageVm == null && args.getSecStorageVmId() != 0) secStorageVm = _ssvmDao.findById(args.getSecStorageVmId());	if (secStorageVm == null && args.getType() != SecStorageVmAlertEventArgs.SSVM_CREATE_FAILURE) {	throw new CloudRuntimeException("Invalid alert arguments, secStorageVm must be set");	}	switch (args.getType()) {	break;	
secondary storage vm is up zone secstoragevm public ip private ip 

switch (args.getType()) {	break;	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SSVM, args.getZoneId(), secStorageVm.getPodIdToDeployIn(), "Secondary Storage Vm up in zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()), "Secondary Storage Vm up (zone " + dc.getName() + ")");	break;	case SecStorageVmAlertEventArgs.SSVM_DOWN: if (s_logger.isDebugEnabled()) s_logger.debug("Secondary Storage Vm is down, zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()));	_alertMgr.sendAlert( AlertManager.AlertType.ALERT_TYPE_SSVM, args.getZoneId(), secStorageVm.getPodIdToDeployIn(), "Secondary Storage Vm down in zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()), "Secondary Storage Vm down (zone " + dc.getName() + ")");	break;	case SecStorageVmAlertEventArgs.SSVM_REBOOTED: if (s_logger.isDebugEnabled()) s_logger.debug("Secondary Storage Vm is rebooted, zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()));	_alertMgr.sendAlert( AlertManager.AlertType.ALERT_TYPE_SSVM, args.getZoneId(), secStorageVm.getPodIdToDeployIn(), "Secondary Storage Vm rebooted in zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()), "Secondary Storage Vm rebooted (zone " + dc.getName() + ")");	break;	
secondary storage vm creation failure zone 

_alertMgr.sendAlert( AlertManager.AlertType.ALERT_TYPE_SSVM, args.getZoneId(), secStorageVm.getPodIdToDeployIn(), "Secondary Storage Vm rebooted in zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()), "Secondary Storage Vm rebooted (zone " + dc.getName() + ")");	break;	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SSVM, args.getZoneId(), null, "Secondary Storage Vm creation failure. zone: " + dc.getName() + ", error details: " + args.getMessage(), "Secondary Storage Vm creation failure (zone " + dc.getName() + ")");	break;	case SecStorageVmAlertEventArgs.SSVM_START_FAILURE: if (s_logger.isDebugEnabled()) s_logger.debug("Secondary Storage Vm startup failure, zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()));	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SSVM, args.getZoneId(), secStorageVm.getPodIdToDeployIn(), "Secondary Storage Vm startup failure. zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()) + ", error details: " + args.getMessage(), "Secondary Storage Vm startup failure (zone " + dc.getName() + ")");	break;	case SecStorageVmAlertEventArgs.SSVM_FIREWALL_ALERT: if (s_logger.isDebugEnabled()) s_logger.debug("Secondary Storage Vm firewall alert, zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()));	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_SSVM, args.getZoneId(), secStorageVm.getPodIdToDeployIn(), "Failed to open secondary storage vm firewall port. zone: " + dc.getName() + ", secStorageVm: " + secStorageVm.getHostName() + ", public IP: " + secStorageVm.getPublicIpAddress() + ", private IP: " + (secStorageVm.getPrivateIpAddress() == null ? "N/A" : secStorageVm.getPrivateIpAddress()), "Secondary Storage Vm alert (zone " + dc.getName() + ")");	break;	
secondary storage vm storage alert zone secstoragevm public ip private ip message 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	
start configuring secondary storage vm alert manager 

========================= cloudstack sample_2266 =========================

super.configure(name, params);	_tftpDir = (String)params.get(BaremetalPxeService.PXE_PARAM_TFTP_DIR);	if (_tftpDir == null) {	throw new ConfigurationException("No tftp directory specified");	}	com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22);	s_logger.debug(String.format("Trying to connect to kickstart PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, "******"));	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	
ssh failed to authenticate 

sb.append(folder);	sb.append(",");	sb.append(file);	sb.append(",");	sb.append(contents);	sb.append(";");	}	String arg = StringUtils.stripEnd(sb.toString(), ";");	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	
ssh failed to authenticate 

sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	throw new ConfigurationException(String.format("Cannot connect to PING PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, _password));	}	String script = String.format("python /usr/bin/baremetal_user_data.py '%s'", arg);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new Answer(cmd, false, "Failed to add user data, command:" + script);	}	return new Answer(cmd, true, "Success");	} catch (Exception e) {	
prepare for creating baremetal template failed 

private Answer execute(PrepareKickstartPxeServerCommand cmd) {	com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	
ssh failed to authenticate 

String script = String.format("python /usr/bin/prepare_kickstart_kernel_initrd.py %s %s %s", cmd.getKernel(), cmd.getInitrd(), copyTo);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new Answer(cmd, false, "prepare kickstart at pxe server " + _ip + " failed, command:" + script);	}	String kernelPath = String.format("%s/vmlinuz", cmd.getTemplateUuid());	String initrdPath = String.format("%s/initrd.img", cmd.getTemplateUuid());	script = String.format("python /usr/bin/prepare_kickstart_bootfile.py %s %s %s %s %s %s", _tftpDir, cmd.getMac(), kernelPath, initrdPath, cmd.getKsFile(), cmd.getMac());	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new Answer(cmd, false, "prepare kickstart at pxe server " + _ip + " failed, command:" + script);	}	
prepare kickstart pxe server successfully 

return new Answer(cmd, false, "prepare kickstart at pxe server " + _ip + " failed, command:" + script);	}	String kernelPath = String.format("%s/vmlinuz", cmd.getTemplateUuid());	String initrdPath = String.format("%s/initrd.img", cmd.getTemplateUuid());	script = String.format("python /usr/bin/prepare_kickstart_bootfile.py %s %s %s %s %s %s", _tftpDir, cmd.getMac(), kernelPath, initrdPath, cmd.getKsFile(), cmd.getMac());	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new Answer(cmd, false, "prepare kickstart at pxe server " + _ip + " failed, command:" + script);	}	return new Answer(cmd, true, "Success");	} catch (Exception e) {	
prepare for kickstart server failed 

========================= cloudstack sample_891 =========================

public PortProfileVO addPortProfile(String portProfName, long vsmId, int vlanId, PortType pType, BindingType bType) {	if (_portProfileDao.findByName(portProfName) != null) {	
port profile with specified name already exists 

public PortProfileVO addPortProfile(String portProfName, long vsmId, int lowVlanId, int highVlanId, PortType pType, BindingType bType) {	PortProfileVO portProfileObj;	portProfileObj = _portProfileDao.findByName(portProfName);	if (portProfileObj != null) {	
port profile with specified name already exists 

public PortProfileVO addPortProfile(String portProfName, long vsmId, int lowVlanId, int highVlanId, PortType pType, BindingType bType) {	PortProfileVO portProfileObj;	portProfileObj = _portProfileDao.findByName(portProfName);	if (portProfileObj != null) {	throw new InvalidParameterValueException("Port Profile with specified name: " + portProfName + " already exists");	}	if (_portProfileDao.doesVlanRangeClash(lowVlanId, highVlanId) == true) {	
port profile s vlanid range clashes with an existing port profile s 

========================= cloudstack sample_2354 =========================

public void start() {	appContext = new ClassPathXmlApplicationContext("usageApplicationContext.xml");	try {	ComponentContext.initComponentsLifeCycle();	} catch (Exception e) {	e.printStackTrace();	}	mgr = appContext.getBean(UsageManager.class);	if (mgr != null) {	if (s_logger.isInfoEnabled()) {	
usageserver ready 

========================= cloudstack sample_2641 =========================

public void disconnected() {	
opendaylightcontrollerresource is disconnected from the controller at 

int i = keyGenerator.nextInt();	for (NeutronNetwork network : networks.getNetworks()) {	if (network.getSegmentationId() == i) {	continue;	}	}	gre_key = i;	break;	}	} catch (NeutronRestApiException e) {	
failed to list existing networks on the odl controller 

newNetwork.setTenantId(cmd.getTenantId());	newNetwork.setNetworkType("gre");	newNetwork.setShared(false);	newNetwork.setSegmentationId(gre_key);	newNetwork.setId(UUID.randomUUID());	NeutronNetworkWrapper wrapper = new NeutronNetworkWrapper();	wrapper.setNetwork(newNetwork);	try {	wrapper = configureNetwork.createNeutronNetwork(wrapper);	} catch (NeutronRestApiException e) {	
createneutronnetwork failed 

private Answer executeRequest(DestroyNetworkCommand cmd) {	NeutronNetworksNorthboundAction configureNetwork = new NeutronNetworksNorthboundAction(controllerUrl, controllerUsername, controllerPassword);	try {	configureNetwork.deleteNeutronNetwork(cmd.getNetworkUuid());	} catch (NeutronRestApiException e) {	
deleteneutronnetwork failed 

newPort.setNetworkId(cmd.getNetworkId());	newPort.setMacAddress(cmd.getMacAddress());	newPort.setDeviceId(UUID.randomUUID());	newPort.setStatus("ACTIVE");	newPort.setFixedIps(Collections.<String> emptyList());	NeutronPortWrapper portWrapper = new NeutronPortWrapper();	portWrapper.setPort(newPort);	try {	portWrapper = configurePort.createNeutronPort(portWrapper);	} catch (NeutronRestApiException e) {	
createportcommand failed 

private Answer executeRequest(DestroyPortCommand cmd) {	NeutronPortsNorthboundAction configurePort = new NeutronPortsNorthboundAction(controllerUrl, controllerUsername, controllerPassword);	try {	configurePort.deleteNeutronPort(cmd.getPortId().toString());	} catch (NeutronRestApiException e) {	
deleteneutronport failed 

if (nodes.getNodes() != null) {	for (NeutronNodeWrapper nodeWrapper : nodes.getNodes()) {	NeutronNode node = nodeWrapper.getNode();	if (node.getId().equals(cmd.getHostId())) {	return new AddHypervisorAnswer(cmd, true, "Hypervisor already connected");	}	}	}	nodeActions.updateNeutronNodeV2("OVS", cmd.getHostId(), cmd.getIpAddress(), 6640);	} catch (NeutronRestApiException e) {	
call to opendaylight failed 

========================= cloudstack sample_1597 =========================

private void createCloudstackUserAccount(LdapUser user, String accountName, Domain domain) {	Account account = _accountService.getActiveAccountByName(accountName, domain.getId());	if (account == null) {	
no account exists with name creating the account and an user with name in the account 

private void createCloudstackUserAccount(LdapUser user, String accountName, Domain domain) {	Account account = _accountService.getActiveAccountByName(accountName, domain.getId());	if (account == null) {	_accountService.createUserAccount(user.getUsername(), generatePassword(), user.getFirstname(), user.getLastname(), user.getEmail(), timezone, accountName, getAccountType(), getRoleId(), domain.getId(), domain.getNetworkDomain(), details, UUID.randomUUID().toString(), UUID.randomUUID().toString(), User.Source.LDAP);	} else {	UserAccount csuser = _accountService.getActiveUserAccount(user.getUsername(), domain.getId());	if(csuser == null) {	
no user exists with name creating a user in the account 

private void createCloudstackUserAccount(LdapUser user, String accountName, Domain domain) {	Account account = _accountService.getActiveAccountByName(accountName, domain.getId());	if (account == null) {	_accountService.createUserAccount(user.getUsername(), generatePassword(), user.getFirstname(), user.getLastname(), user.getEmail(), timezone, accountName, getAccountType(), getRoleId(), domain.getId(), domain.getNetworkDomain(), details, UUID.randomUUID().toString(), UUID.randomUUID().toString(), User.Source.LDAP);	} else {	UserAccount csuser = _accountService.getActiveUserAccount(user.getUsername(), domain.getId());	if(csuser == null) {	_accountService.createUser(user.getUsername(), generatePassword(), user.getFirstname(), user.getLastname(), user.getEmail(), timezone, accountName, domain.getId(), UUID.randomUUID().toString(), User.Source.LDAP);	} else {	
account with name exist and user with name exists in the account updating the account 

}	List<LdapUser> users;	try {	if (StringUtils.isNotBlank(groupName)) {	users = _ldapManager.getUsersInGroup(groupName);	} else {	users = _ldapManager.getUsers();	}	} catch (NoLdapUserMatchingQueryException ex) {	users = new ArrayList<LdapUser>();	
no ldap user matching query 

} catch (NoLdapUserMatchingQueryException ex) {	users = new ArrayList<LdapUser>();	}	List<LdapUser> addedUsers = new ArrayList<LdapUser>();	for (LdapUser user : users) {	Domain domain = getDomain(user);	try {	createCloudstackUserAccount(user, getAccountName(user), domain);	addedUsers.add(user);	} catch (InvalidParameterValueException ex) {	
failed to create user with username 

========================= cloudstack sample_1344 =========================

public List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	
garbagecollectingstoragepoolallocator looking for storage pool 

public List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	if (!_storagePoolCleanupEnabled) {	
storage pool cleanup is not enabled so garbagecollectingstoragepoolallocator is being skipped 

========================= cloudstack sample_4003 =========================

public Answer execute(final RebootCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	
the vm is in starting state 

public Answer execute(final RebootCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	try {	Set<VM> vms = null;	try {	vms = VM.getByNameLabel(conn, command.getVmName());	} catch (final XenAPIException e0) {	
getbynamelabel failed 

public Answer execute(final RebootCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	try {	Set<VM> vms = null;	try {	vms = VM.getByNameLabel(conn, command.getVmName());	} catch (final XenAPIException e0) {	return new RebootAnswer(command, "getByNameLabel failed " + e0.toString(), false);	} catch (final Exception e0) {	
getbynamelabel failed 

try {	citrixResourceBase.rebootVM(conn, vm, vm.getNameLabel(conn));	} catch (final Exception e) {	final String msg = e.toString();	s_logger.warn(msg, e);	return new RebootAnswer(command, msg, false);	}	}	return new RebootAnswer(command, "reboot succeeded", true);	} finally {	
the vm is in running state 

========================= cloudstack sample_1201 =========================

private void closeStream() {	if (socketWrapper.shutdown) return;	if (verbose) System.out.println("[" + this + "] INFO: Closing stream.");	try {	sendEventToAllPads(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	
ignored failing sending sink event to all pads 

========================= cloudstack sample_5096 =========================

String secretKey = user.getSecretKey();	String csUrl = ApiServiceConfiguration.ApiServletPath.value();	String zoneId = _dcDao.findById(autoScaleVmProfile.getZoneId()).getUuid();	String domainId = _domainDao.findById(autoScaleVmProfile.getDomainId()).getUuid();	String serviceOfferingId = _offeringsDao.findById(autoScaleVmProfile.getServiceOfferingId()).getUuid();	String templateId = _templateDao.findById(autoScaleVmProfile.getTemplateId()).getUuid();	String vmName = "AutoScale-LB-" + lbName;	String lbNetworkUuid = null;	DataCenter zone = _entityMgr.findById(DataCenter.class, vmGroup.getZoneId());	if (zone == null) {	
unable to find zone while packaging autoscale vm group zoneid 

LbAutoScaleVmGroup lbAutoScaleVmGroup = getLbAutoScaleVmGroup(vmGroup, currentState, lb);	List<LbStickinessPolicy> policyList = getStickinessPolicies(lb.getId());	Ip sourceIp = getSourceIp(lb);	LoadBalancingRule rule = new LoadBalancingRule(lb, null, policyList, null, sourceIp, null, lb.getLbProtocol());	rule.setAutoScaleVmGroup(lbAutoScaleVmGroup);	if (!isRollBackAllowedForProvider(lb)) {	return false;	}	List<LoadBalancingRule> rules = Arrays.asList(rule);	if (!applyLbRules(rules, false)) {	
lb rules autoscale config are not completely applied 

if (vmGroup.getState().equals(AutoScaleVmGroup.State_New)) {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	} else if (loadBalancer.getState() == FirewallRule.State.Active && vmGroup.getState().equals(AutoScaleVmGroup.State_Revoke)) {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	}	try {	success = applyAutoScaleConfig(loadBalancer, vmGroup, currentState);	} catch (ResourceUnavailableException e) {	
unable to configure autoscalevmgroup to the lb rule because resource is unavaliable 

} else if (loadBalancer.getState() == FirewallRule.State.Active && vmGroup.getState().equals(AutoScaleVmGroup.State_Revoke)) {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	}	try {	success = applyAutoScaleConfig(loadBalancer, vmGroup, currentState);	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	
lb rollback rule id lb state rolback while creating autoscalevmgroup 

try {	success = applyAutoScaleConfig(loadBalancer, vmGroup, currentState);	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	}	throw e;	} finally {	if (!success) {	
failed to configure lb auto scale vm group with id 

throw e;	} finally {	if (!success) {	}	}	if (success) {	if (vmGroup.getState().equals(AutoScaleVmGroup.State_New)) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	loadBalancer.setState(FirewallRule.State.Active);	
lb rule state is set to active 

}	}	if (success) {	if (vmGroup.getState().equals(AutoScaleVmGroup.State_New)) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	loadBalancer.setState(FirewallRule.State.Active);	_lbDao.persist(loadBalancer);	vmGroup.setState(AutoScaleVmGroup.State_Enabled);	_autoScaleVmGroupDao.persist(vmGroup);	
lb auto scale vm group with id is set to enabled state 

if (vmGroup.getState().equals(AutoScaleVmGroup.State_New)) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	loadBalancer.setState(FirewallRule.State.Active);	_lbDao.persist(loadBalancer);	vmGroup.setState(AutoScaleVmGroup.State_Enabled);	_autoScaleVmGroupDao.persist(vmGroup);	}	});	}	
successfully configured lb autoscale vm group with id 

public boolean validateLbRule(LoadBalancingRule lbRule) {	Network network = _networkDao.findById(lbRule.getNetworkId());	Purpose purpose = lbRule.getPurpose();	if (purpose != Purpose.LoadBalancing) {	
unable to validate network rules for purpose 

_lbDao.persist(loadBalancer);	} else {	oldStickinessPolicyId = stickinessPolicy.getId();	stickinessPolicy.setRevoke(true);	_lb2stickinesspoliciesDao.persist(stickinessPolicy);	}	}	try {	applyLoadBalancerConfig(cmd.getLbRuleId());	} catch (ResourceUnavailableException e) {	
unable to apply stickiness policy to the lb rule because resource is unavaliable 

_lb2stickinesspoliciesDao.persist(stickinessPolicy);	}	}	try {	applyLoadBalancerConfig(cmd.getLbRuleId());	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	deleteLBStickinessPolicy(cmd.getEntityId(), false);	
lb rollback rule id lb state rolback while creating sticky policy 

deleteLBStickinessPolicy(cmd.getEntityId(), false);	} else {	deleteLBStickinessPolicy(cmd.getEntityId(), false);	if (oldStickinessPolicyId != 0) {	LBStickinessPolicyVO stickinessPolicy = _lb2stickinesspoliciesDao.findById(oldStickinessPolicyId);	stickinessPolicy.setRevoke(false);	_lb2stickinesspoliciesDao.persist(stickinessPolicy);	try {	if (backupState.equals(FirewallRule.State.Active)) applyLoadBalancerConfig(cmd.getLbRuleId());	} catch (ResourceUnavailableException e1) {	
ignored applying load balancer config 

LoadBalancerVO loadBalancer = _lbDao.findById(cmd.getLbRuleId());	if (loadBalancer == null) {	throw new InvalidParameterException("Invalid Load balancer Id:" + cmd.getLbRuleId());	}	FirewallRule.State backupState = loadBalancer.getState();	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	try {	applyLoadBalancerConfig(cmd.getLbRuleId());	} catch (ResourceUnavailableException e) {	
unable to apply healthcheck policy to the lb rule because resource is unavaliable 

}	FirewallRule.State backupState = loadBalancer.getState();	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	try {	applyLoadBalancerConfig(cmd.getLbRuleId());	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	
lb rollback rule id lb state rolback while creating healthcheck policy 

FirewallRule.State backupState = loadBalancer.getState();	_accountMgr.checkAccess(caller.getCallingAccount(), null, true, loadBalancer);	if (apply) {	if (loadBalancer.getState() == FirewallRule.State.Active) {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	}	boolean backupStickyState = stickinessPolicy.isRevoke();	stickinessPolicy.setRevoke(true);	_lb2stickinesspoliciesDao.persist(stickinessPolicy);	
set load balancer rule for revoke rule id stickinesspolicyid 

if (apply) {	if (loadBalancer.getState() == FirewallRule.State.Active) {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	}	boolean backupStickyState = stickinessPolicy.isRevoke();	stickinessPolicy.setRevoke(true);	_lb2stickinesspoliciesDao.persist(stickinessPolicy);	try {	if (!applyLoadBalancerConfig(loadBalancerId)) {	
failed to remove load balancer rule id for stickinesspolicyid 

try {	if (!applyLoadBalancerConfig(loadBalancerId)) {	throw new CloudRuntimeException("Failed to remove load balancer rule id " + loadBalancerId + " for stickinesspolicyID " + stickinessPolicyId);	}	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	stickinessPolicy.setRevoke(backupStickyState);	_lb2stickinesspoliciesDao.persist(stickinessPolicy);	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	
lb rollback rule id while deleting sticky policy 

if (!applyLoadBalancerConfig(loadBalancerId)) {	throw new CloudRuntimeException("Failed to remove load balancer rule id " + loadBalancerId + " for stickinesspolicyID " + stickinessPolicyId);	}	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	stickinessPolicy.setRevoke(backupStickyState);	_lb2stickinesspoliciesDao.persist(stickinessPolicy);	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	}	
unable to apply the load balancer config because resource is unavaliable 

FirewallRule.State backupState = loadBalancer.getState();	_accountMgr.checkAccess(caller.getCallingAccount(), null, true, loadBalancer);	if (apply) {	if (loadBalancer.getState() == FirewallRule.State.Active) {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	}	boolean backupStickyState = healthCheckPolicy.isRevoke();	healthCheckPolicy.setRevoke(true);	_lb2healthcheckDao.persist(healthCheckPolicy);	
set health check policy to revoke for loadbalancing rule id healthcheckpolicyid 

loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	}	boolean backupStickyState = healthCheckPolicy.isRevoke();	healthCheckPolicy.setRevoke(true);	_lb2healthcheckDao.persist(healthCheckPolicy);	final List<LoadBalancerVMMapVO> maps = _lb2VmMapDao.listByLoadBalancerId(loadBalancerId);	if (maps != null) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	
resetting health state policy for services in loadbalancing rule id 

public void doInTransactionWithoutResult(TransactionStatus status) {	for (LoadBalancerVMMapVO map : maps) {	map.setState(null);	_lb2VmMapDao.persist(map);	}	}	});	}	try {	if (!applyLoadBalancerConfig(loadBalancerId)) {	
failed to remove load balancer rule id for healthcheckpolicyid 

try {	if (!applyLoadBalancerConfig(loadBalancerId)) {	throw new CloudRuntimeException("Failed to remove load balancer rule id " + loadBalancerId + " for healthCheckpolicyID " + healthCheckPolicyId);	}	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	healthCheckPolicy.setRevoke(backupStickyState);	_lb2healthcheckDao.persist(healthCheckPolicy);	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	
lb rollback rule id while deleting healthcheck policy 

if (!applyLoadBalancerConfig(loadBalancerId)) {	throw new CloudRuntimeException("Failed to remove load balancer rule id " + loadBalancerId + " for healthCheckpolicyID " + healthCheckPolicyId);	}	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	healthCheckPolicy.setRevoke(backupStickyState);	_lb2healthcheckDao.persist(healthCheckPolicy);	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	}	
unable to apply the load balancer config because resource is unavaliable 

List<LoadBalancerVMMapVO> lbVmMaps = _lb2VmMapDao.listByLoadBalancerId(ulb.getId());	for (LoadBalancerVMMapVO lbVmMap : lbVmMaps) {	UserVm vm = _vmDao.findById(lbVmMap.getInstanceId());	Nic nic = _nicDao.findByInstanceIdAndNetworkIdIncludingRemoved(ulb.getNetworkId(), vm.getId());	String dstIp = lbVmMap.getInstanceIp() == null ? nic.getIPv4Address(): lbVmMap.getInstanceIp();	for (int i = 0; i < lbto.getDestinations().length; i++) {	LoadBalancerTO.DestinationTO des = lbto.getDestinations()[i];	if (dstIp.equalsIgnoreCase(lbto.getDestinations()[i].getDestIp())) {	lbVmMap.setState(des.getMonitorState());	_lb2VmMapDao.persist(lbVmMap);	
updating the lb vm map table with the service state 

vmIpsList = new ArrayList<String>();	vmIpsList.add(priIp);	}	if (instanceIds != null ) {	if (instanceIds.contains(instanceId)) {	vmIpsList.add(priIp);	}	}	vmIdIpMap.put(instanceId, vmIpsList);	if (s_logger.isDebugEnabled()) {	
adding to the load balancer pool 

return true;	}	boolean success = false;	FirewallRule.State backupState = loadBalancer.getState();	try {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	applyLoadBalancerConfig(loadBalancerId);	success = true;	} catch (ResourceUnavailableException e) {	
unable to apply the load balancer config because resource is unavaliable 

final List<Long> vmInstanceIds = new ArrayList<Long>();	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	for (Long vmId : vmIds) {	vmInstanceIds.add(vmId);	}	}	});	if (!vmInstanceIds.isEmpty()) {	_lb2VmMapDao.remove(loadBalancer.getId(), vmInstanceIds, null);	
lb rollback rule id while attaching vm 

public boolean assignSSLCertToLoadBalancerRule(Long lbId, String certName, String publicCert, String privateKey) {	
calling the manager for lb 

public LbSslCert getLbSslCert(long lbRuleId) {	LoadBalancerCertMapVO lbCertMap = _lbCertMapDao.findByLbRuleId(lbRuleId);	if (lbCertMap == null) return null;	SslCertVO certVO = _entityMgr.findById(SslCertVO.class, lbCertMap.getCertId());	if (certVO == null) {	
cert rule with cert id but cert is not found 

LoadBalancerCertMapVO certMap = new LoadBalancerCertMapVO(lbRuleId, certId, false);	_lbCertMapDao.persist(certMap);	applyLoadBalancerConfig(loadBalancer.getId());	success = true;	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	LoadBalancerCertMapVO certMap = _lbCertMapDao.findByLbRuleId(lbRuleId);	_lbCertMapDao.remove(certMap.getId());	
lb rollback rule id while adding cert 

_lbCertMapDao.persist(certMap);	applyLoadBalancerConfig(loadBalancer.getId());	success = true;	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	LoadBalancerCertMapVO certMap = _lbCertMapDao.findByLbRuleId(lbRuleId);	_lbCertMapDao.remove(certMap.getId());	}	
unable to apply the load balancer config because resource is unavaliable 

}	_accountMgr.checkAccess(caller.getCallingAccount(), null, true, loadBalancer);	boolean success = false;	FirewallRule.State backupState = loadBalancer.getState();	try {	loadBalancer.setState(FirewallRule.State.Add);	_lbDao.persist(loadBalancer);	lbCertMap.setRevoke(true);	_lbCertMapDao.persist(lbCertMap);	if (!applyLoadBalancerConfig(lbRuleId)) {	
failed to remove cert from load balancer rule id 

ex.addProxyObject(loadBalancer.getUuid(), "loadBalancerId");	throw ex;	}	success = true;	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	lbCertMap.setRevoke(false);	_lbCertMapDao.persist(lbCertMap);	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	
rolled back certificate removal lb id 

throw ex;	}	success = true;	} catch (ResourceUnavailableException e) {	if (isRollBackAllowedForProvider(loadBalancer)) {	lbCertMap.setRevoke(false);	_lbCertMapDao.persist(lbCertMap);	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	}	
unable to apply the load balancer config because resource is unavaliable 

List<String> lbVmIps = vmIdIpMap.get(instanceId);	if (lbVmIps == null || lbVmIps.isEmpty()) {	List<LoadBalancerVMMapVO> lbVms = _lb2VmMapDao.listByLoadBalancerIdAndVmId(loadBalancerId, instanceId);	if (lbVms == null) {	throw new InvalidParameterValueException("The instance id: "+ instanceId +" is not configured " + " for LB rule id " + loadBalancerId);	}	for (LoadBalancerVMMapVO lbvm: lbVms) {	lbvm.setRevoke(true);	_lb2VmMapDao.persist(lbvm);	}	
set load balancer rule for revoke rule id vmid 

_lb2VmMapDao.persist(lbvm);	}	} else {	for (String vmIp: lbVmIps) {	LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmIdVmIp (loadBalancerId, instanceId, vmIp);	if (map == null) {	throw new InvalidParameterValueException("The instance id: "+ instanceId +" is not configured " + " for LB rule id " + loadBalancerId);	}	map.setRevoke(true);	_lb2VmMapDao.persist(map);	
set load balancer rule for revoke rule id vmid vmip 

map.setRevoke(true);	_lb2VmMapDao.persist(map);	}	}	}	if (_autoScaleVmGroupDao.isAutoScaleLoadBalancer(loadBalancerId)) {	_lb2VmMapDao.remove(loadBalancer.getId(), instanceIds, null);	return true;	}	if (!applyLoadBalancerConfig(loadBalancerId)) {	
failed to remove load balancer rule id for vms 

}	success = true;	} catch (ResourceUnavailableException e) {	if (rollBack && isRollBackAllowedForProvider(loadBalancer)) {	for (long instanceId : vmIds) {	List<String> lbVmIps = vmIdIpMap.get(instanceId);	if (lbVmIps == null || lbVmIps.isEmpty()) {	LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmId(loadBalancerId, instanceId);	map.setRevoke(false);	_lb2VmMapDao.persist(map);	
lb rollback rule id while removing vmid 

List<String> lbVmIps = vmIdIpMap.get(instanceId);	if (lbVmIps == null || lbVmIps.isEmpty()) {	LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmId(loadBalancerId, instanceId);	map.setRevoke(false);	_lb2VmMapDao.persist(map);	}else {	for (String vmIp: lbVmIps) {	LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmIdVmIp (loadBalancerId, instanceId, vmIp);	map.setRevoke(true);	_lb2VmMapDao.persist(map);	
lb rollback rule id while removing vmid vmip 

}else {	for (String vmIp: lbVmIps) {	LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmIdVmIp (loadBalancerId, instanceId, vmIp);	map.setRevoke(true);	_lb2VmMapDao.persist(map);	}	}	}	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	
lb rollback rule id while removing vm instances 

for (String vmIp: lbVmIps) {	LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmIdVmIp (loadBalancerId, instanceId, vmIp);	map.setRevoke(true);	_lb2VmMapDao.persist(map);	}	}	}	loadBalancer.setState(backupState);	_lbDao.persist(loadBalancer);	}	
unable to apply the load balancer config because resource is unavaliable 

for (LoadBalancerVMMapVO map : maps) {	long lbId = map.getLoadBalancerId();	List<Long> instances = lbsToReconfigure.get(lbId);	if (instances == null) {	instances = new ArrayList<Long>();	}	instances.add(map.getInstanceId());	lbsToReconfigure.put(lbId, instances);	map.setRevoke(true);	_lb2VmMapDao.persist(map);	
set load balancer rule for revoke rule id vmid 

boolean removeResult = removeCertFromLoadBalancer(loadBalancerId);	if (!removeResult) {	throw new CloudRuntimeException("Unable to remove certificate from load balancer rule " + loadBalancerId);	}	}	List<LoadBalancerVMMapVO> backupMaps = Transaction.execute(new TransactionCallback<List<LoadBalancerVMMapVO>>() {	public List<LoadBalancerVMMapVO> doInTransaction(TransactionStatus status) {	boolean generateUsageEvent = false;	if (lb.getState() == FirewallRule.State.Staged) {	if (s_logger.isDebugEnabled()) {	
found a rule that is still in stage state so just removing it 

lb.setState(FirewallRule.State.Revoke);	_lbDao.persist(lb);	generateUsageEvent = true;	}	List<LoadBalancerVMMapVO> backupMaps = _lb2VmMapDao.listByLoadBalancerId(loadBalancerId);	List<LoadBalancerVMMapVO> maps = _lb2VmMapDao.listByLoadBalancerId(loadBalancerId);	if (maps != null) {	for (LoadBalancerVMMapVO map : maps) {	map.setRevoke(true);	_lb2VmMapDao.persist(map);	
set load balancer rule for revoke rule id vmid 

});	NetworkVO network = _networkDao.findById(lb.getNetworkId());	if (network != null) {	if (_networkModel.networkIsConfiguredForExternalNetworking(network.getDataCenterId(), network.getId())) {	_externalDeviceUsageMgr.updateExternalLoadBalancerNetworkUsageStats(loadBalancerId);	}	}	if (apply) {	try {	if (!applyLoadBalancerConfig(loadBalancerId)) {	
unable to apply the load balancer config 

if (apply) {	try {	if (!applyLoadBalancerConfig(loadBalancerId)) {	return false;	}	} catch (ResourceUnavailableException e) {	if (rollBack && isRollBackAllowedForProvider(lb)) {	if (backupMaps != null) {	for (LoadBalancerVMMapVO map : backupMaps) {	_lb2VmMapDao.persist(map);	
lb rollback rule id vmid 

}	} catch (ResourceUnavailableException e) {	if (rollBack && isRollBackAllowedForProvider(lb)) {	if (backupMaps != null) {	for (LoadBalancerVMMapVO map : backupMaps) {	_lb2VmMapDao.persist(map);	}	}	lb.setState(backupState);	_lbDao.persist(lb);	
lb rollback rule id while deleting lb rule 

} catch (ResourceUnavailableException e) {	if (rollBack && isRollBackAllowedForProvider(lb)) {	if (backupMaps != null) {	for (LoadBalancerVMMapVO map : backupMaps) {	_lb2VmMapDao.persist(map);	}	}	lb.setState(backupState);	_lbDao.persist(lb);	} else {	
unable to apply the load balancer config because resource is unavaliable 

return false;	}	}	FirewallRuleVO relatedRule = _firewallDao.findByRelatedId(lb.getId());	if (relatedRule != null) {	s_logger.warn("Unable to remove firewall rule id=" + lb.getId() + " as it has related firewall rule id=" + relatedRule.getId() + "; leaving it in Revoke state");	return false;	} else {	_firewallMgr.removeRule(lb);	}	
load balancer with id is removed successfully 

performedIpAssoc = true;	}	} else {	_networkModel.checkIpForService(ipVO, Service.Lb, null);	}	if (ipVO.getAssociatedWithNetworkId() == null) {	throw new InvalidParameterValueException("Ip address " + ipVO + " is not assigned to the network " + network);	}	result = createPublicLoadBalancer(xId, name, description, srcPortStart, defPortStart, ipVO.getId(), protocol, algorithm, openFirewall, CallContext.current(), lbProtocol, forDisplay);	} catch (Exception ex) {	
failed to create load balancer due to 

result = createPublicLoadBalancer(xId, name, description, srcPortStart, defPortStart, ipVO.getId(), protocol, algorithm, openFirewall, CallContext.current(), lbProtocol, forDisplay);	} catch (Exception ex) {	if (ex instanceof NetworkRuleConflictException) {	throw (NetworkRuleConflictException)ex;	}	if (ex instanceof InvalidParameterValueException) {	throw (InvalidParameterValueException)ex;	}	} finally {	if (result == null && systemIp != null) {	
releasing system ip address as corresponding lb rule failed to create 

protected boolean applyLoadBalancerRules(List<LoadBalancerVO> lbs, boolean updateRulesInDB) throws ResourceUnavailableException {	List<LoadBalancingRule> rules = new ArrayList<LoadBalancingRule>();	for (LoadBalancerVO lb : lbs) {	rules.add(getLoadBalancerRuleToApply(lb));	}	if (!applyLbRules(rules, false)) {	
lb rules are not completely applied 

if (!applyLbRules(rules, false)) {	return false;	}	if (updateRulesInDB) {	for (final LoadBalancerVO lb : lbs) {	boolean checkForReleaseElasticIp = Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean checkForReleaseElasticIp = false;	if (lb.getState() == FirewallRule.State.Revoke) {	removeLBRule(lb);	
lb is successfully removed 

if (updateRulesInDB) {	for (final LoadBalancerVO lb : lbs) {	boolean checkForReleaseElasticIp = Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean checkForReleaseElasticIp = false;	if (lb.getState() == FirewallRule.State.Revoke) {	removeLBRule(lb);	checkForReleaseElasticIp = true;	} else if (lb.getState() == FirewallRule.State.Add) {	lb.setState(FirewallRule.State.Active);	
lb rule state is set to active 

checkForReleaseElasticIp = true;	} else if (lb.getState() == FirewallRule.State.Add) {	lb.setState(FirewallRule.State.Active);	_lbDao.persist(lb);	}	List<LoadBalancerVMMapVO> lbVmMaps = _lb2VmMapDao.listByLoadBalancerId(lb.getId(), true);	List<Long> instanceIds = new ArrayList<Long>();	for (LoadBalancerVMMapVO lbVmMap : lbVmMaps) {	instanceIds.add(lbVmMap.getInstanceId());	_lb2VmMapDao.remove(lb.getId(), lbVmMap.getInstanceId(), lbVmMap.getInstanceIp(), null);	
load balancer rule id is removed for vm instance ip 

}	List<LoadBalancerVMMapVO> lbVmMaps = _lb2VmMapDao.listByLoadBalancerId(lb.getId(), true);	List<Long> instanceIds = new ArrayList<Long>();	for (LoadBalancerVMMapVO lbVmMap : lbVmMaps) {	instanceIds.add(lbVmMap.getInstanceId());	_lb2VmMapDao.remove(lb.getId(), lbVmMap.getInstanceId(), lbVmMap.getInstanceIp(), null);	}	if (_lb2VmMapDao.listByLoadBalancerId(lb.getId()).isEmpty()) {	lb.setState(FirewallRule.State.Add);	_lbDao.persist(lb);	
lb rule state is set to add as there are no more active lb vm mappings 

instanceIds.add(lbVmMap.getInstanceId());	_lb2VmMapDao.remove(lb.getId(), lbVmMap.getInstanceId(), lbVmMap.getInstanceIp(), null);	}	if (_lb2VmMapDao.listByLoadBalancerId(lb.getId()).isEmpty()) {	lb.setState(FirewallRule.State.Add);	_lbDao.persist(lb);	}	List<LBStickinessPolicyVO> stickinesspolicies = _lb2stickinesspoliciesDao.listByLoadBalancerId(lb.getId(), true);	if (!stickinesspolicies.isEmpty()) {	_lb2stickinesspoliciesDao.remove(lb.getId(), true);	
load balancer rule id is removed stickiness policies 

lb.setState(FirewallRule.State.Add);	_lbDao.persist(lb);	}	List<LBStickinessPolicyVO> stickinesspolicies = _lb2stickinesspoliciesDao.listByLoadBalancerId(lb.getId(), true);	if (!stickinesspolicies.isEmpty()) {	_lb2stickinesspoliciesDao.remove(lb.getId(), true);	}	List<LBHealthCheckPolicyVO> healthCheckpolicies = _lb2healthcheckDao.listByLoadBalancerId(lb.getId(), true);	if (!healthCheckpolicies.isEmpty()) {	_lb2healthcheckDao.remove(lb.getId(), true);	
load balancer rule id is removed health check monitors policies 

if (!stickinesspolicies.isEmpty()) {	_lb2stickinesspoliciesDao.remove(lb.getId(), true);	}	List<LBHealthCheckPolicyVO> healthCheckpolicies = _lb2healthcheckDao.listByLoadBalancerId(lb.getId(), true);	if (!healthCheckpolicies.isEmpty()) {	_lb2healthcheckDao.remove(lb.getId(), true);	}	LoadBalancerCertMapVO lbCertMap = _lbCertMapDao.findByLbRuleId(lb.getId());	if (lbCertMap != null && lbCertMap.isRevoke()) {	_lbCertMapDao.remove(lbCertMap.getId());	
load balancer rule id removed certificate mapping 

return checkForReleaseElasticIp;	}	});	if (checkForReleaseElasticIp && lb.getSourceIpAddressId() != null) {	boolean success = true;	long count = _firewallDao.countRulesByIpId(lb.getSourceIpAddressId());	if (count == 0) {	try {	success = handleSystemLBIpRelease(lb);	} catch (Exception ex) {	
failed to release system ip as a part of lb rule deletion due to exception 

if (checkForReleaseElasticIp && lb.getSourceIpAddressId() != null) {	boolean success = true;	long count = _firewallDao.countRulesByIpId(lb.getSourceIpAddressId());	if (count == 0) {	try {	success = handleSystemLBIpRelease(lb);	} catch (Exception ex) {	success = false;	} finally {	if (!success) {	
failed to release system ip as a part of lb rule deletion 

protected boolean handleSystemLBIpRelease(LoadBalancerVO lb) {	IpAddress ip = _ipAddressDao.findById(lb.getSourceIpAddressId());	boolean success = true;	if (ip.getSystem()) {	
releasing system ip address as a part of delete lb rule 

public boolean removeAllLoadBalanacersForIp(long ipId, Account caller, long callerUserId) {	List<FirewallRuleVO> rules = _firewallDao.listByIpAndPurposeAndNotRevoked(ipId, Purpose.LoadBalancing);	if (rules != null) {	
found lb rules to cleanup 

public boolean removeAllLoadBalanacersForIp(long ipId, Account caller, long callerUserId) {	List<FirewallRuleVO> rules = _firewallDao.listByIpAndPurposeAndNotRevoked(ipId, Purpose.LoadBalancing);	if (rules != null) {	for (FirewallRule rule : rules) {	boolean result = deleteLoadBalancerRule(rule.getId(), true, caller, callerUserId, false);	if (result == false) {	
unable to remove load balancer rule 

public boolean removeAllLoadBalanacersForNetwork(long networkId, Account caller, long callerUserId) {	List<FirewallRuleVO> rules = _firewallDao.listByNetworkAndPurposeAndNotRevoked(networkId, Purpose.LoadBalancing);	if (rules != null) {	
found lb rules to cleanup 

public boolean removeAllLoadBalanacersForNetwork(long networkId, Account caller, long callerUserId) {	List<FirewallRuleVO> rules = _firewallDao.listByNetworkAndPurposeAndNotRevoked(networkId, Purpose.LoadBalancing);	if (rules != null) {	for (FirewallRule rule : rules) {	boolean result = deleteLoadBalancerRule(rule.getId(), true, caller, callerUserId, false);	if (result == false) {	
unable to remove load balancer rule 

}	if (lbBackup.getDescription() != null) {	lb.setDescription(lbBackup.getDescription());	}	if (lbBackup.getAlgorithm() != null) {	lb.setAlgorithm(lbBackup.getAlgorithm());	}	lb.setState(lbBackup.getState());	_lbDao.update(lb.getId(), lb);	_lbDao.persist(lb);	
lb rollback rule id while updating lb rule 

if (lbBackup.getDescription() != null) {	lb.setDescription(lbBackup.getDescription());	}	if (lbBackup.getAlgorithm() != null) {	lb.setAlgorithm(lbBackup.getAlgorithm());	}	lb.setState(lbBackup.getState());	_lbDao.update(lb.getId(), lb);	_lbDao.persist(lb);	}	
unable to apply the load balancer config because resource is unavaliable 

public boolean applyLbRules(List<LoadBalancingRule> rules, boolean continueOnError) throws ResourceUnavailableException {	if (rules == null || rules.size() == 0) {	
there are no load balancing rules to forward to the network elements 

publicIps.add(publicIp);	}	}	_ipAddrMgr.applyIpAssociations(network, false, continueOnError, publicIps);	try {	applyLbRules(network, rules);	} catch (ResourceUnavailableException e) {	if (!continueOnError) {	throw e;	}	
problems with applying load balancing rules but pushing on 

========================= cloudstack sample_2303 =========================

api.setResponseType(ResponseType.EMPTY);	}	verify = true;	}	if (this.denyToExecute()) {	api.setResponseType(ResponseType.ERROR);	}	}	api.sendCommand(this.getClient(), null);	if ((verify == true) && !(api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	
test case failed command that was supposed to fail passed the command was sent with the following url 

verify = true;	}	if (this.denyToExecute()) {	api.setResponseType(ResponseType.ERROR);	}	}	api.sendCommand(this.getClient(), null);	if ((verify == true) && !(api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	error++;	} else if ((verify == true) && (api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	
test case passed 

}	if (this.denyToExecute()) {	api.setResponseType(ResponseType.ERROR);	}	}	api.sendCommand(this.getClient(), null);	if ((verify == true) && !(api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	error++;	} else if ((verify == true) && (api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	} else if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	
test case failed command that was supposed to fail passed the command was sent with the following url 

}	}	api.sendCommand(this.getClient(), null);	if ((verify == true) && !(api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	error++;	} else if ((verify == true) && (api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	} else if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use the command was sent with url 

api.sendCommand(this.getClient(), null);	if ((verify == true) && !(api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	error++;	} else if ((verify == true) && (api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	} else if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	
test case passed 

error++;	} else if ((verify == true) && (api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	} else if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	
test case failed with an error code command was sent with url 

} else if ((verify == true) && (api.getResponseType() == ResponseType.ERROR || api.getResponseType() == ResponseType.EMPTY)) {	} else if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	
the command is required for the future use so exiging 

if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	return false;	}	error++;	} else if (api.getTestCaseInfo() != null) {	
test case passed 

========================= cloudstack sample_448 =========================

vspNetworkBuilder.firewallServiceSupported(firewallServiceSupported);	String preConfiguredDomainTemplateName = NuageVspUtil.getPreConfiguredDomainTemplateName(_configurationDao, _networkDetailsDao, network, networkOffering);	vspNetworkBuilder.domainTemplateName(preConfiguredDomainTemplateName);	if (fillAddressRange) {	try {	List<Pair<String, String>> ipAddressRanges = getIpAddressRanges(networkOffering, network);	vspNetworkBuilder.ipAddressRanges(ipAddressRanges);	String virtualRouterIp = getVirtualRouterIP(network, ipAddressRanges);	vspNetworkBuilder.virtualRouterIp(virtualRouterIp);	} catch (InsufficientVirtualNetworkCapacityException ex) {	
there is an insufficient network capacity in network 

========================= cloudstack sample_1485 =========================

cpuoverprov = configData.getString(1);	}	}	String memoverprov = "1";	selectConfiguration.setString(1, "mem.overprovisioning.factor");	try (ResultSet configData = selectConfiguration.executeQuery()) {	if (configData.next()) {	memoverprov = configData.getString(1);	}	}	
starting updating user vm details with cpu memory overprovisioning factors 

pstmt3.setString(2, "cpuOvercommitRatio");	pstmt3.setString(3, cpuoverprov);	pstmt3.executeUpdate();	pstmt3.setLong(1, result2.getLong(1));	pstmt3.setString(2, "memoryOvercommitRatio");	pstmt3.setString(3, "1");	pstmt3.executeUpdate();	}	}	}	
done updating user vm details with cpu memory overprovisioning factors 

private void upgradeResourceCount(Connection conn) {	
upgraderesourcecount start 

String resource_type = resource_types[count];	pstmtSelectAccountCount.setString(1, resource_type);	try (ResultSet rsAccountCount = pstmtSelectAccountCount.executeQuery();) {	while (rsAccountCount.next()) {	long domain_id = rsAccountCount.getLong(1);	long resource_count = rsAccountCount.getLong(2);	upgradeResourceCountforDomain(conn, domain_id, resource_type, resource_count);	}	}	}	
upgraderesourcecount finish 

========================= cloudstack sample_4238 =========================

public void execute() {	CallContext.current().setEventDetails("AutoScale Vm Group Id: " + getId());	boolean result = _autoScaleService.deleteAutoScaleVmGroup(id);	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	
failed to delete autoscale vm group 

========================= cloudstack sample_3457 =========================

params.put("url", url.toString());	params.put("username", username);	params.put("password", password);	params.put("zone", Long.toString(dcId));	params.put("guid", UUID.randomUUID().toString());	params.put("pod", Long.toString(podId));	DummyHostServerResource resource = new DummyHostServerResource();	try {	resource.configure("Dummy Host Server", params);	} catch (ConfigurationException e) {	
unable to instantiate dummy host server resource 

========================= cloudstack sample_2616 =========================

String tags = (String)dsInfos.get("tags");	Map<String, String> details = (Map<String, String>)dsInfos.get("details");	parameters.setTags(tags);	parameters.setDetails(details);	String scheme = uri.getScheme();	String storageHost = uri.getHost();	String hostPath = null;	try {	hostPath = URLDecoder.decode(uri.getPath(), "UTF-8");	} catch (UnsupportedEncodingException e) {	
ignored we are on a platform not supporting 

hostPath = uri.getPath();	}	Object localStorage = dsInfos.get("localStorage");	if (localStorage != null) {	hostPath = hostPath.replaceFirst("/", "");	hostPath = hostPath.replace("+", " ");	}	String userInfo = uri.getUserInfo();	int port = uri.getPort();	if (s_logger.isDebugEnabled()) {	
createpool params scheme storagehost hostpath port 

parameters.setPort(port);	parameters.setPath(hostPath);	} else {	StoragePoolType type = Enum.valueOf(StoragePoolType.class, scheme);	if (type != null) {	parameters.setType(type);	parameters.setHost(storageHost);	parameters.setPort(0);	parameters.setPath(hostPath);	} else {	
unable to figure out the scheme for uri 

} else if (scheme.equalsIgnoreCase("sharedmountpoint") || scheme.equalsIgnoreCase("clvm")) {	uuid = UUID.randomUUID().toString();	} else if (scheme.equalsIgnoreCase("PreSetup")) {	uuid = hostPath.replace("/", "");	} else {	uuid = UUID.nameUUIDFromBytes((storageHost + hostPath).getBytes()).toString();	}	List<StoragePoolVO> spHandles = primaryDataStoreDao.findIfDuplicatePoolsExistByUUID(uuid);	if ((spHandles != null) && (spHandles.size() > 0)) {	if (s_logger.isDebugEnabled()) {	
another active pool with the same uuid already exists 

protected boolean createStoragePool(long hostId, StoragePool pool) {	
creating pool on host 

protected boolean createStoragePool(long hostId, StoragePool pool) {	if (pool.getPoolType() != StoragePoolType.NetworkFilesystem && pool.getPoolType() != StoragePoolType.Filesystem && pool.getPoolType() != StoragePoolType.IscsiLUN && pool.getPoolType() != StoragePoolType.Iscsi && pool.getPoolType() != StoragePoolType.VMFS && pool.getPoolType() != StoragePoolType.SharedMountPoint && pool.getPoolType() != StoragePoolType.PreSetup && pool.getPoolType() != StoragePoolType.OCFS2 && pool.getPoolType() != StoragePoolType.RBD && pool.getPoolType() != StoragePoolType.CLVM && pool.getPoolType() != StoragePoolType.SMB && pool.getPoolType() != StoragePoolType.Gluster) {	
doesn t support storage pool type 

public boolean attachCluster(DataStore store, ClusterScope scope) {	PrimaryDataStoreInfo primarystore = (PrimaryDataStoreInfo)store;	List<HostVO> allHosts = _resourceMgr.listAllUpAndEnabledHosts(Host.Type.Routing, primarystore.getClusterId(), primarystore.getPodId(), primarystore.getDataCenterId());	if (allHosts.isEmpty()) {	primaryDataStoreDao.expunge(primarystore.getId());	throw new CloudRuntimeException("No host up to associate a storage pool with in cluster " + primarystore.getClusterId());	}	if (primarystore.getPoolType() == StoragePoolType.OCFS2 && !_ocfs2Mgr.prepareNodes(allHosts, primarystore)) {	
can not create storage pool on cluster 

primaryDataStoreDao.expunge(primarystore.getId());	return false;	}	boolean success = false;	for (HostVO h : allHosts) {	success = createStoragePool(h.getId(), primarystore);	if (success) {	break;	}	}	
in createpool adding the pool to each of the hosts 

}	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO h : allHosts) {	try {	storageMgr.connectHostToSharedPool(h.getId(), primarystore.getId());	poolHosts.add(h);	} catch (StorageConflictException se) {	primaryDataStoreDao.expunge(primarystore.getId());	throw new CloudRuntimeException("Storage has already been added as local storage");	} catch (Exception e) {	
unable to establish a connection between and 

try {	storageMgr.connectHostToSharedPool(h.getId(), primarystore.getId());	poolHosts.add(h);	} catch (StorageConflictException se) {	primaryDataStoreDao.expunge(primarystore.getId());	throw new CloudRuntimeException("Storage has already been added as local storage");	} catch (Exception e) {	}	}	if (poolHosts.isEmpty()) {	
no host can access storage pool on cluster 

public boolean attachZone(DataStore dataStore, ZoneScope scope, HypervisorType hypervisorType) {	List<HostVO> hosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(hypervisorType, scope.getScopeId());	
in createpool attaching the pool to each of the hosts 

List<HostVO> hosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(hypervisorType, scope.getScopeId());	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO host : hosts) {	try {	storageMgr.connectHostToSharedPool(host.getId(), dataStore.getId());	poolHosts.add(host);	} catch (StorageConflictException se) {	primaryDataStoreDao.expunge(dataStore.getId());	throw new CloudRuntimeException("Storage has already been added as local storage to host: " + host.getName());	} catch (Exception e) {	
unable to establish a connection between and 

try {	storageMgr.connectHostToSharedPool(host.getId(), dataStore.getId());	poolHosts.add(host);	} catch (StorageConflictException se) {	primaryDataStoreDao.expunge(dataStore.getId());	throw new CloudRuntimeException("Storage has already been added as local storage to host: " + host.getName());	} catch (Exception e) {	}	}	if (poolHosts.isEmpty()) {	
no host can access storage pool in this zone 

for (StoragePoolHostVO host : hostPoolRecords) {	DeleteStoragePoolCommand deleteCmd = new DeleteStoragePoolCommand(pool);	final Answer answer = agentMgr.easySend(host.getHostId(), deleteCmd);	if (answer != null && answer.getResult()) {	deleteFlag = true;	if (HypervisorType.KVM != hType) {	break;	}	} else {	if (answer != null) {	
failed to delete storage pool 

========================= cloudstack sample_1939 =========================

public Status investigate(final long hostId) {	final HostVO host = _hostDao.findById(hostId);	if (host == null) {	return Status.Alert;	}	Status hostState = null;	for (Investigator investigator : investigators) {	hostState = investigator.isAgentAlive(host);	if (hostState != null) {	if (s_logger.isDebugEnabled()) {	
was able to determine host is in 

}	Status hostState = null;	for (Investigator investigator : investigators) {	hostState = investigator.isAgentAlive(host);	if (hostState != null) {	if (s_logger.isDebugEnabled()) {	}	return hostState;	}	if (s_logger.isDebugEnabled()) {	
unable to determine the state of the host moving on 

public void scheduleRestartForVmsOnHost(final HostVO host, boolean investigate) {	if (host.getType() != Host.Type.Routing) {	return;	}	if (host.getHypervisorType() == HypervisorType.VMware || host.getHypervisorType() == HypervisorType.Hyperv) {	
don t restart vms on host as it is a host 

public void scheduleRestartForVmsOnHost(final HostVO host, boolean investigate) {	if (host.getType() != Host.Type.Routing) {	return;	}	if (host.getHypervisorType() == HypervisorType.VMware || host.getHypervisorType() == HypervisorType.Hyperv) {	return;	}	
scheduling restart for vms on host 

}	}	}	HostPodVO podVO = _podDao.findById(host.getPodId());	String hostDesc = "name: " + host.getName() + " (id:" + host.getId() + "), availability zone: " + dcVO.getName() + ", pod: " + podVO.getName();	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Host is down, " + hostDesc, "Host [" + hostDesc + "] is down." + ((sb != null) ? sb.toString() : ""));	for (VMInstanceVO vm : reorderedVMList) {	ServiceOfferingVO vmOffering = _serviceOfferingDao.findById(vm.getServiceOfferingId());	if (vmOffering.getUseLocalStorage()) {	if (s_logger.isDebugEnabled()){	
skipping ha on vm because it uses local storage its fate is tied to the host 

String hostDesc = "name: " + host.getName() + " (id:" + host.getId() + "), availability zone: " + dcVO.getName() + ", pod: " + podVO.getName();	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Host is down, " + hostDesc, "Host [" + hostDesc + "] is down." + ((sb != null) ? sb.toString() : ""));	for (VMInstanceVO vm : reorderedVMList) {	ServiceOfferingVO vmOffering = _serviceOfferingDao.findById(vm.getServiceOfferingId());	if (vmOffering.getUseLocalStorage()) {	if (s_logger.isDebugEnabled()){	}	continue;	}	if (s_logger.isDebugEnabled()) {	
notifying ha mgr of to restart vm 

if (vmOffering.getUseLocalStorage()) {	if (s_logger.isDebugEnabled()){	}	continue;	}	if (s_logger.isDebugEnabled()) {	}	vm = _instanceDao.findByUuid(vm.getUuid());	Long hostId = vm.getHostId();	if (hostId != null && !hostId.equals(host.getId())) {	
vm is not on down host it is on other host vm ha is done 

public void scheduleStop(VMInstanceVO vm, long hostId, WorkType type) {	assert (type == WorkType.CheckStop || type == WorkType.ForceStop || type == WorkType.Stop);	if (_haDao.hasBeenScheduled(vm.getId(), type)) {	
there s already a job scheduled to stop 

public void scheduleStop(VMInstanceVO vm, long hostId, WorkType type) {	assert (type == WorkType.CheckStop || type == WorkType.ForceStop || type == WorkType.Stop);	if (_haDao.hasBeenScheduled(vm.getId(), type)) {	return;	}	HaWorkVO work = new HaWorkVO(vm.getId(), vm.getType(), type, Step.Scheduled, hostId, vm.getState(), 0, vm.getUpdated());	_haDao.persist(work);	if (s_logger.isDebugEnabled()) {	
scheduled 

public void scheduleRestart(VMInstanceVO vm, boolean investigate) {	Long hostId = vm.getHostId();	if (hostId == null) {	try {	
found a vm that is scheduled to be restarted but has no host id 

throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	} catch (OperationTimedoutException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	} catch (ConcurrentOperationException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	}	}	if (vm.getHypervisorType() == HypervisorType.VMware || vm.getHypervisorType() == HypervisorType.Hyperv) {	
skip ha for vmware vm or hyperv vm 

} catch (ConcurrentOperationException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	}	}	if (vm.getHypervisorType() == HypervisorType.VMware || vm.getHypervisorType() == HypervisorType.Hyperv) {	return;	}	if (!investigate) {	if (s_logger.isDebugEnabled()) {	
vm does not require investigation so i m marking it as stopped 

alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER;	} else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {	alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY;	} else if (VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) {	alertType = AlertManager.AlertType.ALERT_TYPE_SSVM;	}	if (!(_forceHA || vm.isHaEnabled())) {	String hostDesc = "id:" + vm.getHostId() + ", availability zone id:" + vm.getDataCenterId() + ", pod id:" + vm.getPodIdToDeployIn();	_alertMgr.sendAlert(alertType, vm.getDataCenterId(), vm.getPodIdToDeployIn(), "VM (name: " + vm.getHostName() + ", id: " + vm.getId() + ") stopped unexpectedly on host " + hostDesc, "Virtual Machine " + vm.getHostName() + " (id: " + vm.getId() + ") running on host [" + vm.getHostId() + "] stopped unexpectedly.");	if (s_logger.isDebugEnabled()) {	
vm is not ha enabled so we re done 

throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	} catch (OperationTimedoutException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	} catch (ConcurrentOperationException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	}	}	if (vm.getHypervisorType() == HypervisorType.VMware) {	
skip ha for vmware vm 

timesTried = item.getTimesTried();	break;	}	}	if (hostId == null) {	hostId = vm.getLastHostId();	}	HaWorkVO work = new HaWorkVO(vm.getId(), vm.getType(), WorkType.HA, investigate ? Step.Investigating : Step.Scheduled, hostId != null ? hostId : 0L, vm.getState(), timesTried, vm.getUpdated());	_haDao.persist(work);	if (s_logger.isInfoEnabled()) {	
schedule vm for ha 

for (HaWorkVO item : items) {	str.append(item.getId()).append(", ");	}	str.delete(str.length() - 2, str.length()).append("]");	s_logger.info(str.toString());	return (System.currentTimeMillis() >> 10) + _investigateRetryInterval;	}	long vmId = work.getInstanceId();	VirtualMachine vm = _itMgr.findById(work.getInstanceId());	if (vm == null) {	
unable to find vm 

}	str.delete(str.length() - 2, str.length()).append("]");	s_logger.info(str.toString());	return (System.currentTimeMillis() >> 10) + _investigateRetryInterval;	}	long vmId = work.getInstanceId();	VirtualMachine vm = _itMgr.findById(work.getInstanceId());	if (vm == null) {	return null;	}	
ha on 

} else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {	alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY;	} else if (VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) {	alertType = AlertManager.AlertType.ALERT_TYPE_SSVM;	}	HostVO host = _hostDao.findById(work.getHostId());	boolean isHostRemoved = false;	if (host == null) {	host = _hostDao.findByIdIncludingRemoved(work.getHostId());	if (host != null) {	
vm is now no longer on host as the host is removed 

isHostRemoved = true;	}	}	DataCenterVO dcVO = _dcDao.findById(host.getDataCenterId());	HostPodVO podVO = _podDao.findById(host.getPodId());	String hostDesc = "name: " + host.getName() + "(id:" + host.getId() + "), availability zone: " + dcVO.getName() + ", pod: " + podVO.getName();	Boolean alive = null;	if (work.getStep() == Step.Investigating) {	if (!isHostRemoved) {	if (vm.getHostId() == null || vm.getHostId() != work.getHostId()) {	
vm is now no longer on host 

if (work.getStep() == Step.Investigating) {	if (!isHostRemoved) {	if (vm.getHostId() == null || vm.getHostId() != work.getHostId()) {	return null;	}	Investigator investigator = null;	for (Investigator it : investigators) {	investigator = it;	try {	alive = investigator.isVmAlive(vm, host);	
found to be alive 

if (vm.getHostId() == null || vm.getHostId() != work.getHostId()) {	return null;	}	Investigator investigator = null;	for (Investigator it : investigators) {	investigator = it;	try {	alive = investigator.isVmAlive(vm, host);	break;	} catch (UnknownVM e) {	
could not find 

for (Investigator it : investigators) {	investigator = it;	try {	alive = investigator.isVmAlive(vm, host);	break;	} catch (UnknownVM e) {	}	}	boolean fenced = false;	if (alive == null) {	
fencing off vm that we don t know the state of 

try {	alive = investigator.isVmAlive(vm, host);	break;	} catch (UnknownVM e) {	}	}	boolean fenced = false;	if (alive == null) {	for (FenceBuilder fb : fenceBuilders) {	Boolean result = fb.fenceOff(vm, host);	
fencer returned 

for (FenceBuilder fb : fenceBuilders) {	Boolean result = fb.fenceOff(vm, host);	if (result != null && result) {	fenced = true;	break;	}	}	} else if (!alive) {	fenced = true;	} else {	
vm is found to be alive by 

Boolean result = fb.fenceOff(vm, host);	if (result != null && result) {	fenced = true;	break;	}	}	} else if (!alive) {	fenced = true;	} else {	if (host.getStatus() == Status.Up) {	
is alive and host is up no need to restart it 

fenced = true;	break;	}	}	} else if (!alive) {	fenced = true;	} else {	if (host.getStatus() == Status.Up) {	return null;	} else {	
rescheduling because the host is not up but the vm is alive 

} else if (!alive) {	fenced = true;	} else {	if (host.getStatus() == Status.Up) {	return null;	} else {	return (System.currentTimeMillis() >> 10) + _investigateRetryInterval;	}	}	if (!fenced) {	
we were unable to fence off the vm 

} catch (OperationTimedoutException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	} catch (ConcurrentOperationException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	}	work.setStep(Step.Scheduled);	_haDao.update(work.getId(), work);	} else {	
how come that ha step is investigating and the host is removed calling forced stop on vm anyways 

throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	} catch (ConcurrentOperationException e) {	assert false : "How do we hit this when force is true?";	throw new CloudRuntimeException("Caught exception even though it should be handled.", e);	}	}	}	vm = _itMgr.findById(vm.getId());	if (!_forceHA && !vm.isHaEnabled()) {	if (s_logger.isDebugEnabled()) {	
vm is not ha enabled so we re done 

}	}	vm = _itMgr.findById(vm.getId());	if (!_forceHA && !vm.isHaEnabled()) {	if (s_logger.isDebugEnabled()) {	}	return null;	}	if ((host == null || host.getRemoved() != null || host.getState() != Status.Up) && !volumeMgr.canVmRestartOnAnotherServer(vm.getId())) {	if (s_logger.isDebugEnabled()) {	
vm can not restart on another server 

if (_haTag != null) {	params.put(VirtualMachineProfile.Param.HaTag, _haTag);	}	WorkType wt = work.getWorkType();	if (wt.equals(WorkType.HA)) {	params.put(VirtualMachineProfile.Param.HaOperation, true);	}	try{	_itMgr.advanceStart(vm.getUuid(), params, null);	}catch (InsufficientCapacityException e){	
failed to deploy vm with original planner sending haplanner 

if (wt.equals(WorkType.HA)) {	params.put(VirtualMachineProfile.Param.HaOperation, true);	}	try{	_itMgr.advanceStart(vm.getUuid(), params, null);	}catch (InsufficientCapacityException e){	_itMgr.advanceStart(vm.getUuid(), params, _haPlanners.get(0));	}	VMInstanceVO started = _instanceDao.findById(vm.getId());	if (started != null && started.getState() == VirtualMachine.State.Running) {	
vm is now restarted on 

try{	_itMgr.advanceStart(vm.getUuid(), params, null);	}catch (InsufficientCapacityException e){	_itMgr.advanceStart(vm.getUuid(), params, _haPlanners.get(0));	}	VMInstanceVO started = _instanceDao.findById(vm.getId());	if (started != null && started.getState() == VirtualMachine.State.Running) {	return null;	}	if (s_logger.isDebugEnabled()) {	
rescheduling vm to try again in 

}catch (InsufficientCapacityException e){	_itMgr.advanceStart(vm.getUuid(), params, _haPlanners.get(0));	}	VMInstanceVO started = _instanceDao.findById(vm.getId());	if (started != null && started.getState() == VirtualMachine.State.Running) {	return null;	}	if (s_logger.isDebugEnabled()) {	}	} catch (final InsufficientCapacityException e) {	
unable to restart due to 

}	VMInstanceVO started = _instanceDao.findById(vm.getId());	if (started != null && started.getState() == VirtualMachine.State.Running) {	return null;	}	if (s_logger.isDebugEnabled()) {	}	} catch (final InsufficientCapacityException e) {	_alertMgr.sendAlert(alertType, vm.getDataCenterId(), vm.getPodIdToDeployIn(), "Unable to restart " + vm.getHostName() + " which was running on host " + hostDesc, "Insufficient capacity to restart VM, name: " + vm.getHostName() + ", id: " + vmId + " which was running on host " + hostDesc);	} catch (final ResourceUnavailableException e) {	
unable to restart due to 

if (started != null && started.getState() == VirtualMachine.State.Running) {	return null;	}	if (s_logger.isDebugEnabled()) {	}	} catch (final InsufficientCapacityException e) {	_alertMgr.sendAlert(alertType, vm.getDataCenterId(), vm.getPodIdToDeployIn(), "Unable to restart " + vm.getHostName() + " which was running on host " + hostDesc, "Insufficient capacity to restart VM, name: " + vm.getHostName() + ", id: " + vmId + " which was running on host " + hostDesc);	} catch (final ResourceUnavailableException e) {	_alertMgr.sendAlert(alertType, vm.getDataCenterId(), vm.getPodIdToDeployIn(), "Unable to restart " + vm.getHostName() + " which was running on host " + hostDesc, "The Storage is unavailable for trying to restart VM, name: " + vm.getHostName() + ", id: " + vmId + " which was running on host " + hostDesc);	} catch (ConcurrentOperationException e) {	
unable to restart due to 

}	if (s_logger.isDebugEnabled()) {	}	} catch (final InsufficientCapacityException e) {	_alertMgr.sendAlert(alertType, vm.getDataCenterId(), vm.getPodIdToDeployIn(), "Unable to restart " + vm.getHostName() + " which was running on host " + hostDesc, "Insufficient capacity to restart VM, name: " + vm.getHostName() + ", id: " + vmId + " which was running on host " + hostDesc);	} catch (final ResourceUnavailableException e) {	_alertMgr.sendAlert(alertType, vm.getDataCenterId(), vm.getPodIdToDeployIn(), "Unable to restart " + vm.getHostName() + " which was running on host " + hostDesc, "The Storage is unavailable for trying to restart VM, name: " + vm.getHostName() + ", id: " + vmId + " which was running on host " + hostDesc);	} catch (ConcurrentOperationException e) {	_alertMgr.sendAlert(alertType, vm.getDataCenterId(), vm.getPodIdToDeployIn(), "Unable to restart " + vm.getHostName() + " which was running on host " + hostDesc, "The Storage is unavailable for trying to restart VM, name: " + vm.getHostName() + ", id: " + vmId + " which was running on host " + hostDesc);	} catch (OperationTimedoutException e) {	
unable to restart due to 

try {	work.setStep(Step.Migrating);	_haDao.update(work.getId(), work);	VMInstanceVO vm = _instanceDao.findById(vmId);	if (vm == null) {	return null;	}	_itMgr.migrateAway(vm.getUuid(), srcHostId);	return null;	} catch (InsufficientServerCapacityException e) {	
insufficient capacity for migrating a vm 

public void scheduleDestroy(VMInstanceVO vm, long hostId) {	final HaWorkVO work = new HaWorkVO(vm.getId(), vm.getType(), WorkType.Destroy, Step.Scheduled, hostId, vm.getState(), 0, vm.getUpdated());	_haDao.persist(work);	if (s_logger.isDebugEnabled()) {	
scheduled 

protected Long destroyVM(final HaWorkVO work) {	final VirtualMachine vm = _itMgr.findById(work.getInstanceId());	
destroying 

protected Long destroyVM(final HaWorkVO work) {	final VirtualMachine vm = _itMgr.findById(work.getInstanceId());	try {	if (vm.getState() != State.Destroyed) {	
vm is no longer in destroyed state 

protected Long destroyVM(final HaWorkVO work) {	final VirtualMachine vm = _itMgr.findById(work.getInstanceId());	try {	if (vm.getState() != State.Destroyed) {	return null;	}	if (vm.getHostId() != null) {	_itMgr.destroy(vm.getUuid());	
successfully destroy 

final VirtualMachine vm = _itMgr.findById(work.getInstanceId());	try {	if (vm.getState() != State.Destroyed) {	return null;	}	if (vm.getHostId() != null) {	_itMgr.destroy(vm.getUuid());	return null;	} else {	if (s_logger.isDebugEnabled()) {	
has already been stopped 

}	if (vm.getHostId() != null) {	_itMgr.destroy(vm.getUuid());	return null;	} else {	if (s_logger.isDebugEnabled()) {	}	return null;	}	} catch (final AgentUnavailableException e) {	
agnet is not available 

if (vm.getHostId() != null) {	_itMgr.destroy(vm.getUuid());	return null;	} else {	if (s_logger.isDebugEnabled()) {	}	return null;	}	} catch (final AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	
operation timed out 

_itMgr.destroy(vm.getUuid());	return null;	} else {	if (s_logger.isDebugEnabled()) {	}	return null;	}	} catch (final AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	} catch (ConcurrentOperationException e) {	
concurrent operation 

protected Long stopVM(final HaWorkVO work) throws ConcurrentOperationException {	VirtualMachine vm = _itMgr.findById(work.getInstanceId());	if (vm == null) {	
no longer can find vm throwing away 

protected Long stopVM(final HaWorkVO work) throws ConcurrentOperationException {	VirtualMachine vm = _itMgr.findById(work.getInstanceId());	if (vm == null) {	work.setStep(Step.Done);	return null;	}	
stopping 

protected Long stopVM(final HaWorkVO work) throws ConcurrentOperationException {	VirtualMachine vm = _itMgr.findById(work.getInstanceId());	if (vm == null) {	work.setStep(Step.Done);	return null;	}	try {	if (work.getWorkType() == WorkType.Stop) {	_itMgr.advanceStop(vm.getUuid(), false);	
successfully stopped 

try {	if (work.getWorkType() == WorkType.Stop) {	_itMgr.advanceStop(vm.getUuid(), false);	return null;	} else if (work.getWorkType() == WorkType.CheckStop) {	if ((vm.getState() != work.getPreviousState()) || vm.getUpdated() != work.getUpdateTime() || vm.getHostId() == null || vm.getHostId().longValue() != work.getHostId()) {	s_logger.info(vm + " is different now.  Scheduled Host: " + work.getHostId() + " Current Host: " + (vm.getHostId() != null ? vm.getHostId() : "none") + " State: " + vm.getState());	return null;	}	_itMgr.advanceStop(vm.getUuid(), false);	
stop for was successful 

return null;	}	_itMgr.advanceStop(vm.getUuid(), false);	return null;	} else if (work.getWorkType() == WorkType.ForceStop) {	if ((vm.getState() != work.getPreviousState()) || vm.getUpdated() != work.getUpdateTime() || vm.getHostId() == null || vm.getHostId().longValue() != work.getHostId()) {	s_logger.info(vm + " is different now.  Scheduled Host: " + work.getHostId() + " Current Host: " + (vm.getHostId() != null ? vm.getHostId() : "none") + " State: " + vm.getState());	return null;	}	_itMgr.advanceStop(vm.getUuid(), true);	
stop for was successful 

if ((vm.getState() != work.getPreviousState()) || vm.getUpdated() != work.getUpdateTime() || vm.getHostId() == null || vm.getHostId().longValue() != work.getHostId()) {	s_logger.info(vm + " is different now.  Scheduled Host: " + work.getHostId() + " Current Host: " + (vm.getHostId() != null ? vm.getHostId() : "none") + " State: " + vm.getState());	return null;	}	_itMgr.advanceStop(vm.getUuid(), true);	return null;	} else {	assert false : "Who decided there's other steps but didn't modify the guy who does the work?";	}	} catch (final ResourceUnavailableException e) {	
agnet is not available 

s_logger.info(vm + " is different now.  Scheduled Host: " + work.getHostId() + " Current Host: " + (vm.getHostId() != null ? vm.getHostId() : "none") + " State: " + vm.getState());	return null;	}	_itMgr.advanceStop(vm.getUuid(), true);	return null;	} else {	assert false : "Who decided there's other steps but didn't modify the guy who does the work?";	}	} catch (final ResourceUnavailableException e) {	} catch (OperationTimedoutException e) {	
operation timed out 

private void rescheduleWork(final HaWorkVO work, final long nextTime) {	
rescheduling work to try again at 

nextTime = restart(work);	} else if (wt == WorkType.Stop || wt == WorkType.CheckStop || wt == WorkType.ForceStop) {	nextTime = stopVM(work);	} else if (wt == WorkType.Destroy) {	nextTime = destroyVM(work);	} else {	assert false : "How did we get here with " + wt.toString();	return;	}	if (nextTime == null) {	
completed work 

} else {	assert false : "How did we get here with " + wt.toString();	return;	}	if (nextTime == null) {	work.setStep(Step.Done);	} else {	rescheduleWork(work, nextTime.longValue());	}	} catch (Exception e) {	
encountered unhandled exception during ha process reschedule work 

rescheduleWork(work, nextTime.longValue());	}	} catch (Exception e) {	long nextTime = getRescheduleTime(wt);	rescheduleWork(work, nextTime);	VMInstanceVO vm = _instanceDao.findById(work.getInstanceId());	work.setUpdateTime(vm.getUpdated());	work.setPreviousState(vm.getState());	}	if (!Step.Done.equals(work.getStep()) && work.getTimesTried() >= _maxRetries) {	
giving up retried max times for work 

protected void runInContext() {	
ha cleanup thread running 

protected void runInContext() {	try {	_haDao.cleanup(System.currentTimeMillis() - _timeBetweenFailures);	} catch (Exception e) {	
error while cleaning up 

public void run() {	
starting work 

public void run() {	while (!_stopped) {	_managedContext.runWithContext(new Runnable() {	public void run() {	runWithContext();	}	});	}	
time to go home 

private void runWithContext() {	HaWorkVO work = null;	try {	
checking the database for work 

HaWorkVO work = null;	try {	work = _haDao.take(_serverId);	if (work == null) {	try {	synchronized (this) {	wait(_timeToSleep);	}	return;	} catch (final InterruptedException e) {	
Interrupted 

try {	synchronized (this) {	wait(_timeToSleep);	}	return;	} catch (final InterruptedException e) {	return;	}	}	NDC.push("work-" + work.getId());	
processing work 

wait(_timeToSleep);	}	return;	} catch (final InterruptedException e) {	return;	}	}	NDC.push("work-" + work.getId());	processWork(work);	} catch (final Throwable th) {	
caught this throwable 

========================= cloudstack sample_2495 =========================

private List<Long> reorderClustersByPods(List<Long> clusterIds, List<Long> podIds) {	if (s_logger.isDebugEnabled()) {	
reordering cluster list as per pods ordered by user concentration 

private List<Long> reorderClustersByPods(List<Long> clusterIds, List<Long> podIds) {	if (s_logger.isDebugEnabled()) {	}	Map<Long, List<Long>> podClusterMap = clusterDao.getPodClusterIdMap(clusterIds);	if (s_logger.isTraceEnabled()) {	
pod to cluster map is 

if (clustersOfThisPod.contains(clusterId)) {	reorderedClusters.add(clusterId);	}	}	clusterIds.removeAll(clustersOfThisPod);	}	}	}	reorderedClusters.addAll(clusterIds);	if (s_logger.isTraceEnabled()) {	
reordered cluster list 

protected List<Long> listPodsByUserConcentration(long zoneId, long accountId) {	if (s_logger.isDebugEnabled()) {	
applying userconcentratedpod heuristic for account 

protected List<Long> listPodsByUserConcentration(long zoneId, long accountId) {	if (s_logger.isDebugEnabled()) {	}	List<Long> prioritizedPods = vmDao.listPodIdsHavingVmsforAccount(zoneId, accountId);	if (s_logger.isTraceEnabled()) {	
list of pods to be considered after applying userconcentratedpod heuristic 

========================= cloudstack sample_761 =========================

public BcfAnswer sendBcfCommandWithNetworkSyncCheck(BcfCommand cmd, Network network)throws IllegalArgumentException{	ControlClusterData cluster = getControlClusterData(network.getPhysicalNetworkId());	if(cluster.getMaster()==null){	return new BcfAnswer(cmd, new CloudRuntimeException("Big Switch Network controller temporarily unavailable"));	}	TopologyData topo = getTopology(network.getPhysicalNetworkId());	cmd.setTopology(topo);	BcfAnswer answer =  (BcfAnswer) _agentMgr.easySend(cluster.getMaster().getId(), cmd);	if (answer == null || !answer.getResult()) {	
bcf api command failed 

========================= cloudstack sample_1539 =========================

public PingCommand getCurrentStatus(long id) {	if (Strings.isNullOrEmpty(_relativePath)) {	
refusing to ping nuage vsd because the resource configuration is missing the relative path information 

public PingCommand getCurrentStatus(long id) {	if (Strings.isNullOrEmpty(_relativePath)) {	_shouldAudit = true;	return null;	}	if (Strings.isNullOrEmpty(_cmsUserLogin) || Strings.isNullOrEmpty(_cmsUserPassword)) {	
refusing to ping nuage vsd because the resource configuration is missing the cms user information 

_shouldAudit = true;	return null;	}	if (Strings.isNullOrEmpty(_cmsUserLogin) || Strings.isNullOrEmpty(_cmsUserPassword)) {	_shouldAudit = true;	return null;	}	try {	login();	} catch (ExecutionException | ConfigurationException e) {	
failed to ping to nuage vsd on as user 

return executeRequest((SyncNuageVspCmsIdCommand)cmd);	} else if (cmd instanceof SyncDomainCommand) {	return executeRequest((SyncDomainCommand)cmd);	}	else if (cmd instanceof GetApiDefaultsCommand) {	return executeRequest((GetApiDefaultsCommand)cmd);	} else if (cmd instanceof SupportedApiVersionCommand) {	return executeRequest((SupportedApiVersionCommand)cmd);	}	if (s_logger.isDebugEnabled()) {	
received unsupported command 

private Answer executeRequest(ImplementNetworkVspCommand cmd) {	try {	isNuageVspGuruLoaded();	_nuageVspGuruClient.implement(cmd.getNetwork(), cmd.getDnsServers());	return new Answer(cmd, true, "Created network mapping to " + cmd.getNetwork().getName() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(ReserveVmInterfaceVspCommand cmd) {	try {	isNuageVspGuruLoaded();	_nuageVspGuruClient.reserve(cmd.getNetwork(), cmd.getVm(), cmd.getNic(), cmd.getStaticNat());	return new Answer(cmd, true, "Created NIC that maps to nicUuid" + cmd.getNic().getUuid() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(DeallocateVmVspCommand cmd) {	try {	isNuageVspGuruLoaded();	_nuageVspGuruClient.deallocate(cmd.getNetwork(), cmd.getVm(), cmd.getNic());	return new Answer(cmd, true, "Deallocated VM " + cmd.getVm().getName() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(TrashNetworkVspCommand cmd) {	try {	isNuageVspGuruLoaded();	_nuageVspGuruClient.trash(cmd.getNetwork());	return new Answer(cmd, true, "Deleted network mapping to " + cmd.getNetwork().getUuid() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(ApplyStaticNatVspCommand cmd) {	try {	isNuageVspElementLoaded();	_nuageVspElementClient.applyStaticNats(cmd.getNetwork(), cmd.getStaticNatDetails());	return new Answer(cmd, true, "Applied Static NAT to network mapping " + cmd.getNetwork().getUuid() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(ImplementVspCommand cmd) {	try {	isNuageVspElementLoaded();	boolean success = _nuageVspElementClient.implement(cmd.getNetwork(), cmd.getDnsServers(), cmd.getIngressFirewallRules(), cmd.getEgressFirewallRules(), cmd.getFloatingIpUuids());	return new Answer(cmd, success, "Implemented network " + cmd.getNetwork().getUuid() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(ApplyAclRuleVspCommand cmd) {	try {	isNuageVspElementLoaded();	_nuageVspElementClient.applyAclRules(cmd.getAclType(), cmd.getNetwork(), cmd.getAclRules(), cmd.isNetworkReset());	return new Answer(cmd, true, "Applied ACL Rule to network mapping " + cmd.getNetwork().getUuid() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(ShutDownVpcVspCommand cmd) {	try {	isNuageVspElementLoaded();	_nuageVspElementClient.shutdownVpc(cmd.getDomainUuid(), cmd.getVpcUuid(), cmd.getDomainTemplateName(), cmd.getDomainRouterUuids());	return new Answer(cmd, true, "Shutdown VPC " + cmd.getVpcUuid() + " on Nuage VSD " + _hostName);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

Pair<Boolean, String> answer = _nuageVspManagerClient.auditNuageVspCmsId(cmd.getNuageVspCmsId(), cmd.getSyncType() == SyncType.AUDIT_ONLY);	return new SyncNuageVspCmsIdAnswer(answer.getLeft(), answer.getRight(), cmd.getSyncType());	} else if (cmd.getSyncType() == SyncType.REGISTER) {	String registeredNuageVspCmsId = _nuageVspManagerClient.registerNuageVspCmsId();	return new SyncNuageVspCmsIdAnswer(StringUtils.isNotBlank(registeredNuageVspCmsId), registeredNuageVspCmsId, cmd.getSyncType());	} else {	boolean success = _nuageVspManagerClient.unregisterNuageVspCmsId(cmd.getNuageVspCmsId());	return new SyncNuageVspCmsIdAnswer(success, cmd.getNuageVspCmsId(), cmd.getSyncType());	}	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(SyncDomainCommand cmd) {	try {	isNuageVspManagerLoaded();	boolean success = _nuageVspManagerClient.syncDomainWithNuageVsp(cmd.getDomain(), cmd.isToAdd(), cmd.isToRemove());	return new SyncDomainAnswer(success);	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(GetApiDefaultsCommand cmd) {	try {	isNuageVspManagerLoaded();	return new GetApiDefaultsAnswer(cmd, _nuageVspManagerClient.getApiDefaults());	} catch (ExecutionException | ConfigurationException e) {	
failure during on nuage vsd 

private Answer executeRequest(SupportedApiVersionCommand cmd) {	try {	isNuageVspManagerLoaded();	boolean supported = _nuageVspManagerClient.isSupportedApiVersion(cmd.getApiVersion());	return new Answer(cmd, supported, "Check if API version " + cmd.getApiVersion() + " is supported");	} catch (ConfigurationException e) {	
failure during on nuage vsd 

========================= cloudstack sample_1493 =========================

while ((line = reader.readLine()) != null) {	sb2.append(line + "\n");	}	result = sb2.toString();	} catch (final IOException e) {	success = false;	} finally {	try {	is.close();	} catch (final IOException e) {	
exception when closing console proxy address 

} catch (final IOException e) {	success = false;	} finally {	try {	is.close();	} catch (final IOException e) {	success = false;	}	}	} catch (final IOException e) {	
unable to open console proxy command port url console proxy address 

========================= cloudstack sample_1169 =========================

searchBuilder.and("networkOfferingId", searchBuilder.entity().getNetworkOfferingId(), Op.EQ);	SearchCriteria<NetworkVO> sc = searchBuilder.create();	sc.setParameters("networkOfferingId", controller.getManager().getVpcRouterOffering().getId());	sc.setParameters("cidr", cidr);	sc.setParameters("trafficType", Networks.TrafficType.Guest);	List<NetworkVO> dbNets = controller.getNetworkDao().search(sc, null);	if (dbNets == null || dbNets.size() == 0) {	return null;	}	if (dbNets.size() > 1) {	
more than one network found with cidr 

public void update(ModelController controller) throws InternalErrorException, IOException {	ApiConnector api = controller.getApiAccessor();	if (_project == null) {	
project is null for the policy 

if (policyId != null) {	policy = _policy = (NetworkPolicy) api.findById(NetworkPolicy.class, policyId);	}	if (policy == null) {	policy = new NetworkPolicy();	policy.setUuid(_uuid);	policy.setName(_name);	policy.setParent(_project);	}	} catch (IOException ex) {	
network policy read 

}	} catch (IOException ex) {	return;	}	}	policy.setEntries(_policyMap);	if (_policy == null) {	try {	api.create(policy);	} catch (Exception ex) {	
network policy create 

try {	api.create(policy);	} catch (Exception ex) {	throw new CloudRuntimeException("Failed to create network policy", ex);	}	_policy = policy;	} else {	try {	api.update(policy);	} catch (IOException ex) {	
network policy update 

========================= cloudstack sample_1885 =========================

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (s_logger.isInfoEnabled()) {	
start configuring agentbasedconsoleproxymanager 

_consoleProxyPort = NumbersUtil.parseInt(value, ConsoleProxyManager.DEFAULT_PROXY_VNC_PORT);	}	value = configs.get("consoleproxy.sslEnabled");	if (value != null && value.equalsIgnoreCase("true")) {	_sslEnabled = true;	}	_consoleProxyUrlDomain = configs.get("consoleproxy.url.domain");	_listener = new ConsoleProxyListener(new AgentBasedAgentHook(_instanceDao, _hostDao, _configDao, _ksMgr, _agentMgr, _keysMgr));	_agentMgr.registerForHostEvents(_listener, true, true, false);	if (s_logger.isInfoEnabled()) {	
agentbasedconsoleproxymanager has been configured ssl enabled 

public ConsoleProxyInfo assignProxy(long dataCenterId, long userVmId) {	UserVmVO userVm = _userVmDao.findById(userVmId);	if (userVm == null) {	
user vm no longer exists return a null proxy for user vm 

public ConsoleProxyInfo assignProxy(long dataCenterId, long userVmId) {	UserVmVO userVm = _userVmDao.findById(userVmId);	if (userVm == null) {	return null;	}	HostVO host = findHost(userVm);	if (host != null) {	if (s_logger.isDebugEnabled()) {	
assign embedded console proxy running at to user vm with public ip 

if (userVm == null) {	return null;	}	HostVO host = findHost(userVm);	if (host != null) {	if (s_logger.isDebugEnabled()) {	}	String publicIp = host.getPublicIpAddress();	if (publicIp == null) {	if (s_logger.isDebugEnabled()) {	
host does not have public interface we will return its private ip for cosole proxy 

if (s_logger.isDebugEnabled()) {	}	publicIp = host.getPrivateIpAddress();	}	int urlPort = _consoleProxyUrlPort;	if (host.getProxyPort() != null && host.getProxyPort().intValue() > 0) {	urlPort = host.getProxyPort().intValue();	}	return new ConsoleProxyInfo(_sslEnabled, publicIp, _consoleProxyPort, urlPort, _consoleProxyUrlDomain);	} else {	
host that vm is running is no longer available console access to vm will be temporarily unavailable 

========================= cloudstack sample_2483 =========================

if (cleanupMaid.getDatacenterMorValue() != null) {	DatacenterMO dcMo = new DatacenterMO(context, "Datacenter", cleanupMaid.getDatacenterMorValue());	vmMo = dcMo.findVm(cleanupMaid.getVmName());	} else {	assert (cleanupMaid.getHostMorValue() != null);	HostMO hostMo = new HostMO(context, "HostSystem", cleanupMaid.getHostMorValue());	ClusterMO clusterMo = new ClusterMO(context, hostMo.getHyperHostCluster());	vmMo = clusterMo.findVmOnHyperHost(cleanupMaid.getVmName());	}	if (vmMo != null) {	
found left over dummy vm destroy it 

} else {	assert (cleanupMaid.getHostMorValue() != null);	HostMO hostMo = new HostMO(context, "HostSystem", cleanupMaid.getHostMorValue());	ClusterMO clusterMo = new ClusterMO(context, hostMo.getHyperHostCluster());	vmMo = clusterMo.findVmOnHyperHost(cleanupMaid.getVmName());	}	if (vmMo != null) {	vmMo.destroy();	}	} catch (Throwable e) {	
unable to destroy left over dummy vm 

========================= cloudstack sample_1305 =========================

public Map<String, List<String>> getServiceProviders() {	Map<String, List<String>> serviceProviderMap = null;	if (serviceProviderList != null && !serviceProviderList.isEmpty()) {	serviceProviderMap = new HashMap<String, List<String>>();	Collection<? extends Map<String, String>> servicesCollection = serviceProviderList.values();	Iterator<? extends Map<String, String>> iter = servicesCollection.iterator();	while (iter.hasNext()) {	Map<String, String> obj = iter.next();	if (s_logger.isTraceEnabled()) {	
service provider entry specified 

========================= cloudstack sample_3292 =========================

protected NeutronRestApi(final Class<? extends HttpMethodBase> httpClazz, final String protocol, final int port) {	client = createHttpClient();	client.getParams().setCookiePolicy(CookiePolicy.BROWSER_COMPATIBILITY);	this.httpClazz = httpClazz;	try {	Protocol.registerProtocol(protocol, new Protocol(protocol, (ProtocolSocketFactory) new TrustingProtocolSocketFactory(), HTTPS_PORT));	} catch (IOException e) {	
failed to register the trustingprotocolsocketfactory falling back to default sslsocketfactory 

public void executeMethod(final HttpMethodBase method) throws NeutronRestApiException {	try {	client.executeMethod(method);	} catch (HttpException e) {	
httpexception caught while trying to connect to the neutron controller 

public void executeMethod(final HttpMethodBase method) throws NeutronRestApiException {	try {	client.executeMethod(method);	} catch (HttpException e) {	method.releaseConnection();	throw new NeutronRestApiException("API call to Neutron Controller Failed", e);	} catch (IOException e) {	
ioexception caught while trying to connect to the neutron controller 

========================= cloudstack sample_1610 =========================

HashMap<String, String> deployParams = cmd.getDeployParamMap();	if (deployParams.containsKey("networks") && deployParams.get("networks").length() > 0) {	throw new InvalidParameterValueException( "'networks' is not a valid parameter, network for an AutoScaled VM is chosen automatically. An autoscaled VM is deployed in the loadbalancer's network");	}	dispatchChainFactory.getStandardDispatchChain().dispatch(new DispatchTask(ComponentContext.inject(DeployVMCmd.class), deployParams));	AutoScaleVmProfileVO profileVO = new AutoScaleVmProfileVO(cmd.getZoneId(), cmd.getDomainId(), cmd.getAccountId(), cmd.getServiceOfferingId(), cmd.getTemplateId(), cmd.getOtherDeployParams(), cmd.getCounterParamList(), cmd.getDestroyVmGraceperiod(), autoscaleUserId);	if (cmd.getDisplay() != null) {	profileVO.setDisplay(cmd.getDisplay());	}	profileVO = checkValidityAndPersist(profileVO);	
successfully create autoscale vm profile with id 

if (cmd.getDisplay() != null) {	vmProfile.setDisplay(cmd.getDisplay());	}	List<AutoScaleVmGroupVO> vmGroupList = _autoScaleVmGroupDao.listByAll(null, profileId);	for (AutoScaleVmGroupVO vmGroupVO : vmGroupList) {	if (physicalParameterUpdate && !vmGroupVO.getState().equals(AutoScaleVmGroup.State_Disabled)) {	throw new InvalidParameterValueException("The AutoScale Vm Profile can be updated only if the Vm Group it is associated with is disabled in state");	}	}	vmProfile = checkValidityAndPersist(vmProfile);	
updated auto scale vm profile id 

public boolean deleteAutoScaleVmProfile(long id) {	getEntityInDatabase(CallContext.current().getCallingAccount(), "AutoScale Vm Profile", id, _autoScaleVmProfileDao);	if (_autoScaleVmGroupDao.isProfileInUse(id)) {	throw new InvalidParameterValueException("Cannot delete AutoScale Vm Profile when it is in use by one more vm groups");	}	boolean success = _autoScaleVmProfileDao.remove(id);	if (success) {	
successfully deleted autoscale vm profile with id 

String action = cmd.getAction();	if (quietTime == null) {	quietTime = NetUtils.DEFAULT_AUTOSCALE_POLICY_QUIET_TIME;	}	action = action.toLowerCase();	if (!NetUtils.isValidAutoScaleAction(action)) {	throw new InvalidParameterValueException("action is invalid, only 'scaleup' and 'scaledown' is supported");	}	AutoScalePolicyVO policyVO = new AutoScalePolicyVO(cmd.getDomainId(), cmd.getAccountId(), duration, quietTime, null, action);	policyVO = checkValidityAndPersist(policyVO, cmd.getConditionIds());	
successfully created autoscale policy with id 

public boolean deleteAutoScalePolicy(final long id) {	getEntityInDatabase(CallContext.current().getCallingAccount(), "AutoScale Policy", id, _autoScalePolicyDao);	if (_autoScaleVmGroupPolicyMapDao.isAutoScalePolicyInUse(id)) {	throw new InvalidParameterValueException("Cannot delete AutoScale Policy when it is in use by one or more AutoScale Vm Groups");	}	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean success = true;	success = _autoScalePolicyDao.remove(id);	if (!success) {	
failed to remove autoscale policy db object 

}	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean success = true;	success = _autoScalePolicyDao.remove(id);	if (!success) {	return false;	}	success = _autoScalePolicyConditionMapDao.removeByAutoScalePolicyId(id);	if (!success) {	
failed to remove autoscale policy condition mappings 

public Boolean doInTransaction(TransactionStatus status) {	boolean success = true;	success = _autoScalePolicyDao.remove(id);	if (!success) {	return false;	}	success = _autoScalePolicyConditionMapDao.removeByAutoScalePolicyId(id);	if (!success) {	return false;	}	
successfully deleted autoscale policy id 

if (duration != null) {	policy.setDuration(duration);	}	if (quietTime != null) {	policy.setQuietTime(quietTime);	}	List<AutoScaleVmGroupPolicyMapVO> vmGroupPolicyList = _autoScaleVmGroupPolicyMapDao.listByPolicyId(policyId);	for (AutoScaleVmGroupPolicyMapVO vmGroupPolicy : vmGroupPolicyList) {	AutoScaleVmGroupVO vmGroupVO = _autoScaleVmGroupDao.findById(vmGroupPolicy.getVmGroupId());	if (vmGroupVO == null) {	
stale database entry there is an entry in vmgrouppolicymap but the vmgroup is missing 

continue;	}	if (!vmGroupVO.getState().equals(AutoScaleVmGroup.State_Disabled)) {	throw new InvalidParameterValueException("The AutoScale Policy can be updated only if the Vm Group it is associated with is disabled in state");	}	if (policy.getDuration() < vmGroupVO.getInterval()) {	throw new InvalidParameterValueException("duration is less than the associated AutoScaleVmGroup's interval");	}	}	policy = checkValidityAndPersist(policy, conditionIds);	
successfully updated auto scale policy id 

throw new InvalidParameterValueException("an AutoScaleVmGroup is already attached to the lb rule, the existing vm group has to be first deleted");	}	if (_lb2VmMapDao.isVmAttachedToLoadBalancer(loadBalancer.getId())) {	throw new InvalidParameterValueException( "there are Vms already bound to the specified LoadBalancing Rule. User bound Vms and AutoScaled Vm Group cannot co-exist on a Load Balancing Rule");	}	AutoScaleVmGroupVO vmGroupVO = new AutoScaleVmGroupVO(cmd.getLbRuleId(), zoneId, loadBalancer.getDomainId(), loadBalancer.getAccountId(), minMembers, maxMembers, loadBalancer.getDefaultPortStart(), interval, null, cmd.getProfileId(), AutoScaleVmGroup.State_New);	if (forDisplay != null) {	vmGroupVO.setDisplay(forDisplay);	}	vmGroupVO = checkValidityAndPersist(vmGroupVO, cmd.getScaleUpPolicyIds(), cmd.getScaleDownPolicyIds());	
successfully created autoscale vm group with id 

private boolean configureAutoScaleVmGroup(long vmGroupid, String currentState) throws ResourceUnavailableException {	AutoScaleVmGroup vmGroup = _autoScaleVmGroupDao.findById(vmGroupid);	if (isLoadBalancerBasedAutoScaleVmGroup(vmGroup)) {	try {	return _lbRulesMgr.configureLbAutoScaleVmGroup(vmGroupid, currentState);	} catch (ResourceUnavailableException re) {	throw re;	} catch (Exception e) {	
exception during configurelbautoscalevmgroup in lb rules manager 

autoScaleVmGroupVO.setState(AutoScaleVmGroup.State_Revoke);	_autoScaleVmGroupDao.persist(autoScaleVmGroupVO);	boolean success = false;	try {	success = configureAutoScaleVmGroup(id, bakupState);	} catch (ResourceUnavailableException e) {	autoScaleVmGroupVO.setState(bakupState);	_autoScaleVmGroupDao.persist(autoScaleVmGroupVO);	} finally {	if (!success) {	
could not delete autoscale vm group id 

_autoScaleVmGroupDao.persist(autoScaleVmGroupVO);	} finally {	if (!success) {	return false;	}	}	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean success = _autoScaleVmGroupDao.remove(id);	if (!success) {	
failed to remove autoscale group db object 

}	}	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean success = _autoScaleVmGroupDao.remove(id);	if (!success) {	return false;	}	success = _autoScaleVmGroupPolicyMapDao.removeByGroupId(id);	if (!success) {	
failed to remove autoscale group policy mappings 

return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean success = _autoScaleVmGroupDao.remove(id);	if (!success) {	return false;	}	success = _autoScaleVmGroupPolicyMapDao.removeByGroupId(id);	if (!success) {	return false;	}	
successfully deleted autoscale vm group id 

vmGroupVO.setInterval(interval);	}	if (cmd.getCustomId() != null) {	vmGroupVO.setUuid(cmd.getCustomId());	}	if (forDisplay != null) {	vmGroupVO.setDisplay(forDisplay);	}	vmGroupVO = checkValidityAndPersist(vmGroupVO, scaleUpPolicyIds, scaleDownPolicyIds);	if (vmGroupVO != null) {	
updated auto scale vmgroup id 

}	try {	vmGroup.setState(AutoScaleVmGroup.State_Enabled);	vmGroup = _autoScaleVmGroupDao.persist(vmGroup);	success = configureAutoScaleVmGroup(id, AutoScaleVmGroup.State_Disabled);	} catch (ResourceUnavailableException e) {	vmGroup.setState(AutoScaleVmGroup.State_Disabled);	_autoScaleVmGroupDao.persist(vmGroup);	} finally {	if (!success) {	
failed to enable autoscale vm group id 

vmGroup.setState(AutoScaleVmGroup.State_Enabled);	vmGroup = _autoScaleVmGroupDao.persist(vmGroup);	success = configureAutoScaleVmGroup(id, AutoScaleVmGroup.State_Disabled);	} catch (ResourceUnavailableException e) {	vmGroup.setState(AutoScaleVmGroup.State_Disabled);	_autoScaleVmGroupDao.persist(vmGroup);	} finally {	if (!success) {	return null;	}	
successfully enabled autoscale vm group with id 

}	try {	vmGroup.setState(AutoScaleVmGroup.State_Disabled);	vmGroup = _autoScaleVmGroupDao.persist(vmGroup);	success = configureAutoScaleVmGroup(id, AutoScaleVmGroup.State_Enabled);	} catch (ResourceUnavailableException e) {	vmGroup.setState(AutoScaleVmGroup.State_Enabled);	_autoScaleVmGroupDao.persist(vmGroup);	} finally {	if (!success) {	
failed to disable autoscale vm group id 

vmGroup.setState(AutoScaleVmGroup.State_Disabled);	vmGroup = _autoScaleVmGroupDao.persist(vmGroup);	success = configureAutoScaleVmGroup(id, AutoScaleVmGroup.State_Enabled);	} catch (ResourceUnavailableException e) {	vmGroup.setState(AutoScaleVmGroup.State_Enabled);	_autoScaleVmGroupDao.persist(vmGroup);	} finally {	if (!success) {	return null;	}	
successfully disabled autoscale vm group with id 

public Counter createCounter(CreateCounterCmd cmd) {	String source = cmd.getSource().toLowerCase();	String name = cmd.getName();	Counter.Source src;	try {	src = Counter.Source.valueOf(source);	} catch (Exception ex) {	throw new InvalidParameterValueException("The Source " + source + " does not exist; Unable to create Counter");	}	CounterVO counter = null;	
adding counter 

op = Condition.Operator.valueOf(opr);	} catch (IllegalArgumentException ex) {	throw new InvalidParameterValueException("The Operator " + opr + " does not exist; Unable to create Condition.");	}	CounterVO counter = _counterDao.findById(cid);	if (counter == null) {	throw new InvalidParameterValueException("Unable to find counter");	}	ConditionVO condition = null;	condition = _conditionDao.persist(new ConditionVO(cid, threshold, cmd.getEntityOwnerId(), cmd.getDomainId(), op));	
successfully created condition with id 

public boolean deleteCounter(long counterId) throws ResourceInUseException {	CounterVO counter = _counterDao.findById(counterId);	if (counter == null) {	throw new InvalidParameterValueException("Unable to find Counter");	}	ConditionVO condition = _conditionDao.findByCounterId(counterId);	if (condition != null) {	
cannot delete counter as it is being used in a condition 

CounterVO counter = _counterDao.findById(counterId);	if (counter == null) {	throw new InvalidParameterValueException("Unable to find Counter");	}	ConditionVO condition = _conditionDao.findByCounterId(counterId);	if (condition != null) {	throw new ResourceInUseException("Counter is in use.");	}	boolean success = _counterDao.remove(counterId);	if (success) {	
successfully deleted counter with id 

public boolean deleteCondition(long conditionId) throws ResourceInUseException {	ConditionVO condition = getEntityInDatabase(CallContext.current().getCallingAccount(), "Condition", conditionId, _conditionDao);	if (condition == null) {	throw new InvalidParameterValueException("Unable to find Condition");	}	if (_autoScalePolicyConditionMapDao.isConditionInUse(conditionId)) {	
cannot delete condition as it is being used in a condition 

public boolean deleteCondition(long conditionId) throws ResourceInUseException {	ConditionVO condition = getEntityInDatabase(CallContext.current().getCallingAccount(), "Condition", conditionId, _conditionDao);	if (condition == null) {	throw new InvalidParameterValueException("Unable to find Condition");	}	if (_autoScalePolicyConditionMapDao.isConditionInUse(conditionId)) {	throw new ResourceInUseException("Cannot delete Condition when it is in use by one or more AutoScale Policies.");	}	boolean success = _conditionDao.remove(conditionId);	if (success) {	
successfully deleted condition 

public void cleanUpAutoScaleResources(Long accountId) {	int count = 0;	count = _autoScaleVmProfileDao.removeByAccountId(accountId);	if (count > 0) {	
deleted autoscale vm profile for account id 

public void cleanUpAutoScaleResources(Long accountId) {	int count = 0;	count = _autoScaleVmProfileDao.removeByAccountId(accountId);	if (count > 0) {	}	count = _autoScalePolicyDao.removeByAccountId(accountId);	if (count > 0) {	
deleted autoscale policies for account id 

public void cleanUpAutoScaleResources(Long accountId) {	int count = 0;	count = _autoScaleVmProfileDao.removeByAccountId(accountId);	if (count > 0) {	}	count = _autoScalePolicyDao.removeByAccountId(accountId);	if (count > 0) {	}	count = _conditionDao.removeByAccountId(accountId);	if (count > 0) {	
deleted conditions for account id 

private boolean checkConditionUp(AutoScaleVmGroupVO asGroup, Integer numVm) {	Integer currentVM = _autoScaleVmGroupVmMapDao.countByGroup(asGroup.getId());	Integer maxVm = asGroup.getMaxMembers();	if (currentVM + numVm > maxVm) {	
number of vm will greater than the maximum in this group if scaling up so do nothing more 

private boolean checkConditionDown(AutoScaleVmGroupVO asGroup) {	Integer currentVM = _autoScaleVmGroupVmMapDao.countByGroup(asGroup.getId());	Integer minVm = asGroup.getMinMembers();	if (currentVM - 1 < minVm) {	
number of vm will less than the minimum in this group if scaling down so do nothing more 

if (vm != null) {	return vm.getId();	} else {	return -1;	}	} catch (InsufficientCapacityException ex) {	s_logger.info(ex);	s_logger.trace(ex.getMessage(), ex);	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, ex.getMessage());	} catch (ResourceUnavailableException ex) {	
exception 

} else {	return -1;	}	} catch (InsufficientCapacityException ex) {	s_logger.info(ex);	s_logger.trace(ex.getMessage(), ex);	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, ex.getMessage());	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

}	} catch (InsufficientCapacityException ex) {	s_logger.info(ex);	s_logger.trace(ex.getMessage(), ex);	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, ex.getMessage());	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ResourceAllocationException ex) {	
exception 

private boolean startNewVM(long vmId) {	try {	CallContext.current().setEventDetails("Vm Id: " + vmId);	_userVmManager.startVirtualMachine(vmId, null, null, null);	} catch (final ResourceUnavailableException ex) {	
exception 

private boolean startNewVM(long vmId) {	try {	CallContext.current().setEventDetails("Vm Id: " + vmId);	_userVmManager.startVirtualMachine(vmId, null, null, null);	} catch (final ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

private boolean assignLBruleToNewVm(long vmId, AutoScaleVmGroupVO asGroup) {	List<Long> lstVmId = new ArrayList<Long>();	long lbId = asGroup.getLoadBalancerId();	List<LoadBalancerVMMapVO> LbVmMapVos = _lbVmMapDao.listByLoadBalancerId(lbId);	if ((LbVmMapVos != null) && (LbVmMapVos.size() > 0)) {	for (LoadBalancerVMMapVO LbVmMapVo : LbVmMapVos) {	long instanceId = LbVmMapVo.getInstanceId();	if (instanceId == vmId) {	
the new vm is already mapped to lb rule what s wrong 

public void doScaleUp(long groupId, Integer numVm) {	AutoScaleVmGroupVO asGroup = _autoScaleVmGroupDao.findById(groupId);	if (asGroup == null) {	
can not find the groupid for scaling up 

AutoScaleVmGroupVO asGroup = _autoScaleVmGroupDao.findById(groupId);	if (asGroup == null) {	return;	}	if (!checkConditionUp(asGroup, numVm)) {	return;	}	for (int i = 0; i < numVm; i++) {	long vmId = createNewVM(asGroup);	if (vmId == -1) {	
can not deploy new vm for scaling up in the group waiting for next round 

List<AutoScaleVmGroupPolicyMapVO> GroupPolicyVOs = _autoScaleVmGroupPolicyMapDao .listByVmGroupId(groupId);	for (AutoScaleVmGroupPolicyMapVO GroupPolicyVO : GroupPolicyVOs) {	AutoScalePolicyVO vo = _autoScalePolicyDao .findById(GroupPolicyVO.getPolicyId());	if (vo.getAction().equals("scaleup")) {	vo.setLastQuiteTime(new Date());	_autoScalePolicyDao.persist(vo);	break;	}	}	} else {	
can not assign lb rule for this new vm 

if (vo.getAction().equals("scaleup")) {	vo.setLastQuiteTime(new Date());	_autoScalePolicyDao.persist(vo);	break;	}	}	} else {	break;	}	} else {	
can not deploy new vm for scaling up in the group waiting for next round 

public void doScaleDown(final long groupId) {	AutoScaleVmGroupVO asGroup = _autoScaleVmGroupDao.findById(groupId);	if (asGroup == null) {	
can not find the groupid for scaling up 

_userVmManager.destroyVm(vmId);	} catch (ResourceUnavailableException e) {	e.printStackTrace();	} catch (ConcurrentOperationException e) {	e.printStackTrace();	}	}	}, destroyVmGracePeriod, TimeUnit.SECONDS);	}	} else {	
can not remove lb rule for the vm being destroyed do nothing more 

========================= cloudstack sample_2342 =========================

commandLine.addArgument(outputFile.getAbsolutePath());	}	if (directoryName != null) {	commandLine.addArgument("-dr");	commandLine.addArgument(directoryName);	}	if (vars != null) {	commandLine.addArguments(vars, false);	}	DefaultExecutor executor = new DefaultExecutor();	
working directory 

========================= cloudstack sample_3 =========================

public ExecutionResult createFileInVR(final String routerIp, final String path, final String filename, final String content) {	final File permKey = new File("/root/.ssh/id_rsa.cloud");	String error = null;	try {	SshHelper.scpTo(routerIp, 3922, "root", permKey, null, path, content.getBytes(), filename, null);	} catch (final Exception e) {	
fail to create file in vr 

public String interpret(final BufferedReader reader) throws IOException {	String line = null;	int numLines = 0;	while ((line = reader.readLine()) != null) {	final String[] toks = line.trim().split("=");	if (toks.length < 2) {	
failed to parse script output 

int numLines = 0;	while ((line = reader.readLine()) != null) {	final String[] toks = line.trim().split("=");	if (toks.length < 2) {	} else {	map.put(toks[0].trim(), toks[1].trim());	}	numLines++;	}	if (numLines == 0) {	
keyvalueinterpreter no output lines 

private Map<String, Object> getDeveloperProperties() throws ConfigurationException {	final File file = PropertiesUtil.findConfigFile("developer.properties");	if (file == null) {	throw new ConfigurationException("Unable to find developer.properties.");	}	
developer properties found at 

throw new ConfigurationException("NO HVM support on this machine, please make sure: " + "1. VT/SVM is supported by your CPU, or is enabled in BIOS. " + "2. kvm modules are loaded (kvm, kvm_amd|kvm_intel)");	}	}	_hypervisorPath = getHypervisorPath(conn);	try {	_hvVersion = conn.getVersion();	_hvVersion = _hvVersion % 1000000 / 1000;	_hypervisorLibvirtVersion = conn.getLibVirVersion();	_hypervisorQemuVersion = conn.getVersion();	} catch (final LibvirtException e) {	
ignoring libvirt error 

_hvVersion = conn.getVersion();	_hvVersion = _hvVersion % 1000000 / 1000;	_hypervisorLibvirtVersion = conn.getLibVirVersion();	_hypervisorQemuVersion = conn.getVersion();	} catch (final LibvirtException e) {	}	_guestCpuMode = (String)params.get("guest.cpu.mode");	if (_guestCpuMode != null) {	_guestCpuModel = (String)params.get("guest.cpu.model");	if (_hypervisorLibvirtVersion < 9 * 1000 + 10) {	
libvirt version required for guest cpu mode but version detected so it will be disabled 

_sysvmISOPath = (String)params.get("systemvm.iso.path");	if (_sysvmISOPath == null) {	final String[] isoPaths = {"/usr/share/cloudstack-common/vms/systemvm.iso"};	for (final String isoPath : isoPaths) {	if (_storage.exists(isoPath)) {	_sysvmISOPath = isoPath;	break;	}	}	if (_sysvmISOPath == null) {	
can t find system vm iso 

if (_sysvmISOPath == null) {	}	}	switch (_bridgeType) {	case OPENVSWITCH: getOvsPifs();	break;	case NATIVE: default: getPifs();	break;	}	if (_pifs.get("private") == null) {	
failed to get private nic name 

switch (_bridgeType) {	case OPENVSWITCH: getOvsPifs();	break;	case NATIVE: default: getPifs();	break;	}	if (_pifs.get("private") == null) {	throw new ConfigurationException("Failed to get private nic name");	}	if (_pifs.get("public") == null) {	
failed to get public nic name 

break;	case NATIVE: default: getPifs();	break;	}	if (_pifs.get("private") == null) {	throw new ConfigurationException("Failed to get private nic name");	}	if (_pifs.get("public") == null) {	throw new ConfigurationException("Failed to get public nic name");	}	
found pif private on pif public on 

}	if (_pifs.get("private") == null) {	throw new ConfigurationException("Failed to get private nic name");	}	if (_pifs.get("public") == null) {	throw new ConfigurationException("Failed to get public nic name");	}	_canBridgeFirewall = canBridgeFirewall(_pifs.get("public"));	_localGateway = Script.runSimpleBashScript("ip route |grep default|awk '{print $3}'");	if (_localGateway == null) {	
failed to found the local gateway 

_migrateSpeed = NumbersUtil.parseInt(value, -1);	if (_migrateSpeed == -1) {	_migrateSpeed = 0;	final String speed = Script.runSimpleBashScript("ethtool " + _pifs.get("public") + " |grep Speed | cut -d \\  -f 2");	if (speed != null) {	final String[] tokens = speed.split("M");	if (tokens.length == 2) {	try {	_migrateSpeed = Integer.parseInt(tokens[0]);	} catch (final NumberFormatException e) {	
ignoring migratespeed extraction error 

if (_migrateSpeed == -1) {	_migrateSpeed = 0;	final String speed = Script.runSimpleBashScript("ethtool " + _pifs.get("public") + " |grep Speed | cut -d \\  -f 2");	if (speed != null) {	final String[] tokens = speed.split("M");	if (tokens.length == 2) {	try {	_migrateSpeed = Integer.parseInt(tokens[0]);	} catch (final NumberFormatException e) {	}	
device public has speed 

protected void configureVifDrivers(final Map<String, Object> params) throws ConfigurationException {	final String LIBVIRT_VIF_DRIVER = "libvirt.vif.driver";	_trafficTypeVifDrivers = new HashMap<TrafficType, VifDriver>();	String defaultVifDriverName = (String)params.get(LIBVIRT_VIF_DRIVER);	if (defaultVifDriverName == null) {	if (_bridgeType == BridgeType.OPENVSWITCH) {	
no libvirt vif driver specified defaults to ovsvifdriver 

protected void configureVifDrivers(final Map<String, Object> params) throws ConfigurationException {	final String LIBVIRT_VIF_DRIVER = "libvirt.vif.driver";	_trafficTypeVifDrivers = new HashMap<TrafficType, VifDriver>();	String defaultVifDriverName = (String)params.get(LIBVIRT_VIF_DRIVER);	if (defaultVifDriverName == null) {	if (_bridgeType == BridgeType.OPENVSWITCH) {	defaultVifDriverName = DEFAULT_OVS_VIF_DRIVER_CLASS_NAME;	} else {	
no libvirt vif driver specified defaults to bridgevifdriver 

private void getPifs() {	final File dir = new File("/sys/devices/virtual/net");	final File[] netdevs = dir.listFiles();	final List<String> bridges = new ArrayList<String>();	for (int i = 0; i < netdevs.length; i++) {	final File isbridge = new File(netdevs[i].getAbsolutePath() + "/bridge");	final String netdevName = netdevs[i].getName();	
looking in file bridge 

private void getPifs() {	final File dir = new File("/sys/devices/virtual/net");	final File[] netdevs = dir.listFiles();	final List<String> bridges = new ArrayList<String>();	for (int i = 0; i < netdevs.length; i++) {	final File isbridge = new File(netdevs[i].getAbsolutePath() + "/bridge");	final String netdevName = netdevs[i].getName();	if (isbridge.exists()) {	
found bridge 

final File[] netdevs = dir.listFiles();	final List<String> bridges = new ArrayList<String>();	for (int i = 0; i < netdevs.length; i++) {	final File isbridge = new File(netdevs[i].getAbsolutePath() + "/bridge");	final String netdevName = netdevs[i].getName();	if (isbridge.exists()) {	bridges.add(netdevName);	}	}	for (final String bridge : bridges) {	
looking for pif for bridge 

final String pif = getPif(bridge);	if (_publicBridgeName != null && bridge.equals(_publicBridgeName)) {	_pifs.put("public", pif);	}	if (_guestBridgeName != null && bridge.equals(_guestBridgeName)) {	_pifs.put("private", pif);	}	_pifs.put(bridge, pif);	}	if (_pifs.get("private") == null) {	
guest private traffic label not found as bridge looking for physical interface 

_pifs.put("public", pif);	}	if (_guestBridgeName != null && bridge.equals(_guestBridgeName)) {	_pifs.put("private", pif);	}	_pifs.put(bridge, pif);	}	if (_pifs.get("private") == null) {	final File dev = new File("/sys/class/net/" + _guestBridgeName);	if (dev.exists()) {	
guest private traffic label found as a physical device 

}	_pifs.put(bridge, pif);	}	if (_pifs.get("private") == null) {	final File dev = new File("/sys/class/net/" + _guestBridgeName);	if (dev.exists()) {	_pifs.put("private", _guestBridgeName);	}	}	if (_pifs.get("public") == null) {	
public traffic label not found as bridge looking for physical interface 

}	if (_pifs.get("private") == null) {	final File dev = new File("/sys/class/net/" + _guestBridgeName);	if (dev.exists()) {	_pifs.put("private", _guestBridgeName);	}	}	if (_pifs.get("public") == null) {	final File dev = new File("/sys/class/net/" + _publicBridgeName);	if (dev.exists()) {	
public traffic label found as a physical device 

if (dev.exists()) {	_pifs.put("private", _guestBridgeName);	}	}	if (_pifs.get("public") == null) {	final File dev = new File("/sys/class/net/" + _publicBridgeName);	if (dev.exists()) {	_pifs.put("public", _publicBridgeName);	}	}	
done looking for pifs no more bridges 

private void getOvsPifs() {	final String cmdout = Script.runSimpleBashScript("ovs-vsctl list-br | sed '{:q;N;s/\\n/%/g;t q}'");	
cmdout was 

private void getOvsPifs() {	final String cmdout = Script.runSimpleBashScript("ovs-vsctl list-br | sed '{:q;N;s/\\n/%/g;t q}'");	final List<String> bridges = Arrays.asList(cmdout.split("%"));	for (final String bridge : bridges) {	
looking for pif for bridge 

for (final String bridge : bridges) {	final String pif = bridge;	if (_publicBridgeName != null && bridge.equals(_publicBridgeName)) {	_pifs.put("public", pif);	}	if (_guestBridgeName != null && bridge.equals(_guestBridgeName)) {	_pifs.put("private", pif);	}	_pifs.put(bridge, pif);	}	
done looking for pifs no more bridges 

private String matchPifFileInDirectory(final String bridgeName) {	final File brif = new File("/sys/devices/virtual/net/" + bridgeName + "/brif");	if (!brif.isDirectory()) {	final File pif = new File("/sys/class/net/" + bridgeName);	if (pif.isDirectory()) {	return bridgeName;	}	
failing to get physical interface from bridge does exist 

if (!brif.isDirectory()) {	final File pif = new File("/sys/class/net/" + bridgeName);	if (pif.isDirectory()) {	return bridgeName;	}	return "";	}	final File[] interfaces = brif.listFiles();	for (int i = 0; i < interfaces.length; i++) {	final String fname = interfaces[i].getName();	
matchpiffileindirectory file name 

}	return "";	}	final File[] interfaces = brif.listFiles();	for (int i = 0; i < interfaces.length; i++) {	final String fname = interfaces[i].getName();	if (isInterface(fname)) {	return fname;	}	}	
failing to get physical interface from bridge did not find an eth bond team vlan em p p ens eno enp or enx in 

private boolean checkOvsNetwork(final String networkName) {	
checking if network exists as openvswitch bridge 

public boolean passCmdLine(final String vmName, final String cmdLine) throws InternalErrorException {	final Script command = new Script(_patchViaSocketPath, 5 * 1000, s_logger);	String result;	command.add("-n", vmName);	command.add("-p", cmdLine.replaceAll(" ", "%"));	result = command.execute();	if (result != null) {	
passcmd failed 

public boolean stop() {	try {	final Connect conn = LibvirtConnection.getConnection();	conn.close();	} catch (final LibvirtException e) {	
ignoring libvirt error 

public synchronized boolean findOrCreateTunnelNetwork(final String nwName) {	try {	if (checkNetwork(nwName)) {	return true;	}	final Map<String, String> otherConfig = new HashMap<String, String>();	otherConfig.put("ovs-host-setup", "");	Script.runSimpleBashScript("ovs-vsctl -- --may-exist add-br " + nwName + " -- set bridge " + nwName + " other_config:ovs-host-setup='-1'");	
kvm network for tunnels created 

public synchronized boolean findOrCreateTunnelNetwork(final String nwName) {	try {	if (checkNetwork(nwName)) {	return true;	}	final Map<String, String> otherConfig = new HashMap<String, String>();	otherConfig.put("ovs-host-setup", "");	Script.runSimpleBashScript("ovs-vsctl -- --may-exist add-br " + nwName + " -- set bridge " + nwName + " other_config:ovs-host-setup='-1'");	} catch (final Exception e) {	
createtunnelnetwork failed 

public synchronized boolean configureTunnelNetwork(final long networkId, final long hostId, final String nwName) {	try {	final boolean findResult = findOrCreateTunnelNetwork(nwName);	if (!findResult) {	
libvirtcomputingresource findorcreatetunnelnetwork failed cannot proceed creating the tunnel 

cmd.add("setup_ovs_bridge");	cmd.add("--key", nwName);	cmd.add("--cs_host_id", ((Long)hostId).toString());	cmd.add("--bridge", nwName);	final String result = cmd.execute();	if (result != null) {	throw new CloudRuntimeException( "Unable to pre-configure OVS bridge " + nwName + " for network ID:" + networkId);	}	}	} catch (final Exception e) {	
createandconfiguretunnelnetwork failed 

templateName = templateUrl.substring(index + 1);	}	KVMPhysicalDisk templateVol = null;	KVMStoragePool secondaryPool = null;	try {	secondaryPool = _storagePoolMgr.getStoragePoolByURI(mountpoint);	if (templateName == null) {	secondaryPool.refresh();	final List<KVMPhysicalDisk> disks = secondaryPool.listPhysicalDisks();	if (disks == null || disks.isEmpty()) {	
failed to get volumes from pool 

if (disks == null || disks.isEmpty()) {	return null;	}	for (final KVMPhysicalDisk disk : disks) {	if (disk.getName().endsWith("qcow2")) {	templateVol = disk;	break;	}	}	if (templateVol == null) {	
failed to get template from pool 

}	if (templateVol == null) {	return null;	}	} else {	templateVol = secondaryPool.getPhysicalDisk(templateName);	}	final KVMPhysicalDisk primaryVol = _storagePoolMgr.copyPhysicalDisk(templateVol, volUuid, primaryPool, 0);	return primaryVol;	} catch (final CloudRuntimeException e) {	
failed to download template to primary storage 

private String getBroadcastUriFromBridge(final String brName) {	final String pif = matchPifFileInDirectory(brName);	final Pattern pattern = Pattern.compile("(\\D+)(\\d+)(\\D*)(\\d*)(\\D*)(\\d*)");	final Matcher matcher = pattern.matcher(pif);	
getting broadcast uri for pif and bridge 

if(matcher.find()) {	if (brName.startsWith("brvx")){	return BroadcastDomainType.Vxlan.toUri(matcher.group(2)).toString();	}	else{	if (!matcher.group(6).isEmpty()) {	return BroadcastDomainType.Vlan.toUri(matcher.group(6)).toString();	} else if (!matcher.group(4).isEmpty()) {	return BroadcastDomainType.Vlan.toUri(matcher.group(4)).toString();	} else {	
failed to get vnet id from bridge attached to physical interface perhaps untagged interface 

else{	if (!matcher.group(6).isEmpty()) {	return BroadcastDomainType.Vlan.toUri(matcher.group(6)).toString();	} else if (!matcher.group(4).isEmpty()) {	return BroadcastDomainType.Vlan.toUri(matcher.group(4)).toString();	} else {	return "";	}	}	} else {	
failed to get vnet id from bridge attached to physical interface 

} else {	broadcastUriToNicNum.put(getBroadcastUriFromBridge(pluggedVlan), devNum);	}	devNum++;	}	for (final IpAddressTO ip : ips) {	ip.setNicDevId(broadcastUriToNicNum.get(ip.getBroadcastUri()));	}	return new ExecutionResult(true, null);	} catch (final LibvirtException e) {	
ip assoc failure on applying one ip due to exception 

broadcastUriAllocatedToVM.put(ip.getBroadcastUri(), nicPos++);	newNic = true;	}	nicNum = broadcastUriAllocatedToVM.get(ip.getBroadcastUri());	networkUsage(routerIp, "addVif", "eth" + nicNum);	ip.setNicDevId(nicNum);	ip.setNewNic(newNic);	}	return new ExecutionResult(true, null);	} catch (final LibvirtException e) {	
ipassoccmd failed 

}	nicNum = broadcastUriAllocatedToVM.get(ip.getBroadcastUri());	networkUsage(routerIp, "addVif", "eth" + nicNum);	ip.setNicDevId(nicNum);	ip.setNewNic(newNic);	}	return new ExecutionResult(true, null);	} catch (final LibvirtException e) {	return new ExecutionResult(false, e.getMessage());	} catch (final InternalErrorException e) {	
ipassoccmd failed 

VifHotPlug(conn, routerName, ip.getBroadcastUri(), ip.getVifMacAddress());	broadcastUriAllocatedToVM.put(ip.getBroadcastUri(), nicPos++);	}	nicNum = broadcastUriAllocatedToVM.get(ip.getBroadcastUri());	if (numOfIps == 1 && !ip.isAdd()) {	vifHotUnPlug(conn, routerName, ip.getVifMacAddress());	networkUsage(routerIp, "deleteVif", "eth" + nicNum);	}	}	} catch (final LibvirtException e) {	
ipassoccmd failed 

}	nicNum = broadcastUriAllocatedToVM.get(ip.getBroadcastUri());	if (numOfIps == 1 && !ip.isAdd()) {	vifHotUnPlug(conn, routerName, ip.getVifMacAddress());	networkUsage(routerIp, "deleteVif", "eth" + nicNum);	}	}	} catch (final LibvirtException e) {	return new ExecutionResult(false, e.getMessage());	} catch (final InternalErrorException e) {	
ipassoccmd failed 

public PowerState getVmState(final Connect conn, final String vmName) {	int retry = 3;	Domain vms = null;	while (retry-- > 0) {	try {	vms = conn.domainLookupByName(vmName);	final PowerState s = convertToPowerState(vms.getInfo().state);	return s;	} catch (final LibvirtException e) {	
can t get vm state retry 

vms = conn.domainLookupByName(vmName);	final PowerState s = convertToPowerState(vms.getInfo().state);	return s;	} catch (final LibvirtException e) {	} finally {	try {	if (vms != null) {	vms.free();	}	} catch (final LibvirtException l) {	
ignoring libvirt error 

} else if (option.equals("reset")) {	getUsage.add("-r");	} else if (option.equals("addVif")) {	getUsage.add("-a", vif);	} else if (option.equals("deleteVif")) {	getUsage.add("-d", vif);	}	final OutputInterpreter.OneLineParser usageParser = new OutputInterpreter.OneLineParser();	final String result = getUsage.execute(usageParser);	if (result != null) {	
failed to execute networkusage 

} else if (option.equals("reset")) {	getUsage.add("-r");	} else if (option.equals("vpn")) {	getUsage.add("-n");	} else if (option.equals("remove")) {	getUsage.add("-d");	}	final OutputInterpreter.OneLineParser usageParser = new OutputInterpreter.OneLineParser();	final String result = getUsage.execute(usageParser);	if (result != null) {	
failed to execute vpcnetworkusage 

} else if (volume.getType() != Volume.Type.ISO) {	final PrimaryDataStoreTO store = (PrimaryDataStoreTO)data.getDataStore();	physicalDisk = _storagePoolMgr.getPhysicalDisk(store.getPoolType(), store.getUuid(), data.getPath());	pool = physicalDisk.getPool();	}	String volPath = null;	if (physicalDisk != null) {	volPath = physicalDisk.getPath();	}	if (_diskActivityCheckEnabled && physicalDisk != null && physicalDisk.getFormat() == PhysicalDiskFormat.QCOW2) {	
checking physical disk file at path for disk activity to ensure vm is not running elsewhere 

String volPath = null;	if (physicalDisk != null) {	volPath = physicalDisk.getPath();	}	if (_diskActivityCheckEnabled && physicalDisk != null && physicalDisk.getFormat() == PhysicalDiskFormat.QCOW2) {	try {	HypervisorUtils.checkVolumeFileForActivity(volPath, _diskActivityCheckTimeoutSeconds, _diskActivityInactiveThresholdMilliseconds, _diskActivityCheckFileSizeMin);	} catch (final IOException ex) {	throw new CloudRuntimeException("Unable to check physical disk file for activity", ex);	}	
disk activity check cleared 

try {	HypervisorUtils.checkVolumeFileForActivity(volPath, _diskActivityCheckTimeoutSeconds, _diskActivityInactiveThresholdMilliseconds, _diskActivityCheckFileSizeMin);	} catch (final IOException ex) {	throw new CloudRuntimeException("Unable to check physical disk file for activity", ex);	}	}	DiskDef.DiskBus diskBusType = null;	final Map <String, String> params = vmSpec.getDetails();	if (params != null && params.get("rootDiskController") != null && !params.get("rootDiskController").isEmpty()) {	final String rootDiskController = params.get("rootDiskController");	
passed custom disk bus 

} catch (final IOException ex) {	throw new CloudRuntimeException("Unable to check physical disk file for activity", ex);	}	}	DiskDef.DiskBus diskBusType = null;	final Map <String, String> params = vmSpec.getDetails();	if (params != null && params.get("rootDiskController") != null && !params.get("rootDiskController").isEmpty()) {	final String rootDiskController = params.get("rootDiskController");	for (final DiskDef.DiskBus bus : DiskDef.DiskBus.values()) {	if (bus.toString().equalsIgnoreCase(rootDiskController)) {	
found matching enum for disk bus 

final KVMPhysicalDisk physicalDisk = _storagePoolMgr.getPhysicalDisk(store.getPoolType(), store.getUuid(), data.getPath());	final FilesystemDef rootFs = new FilesystemDef(physicalDisk.getPath(), "/");	vm.getDevices().addDevice(rootFs);	} else if (volume.getType() == Volume.Type.DATADISK) {	final KVMPhysicalDisk physicalDisk = _storagePoolMgr.getPhysicalDisk(store.getPoolType(), store.getUuid(), data.getPath());	final KVMStoragePool pool = physicalDisk.getPool();	if(StoragePoolType.RBD.equals(pool.getType())) {	final int devId = volume.getDiskSeq().intValue();	final String device = mapRbdDevice(physicalDisk);	if (device != null) {	
rbd device on host is 

private void createVif(final LibvirtVMDef vm, final NicTO nic, final String nicAdapter) throws InternalErrorException, LibvirtException {	if (nic.getType().equals(TrafficType.Guest) && nic.getBroadcastType().equals(BroadcastDomainType.Vsp)) {	String vrIp = nic.getBroadcastUri().getPath().substring(1);	vm.getMetaData().getMetadataNode(LibvirtVMDef.NuageExtensionDef.class).addNuageExtension(nic.getMac(), vrIp);	if (s_logger.isDebugEnabled()) {	
nic with mac and broadcastdomaintype in network is traffic type so vsp vr ip is set in the metadata 

public boolean cleanupDisk(final DiskDef disk) {	final String path = disk.getDiskPath();	if (path == null) {	
unable to clean up disk with null path perhaps empty cdrom drive 

protected synchronized String attachOrDetachDevice(final Connect conn, final boolean attach, final String vmName, final String xml) throws LibvirtException, InternalErrorException {	Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	if (attach) {	
attaching device 

protected synchronized String attachOrDetachDevice(final Connect conn, final boolean attach, final String vmName, final String xml) throws LibvirtException, InternalErrorException {	Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	if (attach) {	dm.attachDevice(xml);	} else {	
detaching device 

Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	if (attach) {	dm.attachDevice(xml);	} else {	dm.detachDevice(xml);	}	} catch (final LibvirtException e) {	if (attach) {	
failed to attach device to 

try {	dm = conn.domainLookupByName(vmName);	if (attach) {	dm.attachDevice(xml);	} else {	dm.detachDevice(xml);	}	} catch (final LibvirtException e) {	if (attach) {	} else {	
failed to detach device from 

} catch (final LibvirtException e) {	if (attach) {	} else {	}	throw e;	} finally {	if (dm != null) {	try {	dm.free();	} catch (final LibvirtException l) {	
ignoring libvirt error 

StartupStorageCommand sscmd = null;	try {	final KVMStoragePool localStoragePool = _storagePoolMgr.createStoragePool(_localStorageUUID, "localhost", -1, _localStoragePath, "", StoragePoolType.Filesystem);	final com.cloud.agent.api.StoragePoolInfo pi = new com.cloud.agent.api.StoragePoolInfo(localStoragePool.getUuid(), cmd.getPrivateIpAddress(), _localStoragePath, _localStoragePath, StoragePoolType.Filesystem, localStoragePool.getCapacity(), localStoragePool.getAvailable());	sscmd = new StartupStorageCommand();	sscmd.setPoolInfo(pi);	sscmd.setGuid(pi.getUuid());	sscmd.setDataCenter(_dcId);	sscmd.setResourceType(Storage.StorageResourceType.STORAGE_POOL);	} catch (final CloudRuntimeException e) {	
unable to initialize local storage pool 

protected List<String> getAllVmNames(final Connect conn) {	final ArrayList<String> la = new ArrayList<String>();	try {	final String names[] = conn.listDefinedDomains();	for (int i = 0; i < names.length; i++) {	la.add(names[i]);	}	} catch (final LibvirtException e) {	
failed to list defined domains 

final String names[] = conn.listDefinedDomains();	for (int i = 0; i < names.length; i++) {	la.add(names[i]);	}	} catch (final LibvirtException e) {	}	int[] ids = null;	try {	ids = conn.listDomains();	} catch (final LibvirtException e) {	
failed to list domains 

ids = conn.listDomains();	} catch (final LibvirtException e) {	return la;	}	Domain dm = null;	for (int i = 0; i < ids.length; i++) {	try {	dm = conn.domainLookupByID(ids[i]);	la.add(dm.getName());	} catch (final LibvirtException e) {	
unable to get vms 

try {	dm = conn.domainLookupByID(ids[i]);	la.add(dm.getName());	} catch (final LibvirtException e) {	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

private HashMap<String, HostVmStateReportEntry> getHostVmStateReport() {	final HashMap<String, HostVmStateReportEntry> vmStates = new HashMap<String, HostVmStateReportEntry>();	Connect conn = null;	if (_hypervisorType == HypervisorType.LXC) {	try {	conn = LibvirtConnection.getConnectionByType(HypervisorType.LXC.toString());	vmStates.putAll(getHostVmStateReport(conn));	conn = LibvirtConnection.getConnectionByType(HypervisorType.KVM.toString());	vmStates.putAll(getHostVmStateReport(conn));	} catch (final LibvirtException e) {	
failed to get connection 

conn = LibvirtConnection.getConnectionByType(HypervisorType.KVM.toString());	vmStates.putAll(getHostVmStateReport(conn));	} catch (final LibvirtException e) {	}	}	if (_hypervisorType == HypervisorType.KVM) {	try {	conn = LibvirtConnection.getConnectionByType(HypervisorType.KVM.toString());	vmStates.putAll(getHostVmStateReport(conn));	} catch (final LibvirtException e) {	
failed to get connection 

private HashMap<String, HostVmStateReportEntry> getHostVmStateReport(final Connect conn) {	final HashMap<String, HostVmStateReportEntry> vmStates = new HashMap<String, HostVmStateReportEntry>();	String[] vms = null;	int[] ids = null;	try {	ids = conn.listDomains();	} catch (final LibvirtException e) {	
unable to listdomains 

String[] vms = null;	int[] ids = null;	try {	ids = conn.listDomains();	} catch (final LibvirtException e) {	return null;	}	try {	vms = conn.listDefinedDomains();	} catch (final LibvirtException e) {	
unable to listdomains 

try {	dm = conn.domainLookupByID(ids[i]);	final DomainState ps = dm.getInfo().state;	final PowerState state = convertToPowerState(ps);	s_logger.trace("VM " + dm.getName() + ": powerstate = " + ps + "; vm state=" + state.toString());	final String vmName = dm.getName();	if (state == PowerState.PowerOn) {	vmStates.put(vmName, new HostVmStateReportEntry(state, conn.getHostName()));	}	} catch (final LibvirtException e) {	
unable to get vms 

if (state == PowerState.PowerOn) {	vmStates.put(vmName, new HostVmStateReportEntry(state, conn.getHostName()));	}	} catch (final LibvirtException e) {	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

try {	dm = conn.domainLookupByName(vms[i]);	final DomainState ps = dm.getInfo().state;	final PowerState state = convertToPowerState(ps);	final String vmName = dm.getName();	s_logger.trace("VM " + vmName + ": powerstate = " + ps + "; vm state=" + state.toString());	if (state == PowerState.PowerOn) {	vmStates.put(vmName, new HostVmStateReportEntry(state, conn.getHostName()));	}	} catch (final LibvirtException e) {	
unable to get vms 

if (state == PowerState.PowerOn) {	vmStates.put(vmName, new HostVmStateReportEntry(state, conn.getHostName()));	}	} catch (final LibvirtException e) {	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

ram = hosts.memory * 1024L;	final LibvirtCapXMLParser parser = new LibvirtCapXMLParser();	parser.parseCapabilitiesXML(conn.getCapabilities());	final ArrayList<String> oss = parser.getGuestOsType();	for (final String s : oss) {	if (s.equalsIgnoreCase("hvm")) {	cap = "hvm";	}	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

protected static long getCpuSpeed(final NodeInfo nodeInfo) {	try (final Reader reader = new FileReader( "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq")) {	return Long.parseLong(IOUtils.toString(reader).trim()) / 1000;	} catch (IOException | NumberFormatException e) {	
could not read cpuinfo max freq 

String vmDef = dm.getXMLDesc(1);	final LibvirtDomainXMLParser parser = new LibvirtDomainXMLParser();	parser.parseDomainXML(vmDef);	for (final InterfaceDef nic : parser.getInterfaces()) {	if (nic.getNetType() == GuestNetType.BRIDGE && nic.getBrName().startsWith("cloudVirBr")) {	try {	final int vnetId = Integer.parseInt(nic.getBrName().replaceFirst("cloudVirBr", ""));	final String pifName = getPif(_guestBridgeName);	final String newBrName = "br" + pifName + "-" + vnetId;	vmDef = vmDef.replaceAll("'" + nic.getBrName() + "'", "'" + newBrName + "'");	
vm bridge name is changed from to 

} catch (final NumberFormatException e) {	continue;	}	}	}	s_logger.debug(vmDef);	msg = stopVM(conn, vmName, false);	msg = startVM(conn, vmName, vmDef);	return null;	} catch (final LibvirtException e) {	
failed to create vm 

}	}	}	s_logger.debug(vmDef);	msg = stopVM(conn, vmName, false);	msg = startVM(conn, vmName, vmDef);	return null;	} catch (final LibvirtException e) {	msg = e.getMessage();	} catch (final InternalErrorException e) {	
failed to create vm 

} catch (final LibvirtException e) {	msg = e.getMessage();	} catch (final InternalErrorException e) {	msg = e.getMessage();	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

public String stopVM(final Connect conn, final String vmName, final boolean forceStop) {	DomainState state = null;	Domain dm = null;	
try to stop the vm at first 

String ret = stopVMInternal(conn, vmName, false);	if (ret == Script.ERR_TIMEOUT) {	ret = stopVMInternal(conn, vmName, true);	} else if (ret != null) {	for (int i = 0; i < 3; i++) {	try {	dm = conn.domainLookupByName(vmName);	state = dm.getInfo().state;	break;	} catch (final LibvirtException e) {	
failed to get vm status 

dm = conn.domainLookupByName(vmName);	state = dm.getInfo().state;	break;	} catch (final LibvirtException e) {	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException l) {	
ignoring libvirt error 

} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException l) {	}	}	}	if (state == null) {	
can t get vm s status assume it s dead already 

dm.free();	}	} catch (final LibvirtException l) {	}	}	}	if (state == null) {	return null;	}	if (state != DomainState.VIR_DOMAIN_SHUTOFF) {	
try to destroy the vm 

dm.shutdown();	int retry = _stopTimeout / 2000;	the dm object will no longer work, so we need to catch it. */ try {	while (dm.isActive() == 1 && retry >= 0) {	Thread.sleep(2000);	retry--;	}	} catch (final LibvirtException e) {	final String error = e.toString();	if (error.contains("Domain not found")) {	
successfully shut down vm 

int retry = _stopTimeout / 2000;	the dm object will no longer work, so we need to catch it. */ try {	while (dm.isActive() == 1 && retry >= 0) {	Thread.sleep(2000);	retry--;	}	} catch (final LibvirtException e) {	final String error = e.toString();	if (error.contains("Domain not found")) {	} else {	
error in waiting for vm shutdown 

Thread.sleep(2000);	retry--;	}	} catch (final LibvirtException e) {	final String error = e.toString();	if (error.contains("Domain not found")) {	} else {	}	}	if (retry < 0) {	
timed out waiting for domain to shutdown gracefully 

if (retry < 0) {	return Script.ERR_TIMEOUT;	} else {	if (persist == 1) {	dm.undefine();	}	}	}	} catch (final LibvirtException e) {	if (e.getMessage().contains("Domain not found")) {	
vm doesn t exist no need to stop it 

} else {	if (persist == 1) {	dm.undefine();	}	}	}	} catch (final LibvirtException e) {	if (e.getMessage().contains("Domain not found")) {	return null;	}	
failed to stop vm 

dm.undefine();	}	}	}	} catch (final LibvirtException e) {	if (e.getMessage().contains("Domain not found")) {	return null;	}	return e.getMessage();	} catch (final InterruptedException ie) {	
interrupted sleep 

}	return e.getMessage();	} catch (final InterruptedException ie) {	return ie.getMessage();	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

dm = conn.domainLookupByName(vmName);	final String xmlDesc = dm.getXMLDesc(0);	parser.parseDomainXML(xmlDesc);	return parser.getVncPort();	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException l) {	
ignoring libvirt error 

final LibvirtCapXMLParser parser = new LibvirtCapXMLParser();	try {	parser.parseCapabilitiesXML(conn.getCapabilities());	final ArrayList<String> osTypes = parser.getGuestOsType();	for (final String o : osTypes) {	if (o.equalsIgnoreCase("hvm")) {	return true;	}	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

public List<InterfaceDef> getInterfaces(final Connect conn, final String vmName) {	final LibvirtDomainXMLParser parser = new LibvirtDomainXMLParser();	Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	parser.parseDomainXML(dm.getXMLDesc(0));	return parser.getInterfaces();	} catch (final LibvirtException e) {	
failed to get dom xml 

parser.parseDomainXML(dm.getXMLDesc(0));	return parser.getInterfaces();	} catch (final LibvirtException e) {	return new ArrayList<InterfaceDef>();	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

public List<DiskDef> getDisks(final Connect conn, final String vmName) {	final LibvirtDomainXMLParser parser = new LibvirtDomainXMLParser();	Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	parser.parseDomainXML(dm.getXMLDesc(0));	return parser.getDisks();	} catch (final LibvirtException e) {	
failed to get dom xml 

parser.parseDomainXML(dm.getXMLDesc(0));	return parser.getDisks();	} catch (final LibvirtException e) {	return new ArrayList<DiskDef>();	} finally {	try {	if (dm != null) {	dm.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

static double readDouble(final String nicName, final String fileName) {	final String path = "/sys/class/net/" + nicName + "/statistics/" + fileName;	try {	return Double.parseDouble(FileUtils.readFileToString(new File(path)));	} catch (final IOException ioe) {	
failed to read the for from 

========================= cloudstack sample_1094 =========================

final TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	final SearchCriteria<SecurityGroupWorkVO> sc = UntakenWorkSearch.create();	sc.setParameters("step", Step.Scheduled);	final Filter filter = new Filter(SecurityGroupWorkVO.class, null, true, 0l, 1l);	txn.start();	final List<SecurityGroupWorkVO> vos = lockRows(sc, filter, true);	if (vos.size() == 0) {	txn.commit();	if (s_logger.isTraceEnabled()) {	
security group take no work found 

========================= cloudstack sample_4279 =========================

public void resetHostSyncState(long hostId) {	
reset vm power state sync for host 

public void processHostVmStateReport(long hostId, Map<String, HostVmStateReportEntry> report) {	
process host vm state report from ping process host 

public void processHostVmStatePingReport(long hostId, Map<String, HostVmStateReportEntry> report) {	
process host vm state report from ping process host 

private void processReport(long hostId, Map<Long, VirtualMachine.PowerState> translatedInfo) {	
process vm state report host number of records in report 

private void processReport(long hostId, Map<Long, VirtualMachine.PowerState> translatedInfo) {	for (Map.Entry<Long, VirtualMachine.PowerState> entry : translatedInfo.entrySet()) {	
vm state report host vm id power state 

private void processReport(long hostId, Map<Long, VirtualMachine.PowerState> translatedInfo) {	for (Map.Entry<Long, VirtualMachine.PowerState> entry : translatedInfo.entrySet()) {	if (_instanceDao.updatePowerState(entry.getKey(), hostId, entry.getValue())) {	
vm state report is updated host vm id power state 

private void processReport(long hostId, Map<Long, VirtualMachine.PowerState> translatedInfo) {	for (Map.Entry<Long, VirtualMachine.PowerState> entry : translatedInfo.entrySet()) {	if (_instanceDao.updatePowerState(entry.getKey(), hostId, entry.getValue())) {	_messageBus.publish(null, VirtualMachineManager.Topics.VM_POWER_STATE, PublishScope.GLOBAL, entry.getKey());	} else {	
vm power state does not change skip db writing vm id 

}	}	List<VMInstanceVO> vmsThatAreMissingReport = _instanceDao.findByHostInStates(hostId, VirtualMachine.State.Running, VirtualMachine.State.Stopping, VirtualMachine.State.Starting);	java.util.Iterator<VMInstanceVO> it = vmsThatAreMissingReport.iterator();	while (it.hasNext()) {	VMInstanceVO instance = it.next();	if (translatedInfo.get(instance.getId()) != null) it.remove();	}	if (vmsThatAreMissingReport.size() > 0) {	Date currentTime = DateUtil.currentGMTTime();	
run missing vm report current time 

while (it.hasNext()) {	VMInstanceVO instance = it.next();	if (translatedInfo.get(instance.getId()) != null) it.remove();	}	if (vmsThatAreMissingReport.size() > 0) {	Date currentTime = DateUtil.currentGMTTime();	long milliSecondsGracefullPeriod = PingInterval.value() * 2000L;	for (VMInstanceVO instance : vmsThatAreMissingReport) {	try {	if (!_instanceDao.isPowerStateUpToDate(instance.getId())) {	
detected missing vm but power state is outdated wait for another process report run for vm id 

if (vmsThatAreMissingReport.size() > 0) {	Date currentTime = DateUtil.currentGMTTime();	long milliSecondsGracefullPeriod = PingInterval.value() * 2000L;	for (VMInstanceVO instance : vmsThatAreMissingReport) {	try {	if (!_instanceDao.isPowerStateUpToDate(instance.getId())) {	_instanceDao.resetVmPowerStateTracking(instance.getId());	continue;	}	} catch (CloudRuntimeException e) {	
checked for missing powerstate of a none existing vm 

try {	if (!_instanceDao.isPowerStateUpToDate(instance.getId())) {	_instanceDao.resetVmPowerStateTracking(instance.getId());	continue;	}	} catch (CloudRuntimeException e) {	continue;	}	Date vmStateUpdateTime = instance.getPowerStateUpdateTime();	if (vmStateUpdateTime == null) {	
vm state was updated but update time is null vm id 

_instanceDao.resetVmPowerStateTracking(instance.getId());	continue;	}	} catch (CloudRuntimeException e) {	continue;	}	Date vmStateUpdateTime = instance.getPowerStateUpdateTime();	if (vmStateUpdateTime == null) {	vmStateUpdateTime = currentTime;	}	
detected missing vm host vm id power state powerreportmissing last state update 

}	} catch (CloudRuntimeException e) {	continue;	}	Date vmStateUpdateTime = instance.getPowerStateUpdateTime();	if (vmStateUpdateTime == null) {	vmStateUpdateTime = currentTime;	}	long milliSecondsSinceLastStateUpdate = currentTime.getTime() - vmStateUpdateTime.getTime();	if (milliSecondsSinceLastStateUpdate > milliSecondsGracefullPeriod) {	
vm id time since last state update ms has passed graceful period 

} catch (CloudRuntimeException e) {	continue;	}	Date vmStateUpdateTime = instance.getPowerStateUpdateTime();	if (vmStateUpdateTime == null) {	vmStateUpdateTime = currentTime;	}	long milliSecondsSinceLastStateUpdate = currentTime.getTime() - vmStateUpdateTime.getTime();	if (milliSecondsSinceLastStateUpdate > milliSecondsGracefullPeriod) {	if (_instanceDao.updatePowerState(instance.getId(), hostId, VirtualMachine.PowerState.PowerReportMissing)) {	
vm state report is updated host vm id power state powerreportmissing 

}	Date vmStateUpdateTime = instance.getPowerStateUpdateTime();	if (vmStateUpdateTime == null) {	vmStateUpdateTime = currentTime;	}	long milliSecondsSinceLastStateUpdate = currentTime.getTime() - vmStateUpdateTime.getTime();	if (milliSecondsSinceLastStateUpdate > milliSecondsGracefullPeriod) {	if (_instanceDao.updatePowerState(instance.getId(), hostId, VirtualMachine.PowerState.PowerReportMissing)) {	_messageBus.publish(null, VirtualMachineManager.Topics.VM_POWER_STATE, PublishScope.GLOBAL, instance.getId());	} else {	
vm power state does not change skip db writing vm id 

if (vmStateUpdateTime == null) {	vmStateUpdateTime = currentTime;	}	long milliSecondsSinceLastStateUpdate = currentTime.getTime() - vmStateUpdateTime.getTime();	if (milliSecondsSinceLastStateUpdate > milliSecondsGracefullPeriod) {	if (_instanceDao.updatePowerState(instance.getId(), hostId, VirtualMachine.PowerState.PowerReportMissing)) {	_messageBus.publish(null, VirtualMachineManager.Topics.VM_POWER_STATE, PublishScope.GLOBAL, instance.getId());	} else {	}	} else {	
vm id time since last state update ms has not passed graceful period yet 

long milliSecondsSinceLastStateUpdate = currentTime.getTime() - vmStateUpdateTime.getTime();	if (milliSecondsSinceLastStateUpdate > milliSecondsGracefullPeriod) {	if (_instanceDao.updatePowerState(instance.getId(), hostId, VirtualMachine.PowerState.PowerReportMissing)) {	_messageBus.publish(null, VirtualMachineManager.Topics.VM_POWER_STATE, PublishScope.GLOBAL, instance.getId());	} else {	}	} else {	}	}	}	
done with process of vm state report host 

public Map<Long, VirtualMachine.PowerState> convertVmStateReport(Map<String, HostVmStateReportEntry> states) {	final HashMap<Long, VirtualMachine.PowerState> map = new HashMap<Long, VirtualMachine.PowerState>();	if (states == null) {	return map;	}	for (Map.Entry<String, HostVmStateReportEntry> entry : states.entrySet()) {	VMInstanceVO vm = findVM(entry.getKey());	if (vm != null) {	map.put(vm.getId(), entry.getValue().getState());	} else {	
unable to find matched vm in cloudstack db name 

========================= cloudstack sample_4783 =========================

}	for (VMTemplateVO builtinTmplt : defaultBuiltin) {	if (builtinTmplt.getHypervisorType() == hostHyper) {	toBeDownloaded.add(builtinTmplt);	}	}	for (VMTemplateVO template : toBeDownloaded) {	TemplateDataStoreVO tmpltHost = _vmTemplateStoreDao.findByStoreTemplate(store.getId(), template.getId());	if (tmpltHost == null) {	associateTemplateToZone(template.getId(), dcId);	
downloading builtin template to data center 

public void handleTemplateSync(DataStore store) {	if (store == null) {	
huh image store is null 

}	toBeDownloaded.addAll(allTemplates);	final StateMachine2<VirtualMachineTemplate.State, VirtualMachineTemplate.Event, VirtualMachineTemplate> stateMachine = VirtualMachineTemplate.State.getStateMachine();	for (VMTemplateVO tmplt : allTemplates) {	String uniqueName = tmplt.getUniqueName();	TemplateDataStoreVO tmpltStore = _vmTemplateStoreDao.findByStoreTemplate(storeId, tmplt.getId());	if (templateInfos.containsKey(uniqueName)) {	TemplateProp tmpltInfo = templateInfos.remove(uniqueName);	toBeDownloaded.remove(tmplt);	if (tmpltStore != null) {	
template sync found already in the image store 

if (tmpltStore.getDownloadState() != Status.DOWNLOADED) {	tmpltStore.setErrorString("");	}	if (tmpltInfo.isCorrupted()) {	tmpltStore.setDownloadState(Status.DOWNLOAD_ERROR);	String msg = "Template " + tmplt.getName() + ":" + tmplt.getId() + " is corrupted on secondary storage " + tmpltStore.getId();	tmpltStore.setErrorString(msg);	s_logger.info(msg);	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_UPLOAD_FAILED, zoneId, null, msg, msg);	if (tmplt.getState() == VirtualMachineTemplate.State.NotUploaded || tmplt.getState() == VirtualMachineTemplate.State.UploadInProgress) {	
template sync found on image store uploaded using ssvm as corrupted marking it as failed 

tmpltStore.setDownloadState(Status.DOWNLOAD_ERROR);	String msg = "Template " + tmplt.getName() + ":" + tmplt.getId() + " is corrupted on secondary storage " + tmpltStore.getId();	tmpltStore.setErrorString(msg);	s_logger.info(msg);	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_UPLOAD_FAILED, zoneId, null, msg, msg);	if (tmplt.getState() == VirtualMachineTemplate.State.NotUploaded || tmplt.getState() == VirtualMachineTemplate.State.UploadInProgress) {	tmpltStore.setState(State.Failed);	try {	stateMachine.transitTo(tmplt, VirtualMachineTemplate.Event.OperationFailed, null, _templateDao);	} catch (NoTransitionException e) {	
unexpected state transition exception for template details 

if (tmplt.getState() == VirtualMachineTemplate.State.NotUploaded || tmplt.getState() == VirtualMachineTemplate.State.UploadInProgress) {	tmpltStore.setState(State.Failed);	try {	stateMachine.transitTo(tmplt, VirtualMachineTemplate.Event.OperationFailed, null, _templateDao);	} catch (NoTransitionException e) {	}	} else if (tmplt.getUrl() == null) {	msg = "Private template (" + tmplt + ") with install path " + tmpltInfo.getInstallPath() + " is corrupted, please check in image store: " + tmpltStore.getDataStoreId();	s_logger.warn(msg);	} else {	
removing template store ref entry for corrupted template 

tmpltStore.setSize(tmpltInfo.getSize());	tmpltStore.setPhysicalSize(tmpltInfo.getPhysicalSize());	tmpltStore.setLastUpdated(new Date());	VMTemplateVO tmlpt = _templateDao.findById(tmplt.getId());	tmlpt.setSize(tmpltInfo.getSize());	_templateDao.update(tmplt.getId(), tmlpt);	if (tmplt.getState() == VirtualMachineTemplate.State.NotUploaded || tmplt.getState() == VirtualMachineTemplate.State.UploadInProgress) {	try {	stateMachine.transitTo(tmplt, VirtualMachineTemplate.Event.OperationSucceeded, null, _templateDao);	} catch (NoTransitionException e) {	
unexpected state transition exception for template details 

tmlpt.setSize(tmpltInfo.getSize());	_templateDao.update(tmplt.getId(), tmlpt);	associateTemplateToZone(tmplt.getId(), zoneId);	String etype = EventTypes.EVENT_TEMPLATE_CREATE;	if (tmplt.getFormat() == ImageFormat.ISO) {	etype = EventTypes.EVENT_ISO_CREATE;	}	UsageEventUtils.publishUsageEvent(etype, tmplt.getAccountId(), zoneId, tmplt.getId(), tmplt.getName(), null, null, tmpltInfo.getPhysicalSize(), tmpltInfo.getSize(), VirtualMachineTemplate.class.getName(), tmplt.getUuid());	}	} else if (tmplt.getState() == VirtualMachineTemplate.State.NotUploaded || tmplt.getState() == VirtualMachineTemplate.State.UploadInProgress) {	
template sync did not find on image store uploaded using ssvm marking it as failed 

} else if (tmplt.getState() == VirtualMachineTemplate.State.NotUploaded || tmplt.getState() == VirtualMachineTemplate.State.UploadInProgress) {	toBeDownloaded.remove(tmplt);	tmpltStore.setDownloadState(Status.DOWNLOAD_ERROR);	String msg = "Template " + tmplt.getName() + ":" + tmplt.getId() + " is corrupted on secondary storage " + tmpltStore.getId();	tmpltStore.setErrorString(msg);	tmpltStore.setState(State.Failed);	_vmTemplateStoreDao.update(tmpltStore.getId(), tmpltStore);	try {	stateMachine.transitTo(tmplt, VirtualMachineTemplate.Event.OperationFailed, null, _templateDao);	} catch (NoTransitionException e) {	
unexpected state transition exception for template details 

tmpltStore.setDownloadState(Status.DOWNLOAD_ERROR);	String msg = "Template " + tmplt.getName() + ":" + tmplt.getId() + " is corrupted on secondary storage " + tmpltStore.getId();	tmpltStore.setErrorString(msg);	tmpltStore.setState(State.Failed);	_vmTemplateStoreDao.update(tmpltStore.getId(), tmpltStore);	try {	stateMachine.transitTo(tmplt, VirtualMachineTemplate.Event.OperationFailed, null, _templateDao);	} catch (NoTransitionException e) {	}	} else {	
template sync did not find on image store may request download based on available hypervisor types 

tmpltStore.setErrorString(msg);	tmpltStore.setState(State.Failed);	_vmTemplateStoreDao.update(tmpltStore.getId(), tmpltStore);	try {	stateMachine.transitTo(tmplt, VirtualMachineTemplate.Event.OperationFailed, null, _templateDao);	} catch (NoTransitionException e) {	}	} else {	if (tmpltStore != null) {	if (_storeMgr.isRegionStore(store) && tmpltStore.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED && tmpltStore.getState() == State.Ready && tmpltStore.getInstallPath() == null) {	
keep fake entry in template store table for migration of previous nfs to object store 

tmpltStore.setState(State.Failed);	_vmTemplateStoreDao.update(tmpltStore.getId(), tmpltStore);	try {	stateMachine.transitTo(tmplt, VirtualMachineTemplate.Event.OperationFailed, null, _templateDao);	} catch (NoTransitionException e) {	}	} else {	if (tmpltStore != null) {	if (_storeMgr.isRegionStore(store) && tmpltStore.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED && tmpltStore.getState() == State.Ready && tmpltStore.getInstallPath() == null) {	} else {	
removing leftover template entry from template store table 

}	if (toBeDownloaded.size() > 0) {	List<HypervisorType> availHypers = _clusterDao.getAvailableHypervisorInZone(zoneId);	if (availHypers.isEmpty()) {	availHypers.add(HypervisorType.KVM);	}	availHypers.remove(HypervisorType.BareMetal);	availHypers.add(HypervisorType.None);	for (VMTemplateVO tmplt : toBeDownloaded) {	if (tmplt.getUrl() == null) {	
skip downloading template since no url is specified 

if (availHypers.isEmpty()) {	availHypers.add(HypervisorType.KVM);	}	availHypers.remove(HypervisorType.BareMetal);	availHypers.add(HypervisorType.None);	for (VMTemplateVO tmplt : toBeDownloaded) {	if (tmplt.getUrl() == null) {	continue;	}	if (!tmplt.isPublicTemplate() && !tmplt.isFeatured() && tmplt.getTemplateType() != TemplateType.SYSTEM) {	
skip sync downloading private template to a new image store 

for (VMTemplateVO tmplt : toBeDownloaded) {	if (tmplt.getUrl() == null) {	continue;	}	if (!tmplt.isPublicTemplate() && !tmplt.isFeatured() && tmplt.getTemplateType() != TemplateType.SYSTEM) {	continue;	}	if (_storeMgr.isRegionStore(store)) {	TemplateDataStoreVO tmpltStore = _vmTemplateStoreDao.findByStoreTemplate(storeId, tmplt.getId());	if (tmpltStore != null && tmpltStore.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED && tmpltStore.getState() == State.Ready && tmpltStore.getInstallPath() == null) {	
skip sync template for migration of previous nfs to object store 

if (!tmplt.isPublicTemplate() && !tmplt.isFeatured() && tmplt.getTemplateType() != TemplateType.SYSTEM) {	continue;	}	if (_storeMgr.isRegionStore(store)) {	TemplateDataStoreVO tmpltStore = _vmTemplateStoreDao.findByStoreTemplate(storeId, tmplt.getId());	if (tmpltStore != null && tmpltStore.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED && tmpltStore.getState() == State.Ready && tmpltStore.getInstallPath() == null) {	continue;	}	}	if (availHypers.contains(tmplt.getHypervisorType())) {	
downloading template to image store 

}	if (availHypers.contains(tmplt.getHypervisorType())) {	associateTemplateToZone(tmplt.getId(), zoneId);	TemplateInfo tmpl = _templateFactory.getTemplate(tmplt.getId(), store);	TemplateOpContext<TemplateApiResult> context = new TemplateOpContext<>(null,(TemplateObject)tmpl, null);	AsyncCallbackDispatcher<TemplateServiceImpl, TemplateApiResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().createTemplateAsyncCallBack(null, null));	caller.setContext(context);	createTemplateAsync(tmpl, store, caller);	} else {	
skip downloading template since current data center does not have hypervisor 

EndPoint ep = _epSelector.select(store);	Answer answer = null;	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(dtCommand, false, errMsg);	} else {	answer = ep.sendMessage(dtCommand);	}	if (answer == null || !answer.getResult()) {	
failed to deleted template at store 

} else {	String description = "Deleted template " + tInfo.getTemplateName() + " on secondary storage " + storeId;	s_logger.info(description);	}	}	}	} finally {	syncLock.unlock();	}	} else {	
couldn t get global lock on another thread may be doing template sync on data store now 

String etype = EventTypes.EVENT_TEMPLATE_CREATE;	if (tmplt.getFormat() == ImageFormat.ISO) {	etype = EventTypes.EVENT_ISO_CREATE;	}	long physicalSize = 0;	DataStore ds = template.getDataStore();	TemplateDataStoreVO tmpltStore = _vmTemplateStoreDao.findByStoreTemplate(ds.getId(), template.getId());	if (tmpltStore != null) {	physicalSize = tmpltStore.getPhysicalSize();	} else {	
no entry found in template store ref for template id and image store id at the end of registering template 

DataStore ds = template.getDataStore();	TemplateDataStoreVO tmpltStore = _vmTemplateStoreDao.findByStoreTemplate(ds.getId(), template.getId());	if (tmpltStore != null) {	physicalSize = tmpltStore.getPhysicalSize();	} else {	}	Scope dsScope = ds.getScope();	if (dsScope.getScopeId() != null) {	UsageEventUtils.publishUsageEvent(etype, template.getAccountId(), dsScope.getScopeId(), template.getId(), template.getName(), null, null, physicalSize, template.getSize(), VirtualMachineTemplate.class.getName(), template.getUuid());	} else {	
zone scope image store has a null scope id 

s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if (answer != null && answer.getResult()) {	ListTemplateAnswer tanswer = (ListTemplateAnswer)answer;	return tanswer.getTemplateInfo();	} else {	if (s_logger.isDebugEnabled()) {	
can not list template for secondary storage host 

AsyncCallFuture<TemplateApiResult> future = context.getFuture();	TemplateApiResult res = new TemplateApiResult(destTemplate);	try {	if (result.isFailed()) {	res.setResult(result.getResult());	} else {	destTemplate.processEvent(Event.OperationSuccessed, result.getAnswer());	}	future.complete(res);	} catch (Exception e) {	
failed to process sync template callback 

public void syncTemplateToRegionStore(long templateId, DataStore store) {	if (_storeMgr.isRegionStore(store)) {	if (s_logger.isDebugEnabled()) {	
sync template from cache to object store 

public AsyncCallFuture<TemplateApiResult> copyTemplate(TemplateInfo srcTemplate, DataStore destStore) {	if (srcTemplate.getFormat() == ImageFormat.OVA){	ImageStoreEntity tmpltStore = (ImageStoreEntity)srcTemplate.getDataStore();	tmpltStore.createEntityExtractUrl(srcTemplate.getInstallPath(), srcTemplate.getFormat(), srcTemplate);	}	String url = generateCopyUrl(srcTemplate);	if (url == null) {	
unable to start resume copy of template to no secondary storage vm in running state in source zone 

if (srcTemplate.getFormat() == ImageFormat.OVA){	ImageStoreEntity tmpltStore = (ImageStoreEntity)srcTemplate.getDataStore();	tmpltStore.createEntityExtractUrl(srcTemplate.getInstallPath(), srcTemplate.getFormat(), srcTemplate);	}	String url = generateCopyUrl(srcTemplate);	if (url == null) {	throw new CloudRuntimeException("No secondary VM in running state in source template zone ");	}	TemplateObject tmplForCopy = (TemplateObject)_templateFactory.getTemplate(srcTemplate, destStore);	if (s_logger.isDebugEnabled()) {	
setting source template url to 

}	String url = generateCopyUrl(srcTemplate);	if (url == null) {	throw new CloudRuntimeException("No secondary VM in running state in source template zone ");	}	TemplateObject tmplForCopy = (TemplateObject)_templateFactory.getTemplate(srcTemplate, destStore);	if (s_logger.isDebugEnabled()) {	}	tmplForCopy.setUrl(url);	if (s_logger.isDebugEnabled()) {	
mark template store ref entry as creating 

TemplateObject tmplForCopy = (TemplateObject)_templateFactory.getTemplate(srcTemplate, destStore);	if (s_logger.isDebugEnabled()) {	}	tmplForCopy.setUrl(url);	if (s_logger.isDebugEnabled()) {	}	AsyncCallFuture<TemplateApiResult> future = new AsyncCallFuture<TemplateApiResult>();	DataObject templateOnStore = destStore.create(tmplForCopy);	templateOnStore.processEvent(Event.CreateOnlyRequested);	if (s_logger.isDebugEnabled()) {	
invoke datastore driver createasync to create template on destination store 

private String generateCopyUrl(String ipAddress, String dir, String path) {	String hostname = ipAddress;	String scheme = "http";	boolean _sslCopy = false;	String sslCfg = _configDao.getValue(Config.SecStorageEncryptCopy.toString());	String _ssvmUrlDomain = _configDao.getValue("secstorage.ssl.cert.domain");	if (sslCfg != null) {	_sslCopy = Boolean.parseBoolean(sslCfg);	}	if(_sslCopy && (_ssvmUrlDomain == null || _ssvmUrlDomain.isEmpty())){	
empty secondary storage url domain ignoring ssl 

private String generateCopyUrl(TemplateInfo srcTemplate) {	DataStore srcStore = srcTemplate.getDataStore();	EndPoint ep = _epSelector.select(srcTemplate);	if (ep != null) {	if (ep.getPublicAddr() == null) {	
a running secondary storage vm has a null public ip 

TemplateApiResult res = new TemplateApiResult(destTemplate);	try {	if (result.isFailed()) {	res.setResult(result.getResult());	destTemplate.processEvent(Event.OperationFailed);	} else {	destTemplate.processEvent(Event.OperationSuccessed, result.getAnswer());	}	future.complete(res);	} catch (Exception e) {	
failed to process copy template callback 

protected Void copyTemplateCrossZoneCallBack(AsyncCallbackDispatcher<TemplateServiceImpl, CreateCmdResult> callback, TemplateOpContext<TemplateApiResult> context) {	if (s_logger.isDebugEnabled()) {	
performing copy template cross zone callback after completion 

TemplateApiResult res = new TemplateApiResult(destTemplate);	try {	if (result.isFailed()) {	res.setResult(result.getResult());	destTemplate.processEvent(Event.OperationFailed);	} else {	destTemplate.processEvent(Event.OperationSuccessed, result.getAnswer());	}	future.complete(res);	} catch (Exception e) {	
failed to process copy template cross zones callback 

========================= cloudstack sample_3945 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all storage usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageStorageVO> usageUsageStorages = s_usageStorageDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate, false, 0);	if (usageUsageStorages.isEmpty()) {	
no storage usage events for this period 

private static void createUsageRecord(long zoneId, int type, long runningTime, Date startDate, Date endDate, AccountVO account, long storageId, Long sourceId, long size, Long virtualSize) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(long zoneId, int type, long runningTime, Date startDate, Date endDate, AccountVO account, long storageId, Long sourceId, long size, Long virtualSize) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating storage usage record for type with id usage startdate enddate for account 

========================= cloudstack sample_2657 =========================

try {	txn.start();	String sql = REMOVE_BY_USERID_LBID;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, accountId);	pstmt.setLong(2, lbId);	pstmt.executeUpdate();	txn.commit();	} catch (Exception e) {	txn.rollback();	
error removing usageloadbalancerpolicyvo 

pstmt.setLong(3, usage.getId());	pstmt.executeUpdate();	}	}catch (SQLException e) {	throw new CloudException("Error updating UsageLoadBalancerPolicyVO:" + e.getMessage(), e);	}	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usageloadbalancerpolicyvo 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (deletedTS != null) {	deletedDate = DateUtil.parseDateString(s_gmtTimeZone, deletedTS);	}	usageRecords.add(new UsageLoadBalancerPolicyVO(lbId, zoneId, acctId, dId, createdDate, deletedDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4500 =========================

public void close() {	
close progressreporter interrupt reporter runner to let it quit 

public void run() {	while (!_done) {	try {	Thread.sleep(1000);	updateLeaseProgress(_percent);	} catch (InterruptedException e) {	
progressreporter is interrupted quiting 

public void run() {	while (!_done) {	try {	Thread.sleep(1000);	updateLeaseProgress(_percent);	} catch (InterruptedException e) {	break;	} catch (Exception e) {	
unexpected exception 

public void run() {	while (!_done) {	try {	Thread.sleep(1000);	updateLeaseProgress(_percent);	} catch (InterruptedException e) {	break;	} catch (Exception e) {	}	}	
progressreporter stopped 

========================= cloudstack sample_2084 =========================

public PingCommand getCurrentStatus(long id) {	Output output;	try {	output = _brocadeVcsApi.getSwitchStatus();	} catch (BrocadeVcsApiException e) {	
getswitchstatus failed 

Output output;	try {	output = _brocadeVcsApi.getSwitchStatus();	} catch (BrocadeVcsApiException e) {	return null;	}	List<VcsNodeInfo> vcsNodes = output.getVcsNodes().getVcsNodeInfo();	if (vcsNodes != null && !vcsNodes.isEmpty()) {	for (VcsNodeInfo vcsNodeInfo : vcsNodes) {	if (!"Online".equals(vcsNodeInfo.getNodeState())) {	
brocade switch is not ready 

return executeRequest((MaintainCommand)cmd);	} else if (cmd instanceof CreateNetworkCommand) {	return executeRequest((CreateNetworkCommand)cmd, numRetries);	} else if (cmd instanceof AssociateMacToNetworkCommand) {	return executeRequest((AssociateMacToNetworkCommand)cmd, numRetries);	} else if (cmd instanceof DisassociateMacFromNetworkCommand) {	return executeRequest((DisassociateMacFromNetworkCommand)cmd, numRetries);	} else if (cmd instanceof DeleteNetworkCommand) {	return executeRequest((DeleteNetworkCommand)cmd, numRetries);	}	
received unsupported command 

private Answer retry(Command cmd, int numRetries) {	
retrying number of retries remaining 

========================= cloudstack sample_1647 =========================

CreateVMSnapshotCommand ccmd = new CreateVMSnapshotCommand(userVm.getInstanceName(), userVm.getUuid(), target, volumeTOs, guestOS.getDisplayName());	if (guestOsMapping == null) {	ccmd.setPlatformEmulator(null);	} else {	ccmd.setPlatformEmulator(guestOsMapping.getGuestOsName());	}	ccmd.setWait(_wait);	answer = (CreateVMSnapshotAnswer)agentMgr.send(hostId, ccmd);	if (answer != null && answer.getResult()) {	processAnswer(vmSnapshotVO, userVm, answer, hostId);	
create vm snapshot succeeded for vm 

publishUsageEvent(EventTypes.EVENT_VM_SNAPSHOT_CREATE, vmSnapshot, userVm, volumeTo);	}	return vmSnapshot;	} else {	String errMsg = "Creating VM snapshot: " + vmSnapshot.getName() + " failed";	if (answer != null && answer.getDetails() != null) errMsg = errMsg + " due to " + answer.getDetails();	s_logger.error(errMsg);	throw new CloudRuntimeException(errMsg);	}	} catch (OperationTimedoutException e) {	
creating vm snapshot failed 

return vmSnapshot;	} else {	String errMsg = "Creating VM snapshot: " + vmSnapshot.getName() + " failed";	if (answer != null && answer.getDetails() != null) errMsg = errMsg + " due to " + answer.getDetails();	s_logger.error(errMsg);	throw new CloudRuntimeException(errMsg);	}	} catch (OperationTimedoutException e) {	throw new CloudRuntimeException("Creating VM snapshot: " + vmSnapshot.getName() + " failed: " + e.toString());	} catch (AgentUnavailableException e) {	
creating vm snapshot failed 

}	} catch (OperationTimedoutException e) {	throw new CloudRuntimeException("Creating VM snapshot: " + vmSnapshot.getName() + " failed: " + e.toString());	} catch (AgentUnavailableException e) {	throw new CloudRuntimeException("Creating VM snapshot: " + vmSnapshot.getName() + " failed: " + e.toString());	} finally {	if (!result) {	try {	vmSnapshotHelper.vmSnapshotStateTransitTo(vmSnapshot, VMSnapshot.Event.OperationFailed);	} catch (NoTransitionException e1) {	
cannot set vm snapshot state due to 

public boolean deleteVMSnapshot(VMSnapshot vmSnapshot) {	UserVmVO userVm = userVmDao.findById(vmSnapshot.getVmId());	VMSnapshotVO vmSnapshotVO = (VMSnapshotVO)vmSnapshot;	try {	vmSnapshotHelper.vmSnapshotStateTransitTo(vmSnapshot, VMSnapshot.Event.ExpungeRequested);	} catch (NoTransitionException e) {	
failed to change vm snapshot state with event expungerequested 

Answer answer = agentMgr.send(hostId, deleteSnapshotCommand);	if (answer != null && answer.getResult()) {	DeleteVMSnapshotAnswer deleteVMSnapshotAnswer = (DeleteVMSnapshotAnswer)answer;	processAnswer(vmSnapshotVO, userVm, answer, hostId);	for (VolumeObjectTO volumeTo : deleteVMSnapshotAnswer.getVolumeTOs()) {	publishUsageEvent(EventTypes.EVENT_VM_SNAPSHOT_DELETE, vmSnapshot, userVm, volumeTo);	}	return true;	} else {	String errMsg = (answer == null) ? null : answer.getDetails();	
delete vm snapshot of vm failed due to 

if (answer != null && answer.getResult()) {	processAnswer(vmSnapshotVO, userVm, answer, hostId);	result = true;	} else {	String errMsg = "Revert VM: " + userVm.getInstanceName() + " to snapshot: " + vmSnapshotVO.getName() + " failed";	if (answer != null && answer.getDetails() != null) errMsg = errMsg + " due to " + answer.getDetails();	s_logger.error(errMsg);	throw new CloudRuntimeException(errMsg);	}	} catch (OperationTimedoutException e) {	
failed to revert vm snapshot 

result = true;	} else {	String errMsg = "Revert VM: " + userVm.getInstanceName() + " to snapshot: " + vmSnapshotVO.getName() + " failed";	if (answer != null && answer.getDetails() != null) errMsg = errMsg + " due to " + answer.getDetails();	s_logger.error(errMsg);	throw new CloudRuntimeException(errMsg);	}	} catch (OperationTimedoutException e) {	throw new CloudRuntimeException(e.getMessage());	} catch (AgentUnavailableException e) {	
failed to revert vm snapshot 

}	} catch (OperationTimedoutException e) {	throw new CloudRuntimeException(e.getMessage());	} catch (AgentUnavailableException e) {	throw new CloudRuntimeException(e.getMessage());	} finally {	if (!result) {	try {	vmSnapshotHelper.vmSnapshotStateTransitTo(vmSnapshot, VMSnapshot.Event.OperationFailed);	} catch (NoTransitionException e1) {	
cannot set vm snapshot state due to 

========================= cloudstack sample_3894 =========================

if (l.size() == 1) {	ManagementServerHostPeerVO peer = l.get(0);	peer.setPeerState(peerState);	update(peer.getId(), peer);	} else {	ManagementServerHostPeerVO peer = new ManagementServerHostPeerVO(ownerMshost, peerMshost, peerRunid, peerState);	persist(peer);	}	txn.commit();	} catch (Exception e) {	
unexpected exception 

========================= cloudstack sample_472 =========================

public Pair<Boolean, Long> getCommandHostDelegation(long hostId, Command cmd) {	
getcommandhostdelegation 

========================= cloudstack sample_1145 =========================

public static VmwareContext getContext(String vCenterAddress, String vCenterUserName, String vCenterPassword) throws Exception {	VmwareContext context = s_pool.getContext(vCenterAddress, vCenterUserName);	if (context == null) {	context = create(vCenterAddress, vCenterUserName, vCenterPassword);	} else {	if (!context.validate() || (context.getVimClient().getVcenterSessionTimeout() != s_vCenterSessionTimeout)) {	
validation of the context faild dispose and create a new one 

========================= cloudstack sample_1283 =========================

public PingCommand getCurrentStatus(final long id) {	try {	final ControlClusterStatus ccs = niciraNvpApi.getControlClusterStatus();	getApiProviderMajorityVersion(ccs);	if (!"stable".equals(ccs.getClusterStatus())) {	
controlcluster state is not stable 

public PingCommand getCurrentStatus(final long id) {	try {	final ControlClusterStatus ccs = niciraNvpApi.getControlClusterStatus();	getApiProviderMajorityVersion(ccs);	if (!"stable".equals(ccs.getClusterStatus())) {	return null;	}	} catch (final NiciraNvpApiException e) {	
getcontrolclusterstatus failed 

public Answer executeRequest(final Command cmd) {	final NiciraNvpRequestWrapper wrapper = NiciraNvpRequestWrapper.getInstance();	try {	return wrapper.execute(cmd, this);	} catch (final Exception e) {	
received unsupported command 

========================= cloudstack sample_1779 =========================

public static Integer retrieveNfsVersionFromParams(Map<String, Object> params){	Integer nfsVersion = null;	if (params.get("nfsVersion") != null){	String nfsVersionParam = (String)params.get("nfsVersion");	try {	nfsVersion = Integer.valueOf(nfsVersionParam);	}	catch (NumberFormatException e){	
couldn t cast to integer 

SnapshotObjectTO snapshot = new SnapshotObjectTO();	snapshot.setPath(destPath + File.separator + destFile.getName());	CopyCmdAnswer answer = new CopyCmdAnswer(snapshot);	return answer;	}	String scriptsDir = "scripts/storage/secondary";	String createTmpltScr = Script.findScript(scriptsDir, "createtmplt.sh");	if (createTmpltScr == null) {	throw new ConfigurationException("Unable to find createtmplt.sh");	}	
createtmplt sh found in 

}	String scriptsDir = "scripts/storage/secondary";	String createTmpltScr = Script.findScript(scriptsDir, "createtmplt.sh");	if (createTmpltScr == null) {	throw new ConfigurationException("Unable to find createtmplt.sh");	}	String createVolScr = Script.findScript(scriptsDir, "createvolume.sh");	if (createVolScr == null) {	throw new ConfigurationException("Unable to find createvolume.sh");	}	
createvolume sh found in 

protected Answer copyFromSwiftToNfs(CopyCommand cmd, DataTO srcData, SwiftTO swiftTO, DataTO destData, NfsTO destImageStore) {	final String storagePath = destImageStore.getUrl();	final String destPath = destData.getPath();	try {	String downloadPath = determineStorageTemplatePath(storagePath, destPath, _nfsVersion);	final File downloadDirectory = _storage.getFile(downloadPath);	if (downloadDirectory.exists()) {	
directory already exists 

} else {	if (!downloadDirectory.mkdirs()) {	final String errMsg = "Unable to create directory " + downloadPath + " to copy from Swift to cache.";	s_logger.error(errMsg);	return new CopyCmdAnswer(errMsg);	}	}	File destFile = SwiftUtil.getObject(swiftTO, downloadDirectory, srcData.getPath());	return postProcessing(destFile, downloadPath, destPath, srcData, destData);	} catch (Exception e) {	
failed to copy swift to nfs 

protected Answer copyFromS3ToNfs(CopyCommand cmd, DataTO srcData, S3TO s3, DataTO destData, NfsTO destImageStore) {	final String storagePath = destImageStore.getUrl();	final String destPath = destData.getPath();	try {	String downloadPath = determineStorageTemplatePath(storagePath, destPath, _nfsVersion);	final File downloadDirectory = _storage.getFile(downloadPath);	if (downloadDirectory.exists()) {	
directory already exists 

loc.save();	TemplateProp prop = loc.getTemplateInfo();	TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(destData.getPath() + File.separator + templateName);	newTemplate.setFormat(ImageFormat.VHD);	newTemplate.setSize(prop.getSize());	newTemplate.setPhysicalSize(prop.getPhysicalSize());	newTemplate.setName(templateUuid);	return new CopyCmdAnswer(newTemplate);	} catch (ConfigurationException e) {	
failed to create template from snapshot 

TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(destData.getPath() + File.separator + templateName);	newTemplate.setFormat(ImageFormat.VHD);	newTemplate.setSize(prop.getSize());	newTemplate.setPhysicalSize(prop.getPhysicalSize());	newTemplate.setName(templateUuid);	return new CopyCmdAnswer(newTemplate);	} catch (ConfigurationException e) {	errMsg = e.toString();	} catch (InternalErrorException e) {	
failed to create template from snapshot 

newTemplate.setFormat(ImageFormat.VHD);	newTemplate.setSize(prop.getSize());	newTemplate.setPhysicalSize(prop.getPhysicalSize());	newTemplate.setName(templateUuid);	return new CopyCmdAnswer(newTemplate);	} catch (ConfigurationException e) {	errMsg = e.toString();	} catch (InternalErrorException e) {	errMsg = e.toString();	} catch (IOException e) {	
failed to create template from snapshot 

VolumeObjectTO volumeObjectTO = srcData.getVolume();	ImageFormat srcFormat = null;	if (volumeObjectTO != null) {	srcFormat = volumeObjectTO.getFormat();	} else {	srcFormat = ImageFormat.QCOW2;	}	String templateName = srcFile.getName();	String fileName = templateName + "." + srcFormat.getFileExtension();	String destFileFullPath = destFile.getAbsolutePath() + File.separator + fileName;	
copy snapshot to template 

loc.addFormat(info);	loc.save();	TemplateProp prop = loc.getTemplateInfo();	TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(destData.getPath() + File.separator + fileName);	newTemplate.setFormat(srcFormat);	newTemplate.setSize(prop.getSize());	newTemplate.setPhysicalSize(prop.getPhysicalSize());	return new CopyCmdAnswer(newTemplate);	} catch (ConfigurationException e) {	
failed to create template 

TemplateProp prop = loc.getTemplateInfo();	TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(destData.getPath() + File.separator + fileName);	newTemplate.setFormat(srcFormat);	newTemplate.setSize(prop.getSize());	newTemplate.setPhysicalSize(prop.getPhysicalSize());	return new CopyCmdAnswer(newTemplate);	} catch (ConfigurationException e) {	return new CopyCmdAnswer(e.toString());	} catch (InternalErrorException e) {	
failed to create template 

newTemplate.setFormat(srcFormat);	newTemplate.setSize(prop.getSize());	newTemplate.setPhysicalSize(prop.getPhysicalSize());	return new CopyCmdAnswer(newTemplate);	} catch (ConfigurationException e) {	return new CopyCmdAnswer(e.toString());	} catch (InternalErrorException e) {	return new CopyCmdAnswer(e.toString());	}	} catch (IOException e) {	
failed to create template 

protected Answer createTemplateFromSnapshot(CopyCommand cmd) {	DataTO srcData = cmd.getSrcTO();	DataTO destData = cmd.getDestTO();	DataStoreTO srcDataStore = srcData.getDataStore();	DataStoreTO destDataStore = destData.getDataStore();	if (srcDataStore.getRole() == DataStoreRole.Image || srcDataStore.getRole() == DataStoreRole.ImageCache || srcDataStore.getRole() == DataStoreRole.Primary) {	if (!(srcDataStore instanceof NfsTO)) {	
only support nfs storage as src when create template from snapshot 

if (!(srcDataStore instanceof NfsTO)) {	return Answer.createUnsupportedCommandAnswer(cmd);	}	if (destDataStore instanceof NfsTO) {	return copySnapshotToTemplateFromNfsToNfs(cmd, (SnapshotObjectTO)srcData, (NfsTO)srcDataStore, (TemplateObjectTO)destData, (NfsTO)destDataStore);	} else if (destDataStore instanceof SwiftTO) {	CopyCmdAnswer answer = (CopyCmdAnswer)copySnapshotToTemplateFromNfsToNfs(cmd, (SnapshotObjectTO)srcData, (NfsTO)srcDataStore, (TemplateObjectTO)destData, (NfsTO)srcDataStore);	if (!answer.getResult()) {	return answer;	}	
starting copy template to swift 

return answer;	}	TemplateObjectTO newTemplate = (TemplateObjectTO)answer.getNewData();	newTemplate.setDataStore(srcDataStore);	CopyCommand newCpyCmd = new CopyCommand(newTemplate, destData, cmd.getWait(), cmd.executeInSequence());	Answer result = copyFromNfsToS3(newCpyCmd);	cleanupStagingNfs(newTemplate);	return result;	}	}	
failed to create template from snapshot 

protected void cleanupStagingNfs(TemplateObjectTO newTemplate) {	try {	DeleteCommand deleteCommand = new DeleteCommand(newTemplate);	execute(deleteCommand);	} catch (Exception e) {	
failed to clean up staging area 

protected File downloadFromUrlToNfs(String url, NfsTO nfs, String path, String name) {	HttpClient client = new DefaultHttpClient();	HttpGet get = new HttpGet(url);	try {	HttpResponse response = client.execute(get);	HttpEntity entity = response.getEntity();	if (entity == null) {	
faled to get entity 

throw new CloudRuntimeException("Failed to get url: " + url);	}	String nfsMountPath = getRootDir(nfs.getUrl(), _nfsVersion);	String filePath = nfsMountPath + File.separator + path;	File directory = new File(filePath);	if (!directory.exists()) {	_storage.mkdirs(filePath);	}	File destFile = new File(filePath + File.separator + name);	if (!destFile.createNewFile()) {	
reusing existing file 

File directory = new File(filePath);	if (!directory.exists()) {	_storage.mkdirs(filePath);	}	File destFile = new File(filePath + File.separator + name);	if (!destFile.createNewFile()) {	}	try(FileOutputStream outputStream = new FileOutputStream(destFile);) {	entity.writeTo(outputStream);	}catch (IOException e) {	
downloadfromurltonfs exception 

}	File destFile = new File(filePath + File.separator + name);	if (!destFile.createNewFile()) {	}	try(FileOutputStream outputStream = new FileOutputStream(destFile);) {	entity.writeTo(outputStream);	}catch (IOException e) {	}	return new File(destFile.getAbsolutePath());	} catch (IOException e) {	
faild to get url due to 

String metaFileName = uniqDir.getAbsolutePath() + File.separator + _tmpltpp;	_storage.create(uniqDir.getAbsolutePath(), _tmpltpp);	File metaFile = swiftWriteMetadataFile(metaFileName, uniqueName, fileName, size, virtualSize);	SwiftUtil.putObject(swiftTO, metaFile, container, _tmpltpp);	metaFile.delete();	uniqDir.delete();	String md5sum = null;	try (FileInputStream fs = new FileInputStream(file)){	md5sum = DigestUtils.md5Hex(fs);	} catch (IOException e) {	
failed to get 

metaFile.delete();	uniqDir.delete();	String md5sum = null;	try (FileInputStream fs = new FileInputStream(file)){	md5sum = DigestUtils.md5Hex(fs);	} catch (IOException e) {	}	DownloadAnswer answer = new DownloadAnswer(null, 100, null, VMTemplateStorageResourceAssoc.Status.DOWNLOADED, swiftPath, swiftPath, virtualSize, file.length(), md5sum);	return answer;	} catch (IOException e) {	
failed to register template into swift 

processor = new TARProcessor();	}	if (processor == null) {	return file.length();	}	Map<String, Object> params = new HashMap<String, Object>();	params.put(StorageLayer.InstanceConfigKey, _storage);	processor.configure("template processor", params);	return processor.getVirtualSize(file);	} catch (Exception e) {	
failed to get virtual size of file returning file size instead 

protected Answer copyFromNfsToS3(CopyCommand cmd) {	final DataTO srcData = cmd.getSrcTO();	final DataTO destData = cmd.getDestTO();	DataStoreTO srcDataStore = srcData.getDataStore();	NfsTO srcStore = (NfsTO)srcDataStore;	DataStoreTO destDataStore = destData.getDataStore();	final S3TO s3 = (S3TO)destDataStore;	try {	final String templatePath = determineStorageTemplatePath(srcStore.getUrl(), srcData.getPath(), _nfsVersion);	if (s_logger.isDebugEnabled()) {	
found from directory to upload to 

newVol.setPath(key);	newVol.setSize(srcFile.length());	retObj = newVol;	} else if (destData.getObjectType() == DataObjectType.SNAPSHOT) {	SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(key);	retObj = newSnapshot;	}	return new CopyCmdAnswer(retObj);	} catch (Exception e) {	
failed to upload 

newVol.setPath(containerName);	newVol.setSize(getVirtualSize(srcFile, getTemplateFormat(srcFile.getName())));	retObj = newVol;	} else if (destData.getObjectType() == DataObjectType.SNAPSHOT) {	SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(containerName);	retObj = newSnapshot;	}	return new CopyCmdAnswer(retObj);	} catch (Exception e) {	
failed to upload 

parent += File.separator;	}	String absoluteTemplatePath = parent + relativeTemplatePath;	MessageDigest digest;	String checksum = null;	File f = new File(absoluteTemplatePath);	InputStream is = null;	byte[] buffer = new byte[8192];	int read = 0;	if (s_logger.isDebugEnabled()) {	
parent path relative template path 

try {	digest = MessageDigest.getInstance("MD5");	is = new FileInputStream(f);	while ((read = is.read(buffer)) > 0) {	digest.update(buffer, 0, read);	}	byte[] md5sum = digest.digest();	BigInteger bigInt = new BigInteger(1, md5sum);	checksum = bigInt.toString(16);	if (s_logger.isDebugEnabled()) {	
successfully calculated checksum for file 

return new Answer(cmd, false, checksum);	} catch (NoSuchAlgorithmException e) {	return new Answer(cmd, false, checksum);	} finally {	try {	if (is != null) {	is.close();	}	} catch (IOException e) {	if (s_logger.isDebugEnabled()) {	
could not close the file 

String prvKey = certs.getPrivKey();	String pubCert = certs.getPrivCert();	String certChain = certs.getCertChain();	String rootCACert = certs.getRootCACert();	try {	File prvKeyFile = File.createTempFile("prvkey", null);	String prvkeyPath = prvKeyFile.getAbsolutePath();	try(BufferedWriter prvt_key_file = new BufferedWriter(new FileWriter(prvKeyFile));) {	prvt_key_file.write(prvKey);	}catch (IOException e) {	
failed to config ssl 

String prvkeyPath = prvKeyFile.getAbsolutePath();	try(BufferedWriter prvt_key_file = new BufferedWriter(new FileWriter(prvKeyFile));) {	prvt_key_file.write(prvKey);	}catch (IOException e) {	}	File pubCertFile = File.createTempFile("pubcert", null);	String pubCertFilePath = pubCertFile.getAbsolutePath();	try(BufferedWriter pub_cert_file = new BufferedWriter(new FileWriter(pubCertFile));) {	pub_cert_file.write(pubCert);	}catch (IOException e) {	
failed to config ssl 

}catch (IOException e) {	}	String certChainFilePath = null, rootCACertFilePath = null;	File certChainFile = null, rootCACertFile = null;	if(certChain != null){	certChainFile = File.createTempFile("certchain", null);	certChainFilePath = certChainFile.getAbsolutePath();	try(BufferedWriter cert_chain_out = new BufferedWriter(new FileWriter(certChainFile));) {	cert_chain_out.write(certChain);	}catch (IOException e) {	
failed to config ssl 

cert_chain_out.write(certChain);	}catch (IOException e) {	}	}	if(rootCACert != null){	rootCACertFile = File.createTempFile("rootcert", null);	rootCACertFilePath = rootCACertFile.getAbsolutePath();	try(BufferedWriter root_ca_cert_file = new BufferedWriter(new FileWriter(rootCACertFile));) {	root_ca_cert_file.write(rootCACert);	}catch (IOException e) {	
failed to config ssl 

configureSSL(prvkeyPath, pubCertFilePath, certChainFilePath, rootCACertFilePath);	prvKeyFile.delete();	pubCertFile.delete();	if(certChainFile != null){	certChainFile.delete();	}	if(rootCACertFile != null){	rootCACertFile.delete();	}	} catch (IOException e) {	
failed to config ssl 

pipeline.addLast(new HttpRequestDecoder());	pipeline.addLast(new HttpResponseEncoder());	pipeline.addLast(new HttpContentCompressor());	pipeline.addLast(new HttpUploadServerHandler(storageResource));	}	});	new Thread() {	public void run() {	try {	Channel ch = b.bind(PORT).sync().channel();	
started post upload server on port d with d workers 

pipeline.addLast(new HttpContentCompressor());	pipeline.addLast(new HttpUploadServerHandler(storageResource));	}	});	new Thread() {	public void run() {	try {	Channel ch = b.bind(PORT).sync().channel();	ch.closeFuture().sync();	} catch (InterruptedException e) {	
failed to start post upload server 

pipeline.addLast(new HttpContentCompressor());	pipeline.addLast(new HttpUploadServerHandler(storageResource));	}	});	new Thread() {	public void run() {	try {	Channel ch = b.bind(PORT).sync().channel();	ch.closeFuture().sync();	} catch (InterruptedException e) {	
exception while starting post upload server 

});	new Thread() {	public void run() {	try {	Channel ch = b.bind(PORT).sync().channel();	ch.closeFuture().sync();	} catch (InterruptedException e) {	} finally {	bossGroup.shutdownGracefully();	workerGroup.shutdownGracefully();	
shutting down post upload server 

try {	Channel ch = b.bind(PORT).sync().channel();	ch.closeFuture().sync();	} catch (InterruptedException e) {	} finally {	bossGroup.shutdownGracefully();	workerGroup.shutdownGracefully();	}	}	}.start();	
created a thread to start post upload server 

private void savePostUploadPSK(String psk) {	try {	FileUtils.writeStringToFile(new File(POST_UPLOAD_KEY_LOCATION),psk, "utf-8");	} catch (IOException ex) {	
failed to copy psk to the file 

if (!parent.endsWith(File.separator)) {	parent += File.separator;	}	String snapshotPath = obj.getPath();	if (snapshotPath.startsWith(File.separator)) {	snapshotPath = snapshotPath.substring(1);	}	String fullSnapPath = parent + snapshotPath;	File snapDir = new File(fullSnapPath);	if (snapDir.exists() && snapDir.isDirectory()) {	
snapshot path is a directory already deleted during backup snapshot so no need to delete 

if (tmpltFiles == null || tmpltFiles.length == 0) {	details = "No files under template parent directory " + tmpltParent.getName();	s_logger.debug(details);	} else {	boolean found = false;	for (File f : tmpltFiles) {	if (!found && f.getName().equals(_tmpltpp)) {	found = true;	}	if (f.isDirectory() && f.getName().equals("KVMHA")) {	
deleting kvmha directory contents from template location 

if (tmpltFiles == null || tmpltFiles.length == 0) {	details = "No files under volume parent directory " + tmpltParent.getName();	s_logger.debug(details);	} else {	boolean found = false;	for (File f : tmpltFiles) {	if (!found && f.getName().equals("volume.properties")) {	found = true;	}	if (f.isDirectory() && f.getName().equals("KVMHA")) {	
deleting kvmha directory contents from template location 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	_eth1ip = (String)params.get("eth1ip");	_eth1mask = (String)params.get("eth1mask");	if (_eth1ip != null) {	params.put("private.network.device", "eth1");	} else {	
parameter has not been configured assuming that we are not inside a system vm 

} else {	}	String eth2ip = (String)params.get("eth2ip");	if (eth2ip != null) {	params.put("public.network.device", "eth2");	}	_publicIp = (String)params.get("eth2ip");	_hostname = (String)params.get("name");	String inSystemVM = (String)params.get("secondary.storage.vm");	if (inSystemVM == null || "true".equalsIgnoreCase(inSystemVM)) {	
conf secondary storage vm is true act as if executing in ssvm 

params.put("public.network.device", "eth2");	}	_publicIp = (String)params.get("eth2ip");	_hostname = (String)params.get("name");	String inSystemVM = (String)params.get("secondary.storage.vm");	if (inSystemVM == null || "true".equalsIgnoreCase(inSystemVM)) {	_inSystemVM = true;	}	_storageIp = (String)params.get("storageip");	if (_storageIp == null && _inSystemVM) {	
there is no storageip in proc cmdline something wrong 

_params = params;	String value = (String)params.get("scripts.timeout");	_timeout = NumbersUtil.parseInt(value, 1440) * 1000;	_storage = (StorageLayer)params.get(StorageLayer.InstanceConfigKey);	configureStorageLayerClass(params);	if (_inSystemVM) {	_storage.mkdirs(_parent);	}	_configSslScr = Script.findScript(getDefaultScriptsDir(), "config_ssl.sh");	if (_configSslScr != null) {	
config ssl sh found in 

_storage = (StorageLayer)params.get(StorageLayer.InstanceConfigKey);	configureStorageLayerClass(params);	if (_inSystemVM) {	_storage.mkdirs(_parent);	}	_configSslScr = Script.findScript(getDefaultScriptsDir(), "config_ssl.sh");	if (_configSslScr != null) {	}	_configAuthScr = Script.findScript(getDefaultScriptsDir(), "config_auth.sh");	if (_configAuthScr != null) {	
config auth sh found in 

_storage.mkdirs(_parent);	}	_configSslScr = Script.findScript(getDefaultScriptsDir(), "config_ssl.sh");	if (_configSslScr != null) {	}	_configAuthScr = Script.findScript(getDefaultScriptsDir(), "config_auth.sh");	if (_configAuthScr != null) {	}	_configIpFirewallScr = Script.findScript(getDefaultScriptsDir(), "ipfirewall.sh");	if (_configIpFirewallScr != null) {	
configipfirewallscr found in 

if (_configIpFirewallScr != null) {	}	createTemplateFromSnapshotXenScript = Script.findScript(getDefaultScriptsDir(), "create_privatetemplate_from_snapshot_xen.sh");	if (createTemplateFromSnapshotXenScript == null) {	throw new ConfigurationException("create_privatetemplate_from_snapshot_xen.sh not found in " + getDefaultScriptsDir());	}	_role = (String)params.get("role");	if (_role == null) {	_role = SecondaryStorageVm.Role.templateProcessor.toString();	}	
secondary storage runs in role 

if (!_inSystemVM) {	_parent = (String)params.get("mount.path");	}	if (_inSystemVM) {	_localgw = (String)params.get("localgw");	if (_localgw != null) {	String mgmtHost = (String)params.get("host");	addRouteToInternalIpOrCidr(_localgw, _eth1ip, _eth1mask, mgmtHost);	String internalDns1 = (String)params.get("internaldns1");	if (internalDns1 == null) {	
no dns entry found during configuration of nfssecondarystorage 

_params.put("secondary.storage.vm", "true");	_nfsVersion = retrieveNfsVersionFromParams(params);	}	try {	_params.put(StorageLayer.InstanceConfigKey, _storage);	_dlMgr = new DownloadManagerImpl();	_dlMgr.configure("DownloadManager", _params);	_upldMgr = new UploadManagerImpl();	_upldMgr.configure("UploadManager", params);	} catch (ConfigurationException e) {	
caught problem while configuring downloadmanager 

private void addRouteToInternalIpOrCidr(String localgw, String eth1ip, String eth1mask, String destIpOrCidr) {	if (!_inSystemVM) {	return;	}	s_logger.debug("addRouteToInternalIp: localgw=" + localgw + ", eth1ip=" + eth1ip + ", eth1mask=" + eth1mask + ",destIp=" + destIpOrCidr);	if (destIpOrCidr == null) {	
addroutetointernalip destip is null 

if (NetUtils.isValidIp(destIpOrCidr)) {	if (eth1ip != null && eth1mask != null) {	inSameSubnet = NetUtils.sameSubnet(eth1ip, destIpOrCidr, eth1mask);	} else {	s_logger.warn("addRouteToInternalIp: unable to determine same subnet: _eth1ip=" + eth1ip + ", dest ip=" + destIpOrCidr + ", _eth1mask=" + eth1mask);	}	} else {	inSameSubnet = NetUtils.isNetworkAWithinNetworkB(destIpOrCidr, NetUtils.ipAndNetMaskToCidr(eth1ip, eth1mask));	}	if (inSameSubnet) {	
addroutetointernalip dest ip is in the same subnet as ip 

private void configureSSL() {	if (!_inSystemVM) {	return;	}	Script command = new Script(_configSslScr);	command.add("-i", _publicIp);	command.add("-h", _hostname);	String result = command.execute();	if (result != null) {	
unable to configure httpd to use ssl 

command.add("-k", prvkeyPath);	command.add("-p", prvCertPath);	if (certChainPath != null) {	command.add("-t", certChainPath);	}	if (rootCACert != null) {	command.add("-u", rootCACert);	}	String result = command.execute();	if (result != null) {	
unable to configure httpd to use ssl 

private String configureAuth(String user, String passwd) {	Script command = new Script(_configAuthScr);	command.add(user);	command.add(passwd);	String result = command.execute();	if (result != null) {	
unable to configure httpd to use auth 

private String configureIpFirewall(List<String> ipList, boolean isAppend) {	Script command = new Script(_configIpFirewallScr);	command.add(String.valueOf(isAppend));	for (String ip : ipList) {	command.add(ip);	}	String result = command.execute();	if (result != null) {	
unable to configure firewall for command 

protected String mountUri(URI uri, Integer nfsVersion) throws UnknownHostException {	String uriHostIp = getUriHostIp(uri);	String nfsPath = uriHostIp + ":" + uri.getPath();	String dir = UUID.nameUUIDFromBytes(nfsPath.getBytes(com.cloud.utils.StringUtils.getPreferredCharset())).toString();	String localRootPath = _parent + "/" + dir;	String remoteDevice;	if (uri.getScheme().equals("cifs")) {	remoteDevice = " s_logger.debug("Mounting device with cifs-style path of " + remoteDevice);	} else {	remoteDevice = nfsPath;	
mounting device with nfs style path of 

String result = command.execute();	if (result != null) {	String errMsg = "Unable to umount " + localRootPath + " due to " + result;	s_logger.error(errMsg);	File file = new File(localRootPath);	if (file.exists()) {	file.delete();	}	throw new CloudRuntimeException(errMsg);	}	
successfully umounted 

result = command.execute();	if (result != null) {	String errMsg = "Unable to mount " + remoteDevice + " at " + localRootPath + " due to " + result;	s_logger.error(errMsg);	File file = new File(localRootPath);	if (file.exists()) {	file.delete();	}	throw new CloudRuntimeException(errMsg);	}	
successfully mounted at 

protected String parseCifsMountOptions(URI uri) {	List<NameValuePair> args = URLEncodedUtils.parse(uri, "UTF-8");	boolean foundUser = false;	boolean foundPswd = false;	StringBuilder extraOpts = new StringBuilder();	for (NameValuePair nvp : args) {	String name = nvp.getName();	if (name.equals("user")) {	foundUser = true;	
founduser is 

List<NameValuePair> args = URLEncodedUtils.parse(uri, "UTF-8");	boolean foundUser = false;	boolean foundPswd = false;	StringBuilder extraOpts = new StringBuilder();	for (NameValuePair nvp : args) {	String name = nvp.getName();	if (name.equals("user")) {	foundUser = true;	} else if (name.equals("password")) {	foundPswd = true;	
password is present in uri 

for (NameValuePair nvp : args) {	String name = nvp.getName();	if (name.equals("user")) {	foundUser = true;	} else if (name.equals("password")) {	foundPswd = true;	}	extraOpts.append(name + "=" + nvp.getValue() + ",");	}	if (s_logger.isDebugEnabled()) {	
extraopts now 

protected boolean mountExists(String localRootPath, URI uri) {	Script script = null;	script = new Script(!_inSystemVM, "mount", _timeout, s_logger);	List<String> res = new ArrayList<String>();	ZfsPathParser parser = new ZfsPathParser(localRootPath);	script.execute(parser);	res.addAll(parser.getPaths());	for (String s : res) {	if (s.contains(localRootPath)) {	
some device already mounted at no need to mount 

protected void ensureLocalRootPathExists(String localRootPath, URI uri) {	
making available on 

protected void ensureLocalRootPathExists(String localRootPath, URI uri) {	File file = new File(localRootPath);	
local folder for mount will be 

protected void ensureLocalRootPathExists(String localRootPath, URI uri) {	File file = new File(localRootPath);	if (!file.exists()) {	
create mount point 

protected String getUriHostIp(URI uri) throws UnknownHostException {	String nfsHost = uri.getHost();	InetAddress nfsHostAddr = InetAddress.getByName(nfsHost);	String nfsHostIp = nfsHostAddr.getHostAddress();	
determined host corresponds to ip 

protected boolean createDir(String dirName, String dirLocation, String mountPoint) {	boolean dirExists = false;	File dir = new File(dirLocation);	if (dir.exists()) {	if (dir.isDirectory()) {	
already exists on secondary storage and is mounted at 

dirExists = true;	} else {	if (dir.delete() && _storage.mkdir(dirLocation)) {	dirExists = true;	}	}	} else if (_storage.mkdir(dirLocation)) {	dirExists = true;	}	if (dirExists) {	
directory created exists on secondary storage 

} else {	if (dir.delete() && _storage.mkdir(dirLocation)) {	dirExists = true;	}	}	} else if (_storage.mkdir(dirLocation)) {	dirExists = true;	}	if (dirExists) {	} else {	
directory does not exist on secondary storage 

uploadEntity.setHvm(cmd.getRequiresHvm());	uploadEntity.setChksum(cmd.getChecksum());	uploadEntity.setMaxSizeInGB(maxSizeInGB);	uploadEntity.setDescription(cmd.getDescription());	uploadEntity.setContentLength(contentLength);	if (!_storage.exists(installPathPrefix)) {	_storage.mkdir(installPathPrefix);	}	uploadEntityStateMap.put(uuid, uploadEntity);	} catch (Exception e) {	
exception occurred while creating upload entity 

long accountVolumeDirSize = 0;	File accountVolumeDir = new File(rootDir + getVolumePathForAccount(accountId));	if(accountVolumeDir.exists()) {	accountVolumeDirSize = FileUtils.sizeOfDirectory(accountVolumeDir);	}	long accountSnapshotDirSize = 0;	File accountSnapshotDir = new File(rootDir + getSnapshotPathForAccount(accountId));	if(accountSnapshotDir.exists()) {	accountSnapshotDirSize = FileUtils.sizeOfDirectory(accountSnapshotDir);	}	
accounttemplatedirsize accountsnapshotdirsize accountvolumedirsize 

accountVolumeDirSize = FileUtils.sizeOfDirectory(accountVolumeDir);	}	long accountSnapshotDirSize = 0;	File accountSnapshotDir = new File(rootDir + getSnapshotPathForAccount(accountId));	if(accountSnapshotDir.exists()) {	accountSnapshotDirSize = FileUtils.sizeOfDirectory(accountSnapshotDir);	}	int accountDirSizeInGB = getSizeInGB(accountTemplateDirSize + accountSnapshotDirSize + accountVolumeDirSize);	int defaultMaxAccountSecondaryStorageInGB = Integer.parseInt(cmd.getDefaultMaxAccountSecondaryStorage());	if ((accountDirSizeInGB + contentLengthInGB) > defaultMaxAccountSecondaryStorageInGB) {	
accountdirsizeingb defaultmaxaccountsecondarystorageingb contentlengthingb 

propertiesFile += "/template.properties";	} else {	propertiesFile += "/volume.properties";	}	File templateProperties = new File(propertiesFile);	_storage.setWorldReadableAndWriteable(templateProperties);	TemplateLocation loc = new TemplateLocation(_storage, resourcePath);	try {	loc.create(uploadEntity.getEntityId(), true, uploadEntity.getFilename());	} catch (IOException e) {	
something is wrong with template location 

} catch (IOException e) {	loc.purge();	return "Unable to upload due to " + e.getMessage();	}	Map<String, Processor> processors = _dlMgr.getProcessors();	for (Processor processor :  processors.values()) {	FormatInfo info = null;	try {	info = processor.process(resourcePath, null, templateName);	} catch (InternalErrorException e) {	
template process exception 

return e.toString();	}	if (info != null) {	loc.addFormat(info);	uploadEntity.setVirtualSize(info.virtualSize);	uploadEntity.setPhysicalSize(info.size);	break;	}	}	if (!loc.save()) {	
cleaning up because we re unable to save the formats 

private String getPostUploadPSK() {	if(_ssvmPSK == null ) {	try {	_ssvmPSK = FileUtils.readFileToString(new File(POST_UPLOAD_KEY_LOCATION), "utf-8");	} catch (IOException e) {	
error while reading ssvm psk from location 

private TemplateOrVolumePostUploadCommand getTemplateOrVolumePostUploadCmd(String metadata) {	TemplateOrVolumePostUploadCommand cmd = null;	try {	Gson gson = new GsonBuilder().create();	cmd = gson.fromJson(EncryptionUtil.decodeData(metadata, getPostUploadPSK()), TemplateOrVolumePostUploadCommand.class);	} catch(Exception ex) {	
exception while decoding and deserialising metadata 

========================= cloudstack sample_5014 =========================

public static TransactionLegacy open(final String name, final short databaseId, final boolean forceDbChange) {	TransactionLegacy txn = tls.get();	boolean isNew = false;	if (txn == null) {	if (s_logger.isTraceEnabled()) {	
creating the transaction 

public static Connection getStandaloneConnectionWithException() throws SQLException {	Connection conn = s_ds.getConnection();	if (s_connLogger.isTraceEnabled()) {	
retrieving a standalone connection dbconn 

public static Connection getStandaloneConnection() {	try {	return getStandaloneConnectionWithException();	} catch (SQLException e) {	
unexpected exception 

public static Connection getStandaloneUsageConnection() {	try {	Connection conn = s_usageDS.getConnection();	if (s_connLogger.isTraceEnabled()) {	
retrieving a standalone connection for usage dbconn 

public static Connection getStandaloneUsageConnection() {	try {	Connection conn = s_usageDS.getConnection();	if (s_connLogger.isTraceEnabled()) {	}	return conn;	} catch (SQLException e) {	
unexpected exception 

public static Connection getStandaloneSimulatorConnection() {	try {	Connection conn = s_simulatorDS.getConnection();	if (s_connLogger.isTraceEnabled()) {	
retrieving a standalone connection for simulator dbconn 

public static Connection getStandaloneSimulatorConnection() {	try {	Connection conn = s_simulatorDS.getConnection();	if (s_connLogger.isTraceEnabled()) {	}	return conn;	} catch (SQLException e) {	
unexpected exception 

return false;	}	StringBuffer sb = new StringBuffer();	for (; stack < stacks.length; stack++) {	String methodName = stacks[stack].getMethodName();	sb.append(" ").append(methodName);	if (methodName.equals(se.ref)) {	return true;	}	}	
non standard stack context that transaction context is manaully placed into the calling chain stack chain 

public void start() {	if (s_logger.isTraceEnabled()) {	
txn start requested by 

public void start() {	if (s_logger.isTraceEnabled()) {	}	_stack.push(new StackElement(START_TXN, null));	if (_txn) {	
txn has already been started 

if (s_logger.isTraceEnabled()) {	}	_stack.push(new StackElement(START_TXN, null));	if (_txn) {	return;	}	_txn = true;	_txnTime = System.currentTimeMillis();	if (_conn != null) {	try {	
txn set auto commit to false 

_stack.push(new StackElement(START_TXN, null));	if (_txn) {	return;	}	_txn = true;	_txnTime = System.currentTimeMillis();	if (_conn != null) {	try {	_conn.setAutoCommit(false);	} catch (final SQLException e) {	
unable to set auto commit 

protected void closePreviousStatement() {	if (_stmt != null) {	try {	if (s_stmtLogger.isTraceEnabled()) {	
closing 

if (_stmt != null) {	try {	if (s_stmtLogger.isTraceEnabled()) {	}	try {	ResultSet rs = _stmt.getResultSet();	if (rs != null && _stmt.getResultSetHoldability() != ResultSet.HOLD_CURSORS_OVER_COMMIT) {	rs.close();	}	} catch (SQLException e) {	
unable to close resultset 

}	try {	ResultSet rs = _stmt.getResultSet();	if (rs != null && _stmt.getResultSetHoldability() != ResultSet.HOLD_CURSORS_OVER_COMMIT) {	rs.close();	}	} catch (SQLException e) {	}	_stmt.close();	} catch (final SQLException e) {	
unable to close statement 

public PreparedStatement prepareStatement(final String sql) throws SQLException {	final Connection conn = getConnection();	final PreparedStatement pstmt = conn.prepareStatement(sql);	if (s_stmtLogger.isTraceEnabled()) {	
preparing 

public PreparedStatement prepareAutoCloseStatement(final String sql, final int autoGeneratedKeys) throws SQLException {	final Connection conn = getConnection();	final PreparedStatement pstmt = conn.prepareStatement(sql, autoGeneratedKeys);	if (s_stmtLogger.isTraceEnabled()) {	
preparing 

public PreparedStatement prepareAutoCloseStatement(final String sql, final String[] columnNames) throws SQLException {	final Connection conn = getConnection();	final PreparedStatement pstmt = conn.prepareStatement(sql, columnNames);	if (s_stmtLogger.isTraceEnabled()) {	
preparing 

public PreparedStatement prepareAutoCloseStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {	final Connection conn = getConnection();	final PreparedStatement pstmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);	if (s_stmtLogger.isTraceEnabled()) {	
preparing 

public Connection getConnection() throws SQLException {	if (_conn == null) {	switch (_dbId) {	case CLOUD_DB: if (s_ds != null) {	_conn = s_ds.getConnection();	} else {	
a static initialized variable becomes null process is dying 

switch (_dbId) {	case CLOUD_DB: if (s_ds != null) {	_conn = s_ds.getConnection();	} else {	throw new CloudRuntimeException("Database is not initialized, process is dying?");	}	break;	case USAGE_DB: if (s_usageDS != null) {	_conn = s_usageDS.getConnection();	} else {	
a static initialized variable becomes null process is dying 

break;	case USAGE_DB: if (s_usageDS != null) {	_conn = s_usageDS.getConnection();	} else {	throw new CloudRuntimeException("Database is not initialized, process is dying?");	}	break;	case SIMULATOR_DB: if (s_simulatorDS != null) {	_conn = s_simulatorDS.getConnection();	} else {	
a static initialized variable becomes null process is dying 

_conn = s_simulatorDS.getConnection();	} else {	throw new CloudRuntimeException("Database is not initialized, process is dying?");	}	break;	default: throw new CloudRuntimeException("No database selected for the transaction");	}	_conn.setAutoCommit(!_txn);	_stack.push(new StackElement(CREATE_CONN, null));	if (s_connLogger.isTraceEnabled()) {	
creating a db connection with txn no txn for dbconn stack 

throw new CloudRuntimeException("Database is not initialized, process is dying?");	}	break;	default: throw new CloudRuntimeException("No database selected for the transaction");	}	_conn.setAutoCommit(!_txn);	_stack.push(new StackElement(CREATE_CONN, null));	if (s_connLogger.isTraceEnabled()) {	}	} else {	
conn using existing db connection 

protected boolean takeOver(final String name, final boolean create) {	if (_stack.size() != 0) {	if (!create) {	if (s_logger.isTraceEnabled()) {	
using current transaction 

if (_stack.size() != 0) {	if (!create) {	if (s_logger.isTraceEnabled()) {	}	mark(name);	return false;	}	final StackElement se = _stack.getFirst();	if (se.type == CREATE_TXN) {	if (s_logger.isTraceEnabled()) {	
create using current transaction 

mark(name);	return false;	}	final StackElement se = _stack.getFirst();	if (se.type == CREATE_TXN) {	if (s_logger.isTraceEnabled()) {	}	mark(name);	return false;	}	
encountered a transaction that has leaked cleaning up 

final StackElement se = _stack.getFirst();	if (se.type == CREATE_TXN) {	if (s_logger.isTraceEnabled()) {	}	mark(name);	return false;	}	cleanup();	}	if (s_logger.isTraceEnabled()) {	
took over the transaction 

public void close() {	removeUpTo(CURRENT_TXN, null);	if (_stack.size() == 0) {	
transaction is done 

public boolean close(final String name) {	if (_name == null) {	if (s_logger.isTraceEnabled()) {	
already cleaned up 

if (_name == null) {	if (s_logger.isTraceEnabled()) {	}	return true;	}	if (!_name.equals(name)) {	close();	return false;	}	if (s_logger.isDebugEnabled() && _stack.size() > 2) {	
transaction is not closed properly called by 

}	return true;	}	if (!_name.equals(name)) {	close();	return false;	}	if (s_logger.isDebugEnabled() && _stack.size() > 2) {	}	cleanup();	
all done 

protected void clearLockTimes() {	if (s_lockLogger.isDebugEnabled()) {	for (Pair<String, Long> time : _lockTimes) {	
sql took 

public boolean commit() {	if (!_txn) {	
txn commit called when it is not a transaction 

Iterator<StackElement> it = _stack.iterator();	while (it.hasNext()) {	StackElement st = it.next();	if (st.type == START_TXN) {	it.remove();	break;	}	}	if (hasTxnInStack()) {	if (s_logger.isTraceEnabled()) {	
txn not committing because transaction started elsewhere 

protected void closeConnection() {	closePreviousStatement();	if (_conn == null) {	return;	}	if (_txn) {	
txn not closing db connection because we re still in a transaction 

closePreviousStatement();	if (_conn == null) {	return;	}	if (_txn) {	return;	}	try {	if (_dbId != CONNECTED_DB) {	if (s_connLogger.isTraceEnabled()) {	
closing db connection dbconn 

return;	}	try {	if (_dbId != CONNECTED_DB) {	if (s_connLogger.isTraceEnabled()) {	}	_conn.close();	_conn = null;	}	} catch (final SQLException e) {	
unable to close connection 

} else if (item.type == CREATE_CONN) {	closeConnection();	} else if (item.type == START_TXN) {	if (item.ref == null) {	rollback = true;	} else {	try {	_conn.rollback((Savepoint)ref);	rollback = false;	} catch (final SQLException e) {	
unable to rollback txn 

} else {	try {	_conn.rollback((Savepoint)ref);	rollback = false;	} catch (final SQLException e) {	}	}	} else if (item.type == STATEMENT) {	try {	if (s_stmtLogger.isTraceEnabled()) {	
closing 

try {	if (s_stmtLogger.isTraceEnabled()) {	}	Statement stmt = (Statement)ref;	try {	ResultSet rs = stmt.getResultSet();	if (rs != null) {	rs.close();	}	} catch (SQLException e) {	
unable to close resultset 

Statement stmt = (Statement)ref;	try {	ResultSet rs = stmt.getResultSet();	if (rs != null) {	rs.close();	}	} catch (SQLException e) {	}	stmt.close();	} catch (final SQLException e) {	
unable to close statement 

rs.close();	}	} catch (SQLException e) {	}	stmt.close();	} catch (final SQLException e) {	}	} else if (item.type == ATTACHMENT) {	TransactionAttachment att = (TransactionAttachment)item.ref;	if (s_logger.isTraceEnabled()) {	
cleaning up 

stmt.close();	} catch (final SQLException e) {	}	} else if (item.type == ATTACHMENT) {	TransactionAttachment att = (TransactionAttachment)item.ref;	if (s_logger.isTraceEnabled()) {	}	att.cleanup();	}	} catch (Exception e) {	
unable to clean up 

protected void rollbackTransaction() {	closePreviousStatement();	if (!_txn) {	if (s_logger.isTraceEnabled()) {	
rollback called for when there s no transaction 

try {	if (_conn != null) {	if (s_logger.isDebugEnabled()) {	s_logger.debug("Rolling back the transaction: Time = " + (System.currentTimeMillis() - _txnTime) + " Name =  " + _name + "; called by " + buildName());	}	_conn.rollback();	}	clearLockTimes();	closeConnection();	} catch (final SQLException e) {	
unable to rollback 

protected void rollbackSavepoint(Savepoint sp) {	try {	if (_conn != null) {	_conn.rollback(sp);	}	} catch (SQLException e) {	
unable to rollback to savepoint 

protected void finalize() throws Throwable {	if (!(_conn == null && (_stack == null || _stack.size() == 0))) {	assert (false) : "Oh Alex oh alex...something is wrong with how we're doing this";	
something went wrong that a transaction is orphaned before db connection is closed 

public static void initDataSource(Properties dbProps) {	try {	if (dbProps.size() == 0) return;	s_dbHAEnabled = Boolean.valueOf(dbProps.getProperty("db.ha.enabled"));	
is data base high availiability enabled ans 

isolationLevel = Connection.TRANSACTION_READ_COMMITTED;	} else if (cloudIsolationLevel.equalsIgnoreCase("readcommitted")) {	isolationLevel = Connection.TRANSACTION_READ_COMMITTED;	} else if (cloudIsolationLevel.equalsIgnoreCase("repeatableread")) {	isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;	} else if (cloudIsolationLevel.equalsIgnoreCase("serializable")) {	isolationLevel = Connection.TRANSACTION_SERIALIZABLE;	} else if (cloudIsolationLevel.equalsIgnoreCase("readuncommitted")) {	isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;	} else {	
unknown isolation level using read uncommitted 

final boolean cloudTestWhileIdle = Boolean.parseBoolean(dbProps.getProperty("db.cloud.testWhileIdle"));	final long cloudTimeBtwEvictionRunsMillis = Long.parseLong(dbProps.getProperty("db.cloud.timeBetweenEvictionRunsMillis"));	final long cloudMinEvcitableIdleTimeMillis = Long.parseLong(dbProps.getProperty("db.cloud.minEvictableIdleTimeMillis"));	final boolean cloudPoolPreparedStatements = Boolean.parseBoolean(dbProps.getProperty("db.cloud.poolPreparedStatements"));	final String url = dbProps.getProperty("db.cloud.url.params");	String cloudDbHAParams = null;	String cloudSlaves = null;	if (s_dbHAEnabled) {	cloudDbHAParams = getDBHAParams("cloud", dbProps);	cloudSlaves = dbProps.getProperty("db.cloud.slaves");	
the slaves configured for cloud data base is are 

final int simulatorPort = Integer.parseInt(dbProps.getProperty("db.simulator.port"));	final String simulatorDbName = dbProps.getProperty("db.simulator.name");	final boolean simulatorAutoReconnect = Boolean.parseBoolean(dbProps.getProperty("db.simulator.autoReconnect"));	final GenericObjectPool simulatorConnectionPool = new GenericObjectPool(null, simulatorMaxActive, GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION, simulatorMaxWait, simulatorMaxIdle);	final String simulatorConnectionUri = simulatorDriver + ": simulatorAutoReconnect;	DriverLoader.loadDriver(simulatorDriver);	final ConnectionFactory simulatorConnectionFactory = new DriverManagerConnectionFactory(simulatorConnectionUri, simulatorUsername, simulatorPassword);	final PoolableConnectionFactory simulatorPoolableConnectionFactory = new PoolableConnectionFactory(simulatorConnectionFactory, simulatorConnectionPool, new StackKeyedObjectPoolFactory(), null, false, false);	s_simulatorDS = new PoolingDataSource(simulatorPoolableConnectionFactory.getPool());	} catch (Exception e) {	
simulator db properties are not available not initializing simulator ds 

========================= cloudstack sample_560 =========================

details.put(SolidFireUtil.CLUSTER_ADMIN_PASSWORD, clusterAdminPassword);	long lClusterDefaultMinIops = 100;	long lClusterDefaultMaxIops = 15000;	float fClusterDefaultBurstIopsPercentOfMaxIops = 1.5f;	try {	String clusterDefaultMinIops = SolidFireUtil.getValue(SolidFireUtil.CLUSTER_DEFAULT_MIN_IOPS, url);	if (clusterDefaultMinIops != null && clusterDefaultMinIops.trim().length() > 0) {	lClusterDefaultMinIops = Long.parseLong(clusterDefaultMinIops);	}	} catch (NumberFormatException ex) {	
cannot parse the setting using default value exception 

lClusterDefaultMinIops = Long.parseLong(clusterDefaultMinIops);	}	} catch (NumberFormatException ex) {	}	try {	String clusterDefaultMaxIops = SolidFireUtil.getValue(SolidFireUtil.CLUSTER_DEFAULT_MAX_IOPS, url);	if (clusterDefaultMaxIops != null && clusterDefaultMaxIops.trim().length() > 0) {	lClusterDefaultMaxIops = Long.parseLong(clusterDefaultMaxIops);	}	} catch (NumberFormatException ex) {	
cannot parse the setting using default value exception 

lClusterDefaultMaxIops = Long.parseLong(clusterDefaultMaxIops);	}	} catch (NumberFormatException ex) {	}	try {	String clusterDefaultBurstIopsPercentOfMaxIops = SolidFireUtil.getValue(SolidFireUtil.CLUSTER_DEFAULT_BURST_IOPS_PERCENT_OF_MAX_IOPS, url);	if (clusterDefaultBurstIopsPercentOfMaxIops != null && clusterDefaultBurstIopsPercentOfMaxIops.trim().length() > 0) {	fClusterDefaultBurstIopsPercentOfMaxIops = Float.parseFloat(clusterDefaultBurstIopsPercentOfMaxIops);	}	} catch (NumberFormatException ex) {	
cannot parse the setting using default value exception 

List<HostVO> vmWareServerHosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(HypervisorType.VMware, scope.getScopeId());	List<HostVO> kvmHosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(HypervisorType.KVM, scope.getScopeId());	List<HostVO> hosts = new ArrayList<HostVO>();	hosts.addAll(xenServerHosts);	hosts.addAll(vmWareServerHosts);	hosts.addAll(kvmHosts);	for (HostVO host : hosts) {	try {	_storageMgr.connectHostToSharedPool(host.getId(), dataStore.getId());	} catch (Exception e) {	
unable to establish a connection between and 

========================= cloudstack sample_1954 =========================

storage.mkdirs(tmpltPath);	if (primary.getType() != StoragePoolType.RBD) {	final String createTmplPath = libvirtComputingResource.createTmplPath();	final int cmdsTimeout = libvirtComputingResource.getCmdsTimeout();	final Script scriptCommand = new Script(createTmplPath, cmdsTimeout, s_logger);	scriptCommand.add("-f", disk.getPath());	scriptCommand.add("-t", tmpltPath);	scriptCommand.add("-n", command.getUniqueName() + ".qcow2");	final String result = scriptCommand.execute();	if (result != null) {	
failed to create template 

final int cmdsTimeout = libvirtComputingResource.getCmdsTimeout();	final Script scriptCommand = new Script(createTmplPath, cmdsTimeout, s_logger);	scriptCommand.add("-f", disk.getPath());	scriptCommand.add("-t", tmpltPath);	scriptCommand.add("-n", command.getUniqueName() + ".qcow2");	final String result = scriptCommand.execute();	if (result != null) {	return new CreatePrivateTemplateAnswer(command, false, result);	}	} else {	
converting rbd disk into template 

}	} else {	final QemuImgFile srcFile = new QemuImgFile(KVMPhysicalDisk.RBDStringBuilder(primary.getSourceHost(), primary.getSourcePort(), primary.getAuthUserName(), primary.getAuthSecret(), disk.getPath()));	srcFile.setFormat(PhysicalDiskFormat.RAW);	final QemuImgFile destFile = new QemuImgFile(tmpltPath + "/" + command.getUniqueName() + ".qcow2");	destFile.setFormat(PhysicalDiskFormat.QCOW2);	final QemuImg q = new QemuImg(0);	try {	q.convert(srcFile, destFile);	} catch (final QemuImgException e) {	
failed to create new template while converting to the error was 

templateProp.createNewFile();	}	String templateContent = "filename=" + command.getUniqueName() + ".qcow2" + System.getProperty("line.separator");	final DateFormat dateFormat = new SimpleDateFormat("MM_dd_yyyy");	final Date date = new Date();	templateContent += "snapshot.name=" + dateFormat.format(date) + System.getProperty("line.separator");	try(FileOutputStream templFo = new FileOutputStream(templateProp);) {	templFo.write(templateContent.getBytes("UTF-8"));	templFo.flush();	}catch(final IOException ex) {	
createprivatetemplateanswer exception 

========================= cloudstack sample_1057 =========================

private boolean canHandle(Network network, Service service) {	
checking if bigswitchbcfelement can handle service on network 

private boolean canHandle(Network network, Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Vlan) {	return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	
bigswitchbcfelement is not a provider for network 

private boolean canHandle(Network network, Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Vlan) {	return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	if (!_ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), service, BcfConstants.BIG_SWITCH_BCF)) {	
bigswitchbcfelement can t provide the service on network 

public boolean release(Network network, NicProfile nic, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	
nic has no broadcast uri 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	
unable to provide services without connectivity service enabled for this element 

tenantId = vpc.getUuid();	_vpcDao.releaseFromLockTable(vpc.getId());	} else {	tenantId = network.getUuid();	}	for (StaticNat rule: rules){	String srcIp = _ipAddressDao.findById(rule.getSourceIpAddressId()).getAddress().addr();	String dstIp = rule.getDestIpAddress();	String mac = rule.getSourceMacAddress();	if(!rule.isForRevoke()) {	
bcf enables static nat for public ip private ip mac 

tenantId = network.getUuid();	}	for (StaticNat rule: rules){	String srcIp = _ipAddressDao.findById(rule.getSourceIpAddressId()).getAddress().addr();	String dstIp = rule.getDestIpAddress();	String mac = rule.getSourceMacAddress();	if(!rule.isForRevoke()) {	CreateBcfStaticNatCommand cmd = new CreateBcfStaticNatCommand( tenantId, network.getUuid(), dstIp, srcIp, mac);	_bcfUtils.sendBcfCommandWithNetworkSyncCheck(cmd, network);	} else {	
bcf removes static nat for public ip private ip mac 

========================= cloudstack sample_1542 =========================

for (HostVO neighbor : neighbors) {	if (neighbor.getId() == agent.getId() || neighbor.getHypervisorType() != Hypervisor.HypervisorType.Simulator) {	continue;	}	try {	Answer answer = _agentMgr.easySend(neighbor.getId(), cmd);	if (answer != null) {	return answer.getResult() ? Status.Up : Status.Down;	}	} catch (Exception e) {	
failed to send command to host 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	CheckVirtualMachineCommand cmd = new CheckVirtualMachineCommand(vm.getInstanceName());	try {	Answer answer = _agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	
unable to get vm state on 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	CheckVirtualMachineCommand cmd = new CheckVirtualMachineCommand(vm.getInstanceName());	try {	Answer answer = _agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	throw new UnknownVM();	}	CheckVirtualMachineAnswer cvmAnswer = (CheckVirtualMachineAnswer)answer;	
agent responded with state 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	CheckVirtualMachineCommand cmd = new CheckVirtualMachineCommand(vm.getInstanceName());	try {	Answer answer = _agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	throw new UnknownVM();	}	CheckVirtualMachineAnswer cvmAnswer = (CheckVirtualMachineAnswer)answer;	return cvmAnswer.getState() == PowerState.PowerOn;	} catch (AgentUnavailableException e) {	
unable to reach the agent for 

try {	Answer answer = _agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	throw new UnknownVM();	}	CheckVirtualMachineAnswer cvmAnswer = (CheckVirtualMachineAnswer)answer;	return cvmAnswer.getState() == PowerState.PowerOn;	} catch (AgentUnavailableException e) {	throw new UnknownVM();	} catch (OperationTimedoutException e) {	
operation timed out for 

========================= cloudstack sample_976 =========================

private boolean canHandle(Network network, Service service) {	DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Advanced && network.getGuestType() != Network.GuestType.Isolated) {	s_logger.trace("Element " + getProvider().getName() + "is not handling network type = " + network.getGuestType());	return false;	}	if (service == null) {	if (!_networkManager.isProviderForNetwork(getProvider(), network.getId())) {	
element is not a provider for the network 

if (zone.getNetworkType() == NetworkType.Advanced && network.getGuestType() != Network.GuestType.Isolated) {	s_logger.trace("Element " + getProvider().getName() + "is not handling network type = " + network.getGuestType());	return false;	}	if (service == null) {	if (!_networkManager.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	} else {	if (!_networkManager.isProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {	
element doesn t support service in the network 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ResourceUnavailableException, ConcurrentOperationException, InsufficientNetworkCapacityException {	DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	
not handling network implement in zone of type 

DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	return false;	}	if (!canHandle(network, null)) {	return false;	}	try {	return manageGuestNetworkWithExternalFirewall(true, network);	} catch (InsufficientCapacityException capacityException) {	
fail to implement the palo alto for network 

public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ResourceUnavailableException, ConcurrentOperationException {	DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	
not handling network shutdown in zone of type 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Firewall)) {	
palo alto must be used as firewall service provider in the network 

========================= cloudstack sample_1391 =========================

hostIdsToTryFirst = new long[] {vmHostId};	}	List<Long> hostIdsToAvoid = new ArrayList<Long>();	for (int retry = _totalRetries; retry >= 0; retry--) {	try {	Pair<Long, Answer> result = _storageMgr.sendToPool(pool, hostIdsToTryFirst, hostIdsToAvoid, cmd);	if (result.second().getResult()) {	return result.second();	}	if (s_logger.isDebugEnabled()) {	
the result for is through 

for (int retry = _totalRetries; retry >= 0; retry--) {	try {	Pair<Long, Answer> result = _storageMgr.sendToPool(pool, hostIdsToTryFirst, hostIdsToAvoid, cmd);	if (result.second().getResult()) {	return result.second();	}	if (s_logger.isDebugEnabled()) {	}	hostIdsToAvoid.add(result.first());	} catch (StorageUnavailableException e1) {	
storage unavailable 

}	if (s_logger.isDebugEnabled()) {	}	hostIdsToAvoid.add(result.first());	} catch (StorageUnavailableException e1) {	return null;	}	try {	Thread.sleep(_pauseInterval * 1000);	} catch (InterruptedException e) {	
ignored interupted while retry cmd 

if (s_logger.isDebugEnabled()) {	}	hostIdsToAvoid.add(result.first());	} catch (StorageUnavailableException e1) {	return null;	}	try {	Thread.sleep(_pauseInterval * 1000);	} catch (InterruptedException e) {	}	
retrying 

}	hostIdsToAvoid.add(result.first());	} catch (StorageUnavailableException e1) {	return null;	}	try {	Thread.sleep(_pauseInterval * 1000);	} catch (InterruptedException e) {	}	}	
after retries the command did not succeed 

if (vm.getState() != State.Stopped && vm.getState() != State.Shutdowned) {	throw new InvalidParameterValueException("The VM the specified disk is attached to is not in the shutdown state.");	}	}	SnapshotInfo snapshotInfo = snapshotFactory.getSnapshot(snapshotId, DataStoreRole.Image);	if (snapshotInfo == null) {	throw new CloudRuntimeException("snapshot:" + snapshotId + " not exist in data store");	}	SnapshotStrategy snapshotStrategy = _storageStrategyFactory.getSnapshotStrategy(snapshot, SnapshotOperation.REVERT);	if (snapshotStrategy == null) {	
unable to find snaphot strategy to handle snapshot with id 

VolumeInfo volume = volFactory.getVolume(volumeId);	if (volume == null) {	throw new InvalidParameterValueException("No such volume exist");	}	if (volume.getState() != Volume.State.Ready) {	throw new InvalidParameterValueException("Volume is not in ready state");	}	_accountMgr.checkAccess(CallContext.current().getCallingAccount(), null, true, volume);	SnapshotInfo snapshot = snapshotFactory.getSnapshot(snapshotId, DataStoreRole.Primary);	if(snapshot == null) {	
failed to create snapshot 

throw new CloudRuntimeException("Failed to create snapshot");	}	try {	postCreateSnapshot(volumeId, snapshot.getId(), policyId);	SnapshotVO freshSnapshot = _snapshotDao.findById(snapshot.getId());	if (freshSnapshot != null)  {	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_SNAPSHOT_CREATE, snapshot.getAccountId(), snapshot.getDataCenterId(), snapshotId, snapshot.getName(), null, null, volume.getSize(), snapshot.getClass().getName(), snapshot.getUuid());	}	_resourceLimitMgr.incrementResourceCount(snapshotOwner.getId(), ResourceType.snapshot);	} catch (Exception e) {	
failed to create snapshot 

int maxSnaps = type.getMax();	List<SnapshotVO> snaps = listSnapsforVolumeType(volumeId, type);	SnapshotPolicyVO policy = _snapshotPolicyDao.findById(policyId);	if (policy != null && policy.getMaxSnaps() < maxSnaps) {	maxSnaps = policy.getMaxSnaps();	}	while (snaps.size() > maxSnaps && snaps.size() > 1) {	SnapshotVO oldestSnapshot = snaps.get(0);	long oldSnapId = oldestSnapshot.getId();	if (policy != null) {	
max snaps exceeded for snapshot policy with id deleting oldest snapshot 

public boolean deleteSnapshot(long snapshotId) {	Account caller = CallContext.current().getCallingAccount();	SnapshotVO snapshotCheck = _snapshotDao.findById(snapshotId);	if (snapshotCheck == null) {	throw new InvalidParameterValueException("unable to find a snapshot with id " + snapshotId);	}	_accountMgr.checkAccess(caller, null, true, snapshotCheck);	SnapshotStrategy snapshotStrategy = _storageStrategyFactory.getSnapshotStrategy(snapshotCheck, SnapshotOperation.DELETE);	if (snapshotStrategy == null) {	
unable to find snaphot strategy to handle snapshot with id 

}	if (snapshotCheck.getState() == Snapshot.State.BackedUp) {	SnapshotDataStoreVO snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshotId, DataStoreRole.Image);	if (snapshotStoreRef != null) {	_resourceLimitMgr.decrementResourceCount(snapshotCheck.getAccountId(), ResourceType.secondary_storage, new Long(snapshotStoreRef.getPhysicalSize()));	}	}	}	return result;	} catch (Exception e) {	
failed to delete snapshot 

EndPoint ep = _epSelector.select(ssHost);	Answer answer = null;	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if ((answer != null) && answer.getResult()) {	
deleted all snapshots for volume under account 

String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if ((answer != null) && answer.getResult()) {	} else {	success = false;	if (answer != null) {	
failed to delete all snapshot for volume on secondary storage 

success = false;	if (answer != null) {	s_logger.error(answer.getDetails());	}	}	}	List<SnapshotVO> snapshots = listSnapsforVolume(volumeId);	for (SnapshotVO snapshot : snapshots) {	SnapshotStrategy snapshotStrategy = _storageStrategyFactory.getSnapshotStrategy(snapshot, SnapshotOperation.DELETE);	if (snapshotStrategy == null) {	
unable to find snaphot strategy to handle snapshot with id 

}	}	IntervalType intvType = DateUtil.IntervalType.getIntervalType(cmd.getIntervalType());	if (intvType == null) {	throw new InvalidParameterValueException("Unsupported interval type " + cmd.getIntervalType());	}	Type type = getSnapshotType(intvType);	TimeZone timeZone = TimeZone.getTimeZone(cmd.getTimezone());	String timezoneId = timeZone.getID();	if (!timezoneId.equals(cmd.getTimezone())) {	
using timezone for running this snapshot policy as an equivalent of 

private boolean hostSupportSnapsthotForVolume(HostVO host, VolumeInfo volume) {	if (host.getHypervisorType() != HypervisorType.KVM) {	return true;	}	Long vmId = volume.getInstanceId();	if (vmId != null) {	VMInstanceVO vm = _vmDao.findById(vmId);	if (vm.getState() != VirtualMachine.State.Stopped && vm.getState() != VirtualMachine.State.Destroyed) {	boolean snapshotEnabled = Boolean.parseBoolean(_configDao.getValue("kvm.snapshot.enabled"));	if (!snapshotEnabled) {	
snapshot is not supported on host for the volume attached to the vm 

SnapshotDataStoreVO snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshotId, dataStoreRole);	if(snapshotStoreRef == null) {	snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshotId, DataStoreRole.Primary);	if(snapshotStoreRef == null) {	throw new CloudRuntimeException("Could not find snapshot");	}	}	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_SNAPSHOT_CREATE, snapshot.getAccountId(), snapshot.getDataCenterId(), snapshotId, snapshot.getName(), null, null, snapshotStoreRef.getPhysicalSize(), volume.getSize(), snapshot.getClass().getName(), snapshot.getUuid());	_resourceLimitMgr.decrementResourceCount(snapshotOwner.getId(), ResourceType.secondary_storage, new Long(volume.getSize() - snapshotStoreRef.getPhysicalSize()));	} catch (Exception e) {	
post process snapshot failed 

snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshotId, DataStoreRole.Primary);	if(snapshotStoreRef == null) {	throw new CloudRuntimeException("Could not find snapshot");	}	}	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_SNAPSHOT_CREATE, snapshot.getAccountId(), snapshot.getDataCenterId(), snapshotId, snapshot.getName(), null, null, snapshotStoreRef.getPhysicalSize(), volume.getSize(), snapshot.getClass().getName(), snapshot.getUuid());	_resourceLimitMgr.decrementResourceCount(snapshotOwner.getId(), ResourceType.secondary_storage, new Long(volume.getSize() - snapshotStoreRef.getPhysicalSize()));	} catch (Exception e) {	}	} catch (Exception e) {	
failed to create snapshot 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	String value = _configDao.getValue(Config.BackupSnapshotWait.toString());	Type.HOURLY.setMax(NumbersUtil.parseInt(_configDao.getValue("snapshot.max.hourly"), HOURLYMAX));	Type.DAILY.setMax(NumbersUtil.parseInt(_configDao.getValue("snapshot.max.daily"), DAILYMAX));	Type.WEEKLY.setMax(NumbersUtil.parseInt(_configDao.getValue("snapshot.max.weekly"), WEEKLYMAX));	Type.MONTHLY.setMax(NumbersUtil.parseInt(_configDao.getValue("snapshot.max.monthly"), MONTHLYMAX));	_totalRetries = NumbersUtil.parseInt(_configDao.getValue("total.retries"), 4);	_pauseInterval = 2 * NumbersUtil.parseInt(_configDao.getValue("ping.interval"), 60);	
snapshot manager is configured 

}	_accountMgr.checkAccess(CallContext.current().getCallingAccount(), null, true, volume);	}	boolean success = true;	if (policyIds.contains(Snapshot.MANUAL_POLICY_ID)) {	throw new InvalidParameterValueException("Invalid Policy id given: " + Snapshot.MANUAL_POLICY_ID);	}	for (Long pId : policyIds) {	if (!deletePolicy(userId, pId)) {	success = false;	
failed to delete snapshot policy with id 

========================= cloudstack sample_2417 =========================

return null;	}	synchronized (poolKey) {	final Queue<VmwareContext> ctxList = _pool.get(poolKey);	if (ctxList != null && !ctxList.isEmpty()) {	final VmwareContext context = ctxList.remove();	if (context != null) {	context.setPoolInfo(this, poolKey);	}	if (s_logger.isTraceEnabled()) {	
return a vmwarecontext from the idle pool current pool size outstanding count 

if (ctxQueue == null) {	ctxQueue = new ConcurrentLinkedQueue<>();	_pool.put(poolKey, ctxQueue);	}	if (ctxQueue.size() >= _maxIdleQueueLength) {	final VmwareContext oldestContext = ctxQueue.remove();	if (oldestContext != null) {	try {	oldestContext.close();	} catch (Throwable t) {	
unexpected exception caught while trying to purge oldest vmwarecontext 

if (oldestContext != null) {	try {	oldestContext.close();	} catch (Throwable t) {	}	}	}	context.clearStockObjects();	ctxQueue.add(context);	if (s_logger.isTraceEnabled()) {	
recycle vmwarecontext into idle pool current idle pool size outstanding count 

private TimerTask getTimerTask() {	return new ManagedContextTimerTask() {	protected void runInContext() {	try {	doKeepAlive();	} catch (Throwable e) {	
unexpected exception 

for (final Queue<VmwareContext> ctxQueue : _pool.values()) {	for (Iterator<VmwareContext> iterator = ctxQueue.iterator(); iterator.hasNext();) {	final VmwareContext context = iterator.next();	if (context == null) {	iterator.remove();	continue;	}	try {	context.idleCheck();	} catch (Throwable e) {	
exception caught during vmwarecontext idle check close and discard the context 

========================= cloudstack sample_2102 =========================

pstmt.setLong(1, accountId);	pstmt.setLong(2, volId);	pstmt.executeUpdate();	}	}catch (SQLException e) {	throw new CloudException("Error removing usageVolumeVO:"+e.getMessage(), e);	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error removing usagevolumevo 

if (usage.getDeleted() != null) {	pstmt = txn.prepareAutoCloseStatement(UPDATE_DELETED);	pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), usage.getDeleted()));	pstmt.setLong(2, usage.getAccountId());	pstmt.setLong(3, usage.getId());	pstmt.executeUpdate();	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usagevolumevo 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (deletedTS != null) {	deletedDate = DateUtil.parseDateString(s_gmtTimeZone, deletedTS);	}	usageRecords.add(new UsageVolumeVO(vId, zoneId, acctId, dId, doId, tId, size, createdDate, deletedDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4486 =========================

protected void runScript(Connection conn, File file) {	try(FileReader reader = new FileReader(file);) {	ScriptRunner runner = new ScriptRunner(conn, false, true);	runner.runScript(reader);	} catch (FileNotFoundException e) {	
unable to find upgrade script 

protected void runScript(Connection conn, File file) {	try(FileReader reader = new FileReader(file);) {	ScriptRunner runner = new ScriptRunner(conn, false, true);	runner.runScript(reader);	} catch (FileNotFoundException e) {	throw new CloudRuntimeException("Unable to find upgrade script: " + file.getAbsolutePath(), e);	} catch (IOException e) {	
unable to read upgrade script 

protected void runScript(Connection conn, File file) {	try(FileReader reader = new FileReader(file);) {	ScriptRunner runner = new ScriptRunner(conn, false, true);	runner.runScript(reader);	} catch (FileNotFoundException e) {	throw new CloudRuntimeException("Unable to find upgrade script: " + file.getAbsolutePath(), e);	} catch (IOException e) {	throw new CloudRuntimeException("Unable to read upgrade script: " + file.getAbsolutePath(), e);	} catch (SQLException e) {	
unable to execute upgrade script 

protected void upgrade(CloudStackVersion dbVersion, CloudStackVersion currentVersion) {	
database upgrade must be performed from to 

supportsRollingUpgrade = false;	break;	}	}	if (!supportsRollingUpgrade && false) {	String errorMessage = "Unable to run upgrade because the upgrade sequence does not support rolling update and there are other management server nodes running";	s_logger.error(errorMessage);	throw new CloudRuntimeException(errorMessage);	}	for (DbUpgrade upgrade : upgrades) {	
running upgrade to upgrade from to 

txn.commit();	} catch (CloudRuntimeException e) {	String errorMessage = "Unable to upgrade the database";	s_logger.error(errorMessage, e);	throw new CloudRuntimeException(errorMessage, e);	} finally {	txn.close();	}	}	if (true) {	
cleaning upgrades because all management server are now at the same version 

if (upgradeList == null) {	upgradeList = new ArrayList<DbUpgrade>();	}	upgradeList.add(upgrade);	upgradedVersions.put(upgradedVerson, upgradeList);	upgradeVersionsList.add(upgradedVerson);	}	for (String upgradedVersion : upgradeVersionsList) {	List<DbUpgrade> versionUpgrades = upgradedVersions.get(upgradedVersion);	VersionVO version = _dao.findByVersion(upgradedVersion, Step.Upgrade);	
upgrading to version 

upgradedVersions.put(upgradedVerson, upgradeList);	upgradeVersionsList.add(upgradedVerson);	}	for (String upgradedVersion : upgradeVersionsList) {	List<DbUpgrade> versionUpgrades = upgradedVersions.get(upgradedVersion);	VersionVO version = _dao.findByVersion(upgradedVersion, Step.Upgrade);	TransactionLegacy txn = TransactionLegacy.open("Cleanup");	try {	if (version != null) {	for (DbUpgrade upgrade : versionUpgrades) {	
cleanup upgrade to upgrade from to 

conn = txn.getConnection();	} catch (SQLException e) {	String errorMessage = "Unable to cleanup the database";	s_logger.error(errorMessage, e);	throw new CloudRuntimeException(errorMessage, e);	}	File[] scripts = upgrade.getCleanupScripts();	if (scripts != null) {	for (File script : scripts) {	runScript(conn, script);	
cleanup script is executed successfully 

File[] scripts = upgrade.getCleanupScripts();	if (scripts != null) {	for (File script : scripts) {	runScript(conn, script);	}	}	txn.commit();	}	txn.start();	version.setStep(Step.Complete);	
upgrade completed for version 

public void check() {	GlobalLock lock = GlobalLock.getInternLock("DatabaseUpgrade");	try {	
grabbing lock to check for database upgrade 

final String currentVersionValue = this.getClass().getPackage().getImplementationVersion();	if (StringUtils.isBlank(currentVersionValue)) {	return;	}	final CloudStackVersion currentVersion = CloudStackVersion.parse(currentVersionValue);	s_logger.info("DB version = " + dbVersion + " Code Version = " + currentVersion);	if (dbVersion.compareTo(currentVersion) > 0) {	throw new CloudRuntimeException("Database version " + dbVersion + " is higher than management software version " + currentVersionValue);	}	if (dbVersion.compareTo(currentVersion) == 0) {	
db version and code version matches so no upgrade needed 

========================= cloudstack sample_4243 =========================

KVMStoragePool primaryPool = snapshotDisk.getPool();	if (primaryPool.getType() == StoragePoolType.RBD) {	return new Answer(command, false, "revert snapshot to RBD is not implemented yet");	} else {	Script cmd = new Script(libvirtComputingResource.manageSnapshotPath(), libvirtComputingResource.getCmdsTimeout(), s_logger);	cmd.add("-v", snapshotPath);	cmd.add("-n", snapshotDisk.getName());	cmd.add("-p", snapshotDisk.getPath());	String result = cmd.execute();	if (result != null) {	
failed to revert snaptshot 

========================= cloudstack sample_1041 =========================

}	boolean isAdmin = false;	boolean isDomainAdmin = false;	if (accountId == null) {	accountId = caller.getId();	if (_accountService.isRootAdmin(caller.getId())) {	isAdmin = true;	} else if (_accountService.isDomainAdmin(caller.getId())) {	isDomainAdmin = true;	}	
account details not available using usercontext accountid 

}	Date startDate = cmd.getStartDate();	Date endDate = cmd.getEndDate();	if (startDate.after(endDate)) {	throw new InvalidParameterValueException("Incorrect Date Range. Start date: " + startDate + " is after end date:" + endDate);	}	TimeZone usageTZ = getUsageTimezone();	Date adjustedStartDate = computeAdjustedTime(startDate, usageTZ);	Date adjustedEndDate = computeAdjustedTime(endDate, usageTZ);	if (s_logger.isDebugEnabled()) {	
getting usage records for account domainid between and using pagesize and startindex 

========================= cloudstack sample_2397 =========================

private static String genDefaultEncryptorPassword() {	try {	SecureRandom random = SecureRandom.getInstance("SHA1PRNG");	byte[] randomBytes = new byte[16];	random.nextBytes(randomBytes);	return Base64.encodeBase64String(randomBytes);	} catch (NoSuchAlgorithmException e) {	
unexpected exception 

private static void configProxy(Properties conf) {	
configure console proxy 

private static void configProxy(Properties conf) {	for (Object key : conf.keySet()) {	
property 

private static void configProxy(Properties conf) {	for (Object key : conf.keySet()) {	}	String s = conf.getProperty("consoleproxy.httpListenPort");	if (s != null) {	httpListenPort = Integer.parseInt(s);	s_logger.info("Setting httpListenPort=" + s);	}	s = conf.getProperty("premium");	if (s != null && s.equalsIgnoreCase("true")) {	
premium setting will override settings from consoleproxy properties listen at port 

factory.init(ConsoleProxy.ksBits, ConsoleProxy.ksPassword);	return factory;	} catch (InstantiationException e) {	s_logger.error(e.getMessage(), e);	return null;	} catch (IllegalAccessException e) {	s_logger.error(e.getMessage(), e);	return null;	}	} catch (ClassNotFoundException e) {	
unable to find http server factory class 

authResult.setHost(param.getClientHostAddress());	authResult.setPort(param.getClientHostPort());	if (standaloneStart) {	return authResult;	}	if (authMethod != null) {	Object result;	try {	result = authMethod.invoke(ConsoleProxy.context, param.getClientHostAddress(), String.valueOf(param.getClientHostPort()), param.getClientTag(), param.getClientHostPassword(), param.getTicket(), new Boolean(reauthentication));	} catch (IllegalAccessException e) {	
unable to invoke authenticateconsoleaccess due to illegalaccessexception for vm 

return authResult;	}	if (authMethod != null) {	Object result;	try {	result = authMethod.invoke(ConsoleProxy.context, param.getClientHostAddress(), String.valueOf(param.getClientHostPort()), param.getClientTag(), param.getClientHostPassword(), param.getTicket(), new Boolean(reauthentication));	} catch (IllegalAccessException e) {	authResult.setSuccess(false);	return authResult;	} catch (InvocationTargetException e) {	
unable to invoke authenticateconsoleaccess due to invocationtargetexception for vm 

} catch (IllegalAccessException e) {	authResult.setSuccess(false);	return authResult;	} catch (InvocationTargetException e) {	authResult.setSuccess(false);	return authResult;	}	if (result != null && result instanceof String) {	authResult = new Gson().fromJson((String)result, ConsoleProxyAuthenticationResult.class);	} else {	
invalid authentication return object for vm decline the access 

} catch (InvocationTargetException e) {	authResult.setSuccess(false);	return authResult;	}	if (result != null && result instanceof String) {	authResult = new Gson().fromJson((String)result, ConsoleProxyAuthenticationResult.class);	} else {	authResult.setSuccess(false);	}	} else {	
private channel towards management server is not setup switch to offline mode and allow access to vm 

public static void reportLoadInfo(String gsonLoadInfo) {	if (reportMethod != null) {	try {	reportMethod.invoke(ConsoleProxy.context, gsonLoadInfo);	} catch (IllegalAccessException e) {	
unable to invoke reportloadinfo due to 

public static void reportLoadInfo(String gsonLoadInfo) {	if (reportMethod != null) {	try {	reportMethod.invoke(ConsoleProxy.context, gsonLoadInfo);	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	
unable to invoke reportloadinfo due to 

public static void reportLoadInfo(String gsonLoadInfo) {	if (reportMethod != null) {	try {	reportMethod.invoke(ConsoleProxy.context, gsonLoadInfo);	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	}	} else {	
private channel towards management server is not setup switch to offline mode and ignore load report 

public static void ensureRoute(String address) {	if (ensureRouteMethod != null) {	try {	ensureRouteMethod.invoke(ConsoleProxy.context, address);	} catch (IllegalAccessException e) {	
unable to invoke ensureroute due to 

public static void ensureRoute(String address) {	if (ensureRouteMethod != null) {	try {	ensureRouteMethod.invoke(ConsoleProxy.context, address);	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	
unable to invoke ensureroute due to 

public static void ensureRoute(String address) {	if (ensureRouteMethod != null) {	try {	ensureRouteMethod.invoke(ConsoleProxy.context, address);	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	}	} else {	
unable to find ensureroute method console proxy agent is not up to date 

public static void startWithContext(Properties conf, Object context, byte[] ksBits, String ksPassword) {	
start console proxy with context 

public static void startWithContext(Properties conf, Object context, byte[] ksBits, String ksPassword) {	if (conf != null) {	for (Object key : conf.keySet()) {	
context property 

Logger.setFactory(new ConsoleProxyLoggerFactory());	ConsoleProxy.context = context;	ConsoleProxy.ksBits = ksBits;	ConsoleProxy.ksPassword = ksPassword;	try {	Class<?> contextClazz = Class.forName("com.cloud.agent.resource.consoleproxy.ConsoleProxyResource");	authMethod = contextClazz.getDeclaredMethod("authenticateConsoleAccess", String.class, String.class, String.class, String.class, String.class, Boolean.class);	reportMethod = contextClazz.getDeclaredMethod("reportLoadInfo", String.class);	ensureRouteMethod = contextClazz.getDeclaredMethod("ensureRoute", String.class);	} catch (SecurityException e) {	
unable to setup private channel due to securityexception 

ConsoleProxy.context = context;	ConsoleProxy.ksBits = ksBits;	ConsoleProxy.ksPassword = ksPassword;	try {	Class<?> contextClazz = Class.forName("com.cloud.agent.resource.consoleproxy.ConsoleProxyResource");	authMethod = contextClazz.getDeclaredMethod("authenticateConsoleAccess", String.class, String.class, String.class, String.class, String.class, Boolean.class);	reportMethod = contextClazz.getDeclaredMethod("reportLoadInfo", String.class);	ensureRouteMethod = contextClazz.getDeclaredMethod("ensureRoute", String.class);	} catch (SecurityException e) {	} catch (NoSuchMethodException e) {	
unable to setup private channel due to nosuchmethodexception 

ConsoleProxy.ksBits = ksBits;	ConsoleProxy.ksPassword = ksPassword;	try {	Class<?> contextClazz = Class.forName("com.cloud.agent.resource.consoleproxy.ConsoleProxyResource");	authMethod = contextClazz.getDeclaredMethod("authenticateConsoleAccess", String.class, String.class, String.class, String.class, String.class, Boolean.class);	reportMethod = contextClazz.getDeclaredMethod("reportLoadInfo", String.class);	ensureRouteMethod = contextClazz.getDeclaredMethod("ensureRoute", String.class);	} catch (SecurityException e) {	} catch (NoSuchMethodException e) {	} catch (IllegalArgumentException e) {	
unable to setup private channel due to illegalargumentexception 

ConsoleProxy.ksPassword = ksPassword;	try {	Class<?> contextClazz = Class.forName("com.cloud.agent.resource.consoleproxy.ConsoleProxyResource");	authMethod = contextClazz.getDeclaredMethod("authenticateConsoleAccess", String.class, String.class, String.class, String.class, String.class, Boolean.class);	reportMethod = contextClazz.getDeclaredMethod("reportLoadInfo", String.class);	ensureRouteMethod = contextClazz.getDeclaredMethod("ensureRoute", String.class);	} catch (SecurityException e) {	} catch (NoSuchMethodException e) {	} catch (IllegalArgumentException e) {	} catch (ClassNotFoundException e) {	
unable to setup private channel due to classnotfoundexception 

} catch (ClassNotFoundException e) {	}	InputStream confs = ConsoleProxy.class.getResourceAsStream("/conf/consoleproxy.properties");	Properties props = new Properties();	if (confs == null) {	final File file = PropertiesUtil.findConfigFile("consoleproxy.properties");	if (file == null) s_logger.info("Can't load consoleproxy.properties from classpath, will use default configuration");	else try {	confs = new FileInputStream(file);	} catch (FileNotFoundException e) {	
ignoring file not found exception and using defaults 

for (Object key : props.keySet()) {	if (conf.get(key) == null) conf.put(key, props.get(key));	}	} catch (Exception e) {	s_logger.error(e.toString(), e);	}	}	try {	confs.close();	} catch (IOException e) {	
failed to close consolepropxy properties 

public static void start(Properties conf) {	System.setProperty("java.awt.headless", "true");	configProxy(conf);	ConsoleProxyServerFactory factory = getHttpServerFactory();	if (factory == null) {	
unable to load console proxy server factory 

public static void start(Properties conf) {	System.setProperty("java.awt.headless", "true");	configProxy(conf);	ConsoleProxyServerFactory factory = getHttpServerFactory();	if (factory == null) {	System.exit(1);	}	if (httpListenPort != 0) {	startupHttpMain();	} else {	
a valid http server port is required to be specified please check your consoleproxy httplistenport settings 

System.exit(1);	}	if (httpListenPort != 0) {	startupHttpMain();	} else {	System.exit(1);	}	if (httpCmdListenPort > 0) {	startupHttpCmdPort();	} else {	
http command port is disabled 

private static void startupHttpMain() {	try {	ConsoleProxyServerFactory factory = getHttpServerFactory();	if (factory == null) {	
unable to load http server factory 

private static void startupHttpCmdPort() {	try {	
listening for http cmds on port 

public static void main(String[] argv) {	standaloneStart = true;	configLog4j();	Logger.setFactory(new ConsoleProxyLoggerFactory());	InputStream confs = ConsoleProxy.class.getResourceAsStream("/conf/consoleproxy.properties");	Properties conf = new Properties();	if (confs == null) {	
can t load consoleproxy properties from classpath will use default configuration 

public static ConsoleProxyClient getVncViewer(ConsoleProxyClientParam param) throws Exception {	ConsoleProxyClient viewer = null;	boolean reportLoadChange = false;	String clientKey = param.getClientMapKey();	synchronized (connectionMap) {	viewer = connectionMap.get(clientKey);	if (viewer == null) {	viewer = getClient(param);	viewer.initClient(param);	connectionMap.put(clientKey, viewer);	
added viewer object 

boolean reportLoadChange = false;	String clientKey = param.getClientMapKey();	synchronized (connectionMap) {	viewer = connectionMap.get(clientKey);	if (viewer == null) {	viewer = getClient(param);	viewer.initClient(param);	connectionMap.put(clientKey, viewer);	reportLoadChange = true;	} else if (!viewer.isFrontEndAlive()) {	
the rfb thread died reinitializing the viewer 

synchronized (connectionMap) {	viewer = connectionMap.get(clientKey);	if (viewer == null) {	viewer = getClient(param);	viewer.initClient(param);	connectionMap.put(clientKey, viewer);	reportLoadChange = true;	} else if (!viewer.isFrontEndAlive()) {	viewer.initClient(param);	} else if (!param.getClientHostPassword().equals(viewer.getClientHostPassword())) {	
bad sid detected vnc port may be reused sid in session sid in request 

} else if (!viewer.isFrontEndAlive()) {	viewer.initClient(param);	} else if (!param.getClientHostPassword().equals(viewer.getClientHostPassword())) {	viewer.initClient(param);	}	}	if (reportLoadChange) {	ConsoleProxyClientStatsCollector statsCollector = getStatsCollector();	String loadInfo = statsCollector.getStatsReport();	reportLoadInfo(loadInfo);	
report load change 

public static ConsoleProxyClient getAjaxVncViewer(ConsoleProxyClientParam param, String ajaxSession) throws Exception {	boolean reportLoadChange = false;	String clientKey = param.getClientMapKey();	synchronized (connectionMap) {	ConsoleProxyClient viewer = connectionMap.get(clientKey);	if (viewer == null) {	authenticationExternally(param);	viewer = getClient(param);	viewer.initClient(param);	connectionMap.put(clientKey, viewer);	
added viewer object 

if (!viewer.isFrontEndAlive()) {	authenticationExternally(param);	viewer.initClient(param);	reportLoadChange = true;	}	}	if (reportLoadChange) {	ConsoleProxyClientStatsCollector statsCollector = getStatsCollector();	String loadInfo = statsCollector.getStatsReport();	reportLoadInfo(loadInfo);	
report load change 

public static void authenticationExternally(ConsoleProxyClientParam param) throws AuthenticationException {	ConsoleProxyAuthenticationResult authResult = authenticateConsoleAccess(param, false);	if (authResult == null || !authResult.isSuccess()) {	
external authenticator failed authencation request for vm with sid 

========================= cloudstack sample_5002 =========================

public void deployVM(long zoneId, long serviceOfferingId, long templateId, String server, String apiKey, String secretKey) throws IOException {	String encodedZoneId = URLEncoder.encode("" + zoneId, "UTF-8");	String encodedServiceOfferingId = URLEncoder.encode("" + serviceOfferingId, "UTF-8");	String encodedTemplateId = URLEncoder.encode("" + templateId, "UTF-8");	String encodedApiKey = URLEncoder.encode(apiKey, "UTF-8");	String requestToSign = "apiKey=" + encodedApiKey + "&command=deployVirtualMachine&serviceOfferingId=" + encodedServiceOfferingId + "&templateId=" + encodedTemplateId + "&zoneId=" + encodedZoneId;	requestToSign = requestToSign.toLowerCase();	String signature = TestClientWithAPI.signRequest(requestToSign, secretKey);	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = server + "?command=deployVirtualMachine" + "&zoneId=" + encodedZoneId + "&serviceOfferingId=" + encodedServiceOfferingId + "&templateId=" + encodedTemplateId + "&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	
sending this request to deploy a vm 

String encodedTemplateId = URLEncoder.encode("" + templateId, "UTF-8");	String encodedApiKey = URLEncoder.encode(apiKey, "UTF-8");	String requestToSign = "apiKey=" + encodedApiKey + "&command=deployVirtualMachine&serviceOfferingId=" + encodedServiceOfferingId + "&templateId=" + encodedTemplateId + "&zoneId=" + encodedZoneId;	requestToSign = requestToSign.toLowerCase();	String signature = TestClientWithAPI.signRequest(requestToSign, secretKey);	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = server + "?command=deployVirtualMachine" + "&zoneId=" + encodedZoneId + "&serviceOfferingId=" + encodedServiceOfferingId + "&templateId=" + encodedTemplateId + "&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
deploy linux vm response code 

String signature = TestClientWithAPI.signRequest(requestToSign, secretKey);	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = server + "?command=deployVirtualMachine" + "&zoneId=" + encodedZoneId + "&serviceOfferingId=" + encodedServiceOfferingId + "&templateId=" + encodedTemplateId + "&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"id", "ipaddress"});	long linuxVMId = Long.parseLong(values.get("id"));	
got linux virtual machine id 

HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"id", "ipaddress"});	long linuxVMId = Long.parseLong(values.get("id"));	this.setPrivateIp(values.get("ipaddress"));	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorcode", "description"});	
deploy linux vm test failed with errorcode errorCode and description description 

int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> values = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"id", "ipaddress"});	long linuxVMId = Long.parseLong(values.get("id"));	this.setPrivateIp(values.get("ipaddress"));	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorcode", "description"});	} else {	
internal error processing request 

========================= cloudstack sample_433 =========================

public void characters(char[] ch, int start, int length) throws SAXException {	if (_host) {	_capXML.append(ch, start, length);	} else if (_osType) {	guestOsTypes.add(new String(ch, start, length));	} else if (_emulatorFlag) {	
found as a suiteable emulator 

========================= cloudstack sample_1104 =========================

public boolean isRootAdmin(Long accountId) {	if (accountId != null) {	AccountVO acct = _accountDao.findById(accountId);	if (acct == null) {	return false;	}	for (SecurityChecker checker : _securityCheckers) {	try {	if (checker.checkAccess(acct, null, null, "SystemCapability")) {	if (s_logger.isTraceEnabled()) {	
root access granted to by 

public boolean isDomainAdmin(Long accountId) {	if (accountId != null) {	AccountVO acct = _accountDao.findById(accountId);	if (acct == null) {	return false;	}	for (SecurityChecker checker : _securityCheckers) {	try {	if (checker.checkAccess(acct, null, null, "DomainCapability")) {	if (s_logger.isTraceEnabled()) {	
domainadmin access granted to by 

public boolean isResourceDomainAdmin(Long accountId) {	if (accountId != null) {	AccountVO acct = _accountDao.findById(accountId);	if (acct == null) {	return false;	}	for (SecurityChecker checker : _securityCheckers) {	try {	if (checker.checkAccess(acct, null, null, "DomainResourceCapability")) {	if (s_logger.isTraceEnabled()) {	
resourcedomainadmin access granted to by 

public void checkAccess(Account caller, Domain domain) throws PermissionDeniedException {	for (SecurityChecker checker : _securityCheckers) {	if (checker.checkAccess(caller, domain)) {	if (s_logger.isDebugEnabled()) {	
access granted to to by 

ownerId = entity.getAccountId();	} else if (ownerId.longValue() != entity.getAccountId()) {	throw new PermissionDeniedException("Entity " + entity + " and entity " + prevEntity + " belong to different accounts");	}	prevEntity = entity;	}	}	}	if (caller.getId() == Account.ACCOUNT_ID_SYSTEM || isRootAdmin(caller.getId())) {	if (s_logger.isTraceEnabled()) {	
no need to make permission check for system rootadmin account returning true 

if (toBeChecked == null) {	toBeChecked = new ArrayList<ControlledEntity>();	domains.put(domainId, toBeChecked);	}	toBeChecked.add(entity);	}	boolean granted = false;	for (SecurityChecker checker : _securityCheckers) {	if (checker.checkAccess(caller, entity, accessType, apiName)) {	if (s_logger.isDebugEnabled()) {	
access to granted to by 

Account account = _accountDao.findById(accountId);	if (account != null) {	if (account.getState().equals(State.locked)) {	return true;	} else if (account.getState().equals(State.enabled)) {	AccountVO acctForUpdate = _accountDao.createForUpdate();	acctForUpdate.setState(State.locked);	success = _accountDao.update(Long.valueOf(accountId), acctForUpdate);	} else {	if (s_logger.isInfoEnabled()) {	
attempting to lock a non enabled account current state is accountid locking failed 

return true;	} else if (account.getState().equals(State.enabled)) {	AccountVO acctForUpdate = _accountDao.createForUpdate();	acctForUpdate.setState(State.locked);	success = _accountDao.update(Long.valueOf(accountId), acctForUpdate);	} else {	if (s_logger.isInfoEnabled()) {	}	}	} else {	
failed to lock account account not found 

public boolean deleteAccount(AccountVO account, long callerUserId, Account caller) {	long accountId = account.getId();	if (!_accountDao.remove(accountId)) {	
unable to delete account 

public boolean deleteAccount(AccountVO account, long callerUserId, Account caller) {	long accountId = account.getId();	if (!_accountDao.remove(accountId)) {	return false;	}	if (s_logger.isDebugEnabled()) {	
removed account 

protected boolean cleanupAccount(AccountVO account, long callerUserId, Account caller) {	long accountId = account.getId();	boolean accountCleanupNeeded = false;	try {	List<UserVO> users = _userDao.listByAccount(accountId);	for (UserVO user : users) {	if (!_userDao.remove(user.getId())) {	
unable to delete user as a part of account cleanup 

if (gslbRules != null && !gslbRules.isEmpty()) {	_gslbService.revokeAllGslbRulesForAccount(caller, accountId);	}	_projectAccountDao.removeAccountFromProjects(accountId);	if (account.getType() != Account.ACCOUNT_TYPE_PROJECT) {	_messageBus.publish(_name, MESSAGE_REMOVE_ACCOUNT_EVENT, PublishScope.LOCAL, accountId);	}	List<InstanceGroupVO> groups = _vmGroupDao.listByAccountId(accountId);	for (InstanceGroupVO group : groups) {	if (!_vmMgr.deleteVmGroup(group.getId())) {	
unable to delete group 

_messageBus.publish(_name, MESSAGE_REMOVE_ACCOUNT_EVENT, PublishScope.LOCAL, accountId);	}	List<InstanceGroupVO> groups = _vmGroupDao.listByAccountId(accountId);	for (InstanceGroupVO group : groups) {	if (!_vmMgr.deleteVmGroup(group.getId())) {	accountCleanupNeeded = true;	}	}	boolean success = _snapMgr.deleteSnapshotDirsForAccount(accountId);	if (success) {	
successfully deleted snapshots directories for all volumes under account across all zones 

boolean success = _snapMgr.deleteSnapshotDirsForAccount(accountId);	if (success) {	}	List<VMTemplateVO> userTemplates = _templateDao.listByAccountId(accountId);	boolean allTemplatesDeleted = true;	for (VMTemplateVO template : userTemplates) {	if (template.getRemoved() == null) {	try {	allTemplatesDeleted = _tmpltMgr.delete(callerUserId, template.getId(), null);	} catch (Exception e) {	
failed to delete template while removing account due to 

}	if (!allTemplatesDeleted) {	s_logger.warn("Failed to delete templates while removing account id=" + accountId);	accountCleanupNeeded = true;	}	List<VMSnapshotVO> vmSnapshots = _vmSnapshotDao.listByAccountId(Long.valueOf(accountId));	for (VMSnapshot vmSnapshot : vmSnapshots) {	try {	_vmSnapshotMgr.deleteVMSnapshot(vmSnapshot.getId());	} catch (Exception e) {	
failed to cleanup vm snapshot due to 

List<UserVmVO> vms = _userVmDao.listByAccountId(accountId);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Expunging # of vms (accountId=" + accountId + "): " + vms.size());	}	for (UserVmVO vm : vms) {	if (vm.getState() != VirtualMachine.State.Destroyed && vm.getState() != VirtualMachine.State.Expunging) {	try {	_vmMgr.destroyVm(vm.getId());	} catch (Exception e) {	e.printStackTrace();	
failed destroying instance as part of account deletion 

}	for (UserVmVO vm : vms) {	if (vm.getState() != VirtualMachine.State.Destroyed && vm.getState() != VirtualMachine.State.Expunging) {	try {	_vmMgr.destroyVm(vm.getId());	} catch (Exception e) {	e.printStackTrace();	}	}	if (!_vmMgr.expunge(vm, callerUserId, caller)) {	
unable to expunge vm 

}	try {	for (RemoteAccessVpnVO vpn : remoteAccessVpns) {	_remoteAccessVpnMgr.destroyRemoteAccessVpnForIp(vpn.getServerAddressId(), caller);	}	} catch (ResourceUnavailableException ex) {	s_logger.warn("Failed to cleanup remote access vpn resources as a part of account id=" + accountId + " cleanup due to Exception: ", ex);	accountCleanupNeeded = true;	}	int numRemoved = _securityGroupDao.removeByAccountId(accountId);	
deleteaccount deleted network groups for account 

try {	for (RemoteAccessVpnVO vpn : remoteAccessVpns) {	_remoteAccessVpnMgr.destroyRemoteAccessVpnForIp(vpn.getServerAddressId(), caller);	}	} catch (ResourceUnavailableException ex) {	s_logger.warn("Failed to cleanup remote access vpn resources as a part of account id=" + accountId + " cleanup due to Exception: ", ex);	accountCleanupNeeded = true;	}	int numRemoved = _securityGroupDao.removeByAccountId(accountId);	int numAGRemoved = _affinityGroupDao.removeByAccountId(accountId);	
deleteaccount deleted affinity groups for account 

for (RemoteAccessVpnVO vpn : remoteAccessVpns) {	_remoteAccessVpnMgr.destroyRemoteAccessVpnForIp(vpn.getServerAddressId(), caller);	}	} catch (ResourceUnavailableException ex) {	s_logger.warn("Failed to cleanup remote access vpn resources as a part of account id=" + accountId + " cleanup due to Exception: ", ex);	accountCleanupNeeded = true;	}	int numRemoved = _securityGroupDao.removeByAccountId(accountId);	int numAGRemoved = _affinityGroupDao.removeByAccountId(accountId);	boolean networksDeleted = true;	
deleting networks for account 

if (!_networkMgr.destroyNetwork(network.getId(), context, false)) {	s_logger.warn("Unable to destroy network " + network + " as a part of account id=" + accountId + " cleanup.");	accountCleanupNeeded = true;	networksDeleted = false;	} else {	s_logger.debug("Network " + network.getId() + " successfully deleted as a part of account id=" + accountId + " cleanup.");	}	}	}	boolean vpcsDeleted = true;	
deleting vpcs for account 

if (networksDeleted && vpcsDeleted) {	List<? extends IpAddress> ipsToRelease = _ipAddressDao.listByAccount(accountId);	for (IpAddress ip : ipsToRelease) {	s_logger.debug("Releasing ip " + ip + " as a part of account id=" + accountId + " cleanup");	if (!_ipAddrMgr.disassociatePublicIpAddress(ip.getId(), callerUserId, caller)) {	s_logger.warn("Failed to release ip address " + ip + " as a part of account id=" + accountId + " clenaup");	accountCleanupNeeded = true;	}	}	}	
deleting site to site vpn customer gateways for account 

List<? extends IpAddress> ipsToRelease = _ipAddressDao.listByAccount(accountId);	for (IpAddress ip : ipsToRelease) {	s_logger.debug("Releasing ip " + ip + " as a part of account id=" + accountId + " cleanup");	if (!_ipAddrMgr.disassociatePublicIpAddress(ip.getId(), callerUserId, caller)) {	s_logger.warn("Failed to release ip address " + ip + " as a part of account id=" + accountId + " clenaup");	accountCleanupNeeded = true;	}	}	}	if (!_vpnMgr.deleteCustomerGatewayByAccount(accountId)) {	
fail to delete site to site vpn customer gateways for account 

accountCleanupNeeded = true;	} else {	s_logger.debug("Account specific Virtual IP ranges " + " are successfully released as a part of account id=" + accountId + " cleanup.");	}	}	List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(accountId);	for (AccountGuestVlanMapVO map : maps) {	_dataCenterVnetDao.releaseDedicatedGuestVlans(map.getId());	}	int vlansReleased = _accountGuestVlanMapDao.removeByAccountId(accountId);	
deleteaccount released dedicated guest vlan ranges from account 

int vlansReleased = _accountGuestVlanMapDao.removeByAccountId(accountId);	List<? extends IpAddress> ipsToRelease = _ipAddressDao.listByAccount(accountId);	for (IpAddress ip : ipsToRelease) {	if (ip.isPortable()) {	s_logger.debug("Releasing portable ip " + ip + " as a part of account id=" + accountId + " cleanup");	_ipAddrMgr.releasePortableIpAddress(ip.getId());	}	}	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByAccountId(accountId);	if (dedicatedResources != null && !dedicatedResources.isEmpty()) {	
releasing dedicated resources for account 

for (IpAddress ip : ipsToRelease) {	if (ip.isPortable()) {	s_logger.debug("Releasing portable ip " + ip + " as a part of account id=" + accountId + " cleanup");	_ipAddrMgr.releasePortableIpAddress(ip.getId());	}	}	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByAccountId(accountId);	if (dedicatedResources != null && !dedicatedResources.isEmpty()) {	for (DedicatedResourceVO dr : dedicatedResources) {	if (!_dedicatedDao.remove(dr.getId())) {	
fail to release dedicated resources for account 

_resourceLimitMgr.decrementResourceCount(accountId, resourceCount.getType(), resourceCount.getCount());	}	_resourceCountDao.removeEntriesByOwner(accountId, ResourceOwnerType.Account);	_resourceLimitDao.removeEntriesByOwner(accountId, ResourceOwnerType.Account);	List<SSHKeyPairVO> sshkeypairs = _sshKeyPairDao.listKeyPairs(accountId, account.getDomainId());	for (SSHKeyPairVO keypair: sshkeypairs) {	_sshKeyPairDao.remove(keypair.getId());	}	return true;	} catch (Exception ex) {	
failed to cleanup account due to 

_resourceLimitDao.removeEntriesByOwner(accountId, ResourceOwnerType.Account);	List<SSHKeyPairVO> sshkeypairs = _sshKeyPairDao.listKeyPairs(accountId, account.getDomainId());	for (SSHKeyPairVO keypair: sshkeypairs) {	_sshKeyPairDao.remove(keypair.getId());	}	return true;	} catch (Exception ex) {	accountCleanupNeeded = true;	return true;	} finally {	
cleanup for account is needed is not needed 

public boolean disableAccount(long accountId) throws ConcurrentOperationException, ResourceUnavailableException {	boolean success = false;	if (accountId <= 2) {	if (s_logger.isInfoEnabled()) {	
disableaccount invalid account id 

} else {	AccountVO acctForUpdate = _accountDao.createForUpdate();	acctForUpdate.setState(State.disabled);	success = _accountDao.update(Long.valueOf(accountId), acctForUpdate);	if (success) {	boolean disableAccountResult = false;	try {	disableAccountResult = doDisableAccount(accountId);	} finally {	if (!disableAccountResult) {	
failed to disable account resources as a part of disableaccount call marking the account for cleanup 

private boolean doDisableAccount(long accountId) throws ConcurrentOperationException, ResourceUnavailableException {	List<VMInstanceVO> vms = _vmDao.listByAccountId(accountId);	boolean success = true;	for (VMInstanceVO vm : vms) {	try {	try {	_itMgr.advanceStop(vm.getUuid(), false);	} catch (OperationTimedoutException ote) {	
operation for stopping vm timed out unable to stop vm 

List<VMInstanceVO> vms = _vmDao.listByAccountId(accountId);	boolean success = true;	for (VMInstanceVO vm : vms) {	try {	try {	_itMgr.advanceStop(vm.getUuid(), false);	} catch (OperationTimedoutException ote) {	success = false;	}	} catch (AgentUnavailableException aue) {	
agent running on host is unavailable unable to stop vm 

if (timeZone != null) {	user.setTimezone(timeZone);	}	if (apiKey != null) {	user.setApiKey(apiKey);	}	if (secretKey != null) {	user.setSecretKey(secretKey);	}	if (s_logger.isDebugEnabled()) {	
updating user with id 

if (apiKeyOwner != null) {	User usr = apiKeyOwner.first();	if (usr.getId() != userId) {	throw new InvalidParameterValueException("The api key:" + apiKey + " exists in the system for user id:" + userId + " ,please provide a unique key");	} else {	}	}	}	_userDao.update(userId, user);	} catch (Throwable th) {	
error updating user 

if (oneUser.getState().equals(State.enabled)) {	lockAccount = false;	break;	}	}	if (lockAccount) {	success = (success && lockAccount(user.getAccountId()));	}	} else {	if (s_logger.isInfoEnabled()) {	
attempting to lock a non enabled user current state is userid locking failed 

public boolean deleteUserAccount(long accountId) {	CallContext ctx = CallContext.current();	long callerUserId = ctx.getCallingUserId();	Account caller = ctx.getCallingAccount();	AccountVO account = _accountDao.findById(accountId);	if (account == null || account.getRemoved() != null) {	if (account != null) {	
the account is already removed 

String networkDomain = cmd.getNetworkDomain();	final Map<String, String> details = cmd.getDetails();	boolean success = false;	Account account = null;	if (accountId != null) {	account = _accountDao.findById(accountId);	} else {	account = _accountDao.findEnabledAccount(accountName, domainId);	}	if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {	
unable to find account by accountid or by name in domain 

protected void runInContext() {	try {	GlobalLock lock = GlobalLock.getInternLock("AccountCleanup");	if (lock == null) {	
couldn t get the global lock 

protected void runInContext() {	try {	GlobalLock lock = GlobalLock.getInternLock("AccountCleanup");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	
couldn t lock the db 

try {	GlobalLock lock = GlobalLock.getInternLock("AccountCleanup");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	return;	}	try {	List<AccountVO> removedAccounts = _accountDao.findCleanupsForRemovedAccounts(null);	
found removed accounts to cleanup 

GlobalLock lock = GlobalLock.getInternLock("AccountCleanup");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	return;	}	try {	List<AccountVO> removedAccounts = _accountDao.findCleanupsForRemovedAccounts(null);	for (AccountVO account : removedAccounts) {	
cleaning up 

}	if (!lock.lock(30)) {	return;	}	try {	List<AccountVO> removedAccounts = _accountDao.findCleanupsForRemovedAccounts(null);	for (AccountVO account : removedAccounts) {	cleanupAccount(account, getSystemUser().getId(), getSystemAccount());	}	List<AccountVO> disabledAccounts = _accountDao.findCleanupsForDisabledAccounts();	
found disabled accounts to cleanup 

if (!lock.lock(30)) {	return;	}	try {	List<AccountVO> removedAccounts = _accountDao.findCleanupsForRemovedAccounts(null);	for (AccountVO account : removedAccounts) {	cleanupAccount(account, getSystemUser().getId(), getSystemAccount());	}	List<AccountVO> disabledAccounts = _accountDao.findCleanupsForDisabledAccounts();	for (AccountVO account : disabledAccounts) {	
disabling account 

try {	List<AccountVO> removedAccounts = _accountDao.findCleanupsForRemovedAccounts(null);	for (AccountVO account : removedAccounts) {	cleanupAccount(account, getSystemUser().getId(), getSystemAccount());	}	List<AccountVO> disabledAccounts = _accountDao.findCleanupsForDisabledAccounts();	for (AccountVO account : disabledAccounts) {	try {	disableAccount(account.getId());	} catch (Exception e) {	
skipping due to error on account 

cleanupAccount(account, getSystemUser().getId(), getSystemAccount());	}	List<AccountVO> disabledAccounts = _accountDao.findCleanupsForDisabledAccounts();	for (AccountVO account : disabledAccounts) {	try {	disableAccount(account.getId());	} catch (Exception e) {	}	}	List<? extends Domain> inactiveDomains = _domainMgr.findInactiveDomains();	
found inactive domains to cleanup 

}	}	List<? extends Domain> inactiveDomains = _domainMgr.findInactiveDomains();	for (Domain inactiveDomain : inactiveDomains) {	long domainId = inactiveDomain.getId();	try {	List<AccountVO> accountsForCleanupInDomain = _accountDao.findCleanupsForRemovedAccounts(domainId);	if (accountsForCleanupInDomain.isEmpty()) {	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByDomainId(domainId);	if (dedicatedResources != null && !dedicatedResources.isEmpty()) {	
releasing dedicated resources for domain 

List<? extends Domain> inactiveDomains = _domainMgr.findInactiveDomains();	for (Domain inactiveDomain : inactiveDomains) {	long domainId = inactiveDomain.getId();	try {	List<AccountVO> accountsForCleanupInDomain = _accountDao.findCleanupsForRemovedAccounts(domainId);	if (accountsForCleanupInDomain.isEmpty()) {	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByDomainId(domainId);	if (dedicatedResources != null && !dedicatedResources.isEmpty()) {	for (DedicatedResourceVO dr : dedicatedResources) {	if (!_dedicatedDao.remove(dr.getId())) {	
fail to release dedicated resources for domain 

if (!_dedicatedDao.remove(dr.getId())) {	}	}	}	s_logger.debug("Removing inactive domain id=" + domainId);	_domainMgr.removeDomain(domainId);	} else {	s_logger.debug("Can't remove inactive domain id=" + domainId + " as it has accounts that need cleanup");	}	} catch (Exception e) {	
skipping due to error on domain 

}	s_logger.debug("Removing inactive domain id=" + domainId);	_domainMgr.removeDomain(domainId);	} else {	s_logger.debug("Can't remove inactive domain id=" + domainId + " as it has accounts that need cleanup");	}	} catch (Exception e) {	}	}	List<ProjectVO> inactiveProjects = _projectDao.listByState(Project.State.Disabled);	
found disabled projects to cleanup 

for (ProjectVO project : inactiveProjects) {	try {	Account projectAccount = getAccount(project.getProjectAccountId());	if (projectAccount == null) {	s_logger.debug("Removing inactive project id=" + project.getId());	_projectMgr.deleteProject(CallContext.current().getCallingAccount(), CallContext.current().getCallingUserId(), project);	} else {	s_logger.debug("Can't remove disabled project " + project + " as it has non removed account id=" + project.getId());	}	} catch (Exception e) {	
skipping due to error on project 

if (projectAccount == null) {	s_logger.debug("Removing inactive project id=" + project.getId());	_projectMgr.deleteProject(CallContext.current().getCallingAccount(), CallContext.current().getCallingUserId(), project);	} else {	s_logger.debug("Can't remove disabled project " + project + " as it has non removed account id=" + project.getId());	}	} catch (Exception e) {	}	}	} catch (Exception e) {	
exception 

s_logger.debug("Can't remove disabled project " + project + " as it has non removed account id=" + project.getId());	}	} catch (Exception e) {	}	}	} catch (Exception e) {	} finally {	lock.unlock();	}	} catch (Exception e) {	
exception 

protected UserVO createUser(long accountId, String userName, String password, String firstName, String lastName, String email, String timezone, String userUUID, User.Source source) {	if (s_logger.isDebugEnabled()) {	
creating user accountid timezone 

private UserAccount getUserAccount(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	
attempting to log in user in domain 

boolean updateIncorrectLoginCount = actionsOnFailedAuthenticaion.contains(ActionOnFailedAuthentication.INCREMENT_INCORRECT_LOGIN_ATTEMPT_COUNT);	if (authenticated) {	Domain domain = _domainMgr.getDomain(domainId);	String domainName = null;	if (domain != null) {	domainName = domain.getName();	}	userAccount = _userAccountDao.getUserAccount(username, domainId);	if (!userAccount.getState().equalsIgnoreCase(Account.State.enabled.toString()) || !userAccount.getAccountState().equalsIgnoreCase(Account.State.enabled.toString())) {	if (s_logger.isInfoEnabled()) {	
user in domain is disabled locked or account is disabled locked 

userAccount = _userAccountDao.getUserAccount(username, domainId);	if (!userAccount.getState().equalsIgnoreCase(Account.State.enabled.toString()) || !userAccount.getAccountState().equalsIgnoreCase(Account.State.enabled.toString())) {	if (s_logger.isInfoEnabled()) {	}	throw new CloudAuthenticationException("User " + username + " (or their account) in domain " + domainName + " is disabled/locked. Please contact the administrator.");	}	if (!isInternalAccount(userAccount.getId())) updateLoginAttempts(userAccount.getId(), 0, false);	return userAccount;	} else {	if (s_logger.isDebugEnabled()) {	
unable to authenticate user with username in domain 

if (s_logger.isInfoEnabled()) {	}	throw new CloudAuthenticationException("User " + username + " (or their account) in domain " + domainName + " is disabled/locked. Please contact the administrator.");	}	if (!isInternalAccount(userAccount.getId())) updateLoginAttempts(userAccount.getId(), 0, false);	return userAccount;	} else {	if (s_logger.isDebugEnabled()) {	}	if (userAccount == null) {	
unable to find an user with username in domain 

}	if (userAccount == null) {	return null;	}	if (userAccount.getState().equalsIgnoreCase(Account.State.enabled.toString())) {	if (!isInternalAccount(userAccount.getId())) {	int attemptsMade = userAccount.getLoginAttempts() + 1;	if (updateIncorrectLoginCount) {	if (attemptsMade < _allowedLoginAttempts) {	updateLoginAttempts(userAccount.getId(), attemptsMade, false);	
login attempt failed you have attempt s remaining 

return null;	}	if (userAccount.getState().equalsIgnoreCase(Account.State.enabled.toString())) {	if (!isInternalAccount(userAccount.getId())) {	int attemptsMade = userAccount.getLoginAttempts() + 1;	if (updateIncorrectLoginCount) {	if (attemptsMade < _allowedLoginAttempts) {	updateLoginAttempts(userAccount.getId(), attemptsMade, false);	} else {	updateLoginAttempts(userAccount.getId(), _allowedLoginAttempts, true);	
user has been disabled due to multiple failed login attempts please contact admin 

int attemptsMade = userAccount.getLoginAttempts() + 1;	if (updateIncorrectLoginCount) {	if (attemptsMade < _allowedLoginAttempts) {	updateLoginAttempts(userAccount.getId(), attemptsMade, false);	} else {	updateLoginAttempts(userAccount.getId(), _allowedLoginAttempts, true);	}	}	}	} else {	
user is disabled locked 

public void checkAccess(Account account, ServiceOffering so) throws PermissionDeniedException {	for (SecurityChecker checker : _securityCheckers) {	if (checker.checkAccess(account, so)) {	if (s_logger.isDebugEnabled()) {	
access granted to to by 

public void checkAccess(Account account, DiskOffering dof) throws PermissionDeniedException {	for (SecurityChecker checker : _securityCheckers) {	if (checker.checkAccess(account, dof)) {	if (s_logger.isDebugEnabled()) {	
access granted to to by 

========================= cloudstack sample_2401 =========================

maskNextCommand--;	continue;	}	if (command.equalsIgnoreCase("-P")) {	maskNextCommand = 1;	} else if (command.toLowerCase().endsWith("password")) {	maskNextCommand = 2;	}	cleanedCommands.add(command);	}	
executed ipmitool process with commands ipmitool execution standard output ipmitool execution error output 

========================= cloudstack sample_1387 =========================

public boolean connectPhysicalDisk(String volumeUuid, KVMStoragePool pool, Map<String, String> details) {	Script iScsiAdmCmd = new Script(true, "iscsiadm", 0, s_logger);	iScsiAdmCmd.add("-m", "node");	iScsiAdmCmd.add("-T", getIqn(volumeUuid));	iScsiAdmCmd.add("-p", pool.getSourceHost() + ":" + pool.getSourcePort());	iScsiAdmCmd.add("-o", "new");	String result = iScsiAdmCmd.execute();	if (result != null) {	
failed to add iscsi target 

Script iScsiAdmCmd = new Script(true, "iscsiadm", 0, s_logger);	iScsiAdmCmd.add("-m", "node");	iScsiAdmCmd.add("-T", getIqn(volumeUuid));	iScsiAdmCmd.add("-p", pool.getSourceHost() + ":" + pool.getSourcePort());	iScsiAdmCmd.add("-o", "new");	String result = iScsiAdmCmd.execute();	if (result != null) {	System.out.println("Failed to add iSCSI target " + volumeUuid);	return false;	} else {	
successfully added iscsi target 

return false;	}	}	iScsiAdmCmd = new Script(true, "iscsiadm", 0, s_logger);	iScsiAdmCmd.add("-m", "node");	iScsiAdmCmd.add("-T", getIqn(volumeUuid));	iScsiAdmCmd.add("-p", pool.getSourceHost() + ":" + pool.getSourcePort());	iScsiAdmCmd.add("--login");	result = iScsiAdmCmd.execute();	if (result != null) {	
failed to log in to iscsi target 

iScsiAdmCmd = new Script(true, "iscsiadm", 0, s_logger);	iScsiAdmCmd.add("-m", "node");	iScsiAdmCmd.add("-T", getIqn(volumeUuid));	iScsiAdmCmd.add("-p", pool.getSourceHost() + ":" + pool.getSourcePort());	iScsiAdmCmd.add("--login");	result = iScsiAdmCmd.execute();	if (result != null) {	System.out.println("Failed to log in to iSCSI target " + volumeUuid);	return false;	} else {	
successfully logged in to iscsi target 

iScsiAdmCmd.add("-n", nParameter);	iScsiAdmCmd.add("-v", vParameter);	String result = iScsiAdmCmd.execute();	boolean useDetail = detail != null && detail.trim().length() > 0;	detail = useDetail ? detail.trim() + " " : detail;	if (result != null) {	s_logger.debug("Failed to execute CHAP " + (useDetail ? detail : "") + "command for iSCSI target " + path + " : message = " + result);	System.out.println("Failed to execute CHAP " + (useDetail ? detail : "") + "command for iSCSI target " + path + " : message = " + result);	throw new Exception("Failed to execute CHAP " + (useDetail ? detail : "") + "command for iSCSI target " + path + " : message = " + result);	} else {	
chap command executed successfully for iscsi target 

private long getDeviceSize(String deviceByPath) {	Script iScsiAdmCmd = new Script(true, "blockdev", 0, s_logger);	iScsiAdmCmd.add("--getsize64", deviceByPath);	OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();	String result = iScsiAdmCmd.execute(parser);	if (result != null) {	
unable to retrieve the size of device 

iScsiAdmCmd.add("-m", "node");	iScsiAdmCmd.add("-T", iqn);	iScsiAdmCmd.add("-p", host + ":" + port);	iScsiAdmCmd.add("--logout");	String result = iScsiAdmCmd.execute();	if (result != null) {	s_logger.debug("Failed to log out of iSCSI target /" + iqn + "/" + lun + " : message = " + result);	System.out.println("Failed to log out of iSCSI target /" + iqn + "/" + lun + " : message = " + result);	return false;	} else {	
successfully logged out of iscsi target 

iScsiAdmCmd.add("-m", "node");	iScsiAdmCmd.add("-T", iqn);	iScsiAdmCmd.add("-p", host + ":" + port);	iScsiAdmCmd.add("-o", "delete");	result = iScsiAdmCmd.execute();	if (result != null) {	s_logger.debug("Failed to remove iSCSI target /" + iqn + "/" + lun + " : message = " + result);	System.out.println("Failed to remove iSCSI target /" + iqn + "/" + lun + " : message = " + result);	return false;	} else {	
removed iscsi target 

========================= cloudstack sample_1016 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	bmMgr.notifyProvisionDone(this);	this.setResponseObject(new SuccessResponse(getCommandName()));	} catch (Exception e) {	
unable to notify baremetal provision done mac s 

========================= cloudstack sample_872 =========================

public UserIpv6Address assignDirectIp6Address(long dcId, Account owner, Long networkId, String requestedIp6) throws InsufficientAddressCapacityException {	Network network = _networkDao.findById(networkId);	if (network == null) {	return null;	}	List<VlanVO> vlans = _vlanDao.listVlansByNetworkId(networkId);	if (vlans == null) {	
cannot find related vlan attached to network 

========================= cloudstack sample_2285 =========================

static void setParameter(BaseCmd cmd, String name, BaseCmd.CommandType fieldType, Object value) {	Class<?> cls = cmd.getClass();	Field field;	try {	field = cls.getDeclaredField(name);	} catch (Exception ex) {	
class t 

private void createPublicVlanIpRange() {	CreateVlanIpRangeCmd cmd = new CreateVlanIpRangeCmd();	BaseCmd proxy = ComponentContext.inject(cmd);	Long public_net_id = null;	List<NetworkVO> nets = _networksDao.listByZoneAndTrafficType(_zone.getId(), TrafficType.Public);	if (nets != null && !nets.isEmpty()) {	NetworkVO public_net = nets.get(0);	public_net_id = public_net.getId();	} else {	
no public network found in the zone 

Account system = _accountMgr.getSystemAccount();	setParameter(cmd, "accountName", BaseCmd.CommandType.STRING, system.getAccountName());	setParameter(cmd, "domainId", BaseCmd.CommandType.LONG, Domain.ROOT_DOMAIN);	setParameter(cmd, "startIp", BaseCmd.CommandType.STRING, "10.84.60.200");	setParameter(cmd, "endIp", BaseCmd.CommandType.STRING, "10.84.60.250");	setParameter(cmd, ApiConstants.GATEWAY, BaseCmd.CommandType.STRING, "10.84.60.254");	setParameter(cmd, ApiConstants.NETMASK, BaseCmd.CommandType.STRING, "255.255.255.0");	setParameter(cmd, "networkID", BaseCmd.CommandType.LONG, public_net_id);	setParameter(cmd, "zoneId", BaseCmd.CommandType.LONG, _zone.getId());	setParameter(cmd, "vlan", BaseCmd.CommandType.STRING, "untagged");	
createpublicvlaniprange execute zone id public net id 

setParameter(cmd, "startIp", BaseCmd.CommandType.STRING, "10.84.60.200");	setParameter(cmd, "endIp", BaseCmd.CommandType.STRING, "10.84.60.250");	setParameter(cmd, ApiConstants.GATEWAY, BaseCmd.CommandType.STRING, "10.84.60.254");	setParameter(cmd, ApiConstants.NETMASK, BaseCmd.CommandType.STRING, "255.255.255.0");	setParameter(cmd, "networkID", BaseCmd.CommandType.LONG, public_net_id);	setParameter(cmd, "zoneId", BaseCmd.CommandType.LONG, _zone.getId());	setParameter(cmd, "vlan", BaseCmd.CommandType.STRING, "untagged");	try {	_configService.createVlanAndPublicIpRange(cmd);	} catch (Exception e) {	
createpublicvlaniprange 

for (PhysicalNetworkTrafficType ttype : trafficTypes.first()) {	if (ttype.getTrafficType() == TrafficType.Guest) {	found = true;	}	}	if (!found) {	_networkService.addTrafficTypeToPhysicalNetwork(_znet.getId(), TrafficType.Guest.toString(), "vlan", null, null, null, null, null, null, null);	}	Pair<List<? extends PhysicalNetworkServiceProvider>, Integer> providers = _networkService.listNetworkServiceProviders(_znet.getId(), Provider.JuniperContrailRouter.getName(), null, null, null);	if (providers.second() == 0) {	
add to network 

if (providers.second() == 0) {	PhysicalNetworkServiceProvider provider = _networkService.addProviderToPhysicalNetwork(_znet.getId(), Provider.JuniperContrailRouter.getName(), null, null);	_networkService.updateNetworkServiceProvider(provider.getId(), PhysicalNetworkServiceProvider.State.Enabled.toString(), null);	} else {	PhysicalNetworkServiceProvider provider = providers.first().get(0);	if (provider.getState() != PhysicalNetworkServiceProvider.State.Enabled) {	_networkService.updateNetworkServiceProvider(provider.getId(), PhysicalNetworkServiceProvider.State.Enabled.toString(), null);	}	}	providers = _networkService.listNetworkServiceProviders(_znet.getId(), null, PhysicalNetworkServiceProvider.State.Enabled.toString(), null, null);	
has enabled providers 

PhysicalNetworkServiceProvider provider = providers.first().get(0);	if (provider.getState() != PhysicalNetworkServiceProvider.State.Enabled) {	_networkService.updateNetworkServiceProvider(provider.getId(), PhysicalNetworkServiceProvider.State.Enabled.toString(), null);	}	}	providers = _networkService.listNetworkServiceProviders(_znet.getId(), null, PhysicalNetworkServiceProvider.State.Enabled.toString(), null, null);	for (PhysicalNetworkServiceProvider provider : providers.first()) {	if (provider.getProviderName().equals(Provider.JuniperContrailRouter.getName())) {	continue;	}	
disabling 

========================= cloudstack sample_1850 =========================

public void execute() {	
getsolidfirevolumeaccessgroupidcmd execute method invoked 

========================= cloudstack sample_2006 =========================

public String encryptText(String text) {	if (text == null || text.isEmpty()) return text;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	
unexpected exception 

if (text == null || text.isEmpty()) return text;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	
unexpected exception 

Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	
unexpected exception 

cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = cipher.doFinal(text.getBytes());	return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	
unexpected exception 

return Base64.encodeBase64URLSafeString(encryptedBytes);	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	
unexpected exception 

return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	return null;	} catch (InvalidAlgorithmParameterException e) {	
unexpected exception 

public String decryptText(String encryptedText) {	if (encryptedText == null || encryptedText.isEmpty()) return encryptedText;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	
unexpected exception 

if (encryptedText == null || encryptedText.isEmpty()) return encryptedText;	try {	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	
unexpected exception 

Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");	SecretKeySpec keySpec = new SecretKeySpec(keyIvPair.getKeyBytes(), "AES");	cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	
unexpected exception 

cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(keyIvPair.getIvBytes()));	byte[] encryptedBytes = Base64.decodeBase64(encryptedText);	return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	
unexpected exception 

return new String(cipher.doFinal(encryptedBytes));	} catch (NoSuchAlgorithmException e) {	return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	
unexpected exception 

return null;	} catch (NoSuchPaddingException e) {	return null;	} catch (IllegalBlockSizeException e) {	return null;	} catch (BadPaddingException e) {	return null;	} catch (InvalidKeyException e) {	return null;	} catch (InvalidAlgorithmParameterException e) {	
unexpected exception 

========================= cloudstack sample_4994 =========================

public VmwareServerDiscoverer() {	
vmwareserverdiscoverer is constructed 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	
configure vmwareserverdiscoverer discover name 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	super.configure(name, params);	createVmwareToolsIso();	if (s_logger.isInfoEnabled()) {	
vmwareserverdiscoverer has been successfully configured 

private VmwareTrafficLabel getTrafficInfo(TrafficType trafficType, String zoneWideTrafficLabel, VirtualSwitchType defaultVirtualSwitchType, String vSwitchType, String vSwitchName, Long clusterId) {	VmwareTrafficLabel trafficLabelObj = null;	Map<String, String> clusterDetails = null;	try {	trafficLabelObj = new VmwareTrafficLabel(zoneWideTrafficLabel, trafficType, defaultVirtualSwitchType);	} catch (InvalidParameterValueException e) {	
failed to recognize virtual switch type specified for traffic due to 

private VmwareTrafficLabel getTrafficInfo(TrafficType trafficType, String zoneWideTrafficLabel, Map<String, String> clusterDetails, VirtualSwitchType defVirtualSwitchType) {	VmwareTrafficLabel trafficLabelObj = null;	try {	trafficLabelObj = new VmwareTrafficLabel(zoneWideTrafficLabel, trafficType, defVirtualSwitchType);	} catch (InvalidParameterValueException e) {	
failed to recognize virtual switch type specified for traffic due to 

public ServerResource reloadResource(HostVO host) {	String resourceName = host.getResource();	ServerResource resource = getResource(resourceName);	if (resource != null) {	_hostDao.loadDetails(host);	HashMap<String, Object> params = buildConfigParams(host);	try {	resource.configure(host.getName(), params);	} catch (ConfigurationException e) {	
unable to configure resource due to 

ServerResource resource = getResource(resourceName);	if (resource != null) {	_hostDao.loadDetails(host);	HashMap<String, Object> params = buildConfigParams(host);	try {	resource.configure(host.getName(), params);	} catch (ConfigurationException e) {	return null;	}	if (!resource.start()) {	
unable to start the resource 

private void validateVswitchType(String inputVswitchType) {	VirtualSwitchType vSwitchType = VirtualSwitchType.getType(inputVswitchType);	if (vSwitchType == VirtualSwitchType.None) {	
unable to resolve to a valid virtual switch type in vmware environment 

========================= cloudstack sample_1295 =========================

if (newTemplate.getHypervisorType() != null) {	templateVO.setHypervisorType(newTemplate.getHypervisorType());	}	templateVO.setSize(newTemplate.getSize());	imageDao.update(templateVO.getId(), templateVO);	}	}	}	objectInStoreMgr.update(this, event);	} catch (NoTransitionException e) {	
failed to update state 

}	templateVO.setSize(newTemplate.getSize());	imageDao.update(templateVO.getId(), templateVO);	}	}	}	objectInStoreMgr.update(this, event);	} catch (NoTransitionException e) {	throw new CloudRuntimeException("Failed to update state" + e.toString());	} catch (Exception ex) {	
failed to process event and answer 

========================= cloudstack sample_3950 =========================

public void process(VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid) throws AffinityConflictException {	VirtualMachine vm = vmProfile.getVirtualMachine();	List<AffinityGroupVMMapVO> vmGroupMappings = _affinityGroupVMMapDao.findByVmIdType(vm.getId(), getType());	DataCenter dc = _dcDao.findById(vm.getDataCenterId());	List<DedicatedResourceVO> resourceList = new ArrayList<DedicatedResourceVO>();	if (vmGroupMappings != null && !vmGroupMappings.isEmpty()) {	for (AffinityGroupVMMapVO vmGroupMapping : vmGroupMappings) {	if (vmGroupMapping != null) {	if (s_logger.isDebugEnabled()) {	
processing affinity group of type explicitdedication for vm id 

avoid.addHost(host.getId());	}	}	}	} else {	if (resourceList != null && resourceList.size() != 0) {	avoid = updateAvoidList(resourceList, avoid, dc);	} else {	avoid.addDataCenter(dc.getId());	if (s_logger.isDebugEnabled()) {	
no dedicated resources available for this domain or account under this group 

}	} else {	if (resourceList != null && resourceList.size() != 0) {	avoid = updateAvoidList(resourceList, avoid, dc);	} else {	avoid.addDataCenter(dc.getId());	if (s_logger.isDebugEnabled()) {	}	}	if (s_logger.isDebugEnabled()) {	
explicitdedicationprocessor returns avoid list as deploy avoids pods clusters hosts 

public void handleDeleteGroup(final AffinityGroup group) {	if (group != null) {	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByAffinityGroupId(group.getId());	if (!dedicatedResources.isEmpty()) {	if (s_logger.isDebugEnabled()) {	
releasing the dedicated resources under group 

listByAffinityGroup.and("affinityGroupId", listByAffinityGroup.entity().getAffinityGroupId(), SearchCriteria.Op.EQ);	listByAffinityGroup.done();	SearchCriteria<DedicatedResourceVO> sc = listByAffinityGroup.create();	sc.setParameters("affinityGroupId", group.getId());	_dedicatedDao.lockRows(sc, null, true);	_dedicatedDao.remove(sc);	}	});	} else {	if (s_logger.isDebugEnabled()) {	
no dedicated resources to releease under group 

========================= cloudstack sample_1982 =========================

final NicProfile guestNic = nicProfileHelper.createGuestNicProfileForVpcRouter(vpcRouterDeploymentDefinition, guestNetwork);	networks.put(guestNetwork, new ArrayList<NicProfile>(Arrays.asList(guestNic)));	}	}	final List<IPAddressVO> ips = _ipAddressDao.listByAssociatedVpc(vpcId, false);	final List<NicProfile> publicNics = new ArrayList<NicProfile>();	Network publicNetwork = null;	for (final IPAddressVO ip : ips) {	final PublicIp publicIp = PublicIp.createFromAddrAndVlan(ip, _vlanDao.findById(ip.getVlanId()));	if ((ip.getState() == IpAddress.State.Allocated || ip.getState() == IpAddress.State.Allocating) && vpcMgr.isIpAllocatedToVpc(ip) && !publicVlans.contains(publicIp.getVlanTag())) {	
allocating nic for router in vlan 

========================= cloudstack sample_2357 =========================

public void cancel(final long seq) {	if (forForward()) {	Listener listener = getListener(seq);	if (listener != null && listener instanceof SynchronousListener) {	SynchronousListener synchronous = (SynchronousListener)listener;	String peerName = synchronous.getPeer();	if (peerName != null) {	if (s_clusteredAgentMgr != null) {	
forwarding to peer to cancel due to timeout 

public void cancel(final long seq) {	if (forForward()) {	Listener listener = getListener(seq);	if (listener != null && listener instanceof SynchronousListener) {	SynchronousListener synchronous = (SynchronousListener)listener;	String peerName = synchronous.getPeer();	if (peerName != null) {	if (s_clusteredAgentMgr != null) {	s_clusteredAgentMgr.cancel(peerName, _id, seq, "Timed Out");	} else {	
unable to forward cancel clusteredagentattache is not properly initialized 

public void routeToAgent(final byte[] data) throws AgentUnavailableException {	if (s_logger.isDebugEnabled()) {	
routing from 

public void routeToAgent(final byte[] data) throws AgentUnavailableException {	if (s_logger.isDebugEnabled()) {	}	if (_link == null) {	if (s_logger.isDebugEnabled()) {	
link is closed 

}	if (_link == null) {	if (s_logger.isDebugEnabled()) {	}	throw new AgentUnavailableException("Link is closed", _id);	}	try {	_link.send(data);	} catch (ClosedChannelException e) {	if (s_logger.isDebugEnabled()) {	
channel is closed 

throw new AgentUnavailableException("Link is closed", _id);	}	try {	_link.send(data);	} catch (ClosedChannelException e) {	if (s_logger.isDebugEnabled()) {	}	throw new AgentUnavailableException("Channel to agent is closed", _id);	} catch (NullPointerException e) {	if (s_logger.isDebugEnabled()) {	
link is closed 

if (_link != null) {	super.send(req, listener);	return;	}	long seq = req.getSequence();	if (listener != null) {	registerListener(req.getSequence(), listener);	}	if (_transferMode) {	if (s_logger.isDebugEnabled()) {	
holding request as the corresponding agent is in transfer mode 

boolean error = true;	try {	while (i++ < 5) {	String peerName = s_clusteredAgentMgr.findPeer(_id);	if (peerName == null) {	throw new AgentUnavailableException("Unable to find peer", _id);	}	ch = s_clusteredAgentMgr.connectToPeer(peerName, ch);	if (ch == null) {	if (s_logger.isDebugEnabled()) {	
unable to forward 

if (s_logger.isDebugEnabled()) {	}	continue;	}	SSLEngine sslEngine = s_clusteredAgentMgr.getSSLEngine(peerName);	if (sslEngine == null) {	throw new AgentUnavailableException("Unable to get SSLEngine of peer " + peerName, _id);	}	try {	if (s_logger.isDebugEnabled()) {	
forwarding to 

synchronous.setPeer(peerName);	}	Link.write(ch, req.toBytes(), sslEngine);	error = false;	return;	} catch (IOException e) {	if (s_logger.isDebugEnabled()) {	s_logger.debug(log(seq, "Error on connecting to management node: " + req.toString() + " try = " + i));	}	if (s_logger.isInfoEnabled()) {	
ioexception when sending data to peer close peer connection and let it re open 

========================= cloudstack sample_4779 =========================

while ((line = reader.readLine()) != null) {	sb2.append(line + "\n");	}	result = sb2.toString();	} catch (final IOException e) {	success = false;	} finally {	try {	is.close();	} catch (final IOException e) {	
exception when closing console proxy address 

} catch (final IOException e) {	success = false;	} finally {	try {	is.close();	} catch (final IOException e) {	success = false;	}	}	} catch (final IOException e) {	
unable to open console proxy command port url console proxy address 

========================= cloudstack sample_1081 =========================

public void execute() {	Host result;	try {	result = _resourceService.updateHost(this);	HostResponse hostResponse = _responseGenerator.createHostResponse(result);	hostResponse.setResponseName(getCommandName());	this.setResponseObject(hostResponse);	} catch (Exception e) {	
failed to update host 

========================= cloudstack sample_3116 =========================

public void execute() throws ResourceUnavailableException {	try {	boolean result = _rulesService.enableStaticNat(ipAddressId, virtualMachineId, getNetworkId(), getVmSecondaryIp());	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to enable static NAT");	}	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

public void execute() throws ResourceUnavailableException {	try {	boolean result = _rulesService.enableStaticNat(ipAddressId, virtualMachineId, getNetworkId(), getVmSecondaryIp());	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to enable static NAT");	}	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

========================= cloudstack sample_3395 =========================

try {	File props = PropertiesUtil.findConfigFile("db.properties");	if (props != null && props.exists()) {	is = new FileInputStream(props);	}	if (is == null) {	is = PropertiesUtil.openStreamFromURL("db.properties");	}	if (is == null) {	System.err.println("Failed to find db.properties");	
failed to find db properties 

========================= cloudstack sample_2838 =========================

throw new CloudRuntimeException("GSLB service is not enabled in region : " + region.getName());	}	GlobalLoadBalancerRuleVO newGslbRule = Transaction.execute(new TransactionCallback<GlobalLoadBalancerRuleVO>() {	public GlobalLoadBalancerRuleVO doInTransaction(TransactionStatus status) {	GlobalLoadBalancerRuleVO newGslbRule = new GlobalLoadBalancerRuleVO(name, description, domainName, algorithm, stickyMethod, serviceType, regionId, gslbOwner.getId(), gslbOwner.getDomainId(), GlobalLoadBalancerRule.State.Staged);	_gslbRuleDao.persist(newGslbRule);	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_GLOBAL_LOAD_BALANCER_CREATE, newGslbRule.getAccountId(), 0, newGslbRule.getId(), name, GlobalLoadBalancerRule.class.getName(), newGslbRule.getUuid());	return newGslbRule;	}	});	
successfully created new global load balancer rule for the account 

_gslbLbMapDao.persist(newGslbLbMap);	}	if (gslbRule.getState() == GlobalLoadBalancerRule.State.Staged || gslbRule.getState() == GlobalLoadBalancerRule.State.Active) {	gslbRule.setState(GlobalLoadBalancerRule.State.Add);	_gslbRuleDao.update(gslbRule.getId(), gslbRule);	}	}	});	boolean success = false;	try {	
configuring gslb rule configuration on the gslb service providers in the participating zones 

}	if (gslbRule.getState() == GlobalLoadBalancerRule.State.Staged || gslbRule.getState() == GlobalLoadBalancerRule.State.Active) {	gslbRule.setState(GlobalLoadBalancerRule.State.Add);	_gslbRuleDao.update(gslbRule.getId(), gslbRule);	}	}	});	boolean success = false;	try {	if (!applyGlobalLoadBalancerRuleConfig(gslbRuleId, false)) {	
failed to add load balancer rules to global load balancer rule id 

_gslbLbMapDao.update(removeGslbLbMap.getId(), removeGslbLbMap);	}	if (gslbRule.getState() == GlobalLoadBalancerRule.State.Staged) {	gslbRule.setState(GlobalLoadBalancerRule.State.Add);	_gslbRuleDao.update(gslbRule.getId(), gslbRule);	}	}	});	boolean success = false;	try {	
attempting to configure global load balancer rule configuration on the gslb service providers 

}	if (gslbRule.getState() == GlobalLoadBalancerRule.State.Staged) {	gslbRule.setState(GlobalLoadBalancerRule.State.Add);	_gslbRuleDao.update(gslbRule.getId(), gslbRule);	}	}	});	boolean success = false;	try {	if (!applyGlobalLoadBalancerRuleConfig(gslbRuleId, false)) {	
failed to remove load balancer rules from global load balancer rule id 

public boolean deleteGlobalLoadBalancerRule(DeleteGlobalLoadBalancerRuleCmd deleteGslbCmd) {	CallContext ctx = CallContext.current();	Account caller = ctx.getCallingAccount();	long gslbRuleId = deleteGslbCmd.getGlobalLoadBalancerId();	try {	revokeGslbRule(gslbRuleId, caller);	} catch (Exception e) {	
failed to delete gslb rule due to 

private void revokeGslbRule(final long gslbRuleId, Account caller) {	final GlobalLoadBalancerRuleVO gslbRule = _gslbRuleDao.findById(gslbRuleId);	if (gslbRule == null) {	throw new InvalidParameterValueException("Invalid global load balancer rule id: " + gslbRuleId);	}	_accountMgr.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, true, gslbRule);	if (gslbRule.getState() == com.cloud.region.ha.GlobalLoadBalancerRule.State.Staged) {	if (s_logger.isDebugEnabled()) {	
rule id is still in staged state so just removing it 

}	if (stickyMethod != null) {	gslbRule.setPersistence(stickyMethod);	}	if (description != null) {	gslbRule.setDescription(description);	}	gslbRule.setState(GlobalLoadBalancerRule.State.Add);	_gslbRuleDao.update(gslbRule.getId(), gslbRule);	try {	
updating global load balancer with id 

========================= cloudstack sample_2245 =========================

public Answer execute(final UpdateHostPasswordCommand command, final CitrixResourceBase citrixResourceBase) {	final String hostIp = command.getHostIp();	final String username = command.getUsername();	final String newPassword = command.getNewPassword();	final XenServerUtilitiesHelper xenServerUtilitiesHelper = citrixResourceBase.getXenServerUtilitiesHelper();	final String cmdLine = xenServerUtilitiesHelper.buildCommandLine(SCRIPT_CMD_PATH, VRScripts.UPDATE_HOST_PASSWD, username, newPassword);	Pair<Boolean, String> result;	try {	
executing command in host 

========================= cloudstack sample_1193 =========================

final String vlanNetmask = ip.getVlanNetmask();	if (ip.isAdd()) {	addGuestVlanAndSubnet(guestVlanTag, vlanSelfIp, vlanNetmask, true);	} else {	deleteGuestVlan(guestVlanTag, vlanSelfIp, vlanNetmask);	}	saveConfiguration();	results[i++] = ip.getPublicIp() + " - success";	final String action = ip.isAdd() ? "associate" : "remove";	if (s_logger.isDebugEnabled()) {	
netscaler load balancer successfully executed ipassoccommand to ip 

} else {	deleteGuestVlan(guestVlanTag, vlanSelfIp, vlanNetmask);	}	saveConfiguration();	results[i++] = ip.getPublicIp() + " - success";	final String action = ip.isAdd() ? "associate" : "remove";	if (s_logger.isDebugEnabled()) {	}	}	} catch (final ExecutionException e) {	
netscaler loadbalancer failed to execute ipassoccommand due to 

destination.setMonitorState(binding.get_curstate());	break;	}	}	}	hcLB.add(loadBalancer);	}	}	}	} catch (final ExecutionException e) {	
failed to execute healthchecklbconfigcommand due to 

}	}	}	} catch (final ExecutionException e) {	if (shouldRetry(numRetries)) {	return retry(cmd, numRetries);	} else {	return new HealthCheckLBConfigAnswer(hcLB);	}	} catch (final Exception e) {	
failed to execute healthchecklbconfigcommand due to 

boolean deleteCert = false;	for (final DestinationTO destination : loadBalancer.getDestinations()) {	if (!destination.isRevoked()) {	destinationsToAdd = true;	break;	}	}	if (!loadBalancer.isRevoked() && destinationsToAdd) {	addLBVirtualServer(nsVirtualServerName, srcIp, srcPort, lbAlgorithm, lbProtocol, loadBalancer.getStickinessPolicies(), null);	if (s_logger.isDebugEnabled()) {	
created load balancing virtual server on the netscaler device 

final String intermediateCertKeyName = generateSslCertKeyName(fingerPrint);	final String intermediateCertFileName = intermediateCertKeyName + ".pem";	if (!SSL.isSslCertKeyPresent(_netscalerService, intermediateCertKeyName)) {	final PemObject pemObject = new PemObject(intermediateCert.getType(), intermediateCert.getEncoded());	final StringWriter textWriter = new StringWriter();	try (final PemWriter pemWriter = new PemWriter(textWriter);) {	pemWriter.writeObject(pemObject);	pemWriter.flush();	} catch (final IOException e) {	if (s_logger.isDebugEnabled()) {	
couldn t write pem to a string 

final String certKeyName = generateSslCertKeyName(sslCert.getFingerprint());	try (final ByteArrayOutputStream certDataStream = new ByteArrayOutputStream();) {	certDataStream.write(sslCert.getCert().getBytes());	if (!SSL.isSslCertKeyPresent(_netscalerService, certKeyName)) {	SSL.uploadCert(_ip, _username, _password, certFilename, certDataStream.toByteArray());	SSL.uploadKey(_ip, _username, _password, keyFilename, sslCert.getKey().getBytes());	SSL.createSslCertKey(_netscalerService, certFilename, keyFilename, certKeyName, sslCert.getPassword());	}	} catch (final IOException e) {	if (s_logger.isDebugEnabled()) {	
couldn t open buffer for certificate 

if (s_logger.isDebugEnabled()) {	}	}	if (previousCertKeyName != null && !SSL.certLinkExists(_netscalerService, certKeyName, previousCertKeyName)) {	SSL.linkCerts(_netscalerService, certKeyName, previousCertKeyName);	}	SSL.bindCertKeyToVserver(_netscalerService, certKeyName, nsVirtualServerName);	}	}	if (s_logger.isDebugEnabled()) {	
successfully added lb destination to load balancer 

SSL.deleteSslCertKey(_netscalerService, intermediateCertKeyName);	SSL.deleteCertFile(_ip, _username, _password, intermediateCertFileName);	} else {	break;	}	}	}	}	}	if (s_logger.isInfoEnabled()) {	
successfully executed resource loadbalancerconfigcommand 

}	}	}	}	}	if (s_logger.isInfoEnabled()) {	}	saveConfiguration();	return new Answer(cmd);	} catch (final ExecutionException e) {	
failed to execute loadbalancerconfigcommand due to 

}	saveConfiguration();	return new Answer(cmd);	} catch (final ExecutionException e) {	if (shouldRetry(numRetries)) {	return retry(cmd, numRetries);	} else {	return new Answer(cmd, e);	}	} catch (final Exception e) {	
failed to execute loadbalancerconfigcommand due to 

ns newVpx = ns.add(_netscalerSdxService, ns_obj);	if (newVpx == null) {	return new Answer(cmd, new ExecutionException("Failed to create VPX instance on the netscaler SDX device " + _ip));	}	long startTick = System.currentTimeMillis();	final long startWaitMilliSeconds = 600000;	while (!newVpx.get_instance_state().equalsIgnoreCase("up") && System.currentTimeMillis() - startTick < startWaitMilliSeconds) {	try {	Thread.sleep(10000);	} catch (final InterruptedException e) {	
ignored interupted while waiting for netscaler to be up 

}	} catch (final Exception e) {	Thread.sleep(10000);	continue;	}	}	if (!nsServiceUp) {	return new Answer(cmd, new ExecutionException("Failed to create VPX instance " + vpxName + " on the netscaler SDX device " + _ip));	}	if (s_logger.isInfoEnabled()) {	
successfully provisioned vpx instance on the netscaler sdx device 

site.set_publicip(sitePublicIP);	site.set_metricexchange("ENABLED");	site.set_nwmetricexchange("ENABLED");	site.set_sessionexchange("ENABLED");	if (isUpdateSite) {	gslbsite.update(client, site);	} else {	gslbsite.add(client, site);	}	if (s_logger.isDebugEnabled()) {	
successfully created gslb site 

private static void deleteSite(final nitro_service client, final String siteName) throws ExecutionException {	try {	final gslbsite site = getSiteObject(client, siteName);	if (site != null) {	final gslbsite_gslbservice_binding[] serviceBindings = gslbsite_gslbservice_binding.get(client, siteName);	if (serviceBindings != null && serviceBindings.length > 0) {	if (s_logger.isDebugEnabled()) {	
there are services associated with gslb site so ignoring site deletion 

try {	final gslbsite site = getSiteObject(client, siteName);	if (site != null) {	final gslbsite_gslbservice_binding[] serviceBindings = gslbsite_gslbservice_binding.get(client, siteName);	if (serviceBindings != null && serviceBindings.length > 0) {	if (s_logger.isDebugEnabled()) {	}	}	gslbsite.delete(client, siteName);	if (s_logger.isDebugEnabled()) {	
successfully deleted gslb site 

final gslbsite_gslbservice_binding[] serviceBindings = gslbsite_gslbservice_binding.get(client, siteName);	if (serviceBindings != null && serviceBindings.length > 0) {	if (s_logger.isDebugEnabled()) {	}	}	gslbsite.delete(client, siteName);	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
ignoring delete request for non existing gslb site 

private static void updateSite(final nitro_service client, final String siteType, final String siteName, final String siteIP, final String sitePublicIP) throws ExecutionException {	try {	gslbsite site;	site = getSiteObject(client, siteName);	if (site == null) {	if (s_logger.isDebugEnabled()) {	
ignoring update request for non existing gslb site 

assert "LOCAL".equalsIgnoreCase(siteType) || "REMOTE".equalsIgnoreCase(siteType);	site.set_sitetype(siteType);	site.set_sitename(siteName);	site.set_siteipaddress(siteIP);	site.set_publicip(sitePublicIP);	site.set_metricexchange("ENABLED");	site.set_nwmetricexchange("ENABLED");	site.set_sessionexchange("ENABLED");	gslbsite.update(client, site);	if (s_logger.isDebugEnabled()) {	
successfully updated gslb site 

private static void deleteVirtualServer(final nitro_service client, final String vserverName) throws ExecutionException {	try {	final gslbvserver vserver = getVserverObject(client, vserverName);	if (vserver != null) {	gslbvserver.delete(client, vserver);	if (s_logger.isDebugEnabled()) {	
successfully deleted gslb virtual server 

private static void deleteVirtualServer(final nitro_service client, final String vserverName) throws ExecutionException {	try {	final gslbvserver vserver = getVserverObject(client, vserverName);	if (vserver != null) {	gslbvserver.delete(client, vserver);	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
ignoring delete request for non existing gslb virtual server 

service.set_servicename(serviceName);	service.set_servicetype(serviceType);	if (isUpdateSite) {	service.set_viewip(null);	service.set_viewname(null);	gslbservice.update(client, service);	} else {	gslbservice.add(client, service);	}	if (s_logger.isDebugEnabled()) {	
successfully created service at site 

private static void deleteService(final nitro_service client, final String serviceName) throws ExecutionException {	try {	final gslbservice service = getServiceObject(client, serviceName);	if (service != null) {	gslbservice.delete(client, serviceName);	if (s_logger.isDebugEnabled()) {	
successfully deleted service 

private static void deleteService(final nitro_service client, final String serviceName) throws ExecutionException {	try {	final gslbservice service = getServiceObject(client, serviceName);	if (service != null) {	gslbservice.delete(client, serviceName);	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
ignoring delete request for non existing service 

private static void createVserverServiceBinding(final nitro_service client, final String serviceName, final String vserverName, final long weight) throws ExecutionException {	String errMsg;	try {	assert weight >= 1 && weight <= 100;	final gslbvserver_gslbservice_binding binding = new gslbvserver_gslbservice_binding();	binding.set_name(vserverName);	binding.set_servicename(serviceName);	binding.set_weight(weight);	gslbvserver_gslbservice_binding.add(client, binding);	if (s_logger.isDebugEnabled()) {	
successfully created service and virtual server binding 

private static void deleteVserverServiceBinding(final nitro_service client, final String serviceName, final String vserverName) throws ExecutionException {	try {	final gslbvserver_gslbservice_binding[] bindings = gslbvserver_gslbservice_binding.get(client, vserverName);	if (bindings != null) {	for (final gslbvserver_gslbservice_binding binding : bindings) {	if (binding.get_servicename().equalsIgnoreCase(serviceName) && binding.get_name().equals(vserverName)) {	gslbvserver_gslbservice_binding.delete(client, binding);	if (s_logger.isDebugEnabled()) {	
successfully deleted service and virtual server binding 

private static void createVserverDomainBinding(final nitro_service client, final String vserverName, final String domainName) throws ExecutionException {	String errMsg;	try {	final gslbvserver_domain_binding binding = new gslbvserver_domain_binding();	binding.set_domainname(domainName);	binding.set_name(vserverName);	gslbvserver_domain_binding.add(client, binding);	if (s_logger.isDebugEnabled()) {	
successfully added virtual server domain name binding 

private static void deleteVserverDomainBinding(final nitro_service client, final String vserverName, final String domainName) throws ExecutionException {	try {	final gslbvserver_domain_binding[] bindings = gslbvserver_domain_binding.get(client, vserverName);	if (bindings != null) {	for (final gslbvserver_domain_binding binding : bindings) {	if (binding.get_domainname().equalsIgnoreCase(domainName)) {	gslbvserver_domain_binding.delete(client, binding);	if (s_logger.isDebugEnabled()) {	
successfully deleted virtual server and domain binding 

private static void createGslbServiceGslbMonitorBinding(final nitro_service nsService, final String monitorName, final String serviceName) {	try {	final gslbservice_lbmonitor_binding monitorBinding = new gslbservice_lbmonitor_binding();	monitorBinding.set_monitor_name(monitorName);	monitorBinding.set_servicename(serviceName);	gslbservice_lbmonitor_binding.add(nsService, monitorBinding);	} catch (final Exception e) {	
failed to bind monitor to gslb service due to 

private static void deleteGslbServiceGslbMonitorBinding(final nitro_service nsService, final String monitorName, final String serviceName) {	try {	final gslbservice_lbmonitor_binding[] monitorBindings = gslbservice_lbmonitor_binding.get(nsService, serviceName);	if (monitorBindings != null && monitorBindings.length > 0) {	for (final gslbservice_lbmonitor_binding binding : monitorBindings) {	if (binding.get_monitor_name().equalsIgnoreCase(monitorName)) {	
found a binding between monitor and 

try {	final gslbservice_lbmonitor_binding[] monitorBindings = gslbservice_lbmonitor_binding.get(nsService, serviceName);	if (monitorBindings != null && monitorBindings.length > 0) {	for (final gslbservice_lbmonitor_binding binding : monitorBindings) {	if (binding.get_monitor_name().equalsIgnoreCase(monitorName)) {	gslbservice_lbmonitor_binding.delete(nsService, binding);	}	}	}	} catch (final Exception e) {	
failed to delete gslb monitor and gslb service binding due to but moving on will be cleaned up as part of gslb service delete any way 

private static gslbsite getSiteObject(final nitro_service client, final String siteName) {	try {	final gslbsite site = gslbsite.get(client, siteName);	if (site != null) {	return site;	}	} catch (final Exception e) {	
ignored error getting site 

private static void createSslCertKey(final nitro_service ns, final String certFilename, final String keyFilename, final String certKeyName, final String password) throws ExecutionException {	
adding cert to netscaler 

private static void bindCertKeyToVserver(final nitro_service ns, final String certKeyName, final String vserver) throws ExecutionException {	
adding cert to netscaler 

iNatRule.set_privateip(dstIP);	iNatRule.set_usnip("OFF");	iNatRule.set_usip("ON");	try {	apiCallResult = inat.add(_netscalerService, iNatRule);	} catch (final nitro_exception e) {	if (e.getErrorCode() != NitroError.NS_RESOURCE_EXISTS) {	throw e;	}	}	
created inat rule on the netscaler device to enable static nat from to 

rnatRule.set_natip(srcIp);	rnatRule.set_network(dstIP);	rnatRule.set_netmask("255.255.255.255");	try {	apiCallResult = rnat.update(_netscalerService, rnatRule);	} catch (final nitro_exception e) {	if (e.getErrorCode() != NitroError.NS_RESOURCE_EXISTS) {	throw e;	}	}	
created rnat rule on the netscaler device to enable revese static nat from to 

rnat.clear(_netscalerService, rnatRule);	break;	}	}	}	} catch (final nitro_exception e) {	if (e.getErrorCode() != NitroError.NS_RESOURCE_NOT_EXISTS) {	throw e;	}	}	
deleted inat rule on the netscaler device to remove static nat from to 

}	if (vserverExisis) {	apiCallResult = lbvserver.update(_netscalerService, vserver);	} else {	apiCallResult = lbvserver.add(_netscalerService, vserver);	}	if (apiCallResult.errorcode != 0) {	throw new ExecutionException("Failed to create new load balancing virtual server:" + virtualServerName + " due to " + apiCallResult.message);	}	if (s_logger.isDebugEnabled()) {	
created load balancing virtual server on the netscaler device 

throw new ExecutionException("Can not update monitor :" + nsMonitorName + " as current protocol:" + csMonitor.get_type() + " of monitor is different from the " + " intended protocol:" + lbProtocol);	}	csMonitorExisis = true;	}	if (!csMonitorExisis) {	final lbmonitor csMon = new lbmonitor();	csMon.set_monitorname(nsMonitorName);	csMon.set_type(lbProtocol);	if (lbProtocol.equalsIgnoreCase("HTTP")) {	csMon.set_httprequest(hcp.getpingPath());	
lb protocol is http applying ping path on healthcheck policy 

}	csMonitorExisis = true;	}	if (!csMonitorExisis) {	final lbmonitor csMon = new lbmonitor();	csMon.set_monitorname(nsMonitorName);	csMon.set_type(lbProtocol);	if (lbProtocol.equalsIgnoreCase("HTTP")) {	csMon.set_httprequest(hcp.getpingPath());	} else {	
lb protocol is not http skipping to apply ping path on healthcheck policy 

csMon.set_type(lbProtocol);	if (lbProtocol.equalsIgnoreCase("HTTP")) {	csMon.set_httprequest(hcp.getpingPath());	} else {	}	csMon.set_interval(hcp.getHealthcheckInterval());	csMon.set_retries(Math.max(hcp.getHealthcheckThresshold(), hcp.getUnhealthThresshold()) + 1);	csMon.set_resptimeout(hcp.getResponseTime());	csMon.set_failureretries(hcp.getUnhealthThresshold());	csMon.set_successretries(hcp.getHealthcheckThresshold());	
monitor properites going to get created interval resptimeout failure retires unhealththresshold successtries healththresshold 

csMon.set_httprequest(hcp.getpingPath());	} else {	}	csMon.set_interval(hcp.getHealthcheckInterval());	csMon.set_retries(Math.max(hcp.getHealthcheckThresshold(), hcp.getUnhealthThresshold()) + 1);	csMon.set_resptimeout(hcp.getResponseTime());	csMon.set_failureretries(hcp.getUnhealthThresshold());	csMon.set_successretries(hcp.getHealthcheckThresshold());	lbmonitor.add(_netscalerService, csMon);	} else {	
monitor is already existing skipping to delete and create it 

private void bindServiceToMonitor(final String nsServiceName, final String nsMonitorName) throws ExecutionException {	try {	com.citrix.netscaler.nitro.resource.config.basic.service serviceObject = new com.citrix.netscaler.nitro.resource.config.basic.service();	serviceObject = com.citrix.netscaler.nitro.resource.config.basic.service.get(_netscalerService, nsServiceName);	if (serviceObject != null) {	final com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding serviceMonitor = new com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding();	serviceMonitor.set_monitor_name(nsMonitorName);	serviceMonitor.set_name(nsServiceName);	serviceMonitor.set_monstate("ENABLED");	
trying to bind the monitor to the service 

private void bindServiceToMonitor(final String nsServiceName, final String nsMonitorName) throws ExecutionException {	try {	com.citrix.netscaler.nitro.resource.config.basic.service serviceObject = new com.citrix.netscaler.nitro.resource.config.basic.service();	serviceObject = com.citrix.netscaler.nitro.resource.config.basic.service.get(_netscalerService, nsServiceName);	if (serviceObject != null) {	final com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding serviceMonitor = new com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding();	serviceMonitor.set_monitor_name(nsMonitorName);	serviceMonitor.set_name(nsServiceName);	serviceMonitor.set_monstate("ENABLED");	com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding.add(_netscalerService, serviceMonitor);	
successfully binded the monitor to the service 

private void unBindServiceToMonitor(final String nsServiceName, final String nsMonitorName) throws ExecutionException {	try {	com.citrix.netscaler.nitro.resource.config.basic.service serviceObject = new com.citrix.netscaler.nitro.resource.config.basic.service();	serviceObject = com.citrix.netscaler.nitro.resource.config.basic.service.get(_netscalerService, nsServiceName);	if (serviceObject != null) {	final com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding serviceMonitor = new com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding();	serviceMonitor.set_monitor_name(nsMonitorName);	serviceMonitor.set_name(nsServiceName);	
trying to unbind the monitor from the service 

private void unBindServiceToMonitor(final String nsServiceName, final String nsMonitorName) throws ExecutionException {	try {	com.citrix.netscaler.nitro.resource.config.basic.service serviceObject = new com.citrix.netscaler.nitro.resource.config.basic.service();	serviceObject = com.citrix.netscaler.nitro.resource.config.basic.service.get(_netscalerService, nsServiceName);	if (serviceObject != null) {	final com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding serviceMonitor = new com.citrix.netscaler.nitro.resource.config.basic.service_lbmonitor_binding();	serviceMonitor.set_monitor_name(nsMonitorName);	serviceMonitor.set_name(nsServiceName);	service_lbmonitor_binding.delete(_netscalerService, serviceMonitor);	
successfully unbinded the monitor from the service 

private void removeLBMonitor(final String nsMonitorName) throws ExecutionException {	try {	if (nsMonitorExist(nsMonitorName)) {	final lbmonitor monitorObj = lbmonitor.get(_netscalerService, nsMonitorName);	monitorObj.set_respcode(null);	lbmonitor.delete(_netscalerService, monitorObj);	
successfully deleted monitor 

if (!isAutoScaleSupportedInNetScaler()) {	throw new ExecutionException("AutoScale not supported in this version of NetScaler");	}	if (loadBalancer.isRevoked() || vmGroupTO.getState().equals("revoke")) {	removeAutoScaleConfig(loadBalancer);	} else {	createAutoScaleConfig(loadBalancer);	}	saveConfiguration();	if (s_logger.isInfoEnabled()) {	
successfully executed resource autoscaleconfig 

private synchronized boolean createAutoScaleConfig(final LoadBalancerTO loadBalancerTO) throws ExecutionException, Exception {	final String srcIp = loadBalancerTO.getSrcIp();	final int srcPort = loadBalancerTO.getSrcPort();	final String lbProtocol = getNetScalerProtocol(loadBalancerTO);	final String lbAlgorithm = loadBalancerTO.getAlgorithm();	generateAutoScaleVmGroupIdentifier(loadBalancerTO);	final String nsVirtualServerName = generateNSVirtualServerName(srcIp, srcPort);	final AutoScaleVmGroupTO vmGroupTO = loadBalancerTO.getAutoScaleVmGroupTO();	if (s_logger.isDebugEnabled()) {	
created load balancing virtual server on the netscaler device 

private boolean isAutoScaleSupportedInNetScaler() throws ExecutionException {	new autoscaleprofile();	try {	autoscaleprofile.get(_netscalerService);	} catch (final Exception ex) {	
autoscale is not supported in netscaler 

bytesSentAndReceived = new long[] {0, 0};	}	bytesSentAndReceived[0] += stat_entry.get_totalrequestbytes();	bytesSentAndReceived[1] += stat_entry.get_totalresponsebytes();	if (bytesSentAndReceived[0] >= 0 && bytesSentAndReceived[1] >= 0) {	answer.ipBytes.put(lbVirtualServerIp, bytesSentAndReceived);	}	}	}	} catch (final Exception e) {	
failed to get bytes sent and recived statistics due to 

private Answer retry(final Command cmd, final int numRetries) {	final int numRetriesRemaining = numRetries - 1;	
retrying number of retries remaining 

private boolean shouldRetry(final int numRetries) {	try {	if (numRetries > 0) {	login();	return true;	}	} catch (final Exception e) {	
failed to log in to netscaler device at due to 

========================= cloudstack sample_1469 =========================

public static String encryptWithSSHPublicKey(String sshPublicKey, String content) {	String returnString = null;	try {	RSAPublicKey publicKey = readKey(sshPublicKey);	Cipher cipher = Cipher.getInstance("RSA/None/PKCS1Padding", BouncyCastleProvider.PROVIDER_NAME);	cipher.init(Cipher.ENCRYPT_MODE, publicKey, new SecureRandom());	byte[] encrypted = cipher.doFinal(content.getBytes());	returnString = Base64.encodeBase64String(encrypted);	} catch (Exception e) {	
ignored error during public key encryption 

========================= cloudstack sample_2750 =========================

private void closeStream() {	if (socketWrapper.shutdown) return;	if (verbose) System.out.println("[" + this + "] INFO: Closing stream.");	try {	sendEventToAllPads(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	
ignored failing sending source event to all pads 

========================= cloudstack sample_5095 =========================

public Boolean fenceOff(VirtualMachine vm, Host host) {	if (host.getHypervisorType() != HypervisorType.KVM && host.getHypervisorType() != HypervisorType.LXC) {	
don t know how to fence non kvm hosts 

continue;	}	i++;	if (h.getId() == host.getId()) {	continue;	}	FenceAnswer answer;	try {	answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);	} catch (AgentUnavailableException e) {	
moving on to the next host because is unavailable 

i++;	if (h.getId() == host.getId()) {	continue;	}	FenceAnswer answer;	try {	answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);	} catch (AgentUnavailableException e) {	continue;	} catch (OperationTimedoutException e) {	
moving on to the next host because is unavailable 

continue;	} catch (OperationTimedoutException e) {	continue;	}	if (answer != null && answer.getResult()) {	return true;	}	}	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(), "Unable to fence off host: " + host.getId(), "Fencing off host " + host.getId() + " did not succeed after asking " + i + " hosts. " + "Check Agent logs for more information.");	
unable to fence off on 

========================= cloudstack sample_2496 =========================

public Answer execute(final OvsCreateTunnelCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	String bridge = "unknown";	try {	final Network nw = citrixResourceBase.findOrCreateTunnelNetwork(conn, command.getNetworkName());	if (nw == null) {	
error during bridge setup 

citrixResourceBase.configureTunnelNetwork(conn, command.getNetworkId(), command.getFrom(), command.getNetworkName());	bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovstunnel", "create_tunnel", "bridge", bridge, "remote_ip", command.getRemoteIp(), "key", command.getKey().toString(), "from", command.getFrom().toString(), "to", command.getTo().toString(), "cloudstack-network-id", command.getNetworkUuid());	final String[] res = result.split(":");	if (res.length == 2 && res[0].equalsIgnoreCase("SUCCESS")) {	return new OvsCreateTunnelAnswer(command, true, result, res[1], bridge);	} else {	return new OvsCreateTunnelAnswer(command, false, result, bridge);	}	} catch (final Exception e) {	
error during tunnel setup 

citrixResourceBase.configureTunnelNetwork(conn, command.getNetworkId(), command.getFrom(), command.getNetworkName());	bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovstunnel", "create_tunnel", "bridge", bridge, "remote_ip", command.getRemoteIp(), "key", command.getKey().toString(), "from", command.getFrom().toString(), "to", command.getTo().toString(), "cloudstack-network-id", command.getNetworkUuid());	final String[] res = result.split(":");	if (res.length == 2 && res[0].equalsIgnoreCase("SUCCESS")) {	return new OvsCreateTunnelAnswer(command, true, result, res[1], bridge);	} else {	return new OvsCreateTunnelAnswer(command, false, result, bridge);	}	} catch (final Exception e) {	
caught execption when creating ovs tunnel 

========================= cloudstack sample_1185 =========================

public boolean start() {	final String mgtCidr = _configDao.getValue(Config.ManagementNetwork.key());	if (mgtCidr == null || mgtCidr.trim().isEmpty()) {	final String[] localCidrs = NetUtils.getLocalCidrs();	if (localCidrs != null && localCidrs.length > 0) {	
management network cidr is not configured originally set it default to 

public boolean start() {	final String mgtCidr = _configDao.getValue(Config.ManagementNetwork.key());	if (mgtCidr == null || mgtCidr.trim().isEmpty()) {	final String[] localCidrs = NetUtils.getLocalCidrs();	if (localCidrs != null && localCidrs.length > 0) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_MANAGMENT_NODE, 0, new Long(0), "Management network CIDR is not configured originally. Set it default to " + localCidrs[0], "");	_configDao.update(Config.ManagementNetwork.key(), Config.ManagementNetwork.getCategory(), localCidrs[0]);	} else {	
management network cidr is not properly configured and we are not able to find a default setting 

public String updateConfiguration(final long userId, final String name, final String category, final String value, final String scope, final Long resourceId) {	final String validationMsg = validateConfigurationValue(name, value, scope);	if (validationMsg != null) {	
invalid configuration option name value 

_accountDetailsDao.update(accountDetailVO.getId(), accountDetailVO);	}	break;	default: throw new InvalidParameterValueException("Scope provided is invalid");	}	return value;	}	final TransactionLegacy txn = TransactionLegacy.currentTxn();	txn.start();	if (!_configDao.update(name, category, value)) {	
failed to update configuration option name value 

String value = cmd.getValue();	final Long zoneId = cmd.getZoneId();	final Long clusterId = cmd.getClusterId();	final Long storagepoolId = cmd.getStoragepoolId();	final Long accountId = cmd.getAccountId();	CallContext.current().setEventDetails(" Name: " + name + " New Value: " + (name.toLowerCase().contains("password") ? "*****" : value == null ? "" : value));	final ConfigurationVO config = _configDao.findByName(name);	String catergory = null;	if (config == null) {	if (_configDepot.get(name) == null) {	
probably the component manager where configuration variable is defined needs to implement configurable interface 

private String validateConfigurationValue(final String name, String value, final String scope) {	final ConfigurationVO cfg = _configDao.findByName(name);	if (cfg == null) {	
missing configuration variable in configuration table 

private String validateConfigurationValue(final String name, String value, final String scope) {	final ConfigurationVO cfg = _configDao.findByName(name);	if (cfg == null) {	return "Invalid configuration variable.";	}	final String configScope = cfg.getScope();	if (scope != null) {	if (!configScope.contains(scope)) {	
invalid scope id provided for the parameter 

}	final String configScope = cfg.getScope();	if (scope != null) {	if (!configScope.contains(scope)) {	return "Invalid scope id provided for the parameter " + name;	}	}	Class<?> type = null;	final Config c = Config.getConfig(name);	if (c == null) {	
did not find configuration in config java perhaps moved to configdepot 

if (scope != null) {	if (!configScope.contains(scope)) {	return "Invalid scope id provided for the parameter " + name;	}	}	Class<?> type = null;	final Config c = Config.getConfig(name);	if (c == null) {	final ConfigKey<?> configKey = _configDepot.get(name);	if(configKey == null) {	
did not find configuration in configdepot too 

s_logger.error(msg);	throw new InvalidParameterValueException(msg);	}	} catch (final NumberFormatException e) {	final String msg = "There was an error trying to parse the float value for: " + name;	s_logger.error(msg);	throw new InvalidParameterValueException(msg);	}	if (type.equals(Boolean.class)) {	if (!(value.equals("true") || value.equals("false"))) {	
configuration variable is expecting true or false instead of 

}	if ("remote.access.vpn.psk.length".equalsIgnoreCase(name)) {	if (val < 8) {	throw new InvalidParameterValueException("Please enter a value greater than 8 for the configuration parameter:" + name);	}	if (val > 256) {	throw new InvalidParameterValueException("Please enter a value less than 256 for the configuration parameter:" + name);	}	}	} catch (final NumberFormatException e) {	
there was an error trying to parse the integer value for 

throw new InvalidParameterValueException("There was an error trying to parse the integer value for:" + name);	}	}	if (type.equals(Float.class)) {	try {	final Float val = Float.parseFloat(value);	if (weightBasedParametersForValidation.contains(name) && (val < 0f || val > 1f)) {	throw new InvalidParameterValueException("Please enter a value between 0 and 1 for the configuration parameter: " + name);	}	} catch (final NumberFormatException e) {	
there was an error trying to parse the float value for 

return null;	}	final String range = c.getRange();	if (range == null) {	return null;	}	if (type.equals(String.class)) {	if (range.equals("privateip")) {	try {	if (!NetUtils.isSiteLocalAddress(value)) {	
privateip range is not a site local address for configuration variable 

if (range == null) {	return null;	}	if (type.equals(String.class)) {	if (range.equals("privateip")) {	try {	if (!NetUtils.isSiteLocalAddress(value)) {	return "Please enter a site local IP address.";	}	} catch (final NullPointerException e) {	
error parsing ip address for 

if (range.equals("privateip")) {	try {	if (!NetUtils.isSiteLocalAddress(value)) {	return "Please enter a site local IP address.";	}	} catch (final NullPointerException e) {	throw new InvalidParameterValueException("Error parsing ip address");	}	} else if (range.equals("netmask")) {	if (!NetUtils.isValidNetmask(value)) {	
netmask is not a valid net mask for configuration variable 

}	}	}	} else {	final String[] options = range.split(",");	for (final String option : options) {	if (option.trim().equalsIgnoreCase(value)) {	return null;	}	}	
configuration value for is invalid 

final String[] options = range.split("-");	if (options.length != 2) {	final String msg = "configuration range " + range + " for " + name + " is invalid";	s_logger.error(msg);	return msg;	}	final int min = Integer.parseInt(options[0]);	final int max = Integer.parseInt(options[1]);	final int val = Integer.parseInt(value);	if (val < min || val > max) {	
configuration value for is invalid 

pod.setDescription(ipRange);	Grouping.AllocationState allocationState = null;	if (allocationStateStrFinal != null && !allocationStateStrFinal.isEmpty()) {	allocationState = Grouping.AllocationState.valueOf(allocationStateStrFinal);	pod.setAllocationState(allocationState);	}	_podDao.update(id, pod);	}	});	} catch (final Exception e) {	
unable to edit pod due to 

PhysicalNetwork mgmtPhyNetwork;	mgmtPhyNetwork = _networkModel.getDefaultPhysicalNetworkByZoneAndTrafficType(zoneId, TrafficType.Management);	if (NetworkType.Advanced == zone.getNetworkType() && !zone.isSecurityGroupEnabled()) {	_networkModel.getDefaultPhysicalNetworkByZoneAndTrafficType(zoneId, TrafficType.Public);	}	try {	_networkModel.getDefaultPhysicalNetworkByZoneAndTrafficType(zoneId, TrafficType.Storage);	} catch (final InvalidParameterValueException noStorage) {	final PhysicalNetworkTrafficTypeVO mgmtTraffic = _trafficTypeDao.findBy(mgmtPhyNetwork.getId(), TrafficType.Management);	_networkSvc.addTrafficTypeToPhysicalNetwork(mgmtPhyNetwork.getId(), TrafficType.Storage.toString(), "vlan", mgmtTraffic.getXenNetworkLabel(), mgmtTraffic.getKvmNetworkLabel(), mgmtTraffic.getVmwareNetworkLabel(), mgmtTraffic.getSimulatorNetworkLabel(), mgmtTraffic.getVlan(), mgmtTraffic.getHypervNetworkLabel(), mgmtTraffic.getOvm3NetworkLabel());	
no storage traffic type was specified by admin create default storage traffic on physical network with same configure of management traffic type 

return Transaction.execute(new TransactionCallback<Vlan>() {	public Vlan doInTransaction(final TransactionStatus status) {	String newVlanNetmask = newVlanNetmaskFinal;	String newVlanGateway = newVlanGatewayFinal;	if ((sameSubnet == null || sameSubnet.first() == false) && network.getTrafficType() == TrafficType.Guest && network.getGuestType() == GuestType.Shared && _vlanDao.listVlansByNetworkId(networkId) != null) {	final Map<Capability, String> dhcpCapabilities = _networkSvc.getNetworkOfferingServiceCapabilities(_networkOfferingDao.findById(network.getNetworkOfferingId()), Service.Dhcp);	final String supportsMultipleSubnets = dhcpCapabilities.get(Capability.DhcpAccrossMultipleSubnets);	if (supportsMultipleSubnets == null || !Boolean.valueOf(supportsMultipleSubnets)) {	throw new  InvalidParameterValueException("The Dhcp serivice provider for this network dose not support the dhcp  across multiple subnets");	}	
adding a new subnet to the network 

private VlanVO commitVlanAndIpRange(final long zoneId, final long networkId, final long physicalNetworkId, final Long podId, final String startIP, final String endIP, final String vlanGateway, final String vlanNetmask, final String vlanId, final Domain domain, final Account vlanOwner, final String vlanIp6Gateway, final String vlanIp6Cidr, final boolean ipv4, final DataCenterVO zone, final VlanType vlanType, final String ipv6Range, final String ipRange) {	return Transaction.execute(new TransactionCallback<VlanVO>() {	public VlanVO doInTransaction(final TransactionStatus status) {	VlanVO vlan = new VlanVO(vlanType, vlanId, vlanGateway, vlanNetmask, zone.getId(), ipRange, networkId, physicalNetworkId, vlanIp6Gateway, vlanIp6Cidr, ipv6Range);	
saving vlan range 

}	final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);	if (isAccountSpecific) {	int resourceCountToBeDecrement = 0;	try {	vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);	if (vlanRange == null) {	throw new CloudRuntimeException("Unable to acquire vlan configuration: " + vlanDbId);	}	if (s_logger.isDebugEnabled()) {	
lock vlan is acquired 

if (ip.isSourceNat()) {	throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip " + ip + " belonging to the range is a source nat ip for the network id=" + ip.getSourceNetworkId() + ". IP range with the source nat ip address can be removed either as a part of Network, or account removal");	}	if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {	throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip " + ip + " belonging to the range has firewall rules applied. Cleanup the rules first");	}	if (ip.getAllocatedTime() != null) {	success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);	}	if (!success) {	
some ip addresses failed to be released as a part of vlan removal 

final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);	boolean success = true;	final List<IPAddressVO> ipsInUse = new ArrayList<IPAddressVO>();	if (allocIpCount > 0) {	try {	vlan = _vlanDao.acquireInLockTable(vlanDbId, 30);	if (vlan == null) {	throw new CloudRuntimeException("Unable to acquire vlan configuration: " + vlanDbId);	}	if (s_logger.isDebugEnabled()) {	
lock vlan is acquired 

try {	vlan = _vlanDao.acquireInLockTable(vlanDbId, 30);	if (vlan == null) {	throw new CloudRuntimeException("Unable to acquire vlan configuration: " + vlanDbId);	}	if (s_logger.isDebugEnabled()) {	}	for (final IPAddressVO ip : ips) {	if (!ip.isOneToOneNat() && !ip.isSourceNat() && !(_firewallDao.countRulesByIpId(ip.getId()) > 0)) {	if (s_logger.isDebugEnabled()) {	
releasing public ip addresses of vlan as part of public ip range release to the system pool 

for (final IPAddressVO ip : ips) {	if (!ip.isOneToOneNat() && !ip.isSourceNat() && !(_firewallDao.countRulesByIpId(ip.getId()) > 0)) {	if (s_logger.isDebugEnabled()) {	}	success = success && _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);	} else {	ipsInUse.add(ip);	}	}	if (!success) {	
some public ip addresses that were not in use failed to be released as a part of vlan release to the system pool 

}	if (isAccountSpecific && _accountVlanMapDao.remove(acctVln.get(0).getId())) {	for (final IPAddressVO ip : ips) {	if (!ipsInUse.contains(ip)) {	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(), ip.getAddress().toString(), ip.isSourceNat(), vlan.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());	}	}	_resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(ips.size()));	return true;	} else if (isDomainSpecific && _domainVlanMapDao.remove(domainVln.get(0).getId())) {	
remove the vlan from domain vlan map successfully 

public void checkDiskOfferingAccess(final Account caller, final DiskOffering dof) {	for (final SecurityChecker checker : _secChecker) {	if (checker.checkAccess(caller, dof)) {	if (s_logger.isDebugEnabled()) {	
access granted to to disk offering by 

public void checkZoneAccess(final Account caller, final DataCenter zone) {	for (final SecurityChecker checker : _secChecker) {	if (checker.checkAccess(caller, zone)) {	if (s_logger.isDebugEnabled()) {	
access granted to to zone by 

serviceSet.add(service);	providerCombinationToVerify.put(provider, serviceSet);	}	serviceProviderMap.put(service, providers);	} else {	throw new InvalidParameterValueException("Service " + serviceStr + " is not enabled for the network " + "offering, can't add a provider to it");	}	}	}	if (dhcpProvider == null && IsVrUserdataProvider) {	
user data provider vr can t be selected without vr as dhcp provider in this case vm fails to contact the dhcp server for userdata 

if (!serviceProviderMap.containsKey(Service.Connectivity) && connectivityServiceCapabilityMap != null && !connectivityServiceCapabilityMap.isEmpty())  {	throw new InvalidParameterValueException("Capabilities for 'Connectivity' service can be specified " + "only when Connectivity service is enabled for network offering.");	}	validateConnectivityServiceCapablities(serviceProviderMap.get(Service.Connectivity), connectivityServiceCapabilityMap);	final Map<Service, Map<Capability, String>> serviceCapabilityMap = new HashMap<Service, Map<Capability, String>>();	serviceCapabilityMap.put(Service.Lb, lbServiceCapabilityMap);	serviceCapabilityMap.put(Service.SourceNat, sourceNatServiceCapabilityMap);	serviceCapabilityMap.put(Service.StaticNat, staticNatServiceCapabilityMap);	serviceCapabilityMap.put(Service.Connectivity, connectivityServiceCapabilityMap);	if (firewallProvider != null) {	
adding firewall service with provider 

final NetworkOfferingVO offeringFinal = new NetworkOfferingVO(name, displayText, trafficType, systemOnly, specifyVlan, networkRate, multicastRate, isDefault, availability, tags, type, conserveMode, dedicatedLb, sharedSourceNat, redundantRouter, elasticIp, elasticLb, specifyIpRanges, inline, isPersistent, associatePublicIp, publicLb, internalLb, egressDefaultPolicy, strechedL2Subnet);	if (serviceOfferingId != null) {	offeringFinal.setServiceOfferingId(serviceOfferingId);	}	if (details != null) {	validateNtwkOffDetails(details, serviceProviderMap);	}	return Transaction.execute(new TransactionCallback<NetworkOfferingVO>() {	public NetworkOfferingVO doInTransaction(final TransactionStatus status) {	NetworkOfferingVO offering = offeringFinal;	
adding network offering 

for (final Network.Service service : serviceProviderMap.keySet()) {	final Set<Provider> providers = serviceProviderMap.get(service);	if (providers != null && !providers.isEmpty()) {	boolean vpcOff = false;	for (final Network.Provider provider : providers) {	if (provider == Provider.VPCVirtualRouter) {	vpcOff = true;	}	final NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(offering.getId(), service, provider);	_ntwkOffServiceMapDao.persist(offService);	
added service for the network offering with provider 

_ntwkOffServiceMapDao.persist(offService);	}	if (vpcOff) {	final List<Service> supportedSvcs = new ArrayList<Service>();	supportedSvcs.addAll(serviceProviderMap.keySet());	_vpcMgr.validateNtwkOffForVpc(offering, supportedSvcs);	}	} else {	final NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(offering.getId(), service, null);	_ntwkOffServiceMapDao.persist(offService);	
added service for the network offering with null provider 

public AccountVO markDefaultZone(final String accountName, final long domainId, final long defaultZoneId) {	final Account account = _accountDao.findEnabledAccount(accountName, domainId);	if (account == null) {	
unable to find account by name in domain 

========================= cloudstack sample_2253 =========================

ApiConnector api = controller.getApiAccessor();	for (ModelObject successor : successors()) {	successor.delete(controller);	}	if (_policyModel != null) {	_policyModel.removeSuccessor(this);	}	try {	api.delete(VirtualNetwork.class, _uuid);	} catch (IOException ex) {	
virtual network delete 

public void setProperties(ModelController controller, Network network) {	ContrailManager manager = controller.getManager();	_name = manager.getCanonicalName(network);	_prefix = network.getCidr();	_gateway = network.getGateway();	if (!isDynamicNetwork()) {	try {	_uuid = manager.findVirtualNetworkId(network);	} catch (IOException ex) {	
unable to read virtual network 

if (!isDynamicNetwork()) {	try {	_uuid = manager.findVirtualNetworkId(network);	} catch (IOException ex) {	}	}	_id = network.getId();	try {	_projectId = manager.getProjectId(network.getDomainId(), network.getAccountId());	} catch (IOException ex) {	
project read 

assert _uuid != null : "uuid is not set";	if (_vn == null) {	vn = _vn = (VirtualNetwork)controller.getApiAccessor().findById(VirtualNetwork.class, _uuid);	if (vn == null) {	vn = new VirtualNetwork();	if (_projectId != null) {	Project project;	try {	project = (Project)api.findById(Project.class, _projectId);	} catch (IOException ex) {	
project read 

vn.clearNetworkPolicy();	_policyModel.removeSuccessor(this);	} else {	vn.setNetworkPolicy(_policyModel.getPolicy(), new VirtualNetworkPolicyType( new VirtualNetworkPolicyType.SequenceType(1, 0), null));	}	if (_ipam == null) {	NetworkIpam ipam = null;	try {	String ipam_id = api.findByName(NetworkIpam.class, null, "default-network-ipam");	if (ipam_id == null) {	
could not find default network ipam 

}	if (_ipam == null) {	NetworkIpam ipam = null;	try {	String ipam_id = api.findByName(NetworkIpam.class, null, "default-network-ipam");	if (ipam_id == null) {	return;	}	ipam = (NetworkIpam)api.findById(NetworkIpam.class, ipam_id);	if (ipam == null) {	
could not find networkipam with ipam id 

int plen = Integer.parseInt(cidr.substring(slash + 1));	VnSubnetsType subnet = new VnSubnetsType();	subnet.addIpamSubnets(new SubnetType(ip_addr, plen), vlan.getVlanGateway());	vn.addNetworkIpam(_ipam, subnet);	}	}	if (_vn == null) {	try {	api.create(vn);	} catch (Exception ex) {	
virtual network create 

try {	api.create(vn);	} catch (Exception ex) {	throw new CloudRuntimeException("Failed to create virtual-network", ex);	}	_vn = vn;	} else {	try {	api.update(vn);	} catch (IOException ex) {	
virtual network update 

e.printStackTrace();	}	if (_vn == null) {	return;	}	if (_ipam == null) {	NetworkIpam ipam = null;	try {	String ipam_id = api.findByName(NetworkIpam.class, null, "default-network-ipam");	if (ipam_id == null) {	
could not find default network ipam 

}	if (_ipam == null) {	NetworkIpam ipam = null;	try {	String ipam_id = api.findByName(NetworkIpam.class, null, "default-network-ipam");	if (ipam_id == null) {	return;	}	ipam = (NetworkIpam)api.findById(NetworkIpam.class, ipam_id);	if (ipam == null) {	
could not find networkipam with ipam id 

if (subnets != null && !subnets.isEmpty()) {	VnSubnetsType.IpamSubnetType ipamSubnet = subnets.get(0);	vncSubnets.add(ipamSubnet.getDefaultGateway() + ipamSubnet.getSubnet().getIpPrefix() + "/" + ipamSubnet.getSubnet().getIpPrefixLen());	}	}	}	}	Set<String> diff = new HashSet<String>(dbSubnets);	diff.removeAll(vncSubnets);	if (!diff.isEmpty()) {	
subnets changed network db vnc diff 

public boolean compare(ModelController controller, ModelObject o) {	VirtualNetworkModel latest;	assert _vn != null : "vnc virtual network current is not initialized";	try {	latest = (VirtualNetworkModel)o;	} catch (ClassCastException ex) {	
invalid model object is passed to cast to virtualnetworkmodel 

List<VnSubnetsType.IpamSubnetType> subnets = vnSubnetType.getIpamSubnets();	if (subnets != null && !subnets.isEmpty()) {	VnSubnetsType.IpamSubnetType ipamSubnet = subnets.get(0);	newSubnets.add(ipamSubnet.getDefaultGateway() + ipamSubnet.getSubnet().getIpPrefix() + "/" + ipamSubnet.getSubnet().getIpPrefixLen());	}	}	}	Set<String> diff = new HashSet<String>(currentSubnets);	diff.removeAll(newSubnets);	if (!diff.isEmpty()) {	
subnets differ network db vnc diff 

========================= cloudstack sample_1886 =========================

public IpAddr getPrivateIpAddress(String macAddr, long dcId, long podId) {	if (_externalIpAllocatorUrl == null || _externalIpAllocatorUrl.equalsIgnoreCase("")) {	return new IpAddr();	}	String urlString = _externalIpAllocatorUrl + "?command=getIpAddr&mac=" + macAddr + "&dc=" + dcId + "&pod=" + podId;	
getip 

try {	URL url = new URL(urlString);	URLConnection conn = url.openConnection();	conn.setReadTimeout(30000);	in = new BufferedReader(new InputStreamReader(conn.getInputStream()));	String inputLine;	while ((inputLine = in.readLine()) != null) {	s_logger.debug(inputLine);	String[] tokens = inputLine.split(",");	if (tokens.length != 3) {	
the return value should be mac netmask gateway 

public boolean releasePrivateIpAddress(String ip, long dcId, long podId) {	if (_externalIpAllocatorUrl == null || _externalIpAllocatorUrl.equalsIgnoreCase("")) {	return false;	}	String urlString = _externalIpAllocatorUrl + "?command=releaseIpAddr&ip=" + ip + "&dc=" + dcId + "&pod=" + podId;	
releaseip 

========================= cloudstack sample_2316 =========================

public void shutdown() {	try {	handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	
ignored error sending input close event 

public void shutdown() {	try {	handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	}	try {	handleEvent(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	
ignored error sending output close event 

handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	}	try {	handleEvent(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	}	try {	if (sslSocket != null) sslSocket.close();	} catch (Exception e) {	
ignored error closing ssl socket 

handleEvent(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	}	try {	if (sslSocket != null) sslSocket.close();	} catch (Exception e) {	}	try {	socket.close();	} catch (Exception e) {	
ignored error closing socket 

========================= cloudstack sample_5083 =========================

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (s_logger.isDebugEnabled()) {	
entering nuageelement implement function for network state 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (s_logger.isDebugEnabled()) {	}	if (network.getVpcId() != null) {	return applyACLRulesForVpc(network, offering);	}	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	
nic has no broadcast uri with the virtual router ip 

List<VspAclRule> egressFirewallRules = getFirewallRulesToApply(network, FirewallRule.TrafficType.Egress);	List<IPAddressVO> ips = _ipAddressDao.listStaticNatPublicIps(network.getId());	List<String> floatingIpUuids = new ArrayList<String>();	for (IPAddressVO ip : ips) {	floatingIpUuids.add(ip.getUuid());	}	HostVO nuageVspHost = getNuageVspHost(network.getPhysicalNetworkId());	ImplementVspCommand cmd = new ImplementVspCommand(vspNetwork, dnsServers, ingressFirewallRules, egressFirewallRules, floatingIpUuids);	Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
implementvspcommand for network failed on nuage vsd hostname 

public boolean prepare(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	
nic has no broadcast uri with the virtual router ip 

public boolean release(Network network, NicProfile nic, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	
nic has no broadcast uri with the virtual router ip 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	
unable to support services combination without connectivity service provided by nuage vsp 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	return false;	}	if ((services.contains(Service.StaticNat)) && (!services.contains(Service.SourceNat))) {	
unable to provide staticnat without the sourcenat service 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	return false;	}	if ((services.contains(Service.StaticNat)) && (!services.contains(Service.SourceNat))) {	return false;	}	if (services.contains(Service.Vpn) || services.contains(Service.Dns) || services.contains(Service.Lb) || services.contains(Service.PortForwarding) || services.contains(Service.SecurityGroup)) {	
unable to support services combination the services list contains service s not supported by nuage vsp 

protected boolean canHandle(Network network, Service service) {	if (network.getBroadcastDomainType() != Networks.BroadcastDomainType.Vsp) {	return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	if (s_logger.isDebugEnabled()) {	
nuagevsp is not a provider for network 

return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	if (service != null) {	if (!_ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {	if (s_logger.isDebugEnabled()) {	
nuagevsp can t provide the service on network 

if (!_ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	}	if (network.getVpcId() != null) {	NetworkOffering networkOffering = _ntwkOfferingDao.findById(network.getNetworkOfferingId());	if (!networkOffering.getIsPersistent()) {	if (s_logger.isDebugEnabled()) {	
nuagevsp can t handle vpc tiers which use a network offering which are not persistent 

VlanVO sourceNatVlan = _vlanDao.findById(sourceNatIp.getVlanId());	NicVO nicVO = _nicDao.findByIp4AddressAndNetworkId(staticNat.getDestIpAddress(), staticNat.getNetworkId());	VspStaticNat vspStaticNat = _nuageVspEntityBuilder.buildVspStaticNat(staticNat.isForRevoke(), sourceNatIp, sourceNatVlan, nicVO);	vspStaticNatDetails.add(vspStaticNat);	}	VspNetwork vspNetwork = _nuageVspEntityBuilder.buildVspNetwork(config, false);	HostVO nuageVspHost = getNuageVspHost(config.getPhysicalNetworkId());	ApplyStaticNatVspCommand cmd = new ApplyStaticNatVspCommand(vspNetwork, vspStaticNatDetails);	Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
applystaticnatnuagevspcommand for network failed on nuage vsd hostname 

public boolean applyFWRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	if (rules.size() == 1 && rules.iterator().next().getType().equals(FirewallRuleType.System)) {	if (s_logger.isDebugEnabled()) {	
default acl added by cs as system is ignored for network with rule 

public boolean applyFWRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	if (rules.size() == 1 && rules.iterator().next().getType().equals(FirewallRuleType.System)) {	if (s_logger.isDebugEnabled()) {	}	return true;	}	
applying firewall rules for network 

return _nuageVspEntityBuilder.buildVspAclRule((FirewallRule) input, network);	}	return _nuageVspEntityBuilder.buildVspAclRule((NetworkACLItem) input);	}	});	HostVO nuageVspHost = getNuageVspHost(network.getPhysicalNetworkId());	VspAclRule.ACLType vspAclType = isNetworkAcl ? VspAclRule.ACLType.NetworkACL : VspAclRule.ACLType.Firewall;	ApplyAclRuleVspCommand cmd = new ApplyAclRuleVspCommand(vspAclType, vspNetwork, vspAclRules, networkReset);	Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
applyaclrulenuagevspcommand for network failed on nuage vsd hostname 

public boolean applyNetworkACLs(Network config, List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	if (s_logger.isDebugEnabled()) {	
no rules to apply so delete all the existing acl in vsp from subnet with uuid 

public boolean applyNetworkACLs(Network config, List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	
new rules has to applied so delete all the existing acl in vsp from subnet with uuid 

public boolean applyNetworkACLs(Network config, List<? extends NetworkACLItem> rules) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (s_logger.isDebugEnabled()) {	}	}	if (rules != null) {	
applying network acls for network 

public boolean implementVpc(Vpc vpc, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	List<VpcOfferingServiceMapVO> vpcOfferingServices = _vpcOfferingSrvcDao.listByVpcOffId(vpc.getVpcOfferingId());	Map<Network.Service, Set<Network.Provider>> supportedVpcServices = NuageVspManagerImpl.NUAGE_VSP_VPC_SERVICE_MAP;	for (VpcOfferingServiceMapVO vpcOfferingService : vpcOfferingServices) {	Network.Service service = Network.Service.getService(vpcOfferingService.getService());	if (!supportedVpcServices.containsKey(service)) {	
nuagevsp doesn t support service s for vpcs 

public boolean implementVpc(Vpc vpc, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	List<VpcOfferingServiceMapVO> vpcOfferingServices = _vpcOfferingSrvcDao.listByVpcOffId(vpc.getVpcOfferingId());	Map<Network.Service, Set<Network.Provider>> supportedVpcServices = NuageVspManagerImpl.NUAGE_VSP_VPC_SERVICE_MAP;	for (VpcOfferingServiceMapVO vpcOfferingService : vpcOfferingServices) {	Network.Service service = Network.Service.getService(vpcOfferingService.getService());	if (!supportedVpcServices.containsKey(service)) {	return false;	}	Network.Provider provider = Network.Provider.getProvider(vpcOfferingService.getProvider());	if (!supportedVpcServices.get(service).contains(provider)) {	
nuagevsp doesn t support provider s for service s for vpcs 

String preConfiguredDomainTemplateName;	VpcDetailVO domainTemplateNameDetail = _vpcDetailsDao.findDetail(vpc.getId(), NuageVspManager.nuageDomainTemplateDetailName);	if (domainTemplateNameDetail != null) {	preConfiguredDomainTemplateName = domainTemplateNameDetail.getValue();	} else {	preConfiguredDomainTemplateName = _configDao.getValue(NuageVspManager.NuageVspVpcDomainTemplateName.key());	}	ShutDownVpcVspCommand cmd = new ShutDownVpcVspCommand(vpcDomain.getUuid(), vpc.getUuid(), preConfiguredDomainTemplateName, domainRouterUuids);	Answer answer =  _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
shutdownvpcvspcommand for vpc failed on nuage vsd hostname 

========================= cloudstack sample_1490 =========================

public void execute() {	try {	boolean result = _networkService.deleteNetworkServiceProvider(getId());	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to delete network service provider");	}	} catch (ResourceUnavailableException ex) {	
exception 

boolean result = _networkService.deleteNetworkServiceProvider(getId());	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to delete network service provider");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3157 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	UcsManagerResponse rsp = mgr.addUcsManager(this);	rsp.setObjectName("ucsmanager");	rsp.setResponseName(getCommandName());	this.setResponseObject(rsp);	} catch (Exception e) {	
exception 

========================= cloudstack sample_1243 =========================

public Answer retry(final Command command, final Class<? extends Answer> answerClass, final Exception error) {	if (commandsToRetry.containsKey(command)) {	Integer numRetries = commandsToRetry.get(command);	if (numRetries > ZERO) {	commandsToRetry.put(command, --numRetries);	
retrying number of retries remaining 

========================= cloudstack sample_1756 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all securitygroup usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageSecurityGroupVO> usageSGs = s_usageSecurityGroupDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate, false, 0);	if (usageSGs.isEmpty()) {	
no securitygroup usage events for this period 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long vmId, long sgId, long zoneId) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long vmId, long sgId, long zoneId) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating security group usage record for vm usage startdate enddate for account 

========================= cloudstack sample_2654 =========================

found = true;	}	} else {	TemplateDataStoreVO templateStoreVO = templateStoreDao.findByStoreTemplate(store.getId(), templateId);	if (templateStoreVO != null) {	found = true;	}	}	if (s_logger.isDebugEnabled()) {	if (!found) {	
template is not in store type 

}	} else {	TemplateDataStoreVO templateStoreVO = templateStoreDao.findByStoreTemplate(store.getId(), templateId);	if (templateStoreVO != null) {	found = true;	}	}	if (s_logger.isDebugEnabled()) {	if (!found) {	} else {	
template is already in store type 

========================= cloudstack sample_3946 =========================

public Answer execute(final OvsDestroyBridgeCommand command, final LibvirtComputingResource libvirtComputingResource) {	final boolean result = libvirtComputingResource.destroyTunnelNetwork(command.getBridgeName());	if (!result) {	
error trying to destroy ovs bridge 

========================= cloudstack sample_1078 =========================

public void execute() throws ServerApiException {	validateRequest();	try {	GetUploadParamsResponse response = _templateService.registerTemplateForPostUpload(this);	response.setResponseName(getCommandName());	setResponseObject(response);	} catch (ResourceAllocationException | MalformedURLException e) {	
exception while registering template 

========================= cloudstack sample_3415 =========================

public boolean start() {	try {	check();	} catch (Exception e) {	
system integrity check exception 

========================= cloudstack sample_2711 =========================

lbDevice.setAllocationState(dedicatedLB ? LBDeviceAllocationState.Dedicated : LBDeviceAllocationState.Shared);	_externalLoadBalancerDeviceDao.update(lbDeviceId, lbDevice);	return lbDevice;	}	});	tryLbProvisioning = false;	retry = false;	} catch (InsufficientCapacityException exception) {	if (tryLbProvisioning) {	retry = false;	
there are no load balancer device with the capacity for implementing this network 

}	Pod pod = _podDao.findById(dcPrivateIp.getPodId());	String lbIP = dcPrivateIp.getIpAddress();	String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());	String gateway = pod.getGateway();	CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);	CreateLoadBalancerApplianceAnswer createLbAnswer = null;	try {	createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);	if (createLbAnswer == null || !createLbAnswer.getResult()) {	
could not provision load balancer instance on the load balancer device 

String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());	String gateway = pod.getGateway();	CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);	CreateLoadBalancerApplianceAnswer createLbAnswer = null;	try {	createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);	if (createLbAnswer == null || !createLbAnswer.getResult()) {	continue;	}	} catch (Exception agentException) {	
could not provision load balancer instance on the load balancer device due to 

String dedicatedLb = offering.getDedicatedLB() ? "true" : "false";	String capacity = Long.toString(lbProviderDevice.getCapacity());	PublicIp publicIp = _ipAddrMgr.assignPublicIpAddress(guestConfig.getDataCenterId(), null, _accountMgr.getSystemAccount(), VlanType.VirtualNetwork, null, null, false);	String publicIPNetmask = publicIp.getVlanNetmask();	String publicIPgateway = publicIp.getVlanGateway();	String publicIP = publicIp.getAddress().toString();	String publicIPVlanTag="";	try {	publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());	} catch (URISyntaxException e) {	
failed to parse public ip vlan tag 

String publicIPVlanTag="";	try {	publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());	} catch (URISyntaxException e) {	}	String url = "https: "&cloudmanaged=true" + "&publicip=" + publicIP + "&publicipnetmask=" + publicIPNetmask + "&lbdevicecapacity=" + capacity + "&publicipvlan=" + publicIPVlanTag + "&publicipgateway=" + publicIPgateway;	ExternalLoadBalancerDeviceVO lbAppliance = null;	try {	lbAppliance = addExternalLoadBalancer(physicalNetworkId, url, username, password, createLbAnswer.getDeviceName(), createLbAnswer.getServerResource(), false, false, null, null);	} catch (Exception e) {	
failed to add load balancer appliance in to cloudstack due to so provisioned load balancer appliance will be destroyed 

ExternalLoadBalancerDeviceVO managedLb = _externalLoadBalancerDeviceDao.findById(lbAppliance.getId());	managedLb.setIsManagedDevice(true);	managedLb.setParentHostId(lbProviderDevice.getHostId());	_externalLoadBalancerDeviceDao.update(lbAppliance.getId(), managedLb);	} else {	DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);	DestroyLoadBalancerApplianceAnswer answer = null;	try {	answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);	if (answer == null || !answer.getResult()) {	
failed to destroy load balancer appliance created 

DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);	DestroyLoadBalancerApplianceAnswer answer = null;	try {	answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);	if (answer == null || !answer.getResult()) {	} else {	_dcDao.releasePrivateIpAddress(lbIP, guestConfig.getDataCenterId(), null);	_ipAddrMgr.disassociatePublicIpAddress(publicIp.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());	}	} catch (Exception e) {	
failed to destroy load balancer appliance created for the network due to 

Host lbHost = _hostDao.findById(lbDevice.getHostId());	String lbIP = lbHost.getPrivateIpAddress();	DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);	DestroyLoadBalancerApplianceAnswer answer = null;	try {	answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);	if (answer == null || !answer.getResult()) {	s_logger.warn("Failed to destoy load balancer appliance used by the network" + guestConfig.getId() + " due to " + answer == null ? "communication error with agent" : answer.getDetails());	}	} catch (Exception e) {	
failed to destroy load balancer appliance used by the network due to 

DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);	DestroyLoadBalancerApplianceAnswer answer = null;	try {	answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);	if (answer == null || !answer.getResult()) {	s_logger.warn("Failed to destoy load balancer appliance used by the network" + guestConfig.getId() + " due to " + answer == null ? "communication error with agent" : answer.getDetails());	}	} catch (Exception e) {	}	if (s_logger.isDebugEnabled()) {	
successfully destroyed load balancer appliance used for the network 

deleteExternalLoadBalancer(lbHost.getId());	_dcDao.releasePrivateIpAddress(lbHost.getPrivateIpAddress(), guestConfig.getDataCenterId(), null);	DetailVO publicIpDetail = _hostDetailDao.findDetail(lbHost.getId(), "publicip");	IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());	_ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());	} else {	deviceMapLock.unlock();	}	return true;	} else {	
failed to release load balancer device for the network as failed to acquire lock 

IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());	_ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());	} else {	deviceMapLock.unlock();	}	return true;	} else {	return false;	}	} catch (Exception exception) {	
failed to release load balancer device for the network due to 

}	mapping = new InlineLoadBalancerNicMapVO(srcIp, loadBalancingIpNic.getId());	_inlineLoadBalancerNicMapDao.persist(mapping);	try {	applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());	} catch (ResourceUnavailableException ex) {	_inlineLoadBalancerNicMapDao.expunge(mapping.getId());	_nicDao.expunge(loadBalancingIpNic.getId());	throw ex;	}	
created static nat rule for inline load balancer 

loadBalancingIpNic = _nicDao.findById(mapping.getNicId());	}	} else {	if (mapping != null) {	loadBalancingIpNic = _nicDao.findById(mapping.getNicId());	int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);	if (count == 0) {	applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());	_inlineLoadBalancerNicMapDao.expunge(mapping.getId());	_nicDao.expunge(loadBalancingIpNic.getId());	
revoked static nat rule for inline load balancer 

if (mapping != null) {	loadBalancingIpNic = _nicDao.findById(mapping.getNicId());	int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);	if (count == 0) {	applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());	_inlineLoadBalancerNicMapDao.expunge(mapping.getId());	_nicDao.expunge(loadBalancingIpNic.getId());	nic.setState(MappingState.Remove);	}	} else {	
revoking a rule for an inline load balancer that has not been programmed yet 

public boolean applyLoadBalancerRules(Network network, List<LoadBalancingRule> loadBalancingRules) throws ResourceUnavailableException {	long zoneId = network.getDataCenterId();	DataCenterVO zone = _dcDao.findById(zoneId);	if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {	return true;	}	ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);	if (lbDeviceVO == null) {	
there is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning 

if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {	return true;	}	ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);	if (lbDeviceVO == null) {	return true;	}	HostVO externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());	boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);	if (network.getState() == Network.State.Allocated) {	
external load balancer was asked to apply lb rules for network with id this network is not implemented skipping backend commands 

Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);	if (answer == null || !answer.getResult()) {	String details = (answer != null) ? answer.getDetails() : "details unavailable";	String msg = "Unable to apply load balancer rules to the external load balancer appliance in zone " + zone.getName() + " due to: " + details + ".";	s_logger.error(msg);	throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());	}	}	} catch (Exception ex) {	if (externalLoadBalancerIsInline) {	
rollbacking static nat operation of inline mode load balancing due to error on applying lb rules 

public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException {	if (guestConfig.getTrafficType() != TrafficType.Guest) {	
external load balancer can only be used for guest networks 

lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);	if (lbDeviceVO == null) {	lbDeviceVO = allocateLoadBalancerForNetwork(guestConfig);	if (lbDeviceVO == null) {	String msg = "failed to alloacate a external load balancer for the network " + guestConfig.getId();	s_logger.error(msg);	throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());	}	}	externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());	
allocated external load balancer device for the network 

if (lbDeviceVO == null) {	String msg = "failed to alloacate a external load balancer for the network " + guestConfig.getId();	s_logger.error(msg);	throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());	}	}	externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());	} else {	ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);	if (lbDeviceVO == null) {	
network shutdwon requested on external load balancer element which did not implement the network either network implement failed half way through or already network shutdown is completed so just returning 

}	selfIp = _ipAddrMgr.acquireGuestIpAddress(guestConfig, null);	if (selfIp == null) {	String msg = "failed to acquire guest IP address so not implementing the network on the external load balancer ";	s_logger.error(msg);	throw new InsufficientNetworkCapacityException(msg, Network.class, guestConfig.getId());	}	} else {	Nic selfipNic = getPlaceholderNic(guestConfig);	if (selfipNic == null) {	
network shutdwon requested on external load balancer element which did not implement the network either network implement failed half way through or already network shutdown is completed so just returning 

protected IpDeployer getIpDeployerForInlineMode(Network network) {	List<Provider> providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);	if (providers == null) {	
cannot find firewall provider for network 

protected IpDeployer getIpDeployerForInlineMode(Network network) {	List<Provider> providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);	if (providers == null) {	return null;	}	if (providers.size() != 1) {	
found firewall provider for network 

protected IpDeployer getIpDeployerForInlineMode(Network network) {	List<Provider> providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);	if (providers == null) {	return null;	}	if (providers.size() != 1) {	return null;	}	NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());	if (!(element instanceof IpDeployer)) {	
the firewall provider for network don t have ability to deploy ip address 

if (providers == null) {	return null;	}	if (providers.size() != 1) {	return null;	}	NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());	if (!(element instanceof IpDeployer)) {	return null;	}	
let handle ip association for in network 

public List<LoadBalancerTO> getLBHealthChecks(Network network, List<LoadBalancingRule> loadBalancingRules) throws ResourceUnavailableException {	long zoneId = network.getDataCenterId();	DataCenterVO zone = _dcDao.findById(zoneId);	if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {	return null;	}	ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);	if (lbDeviceVO == null) {	
there is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning 

if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {	return null;	}	ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);	if (lbDeviceVO == null) {	return null;	}	HostVO externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());	boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);	if (network.getState() == Network.State.Allocated) {	
external load balancer was asked to apply lb rules for network with id this network is not implemented skipping backend commands 

if (loadBalancersToApply.size() > 0) {	int numLoadBalancersForCommand = loadBalancersToApply.size();	LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);	HealthCheckLBConfigCommand cmd = new HealthCheckLBConfigCommand(loadBalancersForCommand);	long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));	cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));	HealthCheckLBConfigAnswer answer = (HealthCheckLBConfigAnswer) _agentMgr .easySend(externalLoadBalancer.getId(), cmd);	return answer == null ? null : answer.getLoadBalancers();	}	} catch (Exception ex) {	
exception occured 

========================= cloudstack sample_2341 =========================

public Answer sendMessage(Command cmd) {	String errMsg = null;	try {	long newHostId = _hvGuruMgr.getGuruProcessedCommandTargetHost(hostId, cmd);	if (newHostId != hostId) {	setId(newHostId);	}	return agentMgr.send(newHostId, cmd);	} catch (AgentUnavailableException e) {	errMsg = e.toString();	
failed to send command due to agent 

try {	long newHostId = _hvGuruMgr.getGuruProcessedCommandTargetHost(hostId, cmd);	if (newHostId != hostId) {	setId(newHostId);	}	return agentMgr.send(newHostId, cmd);	} catch (AgentUnavailableException e) {	errMsg = e.toString();	} catch (OperationTimedoutException e) {	errMsg = e.toString();	
failed to send command due to agent 

public void sendMessageAsync(Command cmd, AsyncCompletionCallback<Answer> callback) {	try {	long newHostId = _hvGuruMgr.getGuruProcessedCommandTargetHost(hostId, cmd);	if (newHostId != hostId) {	setId(newHostId);	}	if (s_logger.isDebugEnabled()) {	
sending command to host 

========================= cloudstack sample_4016 =========================

SyncQueueItemVO item = new SyncQueueItemVO();	item.setQueueId(queueVO.getId());	item.setContentType(itemType);	item.setContentId(itemId);	item.setCreated(dt);	_syncQueueItemDao.persist(item);	return queueVO;	}	});	} catch (Exception e) {	
unexpected exception 

public SyncQueueItemVO dequeueFromOne(final long queueId, final Long msid) {	try {	return Transaction.execute(new TransactionCallback<SyncQueueItemVO>() {	public SyncQueueItemVO doInTransaction(TransactionStatus status) {	SyncQueueVO queueVO = _syncQueueDao.findById(queueId);	if(queueVO == null) {	
sync queue id does not exist 

queueVO.setLastProcessNumber(processNumber);	queueVO.setLastUpdated(dt);	queueVO.setQueueSize(queueVO.getQueueSize() + 1);	_syncQueueDao.update(queueVO.getId(), queueVO);	itemVO.setLastProcessMsid(msid);	itemVO.setLastProcessNumber(processNumber);	itemVO.setLastProcessTime(dt);	_syncQueueItemDao.update(itemVO.getId(), itemVO);	return itemVO;	} else {	
sync queue is currently empty 

queueVO.setQueueSize(queueVO.getQueueSize() + 1);	_syncQueueDao.update(queueVO.getId(), queueVO);	itemVO.setLastProcessMsid(msid);	itemVO.setLastProcessNumber(processNumber);	itemVO.setLastProcessTime(dt);	_syncQueueItemDao.update(itemVO.getId(), itemVO);	return itemVO;	} else {	}	} else {	
there is a pending process in sync queue id 

_syncQueueItemDao.update(itemVO.getId(), itemVO);	return itemVO;	} else {	}	} else {	}	return null;	}	});	} catch (Exception e) {	
unexpected exception 

itemVO.setLastProcessTime(dt);	_syncQueueItemDao.update(item.getId(), itemVO);	resultList.add(itemVO);	}	}	}	}	});	return resultList;	} catch (Exception e) {	
unexpected exception 

if (itemVO.getLastProcessMsid() != null) {	queueVO.setLastUpdated(DateUtil.currentGMTTime());	assert (queueVO.getQueueSize() > 0) : "Count reduce happens when it's already <= 0!";	queueVO.setQueueSize(queueVO.getQueueSize() - 1);	_syncQueueDao.update(queueVO.getId(), queueVO);	}	}	}	});	} catch (Exception e) {	
unexpected exception 

public void returnItem(final long queueItemId) {	
returning queue item back to queue for second try in case of db deadlock 

itemVO.setLastProcessNumber(null);	itemVO.setLastProcessTime(null);	_syncQueueItemDao.update(queueItemId, itemVO);	queueVO.setQueueSize(queueVO.getQueueSize() - 1);	queueVO.setLastUpdated(DateUtil.currentGMTTime());	_syncQueueDao.update(queueVO.getId(), queueVO);	}	}	});	} catch (Exception e) {	
unexpected exception 

private boolean queueReadyToProcess(SyncQueueVO queueVO) {	int nActiveItems = _syncQueueItemDao.getActiveQueueItemCount(queueVO.getId());	if (nActiveItems < queueVO.getQueueSizeLimit()) return true;	
queue queue id sync type sync id is reaching concurrency limit 

public void cleanupActiveQueueItems(Long msid, boolean exclusive) {	List<SyncQueueItemVO> l = getActiveQueueItems(msid, false);	for (SyncQueueItemVO item : l) {	if (s_logger.isInfoEnabled()) {	
discard left over queue item 

========================= cloudstack sample_689 =========================

for (Map.Entry<Host, Host.Record> entry : hosts.entrySet()) {	Host.Record re = entry.getValue();	if (!re.address.equalsIgnoreCase(hostIp)){	continue;	}	Set<HostPatch> patches = re.patches;	PoolPatch poolPatch = PoolPatch.getByUuid(conn, hotFixUuid);	for(HostPatch patch : patches) {	PoolPatch pp = patch.getPoolPatch(conn);	if (pp != null && pp.equals(poolPatch) && patch.getApplied(conn)) {	
host does have hotfix 

PoolPatch poolPatch = PoolPatch.getByUuid(conn, hotFixUuid);	for(HostPatch patch : patches) {	PoolPatch pp = patch.getPoolPatch(conn);	if (pp != null && pp.equals(poolPatch) && patch.getApplied(conn)) {	return true;	}	}	}	return false;	} catch (UuidInvalid e) {	
host doesn t have hotfix 

for(HostPatch patch : patches) {	PoolPatch pp = patch.getPoolPatch(conn);	if (pp != null && pp.equals(poolPatch) && patch.getApplied(conn)) {	return true;	}	}	}	return false;	} catch (UuidInvalid e) {	} catch (Exception e) {	
can t get patches information consider it doesn t have hotfix 

if ("5.6 SP2".equals(prodVersionTextShort.trim())) {	return new XenServer56SP2Resource();	} else if ("5.6 FP1".equals(prodVersionTextShort.trim())) {	return new XenServer56FP1Resource();	}	} else if (prodBrand.equals("XCP_Kronos")) {	return new XcpOssResource();	} else if (prodBrand.equals("XenServer")) {	final String[] items = prodVersion.split("\\.");	if ((Integer.parseInt(items[0]) > 6) || (Integer.parseInt(items[0]) == 6 && Integer.parseInt(items[1]) >= 4)) {	
defaulting to resource for product brand with product version 

public void processConnect(com.cloud.host.Host agent, StartupCommand cmd, boolean forRebalance) throws ConnectionException {	if (!(cmd instanceof StartupRoutingCommand)) {	return;	}	long agentId = agent.getId();	StartupRoutingCommand startup = (StartupRoutingCommand)cmd;	if (startup.getHypervisorType() != HypervisorType.XenServer) {	
not xenserver so moving on 

String resource = createServerResource(prodBrand, prodVersion, prodVersionTextShort, hotfix).getClass().getName();	if (!resource.equals(host.getResource())) {	String msg = "host " + host.getPrivateIpAddress() + " changed from " + host.getResource() + " to " + resource;	s_logger.debug(msg);	host.setResource(resource);	host.setSetup(false);	_hostDao.update(agentId, host);	throw new HypervisorVersionChangedException(msg);	}	if (s_logger.isDebugEnabled()) {	
setting up host 

host.setHypervisorVersion(prodVersion);	_hostDao.update(host.getId(), host);	if (((SetupAnswer)answer).needReconnect()) {	throw new ConnectionException(false, "Reinitialize agent after setup.");	}	return;	} else {	s_logger.warn("Unable to setup agent " + agentId + " due to " + ((answer != null) ? answer.getDetails() : "return null"));	}	} catch (AgentUnavailableException e) {	
unable to setup agent because it became unavailable 

_hostDao.update(host.getId(), host);	if (((SetupAnswer)answer).needReconnect()) {	throw new ConnectionException(false, "Reinitialize agent after setup.");	}	return;	} else {	s_logger.warn("Unable to setup agent " + agentId + " due to " + ((answer != null) ? answer.getDetails() : "return null"));	}	} catch (AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	
unable to setup agent because it timed out 

StartupCommand firstCmd = startup[0];	if (!(firstCmd instanceof StartupRoutingCommand)) {	return null;	}	StartupRoutingCommand ssCmd = ((StartupRoutingCommand)firstCmd);	if (ssCmd.getHypervisorType() != HypervisorType.XenServer) {	return null;	}	HostPodVO pod = _podDao.findById(host.getPodId());	DataCenterVO dc = _dcDao.findById(host.getDataCenterId());	
host connected with hypervisor type checking cidr 

========================= cloudstack sample_1146 =========================

String prepareDnsmasq = "scripts/network/exdhcp/prepare_dnsmasq.sh";	String prepareDnsmasqPath = Script.findScript("", prepareDnsmasq);	if (prepareDnsmasqPath == null) {	throw new ConfigurationException("Can not find script prepare_dnsmasq.sh at " + prepareDnsmasq);	}	scp.put(prepareDnsmasqPath, "/usr/bin/", "0755");	String prepareCmd = String.format("sh /usr/bin/prepare_dnsmasq.sh %1$s %2$s %3$s", _gateway, _dns, _ip);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, prepareCmd)) {	throw new ConfigurationException("prepare dnsmasq at " + _ip + " failed");	}	
dnsmasq resource configure successfully 

if (prepareDnsmasqPath == null) {	throw new ConfigurationException("Can not find script prepare_dnsmasq.sh at " + prepareDnsmasq);	}	scp.put(prepareDnsmasqPath, "/usr/bin/", "0755");	String prepareCmd = String.format("sh /usr/bin/prepare_dnsmasq.sh %1$s %2$s %3$s", _gateway, _dns, _ip);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, prepareCmd)) {	throw new ConfigurationException("prepare dnsmasq at " + _ip + " failed");	}	return true;	} catch (Exception e) {	
dnsmasq resorce configure failed 

========================= cloudstack sample_888 =========================

os = sslSocket.getOutputStream();	break;	}	default: throw new RuntimeException("Unknown packet type: " + packet.type);	}	}	} finally {	try {	is.close();	} catch (Throwable e) {	
ignored in stream close failed 

}	}	} finally {	try {	is.close();	} catch (Throwable e) {	}	try {	os.close();	} catch (Throwable e) {	
ignored out stream close failed 

is.close();	} catch (Throwable e) {	}	try {	os.close();	} catch (Throwable e) {	}	try {	serverSocket.close();	} catch (Throwable e) {	
ignored server socket close failed 

========================= cloudstack sample_5105 =========================

public void handle(HttpRequest request, HttpResponse response, HttpContext context) throws HttpException, IOException {	try {	if (s_logger.isTraceEnabled()) {	
start handling cluster http request 

public void handle(HttpRequest request, HttpResponse response, HttpContext context) throws HttpException, IOException {	try {	if (s_logger.isTraceEnabled()) {	}	parseRequest(request);	handleRequest(request, response);	if (s_logger.isTraceEnabled()) {	
handle cluster http request done 

public void handle(HttpRequest request, HttpResponse response, HttpContext context) throws HttpException, IOException {	try {	if (s_logger.isTraceEnabled()) {	}	parseRequest(request);	handleRequest(request, response);	if (s_logger.isTraceEnabled()) {	}	} catch (final Throwable e) {	if (s_logger.isDebugEnabled()) {	
exception 

handleRequest(request, response);	if (s_logger.isTraceEnabled()) {	}	} catch (final Throwable e) {	if (s_logger.isDebugEnabled()) {	}	try {	writeResponse(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, null);	} catch (final Throwable e2) {	if (s_logger.isDebugEnabled()) {	
exception 

try {	if (method != null) {	nMethod = Integer.parseInt(method);	}	switch (nMethod) {	case RemoteMethodConstants.METHOD_DELIVER_PDU: responseContent = handleDeliverPduMethodCall(req);	break;	case RemoteMethodConstants.METHOD_PING: responseContent = handlePingMethodCall(req);	break;	case RemoteMethodConstants.METHOD_UNKNOWN: default: assert false;	
unrecognized method 

}	switch (nMethod) {	case RemoteMethodConstants.METHOD_DELIVER_PDU: responseContent = handleDeliverPduMethodCall(req);	break;	case RemoteMethodConstants.METHOD_PING: responseContent = handlePingMethodCall(req);	break;	case RemoteMethodConstants.METHOD_UNKNOWN: default: assert false;	break;	}	} catch (final Throwable e) {	
unexpected exception when processing cluster service request 

break;	case RemoteMethodConstants.METHOD_PING: responseContent = handlePingMethodCall(req);	break;	case RemoteMethodConstants.METHOD_UNKNOWN: default: assert false;	break;	}	} catch (final Throwable e) {	}	if (responseContent != null) {	if (s_logger.isTraceEnabled()) {	
write reponse with http ok 

break;	}	} catch (final Throwable e) {	}	if (responseContent != null) {	if (s_logger.isTraceEnabled()) {	}	writeResponse(response, HttpStatus.SC_OK, responseContent);	} else {	if (s_logger.isTraceEnabled()) {	
write reponse with http bad request 

private String handlePingMethodCall(HttpRequest req) {	final String callingPeer = (String)req.getParams().getParameter("callingPeer");	if (s_logger.isDebugEnabled()) {	
handle ping request from 

========================= cloudstack sample_471 =========================

public void handleDeleteLoadBalancerRule(final LoadBalancer lb, final long userId, final Account caller) {	final List<LoadBalancerVO> remainingLbs = _loadBalancerDao.listByIpAddress(lb.getSourceIpAddressId());	if (remainingLbs.size() == 0) {	
elb mgr releasing ip since no lb rules remain for this ip address 

public LoadBalancer handleCreateLoadBalancerRule(final CreateLoadBalancerRuleCmd lb, Account account, final long networkId) throws InsufficientAddressCapacityException, NetworkRuleConflictException {	if (!_networkModel.isProviderSupportServiceInNetwork(lb.getNetworkId(), Service.Lb, Provider.ElasticLoadBalancerVm)) {	return null;	}	final Long ipId = lb.getSourceIpAddressId();	if (ipId != null) {	return null;	}	account = _accountDao.acquireInLockTable(account.getId());	if (account == null) {	
elb createloadbalancer failed to acquire lock on account 

private DomainRouterVO deployLoadBalancerVM(final Long networkId, final IPAddressVO ipAddr) {	final NetworkVO network = _networkDao.findById(networkId);	final DataCenter dc = _dcDao.findById(network.getDataCenterId());	final Long podId = getPodIdForDirectIp(ipAddr);	final Pod pod = podId == null ? null : _podDao.findById(podId);	final Map<VirtualMachineProfile.Param, Object> params = new HashMap<VirtualMachineProfile.Param, Object>(1);	params.put(VirtualMachineProfile.Param.ReProgramGuestNetworks, true);	final Account owner = _accountService.getActiveAccountByName("system", new Long(1));	final DeployDestination dest = new DeployDestination(dc, pod, null, null);	
about to deploy elb vm 

final Account owner = _accountService.getActiveAccountByName("system", new Long(1));	final DeployDestination dest = new DeployDestination(dc, pod, null, null);	try {	final DomainRouterVO elbVm = deployELBVm(network, dest, owner, params);	if (elbVm == null) {	throw new InvalidParameterValueException("Could not deploy or find existing ELB VM");	}	s_logger.debug("Deployed ELB  vm = " + elbVm);	return elbVm;	} catch (final Throwable t) {	
error while deploying elb vm 

final Long guestNetworkId = guestNetwork.getId();	guestNetwork = _networkDao.acquireInLockTable(guestNetworkId);	if (guestNetwork == null) {	throw new ConcurrentOperationException("Unable to acquire network lock: " + guestNetworkId);	}	try {	if (_networkModel.isNetworkSystem(guestNetwork) || guestNetwork.getGuestType() == Network.GuestType.Shared) {	owner = _accountService.getSystemAccount();	}	if (s_logger.isDebugEnabled()) {	
starting a elb vm for network configurations in 

}	if (s_logger.isDebugEnabled()) {	}	assert guestNetwork.getState() == Network.State.Implemented || guestNetwork.getState() == Network.State.Setup || guestNetwork.getState() == Network.State.Implementing : "Network is not yet fully implemented: " + guestNetwork;	DataCenterDeployment plan = null;	DomainRouterVO elbVm = null;	plan = new DataCenterDeployment(dcId, dest.getPod().getId(), null, null, null, null);	if (elbVm == null) {	final long id = _routerDao.getNextInSequence(Long.class, "id");	if (s_logger.isDebugEnabled()) {	
creating the elb vm 

private void releaseIp(final long ipId, final long userId, final Account caller) {	
elb release public ip for loadbalancing 

private LoadBalancer handleCreateLoadBalancerRuleWithLock(final CreateLoadBalancerRuleCmd lb, final Account account, final long networkId) throws InsufficientAddressCapacityException, NetworkRuleConflictException {	Long ipId = null;	boolean newIp = false;	List<LoadBalancerVO> existingLbs = findExistingLoadBalancers(lb.getName(), lb.getSourceIpAddressId(), lb.getAccountId(), lb.getDomainId(), lb.getSourcePortStart());	if (existingLbs == null) {	existingLbs = findExistingLoadBalancers(lb.getName(), lb.getSourceIpAddressId(), lb.getAccountId(), lb.getDomainId(), null);	if (existingLbs == null) {	if (lb.getSourceIpAddressId() != null) {	throwExceptionIfSuppliedlLbNameIsNotAssociatedWithIpAddress(lb);	} else {	
could not find any existing frontend ips for this account for this lb rule acquiring a new frontent ip for elb 

if (existingLbs == null) {	if (lb.getSourceIpAddressId() != null) {	throwExceptionIfSuppliedlLbNameIsNotAssociatedWithIpAddress(lb);	} else {	final PublicIp ip = allocDirectIp(account, networkId);	ipId = ip.getId();	newIp = true;	}	} else {	ipId = existingLbs.get(0).getSourceIpAddressId();	
elb found existing frontend ip for this account for this lb rule 

throwExceptionIfSuppliedlLbNameIsNotAssociatedWithIpAddress(lb);	} else {	final PublicIp ip = allocDirectIp(account, networkId);	ipId = ip.getId();	newIp = true;	}	} else {	ipId = existingLbs.get(0).getSourceIpAddressId();	}	} else {	
elb found existing load balancers matching requested new lb 

}	} else {	throw new NetworkRuleConflictException("ELB: Found existing load balancers matching requested new LB");	}	final IPAddressVO ipAddr = _ipAddressDao.findById(ipId);	LoadBalancer result = null;	try {	lb.setSourceIpAddressId(ipId);	result = _lbMgr.createPublicLoadBalancer(lb.getXid(), lb.getName(), lb.getDescription(), lb.getSourcePortStart(), lb.getDefaultPortStart(), ipId.longValue(), lb.getProtocol(), lb.getAlgorithm(), false, CallContext.current(), lb.getLbProtocol(), true);	} catch (final NetworkRuleConflictException e) {	
failed to create lb rule not continuing with elb deployment 

}	}	}	} else {	final ElasticLbVmMapVO elbVmMap = _elbVmMapDao.findOneByIp(ipId);	if (elbVmMap != null) {	elbVm = _routerDao.findById(elbVmMap.getElbVmId());	}	}	if (elbVm == null) {	
no elb vm can be found or deployed 

}	}	}	} else {	final ElasticLbVmMapVO elbVmMap = _elbVmMapDao.findOneByIp(ipId);	if (elbVmMap != null) {	elbVm = _routerDao.findById(elbVmMap.getElbVmId());	}	}	if (elbVm == null) {	
deleting lb since we failed to deploy elb vm 

private PublicIp allocDirectIp(final Account account, final long guestNetworkId) throws InsufficientAddressCapacityException {	return Transaction.execute(new TransactionCallbackWithException<PublicIp, InsufficientAddressCapacityException>() {	public PublicIp doInTransaction(final TransactionStatus status) throws InsufficientAddressCapacityException {	final Network frontEndNetwork = _networkModel.getNetwork(guestNetworkId);	final PublicIp ip = _ipAddrMgr.assignPublicIpAddress(frontEndNetwork.getDataCenterId(), null, account, VlanType.DirectAttached, frontEndNetwork.getId(), null, true);	final IPAddressVO ipvo = _ipAddressDao.findById(ip.getId());	ipvo.setAssociatedWithNetworkId(frontEndNetwork.getId());	_ipAddressDao.update(ipvo.getId(), ipvo);	
acquired frontend ip for elb 

protected DomainRouterVO start(final DomainRouterVO elbVm, final Map<Param, Object> params) throws ConcurrentOperationException {	
starting elb vm 

========================= cloudstack sample_1900 =========================

protected Void createSnapshotAsyncCallback(AsyncCallbackDispatcher<SnapshotServiceImpl, CreateCmdResult> callback, CreateSnapshotContext<CreateCmdResult> context) {	CreateCmdResult result = callback.getResult();	SnapshotObject snapshot = (SnapshotObject)context.snapshot;	AsyncCallFuture<SnapshotResult> future = context.future;	SnapshotResult snapResult = new SnapshotResult(snapshot, result.getAnswer());	if (result.isFailed()) {	
create snapshot failed 

protected Void createSnapshotAsyncCallback(AsyncCallbackDispatcher<SnapshotServiceImpl, CreateCmdResult> callback, CreateSnapshotContext<CreateCmdResult> context) {	CreateCmdResult result = callback.getResult();	SnapshotObject snapshot = (SnapshotObject)context.snapshot;	AsyncCallFuture<SnapshotResult> future = context.future;	SnapshotResult snapResult = new SnapshotResult(snapshot, result.getAnswer());	if (result.isFailed()) {	try {	snapshot.processEvent(Snapshot.Event.OperationFailed);	snapshot.processEvent(Event.OperationFailed);	} catch (Exception e) {	
failed to update snapshot state due to 

} catch (Exception e) {	}	snapResult.setResult(result.getResult());	future.complete(snapResult);	return null;	}	try {	snapshot.processEvent(Event.OperationSuccessed, result.getAnswer());	snapshot.processEvent(Snapshot.Event.OperationSucceeded);	} catch (Exception e) {	
failed to create snapshot 

return null;	}	try {	snapshot.processEvent(Event.OperationSuccessed, result.getAnswer());	snapshot.processEvent(Snapshot.Event.OperationSucceeded);	} catch (Exception e) {	snapResult.setResult(e.toString());	try {	snapshot.processEvent(Snapshot.Event.OperationFailed);	} catch (NoTransitionException e1) {	
failed to change snapshot state 

public SnapshotResult takeSnapshot(SnapshotInfo snap) {	SnapshotObject snapshot = (SnapshotObject)snap;	SnapshotObject snapshotOnPrimary = null;	try {	snapshotOnPrimary = (SnapshotObject)snap.getDataStore().create(snapshot);	} catch (Exception e) {	
failed to create snapshot state on data store due to 

SnapshotObject snapshot = (SnapshotObject)snap;	SnapshotObject snapshotOnPrimary = null;	try {	snapshotOnPrimary = (SnapshotObject)snap.getDataStore().create(snapshot);	} catch (Exception e) {	throw new CloudRuntimeException(e);	}	try {	snapshotOnPrimary.processEvent(Snapshot.Event.CreateRequested);	} catch (NoTransitionException e) {	
failed to change snapshot state 

throw new CloudRuntimeException(e);	}	try {	snapshotOnPrimary.processEvent(Snapshot.Event.CreateRequested);	} catch (NoTransitionException e) {	throw new CloudRuntimeException(e);	}	try {	snapshotOnPrimary.processEvent(Event.CreateOnlyRequested);	} catch (Exception e) {	
failed to change snapshot state 

snapshotOnPrimary.processEvent(Snapshot.Event.CreateRequested);	} catch (NoTransitionException e) {	throw new CloudRuntimeException(e);	}	try {	snapshotOnPrimary.processEvent(Event.CreateOnlyRequested);	} catch (Exception e) {	try {	snapshotOnPrimary.processEvent(Snapshot.Event.OperationFailed);	} catch (NoTransitionException e1) {	
failed to change snapshot state 

throw new CloudRuntimeException(e);	}	AsyncCallFuture<SnapshotResult> future = new AsyncCallFuture<SnapshotResult>();	try {	CreateSnapshotContext<CommandResult> context = new CreateSnapshotContext<CommandResult>(null, snap.getBaseVolume(), snapshotOnPrimary, future);	AsyncCallbackDispatcher<SnapshotServiceImpl, CreateCmdResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().createSnapshotAsyncCallback(null, null)).setContext(context);	PrimaryDataStoreDriver primaryStore = (PrimaryDataStoreDriver)snapshotOnPrimary.getDataStore().getDriver();	primaryStore.takeSnapshot(snapshot, caller);	} catch (Exception e) {	
failed to take snapshot 

CreateSnapshotContext<CommandResult> context = new CreateSnapshotContext<CommandResult>(null, snap.getBaseVolume(), snapshotOnPrimary, future);	AsyncCallbackDispatcher<SnapshotServiceImpl, CreateCmdResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().createSnapshotAsyncCallback(null, null)).setContext(context);	PrimaryDataStoreDriver primaryStore = (PrimaryDataStoreDriver)snapshotOnPrimary.getDataStore().getDriver();	primaryStore.takeSnapshot(snapshot, caller);	} catch (Exception e) {	try {	snapshot.processEvent(Snapshot.Event.OperationFailed);	snapshot.processEvent(Event.OperationFailed);	} catch (NoTransitionException e1) {	
failed to change state for event operationfailed 

snapshot.processEvent(Event.OperationFailed);	} catch (NoTransitionException e1) {	}	throw new CloudRuntimeException("Failed to take snapshot" + snapshot.getId());	}	SnapshotResult result;	try {	result = future.get();	return result;	} catch (InterruptedException e) {	
failed to create snapshot 

}	throw new CloudRuntimeException("Failed to take snapshot" + snapshot.getId());	}	SnapshotResult result;	try {	result = future.get();	return result;	} catch (InterruptedException e) {	throw new CloudRuntimeException("Failed to create snapshot", e);	} catch (ExecutionException e) {	
failed to create snapshot 

if (imageStore == null) {	throw new CloudRuntimeException("can not find an image stores");	}	SnapshotInfo snapshotOnImageStore = (SnapshotInfo)imageStore.create(snapshot);	snapshotOnImageStore.processEvent(Event.CreateOnlyRequested);	CopySnapshotContext<CommandResult> context = new CopySnapshotContext<CommandResult>(null, snapshot, snapshotOnImageStore, future);	AsyncCallbackDispatcher<SnapshotServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().copySnapshotAsyncCallback(null, null)).setContext(context);	motionSrv.copyAsync(snapshot, snapshotOnImageStore, caller);	} catch (Exception e) {	
failed to copy snapshot 

snapshotOnImageStore.processEvent(Event.CreateOnlyRequested);	CopySnapshotContext<CommandResult> context = new CopySnapshotContext<CommandResult>(null, snapshot, snapshotOnImageStore, future);	AsyncCallbackDispatcher<SnapshotServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().copySnapshotAsyncCallback(null, null)).setContext(context);	motionSrv.copyAsync(snapshot, snapshotOnImageStore, caller);	} catch (Exception e) {	result.setResult("Failed to copy snapshot:" + e.toString());	try {	snapObj.processEvent(Snapshot.Event.OperationFailed);	} catch (NoTransitionException e1) {	
failed to change state 

future.complete(result);	}	try {	SnapshotResult res = future.get();	if (res.isFailed()) {	throw new CloudRuntimeException(res.getResult());	}	SnapshotInfo destSnapshot = res.getSnashot();	return destSnapshot;	} catch (InterruptedException e) {	
failed copy snapshot 

try {	SnapshotResult res = future.get();	if (res.isFailed()) {	throw new CloudRuntimeException(res.getResult());	}	SnapshotInfo destSnapshot = res.getSnashot();	return destSnapshot;	} catch (InterruptedException e) {	throw new CloudRuntimeException("Failed to copy snapshot", e);	} catch (ExecutionException e) {	
failed to copy snapshot 

AsyncCallFuture<SnapshotResult> future = context.future;	SnapshotResult snapResult = new SnapshotResult(destSnapshot, result.getAnswer());	if (result.isFailed()) {	try {	destSnapshot.processEvent(Event.OperationFailed);	srcSnapshot.processEvent(Event.DestroyRequested);	srcSnapshot.processEvent(Event.OperationSuccessed);	srcSnapshot.processEvent(Snapshot.Event.OperationFailed);	_snapshotDao.remove(srcSnapshot.getId());	} catch (NoTransitionException e) {	
failed to update state 

future.complete(snapResult);	return null;	}	try {	CopyCmdAnswer copyCmdAnswer = (CopyCmdAnswer)result.getAnswer();	destSnapshot.processEvent(Event.OperationSuccessed, copyCmdAnswer);	srcSnapshot.processEvent(Snapshot.Event.OperationSucceeded);	snapResult = new SnapshotResult(_snapshotFactory.getSnapshot(destSnapshot.getId(), destSnapshot.getDataStore()), copyCmdAnswer);	future.complete(snapResult);	} catch (Exception e) {	
failed to update snapshot state 

protected Void deleteSnapshotCallback(AsyncCallbackDispatcher<SnapshotServiceImpl, CommandResult> callback, DeleteSnapshotContext<CommandResult> context) {	CommandResult result = callback.getResult();	AsyncCallFuture<SnapshotResult> future = context.future;	SnapshotInfo snapshot = context.snapshot;	SnapshotResult res = null;	try {	if (result.isFailed()) {	
delete snapshot failed 

try {	if (result.isFailed()) {	snapshot.processEvent(ObjectInDataStoreStateMachine.Event.OperationFailed);	res = new SnapshotResult(context.snapshot, null);	res.setResult(result.getResult());	} else {	snapshot.processEvent(ObjectInDataStoreStateMachine.Event.OperationSuccessed);	res = new SnapshotResult(context.snapshot, null);	}	} catch (Exception e) {	
failed to in deletesnapshotcallback 

protected Void revertSnapshotCallback(AsyncCallbackDispatcher<SnapshotServiceImpl, CommandResult> callback, RevertSnapshotContext<CommandResult> context) {	CommandResult result = callback.getResult();	AsyncCallFuture<SnapshotResult> future = context.future;	SnapshotResult res = null;	try {	if (result.isFailed()) {	
revert snapshot failed 

AsyncCallFuture<SnapshotResult> future = context.future;	SnapshotResult res = null;	try {	if (result.isFailed()) {	res = new SnapshotResult(context.snapshot, null);	res.setResult(result.getResult());	} else {	res = new SnapshotResult(context.snapshot, null);	}	} catch (Exception e) {	
failed to in revertsnapshotcallback 

DataStore store = snapInfo.getDataStore();	store.getDriver().deleteAsync(store, snapInfo, caller);	SnapshotResult result = null;	try {	result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException(result.getResult());	}	return true;	} catch (InterruptedException e) {	
delete snapshot is failed 

store.getDriver().deleteAsync(store, snapInfo, caller);	SnapshotResult result = null;	try {	result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException(result.getResult());	}	return true;	} catch (InterruptedException e) {	} catch (ExecutionException e) {	
delete snapshot is failed 

caller.setCallback(caller.getTarget().revertSnapshotCallback(null, null)).setContext(context);	((PrimaryDataStoreDriver)store.getDriver()).revertSnapshot(snapshot, snapshotOnPrimaryStore, caller);	SnapshotResult result = null;	try {	result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException(result.getResult());	}	return true;	} catch (InterruptedException e) {	
revert snapshot is failed 

((PrimaryDataStoreDriver)store.getDriver()).revertSnapshot(snapshot, snapshotOnPrimaryStore, caller);	SnapshotResult result = null;	try {	result = future.get();	if (result.isFailed()) {	throw new CloudRuntimeException(result.getResult());	}	return true;	} catch (InterruptedException e) {	} catch (ExecutionException e) {	
revert snapshot is failed 

public void cleanupVolumeDuringSnapshotFailure(Long volumeId, Long snapshotId) {	SnapshotVO snaphsot = _snapshotDao.findById(snapshotId);	if (snaphsot != null) {	if (snaphsot.getState() != Snapshot.State.BackedUp) {	List<SnapshotDataStoreVO> snapshotDataStoreVOs = _snapshotStoreDao.findBySnapshotId(snapshotId);	for (SnapshotDataStoreVO snapshotDataStoreVO : snapshotDataStoreVOs) {	
remove snapshot status on snapshot store ref table with id 

public void cleanupVolumeDuringSnapshotFailure(Long volumeId, Long snapshotId) {	SnapshotVO snaphsot = _snapshotDao.findById(snapshotId);	if (snaphsot != null) {	if (snaphsot.getState() != Snapshot.State.BackedUp) {	List<SnapshotDataStoreVO> snapshotDataStoreVOs = _snapshotStoreDao.findBySnapshotId(snapshotId);	for (SnapshotDataStoreVO snapshotDataStoreVO : snapshotDataStoreVOs) {	_snapshotStoreDao.remove(snapshotDataStoreVO.getId());	}	
remove snapshot status from snapshot table 

private void syncSnapshotToRegionStore(long snapshotId, DataStore store){	SnapshotInfo snapOnStore = _snapshotFactory.getSnapshot(snapshotId, store);	if (snapOnStore == null) {	throw new CloudRuntimeException("Cannot find an entry in snapshot_store_ref for snapshot " + snapshotId + " on region store: " + store.getName());	}	if (snapOnStore.getPath() == null || snapOnStore.getPath().length() == 0) {	if (s_logger.isDebugEnabled()) {	
sync snapshot from cache to object store 

SnapshotResult res = new SnapshotResult(destSnapshot, null);	AsyncCallFuture<SnapshotResult> future = context.future;	try {	if (result.isFailed()) {	res.setResult(result.getResult());	} else {	destSnapshot.processEvent(Event.OperationSuccessed, result.getAnswer());	}	future.complete(res);	} catch (Exception e) {	
failed to process sync snapshot callback 

========================= cloudstack sample_3897 =========================

private void createResourceCount(Connection conn) {	
creating missing resource count records as a part of upgrade 

========================= cloudstack sample_4201 =========================

public Answer executeRequest(Command cmd) {	try {	Answer answer;	NDC.push(getCommandLogTitle(cmd));	
executing 

}	if (cmd.getContextParam("execid") != null) {	answer.setContextParam("execid", cmd.getContextParam("execid"));	}	if (cmd.getContextParam("checkpoint") != null) {	answer.setContextParam("checkpoint", cmd.getContextParam("checkpoint"));	}	if (cmd.getContextParam("checkpoint2") != null) {	answer.setContextParam("checkpoint2", cmd.getContextParam("checkpoint2"));	}	
command execution answer 

answer.setContextParam("execid", cmd.getContextParam("execid"));	}	if (cmd.getContextParam("checkpoint") != null) {	answer.setContextParam("checkpoint", cmd.getContextParam("checkpoint"));	}	if (cmd.getContextParam("checkpoint2") != null) {	answer.setContextParam("checkpoint2", cmd.getContextParam("checkpoint2"));	}	return answer;	} finally {	
done executing 

public VmwareContext getServiceContext(Command cmd) {	String guid = cmd.getContextParam("guid");	if (guid == null || guid.isEmpty()) {	
invalid command context parameter guid 

public VmwareContext getServiceContext(Command cmd) {	String guid = cmd.getContextParam("guid");	if (guid == null || guid.isEmpty()) {	return null;	}	String username = cmd.getContextParam("username");	if (username == null || username.isEmpty()) {	
invalid command context parameter username 

if (guid == null || guid.isEmpty()) {	return null;	}	String username = cmd.getContextParam("username");	if (username == null || username.isEmpty()) {	return null;	}	String password = cmd.getContextParam("password");	String[] tokens = guid.split("@");	if (tokens == null || tokens.length != 2) {	
invalid content in command context parameter guid 

return null;	}	String password = cmd.getContextParam("password");	String[] tokens = guid.split("@");	if (tokens == null || tokens.length != 2) {	return null;	}	String vCenterAddress = tokens[1];	String[] hostTokens = tokens[0].split(":");	if (hostTokens == null || hostTokens.length != 2) {	
invalid content in command context parameter guid 

}	int vCenterSessionTimeout = NumbersUtil.parseInt(cmd.getContextParam("vCenterSessionTimeout"), 1200000);	try {	_resource.ensureOutgoingRuleForAddress(vCenterAddress);	VmwareContext context = currentContext.get();	if (context != null && !context.validate()) {	invalidateServiceContext(context);	context = null;	}	if (context == null) {	
open new vmwarecontext vcenter user password 

context = VmwareSecondaryStorageContextFactory.getContext(vCenterAddress, username, password);	}	if (context != null) {	context.registerStockObject("serviceconsole", cmd.getContextParam("serviceconsole"));	context.registerStockObject("manageportgroup", cmd.getContextParam("manageportgroup"));	context.registerStockObject("noderuninfo", cmd.getContextParam("noderuninfo"));	}	currentContext.set(context);	return context;	} catch (Exception e) {	
unexpected exception 

public VmwareHypervisorHost getHyperHost(VmwareContext context, Command cmd) {	String guid = cmd.getContextParam("guid");	assert (guid != null);	String[] tokens = guid.split("@");	assert (tokens != null && tokens.length == 2);	ManagedObjectReference morHyperHost = new ManagedObjectReference();	String[] hostTokens = tokens[0].split(":");	if (hostTokens == null || hostTokens.length != 2) {	
invalid content in command context parameter guid 

if (morHyperHost.getType().equalsIgnoreCase("HostSystem")) {	HostMO hostMo = new HostMO(context, morHyperHost);	try {	ManagedObjectReference mor = hostMo.getHyperHostCluster();	ClusterMO clusterMo = new ClusterMO(hostMo.getContext(), mor);	List<Pair<ManagedObjectReference, String>> hostsInCluster = clusterMo.getClusterHosts();	for (Pair<ManagedObjectReference, String> hostPair : hostsInCluster) {	HostMO hostIteratorMo = new HostMO(hostMo.getContext(), hostPair.first());	VmwareHypervisorHostNetworkSummary netSummary = hostIteratorMo.getHyperHostNetworkSummary(hostIteratorMo.getHostType() == VmwareHostType.ESXi ? cmd.getContextParam("manageportgroup") : cmd.getContextParam("serviceconsole"));	_resource.ensureOutgoingRuleForAddress(netSummary.getHostIp());	
setup firewall rule for host 

try {	ManagedObjectReference mor = hostMo.getHyperHostCluster();	ClusterMO clusterMo = new ClusterMO(hostMo.getContext(), mor);	List<Pair<ManagedObjectReference, String>> hostsInCluster = clusterMo.getClusterHosts();	for (Pair<ManagedObjectReference, String> hostPair : hostsInCluster) {	HostMO hostIteratorMo = new HostMO(hostMo.getContext(), hostPair.first());	VmwareHypervisorHostNetworkSummary netSummary = hostIteratorMo.getHyperHostNetworkSummary(hostIteratorMo.getHostType() == VmwareHostType.ESXi ? cmd.getContextParam("manageportgroup") : cmd.getContextParam("serviceconsole"));	_resource.ensureOutgoingRuleForAddress(netSummary.getHostIp());	}	} catch (Throwable e) {	
unable to retrive host network information due to exception host 

========================= cloudstack sample_1280 =========================

migratedVm = _userVmService.vmStorageMigration(getVirtualMachineId(), destStoragePool);	}	if (migratedVm != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", (UserVm)migratedVm).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	
exception 

if (migratedVm != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", (UserVm)migratedVm).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	
exception 

response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (ManagementServerException e) {	
exception 

} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (ManagementServerException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (VirtualMachineMigrationException e) {	
exception 

========================= cloudstack sample_3252 =========================

protected void unlock() {	if (tableLockId != null) {	networkDao.releaseFromLockTable(tableLockId);	if (logger.isDebugEnabled()) {	
lock is released for network id as a part of router startup in 

protected int getNumberOfRoutersToDeploy() {	if (routers.size() >= LIMIT_NUMBER_OF_ROUTERS) {	
too many redundant routers 

protected boolean prepareDeployment() {	setupAccountOwner();	isPublicNetwork = networkModel.isProviderSupportServiceInNetwork(guestNetwork.getId(), Service.SourceNat, Provider.VirtualRouter);	boolean canProceed = true;	if (isRedundant() && !isPublicNetwork) {	
didn t support redundant virtual router without public network 

========================= cloudstack sample_2228 =========================

}	String mountStr = NfsUtils.uri2Mount(uri);	Script script = new Script(true, "mount", _timeout, s_logger);	String mntPoint = null;	File file = null;	do {	mntPoint = _mountParent + File.separator + Integer.toHexString(_random.nextInt(Integer.MAX_VALUE));	file = new File(mntPoint);	} while (file.exists());	if (!file.mkdirs()) {	
unable to make directory 

do {	mntPoint = _mountParent + File.separator + Integer.toHexString(_random.nextInt(Integer.MAX_VALUE));	file = new File(mntPoint);	} while (file.exists());	if (!file.mkdirs()) {	return null;	}	script.add(mountStr, mntPoint);	String result = script.execute();	if (result != null && !result.contains("already mounted")) {	
unable to mount due to 

NfsSecondaryStorageResource storage;	if (_configDao.isPremium()) {	Class<?> impl;	String name = "com.cloud.storage.resource.PremiumSecondaryStorageResource";	try {	impl = Class.forName(name);	final Constructor<?> constructor = impl.getDeclaredConstructor();	constructor.setAccessible(true);	storage = (NfsSecondaryStorageResource)constructor.newInstance();	} catch (final ClassNotFoundException e) {	
unable to load com cloud storage resource premiumsecondarystorageresource due to classnotfoundexception 

Class<?> impl;	String name = "com.cloud.storage.resource.PremiumSecondaryStorageResource";	try {	impl = Class.forName(name);	final Constructor<?> constructor = impl.getDeclaredConstructor();	constructor.setAccessible(true);	storage = (NfsSecondaryStorageResource)constructor.newInstance();	} catch (final ClassNotFoundException e) {	return null;	} catch (final SecurityException e) {	
unable to load com cloud storage resource premiumsecondarystorageresource due to securityexception 

try {	impl = Class.forName(name);	final Constructor<?> constructor = impl.getDeclaredConstructor();	constructor.setAccessible(true);	storage = (NfsSecondaryStorageResource)constructor.newInstance();	} catch (final ClassNotFoundException e) {	return null;	} catch (final SecurityException e) {	return null;	} catch (final NoSuchMethodException e) {	
unable to load com cloud storage resource premiumsecondarystorageresource due to nosuchmethodexception 

final Constructor<?> constructor = impl.getDeclaredConstructor();	constructor.setAccessible(true);	storage = (NfsSecondaryStorageResource)constructor.newInstance();	} catch (final ClassNotFoundException e) {	return null;	} catch (final SecurityException e) {	return null;	} catch (final NoSuchMethodException e) {	return null;	} catch (final IllegalArgumentException e) {	
unable to load com cloud storage resource premiumsecondarystorageresource due to illegalargumentexception 

storage = (NfsSecondaryStorageResource)constructor.newInstance();	} catch (final ClassNotFoundException e) {	return null;	} catch (final SecurityException e) {	return null;	} catch (final NoSuchMethodException e) {	return null;	} catch (final IllegalArgumentException e) {	return null;	} catch (final InstantiationException e) {	
unable to load com cloud storage resource premiumsecondarystorageresource due to instantiationexception 

return null;	} catch (final SecurityException e) {	return null;	} catch (final NoSuchMethodException e) {	return null;	} catch (final IllegalArgumentException e) {	return null;	} catch (final InstantiationException e) {	return null;	} catch (final IllegalAccessException e) {	
unable to load com cloud storage resource premiumsecondarystorageresource due to illegalaccessexception 

return null;	} catch (final NoSuchMethodException e) {	return null;	} catch (final IllegalArgumentException e) {	return null;	} catch (final InstantiationException e) {	return null;	} catch (final IllegalAccessException e) {	return null;	} catch (final InvocationTargetException e) {	
unable to load com cloud storage resource premiumsecondarystorageresource due to invocationtargetexception 

params.put("zone", Long.toString(dcId));	if (podId != null) {	params.put("pod", podId.toString());	}	params.put("guid", uri.toString());	params.put("secondary.storage.vm", "false");	params.put("max.template.iso.size", _configDao.getValue("max.template.iso.size"));	try {	storage.configure("Storage", params);	} catch (ConfigurationException e) {	
unable to configure the storage 

Map<String, Object> params = new HashMap<String, Object>();	params.putAll(details);	params.put("zone", Long.toString(dcId));	if (podId != null) {	params.put("pod", podId.toString());	}	params.put("guid", uri.toString());	try {	storage.configure("Storage", params);	} catch (ConfigurationException e) {	
unable to configure the storage 

Map<String, Object> params = new HashMap<String, Object>();	params.putAll(details);	params.put("zone", Long.toString(dcId));	if (podId != null) {	params.put("pod", podId.toString());	}	params.put("guid", uri.toString());	try {	storage.configure("Storage", params);	} catch (ConfigurationException e) {	
unable to configure the storage 

========================= cloudstack sample_5017 =========================

public void createPool(String poolName, String algorithm) throws InvalidParameterValueException {	
request createpool 

public void createPool(String poolName, String algorithm) throws InvalidParameterValueException {	PoolVO pool = null;	validAlgorithm(algorithm);	try {	pool = new PoolVO(poolName, algorithm);	_poolDao.persist(pool);	
response createpool success 

public void deletePool(String poolName) throws InvalidParameterValueException, ResourceInUseException {	
request deletepool 

public void deletePool(String poolName) throws InvalidParameterValueException, ResourceInUseException {	PoolVO pool = _poolDao.findPool(poolName);	if (pool == null) {	throw new InvalidParameterValueException("Cannot find pool " + poolName);	}	int volCount = _volumeDao.listVolumes(poolName).size();	if (volCount == 0) {	_poolDao.remove(pool.getId());	
request deletepool success 

public void destroyVolumeOnFiler(String ipAddress, String aggrName, String volName) throws ServerException, InvalidParameterValueException, ResourceInUseException {	NaElement xi0;	NaElement xi1;	NetappVolumeVO volume = null;	volume = _volumeDao.findVolume(ipAddress, aggrName, volName);	if (volume == null) {	
the volume does not exist in our system 

public void destroyVolumeOnFiler(String ipAddress, String aggrName, String volName) throws ServerException, InvalidParameterValueException, ResourceInUseException {	NaElement xi0;	NaElement xi1;	NetappVolumeVO volume = null;	volume = _volumeDao.findVolume(ipAddress, aggrName, volName);	if (volume == null) {	throw new InvalidParameterValueException("The given tuple:" + ipAddress + "," + aggrName + "," + volName + " doesn't exist in our system");	}	List<LunVO> lunsOnVol = _lunDao.listLunsByVolId(volume.getId());	if (lunsOnVol != null && lunsOnVol.size() > 0) {	
there are luns on the volume 

s = getServer(volume.getIpAddress(), volume.getUsername(), volume.getPassword());	xi0 = new NaElement("volume-offline");	xi0.addNewChild("name", volName);	s.invokeElem(xi0);	xi1 = new NaElement("volume-destroy");	xi1.addNewChild("name", volName);	s.invokeElem(xi1);	_volumeDao.remove(volume.getId());	txn.commit();	} catch (UnknownHostException uhe) {	
unable to delete volume on filer 

xi0.addNewChild("name", volName);	s.invokeElem(xi0);	xi1 = new NaElement("volume-destroy");	xi1.addNewChild("name", volName);	s.invokeElem(xi1);	_volumeDao.remove(volume.getId());	txn.commit();	} catch (UnknownHostException uhe) {	throw new ServerException("Unable to delete volume on filer", uhe);	} catch (NaAPIFailedException naf) {	
unable to delete volume on filer 

s.invokeElem(xi0);	xi1 = new NaElement("volume-destroy");	xi1.addNewChild("name", volName);	s.invokeElem(xi1);	_volumeDao.remove(volume.getId());	txn.commit();	} catch (UnknownHostException uhe) {	throw new ServerException("Unable to delete volume on filer", uhe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 13040) {	
deleting the volume 

} catch (UnknownHostException uhe) {	throw new ServerException("Unable to delete volume on filer", uhe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 13040) {	_volumeDao.remove(volume.getId());	txn.commit();	}	throw new ServerException("Unable to delete volume on filer", naf);	} catch (NaException nae) {	txn.rollback();	
unable to delete volume on filer 

if (naf.getErrno() == 13040) {	_volumeDao.remove(volume.getId());	txn.commit();	}	throw new ServerException("Unable to delete volume on filer", naf);	} catch (NaException nae) {	txn.rollback();	throw new ServerException("Unable to delete volume on filer", nae);	} catch (IOException ioe) {	txn.rollback();	
unable to delete volume on filer 

public void createVolumeOnFiler(String ipAddress, String aggName, String poolName, String volName, String volSize, String snapshotPolicy, Integer snapshotReservation, String username, String password) throws UnknownHostException, ServerException, InvalidParameterValueException {	
request createvolume serverip 

volume = _volumeDao.findVolume(ipAddress, aggName, volName);	if (volume != null) {	throw new InvalidParameterValueException("The volume for the given ipAddress/aggregateName/volumeName tuple already exists");	}	PoolVO pool = _poolDao.findPool(poolName);	if (pool == null) {	throw new InvalidParameterValueException("Cannot find pool " + poolName);	}	pool = _poolDao.acquireInLockTable(pool.getId());	if (pool == null) {	
failed to acquire lock on pool 

volume.setSnapshotReservation(snapshotReservation);	_volumeDao.update(volumeId, volume);	}	if (snapPolicy) {	s.invokeElem(xi2);	volume.setSnapshotPolicy(snapshotPolicy);	_volumeDao.update(volumeId, volume);	}	txn.commit();	} catch (NaException nae) {	
failed to create volume on the netapp filer 

volume.setSnapshotPolicy(snapshotPolicy);	_volumeDao.update(volumeId, volume);	}	txn.commit();	} catch (NaException nae) {	txn.rollback();	if (volumeCreated) {	try {	deleteRogueVolume(volName, s);	} catch (NaException e) {	
failed to cleanup created volume whilst rolling back on the netapp filer 

}	txn.commit();	} catch (NaException nae) {	txn.rollback();	if (volumeCreated) {	try {	deleteRogueVolume(volName, s);	} catch (NaException e) {	throw new ServerException("Unable to create volume via cloudtools." + "Failed to cleanup created volume on netapp filer whilst rolling back on the cloud db:", e);	} catch (IOException e) {	
failed to cleanup created volume whilst rolling back on the netapp filer 

try {	deleteRogueVolume(volName, s);	} catch (NaException e) {	throw new ServerException("Unable to create volume via cloudtools." + "Failed to cleanup created volume on netapp filer whilst rolling back on the cloud db:", e);	} catch (IOException e) {	throw new ServerException("Unable to create volume via cloudtools." + "Failed to cleanup created volume on netapp filer whilst rolling back on the cloud db:", e);	}	}	throw new ServerException("Unable to create volume", nae);	} catch (IOException ioe) {	
failed to create volume on the netapp filer 

throw new ServerException("Unable to create volume via cloudtools." + "Failed to cleanup created volume on netapp filer whilst rolling back on the cloud db:", e);	}	}	throw new ServerException("Unable to create volume", nae);	} catch (IOException ioe) {	txn.rollback();	if (volumeCreated) {	try {	deleteRogueVolume(volName, s);	} catch (NaException e) {	
failed to cleanup created volume whilst rolling back on the netapp filer 

}	throw new ServerException("Unable to create volume", nae);	} catch (IOException ioe) {	txn.rollback();	if (volumeCreated) {	try {	deleteRogueVolume(volName, s);	} catch (NaException e) {	throw new ServerException("Unable to create volume via cloudtools." + "Failed to cleanup created volume on netapp filer whilst rolling back on the cloud db:", e);	} catch (IOException e) {	
failed to cleanup created volume whilst rolling back on the netapp filer 

public List<NetappVolumeVO> listVolumesOnFiler(String poolName) {	List<NetappVolumeVO> vols = _volumeDao.listVolumesAscending(poolName);	for (NetappVolumeVO vol : vols) {	try {	String snapScheduleOnFiler = returnSnapshotSchedule(vol);	vol.setSnapshotPolicy(snapScheduleOnFiler);	} catch (ServerException e) {	
error trying to get snapshot schedule for volume 

String weeks = xo.getChildContent("weeks");	String days = xo.getChildContent("days");	String hours = xo.getChildContent("hours");	String minutes = xo.getChildContent("minutes");	String whichHours = xo.getChildContent("which-hours");	String whichMinutes = xo.getChildContent("which-minutes");	StringBuilder sB = new StringBuilder();	sB.append(weeks) .append(" ") .append(days) .append(" ") .append(hours) .append("@") .append(whichHours) .append(" ") .append(minutes) .append("@") .append(whichMinutes);	return sB.toString();	} catch (NaException nae) {	
failed to get volume size 

String hours = xo.getChildContent("hours");	String minutes = xo.getChildContent("minutes");	String whichHours = xo.getChildContent("which-hours");	String whichMinutes = xo.getChildContent("which-minutes");	StringBuilder sB = new StringBuilder();	sB.append(weeks) .append(" ") .append(days) .append(" ") .append(hours) .append("@") .append(whichHours) .append(" ") .append(minutes) .append("@") .append(whichMinutes);	return sB.toString();	} catch (NaException nae) {	throw new ServerException("Failed to get volume size", nae);	} catch (IOException ioe) {	
failed to get volume size 

NaElement volInfo = (NaElement)volIter.next();	availableSize = volInfo.getChildLongValue("size-available", -1);	volumeState = volInfo.getChildContent("state");	}	if (volumeState != null) {	return volumeState.equalsIgnoreCase("online") ? availableSize : -1;	} else {	return -1;	}	} catch (NaException nae) {	
failed to get volume size 

volumeState = volInfo.getChildContent("state");	}	if (volumeState != null) {	return volumeState.equalsIgnoreCase("online") ? availableSize : -1;	} else {	return -1;	}	} catch (NaException nae) {	throw new ServerException("Failed to get volume size", nae);	} catch (IOException ioe) {	
failed to get volume size 

throw new InvalidParameterValueException("Please specify a valid lun size in Gb");	}	String algorithm = pool.getAlgorithm();	NetappVolumeVO selectedVol = null;	int numVolsInPool = _volumeDao.listVolumes(poolName).size();	if (numVolsInPool == 0) {	throw new InvalidParameterValueException("No volumes exist in the given pool");	}	pool = _poolDao.acquireInLockTable(pool.getId());	if (pool == null) {	
failed to acquire lock on the pool 

NaServer s = null;	try {	if (algorithm == null || algorithm.equals(Algorithm.roundrobin.toString())) {	selectedVol = _netappAllocator.chooseVolumeFromPool(poolName, lunSize);	} else if (algorithm.equals(Algorithm.leastfull.toString())) {	selectedVol = _netappAllocator.chooseLeastFullVolumeFromPool(poolName, lunSize);	}	if (selectedVol == null) {	throw new ServerException("Could not find a suitable volume to create lun on");	}	
request createlun serverip 

xi.addNewChild("size", (lunSizeBytes.toString()));	s.invokeElem(xi);	try {	xi1 = new NaElement("igroup-create");	xi1.addNewChild("initiator-group-name", lunName.toString());	xi1.addNewChild("initiator-group-type", "iscsi");	xi1.addNewChild("os-type", "linux");	s.invokeElem(xi1);	} catch (NaAPIFailedException e) {	if (e.getErrno() == 9004) {	
igroup already exists 

LunVO lun = _lunDao.findByName(lunName);	if (lun == null) throw new InvalidParameterValueException("Cannot find lun");	NetappVolumeVO vol = _volumeDao.acquireInLockTable(lun.getVolumeId());	if (vol == null) {	s_logger.warn("Failed to lock volume id= " + lun.getVolumeId());	return;	}	NaServer s = null;	try {	s = getServer(vol.getIpAddress(), vol.getUsername(), vol.getPassword());	
request destroylun serverip 

xi.addNewChild("force", "true");	xi.addNewChild("path", lun.getPath() + lun.getLunName());	s.invokeElem(xi);	NaElement xi1 = new NaElement("igroup-destroy");	xi1.addNewChild("initiator-group-name", lunName);	s.invokeElem(xi1);	_lunDao.remove(lun.getId());	txn.commit();	} catch (UnknownHostException uhe) {	txn.rollback();	
failed to delete lun 

NaElement xi1 = new NaElement("igroup-destroy");	xi1.addNewChild("initiator-group-name", lunName);	s.invokeElem(xi1);	_lunDao.remove(lun.getId());	txn.commit();	} catch (UnknownHostException uhe) {	txn.rollback();	throw new ServerException("Failed to delete lun", uhe);	} catch (IOException ioe) {	txn.rollback();	
failed to delete lun 

_lunDao.remove(lun.getId());	txn.commit();	} catch (UnknownHostException uhe) {	txn.rollback();	throw new ServerException("Failed to delete lun", uhe);	} catch (IOException ioe) {	txn.rollback();	throw new ServerException("Failed to delete lun", ioe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 9017) {	
no such group exists excpn caught in deletelun continuing with delete 

txn.rollback();	throw new ServerException("Failed to delete lun", uhe);	} catch (IOException ioe) {	txn.rollback();	throw new ServerException("Failed to delete lun", ioe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 9017) {	_lunDao.remove(lun.getId());	txn.commit();	} else if (naf.getErrno() == 9029) {	
lun maps for this initiator group exist errno caught in deletelun continuing with delete 

throw new ServerException("Failed to delete lun", ioe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 9017) {	_lunDao.remove(lun.getId());	txn.commit();	} else if (naf.getErrno() == 9029) {	_lunDao.remove(lun.getId());	txn.commit();	} else {	txn.rollback();	
failed to delete lun 

txn.commit();	} else if (naf.getErrno() == 9029) {	_lunDao.remove(lun.getId());	txn.commit();	} else {	txn.rollback();	throw new ServerException("Failed to delete lun", naf);	}	} catch (NaException nae) {	txn.rollback();	
failed to delete lun 

public List<LunVO> listLunsOnFiler(String poolName) {	
request listlunsonfiler 

public List<LunVO> listLunsOnFiler(String poolName) {	List<LunVO> luns = new ArrayList<LunVO>();	List<NetappVolumeVO> vols = _volumeDao.listVolumes(poolName);	for (NetappVolumeVO vol : vols) {	luns.addAll(_lunDao.listLunsByVolId(vol.getId()));	}	
response listlunsonfiler success 

public void disassociateLun(String iGroup, String lunName) throws ServerException, InvalidParameterValueException {	NaElement xi;	LunVO lun = _lunDao.findByName(lunName);	if (lun == null) throw new InvalidParameterValueException("Cannot find LUN " + lunName);	NetappVolumeVO vol = _volumeDao.findById(lun.getVolumeId());	NaServer s = null;	try {	s = getServer(vol.getIpAddress(), vol.getUsername(), vol.getPassword());	
request disassociatelun serverip 

Long lId = new Long(lunIdStr);	LunVO lun = _lunDao.findById(lId);	if (lun == null) throw new InvalidParameterValueException("Cannot find LUN " + lunName);	NetappVolumeVO vol = _volumeDao.findById(lun.getVolumeId());	returnVal[0] = lunIdStr;	returnVal[1] = lun.getTargetIqn();	returnVal[2] = vol.getIpAddress();	NaServer s = null;	try {	s = getServer(vol.getIpAddress(), vol.getUsername(), vol.getPassword());	
request associatelun serverip 

NaServer s = null;	try {	s = getServer(vol.getIpAddress(), vol.getUsername(), vol.getPassword());	xi2 = new NaElement("igroup-add");	xi2.addNewChild("force", "true");	xi2.addNewChild("initiator", guestIqn);	xi2.addNewChild("initiator-group-name", lunName);	s.invokeElem(xi2);	return returnVal;	} catch (UnknownHostException uhe) {	
unable to associate lun 

xi2.addNewChild("initiator", guestIqn);	xi2.addNewChild("initiator-group-name", lunName);	s.invokeElem(xi2);	return returnVal;	} catch (UnknownHostException uhe) {	throw new ServerException("Unable to associate LUN", uhe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 9008) {	return returnVal;	}	
unable to associate lun 

s.invokeElem(xi2);	return returnVal;	} catch (UnknownHostException uhe) {	throw new ServerException("Unable to associate LUN", uhe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 9008) {	return returnVal;	}	throw new ServerException("Unable to associate LUN", naf);	} catch (NaException nae) {	
unable to associate lun 

} catch (UnknownHostException uhe) {	throw new ServerException("Unable to associate LUN", uhe);	} catch (NaAPIFailedException naf) {	if (naf.getErrno() == 9008) {	return returnVal;	}	throw new ServerException("Unable to associate LUN", naf);	} catch (NaException nae) {	throw new ServerException("Unable to associate LUN", nae);	} catch (IOException ioe) {	
unable to associate lun 

========================= cloudstack sample_1957 =========================

final SnapshotPolicyVO policy = _snapshotPolicyDao.findById(policyId);	Date nextTimestamp = null;	if (policy != null) {	final short intervalType = policy.getInterval();	final IntervalType type = DateUtil.getIntervalType(intervalType);	final String schedule = policy.getSchedule();	final String timezone = policy.getTimezone();	nextTimestamp = DateUtil.getNextRunTime(type, schedule, timezone, currentTimestamp);	final String currentTime = DateUtil.displayDateInTimezone(DateUtil.GMT_TIMEZONE, currentTimestamp);	final String nextScheduledTime = DateUtil.displayDateInTimezone(DateUtil.GMT_TIMEZONE, nextTimestamp);	
current time is nextscheduledtime of policyid is 

protected void scheduleSnapshots() {	String displayTime = DateUtil.displayDateInTimezone(DateUtil.GMT_TIMEZONE, _currentTimestamp);	
snapshot scheduler poll is being called at 

protected void scheduleSnapshots() {	String displayTime = DateUtil.displayDateInTimezone(DateUtil.GMT_TIMEZONE, _currentTimestamp);	final List<SnapshotScheduleVO> snapshotsToBeExecuted = _snapshotScheduleDao.getSchedulesToExecute(_currentTimestamp);	
got snapshots to be executed at 

final long policyId = snapshotToBeExecuted.getPolicyId();	final long volumeId = snapshotToBeExecuted.getVolumeId();	try {	final VolumeVO volume = _volsDao.findById(volumeId);	if (volume.getPoolId() == null) {	continue;	}	Account volAcct = _acctDao.findById(volume.getAccountId());	if (volAcct == null || volAcct.getState() == Account.State.disabled) {	if (s_logger.isDebugEnabled()) {	
skip snapshot for volume since its account has been removed or disabled 

if (s_logger.isDebugEnabled()) {	}	continue;	}	if (_snapshotPolicyDao.findById(policyId) == null) {	_snapshotScheduleDao.remove(snapshotToBeExecuted.getId());	}	if (s_logger.isDebugEnabled()) {	final Date scheduledTimestamp = snapshotToBeExecuted.getScheduledTimestamp();	displayTime = DateUtil.displayDateInTimezone(DateUtil.GMT_TIMEZONE, scheduledTimestamp);	
scheduling snapshot for volume id volume name for schedule id at 

ComponentContext.inject(cmd);	_dispatcher.dispatchCreateCmd(cmd, params);	params.put("id", "" + cmd.getEntityId());	params.put("ctxStartEventId", "1");	AsyncJobVO job = new AsyncJobVO("", User.UID_SYSTEM, volume.getAccountId(), CreateSnapshotCmd.class.getName(), ApiGsonHelper.getBuilder().create().toJson(params), cmd.getEntityId(), cmd.getInstanceType() != null ? cmd.getInstanceType().toString() : null, null);	job.setDispatcher(_asyncDispatcher.getName());	final long jobId = _asyncMgr.submitAsyncJob(job);	tmpSnapshotScheduleVO.setAsyncJobId(jobId);	_snapshotScheduleDao.update(snapshotScheId, tmpSnapshotScheduleVO);	} catch (final Exception e) {	
scheduling snapshot failed due to 

public boolean removeSchedule(final Long volumeId, final Long policyId) {	final SnapshotScheduleVO schedule = _snapshotScheduleDao.getCurrentSchedule(volumeId, policyId, false);	boolean success = true;	if (schedule != null) {	success = _snapshotScheduleDao.remove(schedule.getId());	}	if (!success) {	
error while deleting snapshot schedule with id 

if (snapshotsRecurringTest) {	final int minutesPerHour = NumbersUtil.parseInt(_configDao.getValue("snapshot.test.minutes.per.hour"), 60);	final int hoursPerDay = NumbersUtil.parseInt(_configDao.getValue("snapshot.test.hours.per.day"), 24);	final int daysPerWeek = NumbersUtil.parseInt(_configDao.getValue("snapshot.test.days.per.week"), 7);	final int daysPerMonth = NumbersUtil.parseInt(_configDao.getValue("snapshot.test.days.per.month"), 30);	final int weeksPerMonth = NumbersUtil.parseInt(_configDao.getValue("snapshot.test.weeks.per.month"), 4);	final int monthsPerYear = NumbersUtil.parseInt(_configDao.getValue("snapshot.test.months.per.year"), 12);	_testTimerTask = new TestClock(this, minutesPerHour, hoursPerDay, daysPerWeek, daysPerMonth, weeksPerMonth, monthsPerYear);	}	_currentTimestamp = new Date();	
snapshot scheduler is configured 

if (_testTimerTask != null) {	_testClockTimer = new Timer("TestClock");	_testClockTimer.schedule(_testTimerTask, 100 * 1000L, 60 * 1000L);	} else {	final TimerTask timerTask = new ManagedContextTimerTask() {	protected void runInContext() {	try {	final Date currentTimestamp = new Date();	poll(currentTimestamp);	} catch (final Throwable t) {	
catch throwable in snapshot scheduler 

========================= cloudstack sample_2414 =========================

}	if (nexusEnabled) {	publicVswitchType = NEXUS_1000V_DVSWITCH;	guestVswitchType = NEXUS_1000V_DVSWITCH;	}	detailsList = new ArrayList<Pair<String, String>>();	detailsList.add(new Pair<String, String>(ApiConstants.VSWITCH_TYPE_GUEST_TRAFFIC, guestVswitchType));	detailsList.add(new Pair<String, String>(ApiConstants.VSWITCH_TYPE_PUBLIC_TRAFFIC, publicVswitchType));	detailsMap.put(clusterId, detailsList);	updateClusterDetails(conn, detailsMap);	
persist vswitch configuration successfully persisted vswitch configuration for cluster 

if (nexusEnabled) {	publicVswitchType = NEXUS_1000V_DVSWITCH;	guestVswitchType = NEXUS_1000V_DVSWITCH;	}	detailsList = new ArrayList<Pair<String, String>>();	detailsList.add(new Pair<String, String>(ApiConstants.VSWITCH_TYPE_GUEST_TRAFFIC, guestVswitchType));	detailsList.add(new Pair<String, String>(ApiConstants.VSWITCH_TYPE_PUBLIC_TRAFFIC, publicVswitchType));	detailsMap.put(clusterId, detailsList);	updateClusterDetails(conn, detailsMap);	} else {	
persist vswitch configuration ignoring cluster with hypervisor type 

keyValues = detailsMap.get(clusterId);	try( PreparedStatement clusterDetailsInsert = conn.prepareStatement("INSERT INTO `cloud`.`cluster_details` (cluster_id, name, value) VALUES (?, ?, ?)");) {	for (Pair<String, String> keyValuePair : keyValues) {	key = keyValuePair.first();	val = keyValuePair.second();	clusterDetailsInsert.setLong(1, clusterId);	clusterDetailsInsert.setString(2, key);	clusterDetailsInsert.setString(3, val);	clusterDetailsInsert.executeUpdate();	}	
inserted vswitch configuration details into cloud cluster details for cluster with id 

private void setConfigurationParameter(Connection conn, String category, String paramName, String paramVal) {	try (PreparedStatement pstmt = conn.prepareStatement("UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?;");) {	pstmt.setString(1, paramVal);	pstmt.setString(2, paramName);	
updating global configuration parameter with value update sql statement is 

if (sel_dom_id_res.next()) {	domainName = sel_dom_id_res.getString(1);	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while Moving private zone information to dedicated resources", e);	}	String type = "ExplicitDedication";	String uuid = UUID.randomUUID().toString();	String groupName = "DedicatedGrp-domain-" + domainName;	
adding affinitygroup of type for domain id 

) {	alter_pstmt_id.executeUpdate();	try(PreparedStatement alter_pstmt_phy_net = conn.prepareStatement("ALTER TABLE `cloud`.`baremetal_dhcp_devices` ADD CONSTRAINT `fk_external_dhcp_devices_physical_network_id` FOREIGN KEY (`physical_network_id`) REFERENCES `physical_network`(`id`) ON DELETE CASCADE");) {	alter_pstmt_phy_net.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to add foreign keys to baremetal_dhcp_devices table", e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to add foreign keys to baremetal_dhcp_devices table", e);	}	
added foreign keys for table baremetal dhcp devices 

try(PreparedStatement alter_pxe_id_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`baremetal_pxe_devices` ADD CONSTRAINT `fk_external_pxe_devices_host_id` FOREIGN KEY (`host_id`) REFERENCES `host`(`id`) ON DELETE CASCADE");) {	alter_pxe_id_pstmt.executeUpdate();	try(PreparedStatement alter_pxe_phy_net_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`baremetal_pxe_devices` ADD CONSTRAINT `fk_external_pxe_devices_physical_network_id` FOREIGN KEY (`physical_network_id`) REFERENCES `physical_network`(`id`) ON DELETE CASCADE");) {	alter_pxe_phy_net_pstmt.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to add foreign keys to baremetal_pxe_devices table", e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to add foreign keys to baremetal_pxe_devices table", e);	}	
added foreign keys for table baremetal pxe devices 

private void addIndexForAlert(Connection conn) {	List<String> indexList = new ArrayList<String>();	
dropping index i alert last sent if it exists 

private void addIndexForAlert(Connection conn) {	List<String> indexList = new ArrayList<String>();	indexList.add("last_sent");	indexList.add("i_alert__last_sent");	DbUpgradeUtils.dropKeysIfExist(conn, "alert", indexList, false);	try(PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`alert` ADD INDEX `i_alert__last_sent`(`last_sent`)");) {	pstmt.executeUpdate();	
added index i alert last sent for table alert 

private void dropUploadTable(Connection conn) {	try(PreparedStatement  pstmt0 = conn.prepareStatement("SELECT url, created, type_id, host_id from upload where type=?");) {	
populating template store ref table 

pstmt0.setString(1, "TEMPLATE");	try(ResultSet rs0 = pstmt0.executeQuery();) {	try(PreparedStatement pstmt1 = conn.prepareStatement("UPDATE template_store_ref SET download_url=?, download_url_created=? where template_id=? and store_id=?");) {	while (rs0.next()) {	pstmt1.setString(1, rs0.getString("url"));	pstmt1.setDate(2, rs0.getDate("created"));	pstmt1.setLong(3, rs0.getLong("type_id"));	pstmt1.setLong(4, rs0.getLong("host_id"));	pstmt1.executeUpdate();	}	
populating volume store ref table 

private void setKVMSnapshotFlag(Connection conn) {	
verify and set the kvm snapshot flag if snapshot was used 

}catch (SQLException e) {	throw new CloudRuntimeException("Failed to read the snapshot table for KVM upgrade. ", e);	}	}	}catch (SQLException e) {	throw new CloudRuntimeException("Failed to read the snapshot table for KVM upgrade. ", e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Failed to read the snapshot table for KVM upgrade. ", e);	}	
done set kvm snapshot flag 

String newGuestLabel = oldParamValue;	try {	if ((rs != null) && (rs.next())) {	oldGuestLabel = rs.getString("vmware_network_label");	separatorIndex = oldGuestLabel.indexOf(",");	if (separatorIndex > -1) {	newGuestLabel += oldGuestLabel.substring(separatorIndex);	}	}	} catch (SQLException e) {	
failed to read vmware network label 

} else if (trafficTypeVswitchParam.equals("vmware.public.vswitch")) {	trafficType = "Public";	} else if (trafficTypeVswitchParam.equals("vmware.guest.vswitch")) {	trafficType = "Guest";	}	try(PreparedStatement sel_pstmt = conn.prepareStatement("select physical_network_id, traffic_type, vmware_network_label from physical_network_traffic_types where vmware_network_label is not NULL and traffic_type=?;");) {	pstmt.setString(1, trafficType);	try(ResultSet rsLabel = sel_pstmt.executeQuery();) {	newLabel = getNewLabel(rsLabel, trafficTypeVswitchParamValue);	try(PreparedStatement update_pstmt = conn.prepareStatement("update physical_network_traffic_types set vmware_network_label = ? where traffic_type = ? and vmware_network_label is not NULL;");) {	
updating vmware label for traffic update sql statement is 

tokens = url.split(" vc = tokens[2];	dcName = tokens[3];	dcOfPreviousCluster = dcOfCurrentCluster;	dcOfCurrentCluster = dcName + "@" + vc;	if (!dcList.contains(dcOfCurrentCluster)) {	dcList.add(dcOfCurrentCluster);	}	if (count > 0) {	if (!dcOfPreviousCluster.equalsIgnoreCase(dcOfCurrentCluster)) {	legacyZone = true;	
marking the zone as legacy zone 

legacyZone = true;	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable add zones to cloud.legacyzones table.", e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable add zones to cloud.legacyzones table.", e);	}	} else {	
ignoring zone with hypervisor type 

if (listOfNonLegacyZones.contains(newLegacyZone)) {	listOfNonLegacyZones.remove(newLegacyZone);	listOfLegacyZones.add(newLegacyZone);	}	}	}	}	updateLegacyZones(conn, listOfLegacyZones);	updateNonLegacyZones(conn, listOfNonLegacyZones);	} catch (SQLException e) {	
unable to discover legacy zones 

}	}	}	}	updateLegacyZones(conn, listOfLegacyZones);	updateNonLegacyZones(conn, listOfNonLegacyZones);	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to discover legacy zones." + e.getMessage(), e);	}	}catch (SQLException e) {	
unable to discover legacy zones 

private void updateLegacyZones(Connection conn, List<Long> zones) {	try (PreparedStatement legacyZonesQuery = conn.prepareStatement("INSERT INTO `cloud`.`legacy_zones` (zone_id) VALUES (?)");){	for (Long zoneId : zones) {	legacyZonesQuery.setLong(1, zoneId);	legacyZonesQuery.executeUpdate();	
inserted zone into cloud legacyzones table 

private void updateNonLegacyZones(Connection conn, List<Long> zones) {	try {	for (Long zoneId : zones) {	
discovered non legacy zone processing the zone to associate with vmware datacenter 

String uuid = UUID.randomUUID().toString();	try(PreparedStatement insert_pstmt = conn.prepareStatement("INSERT INTO `cloud`.`nics` (uuid, ip4_address, gateway, network_id, state, strategy, vm_type, default_nic, created) VALUES (?, ?, ?, ?, 'Reserved', 'PlaceHolder', 'DomainRouter', 0, now())");) {	insert_pstmt.setString(1, uuid);	insert_pstmt.setString(2, ip);	insert_pstmt.setString(3, gateway);	insert_pstmt.setLong(4, networkId);	insert_pstmt.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to create placeholder nics", e);	}	
created placeholder nic for the ipaddress and network 

private void addEgressFwRulesForSRXGuestNw(Connection conn) {	ResultSet rs = null;	try(PreparedStatement pstmt = conn.prepareStatement("select network_id FROM `cloud`.`ntwk_service_map` where service='Firewall' and provider='JuniperSRX' ");) {	rs = pstmt.executeQuery();	while (rs.next()) {	long netId = rs.getLong(1);	try(PreparedStatement sel_net_pstmt = conn.prepareStatement("select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR guest_type='Virtual') and traffic_type='Guest' and vpc_id is NULL and (state='implemented' OR state='Shutdown') and id=? ");) {	sel_net_pstmt.setLong(1, netId);	
getting account id domain id from networks table 

try(PreparedStatement pstmt = conn.prepareStatement("select network_id FROM `cloud`.`ntwk_service_map` where service='Firewall' and provider='JuniperSRX' ");) {	rs = pstmt.executeQuery();	while (rs.next()) {	long netId = rs.getLong(1);	try(PreparedStatement sel_net_pstmt = conn.prepareStatement("select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR guest_type='Virtual') and traffic_type='Guest' and vpc_id is NULL and (state='implemented' OR state='Shutdown') and id=? ");) {	sel_net_pstmt.setLong(1, netId);	try(ResultSet rsNw = pstmt.executeQuery();) {	if (rsNw.next()) {	long accountId = rsNw.getLong(1);	long domainId = rsNw.getLong(2);	
adding default egress firewall rule for network 

try(ResultSet rsNw = pstmt.executeQuery();) {	if (rsNw.next()) {	long accountId = rsNw.getLong(1);	long domainId = rsNw.getLong(2);	try (PreparedStatement insert_pstmt = conn.prepareStatement("INSERT INTO firewall_rules (uuid, state, protocol, purpose, account_id, domain_id, network_id, xid, created,  traffic_type) VALUES (?, 'Active', 'all', 'Firewall', ?, ?, ?, ?, now(), 'Egress')");) {	insert_pstmt.setString(1, UUID.randomUUID().toString());	insert_pstmt.setLong(2, accountId);	insert_pstmt.setLong(3, domainId);	insert_pstmt.setLong(4, netId);	insert_pstmt.setString(5, UUID.randomUUID().toString());	
inserting default egress firewall rule 

private void updateNetworkACLs(Connection conn) {	
updating network acls 

PreparedStatement pstmtUpdate = conn.prepareStatement(sqlUpdateNetworks);	PreparedStatement pstmtInsertNetworkAclItem = conn.prepareStatement(sqlInsertNetworkAclItem);	PreparedStatement pstmtSelectFirewallRules = conn.prepareStatement(sqlSelectFirewallRules);	PreparedStatement pstmtInsertNetworkAcl = conn.prepareStatement(sqlInsertNetworkAcl);	PreparedStatement pstmtSelectFirewallCidrs = conn.prepareStatement(sqlSelectFirewallCidrs);	PreparedStatement pstmtDeleteFirewallCidr = conn.prepareStatement(sqlDeleteFirewallCidr);	PreparedStatement pstmtDeleteFirewallRules = conn.prepareStatement(sqlDeleteFirewallRules);	ResultSet rsNetworkIds = pstmtSelectNetworkIds.executeQuery();) {	while (rsNetworkIds.next()) {	Long networkId = rsNetworkIds.getLong(1);	
updating network acls for network 

String tierUuid = rsNetworkIds.getString(3);	pstmtSelectFirewallRules.setLong(1, networkId);	boolean hasAcls = false;	Long aclId = null;	int number = 1;	try (ResultSet rsAcls = pstmtSelectFirewallRules.executeQuery();) {	while (rsAcls.next()) {	if (!hasAcls) {	hasAcls = true;	aclId = nextAclId++;	
creating network acl for tier 

if (cidr == null) {	cidr = sourceCidr;	} else {	cidr += "," + sourceCidr;	}	pstmtDeleteFirewallCidr.setLong(1, cidrId);	pstmtDeleteFirewallCidr.executeUpdate();	}	}	String aclItemUuid = rsAcls.getString(2);	
moving firewall rule 

pstmtDeleteFirewallRules.executeUpdate();	}	}	if (!hasAcls) {	aclId = NetworkACL.DEFAULT_DENY;	}	pstmtUpdate.setLong(1, aclId);	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.executeUpdate();	}	
done updating network acls 

private void addHostDetailsIndex(Connection conn) {	
checking if host details index exists if not we will add it 

private void addHostDetailsIndex(Connection conn) {	try(PreparedStatement pstmt = conn.prepareStatement("SHOW INDEX FROM `cloud`.`host_details` where KEY_NAME = 'fk_host_details__host_id'");) {	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	
index already exists on host details not adding new one 

private void addHostDetailsIndex(Connection conn) {	try(PreparedStatement pstmt = conn.prepareStatement("SHOW INDEX FROM `cloud`.`host_details` where KEY_NAME = 'fk_host_details__host_id'");) {	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	} else {	try(PreparedStatement pstmtUpdate = conn.prepareStatement("ALTER TABLE `cloud`.`host_details` ADD INDEX `fk_host_details__host_id` (`host_id`)");) {	pstmtUpdate.executeUpdate();	
index did not exist on host details added new one 

private void fix22xKVMSnapshots(Connection conn) {	
updating kvm snapshots 

private void fix22xKVMSnapshots(Connection conn) {	try (PreparedStatement pstmt = conn.prepareStatement("select id, backup_snap_id from `cloud`.`snapshots` where hypervisor_type='KVM' and removed is null and backup_snap_id is not null");) {	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	String backUpPath = rs.getString(2);	int index = backUpPath.indexOf("snapshots" + File.separator);	if (index > 1) {	String correctedPath = backUpPath.substring(index);	
updating snapshot with id original backup path updated backup path 

String correctedPath = backUpPath.substring(index);	try(PreparedStatement update_pstmt = conn.prepareStatement("UPDATE `cloud`.`snapshots` set backup_snap_id=? where id = ?");) {	update_pstmt.setString(1, correctedPath);	update_pstmt.setLong(2, id);	update_pstmt.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to update backup id for KVM snapshots", e);	}	}	}	
done updating kvm snapshots 

private void addF5LoadBalancer(Connection conn, long hostId, long physicalNetworkId) {	String insertF5 = "INSERT INTO `cloud`.`external_load_balancer_devices` (physical_network_id, host_id, provider_name, " + "device_name, capacity, is_dedicated, device_state, allocation_state, is_managed, uuid) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";	try(PreparedStatement pstmtUpdate =  conn.prepareStatement(insertF5);) {	
adding big ip load balancer with host id in to physical network 

private void addSrxFirewall(Connection conn, long hostId, long physicalNetworkId) {	String insertSrx = "INSERT INTO `cloud`.`external_firewall_devices` (physical_network_id, host_id, provider_name, " + "device_name, capacity, is_dedicated, device_state, allocation_state, uuid) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?)";	try(PreparedStatement pstmtUpdate = conn.prepareStatement(insertSrx);) {	
adding srx firewall device with host id in to physical network 

private void addF5ServiceProvider(Connection conn, long physicalNetworkId, long zoneId) {	String insertPNSP = "INSERT INTO `cloud`.`physical_network_service_providers` (`uuid`, `physical_network_id` , `provider_name`, `state` ," + "`destination_physical_network_id`, `vpn_service_provided`, `dhcp_service_provided`, `dns_service_provided`, `gateway_service_provided`," + "`firewall_service_provided`, `source_nat_service_provided`, `load_balance_service_provided`, `static_nat_service_provided`," + "`port_forwarding_service_provided`, `user_data_service_provided`, `security_group_service_provided`) VALUES (?,?,?,?,0,0,0,0,0,0,0,1,0,0,0,0)";	try(PreparedStatement pstmtUpdate = conn.prepareStatement(insertPNSP);) {	
adding physicalnetworkserviceprovider in to physical network 

private void addSrxServiceProvider(Connection conn, long physicalNetworkId, long zoneId) {	String insertPNSP = "INSERT INTO `cloud`.`physical_network_service_providers` (`uuid`, `physical_network_id` , `provider_name`, `state` ," + "`destination_physical_network_id`, `vpn_service_provided`, `dhcp_service_provided`, `dns_service_provided`, `gateway_service_provided`," + "`firewall_service_provided`, `source_nat_service_provided`, `load_balance_service_provided`, `static_nat_service_provided`," + "`port_forwarding_service_provided`, `user_data_service_provided`, `security_group_service_provided`) VALUES (?,?,?,?,0,0,0,0,1,1,1,0,1,1,0,0)";	try( PreparedStatement pstmtUpdate = conn.prepareStatement(insertPNSP);) {	
adding physicalnetworkserviceprovider junipersrx 

networkId = sel_id_cloud_pstmt_rs.getLong(1);	String insertLbMapping = "INSERT INTO `cloud`.`network_external_lb_device_map` (uuid, network_id, external_load_balancer_device_id, created) VALUES ( ?, ?, ?, now())";	try (PreparedStatement insert_lb_stmt = conn.prepareStatement(insertLbMapping);) {	insert_lb_stmt.setString(1, UUID.randomUUID().toString());	insert_lb_stmt.setLong(2, networkId);	insert_lb_stmt.setLong(3, f5DeviceId);	insert_lb_stmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	
successfully added entry in network external lb device map for network and device id 

}	String insertFwMapping = "INSERT INTO `cloud`.`network_external_firewall_device_map` (uuid, network_id, external_firewall_device_id, created) VALUES ( ?, ?, ?, now())";	try (PreparedStatement insert_ext_firewall_stmt = conn.prepareStatement(insertFwMapping);) {	insert_ext_firewall_stmt.setString(1, UUID.randomUUID().toString());	insert_ext_firewall_stmt.setLong(2, networkId);	insert_ext_firewall_stmt.setLong(3, srxDevivceId);	insert_ext_firewall_stmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	
successfully added entry in network external firewall device map for network and srx device id 

} catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	
updating the host details for and srx devices 

} catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	
successfully updated host details for and srx devices 

}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	} catch (RuntimeException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	}	
successfully upgraded network using and srx devices to have a entry in the network external lb device map and network external firewall device map 

private void migrateSecondaryStorageToImageStore(Connection conn) {	String sqlSelectS3Count = "select count(*) from `cloud`.`s3`";	String sqlSelectSwiftCount = "select count(*) from `cloud`.`swift`";	String sqlInsertStoreDetail = "INSERT INTO `cloud`.`image_store_details` (store_id, name, value) values(?, ?, ?)";	String sqlUpdateHostAsRemoved = "UPDATE `cloud`.`host` SET removed = now() WHERE type = 'SecondaryStorage' and removed is null";	
migrating secondary storage to image store 

try ( PreparedStatement pstmtSelectS3Count = conn.prepareStatement(sqlSelectS3Count);	PreparedStatement pstmtSelectSwiftCount = conn.prepareStatement(sqlSelectSwiftCount);	PreparedStatement storeDetailInsert = conn.prepareStatement(sqlInsertStoreDetail);	PreparedStatement storeInsert = conn.prepareStatement("INSERT INTO `cloud`.`image_store` (id, uuid, name, image_provider_name, protocol, url, data_center_id, scope, role, parent, total_size, created, removed) values(?, ?, ?, 'NFS', 'nfs', ?, ?, 'ZONE', ?, ?, ?, ?, ?)");	PreparedStatement nfsQuery = conn.prepareStatement("select id, uuid, url, data_center_id, parent, total_size, created, removed from `cloud`.`host` where type = 'SecondaryStorage'");	PreparedStatement pstmtUpdateHostAsRemoved = conn.prepareStatement(sqlUpdateHostAsRemoved);	ResultSet rsSelectS3Count = pstmtSelectS3Count.executeQuery();	ResultSet rsSelectSwiftCount = pstmtSelectSwiftCount.executeQuery();	ResultSet rsNfs = nfsQuery.executeQuery();	) {	
checking if we need to migrate nfs secondary storage to image store or staging store 

if (rsSelectSwiftCount.next()) {	numRows += rsSelectSwiftCount.getInt(1);	}	if (numRows > 0) {	hasS3orSwift = true;	}	String store_role = "Image";	if (hasS3orSwift) {	store_role = "ImageCache";	}	
migrating nfs secondary storage to store 

storeInsert.setString(7, nfs_parent);	if (nfs_totalsize != null) {	storeInsert.setLong(8, nfs_totalsize);	} else {	storeInsert.setNull(8, Types.BIGINT);	}	storeInsert.setDate(9, nfs_created);	storeInsert.setDate(10, nfs_removed);	storeInsert.executeUpdate();	}	
marking nfs secondary storage in host table as removed 

storeInsert.setDate(9, nfs_created);	storeInsert.setDate(10, nfs_removed);	storeInsert.executeUpdate();	}	pstmtUpdateHostAsRemoved.executeUpdate();	} catch (SQLException e) {	String msg = "Unable to migrate secondary storages." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	
completed migrating secondary storage to image store 

private void migrateVolumeHostRef(Connection conn) {	
updating volume store ref table from volume host ref table 

private void migrateVolumeHostRef(Connection conn) {	try(PreparedStatement volStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`volume_store_ref` (store_id,  volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, update_count, ref_cnt, state) select host_id, volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, 0, 0, 'Allocated' from `cloud`.`volume_host_ref`");) {	int rowCount = volStoreInsert.executeUpdate();	
insert modified rows 

private void migrateVolumeHostRef(Connection conn) {	try(PreparedStatement volStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`volume_store_ref` (store_id,  volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, update_count, ref_cnt, state) select host_id, volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, 0, 0, 'Allocated' from `cloud`.`volume_host_ref`");) {	int rowCount = volStoreInsert.executeUpdate();	try(PreparedStatement volStoreUpdate = conn.prepareStatement("update `cloud`.`volume_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = volStoreUpdate.executeUpdate();	
update modified rows 

private void migrateVolumeHostRef(Connection conn) {	try(PreparedStatement volStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`volume_store_ref` (store_id,  volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, update_count, ref_cnt, state) select host_id, volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, 0, 0, 'Allocated' from `cloud`.`volume_host_ref`");) {	int rowCount = volStoreInsert.executeUpdate();	try(PreparedStatement volStoreUpdate = conn.prepareStatement("update `cloud`.`volume_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = volStoreUpdate.executeUpdate();	}catch (SQLException e) {	
unable to migrate volume host ref 

private void migrateVolumeHostRef(Connection conn) {	try(PreparedStatement volStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`volume_store_ref` (store_id,  volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, update_count, ref_cnt, state) select host_id, volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, 0, 0, 'Allocated' from `cloud`.`volume_host_ref`");) {	int rowCount = volStoreInsert.executeUpdate();	try(PreparedStatement volStoreUpdate = conn.prepareStatement("update `cloud`.`volume_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = volStoreUpdate.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate volume_host_ref." + e.getMessage(),e);	}	} catch (SQLException e) {	
unable to migrate volume host ref 

try(PreparedStatement volStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`volume_store_ref` (store_id,  volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, update_count, ref_cnt, state) select host_id, volume_id, zone_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, checksum, error_str, local_path, install_path, url, destroyed, 0, 0, 'Allocated' from `cloud`.`volume_host_ref`");) {	int rowCount = volStoreInsert.executeUpdate();	try(PreparedStatement volStoreUpdate = conn.prepareStatement("update `cloud`.`volume_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = volStoreUpdate.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate volume_host_ref." + e.getMessage(),e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate volume_host_ref." + e.getMessage(),e);	}	
completed updating volume store ref table from volume host ref table 

private void migrateTemplateHostRef(Connection conn) {	
updating template store ref table from template host ref table 

private void migrateTemplateHostRef(Connection conn) {	try (PreparedStatement tmplStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, update_count, ref_cnt, store_role, state) select host_id, template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, 0, 0, 'Image', 'Allocated' from `cloud`.`template_host_ref`");) {	int rowCount = tmplStoreInsert.executeUpdate();	
insert modified rows 

private void migrateTemplateHostRef(Connection conn) {	try (PreparedStatement tmplStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, update_count, ref_cnt, store_role, state) select host_id, template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, 0, 0, 'Image', 'Allocated' from `cloud`.`template_host_ref`");) {	int rowCount = tmplStoreInsert.executeUpdate();	try(PreparedStatement tmplStoreUpdate = conn.prepareStatement("update `cloud`.`template_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = tmplStoreUpdate.executeUpdate();	}catch (SQLException e) {	
unable to migrate template host ref 

private void migrateTemplateHostRef(Connection conn) {	try (PreparedStatement tmplStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, update_count, ref_cnt, store_role, state) select host_id, template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, 0, 0, 'Image', 'Allocated' from `cloud`.`template_host_ref`");) {	int rowCount = tmplStoreInsert.executeUpdate();	try(PreparedStatement tmplStoreUpdate = conn.prepareStatement("update `cloud`.`template_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = tmplStoreUpdate.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_host_ref." + e.getMessage(), e);	}	
update modified rows 

private void migrateTemplateHostRef(Connection conn) {	try (PreparedStatement tmplStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, update_count, ref_cnt, store_role, state) select host_id, template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, 0, 0, 'Image', 'Allocated' from `cloud`.`template_host_ref`");) {	int rowCount = tmplStoreInsert.executeUpdate();	try(PreparedStatement tmplStoreUpdate = conn.prepareStatement("update `cloud`.`template_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = tmplStoreUpdate.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_host_ref." + e.getMessage(), e);	}	} catch (SQLException e) {	
unable to migrate template host ref 

try (PreparedStatement tmplStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, update_count, ref_cnt, store_role, state) select host_id, template_id, created, last_updated, job_id, download_pct, size, physical_size, download_state, error_str, local_path, install_path, url, destroyed, is_copy, 0, 0, 'Image', 'Allocated' from `cloud`.`template_host_ref`");) {	int rowCount = tmplStoreInsert.executeUpdate();	try(PreparedStatement tmplStoreUpdate = conn.prepareStatement("update `cloud`.`template_store_ref` set state = 'Ready' where download_state = 'DOWNLOADED'");) {	rowCount = tmplStoreUpdate.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_host_ref." + e.getMessage(), e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_host_ref." + e.getMessage(), e);	}	
completed updating template store ref table from template host ref table 

private void migrateSnapshotStoreRef(Connection conn) {	
updating snapshot store ref table from snapshots table 

private void migrateSnapshotStoreRef(Connection conn) {	try(PreparedStatement snapshotStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, CONCAT('snapshots', '/', account_id, '/', volume_id, '/', backup_snap_id), volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type <> 'KVM' and sechost_id is not null and removed is null");	) {	int rowCount = snapshotStoreInsert.executeUpdate();	
inserted snapshots into snapshot store ref 

private void migrateSnapshotStoreRef(Connection conn) {	try(PreparedStatement snapshotStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, CONCAT('snapshots', '/', account_id, '/', volume_id, '/', backup_snap_id), volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type <> 'KVM' and sechost_id is not null and removed is null");	) {	int rowCount = snapshotStoreInsert.executeUpdate();	try(PreparedStatement snapshotStoreInsert_2 = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, backup_snap_id, volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type = 'KVM' and sechost_id is not null and removed is null");) {	rowCount = snapshotStoreInsert_2.executeUpdate();	
inserted kvm snapshots into snapshot store ref 

private void migrateSnapshotStoreRef(Connection conn) {	try(PreparedStatement snapshotStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, CONCAT('snapshots', '/', account_id, '/', volume_id, '/', backup_snap_id), volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type <> 'KVM' and sechost_id is not null and removed is null");	) {	int rowCount = snapshotStoreInsert.executeUpdate();	try(PreparedStatement snapshotStoreInsert_2 = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, backup_snap_id, volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type = 'KVM' and sechost_id is not null and removed is null");) {	rowCount = snapshotStoreInsert_2.executeUpdate();	}catch (SQLException e) {	
unable to migrate snapshot store ref 

private void migrateSnapshotStoreRef(Connection conn) {	try(PreparedStatement snapshotStoreInsert = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, CONCAT('snapshots', '/', account_id, '/', volume_id, '/', backup_snap_id), volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type <> 'KVM' and sechost_id is not null and removed is null");	) {	int rowCount = snapshotStoreInsert.executeUpdate();	try(PreparedStatement snapshotStoreInsert_2 = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, backup_snap_id, volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type = 'KVM' and sechost_id is not null and removed is null");) {	rowCount = snapshotStoreInsert_2.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate snapshot_store_ref." + e.getMessage(),e);	}	} catch (SQLException e) {	
unable to migrate snapshot store ref 

) {	int rowCount = snapshotStoreInsert.executeUpdate();	try(PreparedStatement snapshotStoreInsert_2 = conn.prepareStatement("INSERT INTO `cloud`.`snapshot_store_ref` (store_id,  snapshot_id, created, size, parent_snapshot_id, install_path, volume_id, update_count, ref_cnt, store_role, state) select sechost_id, id, created, size, prev_snap_id, backup_snap_id, volume_id, 0, 0, 'Image', 'Ready' from `cloud`.`snapshots` where status = 'BackedUp' and hypervisor_type = 'KVM' and sechost_id is not null and removed is null");) {	rowCount = snapshotStoreInsert_2.executeUpdate();	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate snapshot_store_ref." + e.getMessage(),e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate snapshot_store_ref." + e.getMessage(),e);	}	
completed updating snapshot store ref table from snapshots table 

private void migrateS3ToImageStore(Connection conn) {	Long storeId = null;	Map<Long, Long> s3_store_id_map = new HashMap<Long, Long>();	
migrating to image store 

storeDetailInsert.setString(3, val);	storeDetailInsert.executeUpdate();	}	s3_store_id_map.put(s3_id, storeId);	}	} catch (SQLException e) {	String msg = "Unable to migrate S3 secondary storages." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	
migrating template ref to template store ref 

storeDetailInsert.executeUpdate();	}	s3_store_id_map.put(s3_id, storeId);	}	} catch (SQLException e) {	String msg = "Unable to migrate S3 secondary storages." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	migrateTemplateS3Ref(conn, s3_store_id_map);	
migrating backedup snapshots to snapshot store ref 

}	s3_store_id_map.put(s3_id, storeId);	}	} catch (SQLException e) {	String msg = "Unable to migrate S3 secondary storages." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	migrateTemplateS3Ref(conn, s3_store_id_map);	migrateSnapshotS3Ref(conn, s3_store_id_map);	
completed migrating secondary storage to image store 

private void migrateTemplateS3Ref(Connection conn, Map<Long, Long> s3StoreMap) {	
updating template store ref table from template ref table 

tmplStoreInsert.setLong(5, s3_psize);	} else {	tmplStoreInsert.setNull(5, Types.BIGINT);	}	String path = "template/tmpl/" + account_id + "/" + s3_tmpl_id;	tmplStoreInsert.setString(6, path);	tmplStoreInsert.setString(7, path);	tmplStoreInsert.executeUpdate();	}	}catch (SQLException e) {	
unable to migrate template ref 

}	String path = "template/tmpl/" + account_id + "/" + s3_tmpl_id;	tmplStoreInsert.setString(6, path);	tmplStoreInsert.setString(7, path);	tmplStoreInsert.executeUpdate();	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_s3_ref." + e.getMessage(),e);	}	}catch (SQLException e) {	
unable to migrate template ref 

tmplStoreInsert.setString(7, path);	tmplStoreInsert.executeUpdate();	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_s3_ref." + e.getMessage(),e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_s3_ref." + e.getMessage(),e);	}	} catch (SQLException e) {	
unable to migrate template ref 

}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_s3_ref." + e.getMessage(),e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_s3_ref." + e.getMessage(),e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate template_s3_ref." + e.getMessage(),e);	}	
completed migrating template ref table 

private void migrateSnapshotS3Ref(Connection conn, Map<Long, Long> s3StoreMap) {	
updating snapshot store ref table from snapshots table for 

if (s3_prev_id != null) {	snapshotStoreInsert.setLong(5, s3_prev_id);	} else {	snapshotStoreInsert.setNull(5, Types.BIGINT);	}	snapshotStoreInsert.setString(6, install_path);	snapshotStoreInsert.setLong(7, s3_vol_id);	snapshotStoreInsert.executeUpdate();	}	}catch (SQLException e) {	
exception 

snapshotStoreInsert.setNull(5, Types.BIGINT);	}	snapshotStoreInsert.setString(6, install_path);	snapshotStoreInsert.setLong(7, s3_vol_id);	snapshotStoreInsert.executeUpdate();	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotS3Ref:Exception:"+e.getMessage(),e);	}	}catch (SQLException e) {	
exception 

snapshotStoreInsert.setLong(7, s3_vol_id);	snapshotStoreInsert.executeUpdate();	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotS3Ref:Exception:"+e.getMessage(),e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotS3Ref:Exception:"+e.getMessage(),e);	}	} catch (SQLException e) {	
unable to migrate backedup snapshots to snapshot store ref 

}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotS3Ref:Exception:"+e.getMessage(),e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotS3Ref:Exception:"+e.getMessage(),e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to migrate s3 backedup snapshots to snapshot_store_ref." + e.getMessage(), e);	}	
completed updating snapshot store ref table from snapshots entries 

private void migrateSwiftToImageStore(Connection conn) {	Long storeId = null;	Map<Long, Long> swift_store_id_map = new HashMap<Long, Long>();	
migrating swift to image store 

storeDetailInsert.setString(3, val);	storeDetailInsert.executeUpdate();	}	swift_store_id_map.put(swift_id, storeId);	}	} catch (SQLException e) {	String msg = "Unable to migrate swift secondary storages." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	
migrating template swift ref to template store ref 

storeDetailInsert.executeUpdate();	}	swift_store_id_map.put(swift_id, storeId);	}	} catch (SQLException e) {	String msg = "Unable to migrate swift secondary storages." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	migrateTemplateSwiftRef(conn, swift_store_id_map);	
migrating swift backedup snapshots to snapshot store ref 

}	swift_store_id_map.put(swift_id, storeId);	}	} catch (SQLException e) {	String msg = "Unable to migrate swift secondary storages." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	migrateTemplateSwiftRef(conn, swift_store_id_map);	migrateSnapshotSwiftRef(conn, swift_store_id_map);	
completed migrating swift secondary storage to image store 

private void migrateTemplateSwiftRef(Connection conn, Map<Long, Long> swiftStoreMap) {	
updating template store ref table from template swift ref table 

}	tmplStoreInsert.setString(6, path);	tmplStoreInsert.setString(7, path);	tmplStoreInsert.executeUpdate();	}	} catch (SQLException e) {	String msg = "Unable to migrate template_swift_ref." + e.getMessage();	s_logger.error(msg);	throw new CloudRuntimeException(msg, e);	}	
completed migrating template swift ref table 

private void migrateSnapshotSwiftRef(Connection conn, Map<Long, Long> swiftStoreMap) {	
updating snapshot store ref table from snapshots table for swift 

snapshotStoreInsert.setLong(1, swiftStoreMap.get(swift_id));	snapshotStoreInsert.setLong(2, snapshot_id);	snapshotStoreInsert.setDate(3, created);	snapshotStoreInsert.setLong(4, size);	snapshotStoreInsert.setLong(5, prev_id);	snapshotStoreInsert.setString(6, install_path);	snapshotStoreInsert.setLong(7, vol_id);	snapshotStoreInsert.executeUpdate();	}	}catch (SQLException e) {	
migratesnapshotswiftref exception 

snapshotStoreInsert.setLong(4, size);	snapshotStoreInsert.setLong(5, prev_id);	snapshotStoreInsert.setString(6, install_path);	snapshotStoreInsert.setLong(7, vol_id);	snapshotStoreInsert.executeUpdate();	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotSwiftRef:Exception:"+e.getMessage(),e);	}	}catch (SQLException e) {	
migratesnapshotswiftref exception 

snapshotStoreInsert.setLong(7, vol_id);	snapshotStoreInsert.executeUpdate();	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotSwiftRef:Exception:"+e.getMessage(),e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotSwiftRef:Exception:"+e.getMessage(),e);	}	} catch (SQLException e) {	
migratesnapshotswiftref exception 

}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotSwiftRef:Exception:"+e.getMessage(),e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotSwiftRef:Exception:"+e.getMessage(),e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("migrateSnapshotSwiftRef:Exception:"+e.getMessage(),e);	}	
completed updating snapshot store ref table from swift snapshots entries 

private void fixNiciraKeys(Connection conn) {	List<String> keys = new ArrayList<String>();	
dropping foreign key fk nicira nvp nic map nic from the table nicira nvp nic map if it exists 

private void fixNiciraKeys(Connection conn) {	List<String> keys = new ArrayList<String>();	keys.add("fk_nicira_nvp_nic_map__nic");	DbUpgradeUtils.dropKeysIfExist(conn, "nicira_nvp_nic_map", keys, true);	try(PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`nicira_nvp_nic_map` ADD CONSTRAINT `fk_nicira_nvp_nic_map__nic` FOREIGN KEY (`nic`) REFERENCES `nics` (`uuid`) ON DELETE CASCADE");) {	pstmt.executeUpdate();	
added foreign key fk nicira nvp nic map nic to the table nicira nvp nic map 

private void fixRouterKeys(Connection conn) {	List<String> keys = new ArrayList<String>();	
dropping foreign key fk router network ref router id from the table router network ref if it exists 

private void fixRouterKeys(Connection conn) {	List<String> keys = new ArrayList<String>();	keys.add("fk_router_network_ref__router_id");	DbUpgradeUtils.dropKeysIfExist(conn, "router_network_ref", keys, true);	try (PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`router_network_ref` ADD CONSTRAINT `fk_router_network_ref__router_id` FOREIGN KEY (`router_id`) REFERENCES `domain_router` (`id`) ON DELETE CASCADE");) {	pstmt.executeUpdate();	
added foreign key fk router network ref router id to the table router network ref 

private void encryptSite2SitePSK(Connection conn) {	
encrypting customer gateway pre shared key 

}	}	}catch (SQLException e) {	throw new CloudRuntimeException("encryptSite2SitePSK:Exception:"+e.getMessage(), e);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to encrypt Site2Site Customer Gateway pre-shared key ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable to encrypt Site2Site Customer Gateway pre-shared key ", e);	}	
done encrypting customer gateway pre shared key 

private void migrateDatafromIsoIdInVolumesTable(Connection conn) {	try(PreparedStatement pstmt = conn.prepareStatement("SELECT iso_id1 From `cloud`.`volumes`");) {	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	try(PreparedStatement alter_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`volumes` DROP COLUMN `iso_id`");) {	alter_pstmt.executeUpdate();	try(PreparedStatement alter_iso_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`volumes` CHANGE COLUMN `iso_id1` `iso_id` bigint(20) unsigned COMMENT 'The id of the iso from which the volume was created'");) {	alter_iso_pstmt.executeUpdate();	}catch (SQLException e) {	
migratedatafromisoidinvolumestable exception 

try(PreparedStatement pstmt = conn.prepareStatement("SELECT iso_id1 From `cloud`.`volumes`");) {	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	try(PreparedStatement alter_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`volumes` DROP COLUMN `iso_id`");) {	alter_pstmt.executeUpdate();	try(PreparedStatement alter_iso_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`volumes` CHANGE COLUMN `iso_id1` `iso_id` bigint(20) unsigned COMMENT 'The id of the iso from which the volume was created'");) {	alter_iso_pstmt.executeUpdate();	}catch (SQLException e) {	}	}catch (SQLException e) {	
migratedatafromisoidinvolumestable exception 

try(PreparedStatement alter_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`volumes` DROP COLUMN `iso_id`");) {	alter_pstmt.executeUpdate();	try(PreparedStatement alter_iso_pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`volumes` CHANGE COLUMN `iso_id1` `iso_id` bigint(20) unsigned COMMENT 'The id of the iso from which the volume was created'");) {	alter_iso_pstmt.executeUpdate();	}catch (SQLException e) {	}	}catch (SQLException e) {	}	}	}catch (SQLException e) {	
migratedatafromisoidinvolumestable exception 

protected void setRAWformatForRBDVolumes(Connection conn) {	try(PreparedStatement pstmt = conn.prepareStatement("UPDATE volumes SET format = 'RAW' WHERE pool_id IN(SELECT id FROM storage_pool WHERE pool_type = 'RBD')");) {	
setting format to raw for all volumes on rbd primary storage pools 

private void upgradeVpcServiceMap(Connection conn) {	
upgrading vpc service map 

} catch (SQLException e) {	throw new CloudRuntimeException("Error during VPC service map upgrade", e);	}	}	}catch (SQLException e) {	throw new CloudRuntimeException("Error during VPC service map upgrade", e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Error during VPC service map upgrade", e);	}	
upgraded service map for vpc 

private void upgradeResourceCount(Connection conn) {	
upgraderesourcecount start 

long resource_count = sel_dom_res.getLong(2);	upgradeResourceCountforDomain(conn, domain_id, resource_type, resource_count);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to upgrade resource count (cpu,memory,primary_storage,secondary_storage) ", e);	}	}catch (SQLException e) {	throw new CloudRuntimeException("Unable to upgrade resource count (cpu,memory,primary_storage,secondary_storage) ", e);	}	}	
upgraderesourcecount finish 

========================= cloudstack sample_4190 =========================

selenium.select("add_template_zone", "label=" + template_zone);	String template_os_type = System.getProperty("add_template_os_type", "CentOS 5.3 (32-bit)");	selenium.select("add_template_os_type", "label=" + template_os_type);	selenium.click(" Thread.sleep(3000);	int i = 1;	try {	for (;; i++) {	System.out.println("i=   " + i);	selenium.click(" }	} catch (Exception ex) {	
ignored error during clicking test on template 

for (;; i++) {	System.out.println("i=   " + i);	selenium.click(" }	} catch (Exception ex) {	}	for (int second = 0;; second++) {	if (second >= 60) fail("timeout");	try {	if (selenium.isVisible(" break;	} catch (Exception e) {	
ignored error during visibility test of template 

selenium.click(" Thread.sleep(3000);	selenium.click(" Thread.sleep(3000);	}	}	selenium.click("link=Delete Template");	selenium.click(" for (int second = 0;; second++) {	if (second >= 60) fail("timeout");	try {	if (selenium.isVisible("after_action_info_container_on_top")) break;	} catch (Exception e) {	
ignored error checking visibility after test completion for template 

========================= cloudstack sample_430 =========================

public void handle(HttpExchange t) throws IOException {	try {	
ajaximagehandler 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	
process time ms 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IOException e) {	throw e;	} catch (IllegalArgumentException e) {	
exception 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IOException e) {	throw e;	} catch (IllegalArgumentException e) {	t.sendResponseHeaders(400, -1);	} catch (OutOfMemoryError e) {	
unrecoverable outofmemory error exit and let it be re launched 

try {	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IOException e) {	throw e;	} catch (IllegalArgumentException e) {	t.sendResponseHeaders(400, -1);	} catch (OutOfMemoryError e) {	System.exit(1);	} catch (Throwable e) {	
unexpected exception 

String h = queryMap.get("h");	int key = 0;	int width = 144;	int height = 110;	if (tag == null) tag = "";	int port;	if (host == null || portStr == null || sid == null) throw new IllegalArgumentException();	try {	port = Integer.parseInt(portStr);	} catch (NumberFormatException e) {	
invalid numeric parameter in query string 

try {	port = Integer.parseInt(portStr);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	try {	if (keyStr != null) key = Integer.parseInt(keyStr);	if (null != w) width = Integer.parseInt(w);	if (null != h) height = Integer.parseInt(h);	} catch (NumberFormatException e) {	
invalid numeric parameter in query string 

Headers hds = t.getResponseHeaders();	hds.set("Content-Type", "image/jpeg");	t.sendResponseHeaders(200, img.length);	OutputStream os = t.getResponseBody();	try {	os.write(img, 0, img.length);	} finally {	os.close();	}	} else {	
image has already been swept out key 

========================= cloudstack sample_5001 =========================

String sqlUpdateConfig = "UPDATE `cloud`.`configuration` SET value=? WHERE name='router.ram.size' AND category='Hidden'";	try (PreparedStatement updatePstmt = conn.prepareStatement(sqlUpdateConfig);){	String encryptedValue = DBEncryptionUtil.encrypt("256");	updatePstmt.setBytes(1, encryptedValue.getBytes("UTF-8"));	updatePstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to upgrade max ram size of router in config.", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt configuration values ", e);	}	
done updating router ram size config to 

) {	if(selectResultSet.next()) {	serviceOfferingId = selectResultSet.getLong("id");	}	updatePstmt.setInt(1, newRamSize);	updatePstmt.setLong(2, serviceOfferingId);	updatePstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to upgrade ram_size of service offering for domain router. ", e);	}	
done upgrading ram for service offering of domain router to 

ResultSet selectResultSet = selectPstmt.executeQuery()){	if(selectResultSet.next()) {	serviceOfferingId = selectResultSet.getLong("id");	}	updatePstmt.setInt(1, newRamSize);	updatePstmt.setLong(2, serviceOfferingId);	updatePstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to upgrade ram_size of service offering for internal loadbalancer vm. ", e);	}	
done upgrading ram for service offering of internal loadbalancer vm to 

private void dropInvalidKeyFromStoragePoolTable(Connection conn) {	HashMap<String, List<String>> uniqueKeys = new HashMap<String, List<String>>();	List<String> keys = new ArrayList<String>();	keys.add("id_2");	uniqueKeys.put("storage_pool", keys);	
dropping id key from storage pool table 

private void dropDuplicatedForeignKeyFromAsyncJobTable(Connection conn) {	HashMap<String, List<String>> foreignKeys = new HashMap<String, List<String>>();	List<String> keys = new ArrayList<String>();	keys.add("fk_async_job_join_map__join_job_id");	foreignKeys.put("async_job_join_map", keys);	
dropping fk async job join map join job id key from async job join map table 

========================= cloudstack sample_4240 =========================

public void testCreateGlobalLoadBalancerRule() throws Exception {	
running tests for creategloballoadbalancerrule service api 

public void testAssignToGlobalLoadBalancerRule() throws Exception {	
running tests for assigntogloballoadbalancerrule service api 

public void testRemoveFromGlobalLoadBalancerRule() throws Exception {	
running tests for removefromgloballoadbalancerrule service api 

public void testDeleteGlobalLoadBalancerRule() throws Exception {	
running tests for deletegloballoadbalancerrule service api 

========================= cloudstack sample_2117 =========================

public static boolean cifsCredentialsPresent(URI uri) {	List<NameValuePair> args = URLEncodedUtils.parse(uri, "UTF-8");	boolean foundUser = false;	boolean foundPswd = false;	for (NameValuePair nvp : args) {	String name = nvp.getName();	if (name.equals("user")) {	foundUser = true;	
founduser is 

public static boolean cifsCredentialsPresent(URI uri) {	List<NameValuePair> args = URLEncodedUtils.parse(uri, "UTF-8");	boolean foundUser = false;	boolean foundPswd = false;	for (NameValuePair nvp : args) {	String name = nvp.getName();	if (name.equals("user")) {	foundUser = true;	} else if (name.equals("password")) {	foundPswd = true;	
foundpswd is 

HttpClient httpclient = new HttpClient(new MultiThreadedHttpConnectionManager());	if ((user != null) && (password != null)) {	httpclient.getParams().setAuthenticationPreemptive(true);	Credentials defaultcreds = new UsernamePasswordCredentials(user, password);	httpclient.getState().setCredentials(new AuthScope(hostAndPort.first(), hostAndPort.second(), AuthScope.ANY_REALM), defaultcreds);	s_logger.info("Added username=" + user + ", password=" + password + "for host " + hostAndPort.first() + ":" + hostAndPort.second());	}	GetMethod method = new GetMethod(url);	int statusCode = httpclient.executeMethod(method);	if (statusCode != HttpStatus.SC_OK) {	
failed to read from url 

httpclient.getState().setCredentials(new AuthScope(hostAndPort.first(), hostAndPort.second(), AuthScope.ANY_REALM), defaultcreds);	s_logger.info("Added username=" + user + ", password=" + password + "for host " + hostAndPort.first() + ":" + hostAndPort.second());	}	GetMethod method = new GetMethod(url);	int statusCode = httpclient.executeMethod(method);	if (statusCode != HttpStatus.SC_OK) {	return null;	}	return method.getResponseBodyAsStream();	} catch (Exception ex) {	
failed to read from url 

========================= cloudstack sample_2814 =========================

protected void closeAutoCloseable(AutoCloseable closable) {	if (closable != null) {	try {	closable.close();	} catch (Exception e) {	
ignored 

========================= cloudstack sample_4186 =========================

public List<StoragePool> select(DiskProfile dskCh, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	List<StoragePool> suitablePools = new ArrayList<StoragePool>();	long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	if (podId == null) {	return null;	}	
looking for pools in dc pod cluster 

List<StoragePool> suitablePools = new ArrayList<StoragePool>();	long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	if (podId == null) {	return null;	}	List<StoragePoolVO> pools = _storagePoolDao.listBy(dcId, podId, clusterId, ScopeType.CLUSTER);	if (pools.size() == 0) {	if (s_logger.isDebugEnabled()) {	
no storage pools available for allocation returning 

return null;	}	List<StoragePoolVO> pools = _storagePoolDao.listBy(dcId, podId, clusterId, ScopeType.CLUSTER);	if (pools.size() == 0) {	if (s_logger.isDebugEnabled()) {	}	return suitablePools;	}	Collections.shuffle(pools);	if (s_logger.isDebugEnabled()) {	
randomstoragepoolallocator has pools to check for allocation 

for (StoragePoolVO pool : pools) {	if (suitablePools.size() == returnUpTo) {	break;	}	StoragePool pol = (StoragePool)this.dataStoreMgr.getPrimaryDataStore(pool.getId());	if (filter(avoid, pol, dskCh, plan)) {	suitablePools.add(pol);	}	}	if (s_logger.isDebugEnabled()) {	
randomstoragepoolallocator returning suitable storage pools 

========================= cloudstack sample_1384 =========================

public static void globalSetUp() throws Exception {	ApiConnectorFactory.setImplementation(ApiConnectorMockito.class);	
mysql server is getting launched 

public static void globalSetUp() throws Exception {	ApiConnectorFactory.setImplementation(ApiConnectorMockito.class);	s_mysqlServerPort = TestDbSetup.init(null);	
mysql server launched on port 

public static void globalTearDown() throws Exception {	s_lockMaster.cleanupForServer(s_msId);	JmxUtil.unregisterMBean("Locks", "Locks");	s_lockMaster = null;	AbstractApplicationContext ctx = (AbstractApplicationContext)ComponentContext.getApplicationContext();	Map<String, ComponentLifecycle> lifecycleComponents = ctx.getBeansOfType(ComponentLifecycle.class);	for (ComponentLifecycle bean : lifecycleComponents.values()) {	bean.stop();	}	ctx.close();	
destroying mysql server instance running at port 

========================= cloudstack sample_1853 =========================

}	final StartupRoutingCommand defaultStartRoutCmd = new StartupRoutingCommand(0, 0, 0, 0, null, Hypervisor.HypervisorType.Hyperv, RouterPrivateIpStrategy.HostLocal);	defaultStartRoutCmd.setDataCenter(_zoneId);	defaultStartRoutCmd.setPod(_podId);	defaultStartRoutCmd.setCluster(_clusterId);	defaultStartRoutCmd.setGuid(_guid);	defaultStartRoutCmd.setName(_name);	defaultStartRoutCmd.setPrivateIpAddress(_agentIp);	defaultStartRoutCmd.setStorageIpAddress(_agentIp);	defaultStartRoutCmd.setPool(_clusterGuid);	
generated startuproutingcommand for agentip agentip 

}	StartupStorageCommand storePoolCmd = null;	if (startCmds.length > 1) {	storePoolCmd = (StartupStorageCommand)startCmds[1];	if (storePoolCmd == null) {	final String frmtStr = "Host %s (IP %s) sent incorrect Command, " + "second parameter should be a " + "StartupStorageCommand";	final String errMsg = String.format(frmtStr, _name, _agentIp);	s_logger.error(errMsg);	return null;	}	
host ip already configured with a storeage pool details 

StartupStorageCommand storePoolCmd = null;	if (startCmds.length > 1) {	storePoolCmd = (StartupStorageCommand)startCmds[1];	if (storePoolCmd == null) {	final String frmtStr = "Host %s (IP %s) sent incorrect Command, " + "second parameter should be a " + "StartupStorageCommand";	final String errMsg = String.format(frmtStr, _name, _agentIp);	s_logger.error(errMsg);	return null;	}	} else {	
host ip already configured with a storeage pool details 

public final PingCommand getCurrentStatus(final long id) {	final PingCommand pingCmd = new PingRoutingCommand(getType(), id, getHostVmStateReport());	if (s_logger.isDebugEnabled()) {	
ping host ip 

public final PingCommand getCurrentStatus(final long id) {	final PingCommand pingCmd = new PingRoutingCommand(getType(), id, getHostVmStateReport());	if (s_logger.isDebugEnabled()) {	}	final Answer pingAns = executeRequest(pingCmd);	if (pingAns == null || !pingAns.getResult()) {	
cannot ping host ip pingans blank means null is 

return null;	}	ArrayList<Map<String, String>> result = null;	try {	result = s_gson.fromJson(incomingCmd, new TypeToken<ArrayList<HashMap<String, String>>>() {	}.getType());	} catch (final Exception ex) {	final String errMsg = "Failed to deserialize Command[] " + incomingCmd;	s_logger.error(errMsg, ex);	}	
hostvmstatereportcommand received response 

if (incomingCmd == null) {	return null;	}	Command[] result = null;	try {	result = s_gson.fromJson(incomingCmd, Command[].class);	} catch (final Exception ex) {	final String errMsg = "Failed to deserialize Command[] " + incomingCmd;	s_logger.error(errMsg, ex);	}	
requeststartupcommand received response 

else {	if (clazz == StartCommand.class) {	final VirtualMachineTO vmSpec = ((StartCommand)cmd).getVirtualMachine();	if (vmSpec.getType() != VirtualMachine.Type.User) {	if (s_hypervMgr != null) {	final String secondary = s_hypervMgr.prepareSecondaryStorageStore(Long.parseLong(_zoneId));	if (secondary != null) {	((StartCommand)cmd).setSecondaryStorage(secondary);	}	} else {	
hyperv manager isn t available couldn t check and copy the systemvm iso 

} else {	}	}	}	final String ansStr = postHttpRequest(s_gson.toJson(cmd), agentUri);	if (ansStr == null) {	return Answer.createUnsupportedCommandAnswer(cmd);	}	final Answer[] result = s_gson.fromJson(ansStr, Answer[].class);	final String logResult = cleanPassword(s_gson.toJson(result));	
executerequest received response 

return null;	}	cleanPassword(cmd.getSrcTO().getDataStore());	cleanPassword(cmd.getDestTO().getDataStore());	final String ansStr = postHttpRequest(s_gson.toJson(cmd), agentUri);	if (ansStr == null) {	return Answer.createUnsupportedCommandAnswer(cmd);	}	final Answer[] result = s_gson.fromJson(ansStr, Answer[].class);	final String logResult = cleanPassword(s_gson.toJson(result));	
executerequest received response 

private PlugNicAnswer execute(final PlugNicCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource plugniccommand 

int publicNicInfo = -1;	publicNicInfo = getVmFreeNicIndex(vmName);	if (publicNicInfo > 0) {	modifyNicVlan(vmName, vlanId, publicNicInfo, true, cmd.getNic().getName());	return new PlugNicAnswer(cmd, true, "success");	}	final String msg = " Plug Nic failed for the vm as it has reached max limit of NICs to be added";	s_logger.warn(msg);	return new PlugNicAnswer(cmd, false, msg);	} catch (final Exception e) {	
unexpected exception 

private UnPlugNicAnswer execute(final UnPlugNicCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource unplugniccommand 

throw new InternalErrorException("Unable to unassign a public IP to a VIF on network " + nic.getBroadcastUri());	}	final String vlanId = BroadcastDomainType.getValue(broadcastUri);	int publicNicInfo = -1;	publicNicInfo = getVmNics(vmName, vlanId);	if (publicNicInfo > 0) {	modifyNicVlan(vmName, "2", publicNicInfo, false, "");	}	return new UnPlugNicAnswer(cmd, true, "success");	} catch (final Exception e) {	
unexpected exception 

public ExecutionResult executeInVR(final String routerIP, final String script, final String args, final Duration timeout) {	Pair<Boolean, String> result;	if (s_logger.isDebugEnabled()) {	
run command on vr script with args 

if (s_logger.isDebugEnabled()) {	}	try {	result = SshHelper.sshExecute(routerIP, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/opt/cloud/bin/" + script + " " + args, VRScripts.CONNECTION_TIMEOUT, VRScripts.CONNECTION_TIMEOUT, timeout);	} catch (final Exception e) {	final String msg = "Command failed due to " + e ;	s_logger.error(msg);	result = new Pair<Boolean, String>(false, msg);	}	if (s_logger.isDebugEnabled()) {	
execution result 

public ExecutionResult createFileInVR(final String routerIp, final String filePath, final String fileName, final String content) {	final File keyFile = getSystemVMKeyFile();	try {	SshHelper.scpTo(routerIp, 3922, "root", keyFile, null, filePath, content.getBytes(Charset.forName("UTF-8")), fileName, null);	} catch (final Exception e) {	
fail to create file in vr 

final URI broadcastUri = BroadcastDomainType.fromString(ip.getBroadcastUri());	if (BroadcastDomainType.getSchemeValue(broadcastUri) != BroadcastDomainType.Vlan) {	throw new InternalErrorException("Unable to assign a public IP to a VIF on network " + ip.getBroadcastUri());	}	final String vlanId = BroadcastDomainType.getValue(broadcastUri);	int publicNicInfo = -1;	publicNicInfo = getVmNics(routerName, vlanId);	boolean addVif = false;	if (ip.isAdd() && publicNicInfo == -1) {	if (s_logger.isDebugEnabled()) {	
plug new nic to associate to 

s_logger.error(msg);	throw new InternalErrorException(msg);	}	ip.setNicDevId(publicNicInfo);	ip.setNewNic(addVif);	} else {	ip.setNicDevId(publicNicInfo);	}	}	} catch (final Throwable e) {	
unexpected exception will shortcut rest of ipassoc commands 

if (BroadcastDomainType.getSchemeValue(broadcastUri) != BroadcastDomainType.Vlan) {	throw new InternalErrorException("Invalid Broadcast URI " + ip.getBroadcastUri());	}	final String vlanId = BroadcastDomainType.getValue(broadcastUri);	int publicNicInfo = -1;	publicNicInfo = getVmNics(routerName, vlanId);	if (publicNicInfo < 0) {	if (ip.isAdd()) {	throw new InternalErrorException("Failed to find DomR VIF to associate/disassociate IP with.");	} else {	
vif to deassociate ip with does not exist return success 

if (publicNicInfo < 0) {	if (ip.isAdd()) {	throw new InternalErrorException("Failed to find DomR VIF to associate/disassociate IP with.");	} else {	continue;	}	}	ip.setNicDevId(publicNicInfo);	}	} catch (final Exception e) {	
prepare ip assoc failure on applying one ip due to exception 

if (cmd.isCreate()) {	argsBuf.append(" -r ").append(cmd.getIpRange()).append(" -p ").append(cmd.getPresharedKey()).append(" -s ").append(cmd.getVpnServerIp()).append(" -l ").append(cmd.getLocalIp()) .append(" -c ");	} else {	argsBuf.append(" -d ").append(" -s ").append(cmd.getVpnServerIp());	}	argsBuf.append(" -C ").append(cmd.getLocalCidr());	argsBuf.append(" -i ").append(cmd.getPublicInterface());	try {	final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.VPN_L2TP, argsBuf.toString());	if (s_logger.isDebugEnabled()) {	
executing 

argsBuf.append(" -d ").append(" -s ").append(cmd.getVpnServerIp());	}	argsBuf.append(" -C ").append(cmd.getLocalCidr());	argsBuf.append(" -i ").append(cmd.getPublicInterface());	try {	final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.VPN_L2TP, argsBuf.toString());	if (s_logger.isDebugEnabled()) {	}	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
remoteaccessvpncfg command on domr failed message 

argsBuf.append(" -i ").append(cmd.getPublicInterface());	try {	final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.VPN_L2TP, argsBuf.toString());	if (s_logger.isDebugEnabled()) {	}	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	return new Answer(cmd, false, "RemoteAccessVpnCfg command failed due to " + result.second());	}	if (s_logger.isInfoEnabled()) {	
remoteaccessvpncfg command on domain router completed 

final String controlIp = getRouterSshControlIp(cmd);	for (final VpnUsersCfgCommand.UsernamePassword userpwd : cmd.getUserpwds()) {	final StringBuffer argsBuf = new StringBuffer();	if (!userpwd.isAdd()) {	argsBuf.append(" -U ").append(userpwd.getUsername());	} else {	argsBuf.append(" -u ").append(userpwd.getUsernamePassword());	}	try {	if (s_logger.isDebugEnabled()) {	
executing opt cloud bin vpn sh 

if (!userpwd.isAdd()) {	argsBuf.append(" -U ").append(userpwd.getUsername());	} else {	argsBuf.append(" -u ").append(userpwd.getUsernamePassword());	}	try {	if (s_logger.isDebugEnabled()) {	}	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/opt/cloud/bin/vpn_l2tp.sh " + argsBuf.toString());	if (!result.first()) {	
vpnusercfg command on domr failed message 

private SetStaticRouteAnswer execute(final SetStaticRouteCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource setstaticroutecommand 

final String[] rules = cmd.generateSRouteRules();	final StringBuilder sb = new StringBuilder();	for (int j = 0; j < rules.length; j++) {	sb.append(rules[j]).append(',');	}	args += " -a " + sb.toString();	final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.VPC_STATIC_ROUTE, args);	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (s_logger.isDebugEnabled()) {	
executing script on domain router opt cloud bin vpc staticroute sh 

for (int j = 0; j < rules.length; j++) {	sb.append(rules[j]).append(',');	}	args += " -a " + sb.toString();	final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.VPC_STATIC_ROUTE, args);	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	
setstaticroutecommand failure on setting one rule args 

final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	results[i++] = "Failed";	endResult = false;	} else {	results[i++] = null;	}	} catch (final Throwable e) {	
setstaticroutecommand args failed on setting one rule due to 

protected CheckS2SVpnConnectionsAnswer execute(final CheckS2SVpnConnectionsCommand cmd) {	final StringBuilder cmdline = new StringBuilder();	cmdline.append("/opt/cloud/bin/");	cmdline.append(VRScripts.S2SVPN_CHECK);	if (s_logger.isDebugEnabled()) {	
executing resource 

protected CheckS2SVpnConnectionsAnswer execute(final CheckS2SVpnConnectionsCommand cmd) {	final StringBuilder cmdline = new StringBuilder();	cmdline.append("/opt/cloud/bin/");	cmdline.append(VRScripts.S2SVPN_CHECK);	if (s_logger.isDebugEnabled()) {	
run command on domr 

}	Pair<Boolean, String> result;	try {	final String controlIp = getRouterSshControlIp(cmd);	for (final String ip : cmd.getVpnIps()) {	cmdline.append(" ");	cmdline.append(ip);	}	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, cmdline.toString());	if (!result.first()) {	
check site to site vpn connections command on domr failed message 

final String controlIp = getRouterSshControlIp(cmd);	for (final String ip : cmd.getVpnIps()) {	cmdline.append(" ");	cmdline.append(ip);	}	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, cmdline.toString());	if (!result.first()) {	return new CheckS2SVpnConnectionsAnswer(cmd, false, result.second());	}	if (s_logger.isDebugEnabled()) {	
check site to site vpn connections command on domain router completed 

protected Answer execute(final Site2SiteVpnCfgCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource 

args += " -n ";	args += cmd.getLocalGuestCidr();	args += " -N ";	args += cmd.getPeerGuestCidrList();	}	Pair<Boolean, String> result;	try {	final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.S2SVPN_IPSEC, args);	result = SshHelper.sshExecute(routerIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
setup vpn failed message 

args += cmd.getPeerGuestCidrList();	}	Pair<Boolean, String> result;	try {	final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.S2SVPN_IPSEC, args);	result = SshHelper.sshExecute(routerIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	return new Answer(cmd, false, "Setup site2site VPN falied due to " + result.second());	}	if (s_logger.isDebugEnabled()) {	
setup site site vpn on router completed 

protected SetSourceNatAnswer execute(final SetSourceNatCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource setsourcenatcommand 

protected Answer execute(final SetPortForwardingRulesCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource setportforwardingrulescommand 

for (final PortForwardingRuleTO rule : cmd.getRules()) {	args += rule.revoked() ? " -D " : " -A ";	args += " -P " + rule.getProtocol().toLowerCase();	args += " -l " + rule.getSrcIp();	args += " -p " + rule.getStringSrcPortRange();	args += " -r " + rule.getDstIp();	args += " -d " + rule.getStringDstPortRange();	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall.sh " + args);	if (s_logger.isDebugEnabled()) {	
executing script on domain router root firewall sh 

args += " -P " + rule.getProtocol().toLowerCase();	args += " -l " + rule.getSrcIp();	args += " -p " + rule.getStringSrcPortRange();	args += " -r " + rule.getDstIp();	args += " -d " + rule.getStringDstPortRange();	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall.sh " + args);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	
setportforwardingrulescommand failure on setting one rule args 

final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall.sh " + args);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	results[i++] = "Failed";	endResult = false;	} else {	results[i++] = null;	}	} catch (final Throwable e) {	
setportforwardingrulescommand args failed on setting one rule due to 

protected Answer execute(final CheckRouterCommand cmd) {	final String command = String.format("%s%s", "/opt/cloud/bin/", VRScripts.RVR_CHECK);	if (s_logger.isDebugEnabled()) {	
executing resource checkroutercommand 

protected Answer execute(final CheckRouterCommand cmd) {	final String command = String.format("%s%s", "/opt/cloud/bin/", VRScripts.RVR_CHECK);	if (s_logger.isDebugEnabled()) {	
run command on domr 

protected Answer execute(final CheckRouterCommand cmd) {	final String command = String.format("%s%s", "/opt/cloud/bin/", VRScripts.RVR_CHECK);	if (s_logger.isDebugEnabled()) {	}	Pair<Boolean, String> result;	try {	final String controlIp = getRouterSshControlIp(cmd);	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
check router command on domr failed message 

if (s_logger.isDebugEnabled()) {	}	Pair<Boolean, String> result;	try {	final String controlIp = getRouterSshControlIp(cmd);	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	return new CheckRouterAnswer(cmd, "CheckRouter failed due to " + result.second());	}	if (s_logger.isDebugEnabled()) {	
check router command on domain router completed 

protected Answer execute(final SetStaticNatRulesCommand cmd) {	if (cmd.getVpcId() != null) {	}	if (s_logger.isInfoEnabled()) {	
executing resource setfirewallrulecommand 

args += " -r " + rule.getDstIp();	if (rule.getProtocol() != null) {	args += " -P " + rule.getProtocol().toLowerCase();	}	args += " -d " + rule.getStringSrcPortRange();	args += " -G ";	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall.sh " + args);	if (s_logger.isDebugEnabled()) {	
executing script on domain router root firewall sh 

args += " -P " + rule.getProtocol().toLowerCase();	}	args += " -d " + rule.getStringSrcPortRange();	args += " -G ";	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall.sh " + args);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	
setstaticnatrulescommand failure on setting one rule args 

final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall.sh " + args);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	results[i++] = "Failed";	endResult = false;	} else {	results[i++] = null;	}	} catch (final Throwable e) {	
setstaticnatrulescommand args failed on setting one rule due to 

protected Answer execute(final PingTestCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource pingtestcommand 

if (s_logger.isInfoEnabled()) {	}	final String controlIp = cmd.getRouterIp();	final String args = " -c 1 -n -q " + cmd.getPrivateIp();	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/bin/ping" + args);	if (result.first()) {	return new Answer(cmd);	}	} catch (final Exception e) {	
unable to execute ping command on domr domr may not be ready yet failure due to 

protected Answer execute(final DeleteIpAliasCommand cmd) {	cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);	final List<IpAliasTO> revokedIpAliasTOs = cmd.getDeleteIpAliasTos();	final List<IpAliasTO> activeIpAliasTOs = cmd.getCreateIpAliasTos();	if (s_logger.isInfoEnabled()) {	
executing deleteipalias command 

args.append("- ");	for (final IpAliasTO ipAliasTO : activeIpAliasTOs) {	args.append(ipAliasTO.getAlias_count());	args.append(":");	args.append(ipAliasTO.getRouterip());	args.append(":");	args.append(ipAliasTO.getNetmask());	args.append("-");	}	if (s_logger.isDebugEnabled()) {	
run command on domr root deleteipalias 

args.append(":");	args.append(ipAliasTO.getNetmask());	args.append("-");	}	if (s_logger.isDebugEnabled()) {	}	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/deleteIpAlias.sh " + args);	if (!result.first()) {	
deleteipalias command on domr failed message 

}	if (s_logger.isDebugEnabled()) {	}	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/deleteIpAlias.sh " + args);	if (!result.first()) {	return new Answer(cmd, false, "deleteIpAlias failed due to " + result.second());	}	if (s_logger.isInfoEnabled()) {	
deleteipalias command on domain router completed 

}	sb = new StringBuilder();	if (statRules.length > 0) {	for (int i = 0; i < statRules.length; i++) {	sb.append(statRules[i]).append(',');	}	args += " -s " + sb.toString();	}	Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "scp " + tmpCfgFilePath + " /etc/haproxy/haproxy.cfg.new");	if (!result.first()) {	
unable to copy haproxy configuration file 

sb.append(statRules[i]).append(',');	}	args += " -s " + sb.toString();	}	Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "scp " + tmpCfgFilePath + " /etc/haproxy/haproxy.cfg.new");	if (!result.first()) {	return new Answer(cmd, false, "LoadBalancerConfigCommand failed due to uanble to copy haproxy configuration file");	}	final String command = String.format("%s%s %s", "/root/", VRScripts.LB, args);	if (s_logger.isDebugEnabled()) {	
run command on domain router 

final String command = String.format("%s%s %s", "/root/", VRScripts.LB, args);	if (s_logger.isDebugEnabled()) {	}	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	final String msg = "LoadBalancerConfigCommand on domain router " + routerIp + " failed. message: " + result.second();	s_logger.error(msg);	return new Answer(cmd, false, msg);	}	if (s_logger.isInfoEnabled()) {	
loadbalancerconfigcommand on domain router completed 

s_logger.error(msg);	return new Answer(cmd, false, msg);	}	if (s_logger.isInfoEnabled()) {	}	} finally {	SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "rm " + tmpCfgFilePath);	}	return new Answer(cmd);	} catch (final Throwable e) {	
unexpected exception 

protected Answer execute(final SavePasswordCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource savepasswordcommand vmname vmip password 

protected Answer execute(final SavePasswordCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	final String controlIp = getRouterSshControlIp(cmd);	final String password = cmd.getPassword();	final String vmIpAddress = cmd.getVmIpAddress();	final String command = String.format("%s%s %s %s %s %s", "/opt/cloud/bin/", VRScripts.PASSWORD, "-v", vmIpAddress, "-p", password);	if (s_logger.isDebugEnabled()) {	final String debugCommand = String.format("%s%s %s %s %s %s", "/opt/cloud/bin/", VRScripts.PASSWORD, "-v", vmIpAddress, "-p", StringUtils.getMaskedPasswordForDisplay(cmd.getPassword()));	
run command on domain router 

final String controlIp = getRouterSshControlIp(cmd);	final String password = cmd.getPassword();	final String vmIpAddress = cmd.getVmIpAddress();	final String command = String.format("%s%s %s %s %s %s", "/opt/cloud/bin/", VRScripts.PASSWORD, "-v", vmIpAddress, "-p", password);	if (s_logger.isDebugEnabled()) {	final String debugCommand = String.format("%s%s %s %s %s %s", "/opt/cloud/bin/", VRScripts.PASSWORD, "-v", vmIpAddress, "-p", StringUtils.getMaskedPasswordForDisplay(cmd.getPassword()));	}	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
savepassword command on domain router failed message 

final String command = String.format("%s%s %s %s %s %s", "/opt/cloud/bin/", VRScripts.PASSWORD, "-v", vmIpAddress, "-p", password);	if (s_logger.isDebugEnabled()) {	final String debugCommand = String.format("%s%s %s %s %s %s", "/opt/cloud/bin/", VRScripts.PASSWORD, "-v", vmIpAddress, "-p", StringUtils.getMaskedPasswordForDisplay(cmd.getPassword()));	}	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	return new Answer(cmd, false, "SavePassword failed due to " + result.second());	}	if (s_logger.isInfoEnabled()) {	
savepassword command on domain router completed 

}	try {	Pair<Boolean, String> result = null;	if (trafficType == FirewallRule.TrafficType.Egress) {	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewallRule_egress.sh " + args);	} else {	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall_rule.sh " + args);	}	if (s_logger.isDebugEnabled()) {	if (trafficType == FirewallRule.TrafficType.Egress) {	
executing script on domain router root firewallrule egress sh 

try {	Pair<Boolean, String> result = null;	if (trafficType == FirewallRule.TrafficType.Egress) {	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewallRule_egress.sh " + args);	} else {	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall_rule.sh " + args);	}	if (s_logger.isDebugEnabled()) {	if (trafficType == FirewallRule.TrafficType.Egress) {	} else {	
executing script on domain router root firewall rule sh 

result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewallRule_egress.sh " + args);	} else {	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/firewall_rule.sh " + args);	}	if (s_logger.isDebugEnabled()) {	if (trafficType == FirewallRule.TrafficType.Egress) {	} else {	}	}	if (!result.first()) {	
setfirewallrulescommand failure on setting one rule args 

} else {	}	}	if (!result.first()) {	for (int i = 0; i < results.length; i++) {	results[i] = "Failed";	}	return new SetFirewallRulesAnswer(cmd, false, results);	}	} catch (final Throwable e) {	
setfirewallrulescommand args failed on setting one rule due to 

protected Answer execute(final VmDataCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource vmdatacommand 

protected Answer execute(final VmDataCommand cmd) {	if (s_logger.isInfoEnabled()) {	}	final String controlIp = getRouterSshControlIp(cmd);	final Map<String, List<String[]>> data = new HashMap<String, List<String[]>>();	data.put(cmd.getVmIpAddress(), cmd.getVmData());	String json = new Gson().toJson(data);	
vm data json is 

}	final String controlIp = getRouterSshControlIp(cmd);	final Map<String, List<String[]>> data = new HashMap<String, List<String[]>>();	data.put(cmd.getVmIpAddress(), cmd.getVmData());	String json = new Gson().toJson(data);	json = Base64.encodeBase64String(json.getBytes(Charset.forName("UTF-8")));	final String command = String.format("%s%s %s %s", "/opt/cloud/bin/", VRScripts.VMDATA, "-d", json);	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
vm data command on domain router failed messge 

data.put(cmd.getVmIpAddress(), cmd.getVmData());	String json = new Gson().toJson(data);	json = Base64.encodeBase64String(json.getBytes(Charset.forName("UTF-8")));	final String command = String.format("%s%s %s %s", "/opt/cloud/bin/", VRScripts.VMDATA, "-d", json);	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	return new Answer(cmd, false, "VmDataCommand failed due to " + result.second());	}	if (s_logger.isInfoEnabled()) {	
vm data command on domain router completed 

protected Answer execute(final DhcpEntryCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource dhcpentrycommand 

}	if (cmd.getVmIp6Address() != null) {	args += " -6 " + cmd.getVmIp6Address();	args += " -u " + cmd.getDuid();	}	if (!cmd.isDefault()) {	args += " -N";	}	final String command = String.format("%s%s %s", "/root/", VRScripts.DHCP, args);	if (s_logger.isDebugEnabled()) {	
run command on domr 

if (!cmd.isDefault()) {	args += " -N";	}	final String command = String.format("%s%s %s", "/root/", VRScripts.DHCP, args);	if (s_logger.isDebugEnabled()) {	}	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
dhcp entry command on domr failed message 

final String command = String.format("%s%s %s", "/root/", VRScripts.DHCP, args);	if (s_logger.isDebugEnabled()) {	}	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	return new Answer(cmd, false, "DhcpEntry failed due to " + result.second());	}	if (s_logger.isInfoEnabled()) {	
dhcp entry command on domain router completed 

protected Answer execute(final CreateIpAliasCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing createipalias command 

final StringBuilder args = new StringBuilder();	for (final IpAliasTO ipaliasto : ipAliasTOs) {	args.append(ipaliasto.getAlias_count());	args.append(":");	args.append(ipaliasto.getRouterip());	args.append(":");	args.append(ipaliasto.getNetmask());	args.append("-");	}	if (s_logger.isDebugEnabled()) {	
run command on domr root createipalias 

args.append(":");	args.append(ipaliasto.getNetmask());	args.append("-");	}	if (s_logger.isDebugEnabled()) {	}	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/createIpAlias.sh " + args);	if (!result.first()) {	
createipalias command on domr failed message 

}	if (s_logger.isDebugEnabled()) {	}	try {	final String controlIp = getRouterSshControlIp(cmd);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/root/createIpAlias.sh " + args);	if (!result.first()) {	return new Answer(cmd, false, "createipAlias failed due to " + result.second());	}	if (s_logger.isInfoEnabled()) {	
createipalias command on domain router completed 

protected Answer execute(final DnsMasqConfigCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing dnsmasqconfig command 

args.append(":");	args.append(dhcpTo.getNetmask());	args.append(":");	args.append(dhcpTo.getStartIpOfSubnet());	args.append("-");	}	try {	final String command = String.format("%s%s %s", "/root/", VRScripts.DHCP, args);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (s_logger.isDebugEnabled()) {	
run command on domain router root dnsmasq sh 

args.append(":");	args.append(dhcpTo.getStartIpOfSubnet());	args.append("-");	}	try {	final String command = String.format("%s%s %s", "/root/", VRScripts.DHCP, args);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	
unable update dnsmasq config file 

}	try {	final String command = String.format("%s%s %s", "/root/", VRScripts.DHCP, args);	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (s_logger.isDebugEnabled()) {	}	if (!result.first()) {	return new Answer(cmd, false, "dnsmasq config update failed due to: " + result.second());	}	if (s_logger.isDebugEnabled()) {	
dnsmasq config command on domain router completed 

private int findRouterEthDeviceIndex(final String domrName, final String routerIp, final String mac) throws Exception {	
findrouterethdeviceindex mac 

private int findRouterEthDeviceIndex(final String domrName, final String routerIp, final String mac) throws Exception {	final Pair<Boolean, String> result = SshHelper.sshExecute(routerIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "ls /proc/sys/net/ipv4/conf");	final long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick < 15000) {	if (result.first()) {	final String[] tokens = result.second().split("\\s+");	for (final String token : tokens) {	if (!("all".equalsIgnoreCase(token) || "default".equalsIgnoreCase(token) || "lo".equalsIgnoreCase(token))) {	final String cmd = String.format("ip address show %s | grep link if (s_logger.isDebugEnabled()) {	
run domr script 

final long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick < 15000) {	if (result.first()) {	final String[] tokens = result.second().split("\\s+");	for (final String token : tokens) {	if (!("all".equalsIgnoreCase(token) || "default".equalsIgnoreCase(token) || "lo".equalsIgnoreCase(token))) {	final String cmd = String.format("ip address show %s | grep link if (s_logger.isDebugEnabled()) {	}	final Pair<Boolean, String> result2 = SshHelper.sshExecute(routerIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, cmd);	if (s_logger.isDebugEnabled()) {	
result output 

}	final Pair<Boolean, String> result2 = SshHelper.sshExecute(routerIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, cmd);	if (s_logger.isDebugEnabled()) {	}	if (result2.first() && result2.second().trim().equalsIgnoreCase(mac.trim())) {	return Integer.parseInt(token.substring(3));	}	}	}	}	
can not find intereface associated with mac guest os may still at loading state retry 

private Pair<Integer, String> findRouterFreeEthDeviceIndex(final String routerIp) throws Exception {	
findrouterfreeethdeviceindex mac 

private Pair<Integer, String> findRouterFreeEthDeviceIndex(final String routerIp) throws Exception {	final Pair<Boolean, String> result = SshHelper.sshExecute(routerIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "ip address | grep DOWN| cut -f2 -d :");	final long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick < 15000) {	if (result.first() && !result.second().isEmpty()) {	final String[] tokens = result.second().split("\\n");	for (final String token : tokens) {	if (!("all".equalsIgnoreCase(token) || "default".equalsIgnoreCase(token) || "lo".equalsIgnoreCase(token))) {	final String cmd = String.format("ip address show %s | grep link if (s_logger.isDebugEnabled()) {	
run domr script 

final long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick < 15000) {	if (result.first() && !result.second().isEmpty()) {	final String[] tokens = result.second().split("\\n");	for (final String token : tokens) {	if (!("all".equalsIgnoreCase(token) || "default".equalsIgnoreCase(token) || "lo".equalsIgnoreCase(token))) {	final String cmd = String.format("ip address show %s | grep link if (s_logger.isDebugEnabled()) {	}	final Pair<Boolean, String> result2 = SshHelper.sshExecute(routerIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, cmd);	if (s_logger.isDebugEnabled()) {	
result output 

protected Answer execute(final IpAssocCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource ipassoccommand 

final String routerName = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME);	final String controlIp = getRouterSshControlIp(cmd);	for (final IpAddressTO ip : ips) {	assignPublicIpAddress(routerName, controlIp, ip.getPublicIp(), ip.isAdd(), ip.isFirstIP(), ip.isSourceNat(), ip.getBroadcastUri(), ip.getVlanGateway(), ip.getVlanNetmask(), ip.getVifMacAddress());	results[i++] = ip.getPublicIp() + " - success";	}	for (; i < cmd.getIpAddresses().length; i++) {	results[i++] = IpAssocAnswer.errorResult;	}	} catch (final Throwable e) {	
unexpected exception will shortcut rest of ipassoc commands 

int nicposition = -1;	try {	final String cmdName = GetVmConfigCommand.class.getName();	agentUri = new URI("https", null, _agentIp, _port, "/api/HypervResource/" + cmdName, null, null);	} catch (final URISyntaxException e) {	final String errMsg = "Could not generate URI for Hyper-V agent";	s_logger.error(errMsg, e);	}	final String ansStr = postHttpRequest(s_gson.toJson(vmConfig), agentUri);	final Answer[] result = s_gson.fromJson(ansStr, Answer[].class);	
getvmconfigcommand response received 

}	try {	final String cmdName = GetVmConfigCommand.class.getName();	agentUri = new URI("https", null, _agentIp, _port, "/api/HypervResource/" + cmdName, null, null);	} catch (final URISyntaxException e) {	final String errMsg = "Could not generate URI for Hyper-V agent";	s_logger.error(errMsg, e);	}	final String ansStr = postHttpRequest(s_gson.toJson(vmConfig), agentUri);	final Answer[] result = s_gson.fromJson(ansStr, Answer[].class);	
executerequest received response 

URI agentUri = null;	try {	final String cmdName = ModifyVmNicConfigCommand.class.getName();	agentUri = new URI("https", null, _agentIp, _port, "/api/HypervResource/" + cmdName, null, null);	} catch (final URISyntaxException e) {	final String errMsg = "Could not generate URI for Hyper-V agent";	s_logger.error(errMsg, e);	}	final String ansStr = postHttpRequest(s_gson.toJson(modifynic), agentUri);	final Answer[] result = s_gson.fromJson(ansStr, Answer[].class);	
executerequest received response 

URI agentUri = null;	try {	final String cmdName = ModifyVmNicConfigCommand.class.getName();	agentUri = new URI("https", null, _agentIp, _port, "/api/HypervResource/" + cmdName, null, null);	} catch (final URISyntaxException e) {	final String errMsg = "Could not generate URI for Hyper-V agent";	s_logger.error(errMsg, e);	}	final String ansStr = postHttpRequest(s_gson.toJson(modifyNic), agentUri);	final Answer[] result = s_gson.fromJson(ansStr, Answer[].class);	
executerequest received response 

final URI broadcastUri = BroadcastDomainType.fromString(broadcastId);	if (BroadcastDomainType.getSchemeValue(broadcastUri) != BroadcastDomainType.Vlan) {	throw new InternalErrorException("Unable to assign a public IP to a VIF on network " + broadcastId);	}	final String vlanId = BroadcastDomainType.getValue(broadcastUri);	int publicNicInfo = -1;	publicNicInfo = getVmNics(vmName, vlanId);	boolean addVif = false;	if (add && publicNicInfo == -1) {	if (s_logger.isDebugEnabled()) {	
plug new nic to associate to 

final String vlanId = BroadcastDomainType.getValue(broadcastUri);	int publicNicInfo = -1;	publicNicInfo = getVmNics(vmName, vlanId);	boolean addVif = false;	if (add && publicNicInfo == -1) {	if (s_logger.isDebugEnabled()) {	}	addVif = true;	} else if (!add && firstIP) {	if (s_logger.isDebugEnabled()) {	
unplug nic 

args += publicIpAddress + "/" + cidrSize;	args += " -c ";	args += "eth" + publicNicInfo;	args += " -g ";	args += vlanGateway;	if (addVif) {	args += " -n ";	}	final String command = String.format("%s%s %s","/opt/cloud/bin/", VRScripts.IPASSOC ,args);	if (s_logger.isDebugEnabled()) {	
run command on domain router 

args += " -g ";	args += vlanGateway;	if (addVif) {	args += " -n ";	}	final String command = String.format("%s%s %s","/opt/cloud/bin/", VRScripts.IPASSOC ,args);	if (s_logger.isDebugEnabled()) {	}	final Pair<Boolean, String> result = SshHelper.sshExecute(privateIpAddress, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
ipassoc command on domain router failed message 

args += " -n ";	}	final String command = String.format("%s%s %s","/opt/cloud/bin/", VRScripts.IPASSOC ,args);	if (s_logger.isDebugEnabled()) {	}	final Pair<Boolean, String> result = SshHelper.sshExecute(privateIpAddress, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	throw new Exception("ipassoc failed due to " + result.second());	}	if (s_logger.isInfoEnabled()) {	
ipassoc command on domain router completed 

protected Answer execute(final GetDomRVersionCmd cmd) {	final String command = String.format("%s%s", "/opt/cloud/bin/", VRScripts.VERSION);	if (s_logger.isDebugEnabled()) {	
executing resource getdomrversioncmd 

protected Answer execute(final GetDomRVersionCmd cmd) {	final String command = String.format("%s%s", "/opt/cloud/bin/", VRScripts.VERSION);	if (s_logger.isDebugEnabled()) {	
run command on domr 

protected Answer execute(final GetDomRVersionCmd cmd) {	final String command = String.format("%s%s", "/opt/cloud/bin/", VRScripts.VERSION);	if (s_logger.isDebugEnabled()) {	}	Pair<Boolean, String> result;	try {	final String controlIp = getRouterSshControlIp(cmd);	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	
getdomrversioncmd on domr failed message 

if (s_logger.isDebugEnabled()) {	}	Pair<Boolean, String> result;	try {	final String controlIp = getRouterSshControlIp(cmd);	result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	return new GetDomRVersionAnswer(cmd, "GetDomRVersionCmd failed due to " + result.second());	}	if (s_logger.isDebugEnabled()) {	
getdomrversioncmd on domain router completed 

private static String getRouterSshControlIp(final NetworkElementCommand cmd) {	final String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);	final String routerGuestIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP);	final String zoneNetworkType = cmd.getAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE);	if (routerGuestIp != null && zoneNetworkType != null && NetworkType.valueOf(zoneNetworkType) == NetworkType.Basic) {	if (s_logger.isDebugEnabled()) {	
in basic zone mode use router s guest ip for ssh control guest ip 

private static String getRouterSshControlIp(final NetworkElementCommand cmd) {	final String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);	final String routerGuestIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP);	final String zoneNetworkType = cmd.getAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE);	if (routerGuestIp != null && zoneNetworkType != null && NetworkType.valueOf(zoneNetworkType) == NetworkType.Basic) {	if (s_logger.isDebugEnabled()) {	}	return routerGuestIp;	}	if (s_logger.isDebugEnabled()) {	
use router s private ip for ssh control ip 

protected Answer execute(final NetworkUsageCommand cmd) {	if (cmd.isForVpc()) {	}	if (s_logger.isInfoEnabled()) {	
executing resource networkusagecommand 

final long[] stats = new long[2];	if (result != null) {	try {	final String[] splitResult = result.split(":");	int i = 0;	while (i < splitResult.length - 1) {	stats[0] += Long.parseLong(splitResult[i++]);	stats[1] += Long.parseLong(splitResult[i++]);	}	} catch (final Throwable e) {	
unable to parse return from script return of network usage command 

protected Answer execute(final SetMonitorServiceCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource setmonitorservicecommand 

final String command = String.format("%s%s %s", "/opt/cloud/bin/", VRScripts.MONITOR_SERVICE, args);	try {	final Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, command);	if (!result.first()) {	final String msg=  "monitor_service.sh failed on domain router " + controlIp + " failed " + result.second();	s_logger.error(msg);	return new Answer(cmd, false, msg);	}	return new Answer(cmd);	} catch (final Throwable e) {	
unexpected exception 

protected CheckSshAnswer execute(final CheckSshCommand cmd) {	final String vmName = cmd.getName();	final String privateIp = cmd.getIp();	final int cmdPort = cmd.getPort();	if (s_logger.isDebugEnabled()) {	
ping command port 

protected CheckSshAnswer execute(final CheckSshCommand cmd) {	final String vmName = cmd.getName();	final String privateIp = cmd.getIp();	final int cmdPort = cmd.getPort();	if (s_logger.isDebugEnabled()) {	}	try {	final String result = connect(cmd.getName(), privateIp, cmdPort);	if (result != null) {	
can not ping system vm due to 

final String privateIp = cmd.getIp();	final int cmdPort = cmd.getPort();	if (s_logger.isDebugEnabled()) {	}	try {	final String result = connect(cmd.getName(), privateIp, cmdPort);	if (result != null) {	return new CheckSshAnswer(cmd, "Can not ping System vm " + vmName + "due to:" + result);	}	} catch (final Exception e) {	
can not ping system vm due to exception 

}	try {	final String result = connect(cmd.getName(), privateIp, cmdPort);	if (result != null) {	return new CheckSshAnswer(cmd, "Can not ping System vm " + vmName + "due to:" + result);	}	} catch (final Exception e) {	return new CheckSshAnswer(cmd, e);	}	if (s_logger.isDebugEnabled()) {	
ping command port succeeded for vm 

if (result != null) {	return new CheckSshAnswer(cmd, "Can not ping System vm " + vmName + "due to:" + result);	}	} catch (final Exception e) {	return new CheckSshAnswer(cmd, e);	}	if (s_logger.isDebugEnabled()) {	}	if (VirtualMachineName.isValidRouterName(vmName)) {	if (s_logger.isDebugEnabled()) {	
execute network usage setup command on 

args = "-r";	} else if (option.equals("addVif")) {	args = "-a";	args += ethName;	} else if (option.equals("deleteVif")) {	args = "-d";	args += ethName;	}	try {	if (s_logger.isTraceEnabled()) {	
executing opt cloud bin netusage sh on domr 

}	try {	if (s_logger.isTraceEnabled()) {	}	final Pair<Boolean, String> result = SshHelper.sshExecute(privateIpAddress, DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "/opt/cloud/bin/netusage.sh " + args);	if (!result.first()) {	return null;	}	return result.second();	} catch (final Throwable e) {	
unable to execute networkusage command on domr domr may not be ready yet failure due to 

final URL url = this.getClass().getClassLoader().getResource("scripts/vm/systemvm/id_rsa.cloud");	File keyFile = null;	if (url != null) {	keyFile = new File(url.getPath());	}	if (keyFile == null || !keyFile.exists()) {	keyFile = new File("/usr/share/cloudstack-common/scripts/vm/systemvm/id_rsa.cloud");	}	assert keyFile != null;	if (!keyFile.exists()) {	
unable to locate id rsa cloud in your setup at 

public static String postHttpRequest(final String jsonCmd, final URI agentUri) {	String logMessage = StringEscapeUtils.unescapeJava(jsonCmd);	logMessage = cleanPassword(logMessage);	
post request to with contents 

return true;	}	};	try {	final SSLSocketFactory sf = new SSLSocketFactory(easyStrategy, new AllowAllHostnameVerifier());	final SchemeRegistry registry = new SchemeRegistry();	registry.register(new Scheme("https", DEFAULT_AGENT_PORT, sf));	final ClientConnectionManager ccm = new BasicClientConnectionManager(registry);	httpClient = new DefaultHttpClient(ccm);	} catch (final KeyManagementException e) {	
failed to initialize http client 

}	};	try {	final SSLSocketFactory sf = new SSLSocketFactory(easyStrategy, new AllowAllHostnameVerifier());	final SchemeRegistry registry = new SchemeRegistry();	registry.register(new Scheme("https", DEFAULT_AGENT_PORT, sf));	final ClientConnectionManager ccm = new BasicClientConnectionManager(registry);	httpClient = new DefaultHttpClient(ccm);	} catch (final KeyManagementException e) {	} catch (final UnrecoverableKeyException e) {	
failed to initialize http client 

};	try {	final SSLSocketFactory sf = new SSLSocketFactory(easyStrategy, new AllowAllHostnameVerifier());	final SchemeRegistry registry = new SchemeRegistry();	registry.register(new Scheme("https", DEFAULT_AGENT_PORT, sf));	final ClientConnectionManager ccm = new BasicClientConnectionManager(registry);	httpClient = new DefaultHttpClient(ccm);	} catch (final KeyManagementException e) {	} catch (final UnrecoverableKeyException e) {	} catch (final NoSuchAlgorithmException e) {	
failed to initialize http client 

try {	final SSLSocketFactory sf = new SSLSocketFactory(easyStrategy, new AllowAllHostnameVerifier());	final SchemeRegistry registry = new SchemeRegistry();	registry.register(new Scheme("https", DEFAULT_AGENT_PORT, sf));	final ClientConnectionManager ccm = new BasicClientConnectionManager(registry);	httpClient = new DefaultHttpClient(ccm);	} catch (final KeyManagementException e) {	} catch (final UnrecoverableKeyException e) {	} catch (final NoSuchAlgorithmException e) {	} catch (final KeyStoreException e) {	
failed to initialize http client 

} catch (final UnrecoverableKeyException e) {	} catch (final NoSuchAlgorithmException e) {	} catch (final KeyStoreException e) {	}	String result = null;	try {	final HttpPost request = new HttpPost(agentUri);	final StringEntity cmdJson = new StringEntity(jsonCmd);	request.addHeader("content-type", "application/json");	request.setEntity(cmdJson);	
sending cmd to cmd data 

final Answer ans = new UnsupportedAnswer(null, unsupportMsg);	s_logger.error(ans);	result = s_gson.toJson(new Answer[] {ans});	} else if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {	final String errMsg = "Failed send to " + agentUri.toString() + " : HTTP error code : " + response.getStatusLine().getStatusCode();	s_logger.error(errMsg);	return null;	} else {	result = EntityUtils.toString(response.getEntity());	final String logResult = cleanPassword(StringEscapeUtils.unescapeJava(result));	
post response is 

protected String connect(final String vmName, final String ipAddress, final int port) {	final long startTick = System.currentTimeMillis();	int retry = _retry;	while (System.currentTimeMillis() - startTick <= _opsTimeout || --retry > 0) {	
trying to connect to 

final long startTick = System.currentTimeMillis();	int retry = _retry;	while (System.currentTimeMillis() - startTick <= _opsTimeout || --retry > 0) {	try (SocketChannel sch = SocketChannel.open();) {	sch.configureBlocking(true);	sch.socket().setSoTimeout(5000);	final InetSocketAddress addr = new InetSocketAddress(ipAddress, port);	sch.connect(addr);	return null;	} catch (final IOException e) {	
could not connect to due to 

sch.configureBlocking(true);	sch.socket().setSoTimeout(5000);	final InetSocketAddress addr = new InetSocketAddress(ipAddress, port);	sch.connect(addr);	return null;	} catch (final IOException e) {	if (e instanceof ConnectException) {	try {	Thread.sleep(5000);	} catch (final InterruptedException ex) {	
ignored interupted while waiting to retry connecting to vm after exception 

if (e instanceof ConnectException) {	try {	Thread.sleep(5000);	} catch (final InterruptedException ex) {	}	}	}	try {	Thread.sleep(1000);	} catch (final InterruptedException ex) {	
ignored interupted while connecting to vm 

Thread.sleep(5000);	} catch (final InterruptedException ex) {	}	}	}	try {	Thread.sleep(1000);	} catch (final InterruptedException ex) {	}	}	
unable to logon to 

========================= cloudstack sample_934 =========================

private void addConnect(String poolUuid, XenServerConnection conn) {	if (poolUuid == null) return;	if (s_logger.isDebugEnabled()) {	
add master connection through for pool 

private void removeConnect(String poolUuid) {	if (poolUuid == null) {	return;	}	XenServerConnection conn = null;	synchronized (_conns) {	conn = _conns.remove(poolUuid);	}	if (conn != null) {	if (s_logger.isDebugEnabled()) {	
remove master connection through for pool 

removeConnect(poolUuid);	mConn = null;	}	throw new CloudRuntimeException(msg);	}	return mConn;	} catch (CloudRuntimeException e) {	throw e;	} catch (Exception e) {	if (s_logger.isDebugEnabled()) {	
connect through ip for pool is broken due to 

if ( mConn == null ) {	try {	Connection conn = new Connection(getURL(ipAddress), 5, _connWait);	Session sess = loginWithPassword(conn, username, password, APIVersion.latest().toString());	Host host = sess.getThisHost(conn);	Boolean hostenabled = host.getEnabled(conn);	if( sess != null ){	try{	Session.logout(conn);	} catch (Exception e) {	
caught exception during logout 

protected Map dispatch(String methodcall, Object[] methodparams)  throws XmlRpcException, XenAPIException {	if (methodcall.equals("session.local_logout") || methodcall.equals("session.slave_local_login_with_password") || methodcall.equals("session.logout") || methodcall.equals("session.login_with_password")) {	return super.dispatch(methodcall, methodparams);	}	try {	return super.dispatch(methodcall, methodparams);	} catch (Types.SessionInvalid e) {	
session is invalid for method due to 

protected Map dispatch(String methodcall, Object[] methodparams)  throws XmlRpcException, XenAPIException {	if (methodcall.equals("session.local_logout") || methodcall.equals("session.slave_local_login_with_password") || methodcall.equals("session.logout") || methodcall.equals("session.login_with_password")) {	return super.dispatch(methodcall, methodparams);	}	try {	return super.dispatch(methodcall, methodparams);	} catch (Types.SessionInvalid e) {	removeConnect(_poolUuid);	throw e;	} catch (XmlRpcClientException e) {	
xmlrpcclientexception for method due to 

}	try {	return super.dispatch(methodcall, methodparams);	} catch (Types.SessionInvalid e) {	removeConnect(_poolUuid);	throw e;	} catch (XmlRpcClientException e) {	removeConnect(_poolUuid);	throw e;	} catch (XmlRpcException e) {	
xmlrpcexception for method due to 

} catch (Types.SessionInvalid e) {	removeConnect(_poolUuid);	throw e;	} catch (XmlRpcClientException e) {	removeConnect(_poolUuid);	throw e;	} catch (XmlRpcException e) {	removeConnect(_poolUuid);	throw e;	} catch (Types.HostIsSlave e) {	
hostisslave exception for method due to 

========================= cloudstack sample_1150 =========================

public SnapshotAndCopyAnswer snapshotAndCopy(final SnapshotAndCopyCommand cmd) {	
snapshotandcopyanswer snapshotandcopy snapshotandcopycommand not currently used for kvmstorageprocessor 

public ResignatureAnswer resignature(final ResignatureCommand cmd) {	
resignatureanswer resignature resignaturecommand not currently used for kvmstorageprocessor 

tmplVol = disk;	break;	}	}	} else {	tmplVol = secondaryPool.getPhysicalDisk(tmpltname);	}	if (tmplVol == null) {	return new PrimaryStorageDownloadAnswer("Failed to get template from pool: " + secondaryPool.getUuid());	}	
copying template to primary storage template format is 

tmplVol = secondaryPool.getPhysicalDisk(tmpltname);	}	if (tmplVol == null) {	return new PrimaryStorageDownloadAnswer("Failed to get template from pool: " + secondaryPool.getUuid());	}	final KVMStoragePool primaryPool = storagePoolMgr.getStoragePool(primaryStore.getPoolType(), primaryStore.getUuid());	KVMPhysicalDisk primaryVol = null;	if (destData instanceof VolumeObjectTO) {	final VolumeObjectTO volume = (VolumeObjectTO)destData;	if (volume.getSize() != null && volume.getSize() > tmplVol.getVirtualSize()) {	
using configured size of 

return new PrimaryStorageDownloadAnswer("Failed to get template from pool: " + secondaryPool.getUuid());	}	final KVMStoragePool primaryPool = storagePoolMgr.getStoragePool(primaryStore.getPoolType(), primaryStore.getUuid());	KVMPhysicalDisk primaryVol = null;	if (destData instanceof VolumeObjectTO) {	final VolumeObjectTO volume = (VolumeObjectTO)destData;	if (volume.getSize() != null && volume.getSize() > tmplVol.getVirtualSize()) {	tmplVol.setSize(volume.getSize());	tmplVol.setVirtualSize(volume.getSize());	} else {	
using template s size of 

}	return new CopyCmdAnswer(data);	} catch (final CloudRuntimeException e) {	return new CopyCmdAnswer(e.toString());	} finally {	try {	if (secondaryPool != null) {	secondaryPool.delete();	}	} catch(final Exception e) {	
failed to clean up secondary storage 

templateName = templateUrl.substring(index + 1);	}	KVMPhysicalDisk templateVol = null;	KVMStoragePool secondaryPool = null;	try {	secondaryPool = storagePoolMgr.getStoragePoolByURI(mountpoint);	if (templateName == null) {	secondaryPool.refresh();	final List<KVMPhysicalDisk> disks = secondaryPool.listPhysicalDisks();	if (disks == null || disks.isEmpty()) {	
failed to get volumes from pool 

if (disks == null || disks.isEmpty()) {	return null;	}	for (final KVMPhysicalDisk disk : disks) {	if (disk.getName().endsWith("qcow2")) {	templateVol = disk;	break;	}	}	if (templateVol == null) {	
failed to get template from pool 

break;	}	}	if (templateVol == null) {	return null;	}	} else {	templateVol = secondaryPool.getPhysicalDisk(templateName);	}	if (size > templateVol.getSize()) {	
overriding provided template s size with new size 

if (templateVol == null) {	return null;	}	} else {	templateVol = secondaryPool.getPhysicalDisk(templateName);	}	if (size > templateVol.getSize()) {	templateVol.setSize(size);	templateVol.setVirtualSize(size);	} else {	
using templates disk size of since size passed was 

templateVol = secondaryPool.getPhysicalDisk(templateName);	}	if (size > templateVol.getSize()) {	templateVol.setSize(size);	templateVol.setVirtualSize(size);	} else {	}	final KVMPhysicalDisk primaryVol = storagePoolMgr.copyPhysicalDisk(templateVol, volUuid, primaryPool, timeout);	return primaryVol;	} catch (final CloudRuntimeException e) {	
failed to download template to primary storage 

newVol.setSize(volume.getSize());	if (vol.getFormat() == PhysicalDiskFormat.RAW) {	newVol.setFormat(ImageFormat.RAW);	} else if (vol.getFormat() == PhysicalDiskFormat.QCOW2) {	newVol.setFormat(ImageFormat.QCOW2);	} else if (vol.getFormat() == PhysicalDiskFormat.DIR) {	newVol.setFormat(ImageFormat.DIR);	}	return new CopyCmdAnswer(newVol);	} catch (final CloudRuntimeException e) {	
failed to create volume 

srcVolumeName = srcVolumeName + ".qcow2";	}	final KVMPhysicalDisk volume = secondaryStoragePool.getPhysicalDisk(srcVolumeName);	volume.setFormat(PhysicalDiskFormat.valueOf(srcFormat.toString()));	final KVMPhysicalDisk newDisk = storagePoolMgr.copyPhysicalDisk(volume, volumeName, primaryPool, cmd.getWaitInMillSeconds());	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setFormat(ImageFormat.valueOf(newDisk.getFormat().toString().toUpperCase()));	newVol.setPath(volumeName);	return new CopyCmdAnswer(newVol);	} catch (final CloudRuntimeException e) {	
failed to ccopyvolumefromimagecachetoprimary 

secondaryStoragePool = storagePoolMgr.getStoragePoolByURI(secondaryStorageUrl);	secondaryStoragePool.createFolder(destVolumePath);	storagePoolMgr.deleteStoragePool(secondaryStoragePool.getType(), secondaryStoragePool.getUuid());	secondaryStoragePool = storagePoolMgr.getStoragePoolByURI(secondaryStorageUrl + File.separator + destVolumePath);	storagePoolMgr.copyPhysicalDisk(volume, destVolumeName, secondaryStoragePool, cmd.getWaitInMillSeconds());	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(destVolumePath + File.separator + destVolumeName);	newVol.setFormat(destFormat);	return new CopyCmdAnswer(newVol);	} catch (final CloudRuntimeException e) {	
failed to copyvolumefromprimarytosecondary 

final String tmpltPath = secondaryStorage.getLocalPath() + File.separator + templateFolder;	storageLayer.mkdirs(tmpltPath);	final String templateName = UUID.randomUUID().toString();	if (primary.getType() != StoragePoolType.RBD) {	final Script command = new Script(_createTmplPath, wait, s_logger);	command.add("-f", disk.getPath());	command.add("-t", tmpltPath);	command.add("-n", templateName + ".qcow2");	final String result = command.execute();	if (result != null) {	
failed to create template 

if (primary.getType() != StoragePoolType.RBD) {	final Script command = new Script(_createTmplPath, wait, s_logger);	command.add("-f", disk.getPath());	command.add("-t", tmpltPath);	command.add("-n", templateName + ".qcow2");	final String result = command.execute();	if (result != null) {	return new CopyCmdAnswer(result);	}	} else {	
converting rbd disk into template 

newTemplate.setPath(templateFolder + File.separator + templateName + ".qcow2");	newTemplate.setSize(info.virtualSize);	newTemplate.setPhysicalSize(info.size);	newTemplate.setFormat(ImageFormat.QCOW2);	newTemplate.setName(templateName);	return new CopyCmdAnswer(newTemplate);	} catch (final QemuImgException e) {	s_logger.error(e.getMessage());	return new CopyCmdAnswer(e.toString());	} catch (final IOException e) {	
failed to createtemplatefromvolume 

newTemplate.setPhysicalSize(info.size);	newTemplate.setFormat(ImageFormat.QCOW2);	newTemplate.setName(templateName);	return new CopyCmdAnswer(newTemplate);	} catch (final QemuImgException e) {	s_logger.error(e.getMessage());	return new CopyCmdAnswer(e.toString());	} catch (final IOException e) {	return new CopyCmdAnswer(e.toString());	} catch (final Exception e) {	
failed to createtemplatefromvolume 

String destPath = null;	if (imageStore instanceof S3TO) {	destPath = copyToS3(srcFile, (S3TO)imageStore, destData.getPath());	} else {	return new CopyCmdAnswer("Unsupported protocol");	}	final SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(destPath);	return new CopyCmdAnswer(newSnapshot);	} catch (final Exception e) {	
failed to upload 

return new CopyCmdAnswer("failed to upload" + srcPath + e.toString());	} finally {	try {	if (srcFile != null) {	srcFile.delete();	}	if (srcStorePool != null) {	srcStorePool.delete();	}	} catch (final Exception e) {	
failed to clean up 

final String ssPmountPath = secondaryStoragePool.getLocalPath();	snapshotRelPath = destSnapshot.getPath();	snapshotDestPath = ssPmountPath + File.separator + snapshotRelPath;	snapshotDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), volumePath);	primaryPool = snapshotDisk.getPool();	long size = 0;	if (primaryPool.getType() == StoragePoolType.RBD) {	final String rbdSnapshot = snapshotDisk.getPath() +  "@" + snapshotName;	final String snapshotFile = snapshotDestPath + "/" + snapshotName;	try {	
attempting to backup rbd snapshot 

snapshotRelPath = destSnapshot.getPath();	snapshotDestPath = ssPmountPath + File.separator + snapshotRelPath;	snapshotDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), volumePath);	primaryPool = snapshotDisk.getPool();	long size = 0;	if (primaryPool.getType() == StoragePoolType.RBD) {	final String rbdSnapshot = snapshotDisk.getPath() +  "@" + snapshotName;	final String snapshotFile = snapshotDestPath + "/" + snapshotName;	try {	final File snapDir = new File(snapshotDestPath);	
attempting to create recursively for snapshot storage 

if (primaryPool.getType() == StoragePoolType.RBD) {	final String rbdSnapshot = snapshotDisk.getPath() +  "@" + snapshotName;	final String snapshotFile = snapshotDestPath + "/" + snapshotName;	try {	final File snapDir = new File(snapshotDestPath);	FileUtils.forceMkdir(snapDir);	final QemuImgFile srcFile = new QemuImgFile(KVMPhysicalDisk.RBDStringBuilder(primaryPool.getSourceHost(), primaryPool.getSourcePort(), primaryPool.getAuthUserName(), primaryPool.getAuthSecret(), rbdSnapshot));	srcFile.setFormat(PhysicalDiskFormat.RAW);	final QemuImgFile destFile = new QemuImgFile(snapshotFile);	destFile.setFormat(snapshotDisk.getFormat());	
backing up rbd snapshot to 

final QemuImgFile srcFile = new QemuImgFile(KVMPhysicalDisk.RBDStringBuilder(primaryPool.getSourceHost(), primaryPool.getSourcePort(), primaryPool.getAuthUserName(), primaryPool.getAuthSecret(), rbdSnapshot));	srcFile.setFormat(PhysicalDiskFormat.RAW);	final QemuImgFile destFile = new QemuImgFile(snapshotFile);	destFile.setFormat(snapshotDisk.getFormat());	final QemuImg q = new QemuImg(cmd.getWaitInMillSeconds());	q.convert(srcFile, destFile);	final File snapFile = new File(snapshotFile);	if(snapFile.exists()) {	size = snapFile.length();	}	
finished backing up rbd snapshot to snapshot size 

srcFile.setFormat(PhysicalDiskFormat.RAW);	final QemuImgFile destFile = new QemuImgFile(snapshotFile);	destFile.setFormat(snapshotDisk.getFormat());	final QemuImg q = new QemuImg(cmd.getWaitInMillSeconds());	q.convert(srcFile, destFile);	final File snapFile = new File(snapshotFile);	if(snapFile.exists()) {	size = snapFile.length();	}	} catch (final FileNotFoundException e) {	
failed to open the error was 

destFile.setFormat(snapshotDisk.getFormat());	final QemuImg q = new QemuImg(cmd.getWaitInMillSeconds());	q.convert(srcFile, destFile);	final File snapFile = new File(snapshotFile);	if(snapFile.exists()) {	size = snapFile.length();	}	} catch (final FileNotFoundException e) {	return new CopyCmdAnswer(e.toString());	} catch (final IOException e) {	
failed to create the error was 

q.convert(srcFile, destFile);	final File snapFile = new File(snapshotFile);	if(snapFile.exists()) {	size = snapFile.length();	}	} catch (final FileNotFoundException e) {	return new CopyCmdAnswer(e.toString());	} catch (final IOException e) {	return new CopyCmdAnswer(e.toString());	}  catch (final QemuImgException e) {	
failed to backup the rbd snapshot from to the error was 

return new CopyCmdAnswer(e.toString());	}	} else {	final Script command = new Script(_manageSnapshotPath, cmd.getWaitInMillSeconds(), s_logger);	command.add("-b", snapshotDisk.getPath());	command.add("-n", snapshotName);	command.add("-p", snapshotDestPath);	command.add("-t", snapshotName);	final String result = command.execute();	if (result != null) {	
failed to backup snaptshot 

final File snapFile = new File(snapshotDestPath + "/" + snapshotName);	if(snapFile.exists()){	size = snapFile.length();	}	}	final SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(snapshotRelPath + File.separator + snapshotName);	newSnapshot.setPhysicalSize(size);	return new CopyCmdAnswer(newSnapshot);	} catch (final LibvirtException e) {	
failed to backup snapshot 

size = snapFile.length();	}	}	final SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(snapshotRelPath + File.separator + snapshotName);	newSnapshot.setPhysicalSize(size);	return new CopyCmdAnswer(newSnapshot);	} catch (final LibvirtException e) {	return new CopyCmdAnswer(e.toString());	} catch (final CloudRuntimeException e) {	
failed to backup snapshot 

return new CopyCmdAnswer(e.toString());	} finally {	try {	DomainInfo.DomainState state = null;	Domain vm = null;	if (vmName != null) {	try {	vm = resource.getDomain(conn, vmName);	state = vm.getInfo().state;	} catch (final LibvirtException e) {	
ignoring libvirt error 

if (state == DomainInfo.DomainState.VIR_DOMAIN_PAUSED) {	vm.resume();	}	} else {	if (primaryPool.getType() != StoragePoolType.RBD) {	final Script command = new Script(_manageSnapshotPath, _cmdsTimeout, s_logger);	command.add("-d", snapshotDisk.getPath());	command.add("-n", snapshotName);	final String result = command.execute();	if (result != null) {	
failed to delete snapshot on primary 

if (primaryPool.getType() != StoragePoolType.RBD) {	final Script command = new Script(_manageSnapshotPath, _cmdsTimeout, s_logger);	command.add("-d", snapshotDisk.getPath());	command.add("-n", snapshotName);	final String result = command.execute();	if (result != null) {	}	}	}	} catch (final Exception ex) {	
failed to delete snapshots on primary 

}	}	}	} catch (final Exception ex) {	}	try {	if (secondaryStoragePool != null) {	secondaryStoragePool.delete();	}	} catch (final Exception ex) {	
failed to delete secondary storage 

protected synchronized String attachOrDetachDevice(final Connect conn, final boolean attach, final String vmName, final String xml) throws LibvirtException, InternalErrorException {	Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	if (attach) {	
attaching device 

protected synchronized String attachOrDetachDevice(final Connect conn, final boolean attach, final String vmName, final String xml) throws LibvirtException, InternalErrorException {	Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	if (attach) {	dm.attachDevice(xml);	} else {	
detaching device 

Domain dm = null;	try {	dm = conn.domainLookupByName(vmName);	if (attach) {	dm.attachDevice(xml);	} else {	dm.detachDevice(xml);	}	} catch (final LibvirtException e) {	if (attach) {	
failed to attach device to 

try {	dm = conn.domainLookupByName(vmName);	if (attach) {	dm.attachDevice(xml);	} else {	dm.detachDevice(xml);	}	} catch (final LibvirtException e) {	if (attach) {	} else {	
failed to detach device from 

} catch (final LibvirtException e) {	if (attach) {	} else {	}	throw e;	} finally {	if (dm != null) {	try {	dm.free();	} catch (final LibvirtException l) {	
ignoring libvirt error 

if (!attach) {	dm = conn.domainLookupByName(vmName);	final LibvirtDomainXMLParser parser = new LibvirtDomainXMLParser();	final String xml = dm.getXMLDesc(0);	parser.parseDomainXML(xml);	disks = parser.getDisks();	if (attachingPool.getType() == StoragePoolType.RBD) {	if (resource.getHypervisorType() == Hypervisor.HypervisorType.LXC) {	final String device = resource.mapRbdDevice(attachingDisk);	if (device != null) {	
rbd device on host is 

if (diskdef == null) {	throw new InternalErrorException("disk: " + attachingDisk.getPath() + " is not attached before");	}	} else {	diskdef = new DiskDef();	diskdef.setSerial(serial);	if (attachingPool.getType() == StoragePoolType.RBD) {	if(resource.getHypervisorType() == Hypervisor.HypervisorType.LXC){	final String device = resource.mapRbdDevice(attachingDisk);	if (device != null) {	
rbd device on host is 

final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();	final String vmName = cmd.getVmName();	final String serial = resource.diskUuidToSerial(vol.getUuid());	try {	final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);	storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());	final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());	attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());	return new AttachAnswer(disk);	} catch (final LibvirtException e) {	
failed to attach volume due to 

try {	final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);	storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());	final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());	attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());	return new AttachAnswer(disk);	} catch (final LibvirtException e) {	storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());	return new AttachAnswer(e.toString());	} catch (final InternalErrorException e) {	
failed to attach volume due to 

final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();	final String vmName = cmd.getVmName();	final String serial = resource.diskUuidToSerial(vol.getUuid());	try {	final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);	final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());	attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());	storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());	return new DettachAnswer(disk);	} catch (final LibvirtException e) {	
failed to attach volume due to 

final String serial = resource.diskUuidToSerial(vol.getUuid());	try {	final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);	final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());	attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());	storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());	return new DettachAnswer(disk);	} catch (final LibvirtException e) {	return new DettachAnswer(e.toString());	} catch (final InternalErrorException e) {	
failed to attach volume due to 

}	vol = primaryPool.createPhysicalDisk(volume.getUuid(), format, volume.getProvisioningType(), disksize);	final VolumeObjectTO newVol = new VolumeObjectTO();	if(vol != null) {	newVol.setPath(vol.getName());	}	newVol.setSize(volume.getSize());	newVol.setFormat(ImageFormat.valueOf(format.toString().toUpperCase()));	return new CreateObjectAnswer(newVol);	} catch (final Exception e) {	
failed to create volume 

final String vmName = volume.getVmName();	try {	final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);	DomainInfo.DomainState state = null;	Domain vm = null;	if (vmName != null) {	try {	vm = resource.getDomain(conn, vmName);	state = vm.getInfo().state;	} catch (final LibvirtException e) {	
ignoring libvirt error 

}	final KVMStoragePool primaryPool = storagePoolMgr.getStoragePool(primaryStore.getPoolType(), primaryStore.getUuid());	final KVMPhysicalDisk disk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), volume.getPath());	if (state == DomainInfo.DomainState.VIR_DOMAIN_RUNNING && !primaryPool.isExternalSnapshot()) {	final String vmUuid = vm.getUUIDString();	final Object[] args = new Object[] {snapshotName, vmUuid};	final String snapshot = SnapshotXML.format(args);	final long start = System.currentTimeMillis();	vm.snapshotCreateXML(snapshot);	final long total = (System.currentTimeMillis() - start)/1000;	
snapshot takes seconds to finish 

vm.resume();	}	} else {	if (primaryPool.getType() == StoragePoolType.RBD) {	try {	final Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

if (primaryPool.getType() == StoragePoolType.RBD) {	try {	final Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	final IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	final Rbd rbd = new Rbd(io);	final RbdImage image = rbd.open(disk.getName());	
attempting to create rbd snapshot 

r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	final IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	final Rbd rbd = new Rbd(io);	final RbdImage image = rbd.open(disk.getName());	image.snapCreate(snapshotName);	rbd.close(image);	r.ioCtxDestroy(io);	} catch (final Exception e) {	
a rbd snapshot operation on failed the error was 

rbd.close(image);	r.ioCtxDestroy(io);	} catch (final Exception e) {	}	} else {	final Script command = new Script(_manageSnapshotPath, _cmdsTimeout, s_logger);	command.add("-c", disk.getPath());	command.add("-n", snapshotName);	final String result = command.execute();	if (result != null) {	
failed to manage snapshot 

final String result = command.execute();	if (result != null) {	return new CreateObjectAnswer("Failed to manage snapshot: " + result);	}	}	}	final SnapshotObjectTO newSnapshot = new SnapshotObjectTO();	newSnapshot.setPath(disk.getPath() + File.separator + snapshotName);	return new CreateObjectAnswer(newSnapshot);	} catch (final LibvirtException e) {	
failed to manage snapshot 

public Answer deleteVolume(final DeleteCommand cmd) {	final VolumeObjectTO vol = (VolumeObjectTO)cmd.getData();	final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();	try {	final KVMStoragePool pool = storagePoolMgr.getStoragePool(primaryStore.getPoolType(), primaryStore.getUuid());	try {	pool.getPhysicalDisk(vol.getPath());	} catch (final Exception e) {	
can t find volume return true 

try {	final KVMStoragePool pool = storagePoolMgr.getStoragePool(primaryStore.getPoolType(), primaryStore.getUuid());	try {	pool.getPhysicalDisk(vol.getPath());	} catch (final Exception e) {	return new Answer(null);	}	pool.deletePhysicalDisk(vol.getPath(), vol.getFormat());	return new Answer(null);	} catch (final CloudRuntimeException e) {	
failed to delete volume 

final String primaryUuid = pool.getUuid();	final KVMStoragePool primaryPool = storagePoolMgr.getStoragePool(pool.getPoolType(), primaryUuid);	final String volUuid = UUID.randomUUID().toString();	final KVMPhysicalDisk disk = storagePoolMgr.copyPhysicalDisk(snapshotDisk, volUuid, primaryPool, cmd.getWaitInMillSeconds());	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(disk.getName());	newVol.setSize(disk.getVirtualSize());	newVol.setFormat(ImageFormat.valueOf(disk.getFormat().toString().toUpperCase()));	return new CopyCmdAnswer(newVol);	} catch (final CloudRuntimeException e) {	
failed to createvolumefromsnapshot 

KVMPhysicalDisk disk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), volume.getPath());	String snapshotFullPath = snapshotTO.getPath();	String snapshotName = snapshotFullPath.substring(snapshotFullPath.lastIndexOf("/") + 1);	snap_full_name = disk.getName() + "@" + snapshotName;	if (primaryPool.getType() == StoragePoolType.RBD) {	Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

if (primaryPool.getType() == StoragePoolType.RBD) {	Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(disk.getName());	try {	
attempting to remove rbd snapshot 

Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(disk.getName());	try {	if (image.snapIsProtected(snapshotName)) {	
unprotecting rbd snapshot 

r.confSet("client_mount_timeout", "30");	r.connect();	IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(disk.getName());	try {	if (image.snapIsProtected(snapshotName)) {	image.snapUnprotect(snapshotName);	}	image.snapRemove(snapshotName);	
snapshot successfully removed from pool 

r.connect();	IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	Rbd rbd = new Rbd(io);	RbdImage image = rbd.open(disk.getName());	try {	if (image.snapIsProtected(snapshotName)) {	image.snapUnprotect(snapshotName);	}	image.snapRemove(snapshotName);	} catch (RbdException e) {	
failed to remove snapshot with exception rbd error 

if (image.snapIsProtected(snapshotName)) {	image.snapUnprotect(snapshotName);	}	image.snapRemove(snapshotName);	} catch (RbdException e) {	} finally {	rbd.close(image);	r.ioCtxDestroy(io);	}	} else {	
operation not implemented for storage pool type of 

} catch (RbdException e) {	} finally {	rbd.close(image);	r.ioCtxDestroy(io);	}	} else {	throw new InternalErrorException("Operation not implemented for storage pool type of " + primaryPool.getType().toString());	}	return new Answer(cmd, true, "Snapshot " + snap_full_name + " removed successfully.");	} catch (RadosException e) {	
failed to remove snapshot with exception rbd error 

rbd.close(image);	r.ioCtxDestroy(io);	}	} else {	throw new InternalErrorException("Operation not implemented for storage pool type of " + primaryPool.getType().toString());	}	return new Answer(cmd, true, "Snapshot " + snap_full_name + " removed successfully.");	} catch (RadosException e) {	return new Answer(cmd, false, "Failed to remove snapshot " + snap_full_name);	} catch (RbdException e) {	
failed to remove snapshot with exception rbd error 

}	} else {	throw new InternalErrorException("Operation not implemented for storage pool type of " + primaryPool.getType().toString());	}	return new Answer(cmd, true, "Snapshot " + snap_full_name + " removed successfully.");	} catch (RadosException e) {	return new Answer(cmd, false, "Failed to remove snapshot " + snap_full_name);	} catch (RbdException e) {	return new Answer(cmd, false, "Failed to remove snapshot " + snap_full_name);	} catch (Exception e) {	
failed to remove snapshot with exception 

========================= cloudstack sample_1015 =========================

DataCenter dc = dcDao.findById(vm.getDataCenterId());	if (avoid.shouldAvoid(dc)) {	if (s_logger.isDebugEnabled()) {	s_logger.debug("DataCenter id = '" + dc.getId() + "' provided is in avoid set, DeploymentPlanner cannot allocate the VM, returning.");	}	return null;	}	List<Long> clusterList = new ArrayList<Long>();	if (plan.getClusterId() != null) {	Long clusterIdSpecified = plan.getClusterId();	
searching resources only under specified cluster 

s_logger.debug("DataCenter id = '" + dc.getId() + "' provided is in avoid set, DeploymentPlanner cannot allocate the VM, returning.");	}	return null;	}	List<Long> clusterList = new ArrayList<Long>();	if (plan.getClusterId() != null) {	Long clusterIdSpecified = plan.getClusterId();	ClusterVO cluster = clusterDao.findById(plan.getClusterId());	if (cluster != null) {	if (avoid.shouldAvoid(cluster)) {	
the specified cluster is in avoid set returning 

if (plan.getClusterId() != null) {	Long clusterIdSpecified = plan.getClusterId();	ClusterVO cluster = clusterDao.findById(plan.getClusterId());	if (cluster != null) {	if (avoid.shouldAvoid(cluster)) {	} else {	clusterList.add(clusterIdSpecified);	removeClustersCrossingThreshold(clusterList, avoid, vmProfile, plan);	}	} else {	
the specified cluster cannot be found returning 

} else {	clusterList.add(clusterIdSpecified);	removeClustersCrossingThreshold(clusterList, avoid, vmProfile, plan);	}	} else {	avoid.addCluster(plan.getClusterId());	return null;	}	} else if (plan.getPodId() != null) {	Long podIdSpecified = plan.getPodId();	
searching resources only under specified pod 

}	} else {	avoid.addCluster(plan.getClusterId());	return null;	}	} else if (plan.getPodId() != null) {	Long podIdSpecified = plan.getPodId();	HostPodVO pod = podDao.findById(podIdSpecified);	if (pod != null) {	if (avoid.shouldAvoid(pod)) {	
the specified pod is in avoid set returning 

HostPodVO pod = podDao.findById(podIdSpecified);	if (pod != null) {	if (avoid.shouldAvoid(pod)) {	} else {	clusterList = scanClustersForDestinationInZoneOrPod(podIdSpecified, false, vmProfile, plan, avoid);	if (clusterList == null) {	avoid.addPod(plan.getPodId());	}	}	} else {	
the specified pod cannot be found returning 

clusterList = scanClustersForDestinationInZoneOrPod(podIdSpecified, false, vmProfile, plan, avoid);	if (clusterList == null) {	avoid.addPod(plan.getPodId());	}	}	} else {	avoid.addPod(plan.getPodId());	return null;	}	} else {	
searching all possible resources under this zone 

private List<Long> scanPodsForDestination(VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid) {	ServiceOffering offering = vmProfile.getServiceOffering();	int requiredCpu = offering.getCpu() * offering.getSpeed();	long requiredRam = offering.getRamSize() * 1024L * 1024L;	List<Long> prioritizedPodIds = new ArrayList<Long>();	Pair<List<Long>, Map<Long, Double>> podCapacityInfo = listPodsByCapacity(plan.getDataCenterId(), requiredCpu, requiredRam);	List<Long> podsWithCapacity = podCapacityInfo.first();	if (!podsWithCapacity.isEmpty()) {	if (avoid.getPodsToAvoid() != null) {	if (s_logger.isDebugEnabled()) {	
removing from the podid list these pods from avoid set 

if (!podsWithCapacity.isEmpty()) {	if (avoid.getPodsToAvoid() != null) {	if (s_logger.isDebugEnabled()) {	}	podsWithCapacity.removeAll(avoid.getPodsToAvoid());	}	if (!isRootAdmin(vmProfile)) {	List<Long> disabledPods = listDisabledPods(plan.getDataCenterId());	if (!disabledPods.isEmpty()) {	if (s_logger.isDebugEnabled()) {	
removing from the podid list these pods that are disabled 

if (!isRootAdmin(vmProfile)) {	List<Long> disabledPods = listDisabledPods(plan.getDataCenterId());	if (!disabledPods.isEmpty()) {	if (s_logger.isDebugEnabled()) {	}	podsWithCapacity.removeAll(disabledPods);	}	}	} else {	if (s_logger.isDebugEnabled()) {	
no pods found having a host with enough capacity returning 

}	} else {	if (s_logger.isDebugEnabled()) {	}	return null;	}	if (!podsWithCapacity.isEmpty()) {	prioritizedPodIds = reorderPods(podCapacityInfo, vmProfile, plan);	if (prioritizedPodIds == null || prioritizedPodIds.isEmpty()) {	if (s_logger.isDebugEnabled()) {	
no pods found for destination returning 

}	if (!podsWithCapacity.isEmpty()) {	prioritizedPodIds = reorderPods(podCapacityInfo, vmProfile, plan);	if (prioritizedPodIds == null || prioritizedPodIds.isEmpty()) {	if (s_logger.isDebugEnabled()) {	}	return null;	}	List<Long> clusterList = new ArrayList<Long>();	for (Long podId : prioritizedPodIds) {	
checking resources under pod 

List<Long> clusterList = new ArrayList<Long>();	for (Long podId : prioritizedPodIds) {	List<Long> clustersUnderPod = scanClustersForDestinationInZoneOrPod(podId, false, vmProfile, plan, avoid);	if (clustersUnderPod != null) {	clusterList.addAll(clustersUnderPod);	}	}	return clusterList;	} else {	if (s_logger.isDebugEnabled()) {	
no pods found after removing disabled pods and pods in avoid list returning 

return;	}	if (capacity == Capacity.CAPACITY_TYPE_CPU) {	clustersCrossingThreshold = capacityDao.listClustersCrossingThreshold(capacity, plan.getDataCenterId(), ClusterCPUCapacityDisableThreshold.key(), cpu_requested);	} else if (capacity == Capacity.CAPACITY_TYPE_MEMORY) {	clustersCrossingThreshold = capacityDao.listClustersCrossingThreshold(capacity, plan.getDataCenterId(), ClusterMemoryCapacityDisableThreshold.key(), ram_requested);	}	if (clustersCrossingThreshold != null && clustersCrossingThreshold.size() != 0) {	avoid.addClusterList(clustersCrossingThreshold);	clusterListForVmAllocation.removeAll(clustersCrossingThreshold);	
cannot allocate cluster list for vm creation since their allocated percentage crosses the disable capacity threshold defined at each cluster at global value for capacity type skipping these clusters 

VirtualMachine vm = vmProfile.getVirtualMachine();	ServiceOffering offering = vmProfile.getServiceOffering();	DataCenter dc = dcDao.findById(vm.getDataCenterId());	int requiredCpu = offering.getCpu() * offering.getSpeed();	long requiredRam = offering.getRamSize() * 1024L * 1024L;	Pair<List<Long>, Map<Long, Double>> clusterCapacityInfo = listClustersByCapacity(id, requiredCpu, requiredRam, avoid, isZone);	List<Long> prioritizedClusterIds = clusterCapacityInfo.first();	if (!prioritizedClusterIds.isEmpty()) {	if (avoid.getClustersToAvoid() != null) {	if (s_logger.isDebugEnabled()) {	
removing from the clusterid list these clusters from avoid set 

}	if (!isRootAdmin(vmProfile)) {	List<Long> disabledClusters = new ArrayList<Long>();	if (isZone) {	disabledClusters = listDisabledClusters(plan.getDataCenterId(), null);	} else {	disabledClusters = listDisabledClusters(plan.getDataCenterId(), id);	}	if (!disabledClusters.isEmpty()) {	if (s_logger.isDebugEnabled()) {	
removing from the clusterid list these clusters that are disabled clusters under disabled pods 

}	if (!disabledClusters.isEmpty()) {	if (s_logger.isDebugEnabled()) {	}	prioritizedClusterIds.removeAll(disabledClusters);	}	}	removeClustersCrossingThreshold(prioritizedClusterIds, avoid, vmProfile, plan);	} else {	if (s_logger.isDebugEnabled()) {	
no clusters found having a host with enough capacity returning 

} else {	if (s_logger.isDebugEnabled()) {	}	return null;	}	if (!prioritizedClusterIds.isEmpty()) {	List<Long> clusterList = reorderClusters(id, isZone, clusterCapacityInfo, vmProfile, plan);	return clusterList;	} else {	if (s_logger.isDebugEnabled()) {	
no clusters found after removing disabled clusters and clusters in avoid list returning 

protected Pair<List<Long>, Map<Long, Double>> listClustersByCapacity(long id, int requiredCpu, long requiredRam, ExcludeList avoid, boolean isZone) {	if (s_logger.isDebugEnabled()) {	
listing clusters in order of aggregate capacity that have atleast one host with enough cpu and ram capacity under this zone pod 

protected Pair<List<Long>, Map<Long, Double>> listClustersByCapacity(long id, int requiredCpu, long requiredRam, ExcludeList avoid, boolean isZone) {	if (s_logger.isDebugEnabled()) {	}	String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());	short capacityType = Capacity.CAPACITY_TYPE_CPU;	if ("RAM".equalsIgnoreCase(capacityTypeToOrder)) {	capacityType = Capacity.CAPACITY_TYPE_MEMORY;	}	List<Long> clusterIdswithEnoughCapacity = capacityDao.listClustersInZoneOrPodByHostCapacities(id, requiredCpu, requiredRam, capacityType, isZone);	if (s_logger.isTraceEnabled()) {	
clusterid list having enough cpu and ram capacity 

short capacityType = Capacity.CAPACITY_TYPE_CPU;	if ("RAM".equalsIgnoreCase(capacityTypeToOrder)) {	capacityType = Capacity.CAPACITY_TYPE_MEMORY;	}	List<Long> clusterIdswithEnoughCapacity = capacityDao.listClustersInZoneOrPodByHostCapacities(id, requiredCpu, requiredRam, capacityType, isZone);	if (s_logger.isTraceEnabled()) {	}	Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderClustersByAggregateCapacity(id, capacityType, isZone);	List<Long> clusterIdsOrderedByAggregateCapacity = result.first();	if (s_logger.isTraceEnabled()) {	
clusterid list in order of aggregate capacity 

}	List<Long> clusterIdswithEnoughCapacity = capacityDao.listClustersInZoneOrPodByHostCapacities(id, requiredCpu, requiredRam, capacityType, isZone);	if (s_logger.isTraceEnabled()) {	}	Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderClustersByAggregateCapacity(id, capacityType, isZone);	List<Long> clusterIdsOrderedByAggregateCapacity = result.first();	if (s_logger.isTraceEnabled()) {	}	clusterIdsOrderedByAggregateCapacity.retainAll(clusterIdswithEnoughCapacity);	if (s_logger.isTraceEnabled()) {	
clusterid list having enough cpu and ram capacity in order of aggregate capacity 

protected Pair<List<Long>, Map<Long, Double>> listPodsByCapacity(long zoneId, int requiredCpu, long requiredRam) {	if (s_logger.isDebugEnabled()) {	
listing pods in order of aggregate capacity that have atleast one host with enough cpu and ram capacity under this zone 

protected Pair<List<Long>, Map<Long, Double>> listPodsByCapacity(long zoneId, int requiredCpu, long requiredRam) {	if (s_logger.isDebugEnabled()) {	}	String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());	short capacityType = Capacity.CAPACITY_TYPE_CPU;	if ("RAM".equalsIgnoreCase(capacityTypeToOrder)) {	capacityType = Capacity.CAPACITY_TYPE_MEMORY;	}	List<Long> podIdswithEnoughCapacity = capacityDao.listPodsByHostCapacities(zoneId, requiredCpu, requiredRam, capacityType);	if (s_logger.isTraceEnabled()) {	
podid list having enough cpu and ram capacity 

short capacityType = Capacity.CAPACITY_TYPE_CPU;	if ("RAM".equalsIgnoreCase(capacityTypeToOrder)) {	capacityType = Capacity.CAPACITY_TYPE_MEMORY;	}	List<Long> podIdswithEnoughCapacity = capacityDao.listPodsByHostCapacities(zoneId, requiredCpu, requiredRam, capacityType);	if (s_logger.isTraceEnabled()) {	}	Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderPodsByAggregateCapacity(zoneId, capacityType);	List<Long> podIdsOrderedByAggregateCapacity = result.first();	if (s_logger.isTraceEnabled()) {	
podid list in order of aggregate capacity 

}	List<Long> podIdswithEnoughCapacity = capacityDao.listPodsByHostCapacities(zoneId, requiredCpu, requiredRam, capacityType);	if (s_logger.isTraceEnabled()) {	}	Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderPodsByAggregateCapacity(zoneId, capacityType);	List<Long> podIdsOrderedByAggregateCapacity = result.first();	if (s_logger.isTraceEnabled()) {	}	podIdsOrderedByAggregateCapacity.retainAll(podIdswithEnoughCapacity);	if (s_logger.isTraceEnabled()) {	
podid list having enough cpu and ram capacity in order of aggregate capacity 

========================= cloudstack sample_2269 =========================

try {	Profiler p = new Profiler();	p.start();	locked = WorkLock.lock(timeoutSeconds);	p.stop();	System.out.println("Thread " + id + " waited " + p.getDurationInMillis() + " ms, locked=" + locked);	if (locked) {	Thread.sleep(jobDuration * 1000);	}	} catch (InterruptedException e) {	
ignored interupted while testing global lock 

========================= cloudstack sample_522 =========================

List<HostVO> vmWareServerHosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(Hypervisor.HypervisorType.VMware, scope.getScopeId());	List<HostVO> kvmHosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(Hypervisor.HypervisorType.KVM, scope.getScopeId());	List<HostVO> hosts = new ArrayList<HostVO>();	hosts.addAll(xenServerHosts);	hosts.addAll(vmWareServerHosts);	hosts.addAll(kvmHosts);	for (HostVO host : hosts) {	try {	_storageMgr.connectHostToSharedPool(host.getId(), dataStore.getId());	} catch (Exception e) {	
unable to establish a connection between and 

========================= cloudstack sample_1916 =========================

final String[] domainName = (String[])params.get(ApiConstants.DOMAIN);	Long domainId = null;	if ((domainIdArr != null) && (domainIdArr.length > 0)) {	try {	domainId = _apiServer.fetchDomainId(domainIdArr[0]);	if (domainId == null) {	domainId = Long.parseLong(domainIdArr[0]);	}	auditTrailSb.append(" domainid=" + domainId);	} catch (final NumberFormatException e) {	
invalid domain id entered by user 

========================= cloudstack sample_2510 =========================

client = connMap.get(key);	}	long seconds_unused = (System.currentTimeMillis() - client.getClientLastFrontEndActivityTime()) / 1000;	if (seconds_unused < MAX_SESSION_IDLE_SECONDS) {	continue;	}	synchronized (connMap) {	connMap.remove(key);	bReportLoad = true;	}	
dropping which has not been used for seconds 

synchronized (connMap) {	connMap.remove(key);	bReportLoad = true;	}	client.closeClient();	}	if (bReportLoad || System.currentTimeMillis() - lastReportTick > 5000) {	String loadInfo = new ConsoleProxyClientStatsCollector(connMap).getStatsReport();	ConsoleProxy.reportLoadInfo(loadInfo);	lastReportTick = System.currentTimeMillis();	
report load change 

client.closeClient();	}	if (bReportLoad || System.currentTimeMillis() - lastReportTick > 5000) {	String loadInfo = new ConsoleProxyClientStatsCollector(connMap).getStatsReport();	ConsoleProxy.reportLoadInfo(loadInfo);	lastReportTick = System.currentTimeMillis();	}	try {	Thread.sleep(5000);	} catch (InterruptedException ex) {	
ignored console proxy was interupted during gc 

========================= cloudstack sample_4997 =========================

public String compressStringifiedRules() {	final String stringified = stringifyRules();	final ByteArrayOutputStream out = new ByteArrayOutputStream();	String encodedResult = null;	try {	final DeflaterOutputStream dzip = new DeflaterOutputStream(out);	dzip.write(stringified.getBytes());	dzip.close();	encodedResult = Base64.encodeBase64String(out.toByteArray());	} catch (final IOException e) {	
exception while compressing security group rules 

========================= cloudstack sample_94 =========================

public void processConnect(Host agent, StartupCommand cmd, boolean forRebalance) {	if ((cmd instanceof StartupStorageCommand)) {	StartupStorageCommand scmd = (StartupStorageCommand)cmd;	if (scmd.getResourceType() == Storage.StorageResourceType.SECONDARY_STORAGE) {	_ssVmMgr.generateSetupCommand(agent.getId());	return;	}	} else if (cmd instanceof StartupSecondaryStorageCommand) {	if (s_logger.isInfoEnabled()) {	
received a host startup notification 

========================= cloudstack sample_2455 =========================

public void execute() {	
getsolidfireaccountidcmd execute method invoked 

========================= cloudstack sample_2005 =========================

public static String syncVolumeToVmDefaultFolder(DatacenterMO dcMo, String vmName, DatastoreMO ds, String vmdkName) throws Exception {	assert (ds != null);	if (!ds.folderExists(String.format("[%s]", ds.getName()), vmName)) {	
vm folder does not exist on target datastore we will create one vm datastore 

ds.makeDirectory(String.format("[%s] %s", ds.getName(), vmName), dcMo.getMor());	}	String[] vmdkLinkedCloneModeLegacyPair = getVmdkFilePairDatastorePath(ds, vmName, vmdkName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, true);	String[] vmdkFullCloneModeLegacyPair = getVmdkFilePairDatastorePath(ds, vmName, vmdkName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, false);	String[] vmdkLinkedCloneModePair = getVmdkFilePairDatastorePath(ds, vmName, vmdkName, VmwareStorageLayoutType.VMWARE, true);	String[] vmdkFullCloneModePair = getVmdkFilePairDatastorePath(ds, vmName, vmdkName, VmwareStorageLayoutType.VMWARE, false);	if (!ds.fileExists(vmdkLinkedCloneModeLegacyPair[0]) && !ds.fileExists(vmdkLinkedCloneModePair[0])) {	syncVolumeToRootFolder(dcMo, ds, vmdkName, vmName);	}	if (ds.fileExists(vmdkFullCloneModeLegacyPair[1])) {	
sync 

String[] vmdkFullCloneModeLegacyPair = getVmdkFilePairDatastorePath(ds, vmName, vmdkName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, false);	String[] vmdkLinkedCloneModePair = getVmdkFilePairDatastorePath(ds, vmName, vmdkName, VmwareStorageLayoutType.VMWARE, true);	String[] vmdkFullCloneModePair = getVmdkFilePairDatastorePath(ds, vmName, vmdkName, VmwareStorageLayoutType.VMWARE, false);	if (!ds.fileExists(vmdkLinkedCloneModeLegacyPair[0]) && !ds.fileExists(vmdkLinkedCloneModePair[0])) {	syncVolumeToRootFolder(dcMo, ds, vmdkName, vmName);	}	if (ds.fileExists(vmdkFullCloneModeLegacyPair[1])) {	ds.moveDatastoreFile(vmdkFullCloneModeLegacyPair[1], dcMo.getMor(), ds.getMor(), vmdkFullCloneModePair[1], dcMo.getMor(), true);	}	if (ds.fileExists(vmdkLinkedCloneModeLegacyPair[1])) {	
sync 

if (!ds.fileExists(vmdkLinkedCloneModeLegacyPair[0]) && !ds.fileExists(vmdkLinkedCloneModePair[0])) {	syncVolumeToRootFolder(dcMo, ds, vmdkName, vmName);	}	if (ds.fileExists(vmdkFullCloneModeLegacyPair[1])) {	ds.moveDatastoreFile(vmdkFullCloneModeLegacyPair[1], dcMo.getMor(), ds.getMor(), vmdkFullCloneModePair[1], dcMo.getMor(), true);	}	if (ds.fileExists(vmdkLinkedCloneModeLegacyPair[1])) {	ds.moveDatastoreFile(vmdkLinkedCloneModeLegacyPair[1], dcMo.getMor(), ds.getMor(), vmdkLinkedCloneModePair[1], dcMo.getMor(), true);	}	if (ds.fileExists(vmdkLinkedCloneModeLegacyPair[0])) {	
sync 

String fileDsFullPath = ds.searchFileInSubFolders(vmdkName + ".vmdk", false);	if (fileDsFullPath == null) return;	String folderName = null;	if (ds.folderExists(String.format("[%s]", ds.getName()), vmName)) {	folderName = String.format("[%s] %s", ds.getName(), vmName);	}	DatastoreFile srcDsFile = new DatastoreFile(fileDsFullPath);	String companionFilePath = srcDsFile.getCompanionPath(vmdkName + "-flat.vmdk");	if (ds.fileExists(companionFilePath)) {	String targetPath = getLegacyDatastorePathFromVmdkFileName(ds, vmdkName + "-flat.vmdk");	
fixup folder synchronization move 

}	DatastoreFile srcDsFile = new DatastoreFile(fileDsFullPath);	String companionFilePath = srcDsFile.getCompanionPath(vmdkName + "-flat.vmdk");	if (ds.fileExists(companionFilePath)) {	String targetPath = getLegacyDatastorePathFromVmdkFileName(ds, vmdkName + "-flat.vmdk");	ds.moveDatastoreFile(companionFilePath, dcMo.getMor(), ds.getMor(), targetPath, dcMo.getMor(), true);	}	companionFilePath = srcDsFile.getCompanionPath(vmdkName + "-delta.vmdk");	if (ds.fileExists(companionFilePath)) {	String targetPath = getLegacyDatastorePathFromVmdkFileName(ds, vmdkName + "-delta.vmdk");	
fixup folder synchronization move 

if (ds.fileExists(companionFilePath)) {	String targetPath = getLegacyDatastorePathFromVmdkFileName(ds, vmdkName + "-flat.vmdk");	ds.moveDatastoreFile(companionFilePath, dcMo.getMor(), ds.getMor(), targetPath, dcMo.getMor(), true);	}	companionFilePath = srcDsFile.getCompanionPath(vmdkName + "-delta.vmdk");	if (ds.fileExists(companionFilePath)) {	String targetPath = getLegacyDatastorePathFromVmdkFileName(ds, vmdkName + "-delta.vmdk");	ds.moveDatastoreFile(companionFilePath, dcMo.getMor(), ds.getMor(), targetPath, dcMo.getMor(), true);	}	String targetPath = getLegacyDatastorePathFromVmdkFileName(ds, vmdkName + ".vmdk");	
fixup folder synchronization move 

public static void moveVolumeToRootFolder(DatacenterMO dcMo, List<String> detachedDisks) throws Exception {	if (detachedDisks.size() > 0) {	for (String fileFullDsPath : detachedDisks) {	DatastoreFile file = new DatastoreFile(fileFullDsPath);	
check if we need to move to its root location 

public static void moveVolumeToRootFolder(DatacenterMO dcMo, List<String> detachedDisks) throws Exception {	if (detachedDisks.size() > 0) {	for (String fileFullDsPath : detachedDisks) {	DatastoreFile file = new DatastoreFile(fileFullDsPath);	DatastoreMO dsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(file.getDatastoreName()));	if (dsMo.getMor() != null) {	DatastoreFile targetFile = new DatastoreFile(file.getDatastoreName(), file.getFileName());	if (!targetFile.getPath().equalsIgnoreCase(file.getPath())) {	
move 

for (String fileFullDsPath : detachedDisks) {	DatastoreFile file = new DatastoreFile(fileFullDsPath);	DatastoreMO dsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(file.getDatastoreName()));	if (dsMo.getMor() != null) {	DatastoreFile targetFile = new DatastoreFile(file.getDatastoreName(), file.getFileName());	if (!targetFile.getPath().equalsIgnoreCase(file.getPath())) {	dsMo.moveDatastoreFile(file.getPath(), dcMo.getMor(), dsMo.getMor(), targetFile.getPath(), dcMo.getMor(), true);	String pairSrcFilePath = file.getCompanionPath(file.getFileBaseName() + "-flat.vmdk");	String pairTargetFilePath = targetFile.getCompanionPath(file.getFileBaseName() + "-flat.vmdk");	if (dsMo.fileExists(pairSrcFilePath)) {	
move 

if (!targetFile.getPath().equalsIgnoreCase(file.getPath())) {	dsMo.moveDatastoreFile(file.getPath(), dcMo.getMor(), dsMo.getMor(), targetFile.getPath(), dcMo.getMor(), true);	String pairSrcFilePath = file.getCompanionPath(file.getFileBaseName() + "-flat.vmdk");	String pairTargetFilePath = targetFile.getCompanionPath(file.getFileBaseName() + "-flat.vmdk");	if (dsMo.fileExists(pairSrcFilePath)) {	dsMo.moveDatastoreFile(pairSrcFilePath, dcMo.getMor(), dsMo.getMor(), pairTargetFilePath, dcMo.getMor(), true);	}	pairSrcFilePath = file.getCompanionPath(file.getFileBaseName() + "-delta.vmdk");	pairTargetFilePath = targetFile.getCompanionPath(file.getFileBaseName() + "-delta.vmdk");	if (dsMo.fileExists(pairSrcFilePath)) {	
move 

if (dsMo.fileExists(pairSrcFilePath)) {	dsMo.moveDatastoreFile(pairSrcFilePath, dcMo.getMor(), dsMo.getMor(), pairTargetFilePath, dcMo.getMor(), true);	}	pairSrcFilePath = file.getCompanionPath(file.getFileBaseName() + "-delta.vmdk");	pairTargetFilePath = targetFile.getCompanionPath(file.getFileBaseName() + "-delta.vmdk");	if (dsMo.fileExists(pairSrcFilePath)) {	dsMo.moveDatastoreFile(pairSrcFilePath, dcMo.getMor(), dsMo.getMor(), pairTargetFilePath, dcMo.getMor(), true);	}	}	} else {	
datastore for no longer exists we have to skip 

public static void deleteVolumeVmdkFiles(DatastoreMO dsMo, String volumeName, DatacenterMO dcMo) throws Exception {	String fileName = volumeName + ".vmdk";	String fileFullPath = getLegacyDatastorePathFromVmdkFileName(dsMo, fileName);	if (!dsMo.fileExists(fileFullPath)) fileFullPath = dsMo.searchFileInSubFolders(fileName, false);	if (fileFullPath != null) {	dsMo.deleteFile(fileFullPath, dcMo.getMor(), true);	} else {	
unable to locate vmdk file 

if (fileFullPath != null) {	dsMo.deleteFile(fileFullPath, dcMo.getMor(), true);	} else {	}	fileName = volumeName + "-flat.vmdk";	fileFullPath = getLegacyDatastorePathFromVmdkFileName(dsMo, fileName);	if (!dsMo.fileExists(fileFullPath)) fileFullPath = dsMo.searchFileInSubFolders(fileName, false);	if (fileFullPath != null) {	dsMo.deleteFile(fileFullPath, dcMo.getMor(), true);	} else {	
unable to locate vmdk file 

if (fileFullPath != null) {	dsMo.deleteFile(fileFullPath, dcMo.getMor(), true);	} else {	}	fileName = volumeName + "-delta.vmdk";	fileFullPath = getLegacyDatastorePathFromVmdkFileName(dsMo, fileName);	if (!dsMo.fileExists(fileFullPath)) fileFullPath = dsMo.searchFileInSubFolders(fileName, false);	if (fileFullPath != null) {	dsMo.deleteFile(fileFullPath, dcMo.getMor(), true);	} else {	
unable to locate vmdk file 

========================= cloudstack sample_1279 =========================

pstmt = txn.prepareAutoCloseStatement(sql);	for (Long accountId : accountIds) {	pstmt.setLong(1, templateId);	pstmt.setLong(2, accountId.longValue());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception e) {	txn.rollback();	
error removing launch permissions 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (isPublic) {	continue;	}	VMTemplateVO template = new VMTemplateVO(id, uniqueName, name, format, isPublic, featured, TemplateType.valueOf(tmpltType), url, createdDate, requiresHVM, bits, templateAccountId, checksum, displayText, enablePassword, guestOSId, true, null);	permittedTemplates.add(template);	}	} catch (Exception e) {	
error listing permitted templates 

========================= cloudstack sample_4581 =========================

public void execute(){	UserVm result;	if (getStartVm()) {	try {	CallContext.current().setEventDetails("Vm Id: "+getEntityId());	result = _userVmService.startVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	
exception 

public void execute(){	UserVm result;	if (getStartVm()) {	try {	CallContext.current().setEventDetails("Vm Id: "+getEntityId());	result = _userVmService.startVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3244 =========================

eventDescription.put("resource", resourceName);	eventDescription.put("id", vo.getUuid());	eventDescription.put("old-state", oldState.name());	eventDescription.put("new-state", newState.name());	String eventDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());	eventDescription.put("eventDateTime", eventDate);	eventMsg.setDescription(eventDescription);	try {	s_eventBus.publish(eventMsg);	} catch (EventBusException e) {	
failed to publish state change event on the the event bus 

========================= cloudstack sample_2422 =========================

try {	String sql = ACTIVE_AND_RECENTLY_DELETED_SEARCH + " LIMIT " + startIndex + "," + limit;	PreparedStatement pstmt = null;	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), minRemovedDate));	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	userStats.add(toEntityBean(rs, false));	}	} catch (Exception ex) {	
error saving user stats to cloud usage db 

List<UserStatisticsVO> userStats = new ArrayList<UserStatisticsVO>();	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement pstmt = null;	pstmt = txn.prepareAutoCloseStatement(UPDATED_STATS_SEARCH);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	userStats.add(toEntityBean(rs, false));	}	} catch (Exception ex) {	
error lisitng updated user stats 

========================= cloudstack sample_4519 =========================

public void create() {	try {	RemoteAccessVpn vpn = _ravService.createRemoteAccessVpn(publicIpId, ipRange, getOpenFirewall(), isDisplay());	if (vpn != null) {	setEntityId(vpn.getId());	setEntityUuid(vpn.getUuid());	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create remote access vpn");	}	} catch (NetworkRuleConflictException e) {	
network rule conflict 

public void create() {	try {	RemoteAccessVpn vpn = _ravService.createRemoteAccessVpn(publicIpId, ipRange, getOpenFirewall(), isDisplay());	if (vpn != null) {	setEntityId(vpn.getId());	setEntityUuid(vpn.getUuid());	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create remote access vpn");	}	} catch (NetworkRuleConflictException e) {	
network rule conflict 

try {	RemoteAccessVpn result = _ravService.startRemoteAccessVpn(publicIpId, getOpenFirewall());	if (result != null) {	RemoteAccessVpnResponse response = _responseGenerator.createRemoteAccessVpnResponse(result);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create remote access vpn");	}	} catch (ResourceUnavailableException ex) {	
exception 

========================= cloudstack sample_3376 =========================

public <T> T getNextSequence(Class<T> clazz, TableGenerator tg, Object key, boolean isRandom) {	Future<T> future = _executors.submit(new Fetcher<T>(clazz, tg, key, isRandom));	try {	return future.get();	} catch (Exception e) {	
unable to get sequeunce for 

} else if (_clazz.isAssignableFrom(Integer.class)) {	obj = rs.getInt(1);	} else {	obj = rs.getObject(1);	}	}	} catch (SQLException e) {	s_logger.warn("Caught this exception when running: " + (selectStmt != null ? selectStmt.toString() : ""), e);	}	if (obj == null) {	
unable to get a sequence 

========================= cloudstack sample_555 =========================

suspendAutoLoading = true;	}	}	List<SecondaryStorageVmVO> alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Running, State.Migrating, State.Starting);	if (alreadyRunning.size() == 0) {	s_logger.info("No running secondary storage vms found in datacenter id=" + dataCenterId + ", starting one");	List<SecondaryStorageVmVO> stopped = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Stopped, State.Stopping);	if (stopped.size() == 0 || !suspendAutoLoading) {	List<SecondaryStorageVmVO> stopping = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, State.Stopping);	if (stopping.size() > 0) {	
found ssvms that are currently at stopping state wait until they are settled 

if (stopped.size() == 0 || !suspendAutoLoading) {	List<SecondaryStorageVmVO> stopping = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, State.Stopping);	if (stopping.size() > 0) {	return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);	}	expandPool(pool, SecondaryStorageVm.Role.templateProcessor);	}	}	if (!suspendAutoLoading) {	if (alreadyRunning.size() == 0) {	
primary secondary storage is not even started wait until next turn 

expandPool(pool, SecondaryStorageVm.Role.templateProcessor);	}	}	if (!suspendAutoLoading) {	if (alreadyRunning.size() == 0) {	return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);	}	alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, dataCenterId, State.Running, State.Migrating, State.Starting);	List<CommandExecLogVO> activeCmds = listActiveCommands(dataCenterId, cutTime);	if (alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() < _standbyCapacity) {	
secondary storage command execution standby capactiy low running vms active cmds starting a new one 

========================= cloudstack sample_5021 =========================

final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(command.getVmName());	final List<InterfaceDef> nics = libvirtComputingResource.getInterfaces(conn, command.getVmName());	vif = nics.get(0).getDevName();	brname = nics.get(0).getBrName();	} catch (final LibvirtException e) {	return new SecurityGroupRuleAnswer(command, false, e.toString());	}	final boolean result = libvirtComputingResource.addNetworkRules(command.getVmName(), Long.toString(command.getVmId()), command.getGuestIp(), command.getSignature(), Long.toString(command.getSeqNum()), command.getGuestMac(), command.stringifyRules(), vif, brname, command.getSecIpsString());	if (!result) {	
failed to program network rules for vm 

========================= cloudstack sample_1062 =========================

private Pair<String, Long> getPodCidr(long podId, long dcId) {	try {	HashMap<Long, List<Object>> podMap = _podDao.getCurrentPodCidrSubnets(dcId, 0);	List<Object> cidrPair = podMap.get(podId);	String cidrAddress = (String)cidrPair.get(0);	Long cidrSize = (Long)cidrPair.get(1);	return new Pair<String, Long>(cidrAddress, cidrSize);	} catch (PatternSyntaxException e) {	
exception while splitting pod cidr 

private Pair<String, Long> getPodCidr(long podId, long dcId) {	try {	HashMap<Long, List<Object>> podMap = _podDao.getCurrentPodCidrSubnets(dcId, 0);	List<Object> cidrPair = podMap.get(podId);	String cidrAddress = (String)cidrPair.get(0);	Long cidrSize = (Long)cidrPair.get(1);	return new Pair<String, Long>(cidrAddress, cidrSize);	} catch (PatternSyntaxException e) {	return null;	} catch (IndexOutOfBoundsException e) {	
invalid pod cidr please check 

mockHost.setStorageMacAddress(macAddress);	mockHost.setVersion(this.getClass().getPackage().getImplementationVersion());	mockHost.setResource("com.cloud.agent.AgentRoutingResource");	TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.SIMULATOR_DB);	try {	txn.start();	mockHost = _mockHostDao.persist(mockHost);	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error while configuring mock agent 

}	_storageMgr.getLocalStorage(guid, localStorageSize);	agentResource = new AgentRoutingResource();	if (agentResource != null) {	try {	params.put("guid", mockHost.getGuid());	agentResource.start();	agentResource.configure(mockHost.getName(), params);	newResources.put(agentResource, args);	} catch (ConfigurationException e) {	
error while configuring server resource 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	try {	random = SecureRandom.getInstance("SHA1PRNG");	_executor = new ThreadPoolExecutor(1, 5, 1, TimeUnit.DAYS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("Simulator-Agent-Mgr"));	} catch (NoSuchAlgorithmException e) {	
failed to initialize random 

} finally {	txn.close();	txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);	txn.close();	}	HostVO host = hostDao.findByGuid(this.guid);	if (host != null) {	try {	_resourceMgr.deleteHost(host.getId(), true, true);	} catch (Exception e) {	
failed to delete host 

Map<String, String> details = new HashMap<String, String>();	params.put("guid", this.guid);	details.put("guid", this.guid);	storageResource.configure("secondaryStorage", params);	storageResource.start();	_resources.put(this.guid, storageResource);	discoverer.setResource(storageResource);	SimulatorAddSecondaryAgent cmd = new SimulatorAddSecondaryAgent("sim: try {	_resourceMgr.discoverHosts(cmd);	} catch (DiscoveryException e) {	
failed to discover host 

storageResource.start();	_resources.put(this.guid, storageResource);	discoverer.setResource(storageResource);	SimulatorAddSecondaryAgent cmd = new SimulatorAddSecondaryAgent("sim: try {	_resourceMgr.discoverHosts(cmd);	} catch (DiscoveryException e) {	CallContext.unregister();	return;	}	} catch (ConfigurationException e) {	
failed to load secondary storage resource 

public MockHost getHost(String guid) {	TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.SIMULATOR_DB);	try {	txn.start();	MockHost _host = _mockHostDao.findByGuid(guid);	txn.commit();	if (_host != null) {	return _host;	} else {	
host with guid was not found 

public Answer checkNetworkCommand(CheckNetworkCommand cmd) {	if (s_logger.isDebugEnabled()) {	
checking if network name setup is done on the resource 

========================= cloudstack sample_943 =========================

public void disconnect(final Status state) {	synchronized (this) {	
processing disconnect 

protected void finalize() throws Throwable {	try {	assert _link == null : "Duh...Says you....Forgot to call disconnect()!";	synchronized (this) {	if (_link != null) {	
lost attache 

========================= cloudstack sample_4775 =========================

public void create() throws ResourceAllocationException {	try {	PortableIpRange portableIpRange = _configService.createPortableIpRange(this);	if (portableIpRange != null) {	this.setEntityId(portableIpRange.getId());	this.setEntityUuid(portableIpRange.getUuid());	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create portable public IP range");	}	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3264 =========================

public <T> void executeUpdateObject(final T newObject, final String path, final Map<String, String> parameters) throws CloudstackRESTException {	
executing update object on 

public <T> T executeCreateObject(final T newObject, final String path, final Map<String, String> parameters) throws CloudstackRESTException {	
executing create object on 

public void executeDeleteObject(final String path) throws CloudstackRESTException {	
executing delete object on 

public <T> T executeRetrieveObject(final Type returnObjectType, final String path, final Map<String, String> parameters) throws CloudstackRESTException {	
executing retrieve object on 

private CloseableHttpResponse createAndExecuteRequest(final HttpMethods method, final String path, final Map<String, String> parameters, final Optional<String> jsonPayLoad) throws CloudstackRESTException {	final HttpUriRequest httpRequest = HttpUriRequestBuilder.create() .path(path) .parameters(parameters) .jsonPayload(jsonPayLoad) .method(method) .build();	if (jsonPayLoad.isPresent()) {	
built request with payload 

private CloseableHttpResponse executeRequest(final HttpUriRequest httpRequest) throws CloudstackRESTException {	final CloseableHttpResponse response = client.execute(httpRequest);	
executed request status was 

========================= cloudstack sample_2863 =========================

public void handleAsyncJobPublishEvent(String subject, String senderAddress, Object args) {	assert (args != null);	Pair<AsyncJob, String> eventInfo = (Pair<AsyncJob, String>)args;	AsyncJob job = eventInfo.first();	String jobEvent = eventInfo.second();	
handle asyjob publish event 

User userJobOwner = accountMgr.getUserIncludingRemoved(job.getUserId());	Account jobOwner = accountMgr.getAccount(userJobOwner.getAccountId());	String info = job.getCmdInfo();	String cmdEventType = "unknown";	if (info != null) {	Type type = new TypeToken<Map<String, String>>(){}.getType();	Map<String, String> cmdInfo = ApiGsonHelper.getBuilder().create().fromJson(info, type);	String eventTypeObj = cmdInfo.get("cmdEventType");	if (eventTypeObj != null) {	cmdEventType = eventTypeObj;	
retrieved cmdeventtype from job info 

Account jobOwner = accountMgr.getAccount(userJobOwner.getAccountId());	String info = job.getCmdInfo();	String cmdEventType = "unknown";	if (info != null) {	Type type = new TypeToken<Map<String, String>>(){}.getType();	Map<String, String> cmdInfo = ApiGsonHelper.getBuilder().create().fromJson(info, type);	String eventTypeObj = cmdInfo.get("cmdEventType");	if (eventTypeObj != null) {	cmdEventType = eventTypeObj;	} else {	
unable to locate cmdeventtype marker in job info publish as unknown event 

final ConfigurationVO apiPortConfig = values.get(0);	if (apiPortConfig.getValue() != null) {	apiPort = Integer.parseInt(apiPortConfig.getValue());	}	}	final Map<String, String> configs = configDao.getConfiguration();	final String strSnapshotLimit = configs.get(Config.ConcurrentSnapshotsThresholdPerHost.key());	if (strSnapshotLimit != null) {	final Long snapshotLimit = NumbersUtil.parseLong(strSnapshotLimit, 1L);	if (snapshotLimit.longValue() <= 0) {	
global config parameter is less or equal defaulting to unlimited 

final Long snapshotLimit = NumbersUtil.parseLong(strSnapshotLimit, 1L);	if (snapshotLimit.longValue() <= 0) {	} else {	dispatcher.setCreateSnapshotQueueSizeLimit(snapshotLimit);	}	}	final Set<Class<?>> cmdClasses = new HashSet<Class<?>>();	for (final PluggableService pluggableService : pluggableServices) {	cmdClasses.addAll(pluggableService.getCommands());	if (s_logger.isDebugEnabled()) {	
discovered plugin 

if (connObj instanceof SocketHttpServerConnection) {	final InetAddress remoteAddr = ((SocketHttpServerConnection)connObj).getRemoteAddress();	sb.append(remoteAddr.toString() + " -- ");	}	sb.append(StringUtils.cleanString(request.getRequestLine().toString()));	try {	List<NameValuePair> paramList = null;	try {	paramList = URLEncodedUtils.parse(new URI(request.getRequestLine().getUri()), HttpUtils.UTF_8);	} catch (final URISyntaxException e) {	
error parsing url request 

CallContext.register(accountMgr.getSystemUser(), accountMgr.getSystemAccount());	sb.insert(0, "(userId=" + User.UID_SYSTEM + " accountId=" + Account.ACCOUNT_ID_SYSTEM + " sessionId=" + null + ") ");	final String responseText = handleRequest(parameterMap, responseType, sb);	sb.append(" 200 " + ((responseText == null) ? 0 : responseText.length()));	writeResponse(response, responseText, HttpStatus.SC_OK, responseType, null);	} catch (final ServerApiException se) {	final String responseText = getSerializedApiError(se, parameterMap, responseType);	writeResponse(response, responseText, se.getErrorCode().getHttpCode(), responseType, se.getDescription());	sb.append(" " + se.getErrorCode() + " " + se.getDescription());	} catch (final RuntimeException e) {	
unhandled exception 

public String handleRequest(final Map params, final String responseType, final StringBuilder auditTrailSb) throws ServerApiException {	checkCharacterInkParams(params);	String response = null;	String[] command = null;	try {	command = (String[])params.get("command");	if (command == null) {	
invalid request no command sent 

public String handleRequest(final Map params, final String responseType, final StringBuilder auditTrailSb) throws ServerApiException {	checkCharacterInkParams(params);	String response = null;	String[] command = null;	try {	command = (String[])params.get("command");	if (command == null) {	if (s_logger.isTraceEnabled()) {	
dumping request parameters 

if ("command".equalsIgnoreCase(key)) {	continue;	}	final String[] value = (String[])params.get(key);	paramMap.put(key, value[0]);	}	Class<?> cmdClass = getCmdClass(command[0]);	if (cmdClass != null) {	APICommand annotation = cmdClass.getAnnotation(APICommand.class);	if (annotation == null) {	
no apicommand annotation found for class 

} catch (final PermissionDeniedException ex) {	final ArrayList<ExceptionProxyObject> idList = ex.getIdProxyList();	if (idList != null) {	final StringBuffer buf = new StringBuffer();	for (final ExceptionProxyObject obj : idList) {	buf.append(obj.getDescription());	buf.append(":");	buf.append(obj.getUuid());	buf.append(" ");	}	
permissiondenied on objs 

final ArrayList<ExceptionProxyObject> idList = ex.getIdProxyList();	if (idList != null) {	final StringBuffer buf = new StringBuffer();	for (final ExceptionProxyObject obj : idList) {	buf.append(obj.getDescription());	buf.append(":");	buf.append(obj.getUuid());	buf.append(" ");	}	} else {	
permissiondenied 

public boolean verifyRequest(final Map<String, Object[]> requestParameters, final Long userId) throws ServerApiException {	try {	String apiKey = null;	String secretKey = null;	String signature = null;	String unsignedRequest = null;	final String[] command = (String[])requestParameters.get(ApiConstants.COMMAND);	if (command == null) {	
missing command ignoring request 

}	final String commandName = command[0];	if (userId != null) {	final User user = ApiDBUtils.findUserById(userId);	try {	checkCommandAvailable(user, commandName);	} catch (final RequestLimitException ex) {	s_logger.debug(ex.getMessage());	throw new ServerApiException(ApiErrorCode.API_LIMIT_EXCEED, ex.getMessage());	} catch (final PermissionDeniedException ex) {	
the user with id is not allowed to request the api command or the api command does not exist 

checkCommandAvailable(user, commandName);	} catch (final RequestLimitException ex) {	s_logger.debug(ex.getMessage());	throw new ServerApiException(ApiErrorCode.API_LIMIT_EXCEED, ex.getMessage());	} catch (final PermissionDeniedException ex) {	throw new ServerApiException(ApiErrorCode.UNSUPPORTED_ACTION_ERROR, "The user is not allowed to request the API command or the API command does not exist");	}	return true;	} else {	if (!s_apiNameCmdClassMap.containsKey(commandName) && !commandName.equals("login") && !commandName.equals("logout")) {	
the user with id is not allowed to request the api command or the api command does not exist 

expires = paramValue;	}	if (unsignedRequest == null) {	unsignedRequest = paramName + "=" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll("\\+", "%20");	} else {	unsignedRequest = unsignedRequest + "&" + paramName + "=" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll("\\+", "%20");	}	}	}	if ((signature == null) || (apiKey == null)) {	
expired session missing signature or missing apikey ignoring request signature apikey 

unsignedRequest = unsignedRequest + "&" + paramName + "=" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll("\\+", "%20");	}	}	}	if ((signature == null) || (apiKey == null)) {	return false;	}	Date expiresTS = null;	if ("3".equals(signatureVersion)) {	if (expires == null) {	
missing expires parameter ignoring request signature apikey 

}	Date expiresTS = null;	if ("3".equals(signatureVersion)) {	if (expires == null) {	return false;	}	synchronized (DateFormatToUse) {	try {	expiresTS = DateFormatToUse.parse(expires);	} catch (final ParseException pe) {	
incorrect date format for expires parameter 

}	synchronized (DateFormatToUse) {	try {	expiresTS = DateFormatToUse.parse(expires);	} catch (final ParseException pe) {	return false;	}	}	final Date now = new Date(System.currentTimeMillis());	if (expiresTS.before(now)) {	
request expired ignoring sig apikey 

final Date now = new Date(System.currentTimeMillis());	if (expiresTS.before(now)) {	return false;	}	}	final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);	txn.close();	User user = null;	final Pair<User, Account> userAcctPair = accountMgr.findUserByApiKey(apiKey);	if (userAcctPair == null) {	
apikey does not map to a valid user ignoring request apikey 

if (user.getState() != Account.State.enabled || !account.getState().equals(Account.State.enabled)) {	s_logger.info("disabled or locked user accessing the api, userid = " + user.getId() + "; name = " + user.getUsername() + "; state: " + user.getState() + "; accountState: " + account.getState());	return false;	}	try {	checkCommandAvailable(user, commandName);	} catch (final RequestLimitException ex) {	s_logger.debug(ex.getMessage());	throw new ServerApiException(ApiErrorCode.API_LIMIT_EXCEED, ex.getMessage());	} catch (final PermissionDeniedException ex) {	
the given command does not exist or it is not available for user 

try {	checkCommandAvailable(user, commandName);	} catch (final RequestLimitException ex) {	s_logger.debug(ex.getMessage());	throw new ServerApiException(ApiErrorCode.API_LIMIT_EXCEED, ex.getMessage());	} catch (final PermissionDeniedException ex) {	throw new ServerApiException(ApiErrorCode.UNSUPPORTED_ACTION_ERROR, "The given command:" + commandName + " does not exist or it is not available for user with id:" + userId);	}	secretKey = user.getSecretKey();	if (secretKey == null) {	
user does not have a secret key associated with the account ignoring request username 

}	unsignedRequest = unsignedRequest.toLowerCase();	final Mac mac = Mac.getInstance("HmacSHA1");	final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), "HmacSHA1");	mac.init(keySpec);	mac.update(unsignedRequest.getBytes());	final byte[] encryptedBytes = mac.doFinal();	final String computedSignature = Base64.encodeBase64String(encryptedBytes);	final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);	if (!equalSig) {	
user signature is not equaled to computed signature 

final String computedSignature = Base64.encodeBase64String(encryptedBytes);	final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);	if (!equalSig) {	} else {	CallContext.register(user, account);	}	return equalSig;	} catch (final ServerApiException ex) {	throw ex;	} catch (final Exception ex) {	
unable to verify request signature 

body.setContentType("text/xml");	if (responseText == null) {	body.setContent(new ByteArrayInputStream("<error>Internal Server Error</error>".getBytes(HttpUtils.UTF_8)));	}	}	if (responseText != null) {	body.setContent(new ByteArrayInputStream(responseText.getBytes(HttpUtils.UTF_8)));	}	resp.setEntity(body);	} catch (final Exception ex) {	
error 

public ListenerThread(final ApiServer requestHandler, final int port) {	try {	_serverSocket = new ServerSocket(port);	} catch (final IOException ioex) {	
error initializing api server 

public void run() {	
apiserver listening on port 

public void run() {	while (!Thread.interrupted()) {	try {	final Socket socket = _serverSocket.accept();	final DefaultHttpServerConnection conn = new DefaultHttpServerConnection();	conn.bind(socket, _params);	s_executor.execute(new WorkerTask(_httpService, conn, s_workerCount++));	} catch (final InterruptedIOException ex) {	break;	} catch (final IOException e) {	
i o error initializing connection thread 

protected void runInContext() {	final HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && _conn.isOpen()) {	_httpService.handleRequest(_conn, context);	_conn.close();	}	} catch (final ConnectionClosedException ex) {	if (s_logger.isTraceEnabled()) {	
apiserver client closed connection 

try {	while (!Thread.interrupted() && _conn.isOpen()) {	_httpService.handleRequest(_conn, context);	_conn.close();	}	} catch (final ConnectionClosedException ex) {	if (s_logger.isTraceEnabled()) {	}	} catch (final IOException ex) {	if (s_logger.isTraceEnabled()) {	
apiserver ioexception 

_httpService.handleRequest(_conn, context);	_conn.close();	}	} catch (final ConnectionClosedException ex) {	if (s_logger.isTraceEnabled()) {	}	} catch (final IOException ex) {	if (s_logger.isTraceEnabled()) {	}	} catch (final HttpException ex) {	
apiserver unrecoverable http protocol violation 

}	}	}	final ExceptionResponse apiResponse = new ExceptionResponse();	apiResponse.setErrorCode(errorCode);	apiResponse.setErrorText(errorText);	apiResponse.setResponseName(responseName);	SerializationContext.current().setUuidTranslation(true);	responseText = ApiResponseSerializer.toSerializedString(apiResponse, responseType);	} catch (final Exception e) {	
exception responding to http request 

final ArrayList<ExceptionProxyObject> idList = ex.getIdProxyList();	if (idList != null) {	for (int i = 0; i < idList.size(); i++) {	apiResponse.addProxyObject(idList.get(i));	}	}	apiResponse.setCSErrorCode(ex.getCSErrorCode());	SerializationContext.current().setUuidTranslation(true);	responseText = ApiResponseSerializer.toSerializedString(apiResponse, responseType);	} catch (final Exception e) {	
exception responding to http request 

========================= cloudstack sample_2530 =========================

for (final String vmName : vmNames) {	final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(vmName);	try {	final VmStatsEntry statEntry = libvirtComputingResource.getVmStat(conn, vmName);	if (statEntry == null) {	continue;	}	vmStatsNameMap.put(vmName, statEntry);	} catch (LibvirtException e) {	
can t get vm stats continue 

final VmStatsEntry statEntry = libvirtComputingResource.getVmStat(conn, vmName);	if (statEntry == null) {	continue;	}	vmStatsNameMap.put(vmName, statEntry);	} catch (LibvirtException e) {	}	}	return new GetVmStatsAnswer(command, vmStatsNameMap);	} catch (final LibvirtException e) {	
can t get vm stats 

========================= cloudstack sample_1035 =========================

pstmt = conn.prepareStatement("INSERT INTO firewall_rules (ip_address_id, start_port, end_port, protocol, account_id, domain_id, network_id, purpose, state, xid, created, related) VALUES (?, ?, ?, ?, ?, ?, ?, 'Firewall', 'Active', ?, now(), ?)");	pstmt.setLong(1, ipId);	pstmt.setInt(2, startPort);	pstmt.setInt(3, endPort);	pstmt.setString(4, protocol);	pstmt.setLong(5, accountId);	pstmt.setLong(6, domainId);	pstmt.setLong(7, networkId);	pstmt.setString(8, UUID.randomUUID().toString());	pstmt.setLong(9, id);	
updating firewall rule with the statement 

throw new CloudRuntimeException("Unable to update firewall rule id=" + currentRuleId, e);	} finally {	try {	if (rs != null) {	rs.close();	}	if (pstmt != null) {	pstmt.close();	}	} catch (SQLException e) {	
ignored 

========================= cloudstack sample_4237 =========================

private void initializeDriversMap() {	if (outOfBandManagementDriversMap.isEmpty() && outOfBandManagementDrivers != null && outOfBandManagementDrivers.size() > 0) {	for (final OutOfBandManagementDriver driver : outOfBandManagementDrivers) {	outOfBandManagementDriversMap.put(driver.getName().toLowerCase(), driver);	}	
discovered out of band management drivers configured in the outofbandmanagementservice 

final OutOfBandManagement updatedOutOfBandManagementConfig = outOfBandManagementDao.findByHost(host.getId());	updatedOutOfBandManagementConfig.setPassword(newPassword);	boolean result = outOfBandManagementDao.update(updatedOutOfBandManagementConfig.getId(), (OutOfBandManagementVO) updatedOutOfBandManagementConfig);	if (!result) {	throw new CloudRuntimeException(String.format("Failed to change out-of-band management password for host (%s) in the database.", host.getUuid()));	}	final OutOfBandManagementDriverResponse driverResponse;	try {	driverResponse = driver.execute(changePasswordCmd);	} catch (Exception e) {	
out of band management change password failed due to driver error 

========================= cloudstack sample_2249 =========================

storageIp = url;	storagePort = 2049;	storagetype = StoragePoolType.NetworkFilesystem;	accesspath = storageIp + ":/" + storagePoolName;	}	if (details.get("esaccountid") != null) ElastistorUtil.setElastistorAccountId(details.get("esaccountid"));	if (details.get("esdefaultgateway") != null) ElastistorUtil.setElastistorGateway(details.get("esdefaultgateway"));	if (details.get("estntinterface") != null) ElastistorUtil.setElastistorInterface(details.get("estntinterface"));	if (details.get("espoolid") != null) ElastistorUtil.setElastistorPoolId(details.get("espoolid"));	if (details.get("essubnet") != null) ElastistorUtil.setElastistorSubnet(details.get("essubnet"));	
elastistor details was set successfully 

if (details.get("espoolid") != null) ElastistorUtil.setElastistorPoolId(details.get("espoolid"));	if (details.get("essubnet") != null) ElastistorUtil.setElastistorSubnet(details.get("essubnet"));	if (capacityBytes == null || capacityBytes <= 0) {	throw new IllegalArgumentException("'capacityBytes' must be present and greater than 0.");	}	if (capacityIops == null || capacityIops <= 0) {	throw new IllegalArgumentException("'capacityIops' must be present and greater than 0.");	}	if (domainName == null) {	domainName = "ROOT";	
setting the domain to root 

private Tsm createElastistorTSM(String storagePoolName, String storageIp, Long capacityBytes, Long capacityIops, String domainName) {	
creation of elastistor tsm started 

private Tsm createElastistorTSM(String storagePoolName, String storageIp, Long capacityBytes, Long capacityIops, String domainName) {	Tsm tsm;	String elastistorAccountId;	try {	elastistorAccountId = ElastistorUtil.getElastistorAccountId(domainName);	tsm = ElastistorUtil.createElastistorTsm(storagePoolName, storageIp, capacityBytes, capacityIops, elastistorAccountId);	} catch (Throwable e) {	
failed to create tsm in elastistor 

private Tsm createElastistorTSM(String storagePoolName, String storageIp, Long capacityBytes, Long capacityIops, String domainName) {	Tsm tsm;	String elastistorAccountId;	try {	elastistorAccountId = ElastistorUtil.getElastistorAccountId(domainName);	tsm = ElastistorUtil.createElastistorTsm(storagePoolName, storageIp, capacityBytes, capacityIops, elastistorAccountId);	} catch (Throwable e) {	throw new CloudRuntimeException("Failed to create TSM in elastistor. " + e.getMessage());	}	
creation of elastistor tsm completed successfully 

private PrimaryDataStoreParameters createElastistorVolume(PrimaryDataStoreParameters parameters, Tsm tsm, String storagePoolName, Long capacityBytes, Long capacityIops, String protocoltype, String mountpoint) {	try {	
creation of elastistor volume started 

private PrimaryDataStoreParameters createElastistorVolume(PrimaryDataStoreParameters parameters, Tsm tsm, String storagePoolName, Long capacityBytes, Long capacityIops, String protocoltype, String mountpoint) {	try {	FileSystem volume = ElastistorUtil.createElastistorVolume(storagePoolName, tsm.getUuid(), capacityBytes, capacityIops, protocoltype, mountpoint);	if (protocoltype.contentEquals("iscsi")) {	String accesspath = "/" + volume.getIqn() + "/0";	parameters.setPath(accesspath);	}	
creation of elastistor volume completed successfully 

private PrimaryDataStoreParameters createElastistorVolume(PrimaryDataStoreParameters parameters, Tsm tsm, String storagePoolName, Long capacityBytes, Long capacityIops, String protocoltype, String mountpoint) {	try {	FileSystem volume = ElastistorUtil.createElastistorVolume(storagePoolName, tsm.getUuid(), capacityBytes, capacityIops, protocoltype, mountpoint);	if (protocoltype.contentEquals("iscsi")) {	String accesspath = "/" + volume.getIqn() + "/0";	parameters.setPath(accesspath);	}	return parameters;	} catch (Throwable e) {	
failed to create volume in elastistor 

}	if (!dataStoreVO.isManaged()) {	boolean success = false;	for (HostVO h : allHosts) {	success = createStoragePool(h.getId(), primarystore);	if (success) {	break;	}	}	}	
in createpool adding the pool to each of the hosts 

break;	}	}	}	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO h : allHosts) {	try {	storageMgr.connectHostToSharedPool(h.getId(), primarystore.getId());	poolHosts.add(h);	} catch (Exception e) {	
unable to establish a connection between and 

}	}	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO h : allHosts) {	try {	storageMgr.connectHostToSharedPool(h.getId(), primarystore.getId());	poolHosts.add(h);	} catch (Exception e) {	}	if (poolHosts.isEmpty()) {	
no host can access storage pool on cluster 

private boolean createStoragePool(long hostId, StoragePool pool) {	
creating pool on host 

private boolean createStoragePool(long hostId, StoragePool pool) {	if (pool.getPoolType() != StoragePoolType.NetworkFilesystem && pool.getPoolType() != StoragePoolType.Filesystem && pool.getPoolType() != StoragePoolType.IscsiLUN && pool.getPoolType() != StoragePoolType.Iscsi && pool.getPoolType() != StoragePoolType.VMFS && pool.getPoolType() != StoragePoolType.SharedMountPoint && pool.getPoolType() != StoragePoolType.PreSetup && pool.getPoolType() != StoragePoolType.OCFS2 && pool.getPoolType() != StoragePoolType.RBD && pool.getPoolType() != StoragePoolType.CLVM) {	
doesn t support storage pool type 

public boolean attachZone(DataStore dataStore, ZoneScope scope, HypervisorType hypervisorType) {	List<HostVO> hosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(hypervisorType, scope.getScopeId());	
in createpool attaching the pool to each of the hosts 

public boolean attachZone(DataStore dataStore, ZoneScope scope, HypervisorType hypervisorType) {	List<HostVO> hosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(hypervisorType, scope.getScopeId());	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO host : hosts) {	try {	storageMgr.connectHostToSharedPool(host.getId(), dataStore.getId());	poolHosts.add(host);	} catch (Exception e) {	
unable to establish a connection between and 

List<HostVO> hosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(hypervisorType, scope.getScopeId());	List<HostVO> poolHosts = new ArrayList<HostVO>();	for (HostVO host : hosts) {	try {	storageMgr.connectHostToSharedPool(host.getId(), dataStore.getId());	poolHosts.add(host);	} catch (Exception e) {	}	}	if (poolHosts.isEmpty()) {	
no host can access storage pool in this zone 

if (!(storagePoolVO.isManaged())) {	for (StoragePoolHostVO host : hostPoolRecords) {	DeleteStoragePoolCommand deleteCmd = new DeleteStoragePoolCommand(pool);	final Answer answer = agentMgr.easySend(host.getHostId(), deleteCmd);	if (answer != null && answer.getResult()) {	if (HypervisorType.KVM != hType) {	break;	}	} else {	if (answer != null) {	
failed to delete storage pool 

private void deleteElastistorVolume(StoragePool pool, boolean managed) {	String poolid = pool.getUuid();	boolean status;	try {	status = ElastistorUtil.deleteElastistorTsm(poolid, managed);	} catch (Throwable e) {	throw new CloudRuntimeException("Failed to delete primary storage on elastistor" + e);	}	if (status == true) {	
deletion of elastistor primary storage complete 

private void deleteElastistorVolume(StoragePool pool, boolean managed) {	String poolid = pool.getUuid();	boolean status;	try {	status = ElastistorUtil.deleteElastistorTsm(poolid, managed);	} catch (Throwable e) {	throw new CloudRuntimeException("Failed to delete primary storage on elastistor" + e);	}	if (status == true) {	} else {	
deletion of elastistor volume failed 

StoragePoolVO storagePoolVO = _storagePoolDao.findById(storagePool.getId());	try {	if(capacityBytes != null){	long usedBytes = _capacityMgr.getUsedBytes(storagePoolVO);	if (Long.parseLong(capacityBytes) < usedBytes) {	throw new CloudRuntimeException("Cannot reduce the number of bytes for this storage pool as it would lead to an insufficient number of bytes");	}	UpdateTsmStorageCmdResponse updateTsmStorageCmdResponse  = ElastistorUtil.updateElastistorTsmStorage(capacityBytes,storagePool.getUuid());	if(updateTsmStorageCmdResponse.getStorage().getId() != null){	_storagePoolDao.updateCapacityBytes(storagePool.getId(), Long.parseLong(capacityBytes));	
elastistor tsm storage successfully updated 

}	if(capacityIops != null){	long usedIops = _capacityMgr.getUsedIops(storagePoolVO);	long capacity = Long.parseLong(capacityIops);	if (capacity < usedIops) {	throw new CloudRuntimeException("Cannot reduce the number of IOPS for this storage pool as it would lead to an insufficient number of IOPS");	}	UpdateTsmCmdResponse updateTsmCmdResponse   = ElastistorUtil.updateElastistorTsmIOPS(capacityIops,storagePool.getUuid());	if(updateTsmCmdResponse.getTsm(0).getUuid() != null){	_storagePoolDao.updateCapacityIops(storagePool.getId(), capacity);	
elastistor tsm iops successfully updated 

========================= cloudstack sample_1936 =========================

String entityUuid = null;	CallContext context = CallContext.current();	Class<?> entityClass = EventTypes.getEntityClassForEvent(eventType);	if (entityClass != null){	Object param = context.getContextParameter(entityClass);	if(param != null){	try {	entityUuid = getEntityUuid(entityClass, param);	entityType = entityClass.getName();	} catch (Exception e){	
caught exception while finding entityuuid moving on 

eventDescription.put("entity", entityType);	eventDescription.put("entityuuid", entityUuid);	populateFirstClassEntities(eventDescription);	eventDescription.put("description", description);	String eventDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").format(new Date());	eventDescription.put("eventDateTime", eventDate);	event.setDescription(eventDescription);	try {	s_eventBus.publish(event);	} catch (EventBusException e) {	
failed to publish action event on the the event bus 

private static long getDomainId(long accountId) {	AccountVO account = s_accountDao.findByIdIncludingRemoved(accountId);	if (account == null) {	
failed to find account including removed ones by id 

CallContext context = CallContext.current();	Map<Object, Object> contextMap = context.getContextParameters();	for(Map.Entry<Object, Object> entry : contextMap.entrySet()){	try{	Class<?> clz = (Class<?>)entry.getKey();	if(clz != null && Identity.class.isAssignableFrom(clz)){	String uuid = getEntityUuid(clz, entry.getValue());	eventDescription.put(ReflectUtil.getEntityName(clz), uuid);	}	} catch (Exception e){	
caught exception while populating first class entities for event bus moving on 

========================= cloudstack sample_2619 =========================

public boolean executeTest() {	int error = 0;	Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	
test case failed command that was supposed to fail passed the command was sent with the following url 

for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	
test case passed 

Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	
test case failed empty response was expected command was sent with url 

error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	}	} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use the command was sent with url 

if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	}	} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	
test case passed 

} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	
test case failed command was sent with url 

if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(this.getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	
the command is required for the future use so exiging 

} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	return false;	}	error++;	} else if (api.getTestCaseInfo() != null) {	
test case passed 

========================= cloudstack sample_447 =========================

public boolean start() {	if (_api == null) {	return true;	}	_dbSyncTimer = new Timer("DBSyncTimer");	try {	_dbSyncTimer.schedule(new DBSyncTask(), 0, _dbSyncInterval);	} catch (Exception ex) {	
unable to start db sync timer 

public boolean start() {	if (_api == null) {	return true;	}	_dbSyncTimer = new Timer("DBSyncTimer");	try {	_dbSyncTimer.schedule(new DBSyncTask(), 0, _dbSyncInterval);	} catch (Exception ex) {	
timer start 

_dbSyncInterval = Integer.parseInt(value);	}	hostname = configProps.getProperty("api.hostname");	String portStr = configProps.getProperty("api.port");	if (portStr != null && portStr.length() > 0) {	port = Integer.parseInt(portStr);	}	}	_api = ApiConnectorFactory.build(hostname, port);	} catch (IOException ex) {	
unable to read 

hostname = configProps.getProperty("api.hostname");	String portStr = configProps.getProperty("api.port");	if (portStr != null && portStr.length() > 0) {	port = Integer.parseInt(portStr);	}	}	_api = ApiConnectorFactory.build(hostname, port);	} catch (IOException ex) {	throw new ConfigurationException();	} catch (Exception ex) {	
exception in configure 

} finally {	IOUtils.closeQuietly(fileStream);	}	_controller = new ModelController(this, _api, _vmDao, _networksDao, _nicDao, _vlanDao, _ipAddressDao);	try {	_routerOffering = locateNetworkOffering(routerOfferingName, routerOfferingDisplayText, Provider.JuniperContrailRouter);	_routerPublicOffering = locatePublicNetworkOffering(routerPublicOfferingName, routerPublicOfferingDisplayText, Provider.JuniperContrailRouter);	_vpcRouterOffering = locateNetworkOffering(vpcRouterOfferingName, vpcRouterOfferingDisplayText, Provider.JuniperContrailVpcRouter);	_vpcOffering = locateVpcOffering();	}catch (Exception ex) {	
exception in locating network offerings 

public void syncNetworkDB(short syncMode) throws IOException {	if (_dbSync.syncAll(syncMode) == ServerDBSync.SYNC_STATE_OUT_OF_SYNC) {	if (syncMode == DBSyncGeneric.SYNC_MODE_CHECK) {	
cloudstack db vnc are out of sync 

public void syncNetworkDB(short syncMode) throws IOException {	if (_dbSync.syncAll(syncMode) == ServerDBSync.SYNC_STATE_OUT_OF_SYNC) {	if (syncMode == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	
cloudstack db vnc were out of sync performed re sync operation 

public void syncNetworkDB(short syncMode) throws IOException {	if (_dbSync.syncAll(syncMode) == ServerDBSync.SYNC_STATE_OUT_OF_SYNC) {	if (syncMode == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	}	} else {	
cloudstack db vnc are in sync 

public void run() {	try {	
db sync task is running 

public void run() {	try {	syncNetworkDB(_syncMode);	_syncMode = DBSyncGeneric.SYNC_MODE_CHECK;	} catch (Exception ex) {	s_logger.debug(ex);	
unable to sync network db 

if (types == null || types.isEmpty()) {	types = new ArrayList<TrafficType>();	types.add(TrafficType.Control);	types.add(TrafficType.Management);	types.add(TrafficType.Public);	types.add(TrafficType.Storage);	}	sc.setParameters("trafficType", types.toArray());	List<NetworkVO> dbNets = _networksDao.search(sc, null);	if (dbNets == null) {	
no system networks for the given traffic types 

types = new ArrayList<TrafficType>();	types.add(TrafficType.Control);	types.add(TrafficType.Management);	types.add(TrafficType.Public);	types.add(TrafficType.Storage);	types.add(TrafficType.Guest);	}	sc.setParameters("trafficType", types.toArray());	List<NetworkVO> dbNets = _networksDao.search(sc, null);	if (dbNets == null) {	
no juniper managed networks for the given traffic types 

public List<VpcVO> findManagedVpcs() {	SearchBuilder<VpcVO> searchBuilder = _vpcDao.createSearchBuilder();	searchBuilder.and("vpcOffering", searchBuilder.entity().getVpcOfferingId(), Op.EQ);	SearchCriteria<VpcVO> sc = searchBuilder.create();	sc.setParameters("vpcOffering", getVpcOffering().getId());	List<VpcVO> vpcs = _vpcDao.search(sc, null);	if (vpcs == null || vpcs.size() == 0) {	
no vpcs found 

vpcIds.add((long)0);	for (VpcVO vpc:vpcs) {	vpcIds.add(vpc.getId());	}	SearchBuilder<NetworkACLVO> searchBuilder = _networkAclDao.createSearchBuilder();	searchBuilder.and("vpcId", searchBuilder.entity().getVpcId(), Op.IN);	SearchCriteria<NetworkACLVO> sc = searchBuilder.create();	sc.setParameters("vpcId", vpcIds.toArray());	List<NetworkACLVO> acls = _networkAclDao.search(sc, null);	if (acls == null || acls.size() == 0) {	
no acls found 

public List<IPAddressVO> findManagedPublicIps() {	List<NetworkVO> dbNets = findManagedNetworks(null);	if (dbNets == null || dbNets.isEmpty()) {	
juniper managed networks is empty 

List<Long> netIds = new ArrayList<Long>();	for (NetworkVO net : dbNets) {	netIds.add(net.getId());	}	SearchCriteria<IPAddressVO> sc = searchBuilder.create();	sc.setParameters("oneToOneNat", true);	sc.setParameters("sourceNat", false);	sc.setParameters("network", netIds.toArray());	List<IPAddressVO> publicIps = _ipAddressDao.search(sc, null);	if (publicIps == null) {	
no public ips 

for (NetworkVO net : dbNets) {	VirtualNetworkModel vnModel = getDatabase().lookupVirtualNetwork(null, getCanonicalName(net), net.getTrafficType());	if (vnModel == null) {	vnModel = new VirtualNetworkModel(net, null, getCanonicalName(net), net.getTrafficType());	vnModel.build(getModelController(), net);	try {	if (!vnModel.verify(getModelController())) {	vnModel.update(getModelController());	}	} catch (Exception ex) {	
virtual network update 

if (vnModel == null) {	vnModel = new VirtualNetworkModel(net, net.getUuid(), getCanonicalName(net), net.getTrafficType());	vnModel.setProperties(getModelController(), net);	}	try {	if (!vnModel.verify(getModelController())) {	vnModel.update(getModelController());	}	getDatabase().getVirtualNetworks().add(vnModel);	} catch (Exception ex) {	
virtual network update 

assert vnModel != null : "public network vn model is null";	FloatingIpPoolModel fipPoolModel = vnModel.getFipPoolModel();	if (fipPoolModel == null) {	fipPoolModel = new FloatingIpPoolModel();	fipPoolModel.addToVirtualNetwork(vnModel);	fipPoolModel.build(getModelController());	try {	fipPoolModel.update(getModelController());	vnModel.setFipPoolModel(fipPoolModel);	} catch (Exception ex) {	
floating ip pool create 

}	}	FloatingIpModel fipModel = fipPoolModel.getFloatingIpModel(ip.getUuid());	if (fipModel == null) {	fipModel = new FloatingIpModel(ip.getUuid());	fipModel.addToFloatingIpPool(fipPoolModel);	fipModel.build(getModelController(), ip);	try {	fipModel.update(getModelController());	} catch (Exception ex) {	
floating ip create 

public boolean deleteFloatingIp(PublicIpAddress ip) {	VirtualNetworkModel vnModel = lookupPublicNetworkModel();	assert vnModel != null : "public network model is null";	FloatingIpPoolModel fipPoolModel = vnModel.getFipPoolModel();	FloatingIpModel fipModel = fipPoolModel.getFloatingIpModel(ip.getUuid());	if (fipModel != null) {	try {	fipModel.destroy(getModelController());	} catch (IOException ex) {	
floating ip delete 

========================= cloudstack sample_1873 =========================

public Answer execute(final OvsFetchInterfaceCommand command, final CitrixResourceBase citrixResourceBase) {	String label = command.getLabel();	if (citrixResourceBase.isXcp()) {	label = citrixResourceBase.getLabel();	}	
will look for network with name label on host 

String label = command.getLabel();	if (citrixResourceBase.isXcp()) {	label = citrixResourceBase.getLabel();	}	final Connection conn = citrixResourceBase.getConnection();	try {	final XsLocalNetwork nw = citrixResourceBase.getNetworkByName(conn, label);	if(nw == null) {	throw new CloudRuntimeException("Unable to locate the network with name-label: " + label + " on host: " + citrixResourceBase.getHost().getIp());	}	
network object 

label = citrixResourceBase.getLabel();	}	final Connection conn = citrixResourceBase.getConnection();	try {	final XsLocalNetwork nw = citrixResourceBase.getNetworkByName(conn, label);	if(nw == null) {	throw new CloudRuntimeException("Unable to locate the network with name-label: " + label + " on host: " + citrixResourceBase.getHost().getIp());	}	final PIF pif = nw.getPif(conn);	final PIF.Record pifRec = pif.getRecord(conn);	
pif object 

final Connection conn = citrixResourceBase.getConnection();	try {	final XsLocalNetwork nw = citrixResourceBase.getNetworkByName(conn, label);	if(nw == null) {	throw new CloudRuntimeException("Unable to locate the network with name-label: " + label + " on host: " + citrixResourceBase.getHost().getIp());	}	final PIF pif = nw.getPif(conn);	final PIF.Record pifRec = pif.getRecord(conn);	return new OvsFetchInterfaceAnswer(command, true, "Interface " + pifRec.device + " retrieved successfully", pifRec.IP, pifRec.netmask, pifRec.MAC);	} catch (final BadServerResponse e) {	
an error occurred while fetching the interface for on host 

final XsLocalNetwork nw = citrixResourceBase.getNetworkByName(conn, label);	if(nw == null) {	throw new CloudRuntimeException("Unable to locate the network with name-label: " + label + " on host: " + citrixResourceBase.getHost().getIp());	}	final PIF pif = nw.getPif(conn);	final PIF.Record pifRec = pif.getRecord(conn);	return new OvsFetchInterfaceAnswer(command, true, "Interface " + pifRec.device + " retrieved successfully", pifRec.IP, pifRec.netmask, pifRec.MAC);	} catch (final BadServerResponse e) {	return new OvsFetchInterfaceAnswer(command, false, "EXCEPTION:" + e.getMessage());	} catch (final XenAPIException e) {	
an error occurred while fetching the interface for on host 

throw new CloudRuntimeException("Unable to locate the network with name-label: " + label + " on host: " + citrixResourceBase.getHost().getIp());	}	final PIF pif = nw.getPif(conn);	final PIF.Record pifRec = pif.getRecord(conn);	return new OvsFetchInterfaceAnswer(command, true, "Interface " + pifRec.device + " retrieved successfully", pifRec.IP, pifRec.netmask, pifRec.MAC);	} catch (final BadServerResponse e) {	return new OvsFetchInterfaceAnswer(command, false, "EXCEPTION:" + e.getMessage());	} catch (final XenAPIException e) {	return new OvsFetchInterfaceAnswer(command, false, "EXCEPTION:" + e.getMessage());	} catch (final XmlRpcException e) {	
an error occurred while fetching the interface for on host 

========================= cloudstack sample_1170 =========================

if (whiteListIndex != null) {	whiteList.remove(whiteListIndex.intValue());	whiteListMap = this.getArrayIndexMap(whiteList);	}	proxy.addToGlobalBlacklist(hostPortSpec);	if (whiteList.size() == 0) {	attempts++;	try {	Thread.sleep(250);	} catch (InterruptedException e) {	
ignored interupted while fail over in progres 

========================= cloudstack sample_778 =========================

if (hostId == null) {	return true;	}	final ServiceOfferingVO svo = _offeringsDao.findById(vm.getId(), vm.getServiceOfferingId());	CapacityVO capacityCpu = _capacityDao.findByHostIdType(hostId, Capacity.CAPACITY_TYPE_CPU);	CapacityVO capacityMemory = _capacityDao.findByHostIdType(hostId, Capacity.CAPACITY_TYPE_MEMORY);	Long clusterId = null;	if (hostId != null) {	HostVO host = _hostDao.findById(hostId);	if (host == null) {	
host no long exist anymore 

long reservedMem = capacityMemory.getReservedCapacity();	long actualTotalCpu = capacityCpu.getTotalCapacity();	float cpuOvercommitRatio = Float.parseFloat(_clusterDetailsDao.findDetail(clusterIdFinal, "cpuOvercommitRatio").getValue());	float memoryOvercommitRatio = Float.parseFloat(_clusterDetailsDao.findDetail(clusterIdFinal, "memoryOvercommitRatio").getValue());	int vmCPU = svo.getCpu() * svo.getSpeed();	long vmMem = svo.getRamSize() * 1024L * 1024L;	long actualTotalMem = capacityMemory.getTotalCapacity();	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	if (s_logger.isDebugEnabled()) {	
hosts s actual total cpu and cpu after applying overprovisioning 

long reservedMem = capacityMemory.getReservedCapacity();	long actualTotalCpu = capacityCpu.getTotalCapacity();	float cpuOvercommitRatio = Float.parseFloat(_clusterDetailsDao.findDetail(clusterIdFinal, "cpuOvercommitRatio").getValue());	float memoryOvercommitRatio = Float.parseFloat(_clusterDetailsDao.findDetail(clusterIdFinal, "memoryOvercommitRatio").getValue());	int vmCPU = svo.getCpu() * svo.getSpeed();	long vmMem = svo.getRamSize() * 1024L * 1024L;	long actualTotalMem = capacityMemory.getTotalCapacity();	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	if (s_logger.isDebugEnabled()) {	
hosts s actual total ram and ram after applying overprovisioning 

}	}	} else {	if (reservedCpu >= vmCPU) {	capacityCpu.setReservedCapacity(reservedCpu - vmCPU);	}	if (reservedMem >= vmMem) {	capacityMemory.setReservedCapacity(reservedMem - vmMem);	}	}	
release cpu from host old used reserved actual total total with overprovisioning new used reserved movedfromreserved movetoreservered 

}	}	} else {	if (reservedCpu >= vmCPU) {	capacityCpu.setReservedCapacity(reservedCpu - vmCPU);	}	if (reservedMem >= vmMem) {	capacityMemory.setReservedCapacity(reservedMem - vmMem);	}	}	
release mem from host old used reserved total new used reserved movedfromreserved movetoreservered 

if (reservedMem >= vmMem) {	capacityMemory.setReservedCapacity(reservedMem - vmMem);	}	}	_capacityDao.update(capacityCpu.getId(), capacityCpu);	_capacityDao.update(capacityMemory.getId(), capacityMemory);	}	});	return true;	} catch (Exception e) {	
failed to transit vm s state due to 

CapacityVO capacityMem = _capacityDao.lockRow(capacityMemId, true);	long usedCpu = capacityCpu.getUsedCapacity();	long usedMem = capacityMem.getUsedCapacity();	long reservedCpu = capacityCpu.getReservedCapacity();	long reservedMem = capacityMem.getReservedCapacity();	long actualTotalCpu = capacityCpu.getTotalCapacity();	long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	
hosts s actual total cpu and cpu after applying overprovisioning 

long reservedMem = capacityMem.getReservedCapacity();	long actualTotalCpu = capacityCpu.getTotalCapacity();	long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	}	long freeCpu = totalCpu - (reservedCpu + usedCpu);	long freeMem = totalMem - (reservedMem + usedMem);	if (s_logger.isDebugEnabled()) {	
we are allocating vm increasing the used capacity of this host 

long reservedMem = capacityMem.getReservedCapacity();	long actualTotalCpu = capacityCpu.getTotalCapacity();	long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	}	long freeCpu = totalCpu - (reservedCpu + usedCpu);	long freeMem = totalMem - (reservedMem + usedMem);	if (s_logger.isDebugEnabled()) {	
current used cpu free cpu requested cpu 

long reservedMem = capacityMem.getReservedCapacity();	long actualTotalCpu = capacityCpu.getTotalCapacity();	long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	}	long freeCpu = totalCpu - (reservedCpu + usedCpu);	long freeMem = totalMem - (reservedMem + usedMem);	if (s_logger.isDebugEnabled()) {	
current used ram free ram requested ram 

if (s_logger.isDebugEnabled()) {	}	long freeCpu = totalCpu - (reservedCpu + usedCpu);	long freeMem = totalMem - (reservedMem + usedMem);	if (s_logger.isDebugEnabled()) {	}	capacityCpu.setUsedCapacity(usedCpu + cpu);	capacityMem.setUsedCapacity(usedMem + ram);	if (fromLastHost) {	if (s_logger.isDebugEnabled()) {	
we are allocating vm to the last host again so adjusting the reserved capacity if it is not less than required 

if (s_logger.isDebugEnabled()) {	}	long freeCpu = totalCpu - (reservedCpu + usedCpu);	long freeMem = totalMem - (reservedMem + usedMem);	if (s_logger.isDebugEnabled()) {	}	capacityCpu.setUsedCapacity(usedCpu + cpu);	capacityMem.setUsedCapacity(usedMem + ram);	if (fromLastHost) {	if (s_logger.isDebugEnabled()) {	
reserved cpu requested cpu 

if (s_logger.isDebugEnabled()) {	}	long freeCpu = totalCpu - (reservedCpu + usedCpu);	long freeMem = totalMem - (reservedMem + usedMem);	if (s_logger.isDebugEnabled()) {	}	capacityCpu.setUsedCapacity(usedCpu + cpu);	capacityMem.setUsedCapacity(usedMem + ram);	if (fromLastHost) {	if (s_logger.isDebugEnabled()) {	
reserved ram requested ram 

if (fromLastHost) {	if (s_logger.isDebugEnabled()) {	}	if (reservedCpu >= cpu && reservedMem >= ram) {	capacityCpu.setReservedCapacity(reservedCpu - cpu);	capacityMem.setReservedCapacity(reservedMem - ram);	}	} else {	if (!((reservedCpu + usedCpu + cpu <= totalCpu) && (reservedMem + usedMem + ram <= totalMem))) {	if (s_logger.isDebugEnabled()) {	
host doesnt seem to have enough free capacity but increasing the used capacity anyways since the vm is already starting on this host 

if (reservedCpu >= cpu && reservedMem >= ram) {	capacityCpu.setReservedCapacity(reservedCpu - cpu);	capacityMem.setReservedCapacity(reservedMem - ram);	}	} else {	if (!((reservedCpu + usedCpu + cpu <= totalCpu) && (reservedMem + usedMem + ram <= totalMem))) {	if (s_logger.isDebugEnabled()) {	}	}	}	
cpu stats after allocation for host old used old reserved actual total total with overprovisioning new used reserved requested cpu alloc from last 

if (reservedCpu >= cpu && reservedMem >= ram) {	capacityCpu.setReservedCapacity(reservedCpu - cpu);	capacityMem.setReservedCapacity(reservedMem - ram);	}	} else {	if (!((reservedCpu + usedCpu + cpu <= totalCpu) && (reservedMem + usedMem + ram <= totalMem))) {	if (s_logger.isDebugEnabled()) {	}	}	}	
ram stats after allocation for host old used old reserved total new used reserved requested mem alloc from last 

if (!((reservedCpu + usedCpu + cpu <= totalCpu) && (reservedMem + usedMem + ram <= totalMem))) {	if (s_logger.isDebugEnabled()) {	}	}	}	_capacityDao.update(capacityCpu.getId(), capacityCpu);	_capacityDao.update(capacityMem.getId(), capacityMem);	}	});	} catch (Exception e) {	
exception allocating vm capacity 

public boolean checkIfHostHasCpuCapability(long hostId, Integer cpuNum, Integer cpuSpeed) {	Host host = _hostDao.findById(hostId);	boolean isCpuNumGood = host.getCpus().intValue() >= cpuNum;	boolean isCpuSpeedGood = host.getSpeed().intValue() >= cpuSpeed;	if (isCpuNumGood && isCpuSpeedGood) {	if (s_logger.isDebugEnabled()) {	
host has cpu capability cpu speed to support requested cpu and requested speed 

public boolean checkIfHostHasCpuCapability(long hostId, Integer cpuNum, Integer cpuSpeed) {	Host host = _hostDao.findById(hostId);	boolean isCpuNumGood = host.getCpus().intValue() >= cpuNum;	boolean isCpuSpeedGood = host.getSpeed().intValue() >= cpuSpeed;	if (isCpuNumGood && isCpuSpeedGood) {	if (s_logger.isDebugEnabled()) {	}	return true;	} else {	if (s_logger.isDebugEnabled()) {	
host doesn t have cpu capability cpu speed to support requested cpu and requested speed 

public boolean checkIfHostHasCapacity(long hostId, Integer cpu, long ram, boolean checkFromReservedCapacity, float cpuOvercommitRatio, float memoryOvercommitRatio, boolean considerReservedCapacity) {	boolean hasCapacity = false;	if (s_logger.isDebugEnabled()) {	
checking if host has enough capacity for requested cpu and requested ram cpuoverprovisioningfactor 

public boolean checkIfHostHasCapacity(long hostId, Integer cpu, long ram, boolean checkFromReservedCapacity, float cpuOvercommitRatio, float memoryOvercommitRatio, boolean considerReservedCapacity) {	boolean hasCapacity = false;	if (s_logger.isDebugEnabled()) {	}	CapacityVO capacityCpu = _capacityDao.findByHostIdType(hostId, Capacity.CAPACITY_TYPE_CPU);	CapacityVO capacityMem = _capacityDao.findByHostIdType(hostId, Capacity.CAPACITY_TYPE_MEMORY);	if (capacityCpu == null || capacityMem == null) {	if (capacityCpu == null) {	if (s_logger.isDebugEnabled()) {	
cannot checkifhosthascapacity capacity entry for cpu not found in db for hostid 

}	CapacityVO capacityCpu = _capacityDao.findByHostIdType(hostId, Capacity.CAPACITY_TYPE_CPU);	CapacityVO capacityMem = _capacityDao.findByHostIdType(hostId, Capacity.CAPACITY_TYPE_MEMORY);	if (capacityCpu == null || capacityMem == null) {	if (capacityCpu == null) {	if (s_logger.isDebugEnabled()) {	}	}	if (capacityMem == null) {	if (s_logger.isDebugEnabled()) {	
cannot checkifhosthascapacity capacity entry for ram not found in db for hostid 

}	long usedCpu = capacityCpu.getUsedCapacity();	long usedMem = capacityMem.getUsedCapacity();	long reservedCpu = capacityCpu.getReservedCapacity();	long reservedMem = capacityMem.getReservedCapacity();	long actualTotalCpu = capacityCpu.getTotalCapacity();	long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	
hosts s actual total cpu and cpu after applying overprovisioning 

long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	}	String failureReason = "";	if (checkFromReservedCapacity) {	long freeCpu = reservedCpu;	long freeMem = reservedMem;	if (s_logger.isDebugEnabled()) {	
we need to allocate to the last host again so checking if there is enough reserved capacity 

long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	}	String failureReason = "";	if (checkFromReservedCapacity) {	long freeCpu = reservedCpu;	long freeMem = reservedMem;	if (s_logger.isDebugEnabled()) {	
reserved cpu requested cpu 

long actualTotalMem = capacityMem.getTotalCapacity();	long totalCpu = (long)(actualTotalCpu * cpuOvercommitRatio);	long totalMem = (long)(actualTotalMem * memoryOvercommitRatio);	if (s_logger.isDebugEnabled()) {	}	String failureReason = "";	if (checkFromReservedCapacity) {	long freeCpu = reservedCpu;	long freeMem = reservedMem;	if (s_logger.isDebugEnabled()) {	
reserved ram requested ram 

failureReason = "Host does not have enough reserved RAM available";	}	} else {	failureReason = "Host does not have enough reserved CPU available";	}	} else {	long reservedCpuValueToUse = reservedCpu;	long reservedMemValueToUse = reservedMem;	if (!considerReservedCapacity) {	if (s_logger.isDebugEnabled()) {	
considerreservedcapacity is not considering reserved capacity for calculating free capacity 

long reservedMemValueToUse = reservedMem;	if (!considerReservedCapacity) {	if (s_logger.isDebugEnabled()) {	}	reservedCpuValueToUse = 0;	reservedMemValueToUse = 0;	}	long freeCpu = totalCpu - (reservedCpuValueToUse + usedCpu);	long freeMem = totalMem - (reservedMemValueToUse + usedMem);	if (s_logger.isDebugEnabled()) {	
free cpu requested cpu 

long reservedMemValueToUse = reservedMem;	if (!considerReservedCapacity) {	if (s_logger.isDebugEnabled()) {	}	reservedCpuValueToUse = 0;	reservedMemValueToUse = 0;	}	long freeCpu = totalCpu - (reservedCpuValueToUse + usedCpu);	long freeMem = totalMem - (reservedMemValueToUse + usedMem);	if (s_logger.isDebugEnabled()) {	
free ram requested ram 

hasCapacity = true;	} else {	failureReason = "Host does not have enough RAM available";	}	} else {	failureReason = "Host does not have enough CPU available";	}	}	if (hasCapacity) {	if (s_logger.isDebugEnabled()) {	
host has enough cpu and ram available 

} else {	failureReason = "Host does not have enough RAM available";	}	} else {	failureReason = "Host does not have enough CPU available";	}	}	if (hasCapacity) {	if (s_logger.isDebugEnabled()) {	}	
stats can alloc cpu from host used reserved actual total total with overprovisioning requested cpu alloc from last host considerreservedcapacity 

} else {	failureReason = "Host does not have enough RAM available";	}	} else {	failureReason = "Host does not have enough CPU available";	}	}	if (hasCapacity) {	if (s_logger.isDebugEnabled()) {	}	
stats can alloc mem from host used reserved total requested mem alloc from last host considerreservedcapacity 

}	} else {	failureReason = "Host does not have enough CPU available";	}	}	if (hasCapacity) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (checkFromReservedCapacity) {	
stats failed to alloc resource from host reservedcpu requested cpu reservedmem requested mem 

} else {	failureReason = "Host does not have enough CPU available";	}	}	if (hasCapacity) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (checkFromReservedCapacity) {	} else {	
stats failed to alloc resource from host reservedcpu used cpu requested cpu actual total cpu total cpu with overprovisioning reservedmem used mem requested mem total mem considerreservedcapacity 

}	}	if (hasCapacity) {	if (s_logger.isDebugEnabled()) {	}	} else {	if (checkFromReservedCapacity) {	} else {	}	if (s_logger.isDebugEnabled()) {	
cannot allocate to this host 

for (ServiceOfferingVO offering : offerings) {	offeringsMap.put(offering.getId(), offering);	}	long usedCpu = 0;	long usedMemory = 0;	long reservedMemory = 0;	long reservedCpu = 0;	final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;	List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());	if (s_logger.isDebugEnabled()) {	
found vms on host 

if (so.isDynamic()) {	usedMemory += ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;	usedCpu += ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;	} else {	usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;	usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;	}	}	List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());	if (s_logger.isDebugEnabled()) {	
found vm not running on host 

}	}	CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);	CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);	if (cpuCap != null && memCap != null) {	if (host.getTotalMemory() != null) {	memCap.setTotalCapacity(host.getTotalMemory());	}	long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();	if (cpuCap.getTotalCapacity() != hostTotalCpu) {	
calibrate total cpu for host old total cpu new total cpu 

CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);	if (cpuCap != null && memCap != null) {	if (host.getTotalMemory() != null) {	memCap.setTotalCapacity(host.getTotalMemory());	}	long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();	if (cpuCap.getTotalCapacity() != hostTotalCpu) {	cpuCap.setTotalCapacity(hostTotalCpu);	}	if(capacityState != cpuCap.getCapacityState()){	
calibrate cpu capacity state for host old capacity state new capacity state 

}	long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();	if (cpuCap.getTotalCapacity() != hostTotalCpu) {	cpuCap.setTotalCapacity(hostTotalCpu);	}	if(capacityState != cpuCap.getCapacityState()){	cpuCap.setCapacityState(capacityState);	}	memCap.setCapacityState(capacityState);	if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {	
no need to calibrate cpu capacity host usedcpu reservedcpu 

if (cpuCap.getTotalCapacity() != hostTotalCpu) {	cpuCap.setTotalCapacity(hostTotalCpu);	}	if(capacityState != cpuCap.getCapacityState()){	cpuCap.setCapacityState(capacityState);	}	memCap.setCapacityState(capacityState);	if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {	} else {	if (cpuCap.getReservedCapacity() != reservedCpu) {	
calibrate reserved cpu for host old reservedcpu new reservedcpu 

if(capacityState != cpuCap.getCapacityState()){	cpuCap.setCapacityState(capacityState);	}	memCap.setCapacityState(capacityState);	if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {	} else {	if (cpuCap.getReservedCapacity() != reservedCpu) {	cpuCap.setReservedCapacity(reservedCpu);	}	if (cpuCap.getUsedCapacity() != usedCpu) {	
calibrate used cpu for host old usedcpu new usedcpu 

if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {	} else {	if (cpuCap.getReservedCapacity() != reservedCpu) {	cpuCap.setReservedCapacity(reservedCpu);	}	if (cpuCap.getUsedCapacity() != usedCpu) {	cpuCap.setUsedCapacity(usedCpu);	}	}	if (memCap.getTotalCapacity() != host.getTotalMemory()) {	
calibrate total memory for host old total memory new total memory 

cpuCap.setReservedCapacity(reservedCpu);	}	if (cpuCap.getUsedCapacity() != usedCpu) {	cpuCap.setUsedCapacity(usedCpu);	}	}	if (memCap.getTotalCapacity() != host.getTotalMemory()) {	memCap.setTotalCapacity(host.getTotalMemory());	}	if(capacityState != memCap.getCapacityState()){	
calibrate memory capacity state for host old capacity state new capacity state 

cpuCap.setUsedCapacity(usedCpu);	}	}	if (memCap.getTotalCapacity() != host.getTotalMemory()) {	memCap.setTotalCapacity(host.getTotalMemory());	}	if(capacityState != memCap.getCapacityState()){	memCap.setCapacityState(capacityState);	}	if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {	
no need to calibrate memory capacity host usedmem reservedmem 

}	if (memCap.getTotalCapacity() != host.getTotalMemory()) {	memCap.setTotalCapacity(host.getTotalMemory());	}	if(capacityState != memCap.getCapacityState()){	memCap.setCapacityState(capacityState);	}	if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {	} else {	if (memCap.getReservedCapacity() != reservedMemory) {	
calibrate reserved memory for host old reservedmem new reservedmem 

}	if(capacityState != memCap.getCapacityState()){	memCap.setCapacityState(capacityState);	}	if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {	} else {	if (memCap.getReservedCapacity() != reservedMemory) {	memCap.setReservedCapacity(reservedMemory);	}	if (memCap.getUsedCapacity() != usedMemory) {	
calibrate used memory for host old usedmem new usedmem 

memCap.setReservedCapacity(reservedMemory);	}	if (memCap.getUsedCapacity() != usedMemory) {	memCap.setUsedCapacity(usedMemory);	}	}	try {	_capacityDao.update(cpuCap.getId(), cpuCap);	_capacityDao.update(memCap.getId(), memCap);	} catch (Exception e) {	
caught exception while updating cpu memory capacity for the host 

public boolean postStateTransitionEvent(StateMachine2.Transition<State, Event> transition, VirtualMachine vm, boolean status, Object opaque) {	if (!status) {	return false;	}	Pair<Long, Long> hosts = (Pair<Long, Long>)opaque;	Long oldHostId = hosts.first();	State oldState = transition.getCurrentState();	State newState = transition.getToState();	Event event = transition.getEvent();	
vm state transitted from to with event vm s original host id new host id host id before state transition 

} else if (oldState == State.Stopped) {	if (event == Event.DestroyRequested || event == Event.ExpungeOperation) {	releaseVmCapacity(vm, true, false, vm.getLastHostId());	} else if (event == Event.AgentReportMigrated) {	releaseVmCapacity(vm, false, false, oldHostId);	}	}	if ((newState == State.Starting || newState == State.Migrating || event == Event.AgentReportMigrated) && vm.getHostId() != null) {	boolean fromLastHost = false;	if (vm.getHostId().equals(vm.getLastHostId())) {	
vm starting again on the last host it was stopped on 

Float memoryOvercommitRatio = Float.parseFloat(_clusterDetailsDao.findDetail(server.getClusterId(), "memoryOvercommitRatio").getValue());	if (capacityVOCpus != null && !capacityVOCpus.isEmpty()) {	CapacityVO CapacityVOCpu = capacityVOCpus.get(0);	long newTotalCpu = (long)(server.getCpus().longValue() * server.getSpeed().longValue() * cpuovercommitratio);	if ((CapacityVOCpu.getTotalCapacity() <= newTotalCpu) || ((CapacityVOCpu.getUsedCapacity() + CapacityVOCpu.getReservedCapacity()) <= newTotalCpu)) {	CapacityVOCpu.setTotalCapacity(newTotalCpu);	} else if ((CapacityVOCpu.getUsedCapacity() + CapacityVOCpu.getReservedCapacity() > newTotalCpu) && (CapacityVOCpu.getUsedCapacity() < newTotalCpu)) {	CapacityVOCpu.setReservedCapacity(0);	CapacityVOCpu.setTotalCapacity(newTotalCpu);	} else {	
what new cpu is old one is 

List<CapacityVO> capacityVOMems = _capacityDao.search(capacityMem, null);	if (capacityVOMems != null && !capacityVOMems.isEmpty()) {	CapacityVO CapacityVOMem = capacityVOMems.get(0);	long newTotalMem = (long)((server.getTotalMemory()) * memoryOvercommitRatio);	if (CapacityVOMem.getTotalCapacity() <= newTotalMem || (CapacityVOMem.getUsedCapacity() + CapacityVOMem.getReservedCapacity() <= newTotalMem)) {	CapacityVOMem.setTotalCapacity(newTotalMem);	} else if (CapacityVOMem.getUsedCapacity() + CapacityVOMem.getReservedCapacity() > newTotalMem && CapacityVOMem.getUsedCapacity() < newTotalMem) {	CapacityVOMem.setReservedCapacity(0);	CapacityVOMem.setTotalCapacity(newTotalMem);	} else {	
what new cpu is old one is 

public boolean checkIfClusterCrossesThreshold(Long clusterId, Integer cpuRequested, long ramRequested) {	Float clusterCpuOverProvisioning = getClusterOverProvisioningFactor(clusterId, Capacity.CAPACITY_TYPE_CPU);	Float clusterMemoryOverProvisioning = getClusterOverProvisioningFactor(clusterId, Capacity.CAPACITY_TYPE_MEMORY);	Float clusterCpuCapacityDisableThreshold = DeploymentClusterPlanner.ClusterCPUCapacityDisableThreshold.valueIn(clusterId);	Float clusterMemoryCapacityDisableThreshold = DeploymentClusterPlanner.ClusterMemoryCapacityDisableThreshold.valueIn(clusterId);	float cpuConsumption = _capacityDao.findClusterConsumption(clusterId, Capacity.CAPACITY_TYPE_CPU, cpuRequested);	if (cpuConsumption / clusterCpuOverProvisioning > clusterCpuCapacityDisableThreshold) {	
cluster cpu consumption crosses disable threshold 

Float clusterCpuOverProvisioning = getClusterOverProvisioningFactor(clusterId, Capacity.CAPACITY_TYPE_CPU);	Float clusterMemoryOverProvisioning = getClusterOverProvisioningFactor(clusterId, Capacity.CAPACITY_TYPE_MEMORY);	Float clusterCpuCapacityDisableThreshold = DeploymentClusterPlanner.ClusterCPUCapacityDisableThreshold.valueIn(clusterId);	Float clusterMemoryCapacityDisableThreshold = DeploymentClusterPlanner.ClusterMemoryCapacityDisableThreshold.valueIn(clusterId);	float cpuConsumption = _capacityDao.findClusterConsumption(clusterId, Capacity.CAPACITY_TYPE_CPU, cpuRequested);	if (cpuConsumption / clusterCpuOverProvisioning > clusterCpuCapacityDisableThreshold) {	return true;	}	float memoryConsumption = _capacityDao.findClusterConsumption(clusterId, Capacity.CAPACITY_TYPE_MEMORY, ramRequested);	if (memoryConsumption / clusterMemoryOverProvisioning > clusterMemoryCapacityDisableThreshold) {	
cluster memory consumption crosses disable threshold 

public boolean checkIfHostReachMaxGuestLimit(Host host) {	Long vmCount = _vmDao.countActiveByHostId(host.getId());	HypervisorType hypervisorType = host.getHypervisorType();	String hypervisorVersion = host.getHypervisorVersion();	Long maxGuestLimit = _hypervisorCapabilitiesDao.getMaxGuestsLimit(hypervisorType, hypervisorVersion);	if (vmCount.longValue() >= maxGuestLimit.longValue()) {	if (s_logger.isDebugEnabled()) {	
host name hostid already reached max running vms count includes system vms limit is running vm counts is 

========================= cloudstack sample_2463 =========================

public void deleteIscsiVolume(String volumeName) {	try {	NmsResponse response = client.execute(NmsResponse.class, "zvol", "destroy", volumeName, "");	} catch (CloudRuntimeException ex) {	if (!ex.getMessage().contains("does not exist")) {	throw ex;	}	
volume s does not exist it seems it was already deleted 

========================= cloudstack sample_1920 =========================

Throwable firstError = null;	try {	for (ManagedContextListener<?> listener : listeners) {	Object data = null;	try {	data = listener.onEnterContext(reentry);	} catch (Throwable t) {	if (firstError == null) {	firstError = t;	}	
failed onentercontext for listener 

return null;	}	} finally {	Throwable lastError = null;	while (!invocations.isEmpty()) {	ListenerInvocation invocation = invocations.pop();	try {	invocation.listener.onLeaveContext(invocation.data, reentry);	} catch (Throwable t) {	lastError = t;	
failed onleavecontext for listener 

========================= cloudstack sample_514 =========================

public Boolean createVifs(Xen.Vm vm, VirtualMachineTO spec) throws Ovm3ResourceException {	if (spec.getNics() != null) {	NicTO[] nics = spec.getNics();	return createVifs(vm, nics);	} else {	
no nics for vm 

private Boolean createVif(Xen.Vm vm, NicTO nic) throws Ovm3ResourceException {	try {	String net = network.getNetwork(nic);	if (net != null) {	
adding vif to 

private Boolean createVif(Xen.Vm vm, NicTO nic) throws Ovm3ResourceException {	try {	String net = network.getNetwork(nic);	if (net != null) {	vm.addVif(nic.getDeviceId(), net, nic.getMac());	} else {	
unable to add vif no network for 

private Boolean deleteVif(Xen.Vm vm, NicTO nic) throws Ovm3ResourceException {	try {	String net = network.getNetwork(nic);	if (net != null) {	
removing vif from 

private Boolean deleteVif(Xen.Vm vm, NicTO nic) throws Ovm3ResourceException {	try {	String net = network.getNetwork(nic);	if (net != null) {	vm.removeVif(net, nic.getMac());	} else {	
unable to remove vif no network for 

public PrepareForMigrationAnswer execute(PrepareForMigrationCommand cmd) {	VirtualMachineTO vm = cmd.getVirtualMachine();	if (LOGGER.isDebugEnabled()) {	
preparing host for migrating 

public PrepareForMigrationAnswer execute(PrepareForMigrationCommand cmd) {	VirtualMachineTO vm = cmd.getVirtualMachine();	if (LOGGER.isDebugEnabled()) {	}	NicTO[] nics = vm.getNics();	try {	for (NicTO nic : nics) {	network.getNetwork(nic);	}	hypervisor.setVmState(vm.getName(), State.Migrating);	
vm is in migrating state 

if (LOGGER.isDebugEnabled()) {	}	NicTO[] nics = vm.getNics();	try {	for (NicTO nic : nics) {	network.getNetwork(nic);	}	hypervisor.setVmState(vm.getName(), State.Migrating);	return new PrepareForMigrationAnswer(cmd);	} catch (Ovm3ResourceException e) {	
catch exception prepare for migration failed due to 

public GetVncPortAnswer execute(GetVncPortCommand cmd) {	try {	Xen host = new Xen(c);	Xen.Vm vm = host.getRunningVmConfig(cmd.getName());	Integer vncPort = vm.getVncPort();	
get vnc port for 

public GetVncPortAnswer execute(GetVncPortCommand cmd) {	try {	Xen host = new Xen(c);	Xen.Vm vm = host.getRunningVmConfig(cmd.getName());	Integer vncPort = vm.getVncPort();	return new GetVncPortAnswer(cmd, c.getIp(), vncPort);	} catch (Ovm3ResourceException e) {	
get vnc port for failed 

Map<String, String> oldVmStats = null;	Map<String, String> newVmStats = null;	VmStatsEntry stats = new VmStatsEntry();	try {	if (vmStats.containsKey(vmName)) {	oldVmStats = new HashMap<String, String>();	oldVmStats.putAll(vmStats.get(vmName));	}	newVmStats = cSp.ovsDomUStats(vmName);	} catch (Ovm3ResourceException e) {	
unable to retrieve stats from 

try {	if (vmStats.containsKey(vmName)) {	oldVmStats = new HashMap<String, String>();	oldVmStats.putAll(vmStats.get(vmName));	}	newVmStats = cSp.ovsDomUStats(vmName);	} catch (Ovm3ResourceException e) {	return stats;	}	if (oldVmStats == null) {	
no old stats retrieved stats from 

stats.setNumCPUs(1);	stats.setNetworkReadKBs(0);	stats.setNetworkWriteKBs(0);	stats.setDiskReadKBs(0);	stats.setDiskWriteKBs(0);	stats.setDiskReadIOs(0);	stats.setDiskWriteIOs(0);	stats.setCPUUtilization(0);	stats.setEntityType("vm");	} else {	
retrieved new stats from 

public boolean startVm(String repoId, String vmId) throws XmlRpcException {	Xen host = new Xen(c);	try {	if (host.getRunningVmConfig(vmId) == null) {	
create vm first on 

public boolean startVm(String repoId, String vmId) throws XmlRpcException {	Xen host = new Xen(c);	try {	if (host.getRunningVmConfig(vmId) == null) {	return false;	} else {	
vm exists on 

public boolean startVm(String repoId, String vmId) throws XmlRpcException {	Xen host = new Xen(c);	try {	if (host.getRunningVmConfig(vmId) == null) {	return false;	} else {	}	host.startVm(repoId, vmId);	} catch (Exception e) {	
failed to start vm on 

public void cleanup(Xen.Vm vm) {	try {	cleanupNetwork(vm.getVmVifs());	} catch (XmlRpcException e) {	
clean up network for failed 

public Boolean createVbds(Xen.Vm vm, VirtualMachineTO spec) {	if (spec.getDisks() == null) {	
no disks defined for 

if (spec.getDisks() == null) {	return false;	}	for (DiskTO disk : spec.getDisks()) {	try {	if (disk.getType() == Volume.Type.ROOT) {	VolumeObjectTO vol = (VolumeObjectTO) disk.getData();	String diskFile = processor.getVirtualDiskPath(vol.getUuid(),  vol.getDataStore().getUuid());	vm.addRootDisk(diskFile);	vm.setPrimaryPoolUuid(vol.getDataStore().getUuid());	
adding root disk 

if (isoTO.getPath() != null) {	TemplateObjectTO template = (TemplateObjectTO) isoTO;	DataStoreTO store = template.getDataStore();	if (!(store instanceof NfsTO)) {	throw new CloudRuntimeException( "unsupported protocol");	}	NfsTO nfsStore = (NfsTO) store;	String secPoolUuid = pool.setupSecondaryStorage(nfsStore .getUrl());	String isoPath = config.getAgentSecStoragePath() + "/" + secPoolUuid + "/" + template.getPath();	vm.addIso(isoPath);	
adding iso 

}	NfsTO nfsStore = (NfsTO) store;	String secPoolUuid = pool.setupSecondaryStorage(nfsStore .getUrl());	String isoPath = config.getAgentSecStoragePath() + "/" + secPoolUuid + "/" + template.getPath();	vm.addIso(isoPath);	}	} else if (disk.getType() == Volume.Type.DATADISK) {	VolumeObjectTO vol = (VolumeObjectTO) disk.getData();	String diskFile = processor.getVirtualDiskPath(vol.getUuid(),  vol.getDataStore().getUuid());	vm.addDataDisk(diskFile);	
adding data disk 

vm.addIso(isoPath);	}	} else if (disk.getType() == Volume.Type.DATADISK) {	VolumeObjectTO vol = (VolumeObjectTO) disk.getData();	String diskFile = processor.getVirtualDiskPath(vol.getUuid(),  vol.getDataStore().getUuid());	vm.addDataDisk(diskFile);	} else {	throw new CloudRuntimeException("Unknown disk type: " + disk.getType());	}	} catch (Exception e) {	
createvbds failed 

========================= cloudstack sample_847 =========================

protected void runInContext() {	synchronized (_storagePool) {	Set<String> removedPools = new HashSet<String>();	for (String uuid : _storagePool.keySet()) {	NfsStoragePool primaryStoragePool = _storagePool.get(uuid);	StoragePool storage = null;	try {	Connect conn = LibvirtConnection.getConnection();	storage = conn.storagePoolLookupByUUIDString(uuid);	if (storage == null) {	
libvirt storage pool not found removing from ha list 

for (String uuid : _storagePool.keySet()) {	NfsStoragePool primaryStoragePool = _storagePool.get(uuid);	StoragePool storage = null;	try {	Connect conn = LibvirtConnection.getConnection();	storage = conn.storagePoolLookupByUUIDString(uuid);	if (storage == null) {	removedPools.add(uuid);	continue;	} else if (storage.getInfo().state != StoragePoolState.VIR_STORAGE_POOL_RUNNING) {	
libvirt storage pool found but not running removing from ha list 

try {	Connect conn = LibvirtConnection.getConnection();	storage = conn.storagePoolLookupByUUIDString(uuid);	if (storage == null) {	removedPools.add(uuid);	continue;	} else if (storage.getInfo().state != StoragePoolState.VIR_STORAGE_POOL_RUNNING) {	removedPools.add(uuid);	continue;	}	
found nfs storage pool in libvirt continuing 

Connect conn = LibvirtConnection.getConnection();	storage = conn.storagePoolLookupByUUIDString(uuid);	if (storage == null) {	removedPools.add(uuid);	continue;	} else if (storage.getInfo().state != StoragePoolState.VIR_STORAGE_POOL_RUNNING) {	removedPools.add(uuid);	continue;	}	} catch (LibvirtException e) {	
failed to lookup libvirt storage pool due to 

storage = conn.storagePoolLookupByUUIDString(uuid);	if (storage == null) {	removedPools.add(uuid);	continue;	} else if (storage.getInfo().state != StoragePoolState.VIR_STORAGE_POOL_RUNNING) {	removedPools.add(uuid);	continue;	}	} catch (LibvirtException e) {	if (e.toString().contains("pool not found")) {	
removing pool from ha monitor since it was deleted 

}	String result = null;	for (int i = 0; i < 5; i++) {	Script cmd = new Script(s_heartBeatPath, _heartBeatUpdateTimeout, s_logger);	cmd.add("-i", primaryStoragePool._poolIp);	cmd.add("-p", primaryStoragePool._poolMountSourcePath);	cmd.add("-m", primaryStoragePool._mountDestPath);	cmd.add("-h", _hostIP);	result = cmd.execute();	if (result != null) {	
write heartbeat failed retry 

cmd.add("-p", primaryStoragePool._poolMountSourcePath);	cmd.add("-m", primaryStoragePool._mountDestPath);	cmd.add("-h", _hostIP);	result = cmd.execute();	if (result != null) {	} else {	break;	}	}	if (result != null) {	
write heartbeat failed reboot the host 

public void run() {	while (true) {	Thread monitorThread = new Thread(new Monitor());	monitorThread.start();	try {	monitorThread.join();	} catch (InterruptedException e) {	
ignored interupted joining monitor 

while (true) {	Thread monitorThread = new Thread(new Monitor());	monitorThread.start();	try {	monitorThread.join();	} catch (InterruptedException e) {	}	try {	Thread.sleep(_heartBeatUpdateFreq);	} catch (InterruptedException e) {	
ignored interupted between heartbeats 

========================= cloudstack sample_1023 =========================

continue;	}	String cidrAddress = rs.getString("cidr_address");	long cidrSize = rs.getLong("cidr_size");	List<Object> cidrPair = new ArrayList<Object>();	cidrPair.add(0, cidrAddress);	cidrPair.add(1, new Long(cidrSize));	currentPodCidrSubnets.put(podId, cidrPair);	}	} catch (SQLException ex) {	
db exception 

========================= cloudstack sample_4671 =========================

vbd.destroy(conn);	}	}	continue;	}	}	citrixResourceBase.migrateVM(conn, dsthost, vm, vmName);	vm.setAffinity(conn, dsthost);	}	if (!citrixResourceBase.attachConfigDriveToMigratedVm(conn, vmName, dstHostIpAddr)) {	
config drive iso attach failed after migration for vm 

========================= cloudstack sample_1189 =========================

} else {	vmState = PowerState.PowerOn;	}	for (final VolumeObjectTO volumeTo : listVolumeTo) {	final Long deviceId = volumeTo.getDeviceId();	final VDI vdi = vdiMap.get(deviceId.toString());	volumeTo.setPath(vdi.getUuid(conn));	}	return new RevertToVMSnapshotAnswer(command, listVolumeTo, vmState);	} catch (final Exception e) {	
revert vm to snapshot failed due to 

========================= cloudstack sample_1166 =========================

public void defaultMessageHandler(String subject, String topic, Object args) {	
db event received topic subject 

private long parseForId(String resourceType, String description) {	String typeStr = resourceType + " Id:";	int idIdx = description.indexOf(typeStr) + typeStr.length();	String idStr = description.substring(idIdx, description.indexOf('"', idIdx));	long id = 0;	try {	id = Long.parseLong(idStr.trim());	} catch (Exception e) {	
unable to parse id string for long value ignored 

public void onDomainCreate(String subject, String topic, org.apache.cloudstack.framework.events.Event event) {	
ondomaincreate topic subject 

public void onDomainCreate(String subject, String topic, org.apache.cloudstack.framework.events.Event event) {	try {	long id = parseForId(event.getResourceType(), event.getDescription());	if (id != 0) {	DomainVO domain = _domainDao.findById(id);	if (domain != null) {	
createdomain for name uuid 

public void onProjectCreate(String subject, String topic, org.apache.cloudstack.framework.events.Event event) {	
onprojectcreate topic subject 

public void onProjectCreate(String subject, String topic, org.apache.cloudstack.framework.events.Event event) {	try {	long id = parseForId(event.getResourceType(), event.getDescription());	if (id != 0) {	ProjectVO project = _projectDao.findById(id);	if (project != null) {	
createproject for name uuid 

========================= cloudstack sample_1865 =========================

public boolean executeTest() {	int error = 0;	Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	if (api.getName().equals("rebootManagementServer")) {	
attempting to ssh into management server hostip 

Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	if (api.getName().equals("rebootManagementServer")) {	try {	Connection conn = new Connection(this.getParam().get("hostip"));	conn.connect(null, 60000, 60000);	
sshed successfully into management server hostip 

for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	if (api.getName().equals("rebootManagementServer")) {	try {	Connection conn = new Connection(this.getParam().get("hostip"));	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", "password");	if (isAuthenticated == false) {	
authentication failed for root with password 

if (api.getName().equals("rebootManagementServer")) {	try {	Connection conn = new Connection(this.getParam().get("hostip"));	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", "password");	if (isAuthenticated == false) {	return false;	}	String restartCommand = "service cloud-management restart; service cloud-usage restart";	Session sess = conn.openSession();	
executing 

Thread.sleep(120000);	sess.close();	conn.close();	} catch (Exception ex) {	s_logger.error(ex);	return false;	}	} else {	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200) && (api.getTestCaseInfo() != null)) {	
test case failed command that was supposed to fail passed the command was sent with the following url 

} catch (Exception ex) {	s_logger.error(ex);	return false;	}	} else {	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200) && (api.getTestCaseInfo() != null)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use the command was sent with url 

}	} else {	api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200) && (api.getTestCaseInfo() != null)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	} else {	if (api.verifyParam() == false) {	
command failed verification for returned parameters failed command was sent with url 

api.sendCommand(this.getClient(), null);	if ((api.getResponseType() == ResponseType.ERROR) && (api.getResponseCode() == 200) && (api.getTestCaseInfo() != null)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	} else {	if (api.verifyParam() == false) {	error++;	} else if (api.getTestCaseInfo() != null) {	
test case passed command was sent with the url 

} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.setParam(this.getParam()) == false) {	return false;	} else {	if (api.verifyParam() == false) {	error++;	} else if (api.getTestCaseInfo() != null) {	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	
command failed with an error code command was sent with url required 

if (api.setParam(this.getParam()) == false) {	return false;	} else {	if (api.verifyParam() == false) {	error++;	} else if (api.getTestCaseInfo() != null) {	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	
the command is required for the future use so exiging 

error++;	} else if (api.getTestCaseInfo() != null) {	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	return false;	}	error++;	} else if (api.getTestCaseInfo() != null) {	
test case passed command that was supposed to fail failed test passed command was sent with url 

========================= cloudstack sample_451 =========================

public void testWaitBehave() {	final Object me = this;	new Thread(new Runnable() {	public void run() {	
sleeping 

public void testWaitBehave() {	final Object me = this;	new Thread(new Runnable() {	public void run() {	try {	Thread.sleep(3000);	} catch (InterruptedException e) {	
ignored 

public void testWaitBehave() {	final Object me = this;	new Thread(new Runnable() {	public void run() {	try {	Thread.sleep(3000);	} catch (InterruptedException e) {	}	
wakeup 

public void run() {	try {	Thread.sleep(3000);	} catch (InterruptedException e) {	}	synchronized (me) {	me.notifyAll();	}	}	}).start();	
first wait 

}	}	}).start();	synchronized (me) {	try {	wait(5000);	} catch (InterruptedException e) {	e.printStackTrace();	}	}	
first wait done 

}	}	}).start();	synchronized (me) {	try {	wait(5000);	} catch (InterruptedException e) {	e.printStackTrace();	}	}	
second wait 

e.printStackTrace();	}	}	synchronized (me) {	try {	wait(5000);	} catch (InterruptedException e) {	e.printStackTrace();	}	}	
second wait done 

public void test() {	final int TOTAL_JOBS_PER_QUEUE = 5;	final int TOTAL_QUEUES = 100;	for (int i = 0; i < TOTAL_QUEUES; i++) {	for (int j = 0; j < TOTAL_JOBS_PER_QUEUE; j++) {	AsyncJobVO job = new AsyncJobVO();	job.setCmd("TestCmd");	job.setDispatcher("TestJobDispatcher");	job.setCmdInfo("TestCmd info");	_jobMgr.submitAsyncJob(job, "fakequeue", i);	
job submitted job queue 

job.setDispatcher("TestJobDispatcher");	job.setCmdInfo("TestCmd info");	_jobMgr.submitAsyncJob(job, "fakequeue", i);	}	}	while (true) {	if (_testDashboard.getCompletedJobCount() == TOTAL_JOBS_PER_QUEUE * TOTAL_QUEUES) break;	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored 

_jobMgr.submitAsyncJob(job, "fakequeue", i);	}	}	while (true) {	if (_testDashboard.getCompletedJobCount() == TOTAL_JOBS_PER_QUEUE * TOTAL_QUEUES) break;	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	
test done with job executed 

========================= cloudstack sample_685 =========================

public static com.trilead.ssh2.Connection acquireAuthorizedConnection(String ip, int port, String username, String password) {	com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(ip, port);	try {	sshConnection.connect(null, DEFAULT_CONNECT_TIMEOUT, DEFAULT_KEX_TIMEOUT);	if (!sshConnection.authenticateWithPassword(username, password)) {	String[] methods = sshConnection.getRemainingAuthMethods(username);	StringBuffer mStr = new StringBuffer();	for (int i = 0; i < methods.length; i++) {	mStr.append(methods[i]);	}	
ssh authorizes failed support authorized methods are 

if (!sshConnection.authenticateWithPassword(username, password)) {	String[] methods = sshConnection.getRemainingAuthMethods(username);	StringBuffer mStr = new StringBuffer();	for (int i = 0; i < methods.length; i++) {	mStr.append(methods[i]);	}	return null;	}	return sshConnection;	} catch (IOException e) {	
get ssh connection failed 

public static int sshExecuteCmdOneShotWithExitCode(com.trilead.ssh2.Connection sshConnection, String cmd) throws SshException {	
executing cmd 

if (result != null && !result.isEmpty()) s_logger.debug(cmd + " output:" + result);	for(int i = 0 ; i<10 ; i++ ) {	Integer status = sshSession.getExitStatus();	if( status != null ) {	return status;	}	Thread.sleep(100);	}	return -1;	} catch (Exception e) {	
ssh executed failed 

========================= cloudstack sample_2822 =========================

protected void runInContext() {	try {	parse(null);	} catch (Exception e) {	
error while parsing usage events 

========================= cloudstack sample_2658 =========================

dest = _dpMgr.planDeployment(vmProfile, plan, exclude, plannerToUse);	} catch (AffinityConflictException e) {	throw new CloudRuntimeException("Unable to create deployment, affinity rules associated to the VM conflict");	}	if (dest != null) {	String reservationId = _dpMgr.finalizeReservation(dest, vmProfile, plan, exclude, plannerToUse);	if (reservationId != null) {	return reservationId;	} else {	if (s_logger.isDebugEnabled()) {	
cannot finalize the vm reservation for this destination found retrying 

========================= cloudstack sample_4763 =========================

public void closeResponse(final CloseableHttpResponse response) throws CloudstackRESTException {	try {	
closing http connection 

========================= cloudstack sample_2859 =========================

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, hostId);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	l.add(rs.getLong(1));	}	} catch (SQLException e) {	
exception 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	boolean result = super.configure(name, params);	PublicSearch = createSearchBuilder();	PublicSearch.and("public", PublicSearch.entity().isPublicTemplate(), SearchCriteria.Op.EQ);	routerTmpltName = (String)params.get("routing.uniquename");	
found parameter routing unique name 

PublicSearch.and("public", PublicSearch.entity().isPublicTemplate(), SearchCriteria.Op.EQ);	routerTmpltName = (String)params.get("routing.uniquename");	if (routerTmpltName == null) {	routerTmpltName = "routing";	}	consoleProxyTmpltName = (String)params.get("consoleproxy.uniquename");	if (consoleProxyTmpltName == null) {	consoleProxyTmpltName = "routing";	}	if (s_logger.isDebugEnabled()) {	
use console proxy template 

========================= cloudstack sample_4574 =========================

clz = Class.forName(clzName);	} catch (ClassNotFoundException e) {	return null;	}	Gson gson = GsonHelper.getGson();	Object obj = gson.fromJson(content, clz);	return obj;	}	return null;	} catch (RuntimeException e) {	
caught runtime exception when doing gson deserialization on 

try {	Object fieldValue = method.invoke(o);	if (fieldValue != null) {	if (f.getType() == Date.class) {	l.add(new Pair<String, Object>(paramName, DateUtil.getOutputString((Date)fieldValue)));	} else {	l.add(new Pair<String, Object>(paramName, fieldValue.toString()));	}	}	} catch (IllegalArgumentException e) {	
illegal argument exception when calling pojo get method for property 

Object fieldValue = method.invoke(o);	if (fieldValue != null) {	if (f.getType() == Date.class) {	l.add(new Pair<String, Object>(paramName, DateUtil.getOutputString((Date)fieldValue)));	} else {	l.add(new Pair<String, Object>(paramName, fieldValue.toString()));	}	}	} catch (IllegalArgumentException e) {	} catch (IllegalAccessException e) {	
illegal access exception when calling pojo get method for property 

if (fieldValue != null) {	if (f.getType() == Date.class) {	l.add(new Pair<String, Object>(paramName, DateUtil.getOutputString((Date)fieldValue)));	} else {	l.add(new Pair<String, Object>(paramName, fieldValue.toString()));	}	}	} catch (IllegalArgumentException e) {	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	
invocation target exception when calling pojo get method for property 

private static Method getGetMethod(Object o, String propName) {	Method method = null;	String methodName = getGetMethodName("get", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	
security exception in getting pojo get method for property 

private static Method getGetMethod(Object o, String propName) {	Method method = null;	String methodName = getGetMethodName("get", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	} catch (NoSuchMethodException e1) {	if (s_logger.isTraceEnabled()) {	
pojo does not have method for property will check is prefixed method to see if it is boolean property 

if (s_logger.isTraceEnabled()) {	}	}	if (method != null) {	return method;	}	methodName = getGetMethodName("is", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	
security exception in getting pojo get method for property 

}	}	if (method != null) {	return method;	}	methodName = getGetMethodName("is", propName);	try {	method = o.getClass().getMethod(methodName);	} catch (SecurityException e1) {	} catch (NoSuchMethodException e1) {	
pojo does not have method for property 

========================= cloudstack sample_61 =========================

private boolean canHandle(Network config, Scheme lbScheme) {	DataCenter dc = _entityMgr.findById(DataCenter.class, config.getDataCenterId());	if (dc.getNetworkType() != NetworkType.Advanced) {	
not hanling zone of network type 

private boolean canHandle(Network config, Scheme lbScheme) {	DataCenter dc = _entityMgr.findById(DataCenter.class, config.getDataCenterId());	if (dc.getNetworkType() != NetworkType.Advanced) {	return false;	}	if (config.getGuestType() != Network.GuestType.Isolated || config.getTrafficType() != TrafficType.Guest) {	
not handling network with type and traffic type 

return false;	}	if (config.getGuestType() != Network.GuestType.Isolated || config.getTrafficType() != TrafficType.Guest) {	return false;	}	Map<Capability, String> lbCaps = getCapabilities().get(Service.Lb);	if (!lbCaps.isEmpty()) {	String schemeCaps = lbCaps.get(Capability.LbSchemes);	if (schemeCaps != null && lbScheme != null) {	if (!schemeCaps.contains(lbScheme.toString())) {	
scheme is not supported by the provider 

Map<Capability, String> lbCaps = getCapabilities().get(Service.Lb);	if (!lbCaps.isEmpty()) {	String schemeCaps = lbCaps.get(Capability.LbSchemes);	if (schemeCaps != null && lbScheme != null) {	if (!schemeCaps.contains(lbScheme.toString())) {	return false;	}	}	}	if (!_ntwkModel.isProviderSupportServiceInNetwork(config.getId(), Service.Lb, getProvider())) {	
element doesn t support service in the network 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!canHandle(network, null)) {	
no need to implement 

public boolean prepare(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!canHandle(network, null)) {	
no need to prepare 

protected boolean implementInternalLbVms(Network network, DeployDestination dest) throws ResourceUnavailableException {	List<String> ips = _appLbDao.listLbIpsBySourceIpNetworkIdAndScheme(network.getId(), Scheme.Internal);	for (String ip : ips) {	Ip sourceIp = new Ip(ip);	long active = _appLbDao.countActiveBySourceIp(sourceIp, network.getId());	if (active > 0) {	
have to implement internal lb vm for source ip as a part of network implement as there are internal lb rules exist for this ip 

protected boolean implementInternalLbVms(Network network, DeployDestination dest) throws ResourceUnavailableException {	List<String> ips = _appLbDao.listLbIpsBySourceIpNetworkIdAndScheme(network.getId(), Scheme.Internal);	for (String ip : ips) {	Ip sourceIp = new Ip(ip);	long active = _appLbDao.countActiveBySourceIp(sourceIp, network.getId());	if (active > 0) {	List<? extends VirtualRouter> internalLbVms;	try {	internalLbVms = _internalLbMgr.deployInternalLbVm(network, sourceIp, dest, _accountMgr.getAccount(network.getAccountId()), null);	} catch (InsufficientCapacityException e) {	
failed to deploy element for ip due to 

for (String ip : ips) {	Ip sourceIp = new Ip(ip);	long active = _appLbDao.countActiveBySourceIp(sourceIp, network.getId());	if (active > 0) {	List<? extends VirtualRouter> internalLbVms;	try {	internalLbVms = _internalLbMgr.deployInternalLbVm(network, sourceIp, dest, _accountMgr.getAccount(network.getAccountId()), null);	} catch (InsufficientCapacityException e) {	return false;	} catch (ConcurrentOperationException e) {	
failed to deploy element for ip due to 

public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	List<? extends VirtualRouter> internalLbVms = _routerDao.listByNetworkAndRole(network.getId(), Role.INTERNAL_LB_VM);	if (internalLbVms == null || internalLbVms.isEmpty()) {	return true;	}	boolean result = true;	for (VirtualRouter internalLbVm : internalLbVms) {	result = result && _internalLbMgr.destroyInternalLbVm(internalLbVm.getId(), context.getAccount(), context.getCaller().getId());	if (cleanup) {	if (!result) {	
failed to stop internal lb element but would try to process clean up anyway 

return true;	}	boolean result = true;	for (VirtualRouter internalLbVm : internalLbVms) {	result = result && _internalLbMgr.destroyInternalLbVm(internalLbVm.getId(), context.getAccount(), context.getCaller().getId());	if (cleanup) {	if (!result) {	}	result = (_internalLbMgr.destroyInternalLbVm(internalLbVm.getId(), context.getAccount(), context.getCaller().getId()));	if (!result) {	
failed to clean up internal lb element 

public boolean applyLBRules(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException {	Set<Ip> vmsToDestroy = getVmsToDestroy(network, rules);	Map<Ip, List<LoadBalancingRule>> rulesToApply = getLbRulesToApply(rules);	
applying on element 

public boolean applyLBRules(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException {	Set<Ip> vmsToDestroy = getVmsToDestroy(network, rules);	Map<Ip, List<LoadBalancingRule>> rulesToApply = getLbRulesToApply(rules);	for (Ip sourceIp : vmsToDestroy) {	List<? extends VirtualRouter> vms = _internalLbMgr.findInternalLbVms(network.getId(), sourceIp);	if (vms.size() > 0) {	try {	
destroying internal lb vm for ip s as all the rules for this vm are in revoke state 

public boolean applyLBRules(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException {	Set<Ip> vmsToDestroy = getVmsToDestroy(network, rules);	Map<Ip, List<LoadBalancingRule>> rulesToApply = getLbRulesToApply(rules);	for (Ip sourceIp : vmsToDestroy) {	List<? extends VirtualRouter> vms = _internalLbMgr.findInternalLbVms(network.getId(), sourceIp);	if (vms.size() > 0) {	try {	return _internalLbMgr.destroyInternalLbVm(vms.get(0).getId(), _accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM), _accountMgr.getUserIncludingRemoved(User.UID_SYSTEM).getId());	} catch (ConcurrentOperationException e) {	
failed to apply lb rule s for ip s on the element s due to 

}	rulesToApply.remove(sourceIp);	}	for (Map.Entry<Ip,List<LoadBalancingRule>> entry : rulesToApply.entrySet()) {	Ip sourceIp = entry.getKey();	List<? extends VirtualRouter> internalLbVms;	try {	DeployDestination dest = new DeployDestination(_entityMgr.findById(DataCenter.class, network.getDataCenterId()), null, null, null);	internalLbVms = _internalLbMgr.deployInternalLbVm(network, sourceIp, dest, _accountMgr.getAccount(network.getAccountId()), null);	} catch (InsufficientCapacityException e) {	
failed to apply lb rule s for ip s on the element s due to 

}	for (Map.Entry<Ip,List<LoadBalancingRule>> entry : rulesToApply.entrySet()) {	Ip sourceIp = entry.getKey();	List<? extends VirtualRouter> internalLbVms;	try {	DeployDestination dest = new DeployDestination(_entityMgr.findById(DataCenter.class, network.getDataCenterId()), null, null, null);	internalLbVms = _internalLbMgr.deployInternalLbVm(network, sourceIp, dest, _accountMgr.getAccount(network.getAccountId()), null);	} catch (InsufficientCapacityException e) {	return false;	} catch (ConcurrentOperationException e) {	
failed to apply lb rule s for ip s on the element s due to 

protected Set<Ip> getVmsToDestroy(Network network, List<LoadBalancingRule> rules) {	Set<Ip> lbPublicIps = new HashSet<Ip>();	Set<Ip> vmsToDestroy = new HashSet<Ip>();	for (LoadBalancingRule rule : rules) {	lbPublicIps.add(rule.getSourceIp());	}	for (Ip sourceIp : lbPublicIps) {	if (_appLbDao.countBySourceIpAndNotRevoked(sourceIp, network.getId()) == 0) {	
have to destroy internal lb vm for source ip as it has rules in non revoke state 

if (!groupedRules.containsKey(sourceIp)) {	groupedRules.put(sourceIp, null);	}	List<LoadBalancingRule> rulesToApply = groupedRules.get(sourceIp);	if (rulesToApply == null) {	rulesToApply = new ArrayList<LoadBalancingRule>();	}	rulesToApply.add(rule);	groupedRules.put(sourceIp, rulesToApply);	} else {	
internal lb rule doesn t have any vms assigned skipping 

public VirtualRouterProvider addInternalLoadBalancerElement(long ntwkSvcProviderId) {	VirtualRouterProviderVO element = _vrProviderDao.findByNspIdAndType(ntwkSvcProviderId, Type.InternalLbVm);	if (element != null) {	
there is already an with service provider id 

========================= cloudstack sample_1849 =========================

public void execute() {	try {	final boolean result = _vpcService.restartVpc(getId(), getCleanup(), getMakeredundant());	if (result) {	final SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to restart VPC");	}	} catch (final ResourceUnavailableException ex) {	
exception 

final boolean result = _vpcService.restartVpc(getId(), getCleanup(), getMakeredundant());	if (result) {	final SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to restart VPC");	}	} catch (final ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (final ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3527 =========================

public void setAuthenticators(List<PluggableAPIAuthenticator> authenticators) {	for (PluggableAPIAuthenticator authManager: authenticators) {	if (authManager != null && authManager instanceof SAML2AuthManager) {	_samlAuthManager = (SAML2AuthManager) authManager;	}	}	if (_samlAuthManager == null) {	
no suitable pluggable authentication manager found for login cmd 

========================= cloudstack sample_1371 =========================

protected void setMemory(final Connection conn, final VM vm, final long minMemsize, final long maxMemsize) throws XmlRpcException, XenAPIException {	if (s_logger.isDebugEnabled()) {	
memory limits for vm staticmin staticmax dynamicmin dynamicmax 

========================= cloudstack sample_1234 =========================

SearchCriteria<VmWorkJobVO> sc = ExpungeWorkJobSearch.create();	sc.setParameters("lastUpdated",cutDate);	sc.setParameters("jobStatus", JobInfo.Status.IN_PROGRESS);	expunge(sc);	SearchCriteria<VmWorkJobVO> sc = ExpungingWorkJobSearch.create();	sc.setParameters("jobStatus", JobInfo.Status.IN_PROGRESS);	sc.setParameters("cutDate", cutDate);	sc.setParameters("dispatcher", "VmWorkJobDispatcher");	List<VmWorkJobVO> expungeList = listBy(sc);	for (VmWorkJobVO job : expungeList) {	
expunge completed work job 

sc.setParameters("msid", msid);	expunge(sc);	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try ( PreparedStatement pstmt = txn .prepareAutoCloseStatement( "DELETE FROM vm_work_job WHERE id IN (SELECT id FROM async_job WHERE (job_dispatcher='VmWorkJobPlaceHolder' OR job_dispatcher='VmWorkJobDispatcher') AND job_init_msid=?)");	) {	pstmt.setLong(1, msid);	pstmt.execute();	} catch (SQLException e) {	
ignored sql failed to delete vm work job 

expunge(sc);	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try ( PreparedStatement pstmt = txn .prepareAutoCloseStatement( "DELETE FROM vm_work_job WHERE id IN (SELECT id FROM async_job WHERE (job_dispatcher='VmWorkJobPlaceHolder' OR job_dispatcher='VmWorkJobDispatcher') AND job_init_msid=?)");	) {	pstmt.setLong(1, msid);	pstmt.execute();	} catch (SQLException e) {	} catch (Throwable e) {	
ignored caught an error during delete vm work job 

pstmt.setLong(1, msid);	pstmt.execute();	} catch (SQLException e) {	} catch (Throwable e) {	}	try ( PreparedStatement pstmt = txn.prepareAutoCloseStatement( "DELETE FROM async_job WHERE (job_dispatcher='VmWorkJobPlaceHolder' OR job_dispatcher='VmWorkJobDispatcher') AND job_init_msid=?");	) {	pstmt.setLong(1, msid);	pstmt.execute();	} catch (SQLException e) {	
ignored sql failed to delete async job 

pstmt.execute();	} catch (SQLException e) {	} catch (Throwable e) {	}	try ( PreparedStatement pstmt = txn.prepareAutoCloseStatement( "DELETE FROM async_job WHERE (job_dispatcher='VmWorkJobPlaceHolder' OR job_dispatcher='VmWorkJobDispatcher') AND job_init_msid=?");	) {	pstmt.setLong(1, msid);	pstmt.execute();	} catch (SQLException e) {	} catch (Throwable e) {	
ignored caught an error during delete async job 

========================= cloudstack sample_703 =========================

private boolean prepareNodes(String clusterName, List<HostVO> hosts) {	PrepareOCFS2NodesCommand cmd = new PrepareOCFS2NodesCommand(clusterName, marshalNodes(hosts));	for (HostVO h : hosts) {	Answer ans = _agentMgr.easySend(h.getId(), cmd);	if (ans == null) {	
host is not in up state skip preparing node on it 

private boolean prepareNodes(String clusterName, List<HostVO> hosts) {	PrepareOCFS2NodesCommand cmd = new PrepareOCFS2NodesCommand(clusterName, marshalNodes(hosts));	for (HostVO h : hosts) {	Answer ans = _agentMgr.easySend(h.getId(), cmd);	if (ans == null) {	continue;	}	if (!ans.getResult()) {	
failed on host 

if (cluster == null) {	throw new CloudRuntimeException("Cannot find cluster for ID " + clusterId);	}	QueryBuilder<HostVO> sc = QueryBuilder.create(HostVO.class);	sc.and(sc.entity().getClusterId(), Op.EQ, clusterId);	sc.and(sc.entity().getPodId(), Op.EQ, cluster.getPodId());	sc.and(sc.entity().getDataCenterId(), Op.EQ, cluster.getDataCenterId());	sc.and(sc.entity().getType(), Op.EQ, Host.Type.Routing);	List<HostVO> hosts = sc.list();	if (hosts.isEmpty()) {	
there is no host in cluster no need to prepare nodes 

========================= cloudstack sample_2418 =========================

public void execute() throws ServerApiException {	try {	GetUploadParamsResponse response = _volumeService.uploadVolume(this);	response.setResponseName(getCommandName());	setResponseObject(response);	} catch (MalformedURLException | ResourceAllocationException e) {	
exception while uploading volume 

========================= cloudstack sample_3570 =========================

public AsyncCallFuture<VolumeApiResult> expungeVolumeAsync(VolumeInfo volume) {	AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();	VolumeApiResult result = new VolumeApiResult(volume);	if (volume.getDataStore() == null) {	
expunge volume with no data store specified 

public AsyncCallFuture<VolumeApiResult> expungeVolumeAsync(VolumeInfo volume) {	AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();	VolumeApiResult result = new VolumeApiResult(volume);	if (volume.getDataStore() == null) {	if (canVolumeBeRemoved(volume.getId())) {	
volume is not referred anywhere remove it from volumes table 

if (volume.getDataStore() == null) {	if (canVolumeBeRemoved(volume.getId())) {	volDao.remove(volume.getId());	}	future.complete(result);	return future;	}	VolumeDataStoreVO volumeStore = _volumeStoreDao.findByVolume(volume.getId());	if (volumeStore != null) {	if (volumeStore.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_IN_PROGRESS) {	
volume is currently being uploaded cant delete it 

future.complete(result);	return future;	}	}	VolumeVO vol = volDao.findById(volume.getId());	String volumePath = vol.getPath();	Long poolId = vol.getPoolId();	if (poolId == null || volumePath == null || volumePath.trim().isEmpty()) {	if (volumeStore == null) {	if (s_logger.isDebugEnabled()) {	
marking volume that was never created as destroyed 

public Void deleteVolumeCallback(AsyncCallbackDispatcher<VolumeServiceImpl, CommandResult> callback, DeleteVolumeContext<VolumeApiResult> context) {	CommandResult result = callback.getResult();	VolumeObject vo = context.getVolume();	VolumeApiResult apiResult = new VolumeApiResult(vo);	try {	if (result.isSuccess()) {	vo.processEvent(Event.OperationSuccessed);	if (canVolumeBeRemoved(vo.getId())) {	
volume is not referred anywhere remove it from volumes table 

}	SnapshotDataStoreVO snapStoreVo = _snapshotStoreDao.findByVolume(vo.getId(), DataStoreRole.Primary);	if(snapStoreVo != null){	_snapshotStoreDao.remove(snapStoreVo.getId());	}	} else {	vo.processEvent(Event.OperationFailed);	apiResult.setResult(result.getResult());	}	} catch (Exception e) {	
ignore delete volume status update failure it will be picked up by storage clean up thread later 

int sleepTime = 120;	int tries = storagePoolMaxWaitSeconds / sleepTime;	while (tries > 0) {	TemplateInfo tmpl = store.getTemplate(template.getId());	if (tmpl != null) {	return tmpl;	}	try {	Thread.sleep(sleepTime * 1000);	} catch (InterruptedException e) {	
waiting for template download been interrupted 

protected void createBaseImageAsync(VolumeInfo volume, PrimaryDataStore dataStore, TemplateInfo template, AsyncCallFuture<VolumeApiResult> future) {	DataObject templateOnPrimaryStoreObj = dataStore.create(template);	VMTemplateStoragePoolVO templatePoolRef = _tmpltPoolDao.findByPoolTemplate(dataStore.getId(), template.getId());	if (templatePoolRef == null) {	throw new CloudRuntimeException("Failed to find template " + template.getUniqueName() + " in storage pool " + dataStore.getId());	} else {	if (s_logger.isDebugEnabled()) {	
found template in storage pool with vmtemplatestoragepool id 

} else {	if (s_logger.isDebugEnabled()) {	}	}	long templatePoolRefId = templatePoolRef.getId();	CreateBaseImageContext<CreateCmdResult> context = new CreateBaseImageContext<CreateCmdResult>(null, volume, dataStore, template, future, templateOnPrimaryStoreObj, templatePoolRefId);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().copyBaseImageCallback(null, null)).setContext(context);	int storagePoolMaxWaitSeconds = NumbersUtil.parseInt(configDao.getValue(Config.StoragePoolMaxWaitSeconds.key()), 3600);	if (s_logger.isDebugEnabled()) {	
acquire lock on vmtemplatestoragepool with timeout seconds 

long templatePoolRefId = templatePoolRef.getId();	CreateBaseImageContext<CreateCmdResult> context = new CreateBaseImageContext<CreateCmdResult>(null, volume, dataStore, template, future, templateOnPrimaryStoreObj, templatePoolRefId);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().copyBaseImageCallback(null, null)).setContext(context);	int storagePoolMaxWaitSeconds = NumbersUtil.parseInt(configDao.getValue(Config.StoragePoolMaxWaitSeconds.key()), 3600);	if (s_logger.isDebugEnabled()) {	}	templatePoolRef = _tmpltPoolDao.acquireInLockTable(templatePoolRefId, storagePoolMaxWaitSeconds);	if (templatePoolRef == null) {	if (s_logger.isDebugEnabled()) {	
unable to acquire lock on vmtemplatestoragepool 

caller.setCallback(caller.getTarget().copyBaseImageCallback(null, null)).setContext(context);	int storagePoolMaxWaitSeconds = NumbersUtil.parseInt(configDao.getValue(Config.StoragePoolMaxWaitSeconds.key()), 3600);	if (s_logger.isDebugEnabled()) {	}	templatePoolRef = _tmpltPoolDao.acquireInLockTable(templatePoolRefId, storagePoolMaxWaitSeconds);	if (templatePoolRef == null) {	if (s_logger.isDebugEnabled()) {	}	templatePoolRef = _tmpltPoolDao.findByPoolTemplate(dataStore.getId(), template.getId());	if (templatePoolRef != null && templatePoolRef.getState() == ObjectInDataStoreStateMachine.State.Ready) {	
unable to acquire lock on vmtemplatestoragepool but template is already copied to primary storage skip copying 

if (s_logger.isDebugEnabled()) {	}	templatePoolRef = _tmpltPoolDao.findByPoolTemplate(dataStore.getId(), template.getId());	if (templatePoolRef != null && templatePoolRef.getState() == ObjectInDataStoreStateMachine.State.Ready) {	createVolumeFromBaseImageAsync(volume, templateOnPrimaryStoreObj, dataStore, future);	return;	}	throw new CloudRuntimeException("Unable to acquire lock on VMTemplateStoragePool: " + templatePoolRefId);	}	if (s_logger.isDebugEnabled()) {	
lock is acquired for vmtemplatestoragepool 

if (templatePoolRef != null && templatePoolRef.getState() == ObjectInDataStoreStateMachine.State.Ready) {	createVolumeFromBaseImageAsync(volume, templateOnPrimaryStoreObj, dataStore, future);	return;	}	throw new CloudRuntimeException("Unable to acquire lock on VMTemplateStoragePool: " + templatePoolRefId);	}	if (s_logger.isDebugEnabled()) {	}	try {	if (templatePoolRef.getState() == ObjectInDataStoreStateMachine.State.Ready) {	
template is already copied to primary storage skip copying 

if (s_logger.isDebugEnabled()) {	}	try {	if (templatePoolRef.getState() == ObjectInDataStoreStateMachine.State.Ready) {	createVolumeFromBaseImageAsync(volume, templateOnPrimaryStoreObj, dataStore, future);	return;	}	templateOnPrimaryStoreObj.processEvent(Event.CreateOnlyRequested);	motionSrv.copyAsync(template, templateOnPrimaryStoreObj, caller);	} catch (Throwable e) {	
failed to create template on storage 

templateOnPrimaryStoreObj.processEvent(Event.CreateOnlyRequested);	motionSrv.copyAsync(template, templateOnPrimaryStoreObj, caller);	} catch (Throwable e) {	templateOnPrimaryStoreObj.processEvent(Event.OperationFailed);	dataStore.create(template);	VolumeApiResult result = new VolumeApiResult(volume);	result.setResult(e.toString());	future.complete(result);	} finally {	if (s_logger.isDebugEnabled()) {	
releasing lock for vmtemplatestoragepool 

CopyCommandResult result = callback.getResult();	VolumeApiResult volResult = new VolumeApiResult((VolumeObject)vo);	if (result.isSuccess()) {	vo.processEvent(Event.OperationSuccessed, result.getAnswer());	} else {	vo.processEvent(Event.OperationFailed);	volResult.setResult(result.getResult());	Answer ans = result.getAnswer();	if (ans != null && ans instanceof CopyCmdAnswer && ans.getDetails().contains("request template reload")) {	if (tmplOnPrimary != null) {	
reset template spool ref entry so that vmware template can be reloaded in next try 

volResult.setResult(result.getResult());	Answer ans = result.getAnswer();	if (ans != null && ans instanceof CopyCmdAnswer && ans.getDetails().contains("request template reload")) {	if (tmplOnPrimary != null) {	VMTemplateStoragePoolVO templatePoolRef = _tmpltPoolDao.findByPoolTemplate(tmplOnPrimary.getDataStore().getId(), tmplOnPrimary.getId());	if (templatePoolRef != null) {	long templatePoolRefId = templatePoolRef.getId();	templatePoolRef = _tmpltPoolDao.acquireInLockTable(templatePoolRefId, 1200);	try {	if (templatePoolRef == null) {	
reset template state on pool failed unable to lock templatepoolref 

CreateVolumeContext<CreateCmdResult> createContext = new CreateVolumeContext<>(null, templateOnPrimary, createTemplateFuture);	AsyncCallbackDispatcher<VolumeServiceImpl, CreateCmdResult> createCaller = AsyncCallbackDispatcher.create(this);	createCaller.setCallback(createCaller.getTarget().createManagedTemplateImageCallback(null, null)).setContext(createContext);	destPrimaryDataStore.getDriver().createAsync(destPrimaryDataStore, templateOnPrimary, createCaller);	VolumeApiResult result = createTemplateFuture.get();	if (result.isFailed()) {	String errMesg =  result.getResult();	throw new CloudRuntimeException("Unable to create template " +  templateOnPrimary.getId() + " on primary storage " + destPrimaryDataStore.getId() + ":" + errMesg);	}	} catch (Throwable e) {	
failed to create template volume on storage 

private void copyTemplateToManagedTemplateVolume(TemplateInfo srcTemplateInfo, TemplateInfo templateOnPrimary, VMTemplateStoragePoolVO templatePoolRef, PrimaryDataStore destPrimaryDataStore, Host destHost) {	AsyncCallFuture<VolumeApiResult> copyTemplateFuture = new AsyncCallFuture<>();	int storagePoolMaxWaitSeconds = NumbersUtil.parseInt(configDao.getValue(Config.StoragePoolMaxWaitSeconds.key()), 3600);	long templatePoolRefId = templatePoolRef.getId();	templatePoolRef = _tmpltPoolDao.acquireInLockTable(templatePoolRefId, storagePoolMaxWaitSeconds);	if (templatePoolRef == null) {	throw new CloudRuntimeException("Unable to acquire lock on VMTemplateStoragePool: " + templatePoolRefId);	}	if (templatePoolRef.getDownloadState() == Status.DOWNLOADED) {	
template already downloaded nothing to do 

result = copyTemplateFuture.get();	}	finally {	revokeAccess(templateOnPrimary, destHost, destPrimaryDataStore);	}	if (result.isFailed()) {	throw new CloudRuntimeException("Failed to copy template " + templateOnPrimary.getId() + " to primary storage " + destPrimaryDataStore.getId() + ": " + result.getResult());	}	}	catch (Throwable e) {	
failed to create a template on primary storage 

throw new CloudRuntimeException("Template " + templateOnPrimary.getUniqueName() + " has not been downloaded to primary storage.");	}	try {	volumeInfo.processEvent(Event.CreateOnlyRequested);	CreateVolumeFromBaseImageContext<VolumeApiResult> context = new CreateVolumeFromBaseImageContext<>(null, volumeInfo, destPrimaryDataStore, templateOnPrimary, future, null);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().createVolumeFromBaseImageCallBack(null, null));	caller.setContext(context);	motionSrv.copyAsync(templateOnPrimary, volumeInfo, caller);	} catch (Throwable e) {	
failed to clone template on primary storage 

public AsyncCallFuture<VolumeApiResult> createManagedStorageVolumeFromTemplateAsync(VolumeInfo volumeInfo, long destDataStoreId, TemplateInfo srcTemplateInfo, long destHostId) {	PrimaryDataStore destPrimaryDataStore = dataStoreMgr.getPrimaryDataStore(destDataStoreId);	Host destHost = _hostDao.findById(destHostId);	if (destHost == null) {	throw new CloudRuntimeException("Destination host should not be null.");	}	Boolean storageCanCloneVolume = new Boolean( destPrimaryDataStore.getDriver().getCapabilities().get(DataStoreCapabilities.CAN_CREATE_VOLUME_FROM_VOLUME.toString()) );	boolean computeZoneSupportsResign = computeZoneSupportsResign(destHost.getDataCenterId(), destHost.getHypervisorType());	AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<>();	if (storageCanCloneVolume && computeZoneSupportsResign) {	
storage can support cloning using a cached template and host cluster can perform uuid resigning 

throw new CloudRuntimeException("Failed to create template " + srcTemplateInfo.getUniqueName() + " on primary storage: " + destDataStoreId);	}	}	VMTemplateStoragePoolVO templatePoolRef = _tmpltPoolDao.findByPoolTemplate(destPrimaryDataStore.getId(), templateOnPrimary.getId());	if (templatePoolRef == null) {	throw new CloudRuntimeException("Failed to find template " + srcTemplateInfo.getUniqueName() + " in storage pool " + destPrimaryDataStore.getId() );	}	if (templatePoolRef.getDownloadState() == Status.NOT_DOWNLOADED) {	copyTemplateToManagedTemplateVolume(srcTemplateInfo, templateOnPrimary, templatePoolRef, destPrimaryDataStore, destHost);	}	
creating a clone from template on primary storage 

}	VMTemplateStoragePoolVO templatePoolRef = _tmpltPoolDao.findByPoolTemplate(destPrimaryDataStore.getId(), templateOnPrimary.getId());	if (templatePoolRef == null) {	throw new CloudRuntimeException("Failed to find template " + srcTemplateInfo.getUniqueName() + " in storage pool " + destPrimaryDataStore.getId() );	}	if (templatePoolRef.getDownloadState() == Status.NOT_DOWNLOADED) {	copyTemplateToManagedTemplateVolume(srcTemplateInfo, templateOnPrimary, templatePoolRef, destPrimaryDataStore, destHost);	}	createManagedVolumeCloneTemplateAsync(volumeInfo, templateOnPrimary, destPrimaryDataStore, future);	} else {	
primary storage does not support cloning or no support for uuid resigning on the host side copying the template normally 

AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();	try {	DataObject volumeOnStore = store.create(volume);	volumeOnStore.processEvent(Event.CreateOnlyRequested);	snapshot.processEvent(Event.CopyingRequested);	CreateVolumeFromBaseImageContext<VolumeApiResult> context = new CreateVolumeFromBaseImageContext<VolumeApiResult>(null, volume, store, volumeOnStore, future, snapshot);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().createVolumeFromSnapshotCallback(null, null)).setContext(context);	motionSrv.copyAsync(snapshot, volumeOnStore, caller);	} catch (Exception e) {	
create volume from snapshot failed 

event = Event.OperationSuccessed;	}	try {	if (result.isSuccess()) {	volume.processEvent(event, result.getAnswer());	} else {	volume.processEvent(event);	}	snapshot.processEvent(event);	} catch (Exception e) {	
create volume from snapshot failed 

try {	destVolume = (VolumeInfo)destStore.create(srcVolume);	destVolume.processEvent(Event.CopyingRequested);	srcVolume.processEvent(Event.CopyingRequested);	CopyVolumeContext<VolumeApiResult> context = new CopyVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().copyVolumeFromImageToPrimaryCallback(null, null)).setContext(context);	motionSrv.copyAsync(srcVolume, destVolume, caller);	return future;	} catch (Exception e) {	
failed to copy volume from image store 

try {	destVolume = (VolumeInfo)destStore.create(srcVolume);	srcVolume.processEvent(Event.MigrationRequested);	destVolume.processEventOnly(Event.CreateOnlyRequested);	CopyVolumeContext<VolumeApiResult> context = new CopyVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().copyVolumeFromPrimaryToImageCallback(null, null)).setContext(context);	motionSrv.copyAsync(srcVolume, destVolume, caller);	return future;	} catch (Exception e) {	
failed to copy volume to image store 

if (srcVolume.getState() == Volume.State.Uploaded) {	return copyVolumeFromImageToPrimary(srcVolume, destStore);	}	if (destStore.getRole() == DataStoreRole.Image) {	return copyVolumeFromPrimaryToImage(srcVolume, destStore);	}	AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();	VolumeApiResult res = new VolumeApiResult(srcVolume);	try {	if (!snapshotMgr.canOperateOnVolume(srcVolume)) {	
there are snapshots creating on this volume can not move this volume 

}	VolumeVO destVol = duplicateVolumeOnAnotherStorage(srcVolume, (StoragePool)destStore);	VolumeInfo destVolume = volFactory.getVolume(destVol.getId(), destStore);	destVolume.processEvent(Event.MigrationCopyRequested);	srcVolume.processEvent(Event.MigrationRequested);	CopyVolumeContext<VolumeApiResult> context = new CopyVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().copyVolumeCallBack(null, null)).setContext(context);	motionSrv.copyAsync(srcVolume, destVolume, caller);	} catch (Exception e) {	
failed to copy volume 

destroyVolume(srcVolume.getId());	srcVolume = volFactory.getVolume(srcVolume.getId());	AsyncCallFuture<VolumeApiResult> destroyFuture = expungeVolumeAsync(srcVolume);	if (destroyFuture.get().isFailed()) {	Thread.sleep(5 * 1000);	destroyFuture = expungeVolumeAsync(srcVolume);	destroyFuture.get();	}	future.complete(res);	} catch (Exception e) {	
failed to clean up volume on storage 

if (destroyFuture.get().isFailed()) {	Thread.sleep(5 * 1000);	destroyFuture = expungeVolumeAsync(srcVolume);	destroyFuture.get();	}	future.complete(res);	} catch (Exception e) {	}	return null;	} catch (Exception e) {	
failed to process copy volume callback 

public AsyncCallFuture<VolumeApiResult> migrateVolume(VolumeInfo srcVolume, DataStore destStore) {	AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();	VolumeApiResult res = new VolumeApiResult(srcVolume);	try {	if (!snapshotMgr.canOperateOnVolume(srcVolume)) {	
snapshots are being created on this volume this volume cannot be migrated now 

future.complete(res);	return future;	}	VolumeInfo destVolume = volFactory.getVolume(srcVolume.getId(), destStore);	srcVolume.processEvent(Event.MigrationRequested);	MigrateVolumeContext<VolumeApiResult> context = new MigrateVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().migrateVolumeCallBack(null, null)).setContext(context);	motionSrv.copyAsync(srcVolume, destVolume, caller);	} catch (Exception e) {	
failed to copy volume 

try {	if (result.isFailed()) {	res.setResult(result.getResult());	srcVolume.processEvent(Event.OperationFailed);	future.complete(res);	} else {	srcVolume.processEvent(Event.OperationSuccessed);	future.complete(res);	}	} catch (Exception e) {	
failed to process migrate volume callback 

public AsyncCallFuture<CommandResult> migrateVolumes(Map<VolumeInfo, DataStore> volumeMap, VirtualMachineTO vmTo, Host srcHost, Host destHost) {	AsyncCallFuture<CommandResult> future = new AsyncCallFuture<CommandResult>();	CommandResult res = new CommandResult();	try {	List<VolumeInfo> volumesMigrating = new ArrayList<VolumeInfo>();	for (Map.Entry<VolumeInfo, DataStore> entry : volumeMap.entrySet()) {	VolumeInfo volume = entry.getKey();	if (!snapshotMgr.canOperateOnVolume(volume)) {	
snapshots are being created on a volume volumes cannot be migrated now 

} else {	volume.processEvent(Event.MigrationRequested);	volumesMigrating.add(volume);	}	}	MigrateVmWithVolumesContext<CommandResult> context = new MigrateVmWithVolumesContext<CommandResult>(null, future, volumeMap);	AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);	caller.setCallback(caller.getTarget().migrateVmWithVolumesCallBack(null, null)).setContext(context);	motionSrv.copyAsync(volumeMap, vmTo, srcHost, destHost, caller);	} catch (Exception e) {	
failed to copy volume 

}	} else {	vo.processEvent(Event.OperationSuccessed, result.getAnswer());	if (vo.getSize() != null) {	long physicalSize = 0;	DataStore ds = vo.getDataStore();	VolumeDataStoreVO volStore = _volumeStoreDao.findByStoreVolume(ds.getId(), vo.getId());	if (volStore != null) {	physicalSize = volStore.getPhysicalSize();	} else {	
no entry found in volume store ref for volume id and image store id at the end of uploading volume 

VolumeDataStoreVO volStore = _volumeStoreDao.findByStoreVolume(ds.getId(), vo.getId());	if (volStore != null) {	physicalSize = volStore.getPhysicalSize();	} else {	}	Scope dsScope = ds.getScope();	if (dsScope.getScopeType() == ScopeType.ZONE) {	if (dsScope.getScopeId() != null) {	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_UPLOAD, vo.getAccountId(), dsScope.getScopeId(), vo.getId(), vo.getName(), null, null, physicalSize, vo.getSize(), Volume.class.getName(), vo.getUuid());	} else {	
zone scope image store has a null scope id 

} else if (dsScope.getScopeType() == ScopeType.REGION) {	UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_UPLOAD, vo.getAccountId(), -1, vo.getId(), vo.getName(), null, null, physicalSize, vo.getSize(), Volume.class.getName(), vo.getUuid());	_resourceLimitMgr.incrementResourceCount(vo.getAccountId(), ResourceType.secondary_storage, vo.getSize());	}	}	}	VolumeApiResult res = new VolumeApiResult(vo);	context.future.complete(res);	return null;	} catch (Exception e) {	
register volume failed 

public AsyncCallFuture<VolumeApiResult> resize(VolumeInfo volume) {	AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();	VolumeApiResult result = new VolumeApiResult(volume);	try {	volume.processEvent(Event.ResizeRequested);	} catch (Exception e) {	
failed to change state to resize 

protected Void resizeVolumeCallback(AsyncCallbackDispatcher<VolumeServiceImpl, CreateCmdResult> callback, CreateVolumeContext<VolumeApiResult> context) {	CreateCmdResult result = callback.getResult();	AsyncCallFuture<VolumeApiResult> future = context.future;	VolumeInfo volume = (VolumeInfo)context.volume;	if (result.isFailed()) {	try {	volume.processEvent(Event.OperationFailed);	} catch (Exception e) {	
failed to change state 

} catch (Exception e) {	}	VolumeApiResult res = new VolumeApiResult(volume);	res.setResult(result.getResult());	future.complete(res);	return null;	}	try {	volume.processEvent(Event.OperationSuccessed);	} catch (Exception e) {	
failed to change state 

public void handleVolumeSync(DataStore store) {	if (store == null) {	
huh image store is null 

try {	Map<Long, TemplateProp> volumeInfos = listVolume(store);	if (volumeInfos == null) {	return;	}	List<VolumeDataStoreVO> dbVolumes = _volumeStoreDao.listByStoreId(storeId);	List<VolumeDataStoreVO> toBeDownloaded = new ArrayList<VolumeDataStoreVO>(dbVolumes);	for (VolumeDataStoreVO volumeStore : dbVolumes) {	VolumeVO volume = volDao.findById(volumeStore.getVolumeId());	if (volume == null) {	
volume store ref table shows that volume is on image store but the volume is not found in volumes table potentially some bugs in deletevolume so we just treat this volume to be deleted and mark it as destroyed 

for (VolumeDataStoreVO volumeStore : dbVolumes) {	VolumeVO volume = volDao.findById(volumeStore.getVolumeId());	if (volume == null) {	volumeStore.setDestroyed(true);	_volumeStoreDao.update(volumeStore.getId(), volumeStore);	continue;	}	if (volumeInfos.containsKey(volume.getId())) {	TemplateProp volInfo = volumeInfos.remove(volume.getId());	toBeDownloaded.remove(volumeStore);	
volume sync found already in the volume image store table 

toBeDownloaded.remove(volumeStore);	if (volumeStore.getDownloadState() != Status.DOWNLOADED) {	volumeStore.setErrorString("");	}	if (volInfo.isCorrupted()) {	volumeStore.setDownloadState(Status.DOWNLOAD_ERROR);	String msg = "Volume " + volume.getUuid() + " is corrupted on image store";	volumeStore.setErrorString(msg);	s_logger.info(msg);	if (volume.getState() == State.NotUploaded || volume.getState() == State.UploadInProgress) {	
volume sync found uploaded using ssvm on image store as corrupted marking it as failed 

volumeStore.setErrorString(msg);	s_logger.info(msg);	if (volume.getState() == State.NotUploaded || volume.getState() == State.UploadInProgress) {	_volumeStoreDao.update(volumeStore.getId(), volumeStore);	VolumeObject volObj = (VolumeObject)volFactory.getVolume(volume.getId());	volObj.processEvent(Event.OperationFailed);	} else if (volumeStore.getDownloadUrl() == null) {	msg = "Volume (" + volume.getUuid() + ") with install path " + volInfo.getInstallPath() + " is corrupted, please check in image store: " + volumeStore.getDataStoreId();	s_logger.warn(msg);	} else {	
removing volume store ref entry for corrupted volume 

} catch (ResourceAllocationException e) {	s_logger.warn(e.getMessage());	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_RESOURCE_LIMIT_EXCEEDED, volume.getDataCenterId(), volume.getPodId(), e.getMessage(), e.getMessage());	} finally {	_resourceLimitMgr.recalculateResourceCount(volume.getAccountId(), volume.getDomainId(), com.cloud.configuration.Resource.ResourceType.secondary_storage.getOrdinal());	}	}	}	continue;	} else if (volume.getState() == State.NotUploaded || volume.getState() == State.UploadInProgress) {	
volume sync did not find uploaded using ssvm on image store marking it as failed 

toBeDownloaded.remove(volumeStore);	volumeStore.setDownloadState(Status.DOWNLOAD_ERROR);	String msg = "Volume " + volume.getUuid() + " is corrupted on image store";	volumeStore.setErrorString(msg);	_volumeStoreDao.update(volumeStore.getId(), volumeStore);	VolumeObject volObj = (VolumeObject)volFactory.getVolume(volume.getId());	volObj.processEvent(Event.OperationFailed);	continue;	}	if (volumeStore.getDownloadState() != Status.DOWNLOADED) {	
volume sync did not find ready on image store will request download to start resume shortly 

VolumeObject volObj = (VolumeObject)volFactory.getVolume(volume.getId());	volObj.processEvent(Event.OperationFailed);	continue;	}	if (volumeStore.getDownloadState() != Status.DOWNLOADED) {	}	}	if (toBeDownloaded.size() > 0) {	for (VolumeDataStoreVO volumeHost : toBeDownloaded) {	if (volumeHost.getDownloadUrl() == null) {	
skip downloading volume since no download url is specified 

if (volumeStore.getDownloadState() != Status.DOWNLOADED) {	}	}	if (toBeDownloaded.size() > 0) {	for (VolumeDataStoreVO volumeHost : toBeDownloaded) {	if (volumeHost.getDownloadUrl() == null) {	continue;	}	if (store.getScope().getScopeType() == ScopeType.REGION) {	if (volumeHost.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED && volumeHost.getInstallPath() == null) {	
skip sync volume for migration of previous nfs to object store 

if (toBeDownloaded.size() > 0) {	for (VolumeDataStoreVO volumeHost : toBeDownloaded) {	if (volumeHost.getDownloadUrl() == null) {	continue;	}	if (store.getScope().getScopeType() == ScopeType.REGION) {	if (volumeHost.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED && volumeHost.getInstallPath() == null) {	continue;	}	}	
volume needs to be downloaded to 

EndPoint ep = _epSelector.select(store);	Answer answer = null;	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	answer = new Answer(dtCommand, false, errMsg);	} else {	answer = ep.sendMessage(dtCommand);	}	if (answer == null || !answer.getResult()) {	
failed to deleted volume at store 

if (answer == null || !answer.getResult()) {	} else {	String description = "Deleted volume " + tInfo.getTemplateName() + " on secondary storage " + storeId;	s_logger.info(description);	}	}	} finally {	syncLock.unlock();	}	} else {	
couldn t get global lock on another thread may be doing volume sync on data store now 

s_logger.error(errMsg);	answer = new Answer(cmd, false, errMsg);	} else {	answer = ep.sendMessage(cmd);	}	if (answer != null && answer.getResult()) {	ListVolumeAnswer tanswer = (ListVolumeAnswer)answer;	return tanswer.getTemplateInfo();	} else {	if (s_logger.isDebugEnabled()) {	
can not list volumes for image store 

public SnapshotInfo takeSnapshot(VolumeInfo volume) {	SnapshotInfo snapshot = null;	try {	snapshot = snapshotMgr.takeSnapshot(volume);	} catch (Exception e) {	
take snapshot failed 

========================= cloudstack sample_3966 =========================

public void testInjected() throws Exception {	
starting test to archive and delete events 

public void testInjected() throws Exception {	archiveEvents();	deleteEvents();	
archive delete events test passed 

========================= cloudstack sample_2224 =========================

public Answer execute(final ResizeVolumeCommand command, final LibvirtComputingResource libvirtComputingResource) {	final String volid = command.getPath();	final long newSize = command.getNewSize();	final long currentSize = command.getCurrentSize();	final String vmInstanceName = command.getInstanceName();	final boolean shrinkOk = command.getShrinkOk();	final StorageFilerTO spool = command.getPool();	final String notifyOnlyType = "NOTIFYONLY";	if ( currentSize == newSize) {	
no need to resize volume current size is same as new size 

KVMStoragePool pool = storagePoolMgr.getStoragePool(spool.getType(), spool.getUuid());	final KVMPhysicalDisk vol = pool.getPhysicalDisk(volid);	final String path = vol.getPath();	String type = notifyOnlyType;	if (pool.getType() != StoragePoolType.RBD) {	type = libvirtComputingResource.getResizeScriptType(pool, vol);	if (type.equals("QCOW2") && shrinkOk) {	return new ResizeVolumeAnswer(command, false, "Unable to shrink volumes of type " + type);	}	} else {	
volume is on a rbd storage pool no need to query for additional information 

final KVMPhysicalDisk vol = pool.getPhysicalDisk(volid);	final String path = vol.getPath();	String type = notifyOnlyType;	if (pool.getType() != StoragePoolType.RBD) {	type = libvirtComputingResource.getResizeScriptType(pool, vol);	if (type.equals("QCOW2") && shrinkOk) {	return new ResizeVolumeAnswer(command, false, "Unable to shrink volumes of type " + type);	}	} else {	}	
resizing volume 

final String path = vol.getPath();	String type = notifyOnlyType;	if (pool.getType() != StoragePoolType.RBD) {	type = libvirtComputingResource.getResizeScriptType(pool, vol);	if (type.equals("QCOW2") && shrinkOk) {	return new ResizeVolumeAnswer(command, false, "Unable to shrink volumes of type " + type);	}	} else {	}	if (pool.getType() != StoragePoolType.CLVM && vol.getFormat() != PhysicalDiskFormat.QCOW2) {	
volume can be resized by libvirt asking libvirt to resize the volume 

flags = 1;	}	if (shrinkOk) {	flags = 4;	}	v.resize(newSize, flags);	} catch (final LibvirtException e) {	return new ResizeVolumeAnswer(command, false, e.toString());	}	}	
invoking resize script to handle type 

if (result != null) {	if(type.equals(notifyOnlyType)) {	return new ResizeVolumeAnswer(command, true, "Resize succeeded, but need reboot to notify guest");	} else {	return new ResizeVolumeAnswer(command, false, result);	}	}	pool = storagePoolMgr.getStoragePool(spool.getType(), spool.getUuid());	pool.refresh();	final long finalSize = pool.getPhysicalDisk(volid).getVirtualSize();	
after resize size reports as requested 

========================= cloudstack sample_1058 =========================

public String authenticate(String command, Map<String, Object[]> params, HttpSession session, InetAddress remoteAddress, String responseType, StringBuilder auditTrailSb, final HttpServletRequest req, final HttpServletResponse resp) throws ServerApiException {	SAMLMetaDataResponse response = new SAMLMetaDataResponse();	response.setResponseName(getCommandName());	try {	DefaultBootstrap.bootstrap();	} catch (ConfigurationException | FactoryConfigurationError e) {	
opensaml bootstrapping error 

BasicX509Credential signingCredential = new BasicX509Credential();	signingCredential.setEntityCertificate(spMetadata.getSigningCertificate());	BasicX509Credential encryptionCredential = new BasicX509Credential();	encryptionCredential.setEntityCertificate(spMetadata.getEncryptionCertificate());	try {	signKeyDescriptor.setKeyInfo(keyInfoGenerator.generate(signingCredential));	encKeyDescriptor.setKeyInfo(keyInfoGenerator.generate(encryptionCredential));	spSSODescriptor.getKeyDescriptors().add(signKeyDescriptor);	spSSODescriptor.getKeyDescriptors().add(encKeyDescriptor);	} catch (SecurityException e) {	
unable to add sp descriptors 

public void setAuthenticators(List<PluggableAPIAuthenticator> authenticators) {	for (PluggableAPIAuthenticator authManager: authenticators) {	if (authManager != null && authManager instanceof SAML2AuthManager) {	_samlAuthManager = (SAML2AuthManager) authManager;	}	}	if (_samlAuthManager == null) {	
no suitable pluggable authentication manager found for getspmetadata cmd 

========================= cloudstack sample_1367 =========================

public boolean waitEvent() throws InterruptedException {	synchronized (this) {	if (signalled) return true;	while (true) {	try {	wait();	assert (signalled);	return signalled;	} catch (InterruptedException e) {	
unexpected awaken signal in wait 

public boolean waitEvent(long timeOutMiliseconds) throws InterruptedException {	synchronized (this) {	if (signalled) return true;	try {	wait(timeOutMiliseconds);	return signalled;	} catch (InterruptedException e) {	
unexpected awaken signal in wait 

========================= cloudstack sample_2818 =========================

final Connection conn = xenServer56.getConnection();	if (command.getOption() != null && command.getOption().equals("create")) {	final String result = xenServer56.networkUsage(conn, command.getPrivateIP(), "create", null);	final NetworkUsageAnswer answer = new NetworkUsageAnswer(command, result, 0L, 0L);	return answer;	}	final long[] stats = xenServer56.getNetworkStats(conn, command.getPrivateIP());	final NetworkUsageAnswer answer = new NetworkUsageAnswer(command, "", stats[0], stats[1]);	return answer;	} catch (final Exception ex) {	
failed to get network usage stats due to 

int i = 0;	while (i < splitResult.length - 1) {	stats[0] += Long.parseLong(splitResult[i++]);	stats[1] += Long.parseLong(splitResult[i++]);	}	return new NetworkUsageAnswer(command, "success", stats[0], stats[1]);	}	}	return new NetworkUsageAnswer(command, "success", 0L, 0L);	} catch (final Exception ex) {	
failed to get network usage stats due to 

========================= cloudstack sample_1222 =========================

final PrivateIpVO ipVO = privateGW.retrivePrivateIP(this);	final Network network = privateGW.retrievePrivateNetwork(this);	final String netmask = NetUtils.getCidrNetmask(network.getCidr());	final PrivateIpAddress ip = new PrivateIpAddress(ipVO, network.getBroadcastUri().toString(), network.getGateway(), netmask, nicProfile.getMacAddress());	final List<PrivateIpAddress> privateIps = new ArrayList<PrivateIpAddress>(1);	privateIps.add(ip);	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createVpcAssociatePrivateIPCommands(router, privateIps, cmds, isAddOperation);	try {	if (_networkGeneralHelper.sendCommandsToRouter(router, cmds)) {	
successfully applied ip association for ip in vpc network 

final String netmask = NetUtils.getCidrNetmask(network.getCidr());	final PrivateIpAddress ip = new PrivateIpAddress(ipVO, network.getBroadcastUri().toString(), network.getGateway(), netmask, nicProfile.getMacAddress());	final List<PrivateIpAddress> privateIps = new ArrayList<PrivateIpAddress>(1);	privateIps.add(ip);	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createVpcAssociatePrivateIPCommands(router, privateIps, cmds, isAddOperation);	try {	if (_networkGeneralHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	
failed to associate ip address in vpc network 

privateIps.add(ip);	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createVpcAssociatePrivateIPCommands(router, privateIps, cmds, isAddOperation);	try {	if (_networkGeneralHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	return false;	}	} catch (final Exception ex) {	
failed to send add delete private network commands to rotuer 

try {	if (_networkGeneralHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	return false;	}	} catch (final Exception ex) {	return false;	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	
router is in so not sending setup private network command to the backend 

if (_networkGeneralHelper.sendCommandsToRouter(router, cmds)) {	return true;	} else {	return false;	}	} catch (final Exception ex) {	return false;	}	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	} else {	
unable to setup private gateway virtual router is not in the right state 

public boolean visit(final DhcpPvlanRules dhcp) throws ResourceUnavailableException {	final VirtualRouter router = dhcp.getRouter();	final PvlanSetupCommand setupCommand = dhcp.getSetupCommand();	final Commands cmds = new Commands(Command.OnError.Stop);	cmds.addCommand(setupCommand);	try {	return _networkGeneralHelper.sendCommandsToRouter(router, cmds);	} catch (final ResourceUnavailableException e) {	
timed out 

========================= cloudstack sample_2232 =========================

rollBackState = true;	CloudRuntimeException e = new CloudRuntimeException("Failed to clean up domain resources and sub domains, delete failed on domain " + domain.getName() + " (id: " + domain.getId() + ").");	e.addProxyObject(domain.getUuid(), "domainId");	throw e;	}	} else {	List<Long> networkIds = _networkDomainDao.listNetworkIdsByDomain(domain.getId());	List<AccountVO> accountsForCleanup = _accountDao.findCleanupsForRemovedAccounts(domain.getId());	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByDomainId(domain.getId());	if (dedicatedResources != null && !dedicatedResources.isEmpty()) {	
there are dedicated resources for the domain 

e.addProxyObject(domain.getUuid(), "domainId");	throw e;	} else {	s_logger.debug("Domain specific Virtual IP ranges " + " are successfully released as a part of domain id=" + domain.getId() + " cleanup.");	}	cleanupDomainOfferings(domain.getId());	CallContext.current().putContextParameter(Domain.class, domain.getUuid());	_messageBus.publish(_name, MESSAGE_REMOVE_DOMAIN_EVENT, PublishScope.LOCAL, domain);	return true;	} catch (Exception ex) {	
exception deleting domain with id 

boolean deleteAccount = _accountMgr.deleteAccount(account, CallContext.current().getCallingUserId(), CallContext.current().getCallingAccount());	if (!deleteAccount) {	s_logger.warn("Failed to cleanup account id=" + account.getId() + " as a part of domain cleanup");	}	success = (success && deleteAccount);	} else {	ProjectVO project = _projectDao.findByProjectAccountId(account.getId());	s_logger.debug("Deleting project " + project + " as a part of domain id=" + domainId + " cleanup");	boolean deleteProject = _projectMgr.deleteProject(CallContext.current().getCallingAccount(), CallContext.current().getCallingUserId(), project);	if (!deleteProject) {	
failed to cleanup project as a part of domain cleanup 

}	if (!networksDeleted) {	s_logger.debug("Failed to delete the shared networks as a part of domain id=" + domainId + " clenaup");	return false;	}	boolean deleteDomainSuccess = true;	List<AccountVO> accountsForCleanup = _accountDao.findCleanupsForRemovedAccounts(domainId);	if (accountsForCleanup.isEmpty()) {	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByDomainId(domainId);	if (dedicatedResources != null && !dedicatedResources.isEmpty()) {	
releasing dedicated resources for domain 

s_logger.debug("Failed to delete the shared networks as a part of domain id=" + domainId + " clenaup");	return false;	}	boolean deleteDomainSuccess = true;	List<AccountVO> accountsForCleanup = _accountDao.findCleanupsForRemovedAccounts(domainId);	if (accountsForCleanup.isEmpty()) {	List<DedicatedResourceVO> dedicatedResources = _dedicatedDao.listByDomainId(domainId);	if (dedicatedResources != null && !dedicatedResources.isEmpty()) {	for (DedicatedResourceVO dr : dedicatedResources) {	if (!_dedicatedDao.remove(dr.getId())) {	
fail to release dedicated resources for domain 

for (DedicatedResourceVO dr : dedicatedResources) {	if (!_dedicatedDao.remove(dr.getId())) {	return false;	}	}	}	deleteDomainSuccess = _domainDao.remove(domainId);	_resourceCountDao.removeEntriesByOwner(domainId, ResourceOwnerType.Domain);	_resourceLimitDao.removeEntriesByOwner(domainId, ResourceOwnerType.Domain);	} else {	
can t delete the domain yet because it has accounts that need a cleanup 

========================= cloudstack sample_2398 =========================

private void executeExpireOwnershipSql(final String sql, final long resource) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try (final PreparedStatement pstmt = txn.prepareAutoCloseStatement(sql);) {	pstmt.setLong(1, resource);	pstmt.executeUpdate();	} catch (SQLException e) {	txn.rollback();	
failed to expire ownership for out of band management server id 

public void expireOutOfBandManagementOwnershipByServer(long serverId) {	final String resetOwnerSql = "UPDATE oobm set mgmt_server_id=NULL, power_state=NULL where mgmt_server_id=?";	executeExpireOwnershipSql(resetOwnerSql, serverId);	if (LOG.isDebugEnabled()) {	
expired out of band management ownership for hosts owned by management server id 

public boolean updateState(OutOfBandManagement.PowerState oldStatus, OutOfBandManagement.PowerState.Event event, OutOfBandManagement.PowerState newStatus, OutOfBandManagement vo, Object data) {	OutOfBandManagementVO oobmHost = (OutOfBandManagementVO) vo;	if (oobmHost == null) {	if (LOG.isTraceEnabled()) {	
invalid out of band management host view object provided 

sc.setParameters("status", oldStatus);	sc.setParameters("id", oobmHost.getId());	sc.setParameters("update", oobmHost.getUpdateCount());	oobmHost.incrUpdateCount();	UpdateBuilder ub = getUpdateBuilder(oobmHost);	ub.set(oobmHost, PowerStateAttr, newStatus);	ub.set(oobmHost, UpdateTimeAttr, DateUtil.currentGMTTime());	ub.set(oobmHost, MsIdAttr, newManagementServerId);	int result = update(ub, sc, null);	if (LOG.isDebugEnabled() && result <= 0) {	
failed to update out of band management power state from s to s due to event s for the host id d 

========================= cloudstack sample_4132 =========================

public boolean deleteCiscoNexusVSM(DeleteCiscoNexusVSMCmd cmd) {	boolean result;	try {	result = deleteCiscoNexusVSM(cmd.getCiscoNexusVSMDeviceId());	} catch (ResourceInUseException e) {	
vsm could not be deleted 

} catch (CloudRuntimeException e) {	String msg = "Invalid credentials supplied for user " + vsmUser + " for Cisco Nexus 1000v VSM at " + vsmIp;	s_logger.error(msg);	_clusterDao.remove(clusterId);	throw new CloudRuntimeException(msg);	}	vsm = _vsmDao.getVSMbyIpaddress(vsmIp);	if (vsm != null) {	List<ClusterVSMMapVO> clusterList = _clusterVSMDao.listByVSMId(vsm.getId());	if (clusterList != null && !clusterList.isEmpty()) {	
failed to add cluster specified nexus vsm is already associated with another cluster 

========================= cloudstack sample_1275 =========================

public void run() {	try {	while (connectionAlive) {	ClientPacket packet = queue.poll(1, TimeUnit.SECONDS);	if (packet != null) {	packet.write(os);	os.flush();	}	}	} catch (Throwable e) {	
unexpected exception 

if (packet != null) {	packet.write(os);	os.flush();	}	}	} catch (Throwable e) {	if (connectionAlive) {	closeConnection();	}	} finally {	
sending thread exit processing shutdown connection 

========================= cloudstack sample_4974 =========================

public DataStore initialize(Map<String, Object> dsInfos) {	Long dcId = (Long)dsInfos.get("zoneId");	String url = (String)dsInfos.get("url");	String name = (String)dsInfos.get("name");	if (name == null) {	name = url;	}	String providerName = (String)dsInfos.get("providerName");	DataStoreRole role = (DataStoreRole)dsInfos.get("role");	Map<String, String> details = (Map<String, String>)dsInfos.get("details");	
trying to add a new data store at to data center 

========================= cloudstack sample_938 =========================

protected boolean doScript(Script cmd, OutputInterpreter interpreter, int retry) {	String res = null;	while (retry-- > 0) {	if (interpreter == null) {	res = cmd.execute();	} else {	res = cmd.execute(interpreter);	}	if (res != null && res.startsWith("Error: Unable to establish LAN")) {	
ipmi script timeout will retry times 

while (retry-- > 0) {	if (interpreter == null) {	res = cmd.execute();	} else {	res = cmd.execute(interpreter);	}	if (res != null && res.startsWith("Error: Unable to establish LAN")) {	try {	TimeUnit.SECONDS.sleep(1);	} catch (InterruptedException e) {	
ignored interupted while waiting to retry running script 

TimeUnit.SECONDS.sleep(1);	} catch (InterruptedException e) {	}	continue;	} else if (res == null) {	return true;	} else {	break;	}	}	
ipmi scirpt failed due to 

public PingCommand getCurrentStatus(long id) {	try {	if (!ipmiPing()) {	Thread.sleep(1000);	if (!ipmiPing()) {	
cannot ping ipmi nic 

public PingCommand getCurrentStatus(long id) {	try {	if (!ipmiPing()) {	Thread.sleep(1000);	if (!ipmiPing()) {	return null;	}	}	} catch (Exception e) {	
cannot ping ipmi nic 

Script bootCmd = null;	if (cmd.getBootDev() == BootDev.disk) {	bootCmd = _setDiskBootCommand;	} else if (cmd.getBootDev() == BootDev.pxe) {	bootCmd = _setPxeBootCommand;	} else {	throw new CloudRuntimeException("Unkonwn boot dev " + cmd.getBootDev());	}	String bootDev = cmd.getBootDev().name();	if (!doScript(bootCmd)) {	
set boot dev to failed 

bootCmd = _setDiskBootCommand;	} else if (cmd.getBootDev() == BootDev.pxe) {	bootCmd = _setPxeBootCommand;	} else {	throw new CloudRuntimeException("Unkonwn boot dev " + cmd.getBootDev());	}	String bootDev = cmd.getBootDev().name();	if (!doScript(bootCmd)) {	return new Answer(cmd, false, "Set " + _ip + " boot dev to " + bootDev + "failed");	}	
set boot dev to Success 

break;	}	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	break;	}	OutputInterpreter.AllLinesParser interpreter = new OutputInterpreter.AllLinesParser();	if (!doScript(_getStatusCommand, interpreter)) {	success = true;	
cannot get power status of assume vm state changed successfully 

}	q = QueryBuilder.create(VMInstanceVO.class);	q.and(q.entity().getInstanceName(), SearchCriteria.Op.EQ, vm.getName());	vmvo = q.find();	if (vmvo == null) {	return new StartAnswer(cmd, String.format("cannot find vm[name:%s] while waiting for baremtal provision done notification", vm.getName()));	}	if (VirtualMachine.State.Running == vmvo.getState()) {	return new StartAnswer(cmd);	}	
still wait for baremetal provision done notification for vm name s current vm state is s 

if (vmvo == null) {	return new StartAnswer(cmd, String.format("cannot find vm[name:%s] while waiting for baremtal provision done notification", vm.getName()));	}	if (VirtualMachine.State.Running == vmvo.getState()) {	return new StartAnswer(cmd);	}	}	return new StartAnswer(cmd, String.format("timeout after %s seconds, no baremetal provision done notification received. vm[name:%s] failed to start", isProvisionDoneNotificationTimeout, vm.getName()));	}	}	
start bare metal vm successfully 

protected ReadyAnswer execute(ReadyCommand cmd) {	
bare metal resource is ready 

========================= cloudstack sample_892 =========================

public void execute() {	Vpc vpc = null;	try {	if (isStart()) {	_vpcService.startVpc(getEntityId(), true);	} else {	s_logger.debug("Not starting VPC as " + ApiConstants.START + "=false was passed to the API");	}	vpc = _entityMgr.findById(Vpc.class, getEntityId());	} catch (ResourceUnavailableException ex) {	
exception 

try {	if (isStart()) {	_vpcService.startVpc(getEntityId(), true);	} else {	s_logger.debug("Not starting VPC as " + ApiConstants.START + "=false was passed to the API");	}	vpc = _entityMgr.findById(Vpc.class, getEntityId());	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3531 =========================

public void onProxyAlert(Object sender, ConsoleProxyAlertEventArgs args) {	
received console proxy alert 

public void onProxyAlert(Object sender, ConsoleProxyAlertEventArgs args) {	DataCenterVO dc = _dcDao.findById(args.getZoneId());	ConsoleProxyVO proxy = args.getProxy();	if (proxy == null && args.getProxyId() != 0) proxy = _consoleProxyDao.findById(args.getProxyId());	if (proxy == null && args.getType() != ConsoleProxyAlertEventArgs.PROXY_CREATE_FAILURE) {	throw new CloudRuntimeException("Invalid alert arguments, proxy must be set");	}	switch (args.getType()) {	
new console proxy created zone proxy public ip private ip 

public void onProxyAlert(Object sender, ConsoleProxyAlertEventArgs args) {	DataCenterVO dc = _dcDao.findById(args.getZoneId());	ConsoleProxyVO proxy = args.getProxy();	if (proxy == null && args.getProxyId() != 0) proxy = _consoleProxyDao.findById(args.getProxyId());	if (proxy == null && args.getType() != ConsoleProxyAlertEventArgs.PROXY_CREATE_FAILURE) {	throw new CloudRuntimeException("Invalid alert arguments, proxy must be set");	}	switch (args.getType()) {	break;	
console proxy is up zone proxy public ip private ip 

switch (args.getType()) {	break;	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY, args.getZoneId(), proxy.getPodIdToDeployIn(), "Console proxy up in zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()), "Console proxy up (zone " + dc.getName() + ")");	break;	case ConsoleProxyAlertEventArgs.PROXY_DOWN: if (s_logger.isDebugEnabled()) s_logger.debug("Console proxy is down, zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()));	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY, args.getZoneId(), proxy.getPodIdToDeployIn(), "Console proxy down in zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()), "Console proxy down (zone " + dc.getName() + ")");	break;	case ConsoleProxyAlertEventArgs.PROXY_REBOOTED: if (s_logger.isDebugEnabled()) s_logger.debug("Console proxy is rebooted, zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()));	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY, args.getZoneId(), proxy.getPodIdToDeployIn(), "Console proxy rebooted in zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()), "Console proxy rebooted (zone " + dc.getName() + ")");	break;	
console proxy creation failure zone 

_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY, args.getZoneId(), proxy.getPodIdToDeployIn(), "Console proxy rebooted in zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()), "Console proxy rebooted (zone " + dc.getName() + ")");	break;	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY, args.getZoneId(), null, "Console proxy creation failure. zone: " + dc.getName() + ", error details: " + args.getMessage(), "Console proxy creation failure (zone " + dc.getName() + ")");	break;	case ConsoleProxyAlertEventArgs.PROXY_START_FAILURE: if (s_logger.isDebugEnabled()) s_logger.debug("Console proxy startup failure, zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()));	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY, args.getZoneId(), proxy.getPodIdToDeployIn(), "Console proxy startup failure. zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()) + ", error details: " + args.getMessage(), "Console proxy startup failure (zone " + dc.getName() + ")");	break;	case ConsoleProxyAlertEventArgs.PROXY_FIREWALL_ALERT: if (s_logger.isDebugEnabled()) s_logger.debug("Console proxy firewall alert, zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()));	_alertMgr.sendAlert( AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY, args.getZoneId(), proxy.getPodIdToDeployIn(), "Failed to open console proxy firewall port. zone: " + dc.getName() + ", proxy: " + proxy.getHostName() + ", public IP: " + proxy.getPublicIpAddress() + ", private IP: " + (proxy.getPrivateIpAddress() == null ? "N/A" : proxy.getPrivateIpAddress()), "Console proxy alert (zone " + dc.getName() + ")");	break;	
console proxy storage alert zone proxy public ip private ip message 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	
start configuring console proxy alert manager 

========================= cloudstack sample_2265 =========================

if (getVpcId() != null) {	throw new  InvalidParameterValueException("Unable to create firewall rule for the network id=" + networkId + " as firewall egress rule can be created only for non vpc networks.");	}	try {	FirewallRule result = _firewallService.createEgressFirewallRule(this);	if (result != null) {	setEntityId(result.getId());	setEntityUuid(result.getUuid());	}	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

if (getVpcId() != null) {	throw new  InvalidParameterValueException("Unable to create firewall rule for the network id=" + networkId + " as firewall egress rule can be created only for non vpc networks.");	}	try {	FirewallRule result = _firewallService.createEgressFirewallRule(this);	if (result != null) {	setEntityId(result.getId());	setEntityUuid(result.getUuid());	}	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

========================= cloudstack sample_3474 =========================

public void execute() {	try {	boolean result = _vpcService.deleteVpc(getId());	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to delete VPC");	}	} catch (ResourceUnavailableException ex) {	
exception 

boolean result = _vpcService.deleteVpc(getId());	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to delete VPC");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3530 =========================

if (url != null) {	keyFile = new File(url.getPath());	}	if (keyFile == null || !keyFile.exists()) {	keyFile = new File("/usr/share/cloudstack-common/scripts/vm/systemvm/id_rsa.cloud");	}	if (!keyFile.exists()) {	throw new CloudRuntimeException(String.format("cannot find id_rsa.cloud"));	}	if (!keyFile.exists()) {	
unable to locate id rsa cloud in your setup at 

String kernel = tuple.get(1);	String initrd = tuple.get(2);	PrepareKickstartPxeServerCommand cmd = new PrepareKickstartPxeServerCommand();	cmd.setKsFile(ks);	cmd.setInitrd(initrd);	cmd.setKernel(kernel);	cmd.setMac(nic.getMacAddress());	cmd.setTemplateUuid(template.getUuid());	Answer aws = _agentMgr.send(pxeVo.getHostId(), cmd);	if (!aws.getResult()) {	
unable to set host to pxe boot because 

}	if (mgmtNic == null) {	throw new CloudRuntimeException(String.format("cannot find management nic on virtual router[id:%s]", vr.getId()));	}	String internalServerIp = _configDao.getValue(Config.BaremetalInternalStorageServer.key());	if (internalServerIp == null) {	throw new CloudRuntimeException(String.format("please specify 'baremetal.internal.storage.server.ip', which is the http server/nfs server storing kickstart files and ISO files, in global setting"));	}	List<String> tuple =  parseKickstartUrl(profile);	String cmd =  String.format("/opt/cloud/bin/prepare_pxe.sh %s %s %s %s %s %s", tuple.get(1), tuple.get(2), profile.getTemplate().getUuid(), String.format("01-%s", nic.getMacAddress().replaceAll(":", "-")).toLowerCase(), tuple.get(0), nic.getMacAddress().toLowerCase());	
prepare pxe on virtual router ip s cmd s 

if (internalServerIp == null) {	throw new CloudRuntimeException(String.format("please specify 'baremetal.internal.storage.server.ip', which is the http server/nfs server storing kickstart files and ISO files, in global setting"));	}	List<String> tuple =  parseKickstartUrl(profile);	String cmd =  String.format("/opt/cloud/bin/prepare_pxe.sh %s %s %s %s %s %s", tuple.get(1), tuple.get(2), profile.getTemplate().getUuid(), String.format("01-%s", nic.getMacAddress().replaceAll(":", "-")).toLowerCase(), tuple.get(0), nic.getMacAddress().toLowerCase());	Pair<Boolean, String> ret = SshHelper.sshExecute(mgmtNic.getIPv4Address(), 3922, "root", getSystemVMKeyFile(), null, cmd);	if (!ret.first()) {	throw new CloudRuntimeException(String.format("failed preparing PXE in virtual router[id:%s], because %s", vr.getId(), ret.second()));	}	cmd = String.format("/opt/cloud/bin/baremetal_snat.sh %s %s %s", mgmtNic.getIPv4Address(), internalServerIp, mgmtNic.getIPv4Gateway());	
prepare snat on virtual router ip s cmd s 

return false;	}	} else {	if (!preparePxeInAdvancedZone(profile, nic, network, dest, context)) {	return false;	}	}	IpmISetBootDevCommand bootCmd = new IpmISetBootDevCommand(BootDev.pxe);	Answer aws = _agentMgr.send(dest.getHost().getId(), bootCmd);	if (!aws.getResult()) {	
unable to set host to pxe boot because 

if (!preparePxeInAdvancedZone(profile, nic, network, dest, context)) {	return false;	}	}	IpmISetBootDevCommand bootCmd = new IpmISetBootDevCommand(BootDev.pxe);	Answer aws = _agentMgr.send(dest.getHost().getId(), bootCmd);	if (!aws.getResult()) {	}	return aws.getResult();	} catch (Exception e) {	
cannot prepare pxe server 

========================= cloudstack sample_893 =========================

public void onClusterAlert(Object sender, EventArgs args) {	if (s_logger.isDebugEnabled()) {	
receive cluster alert eventargs 

public void onClusterAlert(Object sender, EventArgs args) {	if (s_logger.isDebugEnabled()) {	}	if (args instanceof ClusterNodeJoinEventArgs) {	onClusterNodeJoined(sender, (ClusterNodeJoinEventArgs)args);	} else if (args instanceof ClusterNodeLeftEventArgs) {	onClusterNodeLeft(sender, (ClusterNodeLeftEventArgs)args);	} else {	
unrecognized cluster alert event 

private void onClusterNodeJoined(Object sender, ClusterNodeJoinEventArgs args) {	if (s_logger.isDebugEnabled()) {	for (ManagementServerHostVO mshost : args.getJoinedNodes()) {	
handle cluster node join alert joined node msidl 

private void onClusterNodeJoined(Object sender, ClusterNodeJoinEventArgs args) {	if (s_logger.isDebugEnabled()) {	for (ManagementServerHostVO mshost : args.getJoinedNodes()) {	}	}	for (ManagementServerHostVO mshost : args.getJoinedNodes()) {	if (mshost.getId() == args.getSelf().longValue()) {	if (s_logger.isDebugEnabled()) {	
management server node is up send alert 

private void onClusterNodeLeft(Object sender, ClusterNodeLeftEventArgs args) {	if (s_logger.isDebugEnabled()) {	for (ManagementServerHostVO mshost : args.getLeftNodes()) {	
handle cluster node left alert leaving node msid 

private void onClusterNodeLeft(Object sender, ClusterNodeLeftEventArgs args) {	if (s_logger.isDebugEnabled()) {	for (ManagementServerHostVO mshost : args.getLeftNodes()) {	}	}	for (ManagementServerHostVO mshost : args.getLeftNodes()) {	if (mshost.getId() != args.getSelf().longValue()) {	if (_mshostDao.increaseAlertCount(mshost.getId()) > 0) {	if (s_logger.isDebugEnabled()) {	
detected management server node is down send alert 

}	}	for (ManagementServerHostVO mshost : args.getLeftNodes()) {	if (mshost.getId() != args.getSelf().longValue()) {	if (_mshostDao.increaseAlertCount(mshost.getId()) > 0) {	if (s_logger.isDebugEnabled()) {	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_MANAGMENT_NODE, 0, new Long(0), "Management server node " + mshost.getServiceIP() + " is down", "");	} else {	if (s_logger.isDebugEnabled()) {	
detected management server node is down but alert has already been set 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (s_logger.isInfoEnabled()) {	
start configuring cluster alert manager 

========================= cloudstack sample_2264 =========================

String error = e.toString();	if (error.contains("Storage source conflict")) {	throw new CloudRuntimeException("A pool matching this location already exists in libvirt, " + " but has a different UUID/Name. Cannot create new pool without first " + " removing it. Check for inactive pools via 'virsh pool-list --all'. " + error);	} else {	throw new CloudRuntimeException(error);	}	}	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	
attempting to unmount old mount libvirt is unaware of at 

throw new CloudRuntimeException("A pool matching this location already exists in libvirt, " + " but has a different UUID/Name. Cannot create new pool without first " + " removing it. Check for inactive pools via 'virsh pool-list --all'. " + error);	} else {	throw new CloudRuntimeException(error);	}	}	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	
succeeded in unmounting 

throw new CloudRuntimeException(error);	}	}	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	conn.storagePoolCreateXML(spd.toString(), 0);	
succeeded in redefining storage 

}	} catch (LibvirtException e) {	s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	conn.storagePoolCreateXML(spd.toString(), 0);	return true;	} catch (LibvirtException l) {	
target was already mounted unmounted it but failed to redefine storage 

s_logger.error(e.toString());	if (e.toString().contains("already mounted")) {	String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	conn.storagePoolCreateXML(spd.toString(), 0);	return true;	} catch (LibvirtException l) {	}	} else {	
failed in unmounting and redefining storage 

String result = Script.runSimpleBashScript("umount -l " + targetPath);	if (result == null) {	try {	conn.storagePoolCreateXML(spd.toString(), 0);	return true;	} catch (LibvirtException l) {	}	} else {	}	} else {	
internal error occurred when attempting to mount 

public StorageVol getVolume(StoragePool pool, String volName) {	StorageVol vol = null;	try {	vol = pool.storageVolLookupByName(volName);	} catch (LibvirtException e) {	
can t find volume 

public StorageVol getVolume(StoragePool pool, String volName) {	StorageVol vol = null;	try {	vol = pool.storageVolLookupByName(volName);	} catch (LibvirtException e) {	}	if (vol == null) {	try {	refreshPool(pool);	} catch (LibvirtException e) {	
failed to refresh pool 

StorageVol vol = null;	try {	vol = pool.storageVolLookupByName(volName);	} catch (LibvirtException e) {	}	if (vol == null) {	try {	refreshPool(pool);	} catch (LibvirtException e) {	}	
no volume is present on the pool creating a new one 

========================= cloudstack sample_1018 =========================

protected boolean canHandle(final Network network, final Service service) {	
checking if ovselement can handle service on network 

protected boolean canHandle(final Network network, final Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Vswitch) {	return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	
ovselement is not a provider for network 

protected boolean canHandle(final Network network, final Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Vswitch) {	return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	if (!_ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), service, Network.Provider.Ovs)) {	
ovselement can t provide the service on network 

public boolean implement(final Network network, final NetworkOffering offering, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
entering ovselement implement function for network state 

public boolean verifyServicesCombination(final Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	
unable to provide services without connectivity service enabled for this element 

for (final Service service : services) {	if (!canHandle(network, service) && service != Service.SourceNat && service != Service.Firewall) {	canHandle = false;	break;	}	}	boolean result = true;	if (canHandle) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole( network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router element doesn t need to associate ip addresses on the backend virtual router doesn t exist in the network 

public boolean applyStaticNats(final Network network, final List<? extends StaticNat> rules) throws ResourceUnavailableException {	if (!canHandle(network, Service.StaticNat)) {	return false;	}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole( network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
ovs element doesn t need to apply static nat on the backend virtual router doesn t exist in the network 

public boolean applyPFRules(final Network network, final List<PortForwardingRule> rules) throws ResourceUnavailableException {	if (!canHandle(network, Service.PortForwarding)) {	return false;	}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole( network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
ovs element doesn t need to apply firewall rules on the backend virtual router doesn t exist in the network 

public boolean applyLBRules(final Network network, final List<LoadBalancingRule> rules) throws ResourceUnavailableException {	boolean result = true;	if (canHandle(network, Service.Lb)) {	if (!canHandleLbRules(rules)) {	return false;	}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole( network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to apply firewall rules on the backend virtual router doesn t exist in the network 

}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole( network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	return true;	}	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	final NetworkTopology networkTopology = _networkTopologyContext.retrieveNetworkTopology(dcVO);	for (final DomainRouterVO domainRouterVO : routers) {	result = result && networkTopology.applyLoadBalancingRules(network, rules, domainRouterVO);	if (!result) {	
failed to apply load balancing rules in network 

private boolean canHandleLbRules(final List<LoadBalancingRule> rules) {	final Map<Capability, String> lbCaps = getCapabilities().get(Service.Lb);	if (!lbCaps.isEmpty()) {	final String schemeCaps = lbCaps.get(Capability.LbSchemes);	if (schemeCaps != null) {	for (final LoadBalancingRule rule : rules) {	if (!schemeCaps.contains(rule.getScheme().toString())) {	
scheme is not supported by the provider 

========================= cloudstack sample_1448 =========================

autoScaleStatsInterval = NumbersUtil.parseLong(configs.get("autoscale.stats.interval"), 60000L);	vmDiskStatsInterval = NumbersUtil.parseInt(configs.get("vm.disk.stats.interval"), 0);	String externalStatsUri = configs.get("stats.output.uri");	if (externalStatsUri != null && !externalStatsUri.equals("")) {	try {	URI uri = new URI(externalStatsUri);	String scheme = uri.getScheme();	try {	externalStatsType = ExternalStatsProtocol.valueOf(scheme.toUpperCase());	} catch (IllegalArgumentException e) {	
is not a valid protocol for external statistics no statistics will be send 

if (!StringUtils.isEmpty(uri.getPath())) {	externalStatsPrefix = uri.getPath().substring(1);	}	if (!StringUtils.isEmpty(externalStatsPrefix)) {	externalStatsPrefix += ".";	} else {	externalStatsPrefix = "";	}	externalStatsEnabled = true;	} catch (URISyntaxException e) {	
failed to parse external statistics uri 

cal.set(Calendar.MILLISECOND, 0);	cal.roll(Calendar.HOUR_OF_DAY, true);	cal.add(Calendar.MILLISECOND, -1);	endDate = cal.getTime().getTime();	_dailyOrHourly = true;	} else {	endDate = cal.getTime().getTime();	_dailyOrHourly = false;	}	if (_usageAggregationRange < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) {	
usage stats job aggregation range is to small using the minimum value of 

protected void runInContext() {	try {	
hoststatscollector is running 

sc.addAnd("type", SearchCriteria.Op.NEQ, Host.Type.L2Networking.toString());	sc.addAnd("type", SearchCriteria.Op.NEQ, Host.Type.BaremetalDhcp.toString());	sc.addAnd("type", SearchCriteria.Op.NEQ, Host.Type.BaremetalPxe.toString());	ConcurrentHashMap<Long, HostStats> hostStats = new ConcurrentHashMap<Long, HostStats>();	List<HostVO> hosts = _hostDao.search(sc, null);	for (HostVO host : hosts) {	HostStatsEntry stats = (HostStatsEntry)_resourceMgr.getHostStatistics(host.getId());	if (stats != null) {	hostStats.put(host.getId(), stats);	} else {	
received invalid host stats for host 

gpuEnabledHosts = hosts;	}	for (HostVO host : gpuEnabledHosts) {	HashMap<String, HashMap<String, VgpuTypesInfo>> groupDetails = _resourceMgr.getGPUStatistics(host);	if (groupDetails != null) {	_resourceMgr.updateGPUDetails(host.getId(), groupDetails);	}	}	hostIds = _hostGpuGroupsDao.listHostIds();	} catch (Throwable t) {	
error trying to retrieve host stats 

protected void runInContext() {	try {	
hostoutofbandmanagementstatscollector is running 

for (OutOfBandManagement outOfBandManagementHost : outOfBandManagementHosts) {	Host host = _hostDao.findById(outOfBandManagementHost.getHostId());	if (host == null) {	continue;	}	if (outOfBandManagementService.isOutOfBandManagementEnabled(host)) {	outOfBandManagementService.submitBackgroundPowerSyncTask(host);	} else if (outOfBandManagementHost.getPowerState() != OutOfBandManagement.PowerState.Disabled) {	if (outOfBandManagementService.transitionPowerStateToDisabled(Collections.singletonList(host))) {	if (s_logger.isDebugEnabled()) {	
out of band management was disabled in zone cluster host disabled power state for host id 

if (outOfBandManagementService.isOutOfBandManagementEnabled(host)) {	outOfBandManagementService.submitBackgroundPowerSyncTask(host);	} else if (outOfBandManagementHost.getPowerState() != OutOfBandManagement.PowerState.Disabled) {	if (outOfBandManagementService.transitionPowerStateToDisabled(Collections.singletonList(host))) {	if (s_logger.isDebugEnabled()) {	}	}	}	}	} catch (Throwable t) {	
error trying to retrieve host out of band management stats 

protected void runInContext() {	try {	
vmstatscollector is running 

metrics.put(externalStatsPrefix + "cloudstack.stats.instances." + vmName + ".memory.total_kbs", statsForCurrentIteration.getMemoryKBs());	metrics.put(externalStatsPrefix + "cloudstack.stats.instances." + vmName + ".memory.internalfree_kbs", statsForCurrentIteration.getIntFreeMemoryKBs());	metrics.put(externalStatsPrefix + "cloudstack.stats.instances." + vmName + ".memory.target_kbs", statsForCurrentIteration.getTargetMemoryKBs());	}	}	if (!metrics.isEmpty()) {	if (externalStatsType != null && externalStatsType == ExternalStatsProtocol.GRAPHITE) {	if (externalStatsPort == -1) {	externalStatsPort = 2003;	}	
sending vmstats of host to graphite host 

}	if (!metrics.isEmpty()) {	if (externalStatsType != null && externalStatsType == ExternalStatsProtocol.GRAPHITE) {	if (externalStatsPort == -1) {	externalStatsPort = 2003;	}	try {	GraphiteClient g = new GraphiteClient(externalStatsHost, externalStatsPort);	g.sendMetrics(metrics);	} catch (GraphiteException e) {	
failed sending vmstats to graphite host 

try {	GraphiteClient g = new GraphiteClient(externalStatsHost, externalStatsPort);	g.sendMetrics(metrics);	} catch (GraphiteException e) {	}	metrics.clear();	}	}	}	} catch (Exception e) {	
failed to get vm stats for host with id 

}	metrics.clear();	}	}	}	} catch (Exception e) {	continue;	}	}	} catch (Throwable t) {	
error trying to retrieve vm stats 

protected void runInContext() {	GlobalLock scanLock = GlobalLock.getInternLock("vm.disk.stats");	try {	if (scanLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_COOPERATION)) {	ManagementServerHostVO msHost = _msHostDao.findOneInUpState(new Filter(ManagementServerHostVO.class, "id", true, 0L, 1L));	if (msHost == null || (msHost.getMsid() != mgmtSrvrId)) {	
skipping aggregate disk stats update 

List<VmDiskStatisticsVO> updatedVmNetStats = _vmDiskStatsDao.listUpdatedStats();	for (VmDiskStatisticsVO stat : updatedVmNetStats) {	if (_dailyOrHourly) {	stat.setAggBytesRead(stat.getCurrentBytesRead() + stat.getNetBytesRead());	stat.setAggBytesWrite(stat.getCurrentBytesWrite() + stat.getNetBytesWrite());	stat.setAggIORead(stat.getCurrentIORead() + stat.getNetIORead());	stat.setAggIOWrite(stat.getCurrentIOWrite() + stat.getNetIOWrite());	_vmDiskStatsDao.update(stat.getId(), stat);	}	}	
successfully updated aggregate vm disk stats 

stat.setAggBytesRead(stat.getCurrentBytesRead() + stat.getNetBytesRead());	stat.setAggBytesWrite(stat.getCurrentBytesWrite() + stat.getNetBytesWrite());	stat.setAggIORead(stat.getCurrentIORead() + stat.getNetIORead());	stat.setAggIOWrite(stat.getCurrentIOWrite() + stat.getNetIOWrite());	_vmDiskStatsDao.update(stat.getId(), stat);	}	}	}	});	} catch (Exception e) {	
failed to update aggregate disk stats 

}	}	}	});	} catch (Exception e) {	} finally {	scanLock.unlock();	}	}	} catch (Exception e) {	
exception while trying to acquire disk stats lock 

UserVmVO userVm = _userVmDao.findById(vmId);	for (VmDiskStatsEntry vmDiskStat : vmDiskStats) {	SearchCriteria<VolumeVO> sc_volume = _volsDao.createSearchCriteria();	sc_volume.addAnd("path", SearchCriteria.Op.EQ, vmDiskStat.getPath());	List<VolumeVO> volumes = _volsDao.search(sc_volume, null);	if ((volumes == null) || (volumes.size() == 0)) break;	VolumeVO volume = volumes.get(0);	VmDiskStatisticsVO previousVmDiskStats = _vmDiskStatsDao.findBy(userVm.getAccountId(), userVm.getDataCenterId(), vmId, volume.getId());	VmDiskStatisticsVO vmDiskStat_lock = _vmDiskStatsDao.lock(userVm.getAccountId(), userVm.getDataCenterId(), vmId, volume.getId());	if ((vmDiskStat.getBytesRead() == 0) && (vmDiskStat.getBytesWrite() == 0) && (vmDiskStat.getIORead() == 0) && (vmDiskStat.getIOWrite() == 0)) {	
io bytes read and write are all not updating vm disk statistics 

sc_volume.addAnd("path", SearchCriteria.Op.EQ, vmDiskStat.getPath());	List<VolumeVO> volumes = _volsDao.search(sc_volume, null);	if ((volumes == null) || (volumes.size() == 0)) break;	VolumeVO volume = volumes.get(0);	VmDiskStatisticsVO previousVmDiskStats = _vmDiskStatsDao.findBy(userVm.getAccountId(), userVm.getDataCenterId(), vmId, volume.getId());	VmDiskStatisticsVO vmDiskStat_lock = _vmDiskStatsDao.lock(userVm.getAccountId(), userVm.getDataCenterId(), vmId, volume.getId());	if ((vmDiskStat.getBytesRead() == 0) && (vmDiskStat.getBytesWrite() == 0) && (vmDiskStat.getIORead() == 0) && (vmDiskStat.getIOWrite() == 0)) {	continue;	}	if (vmDiskStat_lock == null) {	
unable to find vm disk stats from host for account with vmid and volumeid 

VolumeVO volume = volumes.get(0);	VmDiskStatisticsVO previousVmDiskStats = _vmDiskStatsDao.findBy(userVm.getAccountId(), userVm.getDataCenterId(), vmId, volume.getId());	VmDiskStatisticsVO vmDiskStat_lock = _vmDiskStatsDao.lock(userVm.getAccountId(), userVm.getDataCenterId(), vmId, volume.getId());	if ((vmDiskStat.getBytesRead() == 0) && (vmDiskStat.getBytesWrite() == 0) && (vmDiskStat.getIORead() == 0) && (vmDiskStat.getIOWrite() == 0)) {	continue;	}	if (vmDiskStat_lock == null) {	continue;	}	if (previousVmDiskStats != null && ((previousVmDiskStats.getCurrentBytesRead() != vmDiskStat_lock.getCurrentBytesRead()) || (previousVmDiskStats.getCurrentBytesWrite() != vmDiskStat_lock.getCurrentBytesWrite()) || (previousVmDiskStats.getCurrentIORead() != vmDiskStat_lock.getCurrentIORead()) || (previousVmDiskStats.getCurrentIOWrite() != vmDiskStat_lock.getCurrentIOWrite()))) {	
vm disk stats changed from the time getvmdiskstatscommand was sent ignoring current answer host vm read bytes write bytes read io write io 

continue;	}	if (vmDiskStat_lock == null) {	continue;	}	if (previousVmDiskStats != null && ((previousVmDiskStats.getCurrentBytesRead() != vmDiskStat_lock.getCurrentBytesRead()) || (previousVmDiskStats.getCurrentBytesWrite() != vmDiskStat_lock.getCurrentBytesWrite()) || (previousVmDiskStats.getCurrentIORead() != vmDiskStat_lock.getCurrentIORead()) || (previousVmDiskStats.getCurrentIOWrite() != vmDiskStat_lock.getCurrentIOWrite()))) {	continue;	}	if (vmDiskStat_lock.getCurrentBytesRead() > vmDiskStat.getBytesRead()) {	if (s_logger.isDebugEnabled()) {	
read of bytes that s less than the last one assuming something went wrong and persisting it host vm reported stored 

continue;	}	if (vmDiskStat_lock.getCurrentBytesRead() > vmDiskStat.getBytesRead()) {	if (s_logger.isDebugEnabled()) {	}	vmDiskStat_lock.setNetBytesRead(vmDiskStat_lock.getNetBytesRead() + vmDiskStat_lock.getCurrentBytesRead());	}	vmDiskStat_lock.setCurrentBytesRead(vmDiskStat.getBytesRead());	if (vmDiskStat_lock.getCurrentBytesWrite() > vmDiskStat.getBytesWrite()) {	if (s_logger.isDebugEnabled()) {	
write of bytes that s less than the last one assuming something went wrong and persisting it host vm reported stored 

}	vmDiskStat_lock.setCurrentBytesRead(vmDiskStat.getBytesRead());	if (vmDiskStat_lock.getCurrentBytesWrite() > vmDiskStat.getBytesWrite()) {	if (s_logger.isDebugEnabled()) {	}	vmDiskStat_lock.setNetBytesWrite(vmDiskStat_lock.getNetBytesWrite() + vmDiskStat_lock.getCurrentBytesWrite());	}	vmDiskStat_lock.setCurrentBytesWrite(vmDiskStat.getBytesWrite());	if (vmDiskStat_lock.getCurrentIORead() > vmDiskStat.getIORead()) {	if (s_logger.isDebugEnabled()) {	
read of io that s less than the last one assuming something went wrong and persisting it host vm reported stored 

}	vmDiskStat_lock.setCurrentBytesWrite(vmDiskStat.getBytesWrite());	if (vmDiskStat_lock.getCurrentIORead() > vmDiskStat.getIORead()) {	if (s_logger.isDebugEnabled()) {	}	vmDiskStat_lock.setNetIORead(vmDiskStat_lock.getNetIORead() + vmDiskStat_lock.getCurrentIORead());	}	vmDiskStat_lock.setCurrentIORead(vmDiskStat.getIORead());	if (vmDiskStat_lock.getCurrentIOWrite() > vmDiskStat.getIOWrite()) {	if (s_logger.isDebugEnabled()) {	
write of io that s less than the last one assuming something went wrong and persisting it host vm reported stored 

vmDiskStat_lock.setAggIOWrite(vmDiskStat_lock.getNetIOWrite() + vmDiskStat_lock.getCurrentIOWrite());	vmDiskStat_lock.setAggIORead(vmDiskStat_lock.getNetIORead() + vmDiskStat_lock.getCurrentIORead());	}	_vmDiskStatsDao.update(vmDiskStat_lock.getId(), vmDiskStat_lock);	}	}	}	}	});	} catch (Exception e) {	
error while collecting vm disk stats from hosts 

protected void runInContext() {	try {	if (s_logger.isDebugEnabled()) {	
storagecollector is running 

List<DataStore> stores = _dataStoreMgr.listImageStores();	ConcurrentHashMap<Long, StorageStats> storageStats = new ConcurrentHashMap<Long, StorageStats>();	for (DataStore store : stores) {	if (store.getUri() == null) {	continue;	}	Integer nfsVersion = imageStoreDetailsUtil.getNfsVersion(store.getId());	GetStorageStatsCommand command = new GetStorageStatsCommand(store.getTO(), nfsVersion);	EndPoint ssAhost = _epSelector.select(store);	if (ssAhost == null) {	
there is no secondary storage vm for secondary storage host 

Integer nfsVersion = imageStoreDetailsUtil.getNfsVersion(store.getId());	GetStorageStatsCommand command = new GetStorageStatsCommand(store.getTO(), nfsVersion);	EndPoint ssAhost = _epSelector.select(store);	if (ssAhost == null) {	continue;	}	long storeId = store.getId();	Answer answer = ssAhost.sendMessage(command);	if (answer != null && answer.getResult()) {	storageStats.put(storeId, (StorageStats)answer);	
hostid used total available 

try {	Answer answer = _storageManager.sendToPool(pool, command);	if (answer != null && answer.getResult()) {	storagePoolStats.put(pool.getId(), (StorageStats)answer);	if (_storagePoolStats.get(poolId) != null && _storagePoolStats.get(poolId).getCapacityBytes() != ((StorageStats)answer).getCapacityBytes()) {	pool.setCapacityBytes(((StorageStats)answer).getCapacityBytes());	_storagePoolDao.update(pool.getId(), pool);	}	}	} catch (StorageUnavailableException e) {	
unable to reach 

Answer answer = _storageManager.sendToPool(pool, command);	if (answer != null && answer.getResult()) {	storagePoolStats.put(pool.getId(), (StorageStats)answer);	if (_storagePoolStats.get(poolId) != null && _storagePoolStats.get(poolId).getCapacityBytes() != ((StorageStats)answer).getCapacityBytes()) {	pool.setCapacityBytes(((StorageStats)answer).getCapacityBytes());	_storagePoolDao.update(pool.getId(), pool);	}	}	} catch (StorageUnavailableException e) {	} catch (Exception e) {	
unable to get stats for 

pool.setCapacityBytes(((StorageStats)answer).getCapacityBytes());	_storagePoolDao.update(pool.getId(), pool);	}	}	} catch (StorageUnavailableException e) {	} catch (Exception e) {	}	}	_storagePoolStats = storagePoolStats;	} catch (Throwable t) {	
error trying to retrieve storage stats 

protected void runInContext() {	try {	if (s_logger.isDebugEnabled()) {	
autoscaling monitor is running 

_asManager.doScaleUp(asGroup.getId(), asGroup.getMinMembers() - currentVM);	continue;	}	long now = (new Date()).getTime();	if (asGroup.getLastInterval() != null) if ((now - asGroup.getLastInterval().getTime()) < asGroup .getInterval()) {	continue;	}	asGroup.setLastInterval(new Date());	_asGroupDao.persist(asGroup);	if (s_logger.isDebugEnabled()) {	
autoscale collecting rrds data 

total_counter++;	params.put("duration" + String.valueOf(total_counter), duration.toString());	params.put("counter" + String.valueOf(total_counter), lstCounter[i]);	params.put("con" + String.valueOf(total_counter), strCounterNames.split(",")[1]);	}	params.put("total_counter", String.valueOf(total_counter));	PerformanceMonitorCommand perfMon = new PerformanceMonitorCommand(params, 20);	try {	Answer answer = _agentMgr.send(receiveHost, perfMon);	if (answer == null || !answer.getResult()) {	
failed to send data to node 

params.put("counter" + String.valueOf(total_counter), lstCounter[i]);	params.put("con" + String.valueOf(total_counter), strCounterNames.split(",")[1]);	}	params.put("total_counter", String.valueOf(total_counter));	PerformanceMonitorCommand perfMon = new PerformanceMonitorCommand(params, 20);	try {	Answer answer = _agentMgr.send(receiveHost, perfMon);	if (answer == null || !answer.getResult()) {	} else {	String result = answer.getDetails();	
autoscale rrds collection answer 

} else {	coVal = coVal * 100;	}	avgCounter.put(counterId, avgCounter.get(counterId) + coVal);	} catch (Exception e) {	e.printStackTrace();	}	}	String scaleAction = getAutoscaleAction(avgCounter, asGroup.getId(), currentVM, params);	if (scaleAction != null) {	
autoscale doing scale action for group 

}	}	}	}	} catch (Exception e) {	e.printStackTrace();	}	}	}	} catch (Throwable t) {	
error trying to monitor autoscaling 

========================= cloudstack sample_2376 =========================

public void create() {	try {	HealthCheckPolicy result = _lbService.createLBHealthCheckPolicy(this);	this.setEntityId(result.getId());	this.setEntityUuid(result.getUuid());	} catch (InvalidParameterValueException e) {	
exception 

========================= cloudstack sample_3422 =========================

public String[] applyVpnUsers(final RemoteAccessVpn remoteAccessVpn, final List<? extends VpnUser> users, final VirtualRouter router) throws ResourceUnavailableException {	
applying advanced vpn users rules 

public boolean applyStaticRoutes(final List<StaticRouteProfile> staticRoutes, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	
applying static routes rules 

public boolean applyStaticRoutes(final List<StaticRouteProfile> staticRoutes, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (staticRoutes == null || staticRoutes.isEmpty()) {	
no static routes to apply 

public boolean applyStaticRoutes(final List<StaticRouteProfile> staticRoutes, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (staticRoutes == null || staticRoutes.isEmpty()) {	return true;	}	final StaticRoutesRules routesRules = new StaticRoutesRules(staticRoutes);	boolean result = true;	for (final VirtualRouter router : routers) {	if (router.getState() == State.Running) {	result = result && routesRules.accept(_advancedVisitor, router);	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	
router is in so not sending staticroute command to the backend 

if (staticRoutes == null || staticRoutes.isEmpty()) {	return true;	}	final StaticRoutesRules routesRules = new StaticRoutesRules(staticRoutes);	boolean result = true;	for (final VirtualRouter router : routers) {	if (router.getState() == State.Running) {	result = result && routesRules.accept(_advancedVisitor, router);	} else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {	} else {	
unable to apply staticroute virtual router is not in the right state 

public boolean setupDhcpForPvlan(final boolean isAddPvlan, final DomainRouterVO router, final Long hostId, final NicProfile nic) throws ResourceUnavailableException {	
setup dhcp pvlan rules 

public boolean setupPrivateGateway(final PrivateGateway gateway, final VirtualRouter router) throws ConcurrentOperationException, ResourceUnavailableException {	
setup private gateway rules 

public boolean applyUserData(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final DeployDestination dest, final DomainRouterVO router) throws ResourceUnavailableException {	
applying vpc userdata rules 

public boolean applyDhcpEntry(final Network network, final NicProfile nic, final VirtualMachineProfile profile, final DeployDestination dest, final DomainRouterVO router) throws ResourceUnavailableException {	
applying vpc dhcp entry rules 

public boolean associatePublicIP(final Network network, final List<? extends PublicIpAddress> ipAddresses, final VirtualRouter router) throws ResourceUnavailableException {	if (ipAddresses == null || ipAddresses.isEmpty()) {	
no ip association rules to be applied for network 

public boolean associatePublicIP(final Network network, final List<? extends PublicIpAddress> ipAddresses, final VirtualRouter router) throws ResourceUnavailableException {	if (ipAddresses == null || ipAddresses.isEmpty()) {	return true;	}	if (network.getVpcId() == null) {	return super.associatePublicIP(network, ipAddresses, router);	}	
applying vpc ip rules 

public boolean applyNetworkACLs(final Network network, final List<? extends NetworkACLItem> rules, final VirtualRouter router, final boolean isPrivateGateway) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	
no network acls to be applied for network 

public boolean applyNetworkACLs(final Network network, final List<? extends NetworkACLItem> rules, final VirtualRouter router, final boolean isPrivateGateway) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	
applying network acls rules 

========================= cloudstack sample_2233 =========================

public void testSerDeser() {	
testing serializing and deserializing works as expected 

public void testSerDeser() {	
updatehostpasswordcommand should have two parameters that doesn t show in logging 

public void testSerDeser() {	UpdateHostPasswordCommand cmd1 = new UpdateHostPasswordCommand("abc", "def");	
secstoragefirewallcfgcommand has a context map that shouldn t show up in debug level 

public void testSerDeser() {	UpdateHostPasswordCommand cmd1 = new UpdateHostPasswordCommand("abc", "def");	SecStorageFirewallCfgCommand cmd2 = new SecStorageFirewallCfgCommand();	
gethoststatscommand should not show up at all in debug level 

logger.setLevel(level);	byte[] bytes = sreq.getBytes();	assert Request.getSequence(bytes) == 892403717;	assert Request.getManagementServerId(bytes) == 3;	assert Request.getAgentId(bytes) == 2;	assert Request.getViaAgentId(bytes) == 2;	Request creq = null;	try {	creq = Request.parse(bytes);	} catch (ClassNotFoundException e) {	
unable to parse bytes 

byte[] bytes = sreq.getBytes();	assert Request.getSequence(bytes) == 892403717;	assert Request.getManagementServerId(bytes) == 3;	assert Request.getAgentId(bytes) == 2;	assert Request.getViaAgentId(bytes) == 2;	Request creq = null;	try {	creq = Request.parse(bytes);	} catch (ClassNotFoundException e) {	} catch (UnsupportedVersionException e) {	
unable to parse bytes 

}	assert creq != null : "Couldn't get the request back";	compareRequest(creq, sreq);	Answer ans = new Answer(cmd1, true, "No Problem");	Response cresp = new Response(creq, ans);	bytes = cresp.getBytes();	Response sresp = null;	try {	sresp = Response.parse(bytes);	} catch (ClassNotFoundException e) {	
unable to parse bytes 

assert creq != null : "Couldn't get the request back";	compareRequest(creq, sreq);	Answer ans = new Answer(cmd1, true, "No Problem");	Response cresp = new Response(creq, ans);	bytes = cresp.getBytes();	Response sresp = null;	try {	sresp = Response.parse(bytes);	} catch (ClassNotFoundException e) {	} catch (UnsupportedVersionException e) {	
unable to parse bytes 

public void testSerDeserTO() {	
testing serializing and deserializing interface to works as expected 

sreq.setSequence(892403718);	byte[] bytes = sreq.getBytes();	assert Request.getSequence(bytes) == 892403718;	assert Request.getManagementServerId(bytes) == 3;	assert Request.getAgentId(bytes) == 2;	assert Request.getViaAgentId(bytes) == 2;	Request creq = null;	try {	creq = Request.parse(bytes);	} catch (ClassNotFoundException e) {	
unable to parse bytes 

byte[] bytes = sreq.getBytes();	assert Request.getSequence(bytes) == 892403718;	assert Request.getManagementServerId(bytes) == 3;	assert Request.getAgentId(bytes) == 2;	assert Request.getViaAgentId(bytes) == 2;	Request creq = null;	try {	creq = Request.parse(bytes);	} catch (ClassNotFoundException e) {	} catch (UnsupportedVersionException e) {	
unable to parse bytes 

public void testDownload() {	
testing download answer 

public void testCompress() {	
testCompress 

public void testCompress() {	int len = 800000;	ByteBuffer inputBuffer = ByteBuffer.allocate(len);	for (int i = 0; i < len; i++) {	inputBuffer.array()[i] = 1;	}	inputBuffer.limit(len);	ByteBuffer compressedBuffer = ByteBuffer.allocate(len);	compressedBuffer = Request.doCompress(inputBuffer, len);	
compressed length 

========================= cloudstack sample_21 =========================

public Answer execute(final FenceCommand command, final XenServer56Resource xenServer56) {	final Connection conn = xenServer56.getConnection();	try {	final Boolean alive = xenServer56.checkHeartbeat(command.getHostGuid());	if (alive == null) {	
failed to check heartbeat so unable to fence 

public Answer execute(final FenceCommand command, final XenServer56Resource xenServer56) {	final Connection conn = xenServer56.getConnection();	try {	final Boolean alive = xenServer56.checkHeartbeat(command.getHostGuid());	if (alive == null) {	return new FenceAnswer(command, false, "Failed to check heartbeat, so unable to fence");	}	if (alive) {	
heart beat is still going so unable to fence 

try {	final Boolean alive = xenServer56.checkHeartbeat(command.getHostGuid());	if (alive == null) {	return new FenceAnswer(command, false, "Failed to check heartbeat, so unable to fence");	}	if (alive) {	return new FenceAnswer(command, false, "Heartbeat is still going on unable to fence");	}	final Set<VM> vms = VM.getByNameLabel(conn, command.getVmName());	for (final VM vm : vms) {	
fence command for vm 

if (alive) {	return new FenceAnswer(command, false, "Heartbeat is still going on unable to fence");	}	final Set<VM> vms = VM.getByNameLabel(conn, command.getVmName());	for (final VM vm : vms) {	vm.powerStateReset(conn);	vm.destroy(conn);	}	return new FenceAnswer(command);	} catch (final XmlRpcException e) {	
unable to fence 

}	final Set<VM> vms = VM.getByNameLabel(conn, command.getVmName());	for (final VM vm : vms) {	vm.powerStateReset(conn);	vm.destroy(conn);	}	return new FenceAnswer(command);	} catch (final XmlRpcException e) {	return new FenceAnswer(command, false, e.getMessage());	} catch (final XenAPIException e) {	
unable to fence 

for (final VM vm : vms) {	vm.powerStateReset(conn);	vm.destroy(conn);	}	return new FenceAnswer(command);	} catch (final XmlRpcException e) {	return new FenceAnswer(command, false, e.getMessage());	} catch (final XenAPIException e) {	return new FenceAnswer(command, false, e.getMessage());	} catch (final Exception e) {	
unable to fence 

========================= cloudstack sample_1223 =========================

public boolean implement(final Network network, final NetworkOffering offering, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	
not handling network implement in zone of type 

public boolean implement(final Network network, final NetworkOffering offering, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	return false;	}	if (!canHandle(network)) {	return false;	}	final List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no cisco vnmc device on network 

}	if (!canHandle(network)) {	return false;	}	final List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	List<CiscoAsa1000vDeviceVO> asaList = _ciscoAsa1000vDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (asaList.isEmpty()) {	
no cisco asa device on network 

final List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	List<CiscoAsa1000vDeviceVO> asaList = _ciscoAsa1000vDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (asaList.isEmpty()) {	return false;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork != null) {	
cisco asa device already associated with network 

}	List<CiscoAsa1000vDeviceVO> asaList = _ciscoAsa1000vDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (asaList.isEmpty()) {	return false;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork != null) {	return true;	}	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.SourceNat, Provider.CiscoVnmc)) {	
sourcenat service is not provided by cisco vnmc device on network 

NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork != null) {	return true;	}	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.SourceNat, Provider.CiscoVnmc)) {	return false;	}	try {	CiscoAsa1000vDevice assignedAsa = assignAsa1000vToNetwork(network);	if (assignedAsa == null) {	
unable to assign asa device to network 

return false;	}	try {	CiscoAsa1000vDevice assignedAsa = assignAsa1000vToNetwork(network);	if (assignedAsa == null) {	throw new CloudRuntimeException("Unable to assign ASA 1000v device to network " + network.getName());	}	ClusterVO asaCluster = _clusterDao.findById(assignedAsa.getClusterId());	ClusterVSMMapVO clusterVsmMap = _clusterVsmMapDao.findByClusterId(assignedAsa.getClusterId());	if (clusterVsmMap == null) {	
vmware cluster has no cisco nexus vsm device associated with it 

if (assignedAsa == null) {	throw new CloudRuntimeException("Unable to assign ASA 1000v device to network " + network.getName());	}	ClusterVO asaCluster = _clusterDao.findById(assignedAsa.getClusterId());	ClusterVSMMapVO clusterVsmMap = _clusterVsmMapDao.findByClusterId(assignedAsa.getClusterId());	if (clusterVsmMap == null) {	throw new CloudRuntimeException("Vmware cluster " + asaCluster.getName() + " has no Cisco Nexus VSM device associated with it");	}	CiscoNexusVSMDeviceVO vsmDevice = _vsmDeviceDao.findById(clusterVsmMap.getVsmId());	if (vsmDevice == null) {	
unable to load details of cisco nexus vsm device associated with cluster 

outsideIp = ip;	break;	}	}	if (outsideIp == null) {	try {	Account caller = CallContext.current().getCallingAccount();	long callerUserId = CallContext.current().getCallingUserId();	outsideIp = _ipAddrMgr.allocateIp(owner, false, caller, callerUserId, zone, true);	} catch (ResourceAllocationException e) {	
unable to allocate additional public ip address exception details 

try {	Account caller = CallContext.current().getCallingAccount();	long callerUserId = CallContext.current().getCallingUserId();	outsideIp = _ipAddrMgr.allocateIp(owner, false, caller, callerUserId, zone, true);	} catch (ResourceAllocationException e) {	throw new CloudRuntimeException("Unable to allocate additional public Ip address. Exception details " + e);	}	try {	outsideIp = _ipAddrMgr.associateIPToGuestNetwork(outsideIp.getId(), network.getId(), true);	} catch (ResourceAllocationException e) {	
unable to assign allocated additional public ip to network with vlan exception details 

throw new CloudRuntimeException("Unable to allocate additional public Ip address. Exception details " + e);	}	try {	outsideIp = _ipAddrMgr.associateIPToGuestNetwork(outsideIp.getId(), network.getId(), true);	} catch (ResourceAllocationException e) {	throw new CloudRuntimeException("Unable to assign allocated additional public Ip " + outsideIp.getAddress().addr() + " to network with vlan " + vlanId + ". Exception details " + e);	}	}	String gatewayNetmask = NetUtils.getCidrNetmask(network.getCidr());	if (!createLogicalEdgeFirewall(vlanId, network.getGateway(), gatewayNetmask, outsideIp.getAddress().addr(), sourceNatIp.getNetmask(), publicGateways, ciscoVnmcHost.getId())) {	
failed to create logical edge firewall in cisco vnmc device for network 

outsideIp = _ipAddrMgr.associateIPToGuestNetwork(outsideIp.getId(), network.getId(), true);	} catch (ResourceAllocationException e) {	throw new CloudRuntimeException("Unable to assign allocated additional public Ip " + outsideIp.getAddress().addr() + " to network with vlan " + vlanId + ". Exception details " + e);	}	}	String gatewayNetmask = NetUtils.getCidrNetmask(network.getCidr());	if (!createLogicalEdgeFirewall(vlanId, network.getGateway(), gatewayNetmask, outsideIp.getAddress().addr(), sourceNatIp.getNetmask(), publicGateways, ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to create logical edge firewall in Cisco VNMC device for network " + network.getName());	}	if (!configureNexusVsmForAsa(vlanId, network.getGateway(), vsmDevice.getUserName(), vsmDevice.getPassword(), vsmDevice.getipaddr(), assignedAsa.getInPortProfile(), ciscoVnmcHost.getId())) {	
failed to configure cisco nexus vsm for asa device for network 

}	}	String gatewayNetmask = NetUtils.getCidrNetmask(network.getCidr());	if (!createLogicalEdgeFirewall(vlanId, network.getGateway(), gatewayNetmask, outsideIp.getAddress().addr(), sourceNatIp.getNetmask(), publicGateways, ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to create logical edge firewall in Cisco VNMC device for network " + network.getName());	}	if (!configureNexusVsmForAsa(vlanId, network.getGateway(), vsmDevice.getUserName(), vsmDevice.getPassword(), vsmDevice.getipaddr(), assignedAsa.getInPortProfile(), ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to configure Cisco Nexus VSM " + vsmDevice.getipaddr() + " for ASA device for network " + network.getName());	}	if (!configureSourceNat(vlanId, network.getCidr(), sourceNatIp, ciscoVnmcHost.getId())) {	
failed to configure source nat in cisco vnmc device for network 

if (!createLogicalEdgeFirewall(vlanId, network.getGateway(), gatewayNetmask, outsideIp.getAddress().addr(), sourceNatIp.getNetmask(), publicGateways, ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to create logical edge firewall in Cisco VNMC device for network " + network.getName());	}	if (!configureNexusVsmForAsa(vlanId, network.getGateway(), vsmDevice.getUserName(), vsmDevice.getPassword(), vsmDevice.getipaddr(), assignedAsa.getInPortProfile(), ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to configure Cisco Nexus VSM " + vsmDevice.getipaddr() + " for ASA device for network " + network.getName());	}	if (!configureSourceNat(vlanId, network.getCidr(), sourceNatIp, ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to configure source NAT in Cisco VNMC device for network " + network.getName());	}	if (!associateAsaWithLogicalEdgeFirewall(vlanId, assignedAsa.getManagementIp(), ciscoVnmcHost.getId())) {	
failed to associate cisco asa with logical edge firewall in vnmc for network 

throw new CloudRuntimeException("Failed to configure Cisco Nexus VSM " + vsmDevice.getipaddr() + " for ASA device for network " + network.getName());	}	if (!configureSourceNat(vlanId, network.getCidr(), sourceNatIp, ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to configure source NAT in Cisco VNMC device for network " + network.getName());	}	if (!associateAsaWithLogicalEdgeFirewall(vlanId, assignedAsa.getManagementIp(), ciscoVnmcHost.getId())) {	throw new CloudRuntimeException("Failed to associate Cisco ASA 1000v (" + assignedAsa.getManagementIp() + ") with logical edge firewall in VNMC for network " + network.getName());	}	} catch (CloudRuntimeException e) {	unassignAsa1000vFromNetwork(network);	
ciscovnmcelement failed 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Firewall)) {	
ciscovnmc must be used as firewall service provider in the network 

public boolean applyFWRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.Firewall, Provider.CiscoVnmc)) {	
firewall service is not provided by cisco vnmc device on network 

public boolean applyFWRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.Firewall, Provider.CiscoVnmc)) {	return false;	}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no cisco vnmc device on network 

public boolean applyFWRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.Firewall, Provider.CiscoVnmc)) {	return false;	}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return true;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork == null) {	
cisco asa device is not associated with network 

}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return true;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork == null) {	return true;	}	if (network.getState() == Network.State.Allocated) {	
external firewall was asked to apply firewall rules for network with id this network is not implemented skipping backend commands 

public boolean applyPFRules(Network network, List<PortForwardingRule> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.PortForwarding, Provider.CiscoVnmc)) {	
port forwarding service is not provided by cisco vnmc device on network 

public boolean applyPFRules(Network network, List<PortForwardingRule> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.PortForwarding, Provider.CiscoVnmc)) {	return false;	}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no cisco vnmc device on network 

public boolean applyPFRules(Network network, List<PortForwardingRule> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.PortForwarding, Provider.CiscoVnmc)) {	return false;	}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return true;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork == null) {	
cisco asa device is not associated with network 

}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return true;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork == null) {	return true;	}	if (network.getState() == Network.State.Allocated) {	
external firewall was asked to apply port forwarding rules for network with id this network is not implemented skipping backend commands 

public boolean applyStaticNats(Network network, List<? extends StaticNat> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.StaticNat, Provider.CiscoVnmc)) {	
static nat service is not provided by cisco vnmc device on network 

public boolean applyStaticNats(Network network, List<? extends StaticNat> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.StaticNat, Provider.CiscoVnmc)) {	return false;	}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no cisco vnmc device on network 

public boolean applyStaticNats(Network network, List<? extends StaticNat> rules) throws ResourceUnavailableException {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.StaticNat, Provider.CiscoVnmc)) {	return false;	}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return true;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork == null) {	
cisco asa device is not associated with network 

}	List<CiscoVnmcControllerVO> devices = _ciscoVnmcDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return true;	}	NetworkAsa1000vMapVO asaForNetwork = _networkAsa1000vMapDao.findByNetworkId(network.getId());	if (asaForNetwork == null) {	return true;	}	if (network.getState() == Network.State.Allocated) {	
external firewall was asked to apply static nat rules for network with id this network is not implemented skipping backend commands 

========================= cloudstack sample_1673 =========================

public VirtualRouter upgradeRouter(final UpgradeRouterCmd cmd) {	final Long routerId = cmd.getId();	final Long serviceOfferingId = cmd.getServiceOfferingId();	final Account caller = CallContext.current().getCallingAccount();	final DomainRouterVO router = _routerDao.findById(routerId);	if (router == null) {	throw new InvalidParameterValueException("Unable to find router with id " + routerId);	}	_accountMgr.checkAccess(caller, null, true, router);	if (router.getServiceOfferingId() == serviceOfferingId) {	
router already has service offering 

return _routerDao.findById(routerId);	}	final ServiceOffering newServiceOffering = _entityMgr.findById(ServiceOffering.class, serviceOfferingId);	if (newServiceOffering == null) {	throw new InvalidParameterValueException("Unable to find service offering with id " + serviceOfferingId);	}	if (!newServiceOffering.getSystemUse()) {	throw new InvalidParameterValueException("Cannot upgrade router vm to a non system service offering " + serviceOfferingId);	}	if (!router.getState().equals(VirtualMachine.State.Stopped)) {	
unable to upgrade router in state 

if (router == null) {	throw new InvalidParameterValueException("Unable to find router by id " + routerId + ".");	}	_accountMgr.checkAccess(account, null, true, router);	final UserVO user = _userDao.findById(CallContext.current().getCallingUserId());	final VirtualRouter virtualRouter = stop(router, forced, user, account);	if (virtualRouter == null) {	throw new CloudRuntimeException("Failed to stop router with id " + routerId);	}	if (router.isStopPending()) {	
clear the stop pending flag of router after stop router successfully 

for (final Long guestNtwkId : routerGuestNtwkIds) {	final UserStatisticsVO userStats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), guestNtwkId, null, router.getId(), router.getType() .toString());	if (userStats != null) {	final long currentBytesRcvd = userStats.getCurrentBytesReceived();	userStats.setCurrentBytesReceived(0);	userStats.setNetBytesReceived(userStats.getNetBytesReceived() + currentBytesRcvd);	final long currentBytesSent = userStats.getCurrentBytesSent();	userStats.setCurrentBytesSent(0);	userStats.setNetBytesSent(userStats.getNetBytesSent() + currentBytesSent);	_userStatsDao.update(userStats.getId(), userStats);	
successfully updated user statistics as a part of domr reboot stop 

final UserStatisticsVO userStats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), guestNtwkId, null, router.getId(), router.getType() .toString());	if (userStats != null) {	final long currentBytesRcvd = userStats.getCurrentBytesReceived();	userStats.setCurrentBytesReceived(0);	userStats.setNetBytesReceived(userStats.getNetBytesReceived() + currentBytesRcvd);	final long currentBytesSent = userStats.getCurrentBytesSent();	userStats.setCurrentBytesSent(0);	userStats.setNetBytesSent(userStats.getNetBytesSent() + currentBytesSent);	_userStatsDao.update(userStats.getId(), userStats);	} else {	
user stats were not created for account and dc 

public VirtualRouter rebootRouter(final long routerId, final boolean reprogramNetwork) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final Account caller = CallContext.current().getCallingAccount();	final DomainRouterVO router = _routerDao.findById(routerId);	if (router == null) {	throw new InvalidParameterValueException("Unable to find domain router with id " + routerId + ".");	}	_accountMgr.checkAccess(caller, null, true, router);	if (router == null || router.getState() != VirtualMachine.State.Running) {	
unable to reboot virtual router is not in the right state 

final Account caller = CallContext.current().getCallingAccount();	final DomainRouterVO router = _routerDao.findById(routerId);	if (router == null) {	throw new InvalidParameterValueException("Unable to find domain router with id " + routerId + ".");	}	_accountMgr.checkAccess(caller, null, true, router);	if (router == null || router.getState() != VirtualMachine.State.Running) {	throw new ResourceUnavailableException("Unable to reboot domR, it is not in right state " + router.getState(), DataCenter.class, router.getDataCenterId());	}	final UserVO user = _userDao.findById(CallContext.current().getCallingUserId());	
stopping and starting router as a part of router reboot 

throw new ConfigurationException(msg);	}	NetworkHelperImpl.setSystemAccount(_accountMgr.getSystemAccount());	final String aggregationRange = configs.get("usage.stats.job.aggregation.range");	_usageAggregationRange = NumbersUtil.parseInt(aggregationRange, 1440);	_usageTimeZone = configs.get("usage.aggregation.timezone");	if (_usageTimeZone == null) {	_usageTimeZone = "GMT";	}	_agentMgr.registerForHostEvents(this, true, false, false);	
domainroutermanager is configured 

public boolean start() {	if (_routerStatsInterval > 0) {	_executor.scheduleAtFixedRate(new NetworkUsageTask(), _routerStatsInterval, _routerStatsInterval, TimeUnit.SECONDS);	} else {	
router stats interval so not scheduling the router stats thread 

cal.set(Calendar.MILLISECOND, 0);	cal.roll(Calendar.HOUR_OF_DAY, true);	cal.add(Calendar.MILLISECOND, -1);	aggDate = cal.getTime().getTime();	_dailyOrHourly = true;	} else {	aggDate = cal.getTime().getTime();	_dailyOrHourly = false;	}	if (_usageAggregationRange < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) {	
usage stats job aggregation range is to small using the minimum value of 

_dailyOrHourly = true;	} else {	aggDate = cal.getTime().getTime();	_dailyOrHourly = false;	}	if (_usageAggregationRange < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) {	_usageAggregationRange = UsageUtils.USAGE_AGGREGATION_RANGE_MIN;	}	final long initialDelay = aggDate - System.currentTimeMillis();	if( initialDelay < 0){	
initial delay for network usage stats update task is incorrect stats update task will run immediately 

final long initialDelay = aggDate - System.currentTimeMillis();	if( initialDelay < 0){	}	_networkStatsUpdateExecutor.scheduleAtFixedRate(new NetworkStatsUpdateTask(), initialDelay, _usageAggregationRange * 60 * 1000, TimeUnit.MILLISECONDS);	if (_routerCheckInterval > 0) {	_checkExecutor.scheduleAtFixedRate(new CheckRouterTask(), _routerCheckInterval, _routerCheckInterval, TimeUnit.SECONDS);	for (int i = 0; i < _rvrStatusUpdatePoolSize; i++) {	_rvrStatusUpdateExecutor.execute(new RvRStatusUpdateTask());	}	} else {	
router check interval so not scheduling the redundant router checking thread 

_checkExecutor.scheduleAtFixedRate(new CheckRouterTask(), _routerCheckInterval, _routerCheckInterval, TimeUnit.SECONDS);	for (int i = 0; i < _rvrStatusUpdatePoolSize; i++) {	_rvrStatusUpdateExecutor.execute(new RvRStatusUpdateTask());	}	} else {	}	final int routerAlertsCheckInterval = RouterAlertsCheckInterval.value();	if (routerAlertsCheckInterval > 0) {	_checkExecutor.scheduleAtFixedRate(new CheckRouterAlertsTask(), routerAlertsCheckInterval, routerAlertsCheckInterval, TimeUnit.SECONDS);	} else {	
router alerts check interval so not scheduling the router alerts checking thread 

protected void runInContext() {	try {	final List<DomainRouterVO> routers = _routerDao.listByStateAndNetworkType(VirtualMachine.State.Running, GuestType.Isolated, mgmtSrvrId);	
found running routers 

continue;	}	if (forVpc && network.getTrafficType() == TrafficType.Public || !forVpc && network.getTrafficType() == TrafficType.Guest && network.getGuestType() == Network.GuestType.Isolated) {	final NetworkUsageCommand usageCmd = new NetworkUsageCommand(privateIP, router.getHostName(), forVpc, routerNic.getIPv4Address());	final String routerType = router.getType().toString();	final UserStatisticsVO previousStats = _userStatsDao.findBy(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	NetworkUsageAnswer answer = null;	try {	answer = (NetworkUsageAnswer) _agentMgr.easySend(router.getHostId(), usageCmd);	} catch (final Exception e) {	
error while collecting network stats from router from host 

final String routerType = router.getType().toString();	final UserStatisticsVO previousStats = _userStatsDao.findBy(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	NetworkUsageAnswer answer = null;	try {	answer = (NetworkUsageAnswer) _agentMgr.easySend(router.getHostId(), usageCmd);	} catch (final Exception e) {	continue;	}	if (answer != null) {	if (!answer.getResult()) {	
error while collecting network stats from router from host details 

answer = (NetworkUsageAnswer) _agentMgr.easySend(router.getHostId(), usageCmd);	} catch (final Exception e) {	continue;	}	if (answer != null) {	if (!answer.getResult()) {	continue;	}	try {	if (answer.getBytesReceived() == 0 && answer.getBytesSent() == 0) {	
recieved and sent bytes are both not updating user statistics 

}	try {	if (answer.getBytesReceived() == 0 && answer.getBytesSent() == 0) {	continue;	}	final NetworkUsageAnswer answerFinal = answer;	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final UserStatisticsVO stats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	if (stats == null) {	
unable to find stats for account 

continue;	}	final NetworkUsageAnswer answerFinal = answer;	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final UserStatisticsVO stats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	if (stats == null) {	return;	}	if (previousStats != null && (previousStats.getCurrentBytesReceived() != stats.getCurrentBytesReceived() || previousStats.getCurrentBytesSent() != stats .getCurrentBytesSent())) {	
router stats changed from the time networkusagecommand was sent ignoring current answer router rcvd sent 

public void doInTransactionWithoutResult(final TransactionStatus status) {	final UserStatisticsVO stats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	if (stats == null) {	return;	}	if (previousStats != null && (previousStats.getCurrentBytesReceived() != stats.getCurrentBytesReceived() || previousStats.getCurrentBytesSent() != stats .getCurrentBytesSent())) {	return;	}	if (stats.getCurrentBytesReceived() > answerFinal.getBytesReceived()) {	if (s_logger.isDebugEnabled()) {	
received of bytes that s less than the last one assuming something went wrong and persisting it router reported stored 

return;	}	if (stats.getCurrentBytesReceived() > answerFinal.getBytesReceived()) {	if (s_logger.isDebugEnabled()) {	}	stats.setNetBytesReceived(stats.getNetBytesReceived() + stats.getCurrentBytesReceived());	}	stats.setCurrentBytesReceived(answerFinal.getBytesReceived());	if (stats.getCurrentBytesSent() > answerFinal.getBytesSent()) {	if (s_logger.isDebugEnabled()) {	
received of bytes that s less than the last one assuming something went wrong and persisting it router reported stored 

}	stats.setCurrentBytesSent(answerFinal.getBytesSent());	if (!_dailyOrHourly) {	stats.setAggBytesSent(stats.getNetBytesSent() + stats.getCurrentBytesSent());	stats.setAggBytesReceived(stats.getNetBytesReceived() + stats.getCurrentBytesReceived());	}	_userStatsDao.update(stats.getId(), stats);	}	});	} catch (final Exception e) {	
unable to update user statistics for account rx tx 

}	});	} catch (final Exception e) {	}	}	}	}	}	}	} catch (final Exception e) {	
error while collecting network stats 

protected void runInContext() {	final GlobalLock scanLock = GlobalLock.getInternLock("network.stats");	try {	if (scanLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_COOPERATION)) {	final ManagementServerHostVO msHost = _msHostDao.findOneInUpState(new Filter(ManagementServerHostVO.class, "id", false, 0L, 1L));	if (msHost == null || msHost.getMsid() != mgmtSrvrId) {	
skipping aggregate network stats update 

public void doInTransactionWithoutResult(final TransactionStatus status) {	final List<UserStatisticsVO> updatedStats = _userStatsDao.listUpdatedStats();	final Date updatedTime = new Date();	for (final UserStatisticsVO stat : updatedStats) {	stat.setAggBytesReceived(stat.getCurrentBytesReceived() + stat.getNetBytesReceived());	stat.setAggBytesSent(stat.getCurrentBytesSent() + stat.getNetBytesSent());	_userStatsDao.update(stat.getId(), stat);	final UserStatsLogVO statsLog = new UserStatsLogVO(stat.getId(), stat.getNetBytesReceived(), stat.getNetBytesSent(), stat .getCurrentBytesReceived(), stat.getCurrentBytesSent(), stat.getAggBytesReceived(), stat.getAggBytesSent(), updatedTime);	_userStatsLogDao.persist(statsLog);	}	
successfully updated aggregate network stats 

for (final UserStatisticsVO stat : updatedStats) {	stat.setAggBytesReceived(stat.getCurrentBytesReceived() + stat.getNetBytesReceived());	stat.setAggBytesSent(stat.getCurrentBytesSent() + stat.getNetBytesSent());	_userStatsDao.update(stat.getId(), stat);	final UserStatsLogVO statsLog = new UserStatsLogVO(stat.getId(), stat.getNetBytesReceived(), stat.getNetBytesSent(), stat .getCurrentBytesReceived(), stat.getCurrentBytesSent(), stat.getAggBytesReceived(), stat.getAggBytesSent(), updatedTime);	_userStatsLogDao.persist(statsLog);	}	}	});	} catch (final Exception e) {	
failed to update aggregate network stats 

_userStatsLogDao.persist(statsLog);	}	}	});	} catch (final Exception e) {	} finally {	scanLock.unlock();	}	}	} catch (final Exception e) {	
exception while trying to acquire network stats lock 

} else if (privateIP != null) {	final CheckS2SVpnConnectionsCommand command = new CheckS2SVpnConnectionsCommand(ipList);	command.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));	command.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());	command.setWait(30);	final Answer origAnswer = _agentMgr.easySend(router.getHostId(), command);	CheckS2SVpnConnectionsAnswer answer = null;	if (origAnswer instanceof CheckS2SVpnConnectionsAnswer) {	answer = (CheckS2SVpnConnectionsAnswer) origAnswer;	} else {	
unable to update router s vpn connection status 

command.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());	command.setWait(30);	final Answer origAnswer = _agentMgr.easySend(router.getHostId(), command);	CheckS2SVpnConnectionsAnswer answer = null;	if (origAnswer instanceof CheckS2SVpnConnectionsAnswer) {	answer = (CheckS2SVpnConnectionsAnswer) origAnswer;	} else {	continue;	}	if (!answer.getResult()) {	
unable to update router s vpn connection status 

} else if (privateIP != null) {	final CheckRouterCommand command = new CheckRouterCommand();	command.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));	command.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());	command.setWait(30);	final Answer origAnswer = _agentMgr.easySend(router.getHostId(), command);	CheckRouterAnswer answer = null;	if (origAnswer instanceof CheckRouterAnswer) {	answer = (CheckRouterAnswer) origAnswer;	} else {	
unable to update router s status 

final HostVO backupHost = _hostDao.findById(backupRouter.getHostId());	if (masterHost.getState() == Status.Up && backupHost.getState() == Status.Up) {	final String title = "Reboot " + backupRouter.getInstanceName() + " to ensure redundant virtual routers work";	if (s_logger.isDebugEnabled()) {	s_logger.debug(title);	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER, backupRouter.getDataCenterId(), backupRouter.getPodIdToDeployIn(), title, title);	try {	rebootRouter(backupRouter.getId(), true);	} catch (final ConcurrentOperationException e) {	
fail to reboot 

if (masterHost.getState() == Status.Up && backupHost.getState() == Status.Up) {	final String title = "Reboot " + backupRouter.getInstanceName() + " to ensure redundant virtual routers work";	if (s_logger.isDebugEnabled()) {	s_logger.debug(title);	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER, backupRouter.getDataCenterId(), backupRouter.getPodIdToDeployIn(), title, title);	try {	rebootRouter(backupRouter.getId(), true);	} catch (final ConcurrentOperationException e) {	} catch (final ResourceUnavailableException e) {	
fail to reboot 

final String title = "Reboot " + backupRouter.getInstanceName() + " to ensure redundant virtual routers work";	if (s_logger.isDebugEnabled()) {	s_logger.debug(title);	}	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER, backupRouter.getDataCenterId(), backupRouter.getPodIdToDeployIn(), title, title);	try {	rebootRouter(backupRouter.getId(), true);	} catch (final ConcurrentOperationException e) {	} catch (final ResourceUnavailableException e) {	} catch (final InsufficientCapacityException e) {	
fail to reboot 

updateRoutersRedundantState(routers);	continue;	}	DomainRouterVO router = router0;	if (router0.getId() < router1.getId()) {	router = router0;	} else {	router = router1;	}	if (router.getHostId() == null && router.getState() == VirtualMachine.State.Running) {	
skip router pair due to can t find host 

if (router0.getId() < router1.getId()) {	router = router0;	} else {	router = router1;	}	if (router.getHostId() == null && router.getState() == VirtualMachine.State.Running) {	continue;	}	final HostVO host = _hostDao.findById(router.getHostId());	if (host == null || host.getManagementServerId() == null || host.getManagementServerId() != ManagementServerNode.getManagementServerId()) {	
skip router pair due to not belong to this mgmt server 

continue;	}	final HostVO host = _hostDao.findById(router.getHostId());	if (host == null || host.getManagementServerId() == null || host.getManagementServerId() != ManagementServerNode.getManagementServerId()) {	continue;	}	updateRoutersRedundantState(routers);	checkDuplicateMaster(routers);	checkSanity(routers);	} catch (final Exception ex) {	
fail to complete the rvrstatusupdatetask 

protected void runInContext() {	try {	final List<DomainRouterVO> routers = _routerDao.listIsolatedByHostId(null);	
found routers to update status 

protected void runInContext() {	try {	final List<DomainRouterVO> routers = _routerDao.listIsolatedByHostId(null);	updateSite2SiteVpnConnectionState(routers);	List<NetworkVO> networks = _networkDao.listVpcNetworks();	
found vpc networks to update redundant state 

protected void runInContext() {	try {	final List<DomainRouterVO> routers = _routerDao.listIsolatedByHostId(null);	updateSite2SiteVpnConnectionState(routers);	List<NetworkVO> networks = _networkDao.listVpcNetworks();	pushToUpdateQueue(networks);	networks = _networkDao.listRedundantNetworks();	
found networks to update rvr status 

protected void runInContext() {	try {	final List<DomainRouterVO> routers = _routerDao.listIsolatedByHostId(null);	updateSite2SiteVpnConnectionState(routers);	List<NetworkVO> networks = _networkDao.listVpcNetworks();	pushToUpdateQueue(networks);	networks = _networkDao.listRedundantNetworks();	pushToUpdateQueue(networks);	} catch (final Exception ex) {	
fail to complete the checkroutertask 

protected void pushToUpdateQueue(final List<NetworkVO> networks) throws InterruptedException {	for (final NetworkVO network : networks) {	if (!_vrUpdateQueue.offer(network.getId(), 500, TimeUnit.MILLISECONDS)) {	
cannot insert into virtual router update queue adjustment of router check interval and router check poolsize maybe needed 

protected void runInContext() {	try {	getRouterAlerts();	} catch (final Exception ex) {	
fail to complete the checkrouteralertstask 

protected void getRouterAlerts() {	try {	final List<DomainRouterVO> routers = _routerDao.listByStateAndManagementServer(VirtualMachine.State.Running, mgmtSrvrId);	
found running routers 

if (opRouterMonitorServiceVO == null) {	command = new GetRouterAlertsCommand(new String("1970-01-01 00:00:00"));	} else {	command = new GetRouterAlertsCommand(opRouterMonitorServiceVO.getLastAlertTimestamp());	}	command.setAccessDetail(NetworkElementCommand.ROUTER_IP, controlIP);	try {	final Answer origAnswer = _agentMgr.easySend(router.getHostId(), command);	GetRouterAlertsAnswer answer = null;	if (origAnswer == null) {	
unable to get alerts from router 

command.setAccessDetail(NetworkElementCommand.ROUTER_IP, controlIP);	try {	final Answer origAnswer = _agentMgr.easySend(router.getHostId(), command);	GetRouterAlertsAnswer answer = null;	if (origAnswer == null) {	continue;	}	if (origAnswer instanceof GetRouterAlertsAnswer) {	answer = (GetRouterAlertsAnswer) origAnswer;	} else {	
unable to get alerts from router 

GetRouterAlertsAnswer answer = null;	if (origAnswer == null) {	continue;	}	if (origAnswer instanceof GetRouterAlertsAnswer) {	answer = (GetRouterAlertsAnswer) origAnswer;	} else {	continue;	}	if (!answer.getResult()) {	
unable to get alerts from router 

continue;	}	final String alerts[] = answer.getAlerts();	if (alerts != null) {	final String lastAlertTimeStamp = answer.getTimeStamp();	final SimpleDateFormat sdfrmt = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");	sdfrmt.setLenient(false);	try {	sdfrmt.parse(lastAlertTimeStamp);	} catch (final ParseException e) {	
invalid last alert timestamp received while collecting alerts from router 

}	if (opRouterMonitorServiceVO == null) {	opRouterMonitorServiceVO = new OpRouterMonitorServiceVO(router.getId(), router.getHostName(), lastAlertTimeStamp);	_opRouterMonitorServiceDao.persist(opRouterMonitorServiceVO);	} else {	opRouterMonitorServiceVO.setLastAlertTimestamp(lastAlertTimeStamp);	_opRouterMonitorServiceDao.update(opRouterMonitorServiceVO.getId(), opRouterMonitorServiceVO);	}	}	} catch (final Exception e) {	
error while collecting alerts from router 

opRouterMonitorServiceVO.setLastAlertTimestamp(lastAlertTimeStamp);	_opRouterMonitorServiceDao.update(opRouterMonitorServiceVO.getId(), opRouterMonitorServiceVO);	}	}	} catch (final Exception e) {	continue;	}	}	}	} catch (final Exception e) {	
error while collecting alerts from router 

String controlIP = null;	if(router.getHypervisorType() == HypervisorType.VMware  && dcVo.getNetworkType() == NetworkType.Basic ){	final List<NicVO> nics = _nicDao.listByVmId(router.getId());	for (final NicVO nic : nics) {	final NetworkVO nc = _networkDao.findById(nic.getNetworkId());	if (nc.getTrafficType() == TrafficType.Guest && nic.getIPv4Address() != null) {	controlIP = nic.getIPv4Address();	break;	}	}	
vmware with basic network selected guest nic ip as control ip 

for (final NicVO nic : nics) {	final NetworkVO nc = _networkDao.findById(nic.getNetworkId());	if (nc.getTrafficType() == TrafficType.Guest && nic.getIPv4Address() != null) {	controlIP = nic.getIPv4Address();	break;	}	}	}else{	controlIP = _routerControlHelper.getRouterControlIp(router.getId());	}	
ip of control nic 

defaultDns2 = nic.getIPv4Dns2();	defaultIp6Dns1 = nic.getIPv6Dns1();	defaultIp6Dns2 = nic.getIPv6Dns2();	}	if (nic.getTrafficType() == TrafficType.Management) {	buf.append(" localgw=").append(dest.getPod().getGateway());	} else if (nic.getTrafficType() == TrafficType.Control) {	controlNic = nic;	buf.append(createRedundantRouterArgs(controlNic, router));	if (dest.getHost().getHypervisorType() == HypervisorType.VMware || dest.getHost().getHypervisorType() == HypervisorType.Hyperv) {	
check if we need to add management server explicit route to domr pod cidr pod gateway management host 

defaultIp6Dns1 = nic.getIPv6Dns1();	defaultIp6Dns2 = nic.getIPv6Dns2();	}	if (nic.getTrafficType() == TrafficType.Management) {	buf.append(" localgw=").append(dest.getPod().getGateway());	} else if (nic.getTrafficType() == TrafficType.Control) {	controlNic = nic;	buf.append(createRedundantRouterArgs(controlNic, router));	if (dest.getHost().getHypervisorType() == HypervisorType.VMware || dest.getHost().getHypervisorType() == HypervisorType.Hyperv) {	if (s_logger.isInfoEnabled()) {	
add management server explicit route to domr 

useExtDns = useExtDns || UseExternalDnsServers.valueIn(dc.getId());	if (useExtDns) {	buf.append(" useextdns=true");	}	}	if (Boolean.valueOf(_configDao.getValue(Config.BaremetalProvisionDoneNotificationEnabled.key()))) {	final QueryBuilder<UserVO> acntq = QueryBuilder.create(UserVO.class);	acntq.and(acntq.entity().getUsername(), SearchCriteria.Op.EQ, "baremetal-system-account");	final UserVO user = acntq.find();	if (user == null) {	
global setting baremetal provision done notification is enabled but user baremetal system account is not found baremetal provision done notification will not be enabled 

final UserVO user = acntq.find();	if (user == null) {	} else {	buf.append(String.format(" baremetalnotificationsecuritykey=%s", user.getSecretKey()));	buf.append(String.format(" baremetalnotificationapikey=%s", user.getApiKey()));	buf.append(" host=").append(ApiServiceConfiguration.ManagementHostIPAdr.value());	buf.append(" port=").append(_configDao.getValue(Config.BaremetalProvisionDoneNotificationPort.key()));	}	}	if (s_logger.isDebugEnabled()) {	
boot args for 

routers = _routerDao.listByVpcId(vpcId);	buf.append(" router_id=").append(vpcId);	final Vpc vpc = _vpcDao.findById(vpcId);	try {	final MessageDigest digest = MessageDigest.getInstance("SHA-512");	final byte [] rawDigest = vpc.getUuid().getBytes(Charset.defaultCharset());	digest.update(rawDigest);	final BigInteger password = new BigInteger(1, digest.digest());	buf.append(" router_password=").append(password);	} catch (final NoSuchAlgorithmException e) {	
failed to pssword will use the plan b instead 

public boolean finalizeCommandsOnStart(final Commands cmds, final VirtualMachineProfile profile) {	final DomainRouterVO router = _routerDao.findById(profile.getId());	final NicProfile controlNic = getControlNic(profile);	if (controlNic == null) {	
control network doesn t exist for the router 

private void finalizeMonitorServiceOnStrat(final Commands cmds, final VirtualMachineProfile profile, final DomainRouterVO router, final Provider provider, final long networkId, final Boolean add) {	final NetworkVO network = _networkDao.findById(networkId);	
creating monitoring services on start 

protected void finalizeUserDataAndDhcpOnStart(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {	if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {	
reapplying dhcp entries as a part of domr start 

protected void finalizeUserDataAndDhcpOnStart(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {	if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {	_commandSetupHelper.createDhcpEntryCommandsForVMs(router, cmds, guestNetworkId);	}	if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.UserData, provider)) {	
reapplying vm data userdata and metadata entries as a part of domr start 

protected void finalizeNetworkRulesForNetwork(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {	
resending ipassoc port forwarding load balancing rules as a part of virtual router start 

protected void finalizeNetworkRulesForNetwork(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {	final ArrayList<? extends PublicIpAddress> publicIps = getPublicIpsToApply(router, provider, guestNetworkId);	final List<FirewallRule> firewallRulesEgress = new ArrayList<FirewallRule>();	if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {	firewallRulesEgress.addAll(_rulesDao.listByNetworkPurposeTrafficType(guestNetworkId, Purpose.Firewall, FirewallRule.TrafficType.Egress));	if (firewallRulesEgress.isEmpty()) {	createDefaultEgressFirewallRule(firewallRulesEgress, guestNetworkId);	}	}	
found firewall egress rule s to apply as a part of domr start 

vpns.add(vpn);	}	}	if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {	if (ip.isOneToOneNat()) {	final StaticNatImpl staticNat = new StaticNatImpl(ip.getAccountId(), ip.getDomainId(), guestNetworkId, ip.getId(), ip.getVmIp(), false);	staticNats.add(staticNat);	}	}	}	
found static nat s to apply as a part of domr start 

if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {	if (ip.isOneToOneNat()) {	final StaticNatImpl staticNat = new StaticNatImpl(ip.getAccountId(), ip.getDomainId(), guestNetworkId, ip.getId(), ip.getVmIp(), false);	staticNats.add(staticNat);	}	}	}	if (!staticNats.isEmpty()) {	_commandSetupHelper.createApplyStaticNatCommands(staticNats, router, cmds, guestNetworkId);	}	
found firewall ingress rule s to apply as a part of domr start 

staticNats.add(staticNat);	}	}	}	if (!staticNats.isEmpty()) {	_commandSetupHelper.createApplyStaticNatCommands(staticNats, router, cmds, guestNetworkId);	}	if (!firewallRulesIngress.isEmpty()) {	_commandSetupHelper.createFirewallRulesCommands(firewallRulesIngress, router, cmds, guestNetworkId);	}	
found port forwarding rule s to apply as a part of domr start 

}	if (!staticNats.isEmpty()) {	_commandSetupHelper.createApplyStaticNatCommands(staticNats, router, cmds, guestNetworkId);	}	if (!firewallRulesIngress.isEmpty()) {	_commandSetupHelper.createFirewallRulesCommands(firewallRulesIngress, router, cmds, guestNetworkId);	}	if (!pfRules.isEmpty()) {	_commandSetupHelper.createApplyPortForwardingRulesCommands(pfRules, router, cmds, guestNetworkId);	}	
found static nat rule s to apply as a part of domr start 

if (!pfRules.isEmpty()) {	_commandSetupHelper.createApplyPortForwardingRulesCommands(pfRules, router, cmds, guestNetworkId);	}	if (!staticNatFirewallRules.isEmpty()) {	final List<StaticNatRule> staticNatRules = new ArrayList<StaticNatRule>();	for (final FirewallRule rule : staticNatFirewallRules) {	staticNatRules.add(_rulesMgr.buildStaticNatRule(rule, false));	}	_commandSetupHelper.createApplyStaticNatRulesCommands(staticNatRules, router, cmds, guestNetworkId);	}	
found vpn s to apply as a part of domr start 

for (final LoadBalancerVO lb : lbs) {	final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());	final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());	final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());	final Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();	final LbSslCert sslCert = _lbMgr.getLbSslCert(lb.getId());	final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp, sslCert, lb.getLbProtocol());	lbRules.add(loadBalancing);	}	}	
found load balancing rule s to apply as a part of domr start 

if (!lbRules.isEmpty()) {	_commandSetupHelper.createApplyLoadBalancingRulesCommands(lbRules, router, cmds, guestNetworkId);	}	}	final Network guestNetwork = _networkDao.findById(guestNetworkId);	if (guestNetwork.getGuestType() == GuestType.Shared && _networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {	final Map<Network.Capability, String> dhcpCapabilities = _networkSvc.getNetworkOfferingServiceCapabilities( _networkOfferingDao.findById(_networkDao.findById(guestNetworkId).getNetworkOfferingId()), Service.Dhcp);	final String supportsMultipleSubnets = dhcpCapabilities.get(Network.Capability.DhcpAccrossMultipleSubnets);	if (supportsMultipleSubnets != null && Boolean.valueOf(supportsMultipleSubnets)) {	final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.revoked);	
Found ip aliases to revoke on the router as a part of dhcp configuration 

}	}	final Network guestNetwork = _networkDao.findById(guestNetworkId);	if (guestNetwork.getGuestType() == GuestType.Shared && _networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {	final Map<Network.Capability, String> dhcpCapabilities = _networkSvc.getNetworkOfferingServiceCapabilities( _networkOfferingDao.findById(_networkDao.findById(guestNetworkId).getNetworkOfferingId()), Service.Dhcp);	final String supportsMultipleSubnets = dhcpCapabilities.get(Network.Capability.DhcpAccrossMultipleSubnets);	if (supportsMultipleSubnets != null && Boolean.valueOf(supportsMultipleSubnets)) {	final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.revoked);	removeRevokedIpAliasFromDb(revokedIpAliasVOs);	final List<NicIpAliasVO> aliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.active);	
Found ip aliases to apply on the router as a part of dhcp configuration 

private void createDefaultEgressFirewallRule(final List<FirewallRule> rules, final long networkId) {	final NetworkVO network = _networkDao.findById(networkId);	final NetworkOfferingVO offering = _networkOfferingDao.findById(network.getNetworkOfferingId());	final Boolean defaultEgressPolicy = offering.getEgressDefaultPolicy();	if (defaultEgressPolicy) {	final List<String> sourceCidr = new ArrayList<String>();	sourceCidr.add(NetUtils.ALL_CIDRS);	final FirewallRule rule = new FirewallRuleVO(null, null, null, null, "all", networkId, network.getAccountId(), network.getDomainId(), Purpose.Firewall, sourceCidr, null, null, null, FirewallRule.TrafficType.Egress, FirewallRule.FirewallRuleType.System);	rules.add(rule);	} else {	
egress policy for the network is already defined as deny so no need to default the rule to allow 

protected void finalizeIpAssocForNetwork(final Commands cmds, final VirtualRouter router, final Provider provider, final Long guestNetworkId, final Map<String, String> vlanMacAddress) {	final ArrayList<? extends PublicIpAddress> publicIps = getPublicIpsToApply(router, provider, guestNetworkId);	if (publicIps != null && !publicIps.isEmpty()) {	
found ip s to apply as a part of domr start 

} else {	userIps = _networkModel.listPublicIpsAssignedToGuestNtwk(ownerId, guestNetworkId, null);	}	final List<PublicIp> allPublicIps = new ArrayList<PublicIp>();	if (userIps != null && !userIps.isEmpty()) {	boolean addIp = true;	for (final IpAddress userIp : userIps) {	if (skipInStates != null) {	for (final IpAddress.State stateToSkip : skipInStates) {	if (userIp.getState() == stateToSkip) {	
skipping ip address in state 

final Network network = _networkModel.getNetwork(nic.getNetworkId());	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	if (network.getTrafficType() == TrafficType.Guest) {	guestNetworks.add(network);	if (nic.getBroadcastUri().getScheme().equals("pvlan")) {	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), 0, false, "pvlan-nic");	final NetworkTopology networkTopology = _networkTopologyContext.retrieveNetworkTopology(dcVO);	try {	result = networkTopology.setupDhcpForPvlan(true, router, router.getHostId(), nicProfile);	} catch (final ResourceUnavailableException e) {	
error in finalizestart 

final List<? extends Nic> routerNics = _nicDao.listByVmId(profile.getId());	for (final Nic nic : routerNics) {	final Network network = _networkModel.getNetwork(nic.getNetworkId());	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	if (network.getTrafficType() == TrafficType.Guest && nic.getBroadcastUri() != null && nic.getBroadcastUri().getScheme().equals("pvlan")) {	final NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), 0, false, "pvlan-nic");	final NetworkTopology networkTopology = _networkTopologyContext.retrieveNetworkTopology(dcVO);	try {	networkTopology.setupDhcpForPvlan(false, domR, domR.getHostId(), nicProfile);	} catch (final ResourceUnavailableException e) {	
error in finalizestop 

public boolean startRemoteAccessVpn(final Network network, final RemoteAccessVpn vpn, final List<? extends VirtualRouter> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	
failed to start remote access vpn no router found for account and zone 

public boolean startRemoteAccessVpn(final Network network, final RemoteAccessVpn vpn, final List<? extends VirtualRouter> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	throw new ResourceUnavailableException("Failed to start remote access VPN: no router found for account and zone", DataCenter.class, network.getDataCenterId());	}	for (final VirtualRouter router : routers) {	if (router.getState() != VirtualMachine.State.Running) {	
failed to start remote access vpn router not in right state 

if (router.getState() != VirtualMachine.State.Running) {	throw new ResourceUnavailableException("Failed to start remote access VPN: router not in right state " + router.getState(), DataCenter.class, network.getDataCenterId());	}	final Commands cmds = new Commands(Command.OnError.Stop);	_commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);	if (!_nwHelper.sendCommandsToRouter(router, cmds)) {	throw new AgentUnavailableException("Unable to send commands to virtual router ", router.getHostId());	}	Answer answer = cmds.getAnswer("users");	if (!answer.getResult()) {	
unable to start vpn unable add users to vpn in zone for account on domr due to 

_commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);	if (!_nwHelper.sendCommandsToRouter(router, cmds)) {	throw new AgentUnavailableException("Unable to send commands to virtual router ", router.getHostId());	}	Answer answer = cmds.getAnswer("users");	if (!answer.getResult()) {	throw new ResourceUnavailableException("Unable to start vpn: Unable to add users to vpn in zone " + router.getDataCenterId() + " for account " + vpn.getAccountId() + " on domR: " + router.getInstanceName() + " due to " + answer.getDetails(), DataCenter.class, router.getDataCenterId());	}	answer = cmds.getAnswer("startVpn");	if (!answer.getResult()) {	
unable to start vpn in zone for account on domr due to 

public boolean deleteRemoteAccessVpn(final Network network, final RemoteAccessVpn vpn, final List<? extends VirtualRouter> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	
failed to delete remote access vpn no router found for account and zone 

if (routers == null || routers.isEmpty()) {	throw new ResourceUnavailableException("Failed to delete remote access VPN", DataCenter.class, network.getDataCenterId());	}	boolean result = true;	for (final VirtualRouter router : routers) {	if (router.getState() == VirtualMachine.State.Running) {	final Commands cmds = new Commands(Command.OnError.Continue);	_commandSetupHelper.createApplyVpnCommands(false, vpn, router, cmds);	result = result && _nwHelper.sendCommandsToRouter(router, cmds);	} else if (router.getState() == VirtualMachine.State.Stopped) {	
router is in stopped state not sending deleteremoteaccessvpn command to it 

}	boolean result = true;	for (final VirtualRouter router : routers) {	if (router.getState() == VirtualMachine.State.Running) {	final Commands cmds = new Commands(Command.OnError.Continue);	_commandSetupHelper.createApplyVpnCommands(false, vpn, router, cmds);	result = result && _nwHelper.sendCommandsToRouter(router, cmds);	} else if (router.getState() == VirtualMachine.State.Stopped) {	continue;	} else {	
failed to delete remote access vpn domr is not in right state 

public DomainRouterVO stop(final VirtualRouter router, final boolean forced, final User user, final Account caller) throws ConcurrentOperationException, ResourceUnavailableException {	
stopping router 

public boolean removeDhcpSupportForSubnet(final Network network, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	
failed to add remove vpn users no router found for account and zone 

public boolean removeDhcpSupportForSubnet(final Network network, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	throw new ResourceUnavailableException("Unable to assign ip addresses, domR doesn't exist for network " + network.getId(), DataCenter.class, network.getDataCenterId());	}	for (final DomainRouterVO router : routers) {	if (router.getState() != VirtualMachine.State.Running) {	
failed to add remove vpn users router not in running state 

public boolean removeDhcpSupportForSubnet(final Network network, final List<DomainRouterVO> routers) throws ResourceUnavailableException {	if (routers == null || routers.isEmpty()) {	throw new ResourceUnavailableException("Unable to assign ip addresses, domR doesn't exist for network " + network.getId(), DataCenter.class, network.getDataCenterId());	}	for (final DomainRouterVO router : routers) {	if (router.getState() != VirtualMachine.State.Running) {	throw new ResourceUnavailableException("Unable to assign ip addresses, domR is not in right state " + router.getState(), DataCenter.class, network.getDataCenterId());	}	final Commands cmds = new Commands(Command.OnError.Continue);	final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(network.getId(), NicIpAlias.State.revoked);	
Found ip aliases to revoke on the router as a part of dhcp configuration 

if (router.getState() != VirtualMachine.State.Running) {	throw new ResourceUnavailableException("Unable to assign ip addresses, domR is not in right state " + router.getState(), DataCenter.class, network.getDataCenterId());	}	final Commands cmds = new Commands(Command.OnError.Continue);	final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(network.getId(), NicIpAlias.State.revoked);	final List<IpAliasTO> revokedIpAliasTOs = new ArrayList<IpAliasTO>();	for (final NicIpAliasVO revokedAliasVO : revokedIpAliasVOs) {	revokedIpAliasTOs.add(new IpAliasTO(revokedAliasVO.getIp4Address(), revokedAliasVO.getNetmask(), revokedAliasVO.getAliasCount().toString()));	}	final List<NicIpAliasVO> aliasVOs = _nicIpAliasDao.listByNetworkIdAndState(network.getId(), NicIpAlias.State.active);	
Found ip aliases to apply on the router as a part of dhcp configuration 

public void processConnect(final Host host, final StartupCommand cmd, final boolean forRebalance) throws ConnectionException {	final List<DomainRouterVO> routers = _routerDao.listIsolatedByHostId(host.getId());	for (DomainRouterVO router : routers) {	if (router.isStopPending()) {	
stopping router due to stop pending flag found 

public void processConnect(final Host host, final StartupCommand cmd, final boolean forRebalance) throws ConnectionException {	final List<DomainRouterVO> routers = _routerDao.listIsolatedByHostId(host.getId());	for (DomainRouterVO router : routers) {	if (router.isStopPending()) {	final VirtualMachine.State state = router.getState();	if (state != VirtualMachine.State.Stopped && state != VirtualMachine.State.Destroyed) {	try {	stopRouter(router.getId(), false);	} catch (final ResourceUnavailableException e) {	
fail to stop router 

final List<DomainRouterVO> routers = _routerDao.listIsolatedByHostId(host.getId());	for (DomainRouterVO router : routers) {	if (router.isStopPending()) {	final VirtualMachine.State state = router.getState();	if (state != VirtualMachine.State.Stopped && state != VirtualMachine.State.Destroyed) {	try {	stopRouter(router.getId(), false);	} catch (final ResourceUnavailableException e) {	throw new ConnectionException(false, "Fail to stop router " + router.getInstanceName());	} catch (final ConcurrentOperationException e) {	
fail to stop router 

for (final Nic routerNic : routerNics) {	final Network network = _networkModel.getNetwork(routerNic.getNetworkId());	if (forVpc && network.getTrafficType() == TrafficType.Public || !forVpc && network.getTrafficType() == TrafficType.Guest && network.getGuestType() == Network.GuestType.Isolated) {	final NetworkUsageCommand usageCmd = new NetworkUsageCommand(privateIP, router.getHostName(), forVpc, routerNic.getIPv4Address());	final String routerType = router.getType().toString();	final UserStatisticsVO previousStats = _userStatsDao.findBy(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	NetworkUsageAnswer answer = null;	try {	answer = (NetworkUsageAnswer) _agentMgr.easySend(router.getHostId(), usageCmd);	} catch (final Exception e) {	
error while collecting network stats from router from host 

final String routerType = router.getType().toString();	final UserStatisticsVO previousStats = _userStatsDao.findBy(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	NetworkUsageAnswer answer = null;	try {	answer = (NetworkUsageAnswer) _agentMgr.easySend(router.getHostId(), usageCmd);	} catch (final Exception e) {	continue;	}	if (answer != null) {	if (!answer.getResult()) {	
error while collecting network stats from router from host details 

answer = (NetworkUsageAnswer) _agentMgr.easySend(router.getHostId(), usageCmd);	} catch (final Exception e) {	continue;	}	if (answer != null) {	if (!answer.getResult()) {	continue;	}	try {	if (answer.getBytesReceived() == 0 && answer.getBytesSent() == 0) {	
recieved and sent bytes are both not updating user statistics 

}	try {	if (answer.getBytesReceived() == 0 && answer.getBytesSent() == 0) {	continue;	}	final NetworkUsageAnswer answerFinal = answer;	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final UserStatisticsVO stats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	if (stats == null) {	
unable to find stats for account 

continue;	}	final NetworkUsageAnswer answerFinal = answer;	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final UserStatisticsVO stats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	if (stats == null) {	return;	}	if (previousStats != null && (previousStats.getCurrentBytesReceived() != stats.getCurrentBytesReceived() || previousStats.getCurrentBytesSent() != stats .getCurrentBytesSent())) {	
router stats changed from the time networkusagecommand was sent ignoring current answer router rcvd sent 

public void doInTransactionWithoutResult(final TransactionStatus status) {	final UserStatisticsVO stats = _userStatsDao.lock(router.getAccountId(), router.getDataCenterId(), network.getId(), forVpc ? routerNic.getIPv4Address() : null, router.getId(), routerType);	if (stats == null) {	return;	}	if (previousStats != null && (previousStats.getCurrentBytesReceived() != stats.getCurrentBytesReceived() || previousStats.getCurrentBytesSent() != stats .getCurrentBytesSent())) {	return;	}	if (stats.getCurrentBytesReceived() > answerFinal.getBytesReceived()) {	if (s_logger.isDebugEnabled()) {	
received of bytes that s less than the last one assuming something went wrong and persisting it router reported stored 

return;	}	if (stats.getCurrentBytesReceived() > answerFinal.getBytesReceived()) {	if (s_logger.isDebugEnabled()) {	}	stats.setNetBytesReceived(stats.getNetBytesReceived() + stats.getCurrentBytesReceived());	}	stats.setCurrentBytesReceived(answerFinal.getBytesReceived());	if (stats.getCurrentBytesSent() > answerFinal.getBytesSent()) {	if (s_logger.isDebugEnabled()) {	
received of bytes that s less than the last one assuming something went wrong and persisting it router reported stored 

}	stats.setCurrentBytesSent(answerFinal.getBytesSent());	if (!_dailyOrHourly) {	stats.setAggBytesSent(stats.getNetBytesSent() + stats.getCurrentBytesSent());	stats.setAggBytesReceived(stats.getNetBytesReceived() + stats.getCurrentBytesReceived());	}	_userStatsDao.update(stats.getId(), stats);	}	});	} catch (final Exception e) {	
unable to update user statistics for account rx tx 

private List<Long> rebootRouters(final List<DomainRouterVO> routers) {	final List<Long> jobIds = new ArrayList<Long>();	for (final DomainRouterVO router : routers) {	if (!_nwHelper.checkRouterVersion(router)) {	
upgrading template for router 

params.put("ctxAccountId", "" + router.getAccountId());	final RebootRouterCmd cmd = new RebootRouterCmd();	ComponentContext.inject(cmd);	params.put("id", "" + router.getId());	params.put("ctxStartEventId", "1");	final AsyncJobVO job = new AsyncJobVO("", User.UID_SYSTEM, router.getAccountId(), RebootRouterCmd.class.getName(), ApiGsonHelper.getBuilder().create().toJson(params), router.getId(), cmd.getInstanceType() != null ? cmd.getInstanceType().toString() : null, null);	job.setDispatcher(_asyncDispatcher.getName());	final long jobId = _asyncMgr.submitAsyncJob(job);	jobIds.add(jobId);	} else {	
router is already at the latest version no upgrade required 

public boolean postStateTransitionEvent(final StateMachine2.Transition<VirtualMachine.State, VirtualMachine.Event> transition, final VirtualMachine vo, final boolean status, final Object opaque) {	final VirtualMachine.State newState = transition.getToState();	final VirtualMachine.Event event = transition.getEvent();	if (vo.getType() == VirtualMachine.Type.DomainRouter && event == VirtualMachine.Event.FollowAgentPowerOnReport && newState == VirtualMachine.State.Running && isOutOfBandMigrated(opaque)) {	
virtual router is powered on out of band 

protected void runInContext() {	try {	
reboot router to refresh network rules 

protected void runInContext() {	try {	rebootRouter(_routerId, true);	} catch (final Exception e) {	
error while rebooting the router 

protected boolean aggregationExecution(final AggregationControlCommand.Action action, final Network network, final List<DomainRouterVO> routers) throws AgentUnavailableException, ResourceUnavailableException {	int errors = 0;	for (final DomainRouterVO router : routers) {	final String routerControlIp = _routerControlHelper.getRouterControlIp(router.getId());	final String routerIpInNetwork = _routerControlHelper.getRouterIpInNetwork(network.getId(), router.getId());	if (routerIpInNetwork == null) {	
the network is not configured in the router yet try the next router 

errors++;	continue;	}	final AggregationControlCommand cmd = new AggregationControlCommand(action, router.getInstanceName(), routerControlIp, routerIpInNetwork);	final Commands cmds = new Commands(cmd);	if (!_nwHelper.sendCommandsToRouter(router, cmds)) {	return false;	}	}	if (errors == routers.size()) {	
aggregationexecution on failed network is not configured in any router 

========================= cloudstack sample_2360 =========================

public String authenticate(String command, Map<String, Object[]> params, HttpSession session, InetAddress remoteAddress, String responseType, StringBuilder auditTrailSb, final HttpServletRequest req, final HttpServletResponse resp) throws ServerApiException {	auditTrailSb.append("=== SAML SLO Logging out ===");	LogoutCmdResponse response = new LogoutCmdResponse();	response.setDescription("success");	response.setResponseName(getCommandName());	String responseString = ApiResponseSerializer.toSerializedString(response, responseType);	if (session == null) {	try {	resp.sendRedirect(SAML2AuthManager.SAMLCloudStackRedirectionUrl.value());	} catch (IOException ignored) {	
ignored sending redirected failed 

if (session == null) {	try {	resp.sendRedirect(SAML2AuthManager.SAMLCloudStackRedirectionUrl.value());	} catch (IOException ignored) {	}	return responseString;	}	try {	DefaultBootstrap.bootstrap();	} catch (ConfigurationException | FactoryConfigurationError e) {	
opensaml bootstrapping error 

}	if (params != null && params.containsKey("SAMLResponse")) {	try {	final String samlResponse = ((String[])params.get(SAMLPluginConstants.SAML_RESPONSE))[0];	Response processedSAMLResponse = SAMLUtils.decodeSAMLResponse(samlResponse);	String statusCode = processedSAMLResponse.getStatus().getStatusCode().getValue();	if (!statusCode.equals(StatusCode.SUCCESS_URI)) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, _apiServer.getSerializedApiError(ApiErrorCode.INTERNAL_ERROR.getHttpCode(), "SAML SLO LogoutResponse status is not Success", params, responseType));	}	} catch (ConfigurationException | FactoryConfigurationError | ParserConfigurationException | SAXException | IOException | UnmarshallingException e) {	
samlresponse processing error 

Response processedSAMLResponse = SAMLUtils.decodeSAMLResponse(samlResponse);	String statusCode = processedSAMLResponse.getStatus().getStatusCode().getValue();	if (!statusCode.equals(StatusCode.SUCCESS_URI)) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, _apiServer.getSerializedApiError(ApiErrorCode.INTERNAL_ERROR.getHttpCode(), "SAML SLO LogoutResponse status is not Success", params, responseType));	}	} catch (ConfigurationException | FactoryConfigurationError | ParserConfigurationException | SAXException | IOException | UnmarshallingException e) {	}	try {	resp.sendRedirect(SAML2AuthManager.SAMLCloudStackRedirectionUrl.value());	} catch (IOException ignored) {	
ignored second redirected sending failed 

}	return responseString;	}	String idpId = (String) session.getAttribute(SAMLPluginConstants.SAML_IDPID);	SAMLProviderMetadata idpMetadata = _samlAuthManager.getIdPMetadata(idpId);	String nameId = (String) session.getAttribute(SAMLPluginConstants.SAML_NAMEID);	if (idpMetadata == null || nameId == null || nameId.isEmpty()) {	try {	resp.sendRedirect(SAML2AuthManager.SAMLCloudStackRedirectionUrl.value());	} catch (IOException ignored) {	
ignored final redirected failed 

resp.sendRedirect(SAML2AuthManager.SAMLCloudStackRedirectionUrl.value());	} catch (IOException ignored) {	}	return responseString;	}	LogoutRequest logoutRequest = SAMLUtils.buildLogoutRequest(idpMetadata.getSloUrl(), _samlAuthManager.getSPMetadata().getEntityId(), nameId);	try {	String redirectUrl = idpMetadata.getSloUrl() + "?SAMLRequest=" + SAMLUtils.encodeSAMLRequest(logoutRequest);	resp.sendRedirect(redirectUrl);	} catch (MarshallingException | IOException e) {	
saml slo error 

public void setAuthenticators(List<PluggableAPIAuthenticator> authenticators) {	for (PluggableAPIAuthenticator authManager: authenticators) {	if (authManager != null && authManager instanceof SAML2AuthManager) {	_samlAuthManager = (SAML2AuthManager) authManager;	}	}	if (_samlAuthManager == null) {	
no suitable pluggable authentication manager found for login cmd 

========================= cloudstack sample_1370 =========================

public boolean setupServer(final Connection conn,final Host host) {	final com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_host.getIp(), 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final String cmd = "rm -f /opt/xensource/sm/hostvmstats.py " + "/opt/xensource/bin/copy_vhd_to_secondarystorage.sh " + "/opt/xensource/bin/copy_vhd_from_secondarystorage.sh " + "/opt/xensource/bin/create_privatetemplate_from_snapshot.sh " + "/opt/xensource/bin/vhd-util " + "/opt/cloud/bin/copy_vhd_to_secondarystorage.sh " + "/opt/cloud/bin/copy_vhd_from_secondarystorage.sh " + "/opt/cloud/bin/create_privatetemplate_from_snapshot.sh " + "/opt/cloud/bin/vhd-util";	SSHCmdHelper.sshExecuteCmd(sshConnection, cmd);	} catch (final Exception e) {	
catch exception 

========================= cloudstack sample_1235 =========================

buf.append(" dns1=").append(nic.getIPv4Gateway());	}	if (nic.getTrafficType() == TrafficType.Guest) {	guestNetwork = _ntwkModel.getNetwork(nic.getNetworkId());	} else if (nic.getTrafficType() == TrafficType.Management) {	buf.append(" localgw=").append(dest.getPod().getGateway());	} else if (nic.getTrafficType() == TrafficType.Control) {	controlNic = nic;	if (dest.getHost().getHypervisorType() == HypervisorType.VMware) {	if (s_logger.isInfoEnabled()) {	
check if we need to add management server explicit route to internal lb pod cidr pod gateway management host 

if (nic.getTrafficType() == TrafficType.Guest) {	guestNetwork = _ntwkModel.getNetwork(nic.getNetworkId());	} else if (nic.getTrafficType() == TrafficType.Management) {	buf.append(" localgw=").append(dest.getPod().getGateway());	} else if (nic.getTrafficType() == TrafficType.Control) {	controlNic = nic;	if (dest.getHost().getHypervisorType() == HypervisorType.VMware) {	if (s_logger.isInfoEnabled()) {	}	if (s_logger.isInfoEnabled()) {	
add management server explicit route to internal lb 

}	if (guestNetwork != null) {	final String domain = guestNetwork.getNetworkDomain();	if (domain != null) {	buf.append(" domain=" + domain);	}	}	final String type = "ilbvm";	buf.append(" type=" + type);	if (s_logger.isDebugEnabled()) {	
boot args for 

public boolean finalizeStart(final VirtualMachineProfile profile, final long hostId, final Commands cmds, final ReservationContext context) {	DomainRouterVO internalLbVm = _internalLbVmDao.findById(profile.getId());	boolean result = true;	Answer answer = cmds.getAnswer("checkSsh");	if (answer != null && answer instanceof CheckSshAnswer) {	final CheckSshAnswer sshAnswer = (CheckSshAnswer)answer;	if (sshAnswer == null || !sshAnswer.getResult()) {	
unable to ssh to the internal lb vm 

for (final Nic internalLbVmNic : internalLbVmNics) {	final Network network = _ntwkModel.getNetwork(internalLbVmNic.getNetworkId());	if (network.getTrafficType() == TrafficType.Guest) {	guestNetworks.add(network);	}	}	answer = cmds.getAnswer("getDomRVersion");	if (answer != null && answer instanceof GetDomRVersionAnswer) {	final GetDomRVersionAnswer versionAnswer = (GetDomRVersionAnswer)answer;	if (answer == null || !answer.getResult()) {	
unable to get the template scripts version of internal lb vm due to 

public boolean finalizeCommandsOnStart(final Commands cmds, final VirtualMachineProfile profile) {	final DomainRouterVO internalLbVm = _internalLbVmDao.findById(profile.getId());	final NicProfile controlNic = getNicProfileByTrafficType(profile, TrafficType.Control);	if (controlNic == null) {	
control network doesn t exist for the internal lb vm 

_instance = "DEFAULT";	}	_mgmtHost = configs.get("host");	_mgmtCidr = _configDao.getValue(Config.ManagementNetwork.key());	final String offUUID = configs.get(Config.InternalLbVmServiceOfferingId.key());	if (offUUID != null && !offUUID.isEmpty()) {	final ServiceOfferingVO off = _serviceOfferingDao.findByUuid(offUUID);	if (off != null) {	_internalLbVmOfferingId = off.getId();	} else {	
invalid offering uuid is passed in the default offering will be used instead 

if (_internalLbVmOfferingId == 0L) {	List<ServiceOfferingVO> offerings = _serviceOfferingDao.createSystemServiceOfferings("System Offering For Internal LB VM", ServiceOffering.internalLbVmDefaultOffUniqueName, 1, InternalLoadBalancerVMManager.DEFAULT_INTERNALLB_VM_RAMSIZE, InternalLoadBalancerVMManager.DEFAULT_INTERNALLB_VM_CPU_MHZ, null, null, true, null, Storage.ProvisioningType.THIN, true, null, true, VirtualMachine.Type.InternalLoadBalancerVm, true);	if (offerings == null || offerings.size() < 2) {	String msg = "Data integrity problem : System Offering For Internal LB VM has been removed?";	s_logger.error(msg);	throw new ConfigurationException(msg);	}	}	_itMgr.registerGuru(VirtualMachine.Type.InternalLoadBalancerVm, this);	if (s_logger.isInfoEnabled()) {	
has been configured 

protected void finalizeLbRulesForIp(final Commands cmds, final DomainRouterVO internalLbVm, final Provider provider, final Ip sourceIp, final long guestNtwkId) {	
resending load balancing rules as a part of start for 

final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();	if (_ntwkModel.isProviderSupportServiceInNetwork(guestNtwkId, Service.Lb, provider)) {	for (final ApplicationLoadBalancerRuleVO lb : lbs) {	final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());	final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());	final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());	final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp);	lbRules.add(loadBalancing);	}	}	
found load balancing rule s to apply as a part of intenrnal lb vm start 

protected String getInternalLbControlIp(final long internalLbVmId) {	String controlIpAddress = null;	final List<NicVO> nics = _nicDao.listByVmId(internalLbVmId);	for (final NicVO nic : nics) {	final Network ntwk = _ntwkModel.getNetwork(nic.getNetworkId());	if (ntwk.getTrafficType() == TrafficType.Control) {	controlIpAddress = nic.getIPv4Address();	}	}	if (controlIpAddress == null) {	
unable to find internal lb control ip in its attached nics internal lb vm 

public boolean destroyInternalLbVm(final long vmId, final Account caller, final Long callerUserId) throws ResourceUnavailableException, ConcurrentOperationException {	if (s_logger.isDebugEnabled()) {	
attempting to destroy internal lb vm 

protected VirtualRouter stopInternalLbVm(final DomainRouterVO internalLbVm, final boolean forced, final Account caller, final long callerUserId) throws ResourceUnavailableException, ConcurrentOperationException {	
stopping internal lb vm 

protected List<DomainRouterVO> startInternalLbVms(final Map<Param, Object> params, final List<DomainRouterVO> internalLbVms) throws StorageUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {	List<DomainRouterVO> runningInternalLbVms = null;	if (internalLbVms != null) {	runningInternalLbVms = new ArrayList<DomainRouterVO>();	} else {	
have no internal lb vms to start 

protected List<DomainRouterVO> findOrDeployInternalLbVm(final Network guestNetwork, final Ip requestedGuestIp, final DeployDestination dest, final Account owner, final Map<Param, Object> params) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	List<DomainRouterVO> internalLbVms = new ArrayList<DomainRouterVO>();	final Network lock = _networkDao.acquireInLockTable(guestNetwork.getId(), NetworkOrchestrationService.NetworkLockTimeout.value());	if (lock == null) {	throw new ConcurrentOperationException("Unable to lock network " + guestNetwork.getId());	}	if (s_logger.isDebugEnabled()) {	
lock is acquired for network id as a part of internal lb startup in 

if (s_logger.isDebugEnabled()) {	}	final long internalLbProviderId = getInternalLbProviderId(guestNetwork);	try {	assert guestNetwork.getState() == Network.State.Implemented || guestNetwork.getState() == Network.State.Setup || guestNetwork.getState() == Network.State.Implementing : "Network is not yet fully implemented: " + guestNetwork;	assert guestNetwork.getTrafficType() == TrafficType.Guest;	final Pair<DeploymentPlan, List<DomainRouterVO>> planAndInternalLbVms = getDeploymentPlanAndInternalLbVms(dest, guestNetwork.getId(), requestedGuestIp);	internalLbVms = planAndInternalLbVms.second();	final DeploymentPlan plan = planAndInternalLbVms.first();	if (internalLbVms.size() > 0) {	
found internal lb vms for the requested ip 

}	final DomainRouterVO internalLbVm = deployInternalLbVm(owner, dest, plan, params, internalLbProviderId, internalLbVmOfferingId, guestNetwork.getVpcId(), networks, false);	if (internalLbVm != null) {	_internalLbVmDao.addRouterToGuestNetwork(internalLbVm, guestNetwork);	internalLbVms.add(internalLbVm);	}	} finally {	if (lock != null) {	_networkDao.releaseFromLockTable(lock.getId());	if (s_logger.isDebugEnabled()) {	
lock is released for network id as a part of internal lb vm startup in 

protected LinkedHashMap<Network, List<? extends NicProfile>> createInternalLbVmNetworks(final Network guestNetwork, final DeploymentPlan plan, final Ip guestIp) throws ConcurrentOperationException, InsufficientAddressCapacityException {	final LinkedHashMap<Network, List<? extends NicProfile>> networks = new LinkedHashMap<Network, List<? extends NicProfile>>(3);	if (guestNetwork != null) {	
adding nic for internal lb in guest network 

guestNic.setIPv4Gateway(guestNetwork.getGateway());	guestNic.setBroadcastUri(guestNetwork.getBroadcastUri());	guestNic.setBroadcastType(guestNetwork.getBroadcastDomainType());	guestNic.setIsolationUri(guestNetwork.getBroadcastUri());	guestNic.setMode(guestNetwork.getMode());	final String gatewayCidr = guestNetwork.getCidr();	guestNic.setIPv4Netmask(NetUtils.getCidrNetmask(gatewayCidr));	guestNic.setDefaultNic(true);	networks.put(guestNetwork, new ArrayList<NicProfile>(Arrays.asList(guestNic)));	}	
adding nic for internal lb vm in control network 

final ServiceOfferingVO routerOffering = _serviceOfferingDao.findById(svcOffId);	final List<HypervisorType> hypervisors = getHypervisors(dest, plan, null);	int allocateRetry = 0;	int startRetry = 0;	DomainRouterVO internalLbVm = null;	for (final Iterator<HypervisorType> iter = hypervisors.iterator(); iter.hasNext();) {	final HypervisorType hType = iter.next();	try {	final long id = _internalLbVmDao.getNextInSequence(Long.class, "id");	if (s_logger.isDebugEnabled()) {	
creating the internal lb vm in datacenter with hypervisor type 

case VMware: templateName = VirtualNetworkApplianceManager.RouterTemplateVmware.valueIn(dest.getDataCenter().getId());	break;	case Hyperv: templateName = VirtualNetworkApplianceManager.RouterTemplateHyperV.valueIn(dest.getDataCenter().getId());	break;	case LXC: templateName = VirtualNetworkApplianceManager.RouterTemplateLxc.valueIn(dest.getDataCenter().getId());	break;	default: break;	}	final VMTemplateVO template = _templateDao.findRoutingTemplate(hType, templateName);	if (template == null) {	
won t support system vm skip it 

userId =  userVOs.get(0).getId();	}	}	internalLbVm = new DomainRouterVO(id, routerOffering.getId(), internalLbProviderId, VirtualMachineName.getSystemVmName(id, _instance, InternalLbVmNamePrefix), template.getId(), template.getHypervisorType(), template.getGuestOSId(), owner.getDomainId(), owner.getId(), userId, false, RedundantState.UNKNOWN, false, false, VirtualMachine.Type.InternalLoadBalancerVm, vpcId);	internalLbVm.setRole(Role.INTERNAL_LB_VM);	internalLbVm = _internalLbVmDao.persist(internalLbVm);	_itMgr.allocate(internalLbVm.getInstanceName(), template, routerOffering, networks, plan, null);	internalLbVm = _internalLbVmDao.findById(internalLbVm.getId());	} catch (final InsufficientCapacityException ex) {	if (allocateRetry < 2 && iter.hasNext()) {	
failed to allocate the internal lb vm with hypervisor type retrying one more time 

}	} finally {	allocateRetry++;	}	if (startVm) {	try {	internalLbVm = startInternalLbVm(internalLbVm, _accountMgr.getSystemAccount(), User.UID_SYSTEM, params);	break;	} catch (final InsufficientCapacityException ex) {	if (startRetry < 2 && iter.hasNext()) {	
failed to start the internal lb vm with hypervisor type destroying it and recreating one more time 

protected DomainRouterVO startInternalLbVm(DomainRouterVO internalLbVm, final Account caller, final long callerUserId, final Map<Param, Object> params) throws StorageUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {	
starting internal lb vm 

protected DomainRouterVO startInternalLbVm(DomainRouterVO internalLbVm, final Account caller, final long callerUserId, final Map<Param, Object> params) throws StorageUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {	_itMgr.start(internalLbVm.getUuid(), params, null, null);	if (internalLbVm.isStopPending()) {	
clear the stop pending flag of internal lb vm after start router successfully 

public boolean applyLoadBalancingRules(final Network network, final List<LoadBalancingRule> rules, final List<? extends VirtualRouter> internalLbVms) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	
no lb rules to be applied for network 

public boolean applyLoadBalancingRules(final Network network, final List<LoadBalancingRule> rules, final List<? extends VirtualRouter> internalLbVms) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	
lb rules to be applied for network 

if (rules == null || rules.isEmpty()) {	return true;	}	if (internalLbVms == null || internalLbVms.isEmpty()) {	throw new CloudRuntimeException("Can't apply the lb rules on network " + network + " as the list of internal lb vms is empty");	}	final VirtualRouter lbVm = internalLbVms.get(0);	if (lbVm.getState() == State.Running) {	return sendLBRules(lbVm, rules, network.getId());	} else if (lbVm.getState() == State.Stopped || lbVm.getState() == State.Stopping) {	
internal lb vm is in so not sending apply lb rules commands to the backend 

}	if (internalLbVms == null || internalLbVms.isEmpty()) {	throw new CloudRuntimeException("Can't apply the lb rules on network " + network + " as the list of internal lb vms is empty");	}	final VirtualRouter lbVm = internalLbVms.get(0);	if (lbVm.getState() == State.Running) {	return sendLBRules(lbVm, rules, network.getId());	} else if (lbVm.getState() == State.Stopped || lbVm.getState() == State.Stopping) {	return true;	} else {	
unable to apply lb rules internal lb vm is not in the right state 

protected boolean sendCommandsToInternalLbVm(final VirtualRouter internalLbVm, final Commands cmds) throws AgentUnavailableException {	Answer[] answers = null;	try {	answers = _agentMgr.send(internalLbVm.getHostId(), cmds);	} catch (final OperationTimedoutException e) {	
timed out 

========================= cloudstack sample_1848 =========================

TemplateResponse response = new TemplateResponse();	if (listResponse != null && !listResponse.isEmpty()) {	response = listResponse.get(0);	}	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to copy template");	}	} catch (StorageUnavailableException ex) {	
exception 

========================= cloudstack sample_3176 =========================

DataCenter dc = _dcDao.findById(vm.getDataCenterId());	if (vmGroupCount > 0) {	for (AffinityGroupProcessor processor : _affinityProcessors) {	processor.process(vmProfile, plan, avoids);	}	}	if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {	checkForNonDedicatedResources(vmProfile, dc, avoids);	}	if (s_logger.isDebugEnabled()) {	
deploy avoids pods clusters hosts 

plannerName = "BareMetalPlanner";	} else {	plannerName = _configDao.getValue(Config.VmDeploymentPlanner.key());	}	}	planner = getDeploymentPlannerByName(plannerName);	}	int cpu_requested = offering.getCpu() * offering.getSpeed();	long ram_requested = offering.getRamSize() * 1024L * 1024L;	if (s_logger.isDebugEnabled()) {	
deploymentplanner allocation algorithm 

plannerName = "BareMetalPlanner";	} else {	plannerName = _configDao.getValue(Config.VmDeploymentPlanner.key());	}	}	planner = getDeploymentPlannerByName(plannerName);	}	int cpu_requested = offering.getCpu() * offering.getSpeed();	long ram_requested = offering.getRamSize() * 1024L * 1024L;	if (s_logger.isDebugEnabled()) {	
trying to allocate a host and storage pools from dc pod cluster requested cpu requested ram 

}	int cpu_requested = offering.getCpu() * offering.getSpeed();	long ram_requested = offering.getRamSize() * 1024L * 1024L;	if (s_logger.isDebugEnabled()) {	s_logger.debug("Is ROOT volume READY (pool already allocated)?: " + (plan.getPoolId() != null ? "Yes" : "No"));	}	String haVmTag = (String)vmProfile.getParameter(VirtualMachineProfile.Param.HaTag);	if (plan.getHostId() != null && haVmTag == null) {	Long hostIdSpecified = plan.getHostId();	if (s_logger.isDebugEnabled()) {	
deploymentplan has host id specified choosing this host and making no checks on this host 

if (s_logger.isDebugEnabled()) {	s_logger.debug("Is ROOT volume READY (pool already allocated)?: " + (plan.getPoolId() != null ? "Yes" : "No"));	}	String haVmTag = (String)vmProfile.getParameter(VirtualMachineProfile.Param.HaTag);	if (plan.getHostId() != null && haVmTag == null) {	Long hostIdSpecified = plan.getHostId();	if (s_logger.isDebugEnabled()) {	}	HostVO host = _hostDao.findById(hostIdSpecified);	if (host == null) {	
the specified host cannot be found 

s_logger.debug("Is ROOT volume READY (pool already allocated)?: " + (plan.getPoolId() != null ? "Yes" : "No"));	}	String haVmTag = (String)vmProfile.getParameter(VirtualMachineProfile.Param.HaTag);	if (plan.getHostId() != null && haVmTag == null) {	Long hostIdSpecified = plan.getHostId();	if (s_logger.isDebugEnabled()) {	}	HostVO host = _hostDao.findById(hostIdSpecified);	if (host == null) {	} else if (avoids.shouldAvoid(host)) {	
the specified host is in avoid set 

String haVmTag = (String)vmProfile.getParameter(VirtualMachineProfile.Param.HaTag);	if (plan.getHostId() != null && haVmTag == null) {	Long hostIdSpecified = plan.getHostId();	if (s_logger.isDebugEnabled()) {	}	HostVO host = _hostDao.findById(hostIdSpecified);	if (host == null) {	} else if (avoids.shouldAvoid(host)) {	} else {	if (s_logger.isDebugEnabled()) {	
looking for suitable pools for this host under zone pod cluster 

HostVO host = _hostDao.findById(hostIdSpecified);	if (host == null) {	} else if (avoids.shouldAvoid(host)) {	} else {	if (s_logger.isDebugEnabled()) {	}	Pod pod = _podDao.findById(host.getPodId());	Cluster cluster = _clusterDao.findById(host.getClusterId());	if (vm.getHypervisorType() == HypervisorType.BareMetal) {	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, new HashMap<Volume, StoragePool>());	
returning deployment destination 

suitableHosts.add(host);	Pair<Host, Map<Volume, StoragePool>> potentialResources = findPotentialDeploymentResources( suitableHosts, suitableVolumeStoragePools, avoids, getPlannerUsage(planner, vmProfile, plan, avoids), readyAndReusedVolumes);	if (potentialResources != null) {	pod = _podDao.findById(host.getPodId());	cluster = _clusterDao.findById(host.getClusterId());	Map<Volume, StoragePool> storageVolMap = potentialResources.second();	for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, storageVolMap);	
returning deployment destination 

cluster = _clusterDao.findById(host.getClusterId());	Map<Volume, StoragePool> storageVolMap = potentialResources.second();	for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, storageVolMap);	return dest;	}	}	}	
cannot deploy to specified host returning 

storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, storageVolMap);	return dest;	}	}	}	return null;	}	if (vm.getLastHostId() != null && haVmTag == null) {	
this vm has last host id specified trying to choose the same host 

return dest;	}	}	}	return null;	}	if (vm.getLastHostId() != null && haVmTag == null) {	HostVO host = _hostDao.findById(vm.getLastHostId());	ServiceOfferingDetailsVO offeringDetails = null;	if (host == null) {	
the last host of this vm cannot be found 

}	}	}	return null;	}	if (vm.getLastHostId() != null && haVmTag == null) {	HostVO host = _hostDao.findById(vm.getLastHostId());	ServiceOfferingDetailsVO offeringDetails = null;	if (host == null) {	} else if (avoids.shouldAvoid(host)) {	
the last host of this vm is in avoid set 

}	}	return null;	}	if (vm.getLastHostId() != null && haVmTag == null) {	HostVO host = _hostDao.findById(vm.getLastHostId());	ServiceOfferingDetailsVO offeringDetails = null;	if (host == null) {	} else if (avoids.shouldAvoid(host)) {	} else if (plan.getClusterId() != null && host.getClusterId() != null && !plan.getClusterId().equals(host.getClusterId())) {	
the last host of this vm cannot be picked as the plan specifies different clusterid 

}	return null;	}	if (vm.getLastHostId() != null && haVmTag == null) {	HostVO host = _hostDao.findById(vm.getLastHostId());	ServiceOfferingDetailsVO offeringDetails = null;	if (host == null) {	} else if (avoids.shouldAvoid(host)) {	} else if (plan.getClusterId() != null && host.getClusterId() != null && !plan.getClusterId().equals(host.getClusterId())) {	} else if (_capacityMgr.checkIfHostReachMaxGuestLimit(host)) {	
the last host hostid already has max running vms count includes system vms skipping this and trying other available hosts 

if (vm.getLastHostId() != null && haVmTag == null) {	HostVO host = _hostDao.findById(vm.getLastHostId());	ServiceOfferingDetailsVO offeringDetails = null;	if (host == null) {	} else if (avoids.shouldAvoid(host)) {	} else if (plan.getClusterId() != null && host.getClusterId() != null && !plan.getClusterId().equals(host.getClusterId())) {	} else if (_capacityMgr.checkIfHostReachMaxGuestLimit(host)) {	} else if ((offeringDetails  = _serviceOfferingDetailsDao.findDetail(offering.getId(), GPU.Keys.vgpuType.toString())) != null) {	ServiceOfferingDetailsVO groupName = _serviceOfferingDetailsDao.findDetail(offering.getId(), GPU.Keys.pciDevice.toString());	if(!_resourceMgr.isGPUDeviceAvailable(host.getId(), groupName.getValue(), offeringDetails.getValue())){	
the last host of this vm does not have required gpu devices available 

ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, "memoryOvercommitRatio");	Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());	Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());	boolean hostHasCpuCapability, hostHasCapacity = false;	hostHasCpuCapability = _capacityMgr.checkIfHostHasCpuCapability(host.getId(), offering.getCpu(), offering.getSpeed());	if (hostHasCpuCapability) {	hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, true, cpuOvercommitRatio, memoryOvercommitRatio, true);	if (!hostHasCapacity) hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, false, cpuOvercommitRatio, memoryOvercommitRatio, true);	}	if (hostHasCapacity && hostHasCpuCapability) {	
the last host of this vm is up and has enough capacity 

ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, "memoryOvercommitRatio");	Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());	Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());	boolean hostHasCpuCapability, hostHasCapacity = false;	hostHasCpuCapability = _capacityMgr.checkIfHostHasCpuCapability(host.getId(), offering.getCpu(), offering.getSpeed());	if (hostHasCpuCapability) {	hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, true, cpuOvercommitRatio, memoryOvercommitRatio, true);	if (!hostHasCapacity) hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, false, cpuOvercommitRatio, memoryOvercommitRatio, true);	}	if (hostHasCapacity && hostHasCpuCapability) {	
now checking for suitable pools under zone pod cluster 

hostHasCpuCapability = _capacityMgr.checkIfHostHasCpuCapability(host.getId(), offering.getCpu(), offering.getSpeed());	if (hostHasCpuCapability) {	hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, true, cpuOvercommitRatio, memoryOvercommitRatio, true);	if (!hostHasCapacity) hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, false, cpuOvercommitRatio, memoryOvercommitRatio, true);	}	if (hostHasCapacity && hostHasCpuCapability) {	Pod pod = _podDao.findById(host.getPodId());	Cluster cluster = _clusterDao.findById(host.getClusterId());	if (vm.getHypervisorType() == HypervisorType.BareMetal) {	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, new HashMap<Volume, StoragePool>());	
returning deployment destination 

if (!suitableVolumeStoragePools.isEmpty()) {	List<Host> suitableHosts = new ArrayList<Host>();	suitableHosts.add(host);	Pair<Host, Map<Volume, StoragePool>> potentialResources = findPotentialDeploymentResources( suitableHosts, suitableVolumeStoragePools, avoids, getPlannerUsage(planner, vmProfile, plan, avoids), readyAndReusedVolumes);	if (potentialResources != null) {	Map<Volume, StoragePool> storageVolMap = potentialResources.second();	for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, storageVolMap);	
returning deployment destination 

if (potentialResources != null) {	Map<Volume, StoragePool> storageVolMap = potentialResources.second();	for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, storageVolMap);	return dest;	}	}	} else {	
the last host of this vm does not have enough capacity 

for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, storageVolMap);	return dest;	}	}	} else {	}	} else {	
service offering host tag does not match the last host of this vm 

}	DeployDestination dest = new DeployDestination(dc, pod, cluster, host, storageVolMap);	return dest;	}	}	} else {	}	} else {	}	} else {	
the last host of this vm is not up or is not enabled host status is host resource state is 

return dest;	}	}	} else {	}	} else {	}	} else {	}	}	
cannot choose the last host to deploy this vm 

private boolean checkIfHostFitsPlannerUsage(final long hostId, final PlannerResourceUsage resourceUsageRequired) {	PlannerHostReservationVO reservationEntry = _plannerHostReserveDao.findByHostId(hostId);	if (reservationEntry != null) {	final long id = reservationEntry.getId();	PlannerResourceUsage hostResourceType = reservationEntry.getResourceUsage();	if (hostResourceType != null) {	if (hostResourceType == resourceUsageRequired) {	return true;	} else {	
cannot use this host for usage since this host has been reserved for planner usage 

return true;	} else {	return false;	}	} else {	final PlannerResourceUsage hostResourceTypeFinal = hostResourceType;	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	final PlannerHostReservationVO lockedEntry = _plannerHostReserveDao.lockRow(id, true);	if (lockedEntry == null) {	
unable to lock the host entry for reservation host 

return false;	}	if (lockedEntry.getResourceUsage() == null) {	lockedEntry.setResourceUsage(resourceUsageRequired);	_plannerHostReserveDao.persist(lockedEntry);	return true;	} else {	if (lockedEntry.getResourceUsage() == resourceUsageRequired) {	return true;	} else {	
cannot use this host for usage since this host has been reserved for planner usage 

public boolean checkHostReservationRelease(final Long hostId) {	if (hostId != null) {	PlannerHostReservationVO reservationEntry = _plannerHostReserveDao.findByHostId(hostId);	if (reservationEntry != null && reservationEntry.getResourceUsage() != null) {	List<VMInstanceVO> vms = _vmInstanceDao.listUpByHostId(hostId);	if (vms.size() > 0) {	if (s_logger.isDebugEnabled()) {	
cannot release reservation found vms running on host 

if (s_logger.isDebugEnabled()) {	}	return false;	}	List<VMInstanceVO> vmsByLastHostId = _vmInstanceDao.listByLastHostId(hostId);	if (vmsByLastHostId.size() > 0) {	for (VMInstanceVO stoppedVM : vmsByLastHostId) {	long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - stoppedVM.getUpdateTime().getTime()) / 1000;	if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {	if (s_logger.isDebugEnabled()) {	
cannot release reservation found vm stopped but reserved on host 

if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	}	}	List<VMInstanceVO> vmsStoppingMigratingByHostId = _vmInstanceDao.findByHostInStates(hostId, State.Stopping, State.Migrating, State.Starting);	if (vmsStoppingMigratingByHostId.size() > 0) {	if (s_logger.isDebugEnabled()) {	
cannot release reservation found vms stopping migrating starting on host 

}	List<VMInstanceVO> vmsStoppingMigratingByHostId = _vmInstanceDao.findByHostInStates(hostId, State.Stopping, State.Migrating, State.Starting);	if (vmsStoppingMigratingByHostId.size() > 0) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	List<VMInstanceVO> vmsStartingNoHost = _vmInstanceDao.listStartingWithNoHostId();	if (vmsStartingNoHost.size() > 0) {	if (s_logger.isDebugEnabled()) {	
cannot release reservation found vms starting as of now and no hostid yet stored 

}	return false;	}	List<VMInstanceVO> vmsStartingNoHost = _vmInstanceDao.listStartingWithNoHostId();	if (vmsStartingNoHost.size() > 0) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	if (s_logger.isDebugEnabled()) {	
host has no vms associated releasing the planner reservation for host 

}	return false;	}	if (s_logger.isDebugEnabled()) {	}	final long id = reservationEntry.getId();	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	final PlannerHostReservationVO lockedEntry = _plannerHostReserveDao.lockRow(id, true);	if (lockedEntry == null) {	
unable to lock the host entry for reservation host 

protected void runInContext() {	try {	
checking if any host reservation can be released 

protected void runInContext() {	try {	checkHostReservations();	
done running hostreservationreleasechecker 

protected void runInContext() {	try {	checkHostReservations();	} catch (Throwable t) {	
exception in hostreservationreleasechecker 

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	_agentMgr.registerForHostEvents(this, true, false, true);	VirtualMachine.State.getStateMachine().registerListener(this);	_messageBus.subscribe("VM_ReservedCapacity_Free", new MessageSubscriber() {	public void onPublishMessage(String senderAddress, String subject, Object obj) {	VMInstanceVO vm = ((VMInstanceVO)obj);	
messagebus message host reserved capacity released for vm checking if host reservation can be released for host 

private DeployDestination checkClustersforDestination(List<Long> clusterList, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, DataCenter dc, DeploymentPlanner.PlannerResourceUsage resourceUsageRequired, ExcludeList plannerAvoidOutput) {	if (s_logger.isTraceEnabled()) {	
clusterid list to consider 

private DeployDestination checkClustersforDestination(List<Long> clusterList, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, DataCenter dc, DeploymentPlanner.PlannerResourceUsage resourceUsageRequired, ExcludeList plannerAvoidOutput) {	if (s_logger.isTraceEnabled()) {	}	for (Long clusterId : clusterList) {	ClusterVO clusterVO = _clusterDao.findById(clusterId);	if (clusterVO.getHypervisorType() != vmProfile.getHypervisorType()) {	
cluster has hypervisortype that does not match the vm skipping this cluster 

private DeployDestination checkClustersforDestination(List<Long> clusterList, VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, DataCenter dc, DeploymentPlanner.PlannerResourceUsage resourceUsageRequired, ExcludeList plannerAvoidOutput) {	if (s_logger.isTraceEnabled()) {	}	for (Long clusterId : clusterList) {	ClusterVO clusterVO = _clusterDao.findById(clusterId);	if (clusterVO.getHypervisorType() != vmProfile.getHypervisorType()) {	avoid.addCluster(clusterVO.getId());	continue;	}	
checking resources in cluster under pod 

if (!suitableVolumeStoragePools.isEmpty()) {	Pair<Host, Map<Volume, StoragePool>> potentialResources = findPotentialDeploymentResources( suitableHosts, suitableVolumeStoragePools, avoid, resourceUsageRequired, readyAndReusedVolumes);	if (potentialResources != null) {	Pod pod = _podDao.findById(clusterVO.getPodId());	Host host = _hostDao.findById(potentialResources.first().getId());	Map<Volume, StoragePool> storageVolMap = potentialResources.second();	for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, clusterVO, host, storageVolMap);	
returning deployment destination 

Pod pod = _podDao.findById(clusterVO.getPodId());	Host host = _hostDao.findById(potentialResources.first().getId());	Map<Volume, StoragePool> storageVolMap = potentialResources.second();	for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, clusterVO, host, storageVolMap);	return dest;	}	} else {	
no suitable storagepools found under this cluster 

Map<Volume, StoragePool> storageVolMap = potentialResources.second();	for (Volume vol : readyAndReusedVolumes) {	storageVolMap.remove(vol);	}	DeployDestination dest = new DeployDestination(dc, pod, clusterVO, host, storageVolMap);	return dest;	}	} else {	}	} else {	
no suitable hosts found under this cluster 

return dest;	}	} else {	}	} else {	}	if (canAvoidCluster(clusterVO, avoid, plannerAvoidOutput, vmProfile)) {	avoid.addCluster(clusterVO.getId());	}	}	
could not find suitable deployment destination for this vm under any clusters returning 

protected Pair<Host, Map<Volume, StoragePool>> findPotentialDeploymentResources(List<Host> suitableHosts, Map<Volume, List<StoragePool>> suitableVolumeStoragePools, ExcludeList avoid, DeploymentPlanner.PlannerResourceUsage resourceUsageRequired, List<Volume> readyAndReusedVolumes) {	
trying to find a potenial host and associated storage pools from the suitable host pool lists for this vm 

if (v1.getSize() < v2.getSize()) return 1;	else return -1;	}	});	volumesOrderBySizeDesc.addAll(suitableVolumeStoragePools.keySet());	boolean multipleVolume = volumesOrderBySizeDesc.size() > 1;	for (Host potentialHost : suitableHosts) {	Map<StoragePool, List<Volume>> volumeAllocationMap = new HashMap<StoragePool, List<Volume>>();	for (Volume vol : volumesOrderBySizeDesc) {	haveEnoughSpace = false;	
checking if host can access any suitable storage pool for volume 

}	storage.put(vol, potentialSPool);	haveEnoughSpace = true;	break;	}	}	if (!hostCanAccessPool) {	break;	}	if (!haveEnoughSpace) {	
insufficient capacity to allocate all volumes 

}	}	if (!hostCanAccessPool) {	break;	}	if (!haveEnoughSpace) {	break;	}	}	if (hostCanAccessPool && haveEnoughSpace && checkIfHostFitsPlannerUsage(potentialHost.getId(), resourceUsageRequired)) {	
found a potential host id name and associated storage pools for this vm 

if (!haveEnoughSpace) {	break;	}	}	if (hostCanAccessPool && haveEnoughSpace && checkIfHostFitsPlannerUsage(potentialHost.getId(), resourceUsageRequired)) {	return new Pair<Host, Map<Volume, StoragePool>>(potentialHost, storage);	} else {	avoid.addHost(potentialHost.getId());	}	}	
could not find a potential host that has associated storage pools from the suitable host pool lists for this vm 

protected boolean hostCanAccessSPool(Host host, StoragePool pool) {	boolean hostCanAccessSPool = false;	StoragePoolHostVO hostPoolLinkage = _poolHostDao.findByPoolHost(pool.getId(), host.getId());	if (hostPoolLinkage != null) {	hostCanAccessSPool = true;	}	
host can cannot access pool 

protected List<Host> findSuitableHosts(VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid, int returnUpTo) {	List<Host> suitableHosts = new ArrayList<Host>();	for (HostAllocator allocator : _hostAllocators) {	suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, avoid, returnUpTo);	if (suitableHosts != null && !suitableHosts.isEmpty()) {	break;	}	}	if (suitableHosts.isEmpty()) {	
no suitable hosts found 

}	if (_volsDao.findByInstanceAndType(vmProfile.getId(), Volume.Type.ROOT).isEmpty()) {	throw new CloudRuntimeException("Unable to prepare volumes for vm as ROOT volume is missing");	}	Set<Long> originalAvoidPoolSet = avoid.getPoolsToAvoid();	if (originalAvoidPoolSet == null) {	originalAvoidPoolSet = new HashSet<Long>();	}	Set<Long> poolsToAvoidOutput = new HashSet<Long>(originalAvoidPoolSet);	for (VolumeVO toBeCreated : volumesTobeCreated) {	
checking suitable pools for volume id type 

if (_volsDao.findByInstanceAndType(vmProfile.getId(), Volume.Type.ROOT).isEmpty()) {	throw new CloudRuntimeException("Unable to prepare volumes for vm as ROOT volume is missing");	}	Set<Long> originalAvoidPoolSet = avoid.getPoolsToAvoid();	if (originalAvoidPoolSet == null) {	originalAvoidPoolSet = new HashSet<Long>();	}	Set<Long> poolsToAvoidOutput = new HashSet<Long>(originalAvoidPoolSet);	for (VolumeVO toBeCreated : volumesTobeCreated) {	if (plan.getPoolId() != null || (toBeCreated.getVolumeType() == Volume.Type.DATADISK && toBeCreated.getPoolId() != null && toBeCreated.getState() == Volume.State.Ready)) {	
volume has pool already allocated checking if pool can be reused poolid 

long exstPoolClusterId = pool.getClusterId() != null ? pool.getClusterId() : -1;	boolean canReusePool = false;	if (plan.getDataCenterId() == exstPoolDcId && plan.getPodId() == exstPoolPodId && plan.getClusterId() == exstPoolClusterId) {	canReusePool = true;	} else if (plan.getDataCenterId() == exstPoolDcId) {	DataStore dataStore = dataStoreMgr.getPrimaryDataStore(pool.getId());	if (dataStore != null && dataStore.getScope() != null && dataStore.getScope().getScopeType() == ScopeType.ZONE) {	canReusePool = true;	}	} else {	
pool of the volume does not fit the specified plan need to reallocate a pool for this volume 

canReusePool = true;	} else if (plan.getDataCenterId() == exstPoolDcId) {	DataStore dataStore = dataStoreMgr.getPrimaryDataStore(pool.getId());	if (dataStore != null && dataStore.getScope() != null && dataStore.getScope().getScopeType() == ScopeType.ZONE) {	canReusePool = true;	}	} else {	canReusePool = false;	}	if (canReusePool) {	
planner need not allocate a pool for this volume since its ready 

}	if (canReusePool) {	suitablePools.add(pool);	suitableVolumeStoragePools.put(toBeCreated, suitablePools);	if (!(toBeCreated.getState() == Volume.State.Allocated || toBeCreated.getState() == Volume.State.Creating)) {	readyAndReusedVolumes.add(toBeCreated);	}	continue;	}	} else {	
pool of the volume is in avoid set need to reallocate a pool for this volume 

suitablePools.add(pool);	suitableVolumeStoragePools.put(toBeCreated, suitablePools);	if (!(toBeCreated.getState() == Volume.State.Allocated || toBeCreated.getState() == Volume.State.Creating)) {	readyAndReusedVolumes.add(toBeCreated);	}	continue;	}	} else {	}	} else {	
pool of the volume is in maintenance need to reallocate a pool for this volume 

readyAndReusedVolumes.add(toBeCreated);	}	continue;	}	} else {	}	} else {	}	}	if (s_logger.isDebugEnabled()) {	
we need to allocate new storagepool for this volume 

} else {	}	} else {	}	}	if (s_logger.isDebugEnabled()) {	}	if (!isRootAdmin(vmProfile)) {	if (!isEnabledForAllocation(plan.getDataCenterId(), plan.getPodId(), plan.getClusterId())) {	if (s_logger.isDebugEnabled()) {	
cannot allocate new storagepool for this volume in this cluster allocation state is disabled 

} else {	}	} else {	}	}	if (s_logger.isDebugEnabled()) {	}	if (!isRootAdmin(vmProfile)) {	if (!isEnabledForAllocation(plan.getDataCenterId(), plan.getPodId(), plan.getClusterId())) {	if (s_logger.isDebugEnabled()) {	
cannot deploy to this specified plan allocation state is disabled returning 

if (s_logger.isDebugEnabled()) {	}	if (!isRootAdmin(vmProfile)) {	if (!isEnabledForAllocation(plan.getDataCenterId(), plan.getPodId(), plan.getClusterId())) {	if (s_logger.isDebugEnabled()) {	}	suitableVolumeStoragePools.clear();	break;	}	}	
calling storagepoolallocators to find suitable pools 

suitableVolumeStoragePools.put(toBeCreated, suitablePools);	foundPotentialPools = true;	break;	}	}	if (avoid.getPoolsToAvoid() != null) {	poolsToAvoidOutput.addAll(avoid.getPoolsToAvoid());	avoid.getPoolsToAvoid().retainAll(originalAvoidPoolSet);	}	if (!foundPotentialPools) {	
no suitable pools found for volume under cluster 

for (List<StoragePool> lsp : suitableVolumeStoragePools.values()) {	for (StoragePool sp : lsp) {	toRemove.add(sp.getId());	}	}	poolsToAvoidOutput.removeAll(toRemove);	if (avoid.getPoolsToAvoid() != null) {	avoid.getPoolsToAvoid().addAll(poolsToAvoidOutput);	}	if (suitableVolumeStoragePools.isEmpty()) {	
no suitable pools found 

private boolean isEnabledForAllocation(long zoneId, Long podId, Long clusterId) {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone != null && Grouping.AllocationState.Disabled == zone.getAllocationState()) {	
zone is currently disabled cannot allocate to this zone 

private boolean isEnabledForAllocation(long zoneId, Long podId, Long clusterId) {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone != null && Grouping.AllocationState.Disabled == zone.getAllocationState()) {	return false;	}	Pod pod = _podDao.findById(podId);	if (pod != null && Grouping.AllocationState.Disabled == pod.getAllocationState()) {	
pod is currently disabled cannot allocate to this pod 

DataCenterVO zone = _dcDao.findById(zoneId);	if (zone != null && Grouping.AllocationState.Disabled == zone.getAllocationState()) {	return false;	}	Pod pod = _podDao.findById(podId);	if (pod != null && Grouping.AllocationState.Disabled == pod.getAllocationState()) {	return false;	}	Cluster cluster = _clusterDao.findById(clusterId);	if (cluster != null && Grouping.AllocationState.Disabled == cluster.getAllocationState()) {	
cluster is currently disabled cannot allocate to this cluster 

========================= cloudstack sample_2272 =========================

eventDescription.put("podId", null);	}	eventDescription.put("subject", subject);	eventDescription.put("body", body);	String eventDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").format(new Date());	eventDescription.put("eventDateTime", eventDate);	event.setDescription(eventDescription);	try {	s_eventBus.publish(event);	} catch (EventBusException e) {	
failed to publish alert on the the event bus 

========================= cloudstack sample_2622 =========================

return null;	} else {	_callbackMethod = arg1;	_callbackMethod.setAccessible(true);	return null;	}	}	});	return t;	} catch (Throwable e) {	
unexpected exception 

========================= cloudstack sample_610 =========================

if (registered.size() <= i) {	break;	}	if (RegistryUtils.getName(registered.get(i)).equals(orderTest)) {	i++;	}	}	if (i != -1) {	registered.add(item);	}	
registering extension in 

========================= cloudstack sample_755 =========================

public void decrRefCnt() {	if (refCnt > 0) {	refCnt--;	}	else {	
we should not try to decrement a zero reference count even though our code has guarded 

========================= cloudstack sample_4060 =========================

private String executeMethod(HttpRequestBase req, String path) {	try {	URI base = new URI(apiUrl);	req.setURI(new URI(base.getScheme(), base.getUserInfo(), base.getHost(), base.getPort(), path, null, null));	} catch (URISyntaxException e) {	
invalid api url path 

try {	URI base = new URI(apiUrl);	req.setURI(new URI(base.getScheme(), base.getUserInfo(), base.getHost(), base.getPort(), path, null, null));	} catch (URISyntaxException e) {	return null;	}	try {	String content = null;	try {	content = getHttpClient().execute(req, new BasicResponseHandler());	
ssp api call 

URI base = new URI(apiUrl);	req.setURI(new URI(base.getScheme(), base.getUserInfo(), base.getHost(), base.getPort(), path, null, null));	} catch (URISyntaxException e) {	return null;	}	try {	String content = null;	try {	content = getHttpClient().execute(req, new BasicResponseHandler());	} catch (HttpResponseException e) {	
ssp api call failed 

return null;	}	try {	String content = null;	try {	content = getHttpClient().execute(req, new BasicResponseHandler());	} catch (HttpResponseException e) {	if (e.getStatusCode() == HttpStatus.SC_UNAUTHORIZED && login()) {	req.reset();	content = getHttpClient().execute(req, new BasicResponseHandler());	
ssp api retry call 

try {	content = getHttpClient().execute(req, new BasicResponseHandler());	} catch (HttpResponseException e) {	if (e.getStatusCode() == HttpStatus.SC_UNAUTHORIZED && login()) {	req.reset();	content = getHttpClient().execute(req, new BasicResponseHandler());	}	}	return content;	} catch (ClientProtocolException e) {	
ssp api call failed 

content = getHttpClient().execute(req, new BasicResponseHandler());	} catch (HttpResponseException e) {	if (e.getStatusCode() == HttpStatus.SC_UNAUTHORIZED && login()) {	req.reset();	content = getHttpClient().execute(req, new BasicResponseHandler());	}	}	return content;	} catch (ClientProtocolException e) {	} catch (IOException e) {	
ssp api call failed 

========================= cloudstack sample_1425 =========================

final KVMHAChecker ha = new KVMHAChecker(pools, command.getHostIp());	final Future<Boolean> future = executors.submit(ha);	try {	final Boolean result = future.get();	if (result) {	return new FenceAnswer(command, false, "Heart is still beating...");	} else {	return new FenceAnswer(command);	}	} catch (final InterruptedException e) {	
unable to fence 

try {	final Boolean result = future.get();	if (result) {	return new FenceAnswer(command, false, "Heart is still beating...");	} else {	return new FenceAnswer(command);	}	} catch (final InterruptedException e) {	return new FenceAnswer(command, false, e.getMessage());	} catch (final ExecutionException e) {	
unable to fence 

========================= cloudstack sample_1075 =========================

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	super.configure(name, params);	String timeZoneStr = _configDao.getValue(Config.UsageAggregationTimezone.toString());	String aggregationRange = _configDao.getValue(Config.UsageStatsJobAggregationRange.toString());	if (timeZoneStr == null) {	timeZoneStr = "GMT";	}	_usageTimezone = TimeZone.getTimeZone(timeZoneStr);	_aggregationDuration = Integer.parseInt(aggregationRange);	if (_aggregationDuration < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) {	
usage stats job aggregation range is to small using the minimum value of 

throw new InvalidParameterValueException("Unable to find account " + accountName + " in domain " + domainId);	}	} else {	throw new PermissionDeniedException("Invalid Domain Id or Account");	}	}	startDate = startDate == null ? new Date() : startDate;	if (endDate == null) {	Date adjustedStartDate = computeAdjustedTime(_respBldr.startOfNextDay(startDate));	if (s_logger.isDebugEnabled()) {	
getting quota balance records for account domainid on or before 

startDate = startDate == null ? new Date() : startDate;	if (endDate == null) {	Date adjustedStartDate = computeAdjustedTime(_respBldr.startOfNextDay(startDate));	if (s_logger.isDebugEnabled()) {	}	List<QuotaBalanceVO> qbrecords = _quotaBalanceDao.lastQuotaBalanceVO(accountId, domainId, adjustedStartDate);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Found records size=" + qbrecords.size());	}	if (qbrecords.isEmpty()) {	
incorrect date there are no quota records before this date 

} else {	return qbrecords;	}	} else {	Date adjustedStartDate = computeAdjustedTime(startDate);	if (endDate.after(_respBldr.startOfNextDay())) {	throw new InvalidParameterValueException("Incorrect Date Range. End date:" + endDate + " should not be in future. ");	} else if (startDate.before(endDate)) {	Date adjustedEndDate = computeAdjustedTime(endDate);	if (s_logger.isDebugEnabled()) {	
getting quota balance records for account domainid between and 

throw new InvalidParameterValueException("Incorrect Date Range. End date:" + endDate + " should not be in future. ");	} else if (startDate.before(endDate)) {	Date adjustedEndDate = computeAdjustedTime(endDate);	if (s_logger.isDebugEnabled()) {	}	List<QuotaBalanceVO> qbrecords = _quotaBalanceDao.findQuotaBalance(accountId, domainId, adjustedStartDate, adjustedEndDate);	if (s_logger.isDebugEnabled()) {	s_logger.debug("getQuotaBalance3: Found records size=" + qbrecords.size());	}	if (qbrecords.isEmpty()) {	
there are no quota records between these dates start date and end date 

}	if (startDate.after(endDate)) {	throw new InvalidParameterValueException("Incorrect Date Range. Start date: " + startDate + " is after end date:" + endDate);	}	if (endDate.after(_respBldr.startOfNextDay())) {	throw new InvalidParameterValueException("Incorrect Date Range. End date:" + endDate + " should not be in future. ");	}	Date adjustedEndDate = computeAdjustedTime(endDate);	Date adjustedStartDate = computeAdjustedTime(startDate);	if (s_logger.isDebugEnabled()) {	
getting quota records for account domainid between and 

========================= cloudstack sample_811 =========================

public ScpTemplateDownloader(StorageLayer storageLayer, String downloadUrl, String toDir, long maxTemplateSizeInBytes, DownloadCompleteCallback callback) {	super(storageLayer, downloadUrl, toDir, maxTemplateSizeInBytes, callback);	URI uri;	try {	uri = new URI(_downloadUrl);	} catch (URISyntaxException e) {	
uri syntax error 

sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(username, password)) {	throw new CloudRuntimeException("Unable to authenticate");	}	SCPClient scp = new SCPClient(sshConnection);	String src = uri.getPath();	_status = Status.IN_PROGRESS;	scp.get(src, _toDir);	if (!file.exists()) {	_status = Status.UNRECOVERABLE_ERROR;	
unable to scp the file 

_status = Status.UNRECOVERABLE_ERROR;	return 0;	}	_status = Status.DOWNLOAD_FINISHED;	_totalBytes = file.length();	String downloaded = "(download complete)";	_errorString = "Downloaded " + _remoteSize + " bytes " + downloaded;	_downloadTime += System.currentTimeMillis() - _start;	return _totalBytes;	} catch (Exception e) {	
unable to download 

========================= cloudstack sample_407 =========================

public void runJob(final AsyncJob job) {	_testDashboard.increaseConcurrency();	
execute job current concurrency 

public void runJob(final AsyncJob job) {	_testDashboard.increaseConcurrency();	int interval = 3000;	try {	Thread.sleep(interval);	} catch (InterruptedException e) {	
ignored 

========================= cloudstack sample_684 =========================

getDownloadListener().log("handleTimeout, updateMs=" + updateMs + ", curr state= " + getName(), Level.TRACE);	}	String newState = getName();	if (updateMs > 5 * DownloadListener.STATUS_POLL_INTERVAL) {	newState = Status.DOWNLOAD_ERROR.toString();	getDownloadListener().log("timeout: transitioning to download error state, currstate=" + getName(), Level.DEBUG);	} else if (updateMs > 3 * DownloadListener.STATUS_POLL_INTERVAL) {	getDownloadListener().cancelStatusTask();	getDownloadListener().scheduleImmediateStatusCheck(RequestType.GET_STATUS);	getDownloadListener().scheduleTimeoutTask(3 * DownloadListener.STATUS_POLL_INTERVAL);	
first timeout checking again 

========================= cloudstack sample_2435 =========================

public Answer execute(final DeleteVMSnapshotCommand command, final CitrixResourceBase citrixResourceBase) {	final String snapshotName = command.getTarget().getSnapshotName();	final Connection conn = citrixResourceBase.getConnection();	try {	final List<VDI> vdiList = new ArrayList<VDI>();	final Set<VM> snapshots = VM.getByNameLabel(conn, snapshotName);	if (snapshots == null || snapshots.size() == 0) {	
vm snapshot with name does not exist assume it is already deleted 

try {	Thread.sleep(5000);	} catch (final InterruptedException ex) {	}	for (final VolumeObjectTO volumeTo : command.getVolumeTOs()) {	final long size = citrixResourceBase.getVMSnapshotChainSize(conn, volumeTo, command.getVmName());	volumeTo.setSize(size);	}	return new DeleteVMSnapshotAnswer(command, command.getVolumeTOs());	} catch (final Exception e) {	
catch exception due to 

========================= cloudstack sample_1219 =========================

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	
we currently don t handle conversion from to raw image 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	return null;	}	String imgPath = templatePath + File.separator + templateName + "." + ImageFormat.RAW.getFileExtension();	if (!_storage.exists(imgPath)) {	
unable to find raw image 

}	String imgPath = templatePath + File.separator + templateName + "." + ImageFormat.RAW.getFileExtension();	if (!_storage.exists(imgPath)) {	return null;	}	FormatInfo info = new FormatInfo();	info.format = ImageFormat.RAW;	info.filename = templateName + "." + ImageFormat.RAW.getFileExtension();	info.size = _storage.getSize(imgPath);	info.virtualSize = info.size;	
process raw image successfully 

========================= cloudstack sample_391 =========================

private void createIAMCache(final Map<String, ? extends Object> params) {	final String value = (String)params.get("cache.size");	if (value != null) {	final CacheManager cm = CacheManager.create();	final int maxElements = NumbersUtil.parseInt(value, 0);	final int live = NumbersUtil.parseInt((String)params.get("cache.time.to.live"), 300);	final int idle = NumbersUtil.parseInt((String)params.get("cache.time.to.idle"), 300);	_iamCache = new Cache(getName(), maxElements, false, live == -1, live == -1 ? Integer.MAX_VALUE : live, idle);	cm.addCache(_iamCache);	
iam cache created 

public void addToIAMCache(Object accessKey, Object allowDeny) {	if (_iamCache != null) {	try {	
put iam access check for in cache 

public void addToIAMCache(Object accessKey, Object allowDeny) {	if (_iamCache != null) {	try {	_iamCache.put(new Element(accessKey, allowDeny));	} catch (final Exception e) {	
can t put to iam cache 

public void invalidateIAMCache() {	if (_iamCache != null) {	
invalidate iam cache 

========================= cloudstack sample_5061 =========================

private void takeOwnership(Pool pool) throws ConfigurationException {	try {	
take ownership of host 

private void takeOwnership33x(Pool pool) throws ConfigurationException {	try {	
take ownership of host 

public boolean prepareForPool() throws ConfigurationException {	try {	Linux host = new Linux(c);	Pool pool = new Pool(c);	if (host.getServerRoles().contentEquals( pool.getValidRoles().toString())) {	
server role for host is ok 

String fsType = "nfs";	String clusterUuid = config.getAgentOwnedByUuid().substring(0, 15);	String managerId = config.getAgentOwnedByUuid();	String poolAlias = cmd.getHost() + ":" + cmd.getPath();	String mountPoint = String.format("%1$s:%2$s", cmd.getHost(), cmd.getPath()) + "/VirtualMachines";	Integer poolSize = 0;	Pool poolHost = new Pool(c);	PoolOCFS2 poolFs = new PoolOCFS2(c);	if (config.getAgentIsMaster()) {	try {	
create poolfs on for repo 

List<String> members = new ArrayList<String>();	try {	Connection m = new Connection(config.getOvm3PoolVip(), c.getPort(), c.getUserName(), c.getPassword());	Pool poolMaster = new Pool(m);	if (poolMaster.isInAPool()) {	members.addAll(poolMaster.getPoolMemberList());	if (!poolMaster.getPoolMemberList().contains(c.getIp()) && c.getIp().equals(config.getOvm3PoolVip())) {	members.add(c.getIp());	}	} else {	
noticed master is not part of pool 

members.add(c.getIp());	}	} else {	return false;	}	for (String member : members) {	Connection x = new Connection(member, c.getPort(), c.getUserName(), c.getPassword());	Pool poolM = new Pool(x);	if (poolM.isInAPool()) {	poolM.setPoolMemberList(members);	
added to pool on member 

}	} else {	return false;	}	for (String member : members) {	Connection x = new Connection(member, c.getPort(), c.getUserName(), c.getPassword());	Pool poolM = new Pool(x);	if (poolM.isInAPool()) {	poolM.setPoolMemberList(members);	} else {	
unable to be member of a pool it s not in 

public Answer execute(DeleteStoragePoolCommand cmd) {	try {	Pool pool = new Pool(c);	pool.leaveServerPool(cmd.getPool().getUuid());	} catch (Ovm3ResourceException e) {	
delete storage pool on host failed however we leave to user for cleanup and tell managment server it succeeded 

Repository repo = new Repository(c);	String primUuid = repo.deDash(cmd.getUuid());	String ovsRepo = basePath + "/" + primUuid;	String mountPoint = String.format("%1$s:%2$s", cmd.getHost(), cmd.getPath());	String msg;	if (cmd.getType() == StoragePoolType.NetworkFilesystem) {	Boolean repoExists = false;	try {	repo.mountRepoFs(mountPoint, ovsRepo);	} catch (Ovm3ResourceException e) {	
unable to mount nfs repository on requested for 

if (cmd.getType() == StoragePoolType.NetworkFilesystem) {	Boolean repoExists = false;	try {	repo.mountRepoFs(mountPoint, ovsRepo);	} catch (Ovm3ResourceException e) {	}	try {	repo.addRepo(mountPoint, ovsRepo);	repoExists = true;	} catch (Ovm3ResourceException e) {	
nfs repository on not found creating repo 

private void prepareSecondaryStorageStore(String storageUrl, String poolUuid, String host) {	String mountPoint = storageUrl;	GlobalLock lock = GlobalLock.getInternLock("prepare.systemvm");	try {	if (config.getAgentHasMaster() && config.getAgentInOvm3Pool()) {	
skip systemvm iso copy leave it to the master 

return;	}	if (lock.lock(3600)) {	try {	File srcIso = getSystemVMPatchIsoFile();	String destPath = mountPoint + "/ISOs/";	try {	StoragePlugin sp = new StoragePlugin(c);	FileProperties fp = sp.storagePluginGetFileInfo( poolUuid, host, destPath + "/" + srcIso.getName());	if (fp.getSize() != srcIso.getTotalSpace()) {	
system vm patch iso file already exists destination 

if (lock.lock(3600)) {	try {	File srcIso = getSystemVMPatchIsoFile();	String destPath = mountPoint + "/ISOs/";	try {	StoragePlugin sp = new StoragePlugin(c);	FileProperties fp = sp.storagePluginGetFileInfo( poolUuid, host, destPath + "/" + srcIso.getName());	if (fp.getSize() != srcIso.getTotalSpace()) {	}	} catch (Exception e) {	
copy system vm patch iso file to secondary storage source iso destination 

String destPath = mountPoint + "/ISOs/";	try {	StoragePlugin sp = new StoragePlugin(c);	FileProperties fp = sp.storagePluginGetFileInfo( poolUuid, host, destPath + "/" + srcIso.getName());	if (fp.getSize() != srcIso.getTotalSpace()) {	}	} catch (Exception e) {	try {	SshHelper .scpTo(c.getIp(), 22, config .getAgentSshUserName(), null, config.getAgentSshPassword(), destPath, srcIso.getAbsolutePath() .toString(), "0644");	} catch (Exception es) {	
unexpected exception 

public String setupSecondaryStorage(String url) throws Ovm3ResourceException {	URI uri = URI.create(url);	if (uri.getHost() == null) {	throw new Ovm3ResourceException( "Secondary storage host can not be empty!");	}	String uuid = ovmObject.newUuid(uri.getHost() + ":" + uri.getPath());	
secondary storage with uuid 

public GetStorageStatsAnswer execute(final GetStorageStatsCommand cmd) {	
getting stats for 

StorageDetails sd = store.storagePluginGetFileSystemInfo(propUuid, mntUuid, fs.getHost(), fs.getDevice());	if ("".equals(sd.getSize())) {	String msg = "No size when retrieving stats for " + cmd.getStorageId();	LOGGER.debug(msg);	return new GetStorageStatsAnswer(cmd, msg);	}	long total = Long.parseLong(sd.getSize());	long used = total - Long.parseLong(sd.getFreeSize());	return new GetStorageStatsAnswer(cmd, total, used);	} catch (Ovm3ResourceException e) {	
getstoragestatscommand for failed 

public File getSystemVMPatchIsoFile() {	String iso = "systemvm.iso";	String systemVmIsoPath = Script.findScript("", "vms/" + iso);	File isoFile = null;	if (systemVmIsoPath != null) {	
found systemvm patch iso 

public File getSystemVMPatchIsoFile() {	String iso = "systemvm.iso";	String systemVmIsoPath = Script.findScript("", "vms/" + iso);	File isoFile = null;	if (systemVmIsoPath != null) {	isoFile = new File(systemVmIsoPath);	}	if (isoFile == null || !isoFile.exists()) {	String svm = "client/target/generated-webapp/WEB-INF/classes/vms/" + iso;	
last resort for systemvm patch iso 

File isoFile = null;	if (systemVmIsoPath != null) {	isoFile = new File(systemVmIsoPath);	}	if (isoFile == null || !isoFile.exists()) {	String svm = "client/target/generated-webapp/WEB-INF/classes/vms/" + iso;	isoFile = new File(svm);	}	assert isoFile != null;	if (!isoFile.exists()) {	
unable to locate in your setup at 

private Boolean createOCFS2Sr(StorageFilerTO pool) throws XmlRpcException {	
not implemented yet 

public Answer execute(ModifyStoragePoolCommand cmd) {	StorageFilerTO pool = cmd.getPool();	
modifying pool 

String nfsHost = pool.getHost();	String nfsPath = pool.getPath();	StorageDetails ss = store.storagePluginGetFileSystemInfo( propUuid, mntUuid, nfsHost, nfsPath);	Map<String, TemplateProp> tInfo = new HashMap<String, TemplateProp>();	return new ModifyStoragePoolAnswer(cmd, Long.parseLong(ss .getSize()), Long.parseLong(ss.getFreeSize()), tInfo);	} else if (pool.getType() == StoragePoolType.OCFS2) {	createOCFS2Sr(pool);	}	return new Answer(cmd, false, "The pool type: " + pool.getType().name() + " is not supported.");	} catch (Exception e) {	
modifystoragepoolcommand failed 

public Answer execute(CreateStoragePoolCommand cmd) {	StorageFilerTO pool = cmd.getPool();	
creating pool 

public Answer execute(CreateStoragePoolCommand cmd) {	StorageFilerTO pool = cmd.getPool();	try {	if (pool.getType() == StoragePoolType.NetworkFilesystem) {	createRepo(pool);	} else if (pool.getType() == StoragePoolType.IscsiLUN) {	return new Answer(cmd, false, "iSCSI is unsupported at the moment");	} else if (pool.getType() == StoragePoolType.OCFS2) {	return new Answer(cmd, false, "OCFS2 is unsupported at the moment");	} else if (pool.getType() == StoragePoolType.PreSetup) {	
pre setup for pool 

public PrimaryStorageDownloadAnswer execute( final PrimaryStorageDownloadCommand cmd) {	try {	Repository repo = new Repository(c);	String tmplturl = cmd.getUrl();	String poolName = cmd.getPoolUuid();	String image = repo.deDash(repo.newUuid()) + ".raw";	repo.importVirtualDisk(tmplturl, image, poolName);	return new PrimaryStorageDownloadAnswer(image);	} catch (Exception e) {	
primarystoragedownloadcommand failed 

========================= cloudstack sample_846 =========================

pstmt = conn.prepareStatement("select distinct(hypervisor_type) from `cloud`.`cluster` where removed is null");	rs = pstmt.executeQuery();	while (rs.next()) {	if ("VMware".equals(rs.getString(1))) {	VMware = true;	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Error while iterating through list of hypervisors in use", e);	}	
updating vmware system vms 

pstmt.executeUpdate();	pstmt.close();	pstmt = conn.prepareStatement("update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = 'VMware'");	pstmt.setLong(1, templateId);	pstmt.executeUpdate();	pstmt.close();	} else {	if (VMware) {	throw new CloudRuntimeException("3.0.5 VMware SystemVm template not found. Cannot upgrade system Vms");	} else {	
vmware systemvm template not found vmware hypervisor is not used so not failing upgrade 

pstmt.close();	} else {	if (VMware) {	throw new CloudRuntimeException("3.0.5 VMware SystemVm template not found. Cannot upgrade system Vms");	} else {	}	}	} catch (SQLException e) {	throw new CloudRuntimeException("Error while updating VMware systemVm template", e);	}	
updating system vm template ids complete 

private void addVpcProvider(Connection conn) {	
adding vpc provider to all physical networks in the system 

pstmt.setLong(1, providerId);	pstmt.executeUpdate();	s_logger.debug("Added VPC Virtual router provider for physical network id=" + pNtwkId);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable add VPC physical network service provider ", e);	} finally {	closeAutoCloseable(rs);	closeAutoCloseable(pstmt);	}	
done adding vpc physical network service providers to all physical networks 

private void updateRouterNetworkRef(Connection conn) {	
updating router network ref 

pstmt.setString(3, networkType);	pstmt.executeUpdate();	s_logger.debug("Added reference for router id=" + routerId + " and network id=" + networkId);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Failed to update the router/network reference ", e);	} finally {	closeAutoCloseable(rs);	closeAutoCloseable(pstmt);	}	
done updating router network references 

private void addHostDetailsUniqueKey(Connection conn) {	
checking if host details unique key exists if not we will add it 

private void addHostDetailsUniqueKey(Connection conn) {	PreparedStatement pstmt = null;	ResultSet rs = null;	try {	pstmt = conn.prepareStatement("SHOW INDEX FROM `cloud`.`host_details` WHERE KEY_NAME = 'uk_host_id_name'");	rs = pstmt.executeQuery();	if (rs.next()) {	
unique key already exists on host details not adding new one 

private void addHostDetailsUniqueKey(Connection conn) {	PreparedStatement pstmt = null;	ResultSet rs = null;	try {	pstmt = conn.prepareStatement("SHOW INDEX FROM `cloud`.`host_details` WHERE KEY_NAME = 'uk_host_id_name'");	rs = pstmt.executeQuery();	if (rs.next()) {	} else {	PreparedStatement pstmtUpdate = conn.prepareStatement("ALTER IGNORE TABLE `cloud`.`host_details` ADD CONSTRAINT UNIQUE KEY `uk_host_id_name` (`host_id`, `name`)");	pstmtUpdate.executeUpdate();	
unique key did not exist on host details added new one 

pstmt.setLong(2, networkOfferingId);	rs = pstmt.executeQuery();	while (rs.next()) {	networkId = rs.getLong(1);	String insertLbMapping = "INSERT INTO `cloud`.`network_external_lb_device_map` (uuid, network_id, external_load_balancer_device_id, created) VALUES ( ?, ?, ?, now())";	pstmtUpdate = conn.prepareStatement(insertLbMapping);	pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, f5DeviceId);	pstmtUpdate.executeUpdate();	
successfully added entry in network external lb device map for network and device id 

pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, f5DeviceId);	pstmtUpdate.executeUpdate();	String insertFwMapping = "INSERT INTO `cloud`.`network_external_firewall_device_map` (uuid, network_id, external_firewall_device_id, created) VALUES ( ?, ?, ?, now())";	pstmtUpdate = conn.prepareStatement(insertFwMapping);	pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, srxDevivceId);	pstmtUpdate.executeUpdate();	
successfully added entry in network external firewall device map for network and srx device id 

pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, f5DeviceId);	pstmtUpdate.executeUpdate();	String insertFwMapping = "INSERT INTO `cloud`.`network_external_firewall_device_map` (uuid, network_id, external_firewall_device_id, created) VALUES ( ?, ?, ?, now())";	pstmtUpdate = conn.prepareStatement(insertFwMapping);	pstmtUpdate.setString(1, UUID.randomUUID().toString());	pstmtUpdate.setLong(2, networkId);	pstmtUpdate.setLong(3, srxDevivceId);	pstmtUpdate.executeUpdate();	}	
updating the host details for and srx devices 

if (!(camlCaseName.equalsIgnoreCase("numRetries") || camlCaseName.equalsIgnoreCase("publicZone") || camlCaseName.equalsIgnoreCase("privateZone") || camlCaseName.equalsIgnoreCase("publicInterface") || camlCaseName.equalsIgnoreCase("privateInterface") || camlCaseName.equalsIgnoreCase("usageInterface"))) {	continue;	}	String lowerCaseName = camlCaseName.toLowerCase();	pstmt = conn.prepareStatement("update `cloud`.`host_details` set name=? where host_id=? AND name=?");	pstmt.setString(1, lowerCaseName);	pstmt.setLong(2, hostId);	pstmt.setString(3, camlCaseName);	pstmt.executeUpdate();	}	
successfully updated host details for and srx devices 

pstmt.setLong(2, hostId);	pstmt.setString(3, camlCaseName);	pstmt.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable create a mapping for the networks in network_external_lb_device_map and network_external_firewall_device_map", e);	} finally {	closeAutoCloseable(rs);	closeAutoCloseable(pstmt);	}	
successfully upgraded network using and srx devices to have a entry in the network external lb device map and network external firewall device map 

private void fixForeignKeys(Connection conn) {	
fixing foreign keys names in ssh keypairs table 

private void encryptClusterDetails(Connection conn) {	
encrypting cluster details 

pstmt.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt cluster_details values ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt cluster_details values ", e);	} finally {	closeAutoCloseable(rs);	closeAutoCloseable(pstmt);	}	
done encrypting cluster details 

========================= cloudstack sample_4220 =========================

throw new InternalErrorException("Nicira NVP Logicalswitches are not supported by the BridgeVifDriver");	}	String trafficLabel = nic.getName();	Integer networkRateKBps = 0;	if (libvirtVersion > ((10 * 1000 + 10))) {	networkRateKBps = (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) ? nic.getNetworkRateMbps().intValue() * 128 : 0;	}	if (nic.getType() == Networks.TrafficType.Guest) {	if ((nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan) && (vNetId != null) && (protocol != null) && (!vNetId.equalsIgnoreCase("untagged")) || (nic.getBroadcastType() == Networks.BroadcastDomainType.Vxlan)) {	if (trafficLabel != null && !trafficLabel.isEmpty()) {	
creating a vnet dev and bridge for guest traffic per traffic label 

brname = _bridges.get("guest");	}	intf.defBridgeNet(brname, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);	}	} else if (nic.getType() == Networks.TrafficType.Control) {	createControlNetwork();	intf.defBridgeNet(_bridges.get("linklocal"), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter));	} else if (nic.getType() == Networks.TrafficType.Public) {	if ((nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan) && (vNetId != null) && (protocol != null) && (!vNetId.equalsIgnoreCase("untagged")) || (nic.getBroadcastType() == Networks.BroadcastDomainType.Vxlan)) {	if (trafficLabel != null && !trafficLabel.isEmpty()) {	
creating a vnet dev and bridge for public traffic per traffic label 

vNetId = oldStyleBrNameMatcher.group(1);	} else if (brNameMatcher.find()) {	if (brNameMatcher.group(1) != null || !brNameMatcher.group(1).isEmpty()) {	pName = brNameMatcher.group(1);	} else {	pName = "undefined";	}	vNetId = brNameMatcher.group(2);	}	if (vNetId == null || vNetId.isEmpty()) {	
unable to get a vnet id from name 

} else {	scriptPath = _modifyVlanPath;	}	final Script command = new Script(scriptPath, _timeout, s_logger);	command.add("-o", "delete");	command.add("-v", vNetId);	command.add("-p", pName);	command.add("-b", brName);	final String result = command.execute();	if (result != null) {	
delete bridge failed 

========================= cloudstack sample_1022 =========================

final String op = command.getOp();	final String dhcpName = command.getDhcpName();	final String dhcpMac = command.getDhcpMac();	final String dhcpIp = command.getDhcpIp();	final String vmMac = command.getVmMac();	final String networkTag = command.getNetworkTag();	String nwNameLabel = null;	try {	final XsLocalNetwork nw = citrixResourceBase.getNativeNetworkForTraffic(conn, TrafficType.Guest, networkTag);	if (nw == null) {	
network is not configured on the backend for pvlan 

final String vmMac = command.getVmMac();	final String networkTag = command.getNetworkTag();	String nwNameLabel = null;	try {	final XsLocalNetwork nw = citrixResourceBase.getNativeNetworkForTraffic(conn, TrafficType.Guest, networkTag);	if (nw == null) {	throw new CloudRuntimeException("Network for the backend is not configured correctly for pvlan primary: " + primaryPvlan);	}	nwNameLabel = nw.getNetwork().getNameLabel(conn);	} catch (final XenAPIException e) {	
fail to get network 

String nwNameLabel = null;	try {	final XsLocalNetwork nw = citrixResourceBase.getNativeNetworkForTraffic(conn, TrafficType.Guest, networkTag);	if (nw == null) {	throw new CloudRuntimeException("Network for the backend is not configured correctly for pvlan primary: " + primaryPvlan);	}	nwNameLabel = nw.getNetwork().getNameLabel(conn);	} catch (final XenAPIException e) {	return new Answer(command, false, e.toString());	} catch (final XmlRpcException e) {	
fail to get network 

nwNameLabel = nw.getNetwork().getNameLabel(conn);	} catch (final XenAPIException e) {	return new Answer(command, false, e.toString());	} catch (final XmlRpcException e) {	return new Answer(command, false, e.toString());	}	String result = null;	if (command.getType() == PvlanSetupCommand.Type.DHCP) {	result = citrixResourceBase.callHostPlugin(conn, "ovs-pvlan", "setup-pvlan-dhcp", "op", op, "nw-label", nwNameLabel, "primary-pvlan", primaryPvlan, "isolated-pvlan", isolatedPvlan, "dhcp-name", dhcpName, "dhcp-ip", dhcpIp, "dhcp-mac", dhcpMac);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	
failed to program pvlan for dhcp server with mac 

return new Answer(command, false, e.toString());	} catch (final XmlRpcException e) {	return new Answer(command, false, e.toString());	}	String result = null;	if (command.getType() == PvlanSetupCommand.Type.DHCP) {	result = citrixResourceBase.callHostPlugin(conn, "ovs-pvlan", "setup-pvlan-dhcp", "op", op, "nw-label", nwNameLabel, "primary-pvlan", primaryPvlan, "isolated-pvlan", isolatedPvlan, "dhcp-name", dhcpName, "dhcp-ip", dhcpIp, "dhcp-mac", dhcpMac);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	return new Answer(command, false, result);	} else {	
programmed pvlan for dhcp server with mac 

String result = null;	if (command.getType() == PvlanSetupCommand.Type.DHCP) {	result = citrixResourceBase.callHostPlugin(conn, "ovs-pvlan", "setup-pvlan-dhcp", "op", op, "nw-label", nwNameLabel, "primary-pvlan", primaryPvlan, "isolated-pvlan", isolatedPvlan, "dhcp-name", dhcpName, "dhcp-ip", dhcpIp, "dhcp-mac", dhcpMac);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	return new Answer(command, false, result);	} else {	}	} else if (command.getType() == PvlanSetupCommand.Type.VM) {	result = citrixResourceBase.callHostPlugin(conn, "ovs-pvlan", "setup-pvlan-vm", "op", op, "nw-label", nwNameLabel, "primary-pvlan", primaryPvlan, "isolated-pvlan", isolatedPvlan, "vm-mac", vmMac);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	
failed to program pvlan for vm with mac 

result = citrixResourceBase.callHostPlugin(conn, "ovs-pvlan", "setup-pvlan-dhcp", "op", op, "nw-label", nwNameLabel, "primary-pvlan", primaryPvlan, "isolated-pvlan", isolatedPvlan, "dhcp-name", dhcpName, "dhcp-ip", dhcpIp, "dhcp-mac", dhcpMac);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	return new Answer(command, false, result);	} else {	}	} else if (command.getType() == PvlanSetupCommand.Type.VM) {	result = citrixResourceBase.callHostPlugin(conn, "ovs-pvlan", "setup-pvlan-vm", "op", op, "nw-label", nwNameLabel, "primary-pvlan", primaryPvlan, "isolated-pvlan", isolatedPvlan, "vm-mac", vmMac);	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	return new Answer(command, false, result);	} else {	
programmed pvlan for vm with mac 

========================= cloudstack sample_1188 =========================

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(),physnet)) {	
refusing to design this network 

public Network implement(Network network, NetworkOffering offering, DeployDestination destination, ReservationContext context) throws InsufficientVirtualNetworkCapacityException {	
implement network traffic type 

VirtualNetworkModel vnModel = _manager.getDatabase().lookupVirtualNetwork(network.getUuid(), _manager.getCanonicalName(network), network.getTrafficType());	if (vnModel == null) {	vnModel = new VirtualNetworkModel(network, network.getUuid(), _manager.getCanonicalName(network), network.getTrafficType());	vnModel.setProperties(_manager.getModelController(), network);	}	try {	if (!vnModel.verify(_manager.getModelController())) {	vnModel.update(_manager.getModelController());	}	} catch (Exception ex) {	
virtual network update 

if (!vnModel.verify(_manager.getModelController())) {	vnModel.update(_manager.getModelController());	}	} catch (Exception ex) {	return network;	}	_manager.getDatabase().getVirtualNetworks().add(vnModel);	if (network.getVpcId() != null) {	List<IPAddressVO> ips = _ipAddressDao.listByAssociatedVpc(network.getVpcId(), true);	if (ips.isEmpty()) {	
creating a source nat ip for network 

if (ips.isEmpty()) {	Account owner = _accountMgr.getAccount(network.getAccountId());	try {	PublicIp publicIp = _ipAddrMgr.assignSourceNatIpAddressToGuestNetwork(owner, network);	IPAddressVO ip = publicIp.ip();	ip.setVpcId(network.getVpcId());	_ipAddressDao.acquireInLockTable(ip.getId());	_ipAddressDao.update(ip.getId(), ip);	_ipAddressDao.releaseFromLockTable(ip.getId());	} catch (Exception e) {	
unable to allocate source nat ip 

public NicProfile allocate(Network network, NicProfile profile, VirtualMachineProfile vm) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException, ConcurrentOperationException {	
allocate nicprofile on 

if (profile != null && profile.getRequestedIPv4() != null) {	throw new CloudRuntimeException("Does not support custom ip allocation at this time: " + profile);	}	if (profile == null) {	profile = new NicProfile(ReservationStrategy.Create, null, null, null, null);	}	profile.setReservationStrategy(ReservationStrategy.Start);	URI broadcastUri = null;	try {	broadcastUri = new URI("vlan: } catch (Exception e) {	
unable to instantiate broadcast uri 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException, ConcurrentOperationException {	
reserve nicprofile on network id 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException, ConcurrentOperationException {	
deviceid 

VMInterfaceModel vmiModel = vmModel.getVMInterface(nicVO.getUuid());	if (vmiModel == null) {	vmiModel = new VMInterfaceModel(nicVO.getUuid());	vmiModel.addToVirtualMachine(vmModel);	vmiModel.addToVirtualNetwork(vnModel);	}	try {	vmiModel.build(_manager.getModelController(), (VMInstanceVO)vm.getVirtualMachine(), nicVO);	vmiModel.setActive();	} catch (IOException ex) {	
virtual machine interface set 

vmiModel.build(_manager.getModelController(), (VMInstanceVO)vm.getVirtualMachine(), nicVO);	vmiModel.setActive();	} catch (IOException ex) {	return;	}	InstanceIpModel ipModel = vmiModel.getInstanceIp();	if (ipModel == null) {	ipModel = new InstanceIpModel(vm.getInstanceName(), nic.getDeviceId());	ipModel.addToVMInterface(vmiModel);	} else {	
reuse existing instance ip object on 

} catch (IOException ex) {	return;	}	InstanceIpModel ipModel = vmiModel.getInstanceIp();	if (ipModel == null) {	ipModel = new InstanceIpModel(vm.getInstanceName(), nic.getDeviceId());	ipModel.addToVMInterface(vmiModel);	} else {	}	if (nic.getIPv4Address() != null) {	
nic using existing ip address 

ipModel = new InstanceIpModel(vm.getInstanceName(), nic.getDeviceId());	ipModel.addToVMInterface(vmiModel);	} else {	}	if (nic.getIPv4Address() != null) {	ipModel.setAddress(nic.getIPv4Address());	}	try {	vmModel.update(_manager.getModelController());	} catch (Exception ex) {	
virtual machine update 

try {	vmModel.update(_manager.getModelController());	} catch (Exception ex) {	return;	}	_manager.getDatabase().getVirtualMachines().add(vmModel);	VirtualMachineInterface vmi = vmiModel.getVMInterface();	if (nic.getMacAddress() == null) {	MacAddressesType macs = vmi.getMacAddresses();	if (macs == null) {	
no mac address is allocated for nic 

vmModel.update(_manager.getModelController());	} catch (Exception ex) {	return;	}	_manager.getDatabase().getVirtualMachines().add(vmModel);	VirtualMachineInterface vmi = vmiModel.getVMInterface();	if (nic.getMacAddress() == null) {	MacAddressesType macs = vmi.getMacAddresses();	if (macs == null) {	} else {	
vmi got mac address 

_manager.getDatabase().getVirtualMachines().add(vmModel);	VirtualMachineInterface vmi = vmiModel.getVMInterface();	if (nic.getMacAddress() == null) {	MacAddressesType macs = vmi.getMacAddresses();	if (macs == null) {	} else {	nic.setMacAddress(macs.getMacAddress().get(0));	}	}	if (nic.getIPv4Address() == null) {	
allocated ip address 

public boolean release(NicProfile nic, VirtualMachineProfile vm, String reservationId) {	
release nicprofile 

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	
deallocate nicprofile on 

vmiModel.destroy(_manager.getModelController());	} catch (IOException ex) {	return;	}	vmModel.removeSuccessor(vmiModel);	if (!vmModel.hasDescendents()) {	_manager.getDatabase().getVirtualMachines().remove(vmModel);	try {	vmModel.delete(_manager.getModelController());	} catch (IOException ex) {	
virtual machine delete 

public void updateNicProfile(NicProfile profile, Network network) {	
update nicprofile on 

public void shutdown(NetworkProfile network, NetworkOffering offering) {	
networkguru shutdown 

public void shutdown(NetworkProfile network, NetworkOffering offering) {	VirtualNetworkModel vnModel = _manager.getDatabase().lookupVirtualNetwork(network.getUuid(), _manager.getCanonicalName(network), network.getTrafficType());	if (vnModel == null) {	return;	}	try {	_manager.getDatabase().getVirtualNetworks().remove(vnModel);	vnModel.delete(_manager.getModelController());	} catch (IOException e) {	
virtual network delete 

public boolean trash(Network network, NetworkOffering offering) {	
networkguru trash 

public void updateNetworkProfile(NetworkProfile networkProfile) {	
networkguru updatenetworkprofile 

========================= cloudstack sample_1864 =========================

public boolean executeTest() {	int error = 0;	Element rootElement = this.getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	
exiting the test command required for the future run failed with an error code command was sent with the url 

NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	return false;	} else if (api.getResponseCode() != 200) {	error++;	
test failed with an error code command was sent with url 

Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, this.getParam(), this.getCommands());	api.sendCommand(this.getClient(), null);	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	return false;	} else if (api.getResponseCode() != 200) {	error++;	} else {	if (api.setParam(this.getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use command was sent with url 

api.sendCommand(this.getClient(), null);	if ((api.getResponseCode() != 200) && (api.getRequired() == true)) {	return false;	} else if (api.getResponseCode() != 200) {	error++;	} else {	if (api.setParam(this.getParam()) == false) {	return false;	}	if (api.verifyParam() == false) {	
test failed verification for returned parameters failed the command was sent with url 

return false;	} else if (api.getResponseCode() != 200) {	error++;	} else {	if (api.setParam(this.getParam()) == false) {	return false;	}	if (api.verifyParam() == false) {	error++;	} else if (api.getTestCaseInfo() != null) {	
test passed 

if (api.setParam(this.getParam()) == false) {	return false;	}	if (api.verifyParam() == false) {	error++;	} else if (api.getTestCaseInfo() != null) {	}	}	}	boolean eventResult = ApiCommand.verifyEvents(".. this.getParam().get("accountname"));	
listevent command verification result is 

========================= cloudstack sample_450 =========================

if (_vrLockMap.containsKey(routerName)) {	lock = _vrLockMap.get(routerName);	} else {	lock = new ReentrantLock();	_vrLockMap.put(routerName, lock);	}	lock.lock();	try {	ExecutionResult rc = _vrDeployer.prepareCommand(cmd);	if (!rc.isSuccess()) {	
failed to prepare vr command due to 

return Answer.createUnsupportedCommandAnswer(cmd);	}	return applyConfig(cmd, cfg);	} catch (final IllegalArgumentException e) {	return new Answer(cmd, false, e.getMessage());	} finally {	lock.unlock();	if (!aggregated) {	ExecutionResult rc = _vrDeployer.cleanupCommand(cmd);	if (!rc.isSuccess()) {	
failed to cleanup vr command due to 

private Answer executeQueryCommand(NetworkElementCommand cmd) {	if (cmd instanceof CheckRouterCommand) {	return execute((CheckRouterCommand)cmd);	} else if (cmd instanceof GetDomRVersionCmd) {	return execute((GetDomRVersionCmd)cmd);	} else if (cmd instanceof CheckS2SVpnConnectionsCommand) {	return execute((CheckS2SVpnConnectionsCommand) cmd);	} else if (cmd instanceof GetRouterAlertsCommand) {	return execute((GetRouterAlertsCommand)cmd);	} else {	
unknown query command in virtualroutingresource 

return new Answer(cmd, true, "Nothing to do");	}	List<ExecutionResult> results = new ArrayList<ExecutionResult>();	List<String> details = new ArrayList<String>();	boolean finalResult = false;	for (ConfigItem configItem : cfg) {	long startTimestamp = System.currentTimeMillis();	ExecutionResult result = applyConfigToVR(cmd.getRouterAccessIp(), configItem);	if (s_logger.isDebugEnabled()) {	long elapsed = System.currentTimeMillis() - startTimestamp;	
processing took ms 

long elapsed = System.currentTimeMillis() - startTimestamp;	}	if (result == null) {	result = new ExecutionResult(false, "null execution result");	}	results.add(result);	details.add(configItem.getInfo() + (result.isSuccess() ? " - success: " : " - failed: ") + result.getDetails());	finalResult = result.isSuccess();	}	if (cmd.getAnswersCount() != results.size()) {	
expected answers while executing but received 

_params = params;	String value = (String)params.get("ssh.sleep");	_sleep = NumbersUtil.parseInt(value, 10) * 1000;	value = (String)params.get("ssh.retry");	_retry = NumbersUtil.parseInt(value, 36);	value = (String)params.get("ssh.port");	_port = NumbersUtil.parseInt(value, 3922);	value = (String)params.get("router.aggregation.command.each.timeout");	_eachTimeout = Duration.standardSeconds(NumbersUtil.parseInt(value, (int)VRScripts.VR_SCRIPT_EXEC_TIMEOUT.getStandardSeconds()));	if (s_logger.isDebugEnabled()){	
the router aggregation command each timeout in seconds is set to 

public boolean connect(final String ipAddress, int retry, int sleep) {	for (int i = 0; i <= retry; i++) {	SocketChannel sch = null;	try {	if (s_logger.isDebugEnabled()) {	
trying to connect to 

try {	if (s_logger.isDebugEnabled()) {	}	sch = SocketChannel.open();	sch.configureBlocking(true);	final InetSocketAddress addr = new InetSocketAddress(ipAddress, _port);	sch.connect(addr);	return true;	} catch (final IOException e) {	if (s_logger.isDebugEnabled()) {	
could not connect to 

sch.close();	} catch (final IOException e) {	}	}	}	try {	Thread.sleep(sleep);	} catch (final InterruptedException e) {	}	}	
unable to logon to 

private List<ConfigItem> generateCommandCfg(NetworkElementCommand cmd) {	
transforming to configitems 

Queue<NetworkElementCommand> queue = _vrAggregateCommandsSet.get(routerName);	int answerCounts = 0;	try {	StringBuilder sb = new StringBuilder();	sb.append("#Apache CloudStack Virtual Router Config File\n");	sb.append("<version>\n" + _cfgVersion + "\n</version>\n");	for (NetworkElementCommand command : queue) {	answerCounts += command.getAnswersCount();	List<ConfigItem> cfg = generateCommandCfg(command);	if (cfg == null) {	
unknown commands for virtualroutingresource but continue 

}	for (ConfigItem c : cfg) {	sb.append(c.getAggregateCommand());	}	}	String cfgFileName = "VR-"+ UUID.randomUUID().toString() + ".cfg";	FileConfigItem fileConfigItem = new FileConfigItem(VRScripts.CONFIG_CACHE_LOCATION, cfgFileName, sb.toString());	ScriptConfigItem scriptConfigItem = new ScriptConfigItem(VRScripts.VR_CFG, "-c " + VRScripts.CONFIG_CACHE_LOCATION + cfgFileName);	Duration timeout = _eachTimeout.withDurationAdded(_eachTimeout.getStandardSeconds(), answerCounts);	if (s_logger.isDebugEnabled()){	
aggregate action timeout in seconds is 

========================= cloudstack sample_329 =========================

long sleeptime = 0;	while (!executor.isTerminated()) {	Thread.sleep(100);	sleeptime += 100;	if (sleeptime == 1000) {	final int migrateDowntime = libvirtComputingResource.getMigrateDowntime();	if (migrateDowntime > 0 ) {	try {	final int setDowntime = dm.migrateSetMaxDowntime(migrateDowntime);	if (setDowntime == 0 ) {	
set max downtime for migration of to ms 

Thread.sleep(100);	sleeptime += 100;	if (sleeptime == 1000) {	final int migrateDowntime = libvirtComputingResource.getMigrateDowntime();	if (migrateDowntime > 0 ) {	try {	final int setDowntime = dm.migrateSetMaxDowntime(migrateDowntime);	if (setDowntime == 0 ) {	}	} catch (final LibvirtException e) {	
failed to set max downtime for migration perhaps migration completed error 

if (migrateDowntime > 0 ) {	try {	final int setDowntime = dm.migrateSetMaxDowntime(migrateDowntime);	if (setDowntime == 0 ) {	}	} catch (final LibvirtException e) {	}	}	}	if (sleeptime % 1000 == 0) {	
waiting for migration of to complete waited ms 

if (setDowntime == 0 ) {	}	} catch (final LibvirtException e) {	}	}	}	if (sleeptime % 1000 == 0) {	}	final int migratePauseAfter = libvirtComputingResource.getMigratePauseAfter();	if (migratePauseAfter > 0 && sleeptime > migratePauseAfter && dm.getInfo().state == DomainState.VIR_DOMAIN_RUNNING ) {	
pausing vm due to property vm migrate pauseafter setting to ms to complete migration 

}	}	}	if (sleeptime % 1000 == 0) {	}	final int migratePauseAfter = libvirtComputingResource.getMigratePauseAfter();	if (migratePauseAfter > 0 && sleeptime > migratePauseAfter && dm.getInfo().state == DomainState.VIR_DOMAIN_RUNNING ) {	try {	dm.suspend();	} catch (final LibvirtException e) {	
failed to pause vm 

if (sleeptime % 1000 == 0) {	}	final int migratePauseAfter = libvirtComputingResource.getMigratePauseAfter();	if (migratePauseAfter > 0 && sleeptime > migratePauseAfter && dm.getInfo().state == DomainState.VIR_DOMAIN_RUNNING ) {	try {	dm.suspend();	} catch (final LibvirtException e) {	}	}	}	
migration thread for is done 

}	}	}	destDomain = migrateThread.get(10, TimeUnit.SECONDS);	if (destDomain != null) {	for (final DiskDef disk : disks) {	libvirtComputingResource.cleanupDisk(disk);	}	}	} catch (final LibvirtException e) {	
can t migrate domain 

}	destDomain = migrateThread.get(10, TimeUnit.SECONDS);	if (destDomain != null) {	for (final DiskDef disk : disks) {	libvirtComputingResource.cleanupDisk(disk);	}	}	} catch (final LibvirtException e) {	result = e.getMessage();	} catch (final InterruptedException e) {	
interrupted while migrating domain 

if (destDomain != null) {	for (final DiskDef disk : disks) {	libvirtComputingResource.cleanupDisk(disk);	}	}	} catch (final LibvirtException e) {	result = e.getMessage();	} catch (final InterruptedException e) {	result = e.getMessage();	} catch (final ExecutionException e) {	
failed to execute while migrating domain 

libvirtComputingResource.cleanupDisk(disk);	}	}	} catch (final LibvirtException e) {	result = e.getMessage();	} catch (final InterruptedException e) {	result = e.getMessage();	} catch (final ExecutionException e) {	result = e.getMessage();	} catch (final TimeoutException e) {	
timed out while migrating domain 

}	dm.free();	}	if (dconn != null) {	dconn.close();	}	if (destDomain != null) {	destDomain.free();	}	} catch (final LibvirtException e) {	
ignoring libvirt error 

========================= cloudstack sample_1034 =========================

String xenGuestLabel = getNetworkLabelFromConfig(conn, "xen.guest.network.device");	xenGuestLabel = DBEncryptionUtil.decrypt(xenGuestLabel);	if (xenGuestLabel != null) {	pstmt_count_traffic_types_and_labels.setLong(1, zoneId);	pstmt_count_traffic_types_and_labels.setString(2, xenGuestLabel);	try (ResultSet rsSameLabel = pstmt_count_traffic_types_and_labels.executeQuery();) {	if (rsSameLabel.next()) {	Long sameLabelcount = rsSameLabel.getLong(1);	if (sameLabelcount > 0) {	s_logger.error("There are untagged networks for which we need to add a physical network with Xen traffic label = 'xen.guest.network.device' config value, which is: " + xenGuestLabel);	
however already there are physical networks setup with same traffic label cannot upgrade 

}	}	}	}	long physicalNetworkId = addPhysicalNetworkToZone(conn, zoneId, zoneName, networkType, null, domainId);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, null, null);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, true);	pstmt_network_id.setLong(1, zoneId);	try (ResultSet rsNet = pstmt_network_id.executeQuery();) {	
adding physicalnetwork to vlan 

}	}	}	}	long physicalNetworkId = addPhysicalNetworkToZone(conn, zoneId, zoneName, networkType, null, domainId);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, null, null);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, true);	pstmt_network_id.setLong(1, zoneId);	try (ResultSet rsNet = pstmt_network_id.executeQuery();) {	
adding physicalnetwork to user ip address 

}	}	}	}	long physicalNetworkId = addPhysicalNetworkToZone(conn, zoneId, zoneName, networkType, null, domainId);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, null, null);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, true);	pstmt_network_id.setLong(1, zoneId);	try (ResultSet rsNet = pstmt_network_id.executeQuery();) {	
adding physicalnetwork to networks 

}	}	}	}	boolean multiplePhysicalNetworks = false;	pstmt_count_traffic_types.setLong(1, zoneId);	try (ResultSet rs = pstmt_count_traffic_types.executeQuery();) {	if (rs.next()) {	Long count = rs.getLong(1);	if (count > 1) {	
there are physical networks setup 

}	}	if (multiplePhysicalNetworks) {	pstmt_select_vnets_on_different_physical_net.setLong(1, zoneId);	try (ResultSet rsVNet = pstmt_select_vnets_on_different_physical_net.executeQuery();) {	if (rsVNet.next()) {	String vnet = rsVNet.getString(2);	String networkId = rsVNet.getString(5);	String vpid = rsVNet.getString(4);	String npid = rsVNet.getString(6);	
guest vnet assignment is set wrongly cannot upgrade until that is corrected example vnet has physical network id but the guest network that uses it has physical network id 

pstmt_update_networks.setLong(1, newNetworkOfferingId);	pstmt_update_networks.setLong(2, physicalNetworkId);	pstmt_update_networks.setLong(3, networkOfferingId);	pstmt_update_networks.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Exception while cloning NetworkOffering", e);	} finally {	try (PreparedStatement pstmt_drop_table = conn.prepareStatement("DROP TEMPORARY TABLE `cloud`.`network_offerings2`");) {	pstmt_drop_table.executeUpdate();	} catch (SQLException e) {	
drop of temp table network failed 

========================= cloudstack sample_4236 =========================

public Boolean createPoolFs(String type, String target, String clustername, String fsid, String nfsbaseid, String managerid) throws Ovm3ResourceException {	if (!hasAPoolFs()) {	return nullIsTrueCallWrapper("create_pool_filesystem", type, target, clustername, fsid, nfsbaseid, managerid, fsid);	} else if (hasPoolFs(fsid)) {	
poolfs already exists on this host 

========================= cloudstack sample_850 =========================

public Answer createVolume(VolumeInfo volume) throws StorageUnavailableException {	if (s_logger.isDebugEnabled()) {	
creating volume 

answer = createVolume((VolumeInfo) data);	if ((answer == null) || (!answer.getResult())) {	result.setSuccess(false);	if (answer != null) {	result.setResult(answer.getDetails());	}	} else {	result.setAnswer(answer);	}	} catch (StorageUnavailableException e) {	
failed to create volume 

result.setSuccess(false);	if (answer != null) {	result.setResult(answer.getDetails());	}	} else {	result.setAnswer(answer);	}	} catch (StorageUnavailableException e) {	errMsg = e.toString();	} catch (Exception e) {	
failed to create volume 

String errMsg = "No remote endpoint to send DeleteCommand, check if host or ssvm is down?";	s_logger.error(errMsg);	result.setResult(errMsg);	} else {	Answer answer = ep.sendMessage(cmd);	if (answer != null && !answer.getResult()) {	result.setResult(answer.getDetails());	}	}	} catch (Exception ex) {	
unable to destoy volume 

} else {	answer = ep.sendMessage(cmd);	}	result = new CreateCmdResult(null, answer);	if (answer != null && !answer.getResult()) {	result.setResult(answer.getDetails());	}	callback.complete(result);	return;	} catch (Exception e) {	
failed to take snapshot 

String errMsg = "No remote endpoint to send RevertSnapshotCommand, check if host or ssvm is down?";	s_logger.error(errMsg);	result.setResult(errMsg);	} else {	Answer answer = ep.sendMessage(cmd);	if (answer != null && !answer.getResult()) {	result.setResult(answer.getDetails());	}	}	} catch (Exception ex) {	
unable to revert snapshot 

public void resize(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {	VolumeObject vol = (VolumeObject) data;	StoragePool pool = (StoragePool) data.getDataStore();	ResizeVolumePayload resizeParameter = (ResizeVolumePayload) vol.getpayload();	ResizeVolumeCommand resizeCmd = new ResizeVolumeCommand(vol.getPath(), new StorageFilerTO(pool), vol.getSize(), resizeParameter.newSize, resizeParameter.shrinkOk, resizeParameter.instanceName);	CreateCmdResult result = new CreateCmdResult(null, null);	try {	ResizeVolumeAnswer answer = (ResizeVolumeAnswer) storageMgr.sendToPool(pool, resizeParameter.hosts, resizeCmd);	if (answer != null && answer.getResult()) {	long finalSize = answer.getNewSize();	
resize volume started at size and ended at size 

CreateCmdResult result = new CreateCmdResult(null, null);	try {	ResizeVolumeAnswer answer = (ResizeVolumeAnswer) storageMgr.sendToPool(pool, resizeParameter.hosts, resizeCmd);	if (answer != null && answer.getResult()) {	long finalSize = answer.getNewSize();	vol.setSize(finalSize);	vol.update();	} else if (answer != null) {	result.setResult(answer.getDetails());	} else {	
return a null answer mark it as failed for unknown reason 

if (answer != null && answer.getResult()) {	long finalSize = answer.getNewSize();	vol.setSize(finalSize);	vol.update();	} else if (answer != null) {	result.setResult(answer.getDetails());	} else {	result.setResult("return a null answer, mark it as failed for unknown reason");	}	} catch (Exception e) {	
sending resize command failed 

========================= cloudstack sample_1937 =========================

protected ServerResource getResource(String resourceName) {	ServerResource resource = null;	try {	Class<?> clazz = Class.forName(resourceName);	Constructor constructor = clazz.getConstructor();	resource = (ServerResource)constructor.newInstance();	} catch (ClassNotFoundException e) {	
unable to find class 

protected ServerResource getResource(String resourceName) {	ServerResource resource = null;	try {	Class<?> clazz = Class.forName(resourceName);	Constructor constructor = clazz.getConstructor();	resource = (ServerResource)constructor.newInstance();	} catch (ClassNotFoundException e) {	} catch (InstantiationException e) {	
unablet to instantiate class 

protected ServerResource getResource(String resourceName) {	ServerResource resource = null;	try {	Class<?> clazz = Class.forName(resourceName);	Constructor constructor = clazz.getConstructor();	resource = (ServerResource)constructor.newInstance();	} catch (ClassNotFoundException e) {	} catch (InstantiationException e) {	} catch (IllegalAccessException e) {	
illegal access 

protected ServerResource getResource(String resourceName) {	ServerResource resource = null;	try {	Class<?> clazz = Class.forName(resourceName);	Constructor constructor = clazz.getConstructor();	resource = (ServerResource)constructor.newInstance();	} catch (ClassNotFoundException e) {	} catch (InstantiationException e) {	} catch (IllegalAccessException e) {	} catch (SecurityException e) {	
security error on 

ServerResource resource = null;	try {	Class<?> clazz = Class.forName(resourceName);	Constructor constructor = clazz.getConstructor();	resource = (ServerResource)constructor.newInstance();	} catch (ClassNotFoundException e) {	} catch (InstantiationException e) {	} catch (IllegalAccessException e) {	} catch (SecurityException e) {	} catch (NoSuchMethodException e) {	
nosuchmethodexception error on 

try {	Class<?> clazz = Class.forName(resourceName);	Constructor constructor = clazz.getConstructor();	resource = (ServerResource)constructor.newInstance();	} catch (ClassNotFoundException e) {	} catch (InstantiationException e) {	} catch (IllegalAccessException e) {	} catch (SecurityException e) {	} catch (NoSuchMethodException e) {	} catch (IllegalArgumentException e) {	
illegalargumentexception error on 

Class<?> clazz = Class.forName(resourceName);	Constructor constructor = clazz.getConstructor();	resource = (ServerResource)constructor.newInstance();	} catch (ClassNotFoundException e) {	} catch (InstantiationException e) {	} catch (IllegalAccessException e) {	} catch (SecurityException e) {	} catch (NoSuchMethodException e) {	} catch (IllegalArgumentException e) {	} catch (InvocationTargetException e) {	
invocationtargetexception error on 

public ServerResource reloadResource(HostVO host) {	String resourceName = host.getResource();	ServerResource resource = getResource(resourceName);	if (resource != null) {	_hostDao.loadDetails(host);	updateNetworkLabels(host);	HashMap<String, Object> params = buildConfigParams(host);	try {	resource.configure(host.getName(), params);	} catch (ConfigurationException e) {	
unable to configure resource due to 

if (resource != null) {	_hostDao.loadDetails(host);	updateNetworkLabels(host);	HashMap<String, Object> params = buildConfigParams(host);	try {	resource.configure(host.getName(), params);	} catch (ConfigurationException e) {	return null;	}	if (!resource.start()) {	
unable to start the resource 

========================= cloudstack sample_2618 =========================

out.writeBytes("\r\n");	for (int i = 1; i < 10000; i++) {	StringBuilder imagePath = new StringBuilder();	Formatter formatter = new Formatter(imagePath);	formatter.format("%04x", i);	out.writeBytes("INSERT INTO `vmops`.`dc_vnet_alloc` (vnet, data_center_id) VALUES ('" + imagePath.toString() + "',1);\r\n");	}	out.flush();	out.close();	} catch (Exception e) {	
ignored error during sql generation 

========================= cloudstack sample_446 =========================

public void interceptException(Method method, Object target, Object event) {	
interceptException 

========================= cloudstack sample_1872 =========================

final Network nw = citrixResourceBase.findOrCreateTunnelNetwork(conn, command.getBridgeName());	final String bridgeName = nw.getBridge(conn);	final long sequenceNo = command.getSequenceNumber();	final String result = citrixResourceBase.callHostPlugin(conn, "ovstunnel", "configure_ovs_bridge_for_routing_policies", "bridge", bridgeName, "host-id", ((Long)command.getHostId()).toString(), "config", command.getVpcConfigInJson(), "seq-no", Long.toString(sequenceNo));	if (result.startsWith("SUCCESS")) {	return new Answer(command, true, result);	} else {	return new Answer(command, false, result);	}	} catch  (final Exception e) {	
caught exception while updating host with latest routing policies 

========================= cloudstack sample_1171 =========================

public void stop() {	_capacityScanScheduler.shutdownNow();	try {	_capacityScanScheduler.awaitTermination(1000, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	
ignored interupted while stopping systemvm load scanner 

private Runnable getCapacityScanTask() {	return new ManagedContextRunnable() {	protected void runInContext() {	try {	CallContext callContext = CallContext.current();	assert (callContext != null);	AsyncJobExecutionContext.registerPseudoExecutionContext( callContext.getCallingAccountId(), callContext.getCallingUserId());	reallyRun();	AsyncJobExecutionContext.unregister();	} catch (Throwable e) {	
unexpected exception 

private void loadScan() {	if (!_scanHandler.canScan()) {	return;	}	if (!_capacityScanLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_COOPERATION)) {	if (s_logger.isTraceEnabled()) {	
capacity scan lock is used by others skip and wait for my turn 

========================= cloudstack sample_2474 =========================

String dn = e.getKey();	if (previous.keySet().contains(dn)) {	continue;	}	ComputeBlade nc = e.getValue();	UcsBladeVO vo = new UcsBladeVO();	vo.setDn(nc.getDn());	vo.setUcsManagerId(mgr.getId());	vo.setUuid(UUID.randomUUID().toString());	bladeDao.persist(vo);	
discovered a new ucs blade dn s during sync 

private void decommissionFadedBlade(Map<String, UcsBladeVO> previous, Map<String, ComputeBlade> now) {	for (Map.Entry<String, UcsBladeVO> e : previous.entrySet()) {	String dn = e.getKey();	if (now.keySet().contains(dn)) {	continue;	}	UcsBladeVO vo = e.getValue();	bladeDao.remove(vo.getId());	
decommission faded blade dn s during sync 

private boolean isProfileAssociated(Long ucsMgrId, String dn) {	UcsManagerVO mgrvo = ucsDao.findById(ucsMgrId);	UcsHttpClient client = new UcsHttpClient(mgrvo.getUrl());	String cookie = getCookie(ucsMgrId);	String cmd = UcsCommands.configResolveDn(cookie, dn);	String res = client.call(cmd);	XmlObject xo = XmlObjectParser.parseFromString(res);	
association response is s 

throw new CloudRuntimeException(e);	}	count += 2;	}	if (count >= timeout) {	throw new CloudRuntimeException(String.format("associating profile[%s] to balde[%s] timeout after 600 seconds", pdn, bvo.getDn()));	}	bvo.setProfileDn(pdn);	bladeDao.update(bvo.getId(), bvo);	UcsBladeResponse rsp = bladeVOToResponse(bvo);	
successfully associated profile s to blade s 

========================= cloudstack sample_1258 =========================

protected OvsTunnelInterfaceVO createInterfaceRecord(String ip, String netmask, String mac, long hostId, String label) {	OvsTunnelInterfaceVO ti = null;	try {	ti = new OvsTunnelInterfaceVO(ip, netmask, mac, hostId, label);	OvsTunnelInterfaceVO lock = _tunnelInterfaceDao .acquireInLockTable(Long.valueOf(1));	if (lock == null) {	
cannot lock table ovs tunnel account 

OvsTunnelInterfaceVO ti = null;	try {	ti = new OvsTunnelInterfaceVO(ip, netmask, mac, hostId, label);	OvsTunnelInterfaceVO lock = _tunnelInterfaceDao .acquireInLockTable(Long.valueOf(1));	if (lock == null) {	return null;	}	_tunnelInterfaceDao.persist(ti);	_tunnelInterfaceDao.releaseFromLockTable(lock.getId());	} catch (EntityExistsException e) {	
a record for the interface for network on host id already exists 

private String handleFetchInterfaceAnswer(Answer[] answers, Long hostId) {	OvsFetchInterfaceAnswer ans = (OvsFetchInterfaceAnswer)answers[0];	if (ans.getResult()) {	if (ans.getIp() != null && !("".equals(ans.getIp()))) {	OvsTunnelInterfaceVO ti = createInterfaceRecord(ans.getIp(), ans.getNetmask(), ans.getMac(), hostId, ans.getLabel());	return ti.getIp();	}	}	
unable to fetch the ip address for the gre tunnel endpoint 

protected OvsTunnelNetworkVO createTunnelRecord(long from, long to, long networkId, int key) {	OvsTunnelNetworkVO ta = null;	try {	ta = new OvsTunnelNetworkVO(from, to, key, networkId);	OvsTunnelNetworkVO lock = _tunnelNetworkDao.acquireInLockTable(Long.valueOf(1));	if (lock == null) {	
cannot lock table ovs tunnel account 

OvsTunnelNetworkVO ta = null;	try {	ta = new OvsTunnelNetworkVO(from, to, key, networkId);	OvsTunnelNetworkVO lock = _tunnelNetworkDao.acquireInLockTable(Long.valueOf(1));	if (lock == null) {	return null;	}	_tunnelNetworkDao.persist(ta);	_tunnelNetworkDao.releaseFromLockTable(lock.getId());	} catch (EntityExistsException e) {	
a record for the tunnel from to already exists 

String s = String.format("(hostIP:%1$s, remoteIP:%2$s, bridge:%3$s," + "greKey:%4$s, portName:%5$s)", r.getFromIp(), r.getToIp(), r.getBridge(), r.getKey(), r.getInPortName());	Long from = r.getFrom();	Long to = r.getTo();	long networkId = r.getNetworkId();	OvsTunnelNetworkVO tunnel = _tunnelNetworkDao.getByFromToNetwork(from, to, networkId);	if (tunnel == null) {	throw new CloudRuntimeException( String.format("Unable find tunnelNetwork record" + "(from=%1$s,to=%2$s, account=%3$s", from, to, networkId));	}	if (!r.getResult()) {	tunnel.setState(OvsTunnel.State.Failed.name());	
create gre tunnel from to failed due to 

long networkId = r.getNetworkId();	OvsTunnelNetworkVO tunnel = _tunnelNetworkDao.getByFromToNetwork(from, to, networkId);	if (tunnel == null) {	throw new CloudRuntimeException( String.format("Unable find tunnelNetwork record" + "(from=%1$s,to=%2$s, account=%3$s", from, to, networkId));	}	if (!r.getResult()) {	tunnel.setState(OvsTunnel.State.Failed.name());	} else {	tunnel.setState(OvsTunnel.State.Established.name());	tunnel.setPortName(r.getInPortName());	
create gre tunnel from to succeeded 

case KVM: label = physNetTT.getKvmNetworkLabel();	if ((label != null) && (!label.equals(""))) {	physNetLabel = label;	}	break;	default: throw new CloudRuntimeException("Hypervisor " + hvType.toString() + " unsupported by OVS Tunnel Manager");	}	OvsTunnelInterfaceVO tunnelIface = _tunnelInterfaceDao.getByHostAndLabel(host.getId(), physNetLabel);	if (tunnelIface == null) {	Commands fetchIfaceCmds = new Commands(new OvsFetchInterfaceCommand(physNetLabel));	
ask host to retrieve interface for phy net with label 

try {	String keyStr = network.getBroadcastUri().getAuthority();	if (keyStr.contains(".")) {	String[] parts = keyStr.split("\\.");	key = Integer.parseInt(parts[1]);	} else {	key = Integer.parseInt(keyStr);	}	return key;	} catch (NumberFormatException e) {	
well well how did end up in the broadcast uri for the network 

protected void checkAndCreateTunnel(Network nw, Host host) {	
creating tunnels with ovs tunnel manager 

String bridgeName = generateBridgeName(nw, key);	List<Long> toHostIds = new ArrayList<Long>();	List<Long> fromHostIds = new ArrayList<Long>();	List<Long> networkSpannedHosts = _ovsNetworkToplogyGuru.getNetworkSpanedHosts(nw.getId());	for (Long rh : networkSpannedHosts) {	if (rh == hostId) {	continue;	}	OvsTunnelNetworkVO ta = _tunnelNetworkDao.getByFromToNetwork(hostId, rh.longValue(), nw.getId());	if (ta == null || ta.getState().equals(OvsTunnel.State.Failed.name())) {	
attempting to create tunnel from to 

if (ta == null || ta.getState().equals(OvsTunnel.State.Failed.name())) {	if (ta == null) {	createTunnelRecord(hostId, rh.longValue(), nw.getId(), key);	}	if (!toHostIds.contains(rh)) {	toHostIds.add(rh);	}	}	ta = _tunnelNetworkDao.getByFromToNetwork(rh.longValue(), hostId, nw.getId());	if (ta == null || ta.getState().equals(OvsTunnel.State.Failed.name())) {	
attempting to create tunnel from to 

}	try {	String myIp = getGreEndpointIP(host, nw);	if (myIp == null) throw new GreTunnelException("Unable to retrieve the source " + "endpoint for the GRE tunnel." + "Failure is on host:" + host.getId());	boolean noHost = true;	for (Long i : toHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, nw);	if (otherIp == null) throw new GreTunnelException( "Unable to retrieve the remote " + "endpoint for the GRE tunnel." + "Failure is on host:" + rHost.getId());	Commands cmds = new Commands( new OvsCreateTunnelCommand(otherIp, key, Long.valueOf(hostId), i, nw.getId(), myIp, bridgeName, nw.getUuid()));	
attempting to create tunnel from to for the network 

}	try {	String myIp = getGreEndpointIP(host, nw);	if (myIp == null) throw new GreTunnelException("Unable to retrieve the source " + "endpoint for the GRE tunnel." + "Failure is on host:" + host.getId());	boolean noHost = true;	for (Long i : toHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, nw);	if (otherIp == null) throw new GreTunnelException( "Unable to retrieve the remote " + "endpoint for the GRE tunnel." + "Failure is on host:" + rHost.getId());	Commands cmds = new Commands( new OvsCreateTunnelCommand(otherIp, key, Long.valueOf(hostId), i, nw.getId(), myIp, bridgeName, nw.getUuid()));	
ask host to create gre tunnel to 

if (otherIp == null) throw new GreTunnelException( "Unable to retrieve the remote " + "endpoint for the GRE tunnel." + "Failure is on host:" + rHost.getId());	Commands cmds = new Commands( new OvsCreateTunnelCommand(otherIp, key, Long.valueOf(hostId), i, nw.getId(), myIp, bridgeName, nw.getUuid()));	Answer[] answers = _agentMgr.send(hostId, cmds);	handleCreateTunnelAnswer(answers);	noHost = false;	}	for (Long i : fromHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, nw);	Commands cmds = new Commands(new OvsCreateTunnelCommand(myIp, key, i, Long.valueOf(hostId), nw.getId(), otherIp, bridgeName, nw.getUuid()));	
ask host to create gre tunnel to 

for (Long i : fromHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, nw);	Commands cmds = new Commands(new OvsCreateTunnelCommand(myIp, key, i, Long.valueOf(hostId), nw.getId(), otherIp, bridgeName, nw.getUuid()));	Answer[] answers = _agentMgr.send(i, cmds);	handleCreateTunnelAnswer(answers);	noHost = false;	}	if (noHost) {	Commands cmds = new Commands(new OvsSetupBridgeCommand(bridgeName, hostId, nw.getId()));	
ask host to configure bridge for network 

Answer[] answers = _agentMgr.send(i, cmds);	handleCreateTunnelAnswer(answers);	noHost = false;	}	if (noHost) {	Commands cmds = new Commands(new OvsSetupBridgeCommand(bridgeName, hostId, nw.getId()));	Answer[] answers = _agentMgr.send(hostId, cmds);	handleSetupBridgeAnswer(answers);	}	} catch (GreTunnelException | OperationTimedoutException | AgentUnavailableException e) {	
ovs tunnel network created tunnel failed 

private void handleDestroyTunnelAnswer(Answer ans, long from, long to, long networkId) {	if (ans.getResult()) {	OvsTunnelNetworkVO lock = _tunnelNetworkDao.acquireInLockTable(Long.valueOf(1));	if (lock == null) {	s_logger.warn(String.format("failed to lock" + "ovs_tunnel_account, remove record of " + "tunnel(from=%1$s, to=%2$s account=%3$s) failed", from, to, networkId));	return;	}	_tunnelNetworkDao.removeByFromToNetwork(from, to, networkId);	_tunnelNetworkDao.releaseFromLockTable(lock.getId());	
destroy tunnel account s from s to s successful 

private void handleDestroyTunnelAnswer(Answer ans, long from, long to, long networkId) {	if (ans.getResult()) {	OvsTunnelNetworkVO lock = _tunnelNetworkDao.acquireInLockTable(Long.valueOf(1));	if (lock == null) {	s_logger.warn(String.format("failed to lock" + "ovs_tunnel_account, remove record of " + "tunnel(from=%1$s, to=%2$s account=%3$s) failed", from, to, networkId));	return;	}	_tunnelNetworkDao.removeByFromToNetwork(from, to, networkId);	_tunnelNetworkDao.releaseFromLockTable(lock.getId());	} else {	
destroy tunnel account s from s to s failed 

private void handleDestroyBridgeAnswer(Answer ans, long hostId, long networkId) {	if (ans.getResult()) {	OvsTunnelNetworkVO lock = _tunnelNetworkDao.acquireInLockTable(Long.valueOf(1));	if (lock == null) {	
failed to lock ovs tunnel network remove record 

private void handleDestroyBridgeAnswer(Answer ans, long hostId, long networkId) {	if (ans.getResult()) {	OvsTunnelNetworkVO lock = _tunnelNetworkDao.acquireInLockTable(Long.valueOf(1));	if (lock == null) {	return;	}	_tunnelNetworkDao.removeByFromNetwork(hostId, networkId);	_tunnelNetworkDao.releaseFromLockTable(lock.getId());	
destroy bridge for network s successful 

private void handleDestroyBridgeAnswer(Answer ans, long hostId, long networkId) {	if (ans.getResult()) {	OvsTunnelNetworkVO lock = _tunnelNetworkDao.acquireInLockTable(Long.valueOf(1));	if (lock == null) {	return;	}	_tunnelNetworkDao.removeByFromNetwork(hostId, networkId);	_tunnelNetworkDao.releaseFromLockTable(lock.getId());	} else {	
destroy bridge for network s failed 

private void handleSetupBridgeAnswer(Answer[] answers) {	
placeholder for something more meanginful to come 

}	List<? extends Network> vpcNetworks =  _vpcMgr.getVpcNetworks(nw.getVpcId());	try {	for (Network network: vpcNetworks) {	int key = getGreKey(nw);	String bridgeName = generateBridgeName(nw, key);	List<OvsTunnelNetworkVO> peers = _tunnelNetworkDao.listByToNetwork(host.getId(),nw.getId());	for (OvsTunnelNetworkVO p : peers) {	if (p.getState().equals(OvsTunnel.State.Established.name())) {	Command cmd= new OvsDestroyTunnelCommand(p.getNetworkId(), bridgeName, p.getPortName());	
destroying tunnel to from 

List<OvsTunnelNetworkVO> peers = _tunnelNetworkDao.listByToNetwork(host.getId(),nw.getId());	for (OvsTunnelNetworkVO p : peers) {	if (p.getState().equals(OvsTunnel.State.Established.name())) {	Command cmd= new OvsDestroyTunnelCommand(p.getNetworkId(), bridgeName, p.getPortName());	Answer ans = _agentMgr.send(p.getFrom(), cmd);	handleDestroyTunnelAnswer(ans, p.getFrom(), p.getTo(), p.getNetworkId());	}	}	}	Command cmd = new OvsDestroyBridgeCommand(nw.getId(), generateBridgeNameForVpc(nw.getVpcId()), host.getId());	
destroying bridge for network on host 

Command cmd= new OvsDestroyTunnelCommand(p.getNetworkId(), bridgeName, p.getPortName());	Answer ans = _agentMgr.send(p.getFrom(), cmd);	handleDestroyTunnelAnswer(ans, p.getFrom(), p.getTo(), p.getNetworkId());	}	}	}	Command cmd = new OvsDestroyBridgeCommand(nw.getId(), generateBridgeNameForVpc(nw.getVpcId()), host.getId());	Answer ans = _agentMgr.send(host.getId(), cmd);	handleDestroyBridgeAnswer(ans, host.getId(), nw.getId());	} catch (Exception e) {	
ignored exception while removing host from networks 

}	} else {	List<Long> vmIds = _ovsNetworkToplogyGuru.getActiveVmsInNetworkOnHost(nw.getId(), host.getId(), true);	if (vmIds != null && !vmIds.isEmpty()) {	return;	}	try {	int key = getGreKey(nw);	String bridgeName = generateBridgeName(nw, key);	Command cmd = new OvsDestroyBridgeCommand(nw.getId(), bridgeName, host.getId());	
destroying bridge for network on host 

try {	int key = getGreKey(nw);	String bridgeName = generateBridgeName(nw, key);	Command cmd = new OvsDestroyBridgeCommand(nw.getId(), bridgeName, host.getId());	Answer ans = _agentMgr.send(host.getId(), cmd);	handleDestroyBridgeAnswer(ans, host.getId(), nw.getId());	List<OvsTunnelNetworkVO> peers = _tunnelNetworkDao.listByToNetwork(host.getId(), nw.getId());	for (OvsTunnelNetworkVO p : peers) {	if (p.getState().equals(OvsTunnel.State.Established.name())) {	cmd = new OvsDestroyTunnelCommand(p.getNetworkId(), bridgeName, p.getPortName());	
destroying tunnel to from 

handleDestroyBridgeAnswer(ans, host.getId(), nw.getId());	List<OvsTunnelNetworkVO> peers = _tunnelNetworkDao.listByToNetwork(host.getId(), nw.getId());	for (OvsTunnelNetworkVO p : peers) {	if (p.getState().equals(OvsTunnel.State.Established.name())) {	cmd = new OvsDestroyTunnelCommand(p.getNetworkId(), bridgeName, p.getPortName());	ans = _agentMgr.send(p.getFrom(), cmd);	handleDestroyTunnelAnswer(ans, p.getFrom(), p.getTo(), p.getNetworkId());	}	}	} catch (Exception e) {	
destroy tunnel failed 

protected void checkAndCreateVpcTunnelNetworks(Host host, long vpcId) {	long hostId = host.getId();	String bridgeName=generateBridgeNameForVpc(vpcId);	List<Long> vmIds = _ovsNetworkToplogyGuru.getActiveVmsInVpcOnHost(vpcId, hostId);	if (vmIds == null || vmIds.isEmpty()) {	try {	Commands cmds = new Commands(new OvsSetupBridgeCommand(bridgeName, hostId, null));	
ask host to create bridge for vpc and configure the bridge for distributed routing 

protected void checkAndCreateVpcTunnelNetworks(Host host, long vpcId) {	long hostId = host.getId();	String bridgeName=generateBridgeNameForVpc(vpcId);	List<Long> vmIds = _ovsNetworkToplogyGuru.getActiveVmsInVpcOnHost(vpcId, hostId);	if (vmIds == null || vmIds.isEmpty()) {	try {	Commands cmds = new Commands(new OvsSetupBridgeCommand(bridgeName, hostId, null));	Answer[] answers = _agentMgr.send(hostId, cmds);	handleSetupBridgeAnswer(answers);	} catch (OperationTimedoutException | AgentUnavailableException e) {	
ovs tunnel network created tunnel failed 

if (vmIds == null || vmIds.isEmpty()) {	try {	Commands cmds = new Commands(new OvsSetupBridgeCommand(bridgeName, hostId, null));	Answer[] answers = _agentMgr.send(hostId, cmds);	handleSetupBridgeAnswer(answers);	} catch (OperationTimedoutException | AgentUnavailableException e) {	}	OvsVpcRoutingPolicyConfigCommand cmd = prepareVpcRoutingPolicyUpdate(vpcId);	cmd.setSequenceNumber(getNextRoutingPolicyUpdateSequenceNumber(vpcId));	if (!sendVpcRoutingPolicyChangeUpdate(cmd, hostId, bridgeName)) {	
failed to send vpc routing policy change update to host but moving on with sending the updates to the rest of the hosts 

int key = getGreKey(vpcNetwork);	List<Long> toHostIds = new ArrayList<Long>();	List<Long> fromHostIds = new ArrayList<Long>();	OvsTunnelNetworkVO tunnelRecord = null;	for (Long rh : vpcSpannedHostIds) {	if (rh == hostId) {	continue;	}	tunnelRecord = _tunnelNetworkDao.getByFromToNetwork(hostId, rh.longValue(), vpcNetwork.getId());	if (tunnelRecord == null || tunnelRecord.getState().equals(OvsTunnel.State.Failed.name())) {	
attempting to create tunnel from to 

if (tunnelRecord == null || tunnelRecord.getState().equals(OvsTunnel.State.Failed.name())) {	if (tunnelRecord == null) {	createTunnelRecord(hostId, rh.longValue(), vpcNetwork.getId(), key);	}	if (!toHostIds.contains(rh)) {	toHostIds.add(rh);	}	}	tunnelRecord = _tunnelNetworkDao.getByFromToNetwork(rh.longValue(), hostId, vpcNetwork.getId());	if (tunnelRecord == null || tunnelRecord.getState().equals(OvsTunnel.State.Failed.name())) {	
attempting to create tunnel from to 

}	try {	String myIp = getGreEndpointIP(host, vpcNetwork);	if (myIp == null) throw new GreTunnelException("Unable to retrieve the source " + "endpoint for the GRE tunnel." + "Failure is on host:" + host.getId());	boolean noHost = true;	for (Long i : toHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, vpcNetwork);	if (otherIp == null) throw new GreTunnelException( "Unable to retrieve the remote endpoint for the GRE tunnel." + "Failure is on host:" + rHost.getId());	Commands cmds = new Commands( new OvsCreateTunnelCommand(otherIp, key, Long.valueOf(hostId), i, vpcNetwork.getId(), myIp, bridgeName, vpcNetwork.getUuid()));	
attempting to create tunnel from to for the network 

}	try {	String myIp = getGreEndpointIP(host, vpcNetwork);	if (myIp == null) throw new GreTunnelException("Unable to retrieve the source " + "endpoint for the GRE tunnel." + "Failure is on host:" + host.getId());	boolean noHost = true;	for (Long i : toHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, vpcNetwork);	if (otherIp == null) throw new GreTunnelException( "Unable to retrieve the remote endpoint for the GRE tunnel." + "Failure is on host:" + rHost.getId());	Commands cmds = new Commands( new OvsCreateTunnelCommand(otherIp, key, Long.valueOf(hostId), i, vpcNetwork.getId(), myIp, bridgeName, vpcNetwork.getUuid()));	
ask host to create gre tunnel to 

String otherIp = getGreEndpointIP(rHost, vpcNetwork);	if (otherIp == null) throw new GreTunnelException( "Unable to retrieve the remote endpoint for the GRE tunnel." + "Failure is on host:" + rHost.getId());	Commands cmds = new Commands( new OvsCreateTunnelCommand(otherIp, key, Long.valueOf(hostId), i, vpcNetwork.getId(), myIp, bridgeName, vpcNetwork.getUuid()));	Answer[] answers = _agentMgr.send(hostId, cmds);	handleCreateTunnelAnswer(answers);	}	for (Long i : fromHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, vpcNetwork);	Commands cmds = new Commands(new OvsCreateTunnelCommand(myIp, key, i, Long.valueOf(hostId), vpcNetwork.getId(), otherIp, bridgeName, vpcNetwork.getUuid()));	
ask host to create gre tunnel to 

handleCreateTunnelAnswer(answers);	}	for (Long i : fromHostIds) {	HostVO rHost = _hostDao.findById(i);	String otherIp = getGreEndpointIP(rHost, vpcNetwork);	Commands cmds = new Commands(new OvsCreateTunnelCommand(myIp, key, i, Long.valueOf(hostId), vpcNetwork.getId(), otherIp, bridgeName, vpcNetwork.getUuid()));	Answer[] answers = _agentMgr.send(i, cmds);	handleCreateTunnelAnswer(answers);	}	} catch (GreTunnelException | OperationTimedoutException | AgentUnavailableException e) {	
ovs tunnel network created tunnel failed 

VpcVO vpc = _vpcDao.findById(vpcId);	if (vpc == null || !vpc.usesDistributedRouter()) {	return;	}	List<Long> vpcSpannedHostIds = _ovsNetworkToplogyGuru.getVpcSpannedHosts(vpcId);	String bridgeName=generateBridgeNameForVpc(vpcId);	OvsVpcPhysicalTopologyConfigCommand topologyConfigCommand = prepareVpcTopologyUpdate(vpcId);	topologyConfigCommand.setSequenceNumber(getNextTopologyUpdateSequenceNumber(vpcId));	for (Long id: vpcSpannedHostIds) {	if (!sendVpcTopologyChangeUpdate(topologyConfigCommand, id, bridgeName)) {	
failed to send vpc topology change update to host moving on with rest of the host update 

try {	NetworkVO network = (NetworkVO) args;	String bridgeName=generateBridgeNameForVpc(network.getVpcId());	if (network.getVpcId() != null && isVpcEnabledForDistributedRouter(network.getVpcId())) {	long vpcId = network.getVpcId();	OvsVpcRoutingPolicyConfigCommand cmd = prepareVpcRoutingPolicyUpdate(vpcId);	cmd.setSequenceNumber(getNextRoutingPolicyUpdateSequenceNumber(vpcId));	List<Long> vpcSpannedHostIds = _ovsNetworkToplogyGuru.getVpcSpannedHosts(vpcId);	for (Long id: vpcSpannedHostIds) {	if (!sendVpcRoutingPolicyChangeUpdate(cmd, id, bridgeName)) {	
failed to send vpc routing policy change update to host but moving on with sending the updates to the rest of the hosts 

long vpcId = network.getVpcId();	OvsVpcRoutingPolicyConfigCommand cmd = prepareVpcRoutingPolicyUpdate(vpcId);	cmd.setSequenceNumber(getNextRoutingPolicyUpdateSequenceNumber(vpcId));	List<Long> vpcSpannedHostIds = _ovsNetworkToplogyGuru.getVpcSpannedHosts(vpcId);	for (Long id: vpcSpannedHostIds) {	if (!sendVpcRoutingPolicyChangeUpdate(cmd, id, bridgeName)) {	}	}	}	} catch (Exception e) {	
failed to send vpc routing policy change updates all hosts in vpc 

private boolean sendVpcRoutingPolicyChangeUpdate(OvsVpcRoutingPolicyConfigCommand updateCmd, long hostId, String bridgeName) {	try {	
sending vpc routing policies change update to the host 

private boolean sendVpcRoutingPolicyChangeUpdate(OvsVpcRoutingPolicyConfigCommand updateCmd, long hostId, String bridgeName) {	try {	updateCmd.setHostId(hostId);	updateCmd.setBridgeName(bridgeName);	Answer ans = _agentMgr.send(hostId, updateCmd);	if (ans.getResult()) {	
successfully updated the host with latest vpc routing policies 

private boolean sendVpcRoutingPolicyChangeUpdate(OvsVpcRoutingPolicyConfigCommand updateCmd, long hostId, String bridgeName) {	try {	updateCmd.setHostId(hostId);	updateCmd.setBridgeName(bridgeName);	Answer ans = _agentMgr.send(hostId, updateCmd);	if (ans.getResult()) {	return true;	}  else {	
failed to update the host with latest routing policies 

try {	updateCmd.setHostId(hostId);	updateCmd.setBridgeName(bridgeName);	Answer ans = _agentMgr.send(hostId, updateCmd);	if (ans.getResult()) {	return true;	}  else {	return false;	}	} catch (Exception e) {	
failed to updated the host with latest routing policies due to 

========================= cloudstack sample_1433 =========================

protected Answer execute(CreateObjectCommand cmd) {	DataTO data = cmd.getData();	try {	if (data.getObjectType() == DataObjectType.VOLUME) {	return processor.createVolume(cmd);	} else if (data.getObjectType() == DataObjectType.SNAPSHOT) {	return processor.createSnapshot(cmd);	}	return new CreateObjectAnswer("not supported type");	} catch (Exception e) {	
failed to create object 

========================= cloudstack sample_411 =========================

public synchronized VirtualMachineMO findVmOnHyperHost(String vmName) throws Exception {	
find vm on host 

public synchronized VirtualMachineMO findVmOnHyperHost(String vmName) throws Exception {	VirtualMachineMO vmMo = _vmCache.get(vmName);	if (vmMo != null) {	
vm found in host cache 

public synchronized VirtualMachineMO findVmOnHyperHost(String vmName) throws Exception {	VirtualMachineMO vmMo = _vmCache.get(vmName);	if (vmMo != null) {	return vmMo;	}	
vm not found in host cache 

private void loadVmCache() throws Exception {	
load vm cache on host 

private void loadVmCache() throws Exception {	_vmCache.clear();	int key = getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

} else if (prop.getName().startsWith("value[")) {	if (prop.getVal() != null) vmInternalCSName = ((CustomFieldStringValue)prop.getVal()).getValue();	}	}	String vmName = null;	if (vmInternalCSName != null && isUserVMInternalCSName(vmInternalCSName)) {	vmName = vmInternalCSName;	} else {	vmName = vmVcenterName;	}	
put into host cache 

public boolean createVm(VirtualMachineConfigSpec vmSpec) throws Exception {	assert (vmSpec != null);	DatacenterMO dcMo = new DatacenterMO(_context, getHyperHostDatacenter());	ManagedObjectReference morPool = getHyperHostOwnerResourcePool();	ManagedObjectReference morTask = _context.getService().createVMTask(dcMo.getVmFolder(), vmSpec, morPool, _mor);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware createvm task failed due to 

public HashMap<String, Integer> getVmVncPortsOnHost() throws Exception {	int key = getCustomFieldKey("VirtualMachine", CustomFieldConstants.CLOUD_VM_INTERNAL_NAME);	if (key == 0) {	
custom field is not registered 

public ObjectContent[] getVmPropertiesOnHyperHost(String[] propertyPaths) throws Exception {	
vcenter api trace retrieveproperties for vm properties target mor properties 

ObjectSpec oSpec = new ObjectSpec();	oSpec.setObj(_mor);	oSpec.setSkip(Boolean.TRUE);	oSpec.getSelectSet().add(host2VmTraversal);	PropertyFilterSpec pfSpec = new PropertyFilterSpec();	pfSpec.getPropSet().add(pSpec);	pfSpec.getObjectSet().add(oSpec);	List<PropertyFilterSpec> pfSpecArr = new ArrayList<PropertyFilterSpec>();	pfSpecArr.add(pfSpec);	List<ObjectContent> properties = _context.getService().retrieveProperties(_context.getPropertyCollector(), pfSpecArr);	
vcenter api trace retrieveproperties done 

public ObjectContent[] getDatastorePropertiesOnHyperHost(String[] propertyPaths) throws Exception {	
vcenter api trace retrieveproperties on datastore properties target mor properties 

ObjectSpec oSpec = new ObjectSpec();	oSpec.setObj(_mor);	oSpec.setSkip(Boolean.TRUE);	oSpec.getSelectSet().add(host2DatastoreTraversal);	PropertyFilterSpec pfSpec = new PropertyFilterSpec();	pfSpec.getPropSet().add(pSpec);	pfSpec.getObjectSet().add(oSpec);	List<PropertyFilterSpec> pfSpecArr = new ArrayList<PropertyFilterSpec>();	pfSpecArr.add(pfSpec);	List<ObjectContent> properties = _context.getService().retrieveProperties(_context.getPropertyCollector(), pfSpecArr);	
vcenter api trace retrieveproperties done 

public void importVmFromOVF(String ovfFilePath, String vmName, String datastoreName, String diskOption) throws Exception {	
vcenter api trace importvmfromovf target mor ovffilepath vmname datastorename diskoption 

public void importVmFromOVF(String ovfFilePath, String vmName, String datastoreName, String diskOption) throws Exception {	DatastoreMO dsMo = getHostDatastoreMO(datastoreName);	if (dsMo == null) throw new Exception("Invalid datastore name: " + datastoreName);	importVmFromOVF(ovfFilePath, vmName, dsMo, diskOption);	
vcenter api trace importvmfromovf done 

public boolean createBlankVm(String vmName, String vmInternalCSName, int cpuCount, int cpuSpeedMHz, int cpuReservedMHz, boolean limitCpuUse, int memoryMB, int memoryReserveMB, String guestOsIdentifier, ManagedObjectReference morDs, boolean snapshotDirToParent, Pair<String, String> controllerInfo, Boolean systemVm) throws Exception {	
vcenter api trace createblankvm target mor vmname cpucount cpuspeedmhz cpureservedmhz limitcpu memorymb guestos datastore snapshotdirtoparent controllerinfo systemvm 

public boolean createBlankVm(String vmName, String vmInternalCSName, int cpuCount, int cpuSpeedMHz, int cpuReservedMHz, boolean limitCpuUse, int memoryMB, int memoryReserveMB, String guestOsIdentifier, ManagedObjectReference morDs, boolean snapshotDirToParent, Pair<String, String> controllerInfo, Boolean systemVm) throws Exception {	boolean result = HypervisorHostHelper.createBlankVm(this, vmName, vmInternalCSName, cpuCount, cpuSpeedMHz, cpuReservedMHz, limitCpuUse, memoryMB, memoryReserveMB, guestOsIdentifier, morDs, snapshotDirToParent, controllerInfo, systemVm);	
vcenter api trace createblankvm done 

public ManagedObjectReference getExistingDataStoreOnHost(boolean vmfsDatastore, String hostAddress, int hostPort, String path, String uuid, HostDatastoreSystemMO hostDatastoreSystemMo) {	List<ManagedObjectReference> morArray;	try {	morArray = hostDatastoreSystemMo.getDatastores();	} catch (Exception e) {	
failed to retrieve list of managed object references 

for (i = 0; i < morArray.size(); i++) {	NasDatastoreInfo nasDS;	try {	nasDS = hostDatastoreSystemMo.getNasDatastoreInfo(morArray.get(i));	if (nasDS != null) {	if (nasDS.getNas().getRemoteHost().equalsIgnoreCase(hostAddress) && nasDS.getNas().getRemotePath().equalsIgnoreCase(path)) {	return morArray.get(i);	}	}	} catch (Exception e) {	
encountered exception when retrieving nas datastore info 

public ManagedObjectReference mountDatastore(boolean vmfsDatastore, String poolHostAddress, int poolHostPort, String poolPath, String poolUuid) throws Exception {	
vcenter api trace mountdatastore target mor vmfs poolhost poolhostport poolpath pooluuid 

public ManagedObjectReference mountDatastore(boolean vmfsDatastore, String poolHostAddress, int poolHostPort, String poolPath, String poolUuid) throws Exception {	HostDatastoreSystemMO hostDatastoreSystemMo = getHostDatastoreSystemMO();	ManagedObjectReference morDatastore = hostDatastoreSystemMo.findDatastore(poolUuid);	if (morDatastore == null) {	if (!vmfsDatastore) {	try {	morDatastore = hostDatastoreSystemMo.createNfsDatastore(poolHostAddress, poolHostPort, poolPath, poolUuid);	} catch (AlreadyExistsFaultMsg e) {	
creation of nfs datastore on vcenter failed since datastore already exists details vcenter api trace mountdatastore target mor vmfs poolhost poolhostport poolpath pooluuid 

public ManagedObjectReference mountDatastore(boolean vmfsDatastore, String poolHostAddress, int poolHostPort, String poolPath, String poolUuid) throws Exception {	HostDatastoreSystemMO hostDatastoreSystemMo = getHostDatastoreSystemMO();	ManagedObjectReference morDatastore = hostDatastoreSystemMo.findDatastore(poolUuid);	if (morDatastore == null) {	if (!vmfsDatastore) {	try {	morDatastore = hostDatastoreSystemMo.createNfsDatastore(poolHostAddress, poolHostPort, poolPath, poolUuid);	} catch (AlreadyExistsFaultMsg e) {	return (getExistingDataStoreOnHost(vmfsDatastore, poolHostAddress, poolHostPort, poolPath, poolUuid, hostDatastoreSystemMo));	} catch (Exception e) {	
creation of nfs datastore on vcenter failed details vcenter api trace mountdatastore target mor vmfs poolhost poolhostport poolpath pooluuid exception mesg 

try {	morDatastore = hostDatastoreSystemMo.createNfsDatastore(poolHostAddress, poolHostPort, poolPath, poolUuid);	} catch (AlreadyExistsFaultMsg e) {	return (getExistingDataStoreOnHost(vmfsDatastore, poolHostAddress, poolHostPort, poolPath, poolUuid, hostDatastoreSystemMo));	} catch (Exception e) {	throw new Exception("Creation of NFS datastore on vCenter failed.");	}	if (morDatastore == null) {	String msg = "Unable to create NFS datastore. host: " + poolHostAddress + ", port: " + poolHostPort + ", path: " + poolPath + ", uuid: " + poolUuid;	s_logger.error(msg);	
vcenter api trace mountdatastore done failed 

if (morDatastore == null) {	String msg = "Unable to create NFS datastore. host: " + poolHostAddress + ", port: " + poolHostPort + ", path: " + poolPath + ", uuid: " + poolUuid;	s_logger.error(msg);	throw new Exception(msg);	}	} else {	morDatastore = _context.getDatastoreMorByPath(poolPath);	if (morDatastore == null) {	String msg = "Unable to create VMFS datastore. host: " + poolHostAddress + ", port: " + poolHostPort + ", path: " + poolPath + ", uuid: " + poolUuid;	s_logger.error(msg);	
vcenter api trace mountdatastore done failed 

morDatastore = _context.getDatastoreMorByPath(poolPath);	if (morDatastore == null) {	String msg = "Unable to create VMFS datastore. host: " + poolHostAddress + ", port: " + poolHostPort + ", path: " + poolPath + ", uuid: " + poolUuid;	s_logger.error(msg);	throw new Exception(msg);	}	DatastoreMO dsMo = new DatastoreMO(_context, morDatastore);	dsMo.setCustomFieldValue(CustomFieldConstants.CLOUD_UUID, poolUuid);	}	}	
vcenter api trace mountdatastore done successfully 

public void unmountDatastore(String uuid) throws Exception {	
vcenter api trace unmountdatastore target mor uuid 

public void unmountDatastore(String uuid) throws Exception {	HostDatastoreSystemMO hostDatastoreSystemMo = getHostDatastoreSystemMO();	if (!hostDatastoreSystemMo.deleteDatastore(uuid)) {	String msg = "Unable to unmount datastore. uuid: " + uuid;	s_logger.error(msg);	
vcenter api trace unmountdatastore done failed 

public void unmountDatastore(String uuid) throws Exception {	HostDatastoreSystemMO hostDatastoreSystemMo = getHostDatastoreSystemMO();	if (!hostDatastoreSystemMo.deleteDatastore(uuid)) {	String msg = "Unable to unmount datastore. uuid: " + uuid;	s_logger.error(msg);	throw new Exception(msg);	}	
vcenter api trace unmountdatastore done 

public VmwareHypervisorHostResourceSummary getHyperHostResourceSummary() throws Exception {	
vcenter api trace gethyperhostresourcesummary target mor 

public VmwareHypervisorHostResourceSummary getHyperHostResourceSummary() throws Exception {	VmwareHypervisorHostResourceSummary summary = new VmwareHypervisorHostResourceSummary();	HostHardwareSummary hardwareSummary = getHostHardwareSummary();	summary.setCpuCount(hardwareSummary.getNumCpuThreads());	summary.setMemoryBytes(hardwareSummary.getMemorySize());	summary.setCpuSpeed(hardwareSummary.getCpuMhz());	summary.setCpuSockets((int)hardwareSummary.getNumCpuPkgs());	
vcenter api trace gethyperhostresourcesummary done 

public VmwareHypervisorHostNetworkSummary getHyperHostNetworkSummary(String managementPortGroup) throws Exception {	
vcenter api trace gethyperhostnetworksummary target mor mgmtportgroup 

for (HostVirtualNic nic : netConfig.getCandidateVnic()) {	portGroup = nic.getPortgroup();	if (portGroup == null || portGroup.isEmpty()) {	dvPortGroupKey = nic.getSpec().getDistributedVirtualPort().getPortgroupKey();	portGroup = getNetworkName(dvPortGroupKey);	}	if (portGroup.equalsIgnoreCase(managementPortGroup)) {	summary.setHostIp(nic.getSpec().getIp().getIpAddress());	summary.setHostNetmask(nic.getSpec().getIp().getSubnetMask());	summary.setHostMacAddress(nic.getSpec().getMac());	
vcenter api trace gethyperhostnetworksummary done successfully 

}	}	} else {	List<HostVirtualNic> hostVNics = _context.getVimClient().getDynamicProperty(_mor, "config.network.consoleVnic");	if (hostVNics != null) {	for (HostVirtualNic vnic : hostVNics) {	if (vnic.getPortgroup().equals(managementPortGroup)) {	summary.setHostIp(vnic.getSpec().getIp().getIpAddress());	summary.setHostNetmask(vnic.getSpec().getIp().getSubnetMask());	summary.setHostMacAddress(vnic.getSpec().getMac());	
vcenter api trace gethyperhostnetworksummary done successfully 

for (HostVirtualNic vnic : hostVNics) {	if (vnic.getPortgroup().equals(managementPortGroup)) {	summary.setHostIp(vnic.getSpec().getIp().getIpAddress());	summary.setHostNetmask(vnic.getSpec().getIp().getSubnetMask());	summary.setHostMacAddress(vnic.getSpec().getMac());	return summary;	}	}	}	}	
vcenter api trace gethyperhostnetworksummary done failed 

public ComputeResourceSummary getHyperHostHardwareSummary() throws Exception {	
vcenter api trace gethyperhosthardwaresummary target mor 

HostHardwareSummary hardwareSummary = getHostHardwareSummary();	ComputeResourceSummary resourceSummary = new ComputeResourceSummary();	resourceSummary.setNumCpuCores(hardwareSummary.getNumCpuCores());	resourceSummary.setTotalMemory(hardwareSummary.getMemorySize());	int totalCpu = hardwareSummary.getCpuMhz() * hardwareSummary.getNumCpuCores();	resourceSummary.setTotalCpu(totalCpu);	HostListSummaryQuickStats stats = getHostQuickStats();	if (stats.getOverallCpuUsage() == null || stats.getOverallMemoryUsage() == null) throw new Exception("Unable to get valid overal CPU/Memory usage data, host may be disconnected");	resourceSummary.setEffectiveCpu(totalCpu - stats.getOverallCpuUsage());	resourceSummary.setEffectiveMemory(hardwareSummary.getMemorySize() / (1024 * 1024) - stats.getOverallMemoryUsage());	
vcenter api trace gethyperhosthardwaresummary done 

public boolean revertToSnapshot(ManagedObjectReference morSnapshot) throws Exception {	ManagedObjectReference morTask = _context.getService().revertToSnapshotTask(morSnapshot, _mor, false);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware revert to snapshot failed due to 

public void createPortGroup(HostVirtualSwitch vSwitch, String portGroupName, Integer vlanId, HostNetworkSecurityPolicy secPolicy, HostNetworkTrafficShapingPolicy shapingPolicy, long timeOutMs) throws Exception {	assert (portGroupName != null);	String hostPortGroup = _mor.getValue() + "-" + portGroupName;	synchronized (hostPortGroup.intern()) {	if (hasPortGroup(vSwitch, portGroupName)) {	if (s_logger.isDebugEnabled()) {	
found port group in vswitch not attempting to create port group as it already exists 

public void createPortGroup(HostVirtualSwitch vSwitch, String portGroupName, Integer vlanId, HostNetworkSecurityPolicy secPolicy, HostNetworkTrafficShapingPolicy shapingPolicy, long timeOutMs) throws Exception {	assert (portGroupName != null);	String hostPortGroup = _mor.getValue() + "-" + portGroupName;	synchronized (hostPortGroup.intern()) {	if (hasPortGroup(vSwitch, portGroupName)) {	if (s_logger.isDebugEnabled()) {	}	return;	} else {	if (s_logger.isDebugEnabled()) {	
port group doesn t exist in vswitch attempting to create port group in this vswitch 

}	return;	} else {	if (s_logger.isDebugEnabled()) {	}	}	createPortGroup(vSwitch, portGroupName, vlanId, secPolicy, shapingPolicy);	waitForPortGroup(portGroupName, timeOutMs);	}	if (s_logger.isDebugEnabled()) {	
successfully created port group in vswitch on host 

public ManagedObjectReference waitForPortGroup(String networkName, long timeOutMs) throws Exception {	ManagedObjectReference morNetwork = null;	long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick <= timeOutMs) {	morNetwork = getNetworkMor(networkName);	if (morNetwork != null) {	break;	}	if (s_logger.isInfoEnabled()) {	
waiting for network to be ready 

========================= cloudstack sample_2073 =========================

public void contextInitialized(ServletContextEvent event) {	try {	cloudStackContext = new CloudStackSpringContext();	cloudStackContext.registerShutdownHook();	event.getServletContext().setAttribute(CloudStackSpringContext.CLOUDSTACK_CONTEXT_SERVLET_KEY, cloudStackContext);	} catch (IOException e) {	
failed to start cloudstack 

========================= cloudstack sample_738 =========================

if (providers != null) {	for (DataStoreProvider provider : providers) {	if (provider instanceof PrimaryDataStoreProvider) {	try {	HypervisorHostListener hypervisorHostListener = provider.getHostListener();	if (hypervisorHostListener != null) {	hypervisorHostListener.hostAdded(hostId);	}	}	catch (Exception ex) {	
hostadded long failed for storage provider 

continue;	}	if (!pool.isShared()) {	continue;	}	if (pool.getPoolType() == StoragePoolType.OCFS2 && !_ocfs2Mgr.prepareNodes(pool.getClusterId())) {	throw new ConnectionException(true, "Unable to prepare OCFS2 nodes for pool " + pool.getId());	}	Long hostId = host.getId();	if (s_logger.isDebugEnabled()) {	
host connected connecting host to shared pool id and sending storage pool information 

if (providers != null) {	for (DataStoreProvider provider : providers) {	if (provider instanceof PrimaryDataStoreProvider) {	try {	HypervisorHostListener hypervisorHostListener = provider.getHostListener();	if (hypervisorHostListener != null) {	hypervisorHostListener.hostAboutToBeRemoved(hostId);	}	}	catch (Exception ex) {	
hostabouttoberemoved long failed for storage provider 

if (providers != null) {	for (DataStoreProvider provider : providers) {	if (provider instanceof PrimaryDataStoreProvider) {	try {	HypervisorHostListener hypervisorHostListener = provider.getHostListener();	if (hypervisorHostListener != null) {	hypervisorHostListener.hostRemoved(hostId, clusterId);	}	}	catch (Exception ex) {	
hostremoved long long failed for storage provider 

========================= cloudstack sample_2423 =========================

public long submitAsyncJob(AsyncJob job, boolean scheduleJobExecutionInContext) {	GenericDao dao = GenericDaoBase.getDao(job.getClass());	job.setInitMsid(getMsid());	job.setSyncSource(null);	dao.persist(job);	publishOnEventBus(job, "submit");	scheduleExecution(job, scheduleJobExecutionInContext);	if (s_logger.isDebugEnabled()) {	
submit async job details 

public void completeAsyncJob(final long jobId, final Status jobStatus, final int resultCode, final String resultObject) {	if (s_logger.isDebugEnabled()) {	
complete async job jobstatus resultcode result 

public void completeAsyncJob(final long jobId, final Status jobStatus, final int resultCode, final String resultObject) {	if (s_logger.isDebugEnabled()) {	}	final AsyncJobVO job = _jobDao.findById(jobId);	if (job == null) {	if (s_logger.isDebugEnabled()) {	
job no longer exists we just log completion info here resultcode result 

}	final AsyncJobVO job = _jobDao.findById(jobId);	if (job == null) {	if (s_logger.isDebugEnabled()) {	}	_queueMgr.purgeAsyncJobQueueItemId(jobId);	return;	}	if (job.getStatus() != JobInfo.Status.IN_PROGRESS) {	if (s_logger.isDebugEnabled()) {	
job is already completed 

if (job.getStatus() != JobInfo.Status.IN_PROGRESS) {	if (s_logger.isDebugEnabled()) {	}	_queueMgr.purgeAsyncJobQueueItemId(jobId);	return;	}	if (resultObject != null) {	job.setResult(resultObject);	}	if (s_logger.isDebugEnabled()) {	
publish async job complete on message bus 

}	_queueMgr.purgeAsyncJobQueueItemId(jobId);	return;	}	if (resultObject != null) {	job.setResult(resultObject);	}	if (s_logger.isDebugEnabled()) {	}	if (s_logger.isDebugEnabled()) {	
wake up jobs related to job 

if (resultObject != null) {	job.setResult(resultObject);	}	if (s_logger.isDebugEnabled()) {	}	if (s_logger.isDebugEnabled()) {	}	List<Long> wakeupList = Transaction.execute(new TransactionCallback<List<Long>>() {	public List<Long> doInTransaction(TransactionStatus status) {	if (s_logger.isDebugEnabled()) {	
update db status for job 

job.setResultCode(resultCode);	if (resultObject != null) {	job.setResult(resultObject);	} else {	job.setResult(null);	}	job.setLastUpdated(DateUtil.currentGMTTime());	job.setExecutingMsid(null);	_jobDao.update(jobId, job);	if (s_logger.isDebugEnabled()) {	
wake up jobs joined with job and disjoin all subjobs created from job 

public void updateAsyncJobStatus(final long jobId, final int processStatus, final String resultObject) {	if (s_logger.isDebugEnabled()) {	
update async job progress job processstatus result 

public void updateAsyncJobStatus(final long jobId, final int processStatus, final String resultObject) {	if (s_logger.isDebugEnabled()) {	}	final AsyncJobVO job = _jobDao.findById(jobId);	if (job == null) {	if (s_logger.isDebugEnabled()) {	
job no longer exists we just log progress info here progress status 

public void updateAsyncJobAttachment(final long jobId, final String instanceType, final Long instanceId) {	if (s_logger.isDebugEnabled()) {	
update async job attachment job instancetype instanceid 

public void syncAsyncJobExecution(AsyncJob job, String syncObjType, long syncObjId, long queueSizeLimit) {	if (s_logger.isDebugEnabled()) {	
sync job execution on object 

private AsyncJobDispatcher getWakeupDispatcher(AsyncJob job) {	if (_jobDispatchers != null) {	List<AsyncJobJoinMapVO> joinRecords = _joinMapDao.listJoinRecords(job.getId());	if (joinRecords.size() > 0) {	AsyncJobJoinMapVO joinRecord = joinRecords.get(0);	for (AsyncJobDispatcher dispatcher : _jobDispatchers) {	if (dispatcher.getName().equals(joinRecord.getWakeupDispatcher())) return dispatcher;	}	} else {	
job is scheduled for wakeup run but there is no joining info anymore 

} finally {	NDC.pop();	}	}	protected void runInContext() {	long runNumber = getJobRunNumber();	try {	try {	JmxUtil.registerMBean("AsyncJobManager", "Active Job " + job.getId(), new AsyncJobMBeanImpl(job));	} catch (Exception e) {	
unable to register active job to jmx monitoring due to exception 

String related = job.getRelated();	String logContext = job.getShortUuid();	if (related != null && !related.isEmpty()) {	AsyncJob relatedJob = _jobDao.findByIdIncludingRemoved(Long.parseLong(related));	if (relatedJob != null) {	logContext = relatedJob.getShortUuid();	}	}	MDC.put("logcontextid", logContext);	if (s_logger.isDebugEnabled()) {	
executing 

}	}	MDC.put("logcontextid", logContext);	if (s_logger.isDebugEnabled()) {	}	if ((getAndResetPendingSignals(job) & AsyncJob.Constants.SIGNAL_MASK_WAKEUP) != 0) {	AsyncJobDispatcher jobDispatcher = getWakeupDispatcher(job);	if (jobDispatcher != null) {	jobDispatcher.runJob(job);	} else {	
unable to find a wakeup dispatcher from the joined job 

AsyncJobDispatcher jobDispatcher = getWakeupDispatcher(job);	if (jobDispatcher != null) {	jobDispatcher.runJob(job);	} else {	}	} else {	AsyncJobDispatcher jobDispatcher = getDispatcher(job.getDispatcher());	if (jobDispatcher != null) {	jobDispatcher.runJob(job);	} else {	
unable to find job dispatcher job will be cancelled 

}	} else {	AsyncJobDispatcher jobDispatcher = getDispatcher(job.getDispatcher());	if (jobDispatcher != null) {	jobDispatcher.runJob(job);	} else {	completeAsyncJob(job.getId(), JobInfo.Status.FAILED, ApiErrorCode.INTERNAL_ERROR.getHttpCode(), null);	}	}	if (s_logger.isDebugEnabled()) {	
done executing for job 

AsyncJobDispatcher jobDispatcher = getDispatcher(job.getDispatcher());	if (jobDispatcher != null) {	jobDispatcher.runJob(job);	} else {	completeAsyncJob(job.getId(), JobInfo.Status.FAILED, ApiErrorCode.INTERNAL_ERROR.getHttpCode(), null);	}	}	if (s_logger.isDebugEnabled()) {	}	} catch (Throwable e) {	
unexpected exception 

} catch (Throwable e) {	completeAsyncJob(job.getId(), JobInfo.Status.FAILED, ApiErrorCode.INTERNAL_ERROR.getHttpCode(), null);	} finally {	try {	if (job.getSyncSource() != null) {	_queueMgr.purgeItem(job.getSyncSource().getId());	}	try {	JmxUtil.unregisterMBean("AsyncJobManager", "Active Job " + job.getId());	} catch (Exception e) {	
unable to unregister job to jmx monitoring due to exception 

if (job.getSyncSource() != null) {	_queueMgr.purgeItem(job.getSyncSource().getId());	}	try {	JmxUtil.unregisterMBean("AsyncJobManager", "Active Job " + job.getId());	} catch (Exception e) {	}	AsyncJobExecutionContext.unregister();	_jobMonitor.unregisterActiveTask(runNumber);	} catch (Throwable e) {	
double exception 

private void executeQueueItem(SyncQueueItemVO item, boolean fromPreviousSession) {	AsyncJobVO job = _jobDao.findById(item.getContentId());	if (job != null) {	if (s_logger.isDebugEnabled()) {	
schedule queued job 

private void executeQueueItem(SyncQueueItemVO item, boolean fromPreviousSession) {	AsyncJobVO job = _jobDao.findById(item.getContentId());	if (job != null) {	if (s_logger.isDebugEnabled()) {	}	job.setSyncSource(item);	try {	job.setExecutingMsid(getMsid());	_jobDao.update(job.getId(), job);	} catch (Exception e) {	
unexpected exception while dispatching job 

if (s_logger.isDebugEnabled()) {	}	job.setSyncSource(item);	try {	job.setExecutingMsid(getMsid());	_jobDao.update(job.getId(), job);	} catch (Exception e) {	try {	_queueMgr.returnItem(item.getId());	} catch (Throwable thr) {	
unexpected exception while returning job to queue 

_jobDao.update(job.getId(), job);	} catch (Exception e) {	try {	_queueMgr.returnItem(item.getId());	} catch (Throwable thr) {	}	}	try {	scheduleExecution(job);	} catch (RejectedExecutionException e) {	
execution for job is rejected return it to the queue for next turn 

_queueMgr.returnItem(item.getId());	} catch (Throwable thr) {	}	}	try {	scheduleExecution(job);	} catch (RejectedExecutionException e) {	try {	_queueMgr.returnItem(item.getId());	} catch (Exception e2) {	
unexpected exception while returning job to queue 

scheduleExecution(job);	} catch (RejectedExecutionException e) {	try {	_queueMgr.returnItem(item.getId());	} catch (Exception e2) {	}	try {	job.setExecutingMsid(null);	_jobDao.update(job.getId(), job);	} catch (Exception e3) {	
unexpected exception while update job msid for bookkeeping 

} catch (Exception e2) {	}	try {	job.setExecutingMsid(null);	_jobDao.update(job.getId(), job);	} catch (Exception e3) {	}	}	} else {	if (s_logger.isDebugEnabled()) {	
unable to find related job for queue item 

public void releaseSyncSource() {	AsyncJobExecutionContext executionContext = AsyncJobExecutionContext.getCurrentExecutionContext();	assert (executionContext != null);	if (executionContext.getSyncSource() != null) {	if (s_logger.isDebugEnabled()) {	
release sync source for job sync source 

private void checkQueue(long queueId) {	while (true) {	try {	SyncQueueItemVO item = _queueMgr.dequeueFromOne(queueId, getMsid());	if (item != null) {	if (s_logger.isDebugEnabled()) {	
executing sync queue item 

try {	SyncQueueItemVO item = _queueMgr.dequeueFromOne(queueId, getMsid());	if (item != null) {	if (s_logger.isDebugEnabled()) {	}	executeQueueItem(item, false);	} else {	break;	}	} catch (Throwable e) {	
unexpected exception when kicking sync queue 

} finally {	scanLock.releaseRef();	}	}	protected void reallyRun() {	try {	List<SyncQueueItemVO> l = _queueMgr.dequeueFromAny(getMsid(), MAX_ONETIME_SCHEDULE_SIZE);	if (l != null && l.size() > 0) {	for (SyncQueueItemVO item : l) {	if (s_logger.isDebugEnabled()) {	
execute sync queue item 

}	executeQueueItem(item, false);	}	}	List<Long> standaloneWakeupJobs = wakeupScan();	for (Long jobId : standaloneWakeupJobs) {	AsyncJobVO job = _jobDao.findById(jobId);	if (job != null && (job.getPendingSignals() & AsyncJob.Constants.SIGNAL_MASK_WAKEUP) != 0) scheduleExecution(job, false);	}	} catch (Throwable e) {	
unexpected exception when trying to execute queue item 

} finally {	scanLock.unlock();	}	}	} finally {	scanLock.releaseRef();	}	}	public void reallyRun() {	try {	
begin cleanup expired async jobs 

scanLock.releaseRef();	}	}	public void reallyRun() {	try {	List<SyncQueueItemVO> blockItems = _queueMgr.getBlockedQueueItems(JobCancelThresholdMinutes.value() * 60000, false);	if (blockItems != null && blockItems.size() > 0) {	for (SyncQueueItemVO item : blockItems) {	try {	if (item.getContentType().equalsIgnoreCase(SyncQueueItem.AsyncJobContentType)) {	
remove job from queue since it has been blocked for too long 

List<SyncQueueItemVO> blockItems = _queueMgr.getBlockedQueueItems(JobCancelThresholdMinutes.value() * 60000, false);	if (blockItems != null && blockItems.size() > 0) {	for (SyncQueueItemVO item : blockItems) {	try {	if (item.getContentType().equalsIgnoreCase(SyncQueueItem.AsyncJobContentType)) {	completeAsyncJob(item.getContentId(), JobInfo.Status.FAILED, 0, "Job is cancelled as it has been blocking others for too long");	_jobMonitor.unregisterByJobId(item.getContentId());	}	_queueMgr.purgeItem(item.getId());	} catch (Throwable e) {	
unexpected exception when trying to remove job from sync queue 

}	_queueMgr.purgeItem(item.getId());	} catch (Throwable e) {	}	}	}	Date cutTime = new Date(DateUtil.currentGMTTime().getTime() - JobExpireMinutes.value() * 60000);	List<AsyncJobVO> unfinishedJobs = _jobDao.getExpiredUnfinishedJobs(cutTime, 100);	for (AsyncJobVO job : unfinishedJobs) {	try {	
expunging unfinished job 

}	}	}	Date cutTime = new Date(DateUtil.currentGMTTime().getTime() - JobExpireMinutes.value() * 60000);	List<AsyncJobVO> unfinishedJobs = _jobDao.getExpiredUnfinishedJobs(cutTime, 100);	for (AsyncJobVO job : unfinishedJobs) {	try {	_jobMonitor.unregisterByJobId(job.getId());	expungeAsyncJob(job);	} catch (Throwable e) {	
unexpected exception when trying to expunge job 

for (AsyncJobVO job : unfinishedJobs) {	try {	_jobMonitor.unregisterByJobId(job.getId());	expungeAsyncJob(job);	} catch (Throwable e) {	}	}	List<AsyncJobVO> completedJobs = _jobDao.getExpiredCompletedJobs(cutTime, 100);	for (AsyncJobVO job : completedJobs) {	try {	
expunging completed job 

_jobMonitor.unregisterByJobId(job.getId());	expungeAsyncJob(job);	} catch (Throwable e) {	}	}	List<AsyncJobVO> completedJobs = _jobDao.getExpiredCompletedJobs(cutTime, 100);	for (AsyncJobVO job : completedJobs) {	try {	expungeAsyncJob(job);	} catch (Throwable e) {	
unexpected exception when trying to expunge job 

} catch (Throwable e) {	}	}	List<AsyncJobVO> completedJobs = _jobDao.getExpiredCompletedJobs(cutTime, 100);	for (AsyncJobVO job : completedJobs) {	try {	expungeAsyncJob(job);	} catch (Throwable e) {	}	}	
end cleanup expired async jobs 

}	}	List<AsyncJobVO> completedJobs = _jobDao.getExpiredCompletedJobs(cutTime, 100);	for (AsyncJobVO job : completedJobs) {	try {	expungeAsyncJob(job);	} catch (Throwable e) {	}	}	} catch (Throwable e) {	
unexpected exception when trying to execute queue item 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	try {	final Properties dbProps = DbProperties.getDbProperties();	final int cloudMaxActive = Integer.parseInt(dbProps.getProperty("db.cloud.maxActive"));	int apiPoolSize = cloudMaxActive / 2;	int workPoolSize = (cloudMaxActive * 2) / 3;	
start asyncjobmanager api executor thread pool in size 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	try {	final Properties dbProps = DbProperties.getDbProperties();	final int cloudMaxActive = Integer.parseInt(dbProps.getProperty("db.cloud.maxActive"));	int apiPoolSize = cloudMaxActive / 2;	int workPoolSize = (cloudMaxActive * 2) / 3;	_apiJobExecutor = Executors.newFixedThreadPool(apiPoolSize, new NamedThreadFactory(AsyncJobManager.API_JOB_POOL_THREAD_PREFIX));	
start asyncjobmanager work executor thread pool in size 

private void cleanupLeftOverJobs(final long msid) {	try {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	_queueMgr.cleanupActiveQueueItems(msid, true);	List<AsyncJobVO> jobs = _jobDao.getResetJobs(msid);	for (AsyncJobVO job : jobs) {	if (s_logger.isDebugEnabled()) {	
cancel left over job 

List<AsyncJobVO> jobs = _jobDao.getResetJobs(msid);	for (AsyncJobVO job : jobs) {	if (s_logger.isDebugEnabled()) {	}	job.setStatus(JobInfo.Status.FAILED);	job.setResultCode(ApiErrorCode.INTERNAL_ERROR.getHttpCode());	job.setResult("job cancelled because of management server restart or shutdown");	job.setCompleteMsid(msid);	_jobDao.update(job.getId(), job);	if (s_logger.isDebugEnabled()) {	
purge queue item for cancelled job 

job.setResult("job cancelled because of management server restart or shutdown");	job.setCompleteMsid(msid);	_jobDao.update(job.getId(), job);	if (s_logger.isDebugEnabled()) {	}	_queueMgr.purgeAsyncJobQueueItemId(job.getId());	}	}	});	} catch (Throwable e) {	
unexpected exception in cleaning up left over jobs for mamagement server node 

========================= cloudstack sample_692 =========================

for (final PropertyDescriptor descriptor : descriptors) {	if (excludedProperties.contains(descriptor.getName())) {	continue;	}	serializedProperties.add(descriptor.getName());	final Object value = descriptor.getReadMethod().invoke(target);	serializedProperties.add(value != null ? value.toString() : "null");	}	return unmodifiableList(serializedProperties);	} catch (IntrospectionException e) {	
ignored introspectionexception when serializing class 

if (excludedProperties.contains(descriptor.getName())) {	continue;	}	serializedProperties.add(descriptor.getName());	final Object value = descriptor.getReadMethod().invoke(target);	serializedProperties.add(value != null ? value.toString() : "null");	}	return unmodifiableList(serializedProperties);	} catch (IntrospectionException e) {	} catch (IllegalArgumentException e) {	
ignored illegalargumentexception when serializing class 

continue;	}	serializedProperties.add(descriptor.getName());	final Object value = descriptor.getReadMethod().invoke(target);	serializedProperties.add(value != null ? value.toString() : "null");	}	return unmodifiableList(serializedProperties);	} catch (IntrospectionException e) {	} catch (IllegalArgumentException e) {	} catch (IllegalAccessException e) {	
ignored illegalaccessexception when serializing class 

}	serializedProperties.add(descriptor.getName());	final Object value = descriptor.getReadMethod().invoke(target);	serializedProperties.add(value != null ? value.toString() : "null");	}	return unmodifiableList(serializedProperties);	} catch (IntrospectionException e) {	} catch (IllegalArgumentException e) {	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	
ignored invocationtargetexception when serializing class 

========================= cloudstack sample_2842 =========================

public List<Class<?>> getCommands() {	List<Class<?>> cmdList = new ArrayList<Class<?>>();	cmdList.add(DefaultLoginAPIAuthenticatorCmd.class);	cmdList.add(DefaultLogoutAPIAuthenticatorCmd.class);	for (PluggableAPIAuthenticator apiAuthenticator: _apiAuthenticators) {	List<Class<?>> commands = apiAuthenticator.getAuthCommands();	if (commands != null) {	cmdList.addAll(commands);	} else {	
api authenticator returned null api commands 

public APIAuthenticator getAPIAuthenticator(String name) {	name = name.toLowerCase();	APIAuthenticator apiAuthenticator = null;	if (s_authenticators != null && s_authenticators.containsKey(name)) {	try {	apiAuthenticator = (APIAuthenticator) s_authenticators.get(name).newInstance();	apiAuthenticator = ComponentContext.inject(apiAuthenticator);	apiAuthenticator.setAuthenticators(_apiAuthenticators);	} catch (InstantiationException | IllegalAccessException e) {	if (s_logger.isDebugEnabled()) {	
apiauthenticationmanagerimpl getapiauthenticator failed 

========================= cloudstack sample_2511 =========================

public ConsoleProxyMonitor(String[] argv) {	_argv = argv;	for (String arg : _argv) {	String[] tokens = arg.split("=");	if (tokens.length == 2) {	s_logger.info("Add argument " + tokens[0] + "=" + tokens[1] + " to the argument map");	_argMap.put(tokens[0].trim(), tokens[1].trim());	} else {	
unrecognized argument skip adding it to argument map 

private void run() {	Runtime.getRuntime().addShutdownHook(new Thread() {	public void run() {	_quit = true;	onShutdown();	}	});	while (!_quit) {	String cmdLine = getLaunchCommandLine();	
launch console proxy process with command line 

public void run() {	_quit = true;	onShutdown();	}	});	while (!_quit) {	String cmdLine = getLaunchCommandLine();	try {	_process = Runtime.getRuntime().exec(cmdLine);	} catch (IOException e) {	
unexpected exception 

_process = Runtime.getRuntime().exec(cmdLine);	} catch (IOException e) {	System.exit(1);	}	boolean waitSucceeded = false;	int exitCode = 0;	while (!waitSucceeded) {	try {	exitCode = _process.waitFor();	waitSucceeded = true;	
console proxy process exits with code 

} catch (IOException e) {	System.exit(1);	}	boolean waitSucceeded = false;	int exitCode = 0;	while (!waitSucceeded) {	try {	exitCode = _process.waitFor();	waitSucceeded = true;	} catch (InterruptedException e) {	
interruptedexception while waiting for termination of console proxy will retry 

private void onShutdown() {	if (_process != null) {	
console proxy monitor shuts dwon terminate console proxy process 

========================= cloudstack sample_4996 =========================

_listenerMap.put(uploadVolumeObj, ul);	try {	EndPoint ep = _epSelector.select(secStore);	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	return;	}	ep.sendMessageAsync(ucmd, new UploadListener.Callback(ep.getId(), ul));	} catch (Exception e) {	
unable to start upload of volume from to 

_listenerMap.put(uploadTemplateObj, ul);	try {	EndPoint ep = _epSelector.select(secStore);	if (ep == null) {	String errMsg = "No remote endpoint to send command, check if host or ssvm is down?";	s_logger.error(errMsg);	return null;	}	ep.sendMessageAsync(ucmd, new UploadListener.Callback(ep.getId(), ul));	} catch (Exception e) {	
unable to start upload of from to 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	final Map<String, String> configs = _configDao.getConfiguration("management-server", params);	_sslCopy = Boolean.parseBoolean(configs.get("secstorage.encrypt.copy"));	String cert = configs.get("secstorage.secure.copy.cert");	if ("realhostip.com".equalsIgnoreCase(cert)) {	
only realhostip com ssl cert is supported ignoring self signed and other certs 

public void handleUploadSync(long sserverId) {	HostVO storageHost = _serverDao.findById(sserverId);	if (storageHost == null) {	
huh agent id does not correspond to a row in hosts table 

public void handleUploadSync(long sserverId) {	HostVO storageHost = _serverDao.findById(sserverId);	if (storageHost == null) {	return;	}	
handling upload sserverid 

try {	cleanupStorage();	} finally {	scanLock.unlock();	}	}	} finally {	scanLock.releaseRef();	}	} catch (Exception e) {	
caught the following exception 

public void cleanupStorage() {	final int EXTRACT_URL_LIFE_LIMIT_IN_SECONDS = _urlExpirationInterval;	List<UploadVO> extractJobs = _uploadDao.listByModeAndStatus(Mode.HTTP_DOWNLOAD, Status.DOWNLOAD_URL_CREATED);	for (UploadVO extractJob : extractJobs) {	if (getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS) {	String path = extractJob.getInstallPath();	DataStore secStore = storeMgr.getDataStore(extractJob.getDataStoreId(), DataStoreRole.Image);	DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(), extractJob.getUploadUrl(), ((ImageStoreVO)secStore).getParent());	EndPoint ep = _epSelector.select(secStore);	if (ep == null) {	
uploadmonitor cleanup there is no secondary storage vm for secondary storage host 

for (UploadVO extractJob : extractJobs) {	if (getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS) {	String path = extractJob.getInstallPath();	DataStore secStore = storeMgr.getDataStore(extractJob.getDataStoreId(), DataStoreRole.Image);	DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(), extractJob.getUploadUrl(), ((ImageStoreVO)secStore).getParent());	EndPoint ep = _epSelector.select(secStore);	if (ep == null) {	continue;	}	if (s_logger.isDebugEnabled()) {	
uploadmonitor cleanup sending deletion of extract url to ssvm 

========================= cloudstack sample_2454 =========================

public void execute() {	
getpathforvolumeidcmd execute method invoked 

========================= cloudstack sample_2004 =========================

UserVm result ;	result = _userVmService.startVirtualMachine(this);	if (result != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", result).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to start a vm");	}	} catch (ConcurrentOperationException ex) {	
exception 

if (result != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", result).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to start a vm");	}	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (StorageUnavailableException ex) {	
exception 

response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to start a vm");	}	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (StorageUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ExecutionException ex) {	
exception 

========================= cloudstack sample_3245 =========================

public Answer executeRequest(Command cmd) {	String hypervisor = cmd.getContextParam("hypervisor");	if (hypervisor != null) {	Hypervisor.HypervisorType hypervisorType = Hypervisor.HypervisorType.getType(hypervisor);	if (hypervisorType == null) {	
unsupported hypervisor type in command context hypervisor 

public Answer executeRequest(Command cmd) {	String hypervisor = cmd.getContextParam("hypervisor");	if (hypervisor != null) {	Hypervisor.HypervisorType hypervisorType = Hypervisor.HypervisorType.getType(hypervisor);	if (hypervisorType == null) {	return defaultAction(cmd);	}	SecondaryStorageResourceHandler handler = getHandler(hypervisorType);	if (handler == null) {	
no handler can be found for hypervisor type in command context hypervisor 

public void ensureOutgoingRuleForAddress(String address) {	if (address == null || address.isEmpty() || address.startsWith("0.0.0.0")) {	
drop invalid dynamic route firewall entry 

return;	}	boolean needToSetRule = false;	synchronized (_activeOutgoingAddresses) {	if (!_activeOutgoingAddresses.containsKey(address)) {	_activeOutgoingAddresses.put(address, address);	needToSetRule = true;	}	}	if (needToSetRule) {	
add dynamic route firewall entry for 

========================= cloudstack sample_1278 =========================

public ClusterServiceServletImpl(final String serviceUrl) {	
setup cluster service servlet service url request timeout seconds 

public boolean ping(final String callingPeer) throws RemoteException {	if (s_logger.isDebugEnabled()) {	
ping at 

int response = 0;	String result = null;	try {	final Profiler profiler = new Profiler();	profiler.start();	response = client.executeMethod(method);	if (response == HttpStatus.SC_OK) {	result = method.getResponseBodyAsString();	profiler.stop();	if (s_logger.isDebugEnabled()) {	
post response responding time ms 

final Profiler profiler = new Profiler();	profiler.start();	response = client.executeMethod(method);	if (response == HttpStatus.SC_OK) {	result = method.getResponseBodyAsString();	profiler.stop();	if (s_logger.isDebugEnabled()) {	}	} else {	profiler.stop();	
invalid response code from method method responding time 

response = client.executeMethod(method);	if (response == HttpStatus.SC_OK) {	result = method.getResponseBodyAsString();	profiler.stop();	if (s_logger.isDebugEnabled()) {	}	} else {	profiler.stop();	}	} catch (final HttpException e) {	
httpexception from method method 

if (response == HttpStatus.SC_OK) {	result = method.getResponseBodyAsString();	profiler.stop();	if (s_logger.isDebugEnabled()) {	}	} else {	profiler.stop();	}	} catch (final HttpException e) {	} catch (final IOException e) {	
ioexception from method method 

result = method.getResponseBodyAsString();	profiler.stop();	if (s_logger.isDebugEnabled()) {	}	} else {	profiler.stop();	}	} catch (final HttpException e) {	} catch (final IOException e) {	} catch (final Throwable e) {	
exception from method method exception 

========================= cloudstack sample_466 =========================

final Host.Record re = host.getRecord(conn);	final Set<HostPatch> patches = re.patches;	final PoolPatch poolPatch = PoolPatch.getByUuid(conn, hotFixUuid);	for(final HostPatch patch : patches) {	final PoolPatch pp = patch.getPoolPatch(conn);	if (pp.equals(poolPatch) && patch.getApplied(conn)) {	return true;	}	}	} catch (final Exception e) {	
can t get patches information for hotfix 

========================= cloudstack sample_1151 =========================

public Pair<Pod, Long> allocateTo(VirtualMachineTemplate template, ServiceOffering offering, DataCenter zone, long accountId, Set<Long> avoids) {	long zoneId = zone.getId();	List<HostPodVO> podsInZone = _podDao.listByDataCenterId(zoneId);	if (podsInZone.size() == 0) {	
no pods found in zone 

long podId = pod.getId();	if (!avoids.contains(podId)) {	if (template != null && !templateAvailableInPod(template.getId(), pod.getDataCenterId(), podId)) {	continue;	}	if (offering != null) {	long[] hostCandiates = new long[1];	boolean enoughCapacity = dataCenterAndPodHasEnoughCapacity(zoneId, podId, (offering.getRamSize()) * 1024L * 1024L, Capacity.CAPACITY_TYPE_MEMORY, hostCandiates);	if (!enoughCapacity) {	if (s_logger.isDebugEnabled()) {	
not enough ram available in zone pod to allocate storage for user vm zone pod 

long[] hostCandiates = new long[1];	boolean enoughCapacity = dataCenterAndPodHasEnoughCapacity(zoneId, podId, (offering.getRamSize()) * 1024L * 1024L, Capacity.CAPACITY_TYPE_MEMORY, hostCandiates);	if (!enoughCapacity) {	if (s_logger.isDebugEnabled()) {	}	continue;	}	enoughCapacity = dataCenterAndPodHasEnoughCapacity(zoneId, podId, ((long)offering.getCpu() * offering.getSpeed()), Capacity.CAPACITY_TYPE_CPU, hostCandiates);	if (!enoughCapacity) {	if (s_logger.isDebugEnabled()) {	
not enough cpu available in zone pod to allocate storage for user vm zone pod 

return new Pair<Pod, Long>(pod, podHostCandidates.get(podId));	}	List<VolumeVO> volumesInPod = _volumeDao.findByAccountAndPod(accountId, pod.getId());	if (!volumesInPod.isEmpty()) {	return new Pair<Pod, Long>(pod, podHostCandidates.get(podId));	}	availablePods.add(pod);	}	}	if (availablePods.size() == 0) {	
there are no pods with enough memory cpu capacity in zone 

return new Pair<Pod, Long>(pod, podHostCandidates.get(podId));	}	availablePods.add(pod);	}	}	if (availablePods.size() == 0) {	return null;	} else {	int next = _rand.nextInt(availablePods.size());	HostPodVO selectedPod = availablePods.get(next);	
found pod in zone 

private boolean dataCenterAndPodHasEnoughCapacity(long dataCenterId, long podId, long capacityNeeded, short capacityType, long[] hostCandidate) {	List<CapacityVO> capacities = null;	SearchCriteria<CapacityVO> sc = _capacityDao.createSearchCriteria();	sc.addAnd("capacityType", SearchCriteria.Op.EQ, capacityType);	sc.addAnd("dataCenterId", SearchCriteria.Op.EQ, dataCenterId);	sc.addAnd("podId", SearchCriteria.Op.EQ, podId);	
executing search 

private boolean dataCenterAndPodHasEnoughCapacity(long dataCenterId, long podId, long capacityNeeded, short capacityType, long[] hostCandidate) {	List<CapacityVO> capacities = null;	SearchCriteria<CapacityVO> sc = _capacityDao.createSearchCriteria();	sc.addAnd("capacityType", SearchCriteria.Op.EQ, capacityType);	sc.addAnd("dataCenterId", SearchCriteria.Op.EQ, dataCenterId);	sc.addAnd("podId", SearchCriteria.Op.EQ, podId);	capacities = _capacityDao.search(sc, null);	
done with a search 

private boolean skipCalculation(VMInstanceVO vm) {	if (vm.getState() == State.Expunging) {	if (s_logger.isDebugEnabled()) {	
skip counting capacity for expunging vm 

return true;	}	if (vm.getState() == State.Stopped || vm.getState() == State.Destroyed) {	int secondsToSkipVMs = _secondsToSkipStoppedVMs;	if (vm.getState() == State.Destroyed) {	secondsToSkipVMs = _secondsToSkipDestroyedVMs;	}	long millisecondsSinceLastUpdate = DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime();	if (millisecondsSinceLastUpdate > secondsToSkipVMs * 1000L) {	if (s_logger.isDebugEnabled()) {	
skip counting vm in capacity allocation as it has been for minutes 

if (vm.getType() == VirtualMachine.Type.User) {	UserVmVO userVm = _vmDao.findById(vm.getId());	if (userVm == null) {	continue;	}	}	so = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());	if (capacityType == Capacity.CAPACITY_TYPE_MEMORY) {	usedCapacity += so.getRamSize() * 1024L * 1024L;	if (s_logger.isDebugEnabled()) {	
counting memory capacity used by vm size mb host currently counted bytes 

}	}	so = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());	if (capacityType == Capacity.CAPACITY_TYPE_MEMORY) {	usedCapacity += so.getRamSize() * 1024L * 1024L;	if (s_logger.isDebugEnabled()) {	}	} else if (capacityType == Capacity.CAPACITY_TYPE_CPU) {	usedCapacity += so.getCpu() * so.getSpeed();	if (s_logger.isDebugEnabled()) {	
counting cpu capacity used by vm cpu speed currently counted bytes 

========================= cloudstack sample_2403 =========================

for (final RoleType allowedRole : allowedRoles) {	if (allowedRole.getAccountType() == caller.getType()) {	roleIsAllowed = true;	break;	}	}	}	if (roleIsAllowed) {	validFields.add(field);	} else {	
ignoring paremeter as the caller is not authorized to pass it in 

for(Map.Entry<Object, Object> entry : contextMap.entrySet()){	try{	Object key = entry.getKey();	Class clz = Class.forName((String)key);	if(Displayable.class.isAssignableFrom(clz)){	final Object objVO = getEntityVO(clz, entry.getValue());	isDisplay = ((Displayable) objVO).isDisplay();	}	if(!isDisplay) break;	} catch (Exception e){	
caught exception while checking first class entities for display property continuing on 

========================= cloudstack sample_3091 =========================

public void persistDefaultValues() throws InternalErrorException {	saveUser();	String init = _configDao.getValue("init");	if (init == null || init.equals("false")) {	
configurationserver is saving default values to the database 

String instance = "DEFAULT";	String component = c.getComponent();	String value = c.getDefaultValue();	String description = c.getDescription();	ConfigurationVO configVO = new ConfigurationVO(category, instance, component, name, value, description);	configVO.setDefaultValue(value);	_configDao.persist(configVO);	}	}	_configDao.update(Config.UseSecondaryStorageVm.key(), Config.UseSecondaryStorageVm.getCategory(), "true");	
configurationserver made secondary storage vm required 

String component = c.getComponent();	String value = c.getDefaultValue();	String description = c.getDescription();	ConfigurationVO configVO = new ConfigurationVO(category, instance, component, name, value, description);	configVO.setDefaultValue(value);	_configDao.persist(configVO);	}	}	_configDao.update(Config.UseSecondaryStorageVm.key(), Config.UseSecondaryStorageVm.getCategory(), "true");	_configDao.update(Config.SecStorageEncryptCopy.key(), Config.SecStorageEncryptCopy.getCategory(), "false");	
configurationserver made secondary storage copy encrypt set to false 

String value = c.getDefaultValue();	String description = c.getDescription();	ConfigurationVO configVO = new ConfigurationVO(category, instance, component, name, value, description);	configVO.setDefaultValue(value);	_configDao.persist(configVO);	}	}	_configDao.update(Config.UseSecondaryStorageVm.key(), Config.UseSecondaryStorageVm.getCategory(), "true");	_configDao.update(Config.SecStorageEncryptCopy.key(), Config.SecStorageEncryptCopy.getCategory(), "false");	_configDao.update("secstorage.secure.copy.cert", "realhostip");	
configurationserver made secondary storage copy use realhostip 

String description = c.getDescription();	ConfigurationVO configVO = new ConfigurationVO(category, instance, component, name, value, description);	configVO.setDefaultValue(value);	_configDao.persist(configVO);	}	}	_configDao.update(Config.UseSecondaryStorageVm.key(), Config.UseSecondaryStorageVm.getCategory(), "true");	_configDao.update(Config.SecStorageEncryptCopy.key(), Config.SecStorageEncryptCopy.getCategory(), "false");	_configDao.update("secstorage.secure.copy.cert", "realhostip");	_configDao.update("user.password.encoders.exclude", "MD5,LDAP,PLAINTEXT");	
configuration server excluded insecure encoders 

ConfigurationVO configVO = new ConfigurationVO(category, instance, component, name, value, description);	configVO.setDefaultValue(value);	_configDao.persist(configVO);	}	}	_configDao.update(Config.UseSecondaryStorageVm.key(), Config.UseSecondaryStorageVm.getCategory(), "true");	_configDao.update(Config.SecStorageEncryptCopy.key(), Config.SecStorageEncryptCopy.getCategory(), "false");	_configDao.update("secstorage.secure.copy.cert", "realhostip");	_configDao.update("user.password.encoders.exclude", "MD5,LDAP,PLAINTEXT");	_configDao.update("user.authenticators.exclude", "PLAINTEXT");	
configuration server excluded plaintext authenticator 

createServiceOffering(User.UID_SYSTEM, "Small Instance", 1, 512, 500, "Small Instance", ProvisioningType.THIN, false, false, null);	createServiceOffering(User.UID_SYSTEM, "Medium Instance", 1, 1024, 1000, "Medium Instance", ProvisioningType.THIN, false, false, null);	createdefaultDiskOffering(null, "Small", "Small Disk, 5 GB", ProvisioningType.THIN, 5, null, false, false);	createdefaultDiskOffering(null, "Medium", "Medium Disk, 20 GB", ProvisioningType.THIN, 20, null, false, false);	createdefaultDiskOffering(null, "Large", "Large Disk, 100 GB", ProvisioningType.THIN, 100, null, false, false);	createdefaultDiskOffering(null, "Large", "Large Disk, 100 GB", ProvisioningType.THIN, 100, null, false, false);	createdefaultDiskOffering(null, "Custom", "Custom Disk", ProvisioningType.THIN, 0, null, true, false);	String mountParent = getMountParent();	if (mountParent != null) {	_configDao.update(Config.MountParent.key(), Config.MountParent.getCategory(), mountParent);	
configurationserver saved mountparent as mount parent 

createServiceOffering(User.UID_SYSTEM, "Medium Instance", 1, 1024, 1000, "Medium Instance", ProvisioningType.THIN, false, false, null);	createdefaultDiskOffering(null, "Small", "Small Disk, 5 GB", ProvisioningType.THIN, 5, null, false, false);	createdefaultDiskOffering(null, "Medium", "Medium Disk, 20 GB", ProvisioningType.THIN, 20, null, false, false);	createdefaultDiskOffering(null, "Large", "Large Disk, 100 GB", ProvisioningType.THIN, 100, null, false, false);	createdefaultDiskOffering(null, "Large", "Large Disk, 100 GB", ProvisioningType.THIN, 100, null, false, false);	createdefaultDiskOffering(null, "Custom", "Custom Disk", ProvisioningType.THIN, 0, null, true, false);	String mountParent = getMountParent();	if (mountParent != null) {	_configDao.update(Config.MountParent.key(), Config.MountParent.getCategory(), mountParent);	} else {	
configurationserver could not detect mount parent 

if (hostIpAdr != null) {	Boolean devel = Boolean.valueOf(_configDao.getValue("developer"));	if (devel) {	String value = _configDao.getValue(ApiServiceConfiguration.ManagementHostIPAdr.key());	if (value != null && !value.equals("localhost")) {	needUpdateHostIp = false;	}	}	if (needUpdateHostIp) {	_configDepot.createOrUpdateConfigObject(ApiServiceConfiguration.class.getSimpleName(), ApiServiceConfiguration.ManagementHostIPAdr, hostIpAdr);	
configurationserver saved hostipadr as host 

stmtInsert = txn.prepareAutoCloseStatement("INSERT INTO vm_template_details(template_id, name, value) VALUES(?, ?, ?)");	stmtInsert.setLong(1, id);	stmtInsert.setString(2, name);	stmtInsert.setString(3, value);	if (stmtInsert.executeUpdate() < 1) {	throw new CloudRuntimeException("Unable to init template " + id + " datails: " + name);	}	}	txn.commit();	} catch (Exception e) {	
unable to init template datails 

rs2 = pstmt.executeQuery();	List<Long> tmpl_ids = new ArrayList<Long>();	while (rs2.next()) {	tmpl_ids.add(rs2.getLong(1));	}	for (Long tmpl_id : tmpl_ids) {	templateDetailsInitIfNotExist(tmpl_id, "hypervisortoolsversion", pvdriverversion);	}	}	} catch (Exception e) {	
initiatexenserverpvdriverversion failed due to 

private String getEnvironmentProperty(String name) {	try {	final File propsFile = PropertiesUtil.findConfigFile("environment.properties");	if (propsFile == null) {	return null;	} else {	final Properties props = new Properties();	try(final FileInputStream finputstream = new FileInputStream(propsFile);) {	props.load(finputstream);	}catch (IOException e) {	
getenvironmentproperty exception 

public void saveUser() {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	String insertSql = "INSERT INTO `cloud`.`account` (id, uuid, account_name, type, role_id, domain_id, account.default) VALUES (1, UUID(), 'system', '1', '1', '1', 1)";	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
looks like system account already exists 

try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	}	insertSql = "INSERT INTO `cloud`.`user` (id, uuid, username, password, account_id, firstname, lastname, created, user.default)" + " VALUES (1, UUID(), 'system', RAND(), 1, 'system', 'cloud', now(), 1)";	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
looks like system user already exists 

}	long id = 2;	String username = "admin";	String firstname = "admin";	String lastname = "cloud";	insertSql = "INSERT INTO `cloud`.`account` (id, uuid, account_name, type, role_id, domain_id, account.default) VALUES (" + id + ", UUID(), '" + username + "', '1', '1', '1', 1)";	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
looks like admin account already exists 

try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	}	insertSql = "INSERT INTO `cloud`.`user` (id, uuid, username, password, account_id, firstname, lastname, created, state, user.default) " + "VALUES (" + id + ", UUID(), '" + username + "', RAND(), 2, '" + firstname + "','" + lastname + "',now(), 'disabled', 1)";	try {	PreparedStatement stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
looks like admin user already exists 

if (!rs.next()) {	if (tableName.equals("security_group")) {	insertSql = "INSERT INTO " + tableName + " (uuid, name, description, account_id, domain_id) " + "VALUES (UUID(), 'default', 'Default Security Group', 2, 1)";	} else {	insertSql = "INSERT INTO " + tableName + " (name, description, account_id, domain_id, account_name) " + "VALUES ('default', 'Default Security Group', 2, 1, 'admin')";	}	try {	stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	
failed to create default security group for default admin account due to 

insertSql = "INSERT INTO " + tableName + " (name, description, account_id, domain_id, account_name) " + "VALUES ('default', 'Default Security Group', 2, 1, 'admin')";	}	try {	stmt = txn.prepareAutoCloseStatement(insertSql);	stmt.executeUpdate();	} catch (SQLException ex) {	}	}	rs.close();	} catch (Exception ex) {	
failed to create default security group for default admin account due to 

ou = InetAddress.getLocalHost().getCanonicalHostName();	String[] group = ou.split("\\.");	boolean isIPAddress = Pattern.matches("[0-9]$", group[group.length - 1]);	if (isIPAddress) {	ou = "cloud.com";	} else {	ou = group[group.length - 1];	for (int i = group.length - 2; i >= 0 && i >= group.length - 3; i--) ou = group[i] + "." + ou;	}	} catch (UnknownHostException ex) {	
fail to get user s domain name would use cloud com 

protected void updateSSLKeystore() {	if (s_logger.isInfoEnabled()) {	
processing updatesslkeystore 

File confFile = PropertiesUtil.findConfigFile("db.properties");	String confPath = null;	String keystorePath = null;	File keystoreFile = null;	if (null != confFile) {	confPath = confFile.getParent();	keystorePath = confPath + Link.keystoreFile;	keystoreFile = new File(keystorePath);	}	boolean dbExisted = (dbString != null && !dbString.isEmpty());	
ssl keystore located at 

if (null != confFile) {	confPath = confFile.getParent();	keystorePath = confPath + Link.keystoreFile;	keystoreFile = new File(keystorePath);	}	boolean dbExisted = (dbString != null && !dbString.isEmpty());	try {	if (!dbExisted && null != confFile) {	if (!keystoreFile.exists()) {	generateDefaultKeystore(keystorePath);	
generated ssl keystore 

}	boolean dbExisted = (dbString != null && !dbString.isEmpty());	try {	if (!dbExisted && null != confFile) {	if (!keystoreFile.exists()) {	generateDefaultKeystore(keystorePath);	}	String base64Keystore = getBase64Keystore(keystorePath);	ConfigurationVO configVO = new ConfigurationVO("Hidden", "DEFAULT", "management-server", "ssl.keystore", base64Keystore, "SSL Keystore for the management servers");	_configDao.persist(configVO);	
stored ssl keystore to database 

if (null != keystorePath) {	script.add(keystorePath);	}	String result = script.execute();	if (result != null) {	throw new IOException();	}	} catch (Exception e) {	throw new IOException("Fail to create keystore file!", e);	}	
stored database keystore to local 

}	String result = script.execute();	if (result != null) {	throw new IOException();	}	} catch (Exception e) {	throw new IOException("Fail to create keystore file!", e);	}	}	} catch (Exception ex) {	
would use fail safe keystore to continue 

}	String already = _configDao.getValue("system.vm.password");	if (already == null) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	String rpassword = _mgrService.generateRandomPassword();	String wSql = "INSERT INTO `cloud`.`configuration` (category, instance, component, name, value, description) " + "VALUES ('Secure','DEFAULT', 'management-server','system.vm.password', ?,'randmon password generated each management server starts for system vm')";	PreparedStatement stmt = txn.prepareAutoCloseStatement(wSql);	stmt.setString(1, DBEncryptionUtil.encrypt(rpassword));	stmt.executeUpdate();	
updated systemvm password in database 

String already = _configDao.getValue("system.vm.password");	if (already == null) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	String rpassword = _mgrService.generateRandomPassword();	String wSql = "INSERT INTO `cloud`.`configuration` (category, instance, component, name, value, description) " + "VALUES ('Secure','DEFAULT', 'management-server','system.vm.password', ?,'randmon password generated each management server starts for system vm')";	PreparedStatement stmt = txn.prepareAutoCloseStatement(wSql);	stmt.setString(1, DBEncryptionUtil.encrypt(rpassword));	stmt.executeUpdate();	} catch (SQLException e) {	
cannot retrieve systemvm password 

public void updateKeyPairs() {	String username = System.getProperty("user.name");	Boolean devel = Boolean.valueOf(_configDao.getValue("developer"));	if (!username.equalsIgnoreCase("cloud") && !devel) {	
systemvm keypairs could not be set management server should be run as cloud user or in development mode 

Boolean devel = Boolean.valueOf(_configDao.getValue("developer"));	if (!username.equalsIgnoreCase("cloud") && !devel) {	return;	}	String already = _configDao.getValue("ssh.privatekey");	String homeDir = System.getProperty("user.home");	if (homeDir == null) {	throw new CloudRuntimeException("Cannot get home directory for account: " + username);	}	if (s_logger.isInfoEnabled()) {	
processing updatekeypairs 

return;	}	String already = _configDao.getValue("ssh.privatekey");	String homeDir = System.getProperty("user.home");	if (homeDir == null) {	throw new CloudRuntimeException("Cannot get home directory for account: " + username);	}	if (s_logger.isInfoEnabled()) {	}	if (homeDir != null && homeDir.startsWith("~")) {	
no home directory was detected for the user please check the profile of this user 

File pubkeyfile = null;	if (devel) {	privkeyfile = new File(homeDir + "/.ssh/id_rsa.cloud");	pubkeyfile = new File(homeDir + "/.ssh/id_rsa.cloud.pub");	} else {	privkeyfile = new File(homeDir + "/.ssh/id_rsa");	pubkeyfile = new File(homeDir + "/.ssh/id_rsa.pub");	}	if (already == null || already.isEmpty()) {	if (s_logger.isInfoEnabled()) {	
systemvm keypairs not found in database need to store them in the database 

if (s_logger.isInfoEnabled()) {	}	boolean onWindows = isOnWindows();	if(!onWindows) {	Script.runSimpleBashScript("if [ -f " + privkeyfile + " ]; then rm -f " + privkeyfile + "; fi; ssh-keygen -t rsa -N '' -f " + privkeyfile + " -q");	}	byte[] arr1 = new byte[4094];	try (DataInputStream dis = new DataInputStream(new FileInputStream(privkeyfile))) {	dis.readFully(arr1);	} catch (EOFException e) {	
ignored eof reached 

}	boolean onWindows = isOnWindows();	if(!onWindows) {	Script.runSimpleBashScript("if [ -f " + privkeyfile + " ]; then rm -f " + privkeyfile + "; fi; ssh-keygen -t rsa -N '' -f " + privkeyfile + " -q");	}	byte[] arr1 = new byte[4094];	try (DataInputStream dis = new DataInputStream(new FileInputStream(privkeyfile))) {	dis.readFully(arr1);	} catch (EOFException e) {	} catch (Exception e) {	
cannot read the private key file 

dis.readFully(arr1);	} catch (EOFException e) {	} catch (Exception e) {	throw new CloudRuntimeException("Cannot read the private key file");	}	String privateKey = new String(arr1).trim();	byte[] arr2 = new byte[4094];	try (DataInputStream dis = new DataInputStream(new FileInputStream(pubkeyfile))) {	dis.readFully(arr2);	} catch (EOFException e) {	
ignored eof reached 

} catch (EOFException e) {	} catch (Exception e) {	throw new CloudRuntimeException("Cannot read the private key file");	}	String privateKey = new String(arr1).trim();	byte[] arr2 = new byte[4094];	try (DataInputStream dis = new DataInputStream(new FileInputStream(pubkeyfile))) {	dis.readFully(arr2);	} catch (EOFException e) {	} catch (Exception e) {	
cannot read the public key file 

String publicKey = new String(arr2).trim();	final String insertSql1 = "INSERT INTO `cloud`.`configuration` (category, instance, component, name, value, description) " + "VALUES ('Hidden','DEFAULT', 'management-server','ssh.privatekey', '" + DBEncryptionUtil.encrypt(privateKey) + "','Private key for the entire CloudStack')";	final String insertSql2 = "INSERT INTO `cloud`.`configuration` (category, instance, component, name, value, description) " + "VALUES ('Hidden','DEFAULT', 'management-server','ssh.publickey', '" + DBEncryptionUtil.encrypt(publicKey) + "','Public key for the entire CloudStack')";	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt1 = txn.prepareAutoCloseStatement(insertSql1);	stmt1.executeUpdate();	if (s_logger.isDebugEnabled()) {	
private key inserted into database 

final String insertSql2 = "INSERT INTO `cloud`.`configuration` (category, instance, component, name, value, description) " + "VALUES ('Hidden','DEFAULT', 'management-server','ssh.publickey', '" + DBEncryptionUtil.encrypt(publicKey) + "','Public key for the entire CloudStack')";	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt1 = txn.prepareAutoCloseStatement(insertSql1);	stmt1.executeUpdate();	if (s_logger.isDebugEnabled()) {	}	} catch (SQLException ex) {	
sql of the private key failed 

stmt1.executeUpdate();	if (s_logger.isDebugEnabled()) {	}	} catch (SQLException ex) {	throw new CloudRuntimeException("SQL of the private key failed");	}	try {	PreparedStatement stmt2 = txn.prepareAutoCloseStatement(insertSql2);	stmt2.executeUpdate();	if (s_logger.isDebugEnabled()) {	
public key inserted into database 

}	} catch (SQLException ex) {	throw new CloudRuntimeException("SQL of the private key failed");	}	try {	PreparedStatement stmt2 = txn.prepareAutoCloseStatement(insertSql2);	stmt2.executeUpdate();	if (s_logger.isDebugEnabled()) {	}	} catch (SQLException ex) {	
sql of the public key failed 

PreparedStatement stmt2 = txn.prepareAutoCloseStatement(insertSql2);	stmt2.executeUpdate();	if (s_logger.isDebugEnabled()) {	}	} catch (SQLException ex) {	throw new CloudRuntimeException("SQL of the public key failed");	}	}	});	} else {	
keypairs already in database updating local copy 

if (s_logger.isDebugEnabled()) {	}	} catch (SQLException ex) {	throw new CloudRuntimeException("SQL of the public key failed");	}	}	});	} else {	updateKeyPairsOnDisk(homeDir);	}	
going to update systemvm iso with generated keypairs if needed 

private void writeKeyToDisk(String key, String keyPath) {	File keyfile = new File(keyPath);	if (!keyfile.exists()) {	try {	keyfile.createNewFile();	} catch (IOException e) {	
failed to create file 

} catch (IOException e) {	throw new CloudRuntimeException("Failed to update keypairs on disk: cannot create  key file " + keyPath);	}	}	if (keyfile.exists()) {	try (FileOutputStream kStream = new FileOutputStream(keyfile);){	if (kStream != null) {	kStream.write(key.getBytes());	}	} catch (FileNotFoundException e) {	
failed to write key to 

}	}	if (keyfile.exists()) {	try (FileOutputStream kStream = new FileOutputStream(keyfile);){	if (kStream != null) {	kStream.write(key.getBytes());	}	} catch (FileNotFoundException e) {	throw new CloudRuntimeException("Failed to update keypairs on disk: cannot find  key file " + keyPath);	} catch (IOException e) {	
failed to write key to 

private void updateKeyPairsOnDisk(String homeDir) {	File keyDir = new File(homeDir + "/.ssh");	Boolean devel = Boolean.valueOf(_configDao.getValue("developer"));	if (!keyDir.isDirectory()) {	
failed to create ssh for storing the ssh keypars 

protected void injectSshKeysIntoSystemVmIsoPatch(String publicKeyPath, String privKeyPath) {	
trying to inject public and private keys into systemvm iso 

scriptPath = scriptPath.replaceAll("\\\\" ,"/" );	systemVmIsoPath = systemVmIsoPath.replaceAll("\\\\" ,"/" );	publicKeyPath = publicKeyPath.replaceAll("\\\\" ,"/" );	privKeyPath = privKeyPath.replaceAll("\\\\" ,"/" );	}	command.add(scriptPath);	command.add(publicKeyPath);	command.add(privKeyPath);	command.add(systemVmIsoPath);	final String result = command.execute();	
injected public and private keys into systemvm iso with result 

systemVmIsoPath = systemVmIsoPath.replaceAll("\\\\" ,"/" );	publicKeyPath = publicKeyPath.replaceAll("\\\\" ,"/" );	privKeyPath = privKeyPath.replaceAll("\\\\" ,"/" );	}	command.add(scriptPath);	command.add(publicKeyPath);	command.add(privKeyPath);	command.add(systemVmIsoPath);	final String result = command.execute();	if (result != null) {	
failed to inject generated public key into systemvm iso 

protected void generateSecStorageVmCopyPassword() {	String already = _configDao.getValue("secstorage.copy.password");	if (already == null) {	
need to store secondary storage vm copy password in the database 

String already = _configDao.getValue("secstorage.copy.password");	if (already == null) {	String password = PasswordGenerator.generateRandomPassword(12);	final String insertSql1 = "INSERT INTO `cloud`.`configuration` (category, instance, component, name, value, description) " + "VALUES ('Hidden','DEFAULT', 'management-server','secstorage.copy.password', '" + DBEncryptionUtil.encrypt(password) + "','Password used to authenticate zone-to-zone template copy requests')";	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt1 = txn.prepareAutoCloseStatement(insertSql1);	stmt1.executeUpdate();	
secondary storage vm copy password inserted into database 

if (already == null) {	String password = PasswordGenerator.generateRandomPassword(12);	final String insertSql1 = "INSERT INTO `cloud`.`configuration` (category, instance, component, name, value, description) " + "VALUES ('Hidden','DEFAULT', 'management-server','secstorage.copy.password', '" + DBEncryptionUtil.encrypt(password) + "','Password used to authenticate zone-to-zone template copy requests')";	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	PreparedStatement stmt1 = txn.prepareAutoCloseStatement(insertSql1);	stmt1.executeUpdate();	} catch (SQLException ex) {	
failed to insert secondary storage vm copy password 

private void updateSSOKey() {	try {	_configDao.update(Config.SSOKey.key(), Config.SSOKey.getCategory(), getPrivateKey());	} catch (NoSuchAlgorithmException ex) {	
error generating sso key 

private void updateSecondaryStorageVMSharedKey() {	try {	ConfigurationVO configInDB = _configDao.findByName(Config.SSVMPSK.key());	if(configInDB == null) {	ConfigurationVO configVO = new ConfigurationVO(Config.SSVMPSK.getCategory(), "DEFAULT", Config.SSVMPSK.getComponent(), Config.SSVMPSK.key(), getPrivateKey(), Config.SSVMPSK.getDescription());	
generating a new ssvm psk this goes to ssvm on start 

private void updateSecondaryStorageVMSharedKey() {	try {	ConfigurationVO configInDB = _configDao.findByName(Config.SSVMPSK.key());	if(configInDB == null) {	ConfigurationVO configVO = new ConfigurationVO(Config.SSVMPSK.getCategory(), "DEFAULT", Config.SSVMPSK.getComponent(), Config.SSVMPSK.key(), getPrivateKey(), Config.SSVMPSK.getDescription());	_configDao.persist(configVO);	} else if (StringUtils.isEmpty(configInDB.getValue())) {	
updating the ssvm psk with new value this goes to ssvm on start 

private void updateSecondaryStorageVMSharedKey() {	try {	ConfigurationVO configInDB = _configDao.findByName(Config.SSVMPSK.key());	if(configInDB == null) {	ConfigurationVO configVO = new ConfigurationVO(Config.SSVMPSK.getCategory(), "DEFAULT", Config.SSVMPSK.getComponent(), Config.SSVMPSK.key(), getPrivateKey(), Config.SSVMPSK.getDescription());	_configDao.persist(configVO);	} else if (StringUtils.isEmpty(configInDB.getValue())) {	_configDao.update(Config.SSVMPSK.key(), Config.SSVMPSK.getCategory(), getPrivateKey());	}	} catch (NoSuchAlgorithmException ex) {	
error generating ssvm psk 

}	String[] linkLocalIpRanges = NetUtils.getLinkLocalIPRange(nums);	if (linkLocalIpRanges == null) {	throw new InvalidParameterValueException("The linkLocalIp.nums: " + nums + "may be wrong, should be 1~16");	} else {	_zoneDao.addLinkLocalIpAddress(zoneId, pod.getId(), linkLocalIpRanges[0], linkLocalIpRanges[1]);	}	}	});	} catch (Exception e) {	
unable to create new pod due to 

netscalerServiceProviders.put(Service.StaticNat, Provider.Netscaler);	netscalerServiceProviders.put(Service.Lb, Provider.Netscaler);	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	NetworkOfferingVO defaultSharedSGNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultSharedNetworkOfferingWithSGService, "Offering for Shared Security group enabled networks", TrafficType.Guest, false, true, null, null, true, Availability.Optional, null, Network.GuestType.Shared, true, true, false, false, false);	defaultSharedSGNetworkOffering.setState(NetworkOffering.State.Enabled);	defaultSharedSGNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultSharedSGNetworkOffering);	for (Service service : defaultSharedSGNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultSharedSGNetworkOffering.getId(), service, defaultSharedSGNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

for (Service service : defaultSharedSGNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultSharedSGNetworkOffering.getId(), service, defaultSharedSGNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	}	NetworkOfferingVO defaultSharedNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultSharedNetworkOffering, "Offering for Shared networks", TrafficType.Guest, false, true, null, null, true, Availability.Optional, null, Network.GuestType.Shared, true, true, false, false, false);	defaultSharedNetworkOffering.setState(NetworkOffering.State.Enabled);	defaultSharedNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultSharedNetworkOffering);	for (Service service : defaultSharedNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultSharedNetworkOffering.getId(), service, defaultSharedNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

for (Service service : defaultSharedNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultSharedNetworkOffering.getId(), service, defaultSharedNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	}	NetworkOfferingVO defaultIsolatedSourceNatEnabledNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultIsolatedNetworkOfferingWithSourceNatService, "Offering for Isolated networks with Source Nat service enabled", TrafficType.Guest, false, false, null, null, true, Availability.Required, null, Network.GuestType.Isolated, true, false, false, false, true);	defaultIsolatedSourceNatEnabledNetworkOffering.setState(NetworkOffering.State.Enabled);	defaultIsolatedSourceNatEnabledNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultIsolatedSourceNatEnabledNetworkOffering);	for (Service service : defaultIsolatedSourceNatEnabledNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultIsolatedSourceNatEnabledNetworkOffering.getId(), service, defaultIsolatedSourceNatEnabledNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

for (Service service : defaultIsolatedSourceNatEnabledNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultIsolatedSourceNatEnabledNetworkOffering.getId(), service, defaultIsolatedSourceNatEnabledNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	}	NetworkOfferingVO defaultIsolatedEnabledNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultIsolatedNetworkOffering, "Offering for Isolated networks with no Source Nat service", TrafficType.Guest, false, true, null, null, true, Availability.Optional, null, Network.GuestType.Isolated, true, true, false, false, false);	defaultIsolatedEnabledNetworkOffering.setState(NetworkOffering.State.Enabled);	defaultIsolatedEnabledNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultIsolatedEnabledNetworkOffering);	for (Service service : defaultIsolatedNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultIsolatedEnabledNetworkOffering.getId(), service, defaultIsolatedNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

for (Service service : defaultIsolatedNetworkOfferingProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultIsolatedEnabledNetworkOffering.getId(), service, defaultIsolatedNetworkOfferingProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	}	NetworkOfferingVO defaultNetscalerNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultSharedEIPandELBNetworkOffering, "Offering for Shared networks with Elastic IP and Elastic LB capabilities", TrafficType.Guest, false, true, null, null, true, Availability.Optional, null, Network.GuestType.Shared, true, false, false, false, true, true, true, false, false, true, true, false, false, false);	defaultNetscalerNetworkOffering.setState(NetworkOffering.State.Enabled);	defaultNetscalerNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultNetscalerNetworkOffering);	for (Service service : netscalerServiceProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultNetscalerNetworkOffering.getId(), service, netscalerServiceProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

defaultVpcNetworkOfferingProviders.put(Service.NetworkACL, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProviders.put(Service.Gateway, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProviders.put(Service.Lb, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProviders.put(Service.SourceNat, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProviders.put(Service.StaticNat, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProviders.put(Service.PortForwarding, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProviders.put(Service.Vpn, Provider.VPCVirtualRouter);	for (Map.Entry<Service,Provider> entry : defaultVpcNetworkOfferingProviders.entrySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultNetworkOfferingForVpcNetworks.getId(), entry.getKey(), entry.getValue());	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

defaultVpcNetworkOfferingProvidersNoLB.put(Service.UserData, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProvidersNoLB.put(Service.NetworkACL, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProvidersNoLB.put(Service.Gateway, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProvidersNoLB.put(Service.SourceNat, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProvidersNoLB.put(Service.StaticNat, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProvidersNoLB.put(Service.PortForwarding, Provider.VPCVirtualRouter);	defaultVpcNetworkOfferingProvidersNoLB.put(Service.Vpn, Provider.VPCVirtualRouter);	for (Map.Entry<Service,Provider> entry : defaultVpcNetworkOfferingProvidersNoLB.entrySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(defaultNetworkOfferingForVpcNetworksNoLB.getId(), entry.getKey(), entry.getValue());	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

internalLbOffProviders.put(Service.Dhcp, Provider.VPCVirtualRouter);	internalLbOffProviders.put(Service.Dns, Provider.VPCVirtualRouter);	internalLbOffProviders.put(Service.UserData, Provider.VPCVirtualRouter);	internalLbOffProviders.put(Service.NetworkACL, Provider.VPCVirtualRouter);	internalLbOffProviders.put(Service.Gateway, Provider.VPCVirtualRouter);	internalLbOffProviders.put(Service.Lb, Provider.InternalLbVm);	internalLbOffProviders.put(Service.SourceNat, Provider.VPCVirtualRouter);	for (Service service : internalLbOffProviders.keySet()) {	NetworkOfferingServiceMapVO offService = new NetworkOfferingServiceMapVO(internalLbOff.getId(), service, internalLbOffProviders.get(service));	_ntwkOfferingServiceMapDao.persist(offService);	
added service for the network offering 

if (resourceType.supportsOwner(ResourceOwnerType.Account)) {	accountSupportedResourceTypes.add(resourceType);	}	if (resourceType.supportsOwner(ResourceOwnerType.Domain)) {	domainSupportedResourceTypes.add(resourceType);	}	}	final int accountExpectedCount = accountSupportedResourceTypes.size();	final int domainExpectedCount = domainSupportedResourceTypes.size();	if ((domainResourceCount.size() < domainExpectedCount * domains.size())) {	
resource count table has records missing for some domains going to insert them 

s_logger.debug("Inserting resource count of type " + resourceType + " for domain id=" + domain.getId());	_resourceCountDao.persist(resourceCountVO);	}	}	}	}	});	}	}	if ((accountResourceCount.size() < accountExpectedCount * accounts.size())) {	
resource count table has records missing for some accounts going to insert them 

========================= cloudstack sample_2395 =========================

public void handle(HttpExchange t) throws IOException {	try {	
ajaxhandler 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	
process time ms 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IOException e) {	throw e;	} catch (IllegalArgumentException e) {	
exception 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IOException e) {	throw e;	} catch (IllegalArgumentException e) {	t.sendResponseHeaders(400, -1);	} catch (Throwable e) {	
unexpected exception 

private void doHandle(HttpExchange t) throws Exception, IllegalArgumentException {	String queries = t.getRequestURI().getQuery();	
handle ajax request 

String username = queryMap.get("username");	String password = queryMap.get("password");	if (tag == null) tag = "";	long ajaxSessionId = 0;	int event = 0;	int port;	if (host == null || portStr == null || sid == null) throw new IllegalArgumentException();	try {	port = Integer.parseInt(portStr);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

if (host == null || portStr == null || sid == null) throw new IllegalArgumentException();	try {	port = Integer.parseInt(portStr);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	if (ajaxSessionIdStr != null) {	try {	ajaxSessionId = Long.parseLong(ajaxSessionIdStr);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

try {	ajaxSessionId = Long.parseLong(ajaxSessionIdStr);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	}	if (eventStr != null) {	try {	event = Integer.parseInt(eventStr);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

param.setClientTag(tag);	param.setTicket(ticket);	param.setClientTunnelUrl(console_url);	param.setClientTunnelSession(console_host_session);	param.setLocale(vm_locale);	param.setHypervHost(hypervHost);	param.setUsername(username);	param.setPassword(password);	viewer = ConsoleProxy.getAjaxVncViewer(param, ajaxSessionIdStr);	} catch (Exception e) {	
failed to create viewer due to 

if (event != 0) {	if (ajaxSessionId != 0 && ajaxSessionId == viewer.getAjaxSessionId()) {	if (event == 7) {	InputStream is = t.getRequestBody();	handleClientEventBag(viewer, convertStreamToString(is, true));	} else {	handleClientEvent(viewer, event, queryMap);	}	sendResponse(t, "text/html", "OK");	} else {	
ajax request comes from a different session id in request id in viewer 

handleClientEventBag(viewer, convertStreamToString(is, true));	} else {	handleClientEvent(viewer, event, queryMap);	}	sendResponse(t, "text/html", "OK");	} else {	sendResponse(t, "text/html", "Invalid ajax client session id");	}	} else {	if (ajaxSessionId != 0 && ajaxSessionId != viewer.getAjaxSessionId()) {	
ajax request comes from a different session id in request id in viewer 

handleClientEvent(viewer, event, queryMap);	}	sendResponse(t, "text/html", "OK");	} else {	sendResponse(t, "text/html", "Invalid ajax client session id");	}	} else {	if (ajaxSessionId != 0 && ajaxSessionId != viewer.getAjaxSessionId()) {	handleClientKickoff(t, viewer);	} else if (ajaxSessionId == 0) {	
ajax request indicates a fresh client start 

sendResponse(t, "text/html", "Invalid ajax client session id");	}	} else {	if (ajaxSessionId != 0 && ajaxSessionId != viewer.getAjaxSessionId()) {	handleClientKickoff(t, viewer);	} else if (ajaxSessionId == 0) {	String title = queryMap.get("t");	String guest = queryMap.get("guest");	handleClientStart(t, viewer, title != null ? title : "", guest);	} else {	
ajax request indicates client update 

private static String convertStreamToString(InputStream is, boolean closeStreamAfterRead) {	BufferedReader reader = new BufferedReader(new InputStreamReader(is));	StringBuilder sb = new StringBuilder();	String line = null;	try {	while ((line = reader.readLine()) != null) {	sb.append(line + "\n");	}	} catch (IOException e) {	
exception while reading request body 

private void handleClientEventBag(ConsoleProxyClient viewer, String requestData) {	
handle event bag event bag 

code = Integer.parseInt(tokens[parsePos++]);	modifiers = Integer.parseInt(tokens[parsePos++]);	Map<String, String> queryMap = new HashMap<String, String>();	queryMap.put("event", String.valueOf(event));	queryMap.put("code", String.valueOf(code));	queryMap.put("modifier", String.valueOf(modifiers));	handleClientEvent(viewer, event, queryMap);	}	}	} catch (NumberFormatException e) {	
exception in handle client event bag 

modifiers = Integer.parseInt(tokens[parsePos++]);	Map<String, String> queryMap = new HashMap<String, String>();	queryMap.put("event", String.valueOf(event));	queryMap.put("code", String.valueOf(code));	queryMap.put("modifier", String.valueOf(modifiers));	handleClientEvent(viewer, event, queryMap);	}	}	} catch (NumberFormatException e) {	} catch (Exception e) {	
exception in handle client event bag 

Map<String, String> queryMap = new HashMap<String, String>();	queryMap.put("event", String.valueOf(event));	queryMap.put("code", String.valueOf(code));	queryMap.put("modifier", String.valueOf(modifiers));	handleClientEvent(viewer, event, queryMap);	}	}	} catch (NumberFormatException e) {	} catch (Exception e) {	} catch (OutOfMemoryError e) {	
unrecoverable outofmemory error exit and let it be re launched 

int code = 0;	int x = 0, y = 0;	int modifiers = 0;	String str;	switch (event) {	case 1: case 2: case 3: case 8: str = queryMap.get("x");	if (str != null) {	try {	x = Integer.parseInt(str);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

x = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	}	str = queryMap.get("y");	if (str != null) {	try {	y = Integer.parseInt(str);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

y = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	}	if (event != 1) {	str = queryMap.get("code");	try {	code = Integer.parseInt(str);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

str = queryMap.get("code");	try {	code = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	str = queryMap.get("modifier");	try {	modifiers = Integer.parseInt(str);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

code = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	str = queryMap.get("modifier");	try {	modifiers = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	
handle client mouse event event x y button modifier 

} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	str = queryMap.get("modifier");	try {	modifiers = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	} else {	
handle client mouse move event x y 

throw new IllegalArgumentException(e);	}	} else {	}	viewer.sendClientMouseEvent(InputEventType.fromEventCode(event), x, y, code, modifiers);	break;	case 4: case 5: case 6: str = queryMap.get("code");	try {	code = Integer.parseInt(str);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

case 4: case 5: case 6: str = queryMap.get("code");	try {	code = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	str = queryMap.get("modifier");	try {	modifiers = Integer.parseInt(str);	} catch (NumberFormatException e) {	
invalid number parameter in query string 

code = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	str = queryMap.get("modifier");	try {	modifiers = Integer.parseInt(str);	} catch (NumberFormatException e) {	throw new IllegalArgumentException(e);	}	
handle client keyboard event event code modifier 

========================= cloudstack sample_5000 =========================

try {	TaskInfo info = (TaskInfo)context.getVimClient().getDynamicProperty(morTask, "info");	if (info != null) {	LocalizedMethodFault fault = info.getError();	if (fault != null) {	sb.append(fault.getLocalizedMessage()).append(" ");	if (fault.getFault() != null) sb.append(fault.getFault().getClass().getName());	}	}	} catch (Exception e) {	
ignored error retrieving failure info for task 

========================= cloudstack sample_2100 =========================

private boolean refreshPaloAltoConnection() {	if (s_httpclient == null) {	openHttpConnection();	}	try {	return login(_username, _password);	} catch (ExecutionException e) {	
failed to login due to 

implementGuestNetwork(commandList, type, publicVlanTag, sourceNatIpAddress, guestVlanTag, guestVlanGateway, guestVlanSubnet, cidrSize);	} else {	shutdownGuestNetwork(commandList, type, publicVlanTag, sourceNatIpAddress, guestVlanTag, guestVlanGateway, guestVlanSubnet, cidrSize);	}	boolean status = requestWithCommit(commandList);	results[i++] = ip.getPublicIp() + " - success";	} catch (ExecutionException e) {	s_logger.error(e);	if (numRetries > 0 && refreshPaloAltoConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying ipassoccommand number of retries remaining 

} else {	manageFirewallRule(commandList, PaloAltoPrimative.DELETE, rule);	}	}	boolean status = requestWithCommit(commandList);	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	if (numRetries > 0 && refreshPaloAltoConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying setfirewallrulescommand number of retries remaining 

} else {	manageStcNatRule(commandList, PaloAltoPrimative.DELETE, rule);	}	}	boolean status = requestWithCommit(commandList);	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	if (numRetries > 0 && refreshPaloAltoConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying setstaticnatrulescommand number of retries remaining 

} else {	manageDstNatRule(commandList, PaloAltoPrimative.DELETE, rule);	}	}	boolean status = requestWithCommit(commandList);	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	if (numRetries > 0 && refreshPaloAltoConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying setportforwardingrulescommand number of retries remaining 

public boolean managePrivateInterface(ArrayList<IPaloAltoCommand> cmdList, PaloAltoPrimative prim, long privateVlanTag, String privateGateway) throws ExecutionException {	String interfaceName = genPrivateInterfaceName(privateVlanTag);	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/network/interface/" + _privateInterfaceType + "/entry[@name='" + _privateInterface + "']/layer3/units/entry[@name='" + interfaceName + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
private sub interface exists 

d_vr_params.put("type", "config");	d_vr_params.put("action", "delete");	d_vr_params.put("xpath", "/config/devices/entry/network/virtual-router/entry[@name='" + _virtualRouter + "']/interface/member[text()='" + interfaceName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.GET, d_vr_params));	Map<String, String> d_sub_params = new HashMap<String, String>();	d_sub_params.put("type", "config");	d_sub_params.put("action", "delete");	d_sub_params.put("xpath", "/config/devices/entry/network/interface/" + _privateInterfaceType + "/entry[@name='" + _privateInterface + "']/layer3/units/entry[@name='" + interfaceName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.GET, d_sub_params));	return true;	
unrecognized command 

} else {	interfaceName = genPublicInterfaceName(publicVlanTag);	}	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/network/interface/" + _publicInterfaceType + "/entry[@name='" + _publicInterface + "']/layer3/units/entry[@name='" + interfaceName + "']/ip/entry[@name='" + publicIp + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
public sub interface ip exists 

return true;	case DELETE: if (!managePublicInterface(cmdList, PaloAltoPrimative.CHECK_IF_EXISTS, publicVlanTag, publicIp, privateVlanTag)) {	return true;	}	Map<String, String> d_sub_params = new HashMap<String, String>();	d_sub_params.put("type", "config");	d_sub_params.put("action", "delete");	d_sub_params.put("xpath", "/config/devices/entry/network/interface/" + _publicInterfaceType + "/entry[@name='" + _publicInterface + "']/layer3/units/entry[@name='" + interfaceName + "']/ip/entry[@name='" + publicIp + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.GET, d_sub_params));	return true;	
unrecognized command 

publicInterfaceName = genPublicInterfaceName(publicVlanTag);	}	String srcNatName = genSrcNatRuleName(privateVlanTag);	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/nat/rules/entry[@name='" + srcNatName + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
source nat exists 

return true;	case DELETE: if (!manageSrcNatRule(cmdList, PaloAltoPrimative.CHECK_IF_EXISTS, type, publicVlanTag, publicIp, privateVlanTag, privateGateway)) {	return true;	}	Map<String, String> d_params = new HashMap<String, String>();	d_params.put("type", "config");	d_params.put("action", "delete");	d_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/nat/rules/entry[@name='" + srcNatName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.POST, d_params));	return true;	
unrecognized command 

publicInterfaceName = genPublicInterfaceName(new Long(publicVlanTag));	}	}	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/nat/rules/entry[@name='" + dstNatName + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
destination nat exists 

d_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/nat/rules/entry[@name='" + dstNatName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.POST, d_params));	if (!count.equals("") && Integer.parseInt(count) == 1) {	Map<String, String> d_sub_params = new HashMap<String, String>();	d_sub_params.put("type", "config");	d_sub_params.put("action", "delete");	d_sub_params.put("xpath", "/config/devices/entry/network/interface/" + _publicInterfaceType + "/entry[@name='" + _publicInterface + "']/layer3/units/entry[@name='" + publicInterfaceName + "']/ip/entry[@name='" + publicIp + "/32']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.GET, d_sub_params));	}	return true;	
unrecognized command 

publicInterfaceName = genPublicInterfaceName(new Long(publicVlanTag));	}	}	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/nat/rules/entry[@name='" + stcNatName + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
static nat exists 

d_params.put("type", "config");	d_params.put("action", "delete");	d_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/nat/rules/entry[@name='" + stcNatName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.POST, d_params));	Map<String, String> d_sub_params = new HashMap<String, String>();	d_sub_params.put("type", "config");	d_sub_params.put("action", "delete");	d_sub_params.put("xpath", "/config/devices/entry/network/interface/" + _publicInterfaceType + "/entry[@name='" + _publicInterface + "']/layer3/units/entry[@name='" + publicInterfaceName + "']/ip/entry[@name='" + publicIp + "/32']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.GET, d_sub_params));	return true;	
unrecognized command 

} else {	ruleName = genFirewallRuleName(rule.getId());	}	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='" + ruleName + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
firewall policy exists 

boolean has_default = false;	String defaultEgressRule = "";	if (rule.getTrafficType() == FirewallRule.TrafficType.Egress) {	Map<String, String> e_params = new HashMap<String, String>();	e_params.put("type", "config");	e_params.put("action", "get");	e_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='policy_0_" + rule.getSrcVlanTag() + "']");	String e_response = request(PaloAltoMethod.GET, e_params);	has_default = (validResponse(e_response) && responseNotEmpty(e_response));	if (has_default) {	
moving the default egress rule after the new rule 

a_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='" + ruleName + "']");	a_params.put("element", xml);	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.POST, a_params));	if (rule.getTrafficType() == FirewallRule.TrafficType.Egress && has_default) {	Map<String, String> da_params = new HashMap<String, String>();	da_params.put("type", "config");	da_params.put("action", "set");	da_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='policy_0_" + rule.getSrcVlanTag() + "']");	da_params.put("element", defaultEgressRule);	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.POST, da_params));	
completed move of the default egress rule after rule 

return true;	case DELETE: if (!manageFirewallRule(cmdList, PaloAltoPrimative.CHECK_IF_EXISTS, rule)) {	return true;	}	Map<String, String> d_params = new HashMap<String, String>();	d_params.put("type", "config");	d_params.put("action", "delete");	d_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='" + ruleName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.POST, d_params));	return true;	
unrecognized command 

public boolean manageNetworkIsolation(ArrayList<IPaloAltoCommand> cmdList, PaloAltoPrimative prim, long privateVlanTag, String privateSubnet, String privateGateway) throws ExecutionException {	String ruleName = genNetworkIsolationName(privateVlanTag);	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='" + ruleName + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
firewall policy exists 

return true;	case DELETE: if (!manageNetworkIsolation(cmdList, PaloAltoPrimative.CHECK_IF_EXISTS, privateVlanTag, privateSubnet, privateGateway)) {	return true;	}	Map<String, String> d_params = new HashMap<String, String>();	d_params.put("type", "config");	d_params.put("action", "delete");	d_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='" + ruleName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.POST, d_params));	return true;	
unrecognized command 

public boolean managePingProfile(ArrayList<IPaloAltoCommand> cmdList, PaloAltoPrimative prim) throws ExecutionException {	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/network/profiles/interface-management-profile/entry[@name='" + _pingManagementProfile + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
management profile exists 

return true;	case DELETE: if (!managePingProfile(cmdList, PaloAltoPrimative.CHECK_IF_EXISTS)) {	return true;	}	Map<String, String> d_params = new HashMap<String, String>();	d_params.put("type", "config");	d_params.put("action", "delete");	d_params.put("xpath", "/config/devices/entry/network/profiles/interface-management-profile/entry[@name='" + _pingManagementProfile + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.GET, d_params));	return true;	
unrecognized command 

public boolean manageService(ArrayList<IPaloAltoCommand> cmdList, PaloAltoPrimative prim, String protocol, String dstPorts, String srcPorts) throws ExecutionException {	String serviceName = genServiceName(protocol, dstPorts, srcPorts);	switch (prim) {	case CHECK_IF_EXISTS: Map<String, String> params = new HashMap<String, String>();	params.put("type", "config");	params.put("action", "get");	params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/service/entry[@name='" + serviceName + "']");	String response = request(PaloAltoMethod.GET, params);	boolean result = (validResponse(response) && responseNotEmpty(response));	
service exists 

return true;	case DELETE: if (!manageService(cmdList, PaloAltoPrimative.CHECK_IF_EXISTS, protocol, dstPorts, srcPorts)) {	return true;	}	Map<String, String> d_params = new HashMap<String, String>();	d_params.put("type", "config");	d_params.put("action", "delete");	d_params.put("xpath", "/config/devices/entry/vsys/entry[@name='vsys1']/service/entry[@name='" + serviceName + "']");	cmdList.add(new DefaultPaloAltoCommand(PaloAltoMethod.GET, d_params));	return true;	
unrecognized command 

========================= cloudstack sample_1393 =========================

DirectlyConnectedSearch.done();	UnmanagedDirectConnectSearch = createSearchBuilder();	UnmanagedDirectConnectSearch.and("resource", UnmanagedDirectConnectSearch.entity().getResource(), SearchCriteria.Op.NNULL);	UnmanagedDirectConnectSearch.and("server", UnmanagedDirectConnectSearch.entity().getManagementServerId(), SearchCriteria.Op.NULL);	UnmanagedDirectConnectSearch.and("lastPinged", UnmanagedDirectConnectSearch.entity().getLastPinged(), SearchCriteria.Op.LTEQ);	UnmanagedDirectConnectSearch.and("resourceStates", UnmanagedDirectConnectSearch.entity().getResourceState(), SearchCriteria.Op.NIN);	UnmanagedDirectConnectSearch.and("clusterIn", UnmanagedDirectConnectSearch.entity().getClusterId(), SearchCriteria.Op.IN);	try {	HostTransferSearch = _hostTransferDao.createSearchBuilder();	} catch (Throwable e) {	
error 

sc.setParameters("status", Status.Disconnected, Status.Down, Status.Alert);	StringBuilder sb = new StringBuilder();	List<HostVO> hosts = lockRows(sc, null, true);	for (HostVO host : hosts) {	host.setManagementServerId(null);	update(host.getId(), host);	sb.append(host.getId());	sb.append(" ");	}	if (s_logger.isTraceEnabled()) {	
following hosts got reset 

public List<HostVO> findAndUpdateDirectAgentToLoad(long lastPingSecondsAfter, Long limit, long managementServerId) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	txn.start();	if (s_logger.isDebugEnabled()) {	
resetting hosts suitable for reconnect 

public List<HostVO> findAndUpdateDirectAgentToLoad(long lastPingSecondsAfter, Long limit, long managementServerId) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	txn.start();	if (s_logger.isDebugEnabled()) {	}	resetHosts(managementServerId, lastPingSecondsAfter);	if (s_logger.isDebugEnabled()) {	
completed resetting hosts suitable for reconnect 

public List<HostVO> findAndUpdateDirectAgentToLoad(long lastPingSecondsAfter, Long limit, long managementServerId) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	txn.start();	if (s_logger.isDebugEnabled()) {	}	resetHosts(managementServerId, lastPingSecondsAfter);	if (s_logger.isDebugEnabled()) {	}	List<HostVO> assignedHosts = new ArrayList<HostVO>();	if (s_logger.isDebugEnabled()) {	
acquiring hosts for clusters already owned by this management server 

List<HostVO> unmanagedHosts = lockRows(sc, new Filter(HostVO.class, "clusterId", true, 0L, limit), true);	StringBuilder sb = new StringBuilder();	for (HostVO host : unmanagedHosts) {	host.setManagementServerId(managementServerId);	update(host.getId(), host);	assignedHosts.add(host);	sb.append(host.getId());	sb.append(" ");	}	if (s_logger.isTraceEnabled()) {	
following hosts got acquired for clusters already owned 

host.setManagementServerId(managementServerId);	update(host.getId(), host);	assignedHosts.add(host);	sb.append(host.getId());	sb.append(" ");	}	if (s_logger.isTraceEnabled()) {	}	}	if (s_logger.isDebugEnabled()) {	
completed acquiring hosts for clusters already owned by this management server 

sb.append(host.getId());	sb.append(" ");	}	if (s_logger.isTraceEnabled()) {	}	}	if (s_logger.isDebugEnabled()) {	}	if (assignedHosts.size() < limit) {	if (s_logger.isDebugEnabled()) {	
acquiring hosts for clusters not owned by any management server 

assignedHosts.add(host);	sb.append(host.getId());	sb.append(" ");	}	}	if (assignedHosts.size() > limit) {	break;	}	}	if (s_logger.isTraceEnabled()) {	
following hosts got acquired from newly owned clusters 

}	}	if (assignedHosts.size() > limit) {	break;	}	}	if (s_logger.isTraceEnabled()) {	}	}	if (s_logger.isDebugEnabled()) {	
completed acquiring hosts for clusters not owned by any management server 

try ( TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = txn.prepareStatement(sql);) {	pstmt.setLong(1, timeout);	try (ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}	} catch (SQLException e) {	
exception 

pstmt.setString(2, gmtCutTime);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	RunningHostCountInfo info = new RunningHostCountInfo();	info.setDcId(rs.getLong(1));	info.setHostType(rs.getString(2));	info.setCount(rs.getInt(3));	l.add(info);	}	} catch (SQLException e) {	
sqlexception caught 

public long getNextSequence(long hostId) {	if (s_logger.isTraceEnabled()) {	
getnextsequence hostid 

msg.append("id = " + host.getId());	msg.append("; name = " + host.getName());	msg.append("; old status = " + oldStatus);	msg.append("; event = " + event);	msg.append("; new status = " + newStatus);	msg.append("; old update count = " + oldUpdateCount);	msg.append("; new update count = " + newUpdateCount + "]");	status_logger.debug(msg.toString());	}	if (ho.getState() == newStatus) {	
host state has already been updated to 

========================= cloudstack sample_4257 =========================

public UserVm updateVMAffinityGroups(Long vmId, List<Long> affinityGroupIds) {	UserVmVO vmInstance = _userVmDao.findById(vmId);	if (vmInstance == null) {	throw new InvalidParameterValueException("Unable to find a virtual machine with id " + vmId);	}	if (!vmInstance.getState().equals(State.Stopped)) {	
unable to update affinity groups of the virtual machine in state 

========================= cloudstack sample_2229 =========================

}	attemptMount(localRootPath, remoteDevice, uri, nfsVersion);	Script script = new Script(true, "chmod", _timeout, s_logger);	script.add("777", localRootPath);	String result = script.execute();	if (result != null) {	String errMsg = "Unable to set permissions for " + localRootPath + " due to " + result;	s_logger.error(errMsg);	throw new CloudRuntimeException(errMsg);	}	
successfully set permission for 

========================= cloudstack sample_5016 =========================

protected void removeClustersCrossingThreshold(List<Long> clusterListForVmAllocation, ExcludeList avoid, VirtualMachineProfile vmProfile, DeploymentPlan plan){	if (s_logger.isDebugEnabled()) {	
deploying vm during ha process so skipping disable threshold check 

========================= cloudstack sample_1956 =========================

switch (dataBuf.getDataType()) {	case DataBuffer.TYPE_INT: {	DataBufferInt dataBuffer = (DataBufferInt)dataBuf;	int imageWidth = image.getWidth();	int imageHeight = image.getHeight();	int[] imageBuffer = dataBuffer.getData();	for (int srcLine = 0, dstLine = y; srcLine < height && dstLine < imageHeight; srcLine++, dstLine++) {	try {	System.arraycopy(buf, srcLine * width, imageBuffer, x + dstLine * imageWidth, width);	} catch (IndexOutOfBoundsException e) {	
ignored buffer overflow 

========================= cloudstack sample_4980 =========================

public void testInjected() throws Exception {	
starting test for resource limit manager 

public void testInjected() throws Exception {	updateResourceCount();	updateResourceLimit();	
resource limit manager test passed 

========================= cloudstack sample_2157 =========================

public SnapshotAndCopyAnswer snapshotAndCopy(SnapshotAndCopyCommand cmd) {	
snapshotandcopyanswer snapshotandcopy snapshotandcopycommand not currently used for vmwarestorageprocessor 

public ResignatureAnswer resignature(ResignatureCommand cmd) {	
resignatureanswer resignature resignaturecommand not currently used for vmwarestorageprocessor 

private Pair<VirtualMachineMO, Long> copyTemplateFromSecondaryToPrimary(VmwareHypervisorHost hyperHost, DatastoreMO datastoreMo, String secondaryStorageUrl, String templatePathAtSecondaryStorage, String templateName, String templateUuid, boolean createSnapshot, Integer nfsVersion) throws Exception {	
executing copytemplatefromsecondarytoprimary secondarystorage templatepathatsecondarystorage templatename 

private Pair<VirtualMachineMO, Long> copyTemplateFromSecondaryToPrimary(VmwareHypervisorHost hyperHost, DatastoreMO datastoreMo, String secondaryStorageUrl, String templatePathAtSecondaryStorage, String templateName, String templateUuid, boolean createSnapshot, Integer nfsVersion) throws Exception {	String secondaryMountPoint = mountService.getMountPoint(secondaryStorageUrl, nfsVersion);	
secondary storage mount point 

private Pair<VirtualMachineMO, Long> copyTemplateFromSecondaryToPrimary(VmwareHypervisorHost hyperHost, DatastoreMO datastoreMo, String secondaryStorageUrl, String templatePathAtSecondaryStorage, String templateName, String templateUuid, boolean createSnapshot, Integer nfsVersion) throws Exception {	String secondaryMountPoint = mountService.getMountPoint(secondaryStorageUrl, nfsVersion);	String srcOVAFileName = VmwareStorageLayoutHelper.getTemplateOnSecStorageFilePath(secondaryMountPoint, templatePathAtSecondaryStorage, templateName, ImageFormat.OVA.getFileExtension());	String srcFileName = getOVFFilePath(srcOVAFileName);	if (srcFileName == null) {	Script command = new Script("tar", 0, s_logger);	command.add("--no-same-owner");	command.add("-xf", srcOVAFileName);	command.setWorkDir(secondaryMountPoint + "/" + templatePathAtSecondaryStorage);	
executing command 

try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	String storageUuid = managed ? managedStoragePoolName : primaryStore.getUuid();	String templateUuidName = deriveTemplateUuidOnHost(hyperHost, storageUuid, templateInfo.second());	DatacenterMO dcMo = new DatacenterMO(context, hyperHost.getHyperHostDatacenter());	VirtualMachineMO templateMo = VmwareHelper.pickOneVmOnRunningHost(dcMo.findVmByNameAndLabel(templateUuidName), true);	DatastoreMO dsMo = null;	Pair<VirtualMachineMO, Long> vmInfo = null;	if (templateMo == null) {	if (s_logger.isInfoEnabled()) {	
template is not setup yet set up template from secondary storage with uuid name 

String[] legacyCloudStackLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, null, managedStoragePoolRootVolumeName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, false);	dsMo.moveDatastoreFile(vmwareLayoutFilePair[0], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[0], dcMo.getMor(), true);	dsMo.moveDatastoreFile(vmwareLayoutFilePair[1], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[1], dcMo.getMor(), true);	String folderToDelete = dsMo.getDatastorePath(managedStoragePoolRootVolumeName, true);	dsMo.deleteFolder(folderToDelete, dcMo.getMor());	}	else {	vmInfo = copyTemplateFromSecondaryToPrimary(hyperHost, dsMo, secondaryStorageUrl, templateInfo.first(), templateInfo.second(), templateUuidName, true, _nfsVersion);	}	} else {	
template has already been setup skip the template setup process in primary storage 

private boolean createVMLinkedClone(VirtualMachineMO vmTemplate, DatacenterMO dcMo, DatastoreMO dsMo, String vmdkName, ManagedObjectReference morDatastore, ManagedObjectReference morPool) throws Exception {	ManagedObjectReference morBaseSnapshot = vmTemplate.getSnapshotMor("cloud.template.base");	if (morBaseSnapshot == null) {	String msg = "Unable to find template base snapshot, invalid template";	s_logger.error(msg);	throw new Exception(msg);	}	
creating linked clone from template 

private boolean createVMFullClone(VirtualMachineMO vmTemplate, DatacenterMO dcMo, DatastoreMO dsMo, String vmdkName, ManagedObjectReference morDatastore, ManagedObjectReference morPool) throws Exception {	
creating full clone from template 

String dummyVmName = hostService.getWorkerName(context, cmd, 0);	try {	vmMo = HypervisorHostHelper.createWorkerVM(hyperHost, dsMo, dummyVmName);	if (vmMo == null) {	throw new Exception("Unable to create a dummy VM for volume creation");	}	vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);	String vmdkFilePair[] = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, null, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, true);	String volumeDatastorePath = vmdkFilePair[0];	synchronized (this) {	
delete file if exists in datastore to clear the way for creating the volume file 

}	vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);	String vmdkFilePair[] = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, null, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, true);	String volumeDatastorePath = vmdkFilePair[0];	synchronized (this) {	VmwareStorageLayoutHelper.deleteVolumeVmdkFiles(dsMo, vmdkName, dcMo);	vmMo.createDisk(volumeDatastorePath, (int)(volume.getSize() / (1024L * 1024L)), morDatastore, -1);	vmMo.detachDisk(volumeDatastorePath, false);	}	} finally {	
destroy dummy vm after volume creation 

vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);	String vmdkFilePair[] = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, null, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, true);	String volumeDatastorePath = vmdkFilePair[0];	synchronized (this) {	VmwareStorageLayoutHelper.deleteVolumeVmdkFiles(dsMo, vmdkName, dcMo);	vmMo.createDisk(volumeDatastorePath, (int)(volume.getSize() / (1024L * 1024L)), morDatastore, -1);	vmMo.detachDisk(volumeDatastorePath, false);	}	} finally {	if (vmMo != null) {	
unable to destroy a null vm managedobjectreference 

} finally {	if (vmMo != null) {	vmMo.detachAllDisks();	vmMo.destroy();	}	}	} else {	String templatePath = template.getPath();	VirtualMachineMO vmTemplate = VmwareHelper.pickOneVmOnRunningHost(dcMo.findVmByNameAndLabel(templatePath), true);	if (vmTemplate == null) {	
template host in vsphere is not in connected state request template reload 

ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();	ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();	if (!_fullCloneFlag) {	createVMLinkedClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool);	} else {	createVMFullClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool);	}	vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmdkName);	assert (vmMo != null);	vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);	
move volume out of volume wrapper vm 

} else {	createVMFullClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool);	}	vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmdkName);	assert (vmMo != null);	vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);	String[] vmwareLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.VMWARE, !_fullCloneFlag);	String[] legacyCloudStackLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, !_fullCloneFlag);	dsMo.moveDatastoreFile(vmwareLayoutFilePair[0], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[0], dcMo.getMor(), true);	dsMo.moveDatastoreFile(vmwareLayoutFilePair[1], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[1], dcMo.getMor(), true);	
detach disks from volume wrapper vm 

createVMFullClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool);	}	vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmdkName);	assert (vmMo != null);	vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);	String[] vmwareLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.VMWARE, !_fullCloneFlag);	String[] legacyCloudStackLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, !_fullCloneFlag);	dsMo.moveDatastoreFile(vmwareLayoutFilePair[0], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[0], dcMo.getMor(), true);	dsMo.moveDatastoreFile(vmwareLayoutFilePair[1], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[1], dcMo.getMor(), true);	vmMo.detachAllDisks();	
destroy volume wrapper vm 

if (dsMo.folderExists(String.format("[%s]", dsMo.getName()), vmNameInVcenter)) {	VmwareStorageLayoutHelper.syncVolumeToVmDefaultFolder(dcMo, vmNameInVcenter, dsMo, vmdkFileBaseName);	}	}	VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(vmdkFileBaseName);	newVol.setSize(volume.getSize());	return new CopyCmdAnswer(newVol);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

NfsTO nfsImageStore = (NfsTO)imageStore;	String secondaryStoragePoolURL = nfsImageStore.getUrl();	String volumePath = volume.getPath();	String details = null;	VmwareContext context = hostService.getServiceContext(cmd);	try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(volume.getVmName());	if (vmMo == null) {	if (s_logger.isDebugEnabled()) {	
unable to find the owner vm for createprivatetemplatefromvolumecommand on host try within datacenter 

TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(result.first());	newTemplate.setFormat(ImageFormat.OVA);	newTemplate.setSize(result.third());	newTemplate.setPhysicalSize(result.second());	return new CopyCmdAnswer(newTemplate);	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

result = command.execute();	if (result != null) {	String msg = "unable to copy snapshot " + snapshotFullOVAName + " to " + installFullPath;	s_logger.error(msg);	throw new Exception(msg);	}	command = new Script("tar", wait, s_logger);	command.add("--no-same-owner");	command.add("-xf", installFullOVAName);	command.setWorkDir(installFullPath);	
executing command 

if (new File(snapshotFullOvfName).exists()) {	command = new Script(false, "cp", wait, s_logger);	command.add(snapshotFullOvfName);	command.add(installFullPath);	result = command.execute();	if (result != null) {	String msg = "unable to copy snapshot " + snapshotFullOvfName + " to " + installFullPath;	s_logger.error(msg);	throw new Exception(msg);	}	
vmdkfile parent dir 

}	File snapshotdir = new File(snapshotRoot);	File[] ssfiles = snapshotdir.listFiles();	if (ssfiles == null) {	String msg = "unable to find snapshot vmdk files in " + snapshotRoot;	s_logger.error(msg);	throw new Exception(msg);	}	for (int i = 0; i < ssfiles.length; i++) {	String vmdkfile = ssfiles[i].getName();	
vmdk file name 

snapshotFullVMDKName = snapshotRoot + File.separator + vmdkfile;	templateVMDKName += vmdkfile;	break;	}	}	if (snapshotFullVMDKName != null) {	command = new Script(false, "cp", wait, s_logger);	command.add(snapshotFullVMDKName);	command.add(installFullPath);	result = command.execute();	
copy vmdk file 

newTemplate.setPath(result.first());	newTemplate.setPhysicalSize(result.second());	newTemplate.setSize(result.third());	newTemplate.setFormat(ImageFormat.OVA);	newTemplate.setName(uniqeName);	return new CopyCmdAnswer(newTemplate);	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

String vmName = srcSnapshot.getVmName();	try {	VmwareHypervisorHost hyperHost = hostService.getHyperHost(context, cmd);	morDs = HypervisorHostHelper.findDatastoreWithBackwardsCompatibility(hyperHost, primaryStore.getUuid());	CopyCmdAnswer answer = null;	try {	if(vmName != null) {	vmMo = hyperHost.findVmOnHyperHost(vmName);	if (vmMo == null) {	if(s_logger.isDebugEnabled()) {	
unable to find owner vm for backupsnapshotcommand on host will try within datacenter 

dsMo = new DatastoreMO(hyperHost.getContext(), morDs);	workerVMName = hostService.getWorkerName(context, cmd, 0);	vmMo = HypervisorHostHelper.createWorkerVM(hyperHost, dsMo, workerVMName);	if (vmMo == null) {	throw new Exception("Failed to find the newly create or relocated VM. vmName: " + workerVMName);	}	workerVm = vmMo;	String datastoreVolumePath = dsMo.getDatastorePath(volumePath + ".vmdk");	vmMo.attachDisk(new String[] { datastoreVolumePath }, morDs);	} else {	
using owner vm for snapshot operation 

newSnapshot.setPath(snapshotDir + "/" + snapshotBackupUuid);	newSnapshot.setPhysicalSize(physicalSize);	answer = new CopyCmdAnswer(newSnapshot);	}	} finally {	if (vmMo != null) {	ManagedObjectReference snapshotMor = vmMo.getSnapshotMor(snapshotUuid);	if (snapshotMor != null) {	vmMo.removeSnapshot(snapshotUuid, false);	if (backupResult != null && hasOwnerVm) {	
check if we have disk consolidation after snapshot operation 

answer = new CopyCmdAnswer(newSnapshot);	}	} finally {	if (vmMo != null) {	ManagedObjectReference snapshotMor = vmMo.getSnapshotMor(snapshotUuid);	if (snapshotMor != null) {	vmMo.removeSnapshot(snapshotUuid, false);	if (backupResult != null && hasOwnerVm) {	boolean chainConsolidated = false;	for (String vmdkDsFilePath : backupResult.third()) {	
validate disk chain file 

}	} finally {	if (vmMo != null) {	ManagedObjectReference snapshotMor = vmMo.getSnapshotMor(snapshotUuid);	if (snapshotMor != null) {	vmMo.removeSnapshot(snapshotUuid, false);	if (backupResult != null && hasOwnerVm) {	boolean chainConsolidated = false;	for (String vmdkDsFilePath : backupResult.third()) {	if (vmMo.getDiskDevice(vmdkDsFilePath) == null) {	
no longer exists consolidation detected 

ManagedObjectReference snapshotMor = vmMo.getSnapshotMor(snapshotUuid);	if (snapshotMor != null) {	vmMo.removeSnapshot(snapshotUuid, false);	if (backupResult != null && hasOwnerVm) {	boolean chainConsolidated = false;	for (String vmdkDsFilePath : backupResult.third()) {	if (vmMo.getDiskDevice(vmdkDsFilePath) == null) {	chainConsolidated = true;	break;	} else {	
is found still in chain 

chainConsolidated = true;	break;	} else {	}	}	if (chainConsolidated) {	String topVmdkFilePath = null;	try {	topVmdkFilePath = vmMo.getDiskCurrentTopBackingFileInChain(backupResult.second());	} catch (Exception e) {	
unexpected exception 

break;	} else {	}	}	if (chainConsolidated) {	String topVmdkFilePath = null;	try {	topVmdkFilePath = vmMo.getDiskCurrentTopBackingFileInChain(backupResult.second());	} catch (Exception e) {	}	
disk has been consolidated top vmdk is now 

} catch (Exception e) {	}	if (topVmdkFilePath != null) {	DatastoreFile file = new DatastoreFile(topVmdkFilePath);	SnapshotObjectTO snapshotInfo = (SnapshotObjectTO)answer.getNewData();	VolumeObjectTO vol = new VolumeObjectTO();	vol.setUuid(srcSnapshot.getVolume().getUuid());	vol.setPath(file.getFileBaseName());	snapshotInfo.setVolume(vol);	} else {	
disk has been consolidated but top vmdk is not found 

SnapshotObjectTO snapshotInfo = (SnapshotObjectTO)answer.getNewData();	VolumeObjectTO vol = new VolumeObjectTO();	vol.setUuid(srcSnapshot.getVolume().getUuid());	vol.setPath(file.getFileBaseName());	snapshotInfo.setVolume(vol);	} else {	}	}	}	} else {	
can not find the snapshot we just used 

}	} else {	}	}	try {	if (workerVm != null) {	workerVm.detachAllDisks();	workerVm.destroy();	}	} catch (Throwable e) {	
failed to destroy worker vm 

workerVm.destroy();	}	} catch (Throwable e) {	}	}	return answer;	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

vmMo.detachDisk(datastoreVolumePath, false);	if (isManaged) {	handleDatastoreAndVmdkDetachManaged(diskUuid, iScsiName, storageHost, storagePort);	} else {	VmwareStorageLayoutHelper.syncVolumeToRootFolder(dsMo.getOwnerDatacenter().first(), dsMo, volumeTO.getPath(), vmName);	}	}	return answer;	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

private static String getSecondaryDatastoreUUID(String storeUrl) {	String uuid = null;	try{	uuid=UUID.nameUUIDFromBytes(storeUrl.getBytes("UTF-8")).toString();	}catch(UnsupportedEncodingException e){	
failed to create uuid from string bad storeurl or utf encoding error 

String storeName = secondaryDsMo.getName();	String isoDatastorePath = String.format("[%s] %s/%s", storeName, isoStorePathFromRoot, isoFileName);	if (isAttach) {	vmMo.attachIso(isoDatastorePath, morSecondaryDs, true, false);	} else {	vmMo.detachIso(isoDatastorePath);	}	return new AttachAnswer(disk);	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

ManagedObjectReference morDatastore = HypervisorHostHelper.findDatastoreWithBackwardsCompatibility(hyperHost, primaryStore.getUuid());	if (morDatastore == null) {	throw new Exception("Unable to find datastore in vSphere");	}	DatastoreMO dsMo = new DatastoreMO(context, morDatastore);	VirtualMachineMO vmMo = null;	String volumeUuid = UUID.randomUUID().toString().replace("-", "");	String volumeDatastorePath = dsMo.getDatastorePath(volumeUuid + ".vmdk");	String dummyVmName = hostService.getWorkerName(context, cmd, 0);	try {	
create worker vm 

vmMo = HypervisorHostHelper.createWorkerVM(hyperHost, dsMo, dummyVmName);	if (vmMo == null) {	throw new Exception("Unable to create a dummy VM for volume creation");	}	synchronized (this) {	try {	vmMo.createDisk(volumeDatastorePath, (int)(volume.getSize() / (1024L * 1024L)), morDatastore, vmMo.getScsiDeviceControllerKey());	vmMo.detachDisk(volumeDatastorePath, false);	}	catch (Exception e) {	
deleting file due to error 

catch (Exception e) {	VmwareStorageLayoutHelper.deleteVolumeVmdkFiles(dsMo, volumeUuid.toString(), dcMo);	throw new CloudRuntimeException("Unable to create volume due to: " + e.getMessage());	}	}	VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(volumeUuid);	newVol.setSize(volume.getSize());	return new CreateObjectAnswer(newVol);	} finally {	
destroy dummy vm after volume creation 

newVol.setSize(volume.getSize());	return new CreateObjectAnswer(newVol);	} finally {	if (vmMo != null) {	vmMo.detachAllDisks();	vmMo.destroy();	}	}	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

public Answer deleteVolume(DeleteCommand cmd) {	if (s_logger.isInfoEnabled()) {	
executing resource deletecommand 

if (vol.getVolumeType() == Volume.Type.ROOT) {	String vmName = vol.getVmName();	if (vmName != null) {	VirtualMachineMO vmMo = clusterMo.findVmOnHyperHost(vmName);	if (vmMo == null) {	DatacenterMO dcMo = new DatacenterMO(context, morDc);	vmMo = dcMo.findVm(vmName);	}	if (vmMo != null) {	if (s_logger.isInfoEnabled()) {	
destroy root volume and vm itself vmname 

}	for (NetworkDetails netDetails : networks) {	if (netDetails.getGCTag() != null && netDetails.getGCTag().equalsIgnoreCase("true")) {	if (netDetails.getVMMorsOnNetwork() == null || netDetails.getVMMorsOnNetwork().length == 1) {	resource.cleanupNetwork(hostMo, netDetails);	}	}	}	}	if (s_logger.isInfoEnabled()) {	
destroy volume by original name vmdk 

}	}	}	}	if (s_logger.isInfoEnabled()) {	}	VmwareStorageLayoutHelper.deleteVolumeVmdkFiles(dsMo, vol.getPath(), new DatacenterMO(context, morDc));	return new Answer(cmd, true, "Success");	}	if (s_logger.isInfoEnabled()) {	
destroy root volume directly from datastore 

VmwareStorageLayoutHelper.deleteVolumeVmdkFiles(dsMo, vol.getPath(), new DatacenterMO(context, morDc));	return new Answer(cmd, true, "Success");	}	if (s_logger.isInfoEnabled()) {	}	}	VmwareStorageLayoutHelper.deleteVolumeVmdkFiles(dsMo, vol.getPath(), new DatacenterMO(context, morDc));	return new Answer(cmd, true, "Success");	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

private ManagedObjectReference prepareManagedDatastore(VmwareContext context, VmwareHypervisorHost hyperHost, String diskUuid, String iScsiName, String storageHost, int storagePort, String chapInitiatorUsername, String chapInitiatorSecret, String chapTargetUsername, String chapTargetSecret) throws Exception {	if (storagePort == DEFAULT_NFS_PORT) {	
creating the nfs datastore with the following configuration storagehost storageport exportpath and diskuuid 

}	File ovafile = new File(srcOVAFileName);	File ovfFile = new File(srcOVFFileName);	if (!ovfFile.exists()) {	srcOVFFileName = getOVFFilePath(srcOVAFileName);	if (srcOVFFileName == null && ovafile.exists()) {	Script command = new Script("tar", wait, s_logger);	command.add("--no-same-owner");	command.add("-xf", srcOVAFileName);	command.setWorkDir(secondaryMountPoint + "/" + secStorageDir + "/" + snapshotDir);	
executing command 

}	DatastoreMO primaryDsMo = new DatastoreMO(hyperHost.getContext(), morPrimaryDs);	restoreVolumeFromSecStorage(hyperHost, primaryDsMo, newVolumeName, secondaryStorageUrl, backupPath, backedUpSnapshotUuid, (long)cmd.getWait() * 1000, _nfsVersion);	VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(newVolumeName);	return new CopyCmdAnswer(newVol);	} catch (Throwable e) {	if (e instanceof RemoteException) {	hostService.invalidateServiceContext(context);	}	
unexpecpted exception 

private static String deriveTemplateUuidOnHost(VmwareHypervisorHost hyperHost, String storeIdentifier, String templateName) {	String templateUuid;	try{	templateUuid = UUID.nameUUIDFromBytes((templateName + "@" + storeIdentifier + "-" + hyperHost.getMor().getValue()).getBytes("UTF-8")).toString();	}catch(UnsupportedEncodingException e){	
unexpected encoding error using default charset 

private String getControllerFromConfigurationSetting() throws Exception {	String diskController = null;	VmwareContext context = null;	try {	context = hostService.getServiceContext(null);	VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);	diskController = mgr.getDataDiskController();	} catch (Throwable e) {	if (e instanceof RemoteException) {	
encounter remote exception to vcenter invalidate vmware session context 

public void setNfsVersion(Integer nfsVersion){	this._nfsVersion = nfsVersion;	
vmwareprocessor instance now using nfs version 

========================= cloudstack sample_1281 =========================

public boolean start() {	if (s_apiNameDiscoveryResponseMap == null) {	long startTime = System.nanoTime();	s_apiNameDiscoveryResponseMap = new HashMap<String, ApiDiscoveryResponse>();	Set<Class<?>> cmdClasses = new HashSet<Class<?>>();	for (PluggableService service : _services) {	
getting api commands of service s 

if (s_apiNameDiscoveryResponseMap == null) {	long startTime = System.nanoTime();	s_apiNameDiscoveryResponseMap = new HashMap<String, ApiDiscoveryResponse>();	Set<Class<?>> cmdClasses = new HashSet<Class<?>>();	for (PluggableService service : _services) {	cmdClasses.addAll(service.getCommands());	}	cmdClasses.addAll(this.getCommands());	cacheResponseMap(cmdClasses);	long endTime = System.nanoTime();	
api discovery service annotation docstrings api relation graph processed in ms 

for (Class<?> cmdClass : cmdClasses) {	APICommand apiCmdAnnotation = cmdClass.getAnnotation(APICommand.class);	if (apiCmdAnnotation == null) {	apiCmdAnnotation = cmdClass.getSuperclass().getAnnotation(APICommand.class);	}	if (apiCmdAnnotation == null || !apiCmdAnnotation.includeInApiDoc() || apiCmdAnnotation.name().isEmpty()) {	continue;	}	String apiName = apiCmdAnnotation.name();	if (s_logger.isTraceEnabled()) {	
found api 

public ListResponse<? extends BaseResponse> listApis(User user, String name) {	ListResponse<ApiDiscoveryResponse> response = new ListResponse<ApiDiscoveryResponse>();	List<ApiDiscoveryResponse> responseList = new ArrayList<ApiDiscoveryResponse>();	if (user == null) return null;	if (name != null) {	if (!s_apiNameDiscoveryResponseMap.containsKey(name)) return null;	for (APIChecker apiChecker : _apiAccessCheckers) {	try {	apiChecker.checkAccess(user, name);	} catch (Exception ex) {	
api discovery access check failed for with 

========================= cloudstack sample_2012 =========================

private boolean checkHostSuitabilityForImplicitDedication(Long accountId, List<VMInstanceVO> allVmsOnHost) {	boolean suitable = true;	if (allVmsOnHost.isEmpty()) return false;	for (VMInstanceVO vm : allVmsOnHost) {	if (vm.getAccountId() != accountId) {	
host found to be unsuitable for implicit dedication as it is running instances of another account 

private boolean checkHostSuitabilityForImplicitDedication(Long accountId, List<VMInstanceVO> allVmsOnHost) {	boolean suitable = true;	if (allVmsOnHost.isEmpty()) return false;	for (VMInstanceVO vm : allVmsOnHost) {	if (vm.getAccountId() != accountId) {	suitable = false;	break;	} else {	if (!isImplicitPlannerUsedByOffering(vm.getServiceOfferingId())) {	
host found to be unsuitable for implicit dedication as it is running instances of this account which haven t been created using implicit dedication 

private boolean checkIfAllVmsCreatedInStrictMode(Long accountId, List<VMInstanceVO> allVmsOnHost) {	boolean createdByImplicitStrict = true;	if (allVmsOnHost.isEmpty()) return false;	for (VMInstanceVO vm : allVmsOnHost) {	if (!isImplicitPlannerUsedByOffering(vm.getServiceOfferingId())) {	
host found to be running a vm created by a planner other than implicit 

private boolean checkIfAllVmsCreatedInStrictMode(Long accountId, List<VMInstanceVO> allVmsOnHost) {	boolean createdByImplicitStrict = true;	if (allVmsOnHost.isEmpty()) return false;	for (VMInstanceVO vm : allVmsOnHost) {	if (!isImplicitPlannerUsedByOffering(vm.getServiceOfferingId())) {	createdByImplicitStrict = false;	break;	} else if (isServiceOfferingUsingPlannerInPreferredMode(vm.getServiceOfferingId())) {	
host found to be running a vm created by an implicit planner in preferred mode 

private boolean isImplicitPlannerUsedByOffering(long offeringId) {	boolean implicitPlannerUsed = false;	ServiceOfferingVO offering = serviceOfferingDao.findByIdIncludingRemoved(offeringId);	if (offering == null) {	
couldn t retrieve the offering by the given id 

========================= cloudstack sample_759 =========================

final VolumeObjectTO vol = (VolumeObjectTO)volumeTo.getData();	final Long deviceId = volumeTo.getDiskSeq();	final VDI vdi = deviceIdToVdiMap.get(deviceId.toString());	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(vdi.getUuid(connection));	newVol.setId(vol.getId());	volumeToList.add(newVol);	}	}	} catch (final Exception e) {	
unable to get the updated vdi paths of the migrated vm 

========================= cloudstack sample_1147 =========================

public boolean processAnswers(long agentId, long seq, Answer[] answers) {	List<Long> affectedVms = new ArrayList<Long>();	for (Answer ans : answers) {	if (ans instanceof SecurityGroupRuleAnswer) {	SecurityGroupRuleAnswer ruleAnswer = (SecurityGroupRuleAnswer)ans;	if (ans.getResult()) {	
successfully programmed rule into host 

List<Long> affectedVms = new ArrayList<Long>();	for (Answer ans : answers) {	if (ans instanceof SecurityGroupRuleAnswer) {	SecurityGroupRuleAnswer ruleAnswer = (SecurityGroupRuleAnswer)ans;	if (ans.getResult()) {	_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Done);	recordSuccess(ruleAnswer.getVmId());	} else {	_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Error);	;	
failed to program rule into host due to and updated jobs 

for (Answer ans : answers) {	if (ans instanceof SecurityGroupRuleAnswer) {	SecurityGroupRuleAnswer ruleAnswer = (SecurityGroupRuleAnswer)ans;	if (ans.getResult()) {	_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Done);	recordSuccess(ruleAnswer.getVmId());	} else {	_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Error);	;	if (ruleAnswer.getReason() == FailureReason.CANNOT_BRIDGE_FIREWALL) {	
not retrying security group rules for vm on failure since host cannot do bridge firewalling 

SecurityGroupRuleAnswer ruleAnswer = (SecurityGroupRuleAnswer)ans;	if (ans.getResult()) {	_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Done);	recordSuccess(ruleAnswer.getVmId());	} else {	_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Error);	;	if (ruleAnswer.getReason() == FailureReason.CANNOT_BRIDGE_FIREWALL) {	} else if (ruleAnswer.getReason() == FailureReason.PROGRAMMING_FAILED) {	if (checkShouldRetryOnFailure(ruleAnswer.getVmId())) {	
retrying security group rules on failure for vm 

_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Done);	recordSuccess(ruleAnswer.getVmId());	} else {	_workDao.updateStep(ruleAnswer.getVmId(), ruleAnswer.getLogSequenceNumber(), Step.Error);	;	if (ruleAnswer.getReason() == FailureReason.CANNOT_BRIDGE_FIREWALL) {	} else if (ruleAnswer.getReason() == FailureReason.PROGRAMMING_FAILED) {	if (checkShouldRetryOnFailure(ruleAnswer.getVmId())) {	affectedVms.add(ruleAnswer.getVmId());	} else {	
not retrying security group rules for vm on failure too many retries 

public void processConnect(Host host, StartupCommand cmd, boolean forRebalance) {	
received a host startup notification 

public void processConnect(Host host, StartupCommand cmd, boolean forRebalance) {	if (cmd instanceof StartupRoutingCommand) {	try {	int interval = MIN_TIME_BETWEEN_CLEANUPS + _cleanupRandom.nextInt(MIN_TIME_BETWEEN_CLEANUPS / 2);	CleanupNetworkRulesCmd cleanupCmd = new CleanupNetworkRulesCmd(interval);	Commands c = new Commands(cleanupCmd);	_agentMgr.send(host.getId(), c, this);	if (s_logger.isInfoEnabled()) s_logger.info("Scheduled network rules cleanup, interval=" + cleanupCmd.getInterval());	} catch (AgentUnavailableException e) {	
unable to schedule network rules cleanup for host 

========================= cloudstack sample_2291 =========================

private boolean canHandle(Network network, List<LoadBalancingRule> rules) {	if (network.getGuestType() != Network.GuestType.Shared || network.getTrafficType() != TrafficType.Guest) {	
not handling network with type and traffic type 

private boolean canHandle(Network network, List<LoadBalancingRule> rules) {	if (network.getGuestType() != Network.GuestType.Shared || network.getTrafficType() != TrafficType.Guest) {	return false;	}	Map<Capability, String> lbCaps = this.getCapabilities().get(Service.Lb);	if (!lbCaps.isEmpty()) {	String schemeCaps = lbCaps.get(Capability.LbSchemes);	if (schemeCaps != null) {	for (LoadBalancingRule rule : rules) {	if (!schemeCaps.contains(rule.getScheme().toString())) {	
scheme is not supported by the provider 

========================= cloudstack sample_1901 =========================

public void testLockAndRelease() {	
testing first acquire 

public void testLockAndRelease() {	boolean result = _lockMaster.acquire("first" + 1234, 5);	Assert.assertTrue(result);	
testing acquire of different lock 

public void testLockAndRelease() {	boolean result = _lockMaster.acquire("first" + 1234, 5);	Assert.assertTrue(result);	result = _lockMaster.acquire("second" + 1234, 5);	Assert.assertTrue(result);	
testing reacquire of the same lock 

boolean result = _lockMaster.acquire("first" + 1234, 5);	Assert.assertTrue(result);	result = _lockMaster.acquire("second" + 1234, 5);	Assert.assertTrue(result);	result = _lockMaster.acquire("first" + 1234, 5);	Assert.assertTrue(result);	int count = _lockMaster.owns("first" + 1234);	Assert.assertEquals(count, 2);	count = _lockMaster.owns("second" + 1234);	Assert.assertEquals(count, 1);	
testing release of the first lock 

result = _lockMaster.acquire("first" + 1234, 5);	Assert.assertTrue(result);	int count = _lockMaster.owns("first" + 1234);	Assert.assertEquals(count, 2);	count = _lockMaster.owns("second" + 1234);	Assert.assertEquals(count, 1);	result = _lockMaster.release("first" + 1234);	Assert.assertTrue(result);	count = _lockMaster.owns("first" + 1234);	Assert.assertEquals(count, 1);	
testing release of the second lock 

========================= cloudstack sample_535 =========================

}	if (Snapshot.State.Error.equals(snapshotVO.getState())) {	snapshotDao.remove(snapshotId);	return true;	}	if (!Snapshot.State.BackedUp.equals(snapshotVO.getState())) {	throw new InvalidParameterValueException("Unable to delete snapshotshot " + snapshotId + " because it is in the following state: " + snapshotVO.getState());	}	SnapshotObject snapshotObj = (SnapshotObject)snapshotDataFactory.getSnapshot(snapshotId, DataStoreRole.Primary);	if (snapshotObj == null) {	
can t find snapshot deleting it in db 

snapshotDao.remove(snapshotId);	return true;	}	if (ObjectInDataStoreStateMachine.State.Copying.equals(snapshotObj.getStatus())) {	throw new InvalidParameterValueException("Unable to delete snapshotshot " + snapshotId + " because it is in the copying state.");	}	try {	snapshotObj.processEvent(Snapshot.Event.DestroyRequested);	}	catch (NoTransitionException e) {	
failed to set the state to destroying 

snapshotObj.processEvent(Snapshot.Event.DestroyRequested);	}	catch (NoTransitionException e) {	return false;	}	try {	snapshotSvr.deleteSnapshot(snapshotObj);	snapshotObj.processEvent(Snapshot.Event.OperationSucceeded);	}	catch (Exception e) {	
failed to delete snapshot 

}	try {	snapshotSvr.deleteSnapshot(snapshotObj);	snapshotObj.processEvent(Snapshot.Event.OperationSucceeded);	}	catch (Exception e) {	try {	snapshotObj.processEvent(Snapshot.Event.OperationFailed);	}	catch (NoTransitionException e1) {	
failed to change snapshot state 

volumeInfo.stateTransit(Volume.Event.SnapshotRequested);	HostVO hostVO = getHost(volumeInfo.getId());	boolean canStorageSystemCreateVolumeFromSnapshot = canStorageSystemCreateVolumeFromSnapshot(volumeInfo.getPoolId());	boolean computeClusterSupportsResign = clusterDao.getSupportsResigning(hostVO.getClusterId());	if (canStorageSystemCreateVolumeFromSnapshot && computeClusterSupportsResign) {	SnapshotDetailsVO snapshotDetail = new SnapshotDetailsVO(snapshotInfo.getId(), "takeSnapshot", Boolean.TRUE.toString(), false);	snapshotDetailsDao.persist(snapshotDetail);	}	result = snapshotSvr.takeSnapshot(snapshotInfo);	if (result.isFailed()) {	
failed to take a snapshot 

hostVO = hostDao.findById(hostId);	}	else {	Optional<HostVO> optHostVO = getHost(volumeInfo.getDataCenterId(), false);	if (optHostVO.isPresent()) {	hostVO = optHostVO.get();	}	}	if (hostVO == null) {	final String errMsg = "Unable to locate an applicable host";	
performsnapshotandcopyonhostside 

private void markAsBackedUp(SnapshotObject snapshotObj) {	try {	snapshotObj.processEvent(Snapshot.Event.BackupToSecondary);	snapshotObj.processEvent(Snapshot.Event.OperationSucceeded);	}	catch (NoTransitionException ex) {	
failed to change state 

private void markAsBackedUp(SnapshotObject snapshotObj) {	try {	snapshotObj.processEvent(Snapshot.Event.BackupToSecondary);	snapshotObj.processEvent(Snapshot.Event.OperationSucceeded);	}	catch (NoTransitionException ex) {	try {	snapshotObj.processEvent(Snapshot.Event.OperationFailed);	}	catch (NoTransitionException ex2) {	
failed to change state 

========================= cloudstack sample_3896 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	ListResponse<BaremetalDhcpResponse> response = new ListResponse<BaremetalDhcpResponse>();	List<BaremetalDhcpResponse> dhcpResponses = _dhcpMgr.listBaremetalDhcps(this);	response.setResponses(dhcpResponses);	response.setResponseName(getCommandName());	response.setObjectName("baremetaldhcps");	this.setResponseObject(response);	} catch (Exception e) {	
exception happend while executing listbaremetaldhcpcmd 

========================= cloudstack sample_866 =========================

this.serviceOfferingId = serviceOfferingId;	this.hypervisorType = hypervisorType;	this.userId = userId;	limitCpuUse = false;	try {	SecureRandom random = SecureRandom.getInstance("SHA1PRNG");	byte[] randomBytes = new byte[16];	random.nextBytes(randomBytes);	vncPassword = Base64.encodeBase64URLSafeString(randomBytes);	} catch (NoSuchAlgorithmException e) {	
unexpected exception in securerandom algorithm selection 

========================= cloudstack sample_4650 =========================

protected boolean canHandle(Network network, Service service) {	
checking if brocadevcselement can handle service on network 

protected boolean canHandle(Network network, Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Vcs) {	return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	
brocadevcselement is not a provider for network 

protected boolean canHandle(Network network, Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Vcs) {	return false;	}	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	if (!_ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), service, Network.Provider.BrocadeVcs)) {	
brocadevcselement can t provide the service on network 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
entering brocadevcselement implement function for network state 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	
unable to provide services without connectivity service enabled for this element 

========================= cloudstack sample_1645 =========================

public void releaseIpAddress(String ipAddress, long networkId) {	if (s_logger.isDebugEnabled()) {	
releasing private ip address network id 

========================= cloudstack sample_4447 =========================

public void create() {	try {	Site2SiteVpnConnection conn = _s2sVpnService.createVpnConnection(this);	if (conn != null) {	setEntityId(conn.getId());	setEntityUuid(conn.getUuid());	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create site to site vpn connection");	}	} catch (NetworkRuleConflictException e) {	
network rule conflict 

public void create() {	try {	Site2SiteVpnConnection conn = _s2sVpnService.createVpnConnection(this);	if (conn != null) {	setEntityId(conn.getId());	setEntityUuid(conn.getUuid());	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create site to site vpn connection");	}	} catch (NetworkRuleConflictException e) {	
network rule conflict 

try {	Site2SiteVpnConnection result = _s2sVpnService.startVpnConnection(getEntityId());	if (result != null) {	Site2SiteVpnConnectionResponse response = _responseGenerator.createSite2SiteVpnConnectionResponse(result);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to create site to site vpn connection");	}	} catch (ResourceUnavailableException ex) {	
exception 

========================= cloudstack sample_3382 =========================

public Answer execute(final CleanupNetworkRulesCmd command, final CitrixResourceBase citrixResourceBase) {	if (!citrixResourceBase.canBridgeFirewall()) {	return new Answer(command, true, null);	}	final Connection conn = citrixResourceBase.getConnection();	final String result = citrixResourceBase.callHostPlugin(conn, "vmops", "cleanup_rules", "instance", citrixResourceBase.getVMInstanceName());	final int numCleaned = Integer.parseInt(result);	if (result == null || result.isEmpty() || numCleaned < 0) {	
failed to cleanup rules for host 

if (!citrixResourceBase.canBridgeFirewall()) {	return new Answer(command, true, null);	}	final Connection conn = citrixResourceBase.getConnection();	final String result = citrixResourceBase.callHostPlugin(conn, "vmops", "cleanup_rules", "instance", citrixResourceBase.getVMInstanceName());	final int numCleaned = Integer.parseInt(result);	if (result == null || result.isEmpty() || numCleaned < 0) {	return new Answer(command, false, result);	}	if (numCleaned > 0) {	
cleaned up rules for vms on host 

========================= cloudstack sample_1215 =========================

ImageStoreResponse storeResponse = null;	if (result != null) {	storeResponse = _responseGenerator.createImageStoreResponse(result);	storeResponse.setResponseName(getCommandName());	storeResponse.setObjectName("secondarystorage");	this.setResponseObject(storeResponse);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add secondary storage");	}	} catch (Exception ex) {	
exception 

========================= cloudstack sample_3228 =========================

public void DeleteFile(String datastoreFullPath) throws Exception {	
vcenter api trace deletefile target mor file datastore path 

public void DeleteFile(String datastoreFullPath) throws Exception {	_context.getService().deleteFile(_mor, datastoreFullPath);	
vcenter api trace deletefile done 

public HostDatastoreBrowserSearchResults searchDatastore(String datastorePath, HostDatastoreBrowserSearchSpec searchSpec) throws Exception {	
vcenter api trace searchdatastore target mor file datastore path 

public HostDatastoreBrowserSearchResults searchDatastore(String datastorePath, HostDatastoreBrowserSearchSpec searchSpec) throws Exception {	try {	ManagedObjectReference morTask = _context.getService().searchDatastoreTask(_mor, datastorePath, searchSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return (HostDatastoreBrowserSearchResults)_context.getVimClient().getDynamicProperty(morTask, "info.result");	} else {	
vmware searchdaastore task failed due to 

public HostDatastoreBrowserSearchResults searchDatastore(String datastorePath, HostDatastoreBrowserSearchSpec searchSpec) throws Exception {	try {	ManagedObjectReference morTask = _context.getService().searchDatastoreTask(_mor, datastorePath, searchSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return (HostDatastoreBrowserSearchResults)_context.getVimClient().getDynamicProperty(morTask, "info.result");	} else {	}	} finally {	
vcenter api trace searchdatastore done 

public ArrayList<HostDatastoreBrowserSearchResults> searchDatastoreSubFolders(String datastorePath, HostDatastoreBrowserSearchSpec searchSpec) throws Exception {	
vcenter api trace searchdatastoresubfolders target mor file datastore path 

public ArrayList<HostDatastoreBrowserSearchResults> searchDatastoreSubFolders(String datastorePath, HostDatastoreBrowserSearchSpec searchSpec) throws Exception {	try {	ManagedObjectReference morTask = _context.getService().searchDatastoreSubFoldersTask(_mor, datastorePath, searchSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return (ArrayList<HostDatastoreBrowserSearchResults>)_context.getVimClient().getDynamicProperty(morTask, "info.result");	} else {	
vmware searchdaastoresubfolders task failed due to 

public ArrayList<HostDatastoreBrowserSearchResults> searchDatastoreSubFolders(String datastorePath, HostDatastoreBrowserSearchSpec searchSpec) throws Exception {	try {	ManagedObjectReference morTask = _context.getService().searchDatastoreSubFoldersTask(_mor, datastorePath, searchSpec);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return (ArrayList<HostDatastoreBrowserSearchResults>)_context.getVimClient().getDynamicProperty(morTask, "info.result");	} else {	}	} finally {	
vcenter api trace searchdatastore done 

========================= cloudstack sample_2069 =========================

try {	txn.start();	pstmt = txn.prepareAutoCloseStatement(sql);	if (accountId != null) {	pstmt.setLong(1, accountId.longValue());	}	pstmt.executeUpdate();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error retrieving usage vm instances for account id 

} else {	pstmt.setString(6, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), acct.getRemoved()));	}	pstmt.setBoolean(7, acct.getNeedsCleanup());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving account to cloud usage db 

} else {	pstmt.setString(2, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), acct.getRemoved()));	}	pstmt.setLong(3, acct.getId());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving account to cloud usage db 

pstmt.setLong(10, userStat.getCurrentBytesReceived());	pstmt.setLong(11, userStat.getCurrentBytesSent());	pstmt.setLong(12, userStat.getAggBytesReceived());	pstmt.setLong(13, userStat.getAggBytesSent());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving user stats to cloud usage db 

pstmt.setLong(4, userStat.getCurrentBytesSent());	pstmt.setLong(5, userStat.getAggBytesReceived());	pstmt.setLong(6, userStat.getAggBytesSent());	pstmt.setLong(7, userStat.getId());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving user stats to cloud usage db 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	String sql = GET_LAST_ACCOUNT;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	return Long.valueOf(rs.getLong(1));	}	} catch (Exception ex) {	
error getting last account id 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	String sql = GET_LAST_USER_STATS;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	return Long.valueOf(rs.getLong(1));	}	} catch (Exception ex) {	
error getting last user stats id 

String sql = GET_PUBLIC_TEMPLATES_BY_ACCOUNTID;	List<Long> templateList = new ArrayList<Long>();	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, accountId);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	templateList.add(Long.valueOf(rs.getLong(1)));	}	} catch (Exception ex) {	
error listing public templates 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	String sql = GET_LAST_VM_DISK_STATS;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	return Long.valueOf(rs.getLong(1));	}	} catch (Exception ex) {	
error getting last vm disk stats id 

pstmt.setLong(10, vmDiskStat.getCurrentBytesWrite());	pstmt.setLong(11, vmDiskStat.getAggBytesRead());	pstmt.setLong(12, vmDiskStat.getAggBytesWrite());	pstmt.setLong(13, vmDiskStat.getId());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving vm disk stats to cloud usage db 

pstmt.setLong(14, vmDiskStat.getCurrentBytesRead());	pstmt.setLong(15, vmDiskStat.getCurrentBytesWrite());	pstmt.setLong(16, vmDiskStat.getAggBytesRead());	pstmt.setLong(17, vmDiskStat.getAggBytesWrite());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving vm disk stats to cloud usage db 

pstmt.setLong(18, usageRecord.getVirtualSize());	} else {	pstmt.setNull(18, Types.BIGINT);	}	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving usage records to cloud usage db 

TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);	PreparedStatement pstmt = null;	try {	txn.start();	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, days);	pstmt.executeUpdate();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error removing old cloud usage records for interval 

public Pair<List<? extends UsageVO>, Integer> getUsageRecordsPendingQuotaAggregation(final long accountId, final long domainId) {	if (s_logger.isDebugEnabled()) {	
getting usage records for account domainid 

QueryBuilder<UsageVO> qb = QueryBuilder.create(UsageVO.class);	if (accountId != -1) {	qb.and(qb.entity().getAccountId(), SearchCriteria.Op.EQ, accountId);	}	if (domainId != -1) {	qb.and(qb.entity().getDomainId(), SearchCriteria.Op.EQ, domainId);	}	qb.and(qb.entity().getQuotaCalculated(), SearchCriteria.Op.NEQ, 1);	qb.and(qb.entity().getRawUsage(), SearchCriteria.Op.GT, 0);	if (s_logger.isDebugEnabled()) {	
getting usage records 

========================= cloudstack sample_4502 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all vmsnapshot volume usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageVMSnapshotVO> usageUsageVMSnapshots = s_usageVMSnapshotDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate);	if (usageUsageVMSnapshots.isEmpty()) {	
no vm snapshot usage events for this period 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long volId, long zoneId, Long doId, Long vmId, long size) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long volId, long zoneId, Long doId, Long vmId, long size) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating vmsnapshot volume usage record for vol usage startdate enddate for account 

========================= cloudstack sample_2655 =========================

public List<DataStore> listImageCacheStores(Scope scope) {	if (scope.getScopeType() != ScopeType.ZONE) {	
only support zone wide image cache stores 

========================= cloudstack sample_3947 =========================

final String vmName = command.getVmName();	final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	if (command.checkBeforeCleanup()) {	try {	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(vmName);	final Domain vm = conn.domainLookupByName(command.getVmName());	if (vm != null && vm.getInfo().state == DomainState.VIR_DOMAIN_RUNNING) {	return new StopAnswer(command, "vm is still running on host", false);	}	} catch (final Exception e) {	
failed to get vm status in case of checkboforecleanup is true 

========================= cloudstack sample_1079 =========================

public void disconnect(Status state) {	if (s_logger.isDebugEnabled()) {	
processing disconnect 

protected void finalize() throws Throwable {	try {	assert _resource == null : "Come on now....If you're going to dabble in agent code, you better know how to close out our resources. Ever considered why there's a method called disconnect()?";	synchronized (this) {	if (_resource != null) {	
lost attache for 

protected synchronized void runInContext() {	try {	if (_outstandingCronTaskCount.incrementAndGet() >= _agentMgr.getDirectAgentThreadCap()) {	
pingtask execution for direct attache has reached maximum outstanding limit bailing out 

}	ServerResource resource = _resource;	if (resource != null) {	PingCommand cmd = resource.getCurrentStatus(_id);	int retried = 0;	while (cmd == null && ++retried <= _HostPingRetryCount.value()) {	Thread.sleep(1000*_HostPingRetryTimer.value());	cmd = resource.getCurrentStatus(_id);	}	if (cmd == null) {	
unable to get current status on 

Thread.sleep(1000*_HostPingRetryTimer.value());	cmd = resource.getCurrentStatus(_id);	}	if (cmd == null) {	return;	}	if (cmd.getContextParam("logid") != null) {	MDC.put("logcontextid", cmd.getContextParam("logid"));	}	if (s_logger.isDebugEnabled()) {	
ping from 

if (cmd == null) {	return;	}	if (cmd.getContextParam("logid") != null) {	MDC.put("logcontextid", cmd.getContextParam("logid"));	}	if (s_logger.isDebugEnabled()) {	}	long seq = _seq++;	if (s_logger.isTraceEnabled()) {	
seqa 

if (cmd.getContextParam("logid") != null) {	MDC.put("logcontextid", cmd.getContextParam("logid"));	}	if (s_logger.isDebugEnabled()) {	}	long seq = _seq++;	if (s_logger.isTraceEnabled()) {	}	_agentMgr.handleCommands(DirectAgentAttache.this, seq, new Command[] {cmd});	} else {	
unable to send ping because agent is disconnected 

}	if (s_logger.isDebugEnabled()) {	}	long seq = _seq++;	if (s_logger.isTraceEnabled()) {	}	_agentMgr.handleCommands(DirectAgentAttache.this, seq, new Command[] {cmd});	} else {	}	} catch (Exception e) {	
unable to complete the ping task 

try {	Command[] cmds = _req.getCommands();	ArrayList<Answer> answers = new ArrayList<Answer>(cmds.length);	for (Command cmd : cmds) {	Answer answer = new Answer(cmd, false, "Bailed out as maximum outstanding task limit reached");	answers.add(answer);	}	Response resp = new Response(_req, answers.toArray(new Answer[answers.size()]));	processAnswers(seq, resp);	} catch (Exception e) {	
exception caught in bailout 

protected void runInContext() {	long seq = _req.getSequence();	try {	if (_outstandingCronTaskCount.incrementAndGet() >= _agentMgr.getDirectAgentThreadCap()) {	
crontask execution for direct attache has reached maximum outstanding limit bailing out 

long seq = _req.getSequence();	try {	if (_outstandingCronTaskCount.incrementAndGet() >= _agentMgr.getDirectAgentThreadCap()) {	bailout();	return;	}	ServerResource resource = _resource;	Command[] cmds = _req.getCommands();	boolean stopOnError = _req.stopOnError();	if (s_logger.isDebugEnabled()) {	
executing request 

for (int i = 0; i < cmds.length; i++) {	Answer answer = null;	Command currentCmd = cmds[i];	if (currentCmd.getContextParam("logid") != null) {	MDC.put("logcontextid", currentCmd.getContextParam("logid"));	}	try {	if (resource != null) {	answer = resource.executeRequest(cmds[i]);	if (answer == null) {	
resource returned null answer 

try {	if (resource != null) {	answer = resource.executeRequest(cmds[i]);	if (answer == null) {	answer = new Answer(cmds[i], false, "Resource returned null answer");	}	} else {	answer = new Answer(cmds[i], false, "Agent is disconnected");	}	} catch (Exception e) {	
exception caught while executing command 

}	} else {	answer = new Answer(cmds[i], false, "Agent is disconnected");	}	} catch (Exception e) {	answer = new Answer(cmds[i], false, e.toString());	}	answers.add(answer);	if (!answer.getResult() && stopOnError) {	if (i < cmds.length - 1 && s_logger.isDebugEnabled()) {	
cancelling because one of the answers is false and it is stop on error 

}	answers.add(answer);	if (!answer.getResult() && stopOnError) {	if (i < cmds.length - 1 && s_logger.isDebugEnabled()) {	}	break;	}	}	Response resp = new Response(_req, answers.toArray(new Answer[answers.size()]));	if (s_logger.isDebugEnabled()) {	
response received 

if (i < cmds.length - 1 && s_logger.isDebugEnabled()) {	}	break;	}	}	Response resp = new Response(_req, answers.toArray(new Answer[answers.size()]));	if (s_logger.isDebugEnabled()) {	}	processAnswers(seq, resp);	} catch (Exception e) {	
exception caught 

protected void runInContext() {	long seq = _req.getSequence();	try {	ServerResource resource = _resource;	Command[] cmds = _req.getCommands();	boolean stopOnError = _req.stopOnError();	if (s_logger.isDebugEnabled()) {	
executing request 

for (int i = 0; i < cmds.length; i++) {	Answer answer = null;	Command currentCmd = cmds[i];	if (currentCmd.getContextParam("logid") != null) {	MDC.put("logcontextid", currentCmd.getContextParam("logid"));	}	try {	if (resource != null) {	answer = resource.executeRequest(cmds[i]);	if (answer == null) {	
resource returned null answer 

try {	if (resource != null) {	answer = resource.executeRequest(cmds[i]);	if (answer == null) {	answer = new Answer(cmds[i], false, "Resource returned null answer");	}	} else {	answer = new Answer(cmds[i], false, "Agent is disconnected");	}	} catch (Throwable t) {	
throwable caught while executing command 

}	} else {	answer = new Answer(cmds[i], false, "Agent is disconnected");	}	} catch (Throwable t) {	answer = new Answer(cmds[i], false, t.toString());	}	answers.add(answer);	if (!answer.getResult() && stopOnError) {	if (i < cmds.length - 1 && s_logger.isDebugEnabled()) {	
cancelling because one of the answers is false and it is stop on error 

}	answers.add(answer);	if (!answer.getResult() && stopOnError) {	if (i < cmds.length - 1 && s_logger.isDebugEnabled()) {	}	break;	}	}	Response resp = new Response(_req, answers.toArray(new Answer[answers.size()]));	if (s_logger.isDebugEnabled()) {	
response received 

if (i < cmds.length - 1 && s_logger.isDebugEnabled()) {	}	break;	}	}	Response resp = new Response(_req, answers.toArray(new Answer[answers.size()]));	if (s_logger.isDebugEnabled()) {	}	processAnswers(seq, resp);	} catch (Throwable t) {	
throwable caught in runincontext this will cause the management to become unpredictable 

========================= cloudstack sample_4781 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	
execute 

========================= cloudstack sample_1429 =========================

public void execute() {	try {	boolean result = _securityGroupService.deleteSecurityGroup(this);	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to delete security group");	}	} catch (ResourceInUseException ex) {	
exception 

========================= cloudstack sample_3551 =========================

public LibvirtXMLParser() {	try {	_sp = s_spf.newSAXParser();	_initialized = true;	} catch (ParserConfigurationException e) {	
ignoring xml parser error 

public LibvirtXMLParser() {	try {	_sp = s_spf.newSAXParser();	_initialized = true;	} catch (ParserConfigurationException e) {	} catch (SAXException e) {	
ignoring xml parser error 

========================= cloudstack sample_1096 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	UcsBladeResponse rsp = mgr.associateProfileToBlade(this);	rsp.setResponseName(getCommandName());	this.setResponseObject(rsp);	} catch (Exception e) {	
exception 

========================= cloudstack sample_1242 =========================

List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(parameters.size());	for (Entry<String, String> e : parameters.entrySet()) {	nameValuePairs.add(new NameValuePair(e.getKey(), e.getValue()));	}	getMethod.setQueryString(nameValuePairs.toArray(new NameValuePair[0]));	}	neutronRestApi.executeMethod(getMethod);	if (getMethod.getStatusCode() != HttpStatus.SC_OK) {	String errorMessage = responseToErrorMessage(getMethod);	getMethod.releaseConnection();	
failed to retrieve object 

getMethod.setQueryString(nameValuePairs.toArray(new NameValuePair[0]));	}	neutronRestApi.executeMethod(getMethod);	if (getMethod.getStatusCode() != HttpStatus.SC_OK) {	String errorMessage = responseToErrorMessage(getMethod);	getMethod.releaseConnection();	throw new NeutronRestApiException("Failed to retrieve object : " + errorMessage);	}	return getMethod.getResponseBodyAsString();	} catch (NeutronRestApiException e) {	
neutronrestapiexception caught while trying to execute http method on the neutron controller 

PostMethod postMethod = (PostMethod) neutronRestApi.createMethod(url, uri);	try {	postMethod.setRequestHeader(CONTENT_TYPE, JSON_CONTENT_TYPE);	postMethod.setRequestEntity(entity);	String encodedCredentials = encodeCredentials();	postMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(postMethod);	if (postMethod.getStatusCode() != HttpStatus.SC_CREATED) {	String errorMessage = responseToErrorMessage(postMethod);	postMethod.releaseConnection();	
failed to create object 

String encodedCredentials = encodeCredentials();	postMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(postMethod);	if (postMethod.getStatusCode() != HttpStatus.SC_CREATED) {	String errorMessage = responseToErrorMessage(postMethod);	postMethod.releaseConnection();	throw new NeutronRestApiException("Failed to create object : " + errorMessage);	}	return postMethod.getResponseBodyAsString();	} catch (NeutronRestApiException e) {	
neutronrestapiexception caught while trying to execute http method on the neutron controller 

PutMethod putMethod = (PutMethod) neutronRestApi.createMethod(url, uri);	try {	putMethod.setRequestHeader(CONTENT_TYPE, JSON_CONTENT_TYPE);	putMethod.setRequestEntity(entity);	String encodedCredentials = encodeCredentials();	putMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(putMethod);	if (putMethod.getStatusCode() != HttpStatus.SC_OK) {	String errorMessage = responseToErrorMessage(putMethod);	putMethod.releaseConnection();	
failed to update object 

putMethod.setRequestEntity(entity);	String encodedCredentials = encodeCredentials();	putMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(putMethod);	if (putMethod.getStatusCode() != HttpStatus.SC_OK) {	String errorMessage = responseToErrorMessage(putMethod);	putMethod.releaseConnection();	throw new NeutronRestApiException("Failed to create object : " + errorMessage);	}	} catch (NeutronRestApiException e) {	
neutronrestapiexception caught while trying to execute http method on the neutron controller 

NeutronRestFactory factory = NeutronRestFactory.getInstance();	NeutronRestApi neutronRestApi = factory.getNeutronApi(PutMethod.class);	PutMethod putMethod = (PutMethod) neutronRestApi.createMethod(url, uri);	try {	String encodedCredentials = encodeCredentials();	putMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(putMethod);	if (putMethod.getStatusCode() != HttpStatus.SC_OK) {	String errorMessage = responseToErrorMessage(putMethod);	putMethod.releaseConnection();	
failed to update object 

String encodedCredentials = encodeCredentials();	putMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(putMethod);	if (putMethod.getStatusCode() != HttpStatus.SC_OK) {	String errorMessage = responseToErrorMessage(putMethod);	putMethod.releaseConnection();	throw new NeutronRestApiException("Failed to create object : " + errorMessage);	}	return putMethod.getResponseBodyAsString();	} catch (NeutronRestApiException e) {	
neutronrestapiexception caught while trying to execute http method on the neutron controller 

NeutronRestApi neutronRestApi = factory.getNeutronApi(DeleteMethod.class);	DeleteMethod deleteMethod = (DeleteMethod) neutronRestApi.createMethod(url, uri);	try {	deleteMethod.setRequestHeader(CONTENT_TYPE, JSON_CONTENT_TYPE);	String encodedCredentials = encodeCredentials();	deleteMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(deleteMethod);	if (deleteMethod.getStatusCode() != HttpStatus.SC_NO_CONTENT) {	String errorMessage = responseToErrorMessage(deleteMethod);	deleteMethod.releaseConnection();	
failed to update object 

deleteMethod.setRequestHeader(CONTENT_TYPE, JSON_CONTENT_TYPE);	String encodedCredentials = encodeCredentials();	deleteMethod.setRequestHeader("Authorization", "Basic " + encodedCredentials);	neutronRestApi.executeMethod(deleteMethod);	if (deleteMethod.getStatusCode() != HttpStatus.SC_NO_CONTENT) {	String errorMessage = responseToErrorMessage(deleteMethod);	deleteMethod.releaseConnection();	throw new NeutronRestApiException("Failed to create object : " + errorMessage);	}	} catch (NeutronRestApiException e) {	
neutronrestapiexception caught while trying to execute http method on the neutron controller 

private String responseToErrorMessage(final HttpMethodBase method) {	assert method.isRequestSent() : "no use getting an error message unless the request is sent";	final Header contentTypeHeader = method.getResponseHeader(CONTENT_TYPE);	if (contentTypeHeader != null && TEXT_HTML_CONTENT_TYPE.equals(contentTypeHeader.getValue())) {	try {	return method.getResponseBodyAsString(BODY_RESP_MAX_LEN);	} catch (IOException e) {	
error while loading response body 

========================= cloudstack sample_1612 =========================

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	
configure vmwaremanagerimpl manager name 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (!_configDao.isPremium()) {	
vmware component can only run under premium distribution 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (!_configDao.isPremium()) {	throw new ConfigurationException("Vmware component can only run under premium distribution");	}	_instance = _configDao.getValue(Config.InstanceName.key());	if (_instance == null) {	_instance = "DEFAULT";	}	
vmwaremanagerimpl config instance name 

if (_instance == null) {	_instance = "DEFAULT";	}	_mountParent = _configDao.getValue(Config.MountParent.key());	if (_mountParent == null) {	_mountParent = File.separator + "mnt";	}	if (_instance != null) {	_mountParent = _mountParent + File.separator + _instance;	}	
vmwaremanagerimpl config mountparent 

_managemetPortGroupName = _configDao.getValue(Config.VmwareManagementPortGroup.key());	if (_managemetPortGroupName == null) {	_managemetPortGroupName = "Management Network";	}	_defaultSystemVmNicAdapterType = _configDao.getValue(Config.VmwareSystemVmNicDeviceType.key());	if (_defaultSystemVmNicAdapterType == null) {	_defaultSystemVmNicAdapterType = VirtualEthernetCardType.E1000.toString();	}	_additionalPortRangeStart = NumbersUtil.parseInt(_configDao.getValue(Config.VmwareAdditionalVncPortRangeStart.key()), 59000);	if (_additionalPortRangeStart > 65535) {	
invalid port range start port for additional vnc port allocation reset it to default start port 

_defaultSystemVmNicAdapterType = _configDao.getValue(Config.VmwareSystemVmNicDeviceType.key());	if (_defaultSystemVmNicAdapterType == null) {	_defaultSystemVmNicAdapterType = VirtualEthernetCardType.E1000.toString();	}	_additionalPortRangeStart = NumbersUtil.parseInt(_configDao.getValue(Config.VmwareAdditionalVncPortRangeStart.key()), 59000);	if (_additionalPortRangeStart > 65535) {	_additionalPortRangeStart = 59000;	}	_additionalPortRangeSize = NumbersUtil.parseInt(_configDao.getValue(Config.VmwareAdditionalVncPortRangeSize.key()), 1000);	if (_additionalPortRangeSize < 0 || _additionalPortRangeStart + _additionalPortRangeSize > 65535) {	
invalid port range size for range starts at 

_additionalPortRangeStart = NumbersUtil.parseInt(_configDao.getValue(Config.VmwareAdditionalVncPortRangeStart.key()), 59000);	if (_additionalPortRangeStart > 65535) {	_additionalPortRangeStart = 59000;	}	_additionalPortRangeSize = NumbersUtil.parseInt(_configDao.getValue(Config.VmwareAdditionalVncPortRangeSize.key()), 1000);	if (_additionalPortRangeSize < 0 || _additionalPortRangeStart + _additionalPortRangeSize > 65535) {	_additionalPortRangeSize = Math.min(1000, 65535 - _additionalPortRangeStart);	}	_routerExtraPublicNics = NumbersUtil.parseInt(_configDao.getValue(Config.RouterExtraPublicNics.key()), 2);	_vCenterSessionTimeout = NumbersUtil.parseInt(_configDao.getValue(Config.VmwareVcenterSessionTimeout.key()), 1200) * 1000;	
vmwaremanagerimpl config vmware vcenter session timeout 

_routerExtraPublicNics = NumbersUtil.parseInt(_configDao.getValue(Config.RouterExtraPublicNics.key()), 2);	_vCenterSessionTimeout = NumbersUtil.parseInt(_configDao.getValue(Config.VmwareVcenterSessionTimeout.key()), 1200) * 1000;	_recycleHungWorker = _configDao.getValue(Config.VmwareRecycleHungWorker.key());	if (_recycleHungWorker == null || _recycleHungWorker.isEmpty()) {	_recycleHungWorker = "false";	}	_rootDiskController = _configDao.getValue(Config.VmwareRootDiskControllerType.key());	if (_rootDiskController == null || _rootDiskController.isEmpty()) {	_rootDiskController = DiskControllerType.ide.toString();	}	
additional vnc port allocation range is settled at to 

_recycleHungWorker = _configDao.getValue(Config.VmwareRecycleHungWorker.key());	if (_recycleHungWorker == null || _recycleHungWorker.isEmpty()) {	_recycleHungWorker = "false";	}	_rootDiskController = _configDao.getValue(Config.VmwareRootDiskControllerType.key());	if (_rootDiskController == null || _rootDiskController.isEmpty()) {	_rootDiskController = DiskControllerType.ide.toString();	}	value = _configDao.getValue("vmware.host.scan.interval");	_hostScanInterval = NumbersUtil.parseLong(value, DEFAULT_HOST_SCAN_INTERVAL);	
vmwaremanagerimpl config vmware host scan interval 

_recycleHungWorker = "false";	}	_rootDiskController = _configDao.getValue(Config.VmwareRootDiskControllerType.key());	if (_rootDiskController == null || _rootDiskController.isEmpty()) {	_rootDiskController = DiskControllerType.ide.toString();	}	value = _configDao.getValue("vmware.host.scan.interval");	_hostScanInterval = NumbersUtil.parseLong(value, DEFAULT_HOST_SCAN_INTERVAL);	((VmwareStorageManagerImpl)_storageMgr).configure(params);	_agentMgr.registerForHostEvents(this, true, true, true);	
vmwaremanagerimpl has been successfully configured 

public boolean stop() {	_hostScanScheduler.shutdownNow();	try {	_hostScanScheduler.awaitTermination(3000, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	
ignored interupted while stopping 

firewallMo.refreshFirewall();	}	}	String vSwitchName;	String vlanId;	String vSwitchType;	VmwareTrafficLabel mgmtTrafficLabelObj = new VmwareTrafficLabel(privateTrafficLabel, TrafficType.Management);	vSwitchName = mgmtTrafficLabelObj.getVirtualSwitchName();	vlanId = mgmtTrafficLabelObj.getVlanId();	vSwitchType = mgmtTrafficLabelObj.getVirtualSwitchType().toString();	
preparing network on host for 

prepareHost(hostMo, privateTrafficLabel);	returnedHostList.add(morHost);	}	return returnedHostList;	} else if (mor.getType().equals("HostSystem")) {	HostMO hostMo = new HostMO(serviceContext, mor);	prepareHost(hostMo, privateTrafficLabel);	returnedHostList.add(mor);	return returnedHostList;	} else {	
unsupport host type from inventory path 

return returnedHostList;	} else if (mor.getType().equals("HostSystem")) {	HostMO hostMo = new HostMO(serviceContext, mor);	prepareHost(hostMo, privateTrafficLabel);	returnedHostList.add(mor);	return returnedHostList;	} else {	return null;	}	}	
unable to find host from inventory path 

public Pair<String, Long> getSecondaryStorageStoreUrlAndId(long dcId) {	String secUrl = null;	Long secId = null;	DataStore secStore = _dataStoreMgr.getImageStore(dcId);	if (secStore != null) {	secUrl = secStore.getUri();	secId = secStore.getId();	}	if (secUrl == null) {	
secondary storage is not nfs we need to use staging storage 

if (secStore != null) {	secUrl = secStore.getUri();	secId = secStore.getId();	}	if (secUrl == null) {	DataStore cacheStore = _dataStoreMgr.getImageCacheStore(dcId);	if (cacheStore != null) {	secUrl = cacheStore.getUri();	secId = cacheStore.getId();	} else {	
no staging storage is found when non nfs secondary storage is used 

public boolean needRecycle(String workerTag) {	
check to see if a worker vm with tag needs to be recycled 

public boolean needRecycle(String workerTag) {	if (workerTag == null || workerTag.isEmpty()) {	
invalid worker vm tag 

public boolean needRecycle(String workerTag) {	if (workerTag == null || workerTag.isEmpty()) {	return false;	}	String tokens[] = workerTag.split("-");	if (tokens.length != 3) {	
invalid worker vm tag 

return false;	}	String tokens[] = workerTag.split("-");	if (tokens.length != 3) {	return false;	}	Long.parseLong(tokens[0]);	long msid = Long.parseLong(tokens[1]);	long runid = Long.parseLong(tokens[2]);	if (_mshostPeerDao.countStateSeenInPeers(msid, runid, ManagementServerHost.State.Down) > 0) {	
worker vm s owner management server node has been detected down from peer nodes recycle it 

if (tokens.length != 3) {	return false;	}	Long.parseLong(tokens[0]);	long msid = Long.parseLong(tokens[1]);	long runid = Long.parseLong(tokens[2]);	if (_mshostPeerDao.countStateSeenInPeers(msid, runid, ManagementServerHost.State.Down) > 0) {	return true;	}	if (runid != _clusterMgr.getManagementRunId(msid)) {	
worker vm s owner management server has changed runid recycle it 

Long.parseLong(tokens[0]);	long msid = Long.parseLong(tokens[1]);	long runid = Long.parseLong(tokens[2]);	if (_mshostPeerDao.countStateSeenInPeers(msid, runid, ManagementServerHost.State.Down) > 0) {	return true;	}	if (runid != _clusterMgr.getManagementRunId(msid)) {	return true;	}	if(System.currentTimeMillis() - startTick > _hungWorkerTimeout) {	
worker vm expired seconds elapsed 

if (!patchFolder.exists()) {	if (!patchFolder.mkdirs()) {	String msg = "Unable to create systemvm folder on secondary storage. location: " + patchFolder.toString();	s_logger.error(msg);	throw new CloudRuntimeException(msg);	}	}	File srcIso = getSystemVMPatchIsoFile();	File destIso = new File(mountPoint + "/systemvm/" + getSystemVMIsoFileNameOnDatastore());	if (!destIso.exists()) {	
inject ssh key pairs before copying systemvm iso into secondary storage 

if (!patchFolder.mkdirs()) {	String msg = "Unable to create systemvm folder on secondary storage. location: " + patchFolder.toString();	s_logger.error(msg);	throw new CloudRuntimeException(msg);	}	}	File srcIso = getSystemVMPatchIsoFile();	File destIso = new File(mountPoint + "/systemvm/" + getSystemVMIsoFileNameOnDatastore());	if (!destIso.exists()) {	_configServer.updateKeyPairs();	
copy system vm patch iso file to secondary storage source iso destination 

throw new CloudRuntimeException(msg);	}	}	File srcIso = getSystemVMPatchIsoFile();	File destIso = new File(mountPoint + "/systemvm/" + getSystemVMIsoFileNameOnDatastore());	if (!destIso.exists()) {	_configServer.updateKeyPairs();	try {	FileUtil.copyfile(srcIso, destIso);	} catch (IOException e) {	
unexpected exception 

_configServer.updateKeyPairs();	try {	FileUtil.copyfile(srcIso, destIso);	} catch (IOException e) {	String msg = "Unable to copy systemvm ISO on secondary storage. src location: " + srcIso.toString() + ", dest location: " + destIso;	s_logger.error(msg);	throw new CloudRuntimeException(msg);	}	} else {	if (s_logger.isTraceEnabled()) {	
systemvm iso file already exists 

URL url = this.getClass().getClassLoader().getResource("vms/systemvm.iso");	File isoFile = null;	if (url != null) {	isoFile = new File(url.getPath());	}	if (isoFile == null || !isoFile.exists()) {	isoFile = new File("/usr/share/cloudstack-common/vms/systemvm.iso");	}	assert (isoFile != null);	if (!isoFile.exists()) {	
unable to locate systemvm iso in your setup at 

URL url = this.getClass().getClassLoader().getResource("scripts/vm/systemvm/id_rsa.cloud");	File keyFile = null;	if (url != null) {	keyFile = new File(url.getPath());	}	if (keyFile == null || !keyFile.exists()) {	keyFile = new File("/usr/share/cloudstack-common/scripts/vm/systemvm/id_rsa.cloud");	}	assert (keyFile != null);	if (!keyFile.exists()) {	
unable to locate id rsa cloud in your setup at 

String mountPoint = null;	synchronized (_storageMounts) {	mountPoint = _storageMounts.get(storageUrl);	if (mountPoint != null) {	return mountPoint;	}	URI uri;	try {	uri = new URI(storageUrl);	} catch (URISyntaxException e) {	
invalid storage url format 

return mountPoint;	}	URI uri;	try {	uri = new URI(storageUrl);	} catch (URISyntaxException e) {	throw new CloudRuntimeException("Unable to create mount point due to invalid storage URL format " + storageUrl);	}	mountPoint = mount(uri.getHost() + ":" + uri.getPath(), _mountParent, nfsVersion);	if (mountPoint == null) {	
unable to create mount point for 

long mshostId = ManagementServerNode.getManagementServerId();	for (int i = 0; i < 10; i++) {	String mntPt = parent + File.separator + String.valueOf(mshostId) + "." + Integer.toHexString(_rand.nextInt(Integer.MAX_VALUE));	File file = new File(mntPt);	if (!file.exists()) {	if (_storage.mkdir(mntPt)) {	mountPoint = mntPt;	break;	}	}	
unable to create mount 

private void startupCleanup(String parent) {	
cleanup mounted nfs mount points used in previous session 

private void startupCleanup(String parent) {	long mshostId = ManagementServerNode.getManagementServerId();	List<String> mounts = _storage.listMountPointsByMsHost(parent, mshostId);	if (mounts != null && !mounts.isEmpty()) {	for (String mountPoint : mounts) {	
umount nfs mount from previous session 

private void startupCleanup(String parent) {	long mshostId = ManagementServerNode.getManagementServerId();	List<String> mounts = _storage.listMountPointsByMsHost(parent, mshostId);	if (mounts != null && !mounts.isEmpty()) {	for (String mountPoint : mounts) {	String result = null;	Script command = new Script(true, "umount", _timeout, s_logger);	command.add(mountPoint);	result = command.execute();	if (result != null) {	
unable to umount due to 

private void shutdownCleanup() {	
cleanup mounted nfs mount points used in current session 

private void shutdownCleanup() {	for (String mountPoint : _storageMounts.values()) {	
umount nfs mount 

private void shutdownCleanup() {	for (String mountPoint : _storageMounts.values()) {	String result = null;	Script command = new Script(true, "umount", _timeout, s_logger);	command.add(mountPoint);	result = command.execute();	if (result != null) {	
unable to umount due to 

protected String mount(String path, String parent, Integer nfsVersion) {	String mountPoint = setupMountPoint(parent);	if (mountPoint == null) {	
unable to create a mount point 

if (nfsVersion != null){	command.add("-o", "vers=" + nfsVersion);	}	if ("Mac OS X".equalsIgnoreCase(System.getProperty("os.name"))) {	command.add("-o", "resvport");	}	command.add(path);	command.add(mountPoint);	result = command.execute();	if (result != null) {	
unable to mount due to 

File file = new File(mountPoint);	if (file.exists()) {	file.delete();	}	return null;	}	script = new Script(true, "chmod", _timeout, s_logger);	script.add("1777", mountPoint);	result = script.execute();	if (result != null) {	
unable to set permissions for due to 

protected boolean shutdownRouterVM(DomainRouterVO router) {	if (s_logger.isDebugEnabled()) {	
try to shutdown router vm directly 

protected boolean shutdownRouterVM(DomainRouterVO router) {	if (s_logger.isDebugEnabled()) {	}	Pair<Boolean, String> result;	try {	result = SshHelper.sshExecute(router.getPrivateIpAddress(), DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "poweroff -f");	if (!result.first()) {	
unable to shutdown directly 

protected boolean shutdownRouterVM(DomainRouterVO router) {	if (s_logger.isDebugEnabled()) {	}	Pair<Boolean, String> result;	try {	result = SshHelper.sshExecute(router.getPrivateIpAddress(), DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "poweroff -f");	if (!result.first()) {	return false;	}	} catch (Throwable e) {	
unable to shutdown router directly 

Pair<Boolean, String> result;	try {	result = SshHelper.sshExecute(router.getPrivateIpAddress(), DEFAULT_DOMR_SSHPORT, "root", getSystemVMKeyFile(), null, "poweroff -f");	if (!result.first()) {	return false;	}	} catch (Throwable e) {	return false;	}	if (s_logger.isDebugEnabled()) {	
shutdown router successful 

public Map<String, String> getNexusVSMCredentialsByClusterId(Long clusterId) {	CiscoNexusVSMDeviceVO nexusVSM = null;	ClusterVSMMapVO vsmMapVO = null;	vsmMapVO = _vsmMapDao.findByClusterId(clusterId);	long vsmId = 0;	if (vsmMapVO != null) {	vsmId = vsmMapVO.getVsmId();	
vsmid is 

public Map<String, String> getNexusVSMCredentialsByClusterId(Long clusterId) {	CiscoNexusVSMDeviceVO nexusVSM = null;	ClusterVSMMapVO vsmMapVO = null;	vsmMapVO = _vsmMapDao.findByClusterId(clusterId);	long vsmId = 0;	if (vsmMapVO != null) {	vsmId = vsmMapVO.getVsmId();	nexusVSM = _nexusDao.findById(vsmId);	
fetching nexus vsm credentials from database 

public Map<String, String> getNexusVSMCredentialsByClusterId(Long clusterId) {	CiscoNexusVSMDeviceVO nexusVSM = null;	ClusterVSMMapVO vsmMapVO = null;	vsmMapVO = _vsmMapDao.findByClusterId(clusterId);	long vsmId = 0;	if (vsmMapVO != null) {	vsmId = vsmMapVO.getVsmId();	nexusVSM = _nexusDao.findById(vsmId);	} else {	
found empty vsmmapvo 

vsmId = vsmMapVO.getVsmId();	nexusVSM = _nexusDao.findById(vsmId);	} else {	return null;	}	Map<String, String> nexusVSMCredentials = new HashMap<String, String>();	if (nexusVSM != null) {	nexusVSMCredentials.put("vsmip", nexusVSM.getipaddr());	nexusVSMCredentials.put("vsmusername", nexusVSM.getUserName());	nexusVSMCredentials.put("vsmpassword", nexusVSM.getPassword());	
successfully fetched the credentials of nexus vsm 

}	if (zoneId == null) {	throw new InvalidParameterValueException("Missing or invalid parameter name. " + "Please provide valid zone id.");	}	validateZone(zoneId);	VmwareDatacenterZoneMapVO vmwareDcZoneMap = _vmwareDcZoneMapDao.findByZoneId(zoneId);	if (vmwareDcZoneMap != null) {	Long associatedVmwareDcId = vmwareDcZoneMap.getVmwareDcId();	VmwareDatacenterVO associatedVmwareDc = _vmwareDcDao.findById(associatedVmwareDcId);	if (associatedVmwareDc.getVcenterHost().equalsIgnoreCase(vCenterHost) && associatedVmwareDc.getVmwareDatacenterName().equalsIgnoreCase(vmwareDcName)) {	
ignoring api call addvmwaredc because vmware dc is already associated with specified zone with id 

context = VmwareContextFactory.create(vCenterHost, userName, password);	try {	dcMo = new DatacenterMO(context, vmwareDcName);	} catch (Throwable t) {	String msg = "Unable to find DC " + vmwareDcName + " in vCenter " + vCenterHost;	s_logger.error(msg);	throw new DiscoveryException(msg);	}	assert (dcMo != null);	dcMo.setCustomFieldValue(CustomFieldConstants.CLOUD_ZONE, "false");	
sucessfully reset custom field property cloud zone over dc 

private void validateZone(Long zoneId) throws InvalidParameterValueException {	doesZoneExist(zoneId);	if (isLegacyZone(zoneId)) {	throw new InvalidParameterValueException("The specified zone is legacy zone. Adding VMware datacenter to legacy zone is not supported.");	} else {	if (s_logger.isTraceEnabled()) {	
the specified zone is not legacy zone 

private void doesZoneExist(Long zoneId) throws InvalidParameterValueException {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone == null) {	throw new InvalidParameterValueException("Can't find zone by the id specified.");	}	if (s_logger.isTraceEnabled()) {	
zone with id exists 

public boolean hasNexusVSM(Long clusterId) {	ClusterVSMMapVO vsmMapVo = null;	vsmMapVo = _vsmMapDao.findByClusterId(clusterId);	if (vsmMapVo == null) {	
there is no instance of nexus vsm associated with this cluster id yet 

public boolean hasNexusVSM(Long clusterId) {	ClusterVSMMapVO vsmMapVo = null;	vsmMapVo = _vsmMapDao.findByClusterId(clusterId);	if (vsmMapVo == null) {	return false;	}	else {	
an instance of nexus vsm id associated with this cluster id 

========================= cloudstack sample_1307 =========================

public Answer executeRequest(final Command cmd) {	if (cmd instanceof CheckConsoleProxyLoadCommand) {	return execute((CheckConsoleProxyLoadCommand)cmd);	} else if (cmd instanceof WatchConsoleProxyLoadCommand) {	return execute((WatchConsoleProxyLoadCommand)cmd);	} else if (cmd instanceof ReadyCommand) {	
receive readycommand response with readyanswer 

private Answer execute(StartConsoleProxyAgentHttpHandlerCommand cmd) {	
invoke launchconsoleproxy in responding to startconsoleproxyagenthttphandlercommand 

private void disableRpFilter() {	try (FileWriter fstream = new FileWriter("/proc/sys/net/ipv4/conf/eth2/rp_filter");	BufferedWriter out = new BufferedWriter(fstream);) {	out.write("0");	} catch (IOException e) {	
unable to disable rp filter 

String line = null;	try {	while ((line = reader.readLine()) != null) sb2.append(line + "\n");	result = sb2.toString();	} catch (final IOException e) {	success = false;	} finally {	try {	is.close();	} catch (final IOException e) {	
exception when closing console proxy address 

} catch (final IOException e) {	success = false;	} finally {	try {	is.close();	} catch (final IOException e) {	success = false;	}	}	} catch (final IOException e) {	
unable to open console proxy command port url console proxy address 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	_localgw = (String)params.get("localgw");	_eth1mask = (String)params.get("eth1mask");	_eth1ip = (String)params.get("eth1ip");	if (_eth1ip != null) {	params.put("private.network.device", "eth1");	} else {	
parameter has not been configured assuming that we are not inside a system vm 

_eth1mask = (String)params.get("eth1mask");	_eth1ip = (String)params.get("eth1ip");	if (_eth1ip != null) {	params.put("private.network.device", "eth1");	} else {	}	String eth2ip = (String)params.get("eth2ip");	if (eth2ip != null) {	params.put("public.network.device", "eth2");	} else {	
parameter is not found assuming that we are not inside a system vm 

_proxyPort = NumbersUtil.parseInt(value, 80);	}	value = (String)params.get("proxy_vm");	_proxyVmId = NumbersUtil.parseLong(value, 0);	if (_localgw != null) {	String mgmtHost = (String)params.get("host");	if (_eth1ip != null) {	addRouteToInternalIpOrCidr(_localgw, _eth1ip, _eth1mask, mgmtHost);	String internalDns1 = (String) params.get("internaldns1");	if (internalDns1 == null) {	
no dns entry found during configuration of nfssecondarystorage 

if (internalDns2 != null) {	addRouteToInternalIpOrCidr(_localgw, _eth1ip, _eth1mask, internalDns2);	}	}	}	_pubIp = (String)params.get("public.ip");	value = (String)params.get("disable_rp_filter");	if (value != null && value.equalsIgnoreCase("true")) {	disableRpFilter();	}	
receive proxyvmid in consoleproxyresource configuration as 

private void addRouteToInternalIpOrCidr(String localgw, String eth1ip, String eth1mask, String destIpOrCidr) {	s_logger.debug("addRouteToInternalIp: localgw=" + localgw + ", eth1ip=" + eth1ip + ", eth1mask=" + eth1mask + ",destIp=" + destIpOrCidr);	if (destIpOrCidr == null) {	
addroutetointernalip destip is null 

if (NetUtils.isValidIp(destIpOrCidr)) {	if (eth1ip != null && eth1mask != null) {	inSameSubnet = NetUtils.sameSubnet(eth1ip, destIpOrCidr, eth1mask);	} else {	s_logger.warn("addRouteToInternalIp: unable to determine same subnet: _eth1ip=" + eth1ip + ", dest ip=" + destIpOrCidr + ", _eth1mask=" + eth1mask);	}	} else {	inSameSubnet = NetUtils.isNetworkAWithinNetworkB(destIpOrCidr, NetUtils.ipAndNetMaskToCidr(eth1ip, eth1mask));	}	if (inSameSubnet) {	
addroutetointernalip dest ip is in the same subnet as ip 

private void launchConsoleProxy(final byte[] ksBits, final String ksPassword, final String encryptorPassword) {	final Object resource = this;	if (_consoleProxyMain == null) {	_consoleProxyMain = new Thread(new ManagedContextRunnable() {	protected void runInContext() {	try {	Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	try {	
invoke setencryptorpassword ecnryptorpassword 

private void launchConsoleProxy(final byte[] ksBits, final String ksPassword, final String encryptorPassword) {	final Object resource = this;	if (_consoleProxyMain == null) {	_consoleProxyMain = new Thread(new ManagedContextRunnable() {	protected void runInContext() {	try {	Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	try {	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	
invoke startwithcontext 

_consoleProxyMain = new Thread(new ManagedContextRunnable() {	protected void runInContext() {	try {	Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	try {	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	Method method = consoleProxyClazz.getMethod("startWithContext", Properties.class, Object.class, byte[].class, String.class);	method.invoke(null, _properties, resource, ksBits, ksPassword);	} catch (SecurityException e) {	
unable to launch console proxy due to securityexception 

try {	Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	try {	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	Method method = consoleProxyClazz.getMethod("startWithContext", Properties.class, Object.class, byte[].class, String.class);	method.invoke(null, _properties, resource, ksBits, ksPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	
unable to launch console proxy due to nosuchmethodexception 

try {	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	Method method = consoleProxyClazz.getMethod("startWithContext", Properties.class, Object.class, byte[].class, String.class);	method.invoke(null, _properties, resource, ksBits, ksPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	
unable to launch console proxy due to illegalargumentexception 

methodSetup.invoke(null, encryptorPassword);	Method method = consoleProxyClazz.getMethod("startWithContext", Properties.class, Object.class, byte[].class, String.class);	method.invoke(null, _properties, resource, ksBits, ksPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalAccessException e) {	
unable to launch console proxy due to illegalaccessexception 

method.invoke(null, _properties, resource, ksBits, ksPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalAccessException e) {	System.exit(ExitStatus.Error.value());	} catch (InvocationTargetException e) {	
unable to launch console proxy due to invocationtargetexception 

} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalAccessException e) {	System.exit(ExitStatus.Error.value());	} catch (InvocationTargetException e) {	System.exit(ExitStatus.Error.value());	}	} catch (final ClassNotFoundException e) {	
unable to launch console proxy due to classnotfoundexception 

System.exit(ExitStatus.Error.value());	}	} catch (final ClassNotFoundException e) {	System.exit(ExitStatus.Error.value());	}	}	}, "Console-Proxy-Main");	_consoleProxyMain.setDaemon(true);	_consoleProxyMain.start();	} else {	
com cloud consoleproxy consoleproxy is already running 

}	}, "Console-Proxy-Main");	_consoleProxyMain.setDaemon(true);	_consoleProxyMain.start();	} else {	try {	Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	} catch (SecurityException e) {	
unable to launch console proxy due to securityexception 

_consoleProxyMain.setDaemon(true);	_consoleProxyMain.start();	} else {	try {	Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	
unable to launch console proxy due to nosuchmethodexception 

} else {	try {	Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	
unable to launch console proxy due to illegalargumentexception 

Class<?> consoleProxyClazz = Class.forName("com.cloud.consoleproxy.ConsoleProxy");	Method methodSetup = consoleProxyClazz.getMethod("setEncryptorPassword", String.class);	methodSetup.invoke(null, encryptorPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalAccessException e) {	
unable to launch console proxy due to illegalaccessexception 

methodSetup.invoke(null, encryptorPassword);	} catch (SecurityException e) {	System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalAccessException e) {	System.exit(ExitStatus.Error.value());	} catch (InvocationTargetException e) {	
unable to launch console proxy due to invocationtargetexception 

System.exit(ExitStatus.Error.value());	} catch (NoSuchMethodException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalArgumentException e) {	System.exit(ExitStatus.Error.value());	} catch (IllegalAccessException e) {	System.exit(ExitStatus.Error.value());	} catch (InvocationTargetException e) {	System.exit(ExitStatus.Error.value());	} catch (final ClassNotFoundException e) {	
unable to launch console proxy due to classnotfoundexception 

try {	AgentControlAnswer answer = getAgentControl().sendRequest(cmd, 10000);	if (answer != null) {	ConsoleAccessAuthenticationAnswer authAnswer = (ConsoleAccessAuthenticationAnswer)answer;	result.setSuccess(authAnswer.succeeded());	result.setHost(authAnswer.getHost());	result.setPort(authAnswer.getPort());	result.setTunnelUrl(authAnswer.getTunnelUrl());	result.setTunnelSession(authAnswer.getTunnelSession());	} else {	
authentication failed for vm with sid 

if (answer != null) {	ConsoleAccessAuthenticationAnswer authAnswer = (ConsoleAccessAuthenticationAnswer)answer;	result.setSuccess(authAnswer.succeeded());	result.setHost(authAnswer.getHost());	result.setPort(authAnswer.getPort());	result.setTunnelUrl(authAnswer.getTunnelUrl());	result.setTunnelSession(authAnswer.getTunnelSession());	} else {	}	} catch (AgentControlChannelException e) {	
unable to send out console access authentication request due to 

public void reportLoadInfo(String gsonLoadInfo) {	ConsoleProxyLoadReportCommand cmd = new ConsoleProxyLoadReportCommand(_proxyVmId, gsonLoadInfo);	try {	getAgentControl().postRequest(cmd);	
report proxy load info proxy load 

public void reportLoadInfo(String gsonLoadInfo) {	ConsoleProxyLoadReportCommand cmd = new ConsoleProxyLoadReportCommand(_proxyVmId, gsonLoadInfo);	try {	getAgentControl().postRequest(cmd);	} catch (AgentControlChannelException e) {	
unable to send out load info due to 

public void ensureRoute(String address) {	if (_localgw != null) {	
ensure route for via 

public void ensureRoute(String address) {	if (_localgw != null) {	synchronized (this) {	try {	addRouteToInternalIpOrCidr(_localgw, _eth1ip, _eth1mask, address);	} catch (Throwable e) {	
unexpected exception while adding internal route to 

========================= cloudstack sample_2878 =========================

public void create() throws ResourceAllocationException {	PrivateGateway result = null;	try {	result = _vpcService.createVpcPrivateGateway(getVpcId(), getPhysicalNetworkId(), getBroadcastUri(), getStartIp(), getGateway(), getNetmask(), getEntityOwnerId(), getNetworkOfferingId(), getIsSourceNat(), getAclId());	} catch (InsufficientCapacityException ex) {	s_logger.info(ex);	s_logger.trace(ex);	throw new ServerApiException(ApiErrorCode.INSUFFICIENT_CAPACITY_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

========================= cloudstack sample_3290 =========================

if (cmd.getLoadInfo() == null) {	return;	}	ConsoleProxyStatus status = null;	try {	GsonBuilder gb = new GsonBuilder();	gb.setVersion(1.3);	Gson gson = gb.create();	status = gson.fromJson(cmd.getLoadInfo(), ConsoleProxyStatus.class);	} catch (Throwable e) {	
unable to parse load info from proxy proxy vm id info 

if (status.getConnections() != null) {	count = status.getConnections().length;	}	byte[] details = null;	if (cmd.getLoadInfo() != null) {	details = cmd.getLoadInfo().getBytes(Charset.forName("US-ASCII"));	}	_consoleProxyDao.update(cmd.getProxyVmId(), count, DateUtil.currentGMTTime(), details);	} else {	if (s_logger.isTraceEnabled()) {	
unable to get console proxy load info id 

public void onAgentDisconnect(long agentId, com.cloud.host.Status state) {	if (state == com.cloud.host.Status.Alert || state == com.cloud.host.Status.Disconnected) {	HostVO host = _hostDao.findById(agentId);	if (host.getType() == Type.ConsoleProxy) {	String name = host.getName();	if (s_logger.isInfoEnabled()) {	
console proxy agent disconnected proxy 

if (host.getType() == Type.ConsoleProxy) {	String name = host.getName();	if (s_logger.isInfoEnabled()) {	}	if (name != null && name.startsWith("v-")) {	String[] tokens = name.split("-");	long proxyVmId = 0;	try {	proxyVmId = Long.parseLong(tokens[1]);	} catch (NumberFormatException e) {	
unexpected exception 

long proxyVmId = 0;	try {	proxyVmId = Long.parseLong(tokens[1]);	} catch (NumberFormatException e) {	return;	}	final ConsoleProxyVO proxy = _consoleProxyDao.findById(proxyVmId);	if (proxy != null) {	} else {	if (s_logger.isInfoEnabled()) {	
console proxy agent disconnected but corresponding console proxy vm no longer exists in db proxy 

protected HostVO findConsoleProxyHost(StartupProxyCommand startupCmd) {	long proxyVmId = startupCmd.getProxyVmId();	ConsoleProxyVO consoleProxy = _consoleProxyDao.findById(proxyVmId);	if (consoleProxy == null) {	
proxy is no longer in db skip sending startup command 

public ConsoleProxyInfo assignProxy(final long dataCenterId, final long vmId) {	ConsoleProxyVO proxy = doAssignProxy(dataCenterId, vmId);	if (proxy == null) {	return null;	}	if (proxy.getPublicIpAddress() == null) {	
assigned console proxy does not have a valid public ip address 

public ConsoleProxyInfo assignProxy(final long dataCenterId, final long vmId) {	ConsoleProxyVO proxy = doAssignProxy(dataCenterId, vmId);	if (proxy == null) {	return null;	}	if (proxy.getPublicIpAddress() == null) {	return null;	}	KeystoreVO ksVo = _ksDao.findByName(ConsoleProxyManager.CERTIFICATE_NAME);	if (proxy.isSslEnabled() && ksVo == null) {	
ssl enabled for console proxy but no server certificate found in database 

public ConsoleProxyVO doAssignProxy(long dataCenterId, long vmId) {	ConsoleProxyVO proxy = null;	VMInstanceVO vm = _instanceDao.findById(vmId);	if (vm == null) {	
vm no longer exists return a null proxy for vm 

public ConsoleProxyVO doAssignProxy(long dataCenterId, long vmId) {	ConsoleProxyVO proxy = null;	VMInstanceVO vm = _instanceDao.findById(vmId);	if (vm == null) {	return null;	}	if (vm != null && vm.getState() != State.Running) {	if (s_logger.isInfoEnabled()) {	
detected that vm is not currently at running state we will fail the proxy assignment for it 

}	return null;	}	if (_allocProxyLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_SYNC)) {	try {	if (vm.getProxyId() != null) {	proxy = _consoleProxyDao.findById(vm.getProxyId());	if (proxy != null) {	if (!isInAssignableState(proxy)) {	if (s_logger.isInfoEnabled()) {	
a previous assigned proxy is not assignable now reassign console proxy for user vm 

if (vm.getProxyId() != null) {	proxy = _consoleProxyDao.findById(vm.getProxyId());	if (proxy != null) {	if (!isInAssignableState(proxy)) {	if (s_logger.isInfoEnabled()) {	}	proxy = null;	} else {	if (_consoleProxyDao.getProxyActiveLoad(proxy.getId()) < _capacityPerProxy || hasPreviousSession(proxy, vm)) {	if (s_logger.isTraceEnabled()) {	
assign previous allocated console proxy for user vm 

if (proxy != null) {	if (!isInAssignableState(proxy)) {	if (s_logger.isInfoEnabled()) {	}	proxy = null;	} else {	if (_consoleProxyDao.getProxyActiveLoad(proxy.getId()) < _capacityPerProxy || hasPreviousSession(proxy, vm)) {	if (s_logger.isTraceEnabled()) {	}	if (proxy.getActiveSession() >= _capacityPerProxy) {	
assign overloaded proxy to user vm as previous session exists user vm 

}	}	}	if (proxy == null) {	proxy = assignProxyFromRunningPool(dataCenterId);	}	} finally {	_allocProxyLock.unlock();	}	} else {	
unable to acquire synchronization lock to get allocate proxy resource for vm previous console proxy allocation is taking too long 

}	if (proxy == null) {	proxy = assignProxyFromRunningPool(dataCenterId);	}	} finally {	_allocProxyLock.unlock();	}	} else {	}	if (proxy == null) {	
unable to find or allocate console proxy resource 

private boolean hasPreviousSession(ConsoleProxyVO proxy, VMInstanceVO vm) {	ConsoleProxyStatus status = null;	try {	GsonBuilder gb = new GsonBuilder();	gb.setVersion(1.3);	Gson gson = gb.create();	byte[] details = proxy.getSessionDetails();	status = gson.fromJson(details != null ? new String(details, Charset.forName("US-ASCII")) : null, ConsoleProxyStatus.class);	} catch (Throwable e) {	
unable to parse proxy session details 

} catch (Throwable e) {	}	if (status != null && status.getConnections() != null) {	ConsoleProxyConnectionInfo[] connections = status.getConnections();	for (int i = 0; i < connections.length; i++) {	long taggedVmId = 0;	if (connections[i].tag != null) {	try {	taggedVmId = Long.parseLong(connections[i].tag);	} catch (NumberFormatException e) {	
unable to parse console proxy connection info passed through tag 

}	if (taggedVmId == vm.getId()) {	return true;	}	}	if (DateUtil.currentGMTTime().getTime() - vm.getProxyAssignTime().getTime() < _proxySessionTimeoutValue) {	return true;	}	return false;	} else {	
no proxy load info on an overloaded proxy 

}	String restart = _configDao.getValue(Config.ConsoleProxyRestart.key());	if (!ignoreRestartSetting && restart != null && restart.equalsIgnoreCase("false")) {	return null;	}	if (proxy.getState() == VirtualMachine.State.Stopped) {	_itMgr.advanceStart(proxy.getUuid(), null, null);	proxy = _consoleProxyDao.findById(proxy.getId());	return proxy;	}	
console proxy is not in correct state to be started 

if (!ignoreRestartSetting && restart != null && restart.equalsIgnoreCase("false")) {	return null;	}	if (proxy.getState() == VirtualMachine.State.Stopped) {	_itMgr.advanceStart(proxy.getUuid(), null, null);	proxy = _consoleProxyDao.findById(proxy.getId());	return proxy;	}	return null;	} catch (StorageUnavailableException e) {	
exception while trying to start console proxy 

}	if (proxy.getState() == VirtualMachine.State.Stopped) {	_itMgr.advanceStart(proxy.getUuid(), null, null);	proxy = _consoleProxyDao.findById(proxy.getId());	return proxy;	}	return null;	} catch (StorageUnavailableException e) {	return null;	} catch (InsufficientCapacityException e) {	
exception while trying to start console proxy 

_itMgr.advanceStart(proxy.getUuid(), null, null);	proxy = _consoleProxyDao.findById(proxy.getId());	return proxy;	}	return null;	} catch (StorageUnavailableException e) {	return null;	} catch (InsufficientCapacityException e) {	return null;	} catch (ResourceUnavailableException e) {	
exception while trying to start console proxy 

return proxy;	}	return null;	} catch (StorageUnavailableException e) {	return null;	} catch (InsufficientCapacityException e) {	return null;	} catch (ResourceUnavailableException e) {	return null;	} catch (ConcurrentOperationException e) {	
runtime exception while trying to start console proxy 

return null;	} catch (StorageUnavailableException e) {	return null;	} catch (InsufficientCapacityException e) {	return null;	} catch (ResourceUnavailableException e) {	return null;	} catch (ConcurrentOperationException e) {	return null;	} catch (CloudRuntimeException e) {	
runtime exception while trying to start console proxy 

return null;	} catch (InsufficientCapacityException e) {	return null;	} catch (ResourceUnavailableException e) {	return null;	} catch (ConcurrentOperationException e) {	return null;	} catch (CloudRuntimeException e) {	return null;	} catch (OperationTimedoutException e) {	
runtime exception while trying to start console proxy 

public ConsoleProxyVO assignProxyFromRunningPool(long dataCenterId) {	if (s_logger.isTraceEnabled()) {	
assign console proxy from running pool for request from data center 

List<ConsoleProxyVO> runningList = _consoleProxyDao.getProxyListInStates(dataCenterId, State.Running);	if (runningList != null && runningList.size() > 0) {	Iterator<ConsoleProxyVO> it = runningList.iterator();	while (it.hasNext()) {	ConsoleProxyVO proxy = it.next();	if (proxy.getActiveSession() >= _capacityPerProxy) {	it.remove();	}	}	if (s_logger.isTraceEnabled()) {	
running proxy pool size 

if (runningList != null && runningList.size() > 0) {	Iterator<ConsoleProxyVO> it = runningList.iterator();	while (it.hasNext()) {	ConsoleProxyVO proxy = it.next();	if (proxy.getActiveSession() >= _capacityPerProxy) {	it.remove();	}	}	if (s_logger.isTraceEnabled()) {	for (ConsoleProxyVO proxy : runningList) {	
running proxy instance 

if (s_logger.isTraceEnabled()) {	for (ConsoleProxyVO proxy : runningList) {	}	}	List<Pair<Long, Integer>> l = _consoleProxyDao.getProxyLoadMatrix();	Map<Long, Integer> loadInfo = new HashMap<Long, Integer>();	if (l != null) {	for (Pair<Long, Integer> p : l) {	loadInfo.put(p.first(), p.second());	if (s_logger.isTraceEnabled()) {	
running proxy instance allocation load proxy id load 

Map<Long, Integer> loadInfo = new HashMap<Long, Integer>();	if (l != null) {	for (Pair<Long, Integer> p : l) {	loadInfo.put(p.first(), p.second());	if (s_logger.isTraceEnabled()) {	}	}	}	Long allocated = allocator.allocProxy(runningList, loadInfo, dataCenterId);	if (allocated == null) {	
unable to find a console proxy 

}	}	}	Long allocated = allocator.allocProxy(runningList, loadInfo, dataCenterId);	if (allocated == null) {	return null;	}	return _consoleProxyDao.findById(allocated);	} else {	if (s_logger.isTraceEnabled()) {	
empty running proxy pool for now in data center 

public ConsoleProxyVO startNew(long dataCenterId) throws ConcurrentOperationException {	if (s_logger.isDebugEnabled()) {	
assign console proxy from a newly started instance for request from data center 

public ConsoleProxyVO startNew(long dataCenterId) throws ConcurrentOperationException {	if (s_logger.isDebugEnabled()) {	}	if (!allowToLaunchNew(dataCenterId)) {	
the number of launched console proxy on zone has reached to limit 

VMTemplateVO template = null;	HypervisorType availableHypervisor = _resourceMgr.getAvailableHypervisor(dataCenterId);	template = _templateDao.findSystemVMReadyTemplate(dataCenterId, availableHypervisor);	if (template == null) {	throw new CloudRuntimeException("Not able to find the System templates or not downloaded in zone " + dataCenterId);	}	Map<String, Object> context = createProxyInstance(dataCenterId, template);	long proxyVmId = (Long)context.get("proxyVmId");	if (proxyVmId == 0) {	if (s_logger.isTraceEnabled()) {	
creating proxy instance failed data center id 

if (s_logger.isTraceEnabled()) {	}	return null;	}	ConsoleProxyVO proxy = _consoleProxyDao.findById(proxyVmId);	if (proxy != null) {	SubscriptionMgr.getInstance().notifySubscribers(ConsoleProxyManager.ALERT_SUBJECT, this, new ConsoleProxyAlertEventArgs(ConsoleProxyAlertEventArgs.PROXY_CREATED, dataCenterId, proxy.getId(), proxy, null));	return proxy;	} else {	if (s_logger.isDebugEnabled()) {	
unable to allocate console proxy storage remove the console proxy record from db proxy id 

ServiceOfferingVO serviceOffering = _serviceOffering;	if (serviceOffering == null) {	serviceOffering = _offeringDao.findDefaultSystemOffering(ServiceOffering.consoleProxyDefaultOffUniqueName, ConfigurationManagerImpl.SystemVMUseLocalStorage.valueIn(dataCenterId));	}	ConsoleProxyVO proxy = new ConsoleProxyVO(id, serviceOffering.getId(), name, template.getId(), template.getHypervisorType(), template.getGuestOSId(), dataCenterId, systemAcct.getDomainId(), systemAcct.getId(), _accountMgr.getSystemUser().getId(), 0, serviceOffering.getOfferHA());	proxy.setDynamicallyScalable(template.isDynamicallyScalable());	proxy = _consoleProxyDao.persist(proxy);	try {	_itMgr.allocate(name, template, serviceOffering, networks, plan, null);	} catch (InsufficientCapacityException e) {	
InsufficientCapacity 

if (answer.getDetails() == null) {	return;	}	ConsoleProxyStatus status = null;	try {	GsonBuilder gb = new GsonBuilder();	gb.setVersion(1.3);	Gson gson = gb.create();	status = gson.fromJson(answer.getDetails(), ConsoleProxyStatus.class);	} catch (Throwable e) {	
unable to parse load info from proxy proxy vm id info 

if (status.getConnections() != null) {	count = status.getConnections().length;	}	byte[] details = null;	if (answer.getDetails() != null) {	details = answer.getDetails().getBytes(Charset.forName("US-ASCII"));	}	_consoleProxyDao.update(answer.getProxyVmId(), count, DateUtil.currentGMTTime(), details);	} else {	if (s_logger.isTraceEnabled()) {	
unable to get console proxy load info id 

public void handleAgentDisconnect(long agentId, com.cloud.host.Status state) {	if (state == com.cloud.host.Status.Alert || state == com.cloud.host.Status.Disconnected) {	HostVO host = _hostDao.findById(agentId);	if (host.getType() == Type.ConsoleProxy) {	String name = host.getName();	if (s_logger.isInfoEnabled()) {	
console proxy agent disconnected proxy 

if (host.getType() == Type.ConsoleProxy) {	String name = host.getName();	if (s_logger.isInfoEnabled()) {	}	if (name != null && name.startsWith("v-")) {	String[] tokens = name.split("-");	long proxyVmId = 0;	try {	proxyVmId = Long.parseLong(tokens[1]);	} catch (NumberFormatException e) {	
unexpected exception 

long proxyVmId = 0;	try {	proxyVmId = Long.parseLong(tokens[1]);	} catch (NumberFormatException e) {	return;	}	final ConsoleProxyVO proxy = _consoleProxyDao.findById(proxyVmId);	if (proxy != null) {	} else {	if (s_logger.isInfoEnabled()) {	
console proxy agent disconnected but corresponding console proxy vm no longer exists in db proxy 

private boolean allowToLaunchNew(long dcId) {	if (!isConsoleProxyVmRequired(dcId)) {	if (s_logger.isDebugEnabled()) {	
console proxy vm not required in zone not launching 

private void allocCapacity(long dataCenterId) {	if (s_logger.isTraceEnabled()) {	
allocate console proxy standby capacity for data center 

private void allocCapacity(long dataCenterId) {	if (s_logger.isTraceEnabled()) {	}	ConsoleProxyVO proxy = null;	String errorString = null;	try {	boolean consoleProxyVmFromStoppedPool = false;	proxy = assignProxyFromStoppedPool(dataCenterId);	if (proxy == null) {	if (s_logger.isInfoEnabled()) {	
no stopped console proxy is available need to allocate a new console proxy 

try {	boolean consoleProxyVmFromStoppedPool = false;	proxy = assignProxyFromStoppedPool(dataCenterId);	if (proxy == null) {	if (s_logger.isInfoEnabled()) {	}	if (_allocProxyLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_SYNC)) {	try {	proxy = startNew(dataCenterId);	} catch (ConcurrentOperationException e) {	
concurrent operation exception caught 

}	if (_allocProxyLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_SYNC)) {	try {	proxy = startNew(dataCenterId);	} catch (ConcurrentOperationException e) {	} finally {	_allocProxyLock.unlock();	}	} else {	if (s_logger.isInfoEnabled()) {	
unable to acquire synchronization lock for console proxy vm allocation wait for next scan 

} catch (ConcurrentOperationException e) {	} finally {	_allocProxyLock.unlock();	}	} else {	if (s_logger.isInfoEnabled()) {	}	}	} else {	if (s_logger.isInfoEnabled()) {	
found a stopped console proxy starting it vm id 

} else {	if (s_logger.isInfoEnabled()) {	}	consoleProxyVmFromStoppedPool = true;	}	if (proxy != null) {	long proxyVmId = proxy.getId();	proxy = startProxy(proxyVmId, false);	if (proxy != null) {	if (s_logger.isInfoEnabled()) {	
console proxy is started 

}	if (proxy != null) {	long proxyVmId = proxy.getId();	proxy = startProxy(proxyVmId, false);	if (proxy != null) {	if (s_logger.isInfoEnabled()) {	}	SubscriptionMgr.getInstance().notifySubscribers(ConsoleProxyManager.ALERT_SUBJECT, this, new ConsoleProxyAlertEventArgs(ConsoleProxyAlertEventArgs.PROXY_UP, dataCenterId, proxy.getId(), proxy, null));	} else {	if (s_logger.isInfoEnabled()) {	
unable to start console proxy vm for standby capacity vm id will recycle it and start a new one 

public boolean isZoneReady(Map<Long, ZoneHostInfo> zoneHostInfoMap, long dataCenterId) {	ZoneHostInfo zoneHostInfo = zoneHostInfoMap.get(dataCenterId);	if (zoneHostInfo != null && isZoneHostReady(zoneHostInfo)) {	VMTemplateVO template = _templateDao.findSystemVMReadyTemplate(dataCenterId, HypervisorType.Any);	if (template == null) {	if (s_logger.isDebugEnabled()) {	
system vm template is not ready at data center wait until it is ready to launch console proxy vm 

boolean useLocalStorage = false;	Boolean useLocal = ConfigurationManagerImpl.SystemVMUseLocalStorage.valueIn(dataCenterId);	if (useLocal != null) {	useLocalStorage = useLocal.booleanValue();	}	List<Pair<Long, Integer>> l = _consoleProxyDao.getDatacenterStoragePoolHostInfo(dataCenterId, useLocalStorage);	if (l != null && l.size() > 0 && l.get(0).second().intValue() > 0) {	return true;	} else {	if (s_logger.isDebugEnabled()) {	
primary storage is not ready wait until it is ready to launch console proxy 

}	List<Pair<Long, Integer>> l = _consoleProxyDao.getDatacenterStoragePoolHostInfo(dataCenterId, useLocalStorage);	if (l != null && l.size() > 0 && l.get(0).second().intValue() > 0) {	return true;	} else {	if (s_logger.isDebugEnabled()) {	}	}	} else {	if (s_logger.isDebugEnabled()) {	
zone host is ready but console proxy template is not ready on secondary storage 

public boolean start() {	if (s_logger.isInfoEnabled()) {	
start console proxy manager 

public boolean stop() {	if (s_logger.isInfoEnabled()) {	
stop console proxy manager 

public boolean stopProxy(long proxyVmId) {	ConsoleProxyVO proxy = _consoleProxyDao.findById(proxyVmId);	if (proxy == null) {	if (s_logger.isDebugEnabled()) {	
stopping console proxy failed console proxy no longer exists 

ConsoleProxyVO proxy = _consoleProxyDao.findById(proxyVmId);	if (proxy == null) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	try {	_itMgr.stop(proxy.getUuid());	return true;	} catch (ResourceUnavailableException e) {	
stopping console proxy failed exception 

if (s_logger.isDebugEnabled()) {	}	return false;	}	try {	_itMgr.stop(proxy.getUuid());	return true;	} catch (ResourceUnavailableException e) {	return false;	} catch (CloudRuntimeException e) {	
unable to stop proxy 

}	if (lastState != state) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	_configDao.update(Config.ConsoleProxyManagementLastState.key(), Config.ConsoleProxyManagementLastState.getCategory(), lastState.toString());	_configDao.update(Config.ConsoleProxyManagementState.key(), Config.ConsoleProxyManagementState.getCategory(), state.toString());	}	});	}	} catch (Throwable e) {	
failed to set managment state 

public ConsoleProxyManagementState getManagementState() {	String value = _configDao.getValue(Config.ConsoleProxyManagementState.key());	if (value != null) {	ConsoleProxyManagementState state = ConsoleProxyManagementState.valueOf(value);	if (state == null) {	
invalid console proxy management state 

public ConsoleProxyManagementState getManagementState() {	String value = _configDao.getValue(Config.ConsoleProxyManagementState.key());	if (value != null) {	ConsoleProxyManagementState state = ConsoleProxyManagementState.valueOf(value);	if (state == null) {	}	return state;	}	
invalid console proxy management state 

try {	ConsoleProxyManagementState state = getManagementState();	ConsoleProxyManagementState lastState = getLastManagementState();	if (lastState == null) {	return;	}	if (lastState != state) {	_configDao.update(Config.ConsoleProxyManagementState.key(), Config.ConsoleProxyManagementState.getCategory(), lastState.toString());	}	} catch (Throwable e) {	
failed to resume last management state 

private ConsoleProxyManagementState getLastManagementState() {	String value = _configDao.getValue(Config.ConsoleProxyManagementLastState.key());	if (value != null) {	ConsoleProxyManagementState state = ConsoleProxyManagementState.valueOf(value);	if (state == null) {	
invalid console proxy management state 

private ConsoleProxyManagementState getLastManagementState() {	String value = _configDao.getValue(Config.ConsoleProxyManagementLastState.key());	if (value != null) {	ConsoleProxyManagementState state = ConsoleProxyManagementState.valueOf(value);	if (state == null) {	}	return state;	}	
invalid console proxy management state 

public boolean rebootProxy(long proxyVmId) {	final ConsoleProxyVO proxy = _consoleProxyDao.findById(proxyVmId);	if (proxy == null || proxy.getState() == State.Destroyed) {	return false;	}	if (proxy.getState() == State.Running && proxy.getHostId() != null) {	final RebootCommand cmd = new RebootCommand(proxy.getInstanceName(), _itMgr.getExecuteInSequence(proxy.getHypervisorType()));	final Answer answer = _agentMgr.easySend(proxy.getHostId(), cmd);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	
successfully reboot console proxy 

if (proxy.getState() == State.Running && proxy.getHostId() != null) {	final RebootCommand cmd = new RebootCommand(proxy.getInstanceName(), _itMgr.getExecuteInSequence(proxy.getHypervisorType()));	final Answer answer = _agentMgr.easySend(proxy.getHostId(), cmd);	if (answer != null && answer.getResult()) {	if (s_logger.isDebugEnabled()) {	}	SubscriptionMgr.getInstance().notifySubscribers(ConsoleProxyManager.ALERT_SUBJECT, this, new ConsoleProxyAlertEventArgs(ConsoleProxyAlertEventArgs.PROXY_REBOOTED, proxy.getDataCenterId(), proxy.getId(), proxy, null));	return true;	} else {	if (s_logger.isDebugEnabled()) {	
failed to reboot console proxy 

proxy.setPrivateIpAddress(null);	_consoleProxyDao.update(proxy.getId(), proxy);	_consoleProxyDao.remove(vmId);	HostVO host = _hostDao.findByTypeNameAndZoneId(proxy.getDataCenterId(), proxy.getHostName(), Host.Type.ConsoleProxy);	if (host != null) {	s_logger.debug("Removing host entry for proxy id=" + vmId);	return _hostDao.remove(host.getId());	}	return true;	} catch (ResourceUnavailableException e) {	
unable to expunge 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (s_logger.isInfoEnabled()) {	
start configuring console proxy manager 

if (s_logger.isInfoEnabled()) {	}	Map<String, String> configs = _configDao.getConfiguration("management-server", params);	String value = configs.get(Config.ConsoleProxyCmdPort.key());	value = configs.get("consoleproxy.sslEnabled");	if (value != null && value.equalsIgnoreCase("true")) {	_sslEnabled = true;	}	_consoleProxyUrlDomain = configs.get(Config.ConsoleProxyUrlDomain.key());	if( _sslEnabled && (_consoleProxyUrlDomain == null || _consoleProxyUrlDomain.isEmpty())) {	
empty console proxy domain explicitly disabling ssl 

}	value = configs.get(Config.ConsoleProxyDisableRpFilter.key());	if (value != null && value.equalsIgnoreCase("true")) {	_disableRpFilter = true;	}	value = configs.get("secondary.storage.vm");	if (value != null && value.equalsIgnoreCase("true")) {	_useStorageVm = true;	}	if (s_logger.isInfoEnabled()) {	
console proxy max session soft limit 

}	value = configs.get(Config.ConsoleProxyDisableRpFilter.key());	if (value != null && value.equalsIgnoreCase("true")) {	_disableRpFilter = true;	}	value = configs.get("secondary.storage.vm");	if (value != null && value.equalsIgnoreCase("true")) {	_useStorageVm = true;	}	if (s_logger.isInfoEnabled()) {	
console proxy standby capacity 

}	}	_loadScanner = new SystemVmLoadScanner<Long>(this);	_loadScanner.initScan(STARTUP_DELAY, _capacityScanInterval);	_resourceMgr.registerResourceStateAdapter(this.getClass().getSimpleName(), this);	_staticPublicIp = _configDao.getValue("consoleproxy.static.publicIp");	if (_staticPublicIp != null) {	_staticPort = NumbersUtil.parseInt(_configDao.getValue("consoleproxy.static.port"), 8443);	}	if (s_logger.isInfoEnabled()) {	
console proxy manager is configured 

buf.append(" internaldns1=").append(dc.getInternalDns1());	if (dc.getInternalDns2() != null) {	buf.append(" internaldns2=").append(dc.getInternalDns2());	}	buf.append(" dns1=").append(dc.getDns1());	if (dc.getDns2() != null) {	buf.append(" dns2=").append(dc.getDns2());	}	String bootArgs = buf.toString();	if (s_logger.isDebugEnabled()) {	
boot args for 

NicProfile controlNic = null;	for (NicProfile nic : profile.getNics()) {	if (nic.getTrafficType() == TrafficType.Management) {	managementNic = nic;	} else if (nic.getTrafficType() == TrafficType.Control && nic.getIPv4Address() != null) {	controlNic = nic;	}	}	if (controlNic == null) {	if (managementNic == null) {	
management network doesn t exist for the console proxy vm 

public boolean finalizeStart(VirtualMachineProfile profile, long hostId, Commands cmds, ReservationContext context) {	CheckSshAnswer answer = (CheckSshAnswer)cmds.getAnswer("checkSsh");	if (answer == null || !answer.getResult()) {	if (answer != null) {	
unable to ssh to the vm 

public boolean finalizeStart(VirtualMachineProfile profile, long hostId, Commands cmds, ReservationContext context) {	CheckSshAnswer answer = (CheckSshAnswer)cmds.getAnswer("checkSsh");	if (answer == null || !answer.getResult()) {	if (answer != null) {	} else {	
unable to ssh to the vm null answer 

}	try {	_rulesMgr.getSystemIpAndEnableStaticNatForVm(profile.getVirtualMachine(), false);	IPAddressVO ipaddr = _ipAddressDao.findByAssociatedVmId(profile.getVirtualMachine().getId());	if (ipaddr != null && ipaddr.getSystem()) {	ConsoleProxyVO consoleVm = _consoleProxyDao.findById(profile.getId());	consoleVm.setPublicIpAddress(ipaddr.getAddress().addr());	_consoleProxyDao.update(consoleVm.getId(), consoleVm);	}	} catch (Exception ex) {	
failed to get system ip and enable static nat for the vm due to exception 

public void finalizeStop(VirtualMachineProfile profile, Answer answer) {	IPAddressVO ip = _ipAddressDao.findByAssociatedVmId(profile.getId());	if (ip != null && ip.getSystem()) {	CallContext ctx = CallContext.current();	try {	_rulesMgr.disableStaticNat(ip.getId(), ctx.getCallingAccount(), ctx.getCallingUserId(), true);	} catch (Exception ex) {	
failed to disable static nat and release system ip as a part of vm stop due to exception 

private void handleResetSuspending() {	List<ConsoleProxyVO> runningProxies = _consoleProxyDao.getProxyListInStates(State.Running);	for (ConsoleProxyVO proxy : runningProxies) {	
stop console proxy because of we are currently in resetsuspending management mode 

private void handleResetSuspending() {	List<ConsoleProxyVO> runningProxies = _consoleProxyDao.getProxyListInStates(State.Running);	for (ConsoleProxyVO proxy : runningProxies) {	stopProxy(proxy.getId());	}	List<ConsoleProxyVO> proxiesInTransition = _consoleProxyDao.getProxyListInStates(State.Running, State.Starting, State.Stopping);	if (proxiesInTransition.size() == 0) {	
all previous console proxy vms in transition mode ceased the mode we will now resume to last management state 

public boolean canScan() {	scanManagementState();	if (!reserveStandbyCapacity()) {	if (s_logger.isDebugEnabled()) {	
reserving standby capacity is disabled skip capacity scan 

public boolean canScan() {	scanManagementState();	if (!reserveStandbyCapacity()) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	List<StoragePoolVO> upPools = _storagePoolDao.listByStatus(StoragePoolStatus.Up);	if (upPools == null || upPools.size() == 0) {	
skip capacity scan as there is no primary storage in up state 

public boolean isPoolReadyForScan(Long pool) {	long dataCenterId = pool.longValue();	if (!isZoneReady(_zoneHostInfoMap, dataCenterId)) {	if (s_logger.isDebugEnabled()) {	
zone is not ready to launch console proxy yet 

public boolean isPoolReadyForScan(Long pool) {	long dataCenterId = pool.longValue();	if (!isZoneReady(_zoneHostInfoMap, dataCenterId)) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	List<ConsoleProxyVO> l = _consoleProxyDao.getProxyListInStates(VirtualMachine.State.Starting, VirtualMachine.State.Stopping);	if (l.size() > 0) {	if (s_logger.isDebugEnabled()) {	
zone has console proxy vm s in transition state 

}	return false;	}	List<ConsoleProxyVO> l = _consoleProxyDao.getProxyListInStates(VirtualMachine.State.Starting, VirtualMachine.State.Stopping);	if (l.size() > 0) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	if (s_logger.isDebugEnabled()) {	
zone is ready to launch console proxy 

ConsoleProxyLoadInfo proxyInfo = _zoneProxyCountMap.get(dataCenterId);	if (proxyInfo == null) {	return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);	}	ConsoleProxyLoadInfo vmInfo = _zoneVmCountMap.get(dataCenterId);	if (vmInfo == null) {	vmInfo = new ConsoleProxyLoadInfo();	}	if (!checkCapacity(proxyInfo, vmInfo)) {	if (s_logger.isDebugEnabled()) {	
expand console proxy standby capacity for zone 

========================= cloudstack sample_2481 =========================

public Answer execute(final OvsDestroyBridgeCommand command, final CitrixResourceBase citrixResourceBase) {	try {	final Connection conn = citrixResourceBase.getConnection();	final Network nw = citrixResourceBase.findOrCreateTunnelNetwork(conn, command.getBridgeName());	citrixResourceBase.cleanUpTmpDomVif(conn, nw);	citrixResourceBase.destroyTunnelNetwork(conn, nw, command.getHostId());	
ovs bridge destroyed 

public Answer execute(final OvsDestroyBridgeCommand command, final CitrixResourceBase citrixResourceBase) {	try {	final Connection conn = citrixResourceBase.getConnection();	final Network nw = citrixResourceBase.findOrCreateTunnelNetwork(conn, command.getBridgeName());	citrixResourceBase.cleanUpTmpDomVif(conn, nw);	citrixResourceBase.destroyTunnelNetwork(conn, nw, command.getHostId());	return new Answer(command, true, null);	} catch (final Exception e) {	
caught execption when destroying ovs bridge 

========================= cloudstack sample_1184 =========================

ApiConnector api = controller.getApiAccessor();	_serviceInstance = siObj;	_fqName = StringUtils.join(siObj.getQualifiedName(), ':');	ServiceInstanceType props = siObj.getProperties();	ObjectReference ref = siObj.getServiceTemplate().get(0);	if (ref != null) {	try {	ServiceTemplate tmpl = (ServiceTemplate)api.findById(ServiceTemplate.class, ref.getUuid());	_templateId = tmpl.getUuid();	} catch (IOException ex) {	
service template read 

private ServiceInstance createServiceInstance(ModelController controller) {	Project project = null;	if (_projectId != null) {	try {	ApiConnector api = controller.getApiAccessor();	project = (Project)api.findById(Project.class, _projectId);	} catch (IOException ex) {	
project read 

if (project != null) {	si_obj.setParent(project);	}	si_obj.setName(getName());	si_obj.setServiceTemplate(_tmpl);	si_obj.setProperties(new ServiceInstanceType(false, _mgmtName, _leftName, null, _rightName, null, new ServiceInstanceType.ServiceScaleOutType(1, false)));	try {	ApiConnector api = controller.getApiAccessor();	api.create(si_obj);	} catch (IOException ex) {	
service instance create 

controller.getManager().getDatabase().getNetworkPolicys().remove(_policy);	_policy.delete(controller.getManager().getModelController());	_policy = null;	} catch (Exception e) {	s_logger.error(e);	}	try {	_left.update(controller.getManager().getModelController());	_right.update(controller.getManager().getModelController());	} catch (Exception ex) {	
virtual network update for policy delete 

} catch (Exception e) {	s_logger.error(e);	return null;	}	try {	if (!policyModel.verify(controller.getManager().getModelController())) {	policyModel.update(controller.getManager().getModelController());	}	controller.getManager().getDatabase().getNetworkPolicys().add(policyModel);	} catch (Exception ex) {	
network policy update 

private ServiceTemplate locateServiceTemplate(ModelController controller) {	ServiceTemplate tmpl;	try {	ApiConnector api = controller.getApiAccessor();	tmpl = (ServiceTemplate)api.findById(ServiceTemplate.class, _templateId);	} catch (IOException ex) {	
service template read 

========================= cloudstack sample_1887 =========================

public DataStore getCacheStore(Scope scope) {	if (scope.getScopeType() != ScopeType.ZONE) {	
can only support zone wide cache storage 

public DataStore getCacheStore(Scope scope) {	if (scope.getScopeType() != ScopeType.ZONE) {	return null;	}	List<DataStore> cacheStores = dataStoreMgr.getImageCacheStores(scope);	if ((cacheStores == null) || (cacheStores.size() <= 0)) {	
can t find staging storage in zone 

public DataStore getCacheStore(DataObject data, Scope scope) {	if (scope.getScopeType() != ScopeType.ZONE) {	
can only support zone wide cache storage 

public DataStore getCacheStore(DataObject data, Scope scope) {	if (scope.getScopeType() != ScopeType.ZONE) {	return null;	}	List<DataStore> cacheStores = dataStoreMgr.getImageCacheStores(scope);	if (cacheStores.size() <= 0) {	
can t find staging storage in zone 

return null;	}	List<DataStore> cacheStores = dataStoreMgr.getImageCacheStores(scope);	if (cacheStores.size() <= 0) {	return null;	}	if (cacheStores.size() > 1) {	for (DataStore store : cacheStores) {	DataObjectInStore obj = objectInStoreMgr.findObject(data, store);	if (obj != null && obj.getState() == ObjectInDataStoreStateMachine.State.Ready && statsCollector.imageStoreHasEnoughCapacity(store)) {	
pick the cache store where data is already there 

========================= cloudstack sample_3910 =========================

public void handleData(ByteBuffer buf, Link link) {	
info data received 

case DataBuffer.TYPE_INT: {	int[] intArray = buf.toIntLEArray();	DataBufferInt dataBuffer = (DataBufferInt)dataBuf;	int imageWidth = image.getWidth();	int imageHeight = image.getHeight();	int[] imageBuffer = dataBuffer.getData();	for (int srcLine = 0, dstLine = y; srcLine < rectHeight && dstLine < imageHeight; srcLine++, dstLine++) {	try {	System.arraycopy(intArray, srcLine * rectWidth, imageBuffer, x + dstLine * imageWidth, rectWidth);	} catch (IndexOutOfBoundsException e) {	
ignored copy error 

int[] pixelsLE = new int[] {0x04030201, 0x08070605, 0x0c0b0a09, 0x100f0e0d, 0x04030201, 0x08070605, 0x0c0b0a09, 0x100f0e0d, 0x04030201, 0x08070605, 0x0c0b0a09, 0x100f0e0d, 0x04030201, 0x08070605, 0x0c0b0a09, 0x100f0e0d};	ByteBuffer buf = new ByteBuffer(pixels);	buf.putMetadata(TARGET_X, 0);	buf.putMetadata(TARGET_Y, 0);	buf.putMetadata(WIDTH, 4);	buf.putMetadata(HEIGHT, 4);	buf.putMetadata(PIXEL_FORMAT, RGB888LE32);	renderer.handleData(buf, null);	String actualData = Arrays.toString(((DataBufferInt)canvas.getOfflineImage().getRaster().getDataBuffer()).getData());	String expectedData = Arrays.toString(pixelsLE);	
actual image expected image 

========================= cloudstack sample_5128 =========================

public short syncAll(short syncMode) {	short syncState = SYNC_STATE_IN_SYNC;	
syncing cloudstack db with vnc 

public short syncAll(short syncMode) {	short syncState = SYNC_STATE_IN_SYNC;	try {	for (Class<?> cls : _vncClasses) {	_lockSyncMode.lock();	_rwMode = syncMode == DBSyncGeneric.SYNC_MODE_UPDATE;	_dbSync.setSyncMode(syncMode);	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	
sync check start 

public short syncAll(short syncMode) {	short syncState = SYNC_STATE_IN_SYNC;	try {	for (Class<?> cls : _vncClasses) {	_lockSyncMode.lock();	_rwMode = syncMode == DBSyncGeneric.SYNC_MODE_UPDATE;	_dbSync.setSyncMode(syncMode);	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	
sync start 

try {	for (Class<?> cls : _vncClasses) {	_lockSyncMode.lock();	_rwMode = syncMode == DBSyncGeneric.SYNC_MODE_UPDATE;	_dbSync.setSyncMode(syncMode);	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	}	if (_dbSync.sync(cls) == false) {	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	
out of sync detected 

for (Class<?> cls : _vncClasses) {	_lockSyncMode.lock();	_rwMode = syncMode == DBSyncGeneric.SYNC_MODE_UPDATE;	_dbSync.setSyncMode(syncMode);	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	}	if (_dbSync.sync(cls) == false) {	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	
out of sync detected and re synced 

if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	}	if (_dbSync.sync(cls) == false) {	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	}	syncState = SYNC_STATE_OUT_OF_SYNC;	}	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	
sync check finish 

} else {	}	if (_dbSync.sync(cls) == false) {	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	}	syncState = SYNC_STATE_OUT_OF_SYNC;	}	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	
sync finish 

} else {	}	syncState = SYNC_STATE_OUT_OF_SYNC;	}	if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {	} else {	}	_lockSyncMode.unlock();	}	} catch (Exception ex) {	
db synchronization 

public void syncClass(Class<?> cls) {	
syncclass 

public void syncClass(Class<?> cls) {	try {	
sync start 

public void syncClass(Class<?> cls) {	try {	_lockSyncMode.lock();	_dbSync.setSyncMode(DBSyncGeneric.SYNC_MODE_UPDATE);	_dbSync.sync(cls);	_lockSyncMode.unlock();	
sync finish 

public void syncClass(Class<?> cls) {	try {	_lockSyncMode.lock();	_dbSync.setSyncMode(DBSyncGeneric.SYNC_MODE_UPDATE);	_dbSync.sync(cls);	_lockSyncMode.unlock();	} catch (Exception ex) {	
sync error 

public boolean syncDomain() throws Exception {	final ApiConnector api = _manager.getApiConnector();	try {	List<?> dbList = _domainDao.listAll();	List<?> vncList = api.list(net.juniper.contrail.api.types.Domain.class, null);	return _dbSync.syncGeneric(net.juniper.contrail.api.types.Domain.class, dbList, vncList);	} catch (Exception ex) {	
syncDomain 

public boolean syncProject() throws Exception {	final ApiConnector api = _manager.getApiConnector();	try {	List<?> dbList = _projectDao.listAll();	List<?> vncList = api.list(net.juniper.contrail.api.types.Project.class, null);	return _dbSync.syncGeneric(net.juniper.contrail.api.types.Project.class, dbList, vncList);	} catch (Exception ex) {	
syncProject 

types.add(TrafficType.Public);	types.add(TrafficType.Guest);	List<NetworkVO> dbNets = _manager.findManagedNetworks(types);	List<VirtualNetwork> vList = (List<VirtualNetwork>)api.list(VirtualNetwork.class, null);	List<VirtualNetwork> vncList = new ArrayList<VirtualNetwork>();	for (VirtualNetwork vn : vList) {	if (!_manager.isSystemDefaultNetwork(vn)) {	vncList.add(vn);	}	}	
sync vn db size vnc size 

List<NetworkVO> dbNets = _manager.findManagedNetworks(types);	List<VirtualNetwork> vList = (List<VirtualNetwork>)api.list(VirtualNetwork.class, null);	List<VirtualNetwork> vncList = new ArrayList<VirtualNetwork>();	for (VirtualNetwork vn : vList) {	if (!_manager.isSystemDefaultNetwork(vn)) {	vncList.add(vn);	}	}	return _dbSync.syncGeneric(VirtualNetwork.class, dbNets, vncList);	} catch (Exception ex) {	
sync virtual networks 

public boolean syncVirtualMachine() {	final ApiConnector api = _manager.getApiConnector();	try {	List<VMInstanceVO> vmDbList = _vmInstanceDao.listAll();	List<VirtualMachine> vncVmList = (List<VirtualMachine>)api.list(VirtualMachine.class, null);	
sync vm cs size vnc size 

public boolean syncVirtualMachine() {	final ApiConnector api = _manager.getApiConnector();	try {	List<VMInstanceVO> vmDbList = _vmInstanceDao.listAll();	List<VirtualMachine> vncVmList = (List<VirtualMachine>)api.list(VirtualMachine.class, null);	return _dbSync.syncGeneric(VirtualMachine.class, vmDbList, vncVmList);	} catch (Exception ex) {	
sync virtual machines 

if (ipList == null) {	ipList = new ArrayList<IPAddressVO>();	}	if (vncList == null) {	vncList = new ArrayList<FloatingIp>();	}	boolean status = false;	try {	status = _dbSync.syncGeneric(FloatingIp.class, ipList, vncList);	} catch (Exception ex) {	
sync floating ips 

if (dbAcls == null) {	dbAcls = new ArrayList<NetworkACLVO>();	}	List<NetworkPolicy> pList = (List<NetworkPolicy>) api.list(NetworkPolicy.class, null);	List<NetworkPolicy> vncList = new ArrayList<NetworkPolicy>();	for (NetworkPolicy policy:pList) {	if (!_manager.isSystemDefaultNetworkPolicy(policy)) {	vncList.add(policy);	}	}	
sync network policy db size vnc size 

}	List<NetworkPolicy> pList = (List<NetworkPolicy>) api.list(NetworkPolicy.class, null);	List<NetworkPolicy> vncList = new ArrayList<NetworkPolicy>();	for (NetworkPolicy policy:pList) {	if (!_manager.isSystemDefaultNetworkPolicy(policy)) {	vncList.add(policy);	}	}	return _dbSync.syncGeneric(NetworkPolicy.class, dbAcls, vncList);	} catch (Exception ex) {	
sync network policys 

public boolean syncServiceInstance() {	final ApiConnector api = _manager.getApiConnector();	boolean inSync;	try {	List<ServiceInstance> siList = (List<ServiceInstance>)api.list(ServiceInstance.class, null);	java.util.Collections.sort(siList, new ServiceInstanceComparator());	DBSyncGeneric.SyncStats stats = new DBSyncGeneric.SyncStats();	_dbSync.syncCollections(ServiceInstance.class, _manager.getDatabase().getServiceInstances(), siList, _rwMode, stats);	inSync = stats.create == 0 && stats.delete == 0;	} catch (Exception ex) {	
synchronize service instances 

========================= cloudstack sample_1868 =========================

public String stopVM(String vmName, boolean force) {	
stop vm name 

public String rebootVM(String vmName) {	
reboot vm name 

public boolean migrate(String vmName, String params) {	
migrate vm name 

public MockVm createVmFromSpec(VirtualMachineTO vmSpec) {	String vmName = vmSpec.getName();	long ramSize = vmSpec.getMinRam();	int utilizationPercent = randSeed.nextInt() % 100;	MockVm vm = null;	synchronized (this) {	vm = vms.get(vmName);	if (vm == null) {	if (ramSize > getHostFreeMemory()) {	
host is out of memory 

int utilizationPercent = randSeed.nextInt() % 100;	MockVm vm = null;	synchronized (this) {	vm = vms.get(vmName);	if (vm == null) {	if (ramSize > getHostFreeMemory()) {	throw new CloudRuntimeException("Host is out of Memory");	}	int vncPort = allocVncPort();	if (vncPort < 0) {	
unable to allocate vnc port 

========================= cloudstack sample_2881 =========================

public void testNewCPVMCreation() throws Exception {	
running test for new cpvm creation 

public void testExistingCPVMStart() throws Exception {	
running test for existing cpvm start 

public void testExisingCPVMStartFailure() throws Exception {	
running test for existing cpvm start failure 

========================= cloudstack sample_2182 =========================

public synchronized int putImage(byte[] image) {	while (cache.size() >= cacheSize) {	Integer keyToRemove = fifoQueue.remove(0);	cache.remove(keyToRemove);	
remove image from cache key 

public synchronized int putImage(byte[] image) {	while (cache.size() >= cacheSize) {	Integer keyToRemove = fifoQueue.remove(0);	cache.remove(keyToRemove);	}	int key = getNextKey();	
add image to cache key 

public synchronized byte[] getImage(int key) {	if (key == 0) {	key = nextKey;	}	if (cache.containsKey(key)) {	
retrieve image from cache key 

public synchronized byte[] getImage(int key) {	if (key == 0) {	key = nextKey;	}	if (cache.containsKey(key)) {	return cache.get(key);	}	
image is no long in cache key 

========================= cloudstack sample_4955 =========================

}	if (object == null) {	return;	}	while (object != null) {	object.delete();	object = cacheReplacementAlgorithm.chooseOneToBeReplaced(findAStore);	}	}	} catch (Exception e) {	
failed to execute cachereplacementrunner 

} else if (type == DataObjectType.VOLUME) {	lock = volumeLock;	typeName = "volume";	} else if (type == DataObjectType.SNAPSHOT) {	lock = snapshotLock;	typeName = "snapshot";	} else {	String msg = "unsupported DataObject comes, then can't acquire correct lock object";	throw new CloudRuntimeException(msg);	}	
check cache entry id on store id 

DataObjectInStore obj = objectInStoreMgr.findObject(data, store);	if (obj != null) {	State st = obj.getState();	long miliSeconds = 10000;	long timeoutSeconds = 3600;	long timeoutMiliSeconds = timeoutSeconds * 1000;	Date now = new Date();	long expiredEpoch = now.getTime() + timeoutMiliSeconds;	Date expiredDate = new Date(expiredEpoch);	while (st == ObjectInDataStoreStateMachine.State.Allocated || st == ObjectInDataStoreStateMachine.State.Creating || st == ObjectInDataStoreStateMachine.State.Copying) {	
waiting cache copy completion type id lock 

long miliSeconds = 10000;	long timeoutSeconds = 3600;	long timeoutMiliSeconds = timeoutSeconds * 1000;	Date now = new Date();	long expiredEpoch = now.getTime() + timeoutMiliSeconds;	Date expiredDate = new Date(expiredEpoch);	while (st == ObjectInDataStoreStateMachine.State.Allocated || st == ObjectInDataStoreStateMachine.State.Creating || st == ObjectInDataStoreStateMachine.State.Copying) {	try {	lock.wait(miliSeconds);	} catch (InterruptedException e) {	
ignored interupted while waiting for cache copy completion 

long timeoutSeconds = 3600;	long timeoutMiliSeconds = timeoutSeconds * 1000;	Date now = new Date();	long expiredEpoch = now.getTime() + timeoutMiliSeconds;	Date expiredDate = new Date(expiredEpoch);	while (st == ObjectInDataStoreStateMachine.State.Allocated || st == ObjectInDataStoreStateMachine.State.Creating || st == ObjectInDataStoreStateMachine.State.Copying) {	try {	lock.wait(miliSeconds);	} catch (InterruptedException e) {	}	
waken up 

}	now = new Date();	if (now.after(expiredDate)) {	String msg = "Waiting time exceeds timeout limit(" + timeoutSeconds + " s)";	throw new CloudRuntimeException(msg);	}	obj = objectInStoreMgr.findObject(data, store);	st = obj.getState();	}	if (st == ObjectInDataStoreStateMachine.State.Ready) {	
there is already one in the cache store 

obj = objectInStoreMgr.findObject(data, store);	st = obj.getState();	}	if (st == ObjectInDataStoreStateMachine.State.Ready) {	DataObject dataObj = objectInStoreMgr.get(data, store);	dataObj.incRefCount();	existingDataObj = dataObj;	}	}	if(existingDataObj == null) {	
create cache entry id on store id 

}	if(existingDataObj == null) {	objOnCacheStore = store.create(data);	}	lock.notifyAll();	}	if (existingDataObj != null) {	return existingDataObj;	}	if (objOnCacheStore == null) {	
create cache entry id on store id failed 

dataMotionSvr.copyAsync(data, objOnCacheStore, future);	result = future.get();	if (result.isFailed()) {	objOnCacheStore.processEvent(Event.OperationFailed);	} else {	objOnCacheStore.processEvent(Event.OperationSuccessed, result.getAnswer());	objOnCacheStore.incRefCount();	return objOnCacheStore;	}	} catch (InterruptedException e) {	
create cache storage failed 

if (result.isFailed()) {	objOnCacheStore.processEvent(Event.OperationFailed);	} else {	objOnCacheStore.processEvent(Event.OperationSuccessed, result.getAnswer());	objOnCacheStore.incRefCount();	return objOnCacheStore;	}	} catch (InterruptedException e) {	throw new CloudRuntimeException(e);	} catch (ExecutionException e) {	
create cache storage failed 

}	} catch (InterruptedException e) {	throw new CloudRuntimeException(e);	} catch (ExecutionException e) {	throw new CloudRuntimeException(e);	} finally {	if (result == null) {	objOnCacheStore.processEvent(Event.OperationFailed);	}	synchronized (lock) {	
wake up all waiting threads lock 

========================= cloudstack sample_3906 =========================

public Answer execute(final CheckNetworkCommand command, final CitrixResourceBase citrixResourceBase) {	if (s_logger.isDebugEnabled()) {	
checking if network name setup is done on the resource 

========================= cloudstack sample_1192 =========================

public void execute() {	CallContext.current().setEventDetails("AutoScale Policy Id: " + getId());	boolean result = _autoScaleService.deleteAutoScalePolicy(id);	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	
failed to delete autoscale policy 

========================= cloudstack sample_3455 =========================

VspNetwork vspNetwork = _nuageVspEntityBuilder.buildVspNetwork(implemented, true);	String tenantId = context.getDomain().getName() + "-" + context.getAccount().getAccountId();	String broadcastUriStr = implemented.getUuid() + "/" + vspNetwork.getVirtualRouterIp();	implemented.setBroadcastUri(Networks.BroadcastDomainType.Vsp.toUri(broadcastUriStr));	implemented.setBroadcastDomainType(Networks.BroadcastDomainType.Vsp);	HostVO nuageVspHost = getNuageVspHost(physicalNetworkId);	List<String> dnsServers = _nuageVspManager.getDnsDetails(network);	ImplementNetworkVspCommand cmd = new ImplementNetworkVspCommand(vspNetwork, dnsServers);	Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
implementnetworkvspcommand for network failed on nuage vsd hostname 

}	if (StringUtils.isNotBlank(vspNetwork.getDomainTemplateName())) {	if (network.getVpcId() != null) {	VpcDetailVO vpcDetail = new VpcDetailVO(network.getVpcId(), NuageVspManager.nuageDomainTemplateDetailName, vspNetwork.getDomainTemplateName(), false);	_vpcDetailsDao.persist(vpcDetail);	} else {	NetworkDetailVO networkDetail = new NetworkDetailVO(implemented.getId(), NuageVspManager.nuageDomainTemplateDetailName, vspNetwork.getDomainTemplateName(), false);	_networkDetailsDao.persist(networkDetail);	}	}	
implemented ok network in tenant linked to 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException {	boolean lockedNetwork = lockNetworkForUserVm(network, vm);	if (lockedNetwork && s_logger.isDebugEnabled()) {	
locked network for creation of user vm 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException {	boolean lockedNetwork = lockNetworkForUserVm(network, vm);	if (lockedNetwork && s_logger.isDebugEnabled()) {	}	try {	if (s_logger.isDebugEnabled()) {	
handling reserve call back to with create a new vm or add an interface to existing vm in network 

VspNic vspNic = _nuageVspEntityBuilder.buildVspNic(nicFromDb.getUuid(), nic);	VspStaticNat vspStaticNat = null;	if (staticNatIp != null) {	VlanVO staticNatVlan = _vlanDao.findById(staticNatIp.getVlanId());	vspStaticNat = _nuageVspEntityBuilder.buildVspStaticNat(null, staticNatIp, staticNatVlan, vspNic);	}	HostVO nuageVspHost = getNuageVspHost(network.getPhysicalNetworkId());	ReserveVmInterfaceVspCommand cmd = new ReserveVmInterfaceVspCommand(vspNetwork, vspVm, vspNic, vspStaticNat);	Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
reservevminterfacenuagevspcommand failed for nic attached to vm in network 

}	throw new InsufficientVirtualNetworkCapacityException("Failed to reserve VM in Nuage VSP.", Network.class, network.getId());	}	if (vspVm.getDomainRouter() == Boolean.TRUE) {	nic.setIPv4Address(vspVm.getDomainRouterIp());	}	} finally {	if (network != null && lockedNetwork) {	_networkDao.releaseFromLockTable(network.getId());	if (s_logger.isDebugEnabled()) {	
unlocked network for creation of user vm 

protected boolean canHandle(NetworkOffering offering, final NetworkType networkType, final PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && (offering.getGuestType() == Network.GuestType.Isolated || offering.getGuestType() == Network.GuestType.Shared) && isMyIsolationMethod(physicalNetwork)) {	if (_configMgr.isOfferingForVpc(offering) && !offering.getIsPersistent()) {	if (s_logger.isDebugEnabled()) {	
nuagevsp can t handle vpc tiers which use a network offering which are not persistent 

protected boolean canHandle(NetworkOffering offering, final NetworkType networkType, final PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && (offering.getGuestType() == Network.GuestType.Isolated || offering.getGuestType() == Network.GuestType.Shared) && isMyIsolationMethod(physicalNetwork)) {	if (_configMgr.isOfferingForVpc(offering) && !offering.getIsPersistent()) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	return true;	} else {	if (s_logger.isTraceEnabled()) {	
we only take care of guest networks of type in zone of type 

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	boolean lockedNetwork = lockNetworkForUserVm(network, vm);	if (lockedNetwork && s_logger.isDebugEnabled()) {	
locked network for deallocation of user vm 

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	boolean lockedNetwork = lockNetworkForUserVm(network, vm);	if (lockedNetwork && s_logger.isDebugEnabled()) {	}	try {	if (s_logger.isDebugEnabled()) {	
handling deallocate call back which is called when a vm is destroyed or interface is removed to delete vm interface with ip from a vm with state 

if (s_logger.isDebugEnabled()) {	}	NicVO nicFromDb = _nicDao.findById(nic.getId());	VspNetwork vspNetwork = _nuageVspEntityBuilder.buildVspNetwork(network, false);	VspVm vspVm = _nuageVspEntityBuilder.buildVspVm(vm.getVirtualMachine(), network);	VspNic vspNic = _nuageVspEntityBuilder.buildVspNic(nicFromDb.getUuid(), nic);	HostVO nuageVspHost = getNuageVspHost(network.getPhysicalNetworkId());	DeallocateVmVspCommand cmd = new DeallocateVmVspCommand(vspNetwork, vspVm, vspNic);	Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
deallocatevmnuagevspcommand for vm failed on nuage vsd hostname 

Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	if ((null != answer) && (null != answer.getDetails())) {	s_logger.error(answer.getDetails());	}	}	} finally {	if (network != null && lockedNetwork) {	_networkDao.releaseFromLockTable(network.getId());	if (s_logger.isDebugEnabled()) {	
unlocked network for deallocation of user vm 

public boolean trash(Network network, NetworkOffering offering) {	long networkId = network.getId();	network = _networkDao.acquireInLockTable(networkId, 1200);	if (network == null) {	throw new ConcurrentOperationException("Unable to acquire lock on network " + networkId);	}	try {	if (s_logger.isDebugEnabled()) {	
handling trash call back to delete the network with uuid from vsp 

throw new ConcurrentOperationException("Unable to acquire lock on network " + networkId);	}	try {	if (s_logger.isDebugEnabled()) {	}	VspNetwork vspNetwork = _nuageVspEntityBuilder.buildVspNetwork(network, false);	HostVO nuageVspHost = getNuageVspHost(network.getPhysicalNetworkId());	TrashNetworkVspCommand cmd = new TrashNetworkVspCommand(vspNetwork);	Answer answer = _agentMgr.easySend(nuageVspHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
trashnetworknuagevspcommand for network failed 

========================= cloudstack sample_1487 =========================

public void shutdown() {	if (shutdown) return;	shutdown = true;	try {	handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	
ignored handling stream close event failed on input 

public void shutdown() {	if (shutdown) return;	shutdown = true;	try {	handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	}	try {	handleEvent(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	
ignored handling event close event failed on output 

========================= cloudstack sample_5094 =========================

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	_configs = _configDao.getConfiguration("management-server", params);	if (s_logger.isInfoEnabled()) {	
configuring lbhealthcheck manager s 

public boolean start() {	
lb healthcheckmanager is getting started 

public boolean stop() {	
healthcheckmanager is getting stopped 

protected void runInContext() {	try {	updateLBHealthCheck(Scheme.Public);	updateLBHealthCheck(Scheme.Internal);	} catch (Exception e) {	
exception in lb healthcheck update checker 

public void updateLBHealthCheck(Scheme scheme) {	try {	_lbService.updateLBHealthChecks(scheme);	} catch (ResourceUnavailableException e) {	
error while updating the lb healtcheck 

public void updateLBHealthCheck(Scheme scheme) {	try {	_lbService.updateLBHealthChecks(scheme);	} catch (ResourceUnavailableException e) {	}	
lb healthcheck manager is running and getting the updates from lb providers and updating service status 

========================= cloudstack sample_2301 =========================

protected DataObject waitingForCreated(DataObject dataObj, DataStore dataStore) {	long retries = this.waitingRetries;	DataObjectInStore obj = null;	do {	try {	Thread.sleep(waitingTime);	} catch (InterruptedException e) {	
sleep interrupted 

long retries = this.waitingRetries;	DataObjectInStore obj = null;	do {	try {	Thread.sleep(waitingTime);	} catch (InterruptedException e) {	throw new CloudRuntimeException("sleep interrupted", e);	}	obj = objectInDataStoreMgr.findObject(dataObj, dataStore);	if (obj == null) {	
can t find object in db maybe it s cleaned up already exit waiting 

obj = objectInDataStoreMgr.findObject(dataObj, dataStore);	if (obj == null) {	break;	}	if (obj.getState() == ObjectInDataStoreStateMachine.State.Ready) {	break;	}	retries--;	} while (retries > 0);	if (obj == null || retries <= 0) {	
waiting too long for template downloading marked it as failed 

if (noCopy) {	event = ObjectInDataStoreStateMachine.Event.CreateOnlyRequested;	} else {	event = ObjectInDataStoreStateMachine.Event.CreateRequested;	}	objectInDataStoreMgr.update(objInStore, event);	} catch (NoTransitionException e) {	try {	objectInDataStoreMgr.update(objInStore, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
state transation failed 

}	CreateCmdResult result = new CreateCmdResult(null, null);	result.setSuccess(false);	result.setResult(e.toString());	callback.complete(result);	return;	} catch (ConcurrentOperationException e) {	try {	objectInDataStoreMgr.update(objInStore, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
state transation failed 

upResult.setResult(result.getResult());	context.getParentCallback().complete(upResult);	return null;	}	try {	objectInDataStoreMgr.update(objInStrore, ObjectInDataStoreStateMachine.Event.OperationSuccessed);	} catch (NoTransitionException e) {	try {	objectInDataStoreMgr.update(objInStrore, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
failed to change state 

objectInDataStoreMgr.update(objInStrore, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	}	upResult.setResult(e.toString());	context.getParentCallback().complete(upResult);	return null;	} catch (ConcurrentOperationException e) {	try {	objectInDataStoreMgr.update(objInStrore, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
failed to change state 

public void copyAsync(DataObject srcData, DataObject destData, AsyncCompletionCallback<CreateCmdResult> callback) {	try {	objectInDataStoreMgr.update(destData, ObjectInDataStoreStateMachine.Event.CopyingRequested);	} catch (NoTransitionException e) {	
failed to change state 

public void copyAsync(DataObject srcData, DataObject destData, AsyncCompletionCallback<CreateCmdResult> callback) {	try {	objectInDataStoreMgr.update(destData, ObjectInDataStoreStateMachine.Event.CopyingRequested);	} catch (NoTransitionException e) {	try {	objectInDataStoreMgr.update(destData, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
failed to further change state to operationfailed 

objectInDataStoreMgr.update(destData, ObjectInDataStoreStateMachine.Event.CopyingRequested);	} catch (NoTransitionException e) {	try {	objectInDataStoreMgr.update(destData, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	}	CreateCmdResult res = new CreateCmdResult(null, null);	res.setResult("Failed to change state: " + e.toString());	callback.complete(res);	} catch (ConcurrentOperationException e) {	
failed to change state 

objectInDataStoreMgr.update(destData, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	}	CreateCmdResult res = new CreateCmdResult(null, null);	res.setResult("Failed to change state: " + e.toString());	callback.complete(res);	} catch (ConcurrentOperationException e) {	try {	objectInDataStoreMgr.update(destData, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
failed to further change state to operationfailed 

protected Void copyCallback(AsyncCallbackDispatcher<DataObjectManagerImpl, CopyCommandResult> callback, CopyContext<CreateCmdResult> context) {	CopyCommandResult result = callback.getResult();	DataObject destObj = context.destObj;	if (result.isFailed()) {	try {	objectInDataStoreMgr.update(destObj, Event.OperationFailed);	} catch (NoTransitionException e) {	
failed to update copying state 

protected Void copyCallback(AsyncCallbackDispatcher<DataObjectManagerImpl, CopyCommandResult> callback, CopyContext<CreateCmdResult> context) {	CopyCommandResult result = callback.getResult();	DataObject destObj = context.destObj;	if (result.isFailed()) {	try {	objectInDataStoreMgr.update(destObj, Event.OperationFailed);	} catch (NoTransitionException e) {	} catch (ConcurrentOperationException e) {	
failed to update copying state 

} catch (NoTransitionException e) {	} catch (ConcurrentOperationException e) {	}	CreateCmdResult res = new CreateCmdResult(null, null);	res.setResult(result.getResult());	context.getParentCallback().complete(res);	}	try {	objectInDataStoreMgr.update(destObj, ObjectInDataStoreStateMachine.Event.OperationSuccessed);	} catch (NoTransitionException e) {	
failed to update copying state 

CreateCmdResult res = new CreateCmdResult(null, null);	res.setResult(result.getResult());	context.getParentCallback().complete(res);	}	try {	objectInDataStoreMgr.update(destObj, ObjectInDataStoreStateMachine.Event.OperationSuccessed);	} catch (NoTransitionException e) {	try {	objectInDataStoreMgr.update(destObj, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
failed to further change state to operationfailed 

objectInDataStoreMgr.update(destObj, ObjectInDataStoreStateMachine.Event.OperationSuccessed);	} catch (NoTransitionException e) {	try {	objectInDataStoreMgr.update(destObj, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	}	CreateCmdResult res = new CreateCmdResult(null, null);	res.setResult("Failed to update copying state: " + e.toString());	context.getParentCallback().complete(res);	} catch (ConcurrentOperationException e) {	
failed to update copying state 

objectInDataStoreMgr.update(destObj, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	}	CreateCmdResult res = new CreateCmdResult(null, null);	res.setResult("Failed to update copying state: " + e.toString());	context.getParentCallback().complete(res);	} catch (ConcurrentOperationException e) {	try {	objectInDataStoreMgr.update(destObj, ObjectInDataStoreStateMachine.Event.OperationFailed);	} catch (Exception e1) {	
failed to further change state to operationfailed 

public void deleteAsync(DataObject data, AsyncCompletionCallback<CommandResult> callback) {	try {	objectInDataStoreMgr.update(data, Event.DestroyRequested);	} catch (NoTransitionException e) {	
destroy failed 

public void deleteAsync(DataObject data, AsyncCompletionCallback<CommandResult> callback) {	try {	objectInDataStoreMgr.update(data, Event.DestroyRequested);	} catch (NoTransitionException e) {	CreateCmdResult res = new CreateCmdResult(null, null);	callback.complete(res);	} catch (ConcurrentOperationException e) {	
destroy failed 

protected Void deleteAsynCallback(AsyncCallbackDispatcher<DataObjectManagerImpl, CommandResult> callback, DeleteContext<CommandResult> context) {	DataObject destObj = context.obj;	CommandResult res = callback.getResult();	if (res.isFailed()) {	try {	objectInDataStoreMgr.update(destObj, Event.OperationFailed);	} catch (NoTransitionException e) {	
delete failed 

protected Void deleteAsynCallback(AsyncCallbackDispatcher<DataObjectManagerImpl, CommandResult> callback, DeleteContext<CommandResult> context) {	DataObject destObj = context.obj;	CommandResult res = callback.getResult();	if (res.isFailed()) {	try {	objectInDataStoreMgr.update(destObj, Event.OperationFailed);	} catch (NoTransitionException e) {	} catch (ConcurrentOperationException e) {	
delete failed 

if (res.isFailed()) {	try {	objectInDataStoreMgr.update(destObj, Event.OperationFailed);	} catch (NoTransitionException e) {	} catch (ConcurrentOperationException e) {	}	} else {	try {	objectInDataStoreMgr.update(destObj, Event.OperationSuccessed);	} catch (NoTransitionException e) {	
delete failed 

try {	objectInDataStoreMgr.update(destObj, Event.OperationFailed);	} catch (NoTransitionException e) {	} catch (ConcurrentOperationException e) {	}	} else {	try {	objectInDataStoreMgr.update(destObj, Event.OperationSuccessed);	} catch (NoTransitionException e) {	} catch (ConcurrentOperationException e) {	
delete failed 

DataObject objInStore = null;	if (obj == null) {	objInStore = objectInDataStoreMgr.create(data, store);	}	try {	ObjectInDataStoreStateMachine.Event event = null;	event = ObjectInDataStoreStateMachine.Event.CreateRequested;	objectInDataStoreMgr.update(objInStore, event);	objectInDataStoreMgr.update(objInStore, ObjectInDataStoreStateMachine.Event.OperationSuccessed);	} catch (NoTransitionException e) {	
failed to update state 

objInStore = objectInDataStoreMgr.create(data, store);	}	try {	ObjectInDataStoreStateMachine.Event event = null;	event = ObjectInDataStoreStateMachine.Event.CreateRequested;	objectInDataStoreMgr.update(objInStore, event);	objectInDataStoreMgr.update(objInStore, ObjectInDataStoreStateMachine.Event.OperationSuccessed);	} catch (NoTransitionException e) {	throw new CloudRuntimeException("Failed to update state", e);	} catch (ConcurrentOperationException e) {	
failed to update state 

========================= cloudstack sample_4001 =========================

protected boolean canHandle(Network network, Service service) {	
checking if niciranvpelement can handle service on network 

protected boolean canHandle(Network network, Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Lswitch) {	return false;	}	if (!networkModel.isProviderForNetwork(getProvider(), network.getId())) {	
niciranvpelement is not a provider for network 

protected boolean canHandle(Network network, Service service) {	if (network.getBroadcastDomainType() != BroadcastDomainType.Lswitch) {	return false;	}	if (!networkModel.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	if (!ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), service, Network.Provider.NiciraNvp)) {	
niciranvpelement can t provide the service on network 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
entering niciranvpelement implement function for network state 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	
nic has no broadcast uri with the lswitch uuid 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	return false;	}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	hostDao.loadDetails(niciraNvpHost);	Account owner = context.getAccount();	if (network.getGuestType().equals(GuestType.Shared)){	String lSwitchUuid = BroadcastDomainType.getValue(network.getBroadcastUri());	String ownerName = context.getDomain().getName() + "-" + context.getAccount().getAccountName();	return sharedNetworkSupport(network, lSwitchUuid, ownerName, niciraNvpHost);	}	else if (network.getGuestType().equals(GuestType.Isolated) && networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.SourceNat, Provider.NiciraNvp)) {	
apparently we are supposed to provide sourcenat on this network 

}	if (tiep == BroadcastDomainType.Vlan) {	vtag = BroadcastDomainType.Vlan.getValueFrom(BroadcastDomainType.fromString(vtag));	} else if (!(tiep == BroadcastDomainType.UnDecided || tiep == BroadcastDomainType.Native)) {	throw new CloudRuntimeException("only vlans are supported for sourceNatIp, at this moment: " + vtag);	}	long vlanid = (Vlan.UNTAGGED.equals(vtag)) ? 0 : Long.parseLong(vtag);	CreateLogicalRouterCommand cmd = new CreateLogicalRouterCommand(niciraNvpHost.getDetail("l3gatewayserviceuuid"), vlanid, BroadcastDomainType.getValue(network.getBroadcastUri()), "router-" + network.getDisplayText(), publicCidr, sourceNatIp.getGateway(), internalCidr, context.getDomain().getName() + "-" + context.getAccount().getAccountName());	CreateLogicalRouterAnswer answer = (CreateLogicalRouterAnswer)agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer.getResult() == false) {	
failed to create logical router for network 

private boolean sharedNetworkSupportUUIDVlanId(Network network, String lSwitchUuid, String ownerName, HostVO niciraNvpHost) {	String networkCidr = network.getCidr();	String vlanGateway = network.getGateway();	String portIpAddress = createLogicalRouterPortIpAddress(networkCidr, vlanGateway);	NiciraNvpRouterMappingVO mapRouterNetwork = niciraNvpRouterMappingDao.findByNetworkId(network.getId());	String lRouterUuid = mapRouterNetwork.getLogicalRouterUuid();	ConfigureSharedNetworkUuidCommand cmd = new ConfigureSharedNetworkUuidCommand(lRouterUuid, lSwitchUuid, portIpAddress, ownerName, network.getId());	ConfigureSharedNetworkUuidAnswer answer = (ConfigureSharedNetworkUuidAnswer)agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer.getResult() == false) {	
failed to configure logical router for shared network 

if (networkVlans.size() == 1){	for (VlanVO vlanVO : networkVlans) {	long vlanId = Long.parseLong(vlanVO.getVlanTag());	String l2GatewayServiceUuid = niciraNvpHost.getDetail("l2gatewayserviceuuid");	if (l2GatewayServiceUuid == null){	throw new CloudRuntimeException("No L2 Gateway Service Uuid found on " + niciraNvpHost.getName());	}	ConfigureSharedNetworkVlanIdCommand cmd = new ConfigureSharedNetworkVlanIdCommand(lSwitchUuid, l2GatewayServiceUuid , vlanId, ownerName, network.getId());	ConfigureSharedNetworkVlanIdAnswer answer = (ConfigureSharedNetworkVlanIdAnswer)agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer.getResult() == false) {	
failed to configure shared network 

public boolean prepare(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	
nic has no broadcast uri with the lswitch uuid 

public boolean prepare(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	return false;	}	NicVO nicVO = nicDao.findById(nic.getId());	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

if (devices.isEmpty()) {	return false;	}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	NiciraNvpNicMappingVO existingNicMap = niciraNvpNicMappingDao.findByNicUuid(nicVO.getUuid());	if (existingNicMap != null) {	FindLogicalSwitchPortCommand findCmd = new FindLogicalSwitchPortCommand(existingNicMap.getLogicalSwitchUuid(), existingNicMap.getLogicalSwitchPortUuid());	FindLogicalSwitchPortAnswer answer = (FindLogicalSwitchPortAnswer)agentMgr.easySend(niciraNvpHost.getId(), findCmd);	if (answer.getResult()) {	
existing logical switchport found for nic with uuid 

HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	NiciraNvpNicMappingVO existingNicMap = niciraNvpNicMappingDao.findByNicUuid(nicVO.getUuid());	if (existingNicMap != null) {	FindLogicalSwitchPortCommand findCmd = new FindLogicalSwitchPortCommand(existingNicMap.getLogicalSwitchUuid(), existingNicMap.getLogicalSwitchPortUuid());	FindLogicalSwitchPortAnswer answer = (FindLogicalSwitchPortAnswer)agentMgr.easySend(niciraNvpHost.getId(), findCmd);	if (answer.getResult()) {	UpdateLogicalSwitchPortCommand cmd = new UpdateLogicalSwitchPortCommand(existingNicMap.getLogicalSwitchPortUuid(), BroadcastDomainType.getValue(network.getBroadcastUri()), nicVO.getUuid(), context.getDomain().getName() + "-" + context.getAccount().getAccountName(), nic.getName());	agentMgr.easySend(niciraNvpHost.getId(), cmd);	return true;	} else {	
stale entry found for nic with logical switchport uuid 

UpdateLogicalSwitchPortCommand cmd = new UpdateLogicalSwitchPortCommand(existingNicMap.getLogicalSwitchPortUuid(), BroadcastDomainType.getValue(network.getBroadcastUri()), nicVO.getUuid(), context.getDomain().getName() + "-" + context.getAccount().getAccountName(), nic.getName());	agentMgr.easySend(niciraNvpHost.getId(), cmd);	return true;	} else {	niciraNvpNicMappingDao.remove(existingNicMap.getId());	}	}	CreateLogicalSwitchPortCommand cmd = new CreateLogicalSwitchPortCommand(BroadcastDomainType.getValue(network.getBroadcastUri()), nicVO.getUuid(), context.getDomain().getName() + "-" + context.getAccount().getAccountName(), nic.getName());	CreateLogicalSwitchPortAnswer answer = (CreateLogicalSwitchPortAnswer)agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
createlogicalswitchportcommand failed 

public boolean release(Network network, NicProfile nic, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	
nic has no broadcast uri with the lswitch uuid 

public boolean release(Network network, NicProfile nic, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	if (network.getBroadcastUri() == null) {	return false;	}	NicVO nicVO = nicDao.findById(nic.getId());	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

}	NicVO nicVO = nicDao.findById(nic.getId());	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	NiciraNvpNicMappingVO nicMap = niciraNvpNicMappingDao.findByNicUuid(nicVO.getUuid());	if (nicMap == null) {	
no mapping for nic 

}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	NiciraNvpNicMappingVO nicMap = niciraNvpNicMappingDao.findByNicUuid(nicVO.getUuid());	if (nicMap == null) {	return false;	}	DeleteLogicalSwitchPortCommand cmd = new DeleteLogicalSwitchPortCommand(nicMap.getLogicalSwitchUuid(), nicMap.getLogicalSwitchPortUuid());	DeleteLogicalSwitchPortAnswer answer = (DeleteLogicalSwitchPortAnswer)agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
deletelogicalswitchportcommand failed 

public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	if (!canHandle(network, Service.Connectivity)) {	return false;	}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

if (!canHandle(network, Service.Connectivity)) {	return false;	}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	if (! network.getGuestType().equals(GuestType.Shared) && networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.SourceNat, Provider.NiciraNvp)) {	
apparently we were providing sourcenat on this network 

}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	if (! network.getGuestType().equals(GuestType.Shared) && networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.SourceNat, Provider.NiciraNvp)) {	NiciraNvpRouterMappingVO routermapping = niciraNvpRouterMappingDao.findByNetworkId(network.getId());	if (routermapping == null) {	
no logical router uuid found for network 

NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	if (! network.getGuestType().equals(GuestType.Shared) && networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.SourceNat, Provider.NiciraNvp)) {	NiciraNvpRouterMappingVO routermapping = niciraNvpRouterMappingDao.findByNetworkId(network.getId());	if (routermapping == null) {	return true;	}	DeleteLogicalRouterCommand cmd = new DeleteLogicalRouterCommand(routermapping.getLogicalRouterUuid());	DeleteLogicalRouterAnswer answer = (DeleteLogicalRouterAnswer)agentMgr.easySend(niciraNvpHost.getId(), cmd);	if (answer.getResult() == false) {	
failed to delete logicalrouter for network 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	
unable to provide services without connectivity service enabled for this element 

public boolean verifyServicesCombination(Set<Service> services) {	if (!services.contains(Service.Connectivity)) {	return false;	}	if ((services.contains(Service.PortForwarding) || services.contains(Service.StaticNat)) && !services.contains(Service.SourceNat)) {	
unable to provide staticnat and or portforwarding without the sourcenat service 

public boolean applyIps(Network network, List<? extends PublicIpAddress> ipAddress, Set<Service> services) throws ResourceUnavailableException {	if (services.contains(Service.SourceNat)) {	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

if (services.contains(Service.SourceNat)) {	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	hostDao.loadDetails(niciraNvpHost);	NiciraNvpRouterMappingVO routermapping = niciraNvpRouterMappingDao.findByNetworkId(network.getId());	if (routermapping == null) {	
no logical router uuid found for network 

for (PublicIpAddress ip : ipAddress) {	if (ip.getState() == IpAddress.State.Releasing) {	continue;	}	cidrs.add(ip.getAddress().addr() + "/" + NetUtils.getCidrSize(ip.getNetmask()));	}	ConfigurePublicIpsOnLogicalRouterCommand cmd = new ConfigurePublicIpsOnLogicalRouterCommand(routermapping.getLogicalRouterUuid(), niciraNvpHost.getDetail("l3gatewayserviceuuid"), cidrs);	ConfigurePublicIpsOnLogicalRouterAnswer answer = (ConfigurePublicIpsOnLogicalRouterAnswer)agentMgr.easySend(niciraNvpHost.getId(), cmd);	return answer.getResult();	} else {	
no need to provision ip addresses as we are not providing services 

public boolean applyStaticNats(Network network, List<? extends StaticNat> rules) throws ResourceUnavailableException {	if (!canHandle(network, Service.StaticNat)) {	return false;	}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

return false;	}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	NiciraNvpRouterMappingVO routermapping = niciraNvpRouterMappingDao.findByNetworkId(network.getId());	if (routermapping == null) {	
no logical router uuid found for network 

public boolean applyPFRules(Network network, List<PortForwardingRule> rules) throws ResourceUnavailableException {	if (!canHandle(network, Service.PortForwarding)) {	return false;	}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no niciranvp controller on physical network 

return false;	}	List<NiciraNvpDeviceVO> devices = niciraNvpDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	NiciraNvpDeviceVO niciraNvpDevice = devices.get(0);	HostVO niciraNvpHost = hostDao.findById(niciraNvpDevice.getHostId());	NiciraNvpRouterMappingVO routermapping = niciraNvpRouterMappingDao.findByNetworkId(network.getId());	if (routermapping == null) {	
no logical router uuid found for network 

========================= cloudstack sample_1716 =========================

if(checkCase.checkId) {	pstmt.setInt(1, lastId);	pstmt.setInt(2, maxId);	}	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next() && (rs.getInt(1) > 0)) {	errors.append(String.format("Error: Found %s %s\n", rs.getInt(1), checkCase.itemName));	checkOk = false;	}	}catch (Exception e) {	
checkitemcountbypstmt exception 

try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next() && (rs.getInt(1) > 0)) {	errors.append(String.format("Error: Found %s %s\n", rs.getInt(1), checkCase.itemName));	checkOk = false;	}	}catch (Exception e) {	throw new CloudRuntimeException("checkItemCountByPstmt:Exception:"+e.getMessage(),e);	}	}	catch (Exception e) {	
checkitemcountbypstmt exception 

protected void checkMaxUsage() throws SQLException {	int aggregationRange = DEFAULT_AGGREGATION_RANGE;	try (PreparedStatement pstmt = conn.prepareStatement( "SELECT value FROM `cloud`.`configuration` where name = 'usage.stats.job.aggregation.range'");) {	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	aggregationRange = rs.getInt(1);	} else {	
failed to retrieve aggregation range using default 

protected void checkMaxUsage() throws SQLException {	int aggregationRange = DEFAULT_AGGREGATION_RANGE;	try (PreparedStatement pstmt = conn.prepareStatement( "SELECT value FROM `cloud`.`configuration` where name = 'usage.stats.job.aggregation.range'");) {	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	aggregationRange = rs.getInt(1);	} else {	}	}catch (SQLException e) {	
checkmaxusage exception 

try (PreparedStatement pstmt = conn.prepareStatement( "SELECT value FROM `cloud`.`configuration` where name = 'usage.stats.job.aggregation.range'");) {	try(ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	aggregationRange = rs.getInt(1);	} else {	}	}catch (SQLException e) {	throw new CloudRuntimeException("checkMaxUsage:Exception:"+e.getMessage());	}	} catch (SQLException e) {	
checkmaxusage exception 

protected void readLastCheckId(){	try(BufferedReader reader = new BufferedReader(new FileReader(lastCheckFile));) {	String lastIdText = null;	lastId = -1;	if ((reader != null) && (lastIdText = reader.readLine()) != null) {	lastId = Integer.parseInt(lastIdText);	}	} catch (Exception e) {	
readlastcheckid exception 

protected void readMaxId() throws SQLException {	try (PreparedStatement pstmt = conn.prepareStatement("select max(id) from cloud_usage.cloud_usage");	ResultSet rs = pstmt.executeQuery();) {	maxId = -1;	if (rs.next() && (rs.getInt(1) > 0)) {	maxId = rs.getInt(1);	lastCheckId += " and cu.id <= ?";	}	}catch (Exception e) {	
readmaxid 

protected void updateNewMaxId() {	try (FileWriter fstream = new FileWriter(lastCheckFile);	BufferedWriter out = new BufferedWriter(fstream);	){	out.write("" + maxId);	} catch (IOException e) {	
updatenewmaxid exception 

========================= cloudstack sample_2643 =========================

public void process(VirtualMachineProfile vmProfile, DeploymentPlan plan, ExcludeList avoid) throws AffinityConflictException {	VirtualMachine vm = vmProfile.getVirtualMachine();	List<AffinityGroupVMMapVO> vmGroupMappings = _affinityGroupVMMapDao.findByVmIdType(vm.getId(), getType());	for (AffinityGroupVMMapVO vmGroupMapping : vmGroupMappings) {	if (vmGroupMapping != null) {	AffinityGroupVO group = _affinityGroupDao.findById(vmGroupMapping.getAffinityGroupId());	if (s_logger.isDebugEnabled()) {	
processing affinity group for vm id 

if (s_logger.isDebugEnabled()) {	}	List<Long> groupVMIds = _affinityGroupVMMapDao.listVmIdsByAffinityGroup(group.getId());	groupVMIds.remove(vm.getId());	for (Long groupVMId : groupVMIds) {	VMInstanceVO groupVM = _vmInstanceDao.findById(groupVMId);	if (groupVM != null && !groupVM.isRemoved()) {	if (groupVM.getHostId() != null) {	avoid.addHost(groupVM.getHostId());	if (s_logger.isDebugEnabled()) {	
added host to avoid set since vm is present on the host 

if (groupVM != null && !groupVM.isRemoved()) {	if (groupVM.getHostId() != null) {	avoid.addHost(groupVM.getHostId());	if (s_logger.isDebugEnabled()) {	}	} else if (VirtualMachine.State.Stopped.equals(groupVM.getState()) && groupVM.getLastHostId() != null) {	long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - groupVM.getUpdateTime().getTime()) / 1000;	if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {	avoid.addHost(groupVM.getLastHostId());	if (s_logger.isDebugEnabled()) {	
added host to avoid set since vm is present on the host in stopped state but has reserved capacity 

long plannedHostId = plannedDestination.getHost().getId();	VirtualMachine vm = vmProfile.getVirtualMachine();	List<AffinityGroupVMMapVO> vmGroupMappings = _affinityGroupVMMapDao.findByVmIdType(vm.getId(), getType());	for (AffinityGroupVMMapVO vmGroupMapping : vmGroupMappings) {	List<Long> groupVMIds = _affinityGroupVMMapDao.listVmIdsByAffinityGroup(vmGroupMapping.getAffinityGroupId());	groupVMIds.remove(vm.getId());	for (Long groupVMId : groupVMIds) {	VMReservationVO vmReservation = _reservationDao.findByVmId(groupVMId);	if (vmReservation != null && vmReservation.getHostId() != null && vmReservation.getHostId().equals(plannedHostId)) {	if (s_logger.isDebugEnabled()) {	
planned destination for vm conflicts with an existing vm reserved on the same host 

========================= cloudstack sample_1983 =========================

public boolean sendCommandsToRouter(final VirtualRouter router, final Commands cmds) throws AgentUnavailableException, ResourceUnavailableException {	if (!checkRouterVersion(router)) {	
router requires upgrade unable to send command to router router template version minimal required version 

public boolean sendCommandsToRouter(final VirtualRouter router, final Commands cmds) throws AgentUnavailableException, ResourceUnavailableException {	if (!checkRouterVersion(router)) {	throw new ResourceUnavailableException("Unable to send command. Router requires upgrade", VirtualRouter.class, router.getId());	}	Answer[] answers = null;	try {	answers = _agentMgr.send(router.getHostId(), cmds);	} catch (final OperationTimedoutException e) {	
timed out 

}	}	for (final VirtualRouter virtualRouter : disconnectedRouters) {	if (!virtualRouter.getIsRedundantRouter()) {	throw new ResourceUnavailableException("Who is calling this with non-redundant router or non-domain router?", DataCenter.class, virtualRouter.getDataCenterId());	}	}	final DomainRouterVO connectedRouter = (DomainRouterVO) connectedRouters.get(0);	DomainRouterVO disconnectedRouter = (DomainRouterVO) disconnectedRouters.get(0);	if (s_logger.isDebugEnabled()) {	
about to stop the router due to 

public VirtualRouter destroyRouter(final long routerId, final Account caller, final Long callerUserId) throws ResourceUnavailableException, ConcurrentOperationException {	if (s_logger.isDebugEnabled()) {	
attempting to destroy router 

protected DomainRouterVO start(DomainRouterVO router, final User user, final Account caller, final Map<Param, Object> params, final DeploymentPlan planToDeploy) throws StorageUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {	
starting router 

protected DomainRouterVO start(DomainRouterVO router, final User user, final Account caller, final Map<Param, Object> params, final DeploymentPlan planToDeploy) throws StorageUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {	try {	_itMgr.advanceStart(router.getUuid(), params, planToDeploy, null);	} catch (final OperationTimedoutException e) {	throw new ResourceUnavailableException("Starting router " + router + " failed! " + e.toString(), DataCenter.class, router.getDataCenterId());	}	if (router.isStopPending()) {	
clear the stop pending flag of router after start router successfully 

protected DomainRouterVO waitRouter(final DomainRouterVO router) {	DomainRouterVO vm = _routerDao.findById(router.getId());	if (s_logger.isDebugEnabled()) {	
router is not fully up yet we will wait 

}	while (vm.getState() == State.Starting) {	try {	Thread.sleep(1000);	} catch (final InterruptedException e) {	}	vm = _routerDao.findById(router.getId());	}	if (vm.getState() == State.Running) {	if (s_logger.isDebugEnabled()) {	
router is now fully up 

Thread.sleep(1000);	} catch (final InterruptedException e) {	}	vm = _routerDao.findById(router.getId());	}	if (vm.getState() == State.Running) {	if (s_logger.isDebugEnabled()) {	}	return router;	}	
router failed to start current state 

public DomainRouterVO startVirtualRouter(final DomainRouterVO router, final User user, final Account caller, final Map<Param, Object> params) throws StorageUnavailableException, InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {	if (router.getRole() != Role.VIRTUAL_ROUTER || !router.getIsRedundantRouter()) {	return start(router, user, caller, params, null);	}	if (router.getState() == State.Running) {	
redundant router is already running 

final List<VolumeVO> volumes = _volumeDao.findByInstanceAndType(routerToBeAvoid.getId(), Volume.Type.ROOT);	if (volumes != null && volumes.size() != 0) {	avoids[2].addPool(volumes.get(0).getPoolId());	}	avoids[2].addHost(routerToBeAvoid.getHostId());	avoids[3] = new ExcludeList();	avoids[3].addHost(routerToBeAvoid.getHostId());	avoids[4] = new ExcludeList();	for (int i = 0; i < retryIndex; i++) {	if (s_logger.isTraceEnabled()) {	
try to deploy redundant virtual router for time 

for (final Iterator<HypervisorType> iter = hypervisors.iterator(); iter.hasNext();) {	final HypervisorType hType = iter.next();	try {	final long id = _routerDao.getNextInSequence(Long.class, "id");	if (s_logger.isDebugEnabled()) {	s_logger.debug(String.format("Allocating the VR with id=%s in datacenter %s with the hypervisor type %s", id, routerDeploymentDefinition.getDest() .getDataCenter(), hType));	}	final String templateName = retrieveTemplateName(hType, routerDeploymentDefinition.getDest().getDataCenter().getId());	final VMTemplateVO template = _templateDao.findRoutingTemplate(hType, templateName);	if (template == null) {	
won t support system vm skip it 

}	}	router = new DomainRouterVO(id, routerOffering.getId(), routerDeploymentDefinition.getVirtualProvider().getId(), VirtualMachineName.getRouterName(id, s_vmInstanceName), template.getId(), template.getHypervisorType(), template.getGuestOSId(), owner.getDomainId(), owner.getId(), userId, routerDeploymentDefinition.isRedundant(), RedundantState.UNKNOWN, offerHA, false, vpcId);	router.setDynamicallyScalable(template.isDynamicallyScalable());	router.setRole(Role.VIRTUAL_ROUTER);	router = _routerDao.persist(router);	reallocateRouterNetworks(routerDeploymentDefinition, router, template, null);	router = _routerDao.findById(router.getId());	} catch (final InsufficientCapacityException ex) {	if (allocateRetry < 2 && iter.hasNext()) {	
failed to allocate the vr with hypervisor type retrying one more time 

}	} finally {	allocateRetry++;	}	if (startRouter) {	try {	router = startVirtualRouter(router, _accountMgr.getSystemUser(), _accountMgr.getSystemAccount(), routerDeploymentDefinition.getParams());	break;	} catch (final InsufficientCapacityException ex) {	if (startRetry < 2 && iter.hasNext()) {	
failed to start the vr with hypervisor type destroying it and recreating one more time 

for (final ClusterVO cv : clusters) {	if (cv.getHypervisorType() == HypervisorType.Ovm || cv.getHypervisorType() == HypervisorType.BareMetal) {	continue;	}	final List<HostVO> hosts = _resourceMgr.listAllHostsInCluster(cv.getId());	if (hosts == null || hosts.isEmpty()) {	continue;	}	for (final HostVO h : hosts) {	if (h.getState() == Status.Up) {	
pick up host that has hypervisor type in cluster to start domain router for ovm 

protected LinkedHashMap<Network, List<? extends NicProfile>> configureControlNic(final RouterDeploymentDefinition routerDeploymentDefinition) {	final LinkedHashMap<Network, List<? extends NicProfile>> controlConfig = new LinkedHashMap<Network, List<? extends NicProfile>>(3);	
adding nic for virtual router in control network 

protected LinkedHashMap<Network, List<? extends NicProfile>> configurePublicNic(final RouterDeploymentDefinition routerDeploymentDefinition, final boolean hasGuestNic) {	final LinkedHashMap<Network, List<? extends NicProfile>> publicConfig = new LinkedHashMap<Network, List<? extends NicProfile>>(3);	if (routerDeploymentDefinition.isPublicNetwork()) {	
adding nic for virtual router in public network 

defaultNic.setIsolationUri(IsolationType.Vlan.toUri(sourceNatIp.getVlanTag()));	}	if (hasGuestNic) {	defaultNic.setDeviceId(2);	}	final NetworkOffering publicOffering = _networkModel.getSystemAccountNetworkOfferings(NetworkOffering.SystemPublicNetwork).get(0);	final List<? extends Network> publicNetworks = _networkMgr.setupNetwork(s_systemAccount, publicOffering, routerDeploymentDefinition.getPlan(), null, null, false);	final String publicIp = defaultNic.getIPv4Address();	final NicVO peerNic = _nicDao.findByIp4AddressAndNetworkId(publicIp, publicNetworks.get(0).getId());	if (peerNic != null) {	
use same mac as previous rvr the mac is 

public LinkedHashMap<Network, List<? extends NicProfile>> configureGuestNic(final RouterDeploymentDefinition routerDeploymentDefinition) throws ConcurrentOperationException, InsufficientAddressCapacityException {	final LinkedHashMap<Network, List<? extends NicProfile>> networks = new LinkedHashMap<Network, List<? extends NicProfile>>(3);	final Network guestNetwork = routerDeploymentDefinition.getGuestNetwork();	if (guestNetwork != null) {	
adding nic for virtual router in guest network 

public LinkedHashMap<Network, List<? extends NicProfile>> configureGuestNic(final RouterDeploymentDefinition routerDeploymentDefinition) throws ConcurrentOperationException, InsufficientAddressCapacityException {	final LinkedHashMap<Network, List<? extends NicProfile>> networks = new LinkedHashMap<Network, List<? extends NicProfile>>(3);	final Network guestNetwork = routerDeploymentDefinition.getGuestNetwork();	if (guestNetwork != null) {	String defaultNetworkStartIp = null, defaultNetworkStartIpv6 = null;	if (!routerDeploymentDefinition.isPublicNetwork()) {	final Nic placeholder = _networkModel.getPlaceholderNicForRouter(guestNetwork, routerDeploymentDefinition.getPodId());	if (guestNetwork.getCidr() != null) {	if (placeholder != null && placeholder.getIPv4Address() != null) {	
requesting address stored in placeholder nic for the network 

final String startIp = _networkModel.getStartIpAddress(guestNetwork.getId());	if (startIp != null && _ipAddressDao.findByIpAndSourceNetworkId(guestNetwork.getId(), startIp).getAllocatedTime() == null) {	defaultNetworkStartIp = startIp;	} else if (s_logger.isDebugEnabled()) {	s_logger.debug("First ipv4 " + startIp + " in network id=" + guestNetwork.getId() + " is already allocated, can't use it for domain router; will get random ip address from the range");	}	}	}	if (guestNetwork.getIp6Cidr() != null) {	if (placeholder != null && placeholder.getIPv6Address() != null) {	
requesting address stored in placeholder nic for the network 

========================= cloudstack sample_2356 =========================

if (value.charAt(0) == '\"') value = value.substring(1, value.length() - 1);	_properties.put(name, value);	} else {	if (line.startsWith("RW")) {	int startPos = line.indexOf('\"');	int endPos = line.lastIndexOf('\"');	assert (startPos > 0);	assert (endPos > 0);	_baseFileName = line.substring(startPos + 1, endPos);	} else {	
unrecognized vmdk line content 

assert (endPos > 0);	out.write(line.substring(0, startPos + 1));	out.write(baseFileName);	out.write(line.substring(endPos));	out.newLine();	} else {	out.write(line);	out.newLine();	}	} else {	
unrecognized vmdk line content 

========================= cloudstack sample_2074 =========================

throw new InvalidParameterValueException("Requested size out of range");	}	if (currentSize > newSize && !shrinkOk) {	throw new InvalidParameterValueException("Going from existing size of " + currentSize + " to size of " + newSize + " would shrink the volume." + "Need to sign off by supplying the shrinkok parameter with value of true.");	}	if (newSize > currentSize) {	_resourceLimitMgr.checkResourceLimit(_accountMgr.getAccount(volume.getAccountId()), ResourceType.primary_storage, volume.isDisplayVolume(), new Long(newSize - currentSize).longValue());	}	}	if (volume.getState() == Volume.State.Allocated) {	
volume is in the allocated state but has never been created simply updating database with new size and iops 

AsyncCallFuture<VolumeApiResult> future = volService.resize(vol);	VolumeApiResult result = future.get();	if (storagePool.isManaged() && currentSize != newSize) {	if (hosts != null && hosts.length > 0) {	volService.resizeVolumeOnHypervisor(volumeId, newSize, hosts[0], instanceName);	}	volume.setSize(newSize);	_volsDao.update(volume.getId(), volume);	}	if (result.isFailed()) {	
failed to resize the volume 

volume.setSize(newSize);	}	_volsDao.update(volume.getId(), volume);	if (!shrinkOk) {	_resourceLimitMgr.incrementResourceCount(volume.getAccountId(), ResourceType.primary_storage, volume.isDisplayVolume(), new Long(newSize - currentSize));	} else {	_resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType.primary_storage, volume.isDisplayVolume(), new Long(currentSize - newSize));	}	return volume;	} catch (InterruptedException e) {	
failed get resize volume result 

_volsDao.update(volume.getId(), volume);	if (!shrinkOk) {	_resourceLimitMgr.incrementResourceCount(volume.getAccountId(), ResourceType.primary_storage, volume.isDisplayVolume(), new Long(newSize - currentSize));	} else {	_resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType.primary_storage, volume.isDisplayVolume(), new Long(currentSize - newSize));	}	return volume;	} catch (InterruptedException e) {	throw new CloudRuntimeException(e.getMessage());	} catch (ExecutionException e) {	
failed get resize volume result 

_resourceLimitMgr.incrementResourceCount(volume.getAccountId(), ResourceType.primary_storage, volume.isDisplayVolume(), new Long(newSize - currentSize));	} else {	_resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType.primary_storage, volume.isDisplayVolume(), new Long(currentSize - newSize));	}	return volume;	} catch (InterruptedException e) {	throw new CloudRuntimeException(e.getMessage());	} catch (ExecutionException e) {	throw new CloudRuntimeException(e.getMessage());	} catch (Exception e) {	
failed get resize volume result 

_resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType.volume, volume.isDisplayVolume());	}	}	if (volume.getState() == Volume.State.Allocated) {	_volsDao.remove(volumeId);	stateTransitTo(volume, Volume.Event.DestroyRequested);	return true;	}	VolumeInfo volOnPrimary = volFactory.getVolume(volume.getId(), DataStoreRole.Primary);	if (volOnPrimary != null) {	
expunging volume from primary data store 

return true;	}	VolumeInfo volOnPrimary = volFactory.getVolume(volume.getId(), DataStoreRole.Primary);	if (volOnPrimary != null) {	AsyncCallFuture<VolumeApiResult> future = volService.expungeVolumeAsync(volOnPrimary);	future.get();	_resourceLimitMgr.recalculateResourceCount(volume.getAccountId(), volume.getDomainId(), ResourceType.primary_storage.getOrdinal());	}	VolumeInfo volOnSecondary = volFactory.getVolume(volume.getId(), DataStoreRole.Image);	if (volOnSecondary != null) {	
expunging volume from secondary data store 

_resourceLimitMgr.recalculateResourceCount(volume.getAccountId(), volume.getDomainId(), ResourceType.primary_storage.getOrdinal());	}	VolumeInfo volOnSecondary = volFactory.getVolume(volume.getId(), DataStoreRole.Image);	if (volOnSecondary != null) {	AsyncCallFuture<VolumeApiResult> future2 = volService.expungeVolumeAsync(volOnSecondary);	future2.get();	_resourceLimitMgr.recalculateResourceCount(volume.getAccountId(), volume.getDomainId(), ResourceType.secondary_storage.getOrdinal());	}	List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());	for (VolumeInfo volOnCache : cacheVols) {	
delete volume from image cache store 

if (volOnSecondary != null) {	AsyncCallFuture<VolumeApiResult> future2 = volService.expungeVolumeAsync(volOnSecondary);	future2.get();	_resourceLimitMgr.recalculateResourceCount(volume.getAccountId(), volume.getDomainId(), ResourceType.secondary_storage.getOrdinal());	}	List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());	for (VolumeInfo volOnCache : cacheVols) {	volOnCache.delete();	}	} catch (InterruptedException | ExecutionException | NoTransitionException e) {	
failed to expunge volume 

VolumeInfo newVolumeOnPrimaryStorage = volumeToAttach;	StoragePoolVO destPrimaryStorage = null;	if (exstingVolumeOfVm != null && !exstingVolumeOfVm.getState().equals(Volume.State.Allocated)) {	destPrimaryStorage = _storagePoolDao.findById(exstingVolumeOfVm.getPoolId());	}	boolean volumeOnSecondary = volumeToAttach.getState() == Volume.State.Uploaded;	if (destPrimaryStorage != null && (volumeToAttach.getState() == Volume.State.Allocated || volumeOnSecondary)) {	try {	newVolumeOnPrimaryStorage = _volumeMgr.createVolumeOnPrimaryStorage(vm, volumeToAttach, rootDiskHyperType, destPrimaryStorage);	} catch (NoTransitionException e) {	
failed to create volume on primary storage 

boolean moveVolumeNeeded = needMoveVolume(exstingVolumeOfVm, newVolumeOnPrimaryStorage);	if (moveVolumeNeeded) {	PrimaryDataStoreInfo primaryStore = (PrimaryDataStoreInfo)newVolumeOnPrimaryStorage.getDataStore();	if (primaryStore.isLocal()) {	throw new CloudRuntimeException("Failed to attach local data volume " + volumeToAttach.getName() + " to VM " + vm.getDisplayName() + " as migration of local data volume is not allowed");	}	StoragePoolVO vmRootVolumePool = _storagePoolDao.findById(exstingVolumeOfVm.getPoolId());	try {	newVolumeOnPrimaryStorage = _volumeMgr.moveVolume(newVolumeOnPrimaryStorage, vmRootVolumePool.getDataCenterId(), vmRootVolumePool.getPodId(), vmRootVolumePool.getClusterId(), volumeToAttachHyperType);	} catch (ConcurrentOperationException e) {	
move volume failed 

PrimaryDataStoreInfo primaryStore = (PrimaryDataStoreInfo)newVolumeOnPrimaryStorage.getDataStore();	if (primaryStore.isLocal()) {	throw new CloudRuntimeException("Failed to attach local data volume " + volumeToAttach.getName() + " to VM " + vm.getDisplayName() + " as migration of local data volume is not allowed");	}	StoragePoolVO vmRootVolumePool = _storagePoolDao.findById(exstingVolumeOfVm.getPoolId());	try {	newVolumeOnPrimaryStorage = _volumeMgr.moveVolume(newVolumeOnPrimaryStorage, vmRootVolumePool.getDataCenterId(), vmRootVolumePool.getPodId(), vmRootVolumePool.getClusterId(), volumeToAttachHyperType);	} catch (ConcurrentOperationException e) {	throw new CloudRuntimeException("move volume failed", e);	} catch (StorageUnavailableException e) {	
move volume failed 

throw new InvalidParameterValueException("Unable to attach volume, please specify a VM that does not have VM snapshots");	}	_accountMgr.checkAccess(caller, null, true, volumeToAttach, vm);	if (!(Volume.State.Allocated.equals(volumeToAttach.getState()) || Volume.State.Ready.equals(volumeToAttach.getState()) || Volume.State.Uploaded.equals(volumeToAttach .getState()))) {	throw new InvalidParameterValueException("Volume state must be in Allocated, Ready or in Uploaded state");	}	Account owner = _accountDao.findById(volumeToAttach.getAccountId());	try {	_resourceLimitMgr.checkResourceLimit(owner, ResourceType.primary_storage, volumeToAttach.getSize());	} catch (ResourceAllocationException e) {	
primary storage resource limit check failed 

StoragePoolVO volumeToAttachStoragePool = _storagePoolDao.findById(volumeToAttach.getPoolId());	if (volumeToAttachStoragePool != null && !volumeToAttachStoragePool.isManaged()) {	if (volumeToAttachHyperType != HypervisorType.None && rootDiskHyperType != volumeToAttachHyperType) {	throw new InvalidParameterValueException("Can't attach a volume created by: " + volumeToAttachHyperType + " to a " + rootDiskHyperType + " vm");	}	}	AsyncJobExecutionContext asyncExecutionContext = AsyncJobExecutionContext.getCurrentExecutionContext();	if (asyncExecutionContext != null) {	AsyncJob job = asyncExecutionContext.getJob();	if (s_logger.isInfoEnabled()) {	
trying to attaching volume to vm instance update async job progress status 

validateRootVolumeDetachAttach(volume, vm);	}	List<VMSnapshotVO> vmSnapshots = _vmSnapshotDao.findByVm(vmId);	if (vmSnapshots.size() > 0) {	throw new InvalidParameterValueException("Unable to detach volume, please specify a VM that does not have VM snapshots");	}	AsyncJobExecutionContext asyncExecutionContext = AsyncJobExecutionContext.getCurrentExecutionContext();	if (asyncExecutionContext != null) {	AsyncJob job = asyncExecutionContext.getJob();	if (s_logger.isInfoEnabled()) {	
trying to attaching volume to vm instance update async job progress status 

final VirtualMachineDiskInfo infoInChain = _gson.fromJson(rootVolChainInfo, VirtualMachineDiskInfo.class);	if (infoInChain != null) {	rootDiskController = infoInChain.getControllerFromDeviceBusName();	}	final UserVmVO userVmVo = _userVmDao.findById(vm.getId());	if ((rootDiskController != null) && (!rootDiskController.isEmpty())) {	_userVmDao.loadDetails(userVmVo);	_userVmMgr.persistDeviceBusInfo(userVmVo, rootDiskController);	}	} catch (JsonParseException e) {	
error parsing chain info json 

StoragePool destPool = (StoragePool)dataStoreMgr.getDataStore(destPoolId, DataStoreRole.Primary);	assert (destPool != null);	Volume newVol = null;	try {	if (liveMigrateVolume) {	newVol = liveMigrateVolume(vol, destPool);	} else {	newVol = _volumeMgr.migrateVolume(vol, destPool);	}	} catch (StorageUnavailableException e) {	
failed to migrate volume 

Volume newVol = null;	try {	if (liveMigrateVolume) {	newVol = liveMigrateVolume(vol, destPool);	} else {	newVol = _volumeMgr.migrateVolume(vol, destPool);	}	} catch (StorageUnavailableException e) {	throw new CloudRuntimeException(e.getMessage());	}  catch (Exception e) {	
failed to migrate volume 

protected Volume liveMigrateVolume(Volume volume, StoragePool destPool) throws StorageUnavailableException {	VolumeInfo vol = volFactory.getVolume(volume.getId());	AsyncCallFuture<VolumeApiResult> future = volService.migrateVolume(vol, (DataStore)destPool);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	
migrate volume failed 

protected Volume liveMigrateVolume(Volume volume, StoragePool destPool) throws StorageUnavailableException {	VolumeInfo vol = volFactory.getVolume(volume.getId());	AsyncCallFuture<VolumeApiResult> future = volService.migrateVolume(vol, (DataStore)destPool);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	throw new StorageUnavailableException("Migrate volume failed: " + result.getResult(), destPool.getId());	}	return result.getVolume();	} catch (InterruptedException e) {	
migrate volume failed 

AsyncCallFuture<VolumeApiResult> future = volService.migrateVolume(vol, (DataStore)destPool);	try {	VolumeApiResult result = future.get();	if (result.isFailed()) {	throw new StorageUnavailableException("Migrate volume failed: " + result.getResult(), destPool.getId());	}	return result.getVolume();	} catch (InterruptedException e) {	throw new CloudRuntimeException(e.getMessage());	} catch (ExecutionException e) {	
migrate volume failed 

throw ex;	}	_accountMgr.checkAccess(account, null, true, volume);	if (_dcDao.findById(zoneId) == null) {	throw new InvalidParameterValueException("Please specify a valid zone.");	}	if (volume.getPoolId() == null) {	throw new InvalidParameterValueException("The volume doesnt belong to a storage pool so cant extract it");	}	if (volume.getInstanceId() != null && ApiDBUtils.findVMInstanceById(volume.getInstanceId()).getState() != State.Stopped) {	
invalid state of the volume with id it should be either detached or the vm should be in stopped state 

}	ImageStoreEntity secStore = (ImageStoreEntity)dataStoreMgr.getImageStore(zoneId);	String value = _configDao.getValue(Config.CopyVolumeWait.toString());	NumbersUtil.parseInt(value, Integer.parseInt(Config.CopyVolumeWait.getDefaultValue()));	VolumeInfo srcVol = volFactory.getVolume(volumeId);	AsyncCallFuture<VolumeApiResult> cvAnswer = volService.copyVolume(srcVol, secStore);	VolumeApiResult cvResult = null;	try {	cvResult = cvAnswer.get();	} catch (InterruptedException e1) {	
failed copy volume 

String value = _configDao.getValue(Config.CopyVolumeWait.toString());	NumbersUtil.parseInt(value, Integer.parseInt(Config.CopyVolumeWait.getDefaultValue()));	VolumeInfo srcVol = volFactory.getVolume(volumeId);	AsyncCallFuture<VolumeApiResult> cvAnswer = volService.copyVolume(srcVol, secStore);	VolumeApiResult cvResult = null;	try {	cvResult = cvAnswer.get();	} catch (InterruptedException e1) {	throw new CloudRuntimeException("Failed to copy volume", e1);	} catch (ExecutionException e1) {	
failed copy volume 

details.put(DiskTO.CHAP_INITIATOR_USERNAME, chapInfo.getInitiatorUsername());	details.put(DiskTO.CHAP_INITIATOR_SECRET, chapInfo.getInitiatorSecret());	details.put(DiskTO.CHAP_TARGET_USERNAME, chapInfo.getTargetUsername());	details.put(DiskTO.CHAP_TARGET_SECRET, chapInfo.getTargetSecret());	}	_userVmDao.loadDetails(vm);	Map<String, String> controllerInfo = new HashMap<String, String>();	controllerInfo.put(VmDetailConstants.ROOT_DISK_CONTROLLER, vm.getDetail(VmDetailConstants.ROOT_DISK_CONTROLLER));	controllerInfo.put(VmDetailConstants.DATA_DISK_CONTROLLER, vm.getDetail(VmDetailConstants.DATA_DISK_CONTROLLER));	cmd.setControllerInfo(controllerInfo);	
attach volume id on vm id has controller info 

workJob.setAccountId(callingAccount.getId());	workJob.setUserId(callingUser.getId());	workJob.setStep(VmWorkJobVO.Step.Starting);	workJob.setVmType(VirtualMachine.Type.Instance);	workJob.setVmInstanceId(vm.getId());	workJob.setRelated(AsyncJobExecutionContext.getOriginJobId());	VmWorkAttachVolume workInfo = new VmWorkAttachVolume(callingUser.getId(), callingAccount.getId(), vm.getId(), VolumeApiServiceImpl.VM_WORK_JOB_HANDLER, volumeId, deviceId);	workJob.setCmdInfo(VmWorkSerializer.serialize(workInfo));	_jobMgr.submitAsyncJob(workJob, VmWorkConstants.VM_WORK_QUEUE, vm.getId());	AsyncJobVO jobVo = _jobMgr.getAsyncJob(workJob.getId());	
new job result field 

========================= cloudstack sample_2424 =========================

public void start() throws NioConnectionException {	_todos = new ArrayList<ChangeRequest>();	try {	init();	} catch (final ConnectException e) {	
unable to connect to remote is there a server running on port 

public void start() throws NioConnectionException {	_todos = new ArrayList<ChangeRequest>();	try {	init();	} catch (final ConnectException e) {	return;	} catch (final IOException e) {	
unable to initialize the threads 

public void start() throws NioConnectionException {	_todos = new ArrayList<ChangeRequest>();	try {	init();	} catch (final ConnectException e) {	return;	} catch (final IOException e) {	throw new NioConnectionException(e.getMessage(), e);	} catch (final Exception e) {	
unable to initialize the threads due to unknown exception 

public Boolean call() throws NioConnectionException {	while (_isRunning) {	try {	_selector.select(100);	final Set<SelectionKey> readyKeys = _selector.selectedKeys();	final Iterator<SelectionKey> i = readyKeys.iterator();	if (s_logger.isTraceEnabled()) {	
keys processing 

_selector.select(100);	final Set<SelectionKey> readyKeys = _selector.selectedKeys();	final Iterator<SelectionKey> i = readyKeys.iterator();	if (s_logger.isTraceEnabled()) {	}	while (i.hasNext()) {	final SelectionKey sk = i.next();	i.remove();	if (!sk.isValid()) {	if (s_logger.isTraceEnabled()) {	
selection key is invalid 

} else if (sk.isReadable()) {	read(sk);	} else if (sk.isWritable()) {	write(sk);	} else if (sk.isAcceptable()) {	accept(sk);	} else if (sk.isConnectable()) {	connect(sk);	}	}	
keys done processing 

write(sk);	} else if (sk.isAcceptable()) {	accept(sk);	} else if (sk.isConnectable()) {	connect(sk);	}	}	processTodos();	} catch (final ClosedSelectorException e) {	} catch (final IOException e) {	
agent will die due to this ioexception 

protected void accept(final SelectionKey key) throws IOException {	final ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel();	final SocketChannel socketChannel = serverSocketChannel.accept();	socketChannel.configureBlocking(false);	final Socket socket = socketChannel.socket();	socket.setKeepAlive(true);	if (s_logger.isTraceEnabled()) {	
connection accepted for 

final NioConnection nioConnection = this;	_sslHandshakeExecutor.submit(new Runnable() {	public void run() {	_selector.wakeup();	try {	sslEngine.beginHandshake();	if (!Link.doHandshake(socketChannel, sslEngine, false)) {	throw new IOException("SSL handshake timed out with " + socketChannel.getRemoteAddress());	}	if (s_logger.isTraceEnabled()) {	
ssl handshake done 

}	final InetSocketAddress saddr = (InetSocketAddress)socket.getRemoteSocketAddress();	final Link link = new Link(saddr, nioConnection);	link.setSSLEngine(sslEngine);	link.setKey(socketChannel.register(key.selector(), SelectionKey.OP_READ, link));	final Task task = _factory.create(Task.Type.CONNECT, link, null);	registerLink(saddr, link);	_executor.submit(task);	} catch (IOException e) {	if (s_logger.isTraceEnabled()) {	
connection closed due to failure 

}	closeAutoCloseable(socket, "accepting socket");	closeAutoCloseable(socketChannel, "accepting socketChannel");	} finally {	_selector.wakeup();	}	}	});	} catch (final Exception e) {	if (s_logger.isTraceEnabled()) {	
connection closed due to failure 

protected void terminate(final SelectionKey key) {	final Link link = (Link)key.attachment();	closeConnection(key);	if (link != null) {	link.terminated();	final Task task = _factory.create(Task.Type.DISCONNECT, link, null);	unregisterLink(link.getSocketAddress());	try {	_executor.submit(task);	} catch (final Exception e) {	
exception occurred when submitting the task 

protected void read(final SelectionKey key) throws IOException {	final Link link = (Link)key.attachment();	try {	final SocketChannel socketChannel = (SocketChannel)key.channel();	if (s_logger.isTraceEnabled()) {	
reading from 

protected void read(final SelectionKey key) throws IOException {	final Link link = (Link)key.attachment();	try {	final SocketChannel socketChannel = (SocketChannel)key.channel();	if (s_logger.isTraceEnabled()) {	}	final byte[] data = link.read(socketChannel);	if (data == null) {	if (s_logger.isTraceEnabled()) {	
packet is incomplete waiting for more 

final byte[] data = link.read(socketChannel);	if (data == null) {	if (s_logger.isTraceEnabled()) {	}	return;	}	final Task task = _factory.create(Task.Type.DATA, link, data);	try {	_executor.submit(task);	} catch (final Exception e) {	
exception occurred when submitting the task 

protected void processTodos() {	List<ChangeRequest> todos;	if (_todos.size() == 0) {	return;	}	synchronized (this) {	todos = _todos;	_todos = new ArrayList<ChangeRequest>();	}	if (s_logger.isTraceEnabled()) {	
todos processing 

key = (SelectionKey)todo.key;	if (key != null && key.isValid()) {	if (todo.att != null) {	key.attach(todo.att);	final Link link = (Link)todo.att;	link.setKey(key);	}	key.interestOps(todo.ops);	}	} catch (final CancelledKeyException e) {	
key has been cancelled 

} catch (final CancelledKeyException e) {	}	break;	case ChangeRequest.REGISTER: try {	key = ((SocketChannel)todo.key).register(_selector, todo.ops, todo.att);	if (todo.att != null) {	final Link link = (Link)todo.att;	link.setKey(key);	}	} catch (final ClosedChannelException e) {	
couldn t register socket 

case ChangeRequest.REGISTER: try {	key = ((SocketChannel)todo.key).register(_selector, todo.ops, todo.att);	if (todo.att != null) {	final Link link = (Link)todo.att;	link.setKey(key);	}	} catch (final ClosedChannelException e) {	try {	((SocketChannel)todo.key).close();	} catch (final IOException ignore) {	
ignored socket channel 

try {	((SocketChannel)todo.key).close();	} catch (final IOException ignore) {	} finally {	final Link link = (Link)todo.att;	link.terminated();	}	}	break;	case ChangeRequest.CLOSE: if (s_logger.isTraceEnabled()) {	
trying to close 

}	key = (SelectionKey)todo.key;	closeConnection(key);	if (key != null) {	final Link link = (Link)key.attachment();	if (link != null) {	link.terminated();	}	}	break;	
shouldn t be here 

if (key != null) {	final Link link = (Link)key.attachment();	if (link != null) {	link.terminated();	}	}	break;	throw new RuntimeException("Shouldn't be here");	}	}	
todos done processing 

protected void connect(final SelectionKey key) throws IOException {	final SocketChannel socketChannel = (SocketChannel)key.channel();	try {	socketChannel.finishConnect();	key.interestOps(SelectionKey.OP_READ);	final Socket socket = socketChannel.socket();	if (!socket.getKeepAlive()) {	socket.setKeepAlive(true);	}	if (s_logger.isDebugEnabled()) {	
connected to 

}	if (s_logger.isDebugEnabled()) {	}	final Link link = new Link((InetSocketAddress)socket.getRemoteSocketAddress(), this);	link.setKey(key);	key.attach(link);	final Task task = _factory.create(Task.Type.CONNECT, link, null);	try {	_executor.submit(task);	} catch (final Exception e) {	
exception occurred when submitting the task 

protected void scheduleTask(final Task task) {	try {	_executor.submit(task);	} catch (final Exception e) {	
exception occurred when submitting the task 

protected void write(final SelectionKey key) throws IOException {	final Link link = (Link)key.attachment();	try {	if (s_logger.isTraceEnabled()) {	
writing to 

protected void closeConnection(final SelectionKey key) {	if (key != null) {	final SocketChannel channel = (SocketChannel)key.channel();	key.cancel();	try {	if (channel != null) {	if (s_logger.isDebugEnabled()) {	
closing socket 

if (key != null) {	final SocketChannel channel = (SocketChannel)key.channel();	key.cancel();	try {	if (channel != null) {	if (s_logger.isDebugEnabled()) {	}	channel.close();	}	} catch (final IOException ignore) {	
ignored channel 

========================= cloudstack sample_2832 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all loadbalancerpolicy usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageLoadBalancerPolicyVO> usageLBs = s_usageLoadBalancerPolicyDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate, false, 0);	if (usageLBs.isEmpty()) {	
no load balancer usage events for this period 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long lbId, long zoneId) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long lbId, long zoneId) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating volume usage record for load balancer usage startdate enddate for account 

========================= cloudstack sample_2648 =========================

public Boolean fenceOff(VirtualMachine vm, Host host) {	if (host.getHypervisorType() != HypervisorType.Ovm) {	
don t know how to fence non ovm hosts 

continue;	}	if (h.getId() == host.getId()) {	continue;	}	FenceAnswer answer;	try {	answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	
moving on to the next host because is unavailable 

}	FenceAnswer answer;	try {	answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	}	continue;	} catch (OperationTimedoutException e) {	if (s_logger.isDebugEnabled()) {	
moving on to the next host because is unavailable 

} catch (OperationTimedoutException e) {	if (s_logger.isDebugEnabled()) {	}	continue;	}	if (answer != null && answer.getResult()) {	return true;	}	}	if (s_logger.isDebugEnabled()) {	
unable to fence off on 

========================= cloudstack sample_1121 =========================

public synchronized boolean processDisconnect(long agentId, Status state) {	
agent disconnected agent id state will notify waiters 

========================= cloudstack sample_4773 =========================

private boolean canHandle(Network config, List<LoadBalancingRule> rules) {	if ((config.getGuestType() != Network.GuestType.Isolated && config.getGuestType() != Network.GuestType.Shared) || config.getTrafficType() != TrafficType.Guest) {	
not handling network with type and traffic type 

private boolean canHandle(Network config, List<LoadBalancingRule> rules) {	if ((config.getGuestType() != Network.GuestType.Isolated && config.getGuestType() != Network.GuestType.Shared) || config.getTrafficType() != TrafficType.Guest) {	return false;	}	Map<Capability, String> lbCaps = this.getCapabilities().get(Service.Lb);	if (!lbCaps.isEmpty()) {	String schemeCaps = lbCaps.get(Capability.LbSchemes);	if (schemeCaps != null && rules != null && !rules.isEmpty()) {	for (LoadBalancingRule rule : rules) {	if (!schemeCaps.contains(rule.getScheme().toString())) {	
scheme is not supported by the provider 

public IpDeployer getIpDeployer(Network network) {	ExternalLoadBalancerDeviceVO lbDevice = getExternalLoadBalancerForNetwork(network);	if (lbDevice == null) {	
cannot find external load balanacer for network 

public IpDeployer getIpDeployer(Network network) {	ExternalLoadBalancerDeviceVO lbDevice = getExternalLoadBalancerForNetwork(network);	if (lbDevice == null) {	
make as dummy ip deployer since we likely met this when clean up resource after shutdown network 

========================= cloudstack sample_1571 =========================

} else if (RESPONSE_TYPE_XML.equalsIgnoreCase(responseType)){	resp.setContentType(XML_CONTENT_TYPE);	}	if (responseCode != null) {	resp.setStatus(responseCode);	}	addSecurityHeaders(resp);	resp.getWriter().print(response);	} catch (final IOException ioex) {	if (s_logger.isTraceEnabled()) {	
exception writing http response 

if (responseCode != null) {	resp.setStatus(responseCode);	}	addSecurityHeaders(resp);	resp.getWriter().print(response);	} catch (final IOException ioex) {	if (s_logger.isTraceEnabled()) {	}	} catch (final Exception ex) {	if (!(ex instanceof IllegalStateException)) {	
unknown exception writing http response 

========================= cloudstack sample_2865 =========================

public Answer execute(final CheckVirtualMachineCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	final String vmName = command.getVmName();	final PowerState powerState = citrixResourceBase.getVmState(conn, vmName);	final Integer vncPort = null;	if (powerState == PowerState.PowerOn) {	
the vm is in running state 

========================= cloudstack sample_1199 =========================

final HashMap<String, List<VmDiskStatsEntry>> vmDiskStatsNameMap = new HashMap<String, List<VmDiskStatsEntry>>();	final Connect conn = libvirtUtilitiesHelper.getConnection();	for (final String vmName : vmNames) {	try {	final List<VmDiskStatsEntry> statEntry = libvirtComputingResource.getVmDiskStat(conn, vmName);	if (statEntry == null) {	continue;	}	vmDiskStatsNameMap.put(vmName, statEntry);	} catch (LibvirtException e) {	
can t get vm disk stats continue 

final List<VmDiskStatsEntry> statEntry = libvirtComputingResource.getVmDiskStat(conn, vmName);	if (statEntry == null) {	continue;	}	vmDiskStatsNameMap.put(vmName, statEntry);	} catch (LibvirtException e) {	}	}	return new GetVmDiskStatsAnswer(command, "", command.getHostName(), vmDiskStatsNameMap);	} catch (final LibvirtException e) {	
can t get vm disk stats 

========================= cloudstack sample_1033 =========================

public Answer execute(final PrepareForMigrationCommand command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	final VirtualMachineTO vm = command.getVirtualMachine();	List<String[]> vmDataList = vm.getVmData();	String configDriveLabel = vm.getConfigDriveLabel();	if (configDriveLabel == null)  {	configDriveLabel = "config";	}	if (s_logger.isDebugEnabled()) {	
preparing host for migrating 

configDriveLabel = "config";	}	if (s_logger.isDebugEnabled()) {	}	final NicTO[] nics = vm.getNics();	try {	citrixResourceBase.prepareISO(conn, vm.getName(), vmDataList, configDriveLabel);	for (final NicTO nic : nics) {	citrixResourceBase.getNetwork(conn, nic);	}	
the vm is in migrating state 

if (s_logger.isDebugEnabled()) {	}	final NicTO[] nics = vm.getNics();	try {	citrixResourceBase.prepareISO(conn, vm.getName(), vmDataList, configDriveLabel);	for (final NicTO nic : nics) {	citrixResourceBase.getNetwork(conn, nic);	}	return new PrepareForMigrationAnswer(command);	} catch (final Exception e) {	
catch exception prepare for migration failed due to 

========================= cloudstack sample_1176 =========================

public HashMap<String, Pair<Long, Long>> sync(String vmName, Long vmId, String agentIp) {	HashMap<String, Pair<Long, Long>> states = new HashMap<String, Pair<Long, Long>>();	PostMethod post = new PostMethod(String.format("http: try {	post.addRequestHeader("command", "sync");	if (httpClient.executeMethod(post) != 200) {	
echoing baremetal security group agent on s got error s 

public HashMap<String, Pair<Long, Long>> sync(String vmName, Long vmId, String agentIp) {	HashMap<String, Pair<Long, Long>> states = new HashMap<String, Pair<Long, Long>>();	PostMethod post = new PostMethod(String.format("http: try {	post.addRequestHeader("command", "sync");	if (httpClient.executeMethod(post) != 200) {	} else {	String res = post.getResponseBodyAsString();	String[] rulelogs = res.split(",");	if (rulelogs.length != 6) {	
host s returns invalid security group sync document s reset rules 

String[] rulelogs = res.split(",");	if (rulelogs.length != 6) {	states.put(vmName, new Pair<Long, Long>(vmId, -1L));	return states;	}	Pair<Long, Long> p = new Pair<Long, Long>(Long.valueOf(rulelogs[1]), Long.valueOf(rulelogs[5]));	states.put(rulelogs[0], p);	return states;	}	} catch (SocketTimeoutException se) {	
unable to sync security group rules on host s s 

if (rulelogs.length != 6) {	states.put(vmName, new Pair<Long, Long>(vmId, -1L));	return states;	}	Pair<Long, Long> p = new Pair<Long, Long>(Long.valueOf(rulelogs[1]), Long.valueOf(rulelogs[5]));	states.put(rulelogs[0], p);	return states;	}	} catch (SocketTimeoutException se) {	} catch (Exception e) {	
unable to sync security group rules on host s 

try {	Thread.sleep(m);	count++;	} catch (InterruptedException e1) {	logger.warn("", e1);	break;	}	PostMethod post = new PostMethod(String.format("http: try {	post.addRequestHeader("command", "echo");	if (httpClient.executeMethod(post) != 200) {	
echoing baremetal security group agent on s got error s 

if (httpClient.executeMethod(post) != 200) {	} else {	ret = true;	}	break;	} catch (Exception e) {	if (count*m >= l) {	logger.debug(String.format("ping security group agent on vm[%s] timeout after %s minutes, starting vm failed, count=%s", agentIp, TimeUnit.MILLISECONDS.toSeconds(l), count));	break;	} else {	
having pinged security group agent on vm s s times continue to wait 

========================= cloudstack sample_912 =========================

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
networkelement implement traffic type 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (network.getTrafficType() == TrafficType.Guest) {	
ignore network 

if (vnModel == null) {	vnModel = new VirtualNetworkModel(network, network.getUuid(), _manager.getCanonicalName(network), network.getTrafficType());	vnModel.setProperties(_manager.getModelController(), network);	}	try {	if (!vnModel.verify(_manager.getModelController())) {	vnModel.update(_manager.getModelController());	}	_manager.getDatabase().getVirtualNetworks().add(vnModel);	} catch (Exception ex) {	
virtual network update 

public boolean prepare(Network network, NicProfile nicProfile, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
networkelement prepare traffic type 

public boolean prepare(Network network, NicProfile nicProfile, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (network.getTrafficType() == TrafficType.Guest) {	
ignore network 

public boolean prepare(Network network, NicProfile nicProfile, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (network.getTrafficType() == TrafficType.Guest) {	return true;	}	
network 

assert nic != null;	VMInterfaceModel vmiModel = vmModel.getVMInterface(nic.getUuid());	if (vmiModel == null) {	vmiModel = new VMInterfaceModel(nic.getUuid());	vmiModel.addToVirtualMachine(vmModel);	vmiModel.addToVirtualNetwork(vnModel);	}	try {	vmiModel.build(_manager.getModelController(), (VMInstanceVO)vm.getVirtualMachine(), nic);	} catch (IOException ex) {	
vm interface set 

}	InstanceIpModel ipModel = vmiModel.getInstanceIp();	if (ipModel == null) {	ipModel = new InstanceIpModel(vm.getInstanceName(), nic.getDeviceId());	ipModel.addToVMInterface(vmiModel);	}	ipModel.setAddress(nicProfile.getIPv4Address());	try {	vmModel.update(_manager.getModelController());	} catch (Exception ex) {	
virtual machine update 

public boolean release(Network network, NicProfile nicProfile, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	if (network.getTrafficType() == TrafficType.Guest) {	return true;	} else if (!_manager.isManagedPhysicalNetwork(network)) {	
release ignore network 

public boolean release(Network network, NicProfile nicProfile, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	if (network.getTrafficType() == TrafficType.Guest) {	return true;	} else if (!_manager.isManagedPhysicalNetwork(network)) {	return true;	}	NicVO nic = _nicDao.findById(nicProfile.getId());	assert nic != null;	VirtualMachineModel vmModel = _manager.getDatabase().lookupVirtualMachine(vm.getUuid());	if (vmModel == null) {	
vm not in local database 

assert nic != null;	VirtualMachineModel vmModel = _manager.getDatabase().lookupVirtualMachine(vm.getUuid());	if (vmModel == null) {	return true;	}	VMInterfaceModel vmiModel = vmModel.getVMInterface(nic.getUuid());	if (vmiModel != null) {	try {	vmiModel.destroy(_manager.getModelController());	} catch (IOException ex) {	
virtual machine interface delete 

public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	
networkelement shutdown 

public boolean destroy(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
networkelement destroy 

public boolean isReady(PhysicalNetworkServiceProvider provider) {	Map<String, String> serviceMap = ((ConfigurationServerImpl)_configServer).getServicesAndProvidersForNetwork( _manager.getRouterOffering().getId());	List<TrafficType> types = new ArrayList<TrafficType>();	types.add(TrafficType.Control);	types.add(TrafficType.Management);	types.add(TrafficType.Storage);	List<NetworkVO> systemNets = _manager.findSystemNetworks(types);	if (systemNets != null && !systemNets.isEmpty()) {	for (NetworkVO net: systemNets) {	
update system network service service provider 

List<TrafficType> types = new ArrayList<TrafficType>();	types.add(TrafficType.Control);	types.add(TrafficType.Management);	types.add(TrafficType.Storage);	List<NetworkVO> systemNets = _manager.findSystemNetworks(types);	if (systemNets != null && !systemNets.isEmpty()) {	for (NetworkVO net: systemNets) {	_networksDao.update(net.getId(), net, serviceMap);	}	} else {	
no system networks created yet 

_networksDao.update(net.getId(), net, serviceMap);	}	} else {	}	serviceMap = ((ConfigurationServerImpl)_configServer).getServicesAndProvidersForNetwork( _manager.getPublicRouterOffering().getId());	types = new ArrayList<TrafficType>();	types.add(TrafficType.Public);	systemNets = _manager.findSystemNetworks(types);	if (systemNets != null && !systemNets.isEmpty()) {	for (NetworkVO net: systemNets) {	
update system network service service provider 

}	serviceMap = ((ConfigurationServerImpl)_configServer).getServicesAndProvidersForNetwork( _manager.getPublicRouterOffering().getId());	types = new ArrayList<TrafficType>();	types.add(TrafficType.Public);	systemNets = _manager.findSystemNetworks(types);	if (systemNets != null && !systemNets.isEmpty()) {	for (NetworkVO net: systemNets) {	_networksDao.update(net.getId(), net, serviceMap);	}	} else {	
no system networks created yet 

public boolean shutdownProviderInstances(PhysicalNetworkServiceProvider provider, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
networkelement shutdown providerinstances 

public boolean verifyServicesCombination(Set<Service> services) {	
networkelement verifyservices 

public boolean verifyServicesCombination(Set<Service> services) {	
services 

public boolean applyIps(Network network, List<? extends PublicIpAddress> ipAddress, Set<Service> services) throws ResourceUnavailableException {	for (PublicIpAddress ip : ipAddress) {	if (ip.isSourceNat()) {	continue;	}	if (isFloatingIpCreate(ip)) {	if (_manager.createFloatingIp(ip)) {	
successfully created floating ip 

public boolean applyIps(Network network, List<? extends PublicIpAddress> ipAddress, Set<Service> services) throws ResourceUnavailableException {	for (PublicIpAddress ip : ipAddress) {	if (ip.isSourceNat()) {	continue;	}	if (isFloatingIpCreate(ip)) {	if (_manager.createFloatingIp(ip)) {	}	} else {	if (_manager.deleteFloatingIp(ip)) {	
successfully deleted floating ip 

========================= cloudstack sample_1875 =========================

_id = value != null ? Long.parseLong(value) : null;	s_logger.info("id is " + (_id != null ? _id : ""));	final Map<String, Object> params = PropertiesUtil.toMap(_shell.getProperties());	for (final Map.Entry<String, Object> cmdLineProp : _shell.getCmdLineProperties().entrySet()) {	params.put(cmdLineProp.getKey(), cmdLineProp.getValue());	}	if (!_resource.configure(getResourceName(), params)) {	throw new ConfigurationException("Unable to configure " + _resource.getName());	}	_connection = new NioClient("Agent", _shell.getHost(), _shell.getPort(), _shell.getWorkers(), this);	
adding shutdown hook 

public void start() {	if (!_resource.start()) {	
unable to start the resource 

public void start() {	if (!_resource.start()) {	throw new CloudRuntimeException("Unable to start the resource: " + _resource.getName());	}	try {	_connection.start();	} catch (final NioConnectionException e) {	
nio connection exception 

public void start() {	if (!_resource.start()) {	throw new CloudRuntimeException("Unable to start the resource: " + _resource.getName());	}	try {	_connection.start();	} catch (final NioConnectionException e) {	
attempted to connect to the server but received an unexpected exception trying again 

try {	_connection.start();	} catch (final NioConnectionException e) {	}	while (!_connection.isStartup()) {	_shell.getBackoffAlgorithm().waitBeforeRetry();	_connection = new NioClient("Agent", _shell.getHost(), _shell.getPort(), _shell.getWorkers(), this);	try {	_connection.start();	} catch (final NioConnectionException e) {	
nio connection exception 

try {	_connection.start();	} catch (final NioConnectionException e) {	}	while (!_connection.isStartup()) {	_shell.getBackoffAlgorithm().waitBeforeRetry();	_connection = new NioClient("Agent", _shell.getHost(), _shell.getPort(), _shell.getWorkers(), this);	try {	_connection.start();	} catch (final NioConnectionException e) {	
attempted to connect to the server but received an unexpected exception trying again 

public void stop(final String reason, final String detail) {	s_logger.info("Stopping the agent: Reason = " + reason + (detail != null ? ": Detail = " + detail : ""));	if (_connection != null) {	final ShutdownCommand cmd = new ShutdownCommand(reason, detail);	try {	if (_link != null) {	final Request req = new Request(_id != null ? _id : -1, -1, cmd, false);	_link.send(req.toBytes());	}	} catch (final ClosedChannelException e) {	
unable to send 

s_logger.info("Stopping the agent: Reason = " + reason + (detail != null ? ": Detail = " + detail : ""));	if (_connection != null) {	final ShutdownCommand cmd = new ShutdownCommand(reason, detail);	try {	if (_link != null) {	final Request req = new Request(_id != null ? _id : -1, -1, cmd, false);	_link.send(req.toBytes());	}	} catch (final ClosedChannelException e) {	} catch (final Exception e) {	
unable to send due to exception 

if (_connection != null) {	final ShutdownCommand cmd = new ShutdownCommand(reason, detail);	try {	if (_link != null) {	final Request req = new Request(_id != null ? _id : -1, -1, cmd, false);	_link.send(req.toBytes());	}	} catch (final ClosedChannelException e) {	} catch (final Exception e) {	}	
sending shutdown to management server 

if (_link != null) {	final Request req = new Request(_id != null ? _id : -1, -1, cmd, false);	_link.send(req.toBytes());	}	} catch (final ClosedChannelException e) {	} catch (final Exception e) {	}	try {	Thread.sleep(1000);	} catch (final InterruptedException e) {	
who the heck interrupted me here 

public void setId(final Long id) {	
set agent id 

public void scheduleWatch(final Link link, final Request request, final long delay, final long period) {	synchronized (_watchList) {	if (s_logger.isDebugEnabled()) {	
adding a watch list 

protected void cancelTasks() {	synchronized (_watchList) {	for (final WatchTask task : _watchList) {	task.cancel();	}	if (s_logger.isDebugEnabled()) {	
clearing watch list 

final StartupCommand[] startup = _resource.initialize();	if (startup != null) {	final Command[] commands = new Command[startup.length];	for (int i = 0; i < startup.length; i++) {	setupStartupCommand(startup[i]);	commands[i] = startup[i];	}	final Request request = new Request(_id != null ? _id : -1, -1, commands, false, false);	request.setSequence(getNextSequence());	if (s_logger.isDebugEnabled()) {	
sending startup 

commands[i] = startup[i];	}	final Request request = new Request(_id != null ? _id : -1, -1, commands, false, false);	request.setSequence(getNextSequence());	if (s_logger.isDebugEnabled()) {	}	lockStartupTask(link);	try {	link.send(request.toBytes());	} catch (final ClosedChannelException e) {	
unable to send reques 

protected void setupStartupCommand(final StartupCommand startup) {	InetAddress addr;	try {	addr = InetAddress.getLocalHost();	} catch (final UnknownHostException e) {	
unknow host 

}	}	link.close();	link.terminated();	setLink(null);	cancelTasks();	_resource.disconnected();	int inProgress = 0;	do {	_shell.getBackoffAlgorithm().waitBeforeRetry();	
lost connection to the server dealing with the remaining commands 

link.close();	link.terminated();	setLink(null);	cancelTasks();	_resource.disconnected();	int inProgress = 0;	do {	_shell.getBackoffAlgorithm().waitBeforeRetry();	inProgress = _inProgress.get();	if (inProgress > 0) {	
cannot connect because we still have commands in progress 

do {	_shell.getBackoffAlgorithm().waitBeforeRetry();	inProgress = _inProgress.get();	if (inProgress > 0) {	}	} while (inProgress > 0);	_connection.stop();	try {	_connection.cleanUp();	} catch (final IOException e) {	
fail to clean up old connection 

_connection.stop();	try {	_connection.cleanUp();	} catch (final IOException e) {	}	while (_connection.isStartup()) {	_shell.getBackoffAlgorithm().waitBeforeRetry();	}	_connection = new NioClient("Agent", _shell.getHost(), _shell.getPort(), _shell.getWorkers(), this);	do {	
reconnecting 

} catch (final IOException e) {	}	while (_connection.isStartup()) {	_shell.getBackoffAlgorithm().waitBeforeRetry();	}	_connection = new NioClient("Agent", _shell.getHost(), _shell.getPort(), _shell.getWorkers(), this);	do {	try {	_connection.start();	} catch (final NioConnectionException e) {	
nio connection exception 

} catch (final IOException e) {	}	while (_connection.isStartup()) {	_shell.getBackoffAlgorithm().waitBeforeRetry();	}	_connection = new NioClient("Agent", _shell.getHost(), _shell.getPort(), _shell.getWorkers(), this);	do {	try {	_connection.start();	} catch (final NioConnectionException e) {	
attempted to connect to the server but received an unexpected exception trying again 

_shell.getBackoffAlgorithm().waitBeforeRetry();	}	_connection = new NioClient("Agent", _shell.getHost(), _shell.getPort(), _shell.getWorkers(), this);	do {	try {	_connection.start();	} catch (final NioConnectionException e) {	}	_shell.getBackoffAlgorithm().waitBeforeRetry();	} while (!_connection.isStartup());	
connected to the server 

synchronized (this) {	if (_startup != null) {	_startup.cancel();	_startup = null;	} else {	cancelled = true;	}	}	final StartupAnswer startup = (StartupAnswer)answer;	if (!startup.getResult()) {	
not allowed to connect to the server 

_startup = null;	} else {	cancelled = true;	}	}	final StartupAnswer startup = (StartupAnswer)answer;	if (!startup.getResult()) {	System.exit(1);	}	if (cancelled) {	
threw away a startup answer because we re reconnecting 

final Command cmd = cmds[i];	Answer answer;	try {	if (cmd.getContextParam("logid") != null) {	MDC.put("logcontextid", cmd.getContextParam("logid"));	}	if (s_logger.isDebugEnabled()) {	if (!requestLogged) {	final String requestMsg = request.toString();	if (requestMsg != null) {	
request 

if (cmd.getContextParam("logid") != null) {	MDC.put("logcontextid", cmd.getContextParam("logid"));	}	if (s_logger.isDebugEnabled()) {	if (!requestLogged) {	final String requestMsg = request.toString();	if (requestMsg != null) {	}	requestLogged = true;	}	
processing command 

}	requestLogged = true;	}	}	if (cmd instanceof CronCommand) {	final CronCommand watch = (CronCommand)cmd;	scheduleWatch(link, request, (long)watch.getInterval() * 1000, watch.getInterval() * 1000);	answer = new Answer(cmd, true, null);	} else if (cmd instanceof ShutdownCommand) {	final ShutdownCommand shutdown = (ShutdownCommand)cmd;	
received shutdowncommand due to 

if (cmd instanceof CronCommand) {	final CronCommand watch = (CronCommand)cmd;	scheduleWatch(link, request, (long)watch.getInterval() * 1000, watch.getInterval() * 1000);	answer = new Answer(cmd, true, null);	} else if (cmd instanceof ShutdownCommand) {	final ShutdownCommand shutdown = (ShutdownCommand)cmd;	cancelTasks();	_reconnectAllowed = false;	answer = new Answer(cmd, true, null);	} else if (cmd instanceof ReadyCommand && ((ReadyCommand)cmd).getDetails() != null) {	
not ready to connect to mgt server 

answer = new Answer(cmd, true, null);	} else if (cmd instanceof ShutdownCommand) {	final ShutdownCommand shutdown = (ShutdownCommand)cmd;	cancelTasks();	_reconnectAllowed = false;	answer = new Answer(cmd, true, null);	} else if (cmd instanceof ReadyCommand && ((ReadyCommand)cmd).getDetails() != null) {	System.exit(1);	return;	} else if (cmd instanceof MaintainCommand) {	
received maintaincommand 

answer = null;	synchronized (_controlListeners) {	for (final IAgentControlListener listener : _controlListeners) {	answer = listener.processControlRequest(request, (AgentControlCommand)cmd);	if (answer != null) {	break;	}	}	}	if (answer == null) {	
no handler found to process cmd 

if (cmd instanceof ReadyCommand) {	processReadyCommand(cmd);	}	_inProgress.incrementAndGet();	try {	answer = _resource.executeRequest(cmd);	} finally {	_inProgress.decrementAndGet();	}	if (answer == null) {	
response unsupported command 

try {	answer = _resource.executeRequest(cmd);	} finally {	_inProgress.decrementAndGet();	}	if (answer == null) {	answer = Answer.createUnsupportedCommandAnswer(cmd);	}	}	} catch (final Throwable th) {	
caught 

if (s_logger.isDebugEnabled()) {	final String responseMsg = response.toString();	if (responseMsg != null) {	s_logger.debug(response.toString());	}	}	if (response != null) {	try {	link.send(response.toBytes());	} catch (final ClosedChannelException e) {	
unable to send response 

public void processResponse(final Response response, final Link link) {	final Answer answer = response.getAnswer();	if (s_logger.isDebugEnabled()) {	
received response 

public void processOtherTask(final Task task) {	final Object obj = task.get();	if (obj instanceof Response) {	if (System.currentTimeMillis() - _lastPingResponseTime > _pingInterval * _shell.getPingRetries()) {	
ping interval has gone past won t reconnect to mgt server as connection is still alive 

public void processOtherTask(final Task task) {	final Object obj = task.get();	if (obj instanceof Response) {	if (System.currentTimeMillis() - _lastPingResponseTime > _pingInterval * _shell.getPingRetries()) {	return;	}	final PingCommand ping = _resource.getCurrentStatus(getId());	final Request request = new Request(_id, -1, ping, false);	request.setSequence(getNextSequence());	if (s_logger.isDebugEnabled()) {	
sending ping 

}	final PingCommand ping = _resource.getCurrentStatus(getId());	final Request request = new Request(_id, -1, ping, false);	request.setSequence(getNextSequence());	if (s_logger.isDebugEnabled()) {	}	try {	task.getLink().send(request.toBytes());	setLastPingResponseTime();	} catch (final ClosedChannelException e) {	
unable to send request 

Answer answer = null;	_inProgress.incrementAndGet();	try {	answer = _resource.executeRequest(command);	} finally {	_inProgress.decrementAndGet();	}	if (answer != null) {	final Response response = new Response(req, answer);	if (s_logger.isDebugEnabled()) {	
watch sent 

} finally {	_inProgress.decrementAndGet();	}	if (answer != null) {	final Response response = new Response(req, answer);	if (s_logger.isDebugEnabled()) {	}	try {	task.getLink().send(response.toBytes());	} catch (final ClosedChannelException e) {	
unable to send response 

if (answer != null) {	final Response response = new Response(req, answer);	if (s_logger.isDebugEnabled()) {	}	try {	task.getLink().send(response.toBytes());	} catch (final ClosedChannelException e) {	}	}	} else {	
ignoring an unknown task 

final Request request = new Request(getId(), -1, new Command[] {cmd}, true, false);	request.setSequence(getNextSequence());	final AgentControlListener listener = new AgentControlListener(request);	registerControlListener(listener);	try {	postRequest(request);	synchronized (listener) {	try {	listener.wait(timeoutInMilliseconds);	} catch (final InterruptedException e) {	
sendrequest is interrupted exit waiting 

private void postRequest(final Request request) throws AgentControlChannelException {	if (_link != null) {	try {	_link.send(request.toBytes());	} catch (final ClosedChannelException e) {	
unable to post agent control reques 

protected void runInContext() {	if (s_logger.isTraceEnabled()) {	
scheduling Ping watch task 

protected void runInContext() {	if (s_logger.isTraceEnabled()) {	}	try {	if (_request instanceof Response) {	_ugentTaskPool.submit(new ServerHandler(Task.Type.OTHER, _link, _request));	} else {	_link.schedule(new ServerHandler(Task.Type.OTHER, _link, _request));	}	} catch (final ClosedChannelException e) {	
unable to schedule task because channel is closed 

public StartupTask(final Link link) {	
startup task created 

public synchronized boolean cancel() {	if (!cancelled) {	cancelled = true;	_startupWait = _startupWaitDefault;	
startup task cancelled 

protected synchronized void runInContext() {	if (!cancelled) {	if (s_logger.isInfoEnabled()) {	
the startup command is now cancelled 

} else if (task.getType() == Task.Type.DATA) {	Request request;	try {	request = Request.parse(task.getData());	if (request instanceof Response) {	processResponse((Response)request, task.getLink());	} else {	_executor.submit(new AgentRequestHandler(getType(), getLink(), request));	}	} catch (final ClassNotFoundException e) {	
unable to find this request 

Request request;	try {	request = Request.parse(task.getData());	if (request instanceof Response) {	processResponse((Response)request, task.getLink());	} else {	_executor.submit(new AgentRequestHandler(getType(), getLink(), request));	}	} catch (final ClassNotFoundException e) {	} catch (final Exception e) {	
error parsing task 

========================= cloudstack sample_2873 =========================

pstmt.setLong(1, zoneId);	ResultSet rs1 = pstmt.executeQuery();	if (rs1.next()) {	crtPbNtwk = true;	}	PreparedStatement pstmt2 = conn.prepareStatement("SELECT distinct tag FROM `cloud`.`network_tags` t JOIN `cloud`.`networks` n ON t.network_id = n.id WHERE n.data_center_id = ? and n.removed IS NULL");	pstmt2Close.add(pstmt2);	pstmt2.setLong(1, zoneId);	ResultSet rsTags = pstmt2.executeQuery();	if (rsTags.next()) {	
network tags are not empty might have to create more than one physical network 

}	addTrafficType(conn, physicalNetworkId, "Management", xenPrivateLabel, kvmPrivateLabel, vmwarePrivateLabel);	addTrafficType(conn, physicalNetworkId, "Storage", xenStorageLabel, null, null);	}	addTrafficType(conn, physicalNetworkId, "Guest", guestNetworkTag, kvmGuestLabel, vmwareGuestLabel);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, false);	PreparedStatement pstmt3 = conn.prepareStatement("SELECT network_id FROM `cloud`.`network_tags` where tag= ?");	pstmt3.setString(1,guestNetworkTag);	ResultSet rsNet = pstmt3.executeQuery();	
adding physicalnetwork to vlan 

}	addTrafficType(conn, physicalNetworkId, "Management", xenPrivateLabel, kvmPrivateLabel, vmwarePrivateLabel);	addTrafficType(conn, physicalNetworkId, "Storage", xenStorageLabel, null, null);	}	addTrafficType(conn, physicalNetworkId, "Guest", guestNetworkTag, kvmGuestLabel, vmwareGuestLabel);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, false);	PreparedStatement pstmt3 = conn.prepareStatement("SELECT network_id FROM `cloud`.`network_tags` where tag= ?");	pstmt3.setString(1,guestNetworkTag);	ResultSet rsNet = pstmt3.executeQuery();	
adding physicalnetwork to user ip address 

}	addTrafficType(conn, physicalNetworkId, "Management", xenPrivateLabel, kvmPrivateLabel, vmwarePrivateLabel);	addTrafficType(conn, physicalNetworkId, "Storage", xenStorageLabel, null, null);	}	addTrafficType(conn, physicalNetworkId, "Guest", guestNetworkTag, kvmGuestLabel, vmwareGuestLabel);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, false);	PreparedStatement pstmt3 = conn.prepareStatement("SELECT network_id FROM `cloud`.`network_tags` where tag= ?");	pstmt3.setString(1,guestNetworkTag);	ResultSet rsNet = pstmt3.executeQuery();	
adding physicalnetwork to networks 

addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, false);	PreparedStatement pstmt3 = conn.prepareStatement("SELECT network_id FROM `cloud`.`network_tags` where tag= ?");	pstmt3.setString(1,guestNetworkTag);	ResultSet rsNet = pstmt3.executeQuery();	while (rsNet.next()) {	Long networkId = rsNet.getLong(1);	addPhysicalNtwk_To_Ntwk_IP_Vlan(conn, physicalNetworkId, networkId);	}	pstmt3.close();	if (isFirstPhysicalNtwk) {	
adding physicalnetwork to default public network entries in vlan and user ip address 

}	pstmt3.close();	if (isFirstPhysicalNtwk) {	pstmt3 = conn.prepareStatement("SELECT id FROM `cloud`.`networks` where traffic_type = 'Public' and data_center_id = " + zoneId);	ResultSet rsPubNet = pstmt3.executeQuery();	if (rsPubNet.next()) {	Long publicNetworkId = rsPubNet.getLong(1);	addPhysicalNtwk_To_Ntwk_IP_Vlan(conn, physicalNetworkId, publicNetworkId);	}	pstmt3.close();	
adding physicalnetwork to op dc vnet alloc 

if (crtPbNtwk) {	addTrafficType(conn, physicalNetworkId, "Public", xenPublicLabel, kvmPublicLabel, vmwarePublicLabel);	} else {	s_logger.debug("Skip adding public traffic type to zone id=" + zoneId);	}	addTrafficType(conn, physicalNetworkId, "Management", xenPrivateLabel, kvmPrivateLabel, vmwarePrivateLabel);	addTrafficType(conn, physicalNetworkId, "Storage", xenStorageLabel, null, null);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, kvmGuestLabel, vmwareGuestLabel);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, false);	
adding physicalnetwork to op dc vnet alloc 

}	addTrafficType(conn, physicalNetworkId, "Management", xenPrivateLabel, kvmPrivateLabel, vmwarePrivateLabel);	addTrafficType(conn, physicalNetworkId, "Storage", xenStorageLabel, null, null);	addTrafficType(conn, physicalNetworkId, "Guest", xenGuestLabel, kvmGuestLabel, vmwareGuestLabel);	addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, false);	String updateVnet = "UPDATE `cloud`.`op_dc_vnet_alloc` SET physical_network_id = " + physicalNetworkId + " WHERE data_center_id = " + zoneId;	pstmtUpdate = conn.prepareStatement(updateVnet);	pstmtUpdate.executeUpdate();	pstmtUpdate.close();	
adding physicalnetwork to vlan 

addDefaultVRProvider(conn, physicalNetworkId, zoneId);	addDefaultSGProvider(conn, physicalNetworkId, zoneId, networkType, false);	String updateVnet = "UPDATE `cloud`.`op_dc_vnet_alloc` SET physical_network_id = " + physicalNetworkId + " WHERE data_center_id = " + zoneId;	pstmtUpdate = conn.prepareStatement(updateVnet);	pstmtUpdate.executeUpdate();	pstmtUpdate.close();	String updateVLAN = "UPDATE `cloud`.`vlan` SET physical_network_id = " + physicalNetworkId + " WHERE data_center_id = " + zoneId;	pstmtUpdate = conn.prepareStatement(updateVLAN);	pstmtUpdate.executeUpdate();	pstmtUpdate.close();	
adding physicalnetwork to user ip address 

pstmtUpdate.executeUpdate();	pstmtUpdate.close();	String updateVLAN = "UPDATE `cloud`.`vlan` SET physical_network_id = " + physicalNetworkId + " WHERE data_center_id = " + zoneId;	pstmtUpdate = conn.prepareStatement(updateVLAN);	pstmtUpdate.executeUpdate();	pstmtUpdate.close();	String updateUsrIp = "UPDATE `cloud`.`user_ip_address` SET physical_network_id = " + physicalNetworkId + " WHERE data_center_id = " + zoneId;	pstmtUpdate = conn.prepareStatement(updateUsrIp);	pstmtUpdate.executeUpdate();	pstmtUpdate.close();	
adding physicalnetwork to networks 

private void encryptData(Connection conn) {	
encrypting the data 

private void encryptData(Connection conn) {	encryptConfigValues(conn);	encryptHostDetails(conn);	encryptVNCPassword(conn);	encryptUserCredentials(conn);	encryptVPNPassword(conn);	
done encrypting the data 

private void encryptConfigValues(Connection conn) {	
encrypting config values 

throw new CloudRuntimeException("Unable encrypt configuration values ", e);	} finally {	try {	if (rs != null) {	rs.close();	}	if (pstmt != null) {	pstmt.close();	}	} catch (SQLException e) {	
ignored 

try {	if (rs != null) {	rs.close();	}	if (pstmt != null) {	pstmt.close();	}	} catch (SQLException e) {	}	}	
done encrypting config values 

private void encryptHostDetails(Connection conn) {	
encrypting host details 

pstmt.setLong(2, id);	pstmt.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt host_details values ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt host_details values ", e);	} finally {	TransactionLegacy.closePstmts(pstmt2Close);	}	
done encrypting host details 

private void encryptVNCPassword(Connection conn) {	
encrypting vm instance vnc password 

rs.close();	offset += 500;	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt vm_instance vnc_password ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt vm_instance vnc_password ", e);	} finally {	TransactionLegacy.closePstmts(pstmt2Close);	}	
done encrypting vm instance vnc password 

private void encryptUserCredentials(Connection conn) {	
encrypting user keys 

pstmt.setLong(2, id);	pstmt.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt user secret key ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt user secret key ", e);	} finally {	TransactionLegacy.closePstmts(pstmt2Close);	}	
done encrypting user keys 

private void encryptVPNPassword(Connection conn) {	
encrypting vpn users password 

pstmt.setLong(2, id);	pstmt.executeUpdate();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable encrypt vpn_users password ", e);	} catch (UnsupportedEncodingException e) {	throw new CloudRuntimeException("Unable encrypt vpn_users password ", e);	} finally {	TransactionLegacy.closePstmts(pstmt2Close);	}	
done encrypting vpn users password 

private void dropKeysIfExist(Connection conn) {	HashMap<String, List<String>> uniqueKeys = new HashMap<String, List<String>>();	List<String> keys = new ArrayList<String>();	keys.add("public_ip_address");	uniqueKeys.put("console_proxy", keys);	uniqueKeys.put("secondary_storage_vm", keys);	
dropping public ip address keys from cloud secondary storage vm and console proxy tables 

try {	pstmt = conn.prepareStatement("select value from `cloud`.`configuration` where name='allow.subdomain.network.access'");	pstmt2Close.add(pstmt);	rs = pstmt.executeQuery();	while (rs.next()) {	boolean subdomainAccess = Boolean.valueOf(rs.getString(1));	pstmt = conn.prepareStatement("UPDATE `cloud`.`domain_network_ref` SET subdomain_access=?");	pstmt2Close.add(pstmt);	pstmt.setBoolean(1, subdomainAccess);	pstmt.executeUpdate();	
successfully updated subdomain access field in network domain table with value 

protected void updateRouters(Connection conn) {	PreparedStatement pstmt = null;	try {	
updating domain router table 

pstmt = conn.prepareStatement("select ni.network_id, n.network_offering_id from `cloud`.`nics` ni, `cloud`.`networks` n where ni.instance_id in (select id from `cloud`.`domain_router` where is_redundant_router=1) and n.id=ni.network_id and n.traffic_type='Guest'");	pstmt2Close.add(pstmt);	rs = pstmt.executeQuery();	pstmt = conn.prepareStatement("select count(*) from `cloud`.`network_offerings`");	pstmt2Close.add(pstmt);	rs1 = pstmt.executeQuery();	long ntwkOffCount = 0;	while (rs1.next()) {	ntwkOffCount = rs1.getLong(1);	}	
have networkofferings 

s_logger.debug("Successfully updated network offering id=" + networkId + " with new network offering id " + newNetworkOfferingId);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to update redundant router networks", e);	} finally {	try {	pstmt = conn.prepareStatement("DROP TABLE `cloud`.`network_offerings2`");	pstmt.executeUpdate();	pstmt.close();	} catch (SQLException e) {	
ignored 

protected void updateHostCapacity(Connection conn) {	List<PreparedStatement> pstmt2Close = new ArrayList<PreparedStatement>();	PreparedStatement pstmt = null;	try {	
updating op host capacity table column capacity state 

List<PreparedStatement> pstmt2Close = new ArrayList<PreparedStatement>();	PreparedStatement pstmt = null;	ResultSet rs = null;	ResultSet rs1 = null;	try {	try {	pstmt = conn.prepareStatement("select switch_to_isolated from `cloud`.`networks`");	pstmt2Close.add(pstmt);	rs = pstmt.executeQuery();	} catch (Exception ex) {	
switch to isolated field is not present in networks table 

pstmt = conn.prepareStatement("select id, network_offering_id from `cloud`.`networks` where switch_to_isolated=1");	pstmt2Close.add(pstmt);	rs = pstmt.executeQuery();	pstmt = conn.prepareStatement("select count(*) from `cloud`.`network_offerings`");	pstmt2Close.add(pstmt);	rs1 = pstmt.executeQuery();	long ntwkOffCount = 0;	while (rs1.next()) {	ntwkOffCount = rs1.getLong(1);	}	
have networkofferings 

pstmt.setLong(2, networkId);	pstmt.executeUpdate();	}	s_logger.debug("Successfully updated network offering id=" + networkId + " with new network offering id " + newNetworkOfferingId);	}	try {	pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`networks` DROP COLUMN `switch_to_isolated`");	pstmt2Close.add(pstmt);	pstmt.executeUpdate();	} catch (SQLException ex) {	
caught sqlexception when trying to drop switch to isolated column 

} catch (SQLException ex) {	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to switch networks to isolated", e);	} finally {	try {	pstmt = conn.prepareStatement("DROP TABLE `cloud`.`network_offerings2`");	pstmt.executeUpdate();	pstmt.close();	} catch (SQLException e) {	
ignored 

throw new CloudRuntimeException("Unable to migrate the user_concentrated planner choice", e);	} finally {	try {	if (rs != null) {	rs.close();	}	if (pstmt != null) {	pstmt.close();	}	} catch (SQLException e) {	
ignored 

pstmt.executeUpdate();	}	s_logger.debug("Successfully updated network id=" + networkId + " with new network offering id " + newNetworkOfferingId);	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to switch networks to the new network offering", e);	} finally {	try (PreparedStatement dropStatement = conn.prepareStatement("DROP TABLE `cloud`.`network_offerings2`");){	dropStatement.executeUpdate();	} catch (SQLException e) {	
ignored 

========================= cloudstack sample_4227 =========================

public ExecutionResult executeInVR(String routerIp, String script, String args, Duration timeout) {	if (!script.contains(domRCloudPath)) {	script = domRCloudPath + "/" + script;	}	String cmd = script + " " + args;	
executeinvr via on 

if (!script.contains(domRCloudPath)) {	script = domRCloudPath + "/" + script;	}	String cmd = script + " " + args;	try {	CloudstackPlugin cSp = new CloudstackPlugin(c);	CloudstackPlugin.ReturnCode result;	result = cSp.domrExec(routerIp, cmd);	return new ExecutionResult(result.getRc(), result.getStdOut());	} catch (Exception e) {	
executeinvr failed via on 

public ExecutionResult createFileInVR(String routerIp, String path, String filename, String content) {	String error = null;	
createfileinvr via on content 

public ExecutionResult createFileInVR(String routerIp, String path, String filename, String content) {	String error = null;	try {	CloudstackPlugin cSp = new CloudstackPlugin(c);	boolean result = cSp.ovsDomrUploadFile(routerIp, path, filename, content);	return new ExecutionResult(result, "");	} catch (Exception e) {	error = e.getMessage();	
createfileinvr failed for in vr via 

========================= cloudstack sample_841 =========================

AutoScaleVmGroup vmGroup = null;	try {	success = _autoScaleService.configureAutoScaleVmGroup(this);	if (success) {	vmGroup = _entityMgr.findById(AutoScaleVmGroup.class, getEntityId());	AutoScaleVmGroupResponse responseObject = _responseGenerator.createAutoScaleVmGroupResponse(vmGroup);	setResponseObject(responseObject);	responseObject.setResponseName(getCommandName());	}	} catch (Exception ex) {	
failed to create autoscale vm group 

========================= cloudstack sample_3448 =========================

private static String getBase64EncodedRandomKey(int nBits) {	SecureRandom random;	try {	random = SecureRandom.getInstance("SHA1PRNG");	byte[] keyBytes = new byte[nBits / 8];	random.nextBytes(keyBytes);	return Base64.encodeBase64URLSafeString(keyBytes);	} catch (NoSuchAlgorithmException e) {	
unhandled exception 

========================= cloudstack sample_512 =========================

public boolean executeTest() {	int error = 0;	Element rootElement = getInputFile().get(0).getDocumentElement();	NodeList commandLst = rootElement.getElementsByTagName("command");	for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, getParam(), getCommands());	api.sendCommand(getClient(), null);	if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	
test case failed command that was supposed to fail passed the command was sent with the following url 

for (int i = 0; i < commandLst.getLength(); i++) {	Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, getParam(), getCommands());	api.sendCommand(getClient(), null);	if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	
test case passed 

Node fstNode = commandLst.item(i);	Element fstElmnt = (Element)fstNode;	ApiCommand api = new ApiCommand(fstElmnt, getParam(), getCommands());	api.sendCommand(getClient(), null);	if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	
test case failed empty response was expected command was sent with url 

error++;	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() == 200)) {	if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	}	} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(getParam()) == false) {	
exiting the test command didn t return parameters needed for the future use the command was sent with url 

if (api.getResponseType() == ResponseType.EMPTY) {	if (api.isEmpty() == true) {	} else {	}	} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	
test case passed 

} else {	if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	
test case failed command was sent with url 

if (api.isEmpty() != false) s_logger.error("Test case " + api.getTestCaseInfo() + " failed. Non-empty response was expected. Command was sent with url " + api.getUrl());	else {	if (api.setParam(getParam()) == false) {	return false;	} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	
the command is required for the future use so exiging 

} else if (api.getTestCaseInfo() != null) {	}	}	}	} else if ((api.getResponseType() != ResponseType.ERROR) && (api.getResponseCode() != 200)) {	if (api.getRequired() == true) {	return false;	}	error++;	} else if (api.getTestCaseInfo() != null) {	
test case passed 

========================= cloudstack sample_457 =========================

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (offering.isSystemOnly() || !canHandle(dest, offering.getTrafficType(), network.getGuestType())) {	
baremetaldhcpelement can not handle networkoffering 

========================= cloudstack sample_904 =========================

final Network nw = citrixResourceBase.setupvSwitchNetwork(conn);	bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_create_gre", "bridge", bridge, "remoteIP", command.getRemoteIp(), "greKey", command.getKey(), "from", Long.toString(command.getFrom()), "to", Long.toString(command.getTo()));	final String[] res = result.split(":");	if (res.length != 2 || res.length == 2 && res[1].equalsIgnoreCase("[]")) {	return new OvsCreateGreTunnelAnswer(command, false, result, citrixResourceBase.getHost().getIp(), bridge);	} else {	return new OvsCreateGreTunnelAnswer(command, true, result, citrixResourceBase.getHost().getIp(), bridge, Integer.parseInt(res[1]));	}	} catch (final BadServerResponse e) {	
an error occurred while creating a gre tunnel to on host 

bridge = nw.getBridge(conn);	final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_create_gre", "bridge", bridge, "remoteIP", command.getRemoteIp(), "greKey", command.getKey(), "from", Long.toString(command.getFrom()), "to", Long.toString(command.getTo()));	final String[] res = result.split(":");	if (res.length != 2 || res.length == 2 && res[1].equalsIgnoreCase("[]")) {	return new OvsCreateGreTunnelAnswer(command, false, result, citrixResourceBase.getHost().getIp(), bridge);	} else {	return new OvsCreateGreTunnelAnswer(command, true, result, citrixResourceBase.getHost().getIp(), bridge, Integer.parseInt(res[1]));	}	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	
an error occurred while creating a gre tunnel to on host 

final String result = citrixResourceBase.callHostPlugin(conn, "ovsgre", "ovs_create_gre", "bridge", bridge, "remoteIP", command.getRemoteIp(), "greKey", command.getKey(), "from", Long.toString(command.getFrom()), "to", Long.toString(command.getTo()));	final String[] res = result.split(":");	if (res.length != 2 || res.length == 2 && res[1].equalsIgnoreCase("[]")) {	return new OvsCreateGreTunnelAnswer(command, false, result, citrixResourceBase.getHost().getIp(), bridge);	} else {	return new OvsCreateGreTunnelAnswer(command, true, result, citrixResourceBase.getHost().getIp(), bridge, Integer.parseInt(res[1]));	}	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
an error occurred while creating a gre tunnel to on host 

========================= cloudstack sample_1160 =========================

public void execute() {	try {	boolean result = _s2sVpnService.deleteVpnConnection(this);	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to delete site to site VPN connection");	}	} catch (ResourceUnavailableException ex) {	
exception 

========================= cloudstack sample_3389 =========================

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	if (s_logger.isInfoEnabled()) {	
we currently don t handle conversion from to ova 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	if (s_logger.isInfoEnabled()) {	}	return null;	}	
template processing templatepath templatename 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	if (s_logger.isInfoEnabled()) {	}	return null;	}	String templateFilePath = templatePath + File.separator + templateName + "." + ImageFormat.OVA.getFileExtension();	if (!_storage.exists(templateFilePath)) {	if (s_logger.isInfoEnabled()) {	
unable to find the vmware template file 

if (s_logger.isInfoEnabled()) {	}	return null;	}	String templateFilePath = templatePath + File.separator + templateName + "." + ImageFormat.OVA.getFileExtension();	if (!_storage.exists(templateFilePath)) {	if (s_logger.isInfoEnabled()) {	}	return null;	}	
template processing untar ova package templatepath templatename 

return null;	}	String templateFileFullPath = templatePath + File.separator + templateName + "." + ImageFormat.OVA.getFileExtension();	File templateFile = new File(templateFileFullPath);	Script command = new Script("tar", 0, s_logger);	command.add("--no-same-owner");	command.add("-xf", templateFileFullPath);	command.setWorkDir(templateFile.getParent());	String result = command.execute();	if (result != null) {	
failed to untar ova package due to templatepath templatename 

public long getVirtualSize(File file) {	try {	long size = getTemplateVirtualSize(file.getParent(), file.getName());	return size;	} catch (Exception e) {	
ignored failed to get virtual template size for ova 

========================= cloudstack sample_396 =========================

public static void closeAutoCloseable(AutoCloseable ac, String message) {	try {	if (ac != null) {	ac.close();	}	} catch (Exception e) {	
ignored 

========================= cloudstack sample_2824 =========================

public Answer execute(final OvsDestroyTunnelCommand command, final LibvirtComputingResource libvirtComputingResource) {	try {	if (!libvirtComputingResource.findOrCreateTunnelNetwork(command.getBridgeName())) {	
unable to find tunnel network for gre key 

scriptCommand.add("destroy_tunnel");	scriptCommand.add("--bridge", command.getBridgeName());	scriptCommand.add("--iface_name", command.getInPortName());	final String result = scriptCommand.execute();	if (result == null) {	return new Answer(command, true, result);	} else {	return new Answer(command, false, result);	}	} catch (final Exception e) {	
caught execption when destroy ovs tunnel 

========================= cloudstack sample_1072 =========================

podVlanSearch.and("type", podVlanSearch.entity().getVlanType(), Op.EQ);	podVlanSearch.and("networkId", podVlanSearch.entity().getNetworkId(), Op.EQ);	final SearchBuilder<PodVlanMapVO> podVlanMapSB = _podVlanMapDao.createSearchBuilder();	podVlanMapSB.and("podId", podVlanMapSB.entity().getPodId(), Op.EQ);	AssignIpAddressFromPodVlanSearch.join("podVlanMapSB", podVlanMapSB, podVlanMapSB.entity().getVlanDbId(), AssignIpAddressFromPodVlanSearch.entity().getVlanId(), JoinType.INNER);	AssignIpAddressFromPodVlanSearch.join("vlan", podVlanSearch, podVlanSearch.entity().getId(), AssignIpAddressFromPodVlanSearch.entity().getVlanId(), JoinType.INNER);	AssignIpAddressFromPodVlanSearch.done();	_executor = Executors.newScheduledThreadPool(1, new NamedThreadFactory("Network-Scavenger"));	_agentMgr.registerForHostEvents(this, true, false, true);	Network.State.getStateMachine().registerListener(new NetworkStateListener(_configDao));	
network manager is configured 

public boolean start() {	final int netGcInterval = NumbersUtil.parseInt(_configDao.getValue(NetworkGcInterval.key()), 60);	
network manager will run the networkgarbagecollector every seconds 

public List<? extends Network> setupNetwork(final Account owner, final NetworkOffering offering, final Network predefined, final DeploymentPlan plan, final String name, final String displayText, final boolean errorIfAlreadySetup, final Long domainId, final ACLType aclType, final Boolean subdomainAccess, final Long vpcId, final Boolean isDisplayNetworkEnabled) throws ConcurrentOperationException {	final Account locked = _accountDao.acquireInLockTable(owner.getId());	if (locked == null) {	throw new ConcurrentOperationException("Unable to acquire lock on " + owner);	}	try {	if (predefined == null || offering.getTrafficType() != TrafficType.Guest && predefined.getCidr() == null && predefined.getBroadcastUri() == null && !(predefined .getBroadcastDomainType() == BroadcastDomainType.Vlan || predefined.getBroadcastDomainType() == BroadcastDomainType.Lswitch || predefined .getBroadcastDomainType() == BroadcastDomainType.Vxlan)) {	final List<NetworkVO> configs = _networksDao.listBy(owner.getId(), offering.getId(), plan.getDataCenterId());	if (configs.size() > 0) {	if (s_logger.isDebugEnabled()) {	
found existing network configuration for offering 

}	});	}	if (networks.size() < 1) {	final CloudRuntimeException ex = new CloudRuntimeException("Unable to convert network offering with specified id to network profile");	ex.addProxyObject(offering.getUuid(), "offeringId");	throw ex;	}	return networks;	} finally {	
releasing lock for 

if (defaultNic != null) {	throw new IllegalArgumentException("You cannot specify two nics as default nics: nic 1 = " + defaultNic + "; nic 2 = " + vmNic);	}	defaultNic = vmNic;	}	nics.add(vmNic);	vm.addNic(vmNic);	}	}	if (nics.size() != size) {	
number of nics doesn t match number of requested nics 

public Pair<NicProfile, Integer> allocateNic(final NicProfile requested, final Network network, final Boolean isDefaultNic, int deviceId, final VirtualMachineProfile vm) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException, ConcurrentOperationException {	final NetworkVO ntwkVO = _networksDao.findById(network.getId());	
allocating nic for vm in network with requested profile 

implemented.set(guru, network);	return implemented;	}	network = _networksDao.acquireInLockTable(networkId, NetworkLockTimeout.value());	if (network == null) {	final ConcurrentOperationException ex = new ConcurrentOperationException("Unable to acquire network configuration");	ex.addProxyObject(_entityMgr.findById(Network.class, networkId).getUuid());	throw ex;	}	if (s_logger.isDebugEnabled()) {	
lock is acquired for network id as a part of network implement 

}	if (s_logger.isDebugEnabled()) {	}	try {	if (isNetworkImplemented(network)) {	s_logger.debug("Network id=" + networkId + " is already implemented");	implemented.set(guru, network);	return implemented;	}	if (s_logger.isDebugEnabled()) {	
asking to implement 

stateTransitTo(network, Event.OperationSucceeded);	}	network.setRestartRequired(false);	_networksDao.update(network.getId(), network);	implemented.set(guru, network);	return implemented;	} catch (final NoTransitionException e) {	s_logger.error(e.getMessage());	return null;	} catch (final CloudRuntimeException e) {	
caught exception 

_networksDao.update(network.getId(), network);	implemented.set(guru, network);	return implemented;	} catch (final NoTransitionException e) {	s_logger.error(e.getMessage());	return null;	} catch (final CloudRuntimeException e) {	return null;	} finally {	if (implemented.first() == null) {	
cleaning up because we re unable to implement the network 

_networksDao.update(networkId, network);	} else {	stateTransitTo(network, Event.OperationFailed);	}	} catch (final NoTransitionException e) {	s_logger.error(e.getMessage());	}	try {	shutdownNetwork(networkId, context, false);	} catch (final Exception e) {	
exception caught while shutting down a network as part of a failed implementation 

} catch (final NoTransitionException e) {	s_logger.error(e.getMessage());	}	try {	shutdownNetwork(networkId, context, false);	} catch (final Exception e) {	}	}	_networksDao.releaseFromLockTable(networkId);	if (s_logger.isDebugEnabled()) {	
lock is released for network id as a part of network implement 

public void implementNetworkElementsAndResources(final DeployDestination dest, final ReservationContext context, final Network network, final NetworkOffering offering) throws ConcurrentOperationException, InsufficientAddressCapacityException, ResourceUnavailableException, InsufficientCapacityException {	final boolean sharedSourceNat = offering.getSharedSourceNat();	final DataCenter zone = _dcDao.findById(network.getDataCenterId());	if (!sharedSourceNat && _networkModel.areServicesSupportedInNetwork(network.getId(), Service.SourceNat) && (network.getGuestType() == Network.GuestType.Isolated || network.getGuestType() == Network.GuestType.Shared && zone.getNetworkType() == NetworkType.Advanced)) {	List<IPAddressVO> ips = null;	final Account owner = _entityMgr.findById(Account.class, network.getAccountId());	if (network.getVpcId() != null) {	ips = _ipAddressDao.listByAssociatedVpc(network.getVpcId(), true);	if (ips.isEmpty()) {	final Vpc vpc = _vpcMgr.getActiveVpc(network.getVpcId());	
creating a source nat ip for vpc 

final Account owner = _entityMgr.findById(Account.class, network.getAccountId());	if (network.getVpcId() != null) {	ips = _ipAddressDao.listByAssociatedVpc(network.getVpcId(), true);	if (ips.isEmpty()) {	final Vpc vpc = _vpcMgr.getActiveVpc(network.getVpcId());	_vpcMgr.assignSourceNatIpAddressToVpc(owner, vpc);	}	} else {	ips = _ipAddressDao.listByAssociatedNetwork(network.getId(), true);	if (ips.isEmpty()) {	
creating a source nat ip for network 

}	}	}	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (!_networkModel.isProviderEnabledInPhysicalNetwork(_networkModel.getPhysicalNetworkId(network), element.getProvider().getName())) {	throw new CloudRuntimeException("Service provider " + element.getProvider().getName() + " either doesn't exist or is not enabled in physical network id: " + network.getPhysicalNetworkId());	}	if (s_logger.isDebugEnabled()) {	
asking to implemenet 

throw ex;	}	}	}	for (final NetworkElement element : networkElements) {	if (element instanceof AggregatedCommandExecutor && providersToImplement.contains(element.getProvider())) {	((AggregatedCommandExecutor)element).prepareAggregatedExecution(network, dest);	}	}	try {	
reprogramming network as a part of network implement 

}	}	}	for (final NetworkElement element : networkElements) {	if (element instanceof AggregatedCommandExecutor && providersToImplement.contains(element.getProvider())) {	((AggregatedCommandExecutor)element).prepareAggregatedExecution(network, dest);	}	}	try {	if (!reprogramNetworkRules(network.getId(), CallContext.current().getCallingAccount(), network)) {	
failed to re program the network as a part of network implement 

}	try {	if (!reprogramNetworkRules(network.getId(), CallContext.current().getCallingAccount(), network)) {	final ResourceUnavailableException ex = new ResourceUnavailableException("Unable to apply network rules as a part of network " + network + " implement", DataCenter.class, network.getDataCenterId());	ex.addProxyObject(_entityMgr.findById(DataCenter.class, network.getDataCenterId()).getUuid());	throw ex;	}	for (final NetworkElement element : networkElements) {	if (element instanceof AggregatedCommandExecutor && providersToImplement.contains(element.getProvider())) {	if (!((AggregatedCommandExecutor)element).completeAggregatedExecution(network, dest)) {	
failed to re program the network as a part of network implement due to aggregated commands execution failure 

final NetworkOfferingVO offering = _networkOfferingDao.findById(network.getNetworkOfferingId());	final DataCenter zone = _dcDao.findById(network.getDataCenterId());	if (_networkModel.areServicesSupportedInNetwork(network.getId(), Service.Firewall) && _networkModel.areServicesSupportedInNetwork(network.getId(), Service.Firewall) && (network.getGuestType() == Network.GuestType.Isolated || network.getGuestType() == Network.GuestType.Shared && zone.getNetworkType() == NetworkType.Advanced)) {	_firewallMgr.applyDefaultEgressFirewallRule(network.getId(), offering.getEgressDefaultPolicy(), true);	}	if (!_firewallMgr.applyFirewallRules(firewallEgressRulesToApply, false, caller)) {	s_logger.warn("Failed to reapply firewall Egress rule(s) as a part of network id=" + networkId + " restart");	success = false;	}	if (!_ipAddrMgr.applyIpAssociations(network, false)) {	
failed to apply ip addresses as a part of network id restart 

_firewallMgr.applyDefaultEgressFirewallRule(network.getId(), offering.getEgressDefaultPolicy(), true);	}	if (!_firewallMgr.applyFirewallRules(firewallEgressRulesToApply, false, caller)) {	s_logger.warn("Failed to reapply firewall Egress rule(s) as a part of network id=" + networkId + " restart");	success = false;	}	if (!_ipAddrMgr.applyIpAssociations(network, false)) {	success = false;	}	if (!_rulesMgr.applyStaticNatsForNetwork(networkId, false, caller)) {	
failed to apply static nats a part of network id restart 

nic.setState(Nic.State.Reserved);	updateNic(nic, network.getId(), 1);	}	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (!_networkModel.isProviderEnabledInPhysicalNetwork(_networkModel.getPhysicalNetworkId(network), element.getProvider().getName())) {	throw new CloudRuntimeException("Service provider " + element.getProvider().getName() + " either doesn't exist or is not enabled in physical network id: " + network.getPhysicalNetworkId());	}	if (s_logger.isDebugEnabled()) {	
asking to prepare for 

}	final List<NicVO> nics = _nicDao.listByVmId(vm.getId());	final ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), null, null);	for (final NicVO nic : nics) {	final NetworkVO network = _networksDao.findById(nic.getNetworkId());	final Integer networkRate = _networkModel.getNetworkRate(network.getId(), vm.getId());	final NetworkGuru guru = AdapterBase.getAdapterByName(networkGurus, network.getGuruName());	final NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), networkRate, _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vm.getHypervisorType(), network));	if (guru instanceof NetworkMigrationResponder) {	if (!((NetworkMigrationResponder)guru).prepareMigration(profile, network, vm, dest, context)) {	
networkguru prepareformigration failed 

}	}	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (!_networkModel.isProviderEnabledInPhysicalNetwork(_networkModel.getPhysicalNetworkId(network), element.getProvider().getName())) {	throw new CloudRuntimeException("Service provider " + element.getProvider().getName() + " either doesn't exist or is not enabled in physical network id: " + network.getPhysicalNetworkId());	}	if (element instanceof NetworkMigrationResponder) {	if (!((NetworkMigrationResponder)element).prepareMigration(profile, network, vm, dest, context)) {	
networkelement prepareformigration failed 

for (final NicVO nic : nics) {	final NetworkVO network = _networksDao.findById(nic.getNetworkId());	if(network.getTrafficType().equals(TrafficType.Guest) && network.getGuestType().equals(GuestType.Isolated)){	guestNetworkId = network.getId();	}	final Integer networkRate = _networkModel.getNetworkRate(network.getId(), vm.getId());	final NetworkGuru guru = AdapterBase.getAdapterByName(networkGurus, network.getGuruName());	final NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), networkRate, _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag(vm.getHypervisorType(), network));	if(guru instanceof NetworkMigrationResponder){	if(!((NetworkMigrationResponder) guru).prepareMigration(profile, network, vm, dest, context)){	
networkguru prepareformigration failed 

}	}	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (!_networkModel.isProviderEnabledInPhysicalNetwork(_networkModel.getPhysicalNetworkId(network), element.getProvider().getName())) {	throw new CloudRuntimeException("Service provider " + element.getProvider().getName() + " either doesn't exist or is not enabled in physical network id: " + network.getPhysicalNetworkId());	}	if(element instanceof NetworkMigrationResponder){	if(!((NetworkMigrationResponder) element).prepareMigration(profile, network, vm, dest, context)){	
networkelement prepareformigration failed 

}	final List<String> addedURIs = new ArrayList<String>();	if(guestNetworkId != null){	final List<IPAddressVO> publicIps = _ipAddressDao.listByAssociatedNetwork(guestNetworkId, null);	for (final IPAddressVO userIp : publicIps){	final PublicIp publicIp = PublicIp.createFromAddrAndVlan(userIp, _vlanDao.findById(userIp.getVlanId()));	final URI broadcastUri = BroadcastDomainType.Vlan.toUri(publicIp.getVlanTag());	final long ntwkId = publicIp.getNetworkId();	final Nic nic = _nicDao.findByNetworkIdInstanceIdAndBroadcastUri(ntwkId, vm.getId(), broadcastUri.toString());	if(nic == null && !addedURIs.contains(broadcastUri.toString())){	
creating nic profile for migration broadcasturi networkid vm 

}	}	}	if (networkToRelease != null) {	final Network network = networkToRelease.first();	final NicProfile profile = networkToRelease.second();	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (s_logger.isDebugEnabled()) {	
asking to release 

public void cleanupNics(final VirtualMachineProfile vm) {	if (s_logger.isDebugEnabled()) {	
cleaning network for vm 

protected void removeNic(final VirtualMachineProfile vm, final NicVO nic) {	if (nic.getReservationStrategy() == Nic.ReservationStrategy.Start && nic.getState() != Nic.State.Allocated) {	try {	releaseNic(vm, nic.getId());	} catch (final Exception ex) {	
failed to release nic as part of remove operation due to 

}	nic.setState(Nic.State.Deallocating);	_nicDao.update(nic.getId(), nic);	final NetworkVO network = _networksDao.findById(nic.getNetworkId());	final NicProfile profile = new NicProfile(nic, network, null, null, null, _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag( vm.getHypervisorType(), network));	if (nic.getReservationStrategy() == Nic.ReservationStrategy.Create) {	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (s_logger.isDebugEnabled()) {	
asking to release 

final NicProfile profile = new NicProfile(nic, network, null, null, null, _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag( vm.getHypervisorType(), network));	if (nic.getReservationStrategy() == Nic.ReservationStrategy.Create) {	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (s_logger.isDebugEnabled()) {	}	try {	element.release(network, profile, vm, null);	} catch (final ConcurrentOperationException ex) {	
release failed during the nic removenic due to 

if (nic.getReservationStrategy() == Nic.ReservationStrategy.Create) {	final List<Provider> providersToImplement = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToImplement.contains(element.getProvider())) {	if (s_logger.isDebugEnabled()) {	}	try {	element.release(network, profile, vm, null);	} catch (final ConcurrentOperationException ex) {	} catch (final ResourceUnavailableException ex) {	
release failed during the nic removenic due to 

final DhcpServiceProvider dhcpServiceProvider = getDhcpServiceProvider(network);	if (dhcpServiceProvider != null && isDhcpAccrossMultipleSubnetsSupported(dhcpServiceProvider)) {	removeDhcpServiceInSubnet(nic);	}	}	final NetworkGuru guru = AdapterBase.getAdapterByName(networkGurus, network.getGuruName());	guru.deallocate(network, profile, vm);	_nicDao.remove(nic.getId());	s_logger.debug("Removed nic id=" + nic.getId());	if (!removeVmSecondaryIpsOfNic(nic.getId())) {	
removing nic secondary ip addreses failed 

if (ipAlias != null) {	ipAlias.setState(NicIpAlias.State.revoked);	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	_nicIpAliasDao.update(ipAlias.getId(), ipAlias);	final IPAddressVO aliasIpaddressVo = _publicIpAddressDao.findByIpAndSourceNetworkId(ipAlias.getNetworkId(), ipAlias.getIp4Address());	_publicIpAddressDao.unassignIpAddress(aliasIpaddressVo.getId());	}	});	if (!dhcpServiceProvider.removeDhcpSupportForSubnet(network)) {	
failed to remove the ip alias on the router marking it as removed in db and freed the allocated ip 

public void doInTransactionWithoutResult(final TransactionStatus status) {	_nicIpAliasDao.update(ipAlias.getId(), ipAlias);	final IPAddressVO aliasIpaddressVo = _publicIpAddressDao.findByIpAndSourceNetworkId(ipAlias.getNetworkId(), ipAlias.getIp4Address());	_publicIpAddressDao.unassignIpAddress(aliasIpaddressVo.getId());	}	});	if (!dhcpServiceProvider.removeDhcpSupportForSubnet(network)) {	}	}	} catch (final ResourceUnavailableException e) {	
unable to delete the ip alias due to unable to contact the virtualrouter 

public Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk, final long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr, final Boolean isDisplayNetworkEnabled, final String isolatedPvlan) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {	final NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);	if (ntwkOff.getTrafficType() != TrafficType.Guest) {	
only guest networks can be created using this method 

public boolean shutdownNetwork(final long networkId, final ReservationContext context, final boolean cleanupElements) {	NetworkVO network = _networksDao.findById(networkId);	if (network.getState() == Network.State.Allocated) {	
network is already shutdown 

public boolean shutdownNetwork(final long networkId, final ReservationContext context, final boolean cleanupElements) {	NetworkVO network = _networksDao.findById(networkId);	if (network.getState() == Network.State.Allocated) {	return true;	}	if (network.getState() != Network.State.Implemented && network.getState() != Network.State.Shutdown) {	
network is not implemented 

NetworkVO network = _networksDao.findById(networkId);	if (network.getState() == Network.State.Allocated) {	return true;	}	if (network.getState() != Network.State.Implemented && network.getState() != Network.State.Shutdown) {	return false;	}	try {	network = _networksDao.acquireInLockTable(networkId, NetworkLockTimeout.value());	if (network == null) {	
unable to acquire lock for the network as a part of network shutdown 

}	if (network.getState() != Network.State.Implemented && network.getState() != Network.State.Shutdown) {	return false;	}	try {	network = _networksDao.acquireInLockTable(networkId, NetworkLockTimeout.value());	if (network == null) {	return false;	}	if (s_logger.isDebugEnabled()) {	
lock is acquired for network as a part of network shutdown 

return false;	}	try {	network = _networksDao.acquireInLockTable(networkId, NetworkLockTimeout.value());	if (network == null) {	return false;	}	if (s_logger.isDebugEnabled()) {	}	if (network.getState() == Network.State.Allocated) {	
network is already shutdown 

network = _networksDao.acquireInLockTable(networkId, NetworkLockTimeout.value());	if (network == null) {	return false;	}	if (s_logger.isDebugEnabled()) {	}	if (network.getState() == Network.State.Allocated) {	return true;	}	if (network.getState() != Network.State.Implemented && network.getState() != Network.State.Shutdown) {	
network is not implemented 

result = false;	}	return result;	}	});	return result;	} finally {	if (network != null) {	_networksDao.releaseFromLockTable(network.getId());	if (s_logger.isDebugEnabled()) {	
lock is released for network as a part of network shutdown 

for (final Provider provider: providersToShutdown) {	if (provider.cleanupNeededOnShutdown()) {	cleanupNeeded = true;	break;	}	}	if (cleanupNeeded) {	cleanupResult = shutdownNetworkResources(network.getId(), context.getAccount(), context.getCaller().getId());	}	} catch (final Exception ex) {	
shutdownnetworkrules failed during the network shutdown due to 

} finally {	if (!cleanupResult) {	s_logger.warn("Failed to cleanup network id=" + network.getId() + " resources as a part of shutdownNetwork");	}	}	boolean success = true;	for (final NetworkElement element : networkElements) {	if (providersToShutdown.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	
sending network shutdown to 

s_logger.warn("Failed to cleanup network id=" + network.getId() + " resources as a part of shutdownNetwork");	}	}	boolean success = true;	for (final NetworkElement element : networkElements) {	if (providersToShutdown.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	}	if (!element.shutdown(network, context, cleanupElements)) {	
unable to complete shutdown of the network elements due to element 

boolean success = true;	for (final NetworkElement element : networkElements) {	if (providersToShutdown.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	}	if (!element.shutdown(network, context, cleanupElements)) {	success = false;	}	} catch (final ResourceUnavailableException e) {	
unable to complete shutdown of the network elements due to element 

if (providersToShutdown.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	}	if (!element.shutdown(network, context, cleanupElements)) {	success = false;	}	} catch (final ResourceUnavailableException e) {	success = false;	} catch (final ConcurrentOperationException e) {	
unable to complete shutdown of the network elements due to element 

if (s_logger.isDebugEnabled()) {	}	if (!element.shutdown(network, context, cleanupElements)) {	success = false;	}	} catch (final ResourceUnavailableException e) {	success = false;	} catch (final ConcurrentOperationException e) {	success = false;	} catch (final Exception e) {	
unable to complete shutdown of the network elements due to element 

public boolean destroyNetwork(final long networkId, final ReservationContext context, final boolean forced) {	final Account callerAccount = context.getAccount();	NetworkVO network = _networksDao.findById(networkId);	if (network == null) {	
unable to find network with id 

public boolean destroyNetwork(final long networkId, final ReservationContext context, final boolean forced) {	final Account callerAccount = context.getAccount();	NetworkVO network = _networksDao.findById(networkId);	if (network == null) {	return false;	}	final List<UserVmVO> userVms = _userVmDao.listByNetworkIdAndStates(networkId);	for (final UserVmVO vm : userVms) {	if (!(vm.getState() == VirtualMachine.State.Expunging && vm.getRemoved() != null)) {	
can t delete the network not all user vms are expunged vm is in state 

}	final int nicCount = getActiveNicsInNetwork(networkId);	if (nicCount > 0) {	s_logger.debug("The network id=" + networkId + " has active Nics, but shouldn't.");	_networksDao.changeActiveNicsBy(networkId, -1 * nicCount);	}	final DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	final List<VMInstanceVO> systemVms = _vmDao.listNonRemovedVmsByTypeAndNetwork(network.getId(), Type.ConsoleProxy, Type.SecondaryStorageVm);	if (systemVms != null && !systemVms.isEmpty()) {	
can t delete the network not all consoleproxy secondarystorage vms are expunged 

final DataCenter zone = _entityMgr.findById(DataCenter.class, network.getDataCenterId());	if (zone.getNetworkType() == NetworkType.Basic) {	final List<VMInstanceVO> systemVms = _vmDao.listNonRemovedVmsByTypeAndNetwork(network.getId(), Type.ConsoleProxy, Type.SecondaryStorageVm);	if (systemVms != null && !systemVms.isEmpty()) {	return false;	}	}	shutdownNetwork(networkId, context, false);	network = _networksDao.findById(networkId);	if (network.getState() != Network.State.Allocated && network.getState() != Network.State.Setup && !forced) {	
network is not not in the correct state to be destroyed 

boolean success = true;	if (!cleanupNetworkResources(networkId, callerAccount, context.getCaller().getId())) {	s_logger.warn("Unable to delete network id=" + networkId + ": failed to cleanup network resources");	return false;	}	final List<Provider> providersToDestroy = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToDestroy.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	
sending destroy to 

return false;	}	final List<Provider> providersToDestroy = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToDestroy.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	}	if (!element.destroy(network, context)) {	success = false;	
unable to complete destroy of the network failed to destroy network element 

final List<Provider> providersToDestroy = getNetworkProviders(network.getId());	for (final NetworkElement element : networkElements) {	if (providersToDestroy.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	}	if (!element.destroy(network, context)) {	success = false;	}	} catch (final ResourceUnavailableException e) {	
unable to complete destroy of the network due to element 

if (providersToDestroy.contains(element.getProvider())) {	try {	if (s_logger.isDebugEnabled()) {	}	if (!element.destroy(network, context)) {	success = false;	}	} catch (final ResourceUnavailableException e) {	success = false;	} catch (final ConcurrentOperationException e) {	
unable to complete destroy of the network due to element 

if (s_logger.isDebugEnabled()) {	}	if (!element.destroy(network, context)) {	success = false;	}	} catch (final ResourceUnavailableException e) {	success = false;	} catch (final ConcurrentOperationException e) {	success = false;	} catch (final Exception e) {	
unable to complete destroy of the network due to element 

if (s_logger.isDebugEnabled()) {	s_logger.debug("Network id=" + networkId + " is destroyed successfully, cleaning up corresponding resources now.");	}	final NetworkVO networkFinal = network;	try {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final NetworkGuru guru = AdapterBase.getAdapterByName(networkGurus, networkFinal.getGuruName());	guru.trash(networkFinal, _networkOfferingDao.findById(networkFinal.getNetworkOfferingId()));	if (!deleteVlansInNetwork(networkFinal.getId(), context.getCaller().getId(), callerAccount)) {	
failed to delete network was unable to cleanup corresponding ip ranges 

}	}	}	});	if (_networksDao.findById(network.getId()) == null) {	final Pair<Class<?>, Long> networkMsg = new Pair<Class<?>, Long>(Network.class, networkFinal.getId());	_messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, networkMsg);	}	return true;	} catch (final CloudRuntimeException e) {	
failed to delete network 

protected boolean deleteVlansInNetwork(final long networkId, final long userId, final Account callerAccount) {	final List<VlanVO> publicVlans = _vlanDao.listVlansByNetworkId(networkId);	boolean result = true;	for (final VlanVO vlan : publicVlans) {	if (!_configMgr.deleteVlanAndPublicIpRange(userId, vlan.getId(), callerAccount)) {	
failed to delete vlan 

protected boolean deleteVlansInNetwork(final long networkId, final long userId, final Account callerAccount) {	final List<VlanVO> publicVlans = _vlanDao.listVlansByNetworkId(networkId);	boolean result = true;	for (final VlanVO vlan : publicVlans) {	if (!_configMgr.deleteVlanAndPublicIpRange(userId, vlan.getId(), callerAccount)) {	result = false;	}	}	final int privateIpAllocCount = _privateIpDao.countAllocatedByNetworkId(networkId);	if (privateIpAllocCount > 0) {	
can t delete private ip range for network as it has allocated ip addresses 

public void reallyRun() {	try {	final List<Long> shutdownList = new ArrayList<Long>();	final long currentTime = System.currentTimeMillis() / 1000;	final HashMap<Long, Long> stillFree = new HashMap<Long, Long>();	final List<Long> networkIds = _networksDao.findNetworksToGarbageCollect();	final int netGcWait = NumbersUtil.parseInt(_configDao.getValue(NetworkGcWait.key()), 60);	
networkgarbagecollector uses seconds for gc interval 

final HashMap<Long, Long> stillFree = new HashMap<Long, Long>();	final List<Long> networkIds = _networksDao.findNetworksToGarbageCollect();	final int netGcWait = NumbersUtil.parseInt(_configDao.getValue(NetworkGcWait.key()), 60);	for (final Long networkId : networkIds) {	if (!_networkModel.isNetworkReadyForGc(networkId)) {	continue;	}	final Long time = _lastNetworkIdsToFree.remove(networkId);	if (time == null) {	if (s_logger.isDebugEnabled()) {	
we found network to be free for the first time adding it to the list 

if (!_networkModel.isNetworkReadyForGc(networkId)) {	continue;	}	final Long time = _lastNetworkIdsToFree.remove(networkId);	if (time == null) {	if (s_logger.isDebugEnabled()) {	}	stillFree.put(networkId, currentTime);	} else if (time > currentTime - netGcWait) {	if (s_logger.isDebugEnabled()) {	
network is still free but it s not time to shutdown yet 

if (_networksDao.findById(networkId) == null) {	s_logger.debug("Network id=" + networkId + " is removed, so clearing up corresponding gc check");	_networksDao.clearCheckForGc(networkId);	} else {	try {	final User caller = cctx.getCallingUser();	final Account owner = cctx.getCallingAccount();	final ReservationContext context = new ReservationContextImpl(null, null, caller, owner);	shutdownNetwork(networkId, context, false);	} catch (final Exception e) {	
unable to shutdown network 

try {	final User caller = cctx.getCallingUser();	final Account owner = cctx.getCallingAccount();	final ReservationContext context = new ReservationContextImpl(null, null, caller, owner);	shutdownNetwork(networkId, context, false);	} catch (final Exception e) {	}	}	}	} catch (final Exception e) {	
caught exception while running network gc 

public boolean startNetwork(final long networkId, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final NetworkVO network = _networksDao.findById(networkId);	if (network == null) {	final InvalidParameterValueException ex = new InvalidParameterValueException("Network with specified id doesn't exist");	ex.addProxyObject(String.valueOf(networkId), "networkId");	throw ex;	}	
starting network 

public boolean startNetwork(final long networkId, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final NetworkVO network = _networksDao.findById(networkId);	if (network == null) {	final InvalidParameterValueException ex = new InvalidParameterValueException("Network with specified id doesn't exist");	ex.addProxyObject(String.valueOf(networkId), "networkId");	throw ex;	}	final Pair<NetworkGuru, NetworkVO> implementedNetwork = implementNetwork(networkId, dest, context);	if (implementedNetwork== null || implementedNetwork.first() == null) {	
failed to start the network 

public boolean restartNetwork(final Long networkId, final Account callerAccount, final User callerUser, final boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final NetworkVO network = _networksDao.findById(networkId);	
restarting network 

public boolean restartNetwork(final Long networkId, final Account callerAccount, final User callerUser, final boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final NetworkVO network = _networksDao.findById(networkId);	final ReservationContext context = new ReservationContextImpl(null, null, callerUser, callerAccount);	if (cleanup) {	s_logger.debug("Shutting down the network id=" + networkId + " as a part of network restart");	if (!shutdownNetworkElementsAndResources(context, true, network)) {	
failed to shutdown the network elements and resources as a part of network restart 

if (cleanup) {	s_logger.debug("Shutting down the network id=" + networkId + " as a part of network restart");	if (!shutdownNetworkElementsAndResources(context, true, network)) {	setRestartRequired(network, true);	return false;	}	} else {	s_logger.debug("Skip the shutting down of network id=" + networkId);	}	final DeployDestination dest = new DeployDestination(_dcDao.findById(network.getDataCenterId()), null, null, null);	
implementing the network elements and resources as a part of network restart 

} else {	s_logger.debug("Skip the shutting down of network id=" + networkId);	}	final DeployDestination dest = new DeployDestination(_dcDao.findById(network.getDataCenterId()), null, null, null);	final NetworkOfferingVO offering = _networkOfferingDao.findById(network.getNetworkOfferingId());	try {	implementNetworkElementsAndResources(dest, context, network, offering);	setRestartRequired(network, true);	return true;	} catch (final Exception ex) {	
failed to implement network elements and resources as a part of network restart due to 

public UserDataServiceProvider getPasswordResetProvider(final Network network) {	final String passwordProvider = _ntwkSrvcDao.getProviderForServiceInNetwork(network.getId(), Service.UserData);	if (passwordProvider == null) {	
network doesn t support service 

public UserDataServiceProvider getSSHKeyResetProvider(final Network network) {	final String SSHKeyProvider = _ntwkSrvcDao.getProviderForServiceInNetwork(network.getId(), Service.UserData);	if (SSHKeyProvider == null) {	
network doesn t support service 

public DhcpServiceProvider getDhcpServiceProvider(final Network network) {	final String DhcpProvider = _ntwkSrvcDao.getProviderForServiceInNetwork(network.getId(), Service.Dhcp);	if (DhcpProvider == null) {	
network doesn t support service 

public List<? extends Nic> listVmNics(final long vmId, final Long nicId, final Long networkId) {	List<NicVO> result = null;	if (nicId == null && networkId == null) {	result = _nicDao.listByVmId(vmId);	} else {	result = _nicDao.listByVmIdAndNicIdAndNtwkId(vmId, nicId, networkId);	}	for (final NicVO nic : result) {	if (_networkModel.isProviderForNetwork(Provider.NiciraNvp, nic.getNetworkId())) {	
listing nsx logical switch and logical switch por for each nic 

}	final List<IPAddressVO> ipsToRelease = _ipAddressDao.listByAssociatedNetwork(networkId, null);	for (final IPAddressVO ipToRelease : ipsToRelease) {	if (ipToRelease.getVpcId() == null) {	if (!ipToRelease.isPortable()) {	final IPAddressVO ip = _ipAddrMgr.markIpAsUnavailable(ipToRelease.getId());	assert ip != null : "Unable to mark the ip address id=" + ipToRelease.getId() + " as unavailable.";	} else {	ipToRelease.setAssociatedWithNetworkId(null);	_ipAddressDao.update(ipToRelease.getId(), ipToRelease);	
portable ip address is no longer associated with any network 

} else {	ipToRelease.setAssociatedWithNetworkId(null);	_ipAddressDao.update(ipToRelease.getId(), ipToRelease);	}	} else {	_vpcMgr.unassignIPFromVpcNetwork(ipToRelease.getId(), network.getId());	}	}	try {	if (!_ipAddrMgr.applyIpAssociations(network, true)) {	
unable to apply ip address associations for 

private boolean shutdownNetworkResources(final long networkId, final Account caller, final long callerUserId) {	boolean success = true;	final Network network = _networksDao.findById(networkId);	final List<PortForwardingRuleVO> pfRules = _portForwardingRulesDao.listByNetwork(networkId);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing " + pfRules.size() + " port forwarding rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	for (final PortForwardingRuleVO pfRule : pfRules) {	
marking pf rule with revoke state 

final Network network = _networksDao.findById(networkId);	final List<PortForwardingRuleVO> pfRules = _portForwardingRulesDao.listByNetwork(networkId);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing " + pfRules.size() + " port forwarding rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	for (final PortForwardingRuleVO pfRule : pfRules) {	pfRule.setState(FirewallRule.State.Revoke);	}	try {	if (!_firewallMgr.applyRules(pfRules, true, false)) {	
failed to cleanup pf rules as a part of shutdownnetworkrules 

s_logger.debug("Releasing " + pfRules.size() + " port forwarding rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	for (final PortForwardingRuleVO pfRule : pfRules) {	pfRule.setState(FirewallRule.State.Revoke);	}	try {	if (!_firewallMgr.applyRules(pfRules, true, false)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup pf rules as a part of shutdownnetworkrules due to 

}	} catch (final ResourceUnavailableException ex) {	success = false;	}	final List<FirewallRuleVO> firewallStaticNatRules = _firewallDao.listByNetworkAndPurpose(networkId, Purpose.StaticNat);	final List<StaticNatRule> staticNatRules = new ArrayList<StaticNatRule>();	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing " + firewallStaticNatRules.size() + " static nat rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	for (final FirewallRuleVO firewallStaticNatRule : firewallStaticNatRules) {	
marking static nat rule with revoke state 

final IpAddress ip = _ipAddressDao.findById(firewallStaticNatRule.getSourceIpAddressId());	final FirewallRuleVO ruleVO = _firewallDao.findById(firewallStaticNatRule.getId());	if (ip == null || !ip.isOneToOneNat() || ip.getAssociatedWithVmId() == null) {	throw new InvalidParameterValueException("Source ip address of the rule id=" + firewallStaticNatRule.getId() + " is not static nat enabled");	}	ruleVO.setState(FirewallRule.State.Revoke);	staticNatRules.add(new StaticNatRuleImpl(ruleVO, ip.getVmIp()));	}	try {	if (!_firewallMgr.applyRules(staticNatRules, true, false)) {	
failed to cleanup static nat rules as a part of shutdownnetworkrules 

throw new InvalidParameterValueException("Source ip address of the rule id=" + firewallStaticNatRule.getId() + " is not static nat enabled");	}	ruleVO.setState(FirewallRule.State.Revoke);	staticNatRules.add(new StaticNatRuleImpl(ruleVO, ip.getVmIp()));	}	try {	if (!_firewallMgr.applyRules(staticNatRules, true, false)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup static nat rules as a part of shutdownnetworkrules due to 

}	try {	if (!_firewallMgr.applyRules(staticNatRules, true, false)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	try {	if (!_lbMgr.revokeLoadBalancersForNetwork(networkId, Scheme.Public)) {	
failed to cleanup public lb rules as a part of shutdownnetworkrules 

success = false;	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	try {	if (!_lbMgr.revokeLoadBalancersForNetwork(networkId, Scheme.Public)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup public lb rules as a part of shutdownnetworkrules due to 

}	try {	if (!_lbMgr.revokeLoadBalancersForNetwork(networkId, Scheme.Public)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	try {	if (!_lbMgr.revokeLoadBalancersForNetwork(networkId, Scheme.Internal)) {	
failed to cleanup internal lb rules as a part of shutdownnetworkrules 

success = false;	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	try {	if (!_lbMgr.revokeLoadBalancersForNetwork(networkId, Scheme.Internal)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup public lb rules as a part of shutdownnetworkrules due to 

success = false;	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	final List<FirewallRuleVO> firewallRules = _firewallDao.listByNetworkPurposeTrafficType(networkId, Purpose.Firewall, FirewallRule.TrafficType.Ingress);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing " + firewallRules.size() + " firewall ingress rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	for (final FirewallRuleVO firewallRule : firewallRules) {	
marking firewall ingress rule with revoke state 

}	final List<FirewallRuleVO> firewallRules = _firewallDao.listByNetworkPurposeTrafficType(networkId, Purpose.Firewall, FirewallRule.TrafficType.Ingress);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing " + firewallRules.size() + " firewall ingress rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	for (final FirewallRuleVO firewallRule : firewallRules) {	firewallRule.setState(FirewallRule.State.Revoke);	}	try {	if (!_firewallMgr.applyRules(firewallRules, true, false)) {	
failed to cleanup firewall ingress rules as a part of shutdownnetworkrules 

s_logger.debug("Releasing " + firewallRules.size() + " firewall ingress rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	for (final FirewallRuleVO firewallRule : firewallRules) {	firewallRule.setState(FirewallRule.State.Revoke);	}	try {	if (!_firewallMgr.applyRules(firewallRules, true, false)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup firewall ingress rules as a part of shutdownnetworkrules due to 

final List<FirewallRuleVO> firewallEgressRules = _firewallDao.listByNetworkPurposeTrafficType(networkId, Purpose.Firewall, FirewallRule.TrafficType.Egress);	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing " + firewallEgressRules.size() + " firewall egress rules for network id=" + networkId + " as a part of shutdownNetworkRules");	}	try {	final DataCenter zone = _dcDao.findById(network.getDataCenterId());	if (_networkModel.areServicesSupportedInNetwork(network.getId(), Service.Firewall) && (network.getGuestType() == Network.GuestType.Isolated || network.getGuestType() == Network.GuestType.Shared && zone.getNetworkType() == NetworkType.Advanced)) {	_firewallMgr.applyDefaultEgressFirewallRule(network.getId(), _networkModel.getNetworkEgressDefaultPolicy(networkId), false);	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup firewall default egress rule as a part of shutdownnetworkrules due to 

}	try {	final DataCenter zone = _dcDao.findById(network.getDataCenterId());	if (_networkModel.areServicesSupportedInNetwork(network.getId(), Service.Firewall) && (network.getGuestType() == Network.GuestType.Isolated || network.getGuestType() == Network.GuestType.Shared && zone.getNetworkType() == NetworkType.Advanced)) {	_firewallMgr.applyDefaultEgressFirewallRule(network.getId(), _networkModel.getNetworkEgressDefaultPolicy(networkId), false);	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	for (final FirewallRuleVO firewallRule : firewallEgressRules) {	
marking firewall egress rule with revoke state 

_firewallMgr.applyDefaultEgressFirewallRule(network.getId(), _networkModel.getNetworkEgressDefaultPolicy(networkId), false);	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	for (final FirewallRuleVO firewallRule : firewallEgressRules) {	firewallRule.setState(FirewallRule.State.Revoke);	}	try {	if (!_firewallMgr.applyRules(firewallEgressRules, true, false)) {	
failed to cleanup firewall egress rules as a part of shutdownnetworkrules 

success = false;	}	for (final FirewallRuleVO firewallRule : firewallEgressRules) {	firewallRule.setState(FirewallRule.State.Revoke);	}	try {	if (!_firewallMgr.applyRules(firewallEgressRules, true, false)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup firewall egress rules as a part of shutdownnetworkrules due to 

}	} catch (final ResourceUnavailableException ex) {	success = false;	}	if (network.getVpcId() != null) {	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing Network ACL Items for network id=" + networkId + " as a part of shutdownNetworkRules");	}	try {	if (!_networkACLMgr.revokeACLItemsForNetwork(networkId)) {	
failed to cleanup network acls as a part of shutdownnetworkrules 

}	if (network.getVpcId() != null) {	if (s_logger.isDebugEnabled()) {	s_logger.debug("Releasing Network ACL Items for network id=" + networkId + " as a part of shutdownNetworkRules");	}	try {	if (!_networkACLMgr.revokeACLItemsForNetwork(networkId)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	
failed to cleanup network acls as a part of shutdownnetworkrules due to 

}	try {	if (!_networkACLMgr.revokeACLItemsForNetwork(networkId)) {	success = false;	}	} catch (final ResourceUnavailableException ex) {	success = false;	}	}	if (!_rulesMgr.applyStaticNatForNetwork(networkId, false, caller, true)) {	
failed to disable static nats as part of shutdownnetworkrules for network id 

final List<PublicIp> publicIpsToRelease = new ArrayList<PublicIp>();	if (userIps != null && !userIps.isEmpty()) {	for (final IPAddressVO userIp : userIps) {	userIp.setState(IpAddress.State.Releasing);	final PublicIp publicIp = PublicIp.createFromAddrAndVlan(userIp, _vlanDao.findById(userIp.getVlanId()));	publicIpsToRelease.add(publicIp);	}	}	try {	if (!_ipAddrMgr.applyIpAssociations(network, true, true, publicIpsToRelease)) {	
unable to apply ip address associations for as a part of shutdownnetworkrules 

dc = _dcDao.findById(dcId);	} catch (final NumberFormatException e) {	}	}	if (dc == null) {	throw new IllegalArgumentException("Host " + startup.getPrivateIpAddress() + " sent incorrect data center: " + dataCenter);	}	dcId = dc.getId();	final HypervisorType hypervisorType = startup.getHypervisorType();	if (s_logger.isDebugEnabled()) {	
host s hypervisortype is 

info.setPublicNetworkName(publicName);	info.setStorageNetworkName(storageName);	final PhysicalNetworkTrafficTypeVO mgmtTraffic = _pNTrafficTypeDao.findBy(pNtwk.getId(), TrafficType.Management);	if (mgmtTraffic != null) {	final String vlan = mgmtTraffic.getVlan();	info.setMgmtVlan(vlan);	}	networkInfoList.add(info);	}	if (s_logger.isDebugEnabled()) {	
sending checknetworkcommand to check the network is setup correctly on agent 

final String vlan = mgmtTraffic.getVlan();	info.setMgmtVlan(vlan);	}	networkInfoList.add(info);	}	if (s_logger.isDebugEnabled()) {	}	final CheckNetworkCommand nwCmd = new CheckNetworkCommand(networkInfoList);	final CheckNetworkAnswer answer = (CheckNetworkAnswer)_agentMgr.easySend(hostId, nwCmd);	if (answer == null) {	
unable to get an answer to the checknetworkcommand from agent 

networkInfoList.add(info);	}	if (s_logger.isDebugEnabled()) {	}	final CheckNetworkCommand nwCmd = new CheckNetworkCommand(networkInfoList);	final CheckNetworkAnswer answer = (CheckNetworkAnswer)_agentMgr.easySend(hostId, nwCmd);	if (answer == null) {	throw new ConnectionException(true, "Unable to get an answer to the CheckNetworkCommand from agent: " + host.getId());	}	if (!answer.getResult()) {	
unable to setup agent due to 

}	if (!answer.getResult()) {	final String msg = "Incorrect Network setup on agent, Reinitialize agent after network names are setup, details : " + answer.getDetails();	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, dcId, host.getPodId(), msg, msg);	throw new ConnectionException(true, msg);	} else {	if (answer.needReconnect()) {	throw new ConnectionException(false, "Reinitialize agent after network setup.");	}	if (s_logger.isDebugEnabled()) {	
network setup is correct on agent 

if (nic == null || vmProfile.getType() == VirtualMachine.Type.User) {	final int deviceId = _nicDao.getFreeDeviceId(vm.getId());	nic = allocateNic(requested, network, false, deviceId, vmProfile).first();	if (nic == null) {	throw new CloudRuntimeException("Failed to allocate nic for vm " + vm + " in network " + network);	}	if(vmProfile.getType() == VirtualMachine.Type.User) {	final VMNetworkMapVO vno = new VMNetworkMapVO(vm.getId(), network.getId());	_vmNetworkMapDao.persist(vno);	}	
nic is allocated successfully for vm in network 

_vmNetworkMapDao.persist(vno);	}	}	if (prepare) {	final Pair<NetworkGuru, NetworkVO> implemented = implementNetwork(nic.getNetworkId(), dest, context, vmProfile.getVirtualMachine().getType() == Type.DomainRouter);	if (implemented == null || implemented.first() == null) {	s_logger.warn("Failed to implement network id=" + nic.getNetworkId() + " as a part of preparing nic id=" + nic.getId());	throw new CloudRuntimeException("Failed to implement network id=" + nic.getNetworkId() + " as a part preparing nic id=" + nic.getId());	}	nic = prepareNic(vmProfile, dest, context, nic.getId(), implemented.second());	
nic is prepared successfully for vm in network 

protected List<NetworkElement> getElementForServiceInNetwork(final Network network, final Service service) {	final List<NetworkElement> elements = new ArrayList<NetworkElement>();	final List<Provider> providers = getProvidersForServiceInNetwork(network, service);	if (providers == null) {	
cannot find provider for network 

protected List<NetworkElement> getElementForServiceInNetwork(final Network network, final Service service) {	final List<NetworkElement> elements = new ArrayList<NetworkElement>();	final List<Provider> providers = getProvidersForServiceInNetwork(network, service);	if (providers == null) {	return null;	}	if (providers.size() != 1 && service != Service.Lb) {	
found providers for network 

final List<NetworkElement> elements = new ArrayList<NetworkElement>();	final List<Provider> providers = getProvidersForServiceInNetwork(network, service);	if (providers == null) {	return null;	}	if (providers.size() != 1 && service != Service.Lb) {	return null;	}	for (final Provider provider : providers) {	final NetworkElement element = _networkModel.getElementImplementingProvider(provider.getName());	
let handle in network 

private boolean removeVmSecondaryIpsOfNic(final long nicId) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final List<NicSecondaryIpVO> ipList = _nicSecondaryIpDao.listByNicId(nicId);	if (ipList != null) {	for (final NicSecondaryIpVO ip : ipList) {	_nicSecondaryIpDao.remove(ip.getId());	}	
revoving nic secondary ip entry 

========================= cloudstack sample_4765 =========================

public boolean purge() {	boolean purged = true;	String[] files = _storage.listFiles(_templatePath);	for (String file : files) {	boolean r = _storage.delete(file);	if (!r) {	purged = false;	}	if (s_logger.isDebugEnabled()) {	
R unable to r emove 

public boolean load() throws IOException {	try (FileInputStream strm = new FileInputStream(_file);) {	_props.load(strm);	} catch (IOException e) {	
unable to load the template properties 

info.filename = _props.getProperty(format.getFileExtension() + ".filename");	if (info.filename == null) {	continue;	}	info.size = NumbersUtil.parseLong(_props.getProperty(format.getFileExtension() + ".size"), -1);	_props.setProperty("physicalSize", Long.toString(info.size));	info.virtualSize = NumbersUtil.parseLong(_props.getProperty(format.getFileExtension() + ".virtualsize"), -1);	_formats.add(info);	if (!checkFormatValidity(info)) {	_isCorrupted = true;	
cleaning up inconsistent information for 

public boolean save() {	for (FormatInfo info : _formats) {	_props.setProperty(info.format.getFileExtension(), "true");	_props.setProperty(info.format.getFileExtension() + ".filename", info.filename);	_props.setProperty(info.format.getFileExtension() + ".size", Long.toString(info.size));	_props.setProperty(info.format.getFileExtension() + ".virtualsize", Long.toString(info.virtualSize));	}	try (FileOutputStream strm =  new FileOutputStream(_file);) {	_props.store(strm, "");	} catch (IOException e) {	
unable to save the template properties 

public boolean addFormat(FormatInfo newInfo) {	deleteFormat(newInfo.format);	if (!checkFormatValidity(newInfo)) {	
format is invalid 

public boolean addFormat(FormatInfo newInfo) {	deleteFormat(newInfo.format);	if (!checkFormatValidity(newInfo)) {	
format size virtualsize filename 

public boolean addFormat(FormatInfo newInfo) {	deleteFormat(newInfo.format);	if (!checkFormatValidity(newInfo)) {	
format filename cannot be null and size virtual size should be 

========================= cloudstack sample_400 =========================

public StartupCommand[] initialize() {	
initialize called 

public Answer execute(RemoveDomainCommand cmd) {	try {	Domain domain = searchDomain(cmd.getNetworkDomain(), false);	if (domain != null) {	if (!cmd.isOverride()) {	for (Record record : _globoDns.getRecordAPI().listAll(domain.getId())) {	if (record.getTypeNSRecordAttributes().getId() == null) {	
there are records in domain and override is not enable i will not delete this domain 

if (!cmd.isOverride()) {	for (Record record : _globoDns.getRecordAPI().listAll(domain.getId())) {	if (record.getTypeNSRecordAttributes().getId() == null) {	return new Answer(cmd, true, "Domain keeped");	}	}	}	_globoDns.getDomainAPI().removeDomain(domain.getId());	scheduleExportChangesToBind();	} else {	
domain already been deleted 

public Answer execute(CreateOrUpdateRecordAndReverseCommand cmd) {	boolean needsExport = false;	try {	Domain domain = searchDomain(cmd.getNetworkDomain(), false);	if (domain == null) {	domain = _globoDns.getDomainAPI().createDomain(cmd.getNetworkDomain(), cmd.getReverseTemplateId(), DEFAULT_AUTHORITY_TYPE);	
domain doesn t exist maybe someone removed it it was automatically created with template 

protected boolean createOrUpdateReverse(String networkIp, String reverseRecordContent, Long templateId, boolean override) {	String reverseDomainName = generateReverseDomainNameFromNetworkIp(networkIp);	Domain reverseDomain = searchDomain(reverseDomainName, true);	if (reverseDomain == null) {	reverseDomain = _globoDns.getDomainAPI().createReverseDomain(reverseDomainName, templateId, DEFAULT_AUTHORITY_TYPE);	
created reverse domain with template 

public Answer execute(CreateOrUpdateDomainCommand cmd) {	boolean needsExport = false;	try {	Domain domain = searchDomain(cmd.getDomainName(), false);	if (domain == null) {	domain = _globoDns.getDomainAPI().createDomain(cmd.getDomainName(), cmd.getTemplateId(), DEFAULT_AUTHORITY_TYPE);	
created domain with template 

try {	Domain domain = searchDomain(cmd.getDomainName(), false);	if (domain == null) {	domain = _globoDns.getDomainAPI().createDomain(cmd.getDomainName(), cmd.getTemplateId(), DEFAULT_AUTHORITY_TYPE);	if (domain == null) {	return new Answer(cmd, false, "Unable to create domain " + cmd.getDomainName());	} else {	needsExport = true;	}	} else {	
domain already exist 

protected boolean removeRecord(String recordName, String recordValue, String bindZoneName, boolean reverse, boolean override) {	Domain domain = searchDomain(bindZoneName, reverse);	if (domain == null) {	
domain doesn t exists in globodns record has already been removed 

protected boolean removeRecord(String recordName, String recordValue, String bindZoneName, boolean reverse, boolean override) {	Domain domain = searchDomain(bindZoneName, reverse);	if (domain == null) {	return false;	}	Record record = searchRecord(recordName, domain.getId());	if (record == null) {	
record in domain has already been removed 

protected boolean removeRecord(String recordName, String recordValue, String bindZoneName, boolean reverse, boolean override) {	Domain domain = searchDomain(bindZoneName, reverse);	if (domain == null) {	return false;	}	Record record = searchRecord(recordName, domain.getId());	if (record == null) {	return false;	} else {	if (!override && !record.getContent().equals(recordValue)) {	
record in domain have different value from and override is not enable i will not delete it 

private boolean createOrUpdateRecord(Long domainId, String name, String ip, String type, boolean override) {	Record record = this.searchRecord(name, domainId);	if (record == null) {	record = _globoDns.getRecordAPI().createRecord(domainId, name, ip, type);	
created record in domain 

public void scheduleExportChangesToBind() {	try {	Export export = _globoDns.getExportAPI().scheduleExport();	if (export != null) {	
globodns export 

public void scheduleExportChangesToBind() {	try {	Export export = _globoDns.getExportAPI().scheduleExport();	if (export != null) {	}	} catch (GloboDnsException e) {	
error on scheduling export although everything was persist someone need to manually force export in globodns 

private Record searchRecord(String recordName, Long domainId) {	if (recordName == null || domainId == null) {	return null;	}	List<Record> candidates = _globoDns.getRecordAPI().listByQuery(domainId, recordName);	for (Record candidate : candidates) {	if (recordName.equalsIgnoreCase(candidate.getName())) {	
record in domain id found in globodns 

private Record searchRecord(String recordName, Long domainId) {	if (recordName == null || domainId == null) {	return null;	}	List<Record> candidates = _globoDns.getRecordAPI().listByQuery(domainId, recordName);	for (Record candidate : candidates) {	if (recordName.equalsIgnoreCase(candidate.getName())) {	return candidate;	}	}	
record in domain id not found in globodns 

========================= cloudstack sample_1834 =========================

public static boolean dispatch(Object target, String subject, String senderAddress, Object args) {	assert (subject != null);	assert (target != null);	Method handler = resolveHandler(target.getClass(), subject);	if (handler == null) return false;	try {	handler.invoke(target, subject, senderAddress, args);	} catch (IllegalArgumentException e) {	
unexpected exception when calling 

public static boolean dispatch(Object target, String subject, String senderAddress, Object args) {	assert (subject != null);	assert (target != null);	Method handler = resolveHandler(target.getClass(), subject);	if (handler == null) return false;	try {	handler.invoke(target, subject, senderAddress, args);	} catch (IllegalArgumentException e) {	throw new RuntimeException("IllegalArgumentException when invoking event handler for subject: " + subject);	} catch (IllegalAccessException e) {	
unexpected exception when calling 

assert (target != null);	Method handler = resolveHandler(target.getClass(), subject);	if (handler == null) return false;	try {	handler.invoke(target, subject, senderAddress, args);	} catch (IllegalArgumentException e) {	throw new RuntimeException("IllegalArgumentException when invoking event handler for subject: " + subject);	} catch (IllegalAccessException e) {	throw new RuntimeException("IllegalAccessException when invoking event handler for subject: " + subject);	} catch (InvocationTargetException e) {	
unexpected exception when calling 

List<Method> handlerList = s_handlerCache.get(handlerClz);	if (handlerList != null) {	for (Method method : handlerList) {	MessageHandler annotation = method.getAnnotation(MessageHandler.class);	assert (annotation != null);	if (match(annotation.topic(), subject)) {	return method;	}	}	} else {	
handler class is not registered 

private void buildHandlerMethodCache(Class<?> handlerClz) {	
build message handler cache for 

if (handlerList == null) {	handlerList = new ArrayList<Method>();	s_handlerCache.put(handlerClz, handlerList);	Class<?> clz = handlerClz;	while (clz != null && clz != Object.class) {	for (Method method : clz.getDeclaredMethods()) {	MessageHandler annotation = method.getAnnotation(MessageHandler.class);	if (annotation != null) {	method.setAccessible(true);	handlerList.add(method);	
add message handler to cache 

for (Method method : clz.getDeclaredMethods()) {	MessageHandler annotation = method.getAnnotation(MessageHandler.class);	if (annotation != null) {	method.setAccessible(true);	handlerList.add(method);	}	}	clz = clz.getSuperclass();	}	} else {	
message handler for class is already in cache 

if (annotation != null) {	method.setAccessible(true);	handlerList.add(method);	}	}	clz = clz.getSuperclass();	}	} else {	}	}	
done building message handler cache for 

========================= cloudstack sample_617 =========================

public HypervisorType getHypervisorType(long volumeId) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	String sql = null;	try {	ScopeType scope = getVolumeStoragePoolScope(volumeId);	if (scope != null) {	if (scope == ScopeType.CLUSTER || scope == ScopeType.HOST) sql = SELECT_HYPERTYPE_FROM_CLUSTER_VOLUME;	else if (scope == ScopeType.ZONE) sql = SELECT_HYPERTYPE_FROM_ZONE_VOLUME;	
unhandled scope type when running gethypervisortype on volume id 

public ImageFormat getImageFormat(Long volumeId) {	HypervisorType type = getHypervisorType(volumeId);	if (type.equals(HypervisorType.KVM)) {	return ImageFormat.QCOW2;	} else if (type.equals(HypervisorType.XenServer)) {	return ImageFormat.VHD;	} else if (type.equals(HypervisorType.VMware)) {	return ImageFormat.OVA;	} else {	
do not support hypervisor 

========================= cloudstack sample_4572 =========================

public Answer execute(ConfigureSharedNetworkUuidCommand command, NiciraNvpResource niciraNvpResource) {	final String logicalRouterUuid = command.getLogicalRouterUuid();	final String logicalSwitchUuid = command.getLogicalSwitchUuid();	final String portIpAddress = command.getPortIpAddress();	final List<NiciraNvpTag> tags = new ArrayList<NiciraNvpTag>();	tags.add(new NiciraNvpTag("cs_account", command.getOwnerName()));	final long networkId = command.getNetworkId();	final NiciraNvpApi niciraNvpApi = niciraNvpResource.getNiciraNvpApi();	
attaching logical switch on logical router for shared network 

public Answer execute(ConfigureSharedNetworkUuidCommand command, NiciraNvpResource niciraNvpResource) {	final String logicalRouterUuid = command.getLogicalRouterUuid();	final String logicalSwitchUuid = command.getLogicalSwitchUuid();	final String portIpAddress = command.getPortIpAddress();	final List<NiciraNvpTag> tags = new ArrayList<NiciraNvpTag>();	tags.add(new NiciraNvpTag("cs_account", command.getOwnerName()));	final long networkId = command.getNetworkId();	final NiciraNvpApi niciraNvpApi = niciraNvpResource.getNiciraNvpApi();	
looking for logical switch display name 

final long networkId = command.getNetworkId();	final NiciraNvpApi niciraNvpApi = niciraNvpResource.getNiciraNvpApi();	String logicalSwitchDisplayName;	try{	List<LogicalSwitch> lSwitchList = niciraNvpApi.findLogicalSwitch(logicalSwitchUuid);	if (lSwitchList != null){	if (lSwitchList.size() == 1){	logicalSwitchDisplayName = lSwitchList.get(0).getDisplayName();	}	else {	
more than one logical switch found with uuid 

List<LogicalSwitch> lSwitchList = niciraNvpApi.findLogicalSwitch(logicalSwitchUuid);	if (lSwitchList != null){	if (lSwitchList.size() == 1){	logicalSwitchDisplayName = lSwitchList.get(0).getDisplayName();	}	else {	throw new CloudRuntimeException("More than one Logical Switch found with uuid=" + logicalSwitchUuid);	}	}	else {	
logical switch not found 

}	else {	throw new CloudRuntimeException("More than one Logical Switch found with uuid=" + logicalSwitchUuid);	}	}	else {	throw new CloudRuntimeException("Logical Switch " + logicalSwitchUuid + " not found");	}	}	catch (NiciraNvpApiException e){	
logical switch not found retrying 

else {	throw new CloudRuntimeException("Logical Switch " + logicalSwitchUuid + " not found");	}	}	catch (NiciraNvpApiException e){	final CommandRetryUtility retryUtility = niciraNvpResource.getRetryUtility();	retryUtility.addRetry(command, NUM_RETRIES);	return retryUtility.retry(command, ConfigureSharedNetworkUuidAnswer.class, e);	}	catch (CloudRuntimeException e){	
shared network uuid vlan id failed due to 

}	}	catch (NiciraNvpApiException e){	final CommandRetryUtility retryUtility = niciraNvpResource.getRetryUtility();	retryUtility.addRetry(command, NUM_RETRIES);	return retryUtility.retry(command, ConfigureSharedNetworkUuidAnswer.class, e);	}	catch (CloudRuntimeException e){	return new ConfigureSharedNetworkUuidAnswer(command, false, e.getMessage());	}	
found display name for logical switch 

}	}	catch (NiciraNvpApiException e){	final CommandRetryUtility retryUtility = niciraNvpResource.getRetryUtility();	retryUtility.addRetry(command, NUM_RETRIES);	return retryUtility.retry(command, ConfigureSharedNetworkUuidAnswer.class, e);	}	catch (CloudRuntimeException e){	return new ConfigureSharedNetworkUuidAnswer(command, false, e.getMessage());	}	
creating logical router port in logical router 

lRouterPort = new LogicalRouterPort();	lRouterPort.setAdminStatusEnabled(true);	lRouterPort.setDisplayName(niciraNvpResource.truncate(logicalSwitchDisplayName + "-uplink", NAME_MAX_LEN));	lRouterPort.setTags(tags);	final List<String> ipAddresses = new ArrayList<String>();	ipAddresses.add(portIpAddress);	lRouterPort.setIpAddresses(ipAddresses);	lRouterPort = niciraNvpApi.createLogicalRouterPort(logicalRouterUuid, lRouterPort);	}	catch (NiciraNvpApiException e){	
could not create logical router port on logical router due to retrying 

lRouterPort.setDisplayName(niciraNvpResource.truncate(logicalSwitchDisplayName + "-uplink", NAME_MAX_LEN));	lRouterPort.setTags(tags);	final List<String> ipAddresses = new ArrayList<String>();	ipAddresses.add(portIpAddress);	lRouterPort.setIpAddresses(ipAddresses);	lRouterPort = niciraNvpApi.createLogicalRouterPort(logicalRouterUuid, lRouterPort);	}	catch (NiciraNvpApiException e){	return handleException(e, command, niciraNvpResource);	}	
logical router port successfully created in logical router 

lRouterPort.setDisplayName(niciraNvpResource.truncate(logicalSwitchDisplayName + "-uplink", NAME_MAX_LEN));	lRouterPort.setTags(tags);	final List<String> ipAddresses = new ArrayList<String>();	ipAddresses.add(portIpAddress);	lRouterPort.setIpAddresses(ipAddresses);	lRouterPort = niciraNvpApi.createLogicalRouterPort(logicalRouterUuid, lRouterPort);	}	catch (NiciraNvpApiException e){	return handleException(e, command, niciraNvpResource);	}	
creating logical switch port in logical switch 

}	catch (NiciraNvpApiException e){	return handleException(e, command, niciraNvpResource);	}	LogicalSwitchPort lSwitchPort = null;	try {	lSwitchPort = new LogicalSwitchPort(niciraNvpResource.truncate("lrouter-uplink", NAME_MAX_LEN), tags, true);	lSwitchPort = niciraNvpApi.createLogicalSwitchPort(logicalSwitchUuid, lSwitchPort);	}	catch (NiciraNvpApiException e){	
could not create logical switch port on logical switch due to 

}	LogicalSwitchPort lSwitchPort = null;	try {	lSwitchPort = new LogicalSwitchPort(niciraNvpResource.truncate("lrouter-uplink", NAME_MAX_LEN), tags, true);	lSwitchPort = niciraNvpApi.createLogicalSwitchPort(logicalSwitchUuid, lSwitchPort);	}	catch (NiciraNvpApiException e){	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
logical switch port successfully created in logical switch 

}	LogicalSwitchPort lSwitchPort = null;	try {	lSwitchPort = new LogicalSwitchPort(niciraNvpResource.truncate("lrouter-uplink", NAME_MAX_LEN), tags, true);	lSwitchPort = niciraNvpApi.createLogicalSwitchPort(logicalSwitchUuid, lSwitchPort);	}	catch (NiciraNvpApiException e){	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
attaching logical router port to logical switch port with a patchattachment 

lSwitchPort = niciraNvpApi.createLogicalSwitchPort(logicalSwitchUuid, lSwitchPort);	}	catch (NiciraNvpApiException e){	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	try {	niciraNvpApi.updateLogicalRouterPortAttachment(logicalRouterUuid, lRouterPort.getUuid(), new PatchAttachment(lSwitchPort.getUuid()));	}	catch (NiciraNvpApiException e) {	
could not attach logical router port to logical switch port due to retrying 

return handleException(e, command, niciraNvpResource);	}	try {	niciraNvpApi.updateLogicalRouterPortAttachment(logicalRouterUuid, lRouterPort.getUuid(), new PatchAttachment(lSwitchPort.getUuid()));	}	catch (NiciraNvpApiException e) {	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	cleanupLSwitchPort(logicalSwitchUuid, lSwitchPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
logical router port successfully attached to to logical switch port with a patchattachment 

return handleException(e, command, niciraNvpResource);	}	try {	niciraNvpApi.updateLogicalRouterPortAttachment(logicalRouterUuid, lRouterPort.getUuid(), new PatchAttachment(lSwitchPort.getUuid()));	}	catch (NiciraNvpApiException e) {	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	cleanupLSwitchPort(logicalSwitchUuid, lSwitchPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
attaching logical switch port to logical router port with a patchattachment 

}	catch (NiciraNvpApiException e) {	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	cleanupLSwitchPort(logicalSwitchUuid, lSwitchPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	try {	niciraNvpApi.updateLogicalSwitchPortAttachment(logicalSwitchUuid, lSwitchPort.getUuid(), new PatchAttachment(lRouterPort.getUuid()));	}	catch (NiciraNvpApiException e){	
could not attach logical switch port to logical router port due to retrying 

return handleException(e, command, niciraNvpResource);	}	try {	niciraNvpApi.updateLogicalSwitchPortAttachment(logicalSwitchUuid, lSwitchPort.getUuid(), new PatchAttachment(lRouterPort.getUuid()));	}	catch (NiciraNvpApiException e){	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	cleanupLSwitchPort(logicalSwitchUuid, lSwitchPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
logical switch port successfully attached to to logical router port with a patchattachment 

return handleException(e, command, niciraNvpResource);	}	try {	niciraNvpApi.updateLogicalSwitchPortAttachment(logicalSwitchUuid, lSwitchPort.getUuid(), new PatchAttachment(lRouterPort.getUuid()));	}	catch (NiciraNvpApiException e){	cleanupLRouterPort(logicalRouterUuid, lRouterPort, niciraNvpApi);	cleanupLSwitchPort(logicalSwitchUuid, lSwitchPort, niciraNvpApi);	return handleException(e, command, niciraNvpResource);	}	
successfully attached logical switch on logical router for shared network 

private Answer handleException(NiciraNvpApiException e, ConfigureSharedNetworkUuidCommand command, NiciraNvpResource niciraNvpResource) {	if (HttpStatusCodeHelper.isConflict(e.getErrorCode())){	
there s been a conflict in nsx side aborting implementation 

private Answer handleException(NiciraNvpApiException e, ConfigureSharedNetworkUuidCommand command, NiciraNvpResource niciraNvpResource) {	if (HttpStatusCodeHelper.isConflict(e.getErrorCode())){	return new ConfigureSharedNetworkUuidAnswer(command, false, "FAILED: There's been a conflict in NSX side");	}	else {	
error code retrying 

========================= cloudstack sample_1770 =========================

try {	VirtualMachine migratedVm = _userVmService.migrateVirtualMachineWithVolume(getVirtualMachineId(), destinationHost, getVolumeToPool());	if (migratedVm != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", (UserVm)migratedVm).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	
exception 

if (migratedVm != null) {	UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", (UserVm)migratedVm).get(0);	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	
exception 

response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (ManagementServerException e) {	
exception 

} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to migrate vm");	}	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (ManagementServerException e) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());	} catch (VirtualMachineMigrationException e) {	
exception 

========================= cloudstack sample_3258 =========================

public StrategyPriority canHandle(Map<VolumeInfo, DataStore> volumeMap, Host srcHost, Host destHost) {	if (srcHost.getHypervisorType() == HypervisorType.VMware && destHost.getHypervisorType() == HypervisorType.VMware) {	
can handle the request because the hosts have vmware hypervisor 

if (instance != null) {	if (srcHost.getClusterId().equals(destHost.getClusterId())) {	answer = migrateVmWithVolumesWithinCluster(instance, vmTo, srcHost, destHost, volumeMap);	} else {	answer = migrateVmWithVolumesAcrossCluster(instance, vmTo, srcHost, destHost, volumeMap);	}	} else {	throw new CloudRuntimeException("Unsupported operation requested for moving data.");	}	} catch (Exception e) {	
copy failed 

List<Pair<VolumeTO, StorageFilerTO>> volumeToFilerto = new ArrayList<Pair<VolumeTO, StorageFilerTO>>();	for (Map.Entry<VolumeInfo, DataStore> entry : volumeToPool.entrySet()) {	VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand migrateWithStorageCmd = new MigrateWithStorageCommand(to, volumeToFilerto, destHost.getGuid());	MigrateWithStorageAnswer migrateWithStorageAnswer = (MigrateWithStorageAnswer)agentMgr.send(srcHost.getId(), migrateWithStorageCmd);	if (migrateWithStorageAnswer == null) {	
migration with storage of vm to host failed 

VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand migrateWithStorageCmd = new MigrateWithStorageCommand(to, volumeToFilerto, destHost.getGuid());	MigrateWithStorageAnswer migrateWithStorageAnswer = (MigrateWithStorageAnswer)agentMgr.send(srcHost.getId(), migrateWithStorageCmd);	if (migrateWithStorageAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!migrateWithStorageAnswer.getResult()) {	
migration with storage of vm failed details 

}	MigrateWithStorageCommand migrateWithStorageCmd = new MigrateWithStorageCommand(to, volumeToFilerto, destHost.getGuid());	MigrateWithStorageAnswer migrateWithStorageAnswer = (MigrateWithStorageAnswer)agentMgr.send(srcHost.getId(), migrateWithStorageCmd);	if (migrateWithStorageAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!migrateWithStorageAnswer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost + ". " + migrateWithStorageAnswer.getDetails());	} else {	updateVolumesAfterMigration(volumeToPool, migrateWithStorageAnswer.getVolumeTos());	}	
storage migration of vm completed successfully migrated to host 

MigrateWithStorageAnswer migrateWithStorageAnswer = (MigrateWithStorageAnswer)agentMgr.send(srcHost.getId(), migrateWithStorageCmd);	if (migrateWithStorageAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!migrateWithStorageAnswer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost + ". " + migrateWithStorageAnswer.getDetails());	} else {	updateVolumesAfterMigration(volumeToPool, migrateWithStorageAnswer.getVolumeTos());	}	return migrateWithStorageAnswer;	} catch (OperationTimedoutException e) {	
error while migrating vm to host 

List<Pair<VolumeTO, StorageFilerTO>> volumeToFilerto = new ArrayList<Pair<VolumeTO, StorageFilerTO>>();	for (Map.Entry<VolumeInfo, DataStore> entry : volumeToPool.entrySet()) {	VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand command = new MigrateWithStorageCommand(to, volumeToFilerto, destHost.getGuid());	MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer)agentMgr.send(srcHost.getId(), command);	if (answer == null) {	
migration with storage of vm failed 

VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand command = new MigrateWithStorageCommand(to, volumeToFilerto, destHost.getGuid());	MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer)agentMgr.send(srcHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	
migration with storage of vm failed details 

MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer)agentMgr.send(srcHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost + ". " + answer.getDetails());	} else {	updateVolumesAfterMigration(volumeToPool, answer.getVolumeTos());	}	return answer;	} catch (OperationTimedoutException e) {	
error while migrating vm to host 

volumeVO.setLastPoolId(oldPoolId);	volumeVO.setFolder(pool.getPath());	volumeVO.setPodId(pool.getPodId());	volumeVO.setPoolId(pool.getId());	volDao.update(volume.getId(), volumeVO);	updated = true;	break;	}	}	if (!updated) {	
volume path wasn t updated for volume after it was migrated 

========================= cloudstack sample_1265 =========================

protected boolean canHandle(NetworkOffering offering, final NetworkType networkType, final PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && isMyIsolationMethod(physicalNetwork) && _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(offering.getId(), Service.Connectivity)) {	return true;	} else {	
we only take care of guest networks of type in zone of type 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	
refusing to design this network 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = _physicalNetworkDao.findById(plan.getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	return null;	}	
physical isolation type is vcs asking guestnetworkguru to design this network 

public Network implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException {	assert (network.getState() == State.Implementing) : "Why are we implementing " + network;	Network implemented = super.implement(network, offering, dest, context);	int vlanTag = Integer.parseInt(BroadcastDomainType.getValue(implemented.getBroadcastUri()));	Long physicalNetworkId = network.getPhysicalNetworkId();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	
no brocade vcs switch on physical network 

Long physicalNetworkId = network.getPhysicalNetworkId();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	return null;	}	for (BrocadeVcsDeviceVO brocadeVcsDevice : devices) {	HostVO brocadeVcsHost = _hostDao.findById(brocadeVcsDevice.getHostId());	CreateNetworkCommand cmd = new CreateNetworkCommand(vlanTag, network.getId(), context.getDomain().getName() + "-" + context.getAccount().getAccountName());	CreateNetworkAnswer answer = (CreateNetworkAnswer)_agentMgr.easySend(brocadeVcsHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
createnetworkcommand failed 

Long physicalNetworkId = network.getPhysicalNetworkId();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	return null;	}	for (BrocadeVcsDeviceVO brocadeVcsDevice : devices) {	HostVO brocadeVcsHost = _hostDao.findById(brocadeVcsDevice.getHostId());	CreateNetworkCommand cmd = new CreateNetworkCommand(vlanTag, network.getId(), context.getDomain().getName() + "-" + context.getAccount().getAccountName());	CreateNetworkAnswer answer = (CreateNetworkAnswer)_agentMgr.easySend(brocadeVcsHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
unable to create network 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException {	super.reserve(nic, network, vm, dest, context);	DataCenter dc = _dcDao.findById(network.getDataCenterId());	String interfaceMac = nic.getMacAddress();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no brocade vcs switch on physical network 

String interfaceMac = nic.getMacAddress();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return;	}	for (BrocadeVcsDeviceVO brocadeVcsDevice : devices) {	HostVO brocadeVcsHost = _hostDao.findById(brocadeVcsDevice.getHostId());	AssociateMacToNetworkCommand cmd = new AssociateMacToNetworkCommand(network.getId(), interfaceMac, context.getDomain().getName() + "-" + context.getAccount().getAccountName());	AssociateMacToNetworkAnswer answer = (AssociateMacToNetworkAnswer)_agentMgr.easySend(brocadeVcsHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
associatemactonetworkcommand failed 

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	String interfaceMac = nic.getMacAddress();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no brocade vcs switch on physical network 

String interfaceMac = nic.getMacAddress();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return;	}	for (BrocadeVcsDeviceVO brocadeVcsDevice : devices) {	HostVO brocadeVcsHost = _hostDao.findById(brocadeVcsDevice.getHostId());	DisassociateMacFromNetworkCommand cmd = new DisassociateMacFromNetworkCommand(network.getId(), interfaceMac);	DisassociateMacFromNetworkAnswer answer = (DisassociateMacFromNetworkAnswer)_agentMgr.easySend(brocadeVcsHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
disassociatemacfromnetworkcommand failed 

String interfaceMac = nic.getMacAddress();	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return;	}	for (BrocadeVcsDeviceVO brocadeVcsDevice : devices) {	HostVO brocadeVcsHost = _hostDao.findById(brocadeVcsDevice.getHostId());	DisassociateMacFromNetworkCommand cmd = new DisassociateMacFromNetworkCommand(network.getId(), interfaceMac);	DisassociateMacFromNetworkAnswer answer = (DisassociateMacFromNetworkAnswer)_agentMgr.easySend(brocadeVcsHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
unable to disassociate mac from network 

public boolean trash(Network network, NetworkOffering offering) {	int vlanTag = 0;	BrocadeVcsNetworkVlanMappingVO brocadeVcsNetworkVlanMapping = _brocadeVcsNetworkVlanDao.findByNetworkId(network.getId());	if (brocadeVcsNetworkVlanMapping != null) {	vlanTag = brocadeVcsNetworkVlanMapping.getVlanId();	} else {	
not able to find vlanid for network 

public boolean trash(Network network, NetworkOffering offering) {	int vlanTag = 0;	BrocadeVcsNetworkVlanMappingVO brocadeVcsNetworkVlanMapping = _brocadeVcsNetworkVlanDao.findByNetworkId(network.getId());	if (brocadeVcsNetworkVlanMapping != null) {	vlanTag = brocadeVcsNetworkVlanMapping.getVlanId();	} else {	return false;	}	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no brocade vcs switch on physical network 

}	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	for (BrocadeVcsDeviceVO brocadeVcsDevice : devices) {	HostVO brocadeVcsHost = _hostDao.findById(brocadeVcsDevice.getHostId());	DeleteNetworkCommand cmd = new DeleteNetworkCommand(vlanTag, network.getId());	DeleteNetworkAnswer answer = (DeleteNetworkAnswer)_agentMgr.easySend(brocadeVcsHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
deletenetworkcommand failed 

}	List<BrocadeVcsDeviceVO> devices = _brocadeVcsDao.listByPhysicalNetwork(network.getPhysicalNetworkId());	if (devices.isEmpty()) {	return false;	}	for (BrocadeVcsDeviceVO brocadeVcsDevice : devices) {	HostVO brocadeVcsHost = _hostDao.findById(brocadeVcsDevice.getHostId());	DeleteNetworkCommand cmd = new DeleteNetworkCommand(vlanTag, network.getId());	DeleteNetworkAnswer answer = (DeleteNetworkAnswer)_agentMgr.easySend(brocadeVcsHost.getId(), cmd);	if (answer == null || !answer.getResult()) {	
unable to delete network 

========================= cloudstack sample_1635 =========================

public boolean start() {	for (Registry<?> registry : registries) {	StringBuilder buffer = new StringBuilder();	for (Object o : registry.getRegistered()) {	if (buffer.length() > 0) buffer.append(", ");	buffer.append(getName(o));	}	
registry contains 

========================= cloudstack sample_752 =========================

Answer answer = null;	String errMsg = null;	try {	VMInstanceVO instance = instanceDao.findById(vmTo.getId());	if (instance != null) {	answer = migrateVmWithVolumes(instance, vmTo, srcHost, destHost, volumeMap);	} else {	throw new CloudRuntimeException("Unsupported operation requested for moving data.");	}	} catch (Exception e) {	
copy failed 

List<Pair<VolumeTO, StorageFilerTO>> volumeToFilerto = new ArrayList<Pair<VolumeTO, StorageFilerTO>>();	for (Map.Entry<VolumeInfo, DataStore> entry : volumeToPool.entrySet()) {	VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand command = new MigrateWithStorageCommand(to, volumeToFilerto, destHost.getPrivateIpAddress());	MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer) agentMgr.send(srcHost.getId(), command);	if (answer == null) {	
migration with storage of vm failed 

VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand command = new MigrateWithStorageCommand(to, volumeToFilerto, destHost.getPrivateIpAddress());	MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer) agentMgr.send(srcHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	
migration with storage of vm failed details 

MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer) agentMgr.send(srcHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost + ". " + answer.getDetails());	} else {	updateVolumePathsAfterMigration(volumeToPool, answer.getVolumeTos());	}	return answer;	} catch (OperationTimedoutException e) {	
error while migrating vm to host 

if (pool.getPoolType() == StoragePoolType.SMB && folder != null && folder.contains("?")) {	folder = folder.substring(0, folder.indexOf("?"));	}	volumeVO.setFolder(folder);	volDao.update(volume.getId(), volumeVO);	updated = true;	break;	}	}	if (!updated) {	
volume path wasn t updated for volume after it was migrated 

========================= cloudstack sample_928 =========================

public void setApplicationContext(ApplicationContext applicationContext) {	
setup spring application context 

Map<String, ComponentLifecycle> lifecycleComponents = getApplicationContext().getBeansOfType(ComponentLifecycle.class);	Map<String, ComponentLifecycle>[] classifiedComponents = new Map[ComponentLifecycle.MAX_RUN_LEVELS];	for (int i = 0; i < ComponentLifecycle.MAX_RUN_LEVELS; i++) {	classifiedComponents[i] = new HashMap<String, ComponentLifecycle>();	}	for (Map.Entry<String, ComponentLifecycle> entry : lifecycleComponents.entrySet()) {	classifiedComponents[entry.getValue().getRunLevel()].put(entry.getKey(), entry.getValue());	}	Map<String, SystemIntegrityChecker> integrityCheckers = getApplicationContext().getBeansOfType(SystemIntegrityChecker.class);	for (Entry<String, SystemIntegrityChecker> entry : integrityCheckers.entrySet()) {	
running systemintegritychecker 

classifiedComponents[i] = new HashMap<String, ComponentLifecycle>();	}	for (Map.Entry<String, ComponentLifecycle> entry : lifecycleComponents.entrySet()) {	classifiedComponents[entry.getValue().getRunLevel()].put(entry.getKey(), entry.getValue());	}	Map<String, SystemIntegrityChecker> integrityCheckers = getApplicationContext().getBeansOfType(SystemIntegrityChecker.class);	for (Entry<String, SystemIntegrityChecker> entry : integrityCheckers.entrySet()) {	try {	entry.getValue().check();	} catch (Throwable e) {	
system integrity check failed refuse to startup 

entry.getValue().check();	} catch (Throwable e) {	System.exit(1);	}	}	Map<String, String> avoidMap = new HashMap<String, String>();	for (int i = 0; i < ComponentLifecycle.MAX_RUN_LEVELS; i++) {	for (Map.Entry<String, ComponentLifecycle> entry : classifiedComponents[i].entrySet()) {	ComponentLifecycle component = entry.getValue();	String implClassName = ComponentContext.getTargetClass(component).getName();	
configuring 

} catch (Throwable e) {	System.exit(1);	}	}	Map<String, String> avoidMap = new HashMap<String, String>();	for (int i = 0; i < ComponentLifecycle.MAX_RUN_LEVELS; i++) {	for (Map.Entry<String, ComponentLifecycle> entry : classifiedComponents[i].entrySet()) {	ComponentLifecycle component = entry.getValue();	String implClassName = ComponentContext.getTargetClass(component).getName();	if (avoidMap.containsKey(implClassName)) {	
skip configuration of as it is already configured 

for (int i = 0; i < ComponentLifecycle.MAX_RUN_LEVELS; i++) {	for (Map.Entry<String, ComponentLifecycle> entry : classifiedComponents[i].entrySet()) {	ComponentLifecycle component = entry.getValue();	String implClassName = ComponentContext.getTargetClass(component).getName();	if (avoidMap.containsKey(implClassName)) {	continue;	}	try {	component.configure(component.getName(), component.getConfigParams());	} catch (ConfigurationException e) {	
unhandled exception 

throw new RuntimeException("Unable to configure " + implClassName, e);	}	avoidMap.put(implClassName, implClassName);	}	}	avoidMap.clear();	for (int i = 0; i < ComponentLifecycle.MAX_RUN_LEVELS; i++) {	for (Map.Entry<String, ComponentLifecycle> entry : classifiedComponents[i].entrySet()) {	ComponentLifecycle component = entry.getValue();	String implClassName = ComponentContext.getTargetClass(component).getName();	
starting 

}	avoidMap.put(implClassName, implClassName);	}	}	avoidMap.clear();	for (int i = 0; i < ComponentLifecycle.MAX_RUN_LEVELS; i++) {	for (Map.Entry<String, ComponentLifecycle> entry : classifiedComponents[i].entrySet()) {	ComponentLifecycle component = entry.getValue();	String implClassName = ComponentContext.getTargetClass(component).getName();	if (avoidMap.containsKey(implClassName)) {	
skip configuration of as it is already configured 

for (Map.Entry<String, ComponentLifecycle> entry : classifiedComponents[i].entrySet()) {	ComponentLifecycle component = entry.getValue();	String implClassName = ComponentContext.getTargetClass(component).getName();	if (avoidMap.containsKey(implClassName)) {	continue;	}	try {	component.start();	if (getTargetObject(component) instanceof ManagementBean) registerMBean((ManagementBean)getTargetObject(component));	} catch (Exception e) {	
unhandled exception 

static void registerMBean(ManagementBean mbean) {	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	
unable to register mbean 

static void registerMBean(ManagementBean mbean) {	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	
unable to register mbean 

static void registerMBean(ManagementBean mbean) {	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	} catch (MBeanRegistrationException e) {	
unable to register mbean 

static void registerMBean(ManagementBean mbean) {	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	} catch (MBeanRegistrationException e) {	} catch (NotCompliantMBeanException e) {	
unable to register mbean 

static void registerMBean(ManagementBean mbean) {	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	} catch (MBeanRegistrationException e) {	} catch (NotCompliantMBeanException e) {	}	
registered mbean 

public static <T> T getComponent(Class<T> beanType) {	assert (s_appContext != null);	Map<String, T> matchedTypes = getComponentsOfType(beanType);	if (matchedTypes.size() > 0) {	for (Map.Entry<String, T> entry : matchedTypes.entrySet()) {	Primary primary = getTargetClass(entry.getValue()).getAnnotation(Primary.class);	if (primary != null) return entry.getValue();	}	if (matchedTypes.size() > 1) {	
unable to uniquely locate bean type 

public static <T> T getComponent(Class<T> beanType) {	assert (s_appContext != null);	Map<String, T> matchedTypes = getComponentsOfType(beanType);	if (matchedTypes.size() > 0) {	for (Map.Entry<String, T> entry : matchedTypes.entrySet()) {	Primary primary = getTargetClass(entry.getValue()).getAnnotation(Primary.class);	if (primary != null) return entry.getValue();	}	if (matchedTypes.size() > 1) {	for (Map.Entry<String, T> entry : matchedTypes.entrySet()) {	
candidate 

public static <T> T inject(Class<T> clz) {	T instance;	try {	instance = clz.newInstance();	return inject(instance);	} catch (InstantiationException e) {	
unhandled instantiationexception 

public static <T> T inject(Class<T> clz) {	T instance;	try {	instance = clz.newInstance();	return inject(instance);	} catch (InstantiationException e) {	throw new RuntimeException("Unable to instantiate object of class " + clz.getName() + ", make sure it has public constructor");	} catch (IllegalAccessException e) {	
unhandled illegalaccessexception 

========================= cloudstack sample_2760 =========================

protected boolean canHandle(NetworkOffering offering, DataCenter dc) {	if (dc.getNetworkType() == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && offering.isSystemOnly()) {	return true;	} else {	
we only take care of system guest networks of type in zone of type 

public void deallocate(Network network, NicProfile nic, VirtualMachineProfile vm) {	if (s_logger.isDebugEnabled()) {	
deallocate network networkid ip 

========================= cloudstack sample_2275 =========================

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	
trying auth for user 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	
username or password cannot be empty 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	final UserAccount userAccount = _userAccountDao.getUserAccount(username, domainId);	if (userAccount == null || userAccount.getSource() != User.Source.SAML2) {	
unable to find user with in domain or user source is not 

========================= cloudstack sample_1377 =========================

try {	Host result = _resourceService.reconnectHost(this);	if (result != null) {	HostResponse response = _responseGenerator.createHostResponse(result);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to reconnect host");	}	} catch (Exception ex) {	
exception 

========================= cloudstack sample_3126 =========================

if (imageStores == null || imageStores.size() == 0) {	throw new CloudRuntimeException("Unable to find image store to download template " + profile.getTemplate());	}	Set<Long> zoneSet = new HashSet<Long>();	Collections.shuffle(imageStores);	for (DataStore imageStore : imageStores) {	Long zoneId = imageStore.getScope().getScopeId();	if (zoneId != null) {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone == null) {	
unable to find zone by id so skip downloading template to its image store 

Set<Long> zoneSet = new HashSet<Long>();	Collections.shuffle(imageStores);	for (DataStore imageStore : imageStores) {	Long zoneId = imageStore.getScope().getScopeId();	if (zoneId != null) {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone == null) {	continue;	}	if (Grouping.AllocationState.Disabled == zone.getAllocationState()) {	
zone is disabled so skip downloading template to its image store 

Long zoneId = imageStore.getScope().getScopeId();	if (zoneId != null) {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone == null) {	continue;	}	if (Grouping.AllocationState.Disabled == zone.getAllocationState()) {	continue;	}	if (!_statsCollector.imageStoreHasEnoughCapacity(imageStore)) {	
image store doesn t has enough capacity so skip downloading template to this image store 

throw new CloudRuntimeException("Unable to find image store to download template " + profile.getTemplate());	}	List<TemplateOrVolumePostUploadCommand> payloads = new LinkedList<>();	Set<Long> zoneSet = new HashSet<Long>();	Collections.shuffle(imageStores);	for (DataStore imageStore : imageStores) {	Long zoneId = imageStore.getScope().getScopeId();	if (zoneId != null) {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone == null) {	
unable to find zone by id so skip downloading template to its image store 

Set<Long> zoneSet = new HashSet<Long>();	Collections.shuffle(imageStores);	for (DataStore imageStore : imageStores) {	Long zoneId = imageStore.getScope().getScopeId();	if (zoneId != null) {	DataCenterVO zone = _dcDao.findById(zoneId);	if (zone == null) {	continue;	}	if (Grouping.AllocationState.Disabled == zone.getAllocationState()) {	
zone is disabled so skip downloading template to its image store 

String etype = EventTypes.EVENT_TEMPLATE_CREATE;	if (tmplt.getFormat() == ImageFormat.ISO) {	etype = EventTypes.EVENT_ISO_CREATE;	}	long physicalSize = 0;	DataStore ds = template.getDataStore();	TemplateDataStoreVO tmpltStore = _tmpltStoreDao.findByStoreTemplate(ds.getId(), template.getId());	if (tmpltStore != null) {	physicalSize = tmpltStore.getPhysicalSize();	} else {	
no entry found in template store ref for template id and image store id at the end of registering template 

TemplateDataStoreVO tmpltStore = _tmpltStoreDao.findByStoreTemplate(ds.getId(), template.getId());	if (tmpltStore != null) {	physicalSize = tmpltStore.getPhysicalSize();	} else {	}	Scope dsScope = ds.getScope();	if (dsScope.getScopeType() == ScopeType.ZONE) {	if (dsScope.getScopeId() != null) {	UsageEventUtils.publishUsageEvent(etype, template.getAccountId(), dsScope.getScopeId(), template.getId(), template.getName(), null, null, physicalSize, template.getSize(), VirtualMachineTemplate.class.getName(), template.getUuid());	} else {	
zone scope image store has a null scope id 

public boolean delete(TemplateProfile profile) {	boolean success = true;	VMTemplateVO template = profile.getTemplate();	List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(), profile.getZoneId());	if (imageStores == null || imageStores.size() == 0) {	
unable to find image store still having template so just mark the template removed 

VMTemplateVO template = profile.getTemplate();	List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(), profile.getZoneId());	if (imageStores == null || imageStores.size() == 0) {	} else {	for (DataStore store : imageStores) {	long storeId = store.getId();	List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);	for (TemplateDataStoreVO templateStore : templateStores) {	if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {	String errorMsg = "Please specify a template that is not currently being downloaded.";	
template is currently being downloaded to secondary storage host cant delete it 

if (template.getFormat().equals(ImageFormat.ISO)) {	eventType = EventTypes.EVENT_ISO_DELETE;	} else {	eventType = EventTypes.EVENT_TEMPLATE_DELETE;	}	for (DataStore imageStore : imageStores) {	Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();	if (sZoneId != null) {	UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(), template.getUuid());	}	
delete template from image store 

for (DataStore imageStore : imageStores) {	Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();	if (sZoneId != null) {	UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(), template.getUuid());	}	AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));	try {	TemplateApiResult result = future.get();	success = result.isSuccess();	if (!success) {	
failed to delete the template from the image store due to 

break;	}	List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());	if (templateZones != null) {	for (VMTemplateZoneVO templateZone : templateZones) {	templateZoneDao.remove(templateZone.getId());	}	}	templateDataStoreDao.removeByTemplateStore(template.getId(), imageStore.getId());	} catch (InterruptedException e) {	
delete template failed 

List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());	if (templateZones != null) {	for (VMTemplateZoneVO templateZone : templateZones) {	templateZoneDao.remove(templateZone.getId());	}	}	templateDataStoreDao.removeByTemplateStore(template.getId(), imageStore.getId());	} catch (InterruptedException e) {	throw new CloudRuntimeException("delete template Failed", e);	} catch (ExecutionException e) {	
delete template failed 

throw new CloudRuntimeException("delete template Failed", e);	}	}	}	if (success) {	if ((imageStores.size() > 1) && (profile.getZoneId() != null)) {	return success;	}	List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());	for (TemplateInfo tmplOnCache : cacheTmpls) {	
delete template from image cache store 

========================= cloudstack sample_2371 =========================

public static void checkVolumeFileForActivity(final String filePath, int timeoutSeconds, long inactiveThresholdMilliseconds, long minimumFileSize) throws IOException {	File file = new File(filePath);	if (!file.exists()) {	throw new CloudRuntimeException("File " + file.getAbsolutePath() + " not found");	}	if (file.length() < minimumFileSize) {	
vm disk file too small fresh clone skipping modify check 

if (file.length() < minimumFileSize) {	return;	}	int waitedSeconds = 0;	int intervalSeconds = 1;	while (true) {	BasicFileAttributes attrs = Files.readAttributes(file.toPath(), BasicFileAttributes.class);	long modifyIdle = System.currentTimeMillis() - attrs.lastModifiedTime().toMillis();	long accessIdle = System.currentTimeMillis() - attrs.lastAccessTime().toMillis();	if (modifyIdle > inactiveThresholdMilliseconds && accessIdle > inactiveThresholdMilliseconds) {	
file has not been accessed or modified for at least ms 

}	int waitedSeconds = 0;	int intervalSeconds = 1;	while (true) {	BasicFileAttributes attrs = Files.readAttributes(file.toPath(), BasicFileAttributes.class);	long modifyIdle = System.currentTimeMillis() - attrs.lastModifiedTime().toMillis();	long accessIdle = System.currentTimeMillis() - attrs.lastAccessTime().toMillis();	if (modifyIdle > inactiveThresholdMilliseconds && accessIdle > inactiveThresholdMilliseconds) {	return;	} else {	
file was modified ms ago accessed ms ago waiting for inactivity threshold of ms or timeout of s waited s 

========================= cloudstack sample_2721 =========================

} else if (purpose == Purpose.PortForwarding) {	_commandSetupHelper.createApplyPortForwardingRulesCommands((List<? extends PortForwardingRule>) rules, router, cmds, network.getId());	return _networkGeneralHelper.sendCommandsToRouter(router, cmds);	} else if (purpose == Purpose.StaticNat) {	_commandSetupHelper.createApplyStaticNatRulesCommands((List<StaticNatRule>) rules, router, cmds, network.getId());	return _networkGeneralHelper.sendCommandsToRouter(router, cmds);	} else if (purpose == Purpose.Firewall) {	_commandSetupHelper.createApplyFirewallRulesCommands(rules, router, cmds, network.getId());	return _networkGeneralHelper.sendCommandsToRouter(router, cmds);	}	
unable to apply rules of purpose 

========================= cloudstack sample_2234 =========================

public SnapshotAndCopyAnswer snapshotAndCopy(SnapshotAndCopyCommand cmd) {	
snapshotandcopyanswer snapshotandcopy snapshotandcopycommand not currently used for simulatorstorageprocessor 

public ResignatureAnswer resignature(ResignatureCommand cmd) {	
resignatureanswer resignature resignaturecommand not currently used for simulatorstorageprocessor 

========================= cloudstack sample_986 =========================

public Answer execute(final CheckHealthCommand command, final NiciraNvpResource serverResource) {	final NiciraNvpApi niciraNvpApi = serverResource.getNiciraNvpApi();	boolean healthy = true;	try {	final ControlClusterStatus clusterStatus = niciraNvpApi.getControlClusterStatus();	final String status = clusterStatus.getClusterStatus();	if (clusterIsUnstable(status)) {	
control cluster is not stable current status is 

public Answer execute(final CheckHealthCommand command, final NiciraNvpResource serverResource) {	final NiciraNvpApi niciraNvpApi = serverResource.getNiciraNvpApi();	boolean healthy = true;	try {	final ControlClusterStatus clusterStatus = niciraNvpApi.getControlClusterStatus();	final String status = clusterStatus.getClusterStatus();	if (clusterIsUnstable(status)) {	healthy = false;	}	} catch (final NiciraNvpApiException e) {	
exception caught while checking control cluster status during health check 

========================= cloudstack sample_1766 =========================

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(final String username, final String password, final Long domainId, final Map<String, Object[]> requestParameters) {	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	
username or password cannot be empty 

} catch (NoLdapUserMatchingQueryException e) {	s_logger.debug(e.getMessage());	}	} else {	if(user != null ) {	try {	LdapUser ldapUser = _ldapManager.getUser(username);	if(!ldapUser.isDisabled()) {	result = _ldapManager.canAuthenticate(ldapUser.getPrincipal(), password);	} else {	
user with principal is disabled in ldap 

========================= cloudstack sample_1336 =========================

height = offlineImage.getHeight();	BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);	Graphics2D g = bufferedImage.createGraphics();	synchronized (offlineImage) {	g.drawImage(offlineImage, 0, 0, width, height, 0, 0, width, height, null);	}	byte[] imgBits = null;	try {	imgBits = ImageHelper.jpegFromImage(bufferedImage);	} catch (IOException e) {	
ignored read error on image 

for (TileInfo tile : tileList) {	Rectangle rc = tile.getTileRect();	g.drawImage(offlineImage, i * tileWidth, 0, i * tileWidth + rc.width, rc.height, rc.x, rc.y, rc.x + rc.width, rc.y + rc.height, null);	i++;	}	}	byte[] imgBits = null;	try {	imgBits = ImageHelper.jpegFromImage(bufferedImage);	} catch (IOException e) {	
ignored read error on image tiles 

========================= cloudstack sample_4972 =========================

ModelDatabase db = new ModelDatabase();	NetworkVO network = mock(NetworkVO.class);	VirtualNetworkModel storageModel = new VirtualNetworkModel(network, null, ContrailManager.managementNetworkName, TrafficType.Storage);	db.getVirtualNetworks().add(storageModel);	VirtualNetworkModel mgmtModel = new VirtualNetworkModel(network, null, ContrailManager.managementNetworkName, TrafficType.Management);	db.getVirtualNetworks().add(mgmtModel);	VirtualNetworkModel guestModel1 = new VirtualNetworkModel(network, UUID.randomUUID().toString(), "test", TrafficType.Guest);	db.getVirtualNetworks().add(guestModel1);	VirtualNetworkModel guestModel2 = new VirtualNetworkModel(network, UUID.randomUUID().toString(), "test", TrafficType.Guest);	db.getVirtualNetworks().add(guestModel2);	
networks 

ModelDatabase db = new ModelDatabase();	NetworkVO network = mock(NetworkVO.class);	VirtualNetworkModel storageModel = new VirtualNetworkModel(network, null, ContrailManager.managementNetworkName, TrafficType.Storage);	db.getVirtualNetworks().add(storageModel);	VirtualNetworkModel mgmtModel = new VirtualNetworkModel(network, null, ContrailManager.managementNetworkName, TrafficType.Management);	db.getVirtualNetworks().add(mgmtModel);	VirtualNetworkModel guestModel1 = new VirtualNetworkModel(network, UUID.randomUUID().toString(), "test", TrafficType.Guest);	db.getVirtualNetworks().add(guestModel1);	VirtualNetworkModel guestModel2 = new VirtualNetworkModel(network, UUID.randomUUID().toString(), "test", TrafficType.Guest);	db.getVirtualNetworks().add(guestModel2);	
no of vitual networks added to database 

========================= cloudstack sample_1859 =========================

pstmt.setLong(1, dcId);	pstmt.setString(2, vlanId);	pstmt.setString(3, vlanGateway);	pstmt.setString(4, vlanNetmask);	pstmt.setLong(5, accountId);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	ipCount = rs.getInt(1);	}	} catch (Exception e) {	
exception counting ip addresses 

========================= cloudstack sample_4358 =========================

if (pingDirs.length != 2) {	throw new ConfigurationException("PING dir should have format like myshare/direcotry, eg: windows/64bit");	}	_share = pingDirs[0];	_dir = pingDirs[1];	com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22);	s_logger.debug(String.format("Trying to connect to PING PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, "******"));	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	
ssh failed to authenticate 

protected PreparePxeServerAnswer execute(PreparePxeServerCommand cmd) {	com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	
ssh failed to authenticate 

com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	throw new ConfigurationException(String.format("Cannot connect to PING PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, _password));	}	String script = String.format("python /usr/bin/prepare_tftp_bootfile.py restore %1$s %2$s %3$s %4$s %5$s %6$s %7$s %8$s %9$s %10$s %11$s", _tftpDir, cmd.getMac(), _storageServer, _share, _dir, cmd.getTemplate(), _cifsUserName, _cifsPassword, cmd.getIp(), cmd.getNetMask(), cmd.getGateWay());	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new PreparePxeServerAnswer(cmd, "prepare PING at " + _ip + " failed, command:" + script);	}	
prepare ping pxe server successfully 

sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	throw new ConfigurationException(String.format("Cannot connect to PING PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, _password));	}	String script = String.format("python /usr/bin/prepare_tftp_bootfile.py restore %1$s %2$s %3$s %4$s %5$s %6$s %7$s %8$s %9$s %10$s %11$s", _tftpDir, cmd.getMac(), _storageServer, _share, _dir, cmd.getTemplate(), _cifsUserName, _cifsPassword, cmd.getIp(), cmd.getNetMask(), cmd.getGateWay());	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new PreparePxeServerAnswer(cmd, "prepare PING at " + _ip + " failed, command:" + script);	}	return new PreparePxeServerAnswer(cmd);	} catch (Exception e) {	
prepare ping pxe server failed 

protected Answer execute(PrepareCreateTemplateCommand cmd) {	com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	
ssh failed to authenticate 

com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	throw new ConfigurationException(String.format("Cannot connect to PING PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, _password));	}	String script = String.format("python /usr/bin/prepare_tftp_bootfile.py backup %1$s %2$s %3$s %4$s %5$s %6$s %7$s %8$s %9$s %10$s %11$s", _tftpDir, cmd.getMac(), _storageServer, _share, _dir, cmd.getTemplate(), _cifsUserName, _cifsPassword, cmd.getIp(), cmd.getNetMask(), cmd.getGateWay());	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new Answer(cmd, false, "prepare for creating template failed, command:" + script);	}	
prepare for creating template successfully 

sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	throw new ConfigurationException(String.format("Cannot connect to PING PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, _password));	}	String script = String.format("python /usr/bin/prepare_tftp_bootfile.py backup %1$s %2$s %3$s %4$s %5$s %6$s %7$s %8$s %9$s %10$s %11$s", _tftpDir, cmd.getMac(), _storageServer, _share, _dir, cmd.getTemplate(), _cifsUserName, _cifsPassword, cmd.getIp(), cmd.getNetMask(), cmd.getGateWay());	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new Answer(cmd, false, "prepare for creating template failed, command:" + script);	}	return new Answer(cmd, true, "Success");	} catch (Exception e) {	
prepare for creating baremetal template failed 

sb.append(folder);	sb.append(",");	sb.append(file);	sb.append(",");	sb.append(contents);	sb.append(";");	}	String arg = org.apache.commons.lang.StringUtils.stripEnd(sb.toString(), ";");	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	
ssh failed to authenticate 

sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password)) {	throw new ConfigurationException(String.format("Cannot connect to PING PXE server(IP=%1$s, username=%2$s, password=%3$s", _ip, _username, _password));	}	String script = String.format("python /usr/bin/baremetal_user_data.py '%s'", arg);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, script)) {	return new Answer(cmd, false, "Failed to add user data, command:" + script);	}	return new Answer(cmd, true, "Success");	} catch (Exception e) {	
prepare for creating baremetal template failed 

========================= cloudstack sample_894 =========================

if (privateIp != null) {	if (!NetUtils.isValidIp(privateIp.toString())) {	throw new InvalidParameterValueException("Invalid vm ip address");	}	}	try {	PortForwardingRule result = _rulesService.createPortForwardingRule(this, virtualMachineId, privateIp, getOpenFirewall(), isDisplay());	setEntityId(result.getId());	setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

if (privateIp != null) {	if (!NetUtils.isValidIp(privateIp.toString())) {	throw new InvalidParameterValueException("Invalid vm ip address");	}	}	try {	PortForwardingRule result = _rulesService.createPortForwardingRule(this, virtualMachineId, privateIp, getOpenFirewall(), isDisplay());	setEntityId(result.getId());	setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException ex) {	
network rule conflict 

========================= cloudstack sample_3472 =========================

public void onManagementNodeIsolated() {	
received node isolation notification will perform self fencing and shut myself down 

========================= cloudstack sample_482 =========================

to.setUuid(nicVO.getUuid());	if (nicVO.getVmType() != VirtualMachine.Type.User) {	to.setPxeDisable(true);	}	List<String> secIps = null;	if (nicVO.getSecondaryIp()) {	secIps = _nicSecIpDao.getSecondaryIpAddressesForNic(nicVO.getId());	}	to.setNicSecIps(secIps);	} else {	
unabled to load nicvo for nicprofile 

========================= cloudstack sample_2633 =========================

public void clearAlert(AlertType alertType, long dataCenterId, long podId) {	try {	if (_emailAlert != null) {	_emailAlert.clearAlert(alertType.getType(), dataCenterId, podId);	}	} catch (Exception ex) {	
problem clearing email alert 

public void sendAlert(AlertType alertType, long dataCenterId, Long podId, String subject, String body) {	try {	if (_emailAlert != null) {	_emailAlert.sendAlert(alertType, dataCenterId, podId, subject, body);	} else {	
alerttype 

public void sendAlert(AlertType alertType, long dataCenterId, Long podId, String subject, String body) {	try {	if (_emailAlert != null) {	_emailAlert.sendAlert(alertType, dataCenterId, podId, subject, body);	} else {	} catch (Exception ex) {	
problem sending email alert 

public EmailAlert(String[] recipientList, String smtpHost, int smtpPort, boolean smtpUseAuth, final String smtpUsername, final String smtpPassword, String emailSender, boolean smtpDebug) {	if (recipientList != null) {	_recipientList = new InternetAddress[recipientList.length];	for (int i = 0; i < recipientList.length; i++) {	try {	_recipientList[i] = new InternetAddress(recipientList[i], recipientList[i]);	} catch (Exception ex) {	
exception creating address for 

newAlert.setType(alertType.getType());	newAlert.setSubject(subject);	newAlert.setPodId(podId);	newAlert.setDataCenterId(dataCenterId);	newAlert.setSentCount(1);	newAlert.setLastSent(new Date());	newAlert.setName(alertType.getName());	_alertDao.persist(newAlert);	} else {	if (s_logger.isDebugEnabled()) {	
have already sent emails for alert type skipping send email 

========================= cloudstack sample_2644 =========================

protected boolean canHandle(NetworkOffering offering, NetworkType networkType, PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && isMyIsolationMethod(physicalNetwork) && ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(offering.getId(), Service.Connectivity) && ntwkOfferingSrvcDao.isProviderForNetworkOffering(offering.getId(), Provider.Opendaylight)) {	return true;	} else {	
we only take care of guest networks of type in zone of type 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	
refusing to design this network 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	return null;	}	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	
no controller on physical network 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	return null;	}	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	return null;	}	
controller found on physical network 

public Network design(NetworkOffering offering, DeploymentPlan plan, Network userSpecified, Account owner) {	PhysicalNetworkVO physnet = physicalNetworkDao.findById(plan.getPhysicalNetworkId());	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	if (!canHandle(offering, dc.getNetworkType(), physnet)) {	return null;	}	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physnet.getId());	if (devices.isEmpty()) {	return null;	}	
physical isolation type is odl asking guestnetworkguru to design this network 

}	if (network.getCidr() != null) {	implemented.setCidr(network.getCidr());	}	String name = network.getName();	if (name == null || name.isEmpty()) {	name = ((NetworkVO)network).getUuid();	}	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	
no controller on physical network 

name = ((NetworkVO)network).getUuid();	}	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	return null;	}	OpenDaylightControllerVO controller = devices.get(0);	ConfigureNetworkCommand cmd = new ConfigureNetworkCommand(name, context.getAccount().getAccountName());	ConfigureNetworkAnswer answer = (ConfigureNetworkAnswer)agentManager.easySend(controller.getHostId(), cmd);	if (answer == null || !answer.getResult()) {	
configurenetworkcommand failed 

public void reserve(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException {	super.reserve(nic, network, vm, dest, context);	Long physicalNetworkId = network.getPhysicalNetworkId();	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	
no controller on physical network 

super.reserve(nic, network, vm, dest, context);	Long physicalNetworkId = network.getPhysicalNetworkId();	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	throw new InsufficientVirtualNetworkCapacityException("No OpenDaylight Controller configured for this network", dest.getPod().getId());	}	OpenDaylightControllerVO controller = devices.get(0);	AddHypervisorCommand addCmd = new AddHypervisorCommand(dest.getHost().getUuid(), dest.getHost().getPrivateIpAddress());	AddHypervisorAnswer addAnswer = (AddHypervisorAnswer)agentManager.easySend(controller.getHostId(), addCmd);	if (addAnswer == null || !addAnswer.getResult()) {	
failed to add as a node to the controller 

}	OpenDaylightControllerVO controller = devices.get(0);	AddHypervisorCommand addCmd = new AddHypervisorCommand(dest.getHost().getUuid(), dest.getHost().getPrivateIpAddress());	AddHypervisorAnswer addAnswer = (AddHypervisorAnswer)agentManager.easySend(controller.getHostId(), addCmd);	if (addAnswer == null || !addAnswer.getResult()) {	throw new InsufficientVirtualNetworkCapacityException("Failed to add destination hypervisor to the OpenDaylight Controller", dest.getPod().getId());	}	ConfigurePortCommand cmd = new ConfigurePortCommand(UUID.fromString(nic.getUuid()), UUID.fromString(BroadcastDomainType.getValue(network.getBroadcastUri())), context .getAccount().getAccountName(), nic.getMacAddress());	ConfigurePortAnswer answer = (ConfigurePortAnswer)agentManager.easySend(controller.getHostId(), cmd);	if (answer == null || !answer.getResult()) {	
configurenetworkcommand failed 

public boolean release(NicProfile nic, VirtualMachineProfile vm, String reservationId) {	boolean success = super.release(nic, vm, reservationId);	if (success) {	NetworkVO network = _networkDao.findById(nic.getNetworkId());	Long physicalNetworkId = network.getPhysicalNetworkId();	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	
no controller on physical network 

NetworkVO network = _networkDao.findById(nic.getNetworkId());	Long physicalNetworkId = network.getPhysicalNetworkId();	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(physicalNetworkId);	if (devices.isEmpty()) {	throw new CloudRuntimeException("No OpenDaylight controller on this physical network");	}	OpenDaylightControllerVO controller = devices.get(0);	DestroyPortCommand cmd = new DestroyPortCommand(UUID.fromString(nic.getUuid()));	DestroyPortAnswer answer = (DestroyPortAnswer)agentManager.easySend(controller.getHostId(), cmd);	if (answer == null || !answer.getResult()) {	
destroyportcommand failed 

public void shutdown(NetworkProfile profile, NetworkOffering offering) {	NetworkVO networkObject = networkDao.findById(profile.getId());	if (networkObject.getBroadcastDomainType() != BroadcastDomainType.OpenDaylight || networkObject.getBroadcastUri() == null) {	
broadcasturi is empty or incorrect for guestnetwork 

public void shutdown(NetworkProfile profile, NetworkOffering offering) {	NetworkVO networkObject = networkDao.findById(profile.getId());	if (networkObject.getBroadcastDomainType() != BroadcastDomainType.OpenDaylight || networkObject.getBroadcastUri() == null) {	return;	}	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(networkObject.getPhysicalNetworkId());	if (devices.isEmpty()) {	
no controller on physical network 

return;	}	List<OpenDaylightControllerVO> devices = openDaylightControllerMappingDao.listByPhysicalNetwork(networkObject.getPhysicalNetworkId());	if (devices.isEmpty()) {	return;	}	OpenDaylightControllerVO controller = devices.get(0);	DestroyNetworkCommand cmd = new DestroyNetworkCommand(BroadcastDomainType.getValue(networkObject.getBroadcastUri()));	DestroyNetworkAnswer answer = (DestroyNetworkAnswer)agentManager.easySend(controller.getHostId(), cmd);	if (answer == null || !answer.getResult()) {	
destroynetworkcommand failed 

========================= cloudstack sample_1592 =========================

try {	final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(vmName);	DomainState state = null;	Domain vm = null;	if (vmName != null) {	try {	vm = libvirtComputingResource.getDomain(conn, command.getVmName());	state = vm.getInfo().state;	} catch (final LibvirtException e) {	
ignoring libvirt error 

vm.resume();	}	} else {	if (primaryPool.getType() == StoragePoolType.RBD) {	try {	final Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	
succesfully connected to ceph cluster at mon host 

try {	final Rados r = new Rados(primaryPool.getAuthUserName());	r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	final IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	final Rbd rbd = new Rbd(io);	final RbdImage image = rbd.open(disk.getName());	if (command.getCommandSwitch().equalsIgnoreCase(ManageSnapshotCommand.CREATE_SNAPSHOT)) {	
attempting to create rbd snapshot 

r.confSet("mon_host", primaryPool.getSourceHost() + ":" + primaryPool.getSourcePort());	r.confSet("key", primaryPool.getAuthSecret());	r.confSet("client_mount_timeout", "30");	r.connect();	final IoCTX io = r.ioCtxCreate(primaryPool.getSourceDir());	final Rbd rbd = new Rbd(io);	final RbdImage image = rbd.open(disk.getName());	if (command.getCommandSwitch().equalsIgnoreCase(ManageSnapshotCommand.CREATE_SNAPSHOT)) {	image.snapCreate(snapshotName);	} else {	
attempting to remove rbd snapshot 

final Rbd rbd = new Rbd(io);	final RbdImage image = rbd.open(disk.getName());	if (command.getCommandSwitch().equalsIgnoreCase(ManageSnapshotCommand.CREATE_SNAPSHOT)) {	image.snapCreate(snapshotName);	} else {	image.snapRemove(snapshotName);	}	rbd.close(image);	r.ioCtxDestroy(io);	} catch (final Exception e) {	
a rbd snapshot operation on failed the error was 

final String manageSnapshotPath = libvirtComputingResource.manageSnapshotPath();	final Script scriptCommand = new Script(manageSnapshotPath, cmdsTimeout, s_logger);	if (command.getCommandSwitch().equalsIgnoreCase(ManageSnapshotCommand.CREATE_SNAPSHOT)) {	scriptCommand.add("-c", disk.getPath());	} else {	scriptCommand.add("-d", snapshotPath);	}	scriptCommand.add("-n", snapshotName);	final String result = scriptCommand.execute();	if (result != null) {	
failed to manage snapshot 

}	scriptCommand.add("-n", snapshotName);	final String result = scriptCommand.execute();	if (result != null) {	return new ManageSnapshotAnswer(command, false, "Failed to manage snapshot: " + result);	}	}	}	return new ManageSnapshotAnswer(command, command.getSnapshotId(), disk.getPath() + File.separator + snapshotName, true, null);	} catch (final LibvirtException e) {	
failed to manage snapshot 

========================= cloudstack sample_1068 =========================

public static String getGuestOsName(String guestOsName) {	String guestOS = s_mapper.get(guestOsName);	if (guestOS == null) {	
can t find the mapping of guest os 

========================= cloudstack sample_1087 =========================

if (!applyACLItemsToNetwork(network.getId(), rules)) {	handled = false;	break;	}	}	final List<VpcGatewayVO> vpcGateways = _vpcGatewayDao.listByAclIdAndType(aclId, VpcGateway.Type.Private);	for (final VpcGatewayVO vpcGateway : vpcGateways) {	final PrivateGateway privateGateway = _vpcSvc.getVpcPrivateGateway(vpcGateway.getId());	if (!applyACLToPrivateGw(privateGateway)) {	aclApplyStatus = false;	
failed to apply network acl item on private gateway acl id 

public boolean replaceNetworkACLForPrivateGw(final NetworkACL acl, final PrivateGateway gateway) throws ResourceUnavailableException {	final VpcGatewayVO vpcGatewayVo = _vpcGatewayDao.findById(gateway.getId());	final List<NetworkACLItemVO> aclItems = _networkACLItemDao.listByACL(acl.getId());	if (aclItems == null || aclItems.isEmpty()) {	
new network acl is empty revoke existing rules before applying acl 

final NetworkOffering guestNtwkOff = _entityMgr.findById(NetworkOffering.class, network.getNetworkOfferingId());	if (guestNtwkOff == null) {	throw new InvalidParameterValueException("Can't find network offering associated with network: " + network.getUuid());	}	if (!_ntwkModel.areServicesSupportedByNetworkOffering(guestNtwkOff.getId(), Service.NetworkACL)) {	throw new InvalidParameterValueException("Cannot apply NetworkACL. Network Offering does not support NetworkACL service");	}	if (network.getNetworkACLId() != null) {	final List<NetworkACLItemVO> aclItems = _networkACLItemDao.listByACL(acl.getId());	if (aclItems == null || aclItems.isEmpty()) {	
new network acl is empty revoke existing rules before applying acl 

if (network.getNetworkACLId() != null) {	final List<NetworkACLItemVO> aclItems = _networkACLItemDao.listByACL(acl.getId());	if (aclItems == null || aclItems.isEmpty()) {	if (!revokeACLItemsForNetwork(network.getId())) {	throw new CloudRuntimeException("Failed to replace network ACL. Error while removing existing ACL items for network: " + network.getId());	}	}	}	network.setNetworkACLId(acl.getId());	if (_networkDao.update(network.getId(), network)) {	
updated network with network acl id applying acl items 

private void revokeRule(final NetworkACLItemVO rule) {	if (rule.getState() == State.Staged) {	if (s_logger.isDebugEnabled()) {	
found a rule that is still in stage state so just removing it 

vpcElements = new ArrayList<VpcProvider>();	vpcElements.add((VpcProvider)_ntwkModel.getElementImplementingProvider(Network.Provider.VPCVirtualRouter.getName()));	if (vpcElements == null) {	throw new CloudRuntimeException("Failed to initialize vpc elements");	}	try{	for (final VpcProvider provider : vpcElements) {	return provider.applyACLItemsToPrivateGw(gateway, rules);	}	} catch(final Exception ex) {	
failed to apply acl to private gateway 

final Network network = _networkDao.findById(networkId);	boolean handled = false;	boolean foundProvider = false;	for (final NetworkACLServiceProvider element : _networkAclElements) {	final Network.Provider provider = element.getProvider();	final boolean isAclProvider = _networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.NetworkACL, provider);	if (!isAclProvider) {	continue;	}	foundProvider = true;	
applying networkacl for network with network acl service provider 

continue;	}	foundProvider = true;	handled = element.applyNetworkACLs(network, rules);	if (handled) {	_messageBus.publish(_name, "Network_ACL_Replaced", PublishScope.LOCAL, network);	break;	}	}	if (!foundProvider) {	
unable to find networkacl service provider for network 

========================= cloudstack sample_2351 =========================

protected List<StoragePool> reorderPoolsByCapacity(DeploymentPlan plan, List<StoragePool> pools) {	Long clusterId = plan.getClusterId();	short capacityType;	if(pools != null && pools.size() != 0){	capacityType = pools.get(0).getPoolType().isShared() == true ? Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED : Capacity.CAPACITY_TYPE_LOCAL_STORAGE;	} else{	return null;	}	List<Long> poolIdsByCapacity = _capacityDao.orderHostsByFreeCapacity(clusterId, capacityType);	if (s_logger.isDebugEnabled()) {	
list of pools in descending order of free capacity 

protected List<StoragePool> reorderPoolsByNumberOfVolumes(DeploymentPlan plan, List<StoragePool> pools, Account account) {	if (account == null) {	return pools;	}	long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	List<Long> poolIdsByVolCount = _volumeDao.listPoolIdsByVolumeCount(dcId, podId, clusterId, account.getAccountId());	if (s_logger.isDebugEnabled()) {	
list of pools in ascending order of number of volumes for account id is 

protected boolean filter(ExcludeList avoid, StoragePool pool, DiskProfile dskCh, DeploymentPlan plan) {	if (s_logger.isDebugEnabled()) {	
checking if storage pool is suitable name poolid 

protected boolean filter(ExcludeList avoid, StoragePool pool, DiskProfile dskCh, DeploymentPlan plan) {	if (s_logger.isDebugEnabled()) {	}	if (avoid.shouldAvoid(pool)) {	if (s_logger.isDebugEnabled()) {	
storagepool is in avoid set skipping this pool 

if (avoid.shouldAvoid(pool)) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	Long clusterId = pool.getClusterId();	if (clusterId != null) {	ClusterVO cluster = _clusterDao.findById(clusterId);	if (!(cluster.getHypervisorType() == dskCh.getHypervisorType())) {	if (s_logger.isDebugEnabled()) {	
storagepool s cluster does not have required hypervisortype skipping this pool 

Long clusterId = pool.getClusterId();	if (clusterId != null) {	ClusterVO cluster = _clusterDao.findById(clusterId);	if (!(cluster.getHypervisorType() == dskCh.getHypervisorType())) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	} else if (pool.getHypervisor() != null && !pool.getHypervisor().equals(HypervisorType.Any) && !(pool.getHypervisor() == dskCh.getHypervisorType())) {	if (s_logger.isDebugEnabled()) {	
storagepool does not have required hypervisortype skipping this pool 

private boolean checkHypervisorCompatibility(HypervisorType hyperType, Volume.Type volType, Storage.StoragePoolType poolType){	if(HypervisorType.LXC.equals(hyperType)){	if(Volume.Type.ROOT.equals(volType)){	if(!(Storage.StoragePoolType.NetworkFilesystem.equals(poolType) || Storage.StoragePoolType.Filesystem.equals(poolType)) ){	
storagepool does not support lxc root disk skipping this pool 

private boolean checkHypervisorCompatibility(HypervisorType hyperType, Volume.Type volType, Storage.StoragePoolType poolType){	if(HypervisorType.LXC.equals(hyperType)){	if(Volume.Type.ROOT.equals(volType)){	if(!(Storage.StoragePoolType.NetworkFilesystem.equals(poolType) || Storage.StoragePoolType.Filesystem.equals(poolType)) ){	return false;	}	} else if (Volume.Type.DATADISK.equals(volType)){	if(!Storage.StoragePoolType.RBD.equals(poolType)){	
storagepool does not support lxc data disk skipping this pool 

========================= cloudstack sample_4006 =========================

public void create() {	if (cidrlist != null) {	throw new InvalidParameterValueException( "Parameter cidrList is deprecated; if you need to open firewall rule for the specific CIDR, please refer to createFirewallRule command");	}	try {	StaticNatRule rule = _rulesService.createStaticNatRule(this, getOpenFirewall());	setEntityId(rule.getId());	setEntityUuid(rule.getUuid());	} catch (NetworkRuleConflictException e) {	
unable to create static nat rule due to 

========================= cloudstack sample_3393 =========================

public SnapshotInfo backupSnapshot(SnapshotInfo snapshot) {	SnapshotInfo parentSnapshot = snapshot.getParent();	if (parentSnapshot != null && snapshot.getPath().equalsIgnoreCase(parentSnapshot.getPath())) {	
backup an empty snapshot 

SnapshotInfo snapshotOnImageStore = (SnapshotInfo)store.create(snapshot);	snapshotOnImageStore.processEvent(Event.CreateOnlyRequested);	SnapshotObjectTO snapTO = new SnapshotObjectTO();	snapTO.setPath(parentSnapshotOnBackupStore.getInstallPath());	CreateObjectAnswer createSnapshotAnswer = new CreateObjectAnswer(snapTO);	snapshotOnImageStore.processEvent(Event.OperationSuccessed, createSnapshotAnswer);	SnapshotObject snapObj = (SnapshotObject)snapshot;	try {	snapObj.processEvent(Snapshot.Event.OperationNotPerformed);	} catch (NoTransitionException e) {	
failed to change state 

CreateObjectAnswer createSnapshotAnswer = new CreateObjectAnswer(snapTO);	snapshotOnImageStore.processEvent(Event.OperationSuccessed, createSnapshotAnswer);	SnapshotObject snapObj = (SnapshotObject)snapshot;	try {	snapObj.processEvent(Snapshot.Event.OperationNotPerformed);	} catch (NoTransitionException e) {	throw new CloudRuntimeException(e.toString());	}	return snapshotDataFactory.getSnapshot(snapObj.getId(), store);	} else {	
parent snapshot hasn t been backed up yet 

protected boolean deleteSnapshotChain(SnapshotInfo snapshot) {	
delete snapshot chain for snapshot 

protected boolean deleteSnapshotChain(SnapshotInfo snapshot) {	boolean result = false;	boolean resultIsSet = false;	try {	while (snapshot != null && (snapshot.getState() == Snapshot.State.Destroying || snapshot.getState() == Snapshot.State.Destroyed || snapshot.getState() == Snapshot.State.Error)) {	SnapshotInfo child = snapshot.getChild();	if (child != null) {	
the snapshot has child can t delete it on the storage 

protected boolean deleteSnapshotChain(SnapshotInfo snapshot) {	boolean result = false;	boolean resultIsSet = false;	try {	while (snapshot != null && (snapshot.getState() == Snapshot.State.Destroying || snapshot.getState() == Snapshot.State.Destroyed || snapshot.getState() == Snapshot.State.Error)) {	SnapshotInfo child = snapshot.getChild();	if (child != null) {	break;	}	
snapshot doesn t have children so it s ok to delete it and its parents 

try {	while (snapshot != null && (snapshot.getState() == Snapshot.State.Destroying || snapshot.getState() == Snapshot.State.Destroyed || snapshot.getState() == Snapshot.State.Error)) {	SnapshotInfo child = snapshot.getChild();	if (child != null) {	break;	}	SnapshotInfo parent = snapshot.getParent();	boolean deleted = false;	if (parent != null) {	if (parent.getPath() != null && parent.getPath().equalsIgnoreCase(snapshot.getPath())) {	
for empty delta snapshot only mark it as destroyed in db 

result = true;	resultIsSet = true;	}	}	}	if (!deleted) {	boolean r = snapshotSvr.deleteSnapshot(snapshot);	if (r) {	List<SnapshotInfo> cacheSnaps = snapshotDataFactory.listSnapshotOnCache(snapshot.getId());	for (SnapshotInfo cacheSnap : cacheSnaps) {	
delete snapshot from image cache store 

}	}	if (!resultIsSet) {	result = r;	resultIsSet = true;	}	}	snapshot = parent;	}	} catch (Exception e) {	
delete snapshot failed 

}	if (Snapshot.State.Error.equals(snapshotVO.getState())) {	List<SnapshotDataStoreVO> storeRefs = snapshotStoreDao.findBySnapshotId(snapshotId);	for (SnapshotDataStoreVO ref : storeRefs) {	snapshotStoreDao.expunge(ref.getId());	}	snapshotDao.remove(snapshotId);	return true;	}	if (snapshotVO.getState() == Snapshot.State.CreatedOnPrimary) {	
delete snapshot on primary storage 

if (snapshotVO.getState() == Snapshot.State.CreatedOnPrimary) {	snapshotVO.setState(Snapshot.State.Destroyed);	snapshotDao.update(snapshotId, snapshotVO);	return true;	}	if (!Snapshot.State.BackedUp.equals(snapshotVO.getState()) && !Snapshot.State.Error.equals(snapshotVO.getState())) {	throw new InvalidParameterValueException("Can't delete snapshotshot " + snapshotId + " due to it is in " + snapshotVO.getState() + " Status");	}	SnapshotInfo snapshotOnImage = snapshotDataFactory.getSnapshot(snapshotId, DataStoreRole.Image);	if (snapshotOnImage == null) {	
can t find snapshot on backup storage delete it in db 

}	SnapshotInfo snapshotOnImage = snapshotDataFactory.getSnapshot(snapshotId, DataStoreRole.Image);	if (snapshotOnImage == null) {	snapshotDao.remove(snapshotId);	return true;	}	SnapshotObject obj = (SnapshotObject)snapshotOnImage;	try {	obj.processEvent(Snapshot.Event.DestroyRequested);	} catch (NoTransitionException e) {	
failed to set the state to destroying 

long volumeId = snapshotOnPrimary.getVolumeId();	VolumeVO volumeVO = volumeDao.findById(volumeId);	if (((PrimaryDataStoreImpl)snapshotOnPrimaryInfo.getDataStore()).getPoolType() == StoragePoolType.RBD && volumeVO != null) {	snapshotSvr.deleteSnapshot(snapshotOnPrimaryInfo);	}	snapshotOnPrimary.setState(State.Destroyed);	snapshotStoreDao.update(snapshotOnPrimary.getId(), snapshotOnPrimary);	}	}	} catch (Exception e) {	
failed to delete snapshot 

snapshotSvr.deleteSnapshot(snapshotOnPrimaryInfo);	}	snapshotOnPrimary.setState(State.Destroyed);	snapshotStoreDao.update(snapshotOnPrimary.getId(), snapshotOnPrimary);	}	}	} catch (Exception e) {	try {	obj.processEvent(Snapshot.Event.OperationFailed);	} catch (NoTransitionException e1) {	
failed to change snapshot state 

StoragePool store = (StoragePool)volumeInfo.getDataStore();	if (store != null && store.getStatus() != StoragePoolStatus.Up) {	snapshot.processEvent(Event.OperationFailed);	throw new CloudRuntimeException("store is not in up state");	}	volumeInfo.stateTransit(Volume.Event.RevertSnapshotRequested);	boolean result = false;	try {	result =  snapshotSvr.revertSnapshot(snapshot);	if (!result) {	
failed to revert snapshot 

if (snapshotVO == null) {	throw new CloudRuntimeException("Failed to get lock on snapshot:" + snapshot.getId());	}	try {	VolumeInfo volumeInfo = snapshot.getBaseVolume();	volumeInfo.stateTransit(Volume.Event.SnapshotRequested);	SnapshotResult result = null;	try {	result = snapshotSvr.takeSnapshot(snapshot);	if (result.isFailed()) {	
failed to take snapshot 

volumeInfo.stateTransit(Volume.Event.OperationFailed);	}	}	snapshot = result.getSnashot();	DataStore primaryStore = snapshot.getDataStore();	boolean backupFlag = Boolean.parseBoolean(configDao.getValue(Config.BackupSnapshotAfterTakingSnapshot.toString()));	SnapshotInfo backupedSnapshot;	if(backupFlag) {	backupedSnapshot = backupSnapshot(snapshot);	} else {	
skipping backup of snapshot due to configuration 

DataStore primaryStore = snapshot.getDataStore();	boolean backupFlag = Boolean.parseBoolean(configDao.getValue(Config.BackupSnapshotAfterTakingSnapshot.toString()));	SnapshotInfo backupedSnapshot;	if(backupFlag) {	backupedSnapshot = backupSnapshot(snapshot);	} else {	SnapshotObject snapObj = (SnapshotObject)snapshot;	try {	snapObj.processEvent(Snapshot.Event.OperationNotPerformed);	} catch (NoTransitionException e) {	
failed to change state 

}	}	}	SnapshotDataStoreVO snapshotDataStoreVO = snapshotStoreDao.findByStoreSnapshot(primaryStore.getRole(), primaryStore.getId(), snapshot.getId());	if (snapshotDataStoreVO != null) {	snapshotDataStoreVO.setParentSnapshotId(0L);	snapshotStoreDao.update(snapshotDataStoreVO.getId(), snapshotDataStoreVO);	}	}	} catch (Exception e) {	
failed to clean up snapshots on primary storage 

========================= cloudstack sample_3901 =========================

public boolean validateCertificate(String certificate, String key, String domainSuffix) {	if (Strings.isNullOrEmpty(certificate) || Strings.isNullOrEmpty(key) || Strings.isNullOrEmpty(domainSuffix)) {	
invalid parameter found in certificate key domainsuffix tuple for domain 

public boolean validateCertificate(String certificate, String key, String domainSuffix) {	if (Strings.isNullOrEmpty(certificate) || Strings.isNullOrEmpty(key) || Strings.isNullOrEmpty(domainSuffix)) {	return false;	}	try {	String ksPassword = "passwordForValidation";	byte[] ksBits = CertificateHelper.buildAndSaveKeystore(domainSuffix, certificate, getKeyContent(key), ksPassword);	KeyStore ks = CertificateHelper.loadKeystore(ksBits, ksPassword);	if (ks != null) return true;	
unabled to construct keystore for domain 

public boolean validateCertificate(String certificate, String key, String domainSuffix) {	if (Strings.isNullOrEmpty(certificate) || Strings.isNullOrEmpty(key) || Strings.isNullOrEmpty(domainSuffix)) {	return false;	}	try {	String ksPassword = "passwordForValidation";	byte[] ksBits = CertificateHelper.buildAndSaveKeystore(domainSuffix, certificate, getKeyContent(key), ksPassword);	KeyStore ks = CertificateHelper.loadKeystore(ksBits, ksPassword);	if (ks != null) return true;	} catch (Exception e) {	
certificate validation failed due to exception for domain 

List<KeystoreVO> certChains = _ksDao.findCertChain();	for (KeystoreVO ks : certChains) {	Ternary<String, String, String> cert = new Ternary<String, String, String>(ks.getName(), ks.getCertificate(), null);	certs.add(cert);	}	Ternary<String, String, String> cert = new Ternary<String, String, String>(ksVo.getName(), ksVo.getCertificate(), getKeyContent(ksVo.getKey()));	certs.add(cert);	try {	return CertificateHelper.buildAndSaveKeystore(certs, storePassword);	} catch (KeyStoreException e) {	
unable to build keystore for due to keystoreexception 

for (KeystoreVO ks : certChains) {	Ternary<String, String, String> cert = new Ternary<String, String, String>(ks.getName(), ks.getCertificate(), null);	certs.add(cert);	}	Ternary<String, String, String> cert = new Ternary<String, String, String>(ksVo.getName(), ksVo.getCertificate(), getKeyContent(ksVo.getKey()));	certs.add(cert);	try {	return CertificateHelper.buildAndSaveKeystore(certs, storePassword);	} catch (KeyStoreException e) {	} catch (CertificateException e) {	
unable to build keystore for due to certificateexception 

Ternary<String, String, String> cert = new Ternary<String, String, String>(ks.getName(), ks.getCertificate(), null);	certs.add(cert);	}	Ternary<String, String, String> cert = new Ternary<String, String, String>(ksVo.getName(), ksVo.getCertificate(), getKeyContent(ksVo.getKey()));	certs.add(cert);	try {	return CertificateHelper.buildAndSaveKeystore(certs, storePassword);	} catch (KeyStoreException e) {	} catch (CertificateException e) {	} catch (NoSuchAlgorithmException e) {	
unable to build keystore for due to nosuchalgorithmexception 

certs.add(cert);	}	Ternary<String, String, String> cert = new Ternary<String, String, String>(ksVo.getName(), ksVo.getCertificate(), getKeyContent(ksVo.getKey()));	certs.add(cert);	try {	return CertificateHelper.buildAndSaveKeystore(certs, storePassword);	} catch (KeyStoreException e) {	} catch (CertificateException e) {	} catch (NoSuchAlgorithmException e) {	} catch (InvalidKeySpecException e) {	
unable to build keystore for due to invalidkeyspecexception 

}	Ternary<String, String, String> cert = new Ternary<String, String, String>(ksVo.getName(), ksVo.getCertificate(), getKeyContent(ksVo.getKey()));	certs.add(cert);	try {	return CertificateHelper.buildAndSaveKeystore(certs, storePassword);	} catch (KeyStoreException e) {	} catch (CertificateException e) {	} catch (NoSuchAlgorithmException e) {	} catch (InvalidKeySpecException e) {	} catch (IOException e) {	
unable to build keystore for due to ioexception 

========================= cloudstack sample_508 =========================

public ServiceVirtualMachine createServiceInstance(DataCenter zone, Account owner, VirtualMachineTemplate template, ServiceOffering serviceOffering, String name, Network left, Network right) {	
createserviceinstance by 

throw new CloudRuntimeException("Unable to read virtual-network object");	}	VirtualNetworkModel rightModel = _manager.getDatabase().lookupVirtualNetwork(right.getUuid(), _manager.getCanonicalName(right), right.getTrafficType());	if (rightModel == null) {	throw new CloudRuntimeException("Unable to read virtual-network object");	}	net.juniper.contrail.api.types.Project project;	try {	project = _manager.getVncProject(owner.getDomainId(), owner.getAccountId());	} catch (IOException ex) {	
read project 

project = _manager.getVncProject(owner.getDomainId(), owner.getAccountId());	} catch (IOException ex) {	throw new CloudRuntimeException(ex);	}	try {	final String srvid = api.findByName(ServiceInstance.class, project, name);	if (srvid != null) {	throw new InvalidParameterValueException("service-instance " + name + " already exists uuid=" + srvid);	}	} catch (IOException ex) {	
service instance lookup 

if (srvid != null) {	throw new InvalidParameterValueException("service-instance " + name + " already exists uuid=" + srvid);	}	} catch (IOException ex) {	throw new CloudRuntimeException(ex);	}	ServiceInstanceModel serviceModel = new ServiceInstanceModel(project, name, template, serviceOffering, leftModel, rightModel);	try {	serviceModel.update(_manager.getModelController());	} catch (Exception ex) {	
service instance update 

}	} catch (IOException ex) {	throw new CloudRuntimeException(ex);	}	ServiceInstanceModel serviceModel = new ServiceInstanceModel(project, name, template, serviceOffering, leftModel, rightModel);	try {	serviceModel.update(_manager.getModelController());	} catch (Exception ex) {	throw new CloudRuntimeException(ex);	}	
service instance object created 

try {	serviceModel.update(_manager.getModelController());	} catch (Exception ex) {	throw new CloudRuntimeException(ex);	}	ServiceInstance siObj;	try {	_manager.getDatabase().getServiceInstances().add(serviceModel);	siObj = serviceModel.getServiceInstance();	} catch (Exception ex) {	
db add 

}	ServiceInstance siObj;	try {	_manager.getDatabase().getServiceInstances().add(serviceModel);	siObj = serviceModel.getServiceInstance();	} catch (Exception ex) {	throw new CloudRuntimeException(ex);	}	String svmName = name.replace(" ", "_") + "-1";	ServiceVirtualMachine svm = createServiceVM(zone, owner, template, serviceOffering, svmName, siObj, left, right);	
created vminstance 

throw new CloudRuntimeException(ex);	}	String svmName = name.replace(" ", "_") + "-1";	ServiceVirtualMachine svm = createServiceVM(zone, owner, template, serviceOffering, svmName, siObj, left, right);	VirtualMachineModel instanceModel = new VirtualMachineModel(svm, svm.getUuid());	_manager.getDatabase().getVirtualMachines().add(instanceModel);	try {	instanceModel.setServiceInstance(_manager.getModelController(), svm, serviceModel);	instanceModel.update(_manager.getModelController());	} catch (Exception ex) {	
service virtual machine update 

public void startServiceInstance(long instanceId) {	
start service instance 

public ServiceInstanceResponse createServiceInstanceResponse(long instanceId) {	
serviceinstance response for id 

========================= cloudstack sample_1879 =========================

public static String generateSignature(String data, String key) {	try {	final Mac mac = Mac.getInstance("HmacSHA1");	final SecretKeySpec keySpec = new SecretKeySpec(key.getBytes("UTF-8"), "HmacSHA1");	mac.init(keySpec);	mac.update(data.getBytes("UTF-8"));	final byte[] encryptedBytes = mac.doFinal();	return Base64.encodeBase64String(encryptedBytes);	} catch (NoSuchAlgorithmException | InvalidKeyException | UnsupportedEncodingException e) {	
exception occurred which encoding the data 

========================= cloudstack sample_2756 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException {	try {	StorageNetworkIpRange result = _storageNetworkService.updateIpRange(this);	StorageNetworkIpRangeResponse response = _responseGenerator.createStorageNetworkIpRangeResponse(result);	response.setResponseName(getCommandName());	this.setResponseObject(response);	} catch (Exception e) {	
update storage network ip range failed 

========================= cloudstack sample_3147 =========================

public void decrRefCnt() {	if (refCnt > 0) {	refCnt--;	}	else {	
we should not try to decrement a zero reference count even though our code has guarded 

========================= cloudstack sample_4051 =========================

private CloseableHttpResponse execute(final HttpUriRequest request, final int previousStatusCode) throws CloudstackRESTException {	if (counter.hasReachedExecutionLimit()) {	throw new CloudstackRESTException("Reached max executions limit of " + executionLimit);	}	counter.incrementExecutionCounter();	s_logger.debug("Executing " + request.getMethod() + " request [execution count = " + counter.getValue() + "]");	final CloseableHttpResponse response = super.execute(request);	final StatusLine statusLine = response.getStatusLine();	final int statusCode = statusLine.getStatusCode();	
status of last request 

private String responseToErrorMessage(final CloseableHttpResponse response) {	String errorMessage = response.getStatusLine().toString();	if (response.containsHeader(CONTENT_TYPE) && TEXT_HTML_CONTENT_TYPE.equals(response.getFirstHeader(CONTENT_TYPE).getValue())) {	try {	final HttpEntity entity = response.getEntity();	final String respobnseBody = EntityUtils.toString(entity);	errorMessage = respobnseBody.subSequence(0, maxResponseErrorMesageLength).toString();	} catch (final IOException e) {	
could not read repsonse body response 

========================= cloudstack sample_1746 =========================

public void subscribe(String subject, MessageSubscriber subscriber) {	assert (subject != null);	assert (subscriber != null);	if (_gate.enter()) {	if (s_logger.isTraceEnabled()) {	
enter gate in message bus subscribe 

public void unsubscribe(String subject, MessageSubscriber subscriber) {	if (_gate.enter()) {	if (s_logger.isTraceEnabled()) {	
enter gate in message bus unsubscribe 

public void clearAll() {	if (_gate.enter()) {	if (s_logger.isTraceEnabled()) {	
enter gate in message bus clearall 

public void prune() {	if (_gate.enter()) {	if (s_logger.isTraceEnabled()) {	
enter gate in message bus prune 

public void publish(String senderAddress, String subject, PublishScope scope, Object args) {	if (!noDbTxn()){	String errMsg = "NO EVENT PUBLISH CAN BE WRAPPED WITHIN DB TRANSACTION!";	s_logger.error(errMsg, new CloudRuntimeException(errMsg));	}	if (_gate.enter(true)) {	if (s_logger.isTraceEnabled()) {	
enter gate in message bus publish 

if (_reentranceCount == 0) {	assert (_gateOwner == null);	_reentranceCount++;	_gateOwner = Thread.currentThread();	return true;	} else {	if (wait) {	try {	wait();	} catch (InterruptedException e) {	
ignored interupted while guarding re entrance on message bus 

public void leave() {	synchronized (this) {	if (_reentranceCount > 0) {	try {	assert (_gateOwner == Thread.currentThread());	onGateOpen();	} finally {	if (s_logger.isTraceEnabled()) {	
open gate of message bus 

========================= cloudstack sample_621 =========================

citrixResourceBase.destroyPatchVbd(conn, vm.getNameLabel(conn));	}	} catch (final Exception e) {	}	try {	final boolean result = citrixResourceBase.cleanupHaltedVms(conn);	if (!result) {	return new ReadyAnswer(command, "Unable to cleanup halted vms");	}	} catch (final XenAPIException e) {	
unable to cleanup halted vms 

} catch (final Exception e) {	}	try {	final boolean result = citrixResourceBase.cleanupHaltedVms(conn);	if (!result) {	return new ReadyAnswer(command, "Unable to cleanup halted vms");	}	} catch (final XenAPIException e) {	return new ReadyAnswer(command, "Unable to cleanup halted vms");	} catch (final XmlRpcException e) {	
unable to cleanup halted vms 

========================= cloudstack sample_1183 =========================

final String sshpubkeypath = libvirtUtilitiesHelper.retrieveSshPubKeyPath();	final String sshprvkeypath = libvirtUtilitiesHelper.retrieveSshPrvKeyPath();	final File sshKeysDir = new File(sshkeyspath);	String result = null;	if (!sshKeysDir.exists()) {	final Script script = new Script("mkdir", libvirtComputingResource.getTimeout(), s_logger);	script.add("-m", "700");	script.add(sshkeyspath);	script.execute();	if (!sshKeysDir.exists()) {	
failed to create directory 

========================= cloudstack sample_1029 =========================

public void execute() {	UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	
exception 

public void execute() {	UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

public void execute() {	UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ManagementServerException ex) {	
exception 

UserVm result;	try {	result = _userVmService.upgradeVirtualMachine(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ManagementServerException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (VirtualMachineMigrationException ex) {	
exception 

========================= cloudstack sample_3501 =========================

int i;	for (i = 0; i < ips.length - 1; i++) {	buf.append(ips[i]).append(".");	}	buf.append(ips[i]);	String subnet = buf.toString();	String cmd = String.format("sh /usr/bin/prepare_dhcpd.sh %1$s", subnet);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, cmd)) {	throw new ConfigurationException("prepare Dhcpd at " + _ip + " failed, command:" + cmd);	}	
dhcpd resource configure successfully 

buf.append(ips[i]).append(".");	}	buf.append(ips[i]);	String subnet = buf.toString();	String cmd = String.format("sh /usr/bin/prepare_dhcpd.sh %1$s", subnet);	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, cmd)) {	throw new ConfigurationException("prepare Dhcpd at " + _ip + " failed, command:" + cmd);	}	return true;	} catch (Exception e) {	
dhcpd resource configure failed 

========================= cloudstack sample_908 =========================

public boolean start() {	
firewall provider list is 

boolean allowPf = (rule.getPurpose() == Purpose.PortForwarding && newRule.getPurpose() == Purpose.PortForwarding && !newRule.getProtocol().equalsIgnoreCase( rule.getProtocol())) || (rule.getPurpose() == Purpose.Vpn && newRule.getPurpose() == Purpose.PortForwarding && !newRule.getProtocol().equalsIgnoreCase( rule.getProtocol()));	boolean allowStaticNat = (rule.getPurpose() == Purpose.StaticNat && newRule.getPurpose() == Purpose.StaticNat && !newRule.getProtocol().equalsIgnoreCase(rule.getProtocol()));	boolean allowVpnPf = (rule.getPurpose() == Purpose.PortForwarding && newRule.getPurpose() == Purpose.Vpn && !newRule.getProtocol().equalsIgnoreCase(rule.getProtocol()));	boolean allowVpnLb = (rule.getPurpose() == Purpose.LoadBalancing && newRule.getPurpose() == Purpose.Vpn && !newRule.getProtocol().equalsIgnoreCase(rule.getProtocol()));	if (!(allowPf || allowStaticNat || oneOfRulesIsFirewall || allowVpnPf || allowVpnLb)) {	throw new NetworkRuleConflictException("The range specified, " + newRule.getSourcePortStart() + "-" + newRule.getSourcePortEnd() + ", conflicts with rule " + rule.getId() + " which has " + rule.getSourcePortStart() + "-" + rule.getSourcePortEnd());	}	}	}	if (s_logger.isDebugEnabled()) {	
no network rule conflicts detected for against existing rules 

public boolean applyRules(List<? extends FirewallRule> rules, boolean continueOnError, boolean updateRulesInDB) throws ResourceUnavailableException {	boolean success = true;	if (rules == null || rules.size() == 0) {	
there are no rules to forward to the network elements 

public boolean applyRules(List<? extends FirewallRule> rules, boolean continueOnError, boolean updateRulesInDB) throws ResourceUnavailableException {	boolean success = true;	if (rules == null || rules.size() == 0) {	return true;	}	Purpose purpose = rules.get(0).getPurpose();	if (!_ipAddrMgr.applyRules(rules, purpose, this, continueOnError)) {	
rules are not completely applied 

for (NetworkACLServiceProvider element: _networkAclElements) {	Network.Provider provider = element.getProvider();	boolean  isAclProvider = _networkModel.isProviderSupportServiceInNetwork(network.getId(), Service.NetworkACL, provider);	if (!isAclProvider) {	continue;	}	handled = element.applyNetworkACLs(network, rules);	if (handled) break;	}	break;*/ default: assert (false) : "Unexpected fall through in applying rules to the network elements";	
firewallmanager cannot process rules of type 

public boolean applyFirewallRules(List<FirewallRuleVO> rules, boolean continueOnError, Account caller) {	if (rules.size() == 0) {	
there are no firewall rules to apply 

rule.setSourceCidrList(_firewallCidrsDao.getSourceCidrs(rule.getId()));	}	if (caller != null) {	_accountMgr.checkAccess(caller, null, true, rules.toArray(new FirewallRuleVO[rules.size()]));	}	try {	if (!applyRules(rules, continueOnError, true)) {	return false;	}	} catch (ResourceUnavailableException ex) {	
failed to apply firewall rules due to 

public boolean applyDefaultEgressFirewallRule(Long networkId, boolean defaultPolicy, boolean add) throws ResourceUnavailableException {	
applying default firewall egress rules 

sourceCidr.add(NetUtils.ALL_CIDRS);	FirewallRuleVO ruleVO = new FirewallRuleVO(null, null, null, null, "all", networkId, network.getAccountId(), network.getDomainId(), Purpose.Firewall, sourceCidr, null, null, null, FirewallRule.TrafficType.Egress, FirewallRuleType.System);	ruleVO.setState(add ? State.Add : State.Revoke);	List<FirewallRuleVO> rules = new ArrayList<FirewallRuleVO>();	rules.add(ruleVO);	try {	if (!applyRules(rules, false, false)) {	return  false;	}	} catch (ResourceUnavailableException ex) {	
failed to apply default egress rules for guest network due to 

public void revokeRule(final FirewallRuleVO rule, Account caller, long userId, final boolean needUsageEvent) {	if (caller != null) {	_accountMgr.checkAccess(caller, null, true, rule);	}	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	boolean generateUsageEvent = false;	if (rule.getState() == State.Staged) {	if (s_logger.isDebugEnabled()) {	
found a rule that is still in stage state so just removing it 

public boolean addSystemFirewallRules(IPAddressVO ip, Account acct) {	List<FirewallRuleVO> systemRules = _firewallDao.listSystemRules();	for (FirewallRuleVO rule : systemRules) {	try {	if (rule.getSourceCidrList() == null && (rule.getPurpose() == Purpose.Firewall || rule.getPurpose() == Purpose.NetworkACL)) {	_firewallDao.loadSourceCidrs(rule);	}	createFirewallRule(ip.getId(), acct, rule.getXid(), rule.getSourcePortStart(), rule.getSourcePortEnd(), rule.getProtocol(), rule.getSourceCidrList(), rule.getIcmpCode(), rule.getIcmpType(), rule.getRelated(), FirewallRuleType.System, rule.getNetworkId(), rule.getTrafficType(), true);	} catch (Exception e) {	
failed to add system wide firewall rule due to 

========================= cloudstack sample_2310 =========================

public static String getHostName() {	try {	final InetAddress localAddr = InetAddress.getLocalHost();	if (localAddr != null) {	return localAddr.getHostName();	}	} catch (final UnknownHostException e) {	
unknownhostexception when trying to get host name 

public static InetAddress getLocalInetAddress() {	try {	return InetAddress.getLocalHost();	} catch (final UnknownHostException e) {	
unknownhostexception in getlocalinetaddress 

public static String resolveToIp(final String host) {	try {	final InetAddress addr = InetAddress.getByName(host);	return ipFromInetAddress(addr);	} catch (final UnknownHostException e) {	
unable to resolve to ip due to unknownhostexception 

final List<InetAddress> addrList = new ArrayList<InetAddress>();	try {	for (final NetworkInterface ifc : IteratorUtil.enumerationAsIterable(NetworkInterface.getNetworkInterfaces())) {	if (ifc.isUp() && !ifc.isVirtual()) {	for (final InetAddress addr : IteratorUtil.enumerationAsIterable(ifc.getInetAddresses())) {	addrList.add(addr);	}	}	}	} catch (final SocketException e) {	
socketexception in getalllocalinetaddresses 

if (prefixLength < MAX_CIDR && prefixLength > 0) {	final String ip = ipFromInetAddress(addr);	if (ip.equalsIgnoreCase(defaultHostIp)) {	cidrList.add(ipAndNetMaskToCidr(ip, getCidrNetmask(prefixLength)));	}	}	}	}	}	} catch (final SocketException e) {	
unknownhostexception in getlocalcidrs 

final BufferedReader output = new BufferedReader(new InputStreamReader(result.getInputStream()));	String line = output.readLine();	while (line != null) {	final Matcher matcher = pattern.matcher(line);	if (matcher.find()) {	return matcher.group(2);	}	line = output.readLine();	}	} catch (final IOException e) {	
caught ioexception 

}	try {	nic = NetworkInterface.getByName(pubNic);	} catch (final SocketException e) {	return null;	}	String[] info = null;	try {	info = NetUtils.getNetworkParams(nic);	} catch (final NullPointerException ignored) {	
caught nullpointerexception when trying to getdefaulthostip 

public static InetAddress getFirstNonLoopbackLocalInetAddress() {	final InetAddress[] addrs = getAllLocalInetAddresses();	if (addrs != null) {	for (final InetAddress addr : addrs) {	if (s_logger.isInfoEnabled()) {	
check local inetaddress total count 

final InetAddress[] addrs = getAllLocalInetAddresses();	if (addrs != null) {	for (final InetAddress addr : addrs) {	if (s_logger.isInfoEnabled()) {	}	if (!addr.isLoopbackAddress()) {	return addr;	}	}	}	
unable to determine a non loopback address local inet address count 

final List<InetAddress> addrList = new ArrayList<InetAddress>();	try {	for (final NetworkInterface ifc : IteratorUtil.enumerationAsIterable(NetworkInterface.getNetworkInterfaces())) {	if (ifc.isUp() && !ifc.isVirtual() && ifc.getName().equals(ifName)) {	for (final InetAddress addr : IteratorUtil.enumerationAsIterable(ifc.getInetAddresses())) {	addrList.add(addr);	}	}	}	} catch (final SocketException e) {	
socketexception in getalllocalinetaddresses 

public static String getMacAddress(final InetAddress address) {	final StringBuffer sb = new StringBuffer();	final Formatter formatter = new Formatter(sb);	try {	final NetworkInterface ni = NetworkInterface.getByInetAddress(address);	final byte[] mac = ni.getHardwareAddress();	for (int i = 0; i < mac.length; i++) {	formatter.format("%02X%s", mac[i], i < mac.length - 1 ? ":" : "");	}	} catch (final SocketException e) {	
socketexception when trying to retrieve mac address 

public static long getMacAddressAsLong(final InetAddress address) {	long macAddressAsLong = 0;	try {	final NetworkInterface ni = NetworkInterface.getByInetAddress(address);	final byte[] mac = ni.getHardwareAddress();	for (int i = 0; i < mac.length; i++) {	macAddressAsLong |= (long)(mac[i] & 0xff) << (mac.length - i - 1) * 8;	}	} catch (final SocketException e) {	
socketexception when trying to retrieve mac address 

}	if (addr == null) {	return null;	}	final String[] result = new String[3];	result[0] = addr.getAddress().getHostAddress();	try {	final byte[] mac = nic.getHardwareAddress();	result[1] = byte2Mac(mac);	} catch (final SocketException e) {	
caught exception when trying to get the mac address 

public static boolean verifyDomainNameLabel(final String hostName, final boolean isHostName) {	if (hostName.length() > 63 || hostName.length() < 1) {	
domain name label must be between and characters long 

public static boolean verifyDomainNameLabel(final String hostName, final boolean isHostName) {	if (hostName.length() > 63 || hostName.length() < 1) {	return false;	} else if (!hostName.toLowerCase().matches("[a-z0-9-]*")) {	
domain name label may contain only the ascii letters a through z in a case insensitive manner 

public static boolean verifyDomainNameLabel(final String hostName, final boolean isHostName) {	if (hostName.length() > 63 || hostName.length() < 1) {	return false;	} else if (!hostName.toLowerCase().matches("[a-z0-9-]*")) {	return false;	} else if (hostName.startsWith("-") || hostName.endsWith("-")) {	
domain name label can not start with a hyphen and digit and must not end with a hyphen 

public static boolean verifyDomainNameLabel(final String hostName, final boolean isHostName) {	if (hostName.length() > 63 || hostName.length() < 1) {	return false;	} else if (!hostName.toLowerCase().matches("[a-z0-9-]*")) {	return false;	} else if (hostName.startsWith("-") || hostName.endsWith("-")) {	return false;	} else if (isHostName && hostName.matches("^[0-9-].*")) {	
host name can t start with digit 

public static boolean verifyDomainName(final String domainName) {	if (domainName.length() < 1 || domainName.length() > 190) {	
domain name must be between and characters long 

public static boolean verifyDomainName(final String domainName) {	if (domainName.length() < 1 || domainName.length() > 190) {	return false;	}	if (domainName.startsWith(".") || domainName.endsWith(".")) {	
domain name can t start or end with 

public static boolean verifyDomainName(final String domainName) {	if (domainName.length() < 1 || domainName.length() > 190) {	return false;	}	if (domainName.startsWith(".") || domainName.endsWith(".")) {	return false;	}	final String[] domainNameLabels = domainName.split("\\.");	for (int i = 0; i < domainNameLabels.length; i++) {	if (!verifyDomainNameLabel(domainNameLabels[i], false)) {	
domain name label is incorrect 

public static boolean isSameIpRange(final String cidrA, final String cidrB) {	if (!NetUtils.isValidCIDR(cidrA)) {	
invalid value of cidr 

public static boolean isSameIpRange(final String cidrA, final String cidrB) {	if (!NetUtils.isValidCIDR(cidrA)) {	return false;	}	if (!NetUtils.isValidCIDR(cidrB)) {	
invalid value of cidr 

public static boolean validateGuestCidr(final String cidr) {	final String[] allowedNetBlocks = {"10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "100.64.0.0/10"};	if (!isValidCIDR(cidr)) {	
cidr is not valid 

public static boolean validateGuestCidr(final String cidr) {	final String[] allowedNetBlocks = {"10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "100.64.0.0/10"};	if (!isValidCIDR(cidr)) {	return false;	}	for (String block: allowedNetBlocks) {	if (isNetworkAWithinNetworkB(cidr, block)) {	return true;	}	}	
cidr is not rfc or compliant 

public static boolean verifyInstanceName(final String instanceName) {	if (instanceName.contains("-") || instanceName.contains(" ") || instanceName.contains("+")) {	
instance name can not contain hyphen spaces and char 

public static boolean validateIcmpType(final long icmpType) {	if (!(icmpType >= 0 && icmpType <= 255)) {	
impctype is not within range 

public static boolean validateIcmpCode(final long icmpCode) {	if (!(icmpCode >= 0 && icmpCode <= 15)) {	
icmp code should be within range 

if (ips.length > 1) {	endIp = ips[1];	}	try {	final BigInteger startInt = convertIPv6AddressToBigInteger(IPv6Address.fromString(startIp));	final BigInteger endInt = convertIPv6AddressToBigInteger(IPv6Address.fromString(endIp));	if (endInt != null && startInt != null && startInt.compareTo(endInt) <= 0) {	return endInt.subtract(startInt).add(BigInteger.ONE);	}	} catch (final IllegalArgumentException ex) {	
failed to convert a string to an address 

========================= cloudstack sample_2740 =========================

public void shutdown() {	try {	handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	
ignored failure handling close event for bso input stream 

public void shutdown() {	try {	handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	}	try {	handleEvent(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	
ignored failure handling close event for bso output stream 

handleEvent(Event.STREAM_CLOSE, Direction.IN);	} catch (Exception e) {	}	try {	handleEvent(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	}	try {	if (bcoSslSocket != null) bcoSslSocket.close();	} catch (Exception e) {	
ignored failure handling close event for bso socket 

handleEvent(Event.STREAM_CLOSE, Direction.OUT);	} catch (Exception e) {	}	try {	if (bcoSslSocket != null) bcoSslSocket.close();	} catch (Exception e) {	}	try {	socket.close();	} catch (Exception e) {	
ignored failure handling close event for socket 

========================= cloudstack sample_5085 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {	try {	ListResponse<UcsProfileResponse> response = mgr.listUcsProfiles(this);	response.setResponseName(getCommandName());	response.setObjectName("ucsprofiles");	this.setResponseObject(response);	} catch (Exception e) {	
exception 

========================= cloudstack sample_1245 =========================

protected boolean canHandle(NetworkOffering offering, final NetworkType networkType, final PhysicalNetwork physicalNetwork) {	if (networkType == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == Network.GuestType.Isolated && isMyIsolationMethod(physicalNetwork)) {	return true;	} else {	
we only take care of guest networks of type in zone of type 

public void shutdown(NetworkProfile profile, NetworkOffering offering) {	NetworkVO networkObject = _networkDao.findById(profile.getId());	if (networkObject.getBroadcastDomainType() != BroadcastDomainType.Vxlan || networkObject.getBroadcastUri() == null) {	
broadcasturi is empty or incorrect for guestnetwork 

========================= cloudstack sample_1584 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all vm disk usage events for account 

}	List<UsageVO> usageRecords = new ArrayList<UsageVO>();	for (String key : vmDiskUsageByZone.keySet()) {	VmDiskInfo vmDiskInfo = vmDiskUsageByZone.get(key);	long ioRead = vmDiskInfo.getIORead();	long ioWrite = vmDiskInfo.getIOWrite();	long bytesRead = vmDiskInfo.getBytesRead();	long bytesWrite = vmDiskInfo.getBytesWrite();	if ((ioRead > 0L) || (ioWrite > 0L) || (bytesRead > 0L) || (bytesWrite > 0L)) {	if (s_logger.isDebugEnabled()) {	
creating vm disk usage record io read io write bytes read bytes write for account in availability zone start end 

usageRecord = new UsageVO(vmDiskInfo.getZoneId(), account.getId(), account.getDomainId(), usageDesc, bytesRead + " bytes read", UsageTypes.VM_DISK_BYTES_READ, new Double(bytesRead), vmId, null, null, null, vmDiskInfo.getVolumeId(), startDate, endDate, "VirtualMachine");	usageRecords.add(usageRecord);	usageDesc = "disk I/O write (bytes)";	if ((vmDiskInfo.getVmId() != 0) && (vmDiskInfo.getVolumeId() != 0)) {	usageDesc += " for Vm: " + vmId + " and Volume: " + volumeId;	}	usageRecord = new UsageVO(vmDiskInfo.getZoneId(), account.getId(), account.getDomainId(), usageDesc, bytesWrite + " bytes write", UsageTypes.VM_DISK_BYTES_WRITE, new Double(bytesWrite), vmId, null, null, null, vmDiskInfo.getVolumeId(), startDate, endDate, "VirtualMachine");	usageRecords.add(usageRecord);	} else {	if (s_logger.isDebugEnabled()) {	
no vm disk usage record bytes used generated for account 

========================= cloudstack sample_2652 =========================

params.put("username", "root");	params.put("password", "password");	params.put("zone", String.valueOf(host.getDataCenterId()));	params.put("pod", String.valueOf(host.getPodId()));	ServerResource resource = null;	if (host.getHypervisorType() == HypervisorType.XenServer) {	resource = new XcpOssResource();	try {	resource.configure(host.getName(), params);	} catch (ConfigurationException e) {	
failed to load resource 

========================= cloudstack sample_3940 =========================

public static void loadDriver(String dbDriver) {	String driverClass = DRIVERS.get(dbDriver);	if (driverClass == null) {	
db driver type is not supported 

public static void loadDriver(String dbDriver) {	String driverClass = DRIVERS.get(dbDriver);	if (driverClass == null) {	throw new CloudRuntimeException("DB driver type " + dbDriver + " is not supported!");	}	if (LOADED_DRIVERS.contains(dbDriver)) {	if (LOGGER.isDebugEnabled()) {	
db driver was already loaded 

}	if (LOADED_DRIVERS.contains(dbDriver)) {	if (LOGGER.isDebugEnabled()) {	}	return;	}	try {	Class.forName(driverClass).newInstance();	LOADED_DRIVERS.add(dbDriver);	if (LOGGER.isDebugEnabled()) {	
successfully loaded db driver 

if (LOGGER.isDebugEnabled()) {	}	return;	}	try {	Class.forName(driverClass).newInstance();	LOADED_DRIVERS.add(dbDriver);	if (LOGGER.isDebugEnabled()) {	}	} catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {	
failed to load db driver 

========================= cloudstack sample_549 =========================

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	super.configure(name, params);	String routerIdValue = _configDao.getValue(Config.MidoNetProviderRouterId.key());	if (routerIdValue != null) _providerRouterId = UUID.fromString(routerIdValue);	String value = _configDao.getValue(Config.MidoNetAPIServerAddress.key());	if (value == null) {	throw new ConfigurationException("Could not find midonet API location in config");	}	if (this.api == null) {	
midonet api server address is 

protected boolean canHandle(Network network, Service service) {	Long physicalNetworkId = _networkModel.getPhysicalNetworkId(network);	if (physicalNetworkId == null) {	return false;	}	if (!_networkModel.isProviderEnabledInPhysicalNetwork(physicalNetworkId, getProvider().getName())) {	return false;	}	if (service == null) {	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	
element is not a provider for the network 

}	if (!_networkModel.isProviderEnabledInPhysicalNetwork(physicalNetworkId, getProvider().getName())) {	return false;	}	if (service == null) {	if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	} else {	if (!_networkModel.isProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {	
element doesn t support service in the network 

public boolean associatePublicIP(Network network, final List<? extends PublicIpAddress> ipAddress) throws ResourceUnavailableException {	
associatepublicip called with network 

public boolean applyIps(Network network, List<? extends PublicIpAddress> ipAddress, Set<Service> services) throws ResourceUnavailableException {	
applyips called with network 

public IpDeployer getIpDeployer(Network network) {	
getipdeployer called with network 

public boolean addDhcpEntry(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	
adddhcpentry called with network nic vm 

sub = netBridge.addDhcpSubnet();	sub.subnetLength(cidrInfo.second());	sub.subnetPrefix(cidrInfo.first());	sub.defaultGateway(network.getGateway());	List<String> dcs = new ArrayList<String>();	dcs.add(dest.getDataCenter().getDns1());	sub.dnsServerAddrs(dcs);	sub.create();	}	if (sub == null) {	
failed to create dhcp subnet on midonet bridge 

public boolean applyStaticNats(Network network, List<? extends StaticNat> rules) throws ResourceUnavailableException {	
applystaticnats called with network 

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
implement called with network 

public boolean prepare(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	
prepare called with network nic vm 

public boolean release(Network network, NicProfile nic, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
release called with network nic vm 

public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	
shutdown called with network 

public boolean destroy(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {	
destroy called with network 

public boolean applyPFRules(Network network, List<PortForwardingRule> rules) throws ResourceUnavailableException {	
applypfrules called with network 

private Bridge getOrCreateNetworkBridge(long networkID, String accountUuid) {	Bridge netBridge = getNetworkBridge(networkID, accountUuid);	if (netBridge == null) {	String networkUUIDStr = String.valueOf(networkID);	
attempting to create guest network bridge 

private Bridge getOrCreateNetworkBridge(long networkID, String accountUuid) {	Bridge netBridge = getNetworkBridge(networkID, accountUuid);	if (netBridge == null) {	String networkUUIDStr = String.valueOf(networkID);	try {	netBridge = api.addBridge().tenantId(accountUuid).name(networkUUIDStr).create();	} catch (HttpInternalServerError ex) {	
bridge creation failed retrying bridge get in case it now exists 

========================= cloudstack sample_1838 =========================

if (aclId == null) {	if (aclItemCmd.getNetworkId() == null) {	throw new InvalidParameterValueException("Cannot create Network ACL Item. ACL Id or network Id is required");	}	final Network network = _networkMgr.getNetwork(aclItemCmd.getNetworkId());	if (network.getVpcId() == null) {	throw new InvalidParameterValueException("Network: " + network.getUuid() + " does not belong to VPC");	}	aclId = network.getNetworkACLId();	if (aclId == null) {	
network is not associated with any acl creating an acl before adding acl item 

final Vpc vpc = _entityMgr.findById(Vpc.class, network.getVpcId());	if (vpc == null) {	throw new InvalidParameterValueException("Unable to find Vpc associated with the Network");	}	final String aclName = "VPC_" + vpc.getName() + "_Tier_" + network.getName() + "_ACL_" + network.getUuid();	final String description = "ACL for " + aclName;	final NetworkACL acl = _networkAclMgr.createNetworkACL(aclName, description, network.getVpcId(), aclItemCmd.getDisplay());	if (acl == null) {	throw new CloudRuntimeException("Error while create ACL before adding ACL Item for network " + network.getId());	}	
created acl for network 

final String description = "ACL for " + aclName;	final NetworkACL acl = _networkAclMgr.createNetworkACL(aclName, description, network.getVpcId(), aclItemCmd.getDisplay());	if (acl == null) {	throw new CloudRuntimeException("Error while create ACL before adding ACL Item for network " + network.getId());	}	aclId = acl.getId();	try {	if (!_networkAclMgr.replaceNetworkACL(acl, (NetworkVO)network)) {	throw new CloudRuntimeException("Unable to apply auto created ACL to network " + network.getId());	}	
created acl is applied to network 

========================= cloudstack sample_2347 =========================

eventDescription.put("resource", resourceName);	eventDescription.put("id", vo.getUuid());	eventDescription.put("old-state", oldState.name());	eventDescription.put("new-state", newState.name());	String eventDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").format(new Date());	eventDescription.put("eventDateTime", eventDate);	eventMsg.setDescription(eventDescription);	try {	s_eventBus.publish(eventMsg);	} catch (EventBusException e) {	
failed to publish state change event on the the event bus 

========================= cloudstack sample_4913 =========================

public static void loadFromJar(Properties properties, String configFile) throws IOException {	InputStream stream = PropertiesUtil.openStreamFromURL(configFile);	if (stream != null) {	properties.load(stream);	} else {	
unable to find properties file 

public static Map<String, String> processConfigFile(String[] configFiles) {	Map<String, String> configMap = new HashMap<String, String>();	Properties preProcessedCommands = new Properties();	for (String configFile : configFiles) {	File commandsFile = findConfigFile(configFile);	if (commandsFile != null) {	try {	loadFromFile(preProcessedCommands, commandsFile);	} catch (IOException ioe) {	
io exception loading properties file 

if (commandsFile != null) {	try {	loadFromFile(preProcessedCommands, commandsFile);	} catch (IOException ioe) {	}	}	else {	try {	loadFromJar(preProcessedCommands, configFile);	} catch (IOException e) {	
io exception loading properties file from jar 

========================= cloudstack sample_2828 =========================

}	newOrderedPermissionsList.add(permission);	if (parentPermission != null && permission.getId() == parentPermission.getId()) {	newOrderedPermissionsList.add(permissionBeingMoved);	}	}	long sortOrder = 0L;	for (final RolePermissionVO permission : newOrderedPermissionsList) {	permission.setSortOrder(sortOrder++);	if (!update(permission.getId(), permission)) {	
failed to update item s sort order with id while moving permission with id to a new position 

========================= cloudstack sample_4155 =========================

List<QuotaTariffVO> result = new ArrayList<>();	final Filter filter = new Filter(QuotaTariffVO.class, "updatedOn", false, 0L, 1L);	final SearchCriteria<QuotaTariffVO> sc = listAllIncludedUsageType.create();	sc.setParameters("onorbefore", effectiveDate);	sc.setParameters("quotatype", quotaType);	result = search(sc, filter);	if (result != null && !result.isEmpty()) {	return result.get(0);	} else {	if (s_logger.isDebugEnabled()) {	
quotatariffdaoimpl findtariffplanbyusagetype missing quota type 

========================= cloudstack sample_660 =========================

protected void delay() {	try {	Thread.sleep(delay);	} catch (InterruptedException e) {	
ignored interupted while creating latency 

========================= cloudstack sample_5103 =========================

public boolean delete(TemplateProfile profile) {	VMTemplateVO template = profile.getTemplate();	Long templateId = template.getId();	boolean success = true;	String zoneName;	if (!template.isCrossZones() && profile.getZoneId() != null) {	zoneName = profile.getZoneId().toString();	} else {	zoneName = "all zones";	}	
attempting to mark template host refs for template as destroyed in zone 

zoneName = "all zones";	}	Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());	String eventType = EventTypes.EVENT_TEMPLATE_DELETE;	List<TemplateDataStoreVO> templateHostVOs = this._tmpltStoreDao.listByTemplate(templateId);	for (TemplateDataStoreVO vo : templateHostVOs) {	TemplateDataStoreVO lock = null;	try {	lock = _tmpltStoreDao.acquireInLockTable(vo.getId());	if (lock == null) {	
failed to acquire lock when deleting templatedatastorevo with id 

List<DataCenterVO> dcs = _dcDao.listAllIncludingRemoved();	for (DataCenterVO dc : dcs) {	UsageEventVO usageEvent = new UsageEventVO(eventType, account.getId(), dc.getId(), templateId, null);	_usageEventDao.persist(usageEvent);	}	}	VMTemplateZoneVO templateZone = _tmpltZoneDao.findByZoneTemplate(profile.getZoneId(), templateId);	if (templateZone != null) {	_tmpltZoneDao.remove(templateZone.getId());	}	
successfully marked template host refs for template as destroyed in zone 

}	VMTemplateZoneVO templateZone = _tmpltZoneDao.findByZoneTemplate(profile.getZoneId(), templateId);	if (templateZone != null) {	_tmpltZoneDao.remove(templateZone.getId());	}	if (success && (_tmpltStoreDao.listByTemplate(templateId).size() == 0)) {	long accountId = template.getAccountId();	VMTemplateVO lock = _tmpltDao.acquireInLockTable(templateId);	try {	if (lock == null) {	
failed to acquire lock when deleting template with id 

success = false;	} else if (_tmpltDao.remove(templateId)) {	_resourceLimitMgr.decrementResourceCount(accountId, ResourceType.template);	_resourceLimitMgr.recalculateResourceCount(accountId, template.getDomainId(), ResourceType.secondary_storage.getOrdinal());	}	} finally {	if (lock != null) {	_tmpltDao.releaseFromLockTable(lock.getId());	}	}	
removed template because all of its template host refs were marked as destroyed 

========================= cloudstack sample_924 =========================

}	} else {	throw new IllegalArgumentException("Domain name is null.  Please specify a valid domain name.");	}	long parent = Domain.ROOT_DOMAIN;	if (domain.getParent() != null && domain.getParent().longValue() >= Domain.ROOT_DOMAIN) {	parent = domain.getParent().longValue();	}	DomainVO parentDomain = findById(parent);	if (parentDomain == null) {	
unable to load parent domain 

}	DomainVO parentDomain = findById(parent);	if (parentDomain == null) {	return null;	}	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	txn.start();	parentDomain = this.lockRow(parent, true);	if (parentDomain == null) {	
unable to lock parent domain 

}	domain.setPath(allocPath(parentDomain, domain.getName()));	domain.setLevel(parentDomain.getLevel() + 1);	parentDomain.setNextChildSeq(parentDomain.getNextChildSeq() + 1);	parentDomain.setChildCount(parentDomain.getChildCount() + 1);	persist(domain);	update(parentDomain.getId(), parentDomain);	txn.commit();	return domain;	} catch (Exception e) {	
unable to create domain due to 

public boolean remove(Long id) {	if (id != null && id.longValue() == Domain.ROOT_DOMAIN) {	
can not remove domain as it is root domain 

public boolean remove(Long id) {	if (id != null && id.longValue() == Domain.ROOT_DOMAIN) {	return false;	} else {	if(id == null) {	
can not remove domain without id 

public boolean remove(Long id) {	if (id != null && id.longValue() == Domain.ROOT_DOMAIN) {	return false;	} else {	if(id == null) {	return false;	}	}	DomainVO domain = findById(id);	if (domain == null) {	
unable to remove domain as domain no longer exists 

} else {	if(id == null) {	return false;	}	}	DomainVO domain = findById(id);	if (domain == null) {	return true;	}	if (domain.getParent() == null) {	
invalid domain orphan 

return false;	}	String sql = "SELECT * from account where domain_id = " + id + " and removed is null";	String sql1 = "SELECT * from domain where parent = " + id + " and removed is null";	boolean success = false;	TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	txn.start();	DomainVO parentDomain = super.lockRow(domain.getParent(), true);	if (parentDomain == null) {	
unable to load parent domain 

rs = stmt.executeQuery();	if (rs.next()) {	return false;	}	parentDomain.setChildCount(parentDomain.getChildCount() - 1);	update(parentDomain.getId(), parentDomain);	success = super.remove(id);	txn.commit();	} catch (SQLException ex) {	success = false;	
error removing domain 

========================= cloudstack sample_4712 =========================

public void performDataMigration(Connection conn) {	HashMap<Long, Long> networkDomainMap = new HashMap<Long, Long>();	try {	PreparedStatement pstmt = conn.prepareStatement("SELECT id FROM networks WHERE shared=1 AND traffic_type='Guest' AND guest_type='Direct'");	ResultSet rs = pstmt.executeQuery();	
query is 

HashMap<Long, Long> networkDomainMap = new HashMap<Long, Long>();	try {	PreparedStatement pstmt = conn.prepareStatement("SELECT id FROM networks WHERE shared=1 AND traffic_type='Guest' AND guest_type='Direct'");	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	Long networkId = rs.getLong(1);	Long vlanId = null;	Long domainId = null;	pstmt = conn.prepareStatement("SELECT id FROM vlan WHERE network_id=? LIMIT 0,1");	pstmt.setLong(1, networkId);	
query is 

Long domainId = null;	pstmt = conn.prepareStatement("SELECT id FROM vlan WHERE network_id=? LIMIT 0,1");	pstmt.setLong(1, networkId);	rs = pstmt.executeQuery();	while (rs.next()) {	vlanId = rs.getLong(1);	}	if (vlanId != null) {	pstmt = conn.prepareStatement("SELECT domain_id FROM account_vlan_map WHERE domain_id IS NOT NULL AND vlan_db_id=? LIMIT 0,1");	pstmt.setLong(1, vlanId);	
query is 

private void performDbCleanup(Connection conn) {	try {	PreparedStatement pstmt = conn.prepareStatement("SELECT domain_id FROM account_vlan_map");	try {	pstmt.executeQuery();	} catch (SQLException e) {	
assuming that domain id field doesn t exist in account vlan map table no need to upgrade 

========================= cloudstack sample_4207 =========================

String prot = "http";	if (hostUseSsl) {	prot = "https";	}	url = new URL(prot + ": xmlClientConfig.setTimeZone(TimeZone.getTimeZone("UTC"));	xmlClientConfig.setServerURL(url);	xmlClientConfig.setReplyTimeout(0);	xmlClientConfig.setConnectionTimeout(60000);	xmlClientConfig.setReplyTimeout(60 * 15000);	if (hostUser != null && hostPass != null) {	
setting username 

xmlClientConfig.setConnectionTimeout(60000);	xmlClientConfig.setReplyTimeout(60 * 15000);	if (hostUser != null && hostPass != null) {	xmlClientConfig.setBasicUserName(hostUser);	xmlClientConfig.setBasicPassword(hostPass);	}	xmlClientConfig.setXmlRpcServer(null);	client.setConfig(xmlClientConfig);	client.setTypeFactory(new RpcTypeFactory(client));	} catch (MalformedURLException e) {	
incorrect url 

public Object callTimeoutInSec(String method, List<?> params, int timeout, boolean debug) throws XmlRpcException {	TimingOutCallback callback = new TimingOutCallback(timeout * 1000);	if (debug) {	
call agent with 

public Object callTimeoutInSec(String method, List<?> params, int timeout, boolean debug) throws XmlRpcException {	TimingOutCallback callback = new TimingOutCallback(timeout * 1000);	if (debug) {	}	long startTime = System.currentTimeMillis();	try {	XmlRpcClientRequestImpl req = new XmlRpcClientRequestImpl( xmlClient.getClientConfig(), method, params);	xmlClient.executeAsync(req, callback);	return callback.waitForResponse();	} catch (TimingOutCallback.TimeoutException e) {	
timeout 

if (debug) {	}	long startTime = System.currentTimeMillis();	try {	XmlRpcClientRequestImpl req = new XmlRpcClientRequestImpl( xmlClient.getClientConfig(), method, params);	xmlClient.executeAsync(req, callback);	return callback.waitForResponse();	} catch (TimingOutCallback.TimeoutException e) {	throw new XmlRpcException(e.getMessage());	} catch (XmlRpcException e) {	
xml rpc exception occured 

long startTime = System.currentTimeMillis();	try {	XmlRpcClientRequestImpl req = new XmlRpcClientRequestImpl( xmlClient.getClientConfig(), method, params);	xmlClient.executeAsync(req, callback);	return callback.waitForResponse();	} catch (TimingOutCallback.TimeoutException e) {	throw new XmlRpcException(e.getMessage());	} catch (XmlRpcException e) {	throw e;	} catch (RuntimeException e) {	
runtime exception 

XmlRpcClientRequestImpl req = new XmlRpcClientRequestImpl( xmlClient.getClientConfig(), method, params);	xmlClient.executeAsync(req, callback);	return callback.waitForResponse();	} catch (TimingOutCallback.TimeoutException e) {	throw new XmlRpcException(e.getMessage());	} catch (XmlRpcException e) {	throw e;	} catch (RuntimeException e) {	throw new XmlRpcException(e.getMessage());	} catch (Throwable e) {	
holy crap batman 

throw new XmlRpcException(e.getMessage());	} catch (XmlRpcException e) {	throw e;	} catch (RuntimeException e) {	throw new XmlRpcException(e.getMessage());	} catch (Throwable e) {	throw new XmlRpcException(e.getMessage(), e);	} finally {	long endTime = System.currentTimeMillis();	float during = (endTime - startTime) / (float) 1000;	
call finished in secs on 

========================= cloudstack sample_861 =========================

for (int i = 0; i < _waitTime * 2; i++) {	List<HostVO> hosts = _resourceMgr.listAllUpAndEnabledHosts(Host.Type.Routing, clusterId, podId, dcId);	for (HostVO host : hosts) {	if (host.getGuid().toLowerCase().startsWith(guid.toLowerCase())) {	return host;	}	}	try {	Thread.sleep(30000);	} catch (InterruptedException e) {	
failed to sleep 

for (HostVO host : hosts) {	if (host.getGuid().toLowerCase().startsWith(guid.toLowerCase())) {	return host;	}	}	try {	Thread.sleep(30000);	} catch (InterruptedException e) {	}	}	
timeout to wait for the host connecting to mgt svr assuming it is failed 

StartupCommand firstCmd = cmd[0];	if (!(firstCmd instanceof StartupRoutingCommand)) {	return null;	}	StartupRoutingCommand ssCmd = ((StartupRoutingCommand)firstCmd);	if (ssCmd.getHypervisorType() != getHypervisorType()) {	return null;	}	ClusterVO clusterVO = _clusterDao.findById(host.getClusterId());	if (clusterVO == null) {	
cannot find cluster 

public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {	if (host.getType() != Host.Type.Routing || (host.getHypervisorType() != HypervisorType.KVM && host.getHypervisorType() != HypervisorType.LXC)) {	return null;	}	_resourceMgr.deleteRoutingHost(host, isForced, isForceDeleteStorage);	try {	ShutdownCommand cmd = new ShutdownCommand(ShutdownCommand.DeleteHost, null);	_agentMgr.send(host.getId(), cmd);	} catch (AgentUnavailableException e) {	
sending shutdowncommand failed 

public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {	if (host.getType() != Host.Type.Routing || (host.getHypervisorType() != HypervisorType.KVM && host.getHypervisorType() != HypervisorType.LXC)) {	return null;	}	_resourceMgr.deleteRoutingHost(host, isForced, isForceDeleteStorage);	try {	ShutdownCommand cmd = new ShutdownCommand(ShutdownCommand.DeleteHost, null);	_agentMgr.send(host.getId(), cmd);	} catch (AgentUnavailableException e) {	} catch (OperationTimedoutException e) {	
sending shutdowncommand failed 

========================= cloudstack sample_2629 =========================

public boolean isMyIsolationMethod(final PhysicalNetwork physicalNetwork) {	if (physicalNetwork == null) {	return false;	}	List<String> methods = new ArrayList<String>();	for (final String method : physicalNetwork.getIsolationMethods()) {	methods.add(method.toLowerCase());	}	if (methods.isEmpty()) {	
empty physical isolation type for physical network 

public void deallocate(final Network network, final NicProfile nic, final VirtualMachineProfile vm) {	if (network.getSpecifyIpRanges()) {	if (s_logger.isDebugEnabled()) {	
deallocate network networkid ip 

========================= cloudstack sample_2279 =========================

} else if ("status".equalsIgnoreCase(currentNode)) {	if (value.equalsIgnoreCase("1")) {	_portProfile.status = true;	}	} else if ("max_ports".equalsIgnoreCase(currentNode)) {	_portProfile.maxPorts = Integer.parseInt(value.trim());	}	}	}	} catch (DOMException e) {	
error parsing the response 

========================= cloudstack sample_2783 =========================

public void handle(HttpExchange t) throws IOException {	try {	
resource handler 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	
process time ms 

public void handle(HttpExchange t) throws IOException {	try {	long startTick = System.currentTimeMillis();	doHandle(t);	} catch (IOException e) {	throw e;	} catch (Throwable e) {	
unexpected exception 

private void doHandle(HttpExchange t) throws Exception {	String path = t.getRequestURI().getPath();	
get resource request for 

private void doHandle(HttpExchange t) throws Exception {	String path = t.getRequestURI().getPath();	int i = path.indexOf("/", 1);	String filepath = path.substring(i + 1);	i = path.lastIndexOf(".");	String extension = (i == -1) ? "" : path.substring(i + 1);	String contentType = getContentType(extension);	if (!validatePath(filepath)) {	
resource access is forbidden uri 

File f = new File("./" + filepath);	if (f.exists()) {	long lastModified = f.lastModified();	String ifModifiedSince = t.getRequestHeaders().getFirst("If-Modified-Since");	if (ifModifiedSince != null) {	long d = Date.parse(ifModifiedSince);	if (d + 1000 >= lastModified) {	Headers hds = t.getResponseHeaders();	hds.set("Content-Type", contentType);	t.sendResponseHeaders(304, -1);	
sent file has not been modified since 

t.sendResponseHeaders(304, -1);	return;	}	}	long length = f.length();	Headers hds = t.getResponseHeaders();	hds.set("Content-Type", contentType);	hds.set("Last-Modified", new Date(lastModified).toGMTString());	t.sendResponseHeaders(200, length);	responseFileContent(t, f);	
sent file with content type 

return;	}	}	long length = f.length();	Headers hds = t.getResponseHeaders();	hds.set("Content-Type", contentType);	hds.set("Last-Modified", new Date(lastModified).toGMTString());	t.sendResponseHeaders(200, length);	responseFileContent(t, f);	} else {	
file does not exist 

private static boolean validatePath(String path) {	int i = path.indexOf("/");	if (i == -1) {	
invalid resource path can not start at resource root 

private static boolean validatePath(String path) {	int i = path.indexOf("/");	if (i == -1) {	return false;	}	if (path.contains("..")) {	
invalid resource path contains relative up level navigation 

========================= cloudstack sample_4968 =========================

if (result != null) {	response.setId(result.getUuid());	response.setName(result.getVmwareDatacenterName());	response.setResponseName(getCommandName());	response.setObjectName("vmwaredc");	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add VMware Datacenter to zone.");	}	this.setResponseObject(response);	} catch (DiscoveryException ex) {	
exception 

response.setName(result.getVmwareDatacenterName());	response.setResponseName(getCommandName());	response.setObjectName("vmwaredc");	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add VMware Datacenter to zone.");	}	this.setResponseObject(response);	} catch (DiscoveryException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ResourceInUseException ex) {	
exception 

========================= cloudstack sample_1269 =========================

public EngineDataCenterVO findByTokenOrIdOrName(String tokenOrIdOrName) {	EngineDataCenterVO result = findByToken(tokenOrIdOrName);	if (result == null) {	result = findByName(tokenOrIdOrName);	if (result == null) {	try {	Long dcId = Long.parseLong(tokenOrIdOrName);	return findById(dcId);	} catch (NumberFormatException nfe) {	
cannot parse into long 

========================= cloudstack sample_4745 =========================

case IN_PROGRESS: s_logger.info("Resuming jobId: " + jobId + ", status=" + status);	td.setResume(true);	threadPool.execute(td);	break;	case RECOVERABLE_ERROR: threadPool.execute(td);	break;	case DOWNLOAD_FINISHED: if(td instanceof S3TemplateDownloader) {	td.setDownloadError("Download success, starting install ");	String result = postRemoteDownload(jobId);	if (result != null) {	
failed post download install 

((S3TemplateDownloader) td).cleanupAfterError();	} else {	td.setStatus(Status.POST_DOWNLOAD_FINISHED);	td.setDownloadError("Install completed successfully at " + new SimpleDateFormat().format(new Date()));	}	}	else {	td.setDownloadError("Download success, starting install ");	String result = postLocalDownload(jobId);	if (result != null) {	
failed post download script 

private String postLocalDownload(String jobId) {	DownloadJob dnld = jobs.get(jobId);	TemplateDownloader td = dnld.getTemplateDownloader();	String resourcePath = dnld.getInstallPathPrefix();	String finalResourcePath = dnld.getTmpltPath();	ResourceType resourceType = dnld.getResourceType();	File originalTemplate = new File(td.getDownloadLocalPath());	String checkSum = computeCheckSum(originalTemplate);	if (checkSum == null) {	
something wrong happened when try to calculate the checksum of downloaded template 

propertiesFile += "/template.properties";	} else {	propertiesFile += "/volume.properties";	}	File templateProperties = new File(propertiesFile);	_storage.setWorldReadableAndWriteable(templateProperties);	TemplateLocation loc = new TemplateLocation(_storage, resourcePath);	try {	loc.create(dnld.getId(), true, dnld.getTmpltName());	} catch (IOException e) {	
something is wrong with template location 

loc.purge();	return "Unable to download due to " + e.getMessage();	}	Iterator<Processor> en = _processors.values().iterator();	while (en.hasNext()) {	Processor processor = en.next();	FormatInfo info = null;	try {	info = processor.process(resourcePath, null, templateName);	} catch (InternalErrorException e) {	
template process exception 

if(!loc.addFormat(info)) {	loc.purge();	return "Unable to install due to invalid file format";	}	dnld.setTemplatesize(info.virtualSize);	dnld.setTemplatePhysicalSize(info.size);	break;	}	}	if (!loc.save()) {	
cleaning up because we re unable to save the formats 

public String downloadPublicTemplate(long id, String url, String name, ImageFormat format, boolean hvm, Long accountId, String descr, String cksum, String installPathPrefix, String templatePath, String user, String password, long maxTemplateSizeInBytes, Proxy proxy, ResourceType resourceType) {	UUID uuid = UUID.randomUUID();	String jobId = uuid.toString();	String tmpDir = installPathPrefix;	try {	if (!_storage.mkdirs(tmpDir)) {	
unable to create 

UUID uuid = UUID.randomUUID();	String jobId = uuid.toString();	String tmpDir = installPathPrefix;	try {	if (!_storage.mkdirs(tmpDir)) {	return "Unable to create " + tmpDir;	}	File file = ResourceType.TEMPLATE == resourceType ? _storage.getFile(tmpDir + File.separator + TemplateLocation.Filename) : _storage.getFile(tmpDir + File.separator + "volume.properties");	if (file.exists()) {	if(! file.delete()) {	
deletion of file failed 

try {	if (!_storage.mkdirs(tmpDir)) {	return "Unable to create " + tmpDir;	}	File file = ResourceType.TEMPLATE == resourceType ? _storage.getFile(tmpDir + File.separator + TemplateLocation.Filename) : _storage.getFile(tmpDir + File.separator + "volume.properties");	if (file.exists()) {	if(! file.delete()) {	}	}	if (!file.createNewFile()) {	
unable to create new file 

}	} else {	throw new CloudRuntimeException("Unable to download from URL: " + url);	}	DownloadJob dj = new DownloadJob(td, jobId, id, name, format, hvm, accountId, descr, cksum, installPathPrefix, resourceType);	dj.setTmpltPath(templatePath);	jobs.put(jobId, dj);	threadPool.execute(td);	return jobId;	} catch (IOException e) {	
unable to download to 

private List<String> listVolumes(String rootdir) {	List<String> result = new ArrayList<String>();	Script script = new Script(listVolScr, s_logger);	script.add("-r", rootdir);	ZfsPathParser zpp = new ZfsPathParser(rootdir);	script.execute(zpp);	result.addAll(zpp.getPaths());	
found volumes 

private List<String> listTemplates(String rootdir) {	List<String> result = new ArrayList<String>();	Script script = new Script(listTmpltScr, s_logger);	script.add("-r", rootdir);	ZfsPathParser zpp = new ZfsPathParser(rootdir);	script.execute(zpp);	result.addAll(zpp.getPaths());	
found templates 

String templateDir = rootDir + File.separator + _templateDir;	if (!_storage.exists(templateDir)) {	_storage.mkdirs(templateDir);	}	List<String> publicTmplts = listTemplates(templateDir);	for (String tmplt : publicTmplts) {	String path = tmplt.substring(0, tmplt.lastIndexOf(File.separator));	TemplateLocation loc = new TemplateLocation(_storage, path);	try {	if (!loc.load()) {	
post download installation was not completed for 

List<String> publicTmplts = listTemplates(templateDir);	for (String tmplt : publicTmplts) {	String path = tmplt.substring(0, tmplt.lastIndexOf(File.separator));	TemplateLocation loc = new TemplateLocation(_storage, path);	try {	if (!loc.load()) {	_storage.cleanup(path, templateDir);	continue;	}	} catch (IOException e) {	
unable to load template location 

TemplateProp tInfo = loc.getTemplateInfo();	if ((tInfo.getSize() == tInfo.getPhysicalSize()) && (tInfo.getInstallPath().endsWith(ImageFormat.OVA.getFileExtension()))) {	try {	Processor processor = _processors.get("OVA Processor");	OVAProcessor vmdkProcessor = (OVAProcessor)processor;	long vSize = vmdkProcessor.getTemplateVirtualSize(path, tInfo.getInstallPath().substring(tInfo.getInstallPath().lastIndexOf(File.separator) + 1));	tInfo.setSize(vSize);	loc.updateVirtualSize(vSize);	loc.save();	} catch (Exception e) {	
unable to get the virtual size of the template due to 

Processor processor = _processors.get("OVA Processor");	OVAProcessor vmdkProcessor = (OVAProcessor)processor;	long vSize = vmdkProcessor.getTemplateVirtualSize(path, tInfo.getInstallPath().substring(tInfo.getInstallPath().lastIndexOf(File.separator) + 1));	tInfo.setSize(vSize);	loc.updateVirtualSize(vSize);	loc.save();	} catch (Exception e) {	}	}	result.put(tInfo.getTemplateName(), tInfo);	
added template name path 

}	}	result.put(tInfo.getTemplateName(), tInfo);	}	for (String tmplt : isoTmplts) {	String tmp[];	tmp = tmplt.split("/");	String tmpltName = tmp[tmp.length - 2];	tmplt = tmplt.substring(tmplt.lastIndexOf("iso/"));	TemplateInfo tInfo = new TemplateInfo(tmpltName, tmplt, false);	
added iso template name path 

String volumeDir = rootDir + File.separator + _volumeDir;	if (!_storage.exists(volumeDir)) {	_storage.mkdirs(volumeDir);	}	List<String> vols = listVolumes(volumeDir);	for (String vol : vols) {	String path = vol.substring(0, vol.lastIndexOf(File.separator));	TemplateLocation loc = new TemplateLocation(_storage, path);	try {	if (!loc.load()) {	
post download installation was not completed for 

List<String> vols = listVolumes(volumeDir);	for (String vol : vols) {	String path = vol.substring(0, vol.lastIndexOf(File.separator));	TemplateLocation loc = new TemplateLocation(_storage, path);	try {	if (!loc.load()) {	_storage.cleanup(path, volumeDir);	continue;	}	} catch (IOException e) {	
unable to load volume location 

TemplateProp vInfo = loc.getTemplateInfo();	if ((vInfo.getSize() == vInfo.getPhysicalSize()) && (vInfo.getInstallPath().endsWith(ImageFormat.OVA.getFileExtension()))) {	try {	Processor processor = _processors.get("OVA Processor");	OVAProcessor vmdkProcessor = (OVAProcessor)processor;	long vSize = vmdkProcessor.getTemplateVirtualSize(path, vInfo.getInstallPath().substring(vInfo.getInstallPath().lastIndexOf(File.separator) + 1));	vInfo.setSize(vSize);	loc.updateVirtualSize(vSize);	loc.save();	} catch (Exception e) {	
unable to get the virtual size of the volume due to 

Processor processor = _processors.get("OVA Processor");	OVAProcessor vmdkProcessor = (OVAProcessor)processor;	long vSize = vmdkProcessor.getTemplateVirtualSize(path, vInfo.getInstallPath().substring(vInfo.getInstallPath().lastIndexOf(File.separator) + 1));	vInfo.setSize(vSize);	loc.updateVirtualSize(vSize);	loc.save();	} catch (Exception e) {	}	}	result.put(vInfo.getId(), vInfo);	
added volume name path 

} catch (ClassNotFoundException e) {	throw new ConfigurationException("Unable to instantiate " + value);	} catch (InstantiationException e) {	throw new ConfigurationException("Unable to instantiate " + value);	} catch (IllegalAccessException e) {	throw new ConfigurationException("Unable to instantiate " + value);	}	}	String inSystemVM = (String)params.get("secondary.storage.vm");	if (inSystemVM != null && "true".equalsIgnoreCase(inSystemVM)) {	
downloadmanager starting additional services since we are inside system vm 

value = (String)params.get("install.numthreads");	final int numInstallThreads = NumbersUtil.parseInt(value, 10);	String scriptsDir = (String)params.get("template.scripts.dir");	if (scriptsDir == null) {	scriptsDir = "scripts/storage/secondary";	}	listTmpltScr = Script.findScript(scriptsDir, "listvmtmplt.sh");	if (listTmpltScr == null) {	throw new ConfigurationException("Unable to find the listvmtmplt.sh");	}	
listvmtmplt sh found in 

scriptsDir = "scripts/storage/secondary";	}	listTmpltScr = Script.findScript(scriptsDir, "listvmtmplt.sh");	if (listTmpltScr == null) {	throw new ConfigurationException("Unable to find the listvmtmplt.sh");	}	createTmpltScr = Script.findScript(scriptsDir, "createtmplt.sh");	if (createTmpltScr == null) {	throw new ConfigurationException("Unable to find createtmplt.sh");	}	
createtmplt sh found in 

throw new ConfigurationException("Unable to find the listvmtmplt.sh");	}	createTmpltScr = Script.findScript(scriptsDir, "createtmplt.sh");	if (createTmpltScr == null) {	throw new ConfigurationException("Unable to find createtmplt.sh");	}	listVolScr = Script.findScript(scriptsDir, "listvolume.sh");	if (listVolScr == null) {	throw new ConfigurationException("Unable to find the listvolume.sh");	}	
listvolume sh found in 

throw new ConfigurationException("Unable to find createtmplt.sh");	}	listVolScr = Script.findScript(scriptsDir, "listvolume.sh");	if (listVolScr == null) {	throw new ConfigurationException("Unable to find the listvolume.sh");	}	createVolScr = Script.findScript(scriptsDir, "createvolume.sh");	if (createVolScr == null) {	throw new ConfigurationException("Unable to find createvolume.sh");	}	
createvolume sh found in 

========================= cloudstack sample_5011 =========================

private boolean refreshSrxConnection() {	if (!(closeSocket() && openSocket())) {	return false;	}	try {	return login();	} catch (ExecutionException e) {	
failed to login due to 

if (ip.isAdd()) {	implementGuestNetwork(type, publicVlanTag, sourceNatIpAddress, guestVlanTag, guestVlanGateway, guestVlanSubnet, cidrSize);	}	commitConfiguration();	results[i++] = ip.getPublicIp() + " - success";	} catch (ExecutionException e) {	s_logger.error(e);	closeConfiguration();	if (numRetries > 0 && refreshSrxConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying ipassoccommand number of retries remaining 

}	}	commitConfiguration();	}	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	closeConfiguration();	if (numRetries > 0 && refreshSrxConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying setfirewallrulescommand number of retries remaining 

addStaticNatRule(publicVlanTag, publicIp, privateIp, activeRulesForIpPair);	}	}	commitConfiguration();	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	closeConfiguration();	if (numRetries > 0 && refreshSrxConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying setportforwardingrulescommand number of retries remaining 

private void addStaticNatRule(Long publicVlanTag, String publicIp, String privateIp, List<FirewallRuleTO> rules) throws ExecutionException {	manageStaticNatRule(SrxCommand.ADD, publicIp, privateIp);	manageAddressBookEntry(SrxCommand.ADD, _privateZone, privateIp, null);	manageProxyArp(SrxCommand.ADD, publicVlanTag, publicIp);	addSecurityPolicyAndApplications(SecurityPolicyType.STATIC_NAT, privateIp, extractApplications(rules));	
added static nat rule for public ip and private ip 

private void removeStaticNatRule(Long publicVlanTag, String publicIp, String privateIp) throws ExecutionException {	manageStaticNatRule(SrxCommand.DELETE, publicIp, privateIp);	removeSecurityPolicyAndApplications(SecurityPolicyType.STATIC_NAT, privateIp);	manageAddressBookEntry(SrxCommand.DELETE, _privateZone, privateIp, null);	manageProxyArp(SrxCommand.DELETE, publicVlanTag, publicIp);	
removed static nat rule for public ip and private ip 

private void removeStaticNatRules(Long privateVlanTag, Map<String, Long> publicVlanTags, List<String[]> staticNatRules) throws ExecutionException {	for (String[] staticNatRuleToRemove : staticNatRules) {	String staticNatRulePublicIp = staticNatRuleToRemove[0];	String staticNatRulePrivateIp = staticNatRuleToRemove[1];	Long publicVlanTag = null;	if (publicVlanTags.containsKey(staticNatRulePublicIp)) {	publicVlanTag = publicVlanTags.get(staticNatRulePublicIp);	}	if (privateVlanTag != null) {	
found a static nat rule for guest vlan with tag that is active when the guest network is being removed removing rule 

manageIkePolicy(SrxCommand.ADD, null, accountId, preSharedKey);	manageAddressPool(SrxCommand.ADD, null, accountId, guestNetworkCidr, ipRange[0], ipRange[1], _primaryDnsAddress);	}	commitConfiguration();	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	closeConfiguration();	if (numRetries > 0 && refreshSrxConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying remoteaccessvpncfgcommand number of retries remaining 

manageAddressBookEntry(srxCmd, _privateZone, guestNetworkCidr, ipsecVpnName);	manageSecurityPolicy(SecurityPolicyType.VPN, srxCmd, null, null, guestNetworkCidr, null, null, ipsecVpnName, false);	}	commitConfiguration();	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	closeConfiguration();	if (numRetries > 0 && refreshSrxConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying remoteaccessvpncfgcommand number of retries remaining 

addDestinationNatRule(getProtocol(rule.getProtocol()), publicVlanTag, portForwardingRule.getSrcIp(), portForwardingRule.getDstIp(), portForwardingRule.getSrcPortRange()[0], portForwardingRule.getSrcPortRange()[1], portForwardingRule.getDstPortRange()[0], portForwardingRule.getDstPortRange()[1]);	}	}	commitConfiguration();	return new Answer(cmd);	} catch (ExecutionException e) {	s_logger.error(e);	closeConfiguration();	if (numRetries > 0 && refreshSrxConnection()) {	int numRetriesRemaining = numRetries - 1;	
retrying setportforwardingrulescommand number of retries remaining 

manageDestinationNatRule(SrxCommand.ADD, publicIp, privateIp, srcPort, destPort);	offset += 1;	}	manageAddressBookEntry(SrxCommand.ADD, _privateZone, privateIp, null);	List<Object[]> applications = new ArrayList<Object[]>();	applications.add(new Object[] {protocol, destPortStart, destPortEnd});	addSecurityPolicyAndApplications(SecurityPolicyType.DESTINATION_NAT, privateIp, applications);	manageProxyArp(SrxCommand.ADD, publicVlanTag, publicIp);	String srcPortRange = srcPortStart + "-" + srcPortEnd;	String destPortRange = destPortStart + "-" + destPortEnd;	
added destination nat rule for protocol public ip private ip source port range and dest port range 

private void removeDestinationNatRule(Long publicVlanTag, String publicIp, String privateIp, int srcPort, int destPort) throws ExecutionException {	manageDestinationNatRule(SrxCommand.DELETE, publicIp, privateIp, srcPort, destPort);	manageDestinationNatPool(SrxCommand.DELETE, privateIp, destPort);	manageProxyArp(SrxCommand.DELETE, publicVlanTag, publicIp);	removeSecurityPolicyAndApplications(SecurityPolicyType.DESTINATION_NAT, privateIp);	manageAddressBookEntry(SrxCommand.DELETE, _privateZone, privateIp, null);	
removed destination nat rule for public ip private ip source port and dest port 

for (String[] destNatRule : destNatRules) {	String publicIp = destNatRule[0];	String privateIp = destNatRule[1];	int srcPort = Integer.parseInt(destNatRule[2]);	int destPort = Integer.parseInt(destNatRule[3]);	Long publicVlanTag = null;	if (publicVlanTags.containsKey(publicIp)) {	publicVlanTag = publicVlanTags.get(publicIp);	}	if (privateVlanTag != null) {	
found a destination nat rule public ip private ip public port private port for guest vlan with tag that is active when the guest network is being removed removing rule 

return true;	}	xml = SrxXml.IKE_GATEWAY_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "policy-name", ikePolicyName);	if (!sendRequestAndCheckResponse(command, xml, "name", ikePolicyName)) {	throw new ExecutionException("Failed to delete IKE policy: " + ikePolicyName);	} else {	return true;	}	
unrecognized command 

return true;	}	xml = SrxXml.IKE_GATEWAY_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "gateway-name", ikeGatewayName);	if (!sendRequestAndCheckResponse(command, xml, "name", ikeGatewayName)) {	throw new ExecutionException("Failed to delete IKE gateway: " + ikeGatewayName);	} else {	return true;	}	
unrecognized command 

return true;	}	xml = SrxXml.IPSEC_VPN_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "ipsec-vpn-name", ipsecVpnName);	if (!sendRequestAndCheckResponse(command, xml, "name", ipsecVpnName)) {	throw new ExecutionException("Failed to delete IPSec VPN: " + ipsecVpnName);	} else {	return true;	}	
unrecognized command 

return true;	}	xml = SrxXml.DYNAMIC_VPN_CLIENT_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "client-name", clientName);	if (!sendRequestAndCheckResponse(command, xml, "name", clientName)) {	throw new ExecutionException("Failed to delete dynamic VPN client: " + clientName);	} else {	return true;	}	
unrecognized command 

return true;	}	xml = SrxXml.ADDRESS_POOL_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "address-pool-name", addressPoolName);	if (!sendRequestAndCheckResponse(command, xml, "name", addressPoolName)) {	throw new ExecutionException("Failed to delete address pool: " + addressPoolName);	} else {	return true;	}	
unrecognized command 

return true;	}	xml = SrxXml.ACCESS_PROFILE_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "access-profile-name", accessProfileName);	if (!sendRequestAndCheckResponse(command, xml, "name", username)) {	throw new ExecutionException("Failed to delete access profile: " + accessProfileName);	} else {	return true;	}	
unrecognized command 

}	xml = SrxXml.PRIVATE_INTERFACE_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "private-interface-name", _privateInterface);	xml = replaceXmlValue(xml, "vlan-id", String.valueOf(vlanTag));	if (!sendRequestAndCheckResponse(command, xml, "name", String.valueOf(vlanTag))) {	throw new ExecutionException("Failed to delete private interface for guest VLAN tag " + vlanTag);	} else {	return true;	}	
unrecognized command 

}	xml = SrxXml.PROXY_ARP_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "public-interface-name", publicInterface);	xml = replaceXmlValue(xml, "public-ip-address", publicIp);	if (!sendRequestAndCheckResponse(command, xml, "name", publicIp)) {	throw new ExecutionException("Failed to delete proxy ARP entry for public IP " + publicIp);	} else {	return true;	}	
unrecognized command 

}	xml = SrxXml.ZONE_INTERFACE_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "private-zone-name", _privateZone);	xml = replaceXmlValue(xml, "zone-interface-name", zoneInterfaceName);	if (!sendRequestAndCheckResponse(command, xml, "name", zoneInterfaceName)) {	throw new ExecutionException("Failed to delete interface " + zoneInterfaceName + " from zone " + _privateZone);	} else {	return true;	}	
unrecognized command 

}	String rulePublicIp = nameContents[0] + "." + nameContents[1] + "." + nameContents[2] + "." + nameContents[3];	String rulePrivateIp = nameContents[4] + "." + nameContents[5] + "." + nameContents[6] + "." + nameContents[7];	boolean addToList = false;	if (condition.equals(RuleMatchCondition.ALL)) {	addToList = true;	} else if (condition.equals(RuleMatchCondition.PRIVATE_SUBNET)) {	assert (privateGateway != null && privateCidrSize != null);	addToList = NetUtils.sameSubnetCIDR(rulePrivateIp, privateGateway, privateCidrSize);	} else {	
invalid rule match condition 

xml = SrxXml.DEST_NAT_RULE_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "rule-set", _publicZone);	xml = replaceXmlValue(xml, "from-zone", _publicZone);	xml = replaceXmlValue(xml, "rule-name", ruleName);	if (!sendRequestAndCheckResponse(command, xml)) {	throw new ExecutionException("Failed to delete destination NAT rule from public IP " + publicIp + ", public port " + srcPort + ", private IP " + privateIp + ", and private port " + destPort);	} else {	return true;	}	
unrecognized command 

return true;	}	xml = SrxXml.SRC_NAT_POOL_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "pool-name", poolName);	if (!sendRequestAndCheckResponse(command, xml)) {	throw new ExecutionException("Failed to delete source NAT pool for public IP " + publicIp);	} else {	return true;	}	
unrecognized command 

xml = SrxXml.SRC_NAT_RULE_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "rule-set", _privateZone);	xml = replaceXmlValue(xml, "from-zone", _privateZone);	xml = replaceXmlValue(xml, "rule-name", ruleName);	if (!sendRequestAndCheckResponse(command, xml, "name", ruleName)) {	throw new ExecutionException("Failed to delete source NAT rule for public IP " + publicIp + " and private subnet " + privateSubnet);	} else {	return true;	}	
unrecognized command 

}	xml = SrxXml.ADDRESS_BOOK_ENTRY_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "zone", zone);	xml = replaceXmlValue(xml, "entry-name", entryName);	if (!sendRequestAndCheckResponse(command, xml)) {	throw new ExecutionException("Failed to delete address book entry for IP " + ip + " in zone " + zone);	} else {	return true;	}	
unrecognized command 

return true;	}	xml = SrxXml.APPLICATION_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "name", applicationName);	if (!sendRequestAndCheckResponse(command, xml)) {	throw new ExecutionException("Failed to delete application " + applicationName);	} else {	return true;	}	
unrecognized command 

throw new ExecutionException("Deleted security policy, but failed to delete security policy group.");	} else {	return true;	}	} else {	return true;	}	} else {	throw new ExecutionException("Failed to delete security policy for privateIp " + privateIp + " and applications " + applicationNames);	}	
unrecognized command 

return true;	}	List<String> applications = getApplicationsForSecurityPolicy(type, privateIp, _publicZone, _privateZone);	manageSecurityPolicy(type, SrxCommand.DELETE, null, null, privateIp, null, null, null, false);	List<String> unusedApplications = getUnusedApplications(applications, _publicZone, _privateZone);	for (String application : unusedApplications) {	Object[] applicationComponents;	try {	applicationComponents = parseApplicationName(type, application);	} catch (ExecutionException e) {	
found an invalid application not attempting to clean up 

List<String> applications;	applications = getApplicationsForSecurityPolicy(type, guestVlan, _privateZone, _publicZone);	manageSecurityPolicy(type, SrxCommand.DELETE, null, null, guestVlan, null, cidrs, null, defaultEgressAction);	List<String> unusedApplications;	unusedApplications = getUnusedApplications(applications, _privateZone, _publicZone);	for (String application : unusedApplications) {	Object[] applicationComponents;	try {	applicationComponents = parseApplicationName(type, application);	} catch (ExecutionException e) {	
found an invalid application not attempting to clean up 

if (!applicationNames.contains(applicationName)) {	applicationNames.add(applicationName);	}	manageApplication(type, SrxCommand.ADD, protocol, startPort, endPort);	}	}	for (String cidr : cidrs) {	manageAddressBookEntry(SrxCommand.ADD, _privateZone, cidr, null);	}	manageSecurityPolicy(type, SrxCommand.ADD, null, null, guestVlan, applicationNames, cidrs, null, defaultEgressAction);	
added egress firewall rule for guest network 

boolean deleteFilter = filter.equals(_usageFilterVlanInput) || filter.equals(_usageFilterVlanOutput);	xml = deleteFilter ? SrxXml.FILTER_GETONE.getXml() : SrxXml.FILTER_TERM_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "filter-name", filterName);	xml = !deleteFilter ? replaceXmlValue(xml, "term-name", filterTermName) : xml;	if (!sendRequestAndCheckResponse(command, xml)) {	throw new ExecutionException("Failed to delete usage filter: " + filterDescription);	} else {	return true;	}	
unrecognized command 

}	xml = SrxXml.FIREWALL_FILTER_TERM_GETONE.getXml();	xml = setDelete(xml, true);	xml = replaceXmlValue(xml, "filter-name", filterName);	xml = replaceXmlValue(xml, "term-name", term.getName());	if (!sendRequestAndCheckResponse(command, xml)) {	throw new ExecutionException("Failed to delete firewall filter: " + term.getName());	} else {	return true;	}	
unrecognized command 

private void updateUsageAnswer(ExternalNetworkResourceUsageAnswer answer, String counterName, long byteCount) {	if (counterName == null || byteCount <= 0) {	return;	}	UsageFilter filter = getUsageFilter(counterName);	if (filter == null) {	
failed to parse counter name in usage answer 

private String sendRequestPrim(BufferedWriter sendStream, BufferedReader recvStream, String xmlRequest) throws ExecutionException {	if (!xmlRequest.contains("request-login")) {	
sending request 

private String sendRequestPrim(BufferedWriter sendStream, BufferedReader recvStream, String xmlRequest) throws ExecutionException {	if (!xmlRequest.contains("request-login")) {	} else {	
sending login request 

private boolean checkResponse(String xmlResponse, boolean errorKeyAndValue, String key, String value) {	if (xmlResponse == null) {	
failed to communicate with srx 

private boolean checkResponse(String xmlResponse, boolean errorKeyAndValue, String key, String value) {	if (xmlResponse == null) {	return false;	}	if (!xmlResponse.contains("authentication-response")) {	
checking response 

private boolean checkResponse(String xmlResponse, boolean errorKeyAndValue, String key, String value) {	if (xmlResponse == null) {	return false;	}	if (!xmlResponse.contains("authentication-response")) {	} else {	
checking login response 

}	String textToSearchFor = key;	if (value != null) {	textToSearchFor = "<" + key + ">" + value + "</" + key + ">";	}	if ((errorKeyAndValue && !xmlResponse.contains(textToSearchFor)) || (!errorKeyAndValue && xmlResponse.contains(textToSearchFor))) {	return true;	}	String responseMessage = extractXml(xmlResponse, "message");	if (responseMessage != null) {	
request failed due to 

if (value != null) {	textToSearchFor = "<" + key + ">" + value + "</" + key + ">";	}	if ((errorKeyAndValue && !xmlResponse.contains(textToSearchFor)) || (!errorKeyAndValue && xmlResponse.contains(textToSearchFor))) {	return true;	}	String responseMessage = extractXml(xmlResponse, "message");	if (responseMessage != null) {	} else {	if (errorKeyAndValue) {	
found error in response 

textToSearchFor = "<" + key + ">" + value + "</" + key + ">";	}	if ((errorKeyAndValue && !xmlResponse.contains(textToSearchFor)) || (!errorKeyAndValue && xmlResponse.contains(textToSearchFor))) {	return true;	}	String responseMessage = extractXml(xmlResponse, "message");	if (responseMessage != null) {	} else {	if (errorKeyAndValue) {	} else {	
didn t find in response 

========================= cloudstack sample_1402 =========================

String msg = "must specify pod Id when add host";	LOGGER.info(msg);	throw new DiscoveryException(msg);	}	ClusterVO cluster = clusterDao.findById(clusterId);	if (cluster == null || (cluster.getHypervisorType() != HypervisorType.Ovm3)) {	String msg = "invalid cluster id or cluster is not for Ovm3 hypervisors";	LOGGER.info(msg);	throw new DiscoveryException(msg);	} else {	
cluster 

try {	String hostname = url.getHost();	InetAddress ia = InetAddress.getByName(hostname);	String hostIp = ia.getHostAddress();	String guid = UUID.nameUUIDFromBytes(hostIp.getBytes("UTF8")) .toString();	if (checkIfExisted(guid)) {	String msg = "The host " + hostIp + " has been added before";	LOGGER.info(msg);	throw new DiscoveryException(msg);	}	
discover is going to disover host having guid 

Linux host = new Linux(c);	details.put("agentVersion", host.getAgentVersion());	details.put(HostInfo.HOST_OS_KERNEL_VERSION, host.getHostKernelRelease());	details.put(HostInfo.HOST_OS, host.getHostOs());	details.put(HostInfo.HOST_OS_VERSION, host.getHostOsVersion());	details.put(HostInfo.HYPERVISOR_VERSION, host.getHypervisorVersion());	Map<Ovm3HypervisorResource, Map<String, String>> resources = new HashMap<Ovm3HypervisorResource, Map<String, String>>();	resources.put(ovmResource, details);	return resources;	} catch (UnknownHostException e) {	
host name resolve failed exception unable to discover host 

details.put(HostInfo.HOST_OS_KERNEL_VERSION, host.getHostKernelRelease());	details.put(HostInfo.HOST_OS, host.getHostOs());	details.put(HostInfo.HOST_OS_VERSION, host.getHostOsVersion());	details.put(HostInfo.HYPERVISOR_VERSION, host.getHypervisorVersion());	Map<Ovm3HypervisorResource, Map<String, String>> resources = new HashMap<Ovm3HypervisorResource, Map<String, String>>();	resources.put(ovmResource, details);	return resources;	} catch (UnknownHostException e) {	return null;	} catch (ConfigurationException e) {	
configure resource failed unable to discover host 

details.put(HostInfo.HOST_OS_VERSION, host.getHostOsVersion());	details.put(HostInfo.HYPERVISOR_VERSION, host.getHypervisorVersion());	Map<Ovm3HypervisorResource, Map<String, String>> resources = new HashMap<Ovm3HypervisorResource, Map<String, String>>();	resources.put(ovmResource, details);	return resources;	} catch (UnknownHostException e) {	return null;	} catch (ConfigurationException e) {	return null;	} catch (IOException | Ovm3ResourceException e) {	
unable to discover host 

public void postDiscovery(List<HostVO> hosts, long msId) throws CloudRuntimeException {	
postdiscovery 

public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {	
createhostvoforconnectedagent 

public boolean processAnswers(long agentId, long seq, Answer[] answers) {	
processanswers 

public boolean processCommands(long agentId, long seq, Command[] commands) {	
processcommands 

public AgentControlAnswer processControlCommand(long agentId, AgentControlCommand cmd) {	
processcontrolcommand 

public void processConnect(Host host, StartupCommand cmd, boolean forRebalance) {	
processConnect 

public boolean processDisconnect(long agentId, Status state) {	
processDisconnect 

public int getTimeout() {	
getTimeout 

public boolean processTimeout(long agentId, long seq) {	
processtimeout 

public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map<String, String> details, List<String> hostTags) {	
createhostvofordirectconnectagent 

public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {	
deletehost 

========================= cloudstack sample_836 =========================

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	String sql = GET_LAST_JOB_SUCCESS_DATE_MILLIS;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	return rs.getLong(1);	}	} catch (Exception ex) {	
error getting last usage job success date 

jobForUpdate.setStartMillis(startMillis);	jobForUpdate.setEndMillis(endMillis);	jobForUpdate.setExecTime(execTime);	jobForUpdate.setStartDate(new Date(startMillis));	jobForUpdate.setEndDate(new Date(endMillis));	jobForUpdate.setSuccess(success);	update(job.getId(), jobForUpdate);	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error updating job success date 

========================= cloudstack sample_4483 =========================

}	if (clientOptions.getUseTCPKeepAlive() != null) {	configuration.setUseTcpKeepAlive(clientOptions.getUseTCPKeepAlive());	}	if (clientOptions.getConnectionTtl() != null) {	configuration.setConnectionTTL(clientOptions.getConnectionTtl());	}	if (clientOptions.getSigner() != null) {	configuration.setSignerOverride(clientOptions.getSigner());	}	
creating client with configuration protocol s signer s connectiontimeout s maxerrorretry s sockettimeout s usetcpkeepalive s connectionttl s 

configuration.setUseTcpKeepAlive(clientOptions.getUseTCPKeepAlive());	}	if (clientOptions.getConnectionTtl() != null) {	configuration.setConnectionTTL(clientOptions.getConnectionTtl());	}	if (clientOptions.getSigner() != null) {	configuration.setSignerOverride(clientOptions.getSigner());	}	final AmazonS3Client client = new AmazonS3Client(basicAWSCredentials, configuration);	if (isNotBlank(clientOptions.getEndPoint())) {	
setting the end point for client with access key s to s 

public static Upload putFile(final ClientOptions clientOptions, final File sourceFile, final String bucketName, final String key) {	
sending file s as object s in bucket s 

public static Upload putObject(final ClientOptions clientOptions, final InputStream sourceStream, final String bucketName, final String key) {	
sending stream as object s in bucket s 

public static Upload putObject(final ClientOptions clientOptions, final PutObjectRequest req) {	
sending stream as object s in bucket s using putobjectrequest 

public static Download getFile(final ClientOptions clientOptions, final String bucketName, final String key, final File file) {	
receiving object s as file s from bucket s 

public static Download getFile(final ClientOptions clientOptions, final GetObjectRequest getObjectRequest, final File file) {	
receiving object s as file s from bucket s using getobjectrequest 

public static URL generatePresignedUrl(final ClientOptions clientOptions, final String bucketName, final String key, final Date expiration) {	
generating presigned url for key in bucket with expiration date 

public static S3ObjectInputStream getObjectStream(final ClientOptions clientOptions, final String bucketName, final String key) {	
get from object s in bucket s 

public static List<S3ObjectSummary> listDirectory(final ClientOptions clientOptions, final String bucketName, final String directory) {	
listing directory s in bucket s 

public static void deleteObject(final ClientOptions clientOptions, final String bucketName, final String key) {	
deleting object s in bucket s 

public static void deleteDirectory(final ClientOptions clientOptions, final String bucketName, final String directoryName) {	
deleting directory s in bucket s 

========================= cloudstack sample_2804 =========================

private void updateRegionEntries(Connection conn) {	final Properties dbProps = DbProperties.getDbProperties();	int region_id = 1;	String regionId = dbProps.getProperty("region.id");	if (regionId != null) {	region_id = Integer.parseInt(regionId);	}	try (PreparedStatement pstmt = conn.prepareStatement("update `cloud`.`region` set id = ?");) {	
updating region table with id 

private void upgradeEgressFirewallRules(Connection conn) {	try (PreparedStatement updateNwpstmt = conn.prepareStatement("update `cloud`.`firewall_rules`  set traffic_type='Ingress' where purpose='Firewall' and ip_address_id is " + "not null and traffic_type is null");) {	updateNwpstmt.executeUpdate();	
updating firewall ingress rule traffic type 

throw new CloudRuntimeException("Unable to update ingress firewall rules ", e);	}	try (PreparedStatement vrNwpstmt = conn.prepareStatement("select network_id FROM `cloud`.`ntwk_service_map` where service='Firewall' and provider='VirtualRouter' ");	ResultSet vrNwsRs = vrNwpstmt.executeQuery();	) {	while (vrNwsRs.next()) {	long netId = vrNwsRs.getLong(1);	try (PreparedStatement NwAcctDomIdpstmt = conn.prepareStatement("select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR " + "guest_type='Virtual') and traffic_type='Guest' and vpc_id is NULL and " + "(state='implemented' OR state='Shutdown') and id=? "); ) {	NwAcctDomIdpstmt.setLong(1, netId);	try (ResultSet NwAcctDomIdps = NwAcctDomIdpstmt.executeQuery();) {	
getting account id domain id from networks table 

ResultSet vrNwsRs = vrNwpstmt.executeQuery();	) {	while (vrNwsRs.next()) {	long netId = vrNwsRs.getLong(1);	try (PreparedStatement NwAcctDomIdpstmt = conn.prepareStatement("select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR " + "guest_type='Virtual') and traffic_type='Guest' and vpc_id is NULL and " + "(state='implemented' OR state='Shutdown') and id=? "); ) {	NwAcctDomIdpstmt.setLong(1, netId);	try (ResultSet NwAcctDomIdps = NwAcctDomIdpstmt.executeQuery();) {	if (NwAcctDomIdps.next()) {	long accountId = NwAcctDomIdps.getLong(1);	long domainId = NwAcctDomIdps.getLong(2);	
adding default egress firewall rule for network 

if (NwAcctDomIdps.next()) {	long accountId = NwAcctDomIdps.getLong(1);	long domainId = NwAcctDomIdps.getLong(2);	try (PreparedStatement fwRulespstmt = conn.prepareStatement("INSERT INTO firewall_rules "+ " (uuid, state, protocol, purpose, account_id, domain_id, network_id, xid, created," + " traffic_type) VALUES (?, 'Active', 'all', 'Firewall', ?, ?, ?, ?, now(), " +"'Egress')");	) {	fwRulespstmt.setString(1, UUID.randomUUID().toString());	fwRulespstmt.setLong(2, accountId);	fwRulespstmt.setLong(3, domainId);	fwRulespstmt.setLong(4, netId);	fwRulespstmt.setString(5, UUID.randomUUID().toString());	
inserting default egress firewall rule 

========================= cloudstack sample_4196 =========================

}	for (HostVO host : hosts) {	ModifyStoragePoolCommand cmd = new ModifyStoragePoolCommand(false, storagePool);	final Answer answer = agentMgr.easySend(host.getId(), cmd);	if (answer == null || !answer.getResult()) {	if (s_logger.isDebugEnabled()) {	s_logger.debug("ModifyStoragePool false failed due to " + ((answer == null) ? "answer null" : answer.getDetails()));	}	} else {	if (s_logger.isDebugEnabled()) {	
modifystoragepool false succeeded 

VMInstanceVO vmInstance = vmDao.findById(volume.getInstanceId());	if (vmInstance == null) {	continue;	}	if (vmInstance.getState().equals(State.Running) || vmInstance.getState().equals(State.Starting) || vmInstance.getState().equals(State.Stopping)) {	try {	StoragePoolWorkVO work = new StoragePoolWorkVO(vmInstance.getId(), pool.getId(), false, false, server.getId());	_storagePoolWorkDao.persist(work);	} catch (Exception e) {	if (s_logger.isDebugEnabled()) {	
work record already exists re using by re setting values 

work.setStoppedForMaintenance(true);	_storagePoolWorkDao.update(work.getId(), work);	if (restart) {	vmMgr.advanceStart(domR.getUuid(), null, null);	work.setStartedAfterMaintenance(true);	_storagePoolWorkDao.update(work.getId(), work);	}	}	}	} catch (Exception e) {	
exception in enabling primary storage maintenance 

}	for (HostVO host : hosts) {	ModifyStoragePoolCommand msPoolCmd = new ModifyStoragePoolCommand(true, pool);	final Answer answer = agentMgr.easySend(host.getId(), msPoolCmd);	if (answer == null || !answer.getResult()) {	if (s_logger.isDebugEnabled()) {	s_logger.debug("ModifyStoragePool add failed due to " + ((answer == null) ? "answer null" : answer.getDetails()));	}	} else {	if (s_logger.isDebugEnabled()) {	
modifystoragepool add secceeded 

if (volumeDao.findByInstanceAndType(vmInstance.getId(), Volume.Type.ROOT).isEmpty()) {	_storagePoolWorkDao.remove(work.getId());	} else {	UserVmVO userVm = userVmDao.findById(vmInstance.getId());	vmMgr.advanceStart(userVm.getUuid(), null, null);	work.setStartedAfterMaintenance(true);	_storagePoolWorkDao.update(work.getId(), work);	}	}	} catch (Exception e) {	
failed start vm 

========================= cloudstack sample_2412 =========================

host = "http: }	if (arg.equals("-t")) {	numThreads = Integer.parseInt(iter.next());	}	if (arg.equals("-n")) {	s_numVM = Integer.parseInt(iter.next());	}	}	final String server = host + ":" + ApiPort + "/";	final String developerServer = host + ":" + DeveloperPort + ApiUrl;	
starting test in thread s each thread is launching vms 

String username = null;	String singlePrivateIp = null;	String singlePublicIp = null;	Random ran = new Random();	username = Math.abs(ran.nextInt()) + "-user";	User myUser = new User(username, username, server, developerServer);	try {	myUser.launchUser();	myUser.registerUser();	} catch (Exception e) {	
error code 

String singlePublicIp = null;	Random ran = new Random();	username = Math.abs(ran.nextInt()) + "-user";	User myUser = new User(username, username, server, developerServer);	try {	myUser.launchUser();	myUser.registerUser();	} catch (Exception e) {	}	if (myUser.getUserId() != null) {	
user was created successfully starting vm creation 

myUser.registerUser();	} catch (Exception e) {	}	if (myUser.getUserId() != null) {	for (int i = 0; i < s_numVM; i++) {	VirtualMachine myVM = new VirtualMachine(myUser.getUserId());	myVM.deployVM(ZoneId, ServiceOfferingId, TemplateId, myUser.getDeveloperServer(), myUser.getApiKey(), myUser.getSecretKey());	myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	
vm with private ip was successfully created 

} catch (Exception e) {	}	if (myUser.getUserId() != null) {	for (int i = 0; i < s_numVM; i++) {	VirtualMachine myVM = new VirtualMachine(myUser.getUserId());	myVM.deployVM(ZoneId, ServiceOfferingId, TemplateId, myUser.getDeveloperServer(), myUser.getApiKey(), myUser.getSecretKey());	myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	} else {	
problems with vm creation for a user 

myVM.deployVM(ZoneId, ServiceOfferingId, TemplateId, myUser.getDeveloperServer(), myUser.getApiKey(), myUser.getSecretKey());	myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	} else {	break;	}	myUser.retrievePublicIp(ZoneId);	singlePublicIp = myUser.getPublicIp().get(myUser.getPublicIp().size() - 1);	if (singlePublicIp != null) {	
successfully got public ip for user 

myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	} else {	break;	}	myUser.retrievePublicIp(ZoneId);	singlePublicIp = myUser.getPublicIp().get(myUser.getPublicIp().size() - 1);	if (singlePublicIp != null) {	} else {	
problems with getting public ip address for user 

}	myUser.retrievePublicIp(ZoneId);	singlePublicIp = myUser.getPublicIp().get(myUser.getPublicIp().size() - 1);	if (singlePublicIp != null) {	} else {	break;	}	int responseCode = CreateForwardingRule(myUser, singlePrivateIp, singlePublicIp, "22", "22");	if (responseCode == 500) break;	}	
deployment successful vms were created waiting for min before performance test 

myUser.retrievePublicIp(ZoneId);	singlePublicIp = myUser.getPublicIp().get(myUser.getPublicIp().size() - 1);	if (singlePublicIp != null) {	} else {	break;	}	int responseCode = CreateForwardingRule(myUser, singlePrivateIp, singlePublicIp, "22", "22");	if (responseCode == 500) break;	}	Thread.sleep(300000L);	
starting performance test for guest network that has public ip addresses 

singlePublicIp = myUser.getPublicIp().get(myUser.getPublicIp().size() - 1);	if (singlePublicIp != null) {	} else {	break;	}	int responseCode = CreateForwardingRule(myUser, singlePrivateIp, singlePublicIp, "22", "22");	if (responseCode == 500) break;	}	Thread.sleep(300000L);	for (int j = 0; j < myUser.getPublicIp().size(); j++) {	
starting test for user which has vms public ip for the user is number of retries is private ip address of the machine is 

private static int CreateForwardingRule(User myUser, String privateIp, String publicIp, String publicPort, String privatePort) throws IOException {	String encodedPrivateIp = URLEncoder.encode("" + privateIp, "UTF-8");	String encodedPublicIp = URLEncoder.encode("" + publicIp, "UTF-8");	String encodedPrivatePort = URLEncoder.encode("" + privatePort, "UTF-8");	String encodedPublicPort = URLEncoder.encode("" + publicPort, "UTF-8");	String encodedApiKey = URLEncoder.encode(myUser.getApiKey(), "UTF-8");	int responseCode = 500;	String requestToSign = "apiKey=" + encodedApiKey + "&command=createOrUpdateIpForwardingRule&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort;	requestToSign = requestToSign.toLowerCase();	
request to sign is 

String encodedPublicIp = URLEncoder.encode("" + publicIp, "UTF-8");	String encodedPrivatePort = URLEncoder.encode("" + privatePort, "UTF-8");	String encodedPublicPort = URLEncoder.encode("" + publicPort, "UTF-8");	String encodedApiKey = URLEncoder.encode(myUser.getApiKey(), "UTF-8");	int responseCode = 500;	String requestToSign = "apiKey=" + encodedApiKey + "&command=createOrUpdateIpForwardingRule&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort;	requestToSign = requestToSign.toLowerCase();	String signature = TestClientWithAPI.signRequest(requestToSign, myUser.getSecretKey());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = myUser.getDeveloperServer() + "?command=createOrUpdateIpForwardingRule" + "&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort + "&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	
trying to create ip forwarding rule 

String encodedApiKey = URLEncoder.encode(myUser.getApiKey(), "UTF-8");	int responseCode = 500;	String requestToSign = "apiKey=" + encodedApiKey + "&command=createOrUpdateIpForwardingRule&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort;	requestToSign = requestToSign.toLowerCase();	String signature = TestClientWithAPI.signRequest(requestToSign, myUser.getSecretKey());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = myUser.getDeveloperServer() + "?command=createOrUpdateIpForwardingRule" + "&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort + "&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	responseCode = client.executeMethod(method);	
create ip forwarding rule response code 

int responseCode = 500;	String requestToSign = "apiKey=" + encodedApiKey + "&command=createOrUpdateIpForwardingRule&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort;	requestToSign = requestToSign.toLowerCase();	String signature = TestClientWithAPI.signRequest(requestToSign, myUser.getSecretKey());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = myUser.getDeveloperServer() + "?command=createOrUpdateIpForwardingRule" + "&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort + "&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	
the rule is created successfully 

String signature = TestClientWithAPI.signRequest(requestToSign, myUser.getSecretKey());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = myUser.getDeveloperServer() + "?command=createOrUpdateIpForwardingRule" + "&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort + "&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorCode", "description"});	
create ip forwarding rule linux test failed with errorcode errorCode and description description 

String encodedSignature = URLEncoder.encode(signature, "UTF-8");	String url = myUser.getDeveloperServer() + "?command=createOrUpdateIpForwardingRule" + "&publicIp=" + encodedPublicIp + "&publicPort=" + encodedPublicPort + "&privateIp=" + encodedPrivateIp + "&privatePort=" + encodedPrivatePort + "&protocol=tcp&apiKey=" + encodedApiKey + "&signature=" + encodedSignature;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	} else if (responseCode == 500) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> errorInfo = TestClientWithAPI.getSingleValueFromXML(is, new String[] {"errorCode", "description"});	} else {	
internal error processing request 

========================= cloudstack sample_436 =========================

protected boolean registerProvider(DataStoreProvider provider) {	Map<String, Object> copyParams = new HashMap<String, Object>();	String providerName = provider.getName();	if (providerMap.get(providerName) != null) {	
did not register data store provider provider name is not unique 

protected boolean registerProvider(DataStoreProvider provider) {	Map<String, Object> copyParams = new HashMap<String, Object>();	String providerName = provider.getName();	if (providerMap.get(providerName) != null) {	return false;	}	
registering data store provider 

Map<String, Object> copyParams = new HashMap<String, Object>();	String providerName = provider.getName();	if (providerMap.get(providerName) != null) {	return false;	}	providerMap.put(providerName, provider);	try {	boolean registrationResult = provider.configure(copyParams);	if (!registrationResult) {	providerMap.remove(providerName);	
failed to register data store provider 

return false;	}	Set<DataStoreProviderType> types = provider.getTypes();	if (types.contains(DataStoreProviderType.PRIMARY)) {	primaryDataStoreProviderMgr.registerDriver(provider.getName(), (PrimaryDataStoreDriver)provider.getDataStoreDriver());	primaryDataStoreProviderMgr.registerHostListener(provider.getName(), provider.getHostListener());	} else if (types.contains(DataStoreProviderType.IMAGE)) {	imageStoreProviderMgr.registerDriver(provider.getName(), (ImageStoreDriver)provider.getDataStoreDriver());	}	} catch (Exception e) {	
configure provider failed 

========================= cloudstack sample_3995 =========================

formatter.format(" or (data_center_id is null and pod_id is null and cluster_id is null and host_id is null))");	formatter.format(" and removed is NULL ORDER BY id ASC LIMIT 1 for update");	formatter.close();	String sql = search.toString();	try ( PreparedStatement pstmt = txn.prepareAutoCloseStatement(sql);	ResultSet rs = pstmt.executeQuery();) {	if (rs.next()) {	return toEntityBean(rs, false);	}	} catch (Exception e) {	
ignored error while executing dynamically build search 

========================= cloudstack sample_965 =========================

public <T> T getMetadataNode(Class<T> fieldClass) {	T field = (T) customNodes.get(fieldClass.getName());	if (field == null) {	try {	field = fieldClass.newInstance();	customNodes.put(field.getClass().getName(), field);	} catch (InstantiationException | IllegalAccessException e) {	
no default constructor available in class ignoring exception 

========================= cloudstack sample_1101 =========================

return new UnPlugNicAnswer(command, true, "success");	} catch (final LibvirtException e) {	final String msg = " Unplug Nic failed due to " + e.toString();	s_logger.warn(msg, e);	return new UnPlugNicAnswer(command, false, msg);	} finally {	if (vm != null) {	try {	vm.free();	} catch (final LibvirtException l) {	
ignoring libvirt error 

========================= cloudstack sample_1044 =========================

protected boolean canHandle(NetworkOffering offering, NetworkType networkType, PhysicalNetwork physicalNetwork) {	
canHandle 

protected boolean canHandle(NetworkOffering offering, NetworkType networkType, PhysicalNetwork physicalNetwork) {	String setting = null;	if (physicalNetwork != null && physicalNetwork.getIsolationMethods().contains("SSP")) {	setting = "physicalnetwork setting";	} else if (_ntwkOfferingSrvcDao.isProviderForNetworkOffering(offering.getId(), Network.Provider.getProvider(SspElement.s_SSP_NAME))) {	setting = "network offering setting";	}	if (setting != null) {	if (networkType != NetworkType.Advanced) {	
ssp enebled by but not active because networktype was 

protected boolean canHandle(NetworkOffering offering, NetworkType networkType, PhysicalNetwork physicalNetwork) {	String setting = null;	if (physicalNetwork != null && physicalNetwork.getIsolationMethods().contains("SSP")) {	setting = "physicalnetwork setting";	} else if (_ntwkOfferingSrvcDao.isProviderForNetworkOffering(offering.getId(), Network.Provider.getProvider(SspElement.s_SSP_NAME))) {	setting = "network offering setting";	}	if (setting != null) {	if (networkType != NetworkType.Advanced) {	} else if (!isMyTrafficType(offering.getTrafficType())) {	
ssp enabled by but not active because traffic type not guest 

String setting = null;	if (physicalNetwork != null && physicalNetwork.getIsolationMethods().contains("SSP")) {	setting = "physicalnetwork setting";	} else if (_ntwkOfferingSrvcDao.isProviderForNetworkOffering(offering.getId(), Network.Provider.getProvider(SspElement.s_SSP_NAME))) {	setting = "network offering setting";	}	if (setting != null) {	if (networkType != NetworkType.Advanced) {	} else if (!isMyTrafficType(offering.getTrafficType())) {	} else if (offering.getGuestType() != Network.GuestType.Isolated) {	
ssp works for network isolatation 

if (physicalNetwork != null && physicalNetwork.getIsolationMethods().contains("SSP")) {	setting = "physicalnetwork setting";	} else if (_ntwkOfferingSrvcDao.isProviderForNetworkOffering(offering.getId(), Network.Provider.getProvider(SspElement.s_SSP_NAME))) {	setting = "network offering setting";	}	if (setting != null) {	if (networkType != NetworkType.Advanced) {	} else if (!isMyTrafficType(offering.getTrafficType())) {	} else if (offering.getGuestType() != Network.GuestType.Isolated) {	} else if (!_sspMgr.canHandle(physicalNetwork)) {	
ssp manager not ready 

}	if (setting != null) {	if (networkType != NetworkType.Advanced) {	} else if (!isMyTrafficType(offering.getTrafficType())) {	} else if (offering.getGuestType() != Network.GuestType.Isolated) {	} else if (!_sspMgr.canHandle(physicalNetwork)) {	} else {	return true;	}	} else {	
ssp not configured to be active 

public Network implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws InsufficientVirtualNetworkCapacityException {	
implement 

public void shutdown(NetworkProfile profile, NetworkOffering offering) {	
shutdown 

public boolean prepareMigration(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) {	try {	reserve(nic, network, vm, dest, context);	} catch (InsufficientVirtualNetworkCapacityException e) {	
prepareformigration failed 

public boolean prepareMigration(NicProfile nic, Network network, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) {	try {	reserve(nic, network, vm, dest, context);	} catch (InsufficientVirtualNetworkCapacityException e) {	return false;	} catch (InsufficientAddressCapacityException e) {	
prepareformigration failed 

========================= cloudstack sample_1414 =========================

throw new CloudRuntimeException(ex.getMessage());	} catch (IOException ex) {	throw new CloudRuntimeException(ex.getMessage());	} catch (URISyntaxException ex) {	throw new CloudRuntimeException(ex.getMessage());	} finally {	if (httpClient != null) {	try {	httpClient.getConnectionManager().shutdown();	} catch (Exception t) {	
ignored error shutting down http client 

========================= cloudstack sample_1947 =========================

boolean success = true;	ApplicationLoadBalancerRuleVO newRule = null;	try {	newRule = Transaction.execute(new TransactionCallbackWithException<ApplicationLoadBalancerRuleVO, NetworkRuleConflictException>() {	public ApplicationLoadBalancerRuleVO doInTransaction(TransactionStatus status) throws NetworkRuleConflictException {	ApplicationLoadBalancerRuleVO newRule = _lbDao.persist(newRuleFinal);	detectLbRulesConflicts(newRule);	if (!_firewallDao.setStateToAdd(newRule)) {	throw new CloudRuntimeException("Unable to update the state to add for " + newRule);	}	
load balancer for ip address source port instance port is added successfully 

protected Ip getSourceIp(Scheme scheme, Network sourceIpNtwk, String requestedIp) throws InsufficientVirtualNetworkCapacityException {	if (requestedIp != null) {	if (_lbDao.countBySourceIp(new Ip(requestedIp), sourceIpNtwk.getId()) > 0)  {	
ip address is already used by existing lb rule returning it 

continue;	}	if (lbRule.getNetworkId() != newLbRule.getNetworkId() && lbRule.getState() != State.Revoke) {	throw new NetworkRuleConflictException("New rule is for a different network than what's specified in rule " + lbRule.getXid());	}	if ((lbRule.getSourcePortStart().intValue() <= newLbRule.getSourcePortStart().intValue() && lbRule.getSourcePortEnd().intValue() >= newLbRule.getSourcePortStart() .intValue()) || (lbRule.getSourcePortStart().intValue() <= newLbRule.getSourcePortEnd().intValue() && lbRule.getSourcePortEnd().intValue() >= newLbRule.getSourcePortEnd() .intValue()) || (newLbRule.getSourcePortStart().intValue() <= lbRule.getSourcePortStart().intValue() && newLbRule.getSourcePortEnd().intValue() >= lbRule.getSourcePortStart() .intValue()) || (newLbRule.getSourcePortStart().intValue() <= lbRule.getSourcePortEnd().intValue() && newLbRule.getSourcePortEnd().intValue() >= lbRule.getSourcePortEnd() .intValue())) {	throw new NetworkRuleConflictException("The range specified, " + newLbRule.getSourcePortStart().intValue() + "-" + newLbRule.getSourcePortEnd().intValue() + ", conflicts with rule " + lbRule.getId() + " which has " + lbRule.getSourcePortStart().intValue() + "-" + lbRule.getSourcePortEnd().intValue());	}	}	if (s_logger.isDebugEnabled()) {	
no network rule conflicts detected for against existing rules 

========================= cloudstack sample_2238 =========================

public int releaseRef() {	int refCount;	boolean needToRemove = false;	synchronized (this) {	referenceCount--;	refCount = referenceCount;	
unmatched global lock reference usage detected check your code 

private static void releaseInternLock(String name) {	synchronized (s_lockMap) {	GlobalLock lock = s_lockMap.get(name);	if (lock != null) {	if (lock.referenceCount == 0) s_lockMap.remove(name);	} else {	
releasing but it is already released 

public boolean lock(int timeoutSeconds) {	int remainingMilliSeconds = timeoutSeconds * 1000;	Profiler profiler = new Profiler();	boolean interrupted = false;	try {	while (true) {	synchronized (this) {	if (ownerThread != null && ownerThread == Thread.currentThread()) {	
global lock re entrance detected 

public boolean lock(int timeoutSeconds) {	int remainingMilliSeconds = timeoutSeconds * 1000;	Profiler profiler = new Profiler();	boolean interrupted = false;	try {	while (true) {	synchronized (this) {	if (ownerThread != null && ownerThread == Thread.currentThread()) {	lockCount++;	
lock is acquired lock count 

continue;	} else {	ownerThread = Thread.currentThread();	addRef();	}	}	if (DbUtil.getGlobalLock(name, remainingMilliSeconds / 1000)) {	synchronized (this) {	lockCount++;	holdingStartTick = System.currentTimeMillis();	
lock is acquired lock count 

public boolean unlock() {	synchronized (this) {	if (ownerThread != null && ownerThread == Thread.currentThread()) {	lockCount--;	if (lockCount == 0) {	ownerThread = null;	DbUtil.releaseGlobalLock(name);	
lock is returned to free state total holding time 

synchronized (this) {	if (ownerThread != null && ownerThread == Thread.currentThread()) {	lockCount--;	if (lockCount == 0) {	ownerThread = null;	DbUtil.releaseGlobalLock(name);	holdingStartTick = 0;	releaseRef();	notifyAll();	}	
lock is released lock count 

public static <T> T executeWithLock(final String operationId, final int lockAcquisitionTimeout, final Callable<T> operation) throws Exception {	final GlobalLock lock = GlobalLock.getInternLock(operationId);	try {	if (!lock.lock(lockAcquisitionTimeout)) {	if (s_logger.isDebugEnabled()) {	
failed to acquire lock for operation id s 

========================= cloudstack sample_573 =========================

public static Properties loadProperties() throws ConfigurationException {	Properties properties = new Properties();	final File file = PropertiesUtil.findConfigFile("agent.properties");	if (file == null) {	throw new ConfigurationException("Unable to find agent.properties.");	}	
agent properties found at 

========================= cloudstack sample_5007 =========================

pstmt = txn.prepareAutoCloseStatement(UPDATE_DELETED);	pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), usage.getProcessed()));	pstmt.setLong(2, usage.getAccountId());	pstmt.setLong(3, usage.getId());	pstmt.setLong(4, usage.getVmId());	pstmt.setString(5, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), usage.getCreated()));	pstmt.executeUpdate();	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usagevmsnapshotvo 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (processed != null) {	processDate = DateUtil.parseDateString(s_gmtTimeZone, processed);	}	usageRecords.add(new UsageVMSnapshotVO(vId, zoneId, acctId, dId, vmId, doId, size, createdDate, processDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

if (createdTS != null) {	createdDate = DateUtil.parseDateString(s_gmtTimeZone, createdTS);	}	if (processed != null) {	processDate = DateUtil.parseDateString(s_gmtTimeZone, processed);	}	usageRecords.add(new UsageVMSnapshotVO(vId, zoneId, acctId, dId, vmId, doId, size, createdDate, processDate));	}	} catch (Exception e) {	txn.rollback();	
error getting usage records 

========================= cloudstack sample_4495 =========================

long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	ServiceOffering offering = vmProfile.getServiceOffering();	VMTemplateVO template = (VMTemplateVO)vmProfile.getTemplate();	Account account = vmProfile.getOwner();	if (type == Host.Type.Storage) {	return new ArrayList<Host>();	}	if (s_logger.isDebugEnabled()) {	
looking for hosts in dc pod cluster 

if (haVmTag != null) {	clusterHosts = _hostDao.listByHostTag(type, clusterId, podId, dcId, haVmTag);	} else {	if (hostTagOnOffering == null && hostTagOnTemplate == null) {	clusterHosts = _resourceMgr.listAllUpAndEnabledNonHAHosts(type, clusterId, podId, dcId);	} else {	List<HostVO> hostsMatchingOfferingTag = new ArrayList<HostVO>();	List<HostVO> hostsMatchingTemplateTag = new ArrayList<HostVO>();	if (hasSvcOfferingTag) {	if (s_logger.isDebugEnabled()) {	
looking for hosts having tag specified on svcoffering 

if (hostTagOnOffering == null && hostTagOnTemplate == null) {	clusterHosts = _resourceMgr.listAllUpAndEnabledNonHAHosts(type, clusterId, podId, dcId);	} else {	List<HostVO> hostsMatchingOfferingTag = new ArrayList<HostVO>();	List<HostVO> hostsMatchingTemplateTag = new ArrayList<HostVO>();	if (hasSvcOfferingTag) {	if (s_logger.isDebugEnabled()) {	}	hostsMatchingOfferingTag = _hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnOffering);	if (s_logger.isDebugEnabled()) {	
hosts with tag are 

List<HostVO> hostsMatchingTemplateTag = new ArrayList<HostVO>();	if (hasSvcOfferingTag) {	if (s_logger.isDebugEnabled()) {	}	hostsMatchingOfferingTag = _hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnOffering);	if (s_logger.isDebugEnabled()) {	}	}	if (hasTemplateTag) {	if (s_logger.isDebugEnabled()) {	
looking for hosts having tag specified on template 

}	hostsMatchingOfferingTag = _hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnOffering);	if (s_logger.isDebugEnabled()) {	}	}	if (hasTemplateTag) {	if (s_logger.isDebugEnabled()) {	}	hostsMatchingTemplateTag = _hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnTemplate);	if (s_logger.isDebugEnabled()) {	
hosts with tag are 

if (s_logger.isDebugEnabled()) {	}	hostsMatchingTemplateTag = _hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnTemplate);	if (s_logger.isDebugEnabled()) {	}	}	if (hasSvcOfferingTag && hasTemplateTag) {	hostsMatchingOfferingTag.retainAll(hostsMatchingTemplateTag);	clusterHosts = _hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnTemplate);	if (s_logger.isDebugEnabled()) {	
found hosts satisfying both tags host ids are 

boolean hasTemplateTag = hostTagOnTemplate != null ? true : false;	String haVmTag = (String)vmProfile.getParameter(VirtualMachineProfile.Param.HaTag);	if (haVmTag != null) {	hostsCopy.retainAll(_hostDao.listByHostTag(type, clusterId, podId, dcId, haVmTag));	} else {	if (hostTagOnOffering == null && hostTagOnTemplate == null) {	hostsCopy.retainAll(_resourceMgr.listAllUpAndEnabledNonHAHosts(type, clusterId, podId, dcId));	} else {	if (hasSvcOfferingTag) {	if (s_logger.isDebugEnabled()) {	
looking for hosts having tag specified on svcoffering 

hostsCopy.retainAll(_hostDao.listByHostTag(type, clusterId, podId, dcId, haVmTag));	} else {	if (hostTagOnOffering == null && hostTagOnTemplate == null) {	hostsCopy.retainAll(_resourceMgr.listAllUpAndEnabledNonHAHosts(type, clusterId, podId, dcId));	} else {	if (hasSvcOfferingTag) {	if (s_logger.isDebugEnabled()) {	}	hostsCopy.retainAll(_hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnOffering));	if (s_logger.isDebugEnabled()) {	
hosts with tag are 

} else {	if (hasSvcOfferingTag) {	if (s_logger.isDebugEnabled()) {	}	hostsCopy.retainAll(_hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnOffering));	if (s_logger.isDebugEnabled()) {	}	}	if (hasTemplateTag) {	if (s_logger.isDebugEnabled()) {	
looking for hosts having tag specified on template 

}	hostsCopy.retainAll(_hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnOffering));	if (s_logger.isDebugEnabled()) {	}	}	if (hasTemplateTag) {	if (s_logger.isDebugEnabled()) {	}	hostsCopy.retainAll(_hostDao.listByHostTag(type, clusterId, podId, dcId, hostTagOnTemplate));	if (s_logger.isDebugEnabled()) {	
hosts with tag are 

protected List<Host> allocateTo(DeploymentPlan plan, ServiceOffering offering, VMTemplateVO template, ExcludeList avoid, List<? extends Host> hosts, int returnUpTo, boolean considerReservedCapacity, Account account) {	if (_allocationAlgorithm.equals("random") || _allocationAlgorithm.equals("userconcentratedpod_random")) {	Collections.shuffle(hosts);	} else if (_allocationAlgorithm.equals("userdispersing")) {	hosts = reorderHostsByNumberOfVms(plan, hosts, account);	}else if(_allocationAlgorithm.equals("firstfitleastconsumed")){	hosts = reorderHostsByCapacity(plan, hosts);	}	if (s_logger.isDebugEnabled()) {	
firstfitallocator has hosts to check for allocation 

Collections.shuffle(hosts);	} else if (_allocationAlgorithm.equals("userdispersing")) {	hosts = reorderHostsByNumberOfVms(plan, hosts, account);	}else if(_allocationAlgorithm.equals("firstfitleastconsumed")){	hosts = reorderHostsByCapacity(plan, hosts);	}	if (s_logger.isDebugEnabled()) {	}	hosts = prioritizeHosts(template, offering, hosts);	if (s_logger.isDebugEnabled()) {	
found hosts for allocation after prioritization 

}	long serviceOfferingId = offering.getId();	List<Host> suitableHosts = new ArrayList<Host>();	ServiceOfferingDetailsVO offeringDetails = null;	for (Host host : hosts) {	if (suitableHosts.size() == returnUpTo) {	break;	}	if (avoid.shouldAvoid(host)) {	if (s_logger.isDebugEnabled()) {	
host name hostid is in avoid set skipping this and trying other available hosts 

if (suitableHosts.size() == returnUpTo) {	break;	}	if (avoid.shouldAvoid(host)) {	if (s_logger.isDebugEnabled()) {	}	continue;	}	if (_capacityMgr.checkIfHostReachMaxGuestLimit(host)) {	if (s_logger.isDebugEnabled()) {	
host name hostid already has max running vms count includes system vms skipping this and trying other available hosts 

}	if (_capacityMgr.checkIfHostReachMaxGuestLimit(host)) {	if (s_logger.isDebugEnabled()) {	}	avoid.addHost(host.getId());	continue;	}	if ((offeringDetails   = _serviceOfferingDetailsDao.findDetail(serviceOfferingId, GPU.Keys.vgpuType.toString())) != null) {	ServiceOfferingDetailsVO groupName = _serviceOfferingDetailsDao.findDetail(serviceOfferingId, GPU.Keys.pciDevice.toString());	if(!_resourceMgr.isGPUDeviceAvailable(host.getId(), groupName.getValue(), offeringDetails.getValue())){	
host name hostid does not have required gpu devices available 

long ram_requested = offering.getRamSize() * 1024L * 1024L;	Cluster cluster = _clusterDao.findById(host.getClusterId());	ClusterDetailsVO clusterDetailsCpuOvercommit = _clusterDetailsDao.findDetail(cluster.getId(), "cpuOvercommitRatio");	ClusterDetailsVO clusterDetailsRamOvercommmt = _clusterDetailsDao.findDetail(cluster.getId(), "memoryOvercommitRatio");	Float cpuOvercommitRatio = Float.parseFloat(clusterDetailsCpuOvercommit.getValue());	Float memoryOvercommitRatio = Float.parseFloat(clusterDetailsRamOvercommmt.getValue());	boolean hostHasCpuCapability = _capacityMgr.checkIfHostHasCpuCapability(host.getId(), offering.getCpu(), offering.getSpeed());	boolean hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, false, cpuOvercommitRatio, memoryOvercommitRatio, considerReservedCapacity);	if (hostHasCpuCapability && hostHasCapacity) {	if (s_logger.isDebugEnabled()) {	
found a suitable host adding to list 

Float cpuOvercommitRatio = Float.parseFloat(clusterDetailsCpuOvercommit.getValue());	Float memoryOvercommitRatio = Float.parseFloat(clusterDetailsRamOvercommmt.getValue());	boolean hostHasCpuCapability = _capacityMgr.checkIfHostHasCpuCapability(host.getId(), offering.getCpu(), offering.getSpeed());	boolean hostHasCapacity = _capacityMgr.checkIfHostHasCapacity(host.getId(), cpu_requested, ram_requested, false, cpuOvercommitRatio, memoryOvercommitRatio, considerReservedCapacity);	if (hostHasCpuCapability && hostHasCapacity) {	if (s_logger.isDebugEnabled()) {	}	suitableHosts.add(host);	} else {	if (s_logger.isDebugEnabled()) {	
not using host host has cpu capability host has capacity 

if (s_logger.isDebugEnabled()) {	}	suitableHosts.add(host);	} else {	if (s_logger.isDebugEnabled()) {	}	avoid.addHost(host.getId());	}	}	if (s_logger.isDebugEnabled()) {	
host allocator returning suitable hosts 

private List<? extends Host> reorderHostsByCapacity(DeploymentPlan plan, List<? extends Host> hosts) {	Long clusterId = plan.getClusterId();	String capacityTypeToOrder = _configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());	short capacityType = CapacityVO.CAPACITY_TYPE_CPU;	if("RAM".equalsIgnoreCase(capacityTypeToOrder)){	capacityType = CapacityVO.CAPACITY_TYPE_MEMORY;	}	List<Long> hostIdsByFreeCapacity = _capacityDao.orderHostsByFreeCapacity(clusterId, capacityType);	if (s_logger.isDebugEnabled()) {	
list of hosts in descending order of free capacity in the cluster 

private List<? extends Host> reorderHostsByNumberOfVms(DeploymentPlan plan, List<? extends Host> hosts, Account account) {	if (account == null) {	return hosts;	}	long dcId = plan.getDataCenterId();	Long podId = plan.getPodId();	Long clusterId = plan.getClusterId();	List<Long> hostIdsByVmCount = _vmInstanceDao.listHostIdsByVmCount(dcId, podId, clusterId, account.getAccountId());	if (s_logger.isDebugEnabled()) {	
list of hosts in ascending order of number of vms 

hostsToCheck.add(host);	} else {	noHvmHosts.add(host);	}	}	} else {	hostsToCheck.addAll(hosts);	}	if (s_logger.isDebugEnabled()) {	if (noHvmHosts.size() > 0) {	
not considering hosts to deploy template as they are not hvm enabled 

========================= cloudstack sample_2404 =========================

PhysicalNetworkVO phy = phys.get(0);	QueryBuilder<BaremetalPxeVO> sc = QueryBuilder.create(BaremetalPxeVO.class);	sc.and(sc.entity().getPhysicalNetworkId(), Op.EQ, phy.getId());	BaremetalPxeVO pxeVo = sc.find();	if (pxeVo == null) {	throw new CloudRuntimeException("No PXE server found in pod: " + vm.getPodIdToDeployIn() + ", you need to add it before starting VM");	}	try {	Answer ans = _agentMgr.send(pxeVo.getHostId(), cmd);	if (!ans.getResult()) {	
add userdata to vm s failed because s 

throw new CloudRuntimeException("No PXE server found in pod: " + vm.getPodIdToDeployIn() + ", you need to add it before starting VM");	}	try {	Answer ans = _agentMgr.send(pxeVo.getHostId(), cmd);	if (!ans.getResult()) {	return false;	} else {	return true;	}	} catch (Exception e) {	
add userdata to vm s failed 

========================= cloudstack sample_898 =========================

final Set<VM> vms = VM.getByNameLabel(connection, vmSpec.getName());	final VM vmToMigrate = vms.iterator().next();	final Host host = Host.getByUuid(connection, uuid);	final Map<String, String> token = host.migrateReceive(connection, networkForSm, other);	task = vmToMigrate.assertCanMigrateAsync(connection, token, true, vdiMap, vifMap, other);	try {	final long timeout = xenServer610Resource.getMigrateWait() * 1000L;	xenServer610Resource.waitForTask(connection, task, 1000, timeout);	xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	
error while checking if vm can be migrated to the destination host 

xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	throw new CloudRuntimeException("Error while checking if vm " + vmName + " can be migrated to the " + "destination host " + host, e);	}	task = vmToMigrate.migrateSendAsync(connection, token, true, vdiMap, vifMap, other);	try {	final long timeout = xenServer610Resource.getMigrateWait() * 1000L;	xenServer610Resource.waitForTask(connection, task, 1000, timeout);	xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	
error while migrating vm to the destination host 

final long timeout = xenServer610Resource.getMigrateWait() * 1000L;	xenServer610Resource.waitForTask(connection, task, 1000, timeout);	xenServer610Resource.checkForSuccess(connection, task);	} catch (final Types.HandleInvalid e) {	throw new CloudRuntimeException("Error while migrating vm " + vmName + " to the destination host " + host, e);	}	final List<VolumeObjectTO> volumeToList = xenServer610Resource.getUpdatedVolumePathsOfMigratedVm(connection, vmToMigrate, vmSpec.getDisks());	vmToMigrate.setAffinity(connection, host);	return new MigrateWithStorageAnswer(command, volumeToList);	} catch (final Exception e) {	
catch exception storage motion failed due to 

final List<VolumeObjectTO> volumeToList = xenServer610Resource.getUpdatedVolumePathsOfMigratedVm(connection, vmToMigrate, vmSpec.getDisks());	vmToMigrate.setAffinity(connection, host);	return new MigrateWithStorageAnswer(command, volumeToList);	} catch (final Exception e) {	return new MigrateWithStorageAnswer(command, e);	} finally {	if (task != null) {	try {	task.destroy(connection);	} catch (final Exception e) {	
unable to destroy task on host due to 

========================= cloudstack sample_1156 =========================

}	if (arg.equals("-pass")) {	vmPassword = iter.next();	}	if (arg.equals("-url")) {	downloadUrl = iter.next();	}	}	final String server = host + ":" + port + "/";	final String developerServer = host + ":" + devPort + apiUrl;	
starting test against server with thread s 

}	if (arg.equals("-pass")) {	vmPassword = iter.next();	}	if (arg.equals("-url")) {	downloadUrl = iter.next();	}	}	final String server = host + ":" + port + "/";	final String developerServer = host + ":" + devPort + apiUrl;	
clean up is enabled each test will wait ms before cleaning up 

if (arg.equals("-pass")) {	vmPassword = iter.next();	}	if (arg.equals("-url")) {	downloadUrl = iter.next();	}	}	final String server = host + ":" + port + "/";	final String developerServer = host + ":" + devPort + apiUrl;	if (numOfUsers > 0) {	
pre generating users for test of size 

String username = null;	try {	long now = System.currentTimeMillis();	Random ran = new Random();	if (users != null) {	username = users[Math.abs(ran.nextInt()) % numOfUsers];	} else {	username = Math.abs(ran.nextInt()) + "-user";	}	NDC.push(username);	
starting test for the user 

} else {	username = Math.abs(ran.nextInt()) + "-user";	}	NDC.push(username);	int response = executeDeployment(server, developerServer, username, snapshotTest);	boolean success = false;	String reason = null;	if (response == 200) {	success = true;	if (internet) {	
deploy successful waiting minute before ssh tests 

}	NDC.push(username);	int response = executeDeployment(server, developerServer, username, snapshotTest);	boolean success = false;	String reason = null;	if (response == 200) {	success = true;	if (internet) {	Thread.sleep(300000L);	if (accountName == null) {	
begin linux ssh test for account 

boolean success = false;	String reason = null;	if (response == 200) {	success = true;	if (internet) {	Thread.sleep(300000L);	if (accountName == null) {	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get(), snapshotTest);	}	if (reason == null) {	
linux ssh test successful for account 

boolean success = false;	String reason = null;	if (response == 200) {	success = true;	if (internet) {	Thread.sleep(300000L);	if (accountName == null) {	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get(), snapshotTest);	}	if (reason == null) {	
begin windowsssh test for account 

reason = sshTest(s_linuxIP.get(), s_linuxPassword.get(), snapshotTest);	}	if (reason == null) {	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get(), snapshotTest);	}	s_linuxIP.set(null);	s_windowsIP.set(null);	}	if (reason == null) {	if (internet) {	
windows ssh test successful for account 

}	if (reason == null) {	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get(), snapshotTest);	}	s_linuxIP.set(null);	s_windowsIP.set(null);	}	if (reason == null) {	if (internet) {	} else {	
deploy test successful now cleaning up 

if (reason == null) {	reason = sshTest(s_linuxIP.get(), s_linuxPassword.get(), snapshotTest);	}	s_linuxIP.set(null);	s_windowsIP.set(null);	}	if (reason == null) {	if (internet) {	} else {	if (cleanUp) {	
waiting ms before cleaning up vms 

if (internet) {	} else {	if (cleanUp) {	Thread.sleep(sleepTime);	} else {	success = true;	}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	
events and usage records command finished with response code 

if (cleanUp) {	Thread.sleep(sleepTime);	} else {	success = true;	}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	
skipping events and usage records for this user usageiterator and number of threads 

success = true;	}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	
sending cleanup command 

}	}	if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	
cleanup command finished with response code 

if (usageIterator >= numThreads) {	int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	
sending stop domr destroy vm command 

int eventsAndBillingResponseCode = executeEventsAndBilling(server, developerServer);	usageIterator = 1;	} else {	usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	
stop destroy command finished with response code 

usageIterator++;	}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = (stopResponseCode == 200);	}	} else {	
ssh test failed for account with reason stopping vms 

}	if ((users == null) && (accountName == null)) {	int cleanupResponseCode = executeCleanup(server, developerServer, username);	success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = (stopResponseCode == 200);	}	} else {	int stopResponseCode = executeStop(server, developerServer, username, false);	
stop command finished with response code 

success = (cleanupResponseCode == 200);	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = (stopResponseCode == 200);	}	} else {	int stopResponseCode = executeStop(server, developerServer, username, false);	success = false;	}	} else {	
deploy test failed with reason stopping vms 

} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = (stopResponseCode == 200);	}	} else {	int stopResponseCode = executeStop(server, developerServer, username, false);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	
stop command finished with response code 

}	} else {	int stopResponseCode = executeStop(server, developerServer, username, false);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = false;	}	if (success) {	
completed test for user in seconds 

} else {	int stopResponseCode = executeStop(server, developerServer, username, false);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = false;	}	if (success) {	} else {	
failed test for user in seconds with reason 

int stopResponseCode = executeStop(server, developerServer, username, false);	success = false;	}	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = false;	}	if (success) {	} else {	}	
sleeping for seconds before starting next iteration 

}	} else {	int stopResponseCode = executeStop(server, developerServer, username, true);	success = false;	}	if (success) {	} else {	}	Thread.sleep(wait);	} catch (Exception e) {	
error in thread 

int stopResponseCode = executeStop(server, developerServer, username, true);	success = false;	}	if (success) {	} else {	}	Thread.sleep(wait);	} catch (Exception e) {	try {	int stopResponseCode = executeStop(server, developerServer, username, true);	
stop response code 

success = false;	}	if (success) {	} else {	}	Thread.sleep(wait);	} catch (Exception e) {	try {	int stopResponseCode = executeStop(server, developerServer, username, true);	} catch (Exception e1) {	
ignored error executing stop during api test 

public static Map<String, List<String>> getMultipleValuesFromXML(InputStream is, String[] tagNames) {	Map<String, List<String>> returnValues = new HashMap<String, List<String>>();	try {	DocumentBuilder docBuilder = factory.newDocumentBuilder();	Document doc = docBuilder.parse(is);	Element rootElement = doc.getDocumentElement();	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	
no tag in xml response returning null 

public static Map<String, String> getSingleValueFromXML(InputStream is, String[] tagNames) {	Map<String, String> returnValues = new HashMap<String, String>();	try {	DocumentBuilder docBuilder = factory.newDocumentBuilder();	Document doc = docBuilder.parse(is);	Element rootElement = doc.getDocumentElement();	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	
no tag in xml response returning null 

Document doc = docBuilder.parse(is);	Element rootElement = doc.getDocumentElement();	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	} else {	returnValues.put(tagNames[i], targetNodes.item(0).getTextContent());	}	}	} catch (Exception ex) {	
error processing xml 

public static Map<String, String> getSingleValueFromXML(Element rootElement, String[] tagNames) {	Map<String, String> returnValues = new HashMap<String, String>();	if (rootElement == null) {	
root element is null can t get single value from xml 

public static Map<String, String> getSingleValueFromXML(Element rootElement, String[] tagNames) {	Map<String, String> returnValues = new HashMap<String, String>();	if (rootElement == null) {	return null;	}	try {	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	
no tag in xml response returning null 

}	try {	for (int i = 0; i < tagNames.length; i++) {	NodeList targetNodes = rootElement.getElementsByTagName(tagNames[i]);	if (targetNodes.getLength() <= 0) {	} else {	returnValues.put(tagNames[i], targetNodes.item(0).getTextContent());	}	}	} catch (Exception ex) {	
error processing xml 

private static String executeRegistration(String server, String username, String password) throws HttpException, IOException {	String url = server + "?command=registerUserKeys&id=" + s_userId.get().toString();	
registering 

String returnValue = null;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> requestKeyValues = getSingleValueFromXML(is, new String[] {"apikey", "secretkey"});	s_apiKey.set(requestKeyValues.get("apikey"));	returnValue = requestKeyValues.get("secretkey");	} else {	
registration failed with error code 

String encodedPassword = URLEncoder.encode(encryptedPassword, "UTF-8");	String url = server + "?command=createAccount&username=" + encodedUsername + "&account=" + encodedUsername + "&password=" + encodedPassword + "&firstname=Test&lastname=Test&email=test@vmops.com&domainId=1&accounttype=0";	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	long accountId = -1;	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> accountValues = getSingleValueFromXML(is, new String[] {"id", "name"});	String accountIdStr = accountValues.get("id");	
created account with id 

long accountId = -1;	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> accountValues = getSingleValueFromXML(is, new String[] {"id", "name"});	String accountIdStr = accountValues.get("id");	if (accountIdStr != null) {	accountId = Long.parseLong(accountIdStr);	s_accountId.set(accountId);	s_account.set(accountValues.get("name"));	if (accountId == -1) {	
create account failed to retrieve a valid user id aborting depolyment test 

String accountIdStr = accountValues.get("id");	if (accountIdStr != null) {	accountId = Long.parseLong(accountIdStr);	s_accountId.set(accountId);	s_account.set(accountValues.get("name"));	if (accountId == -1) {	return -1;	}	}	} else {	
create account test failed for account with error code aborting deployment test the command was sent with url 

}	url = server + "?command=listUsers&username=" + encodedUsername + "&account=" + encodedUsername + "&domainId=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	long userId = -1;	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id"});	String userIdStr = userIdValues.get("id");	
listed user with id 

responseCode = client.executeMethod(method);	long userId = -1;	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id"});	String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = Long.parseLong(userIdStr);	s_userId.set(userId);	if (userId == -1) {	
list user by username failed to retrieve a valid user id aborting depolyment test 

Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id"});	String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = Long.parseLong(userIdStr);	s_userId.set(userId);	if (userId == -1) {	return -1;	}	}	} else {	
list user test failed for account with error code aborting deployment test the command was sent with url 

s_userId.set(userId);	if (userId == -1) {	return -1;	}	}	} else {	return -1;	}	s_secretKey.set(executeRegistration(server, username, username));	if (s_secretKey.get() == null) {	
failed to retrieve secret key during registration skipping user 

return -1;	}	}	} else {	return -1;	}	s_secretKey.set(executeRegistration(server, username, username));	if (s_secretKey.get() == null) {	return -1;	} else {	
got secret key 

return -1;	}	}	} else {	return -1;	}	s_secretKey.set(executeRegistration(server, username, username));	if (s_secretKey.get() == null) {	return -1;	} else {	
got api key 

} else {	}	url = server + "?command=createNetwork&networkofferingid=" + networkOfferingId + "&account=" + encodedUsername + "&domainId=1" + "&zoneId=" + zoneId + "&name=virtualnetwork-" + encodedUsername + "&displaytext=virtualnetwork-" + encodedUsername;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> networkValues = getSingleValueFromXML(is, new String[] {"id"});	String networkIdStr = networkValues.get("id");	
created virtual network with name virtualnetwork and id 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> networkValues = getSingleValueFromXML(is, new String[] {"id"});	String networkIdStr = networkValues.get("id");	if (networkIdStr != null) {	s_networkId.set(networkIdStr);	}	} else {	
create virtual network failed for account with error code aborting deployment test the command was sent with url 

return -1;	}	url = server + "?command=createNetwork&networkofferingid=" + networkOfferingId_dir + "&account=" + encodedUsername + "&domainId=1" + "&zoneId=" + zoneId + "&name=directnetwork-" + encodedUsername + "&displaytext=directnetwork-" + encodedUsername;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> networkValues = getSingleValueFromXML(is, new String[] { "id" });	String networkIdStr = networkValues.get("id");	
created direct network with name directnetwork and id 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> networkValues = getSingleValueFromXML(is, new String[] { "id" });	String networkIdStr = networkValues.get("id");	if (networkIdStr != null) {	s_networkId_dir.set(networkIdStr);	}	} else {	
create direct network failed for account with error code aborting deployment test the command was sent with url 

String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=deployVirtualMachine" + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&diskofferingid=" + diskOfferingId + "&networkids=" + encodedNetworkIds + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	
deploy linux vm response code the command was sent with url 

url = developerServer + "?command=deployVirtualMachine" + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&diskofferingid=" + diskOfferingId + "&networkids=" + encodedNetworkIds + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	
deploy linux vm response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long linuxVMId = Long.parseLong(values.get("id"));	
got linux virtual machine id 

InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long linuxVMId = Long.parseLong(values.get("id"));	s_linuxVmId.set(values.get("id"));	linuxVMPrivateIP = values.get("ipaddress");	s_linuxPassword.set(vmPassword);	
got linux virtual machine password 

Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long linuxVMId = Long.parseLong(values.get("id"));	s_linuxVmId.set(values.get("id"));	linuxVMPrivateIP = values.get("ipaddress");	s_linuxPassword.set(vmPassword);	}	} else {	
deploy linux vm failed with error code following url was sent 

String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=associateIpAddress" + "&apikey=" + encodedApiKey + "&zoneid=" + zoneId + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Element associpel = queryAsyncJobResult(server, is);	Map<String, String> values = getSingleValueFromXML(associpel, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	
associate ip for windows response code the command was sent with url 

url = developerServer + "?command=associateIpAddress" + "&apikey=" + encodedApiKey + "&zoneid=" + zoneId + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Element associpel = queryAsyncJobResult(server, is);	Map<String, String> values = getSingleValueFromXML(associpel, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	
associate ip address response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Element associpel = queryAsyncJobResult(server, is);	Map<String, String> values = getSingleValueFromXML(associpel, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long publicIpId = Long.parseLong(values.get("id"));	
associate ip s id 

InputStream is = method.getResponseBodyAsStream();	Element associpel = queryAsyncJobResult(server, is);	Map<String, String> values = getSingleValueFromXML(associpel, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	long publicIpId = Long.parseLong(values.get("id"));	s_publicIpId.set(values.get("id"));	}	} else {	
associate ip address for windows vm failed with error code following url was sent 

}	String encodedPublicIpId = URLEncoder.encode(s_publicIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=listPublicIpAddresses" + "&id=" + encodedPublicIpId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
url is 

}	String encodedPublicIpId = URLEncoder.encode(s_publicIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=listPublicIpAddresses" + "&id=" + encodedPublicIpId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list ip addresses for user response code 

url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	List<String> ipAddressValues = getIPs(is, false);	if ((ipAddressValues != null) && !ipAddressValues.isEmpty()) {	s_windowsIpId.set(ipAddressValues.get(0));	s_windowsIP.set(ipAddressValues.get(1));	
for windows using non sourcenat ip address id 

url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	List<String> ipAddressValues = getIPs(is, false);	if ((ipAddressValues != null) && !ipAddressValues.isEmpty()) {	s_windowsIpId.set(ipAddressValues.get(0));	s_windowsIP.set(ipAddressValues.get(1));	
for windows using non sourcenat ip address 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	List<String> ipAddressValues = getIPs(is, false);	if ((ipAddressValues != null) && !ipAddressValues.isEmpty()) {	s_windowsIpId.set(ipAddressValues.get(0));	s_windowsIP.set(ipAddressValues.get(1));	}	} else {	
list ip addresses failed with error code following url was sent 

}	{	requestToSign = "apikey=" + encodedApiKey + "&command=listPublicIpAddresses";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
url is 

}	{	requestToSign = "apikey=" + encodedApiKey + "&command=listPublicIpAddresses";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list ip addresses for user response code 

url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	List<String> ipAddressValues = getIPs(is, true);	if ((ipAddressValues != null) && !ipAddressValues.isEmpty()) {	s_linuxIpId.set(ipAddressValues.get(0));	s_linuxIP.set(ipAddressValues.get(1));	
for linux using sourcenat ip address id 

url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	List<String> ipAddressValues = getIPs(is, true);	if ((ipAddressValues != null) && !ipAddressValues.isEmpty()) {	s_linuxIpId.set(ipAddressValues.get(0));	s_linuxIP.set(ipAddressValues.get(1));	
for linux using sourcenat ip address 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	List<String> ipAddressValues = getIPs(is, true);	if ((ipAddressValues != null) && !ipAddressValues.isEmpty()) {	s_linuxIpId.set(ipAddressValues.get(0));	s_linuxIP.set(ipAddressValues.get(1));	}	} else {	
list ip addresses failed with error code following url was sent 

}	}	String encodedSourceNatPublicIpId = URLEncoder.encode(s_linuxIpId.get(), "UTF-8");	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&signature=" + encodedSignature + "&id=" + encodedSourceNatPublicIpId + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
url is 

}	}	String encodedSourceNatPublicIpId = URLEncoder.encode(s_linuxIpId.get(), "UTF-8");	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&signature=" + encodedSignature + "&id=" + encodedSourceNatPublicIpId + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list ip addresses for user response code 

requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&signature=" + encodedSignature + "&id=" + encodedSourceNatPublicIpId + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] { "success" });	
enable static nat success success 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&signature=" + encodedSignature + "&id=" + encodedSourceNatPublicIpId + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] { "success" });	} else {	
enable static nat failed with error code following url was sent 

} else {	return responseCode;	}	String encodedVmId = URLEncoder.encode(s_linuxVmId.get(), "UTF-8");	String encodedIpAddress = URLEncoder.encode(s_linuxIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=createPortForwardingRule&ipaddressid=" + encodedIpAddress + "&privateport=22&protocol=TCP&publicport=22" + "&virtualmachineid=" + encodedVmId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createPortForwardingRule&apikey=" + encodedApiKey + "&ipaddressid=" + encodedIpAddress + "&privateport=22&protocol=TCP&publicport=22&virtualmachineid=" + encodedVmId + "&signature=" + encodedSignature;	
created port forwarding rule with 

requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createPortForwardingRule&apikey=" + encodedApiKey + "&ipaddressid=" + encodedIpAddress + "&privateport=22&protocol=TCP&publicport=22&virtualmachineid=" + encodedVmId + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	
port forwarding rule was assigned successfully to linux vm 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createPortForwardingRule&apikey=" + encodedApiKey + "&ipaddressid=" + encodedIpAddress + "&privateport=22&protocol=TCP&publicport=22&virtualmachineid=" + encodedVmId + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	long ipfwdid = Long.parseLong(values.get("id"));	
got port forwarding rule s id 

url = developerServer + "?command=createPortForwardingRule&apikey=" + encodedApiKey + "&ipaddressid=" + encodedIpAddress + "&privateport=22&protocol=TCP&publicport=22&virtualmachineid=" + encodedVmId + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	long ipfwdid = Long.parseLong(values.get("id"));	s_linipfwdid.set(values.get("id"));	} else {	
port forwarding rule creation failed with error code following url was sent 

Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	long ipfwdid = Long.parseLong(values.get("id"));	s_linipfwdid.set(values.get("id"));	} else {	return responseCode;	}	if (snapshotTest.equals("yes")) {	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	
getting rootdisk id of centos vm 

s_linipfwdid.set(values.get("id"));	} else {	return responseCode;	}	if (snapshotTest.equals("yes")) {	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list volumes response code 

if (snapshotTest.equals("yes")) {	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	if (success.get("id") == null) {	
unable to get root volume for linux vm followin url was sent 

{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	if (success.get("id") == null) {	}	
got rootvolume for linux vm with id id 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	if (success.get("id") == null) {	}	s_rootVolume.set(success.get("id"));	} else {	
list volumes for linux vm failed with error code following url was sent 

if (success.get("id") == null) {	}	s_rootVolume.set(success.get("id"));	} else {	return responseCode;	}	}	{	String encodedTimeZone = URLEncoder.encode("America/Los Angeles", "UTF-8");	url = server + "?command=createSnapshotPolicy&intervaltype=hourly&schedule=10&maxsnaps=4&volumeid=" + s_rootVolume.get() + "&timezone=" + encodedTimeZone;	
creating recurring snapshot policy for linux vm root disk 

} else {	return responseCode;	}	}	{	String encodedTimeZone = URLEncoder.encode("America/Los Angeles", "UTF-8");	url = server + "?command=createSnapshotPolicy&intervaltype=hourly&schedule=10&maxsnaps=4&volumeid=" + s_rootVolume.get() + "&timezone=" + encodedTimeZone;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
create recurring snapshot policy for linux vm root disk 

return responseCode;	}	}	{	String encodedTimeZone = URLEncoder.encode("America/Los Angeles", "UTF-8");	url = server + "?command=createSnapshotPolicy&intervaltype=hourly&schedule=10&maxsnaps=4&volumeid=" + s_rootVolume.get() + "&timezone=" + encodedTimeZone;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode != 200) {	
create recurring snapshot policy for linux vm root disk failed with error code following url was sent 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=deployVirtualMachine" + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&diskofferingid=" + diskOfferingId + "&networkids=" + encodedNetworkIds + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	
deploy windows vm response code the command was sent with url 

url = developerServer + "?command=deployVirtualMachine" + "&zoneid=" + encodedZoneId + "&serviceofferingid=" + encodedServiceOfferingId + "&diskofferingid=" + diskOfferingId + "&networkids=" + encodedNetworkIds + "&templateid=" + encodedTemplateId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	
deploy windows vm response code 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	windowsVMPrivateIP = values.get("ipaddress");	long windowsVMId = Long.parseLong(values.get("id"));	
got windows virtual machine id 

Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id", "ipaddress"});	if ((values.get("ipaddress") == null) || (values.get("id") == null)) {	return 401;	} else {	windowsVMPrivateIP = values.get("ipaddress");	long windowsVMId = Long.parseLong(values.get("id"));	s_windowsVmId.set(values.get("id"));	}	} else {	
deploy windows vm failes with error code following url was sent 

encodedVmId = URLEncoder.encode(s_windowsVmId.get(), "UTF-8");	encodedPublicIpId = URLEncoder.encode(s_publicIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=enableStaticNat" + "&ipaddressid=" + encodedPublicIpId + "&virtualMachineId=" + encodedVmId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&ipaddressid=" + encodedPublicIpId + "&signature=" + encodedSignature + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
url is 

encodedVmId = URLEncoder.encode(s_windowsVmId.get(), "UTF-8");	encodedPublicIpId = URLEncoder.encode(s_publicIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=enableStaticNat" + "&ipaddressid=" + encodedPublicIpId + "&virtualMachineId=" + encodedVmId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&ipaddressid=" + encodedPublicIpId + "&signature=" + encodedSignature + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list ip addresses for user response code 

requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&ipaddressid=" + encodedPublicIpId + "&signature=" + encodedSignature + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	
enable static nat success success 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=enableStaticNat&apikey=" + encodedApiKey + "&ipaddressid=" + encodedPublicIpId + "&signature=" + encodedSignature + "&virtualMachineId=" + encodedVmId;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	} else {	
enable static nat failed with error code following url was sent 

Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	} else {	return responseCode;	}	encodedIpAddress = URLEncoder.encode(s_windowsIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=createIpForwardingRule&endPort=22&ipaddressid=" + encodedIpAddress + "&protocol=TCP&startPort=22";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createIpForwardingRule&apikey=" + encodedApiKey + "&endPort=22&ipaddressid=" + encodedIpAddress + "&protocol=TCP&signature=" + encodedSignature + "&startPort=22";	
created ip forwarding rule with 

requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createIpForwardingRule&apikey=" + encodedApiKey + "&endPort=22&ipaddressid=" + encodedIpAddress + "&protocol=TCP&signature=" + encodedSignature + "&startPort=22";	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	
port forwarding rule was assigned successfully to windows vm 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createIpForwardingRule&apikey=" + encodedApiKey + "&endPort=22&ipaddressid=" + encodedIpAddress + "&protocol=TCP&signature=" + encodedSignature + "&startPort=22";	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	long ipfwdid = Long.parseLong(values.get("id"));	
got ip forwarding rule s id 

url = developerServer + "?command=createIpForwardingRule&apikey=" + encodedApiKey + "&endPort=22&ipaddressid=" + encodedIpAddress + "&protocol=TCP&signature=" + encodedSignature + "&startPort=22";	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	long ipfwdid = Long.parseLong(values.get("id"));	s_winipfwdid.set(values.get("id"));	} else {	
port forwarding rule creation failed with error code following url was sent 

private static int executeCleanup(String server, String developerServer, String username) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	
cleaning up resources for user with url 

private static int executeCleanup(String server, String developerServer, String username) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
get user response code 

String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userInfo = getSingleValueFromXML(is, new String[] {"username", "id", "account"});	if (!username.equals(userInfo.get("username"))) {	
get user failed to retrieve requested user aborting cleanup test following url was sent 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userInfo = getSingleValueFromXML(is, new String[] {"username", "id", "account"});	if (!username.equals(userInfo.get("username"))) {	return -1;	}	} else {	
get user failed with error code following url was sent 

return -1;	}	} else {	return responseCode;	}	{	url = server + "?command=updateUser&id=" + userId + "&firstname=delete&lastname=me";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
update user response code 

return responseCode;	}	{	url = server + "?command=updateUser&id=" + userId + "&firstname=delete&lastname=me";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	
update user success success 

}	{	url = server + "?command=updateUser&id=" + userId + "&firstname=delete&lastname=me";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	} else {	
update user failed with error code following url was sent 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	} else {	return responseCode;	}	}	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=dataDisk";	
getting datadisk id of centos vm 

Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	} else {	return responseCode;	}	}	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=dataDisk";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list volumes response code 

}	}	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=dataDisk";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	
got datadiskvolume with id id 

{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=dataDisk";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	s_dataVolume.set(success.get("id"));	} else {	
list volumes failed with error code following url was sent 

if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	s_dataVolume.set(success.get("id"));	} else {	return responseCode;	}	}	{	url = server + "?command=detachVolume&id=" + s_dataVolume.get();	
detaching volume with id 

s_dataVolume.set(success.get("id"));	} else {	return responseCode;	}	}	{	url = server + "?command=detachVolume&id=" + s_dataVolume.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
detach data volume response code 

}	}	{	url = server + "?command=detachVolume&id=" + s_dataVolume.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	
the volume was detached successfully 

}	{	url = server + "?command=detachVolume&id=" + s_dataVolume.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	
detach data disk failed with error code following url was sent 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	return responseCode;	}	}	{	url = server + "?command=deleteVolume&id=" + s_dataVolume.get();	
deleting volume with id 

Element el = queryAsyncJobResult(server, input);	} else {	return responseCode;	}	}	{	url = server + "?command=deleteVolume&id=" + s_dataVolume.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
delete data volume response code 

} else {	return responseCode;	}	}	{	url = server + "?command=deleteVolume&id=" + s_dataVolume.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	
the volume was deleted successfully 

return responseCode;	}	}	{	url = server + "?command=deleteVolume&id=" + s_dataVolume.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	} else {	
delete volume failed with error code following url was sent 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	} else {	return responseCode;	}	}	{	url = server + "?command=createVolume&diskofferingid=" + diskOfferingId + "&zoneid=" + zoneId + "&name=newvolume&account=" + s_account.get() + "&domainid=1";	
creating volume 

{	url = server + "?command=createVolume&diskofferingid=" + diskOfferingId + "&zoneid=" + zoneId + "&name=newvolume&account=" + s_account.get() + "&domainid=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
create volume response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
create volume response code 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	long volumeId = Long.parseLong(values.get("id"));	
got volume id 

InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	long volumeId = Long.parseLong(values.get("id"));	s_newVolume.set(values.get("id"));	}	} else {	
create volume failed with error code following url was sent 

} else {	long volumeId = Long.parseLong(values.get("id"));	s_newVolume.set(values.get("id"));	}	} else {	return responseCode;	}	}	{	url = server + "?command=attachVolume&id=" + s_newVolume.get() + "&virtualmachineid=" + s_linuxVmId.get();	
attaching volume with id to the vm 

}	} else {	return responseCode;	}	}	{	url = server + "?command=attachVolume&id=" + s_newVolume.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
attach data volume response code 

}	}	{	url = server + "?command=attachVolume&id=" + s_newVolume.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	
the volume was attached successfully 

}	{	url = server + "?command=attachVolume&id=" + s_newVolume.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	
attach volume failed with error code following url was sent 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	return responseCode;	}	}	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	
getting rootdisk id of centos vm 

Element el = queryAsyncJobResult(server, input);	} else {	return responseCode;	}	}	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list volumes response code 

}	{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	if (success.get("id") == null) {	
unable to get root volume followin url was sent 

{	url = server + "?command=listVolumes&virtualMachineId=" + s_linuxVmId.get() + "&type=root";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	if (success.get("id") == null) {	}	
got rootvolume with id id 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	if (success.get("id") == null) {	}	s_rootVolume.set(success.get("id"));	} else {	
list volumes failed with error code following url was sent 

}	String encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String requestToSign = "apikey=" + encodedApiKey + "&command=createSnapshot&volumeid=" + s_rootVolume.get();	requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createSnapshot&volumeid=" + s_rootVolume.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
create snapshot response code 

String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createSnapshot&volumeid=" + s_rootVolume.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
create snapshot response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
create snapshot response code got snapshot with id id 

if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	s_snapshot.set(values.get("id"));	}	} else {	
create snapshot failed with error code following url was sent 

return responseCode;	}	requestToSign = "apikey=" + encodedApiKey + "&command=createVolume&name=" + s_account.get() + "&snapshotid=" + s_snapshot.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createVolume&name=" + s_account.get() + "&snapshotid=" + s_snapshot.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
create volume from snapshot response code 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createVolume&name=" + s_account.get() + "&snapshotid=" + s_snapshot.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] { "id" });	if (values.get("id") == null) {	
create volume from snapshot response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] { "id" });	if (values.get("id") == null) {	return 401;	} else {	
create volume from snapshot response code got volume with id id the command was sent with url 

if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] { "id" });	if (values.get("id") == null) {	return 401;	} else {	s_volumeFromSnapshot.set(values.get("id"));	}	} else {	
create volume from snapshot failed with error code following url was sent 

if (values.get("id") == null) {	return 401;	} else {	s_volumeFromSnapshot.set(values.get("id"));	}	} else {	return responseCode;	}	{	url = server + "?command=attachVolume&id=" + s_volumeFromSnapshot.get() + "&virtualmachineid=" + s_linuxVmId.get();	
attaching volume with id to the vm 

s_volumeFromSnapshot.set(values.get("id"));	}	} else {	return responseCode;	}	{	url = server + "?command=attachVolume&id=" + s_volumeFromSnapshot.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
attach volume from snapshot to linux vm response code 

return responseCode;	}	{	url = server + "?command=attachVolume&id=" + s_volumeFromSnapshot.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	
the volume created from snapshot was attached successfully to linux vm 

}	{	url = server + "?command=attachVolume&id=" + s_volumeFromSnapshot.get() + "&virtualmachineid=" + s_linuxVmId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	
attach volume created from snapshot failed with error code following url was sent 

}	}	requestToSign = "apikey=" + encodedApiKey + "&command=rebootVirtualMachine&id=" + s_windowsVmId.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=rebootVirtualMachine&id=" + s_windowsVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
reboot windows vm response code 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=rebootVirtualMachine&id=" + s_windowsVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	
windows vm was rebooted with the status success 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=rebootVirtualMachine&id=" + s_windowsVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	} else {	
reboot windows vm test failed with error code following url was sent 

return responseCode;	}	requestToSign = "apikey=" + encodedApiKey + "&command=stopVirtualMachine&id=" + s_linuxVmId.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
stop linux vm response code 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	
linux vm was stopped with the status success 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=stopVirtualMachine&id=" + s_linuxVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	} else {	
stop linux vm test failed with error code following url was sent 

return responseCode;	}	requestToSign = "apikey=" + encodedApiKey + "&command=createTemplate" + "&displaytext=" + s_account.get() + "&name=" + s_account.get() + "&ostypeid=11" + "&snapshotid=" + s_snapshot.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createTemplate" + "&displaytext=" + s_account.get() + "&name=" + s_account.get() + "&ostypeid=11" + "&snapshotid=" + s_snapshot.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
create private template response code 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=createTemplate" + "&displaytext=" + s_account.get() + "&name=" + s_account.get() + "&ostypeid=11" + "&snapshotid=" + s_snapshot.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	
create private template response code 

client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	
create private template response code 

responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> values = getSingleValueFromXML(el, new String[] {"id"});	if (values.get("id") == null) {	return 401;	} else {	}	} else {	
create private template failed with error code following url was sent 

return responseCode;	}	requestToSign = "apikey=" + encodedApiKey + "&command=startVirtualMachine&id=" + s_windowsVmId.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=startVirtualMachine&id=" + s_windowsVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
start linux vm response code 

}	requestToSign = "apikey=" + encodedApiKey + "&command=startVirtualMachine&id=" + s_windowsVmId.get();	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=startVirtualMachine&id=" + s_windowsVmId.get() + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode != 200) {	
start linux vm test failed with error code following url was sent 

method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode != 200) {	return responseCode;	}	{	url = server + "?command=listRouters&zoneid=" + zoneId + "&account=" + s_account.get() + "&domainid=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list domain routers response code 

return responseCode;	}	{	url = server + "?command=listRouters&zoneid=" + zoneId + "&account=" + s_account.get() + "&domainid=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	
got the domr with id id 

{	url = server + "?command=listRouters&zoneid=" + zoneId + "&account=" + s_account.get() + "&domainid=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	s_domainRouterId.set(success.get("id"));	} else {	
list domain routers failed with error code following url was sent 

if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"id"});	s_domainRouterId.set(success.get("id"));	} else {	return responseCode;	}	}	{	url = server + "?command=rebootRouter&id=" + s_domainRouterId.get();	
rebooting domr with id 

s_domainRouterId.set(success.get("id"));	} else {	return responseCode;	}	}	{	url = server + "?command=rebootRouter&id=" + s_domainRouterId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
reboot domain router response code 

}	}	{	url = server + "?command=rebootRouter&id=" + s_domainRouterId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	
domain router was rebooted successfully 

}	{	url = server + "?command=rebootRouter&id=" + s_domainRouterId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	
reboot domain routers failed with error code following url was sent 

Element el = queryAsyncJobResult(server, input);	} else {	return responseCode;	}	}	{	url = server + "?command=deleteAccount&id=" + s_accountId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
delete account response code 

}	}	{	url = server + "?command=deleteAccount&id=" + s_accountId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	
deleted account successfully 

}	{	url = server + "?command=deleteAccount&id=" + s_accountId.get();	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	
delete account failed with error code following url was sent 

private static int executeEventsAndBilling(String server, String developerServer) throws HttpException, IOException {	String url = server + "?command=listEvents&page=1&pagesize=100&&account=" + s_account.get();	
getting events for the account 

private static int executeEventsAndBilling(String server, String developerServer) throws HttpException, IOException {	String url = server + "?command=listEvents&page=1&pagesize=100&&account=" + s_account.get();	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
get events response code 

private static int executeEventsAndBilling(String server, String developerServer) throws HttpException, IOException {	String url = server + "?command=listEvents&page=1&pagesize=100&&account=" + s_account.get();	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, List<String>> eventDescriptions = getMultipleValuesFromXML(is, new String[] {"description"});	List<String> descriptionText = eventDescriptions.get("description");	if (descriptionText == null) {	
no events retrieved 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, List<String>> eventDescriptions = getMultipleValuesFromXML(is, new String[] {"description"});	List<String> descriptionText = eventDescriptions.get("description");	if (descriptionText == null) {	} else {	for (String text : descriptionText) {	
event 

if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, List<String>> eventDescriptions = getMultipleValuesFromXML(is, new String[] {"description"});	List<String> descriptionText = eventDescriptions.get("description");	if (descriptionText == null) {	} else {	for (String text : descriptionText) {	}	}	} else {	
list events failed with error code following url was sent 

} else {	for (String text : descriptionText) {	}	}	} else {	return responseCode;	}	DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");	Date currentDate = new Date();	String endDate = dateFormat.format(currentDate);	
generating usage records from september till 

} else {	return responseCode;	}	DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");	Date currentDate = new Date();	String endDate = dateFormat.format(currentDate);	url = server + "?command=generateUsageRecords&startdate=2009-09-01&enddate=" + endDate;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
generate usage records response code 

DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");	Date currentDate = new Date();	String endDate = dateFormat.format(currentDate);	url = server + "?command=generateUsageRecords&startdate=2009-09-01&enddate=" + endDate;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> successStr = getSingleValueFromXML(is, new String[] {"success"});	
successfully generated usage records success 

Date currentDate = new Date();	String endDate = dateFormat.format(currentDate);	url = server + "?command=generateUsageRecords&startdate=2009-09-01&enddate=" + endDate;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> successStr = getSingleValueFromXML(is, new String[] {"success"});	} else {	
generate usage records failed with error code following url was sent 

Map<String, String> successStr = getSingleValueFromXML(is, new String[] {"success"});	} else {	return responseCode;	}	try {	Thread.sleep(120000);	} catch (Exception ex) {	s_logger.error(ex);	}	url = server + "?command=listUsageRecords&startdate=2009-09-01&enddate=" + endDate + "&account=" + s_account.get() + "&domaindid=1";	
getting all usage records with request 

}	try {	Thread.sleep(120000);	} catch (Exception ex) {	s_logger.error(ex);	}	url = server + "?command=listUsageRecords&startdate=2009-09-01&enddate=" + endDate + "&account=" + s_account.get() + "&domaindid=1";	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
get usage records response code 

List<String> descriptions = usageRecValues.get("description");	List<String> usages = usageRecValues.get("usage");	for (int i = 0; i < descriptions.size(); i++) {	String desc = descriptions.get(i);	String usage = "";	if (usages != null) {	if (i < usages.size()) {	usage = ", usage: " + usages.get(i);	}	}	
desc 

String desc = descriptions.get(i);	String usage = "";	if (usages != null) {	if (i < usages.size()) {	usage = ", usage: " + usages.get(i);	}	}	}	}	} else {	
list usage records failed with error code following url was sent 

private static boolean getNetworkStat(String server) {	try {	String url = server + "?command=listAccountStatistics&account=" + s_account.get();	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
listaccountstatistics response code 

String url = server + "?command=listAccountStatistics&account=" + s_account.get();	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> requestKeyValues = getSingleValueFromXML(is, new String[] {"receivedbytes", "sentbytes"});	int bytesReceived = Integer.parseInt(requestKeyValues.get("receivedbytes"));	int bytesSent = Integer.parseInt(requestKeyValues.get("sentbytes"));	if ((bytesReceived > 100000000) && (bytesSent > 0)) {	
network stat is correct for account bytest received is and bytes sent is 

HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> requestKeyValues = getSingleValueFromXML(is, new String[] {"receivedbytes", "sentbytes"});	int bytesReceived = Integer.parseInt(requestKeyValues.get("receivedbytes"));	int bytesSent = Integer.parseInt(requestKeyValues.get("sentbytes"));	if ((bytesReceived > 100000000) && (bytesSent > 0)) {	return true;	} else {	
incorrect value for bytes received sent for the account we got bytes received and bytes sent 

InputStream is = method.getResponseBodyAsStream();	Map<String, String> requestKeyValues = getSingleValueFromXML(is, new String[] {"receivedbytes", "sentbytes"});	int bytesReceived = Integer.parseInt(requestKeyValues.get("receivedbytes"));	int bytesSent = Integer.parseInt(requestKeyValues.get("sentbytes"));	if ((bytesReceived > 100000000) && (bytesSent > 0)) {	return true;	} else {	return false;	}	} else {	
listaccountstatistics failed with error code following url was sent 

int bytesSent = Integer.parseInt(requestKeyValues.get("sentbytes"));	if ((bytesReceived > 100000000) && (bytesSent > 0)) {	return true;	} else {	return false;	}	} else {	return false;	}	} catch (Exception ex) {	
exception while sending command listaccountstatistics 

private static int executeStop(String server, String developerServer, String username, boolean destroy) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	
stopping resources for user 

private static int executeStop(String server, String developerServer, String username, boolean destroy) throws HttpException, IOException {	String userId = s_userId.get().toString();	String encodedUserId = URLEncoder.encode(userId, "UTF-8");	String url = server + "?command=listUsers&id=" + encodedUserId;	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	
get user response code 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id"});	String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = userIdStr;	} else {	
get user failed to retrieve a valid user id aborting depolyment test following url was sent 

if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> userIdValues = getSingleValueFromXML(is, new String[] {"id"});	String userIdStr = userIdValues.get("id");	if (userIdStr != null) {	userId = userIdStr;	} else {	return -1;	}	} else {	
get user failed with error code following url was sent 

} else {	return responseCode;	}	{	String encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String requestToSign = "apikey=" + encodedApiKey + "&command=listVirtualMachines";	requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listVirtualMachines&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	
listing all virtual machines for the user with url 

String encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String requestToSign = "apikey=" + encodedApiKey + "&command=listVirtualMachines";	requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listVirtualMachines&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	String[] vmIds = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list virtual machines response code 

if (vmIdList != null) {	vmIds = new String[vmIdList.size()];	vmIdList.toArray(vmIds);	String vmIdLogStr = "";	if ((vmIds != null) && (vmIds.length > 0)) {	vmIdLogStr = vmIds[0];	for (int i = 1; i < vmIds.length; i++) {	vmIdLogStr = vmIdLogStr + "," + vmIds[i];	}	}	
got virtual machine ids 

String vmIdLogStr = "";	if ((vmIds != null) && (vmIds.length > 0)) {	vmIdLogStr = vmIds[0];	for (int i = 1; i < vmIds.length; i++) {	vmIdLogStr = vmIdLogStr + "," + vmIds[i];	}	}	}	}	} else {	
list virtual machines test failed with error code following url was sent 

}	requestToSign = "apikey=" + encodedApiKey + "&command=listPublicIpAddresses";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	String[] ipAddresses = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list ip addresses for user response code 

if (ipAddressList != null) {	ipAddresses = new String[ipAddressList.size()];	ipAddressList.toArray(ipAddresses);	String ipAddressLogStr = "";	if ((ipAddresses != null) && (ipAddresses.length > 0)) {	ipAddressLogStr = ipAddresses[0];	for (int i = 1; i < ipAddresses.length; i++) {	ipAddressLogStr = ipAddressLogStr + "," + ipAddresses[i];	}	}	
got ip addresses 

String ipAddressLogStr = "";	if ((ipAddresses != null) && (ipAddresses.length > 0)) {	ipAddressLogStr = ipAddresses[0];	for (int i = 1; i < ipAddresses.length; i++) {	ipAddressLogStr = ipAddressLogStr + "," + ipAddresses[i];	}	}	}	}	} else {	
list user ip addresses failed with error code following url was sent 

}	requestToSign = "apikey=" + encodedApiKey + "&command=listZones";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listZones&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	String[] zoneNames = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list zones response code 

zoneNames = new String[zoneNameList.size()];	zoneNameList.toArray(zoneNames);	String zoneNameLogStr = "\n\n";	if ((zoneNames != null) && (zoneNames.length > 0)) {	zoneNameLogStr += zoneNames[0];	for (int i = 1; i < zoneNames.length; i++) {	zoneNameLogStr = zoneNameLogStr + "\n" + zoneNames[i];	}	}	zoneNameLogStr += "\n\n";	
got zones names 

if ((zoneNames != null) && (zoneNames.length > 0)) {	zoneNameLogStr += zoneNames[0];	for (int i = 1; i < zoneNames.length; i++) {	zoneNameLogStr = zoneNameLogStr + "\n" + zoneNames[i];	}	}	zoneNameLogStr += "\n\n";	}	}	} else {	
list zones failed with error code following url was sent 

}	requestToSign = "apikey=" + encodedApiKey + "&command=listAccounts";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listAccounts&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	String[] statNames = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
listaccountstatistics response code 

statNames = new String[statList.size()];	statList.toArray(statNames);	String statLogStr = "\n\n";	if ((statNames != null) && (zoneNames.length > 0)) {	statLogStr += statNames[0];	for (int i = 1; i < statNames.length; i++) {	statLogStr = statLogStr + "\n" + zoneNames[i];	}	}	statLogStr += "\n\n";	
got accountstatistics 

if ((statNames != null) && (zoneNames.length > 0)) {	statLogStr += statNames[0];	for (int i = 1; i < statNames.length; i++) {	statLogStr = statLogStr + "\n" + zoneNames[i];	}	}	statLogStr += "\n\n";	}	}	} else {	
listaccountstatistics failed with error code following url was sent 

}	requestToSign = "apikey=" + encodedApiKey + "&command=listTemplates@templatefilter=self";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listTemplates&apikey=" + encodedApiKey + "&templatefilter=self&signature=" + encodedSignature;	String[] templateNames = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list templates response code 

templateNames = new String[templateNameList.size()];	templateNameList.toArray(templateNames);	String templateNameLogStr = "\n\n";	if ((templateNames != null) && (templateNames.length > 0)) {	templateNameLogStr += templateNames[0];	for (int i = 1; i < templateNames.length; i++) {	templateNameLogStr = templateNameLogStr + "\n" + templateNames[i];	}	}	templateNameLogStr += "\n\n";	
got template names 

if ((templateNames != null) && (templateNames.length > 0)) {	templateNameLogStr += templateNames[0];	for (int i = 1; i < templateNames.length; i++) {	templateNameLogStr = templateNameLogStr + "\n" + templateNames[i];	}	}	templateNameLogStr += "\n\n";	}	}	} else {	
list templates failed with error code following url was sent 

}	requestToSign = "apikey=" + encodedApiKey + "&command=listServiceOfferings";	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listServiceOfferings&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	String[] serviceOfferingNames = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list service offerings response code 

if (serviceOfferingNameList != null) {	serviceOfferingNames = new String[serviceOfferingNameList.size()];	serviceOfferingNameList.toArray(serviceOfferingNames);	String serviceOfferingNameLogStr = "";	if ((serviceOfferingNames != null) && (serviceOfferingNames.length > 0)) {	serviceOfferingNameLogStr = serviceOfferingNames[0];	for (int i = 1; i < serviceOfferingNames.length; i++) {	serviceOfferingNameLogStr = serviceOfferingNameLogStr + ", " + serviceOfferingNames[i];	}	}	
got service offering names 

String serviceOfferingNameLogStr = "";	if ((serviceOfferingNames != null) && (serviceOfferingNames.length > 0)) {	serviceOfferingNameLogStr = serviceOfferingNames[0];	for (int i = 1; i < serviceOfferingNames.length; i++) {	serviceOfferingNameLogStr = serviceOfferingNameLogStr + ", " + serviceOfferingNames[i];	}	}	}	}	} else {	
list service offerings failed with error code following url was sent 

}	}	} else {	return responseCode;	}	url = server + "?command=listEvents&page=1&pagesize=100&&account=" + s_account.get();	String[] eventDescriptions = null;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list events response code 

eventDescriptions = new String[eventNameList.size()];	eventNameList.toArray(eventDescriptions);	String eventNameLogStr = "\n\n";	if ((eventDescriptions != null) && (eventDescriptions.length > 0)) {	eventNameLogStr += eventDescriptions[0];	for (int i = 1; i < eventDescriptions.length; i++) {	eventNameLogStr = eventNameLogStr + "\n" + eventDescriptions[i];	}	}	eventNameLogStr += "\n\n";	
got event descriptions 

if ((eventDescriptions != null) && (eventDescriptions.length > 0)) {	eventNameLogStr += eventDescriptions[0];	for (int i = 1; i < eventDescriptions.length; i++) {	eventNameLogStr = eventNameLogStr + "\n" + eventDescriptions[i];	}	}	eventNameLogStr += "\n\n";	}	}	} else {	
list events failed with error code following url was sent 

String cmdName = (destroy ? "destroyVirtualMachine" : "stopVirtualMachine");	for (String vmId : vmIds) {	requestToSign = "apikey=" + encodedApiKey + "&command=" + cmdName + "&id=" + vmId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=" + cmdName + "&id=" + vmId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
response code 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=" + cmdName + "&id=" + vmId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	
success success 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=" + cmdName + "&id=" + vmId + "&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(el, new String[] {"success"});	} else {	
test failed with error code following url was sent 

String[] ipAddresses = null;	String encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String requestToSign = "apikey=" + encodedApiKey + "&command=listPublicIpAddresses";	requestToSign = requestToSign.toLowerCase();	String signature = signRequest(requestToSign, s_secretKey.get());	String encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=listPublicIpAddresses&apikey=" + encodedApiKey + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list ip addresses for user response code 

List<String> ipAddressList = getNonSourceNatIPs(is);	ipAddresses = new String[ipAddressList.size()];	ipAddressList.toArray(ipAddresses);	String ipAddrLogStr = "";	if ((ipAddresses != null) && (ipAddresses.length > 0)) {	ipAddrLogStr = ipAddresses[0];	for (int i = 1; i < ipAddresses.length; i++) {	ipAddrLogStr = ipAddrLogStr + "," + ipAddresses[i];	}	}	
got ip addresses 

ipAddresses = new String[ipAddressList.size()];	ipAddressList.toArray(ipAddresses);	String ipAddrLogStr = "";	if ((ipAddresses != null) && (ipAddresses.length > 0)) {	ipAddrLogStr = ipAddresses[0];	for (int i = 1; i < ipAddresses.length; i++) {	ipAddrLogStr = ipAddrLogStr + "," + ipAddresses[i];	}	}	} else {	
list nat ip addresses failed with error code following url was sent 

}	} else {	return responseCode;	}	String encodedIpFwdId = URLEncoder.encode(s_winipfwdid.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=deleteIpForwardingRule&id=" + encodedIpFwdId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=deleteIpForwardingRule&apikey=" + encodedApiKey + "&id=" + encodedIpFwdId + "&signature=" + encodedSignature;	
delete ip forwarding rule with 

requestToSign = "apikey=" + encodedApiKey + "&command=deleteIpForwardingRule&id=" + encodedIpFwdId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=deleteIpForwardingRule&apikey=" + encodedApiKey + "&id=" + encodedIpFwdId + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	
ip forwarding rule was successfully deleted 

requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=deleteIpForwardingRule&apikey=" + encodedApiKey + "&id=" + encodedIpFwdId + "&signature=" + encodedSignature;	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element el = queryAsyncJobResult(server, input);	} else {	
ip forwarding rule creation failed with error code following url was sent 

encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String encodedPublicIpId = URLEncoder.encode(s_publicIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=disableStaticNat" + "&id=" + encodedPublicIpId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=disableStaticNat&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
url is 

encodedApiKey = URLEncoder.encode(s_apiKey.get(), "UTF-8");	String encodedPublicIpId = URLEncoder.encode(s_publicIpId.get(), "UTF-8");	requestToSign = "apikey=" + encodedApiKey + "&command=disableStaticNat" + "&id=" + encodedPublicIpId;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=disableStaticNat&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
list ip addresses for user response code 

requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=disableStaticNat&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	
disable static nat success success 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=disableStaticNat&apikey=" + encodedApiKey + "&id=" + encodedPublicIpId + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream is = method.getResponseBodyAsStream();	Map<String, String> success = getSingleValueFromXML(is, new String[] {"success"});	} else {	
disable static nat failed with error code following url was sent 

if (ipAddresses != null) {	for (String ipAddress : ipAddresses) {	requestToSign = "apikey=" + encodedApiKey + "&command=disassociateIpAddress&id=" + ipAddress;	requestToSign = requestToSign.toLowerCase();	signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=disassociateIpAddress&apikey=" + encodedApiKey + "&id=" + ipAddress + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	
disassociate ip address response code 

signature = signRequest(requestToSign, s_secretKey.get());	encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=disassociateIpAddress&apikey=" + encodedApiKey + "&id=" + ipAddress + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element disassocipel = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(disassocipel, new String[] {"success"});	
disassociate ip address success success 

encodedSignature = URLEncoder.encode(signature, "UTF-8");	url = developerServer + "?command=disassociateIpAddress&apikey=" + encodedApiKey + "&id=" + ipAddress + "&signature=" + encodedSignature;	client = new HttpClient();	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	InputStream input = method.getResponseBodyAsStream();	Element disassocipel = queryAsyncJobResult(server, input);	Map<String, String> success = getSingleValueFromXML(disassocipel, new String[] {"success"});	} else {	
disassociate ip address failed with error code following url was sent 

public static String signRequest(String request, String key) {	try {	Mac mac = Mac.getInstance("HmacSHA1");	SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "HmacSHA1");	mac.init(keySpec);	mac.update(request.getBytes());	byte[] encryptedBytes = mac.doFinal();	return org.apache.commons.codec.binary.Base64.encodeBase64String(encryptedBytes);	} catch (Exception ex) {	
unable to sign request 

private static String sshWinTest(String host) {	if (host == null) {	
did not receive a host back from test ignoring win ssh test 

private static String sshWinTest(String host) {	if (host == null) {	return null;	}	int retry = 1;	while (true) {	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt account is 

private static String sshWinTest(String host) {	if (host == null) {	return null;	}	int retry = 1;	while (true) {	try {	if (retry > 0) {	Thread.sleep(300000);	}	
attempting to ssh into windows host with retry attempt for account 

return null;	}	int retry = 1;	while (true) {	try {	if (retry > 0) {	Thread.sleep(300000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
user sshed successfully into windows host 

if (retry > 0) {	Thread.sleep(300000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean success = false;	boolean isAuthenticated = conn.authenticateWithPassword("Administrator", "password");	if (isAuthenticated == false) {	return "Authentication failed";	} else {	
authentication is successfull 

conn.connect(null, 60000, 60000);	boolean success = false;	boolean isAuthenticated = conn.authenticateWithPassword("Administrator", "password");	if (isAuthenticated == false) {	return "Authentication failed";	} else {	}	try {	SCPClient scp = new SCPClient(conn);	scp.put("wget.exe", "wget.exe", "C:\\Users\\Administrator", "0777");	
successfully put wget exe file 

boolean success = false;	boolean isAuthenticated = conn.authenticateWithPassword("Administrator", "password");	if (isAuthenticated == false) {	return "Authentication failed";	} else {	}	try {	SCPClient scp = new SCPClient(conn);	scp.put("wget.exe", "wget.exe", "C:\\Users\\Administrator", "0777");	} catch (Exception ex) {	
unable to put wget exe 

if (isAuthenticated == false) {	return "Authentication failed";	} else {	}	try {	SCPClient scp = new SCPClient(conn);	scp.put("wget.exe", "wget.exe", "C:\\Users\\Administrator", "0777");	} catch (Exception ex) {	}	if (conn == null) {	
connection is null 

}	Session sess = conn.openSession();	s_logger.info("User + " + s_account.get() + " executing : wget http: String downloadCommand = "wget http: sess.execCommand(downloadCommand);	InputStream stdout = sess.getStdout();	InputStream stderr = sess.getStderr();	byte[] buffer = new byte[8192];	while (true) {	if ((stdout.available() == 0) && (stderr.available() == 0)) {	int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);	if ((conditions & ChannelCondition.TIMEOUT) != 0) {	
timeout while waiting for data from peer 

private static String sshTest(String host, String password, String snapshotTest) {	int i = 0;	if (host == null) {	
did not receive a host back from test ignoring ssh test 

private static String sshTest(String host, String password, String snapshotTest) {	int i = 0;	if (host == null) {	return null;	}	if (password == null) {	
did not receive a password back from test ignoring ssh test 

return null;	}	if (password == null) {	return null;	}	String result = null;	int retry = 0;	while (true) {	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt account is 

if (password == null) {	return null;	}	String result = null;	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	
attempting to ssh into linux host with retry attempt account is 

}	String result = null;	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
user sshed successfully into linux host 

int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", password);	if (isAuthenticated == false) {	
authentication failed for root with password 

}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", password);	if (isAuthenticated == false) {	return "Authentication failed";	}	boolean success = false;	String linuxCommand = null;	if (i % 10 == 0) linuxCommand = "rm -rf *; wget http: else linuxCommand = "wget http: Session sess = conn.openSession();	
user executing 

String linuxCommand = null;	if (i % 10 == 0) linuxCommand = "rm -rf *; wget http: else linuxCommand = "wget http: Session sess = conn.openSession();	sess.execCommand(linuxCommand);	InputStream stdout = sess.getStdout();	InputStream stderr = sess.getStderr();	byte[] buffer = new byte[8192];	while (true) {	if ((stdout.available() == 0) && (stderr.available() == 0)) {	int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);	if ((conditions & ChannelCondition.TIMEOUT) != 0) {	
timeout while waiting for data from peer 

conn.close();	if (!success) {	retry++;	if (retry == MAX_RETRY_LINUX) {	result = "SSH Linux Network test fail";	}	}	if (snapshotTest.equals("no")) return result;	else {	Long sleep = 300000L;	
sleeping for minutes before executing next ssh test 

result = "SSH Linux Network test fail";	}	}	if (snapshotTest.equals("no")) return result;	else {	Long sleep = 300000L;	Thread.sleep(sleep);	}	} catch (Exception e) {	retry++;	
ssh linux network test fail with error 

public static Element queryAsyncJobResult(String host, InputStream inputStream) {	Element returnBody = null;	Map<String, String> values = getSingleValueFromXML(inputStream, new String[] {"jobid"});	String jobId = values.get("jobid");	if (jobId == null) {	
unable to get a jobid 

DocumentBuilder builder = factory.newDocumentBuilder();	Document doc = builder.parse(is);	returnBody = doc.getDocumentElement();	doc.getDocumentElement().normalize();	Element jobStatusTag = (Element)returnBody.getElementsByTagName("jobstatus").item(0);	String jobStatus = jobStatusTag.getTextContent();	if (jobStatus.equals("0")) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while during async job result query 

========================= cloudstack sample_461 =========================

public boolean create(ApiObjectBase arg0) throws IOException {	
create id 

public void delete(ApiObjectBase arg0) throws IOException {	
delete id 

public void delete(Class<? extends ApiObjectBase> arg0, String arg1) throws IOException {	
create id 

public ApiObjectBase findByFQN(Class<? extends ApiObjectBase> arg0, String arg1) throws IOException {	
find name 

public ApiObjectBase findById(Class<? extends ApiObjectBase> arg0, String arg1) throws IOException {	
find id 

public String findByName(Class<? extends ApiObjectBase> arg0, List<String> arg1) throws IOException {	
find name 

public <T extends ApiPropertyBase> List<? extends ApiObjectBase> getObjects(Class<? extends ApiObjectBase> arg0, List<ObjectReference<T>> arg1) throws IOException {	
getObjects 

public List<? extends ApiObjectBase> list(Class<? extends ApiObjectBase> arg0, List<String> arg1) throws IOException {	
list 

public boolean read(ApiObjectBase arg0) throws IOException {	
read id 

public boolean update(ApiObjectBase arg0) throws IOException {	
update id 

========================= cloudstack sample_1855 =========================

protected boolean canHandle(NetworkOffering offering, DataCenter dc) {	if (dc.getNetworkType() == NetworkType.Advanced && isMyTrafficType(offering.getTrafficType()) && offering.getGuestType() == GuestType.Shared && !_ntwkOfferingSrvcDao.isProviderForNetworkOffering(offering.getId(), Network.Provider.NuageVsp) && !_ntwkOfferingSrvcDao.isProviderForNetworkOffering(offering.getId(), Network.Provider.NiciraNvp)) {	return true;	} else {	
we only take care of guest networks of type 

try {	Transaction.execute(new TransactionCallbackWithExceptionNoReturn<InsufficientCapacityException>() {	public void doInTransactionWithoutResult(TransactionStatus status) throws InsufficientVirtualNetworkCapacityException, InsufficientAddressCapacityException {	if (_networkModel.isSharedNetworkWithoutServices(network.getId())) {	_ipAddrMgr.allocateNicValues(nic, dc, vm, network, requestedIp4Addr, requestedIp6Addr);	} else {	_ipAddrMgr.allocateDirectIp(nic, dc, vm, network, requestedIp4Addr, requestedIp6Addr);	if (vm.getType() == VirtualMachine.Type.DomainRouter) {	Nic placeholderNic = _networkModel.getPlaceholderNicForRouter(network, null);	if (placeholderNic == null) {	
saving placeholder nic with address and address for the network 

public void deallocate(final Network network, final NicProfile nic, VirtualMachineProfile vm) {	if (s_logger.isDebugEnabled()) {	
deallocate network networkid ip 

public void deallocate(final Network network, final NicProfile nic, VirtualMachineProfile vm) {	if (s_logger.isDebugEnabled()) {	}	if (nic.getIPv4Address() != null) {	final IPAddressVO ip = _ipAddressDao.findByIpAndSourceNetworkId(nic.getNetworkId(), nic.getIPv4Address());	if (ip != null) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	Nic placeholderNic = _networkModel.getPlaceholderNicForRouter(network, null);	if (placeholderNic != null && placeholderNic.getIPv4Address().equalsIgnoreCase(ip.getAddress().addr())) {	
not releasing direct ip yet as its ip is saved in the placeholder 

final IPAddressVO ip = _ipAddressDao.findByIpAndSourceNetworkId(nic.getNetworkId(), nic.getIPv4Address());	if (ip != null) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	Nic placeholderNic = _networkModel.getPlaceholderNicForRouter(network, null);	if (placeholderNic != null && placeholderNic.getIPv4Address().equalsIgnoreCase(ip.getAddress().addr())) {	} else {	_ipAddrMgr.markIpAsUnavailable(ip.getId());	_ipAddressDao.unassignIpAddress(ip.getId());	}	
remove nic secondary ip 

public boolean trash(Network network, NetworkOffering offering) {	try {	long id = network.getId();	final List<NicVO> nics = _nicDao.listPlaceholderNicsByNetworkId(id);	if (nics != null) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	for (Nic nic : nics) {	if (nic.getIPv4Address() != null) {	
releasing ip of placeholder nic 

final List<NicVO> nics = _nicDao.listPlaceholderNicsByNetworkId(id);	if (nics != null) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	for (Nic nic : nics) {	if (nic.getIPv4Address() != null) {	IPAddressVO ip = _ipAddressDao.findByIpAndSourceNetworkId(nic.getNetworkId(), nic.getIPv4Address());	if (ip != null) {	_ipAddrMgr.markIpAsUnavailable(ip.getId());	_ipAddressDao.unassignIpAddress(ip.getId());	
removing placeholder nic 

_ipAddressDao.unassignIpAddress(ip.getId());	_nicDao.remove(nic.getId());	}	}	}	}	});	}	return true;	}catch (Exception e) {	
trash exception 

========================= cloudstack sample_2280 =========================

public DataStore initialize(Map<String, Object> dsInfos) {	Long dcId = (Long)dsInfos.get("zoneId");	String url = (String)dsInfos.get("url");	String name = (String)dsInfos.get("name");	ScopeType scope = (ScopeType)dsInfos.get("scope");	String providerName = (String)dsInfos.get("providerName");	DataStoreRole role = (DataStoreRole)dsInfos.get("role");	Map<String, String> details = (Map<String, String>)dsInfos.get("details");	
trying to add a swift store at in data center 

========================= cloudstack sample_1910 =========================

private void fixForeignKeys(Connection conn) {	HashMap<String, List<String>> foreignKeys = new HashMap<String, List<String>>();	List<String> keys = new ArrayList<String>();	keys.add("fk_networks__data_center_id");	foreignKeys.put("networks", keys);	
dropping old key fk networks data center id 

PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`networks` ADD CONSTRAINT `fk_networks__data_center_id` FOREIGN KEY (`data_center_id`) REFERENCES `data_center`(`id`) ON DELETE CASCADE");	pstmt.executeUpdate();	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to reinsert data center key for the network", e);	}	DbUpgradeUtils.dropPrimaryKeyIfExists(conn, "cloud_usage.usage_load_balancer_policy");	DbUpgradeUtils.dropPrimaryKeyIfExists(conn, "cloud_usage.usage_port_forwarding");	try {	PreparedStatement pstmt = conn.prepareStatement("drop index network_offering_id on cloud_usage.usage_network_offering");	pstmt.executeUpdate();	
dropped usage network offering unique key 

========================= cloudstack sample_4211 =========================

try {	disk = this._storageAdaptor.getPhysicalDisk(volumeUuid, this);	} catch (CloudRuntimeException e) {	if ((this.getStoragePoolType() != StoragePoolType.NetworkFilesystem) && (this.getStoragePoolType() != StoragePoolType.Filesystem)) {	throw e;	}	}	if (disk != null) {	return disk;	}	
find volume bypass libvirt 

if ((this.getStoragePoolType() != StoragePoolType.NetworkFilesystem) && (this.getStoragePoolType() != StoragePoolType.Filesystem)) {	throw e;	}	}	if (disk != null) {	return disk;	}	String localPoolPath = this.getLocalPath();	File f = new File(localPoolPath + File.separator + volumeUuid);	if (!f.exists()) {	
volume not exist on storage pool 

public boolean delete() {	try {	return this._storageAdaptor.deleteStoragePool(this);	} catch (Exception e) {	
failed to delete storage pool 

========================= cloudstack sample_1013 =========================

public void execute() {	
execute method invoked 

========================= cloudstack sample_2003 =========================

protected void checkIntegrity() {	for (SystemIntegrityChecker checker : getBeans(SystemIntegrityChecker.class)) {	
running system integrity checker 

public void startBeans() {	
starting cloudstack components 

public void startBeans() {	with(new WithComponentLifeCycle() {	public void with(ComponentLifecycle lifecycle) {	lifecycle.start();	if (lifecycle instanceof ManagementBean) {	ManagementBean mbean = (ManagementBean)lifecycle;	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	
unable to register mbean 

public void startBeans() {	with(new WithComponentLifeCycle() {	public void with(ComponentLifecycle lifecycle) {	lifecycle.start();	if (lifecycle instanceof ManagementBean) {	ManagementBean mbean = (ManagementBean)lifecycle;	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	
unable to register mbean 

with(new WithComponentLifeCycle() {	public void with(ComponentLifecycle lifecycle) {	lifecycle.start();	if (lifecycle instanceof ManagementBean) {	ManagementBean mbean = (ManagementBean)lifecycle;	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	} catch (MBeanRegistrationException e) {	
unable to register mbean 

public void with(ComponentLifecycle lifecycle) {	lifecycle.start();	if (lifecycle instanceof ManagementBean) {	ManagementBean mbean = (ManagementBean)lifecycle;	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	} catch (MBeanRegistrationException e) {	} catch (NotCompliantMBeanException e) {	
unable to register mbean 

lifecycle.start();	if (lifecycle instanceof ManagementBean) {	ManagementBean mbean = (ManagementBean)lifecycle;	try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	} catch (MBeanRegistrationException e) {	} catch (NotCompliantMBeanException e) {	}	
registered mbean 

try {	JmxUtil.registerMBean(mbean);	} catch (MalformedObjectNameException e) {	} catch (InstanceAlreadyExistsException e) {	} catch (MBeanRegistrationException e) {	} catch (NotCompliantMBeanException e) {	}	}	}	});	
done starting cloudstack components 

public void stopBeans() {	with(new WithComponentLifeCycle() {	public void with(ComponentLifecycle lifecycle) {	
stopping bean 

private void configure() {	
configuring cloudstack components 

private void configure() {	with(new WithComponentLifeCycle() {	public void with(ComponentLifecycle lifecycle) {	try {	lifecycle.configure(lifecycle.getName(), lifecycle.getConfigParams());	} catch (ConfigurationException e) {	
failed to configure 

private void configure() {	with(new WithComponentLifeCycle() {	public void with(ComponentLifecycle lifecycle) {	try {	lifecycle.configure(lifecycle.getName(), lifecycle.getConfigParams());	} catch (ConfigurationException e) {	throw new CloudRuntimeException(e);	}	}	});	
done configuring cloudstack components 

========================= cloudstack sample_748 =========================

public void notifySubscribers(String subject, Object sender, EventArgs args) {	List<SubscriberInfo> l = getExecutableSubscriberList(subject);	if (l != null) {	for (SubscriberInfo info : l) {	try {	info.execute(sender, args);	} catch (IllegalArgumentException e) {	
exception on notifying event subscribers 

public void notifySubscribers(String subject, Object sender, EventArgs args) {	List<SubscriberInfo> l = getExecutableSubscriberList(subject);	if (l != null) {	for (SubscriberInfo info : l) {	try {	info.execute(sender, args);	} catch (IllegalArgumentException e) {	} catch (IllegalAccessException e) {	
exception on notifying event subscribers 

public void notifySubscribers(String subject, Object sender, EventArgs args) {	List<SubscriberInfo> l = getExecutableSubscriberList(subject);	if (l != null) {	for (SubscriberInfo info : l) {	try {	info.execute(sender, args);	} catch (IllegalArgumentException e) {	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	
exception on notifying event subscribers 

========================= cloudstack sample_2844 =========================

public void execute() {	
getvolumeiscsinamecmd execute method invoked 

========================= cloudstack sample_2002 =========================

}	final VM migratedVm = vms.iterator().next();	if (migratedVm == null) {	throw new CloudRuntimeException("Couldn't find the migrated vm " + name + " on the destination host.");	}	final Host host = Host.getByUuid(connection, uuid);	migratedVm.setAffinity(connection, host);	final List<VolumeObjectTO> volumeToSet = xenServer610Resource.getUpdatedVolumePathsOfMigratedVm(connection, migratedVm, vmSpec.getDisks());	return new MigrateWithStorageCompleteAnswer(command, volumeToSet);	} catch (final CloudRuntimeException e) {	
migration of vm with storage failed due to 

if (migratedVm == null) {	throw new CloudRuntimeException("Couldn't find the migrated vm " + name + " on the destination host.");	}	final Host host = Host.getByUuid(connection, uuid);	migratedVm.setAffinity(connection, host);	final List<VolumeObjectTO> volumeToSet = xenServer610Resource.getUpdatedVolumePathsOfMigratedVm(connection, migratedVm, vmSpec.getDisks());	return new MigrateWithStorageCompleteAnswer(command, volumeToSet);	} catch (final CloudRuntimeException e) {	return new MigrateWithStorageCompleteAnswer(command, e);	} catch (final Exception e) {	
migration of vm with storage failed due to 

========================= cloudstack sample_1157 =========================

public String prepareSecondaryStorageStore(long zoneId) {	String secondaryStorageUri = getSecondaryStorageStoreUrl(zoneId);	if (secondaryStorageUri == null) {	
secondary storage uri for dc couldn t be obtained 

private String getSecondaryStorageStoreUrl(long zoneId) {	String secUrl = null;	DataStore secStore = _dataStoreMgr.getImageStore(zoneId);	if (secStore != null) {	secUrl = secStore.getUri();	}	if (secUrl == null) {	
secondary storage uri couldn t be retrieved 

if (!patchFolder.exists()) {	if (!patchFolder.mkdirs()) {	String msg = "Unable to create systemvm folder on secondary storage. location: " + patchFolder.toString();	s_logger.error(msg);	throw new CloudRuntimeException(msg);	}	}	File srcIso = getSystemVMPatchIsoFile();	File destIso = new File(mountPoint + "/systemvm/" + getSystemVMIsoFileNameOnDatastore());	if (!destIso.exists()) {	
copy system vm patch iso file to secondary storage source iso destination 

s_logger.error(msg);	throw new CloudRuntimeException(msg);	}	}	File srcIso = getSystemVMPatchIsoFile();	File destIso = new File(mountPoint + "/systemvm/" + getSystemVMIsoFileNameOnDatastore());	if (!destIso.exists()) {	try {	FileUtil.copyfile(srcIso, destIso);	} catch (IOException e) {	
unexpected exception 

if (!destIso.exists()) {	try {	FileUtil.copyfile(srcIso, destIso);	} catch (IOException e) {	String msg = "Unable to copy systemvm ISO on secondary storage. src location: " + srcIso.toString() + ", dest location: " + destIso;	s_logger.error(msg);	throw new CloudRuntimeException(msg);	}	} else {	if (s_logger.isTraceEnabled()) {	
systemvm iso file already exists 

String mountPoint = null;	synchronized (_storageMounts) {	mountPoint = _storageMounts.get(storageUrl);	if (mountPoint != null) {	return mountPoint;	}	URI uri;	try {	uri = new URI(storageUrl);	} catch (URISyntaxException e) {	
invalid storage url format 

return mountPoint;	}	URI uri;	try {	uri = new URI(storageUrl);	} catch (URISyntaxException e) {	throw new CloudRuntimeException("Unable to create mount point due to invalid storage URL format " + storageUrl);	}	mountPoint = mount(File.separator + File.separator + uri.getHost() + uri.getPath(), getMountParent(), uri.getScheme(), uri.getQuery());	if (mountPoint == null) {	
unable to create mount point for 

protected String mount(String path, String parent, String scheme, String query) {	String mountPoint = setupMountPoint(parent);	if (mountPoint == null) {	
unable to create a mount point 

if (user != null) {	command.add("-o", "uid=" + user + ",gid=" + user);	}	if (query != null) {	query = query.replace('&', ',');	command.add("-o", query);	}	result = command.execute();	}	if (result != null) {	
unable to mount due to 

File file = new File(mountPoint);	if (file.exists()) {	file.delete();	}	return null;	}	script = new Script(true, "chmod", _timeout, s_logger);	script.add("-R", "777", mountPoint);	result = script.execute();	if (result != null) {	
unable to set permissions for due to 

long mshostId = ManagementServerNode.getManagementServerId();	for (int i = 0; i < 10; i++) {	String mntPt = parent + File.separator + String.valueOf(mshostId) + "." + Integer.toHexString(_rand.nextInt(Integer.MAX_VALUE));	File file = new File(mntPt);	if (!file.exists()) {	if (_storage.mkdir(mntPt)) {	mountPoint = mntPt;	break;	}	}	
unable to create mount 

URL url = this.getClass().getClassLoader().getResource("vms/systemvm.iso");	File isoFile = null;	if (url != null) {	isoFile = new File(url.getPath());	}	if (isoFile == null || !isoFile.exists()) {	isoFile = new File("/usr/share/cloudstack-common/vms/systemvm.iso");	}	assert (isoFile != null);	if (!isoFile.exists()) {	
unable to locate systemvm iso in your setup at 

private void startupCleanup(String parent) {	
cleanup mounted mount points used in previous session 

private void startupCleanup(String parent) {	long mshostId = ManagementServerNode.getManagementServerId();	String[] mounts = _storage.listFiles(parent + File.separator + String.valueOf(mshostId) + ".*");	if (mounts != null && mounts.length > 0) {	for (String mountPoint : mounts) {	
umount nfs mount from previous session 

private void startupCleanup(String parent) {	long mshostId = ManagementServerNode.getManagementServerId();	String[] mounts = _storage.listFiles(parent + File.separator + String.valueOf(mshostId) + ".*");	if (mounts != null && mounts.length > 0) {	for (String mountPoint : mounts) {	String result = null;	Script command = new Script(true, "umount", _timeout, s_logger);	command.add(mountPoint);	result = command.execute();	if (result != null) {	
unable to umount due to 

private void shutdownCleanup() {	
cleanup mounted mount points used in current session 

private void shutdownCleanup() {	synchronized (_storageMounts) {	for (String mountPoint : _storageMounts.values()) {	
umount nfs mount 

private void shutdownCleanup() {	synchronized (_storageMounts) {	for (String mountPoint : _storageMounts.values()) {	String result = null;	Script command = new Script(true, "umount", _timeout, s_logger);	command.add(mountPoint);	result = command.execute();	if (result != null) {	
unable to umount due to 

========================= cloudstack sample_933 =========================

String arg = iter.next();	if (arg.equals("-h")) {	host = iter.next();	}	if (arg.equals("-p")) {	password = iter.next();	}	}	int i = 0;	if (host == null || host.equals("")) {	
did not receive a host back from test ignoring ssh test 

}	if (arg.equals("-p")) {	password = iter.next();	}	}	int i = 0;	if (host == null || host.equals("")) {	System.exit(2);	}	if (password == null) {	
did not receive a password back from test ignoring ssh test 

int i = 0;	if (host == null || host.equals("")) {	System.exit(2);	}	if (password == null) {	System.exit(2);	}	int retry = 0;	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt 

System.exit(2);	}	if (password == null) {	System.exit(2);	}	int retry = 0;	try {	if (retry > 0) {	Thread.sleep(120000);	}	
attempting to ssh into linux host with retry attempt 

if (password == null) {	System.exit(2);	}	int retry = 0;	try {	if (retry > 0) {	Thread.sleep(120000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
user sshed successfully into linux host 

}	int retry = 0;	try {	if (retry > 0) {	Thread.sleep(120000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	boolean isAuthenticated = conn.authenticateWithPassword("root", password);	if (isAuthenticated == false) {	
authentication failed for root with password 

String linuxCommand = null;	if (i % 10 == 0) linuxCommand = "rm -rf *; wget http: else linuxCommand = "wget http: Session sess = conn.openSession();	sess.execCommand(linuxCommand);	InputStream stdout = sess.getStdout();	InputStream stderr = sess.getStderr();	byte[] buffer = new byte[8192];	while (true) {	if ((stdout.available() == 0) && (stderr.available() == 0)) {	int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);	if ((conditions & ChannelCondition.TIMEOUT) != 0) {	
timeout while waiting for data from peer 

sess.close();	conn.close();	if (!success) {	retry++;	if (retry == MAX_RETRY_LINUX) {	System.exit(2);	}	}	} catch (Exception e) {	retry++;	
ssh linux network test fail with error 

conn.close();	if (!success) {	retry++;	if (retry == MAX_RETRY_LINUX) {	System.exit(2);	}	}	} catch (Exception e) {	retry++;	if (retry == MAX_RETRY_LINUX) {	
ssh test failed 

========================= cloudstack sample_460 =========================

protected boolean canHandle(NetworkOffering offering) {	if (offering.isSystemOnly() && isMyTrafficType(offering.getTrafficType())) {	return true;	} else {	
we only care about system only control network 

public boolean release(NicProfile nic, VirtualMachineProfile vm, String reservationId) {	assert nic.getTrafficType() == TrafficType.Control;	HypervisorType hType = vm.getHypervisorType();	if ( ( (hType == HypervisorType.VMware) || (hType == HypervisorType.Hyperv) )&& isRouterVm(vm)) {	long dcId = vm.getVirtualMachine().getDataCenterId();	DataCenterVO dcVo = _dcDao.findById(dcId);	if (dcVo.getNetworkType() != NetworkType.Basic) {	super.release(nic, vm, reservationId);	if (s_logger.isDebugEnabled()) {	
released nic 

long dcId = vm.getVirtualMachine().getDataCenterId();	DataCenterVO dcVo = _dcDao.findById(dcId);	if (dcVo.getNetworkType() != NetworkType.Basic) {	super.release(nic, vm, reservationId);	if (s_logger.isDebugEnabled()) {	}	return true;	} else {	nic.deallocate();	if (s_logger.isDebugEnabled()) {	
released nic 

} else {	nic.deallocate();	if (s_logger.isDebugEnabled()) {	}	return true;	}	}	_dcDao.releaseLinkLocalIpAddress(nic.getId(), reservationId);	nic.deallocate();	if (s_logger.isDebugEnabled()) {	
released nic 

========================= cloudstack sample_2281 =========================

public void MethodWithClassDbAnnotated() {	
called 

========================= cloudstack sample_525 =========================

public void execute() {	CallContext.current().setEventDetails("SystemVm Id: " + getId());	ServiceOffering serviceOffering = _entityMgr.findById(ServiceOffering.class, serviceOfferingId);	if (serviceOffering == null) {	throw new InvalidParameterValueException("Unable to find service offering: " + serviceOfferingId);	}	VirtualMachine result = null;	try {	result = _mgr.upgradeSystemVM(this);	} catch (ResourceUnavailableException ex) {	
exception 

ServiceOffering serviceOffering = _entityMgr.findById(ServiceOffering.class, serviceOfferingId);	if (serviceOffering == null) {	throw new InvalidParameterValueException("Unable to find service offering: " + serviceOfferingId);	}	VirtualMachine result = null;	try {	result = _mgr.upgradeSystemVM(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	
exception 

throw new InvalidParameterValueException("Unable to find service offering: " + serviceOfferingId);	}	VirtualMachine result = null;	try {	result = _mgr.upgradeSystemVM(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ManagementServerException ex) {	
exception 

VirtualMachine result = null;	try {	result = _mgr.upgradeSystemVM(this);	} catch (ResourceUnavailableException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_UNAVAILABLE_ERROR, ex.getMessage());	} catch (ConcurrentOperationException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (ManagementServerException ex) {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());	} catch (VirtualMachineMigrationException ex) {	
exception 

========================= cloudstack sample_3185 =========================

indexes.put("user_ip_address", keys);	keys = new ArrayList<String>();	keys.add("fk_cluster__data_center_id");	foreignKeys.put("cluster", keys);	keys = new ArrayList<String>();	keys.add("fk_domain_router__public_ip_address");	foreignKeys.put("domain_router", keys);	keys = new ArrayList<String>();	keys.add("fk_network_tags__network_id");	foreignKeys.put("network_tags", keys);	
dropping keys that don t exist in version of the db 

========================= cloudstack sample_4210 =========================

}	List<Long> childDomainIds = getDomainChildIds(domainId);	childDomainIds.add(domainId);	checkAccountAndDomain(accountId, domainId);	final DataCenterVO dc = _zoneDao.findById(zoneId);	if (dc == null) {	throw new InvalidParameterValueException("Unable to find zone by id " + zoneId);	} else {	DedicatedResourceVO dedicatedZone = _dedicatedDao.findByZoneId(zoneId);	if (dedicatedZone != null) {	
zone is already dedicated 

for (HostPodVO pod : pods) {	DedicatedResourceVO dPod = _dedicatedDao.findByPodId(pod.getId());	if (dPod != null) {	if (!(childDomainIds.contains(dPod.getDomainId()))) {	throw new CloudRuntimeException("Pod " + pod.getName() + " under this Zone " + dc.getName() + " is dedicated to different account/domain");	}	if (accountId != null) {	if (dPod.getAccountId().equals(accountId)) {	podsToRelease.add(dPod);	} else {	
pod under this zone is dedicated to different account domain 

for (ClusterVO cluster : clusters) {	DedicatedResourceVO dCluster = _dedicatedDao.findByClusterId(cluster.getId());	if (dCluster != null) {	if (!(childDomainIds.contains(dCluster.getDomainId()))) {	throw new CloudRuntimeException("Cluster " + cluster.getName() + " under this Zone " + dc.getName() + " is dedicated to different account/domain");	}	if (accountId != null) {	if (dCluster.getAccountId().equals(accountId)) {	clustersToRelease.add(dCluster);	} else {	
cluster under this zone is dedicated to different account domain 

for (HostVO host : hosts) {	DedicatedResourceVO dHost = _dedicatedDao.findByHostId(host.getId());	if (dHost != null) {	if (!(childDomainIds.contains(dHost.getDomainId()))) {	throw new CloudRuntimeException("Host " + host.getName() + " under this Zone " + dc.getName() + " is dedicated to different account/domain");	}	if (accountId != null) {	if (dHost.getAccountId().equals(accountId)) {	hostsToRelease.add(dHost);	} else {	
host under this zone is dedicated to different account domain 

for (DedicatedResourceVO dr : hostsToRelease) {	releaseDedicatedResource(null, null, null, dr.getHostId());	}	}	checkHostsSuitabilityForExplicitDedication(accountId, childDomainIds, hosts);	final Long accountIdFinal = accountId;	return Transaction.execute(new TransactionCallback<List<DedicatedResourceVO>>() {	public List<DedicatedResourceVO> doInTransaction(TransactionStatus status) {	AffinityGroup group = findOrCreateDedicatedAffinityGroup(domainId, accountIdFinal);	if (group == null) {	
unable to dedicate zone due to failed to create dedication affinity group 

dedicatedResource.setDomainId(domainId);	if (accountIdFinal != null) {	dedicatedResource.setAccountId(accountIdFinal);	}	dedicatedResource = _dedicatedDao.persist(dedicatedResource);	dc.setDomainId(domainId);	if (!_zoneDao.update(zoneId, dc)) {	throw new CloudRuntimeException("Failed to dedicate zone, could not set domainId. Please contact Cloud Support.");	}	} catch (Exception e) {	
unable to dedicate zone due to 

childDomainIds.add(domainId);	checkAccountAndDomain(accountId, domainId);	HostPodVO pod = _podDao.findById(podId);	List<HostVO> hosts = null;	if (pod == null) {	throw new InvalidParameterValueException("Unable to find pod by id " + podId);	} else {	DedicatedResourceVO dedicatedPod = _dedicatedDao.findByPodId(podId);	DedicatedResourceVO dedicatedZoneOfPod = _dedicatedDao.findByZoneId(pod.getDataCenterId());	if (dedicatedPod != null) {	
pod is already dedicated 

} else {	DedicatedResourceVO dedicatedPod = _dedicatedDao.findByPodId(podId);	DedicatedResourceVO dedicatedZoneOfPod = _dedicatedDao.findByZoneId(pod.getDataCenterId());	if (dedicatedPod != null) {	throw new CloudRuntimeException("Pod " + pod.getName() + " is already dedicated");	}	if (dedicatedZoneOfPod != null) {	boolean domainIdInChildreanList = getDomainChildIds(dedicatedZoneOfPod.getDomainId()).contains(domainId);	if (dedicatedZoneOfPod.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedZoneOfPod.getDomainId().equals(domainId) || domainIdInChildreanList))) {	DataCenterVO zone = _zoneDao.findById(pod.getDataCenterId());	
cannot dedicate pod its zone is already dedicated 

for (ClusterVO cluster : clusters) {	DedicatedResourceVO dCluster = _dedicatedDao.findByClusterId(cluster.getId());	if (dCluster != null) {	if (!(childDomainIds.contains(dCluster.getDomainId()))) {	throw new CloudRuntimeException("Cluster " + cluster.getName() + " under this Pod " + pod.getName() + " is dedicated to different account/domain");	}	and make new entry for this Pod*/ if (accountId != null) {	if (dCluster.getAccountId().equals(accountId)) {	clustersToRelease.add(dCluster);	} else {	
cluster under this pod is dedicated to different account domain 

for (HostVO host : hosts) {	DedicatedResourceVO dHost = _dedicatedDao.findByHostId(host.getId());	if (dHost != null) {	if (!(getDomainChildIds(domainId).contains(dHost.getDomainId()))) {	throw new CloudRuntimeException("Host " + host.getName() + " under this Pod " + pod.getName() + " is dedicated to different account/domain");	}	if (accountId != null) {	if (dHost.getAccountId().equals(accountId)) {	hostsToRelease.add(dHost);	} else {	
host under this pod is dedicated to different account domain 

for (DedicatedResourceVO dr : hostsToRelease) {	releaseDedicatedResource(null, null, null, dr.getHostId());	}	}	checkHostsSuitabilityForExplicitDedication(accountId, childDomainIds, hosts);	final Long accountIdFinal = accountId;	return Transaction.execute(new TransactionCallback<List<DedicatedResourceVO>>() {	public List<DedicatedResourceVO> doInTransaction(TransactionStatus status) {	AffinityGroup group = findOrCreateDedicatedAffinityGroup(domainId, accountIdFinal);	if (group == null) {	
unable to dedicate zone due to failed to create dedication affinity group 

throw new CloudRuntimeException("Failed to dedicate zone. Please contact Cloud Support.");	}	DedicatedResourceVO dedicatedResource = new DedicatedResourceVO(null, podId, null, null, null, null, group.getId());	try {	dedicatedResource.setDomainId(domainId);	if (accountIdFinal != null) {	dedicatedResource.setAccountId(accountIdFinal);	}	dedicatedResource = _dedicatedDao.persist(dedicatedResource);	} catch (Exception e) {	
unable to dedicate pod due to 

childDomainIds.add(domainId);	checkAccountAndDomain(accountId, domainId);	ClusterVO cluster = _clusterDao.findById(clusterId);	if (cluster == null) {	throw new InvalidParameterValueException("Unable to find cluster by id " + clusterId);	} else {	DedicatedResourceVO dedicatedCluster = _dedicatedDao.findByClusterId(clusterId);	DedicatedResourceVO dedicatedPodOfCluster = _dedicatedDao.findByPodId(cluster.getPodId());	DedicatedResourceVO dedicatedZoneOfCluster = _dedicatedDao.findByZoneId(cluster.getDataCenterId());	if (dedicatedCluster != null) {	
cluster is already dedicated 

} else {	DedicatedResourceVO dedicatedCluster = _dedicatedDao.findByClusterId(clusterId);	DedicatedResourceVO dedicatedPodOfCluster = _dedicatedDao.findByPodId(cluster.getPodId());	DedicatedResourceVO dedicatedZoneOfCluster = _dedicatedDao.findByZoneId(cluster.getDataCenterId());	if (dedicatedCluster != null) {	throw new CloudRuntimeException("Cluster " + cluster.getName() + " is already dedicated");	}	if (dedicatedPodOfCluster != null) {	boolean domainIdInChildreanList = getDomainChildIds(dedicatedPodOfCluster.getDomainId()).contains(domainId);	if (dedicatedPodOfCluster.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedPodOfCluster.getDomainId().equals(domainId) || domainIdInChildreanList))) {	
cannot dedicate cluster its pod is already dedicated 

if (dedicatedPodOfCluster != null) {	boolean domainIdInChildreanList = getDomainChildIds(dedicatedPodOfCluster.getDomainId()).contains(domainId);	if (dedicatedPodOfCluster.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedPodOfCluster.getDomainId().equals(domainId) || domainIdInChildreanList))) {	HostPodVO pod = _podDao.findById(cluster.getPodId());	throw new CloudRuntimeException("Cluster's Pod " + pod.getName() + " is already dedicated");	}	}	if (dedicatedZoneOfCluster != null) {	boolean domainIdInChildreanList = getDomainChildIds(dedicatedZoneOfCluster.getDomainId()).contains(domainId);	if (dedicatedZoneOfCluster.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedZoneOfCluster.getDomainId().equals(domainId) || domainIdInChildreanList))) {	
cannot dedicate cluster its zone is already dedicated 

for (HostVO host : hosts) {	DedicatedResourceVO dHost = _dedicatedDao.findByHostId(host.getId());	if (dHost != null) {	if (!(childDomainIds.contains(dHost.getDomainId()))) {	throw new CloudRuntimeException("Host " + host.getName() + " under this Cluster " + cluster.getName() + " is dedicated to different account/domain");	}	and make new entry for this cluster */ if (accountId != null) {	if (dHost.getAccountId().equals(accountId)) {	hostsToRelease.add(dHost);	} else {	
cannot dedicate cluster to account 

for (DedicatedResourceVO dr : hostsToRelease) {	releaseDedicatedResource(null, null, null, dr.getHostId());	}	}	checkHostsSuitabilityForExplicitDedication(accountId, childDomainIds, hosts);	final Long accountIdFinal = accountId;	return Transaction.execute(new TransactionCallback<List<DedicatedResourceVO>>() {	public List<DedicatedResourceVO> doInTransaction(TransactionStatus status) {	AffinityGroup group = findOrCreateDedicatedAffinityGroup(domainId, accountIdFinal);	if (group == null) {	
unable to dedicate zone due to failed to create dedication affinity group 

throw new CloudRuntimeException("Failed to dedicate zone. Please contact Cloud Support.");	}	DedicatedResourceVO dedicatedResource = new DedicatedResourceVO(null, null, clusterId, null, null, null, group.getId());	try {	dedicatedResource.setDomainId(domainId);	if (accountIdFinal != null) {	dedicatedResource.setAccountId(accountIdFinal);	}	dedicatedResource = _dedicatedDao.persist(dedicatedResource);	} catch (Exception e) {	
unable to dedicate host due to 

throw new InvalidParameterValueException("Unable to find host by id " + hostId);	} else {	if (host.getType() != Host.Type.Routing) {	throw new CloudRuntimeException("Invalid host type for host " + host.getName());	}	DedicatedResourceVO dedicatedHost = _dedicatedDao.findByHostId(hostId);	DedicatedResourceVO dedicatedClusterOfHost = _dedicatedDao.findByClusterId(host.getClusterId());	DedicatedResourceVO dedicatedPodOfHost = _dedicatedDao.findByPodId(host.getPodId());	DedicatedResourceVO dedicatedZoneOfHost = _dedicatedDao.findByZoneId(host.getDataCenterId());	if (dedicatedHost != null) {	
host is already dedicated 

DedicatedResourceVO dedicatedClusterOfHost = _dedicatedDao.findByClusterId(host.getClusterId());	DedicatedResourceVO dedicatedPodOfHost = _dedicatedDao.findByPodId(host.getPodId());	DedicatedResourceVO dedicatedZoneOfHost = _dedicatedDao.findByZoneId(host.getDataCenterId());	if (dedicatedHost != null) {	throw new CloudRuntimeException("Host " + host.getName() + " is already dedicated");	}	if (dedicatedClusterOfHost != null) {	boolean domainIdInChildreanList = getDomainChildIds(dedicatedClusterOfHost.getDomainId()).contains(domainId);	if (dedicatedClusterOfHost.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedClusterOfHost.getDomainId().equals(domainId) || domainIdInChildreanList))) {	ClusterVO cluster = _clusterDao.findById(host.getClusterId());	
host s cluster is already dedicated 

boolean domainIdInChildreanList = getDomainChildIds(dedicatedClusterOfHost.getDomainId()).contains(domainId);	if (dedicatedClusterOfHost.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedClusterOfHost.getDomainId().equals(domainId) || domainIdInChildreanList))) {	ClusterVO cluster = _clusterDao.findById(host.getClusterId());	throw new CloudRuntimeException("Host's Cluster " + cluster.getName() + " is already dedicated");	}	}	if (dedicatedPodOfHost != null) {	boolean domainIdInChildreanList = getDomainChildIds(dedicatedPodOfHost.getDomainId()).contains(domainId);	if (dedicatedPodOfHost.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedPodOfHost.getDomainId().equals(domainId) || domainIdInChildreanList))) {	HostPodVO pod = _podDao.findById(host.getPodId());	
host s pod is already dedicated 

boolean domainIdInChildreanList = getDomainChildIds(dedicatedPodOfHost.getDomainId()).contains(domainId);	if (dedicatedPodOfHost.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedPodOfHost.getDomainId().equals(domainId) || domainIdInChildreanList))) {	HostPodVO pod = _podDao.findById(host.getPodId());	throw new CloudRuntimeException("Host's Pod " + pod.getName() + " is already dedicated");	}	}	if (dedicatedZoneOfHost != null) {	boolean domainIdInChildreanList = getDomainChildIds(dedicatedZoneOfHost.getDomainId()).contains(domainId);	if (dedicatedZoneOfHost.getAccountId() != null || (accountId == null && !domainIdInChildreanList) || (accountId != null && !(dedicatedZoneOfHost.getDomainId().equals(domainId) || domainIdInChildreanList))) {	DataCenterVO zone = _zoneDao.findById(host.getDataCenterId());	
host s data center is already dedicated 

}	}	List<Long> childDomainIds = getDomainChildIds(domainId);	childDomainIds.add(domainId);	checkHostSuitabilityForExplicitDedication(accountId, childDomainIds, hostId);	final Long accountIdFinal = accountId;	return Transaction.execute(new TransactionCallback<List<DedicatedResourceVO>>() {	public List<DedicatedResourceVO> doInTransaction(TransactionStatus status) {	AffinityGroup group = findOrCreateDedicatedAffinityGroup(domainId, accountIdFinal);	if (group == null) {	
unable to dedicate zone due to failed to create dedication affinity group 

throw new CloudRuntimeException("Failed to dedicate zone. Please contact Cloud Support.");	}	DedicatedResourceVO dedicatedResource = new DedicatedResourceVO(null, null, null, hostId, null, null, group.getId());	try {	dedicatedResource.setDomainId(domainId);	if (accountIdFinal != null) {	dedicatedResource.setAccountId(accountIdFinal);	}	dedicatedResource = _dedicatedDao.persist(dedicatedResource);	} catch (Exception e) {	
unable to dedicate host due to 

private boolean checkHostSuitabilityForExplicitDedication(Long accountId, List<Long> domainIds, long hostId) {	boolean suitable = true;	List<UserVmVO> allVmsOnHost = getVmsOnHost(hostId);	if (accountId != null) {	for (UserVmVO vm : allVmsOnHost) {	if (vm.getAccountId() != accountId) {	
host found to be unsuitable for explicit dedication as it is running instances of another account 

List<UserVmVO> allVmsOnHost = getVmsOnHost(hostId);	if (accountId != null) {	for (UserVmVO vm : allVmsOnHost) {	if (vm.getAccountId() != accountId) {	throw new CloudRuntimeException("Host " + hostId + " found to be unsuitable for explicit dedication as it is " + "running instances of another account");	}	}	} else {	for (UserVmVO vm : allVmsOnHost) {	if (!domainIds.contains(vm.getDomainId())) {	
host found to be unsuitable for explicit dedication as it is running instances of another domain 

========================= cloudstack sample_2055 =========================

public List<Host> allocateTo(VirtualMachineProfile vm, DeploymentPlan plan, Type type, ExcludeList avoid, int returnUpTo) {	List<Host> hosts = super.allocateTo(vm, plan, type, avoid, returnUpTo);	if (hosts != null && !hosts.isEmpty()) {	return hosts;	}	
first fit was unable to find a host 

public List<Host> allocateTo(VirtualMachineProfile vm, DeploymentPlan plan, Type type, ExcludeList avoid, int returnUpTo) {	List<Host> hosts = super.allocateTo(vm, plan, type, avoid, returnUpTo);	if (hosts != null && !hosts.isEmpty()) {	return hosts;	}	VirtualMachine.Type vmType = vm.getType();	if (vmType == VirtualMachine.Type.User) {	
vm is not a system vm so let s just return empty list 

if (hosts != null && !hosts.isEmpty()) {	return hosts;	}	VirtualMachine.Type vmType = vm.getType();	if (vmType == VirtualMachine.Type.User) {	return new ArrayList<Host>();	}	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	List<PodCluster> pcs = _resourceMgr.listByDataCenter(dc.getId());	if (dc.getNetworkType().equals(NetworkType.Basic)) {	
direct networking mode so we can only allow the host to be allocated in the same pod due to public ip address cannot change 

VirtualMachine.Type vmType = vm.getType();	if (vmType == VirtualMachine.Type.User) {	return new ArrayList<Host>();	}	DataCenter dc = _dcDao.findById(plan.getDataCenterId());	List<PodCluster> pcs = _resourceMgr.listByDataCenter(dc.getId());	if (dc.getNetworkType().equals(NetworkType.Basic)) {	List<VolumeVO> vols = _volsDao.findByInstance(vm.getId());	VolumeVO vol = vols.get(0);	long podId = vol.getPodId();	
pod id determined from volume is 

Set<Long> hostIdsToAvoid = avoid.getHostsToAvoid();	if (hostIdsToAvoid != null) {	for (Long hostId : hostIdsToAvoid) {	Host h = _hostDao.findById(hostId);	if (h != null) {	avoidPcs.add(new Pair<Long, Long>(h.getPodId(), h.getClusterId()));	}	}	}	for (Pair<Long, Long> pcId : avoidPcs) {	
removing from the list of available pods 

avoidPcs.add(new Pair<Long, Long>(h.getPodId(), h.getClusterId()));	}	}	}	for (Pair<Long, Long> pcId : avoidPcs) {	pcs.remove(new PodCluster(new HostPodVO(pcId.first()), pcId.second() != null ? new ClusterVO(pcId.second()) : null));	}	for (PodCluster p : pcs) {	if (p.getPod().getAllocationState() != Grouping.AllocationState.Enabled) {	if (s_logger.isDebugEnabled()) {	
pod name podid is in state skipping this and trying other pods 

}	for (PodCluster p : pcs) {	if (p.getPod().getAllocationState() != Grouping.AllocationState.Enabled) {	if (s_logger.isDebugEnabled()) {	}	continue;	}	Long clusterId = p.getCluster() == null ? null : p.getCluster().getId();	if (p.getCluster() != null && p.getCluster().getAllocationState() != Grouping.AllocationState.Enabled) {	if (s_logger.isDebugEnabled()) {	
cluster name clusterid is in state skipping this and trying other pod clusters 

if (s_logger.isDebugEnabled()) {	}	continue;	}	DataCenterDeployment newPlan = new DataCenterDeployment(plan.getDataCenterId(), p.getPod().getId(), clusterId, null, null, null);	hosts = super.allocateTo(vm, newPlan, type, avoid, returnUpTo);	if (hosts != null && !hosts.isEmpty()) {	return hosts;	}	}	
unable to find any available pods at all 

========================= cloudstack sample_2405 =========================

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	
retrieving user 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	
username or password cannot be empty 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	boolean realUser = true;	UserAccount user = _userAccountDao.getUserAccount(username, domainId);	if (user == null) {	
unable to find user with in domain 

boolean realUser = true;	UserAccount user = _userAccountDao.getUserAccount(username, domainId);	if (user == null) {	realUser = false;	}	String realPassword = new String(s_defaultPassword);	byte[] salt = new String(s_defaultSalt).getBytes();	if (realUser) {	String storedPassword[] = user.getPassword().split(":");	if (storedPassword.length != 2) {	
the stored password for isn t in the right format for this authenticator 

========================= cloudstack sample_1383 =========================

vdiSnapshot.destroy(conn);	if (sourceSr != null) {	hypervisorResource.removeSR(conn, sourceSr);	}	hypervisorResource.removeSR(conn, newSr);	final SnapshotAndCopyAnswer snapshotAndCopyAnswer = new SnapshotAndCopyAnswer();	snapshotAndCopyAnswer.setPath(vdiUuid);	return snapshotAndCopyAnswer;	}	catch (final Exception ex) {	
failed to take and copy snapshot 

throw new RuntimeException("There were " + vdis.size() + " VDIs in the SR.");	}	VDI vdi = vdis.iterator().next();	final ResignatureAnswer resignatureAnswer = new ResignatureAnswer();	resignatureAnswer.setSize(vdi.getVirtualSize(conn));	resignatureAnswer.setPath(vdi.getUuid(conn));	resignatureAnswer.setFormat(ImageFormat.VHD);	return resignatureAnswer;	}	catch (final Exception ex) {	
failed to resignature 

public AttachAnswer attachIso(final AttachCommand cmd) {	final DiskTO disk = cmd.getDisk();	final DataTO data = disk.getData();	final DataStoreTO store = data.getDataStore();	String isoURL = null;	if (store == null) {	final TemplateObjectTO iso = (TemplateObjectTO) disk.getData();	isoURL = iso.getName();	} else {	if (!(store instanceof NfsTO)) {	
can t attach a iso which is not created on nfs 

if (isoVBD == null) {	throw new CloudRuntimeException("Unable to find CD-ROM VBD for VM: " + vmName);	} else {	if (!isoVBD.getEmpty(conn)) {	isoVBD.eject(conn);	}	isoVBD.insert(conn, isoVDI);	}	return new AttachAnswer(disk);	} catch (final XenAPIException e) {	
failed to attach iso 

} else {	if (!isoVBD.getEmpty(conn)) {	isoVBD.eject(conn);	}	isoVBD.insert(conn, isoVDI);	}	return new AttachAnswer(disk);	} catch (final XenAPIException e) {	return new AttachAnswer(e.toString());	} catch (final Exception e) {	
failed to attach iso 

public Answer dettachIso(final DettachCommand cmd) {	final DiskTO disk = cmd.getDisk();	final DataTO data = disk.getData();	final DataStoreTO store = data.getDataStore();	String isoURL = null;	if (store == null) {	final TemplateObjectTO iso = (TemplateObjectTO) disk.getData();	isoURL = iso.getName();	} else {	if (!(store instanceof NfsTO)) {	
can t attach a iso which is not created on nfs 

}	vbd.destroy(conn);	}	hypervisorResource.umount(conn, vdi);	}	if (cmd.isManaged()) {	hypervisorResource.handleSrAndVdiDetach(cmd.get_iScsiName(), conn);	}	return new DettachAnswer(disk);	} catch (final Exception e) {	
failed dettach volume 

final String type = sr.getType(conn);	final Boolean isISCSI = IsISCSI(type);	final String snapshotParentUUID = getVhdParent(conn, srUUID, snapshotUUID, isISCSI);	try {	final String preSnapshotParentUUID = getVhdParent(conn, srUUID, preSnapshotUUID, isISCSI);	if (snapshotParentUUID != null && snapshotParentUUID.equals(preSnapshotParentUUID)) {	snapshot.destroy(conn);	snapshotUUID = preSnapshotUUID;	}	} catch (final Exception e) {	
failed to get parent snapshot 

final Connection conn = hypervisorResource.getConnection();	String errorMsg = null;	try {	final VDI vdi = VDI.getByUuid(conn, volume.getPath());	for(VDI svdi : vdi.getSnapshots(conn)) {	deleteVDI(conn, svdi);	}	deleteVDI(conn, vdi);	return new Answer(null);	} catch (final BadServerResponse e) {	
failed to delete volume 

try {	final VDI vdi = VDI.getByUuid(conn, volume.getPath());	for(VDI svdi : vdi.getSnapshots(conn)) {	deleteVDI(conn, svdi);	}	deleteVDI(conn, vdi);	return new Answer(null);	} catch (final BadServerResponse e) {	errorMsg = e.toString();	} catch (final XenAPIException e) {	
failed to delete volume 

for(VDI svdi : vdi.getSnapshots(conn)) {	deleteVDI(conn, svdi);	}	deleteVDI(conn, vdi);	return new Answer(null);	} catch (final BadServerResponse e) {	errorMsg = e.toString();	} catch (final XenAPIException e) {	errorMsg = e.toString();	} catch (final XmlRpcException e) {	
failed to delete volume 

final Map<String, String> deviceCfg = pbd.getDeviceConfig(conn);	pbdLocation = deviceCfg.get("location");	}	if (pbdLocation == null) {	throw new CloudRuntimeException("Can't get pbd location");	}	final String vdiPath = pbdLocation + "/" + vdiLocation + ".vhd";	hypervisorResource.callHostPlugin(conn, "storagePlugin", "downloadTemplateFromUrl", "destPath", vdiPath, "srcUrl", srcObj.getPath());	result = true;	} catch (final BadServerResponse e) {	
failed to download template 

pbdLocation = deviceCfg.get("location");	}	if (pbdLocation == null) {	throw new CloudRuntimeException("Can't get pbd location");	}	final String vdiPath = pbdLocation + "/" + vdiLocation + ".vhd";	hypervisorResource.callHostPlugin(conn, "storagePlugin", "downloadTemplateFromUrl", "destPath", vdiPath, "srcUrl", srcObj.getPath());	result = true;	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	
failed to download template 

}	if (pbdLocation == null) {	throw new CloudRuntimeException("Can't get pbd location");	}	final String vdiPath = pbdLocation + "/" + vdiLocation + ".vhd";	hypervisorResource.callHostPlugin(conn, "storagePlugin", "downloadTemplateFromUrl", "destPath", vdiPath, "srcUrl", srcObj.getPath());	result = true;	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
failed to download template 

if (pbdLocation == null) {	throw new CloudRuntimeException("Can't get pbd location");	}	final String vdiPath = pbdLocation + "/" + vdiLocation + ".vhd";	hypervisorResource.callHostPlugin(conn, "storagePlugin", "downloadTemplateFromUrl", "destPath", vdiPath, "srcUrl", srcObj.getPath());	result = true;	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	} catch (final Exception e) {	
failed to download template 

result = true;	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	} catch (final Exception e) {	} finally {	if (!result && vdi != null) {	try {	vdi.destroy(conn);	} catch (final BadServerResponse e) {	
failed to cleanup newly created vdi 

} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	} catch (final Exception e) {	} finally {	if (!result && vdi != null) {	try {	vdi.destroy(conn);	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	
failed to cleanup newly created vdi 

} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	} catch (final Exception e) {	} finally {	if (!result && vdi != null) {	try {	vdi.destroy(conn);	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
failed to cleanup newly created vdi 

private void destroyVDIbyNameLabel(final Connection conn, final String nameLabel) {	try {	final Set<VDI> vdis = VDI.getByNameLabel(conn, nameLabel);	if (vdis.size() != 1) {	
destoryvdibynamelabel failed due to there are vdis with name 

protected String getVhdParent(final Connection conn, final String primaryStorageSRUuid, final String snapshotUuid, final Boolean isISCSI) {	final String parentUuid = hypervisorResource.callHostPlugin(conn, "vmopsSnapshot", "getVhdParent", "primaryStorageSRUuid", primaryStorageSRUuid, "snapshotUuid", snapshotUuid, "isISCSI", isISCSI.toString());	if (parentUuid == null || parentUuid.isEmpty() || parentUuid.equalsIgnoreCase("None")) {	
unable to get parent of vhd in sr 

vdir.virtualSize = volume.getSize();	VDI vdi;	vdi = VDI.create(conn, vdir);	vdir = vdi.getRecord(conn);	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setName(vdir.nameLabel);	newVol.setSize(vdir.virtualSize);	newVol.setPath(vdir.uuid);	return new CreateObjectAnswer(newVol);	} catch (final Exception e) {	
create volume failed 

final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(uuid);	newVol.setSize(srcVolume.getSize());	return new CopyCmdAnswer(newVol);	} catch (final Exception e) {	final String msg = "Catch Exception " + e.getClass().getName() + " due to " + e.toString();	s_logger.warn(msg, e);	return new CopyCmdAnswer(e.toString());	}	}	
unsupported protocol 

}	secondaryStorage = hypervisorResource.createNfsSRbyURI(conn, new URI(nfsStore.getUrl() + nfsStore.getPathSeparator() + destVolume.getPath()), false);	final VDI srcVdi = getVDIbyUuid(conn, srcVolume.getPath());	final VDI destVdi = hypervisorResource.cloudVDIcopy(conn, srcVdi, secondaryStorage, wait);	final String destVolumeUUID = destVdi.getUuid(conn);	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setPath(destVolume.getPath() + nfsStore.getPathSeparator() + destVolumeUUID + ".vhd");	newVol.setSize(srcVolume.getSize());	return new CopyCmdAnswer(newVol);	} catch (final Exception e) {	
failed to copy volume to secondary 

final String dir = (iSCSIFlag ? "/dev/VG_XenStorage-" : "/var/run/sr-mount/") + srUuid;	final String key = folder + " try {	final List<String> parameters = newArrayList(flattenProperties(s3, ClientOptions.class));	parameters.addAll(Arrays.asList("operation", "put", "filename", dir + "/" + filename, "iSCSIFlag", iSCSIFlag.toString(), "bucket", s3.getBucketName(), "key", key, "https", s3.isHttps() != null ? s3.isHttps().toString() : "null", "maxSingleUploadSizeInBytes", String.valueOf(s3.getMaxSingleUploadSizeInBytes())));	final String result = hypervisorResource.callHostPluginAsync(connection, "s3xenserver", "s3", wait, parameters.toArray(new String[parameters.size()]));	if (result != null && result.equals("true")) {	return key;	}	return null;	} catch (final Exception e) {	
upload failed of snapshot s due to s 

final String backupUuid = UUID.randomUUID().toString();	final String results = hypervisorResource.callHostPluginAsync(conn, "vmopsSnapshot", "backupSnapshot", wait, "primaryStorageSRUuid", primaryStorageSRUuid, "path", path, "secondaryStorageMountPath", secondaryStorageMountPath, "snapshotUuid", snapshotUuid, "prevBackupUuid", prevBackupUuid, "backupUuid", backupUuid, "isISCSI", isISCSI.toString(), "localMountPoint", localMountPoint);	String errMsg = null;	if (results == null || results.isEmpty()) {	errMsg = "Could not copy backupUuid: " + backupSnapshotUuid + " from primary storage " + primaryStorageSRUuid + " to secondary storage " + secondaryStorageMountPath + " due to null";	} else {	final String[] tmp = results.split("#");	final String status = tmp[0];	backupSnapshotUuid = tmp[1];	if (status != null && status.equalsIgnoreCase("1") && backupSnapshotUuid != null) {	
successfully copied backupuuid to secondary storage 

for (final VDI snapshot : snapshots) {	try {	if (!snapshot.getUuid(conn).equals(avoidSnapshotUuid) && snapshot.getSnapshotTime(conn).before(avoidSnapshot.getSnapshotTime(conn)) && snapshot.getVBDs(conn).isEmpty()) {	snapshot.destroy(conn);	}	} catch (final Exception e) {	final String msg = "Destroying snapshot: " + snapshot + " on primary storage failed due to " + e.toString();	s_logger.warn(msg, e);	}	}	
successfully destroyed snapshot on volume execept this current snapshot 

private boolean destroySnapshotOnPrimaryStorage(final Connection conn, final String lastSnapshotUuid) {	try {	final VDI snapshot = getVDIbyUuid(conn, lastSnapshotUuid);	if (snapshot == null) {	
could not destroy snapshot due to can not find it 

if (snapshotPaUuid != null) {	final String snashotPaPaPaUuid = getVhdParent(conn, psUuid, snapshotPaUuid, isISCSI);	final String prevSnashotPaUuid = getVhdParent(conn, psUuid, prevSnapshotUuid, isISCSI);	if (snashotPaPaPaUuid != null && prevSnashotPaUuid != null && prevSnashotPaUuid.equals(snashotPaPaPaUuid)) {	fullbackup = false;	} else {	fullbackup = true;	}	}	} catch (final Exception e) {	
failed to get parent snapshots take full snapshot 

if (destStore instanceof SwiftTO) {	try {	final String container = "S-" + snapshotTO.getVolume().getVolumeId().toString();	final String destSnapshotName = swiftBackupSnapshot(conn, (SwiftTO) destStore, snapshotSr.getUuid(conn), snapshotBackupUuid, container, false, wait);	final String swiftPath = container + File.separator + destSnapshotName;	finalPath = swiftPath;	} finally {	try {	deleteSnapshotBackup(conn, localMountPoint, folder, secondaryStorageMountPath, snapshotBackupUuid);	} catch (final Exception e) {	
failed to delete snapshot on cache storages 

} else if (destStore instanceof S3TO) {	try {	finalPath = backupSnapshotToS3(conn, (S3TO) destStore, snapshotSr.getUuid(conn), folder, snapshotBackupUuid, isISCSI, wait);	if (finalPath == null) {	throw new CloudRuntimeException("S3 upload of snapshots " + snapshotBackupUuid + " failed");	}	} finally {	try {	deleteSnapshotBackup(conn, localMountPoint, folder, secondaryStorageMountPath, snapshotBackupUuid);	} catch (final Exception e) {	
failed to delete snapshot on cache storages 

details = "BackupSnapshot Failed due to " + e.toString();	s_logger.warn(details, e);	} catch (final Exception e) {	details = "BackupSnapshot Failed due to " + e.getMessage();	s_logger.warn(details, e);	} finally {	if (!result) {	try {	destroySnapshotOnPrimaryStorage(conn, snapshotUuid);	} catch (final Exception e) {	
clean up snapshot failed 

if (!(snapshotObjTO.getDataStore() instanceof PrimaryDataStoreTO) || !(templateObjTO.getDataStore() instanceof NfsTO)) {	return null;	}	final String userSpecifiedTemplateName = templateObjTO.getName();	NfsTO destStore = null;	URI destUri = null;	try {	destStore = (NfsTO)templateObjTO.getDataStore();	destUri = new URI(destStore.getUrl());	} catch (final Exception ex) {	
invalid uri 

final TemplateObjectTO newTemplate = new TemplateObjectTO();	newTemplate.setPath(destDir + "/" + templateFilename);	newTemplate.setFormat(Storage.ImageFormat.VHD);	newTemplate.setHypervisorType(HypervisorType.XenServer);	newTemplate.setSize(virtualSize);	newTemplate.setPhysicalSize(physicalSize);	newTemplate.setName(templateUuid);	result = true;	return new CopyCmdAnswer(newTemplate);	} catch (final Exception ex) {	
failed to create a template from a snapshot 

result = true;	return new CopyCmdAnswer(newTemplate);	} catch (final Exception ex) {	return new CopyCmdAnswer("Failed to create a template from a snapshot: " + ex.toString());	} finally {	if (!result) {	if (destVdi != null) {	try {	destVdi.destroy(conn);	} catch (final Exception e) {	
cleaned up leftover vdi on destination storage due to failure 

final VDI vdiCopy = srcVdi.copy(conn, destSr);	final VolumeObjectTO newVol = new VolumeObjectTO();	newVol.setSize(vdiCopy.getVirtualSize(conn));	newVol.setPath(vdiCopy.getUuid(conn));	newVol.setFormat(ImageFormat.VHD);	hypervisorResource.removeSR(conn, srcSr);	hypervisorResource.removeSR(conn, destSr);	return new CopyCmdAnswer(newVol);	}	catch (final Exception ex) {	
failed to copy snapshot to volume 

if (store.getRole() == DataStoreRole.Primary) {	final Connection conn = hypervisorResource.getConnection();	final VDI snapshotVdi = getVDIbyUuid(conn, snapshot.getPath());	if (snapshotVdi == null) {	return new Answer(null);	}	String errMsg = null;	try {	deleteVDI(conn, snapshotVdi);	} catch (final BadServerResponse e) {	
delete snapshot failed 

final VDI snapshotVdi = getVDIbyUuid(conn, snapshot.getPath());	if (snapshotVdi == null) {	return new Answer(null);	}	String errMsg = null;	try {	deleteVDI(conn, snapshotVdi);	} catch (final BadServerResponse e) {	errMsg = e.toString();	} catch (final XenAPIException e) {	
delete snapshot failed 

return new Answer(null);	}	String errMsg = null;	try {	deleteVDI(conn, snapshotVdi);	} catch (final BadServerResponse e) {	errMsg = e.toString();	} catch (final XenAPIException e) {	errMsg = e.toString();	} catch (final XmlRpcException e) {	
delete snapshot failed 

public Answer introduceObject(final IntroduceObjectCmd cmd) {	try {	final Connection conn = hypervisorResource.getConnection();	final DataStoreTO store = cmd.getDataTO().getDataStore();	final SR poolSr = hypervisorResource.getStorageRepository(conn, store.getUuid());	poolSr.scan(conn);	return new IntroduceObjectAnswer(cmd.getDataTO());	} catch (final Exception e) {	
failed to introduce object 

public Answer forgetObject(final ForgetObjectCmd cmd) {	try {	final Connection conn = hypervisorResource.getConnection();	final DataTO data = cmd.getDataTO();	final VDI vdi = VDI.getByUuid(conn, data.getPath());	vdi.forget(conn);	return new IntroduceObjectAnswer(cmd.getDataTO());	} catch (final Exception e) {	
failed to introduce object 

========================= cloudstack sample_1229 =========================

}	if (arg.equals("-e")) {	templateId = Integer.parseInt(iter.next());	}	if (arg.equals("-s")) {	serviceOfferingId = Integer.parseInt(iter.next());	}	}	final String server = host + ":" + ApiPort + "/";	final String developerServer = host + ":" + DeveloperPort + ApiUrl;	
starting test in thread s each thread is launching vms 

try {	String username = null;	String singlePrivateIp = null;	Random ran = new Random();	username = Math.abs(ran.nextInt()) + "-user";	User myUser = new User(username, username, server, developerServer);	try {	myUser.launchUser();	myUser.registerUser();	} catch (Exception e) {	
error code 

String singlePrivateIp = null;	Random ran = new Random();	username = Math.abs(ran.nextInt()) + "-user";	User myUser = new User(username, username, server, developerServer);	try {	myUser.launchUser();	myUser.registerUser();	} catch (Exception e) {	}	if (myUser.getUserId() != null) {	
user was created successfully starting vm creation 

myUser.registerUser();	} catch (Exception e) {	}	if (myUser.getUserId() != null) {	for (int i = 0; i < numVM; i++) {	VirtualMachine myVM = new VirtualMachine(myUser.getUserId());	myVM.deployVM(zoneId, serviceOfferingId, templateId, myUser.getDeveloperServer(), myUser.getApiKey(), myUser.getSecretKey());	myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	
vm with private ip was successfully created 

} catch (Exception e) {	}	if (myUser.getUserId() != null) {	for (int i = 0; i < numVM; i++) {	VirtualMachine myVM = new VirtualMachine(myUser.getUserId());	myVM.deployVM(zoneId, serviceOfferingId, templateId, myUser.getDeveloperServer(), myUser.getApiKey(), myUser.getSecretKey());	myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	} else {	
problems with vm creation for a user 

} catch (Exception e) {	}	if (myUser.getUserId() != null) {	for (int i = 0; i < numVM; i++) {	VirtualMachine myVM = new VirtualMachine(myUser.getUserId());	myVM.deployVM(zoneId, serviceOfferingId, templateId, myUser.getDeveloperServer(), myUser.getApiKey(), myUser.getSecretKey());	myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	} else {	
deployment failed 

for (int i = 0; i < numVM; i++) {	VirtualMachine myVM = new VirtualMachine(myUser.getUserId());	myVM.deployVM(zoneId, serviceOfferingId, templateId, myUser.getDeveloperServer(), myUser.getApiKey(), myUser.getSecretKey());	myUser.getVirtualMachines().add(myVM);	singlePrivateIp = myVM.getPrivateIp();	if (singlePrivateIp != null) {	} else {	break;	}	}	
deployment done vms were created 

========================= cloudstack sample_437 =========================

continue;	}	String cidrAddress = rs.getString("cidr_address");	long cidrSize = rs.getLong("cidr_size");	List<Object> cidrPair = new ArrayList<Object>();	cidrPair.add(0, cidrAddress);	cidrPair.add(1, new Long(cidrSize));	currentPodCidrSubnets.put(podId, cidrPair);	}	} catch (SQLException ex) {	
db exception 

========================= cloudstack sample_4752 =========================

final String vmName = command.getVmName();	Domain vm = null;	try {	final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(vmName);	vm = libvirtComputingResource.getDomain(conn, vmName);	final List<InterfaceDef> pluggedNics = libvirtComputingResource.getInterfaces(conn, vmName);	Integer nicnum = 0;	for (final InterfaceDef pluggedNic : pluggedNics) {	if (pluggedNic.getMacAddress().equalsIgnoreCase(nic.getMac())) {	
found existing nic for mac at index 

return new PlugNicAnswer(command, false, msg);	} catch (final InternalErrorException e) {	final String msg = " Plug Nic failed due to " + e.toString();	s_logger.warn(msg, e);	return new PlugNicAnswer(command, false, msg);	} finally {	if (vm != null) {	try {	vm.free();	} catch (final LibvirtException l) {	
ignoring libvirt error 

========================= cloudstack sample_1045 =========================

public boolean updateState(State oldState, Event event, State newState, VirtualMachine vm, Object opaque) {	if (newState == null) {	if (s_logger.isDebugEnabled()) {	
there s no way to transition from old state event 

StringBuilder str = new StringBuilder("Unable to update ").append(vo.toString());	str.append(": DB Data={Host=").append(vo.getHostId()).append("; State=").append(vo.getState().toString()).append("; updated=").append(vo.getUpdated()) .append("; time=").append(vo.getUpdateTime());	str.append("} New Data: {Host=").append(vm.getHostId()).append("; State=").append(vm.getState().toString()).append("; updated=").append(vmi.getUpdated()) .append("; time=").append(vo.getUpdateTime());	str.append("} Stale Data: {Host=").append(oldHostId).append("; State=").append(oldState).append("; updated=").append(oldUpdated).append("; time=") .append(oldUpdateDate).append("}");	s_logger.debug(str.toString());	} else {	s_logger.debug("Unable to update the vm id=" + vm.getId() + "; the vm either doesn't exist or already removed");	}	}	if (vo != null && vo.getState() == newState) {	
vm state has been already been updated to 

========================= cloudstack sample_4617 =========================

public static VirtualDevice prepareUSBControllerDevice() {	
preparing usb controller ehci uhci device 

writer.append("Exception: " + fault.getClass().getName() + "\n");	writer.append("message: " + ((MethodFault)fault).getFaultMessage() + "\n");	if (printStack) {	writer.append("stack: ");	e.printStackTrace(new PrintWriter(writer));	}	return writer.toString();	}	}	} catch (Exception ex) {	
ignored failed toi get message for exception 

========================= cloudstack sample_2106 =========================

long aggBytesWrite = rs.getLong(12);	long eventTimeMillis = rs.getLong(13);	if (vmId != 0) {	returnMap.put(zoneId + "-" + accountId + "-Vm-" + vmId + "-Disk-" + volumeId, new UsageVmDiskVO(accountId, zoneId, vmId, volumeId, ioRead, ioWrite, aggIORead, aggIOWrite, bytesRead, bytesWrite, aggBytesRead, aggBytesWrite, eventTimeMillis));	} else {	returnMap.put(zoneId + "-" + accountId, new UsageVmDiskVO(accountId, zoneId, vmId, volumeId, ioRead, ioWrite, aggIORead, aggIOWrite, bytesRead, bytesWrite, aggBytesRead, aggBytesWrite, eventTimeMillis));	}	}	return returnMap;	} catch (Exception ex) {	
error getting recent usage disk stats 

String sql = DELETE_OLD_STATS;	PreparedStatement pstmt = null;	try {	txn.start();	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, maxEventTime);	pstmt.executeUpdate();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error deleting old usage disk stats 

pstmt.setLong(10, usageVmDisk.getBytesWrite());	pstmt.setLong(11, usageVmDisk.getAggBytesRead());	pstmt.setLong(12, usageVmDisk.getAggBytesWrite());	pstmt.setLong(13, usageVmDisk.getEventTimeMillis());	pstmt.addBatch();	}	pstmt.executeBatch();	txn.commit();	} catch (Exception ex) {	txn.rollback();	
error saving usage vm disk to cloud usage db 

========================= cloudstack sample_4482 =========================

private void updateRegionEntries(Connection conn) {	final Properties dbProps = DbProperties.getDbProperties();	int region_id = 1;	String regionId = dbProps.getProperty("region.id");	if (regionId != null) {	region_id = Integer.parseInt(regionId);	}	try (PreparedStatement pstmt = conn.prepareStatement("update `cloud`.`region` set id = ?");){	
updating region table with id 

========================= cloudstack sample_4197 =========================

public Pair<Boolean, Long> getCommandHostDelegation(long hostId, Command cmd) {	
getcommandhostdelegation 

========================= cloudstack sample_837 =========================

nic.setPxeDisable(true);	}	}	vm = libvirtComputingResource.createVMFromSpec(vmSpec);	conn = libvirtUtilitiesHelper.getConnectionByType(vm.getHvsType());	libvirtComputingResource.createVbd(conn, vmSpec, vmName, vm);	if (!storagePoolMgr.connectPhysicalDisksViaVmSpec(vmSpec)) {	return new StartAnswer(command, "Failed to connect physical disks to host");	}	libvirtComputingResource.createVifs(vmSpec, vm);	
starting 

final VirtualRoutingResource virtRouterResource = libvirtComputingResource.getVirtRouterResource();	final boolean result = virtRouterResource.connect(controlIp, 1, 5000);	if (result) {	break;	}	}	}	state = DomainState.VIR_DOMAIN_RUNNING;	return new StartAnswer(command);	} catch (final LibvirtException e) {	
libvirtexception 

}	}	state = DomainState.VIR_DOMAIN_RUNNING;	return new StartAnswer(command);	} catch (final LibvirtException e) {	if (conn != null) {	libvirtComputingResource.handleVmStartFailure(conn, vmName, vm);	}	return new StartAnswer(command, e.getMessage());	} catch (final InternalErrorException e) {	
internalerrorexception 

if (conn != null) {	libvirtComputingResource.handleVmStartFailure(conn, vmName, vm);	}	return new StartAnswer(command, e.getMessage());	} catch (final InternalErrorException e) {	if (conn != null) {	libvirtComputingResource.handleVmStartFailure(conn, vmName, vm);	}	return new StartAnswer(command, e.getMessage());	} catch (final URISyntaxException e) {	
urisyntaxexception 

========================= cloudstack sample_1053 =========================

public void onEntry(String prevState, UploadEvent event, Object evtObj) {	super.onEntry(prevState, event, evtObj);	if (event == UploadEvent.DISCONNECT) {	getUploadListener().logDisconnect();	getUploadListener().cancelStatusTask();	getUploadListener().cancelTimeoutTask();	getUploadListener().updateDatabase(Status.UPLOAD_ERROR, "Storage agent or storage VM disconnected");	
entering upload error state because the storage host disconnected 

public void onEntry(String prevState, UploadEvent event, Object evtObj) {	super.onEntry(prevState, event, evtObj);	if (event == UploadEvent.DISCONNECT) {	getUploadListener().logDisconnect();	getUploadListener().cancelStatusTask();	getUploadListener().cancelTimeoutTask();	getUploadListener().updateDatabase(Status.UPLOAD_ERROR, "Storage agent or storage VM disconnected");	} else if (event == UploadEvent.TIMEOUT_CHECK) {	getUploadListener().updateDatabase(Status.UPLOAD_ERROR, "Timeout waiting for response from storage host");	
entering upload error state timeout waiting for response from storage host 

========================= cloudstack sample_2444 =========================

protected HttpRequestBase createMethod(String type, String uri) throws BrocadeVcsApiException {	String url;	try {	url = new URL(Constants.PROTOCOL, _host, Constants.PORT, uri).toString();	} catch (final MalformedURLException e) {	
unable to build brocade switch api url 

}	final HttpPatch pm = (HttpPatch)createMethod("patch", uri);	pm.setHeader("Accept", "application/vnd.configuration.resource+xml");	pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));	final HttpResponse response = executeMethod(pm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	
failed to update object 

pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));	final HttpResponse response = executeMethod(pm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	throw new BrocadeVcsApiException("Failed to update object : " + e.getMessage());	}	pm.releaseConnection();	
failed to update object 

protected <T> String convertToString(T object) throws BrocadeVcsApiException {	final StringWriter stringWriter = new StringWriter();	try {	final JAXBContext context = JAXBContext.newInstance(object.getClass());	final Marshaller marshaller = context.createMarshaller();	marshaller.marshal(object, stringWriter);	} catch (final JAXBException e) {	
failed to convert object to string 

try {	final JAXBContext context = JAXBContext.newInstance(Output.class);	final StringReader reader = new StringReader(object);	final Unmarshaller unmarshaller = context.createUnmarshaller();	final Object result = unmarshaller.unmarshal(reader);	if (result instanceof Output) {	output = (Output)result;	s_logger.info(output);	}	} catch (final JAXBException e) {	
failed to convert string to object 

final boolean result = true;	final HttpPost pm = (HttpPost)createMethod("post", uri);	pm.setHeader("Accept", "application/vnd.configuration.resource+xml");	pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));	final HttpResponse response = executeMethod(pm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	
failed to create object 

pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));	final HttpResponse response = executeMethod(pm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	throw new BrocadeVcsApiException("Failed to create object : " + e.getMessage());	}	pm.releaseConnection();	
failed to create object 

StringBuffer sb = null;	final HttpPost pm = (HttpPost)createMethod("post", uri);	pm.setHeader("Accept", "application/vnd.operational-state.resource+xml");	pm.setEntity(new StringEntity("<show-vcs></show-vcs>", ContentType.APPLICATION_XML));	final HttpResponse response = executeMethod(pm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	
failed to retreive status 

pm.setEntity(new StringEntity("<show-vcs></show-vcs>", ContentType.APPLICATION_XML));	final HttpResponse response = executeMethod(pm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	throw new BrocadeVcsApiException("Failed to retreive status : " + e.getMessage());	}	pm.releaseConnection();	
failed to retreive status 

pm.releaseConnection();	throw new BrocadeVcsApiException("Failed to retreive status : " + errorMessage);	}	try (BufferedReader br = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), Charset.forName("UTF-8")))) {	sb = new StringBuffer();	while ((readLine = br.readLine()) != null) {	s_logger.debug(readLine);	sb.append(readLine);	}	} catch (final Exception e) {	
failed to retreive status 

throw new BrocadeVcsApiException("Hostname/credentials are null or empty");	}	final HttpDelete dm = (HttpDelete)createMethod("delete", uri);	dm.setHeader("Accept", "application/vnd.configuration.resource+xml");	final HttpResponse response = executeMethod(dm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	
failed to delete object 

dm.setHeader("Accept", "application/vnd.configuration.resource+xml");	final HttpResponse response = executeMethod(dm);	if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {	String errorMessage;	try {	errorMessage = responseToErrorMessage(response);	} catch (final IOException e) {	throw new BrocadeVcsApiException("Failed to delete object : " + e.getMessage());	}	dm.releaseConnection();	
failed to delete object 

protected HttpResponse executeMethod(HttpRequestBase method) throws BrocadeVcsApiException {	HttpResponse response = null;	try {	response = _client.execute(method);	if (response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {	method.releaseConnection();	response = _client.execute(method);	}	} catch (final IOException e) {	
ioexception caught while trying to connect to the brocade switch 

========================= cloudstack sample_1638 =========================

SuccessResponse response = new SuccessResponse();	try {	boolean result = _vmwareDatacenterService.removeVmwareDatacenter(this);	if (result) {	response.setResponseName(getCommandName());	setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to remove VMware datacenter from zone");	}	} catch (ResourceInUseException ex) {	
the zone has one or more resources like cluster hence not able to remove vmware datacenter from zone please remove all resource from zone and retry exception 

========================= cloudstack sample_1268 =========================

private void validateRemoteAccessVpnConfiguration() throws ConfigurationException {	String ipRange = RemoteAccessVpnClientIpRange.value();	if (ipRange == null) {	
remote access vpn global configuration missing client ip range ignoring 

try {	for (RemoteAccessVPNServiceProvider element : _vpnServiceProviders) {	if (element.stopVpn(vpn)) {	success = true;	break;	}	}	}catch (ResourceUnavailableException ex) {	vpn.setState(prevState);	_remoteAccessVpnDao.update(vpn.getId(), vpn);	
failed to stop the vpn so reverted state to 

if (vpnFwRules.size() != 0 && _rulesDao.findByRelatedId(vpnFwRules.get(0).getId()) != null) {	applyFirewall = true;	}	if (applyFirewall) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	for (FirewallRule vpnFwRule : vpnFwRules) {	_firewallMgr.revokeRelatedFirewallRule(vpnFwRule.getId(), false);	fwRules.add(_rulesDao.findByRelatedId(vpnFwRule.getId()));	}	
marked firewall rules as revoked as a part of disable remote access vpn 

}	if (vpnFwRules != null) {	for (FirewallRule vpnFwRule : vpnFwRules) {	_rulesDao.remove(vpnFwRule.getId());	s_logger.debug("Successfully removed firewall rule with ip id=" + vpnFwRule.getSourceIpAddressId() + " and port " + vpnFwRule.getSourcePortStart().intValue() + " as a part of vpn cleanup");	}	}	}	});	} catch (Exception ex) {	
unable to release the three vpn ports from the firewall rules 

public boolean applyVpnUsers(long vpnOwnerId, String userName) {	Account caller = CallContext.current().getCallingAccount();	Account owner = _accountDao.findById(vpnOwnerId);	_accountMgr.checkAccess(caller, null, true, owner);	
applying vpn users for 

List<VpnUserVO> users = _vpnUsersDao.listByAccount(vpnOwnerId);	for (VpnUserVO user : users) {	if (user.getState() == State.Active) {	user.setState(State.Add);	_vpnUsersDao.update(user.getId(), user);	}	}	boolean success = true;	Boolean[] finals = new Boolean[users.size()];	for (RemoteAccessVPNServiceProvider element : _vpnServiceProviders) {	
applying vpn access to 

if (finals[indexUser] == null) {	finals[indexUser] = true;	}	} else {	finals[indexUser] = false;	success = false;	}	}	}	} catch (Exception e) {	
unable to apply vpn users 

========================= cloudstack sample_2297 =========================

s_logger.debug(msg);	throw new RuntimeException(msg);	}	if (podId == null) {	String msg = "must specify pod Id when add host";	s_logger.debug(msg);	throw new RuntimeException(msg);	}	ClusterVO cluster = _clusterDao.findById(clusterId);	if (cluster == null || (cluster.getHypervisorType() != HypervisorType.BareMetal)) {	
invalid cluster id or cluster is not for bare metal hosts 

details.put(BaremetalManager.EchoSecurityGroupAgent, isEchoScAgent);	resources.put(resource, details);	resource.start();	zone.setGatewayProvider(Network.Provider.ExternalGateWay.getName());	zone.setDnsProvider(Network.Provider.ExternalDhcpServer.getName());	zone.setDhcpProvider(Network.Provider.ExternalDhcpServer.getName());	_dcDao.update(zone.getId(), zone);	s_logger.debug(String.format("Discover Bare Metal host successfully(ip=%1$s, username=%2$s, password=%3%s," + "cpuNum=%4$s, cpuCapacity-%5$s, memCapacity=%6$s)", ipmiIp, username, "******", cpuNum, cpuCapacity, memCapacity));	return resources;	} catch (Exception e) {	
can not set up bare metal agent 

========================= cloudstack sample_925 =========================

if (instance != null) {	if (srcHost.getClusterId().equals(destHost.getClusterId())) {	answer = migrateVmWithVolumesWithinCluster(instance, vmTo, srcHost, destHost, volumeMap);	} else {	answer = migrateVmWithVolumesAcrossCluster(instance, vmTo, srcHost, destHost, volumeMap);	}	} else {	throw new CloudRuntimeException("Unsupported operation requested for moving data.");	}	} catch (Exception e) {	
copy failed 

List<Pair<VolumeTO, StorageFilerTO>> volumeToFilerto = new ArrayList<Pair<VolumeTO, StorageFilerTO>>();	for (Map.Entry<VolumeInfo, DataStore> entry : volumeToPool.entrySet()) {	VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageReceiveCommand receiveCmd = new MigrateWithStorageReceiveCommand(to, volumeToFilerto);	MigrateWithStorageReceiveAnswer receiveAnswer = (MigrateWithStorageReceiveAnswer)agentMgr.send(destHost.getId(), receiveCmd);	if (receiveAnswer == null) {	
migration with storage of vm to host failed 

VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageReceiveCommand receiveCmd = new MigrateWithStorageReceiveCommand(to, volumeToFilerto);	MigrateWithStorageReceiveAnswer receiveAnswer = (MigrateWithStorageReceiveAnswer)agentMgr.send(destHost.getId(), receiveCmd);	if (receiveAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!receiveAnswer.getResult()) {	
migration with storage of vm failed details 

MigrateWithStorageReceiveCommand receiveCmd = new MigrateWithStorageReceiveCommand(to, volumeToFilerto);	MigrateWithStorageReceiveAnswer receiveAnswer = (MigrateWithStorageReceiveAnswer)agentMgr.send(destHost.getId(), receiveCmd);	if (receiveAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!receiveAnswer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	}	MigrateWithStorageSendCommand sendCmd = new MigrateWithStorageSendCommand(to, receiveAnswer.getVolumeToSr(), receiveAnswer.getNicToNetwork(), receiveAnswer.getToken());	MigrateWithStorageSendAnswer sendAnswer = (MigrateWithStorageSendAnswer)agentMgr.send(srcHost.getId(), sendCmd);	if (sendAnswer == null) {	
migration with storage of vm to host failed 

if (receiveAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!receiveAnswer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	}	MigrateWithStorageSendCommand sendCmd = new MigrateWithStorageSendCommand(to, receiveAnswer.getVolumeToSr(), receiveAnswer.getNicToNetwork(), receiveAnswer.getToken());	MigrateWithStorageSendAnswer sendAnswer = (MigrateWithStorageSendAnswer)agentMgr.send(srcHost.getId(), sendCmd);	if (sendAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!sendAnswer.getResult()) {	
migration with storage of vm failed details 

MigrateWithStorageSendCommand sendCmd = new MigrateWithStorageSendCommand(to, receiveAnswer.getVolumeToSr(), receiveAnswer.getNicToNetwork(), receiveAnswer.getToken());	MigrateWithStorageSendAnswer sendAnswer = (MigrateWithStorageSendAnswer)agentMgr.send(srcHost.getId(), sendCmd);	if (sendAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!sendAnswer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	}	MigrateWithStorageCompleteCommand command = new MigrateWithStorageCompleteCommand(to);	MigrateWithStorageCompleteAnswer answer = (MigrateWithStorageCompleteAnswer)agentMgr.send(destHost.getId(), command);	if (answer == null) {	
migration with storage of vm failed 

if (sendAnswer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!sendAnswer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	}	MigrateWithStorageCompleteCommand command = new MigrateWithStorageCompleteCommand(to);	MigrateWithStorageCompleteAnswer answer = (MigrateWithStorageCompleteAnswer)agentMgr.send(destHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	
migration with storage of vm failed details 

MigrateWithStorageCompleteAnswer answer = (MigrateWithStorageCompleteAnswer)agentMgr.send(destHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else {	updateVolumePathsAfterMigration(volumeToPool, answer.getVolumeTos());	}	return answer;	} catch (OperationTimedoutException e) {	
error while migrating vm to host 

List<Pair<VolumeTO, StorageFilerTO>> volumeToFilerto = new ArrayList<Pair<VolumeTO, StorageFilerTO>>();	for (Map.Entry<VolumeInfo, DataStore> entry : volumeToPool.entrySet()) {	VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand command = new MigrateWithStorageCommand(to, volumeToFilerto);	MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer)agentMgr.send(destHost.getId(), command);	if (answer == null) {	
migration with storage of vm failed 

VolumeInfo volume = entry.getKey();	VolumeTO volumeTo = new VolumeTO(volume, storagePoolDao.findById(volume.getPoolId()));	StorageFilerTO filerTo = new StorageFilerTO((StoragePool)entry.getValue());	volumeToFilerto.add(new Pair<VolumeTO, StorageFilerTO>(volumeTo, filerTo));	}	MigrateWithStorageCommand command = new MigrateWithStorageCommand(to, volumeToFilerto);	MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer)agentMgr.send(destHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	
migration with storage of vm failed details 

MigrateWithStorageAnswer answer = (MigrateWithStorageAnswer)agentMgr.send(destHost.getId(), command);	if (answer == null) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost);	} else if (!answer.getResult()) {	throw new CloudRuntimeException("Error while migrating the vm " + vm + " to host " + destHost + ". " + answer.getDetails());	} else {	updateVolumePathsAfterMigration(volumeToPool, answer.getVolumeTos());	}	return answer;	} catch (OperationTimedoutException e) {	
error while migrating vm to host 

volumeVO.setFolder(pool.getPath());	volumeVO.setPodId(pool.getPodId());	volumeVO.setPoolId(pool.getId());	volumeVO.setLastPoolId(oldPoolId);	volDao.update(volume.getId(), volumeVO);	updated = true;	break;	}	}	if (!updated) {	
volume path wasn t updated for volume after it was migrated 

========================= cloudstack sample_1141 =========================

private UptimeStats getUptimeAndCpuIdleTime() {	UptimeStats uptime = new UptimeStats(0d, 0d);	File f = new File(_uptimeFile);	try (Scanner scanner = new Scanner(f,"UTF-8");) {	String[] stats = scanner.useDelimiter("\\Z").next().split("\\s+");	uptime = new UptimeStats(Double.parseDouble(stats[0]), Double.parseDouble(stats[1]));	} catch (FileNotFoundException ex) {	
file not found 

========================= cloudstack sample_1004 =========================

}	String providerName = (String)dsInfos.get("providerName");	DataStoreRole role = (DataStoreRole)dsInfos.get("role");	Map<String, String> details = (Map<String, String>)dsInfos.get("details");	String logString = "";	if(url.contains("cifs")) {	logString = cleanPassword(url);	} else {	logString = StringUtils.cleanString(url);	}	
trying to add a new data store at to data center 

========================= cloudstack sample_1907 =========================

public boolean update(String name, String value) {	TransactionLegacy txn = TransactionLegacy.currentTxn();	try (PreparedStatement stmt = txn.prepareStatement(UPDATE_CONFIGURATION_SQL);){	stmt.setString(1, value);	stmt.setString(2, name);	stmt.executeUpdate();	return true;	} catch (Exception e) {	
unable to update configuration value 

TransactionLegacy txn = TransactionLegacy.currentTxn();	try {	value = ("Hidden".equals(category) || "Secure".equals(category)) ? DBEncryptionUtil.encrypt(value) : value;	try (PreparedStatement stmt = txn.prepareStatement(UPDATE_CONFIGURATION_SQL);) {	stmt.setString(1, value);	stmt.setString(2, name);	stmt.executeUpdate();	return true;	}	} catch (Exception e) {	
unable to update configuration value 

returnValue = config.getValue();	} else {	update(name, category, initValue);	}	} else {	ConfigurationVO newConfig = new ConfigurationVO(category, "DEFAULT", "management-server", name, initValue, desc);	persist(newConfig);	}	return returnValue;	} catch (Exception e) {	
unable to update configuration value 

========================= cloudstack sample_499 =========================

}	nic.setIPv4Address(ip.first());	nic.setMacAddress(NetUtils.long2Mac(NetUtils.createSequenceBasedMacAddress(ip.second())));	nic.setIPv4Gateway(pod.getGateway());	nic.setFormat(AddressFormat.Ip4);	String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());	nic.setIPv4Netmask(netmask);	nic.setBroadcastType(BroadcastDomainType.Native);	nic.setBroadcastUri(null);	nic.setIsolationUri(null);	
allocated a nic for 

public boolean release(NicProfile nic, VirtualMachineProfile vm, String reservationId) {	_dcDao.releasePrivateIpAddress(nic.getId(), nic.getReservationId());	nic.deallocate();	if (s_logger.isDebugEnabled()) {	
released nic 

========================= cloudstack sample_2278 =========================

_connection = SSHCmdHelper.acquireAuthorizedConnection(ip, username, password);	if (_connection == null) {	throw new CloudRuntimeException("Error opening ssh connection.");	}	try {	_session = _connection.openSession();	_session.startSubSystem("xmlagent");	exchangeHello();	} catch (final Exception e) {	disconnect();	
failed to connect to device ssh server 

private void send(String message) {	try {	OutputStream outputStream = _session.getStdin();	outputStream.write(message.getBytes());	outputStream.flush();	} catch (Exception e) {	
failed to send message 

========================= cloudstack sample_2782 =========================

hostResponse.setCpuUsed(cpuUsed);	hostResponse.setMemoryUsed((new Double(hostStats.getUsedMemory())).longValue());	hostResponse.setNetworkKbsRead((new Double(hostStats.getNetworkReadKBs())).longValue());	hostResponse.setNetworkKbsWrite((new Double(hostStats.getNetworkWriteKBs())).longValue());	}	}	if (details.contains(HostDetails.all) && host.getHypervisorType() == Hypervisor.HypervisorType.KVM) {	try {	hostResponse.setDetails(hostDetailsDao.findDetails(host.getId()));	} catch (Exception e) {	
failed to get host details 

========================= cloudstack sample_2595 =========================

public Answer execute(final SecurityGroupRulesCmd command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	if (s_logger.isTraceEnabled()) {	
sending network rules command to 

public Answer execute(final SecurityGroupRulesCmd command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	if (s_logger.isTraceEnabled()) {	}	if (!citrixResourceBase.canBridgeFirewall()) {	
host cannot do bridge firewalling 

public Answer execute(final SecurityGroupRulesCmd command, final CitrixResourceBase citrixResourceBase) {	final Connection conn = citrixResourceBase.getConnection();	if (s_logger.isTraceEnabled()) {	}	if (!citrixResourceBase.canBridgeFirewall()) {	return new SecurityGroupRuleAnswer(command, false, "Host " + citrixResourceBase.getHost().getIp() + " cannot do bridge firewalling", SecurityGroupRuleAnswer.FailureReason.CANNOT_BRIDGE_FIREWALL);	}	final String result = citrixResourceBase.callHostPlugin(conn, "vmops", "network_rules", "vmName", command.getVmName(), "vmIP", command.getGuestIp(), "vmMAC", command.getGuestMac(), "vmID", Long.toString(command.getVmId()), "signature", command.getSignature(), "seqno", Long.toString(command.getSeqNum()), "deflated", "true", "rules", command.compressStringifiedRules(), "secIps", command.getSecIpsString());	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	
failed to program network rules for vm 

========================= cloudstack sample_1213 =========================

public void parse(byte[] vmsdFileContent) throws IOException {	BufferedReader in = null;	try {	in = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(vmsdFileContent),"UTF-8"));	String line;	while ((line = in.readLine()) != null) {	
parse snapshot file content 

out.write(String.format("%s = \"%s\"", key, value));	out.newLine();	key = String.format("snapshot%d.disk%d.node", i, j);	value = _properties.getProperty(key);	out.write(String.format("%s = \"%s\"", key, value));	out.newLine();	}	}	} catch (IOException e) {	assert (false);	
unexpected exception 

========================= cloudstack sample_2080 =========================

public void runJob(AsyncJob job) {	VmWork work = null;	try {	String cmd = job.getCmd();	assert (cmd != null);	Class<?> workClz = null;	try {	workClz = Class.forName(job.getCmd());	} catch (ClassNotFoundException e) {	
vm work class is not found job origin 

assert (cmd != null);	Class<?> workClz = null;	try {	workClz = Class.forName(job.getCmd());	} catch (ClassNotFoundException e) {	_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, e.getMessage());	return;	}	work = VmWorkSerializer.deserialize(workClz, job.getCmdInfo());	if(work == null) {	
unable to deserialize vm work job info job origin 

workClz = Class.forName(job.getCmd());	} catch (ClassNotFoundException e) {	_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, e.getMessage());	return;	}	work = VmWorkSerializer.deserialize(workClz, job.getCmdInfo());	if(work == null) {	_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, "Unable to deserialize VM work");	return;	}	
run vm work job for vm job origin 

_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, e.getMessage());	return;	}	work = VmWorkSerializer.deserialize(workClz, job.getCmdInfo());	if(work == null) {	_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, "Unable to deserialize VM work");	return;	}	try {	if (_handlers == null || _handlers.isEmpty()) {	
invalid startup configuration no work job handler is found cmd job info job origin 

_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, "Unable to deserialize VM work");	return;	}	try {	if (_handlers == null || _handlers.isEmpty()) {	_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, "Invalid startup configuration. no job handler is found");	return;	}	VmWorkJobHandler handler = _handlers.get(work.getHandlerName());	if (handler == null) {	
unable to find work job handler handler name job cmd job info job origin 

return;	}	CallContext.register(work.getUserId(), work.getAccountId());	try {	Pair<JobInfo.Status, String> result = handler.handleVmWorkJob(work);	_asyncJobMgr.completeAsyncJob(job.getId(), result.first(), 0, result.second());	} finally {	CallContext.unregister();	}	} finally {	
done with run of vm work job for vm job origin 

CallContext.register(work.getUserId(), work.getAccountId());	try {	Pair<JobInfo.Status, String> result = handler.handleVmWorkJob(work);	_asyncJobMgr.completeAsyncJob(job.getId(), result.first(), 0, result.second());	} finally {	CallContext.unregister();	}	} finally {	}	} catch(InvalidParameterValueException e) {	
unable to complete job origin 

Pair<JobInfo.Status, String> result = handler.handleVmWorkJob(work);	_asyncJobMgr.completeAsyncJob(job.getId(), result.first(), 0, result.second());	} finally {	CallContext.unregister();	}	} finally {	}	} catch(InvalidParameterValueException e) {	_asyncJobMgr.completeAsyncJob(job.getId(), JobInfo.Status.FAILED, 0, _asyncJobMgr.marshallResultObject(e));	} catch(Throwable e) {	
unable to complete job origin 

========================= cloudstack sample_4787 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing ip address usage for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageIPAddressVO> usageIPAddress = s_usageIPAddressDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate);	if (usageIPAddress.isEmpty()) {	
no ip address usage for this period 

private static void createUsageRecord(long zoneId, long runningTime, Date startDate, Date endDate, AccountVO account, long ipId, String ipAddress, boolean isSourceNat, boolean isSystem) {	if (s_logger.isDebugEnabled()) {	
total usage time ms 

private static void createUsageRecord(long zoneId, long runningTime, Date startDate, Date endDate, AccountVO account, long ipId, String ipAddress, boolean isSourceNat, boolean isSystem) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating ip usage record with id usage startdate enddate for account 

========================= cloudstack sample_2653 =========================

if (snapshotMemory && userVmVo.getState() == VirtualMachine.State.Running) vmSnapshotType = VMSnapshot.Type.DiskAndMemory;	try {	VMSnapshotVO vmSnapshotVo = new VMSnapshotVO(userVmVo.getAccountId(), userVmVo.getDomainId(), vmId, vsDescription, vmSnapshotName, vsDisplayName, userVmVo.getServiceOfferingId(), vmSnapshotType, null);	VMSnapshot vmSnapshot = _vmSnapshotDao.persist(vmSnapshotVo);	if (vmSnapshot == null) {	throw new CloudRuntimeException("Failed to create snapshot for vm: " + vmId);	}	return vmSnapshot;	} catch (Exception e) {	String msg = e.getMessage();	
create vm snapshot record failed for vm due to 

if (vmSnapshot == null) {	throw new CloudRuntimeException("VM snapshot id: " + vmSnapshotId + " can not be found");	}	VMSnapshotOptions options = new VMSnapshotOptions(quiescevm);	vmSnapshot.setOptions(options);	try {	VMSnapshotStrategy strategy = findVMSnapshotStrategy(vmSnapshot);	VMSnapshot snapshot = strategy.takeVMSnapshot(vmSnapshot);	return snapshot;	} catch (Exception e) {	
failed to create vm snapshot 

if (expungingSnapshots.size() > 0 && expungingSnapshots.get(0).getId() == vmSnapshot.getId()) s_logger.debug("Target VM snapshot already in expunging state, go on deleting it: " + vmSnapshot.getDisplayName());	else throw new InvalidParameterValueException("There is other active vm snapshot tasks on the instance, please try again later");	}	if (vmSnapshot.getState() == VMSnapshot.State.Allocated) {	return _vmSnapshotDao.remove(vmSnapshot.getId());	} else {	try {	VMSnapshotStrategy strategy = findVMSnapshotStrategy(vmSnapshot);	return strategy.deleteVMSnapshot(vmSnapshot);	} catch (Exception e) {	
failed to delete vm snapshot 

throw new InvalidParameterValueException("VM Snapshot reverting failed due to vm snapshot is not in the state of Created.");	}	UserVmVO vm = null;	Long hostId = null;	if (userVm.getState() == VirtualMachine.State.Stopped && vmSnapshotVo.getType() == VMSnapshot.Type.DiskAndMemory) {	try {	_itMgr.advanceStart(userVm.getUuid(), new HashMap<VirtualMachineProfile.Param, Object>(), null);	vm = _userVMDao.findById(userVm.getId());	hostId = vm.getHostId();	} catch (Exception e) {	
start vm before reverting failed due to 

vm = _userVMDao.findById(userVm.getId());	hostId = vm.getHostId();	} catch (Exception e) {	throw new CloudRuntimeException(e.getMessage());	}	} else {	if (userVm.getState() == VirtualMachine.State.Running && vmSnapshotVo.getType() == VMSnapshot.Type.Disk) {	try {	_itMgr.advanceStop(userVm.getUuid(), true);	} catch (Exception e) {	
stop vm before reverting failed due to 

}	}	if (hasActiveVMSnapshotTasks(userVm.getId())) {	throw new InvalidParameterValueException("There is other active vm snapshot tasks on the instance, please try again later");	}	try {	VMSnapshotStrategy strategy = findVMSnapshotStrategy(vmSnapshotVo);	strategy.revertVMSnapshot(vmSnapshotVo);	return userVm;	} catch (Exception e) {	
failed to revert vmsnapshot 

========================= cloudstack sample_2468 =========================

eventDescription.put("zone", zoneUuid);	eventDescription.put("event", usageEventType);	eventDescription.put("resource", resourceType);	eventDescription.put("id", resourceUUID);	String eventDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").format(new Date());	eventDescription.put("eventDateTime", eventDate);	event.setDescription(eventDescription);	try {	s_eventBus.publish(event);	} catch (EventBusException e) {	
failed to publish usage event on the the event bus 

========================= cloudstack sample_4945 =========================

public void runDedicateZoneTest() {	DataCenterVO dc = new DataCenterVO(10L, "TestZone", "Dedicated", "8.8.8.8", null, "10.0.0.1", null, "10.0.0.1/24", null, null, NetworkType.Basic, null, null);	when(_dcDao.findById(10L)).thenReturn(dc);	try {	List<DedicatedResourceVO> result = _dedicatedService.dedicateZone(10L, domainId, accountName);	Assert.assertNotNull(result);	} catch (Exception e) {	
exception in testing dedication of zone 

public void runDedicatePodTest() {	HostPodVO pod = new HostPodVO("TestPod", 20L, "10.0.0.1", "10.0.0.0", 22, null);	when(_podDao.findById(10L)).thenReturn(pod);	try {	List<DedicatedResourceVO> result = _dedicatedService.dedicatePod(10L, domainId, accountName);	Assert.assertNotNull(result);	} catch (Exception e) {	
exception in testing dedication of pod 

public void runDedicateClusterTest() {	ClusterVO cluster = new ClusterVO(10L, 10L, "TestCluster");	when(_clusterDao.findById(10L)).thenReturn(cluster);	try {	List<DedicatedResourceVO> result = _dedicatedService.dedicateCluster(10L, domainId, accountName);	Assert.assertNotNull(result);	} catch (Exception e) {	
exception in testing dedication of cluster 

public void runDedicateHostTest() {	HostVO host = new HostVO(10L, "Host-1", Host.Type.Routing, null, "10.0.0.0", null, null, null, null, null, null, null, null, Status.Up, null, null, null, 10L, 10L, 30L, 10233, null, null, null, 0, null);	when(_hostDao.findById(10L)).thenReturn(host);	try {	List<DedicatedResourceVO> result = _dedicatedService.dedicateHost(10L, domainId, accountName);	Assert.assertNotNull(result);	} catch (Exception e) {	
exception in testing dedication of host 

========================= cloudstack sample_2038 =========================

CheckOnHostCommand cmd = new CheckOnHostCommand(agent);	List<HostVO> neighbors = _resourceMgr.listAllHostsInCluster(agent.getClusterId());	for (HostVO neighbor : neighbors) {	if (neighbor.getId() == agent.getId() || neighbor.getHypervisorType() != HypervisorType.XenServer) {	continue;	}	Answer answer = _agentMgr.easySend(neighbor.getId(), cmd);	if (answer != null && answer.getResult()) {	CheckOnHostAnswer ans = (CheckOnHostAnswer)answer;	if (!ans.isDetermined()) {	
host couldn t determine the status of 

========================= cloudstack sample_2487 =========================

public void build(ModelController controller, VMInstanceVO instance) {	setProperties(controller, instance);	UserVm userVm = controller.getVmDao().findById(instance.getId());	if (userVm != null && userVm.getUserData() != null) {	
vm user data 

private void buildServiceInstance(ModelController controller, String serviceUuid) {	ContrailManager manager = controller.getManager();	ApiConnector api = controller.getApiAccessor();	_serviceUuid = serviceUuid;	ServiceInstance siObj;	try {	siObj = (ServiceInstance) api.findById(ServiceInstance.class, serviceUuid);	} catch (IOException ex) {	
service instance read 

public void delete(ModelController controller) throws IOException {	ApiConnector api = controller.getApiAccessor();	for (ModelObject successor : successors()) {	successor.delete(controller);	}	try {	api.delete(VirtualMachine.class, _uuid);	} catch (IOException ex) {	
virtual machine delete 

public void setProperties(ModelController controller, VMInstanceVO instance) {	ContrailManager manager = controller.getManager();	_instanceName = instance.getInstanceName();	_active = isActiveInstance(instance);	try {	_projectId = manager.getProjectId(instance.getDomainId(), instance.getAccountId());	} catch (IOException ex) {	
project read 

VirtualMachine vm = _vm;	if (vm == null) {	_vm = vm = (VirtualMachine)api.findById(VirtualMachine.class, _uuid);	if (vm == null) {	vm = new VirtualMachine();	if (_projectId != null) {	Project project;	try {	project = (Project)api.findById(Project.class, _projectId);	} catch (IOException ex) {	
project read 

vm.setUuid(_uuid);	}	}	if (_serviceModel != null) {	vm.setServiceInstance(_serviceModel.getServiceInstance());	}	if (_vm == null) {	try {	api.create(vm);	} catch (Exception ex) {	
virtual machine create 

try {	api.create(vm);	} catch (Exception ex) {	throw new CloudRuntimeException("Failed to create virtual-machine", ex);	}	_vm = vm;	} else {	try {	api.update(vm);	} catch (IOException ex) {	
virtual machine update 

public boolean verify(ModelController controller) {	assert _initialized : "initialized is false";	assert _uuid != null : "uuid is not set";	ApiConnector api = controller.getApiAccessor();	try {	_vm = (VirtualMachine) api.findById(VirtualMachine.class, _uuid);	} catch (IOException e) {	
virtual machine verify 

========================= cloudstack sample_1881 =========================

public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	if (dest.getDataCenter().getNetworkType() == DataCenter.NetworkType.Advanced){	return true;	}	if (offering.isSystemOnly() || !canHandle(dest, offering.getTrafficType(), network.getGuestType())) {	
baremetalpxeelement can not handle network offering 

========================= cloudstack sample_909 =========================

public synchronized boolean processDisconnect(long agentId, Status state) {	
agent disconnected agent id state will notify waiters 

public void processConnect(Host host, StartupCommand cmd, boolean forRebalance) throws ConnectionException {	if (cmd instanceof StartupRoutingCommand) {	if (((StartupRoutingCommand)cmd).getHypervisorType() == HypervisorType.KVM || ((StartupRoutingCommand)cmd).getHypervisorType() == HypervisorType.XenServer || ((StartupRoutingCommand)cmd).getHypervisorType() == HypervisorType.LXC) {	String pubKey = _configDao.getValue("ssh.publickey");	String prvKey = _configDao.getValue("ssh.privatekey");	try {	ModifySshKeysCommand cmds = new ModifySshKeysCommand(pubKey, prvKey);	Commands c = new Commands(cmds);	_agentMgr.send(host.getId(), c, this);	} catch (AgentUnavailableException e) {	
failed to send keys to agent 

========================= cloudstack sample_2311 =========================

public static void initOnce() {	try {	processWorkMethod = HighAvailabilityManagerImpl.class.getDeclaredMethod("processWork", HaWorkVO.class);	processWorkMethod.setAccessible(true);	} catch (NoSuchMethodException e) {	
ignored expected nosuchmethodexception caught 

private void processWorkWithRetryCount(int count, Step expectedStep) {	assertNotNull(processWorkMethod);	HaWorkVO work = new HaWorkVO(1l, VirtualMachine.Type.User, WorkType.Migration, Step.Scheduled, 1l, VirtualMachine.State.Running, count, 12345678l);	Mockito.doReturn(12345678l).when(highAvailabilityManagerSpy).migrate(work);	try {	processWorkMethod.invoke(highAvailabilityManagerSpy, work);	} catch (IllegalAccessException e) {	
ignored expected illegalaccessexception caught 

private void processWorkWithRetryCount(int count, Step expectedStep) {	assertNotNull(processWorkMethod);	HaWorkVO work = new HaWorkVO(1l, VirtualMachine.Type.User, WorkType.Migration, Step.Scheduled, 1l, VirtualMachine.State.Running, count, 12345678l);	Mockito.doReturn(12345678l).when(highAvailabilityManagerSpy).migrate(work);	try {	processWorkMethod.invoke(highAvailabilityManagerSpy, work);	} catch (IllegalAccessException e) {	} catch (IllegalArgumentException e) {	
ignored expected illegalargumentexception caught 

private void processWorkWithRetryCount(int count, Step expectedStep) {	assertNotNull(processWorkMethod);	HaWorkVO work = new HaWorkVO(1l, VirtualMachine.Type.User, WorkType.Migration, Step.Scheduled, 1l, VirtualMachine.State.Running, count, 12345678l);	Mockito.doReturn(12345678l).when(highAvailabilityManagerSpy).migrate(work);	try {	processWorkMethod.invoke(highAvailabilityManagerSpy, work);	} catch (IllegalAccessException e) {	} catch (IllegalArgumentException e) {	} catch (InvocationTargetException e) {	
ignored expected invocationtargetexception caught 

========================= cloudstack sample_2184 =========================

public void onClientClose() {	
received client close indication remove viewer from map 

public boolean isFrontEndAlive() {	if (_socket != null) {	if (_workerDone || System.currentTimeMillis() - getClientLastFrontEndActivityTime() > ConsoleProxy.VIEWER_LINGER_SECONDS * 1000) {	
front end has been idle for too long 

_screen = new ScreenDescription();	_canvas = new RdpBufferedImageCanvas(this, canvasWidth, canvasHeight);	onFramebufferSizeChange(canvasWidth, canvasHeight);	_screen.addSizeChangeListener(new SizeChangeListener() {	public void sizeChanged(int width, int height) {	if (_canvas != null) {	_canvas.setCanvasSize(width, height);	}	}	});	
connecting to instance on host 

public void run() {	_socket = new AprSocketWrapperImpl("socket", sslState);	Pipeline pipeline = new PipelineImpl("Client");	pipeline.add(_socket, _client);	pipeline.link("socket", _client.getId(), "socket");	pipeline.validate();	InetSocketAddress address = new InetSocketAddress(host, port);	ConsoleProxy.ensureRoute(host);	try {	_workerDone = false;	
connecting socket to remote server and run main loop s 

Pipeline pipeline = new PipelineImpl("Client");	pipeline.add(_socket, _client);	pipeline.link("socket", _client.getId(), "socket");	pipeline.validate();	InetSocketAddress address = new InetSocketAddress(host, port);	ConsoleProxy.ensureRoute(host);	try {	_workerDone = false;	_socket.connect(address);	} catch (Exception e) {	
error occurred in connecting to socket 

InetSocketAddress address = new InetSocketAddress(host, port);	ConsoleProxy.ensureRoute(host);	try {	_workerDone = false;	_socket.connect(address);	} catch (Exception e) {	} finally {	shutdown();	}	_threadStopTime = System.currentTimeMillis();	
receiver thread stopped 

shutdown();	}	_threadStopTime = System.currentTimeMillis();	_workerDone = true;	}	});	_worker.setDaemon(true);	_worker.start();	} catch (Exception e) {	_workerDone = true;	
error occurred in initializing rdp client 

========================= cloudstack sample_4953 =========================

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	
retrieving user 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	
username or password cannot be empty 

public Pair<Boolean, ActionOnFailedAuthentication> authenticate(String username, String password, Long domainId, Map<String, Object[]> requestParameters) {	if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	UserAccount user = _userAccountDao.getUserAccount(username, domainId);	if (user == null) {	
unable to find user with in domain 

if (s_logger.isDebugEnabled()) {	}	if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	UserAccount user = _userAccountDao.getUserAccount(username, domainId);	if (user == null) {	return new Pair<Boolean, ActionOnFailedAuthentication>(false, null);	}	if (!user.getPassword().equals(encode(password))) {	
password does not match 

========================= cloudstack sample_1317 =========================

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	CheckVirtualMachineCommand cmd = new CheckVirtualMachineCommand(vm.getInstanceName());	try {	CheckVirtualMachineAnswer answer = (CheckVirtualMachineAnswer)_agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	
unable to get vm state on 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	CheckVirtualMachineCommand cmd = new CheckVirtualMachineCommand(vm.getInstanceName());	try {	CheckVirtualMachineAnswer answer = (CheckVirtualMachineAnswer)_agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	throw new UnknownVM();	}	
agent responded with state 

public boolean isVmAlive(VirtualMachine vm, Host host) throws UnknownVM {	CheckVirtualMachineCommand cmd = new CheckVirtualMachineCommand(vm.getInstanceName());	try {	CheckVirtualMachineAnswer answer = (CheckVirtualMachineAnswer)_agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	throw new UnknownVM();	}	return answer.getState() == PowerState.PowerOn;	} catch (AgentUnavailableException e) {	
unable to reach the agent for 

CheckVirtualMachineCommand cmd = new CheckVirtualMachineCommand(vm.getInstanceName());	try {	CheckVirtualMachineAnswer answer = (CheckVirtualMachineAnswer)_agentMgr.send(vm.getHostId(), cmd);	if (!answer.getResult()) {	throw new UnknownVM();	}	return answer.getState() == PowerState.PowerOn;	} catch (AgentUnavailableException e) {	throw new UnknownVM();	} catch (OperationTimedoutException e) {	
operation timed out for 

========================= cloudstack sample_2491 =========================

public void waitAny(long timeoutInMiliseconds) {	if (timeoutInMiliseconds < 100) {	
waitany is passed with a too short time out interval ms 

public void waitAny(long timeoutInMiliseconds) {	if (timeoutInMiliseconds < 100) {	timeoutInMiliseconds = 100;	}	synchronized (this) {	try {	wait(timeoutInMiliseconds);	} catch (InterruptedException e) {	
ignored interupted while waiting on any message 

========================= cloudstack sample_620 =========================

VMGuestMetrics mtr = vm.getGuestMetrics(conn);	VMGuestMetrics.Record rec = mtr.getRecord(conn);	Map<String, String> vmIpsMap = rec.networks;	for (String ipAddr: vmIpsMap.values()) {	if (NetUtils.isIpWithtInCidrRange(ipAddr, networkCidr)) {	vmIp = ipAddr;	break;	}	}	if (vmIp != null) {	
vm ip address got retrieved 

if (NetUtils.isIpWithtInCidrRange(ipAddr, networkCidr)) {	vmIp = ipAddr;	break;	}	}	if (vmIp != null) {	result = true;	return new Answer(command, result, vmIp);	}	}catch (Types.XenAPIException e) {	
got exception in getvmipaddresscommand 

break;	}	}	if (vmIp != null) {	result = true;	return new Answer(command, result, vmIp);	}	}catch (Types.XenAPIException e) {	errorMsg = "Failed to retrived vm ip addr, exception: "+e.getMessage();	}catch (XmlRpcException e) {	
got exception in getvmipaddresscommand 

========================= cloudstack sample_1194 =========================

snapshotResponse.setIntervalType(ApiDBUtils.getSnapshotIntervalTypes(snapshot.getId()));	snapshotResponse.setState(snapshot.getState());	SnapshotInfo snapshotInfo = null;	if (snapshot instanceof SnapshotInfo) {	snapshotInfo = (SnapshotInfo)snapshot;	} else {	DataStoreRole dataStoreRole = getDataStoreRole(snapshot, _snapshotStoreDao, _dataStoreMgr);	snapshotInfo = snapshotfactory.getSnapshot(snapshot.getId(), dataStoreRole);	}	if (snapshotInfo == null) {	
unable to find info for image store snapshot with uuid 

========================= cloudstack sample_2612 =========================

private boolean sendCommandsToRouter(final DomainRouterVO elbVm, Commands cmds) throws AgentUnavailableException {	Answer[] answers = null;	try {	answers = _agentMgr.send(elbVm.getHostId(), cmds);	} catch (OperationTimedoutException e) {	
elb timed out 

public boolean applyLoadBalancerRules(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException {	if (rules == null || rules.isEmpty()) {	return true;	}	DomainRouterVO elbVm = findElbVmForLb(rules.get(0));	if (elbVm == null) {	
unable to apply lb rules elb vm doesn t exist in the network 

List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());	List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());	List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());	Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();	LbSslCert sslCert = _lbMgr.getLbSslCert(lb.getId());	LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp, sslCert, lb.getLbProtocol());	lbRules.add(loadBalancing);	}	return applyLBRules(elbVm, lbRules, network.getId());	} else if (elbVm.getState() == State.Stopped || elbVm.getState() == State.Stopping) {	
elb vm is in so not sending apply loadbalancing rules commands to the backend 

List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());	Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();	LbSslCert sslCert = _lbMgr.getLbSslCert(lb.getId());	LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp, sslCert, lb.getLbProtocol());	lbRules.add(loadBalancing);	}	return applyLBRules(elbVm, lbRules, network.getId());	} else if (elbVm.getState() == State.Stopped || elbVm.getState() == State.Stopping) {	return true;	} else {	
unable to apply loadbalancing rules elb vm is not in the right state 

_elasticLbvmCpuMHz = NumbersUtil.parseInt(configs.get(Config.ElasticLoadBalancerVmCpuMhz.key()), DEFAULT_ELB_VM_CPU_MHZ);	_elasticLbvmNumCpu = NumbersUtil.parseInt(configs.get(Config.ElasticLoadBalancerVmNumVcpu.key()), 1);	List<ServiceOfferingVO> offerings = _serviceOfferingDao.createSystemServiceOfferings("System Offering For Elastic LB VM", ServiceOffering.elbVmDefaultOffUniqueName, _elasticLbvmNumCpu, _elasticLbVmRamSize, _elasticLbvmCpuMHz, 0, 0, true, null, Storage.ProvisioningType.THIN, true, null, true, VirtualMachine.Type.ElasticLoadBalancerVm, true);	if (offerings == null || offerings.size() < 2) {	String msg = "Data integrity problem : System Offering For Elastic LB VM has been removed?";	s_logger.error(msg);	throw new ConfigurationException(msg);	}	String enabled = _configDao.getValue(Config.ElasticLoadBalancerEnabled.key());	_enabled = (enabled == null) ? false : Boolean.parseBoolean(enabled);	
elastic load balancer enabled 

}	String enabled = _configDao.getValue(Config.ElasticLoadBalancerEnabled.key());	_enabled = (enabled == null) ? false : Boolean.parseBoolean(enabled);	if (_enabled) {	String traffType = _configDao.getValue(Config.ElasticLoadBalancerNetwork.key());	if ("guest".equalsIgnoreCase(traffType)) {	_frontendTrafficType = TrafficType.Guest;	} else if ("public".equalsIgnoreCase(traffType)) {	_frontendTrafficType = TrafficType.Public;	} else throw new ConfigurationException("ELB: Traffic type for front end of load balancer has to be guest or public; found : " + traffType);	
elb elastic load balancer will balance on 

_enabled = (enabled == null) ? false : Boolean.parseBoolean(enabled);	if (_enabled) {	String traffType = _configDao.getValue(Config.ElasticLoadBalancerNetwork.key());	if ("guest".equalsIgnoreCase(traffType)) {	_frontendTrafficType = TrafficType.Guest;	} else if ("public".equalsIgnoreCase(traffType)) {	_frontendTrafficType = TrafficType.Public;	} else throw new ConfigurationException("ELB: Traffic type for front end of load balancer has to be guest or public; found : " + traffType);	int gcIntervalMinutes = NumbersUtil.parseInt(configs.get(Config.ElasticLoadBalancerVmGcInterval.key()), 5);	if (gcIntervalMinutes < 5) gcIntervalMinutes = 5;	
elb elastic load balancer scheduling gc to run every minutes 

private DomainRouterVO stop(DomainRouterVO elbVm, boolean forced) throws ConcurrentOperationException, ResourceUnavailableException {	
stopping elb vm 

if (nic.isDefaultNic()) {	buf.append(" gateway=").append(nic.getIPv4Gateway());	defaultDns1 = nic.getIPv4Dns1();	defaultDns2 = nic.getIPv4Dns2();	}	if (nic.getTrafficType() == TrafficType.Management) {	buf.append(" localgw=").append(dest.getPod().getGateway());	} else if (nic.getTrafficType() == TrafficType.Control) {	if (dest.getHost().getHypervisorType() == HypervisorType.VMware) {	if (s_logger.isInfoEnabled()) {	
check if we need to add management server explicit route to elb vm pod cidr pod gateway management host 

defaultDns1 = nic.getIPv4Dns1();	defaultDns2 = nic.getIPv4Dns2();	}	if (nic.getTrafficType() == TrafficType.Management) {	buf.append(" localgw=").append(dest.getPod().getGateway());	} else if (nic.getTrafficType() == TrafficType.Control) {	if (dest.getHost().getHypervisorType() == HypervisorType.VMware) {	if (s_logger.isInfoEnabled()) {	}	if (s_logger.isDebugEnabled()) {	
added management server explicit route to elb vm 

}	String domain = guestNetwork.getNetworkDomain();	if (domain != null) {	buf.append(" domain=" + domain);	}	buf.append(" dns1=").append(defaultDns1);	if (defaultDns2 != null) {	buf.append(" dns2=").append(defaultDns2);	}	if (s_logger.isDebugEnabled()) {	
boot args for 

} else {	for (NicProfile nic : profile.getNics()) {	if (nic.getTrafficType() == TrafficType.Control && nic.getIPv4Address() != null) {	controlNic = nic;	} else if (nic.getTrafficType() == TrafficType.Guest) {	guestNetworkId = nic.getNetworkId();	}	}	}	if (controlNic == null) {	
control network doesn t exist for the elb vm 

List<LoadBalancerVO> lbs = _elbVmMapDao.listLbsForElbVm(elbVm.getId());	List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();	for (LoadBalancerVO lb : lbs) {	List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());	List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());	List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());	Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();	LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp);	lbRules.add(loadBalancing);	}	
found load balancing rule s to apply as a part of elb vm start 

========================= cloudstack sample_1897 =========================

private Boolean filter(Class<?> cls, Object... parameters) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {	String filterMethod = filterMethodPrefix + getClassName(cls);	Method method = _methodMap.get(filterMethod);	if (method == null) {	
method not implemented 

private Boolean equal(Class<?> cls, Object... parameters) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {	String equalMethod = equalMethodPrefix + getClassName(cls);	Method method = _methodMap.get(equalMethod);	if (method == null) {	
method not implemented 

public boolean syncGeneric(Class<?> cls, List<?> dbList, List<?> vncList) throws Exception {	SyncStats stats = new SyncStats();	stats.log("Sync log for <" + getClassName(cls) + ">");	
generic db sync 

public boolean syncGeneric(Class<?> cls, List<?> dbList, List<?> vncList) throws Exception {	SyncStats stats = new SyncStats();	stats.log("Sync log for <" + getClassName(cls) + ">");	java.util.Collections.sort(dbList, this.dbComparator(cls));	java.util.Collections.sort(vncList, this.vncComparator(cls));	syncCollections(cls, dbList, vncList, _syncMode != SYNC_MODE_CHECK, stats);	if (_syncMode != SYNC_MODE_CHECK) {	
sync stats 

public boolean syncGeneric(Class<?> cls, List<?> dbList, List<?> vncList) throws Exception {	SyncStats stats = new SyncStats();	stats.log("Sync log for <" + getClassName(cls) + ">");	java.util.Collections.sort(dbList, this.dbComparator(cls));	java.util.Collections.sort(vncList, this.vncComparator(cls));	syncCollections(cls, dbList, vncList, _syncMode != SYNC_MODE_CHECK, stats);	if (_syncMode != SYNC_MODE_CHECK) {	s_logger.debug(stats.logMsg);	
generic db sync done 

public boolean syncGeneric(Class<?> cls, List<?> dbList, List<?> vncList) throws Exception {	SyncStats stats = new SyncStats();	stats.log("Sync log for <" + getClassName(cls) + ">");	java.util.Collections.sort(dbList, this.dbComparator(cls));	java.util.Collections.sort(vncList, this.vncComparator(cls));	syncCollections(cls, dbList, vncList, _syncMode != SYNC_MODE_CHECK, stats);	if (_syncMode != SYNC_MODE_CHECK) {	s_logger.debug(stats.logMsg);	} else {	
sync state checking stats 

public boolean syncGeneric(Class<?> cls, List<?> dbList, List<?> vncList) throws Exception {	SyncStats stats = new SyncStats();	stats.log("Sync log for <" + getClassName(cls) + ">");	java.util.Collections.sort(dbList, this.dbComparator(cls));	java.util.Collections.sort(vncList, this.vncComparator(cls));	syncCollections(cls, dbList, vncList, _syncMode != SYNC_MODE_CHECK, stats);	if (_syncMode != SYNC_MODE_CHECK) {	s_logger.debug(stats.logMsg);	} else {	if (!stats.isSynchronized()) {	
db and vnc objects out of sync is detected 

public boolean syncGeneric(Class<?> cls, List<?> dbList, List<?> vncList) throws Exception {	SyncStats stats = new SyncStats();	stats.log("Sync log for <" + getClassName(cls) + ">");	java.util.Collections.sort(dbList, this.dbComparator(cls));	java.util.Collections.sort(vncList, this.vncComparator(cls));	syncCollections(cls, dbList, vncList, _syncMode != SYNC_MODE_CHECK, stats);	if (_syncMode != SYNC_MODE_CHECK) {	s_logger.debug(stats.logMsg);	} else {	if (!stats.isSynchronized()) {	
log message 

SyncStats stats = new SyncStats();	stats.log("Sync log for <" + getClassName(cls) + ">");	java.util.Collections.sort(dbList, this.dbComparator(cls));	java.util.Collections.sort(vncList, this.vncComparator(cls));	syncCollections(cls, dbList, vncList, _syncMode != SYNC_MODE_CHECK, stats);	if (_syncMode != SYNC_MODE_CHECK) {	s_logger.debug(stats.logMsg);	} else {	if (!stats.isSynchronized()) {	} else {	
db and vnc objects are in sync 

========================= cloudstack sample_1878 =========================

return false;	}	if (network.getVpcId() != null) {	return false;	}	if (!_networkMdl.isProviderEnabledInPhysicalNetwork(physicalNetworkId, Network.Provider.VirtualRouter.getName())) {	return false;	}	if (service == null) {	if (!_networkMdl.isProviderForNetwork(getProvider(), network.getId())) {	
element is not a provider for the network 

}	if (!_networkMdl.isProviderEnabledInPhysicalNetwork(physicalNetworkId, Network.Provider.VirtualRouter.getName())) {	return false;	}	if (service == null) {	if (!_networkMdl.isProviderForNetwork(getProvider(), network.getId())) {	return false;	}	} else {	if (!_networkMdl.isProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {	
element doesn t support service in the network 

public boolean applyFWRules(final Network network, final List<? extends FirewallRule> rules) throws ResourceUnavailableException {	boolean result = true;	if (canHandle(network, Service.Firewall)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to apply firewall rules on the backend virtual router doesn t exist in the network 

public static boolean validateHAProxyLBRule(final LoadBalancingRule rule) {	final String timeEndChar = "dhms";	if (rule.getSourcePortStart() == NetUtils.HAPROXY_STATS_PORT) {	
can t create lb on port haproxy is listening for lb stats on this port 

public boolean applyLBRules(final Network network, final List<LoadBalancingRule> rules) throws ResourceUnavailableException {	boolean result = true;	if (canHandle(network, Service.Lb)) {	if (!canHandleLbRules(rules)) {	return false;	}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to apply lb rules on the backend virtual router doesn t exist in the network 

public String[] applyVpnUsers(final RemoteAccessVpn vpn, final List<? extends VpnUser> users) throws ResourceUnavailableException {	if (vpn.getNetworkId() == null) {	return null;	}	final Network network = _networksDao.findById(vpn.getNetworkId());	if (canHandle(network, Service.Vpn)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to apply vpn users on the backend virtual router doesn t exist in the network 

final Network network = _networksDao.findById(vpn.getNetworkId());	if (canHandle(network, Service.Vpn)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	return null;	}	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	final NetworkTopology networkTopology = networkTopologyContext.retrieveNetworkTopology(dcVO);	return networkTopology.applyVpnUsers(network, users, routers);	} else {	
element doesn t handle applyvpnusers command 

public boolean startVpn(final RemoteAccessVpn vpn) throws ResourceUnavailableException {	if (vpn.getNetworkId() == null) {	return false;	}	final Network network = _networksDao.findById(vpn.getNetworkId());	if (canHandle(network, Service.Vpn)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need stop vpn on the backend virtual router doesn t exist in the network 

return false;	}	final Network network = _networksDao.findById(vpn.getNetworkId());	if (canHandle(network, Service.Vpn)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	return true;	}	return _routerMgr.startRemoteAccessVpn(network, vpn, routers);	} else {	
element doesn t handle createvpn command 

public boolean stopVpn(final RemoteAccessVpn vpn) throws ResourceUnavailableException {	if (vpn.getNetworkId() == null) {	return false;	}	final Network network = _networksDao.findById(vpn.getNetworkId());	if (canHandle(network, Service.Vpn)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need stop vpn on the backend virtual router doesn t exist in the network 

return false;	}	final Network network = _networksDao.findById(vpn.getNetworkId());	if (canHandle(network, Service.Vpn)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	return true;	}	return _routerMgr.deleteRemoteAccessVpn(network, vpn, routers);	} else {	
element doesn t handle removevpn command 

for (final Service service : services) {	if (!canHandle(network, service)) {	canHandle = false;	break;	}	}	boolean result = true;	if (canHandle) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to associate ip addresses on the backend virtual router doesn t exist in the network 

public boolean applyStaticNats(final Network network, final List<? extends StaticNat> rules) throws ResourceUnavailableException {	boolean result = true;	if (canHandle(network, Service.StaticNat)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to apply static nat on the backend virtual router doesn t exist in the network 

public boolean shutdown(final Network network, final ReservationContext context, final boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	return true;	}	boolean stopResult = true;	boolean destroyResult = true;	for (final DomainRouterVO router : routers) {	stopResult = stopResult && _routerMgr.stop(router, false, context.getCaller(), context.getAccount()) != null;	if (!stopResult) {	
failed to stop virtual router element but would try to process clean up anyway 

}	boolean stopResult = true;	boolean destroyResult = true;	for (final DomainRouterVO router : routers) {	stopResult = stopResult && _routerMgr.stop(router, false, context.getCaller(), context.getAccount()) != null;	if (!stopResult) {	}	if (cleanup) {	destroyResult = destroyResult && _routerMgr.destroyRouter(router.getId(), context.getAccount(), context.getCaller().getId()) != null;	if (!destroyResult) {	
failed to clean up virtual router element 

public boolean savePassword(final Network network, final NicProfile nic, final VirtualMachineProfile vm) throws ResourceUnavailableException {	if (!canHandle(network, null)) {	return false;	}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
can t find virtual router element in network 

public boolean saveSSHKey(final Network network, final NicProfile nic, final VirtualMachineProfile vm, final String sshPublicKey) throws ResourceUnavailableException {	if (!canHandle(network, null)) {	return false;	}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
can t find virtual router element in network 

public boolean saveUserData(final Network network, final NicProfile nic, final VirtualMachineProfile vm) throws ResourceUnavailableException {	if (!canHandle(network, null)) {	return false;	}	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
can t find virtual router element in network 

public VirtualRouterProvider configure(final ConfigureVirtualRouterElementCmd cmd) {	final VirtualRouterProviderVO element = _vrProviderDao.findById(cmd.getId());	if (element == null || !(element.getType() == Type.VirtualRouter || element.getType() == Type.VPCVirtualRouter)) {	
can t find virtual router element with network service provider id 

public OvsProvider configure(final ConfigureOvsElementCmd cmd) {	final OvsProviderVO element = _ovsProviderDao.findById(cmd.getId());	if (element == null) {	
can t find ovs element with network service provider id 

public VirtualRouterProvider addElement(final Long nspId, final Type providerType) {	if (!(providerType == Type.VirtualRouter || providerType == Type.VPCVirtualRouter)) {	throw new InvalidParameterValueException("Element " + getName() + " supports only providerTypes: " + Type.VirtualRouter.toString() + " and " + Type.VPCVirtualRouter);	}	VirtualRouterProviderVO element = _vrProviderDao.findByNspIdAndType(nspId, providerType);	if (element != null) {	
there is already a virtual router element with service provider id 

public boolean applyPFRules(final Network network, final List<PortForwardingRule> rules) throws ResourceUnavailableException {	boolean result = true;	if (canHandle(network, Service.PortForwarding)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.isEmpty()) {	
virtual router elemnt doesn t need to apply firewall rules on the backend virtual router doesn t exist in the network 

public boolean removeDhcpSupportForSubnet(final Network network) throws ResourceUnavailableException {	if (canHandle(network, Service.Dhcp)) {	final List<DomainRouterVO> routers = _routerDao.listByNetworkAndRole(network.getId(), Role.VIRTUAL_ROUTER);	if (routers == null || routers.size() == 0) {	throw new ResourceUnavailableException("Can't find at least one router!", DataCenter.class, network.getDataCenterId());	}	try {	return _routerMgr.removeDhcpSupportForSubnet(network, routers);	} catch (final ResourceUnavailableException e) {	
router resource unavailable 

public boolean addPasswordAndUserdata(final Network network, final NicProfile nic, final VirtualMachineProfile vm, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {	boolean result = true;	if (canHandle(network, Service.UserData)) {	if (vm.getType() != VirtualMachine.Type.User) {	return false;	}	if (network.getIp6Gateway() != null) {	
skip password and userdata service setup for vm 

private boolean canHandleLbRules(final List<LoadBalancingRule> rules) {	final Map<Capability, String> lbCaps = getCapabilities().get(Service.Lb);	if (!lbCaps.isEmpty()) {	final String schemeCaps = lbCaps.get(Capability.LbSchemes);	if (schemeCaps != null) {	for (final LoadBalancingRule rule : rules) {	if (!schemeCaps.contains(rule.getScheme().toString())) {	
scheme is not supported by the provider 

return true;	}	if (vm.getType() == VirtualMachine.Type.DomainRouter) {	assert vm instanceof DomainRouterVO;	final DomainRouterVO router = (DomainRouterVO) vm.getVirtualMachine();	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	final NetworkTopology networkTopology = networkTopologyContext.retrieveNetworkTopology(dcVO);	try {	networkTopology.setupDhcpForPvlan(false, router, router.getHostId(), nic);	} catch (final ResourceUnavailableException e) {	
timed out 

return;	}	if (vm.getType() == VirtualMachine.Type.DomainRouter) {	assert vm instanceof DomainRouterVO;	final DomainRouterVO router = (DomainRouterVO) vm.getVirtualMachine();	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	final NetworkTopology networkTopology = networkTopologyContext.retrieveNetworkTopology(dcVO);	try {	networkTopology.setupDhcpForPvlan(true, router, router.getHostId(), nic);	} catch (final ResourceUnavailableException e) {	
timed out 

return;	}	if (vm.getType() == VirtualMachine.Type.DomainRouter) {	assert vm instanceof DomainRouterVO;	final DomainRouterVO router = (DomainRouterVO) vm.getVirtualMachine();	final DataCenterVO dcVO = _dcDao.findById(network.getDataCenterId());	final NetworkTopology networkTopology = networkTopologyContext.retrieveNetworkTopology(dcVO);	try {	networkTopology.setupDhcpForPvlan(true, router, router.getHostId(), nic);	} catch (final ResourceUnavailableException e) {	
timed out 

========================= cloudstack sample_2307 =========================

public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException {	try {	_storageNetworkService.deleteIpRange(this);	SuccessResponse response = new SuccessResponse(getCommandName());	this.setResponseObject(response);	} catch (Exception e) {	
failed to delete storage network ip range 

========================= cloudstack sample_3146 =========================

if (vmr.powerState == VmPowerState.RUNNING && !citrixResourceBase.isRefNull(vmr.residentOn) && !vmr.residentOn.getUuid(conn).equals(citrixResourceBase.getHost().getUuid())) {	final String msg = "Stop Vm " + vmName + " failed due to this vm is not running on this host: " + citrixResourceBase.getHost().getUuid() + " but host:" + vmr.residentOn.getUuid(conn);	s_logger.warn(msg);	return new StopAnswer(command, msg, platformstring, false);	}	if (command.checkBeforeCleanup() && vmr.powerState == VmPowerState.RUNNING) {	final String msg = "Vm " + vmName + " is running on host and checkBeforeCleanup flag is set, so bailing out";	s_logger.debug(msg);	return new StopAnswer(command, msg, false);	}	
the vm is in stopping state 

final String msg = "Vm " + vmName + " is running on host and checkBeforeCleanup flag is set, so bailing out";	s_logger.debug(msg);	return new StopAnswer(command, msg, false);	}	try {	if (vmr.powerState == VmPowerState.RUNNING) {	vm.setAffinity(conn, vm.getResidentOn(conn));	if (citrixResourceBase.canBridgeFirewall()) {	final String result = citrixResourceBase.callHostPlugin(conn, "vmops", "destroy_network_rules_for_vm", "vmName", command.getVmName());	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	
failed to remove network rules for vm 

s_logger.debug(msg);	return new StopAnswer(command, msg, false);	}	try {	if (vmr.powerState == VmPowerState.RUNNING) {	vm.setAffinity(conn, vm.getResidentOn(conn));	if (citrixResourceBase.canBridgeFirewall()) {	final String result = citrixResourceBase.callHostPlugin(conn, "vmops", "destroy_network_rules_for_vm", "vmName", command.getVmName());	if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {	} else {	
removed network rules for vm 

final String msg = "Catch exception " + e.getClass().getName() + " when stop VM:" + command.getVmName() + " due to " + e.toString();	s_logger.debug(msg);	return new StopAnswer(command, msg, platformstring, false);	} finally {	try {	if (vm.getPowerState(conn) == VmPowerState.HALTED) {	Set<VGPU> vGPUs = null;	try {	vGPUs = vm.getVGPUs(conn);	} catch (final XenAPIException e2) {	
vm does not have gpu support 

}	} catch (final Exception e) {	}	}	return new StopAnswer(command, "Stop VM " + vmName + " Succeed", platformstring, true);	}	} catch (final Exception e) {	final String msg = "VM destroy failed in Stop " + vmName + " Command due to " + e.getMessage();	s_logger.warn(msg, e);	} finally {	
the vm is in stopped state 

========================= cloudstack sample_1205 =========================

public boolean configure(String name, Map<String, Object> params) {	final Map<String, String> configs = _configDao.getConfiguration("management-server", params);	_proxy = configs.get(Config.SecStorageProxy.key());	String cert = configs.get("secstorage.ssl.cert.domain");	if (!"realhostip.com".equalsIgnoreCase(cert)) {	
only realhostip com ssl cert is supported ignoring self signed and other certs 

}	EndPoint ep = _epSelector.select(template);	if (ep == null) {	String errMsg = "There is no secondary storage VM for downloading template to image store " + store.getName();	s_logger.warn(errMsg);	throw new CloudRuntimeException(errMsg);	}	DownloadListener dl = new DownloadListener(ep, store, template, _timer, this, dcmd, callback);	ComponentContext.inject(dl);	if (downloadJobExists) {	
found existing download job 

throw new CloudRuntimeException(errMsg);	}	DownloadListener dl = new DownloadListener(ep, store, template, _timer, this, dcmd, callback);	ComponentContext.inject(dl);	if (downloadJobExists) {	dl.setCurrState(vmTemplateStore.getDownloadState());	}	try {	ep.sendMessageAsync(dcmd, new UploadListener.Callback(ep.getId(), dl));	} catch (Exception e) {	
unable to start resume download of template to 

public void downloadTemplateToStorage(DataObject template, AsyncCompletionCallback<DownloadAnswer> callback) {	if(template != null) {	long templateId = template.getId();	DataStore store = template.getDataStore();	if (isTemplateUpdateable(templateId, store.getId())) {	if (template.getUri() != null) {	initiateTemplateDownload(template, callback);	} else {	
template url is null cannot download 

long templateId = template.getId();	DataStore store = template.getDataStore();	if (isTemplateUpdateable(templateId, store.getId())) {	if (template.getUri() != null) {	initiateTemplateDownload(template, callback);	} else {	DownloadAnswer ans = new DownloadAnswer("Template url is null", Status.UNKNOWN);	callback.complete(ans);	}	} else {	
template download is already in progress or already downloaded 

start();	Volume vol = _volumeDao.findById(volume.getId());	DownloadCommand dcmd = new DownloadCommand((VolumeObjectTO)(volume.getTO()), maxVolumeSizeInBytes, checkSum, url, format);	dcmd.setProxy(getHttpProxy());	if (downloadJobExists) {	dcmd = new DownloadProgressCommand(dcmd, volumeHost.getJobId(), RequestType.GET_OR_RESTART);	dcmd.setResourceType(ResourceType.VOLUME);	}	EndPoint ep = _epSelector.select(volume);	if (ep == null) {	
there is no secondary storage vm for image store 

return;	}	DownloadListener dl = new DownloadListener(ep, store, volume, _timer, this, dcmd, callback);	ComponentContext.inject(dl);	if (downloadJobExists) {	dl.setCurrState(volumeHost.getDownloadState());	}	try {	ep.sendMessageAsync(dcmd, new UploadListener.Callback(ep.getId(), dl));	} catch (Exception e) {	
unable to start resume download of volume to 

========================= cloudstack sample_2429 =========================

public static void createPortProfile(VmwareContext context, String ethPortProfileName, String networkName, Integer vlanId, Integer networkRateMbps, long peakBandwidth, long burstSize, String gateway, boolean configureVServiceInNexus) throws Exception {	Map<String, String> vsmCredentials = getValidatedVsmCredentials(context);	String vsmIp = vsmCredentials.get("vsmip");	String vsmUserName = vsmCredentials.get("vsmusername");	String vsmPassword = vsmCredentials.get("vsmpassword");	String msg;	NetconfHelper netconfClient;	try {	
connecting to nexus 

public static void createPortProfile(VmwareContext context, String ethPortProfileName, String networkName, Integer vlanId, Integer networkRateMbps, long peakBandwidth, long burstSize, String gateway, boolean configureVServiceInNexus) throws Exception {	Map<String, String> vsmCredentials = getValidatedVsmCredentials(context);	String vsmIp = vsmCredentials.get("vsmip");	String vsmUserName = vsmCredentials.get("vsmusername");	String vsmPassword = vsmCredentials.get("vsmpassword");	String msg;	NetconfHelper netconfClient;	try {	netconfClient = new NetconfHelper(vsmIp, vsmUserName, vsmPassword);	
successfully connected to nexus 

throw new CloudRuntimeException(msg);	}	String policyName = s_policyNamePrefix;	int averageBandwidth = 0;	if (networkRateMbps != null) {	averageBandwidth = networkRateMbps.intValue();	policyName += averageBandwidth;	}	try {	if (averageBandwidth > 0) {	
adding policy map 

}	try {	if (averageBandwidth > 0) {	netconfClient.addPolicyMap(policyName, averageBandwidth, (int)peakBandwidth, (int)burstSize);	}	} catch (CloudRuntimeException e) {	msg = "Failed to add policy map of " + policyName + " with parameters " + "committed rate = " + averageBandwidth + "peak bandwidth = " + peakBandwidth + "burst size = " + burstSize + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	if (vlanId != null) {	params.add(new Pair<OperationType, String>(OperationType.addvlanid, vlanId.toString()));	try {	
updating ethernet port profile with vlan 

if (netconfClient != null) {	netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	if (vlanId != null) {	params.add(new Pair<OperationType, String>(OperationType.addvlanid, vlanId.toString()));	try {	netconfClient.updatePortProfile(ethPortProfileName, SwitchPortMode.trunk, params);	
added to ethernet port profile 

List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	if (vlanId != null) {	params.add(new Pair<OperationType, String>(OperationType.addvlanid, vlanId.toString()));	try {	netconfClient.updatePortProfile(ethPortProfileName, SwitchPortMode.trunk, params);	} catch (CloudRuntimeException e) {	msg = "Failed to update Ethernet port profile " + ethPortProfileName + " with VLAN " + vlanId + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

msg = "Failed to update Ethernet port profile " + ethPortProfileName + " with VLAN " + vlanId + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	}	try {	if (vlanId == null) {	
adding port profile configured over untagged vlan 

netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	}	try {	if (vlanId == null) {	netconfClient.addPortProfile(networkName, PortProfileType.vethernet, BindingType.portbindingstatic, SwitchPortMode.access, 0);	} else {	if (!configureVServiceInNexus) {	
adding port profile configured over vlan 

try {	if (vlanId == null) {	netconfClient.addPortProfile(networkName, PortProfileType.vethernet, BindingType.portbindingstatic, SwitchPortMode.access, 0);	} else {	if (!configureVServiceInNexus) {	netconfClient.addPortProfile(networkName, PortProfileType.vethernet, BindingType.portbindingstatic, SwitchPortMode.access, vlanId.intValue());	} else {	String tenant = "vlan-" + vlanId.intValue();	String vdc = "root/" + tenant + "/VDC-" + tenant;	String esp = "ESP-" + tenant;	
adding vservice node in nexus vsm for vlan 

if (vlanId == null) {	netconfClient.addPortProfile(networkName, PortProfileType.vethernet, BindingType.portbindingstatic, SwitchPortMode.access, 0);	} else {	if (!configureVServiceInNexus) {	netconfClient.addPortProfile(networkName, PortProfileType.vethernet, BindingType.portbindingstatic, SwitchPortMode.access, vlanId.intValue());	} else {	String tenant = "vlan-" + vlanId.intValue();	String vdc = "root/" + tenant + "/VDC-" + tenant;	String esp = "ESP-" + tenant;	netconfClient.addVServiceNode(vlanId.toString(), gateway);	
adding port profile with vservice details configured over vlan 

String esp = "ESP-" + tenant;	netconfClient.addVServiceNode(vlanId.toString(), gateway);	netconfClient.addPortProfile(networkName, PortProfileType.vethernet, BindingType.portbindingstatic, SwitchPortMode.access, vlanId.intValue(), vdc, esp);	}	}	} catch (CloudRuntimeException e) {	msg = "Failed to add vEthernet port profile " + networkName + "." + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

} catch (CloudRuntimeException e) {	msg = "Failed to add vEthernet port profile " + networkName + "." + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	try {	if (averageBandwidth > 0) {	
associating policy map with port profile 

if (averageBandwidth > 0) {	netconfClient.attachServicePolicy(policyName, networkName);	}	} catch (CloudRuntimeException e) {	msg = "Failed to associate policy map " + policyName + " with port profile " + networkName + ". Exception: " + e.toString();	s_logger.error(msg);	throw new CloudRuntimeException(msg);	} finally {	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

PortProfile portProfile = netconfClient.getPortProfileByName(vethPortProfileName);	int averageBandwidth = 0;	String policyName = s_policyNamePrefix;	if (networkRateMbps != null) {	averageBandwidth = networkRateMbps.intValue();	policyName += averageBandwidth;	}	if (averageBandwidth > 0) {	PolicyMap policyMap = netconfClient.getPolicyMapByName(portProfile.inputPolicyMap);	if (policyMap.committedRate == averageBandwidth && policyMap.peakRate == peakBandwidth && policyMap.burstRate == burstRate) {	
detected that policy map is already applied to port profile 

String policyName = s_policyNamePrefix;	if (networkRateMbps != null) {	averageBandwidth = networkRateMbps.intValue();	policyName += averageBandwidth;	}	if (averageBandwidth > 0) {	PolicyMap policyMap = netconfClient.getPolicyMapByName(portProfile.inputPolicyMap);	if (policyMap.committedRate == averageBandwidth && policyMap.peakRate == peakBandwidth && policyMap.burstRate == burstRate) {	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

}	if (averageBandwidth > 0) {	PolicyMap policyMap = netconfClient.getPolicyMapByName(portProfile.inputPolicyMap);	if (policyMap.committedRate == averageBandwidth && policyMap.peakRate == peakBandwidth && policyMap.burstRate == burstRate) {	if (netconfClient != null) {	netconfClient.disconnect();	}	return;	} else {	try {	
adding policy map 

}	return;	} else {	try {	netconfClient.addPolicyMap(policyName, averageBandwidth, (int)peakBandwidth, (int)burstRate);	} catch (CloudRuntimeException e) {	msg = "Failed to add policy map of " + policyName + " with parameters " + "committed rate = " + averageBandwidth + "peak bandwidth = " + peakBandwidth + "burst size = " + burstRate + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

netconfClient.addPolicyMap(policyName, averageBandwidth, (int)peakBandwidth, (int)burstRate);	} catch (CloudRuntimeException e) {	msg = "Failed to add policy map of " + policyName + " with parameters " + "committed rate = " + averageBandwidth + "peak bandwidth = " + peakBandwidth + "burst size = " + burstRate + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	try {	
associating policy map with port profile 

}	throw new CloudRuntimeException(msg);	}	try {	netconfClient.attachServicePolicy(policyName, vethPortProfileName);	} catch (CloudRuntimeException e) {	msg = "Failed to associate policy map " + policyName + " with port profile " + vethPortProfileName + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

msg = "Failed to associate policy map " + policyName + " with port profile " + vethPortProfileName + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	}	}	if (vlanId == null) {	
skipping update operation over ethernet port profile for untagged vlan 

if (netconfClient != null) {	netconfClient.disconnect();	}	throw new CloudRuntimeException(msg);	}	}	}	if (vlanId == null) {	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

if (netconfClient != null) {	netconfClient.disconnect();	}	return;	}	String currentVlan = portProfile.vlan;	String newVlan = Integer.toString(vlanId.intValue());	if (currentVlan.equalsIgnoreCase(newVlan)) {	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

String newVlan = Integer.toString(vlanId.intValue());	if (currentVlan.equalsIgnoreCase(newVlan)) {	if (netconfClient != null) {	netconfClient.disconnect();	}	return;	}	List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	params.add(new Pair<OperationType, String>(OperationType.addvlanid, newVlan));	try {	
updating vethernet port profile with vlan 

}	List<Pair<OperationType, String>> params = new ArrayList<Pair<OperationType, String>>();	params.add(new Pair<OperationType, String>(OperationType.addvlanid, newVlan));	try {	netconfClient.updatePortProfile(ethPortProfileName, SwitchPortMode.trunk, params);	} catch (CloudRuntimeException e) {	msg = "Failed to update ethernet port profile " + ethPortProfileName + " with parameters " + params.toString() + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

}	throw new CloudRuntimeException(msg);	}	try {	netconfClient.updatePortProfile(vethPortProfileName, SwitchPortMode.access, params);	} catch (CloudRuntimeException e) {	msg = "Failed to update vEthernet port profile " + vethPortProfileName + " with parameters " + params.toString() + ". Exception: " + e.toString();	s_logger.error(msg);	if (netconfClient != null) {	netconfClient.disconnect();	
disconnected nexus session 

}	}	if (vSwitchType == VirtualSwitchType.VMwareDistributedVirtualSwitch) {	DVSTrafficShapingPolicy shapingPolicy;	DVSSecurityPolicy secPolicy;	vcApiVersion = getVcenterApiVersion(context);	minVcApiVersionSupportingAutoExpand = "5.0";	autoExpandSupported = isFeatureSupportedInVcenterApiVersion(vcApiVersion, minVcApiVersionSupportingAutoExpand);	dvSwitchName = physicalNetwork;	if (dvSwitchName == null) {	
detected null dvswitch defaulting to 

dvSwitchName = physicalNetwork;	if (dvSwitchName == null) {	dvSwitchName = "dvSwitch0";	}	morDvSwitch = dataCenterMo.getDvSwitchMor(dvSwitchName);	if (morDvSwitch == null) {	String msg = "Unable to find distributed vSwitch " + dvSwitchName;	s_logger.error(msg);	throw new Exception(msg);	} else {	
found distributed vswitch 

portGroupPolicy.setVlanOverrideAllowed(true);	portGroupPolicy.setBlockOverrideAllowed(true);	portGroupPolicy.setPortConfigResetAtDisconnect(true);	}	createPortGroup(physicalNetwork, networkName, vid, spvlanid, dataCenterMo, shapingPolicy, secPolicy, portGroupPolicy, dvSwitchMo, numPorts, autoExpandSupported);	bWaitPortGroupReady = true;	}	} else if (vSwitchType == VirtualSwitchType.NexusDistributedVirtualSwitch) {	ethPortProfileName = physicalNetwork;	if (ethPortProfileName == null) {	
detected null ethrenet port profile defaulting to 

ethPortProfileName = physicalNetwork;	if (ethPortProfileName == null) {	ethPortProfileName = "epp0";	}	morEthernetPortProfile = dataCenterMo.getDvPortGroupMor(ethPortProfileName);	if (morEthernetPortProfile == null) {	String msg = "Unable to find Ethernet port profile " + ethPortProfileName;	s_logger.error(msg);	throw new Exception(msg);	} else {	
found ethernet port profile 

throw new Exception(msg);	} else {	}	long averageBandwidth = 0L;	if (networkRateMbps != null && networkRateMbps.intValue() > 0) {	averageBandwidth = networkRateMbps.intValue() * 1024L * 1024L;	}	long peakBandwidth = (long)(averageBandwidth * 1.5);	long burstSize = 5 * averageBandwidth / 8;	if (vsmCredentials != null) {	
stocking credentials of nexus vsm 

long averageBandwidth = 0L;	if (networkRateMbps != null && networkRateMbps.intValue() > 0) {	averageBandwidth = networkRateMbps.intValue() * 1024L * 1024L;	}	long peakBandwidth = (long)(averageBandwidth * 1.5);	long burstSize = 5 * averageBandwidth / 8;	if (vsmCredentials != null) {	context.registerStockObject("vsmcredentials", vsmCredentials);	}	if (!dataCenterMo.hasDvPortGroup(networkName)) {	
port profile not found 

}	long peakBandwidth = (long)(averageBandwidth * 1.5);	long burstSize = 5 * averageBandwidth / 8;	if (vsmCredentials != null) {	context.registerStockObject("vsmcredentials", vsmCredentials);	}	if (!dataCenterMo.hasDvPortGroup(networkName)) {	createPortProfile(context, physicalNetwork, networkName, vid, networkRateMbps, peakBandwidth, burstSize, gateway, configureVServiceInNexus);	bWaitPortGroupReady = true;	} else {	
port profile found 

if (bWaitPortGroupReady) morNetwork = waitForDvPortGroupReady(dataCenterMo, networkName, timeOutMs);	else morNetwork = dataCenterMo.getDvPortGroupMor(networkName);	if (morNetwork == null) {	String msg = "Failed to create guest network " + networkName;	s_logger.error(msg);	throw new Exception(msg);	}	if (createGCTag) {	NetworkMO networkMo = new NetworkMO(hostMo.getContext(), morNetwork);	networkMo.setCustomFieldValue(CustomFieldConstants.CLOUD_GC_DVP, "true");	
added custom field 

if (!vid.equals(spvlanid) && !vlanmap.containsKey(spvlanid)) {	VMwareDVSPvlanConfigSpec spvlanConfigSpec = createDVPortPvlanConfigSpec(vid, spvlanid, PvlanType.isolated, PvlanOperation.add);	dvsSpec.getPvlanConfigSpec().add(spvlanConfigSpec);	}	if (dvsSpec.getPvlanConfigSpec().size() > 0) {	String dvsConfigVersion = dvSwitchMo.getDVSConfigVersion(morDvSwitch);	dvsSpec.setConfigVersion(dvsConfigVersion);	try {	dvSwitchMo.updateVMWareDVSwitchGetTask(morDvSwitch, dvsSpec);	} catch (AlreadyExistsFaultMsg e) {	
specified vlan id private vlan id tuple already configured on vmware dvswitch 

VMwareDVSPvlanConfigSpec spvlanConfigSpec = createDVPortPvlanConfigSpec(vid, spvlanid, PvlanType.isolated, PvlanOperation.add);	dvsSpec.getPvlanConfigSpec().add(spvlanConfigSpec);	}	if (dvsSpec.getPvlanConfigSpec().size() > 0) {	String dvsConfigVersion = dvSwitchMo.getDVSConfigVersion(morDvSwitch);	dvsSpec.setConfigVersion(dvsConfigVersion);	try {	dvSwitchMo.updateVMWareDVSwitchGetTask(morDvSwitch, dvsSpec);	} catch (AlreadyExistsFaultMsg e) {	} catch (Exception e) {	
failed to configure vlan pvlan tuple on vmware dvswitch failure message 

dvsPortSetting = createVmwareDVPortSettingSpec(shapingPolicy, secPolicy, vlanSpec);	} else if (spvlanid != null) {	pvlanSpec = createDVPortPvlanIdSpec(spvlanid);	dvsPortSetting = createVmwareDVPortSettingSpec(shapingPolicy, secPolicy, pvlanSpec);	}	newDvPortGroupSpec = createDvPortGroupSpec(networkName, dvsPortSetting, numPorts, autoExpandSupported);	if (portGroupPolicy != null) {	newDvPortGroupSpec.setPolicy(portGroupPolicy);	}	if (!dataCenterMo.hasDvPortGroup(networkName)) {	
distributed virtual port group not found 

}	if (!dataCenterMo.hasDvPortGroup(networkName)) {	try {	dvSwitchMo.createDVPortGroup(newDvPortGroupSpec);	} catch (Exception e) {	String msg = "Failed to create distributed virtual port group " + networkName + " on dvSwitch " + physicalNetwork;	msg += ". " + VmwareHelper.getExceptionMessage(e);	throw new Exception(msg);	}	} else {	
found distributed virtual port group 

try {	dvSwitchMo.createDVPortGroup(newDvPortGroupSpec);	} catch (Exception e) {	String msg = "Failed to create distributed virtual port group " + networkName + " on dvSwitch " + physicalNetwork;	msg += ". " + VmwareHelper.getExceptionMessage(e);	throw new Exception(msg);	}	} else {	DVPortgroupConfigInfo currentDvPortgroupInfo = dataCenterMo.getDvPortGroupSpec(networkName);	if (!isSpecMatch(currentDvPortgroupInfo, newDvPortGroupSpec)) {	
updating distributed virtual port group 

public static boolean isSpecMatch(DVPortgroupConfigInfo currentDvPortgroupInfo, DVPortgroupConfigSpec newDvPortGroupSpec) {	String dvPortGroupName = newDvPortGroupSpec.getName();	
checking if configuration of dvportgroup has changed 

if (newBurstSizePolicy != null) {	newBurstSize = newBurstSizePolicy.getValue();	}	if (newPeakBandwidthPolicy != null) {	newPeakBandwidth = newPeakBandwidthPolicy.getValue();	}	if (newIsEnabledPolicy != null) {	newIsEnabled = newIsEnabledPolicy.isValue();	}	if (!oldIsEnabled.equals(newIsEnabled)) {	
detected change in state of shaping policy enabled disabled 

newPeakBandwidth = newPeakBandwidthPolicy.getValue();	}	if (newIsEnabledPolicy != null) {	newIsEnabled = newIsEnabledPolicy.isValue();	}	if (!oldIsEnabled.equals(newIsEnabled)) {	specMatches = false;	}	if (oldIsEnabled || newIsEnabled) {	if (oldAverageBandwidth != null && !oldAverageBandwidth.equals(newAverageBandwidth)) {	
average bandwidth setting in new shaping policy doesn t match the existing setting 

if (newIsEnabledPolicy != null) {	newIsEnabled = newIsEnabledPolicy.isValue();	}	if (!oldIsEnabled.equals(newIsEnabled)) {	specMatches = false;	}	if (oldIsEnabled || newIsEnabled) {	if (oldAverageBandwidth != null && !oldAverageBandwidth.equals(newAverageBandwidth)) {	specMatches = false;	} else if (oldBurstSize != null && !oldBurstSize.equals(newBurstSize)) {	
burst size setting in new shaping policy doesn t match the existing setting 

}	if (!oldIsEnabled.equals(newIsEnabled)) {	specMatches = false;	}	if (oldIsEnabled || newIsEnabled) {	if (oldAverageBandwidth != null && !oldAverageBandwidth.equals(newAverageBandwidth)) {	specMatches = false;	} else if (oldBurstSize != null && !oldBurstSize.equals(newBurstSize)) {	specMatches = false;	} else if (oldPeakBandwidth != null && !oldPeakBandwidth.equals(newPeakBandwidth)) {	
peak bandwidth setting in new shaping policy doesn t match the existing setting 

}	boolean oldAutoExpandSetting = currentDvPortgroupInfo.isAutoExpand();	boolean autoExpandEnabled = newDvPortGroupSpec.isAutoExpand();	if (oldAutoExpandSetting != autoExpandEnabled) {	specMatches = false;	}	if (!autoExpandEnabled) {	int oldNumPorts = currentDvPortgroupInfo.getNumPorts();	int newNumPorts = newDvPortGroupSpec.getNumPorts();	if (oldNumPorts < newNumPorts) {	
need to update the number of dvports for dvportgroup from existing number of dvports to 

boolean autoExpandEnabled = newDvPortGroupSpec.isAutoExpand();	if (oldAutoExpandSetting != autoExpandEnabled) {	specMatches = false;	}	if (!autoExpandEnabled) {	int oldNumPorts = currentDvPortgroupInfo.getNumPorts();	int newNumPorts = newDvPortGroupSpec.getNumPorts();	if (oldNumPorts < newNumPorts) {	specMatches = false;	} else if (oldNumPorts > newNumPorts) {	
detected that new number of dvports in dvportgroup is less than existing number of dvports attempt to update this dvportgroup may fail 

specMatches = false;	} else if (oldNumPorts > newNumPorts) {	specMatches = false;	}	}	VmwareDistributedVirtualSwitchVlanIdSpec oldVlanSpec = (VmwareDistributedVirtualSwitchVlanIdSpec)(( VMwareDVSPortSetting)currentDvPortgroupInfo.getDefaultPortConfig()).getVlan();	VmwareDistributedVirtualSwitchVlanIdSpec newVlanSpec = (VmwareDistributedVirtualSwitchVlanIdSpec)(( VMwareDVSPortSetting)newDvPortGroupSpec.getDefaultPortConfig()).getVlan();	int oldVlanId = oldVlanSpec.getVlanId();	int newVlanId = newVlanSpec.getVlanId();	if (oldVlanId != newVlanId) {	
detected that new vlan of dvportgroup is different from current vlan 

public static ManagedObjectReference waitForDvPortGroupReady(DatacenterMO dataCenterMo, String dvPortGroupName, long timeOutMs) throws Exception {	ManagedObjectReference morDvPortGroup = null;	long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick <= timeOutMs) {	morDvPortGroup = dataCenterMo.getDvPortGroupMor(dvPortGroupName);	if (morDvPortGroup != null) {	break;	}	
waiting for dvportgroup to be ready 

assert (currentTrafficShapingPolicy != null);	LongPolicy averageBandwidth = currentTrafficShapingPolicy.getAverageBandwidth();	LongPolicy burstSize = currentTrafficShapingPolicy.getBurstSize();	LongPolicy peakBandwidth = currentTrafficShapingPolicy.getPeakBandwidth();	BoolPolicy isEnabled = currentTrafficShapingPolicy.getEnabled();	if (!isEnabled.equals(shapingPolicy.getEnabled())) {	return false;	}	if (averageBandwidth != null && !averageBandwidth.equals(shapingPolicy.getAverageBandwidth())) {	if (s_logger.isInfoEnabled()) {	
average bandwidth setting in shaping policy doesn t match with existing setting 

BoolPolicy isEnabled = currentTrafficShapingPolicy.getEnabled();	if (!isEnabled.equals(shapingPolicy.getEnabled())) {	return false;	}	if (averageBandwidth != null && !averageBandwidth.equals(shapingPolicy.getAverageBandwidth())) {	if (s_logger.isInfoEnabled()) {	}	return false;	} else if (burstSize != null && !burstSize.equals(shapingPolicy.getBurstSize())) {	if (s_logger.isInfoEnabled()) {	
burst size setting in shaping policy doesn t match with existing setting 

if (averageBandwidth != null && !averageBandwidth.equals(shapingPolicy.getAverageBandwidth())) {	if (s_logger.isInfoEnabled()) {	}	return false;	} else if (burstSize != null && !burstSize.equals(shapingPolicy.getBurstSize())) {	if (s_logger.isInfoEnabled()) {	}	return false;	} else if (peakBandwidth != null && !peakBandwidth.equals(shapingPolicy.getPeakBandwidth())) {	if (s_logger.isInfoEnabled()) {	
peak bandwidth setting in shaping policy doesn t match with existing setting 

public static Pair<ManagedObjectReference, String> prepareNetwork(String vSwitchName, String namePrefix, HostMO hostMo, String vlanId, Integer networkRateMbps, Integer networkRateMulticastMbps, long timeOutMs, boolean syncPeerHosts, BroadcastDomainType broadcastDomainType, String nicUuid) throws Exception {	HostVirtualSwitch vSwitch;	if (vSwitchName == null) {	
detected vswitch name as undefined defaulting to 

GlobalLock lock = GlobalLock.getInternLock("ClusterLock." + morParent.getValue());	try {	if (lock.lock(DEFAULT_LOCK_TIMEOUT_SECONDS)) {	try {	List<ManagedObjectReference> hosts = hostMo.getContext().getVimClient().getDynamicProperty(morParent, "host");	if (hosts != null) {	for (ManagedObjectReference otherHost : hosts) {	if (!otherHost.getValue().equals(hostMo.getMor().getValue())) {	HostMO otherHostMo = new HostMO(hostMo.getContext(), otherHost);	try {	
prepare network on other host vlan host 

if (lock.lock(DEFAULT_LOCK_TIMEOUT_SECONDS)) {	try {	List<ManagedObjectReference> hosts = hostMo.getContext().getVimClient().getDynamicProperty(morParent, "host");	if (hosts != null) {	for (ManagedObjectReference otherHost : hosts) {	if (!otherHost.getValue().equals(hostMo.getMor().getValue())) {	HostMO otherHostMo = new HostMO(hostMo.getContext(), otherHost);	try {	prepareNetwork(vSwitchName, namePrefix, otherHostMo, vlanId, networkRateMbps, networkRateMulticastMbps, timeOutMs, false, broadcastDomainType, nicUuid);	} catch (Exception e) {	
unable to prepare network on other host vlan host 

prepareNetwork(vSwitchName, namePrefix, otherHostMo, vlanId, networkRateMbps, networkRateMulticastMbps, timeOutMs, false, broadcastDomainType, nicUuid);	} catch (Exception e) {	}	}	}	}	} finally {	lock.unlock();	}	} else {	
unable to lock cluster to prepare guest network vlan 

} finally {	lock.unlock();	}	} else {	}	} finally {	lock.releaseRef();	}	}	}	
network is ready on vswitch 

public static ManagedObjectReference waitForNetworkReady(HostMO hostMo, String networkName, long timeOutMs) throws Exception {	ManagedObjectReference morNetwork = null;	long startTick = System.currentTimeMillis();	while (System.currentTimeMillis() - startTick <= timeOutMs) {	morNetwork = hostMo.getNetworkMor(networkName);	if (morNetwork != null) {	break;	}	
waiting for network to be ready 

public static boolean createBlankVm(VmwareHypervisorHost host, String vmName, String vmInternalCSName, int cpuCount, int cpuSpeedMHz, int cpuReservedMHz, boolean limitCpuUse, int memoryMB, int memoryReserveMB, String guestOsIdentifier, ManagedObjectReference morDs, boolean snapshotDirToParent, Pair<String, String> controllerInfo, Boolean systemVm) throws Exception {	
create blank vm cpucount cpuspeed mhz mem mb 

maxControllerCount = 1;	}	while (busNum < maxControllerCount) {	VirtualDeviceConfigSpec scsiControllerSpec = new VirtualDeviceConfigSpec();	scsiControllerSpec = getControllerSpec(DiskControllerType.getType(scsiDiskController).toString(), busNum);	vmConfig.getDeviceChange().add(scsiControllerSpec);	busNum++;	}	}	if (guestOsIdentifier.startsWith("darwin")) {	
add usb controller device for blank mac os vm 

videoDeviceSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	vmConfig.getDeviceChange().add(videoDeviceSpec);	if (host.createVm(vmConfig)) {	VirtualMachineMO vmMo = host.findVmOnHyperHost(vmName);	assert (vmMo != null);	vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_VM_INTERNAL_NAME, vmInternalCSName);	int ideControllerKey = -1;	while (ideControllerKey < 0) {	ideControllerKey = vmMo.tryGetIDEDeviceControllerKey();	if (ideControllerKey >= 0) break;	
waiting for ide controller be ready in vm 

VirtualDeviceConfigSpec scsiControllerSpec = new VirtualDeviceConfigSpec();	scsiControllerSpec.setDevice(scsiController);	scsiControllerSpec.setOperation(VirtualDeviceConfigSpecOperation.ADD);	vmConfig.getDeviceChange().add(scsiControllerSpec);	if (hyperHost.createVm(vmConfig)) {	for (int i = 0; i < 10 && workingVM == null; i++) {	workingVM = hyperHost.findVmOnHyperHost(vmName);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while waiting to config vm 

public static String resolveHostNameInUrl(DatacenterMO dcMo, String url) {	
resolving host name in url through vcenter url 

public static String resolveHostNameInUrl(DatacenterMO dcMo, String url) {	URI uri;	try {	uri = new URI(url);	} catch (URISyntaxException e) {	
urisyntaxexception on url 

public static String resolveHostNameInUrl(DatacenterMO dcMo, String url) {	URI uri;	try {	uri = new URI(url);	} catch (URISyntaxException e) {	return url;	}	String host = uri.getHost();	if (NetUtils.isValidIp(host)) {	
host name in url is already in ip address url 

}	try {	ManagedObjectReference morHost = dcMo.findHost(host);	if (morHost != null) {	HostMO hostMo = new HostMO(dcMo.getContext(), morHost);	String managementPortGroupName;	if (hostMo.getHostType() == VmwareHostType.ESXi) managementPortGroupName = (String)dcMo.getContext().getStockObject("manageportgroup");	else managementPortGroupName = (String)dcMo.getContext().getStockObject("serviceconsole");	VmwareHypervisorHostNetworkSummary summary = hostMo.getHyperHostNetworkSummary(managementPortGroupName);	if (summary == null) {	
unable to resolve host name in url through vsphere url 

String managementPortGroupName;	if (hostMo.getHostType() == VmwareHostType.ESXi) managementPortGroupName = (String)dcMo.getContext().getStockObject("manageportgroup");	else managementPortGroupName = (String)dcMo.getContext().getStockObject("serviceconsole");	VmwareHypervisorHostNetworkSummary summary = hostMo.getHyperHostNetworkSummary(managementPortGroupName);	if (summary == null) {	return url;	}	String hostIp = summary.getHostIp();	try {	URI resolvedUri = new URI(uri.getScheme(), uri.getUserInfo(), hostIp, uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());	
url is resolved to through vcenter 

String hostIp = summary.getHostIp();	try {	URI resolvedUri = new URI(uri.getScheme(), uri.getUserInfo(), hostIp, uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());	return resolvedUri.toString();	} catch (URISyntaxException e) {	assert (false);	return url;	}	}	} catch (Exception e) {	
unexpected exception 

}	}	final DOMSource domSource = new DOMSource(doc);	final StringWriter writer = new StringWriter();	final StreamResult result = new StreamResult(writer);	final TransformerFactory tf = TransformerFactory.newInstance();	final Transformer transformer = tf.newTransformer();	transformer.transform(domSource, result);	return writer.toString();	} catch (SAXException | IOException | ParserConfigurationException | TransformerException e) {	
unexpected exception caught while removing network elements from ovf 

String ovfDescriptor = removeOVFNetwork(HttpNfcLeaseMO.readOvfContent(ovfFilePath));	VmwareContext context = host.getContext();	OvfCreateImportSpecResult ovfImportResult = context.getService().createImportSpec(context.getServiceContent().getOvfManager(), ovfDescriptor, morRp, dsMo.getMor(), importSpecParams);	if (ovfImportResult == null) {	String msg = "createImportSpec() failed. ovfFilePath: " + ovfFilePath + ", vmName: " + vmName + ", diskOption: " + diskOption;	s_logger.error(msg);	throw new Exception(msg);	}	if(!ovfImportResult.getError().isEmpty()) {	for (LocalizedMethodFault fault : ovfImportResult.getError()) {	
createimportspec error 

s_logger.error(msg);	throw new Exception(msg);	}	if(!ovfImportResult.getError().isEmpty()) {	for (LocalizedMethodFault fault : ovfImportResult.getError()) {	}	throw new CloudException("Failed to create an import spec from " + ovfFilePath + ". Check log for details.");	}	if (!ovfImportResult.getWarning().isEmpty()) {	for (LocalizedMethodFault fault : ovfImportResult.getError()) {	
createimportspec warning 

}	} else if (state == HttpNfcLeaseState.ERROR) {	LocalizedMethodFault error = leaseMo.getLeaseError();	MethodFault fault = error.getFault();	String erroMsg = "Object creation on vCenter failed due to: Exception: " + fault.getClass().getName() + ", message: " + error.getLocalizedMessage();	s_logger.error(erroMsg);	throw new Exception(erroMsg);	}	} finally {	if (!importSuccess) {	
aborting the lease on after import operation failed 

========================= cloudstack sample_2079 =========================

public boolean start() {	for (NetworkElement element : _networkElements) {	Provider implementedProvider = element.getProvider();	if (implementedProvider != null) {	if (s_providerToNetworkElementMap.containsKey(implementedProvider.getName())) {	
cannot start mapnetworkmanager provider networkelement must be a one to one map multiple networkelements found for provider 

========================= cloudstack sample_2215 =========================

alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, pool.getDataCenterId(), pool.getPodId(), msg, msg);	throw new CloudRuntimeException("Unable establish connection from storage head to storage pool " + pool.getId() + " due to " + answer.getDetails() + pool.getId());	}	assert (answer instanceof ModifyStoragePoolAnswer) : "Well, now why won't you actually return the ModifyStoragePoolAnswer when it's ModifyStoragePoolCommand? Pool=" + pool.getId() + "Host=" + hostId;	ModifyStoragePoolAnswer mspAnswer = (ModifyStoragePoolAnswer)answer;	if (mspAnswer.getLocalDatastoreName() != null && pool.isShared()) {	String datastoreName = mspAnswer.getLocalDatastoreName();	List<StoragePoolVO> localStoragePools = this.primaryStoreDao.listLocalStoragePoolByPath(pool.getDataCenterId(), datastoreName);	for (StoragePoolVO localStoragePool : localStoragePools) {	if (datastoreName.equals(localStoragePool.getPath())) {	
storage pool has already been added as local storage 

}	StoragePoolHostVO poolHost = storagePoolHostDao.findByPoolHost(pool.getId(), hostId);	if (poolHost == null) {	poolHost = new StoragePoolHostVO(pool.getId(), hostId, mspAnswer.getPoolInfo().getLocalPath().replaceAll(" storagePoolHostDao.persist(poolHost);	} else {	poolHost.setLocalPath(mspAnswer.getPoolInfo().getLocalPath().replaceAll(" }	StoragePoolVO poolVO = this.primaryStoreDao.findById(poolId);	poolVO.setUsedBytes(mspAnswer.getPoolInfo().getCapacityBytes() - mspAnswer.getPoolInfo().getAvailableBytes());	poolVO.setCapacityBytes(mspAnswer.getPoolInfo().getCapacityBytes());	primaryStoreDao.update(pool.getId(), poolVO);	
connection established between storage pool and host 

========================= cloudstack sample_3957 =========================

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	final String run = "usage.vmops.pid";	if (s_logger.isDebugEnabled()) {	
checking to see if exists 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	final String run = "usage.vmops.pid";	if (s_logger.isDebugEnabled()) {	}	final Class<?> c = UsageServer.class;	_version = c.getPackage().getImplementationVersion();	if (_version == null) _version="unknown";	if (s_logger.isInfoEnabled()) {	
implementation version is 

String aggreagationTimeZone = configs.get("usage.aggregation.timezone");	String sanityCheckInterval = configs.get("usage.sanity.check.interval");	String quotaEnable = configs.get("quota.enable.service");	_runQuota = Boolean.valueOf(quotaEnable == null ? "false" : quotaEnable );	if (sanityCheckInterval != null) {	_sanityCheckInterval = Integer.parseInt(sanityCheckInterval);	}	if (aggreagationTimeZone != null && !aggreagationTimeZone.isEmpty()) {	_usageTimezone = TimeZone.getTimeZone(aggreagationTimeZone);	}	
usage stats aggregation time zone 

if (aggreagationTimeZone != null && !aggreagationTimeZone.isEmpty()) {	_usageTimezone = TimeZone.getTimeZone(aggreagationTimeZone);	}	try {	if ((execTime == null) || (aggregationRange == null)) {	s_logger.error("missing configuration values for usage job, usage.stats.job.exec.time = " + execTime + ", usage.stats.job.aggregation.range = " + aggregationRange);	throw new ConfigurationException("Missing configuration values for usage job, usage.stats.job.exec.time = " + execTime + ", usage.stats.job.aggregation.range = " + aggregationRange);	}	String[] execTimeSegments = execTime.split(":");	if (execTimeSegments.length != 2) {	
unable to parse usage stats job exec time 

_jobExecTime.set(Calendar.MINUTE, minutes);	_jobExecTime.set(Calendar.SECOND, 0);	_jobExecTime.set(Calendar.MILLISECOND, 0);	if (execTimeZone != null && !execTimeZone.isEmpty()) {	_jobExecTime.setTimeZone(TimeZone.getTimeZone(execTimeZone));	}	Date execDate = _jobExecTime.getTime();	if (execDate.before(new Date())) {	_jobExecTime.roll(Calendar.DAY_OF_YEAR, true);	}	
execution time 

_jobExecTime.set(Calendar.SECOND, 0);	_jobExecTime.set(Calendar.MILLISECOND, 0);	if (execTimeZone != null && !execTimeZone.isEmpty()) {	_jobExecTime.setTimeZone(TimeZone.getTimeZone(execTimeZone));	}	Date execDate = _jobExecTime.getTime();	if (execDate.before(new Date())) {	_jobExecTime.roll(Calendar.DAY_OF_YEAR, true);	}	Date currentDate = new Date(System.currentTimeMillis());	
current time 

if (execTimeZone != null && !execTimeZone.isEmpty()) {	_jobExecTime.setTimeZone(TimeZone.getTimeZone(execTimeZone));	}	Date execDate = _jobExecTime.getTime();	if (execDate.before(new Date())) {	_jobExecTime.roll(Calendar.DAY_OF_YEAR, true);	}	Date currentDate = new Date(System.currentTimeMillis());	_aggregationDuration = Integer.parseInt(aggregationRange);	if (_aggregationDuration < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) {	
usage stats job aggregation range is to small using the minimum value of 

}	Date currentDate = new Date(System.currentTimeMillis());	_aggregationDuration = Integer.parseInt(aggregationRange);	if (_aggregationDuration < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) {	_aggregationDuration = UsageUtils.USAGE_AGGREGATION_RANGE_MIN;	}	_hostname = InetAddress.getLocalHost().getHostName() + "/" + InetAddress.getLocalHost().getHostAddress();	} catch (NumberFormatException ex) {	throw new ConfigurationException("Unable to parse usage.stats.job.exec.time '" + execTime + "' or usage.stats.job.aggregation.range '" + aggregationRange + "', please check configuration values");	} catch (Exception e) {	
unhandled exception configuring usagemanger 

public boolean start() {	if (s_logger.isInfoEnabled()) {	
starting usage manager 

if (_heartbeatLock.lock(3)) {	try {	UsageJobVO job = _usageJobDao.getLastJob();	if (job == null) {	_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);	}	} finally {	_heartbeatLock.unlock();	}	} else {	
heartbeat lock is in use by others returning true as someone else will take over the job if required 

protected void runInContextInternal() {	if (s_logger.isInfoEnabled()) {	
starting usage job 

endDate = cal.getTime().getTime();	cal.add(Calendar.MINUTE, -1 * _aggregationDuration);	startDate = cal.getTime().getTime();	}	parse(job, startDate, endDate);	if (_runQuota){	try {	_quotaManager.calculateQuotaUsage();	}	catch (Exception e){	
exception received while calculating quota 

parse(job, startDate, endDate);	if (_runQuota){	try {	_quotaManager.calculateQuotaUsage();	}	catch (Exception e){	}	try {	_quotaStatement.sendStatement();	} catch (Exception e) {	
exception received while sending statements 

}	catch (Exception e){	}	try {	_quotaStatement.sendStatement();	} catch (Exception e) {	}	try {	_alertManager.checkAndSendQuotaAlertEmails();	} catch (Exception e) {	
exception received while sending alerts 

_quotaStatement.sendStatement();	} catch (Exception e) {	}	try {	_alertManager.checkAndSendQuotaAlertEmails();	} catch (Exception e) {	}	}	} else {	if (s_logger.isDebugEnabled()) {	
not owner of usage job skipping 

try {	_alertManager.checkAndSendQuotaAlertEmails();	} catch (Exception e) {	}	}	} else {	if (s_logger.isDebugEnabled()) {	}	}	if (s_logger.isInfoEnabled()) {	
usage job complete 

public void scheduleParse() {	if (s_logger.isDebugEnabled()) {	
scheduling usage job 

try {	if ((endDateMillis == 0) || (endDateMillis > timeStart)) {	endDateMillis = timeStart;	}	long lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();	if (lastSuccess != 0) {	startDateMillis = lastSuccess + 1;	}	if (startDateMillis >= endDateMillis) {	if (s_logger.isInfoEnabled()) {	
not parsing usage records since start time mills is on or after end time millis 

}	jobUpdateTxn.commit();	} finally {	jobUpdateTxn.close();	}	return;	}	Date startDate = new Date(startDateMillis);	Date endDate = new Date(endDateMillis);	if (s_logger.isInfoEnabled()) {	
parsing usage records between and 

for (String key : aggregatedStats.keySet()) {	UsageNetworkVO currentNetworkStats = null;	if (networkStats != null) {	currentNetworkStats = networkStats.get(key);	}	createNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);	numAcctsProcessed++;	}	_usageNetworkDao.saveUsageNetworks(usageNetworks);	if (s_logger.isDebugEnabled()) {	
created network stats helper entries for accts 

for (String key : aggregatedDiskStats.keySet()) {	UsageVmDiskVO currentVmDiskStats = null;	if (vmDiskStats != null) {	currentVmDiskStats = vmDiskUsages.get(key);	}	createVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);	numAcctsProcessed++;	}	_usageVmDiskDao.saveUsageVmDisks(usageVmDisks);	if (s_logger.isDebugEnabled()) {	
created vm disk stats helper entries for accts 

accounts = _accountDao.listAll(filter);	if ((accounts != null) && !accounts.isEmpty()) {	for (AccountVO account : accounts) {	parsed = parseHelperTables(account, currentStartDate, currentEndDate);	numAcctsProcessed++;	}	}	offset = new Long(offset.longValue() + limit.longValue());	} while ((accounts != null) && !accounts.isEmpty());	if (s_logger.isDebugEnabled()) {	
processed vm network usage for active accts 

do {	Filter filter = new Filter(AccountVO.class, "id", true, offset, limit);	accounts = _accountDao.findRecentlyDeletedAccounts(null, recentlyDeletedDate, filter);	if ((accounts != null) && !accounts.isEmpty()) {	for (AccountVO account : accounts) {	parsed = parseHelperTables(account, currentStartDate, currentEndDate);	List<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());	for (Long templateId : publicTemplates) {	List<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);	if (storageVOs.size() > 1) {	
more that one usage entry for storage assigned to account marking them all as deleted 

if ((accounts != null) && !accounts.isEmpty()) {	for (AccountVO account : accounts) {	parsed = parseHelperTables(account, currentStartDate, currentEndDate);	List<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());	for (Long templateId : publicTemplates) {	List<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);	if (storageVOs.size() > 1) {	}	for (UsageStorageVO storageVO : storageVOs) {	if (s_logger.isDebugEnabled()) {	
deleting template from account 

}	}	offset = new Long(offset.longValue() + limit.longValue());	} while ((accounts != null) && !accounts.isEmpty());	currentStartDate = new Date(currentEndDate.getTime() + 1);	aggregateCal.setTime(currentEndDate);	aggregateCal.add(Calendar.MINUTE, _aggregationDuration);	currentEndDate = aggregateCal.getTime();	}	if (s_logger.isDebugEnabled()) {	
processed usage for recently deleted accts 

currentEndDate = aggregateCal.getTime();	}	if (s_logger.isDebugEnabled()) {	}	if (!parsed) {	usageTxn.rollback();	} else {	success = true;	}	} catch (Exception ex) {	
exception in usage manager 

usageTxn.close();	TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);	if (!success) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, new Long(0), "Usage job failed. Job id: " + job.getId(), "Usage job failed. Job id: " + job.getId());	} else {	_alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, 0);	}	swap.close();	}	} catch (Exception e) {	
usage manager error 

private boolean parseHelperTables(AccountVO account, Date currentStartDate, Date currentEndDate) {	boolean parsed = false;	parsed = VMInstanceUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
vm usage instances successfully parsed for account id 

private boolean parseHelperTables(AccountVO account, Date currentStartDate, Date currentEndDate) {	boolean parsed = false;	parsed = VMInstanceUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = NetworkUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
network usage successfully parsed for account id 

}	}	parsed = NetworkUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = VmDiskUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
vm disk usage successfully parsed for account id 

}	}	parsed = VmDiskUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = VolumeUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
volume usage successfully parsed for account id 

}	}	parsed = VolumeUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = StorageUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
storage usage successfully parsed for account id 

}	}	parsed = StorageUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = SecurityGroupUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
security group usage successfully parsed for account id 

}	}	parsed = SecurityGroupUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = LoadBalancerUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
load balancer usage successfully parsed for account id 

}	}	parsed = LoadBalancerUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = PortForwardingUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
port forwarding usage successfully parsed for account id 

}	}	parsed = PortForwardingUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = NetworkOfferingUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
network offering usage successfully parsed for account id 

}	}	parsed = NetworkOfferingUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = IPAddressUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
ipaddress usage successfully parsed for account id 

}	}	parsed = IPAddressUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = VPNUserUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
vpn user usage successfully parsed for account id 

}	}	parsed = VPNUserUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	}	}	parsed = VMSnapshotUsageParser.parse(account, currentStartDate, currentEndDate);	if (s_logger.isDebugEnabled()) {	if (!parsed) {	
vm snapshot usage successfully parsed for account id 

String vmName = event.getResourceName();	if (EventTypes.EVENT_VM_START.equals(event.getType())) {	try {	SearchCriteria<UsageVMInstanceVO> sc = _usageInstanceDao.createSearchCriteria();	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, Long.valueOf(vmId));	sc.addAnd("endDate", SearchCriteria.Op.NULL);	sc.addAnd("usageType", SearchCriteria.Op.EQ, UsageTypes.RUNNING_VM);	List<UsageVMInstanceVO> usageInstances = _usageInstanceDao.search(sc, null);	if (usageInstances != null) {	if (usageInstances.size() > 0) {	
found entries for a vm running with id which are not stopped ending them all 

_usageInstanceDao.update(usageInstance);	}	}	}	sc = _usageInstanceDao.createSearchCriteria();	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, Long.valueOf(vmId));	sc.addAnd("endDate", SearchCriteria.Op.NULL);	sc.addAnd("usageType", SearchCriteria.Op.EQ, UsageTypes.ALLOCATED_VM);	usageInstances = _usageInstanceDao.search(sc, null);	if (usageInstances == null || (usageInstances.size() == 0)) {	
cannot find allocated vm entry for a vm running with id 

usageInstance.setStartDate(event.getCreateDate());	usageInstance.setEndDate(null);	populateDynamicComputeOfferingDetailsAndPersist(usageInstance, event.getId());	}	}	Long templateId = event.getTemplateId();	String hypervisorType = event.getResourceType();	UsageVMInstanceVO usageInstanceNew = new UsageVMInstanceVO(UsageTypes.RUNNING_VM, zoneId, event.getAccountId(), vmId, vmName, soId, templateId, hypervisorType, event.getCreateDate(), null);	populateDynamicComputeOfferingDetailsAndPersist(usageInstanceNew, event.getId());	} catch (Exception ex) {	
error saving usage instance for vm 

} catch (Exception ex) {	}	} else if (EventTypes.EVENT_VM_STOP.equals(event.getType())) {	SearchCriteria<UsageVMInstanceVO> sc = _usageInstanceDao.createSearchCriteria();	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, Long.valueOf(vmId));	sc.addAnd("endDate", SearchCriteria.Op.NULL);	sc.addAnd("usageType", SearchCriteria.Op.EQ, UsageTypes.RUNNING_VM);	List<UsageVMInstanceVO> usageInstances = _usageInstanceDao.search(sc, null);	if (usageInstances != null) {	if (usageInstances.size() > 1) {	
found multiple entries for a vm running with id ending them all 

_usageInstanceDao.update(usageInstance);	}	}	} else if (EventTypes.EVENT_VM_CREATE.equals(event.getType())) {	try {	Long templateId = event.getTemplateId();	String hypervisorType = event.getResourceType();	UsageVMInstanceVO usageInstanceNew = new UsageVMInstanceVO(UsageTypes.ALLOCATED_VM, zoneId, event.getAccountId(), vmId, vmName, soId, templateId, hypervisorType, event.getCreateDate(), null);	populateDynamicComputeOfferingDetailsAndPersist(usageInstanceNew, event.getId());	} catch (Exception ex) {	
error saving usage instance for vm 

} catch (Exception ex) {	}	} else if (EventTypes.EVENT_VM_DESTROY.equals(event.getType())) {	SearchCriteria<UsageVMInstanceVO> sc = _usageInstanceDao.createSearchCriteria();	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, Long.valueOf(vmId));	sc.addAnd("endDate", SearchCriteria.Op.NULL);	sc.addAnd("usageType", SearchCriteria.Op.EQ, UsageTypes.ALLOCATED_VM);	List<UsageVMInstanceVO> usageInstances = _usageInstanceDao.search(sc, null);	if (usageInstances != null) {	if (usageInstances.size() > 1) {	
found multiple entries for a vm allocated with id detroying them all 

}	}	} else if (EventTypes.EVENT_VM_UPGRADE.equals(event.getType())) {	SearchCriteria<UsageVMInstanceVO> sc = _usageInstanceDao.createSearchCriteria();	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, Long.valueOf(vmId));	sc.addAnd("endDate", SearchCriteria.Op.NULL);	sc.addAnd("usageType", SearchCriteria.Op.EQ, UsageTypes.ALLOCATED_VM);	List<UsageVMInstanceVO> usageInstances = _usageInstanceDao.search(sc, null);	if (usageInstances != null) {	if (usageInstances.size() > 1) {	
found multiple entries for a vm allocated with id updating end date for all of them 

UsageVMInstanceVO usageInstanceNew = new UsageVMInstanceVO(UsageTypes.ALLOCATED_VM, zoneId, event.getAccountId(), vmId, vmName, soId, templateId, hypervisorType, event.getCreateDate(), null);	populateDynamicComputeOfferingDetailsAndPersist(usageInstanceNew, event.getId());	} else if (EventTypes.EVENT_VM_DYNAMIC_SCALE.equals(event.getType())) {	SearchCriteria<UsageVMInstanceVO> sc = _usageInstanceDao.createSearchCriteria();	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, Long.valueOf(vmId));	sc.addAnd("endDate", SearchCriteria.Op.NULL);	sc.addAnd("usageType", SearchCriteria.Op.EQ, UsageTypes.RUNNING_VM);	List<UsageVMInstanceVO> usageInstances = _usageInstanceDao.search(sc, null);	if (usageInstances != null) {	if (usageInstances.size() > 1) {	
found multiple entries for a vm running with id ending them all 

usageInstance.setEndDate(event.getCreateDate());	_usageInstanceDao.update(usageInstance);	}	}	sc = _usageInstanceDao.createSearchCriteria();	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, Long.valueOf(vmId));	sc.addAnd("endDate", SearchCriteria.Op.NULL);	sc.addAnd("usageType", SearchCriteria.Op.EQ, UsageTypes.ALLOCATED_VM);	usageInstances = _usageInstanceDao.search(sc, null);	if (usageInstances == null || (usageInstances.size() == 0)) {	
cannot find allocated vm entry for a vm running with id 

private void createNetworkHelperEntry(UserStatisticsVO userStat, UsageNetworkVO usageNetworkStats, long timestamp) {	long currentAccountedBytesSent = 0L;	long currentAccountedBytesReceived = 0L;	if (usageNetworkStats != null) {	if (s_logger.isDebugEnabled()) {	
getting current accounted bytes for accountid in zone abr abs 

long currentAccountedBytesReceived = 0L;	if (usageNetworkStats != null) {	if (s_logger.isDebugEnabled()) {	}	currentAccountedBytesSent = usageNetworkStats.getAggBytesSent();	currentAccountedBytesReceived = usageNetworkStats.getAggBytesReceived();	}	long bytesSent = userStat.getAggBytesSent() - currentAccountedBytesSent;	long bytesReceived = userStat.getAggBytesReceived() - currentAccountedBytesReceived;	if (bytesSent < 0) {	
calculated negative value for bytes sent user stats say previous network usage was 

}	currentAccountedBytesSent = usageNetworkStats.getAggBytesSent();	currentAccountedBytesReceived = usageNetworkStats.getAggBytesReceived();	}	long bytesSent = userStat.getAggBytesSent() - currentAccountedBytesSent;	long bytesReceived = userStat.getAggBytesReceived() - currentAccountedBytesReceived;	if (bytesSent < 0) {	bytesSent = 0;	}	if (bytesReceived < 0) {	
calculated negative value for bytes received user stats say previous network usage was 

}	if (bytesReceived < 0) {	bytesReceived = 0;	}	long hostId = 0;	if (userStat.getDeviceId() != null) {	hostId = userStat.getDeviceId();	}	UsageNetworkVO usageNetworkVO = new UsageNetworkVO(userStat.getAccountId(), userStat.getDataCenterId(), hostId, userStat.getDeviceType(), userStat.getNetworkId(), bytesSent, bytesReceived, userStat.getAggBytesReceived(), userStat.getAggBytesSent(), timestamp);	if (s_logger.isDebugEnabled()) {	
creating networkhelperentry accountid in zone abr abs curabs curabr ubs ubr 

private void createVmDiskHelperEntry(VmDiskStatisticsVO vmDiskStat, UsageVmDiskVO usageVmDiskStat, long timestamp) {	long currentAccountedIORead = 0L;	long currentAccountedIOWrite = 0L;	long currentAccountedBytesRead = 0L;	long currentAccountedBytesWrite = 0L;	if (usageVmDiskStat != null) {	if (s_logger.isDebugEnabled()) {	
getting current accounted bytes for accountid in zone aiw air abw abr 

currentAccountedIORead = usageVmDiskStat.getAggIORead();	currentAccountedIOWrite = usageVmDiskStat.getAggIOWrite();	currentAccountedBytesRead = usageVmDiskStat.getAggBytesRead();	currentAccountedBytesWrite = usageVmDiskStat.getAggBytesWrite();	}	long ioRead = vmDiskStat.getAggIORead() - currentAccountedIORead;	long ioWrite = vmDiskStat.getAggIOWrite() - currentAccountedIOWrite;	long bytesRead = vmDiskStat.getAggBytesRead() - currentAccountedBytesRead;	long bytesWrite = vmDiskStat.getAggBytesWrite() - currentAccountedBytesWrite;	if (ioRead < 0) {	
calculated negative value for io read vm disk stats say previous vm disk usage was 

currentAccountedBytesWrite = usageVmDiskStat.getAggBytesWrite();	}	long ioRead = vmDiskStat.getAggIORead() - currentAccountedIORead;	long ioWrite = vmDiskStat.getAggIOWrite() - currentAccountedIOWrite;	long bytesRead = vmDiskStat.getAggBytesRead() - currentAccountedBytesRead;	long bytesWrite = vmDiskStat.getAggBytesWrite() - currentAccountedBytesWrite;	if (ioRead < 0) {	ioRead = 0;	}	if (ioWrite < 0) {	
calculated negative value for io write vm disk stats say previous vm disk usage was 

long ioWrite = vmDiskStat.getAggIOWrite() - currentAccountedIOWrite;	long bytesRead = vmDiskStat.getAggBytesRead() - currentAccountedBytesRead;	long bytesWrite = vmDiskStat.getAggBytesWrite() - currentAccountedBytesWrite;	if (ioRead < 0) {	ioRead = 0;	}	if (ioWrite < 0) {	ioWrite = 0;	}	if (bytesRead < 0) {	
calculated negative value for bytes read vm disk stats say previous vm disk usage was 

if (ioRead < 0) {	ioRead = 0;	}	if (ioWrite < 0) {	ioWrite = 0;	}	if (bytesRead < 0) {	bytesRead = 0;	}	if (bytesWrite < 0) {	
calculated negative value for bytes write vm disk stats say previous vm disk usage was 

}	if (bytesWrite < 0) {	bytesWrite = 0;	}	long vmId = 0;	if (vmDiskStat.getVmId() != null) {	vmId = vmDiskStat.getVmId();	}	UsageVmDiskVO usageVmDiskVO = new UsageVmDiskVO(vmDiskStat.getAccountId(), vmDiskStat.getDataCenterId(), vmId, vmDiskStat.getVolumeId(), ioRead, ioWrite, vmDiskStat.getAggIORead(), vmDiskStat.getAggIOWrite(), bytesRead, bytesWrite, vmDiskStat.getAggBytesRead(), vmDiskStat.getAggBytesWrite(), timestamp);	if (s_logger.isDebugEnabled()) {	
creating vmdiskhelperentry accountid in zone aiw air curair curaiw uir uiw abw abr curabr curabw ubr ubw 

private void createIPHelperEvent(UsageEventVO event) {	String ipAddress = event.getResourceName();	if (EventTypes.EVENT_NET_IP_ASSIGN.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
assigning ip address to account 

boolean isSystem = (event.getTemplateId() == null || event.getTemplateId() == 0) ? false : true;	UsageIPAddressVO ipAddressVO = new UsageIPAddressVO(id, event.getAccountId(), acct.getDomainId(), zoneId, ipAddress, isSourceNat, isSystem, event.getCreateDate(), null);	_usageIPAddressDao.persist(ipAddressVO);	} else if (EventTypes.EVENT_NET_IP_RELEASE.equals(event.getType())) {	SearchCriteria<UsageIPAddressVO> sc = _usageIPAddressDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("address", SearchCriteria.Op.EQ, ipAddress);	sc.addAnd("released", SearchCriteria.Op.NULL);	List<UsageIPAddressVO> ipAddressVOs = _usageIPAddressDao.search(sc, null);	if (ipAddressVOs.size() > 1) {	
more that one usage entry for ip address assigned to account marking them all as released 

} else if (EventTypes.EVENT_NET_IP_RELEASE.equals(event.getType())) {	SearchCriteria<UsageIPAddressVO> sc = _usageIPAddressDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("address", SearchCriteria.Op.EQ, ipAddress);	sc.addAnd("released", SearchCriteria.Op.NULL);	List<UsageIPAddressVO> ipAddressVOs = _usageIPAddressDao.search(sc, null);	if (ipAddressVOs.size() > 1) {	}	for (UsageIPAddressVO ipAddressVO : ipAddressVOs) {	if (s_logger.isDebugEnabled()) {	
releasing ip address from account 

private void createVolumeHelperEvent(UsageEventVO event) {	long volId = event.getResourceId();	if (EventTypes.EVENT_VOLUME_CREATE.equals(event.getType()) || EventTypes.EVENT_VOLUME_RESIZE.equals(event.getType())) {	SearchCriteria<UsageVolumeVO> sc = _usageVolumeDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, volId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageVolumeVO> volumesVOs = _usageVolumeDao.search(sc, null);	if (volumesVOs.size() > 0) {	
found duplicate usage entry for volume assigned to account marking as deleted 

if (EventTypes.EVENT_VOLUME_CREATE.equals(event.getType()) || EventTypes.EVENT_VOLUME_RESIZE.equals(event.getType())) {	SearchCriteria<UsageVolumeVO> sc = _usageVolumeDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, volId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageVolumeVO> volumesVOs = _usageVolumeDao.search(sc, null);	if (volumesVOs.size() > 0) {	}	for (UsageVolumeVO volumesVO : volumesVOs) {	if (s_logger.isDebugEnabled()) {	
deleting volume from account 

List<UsageVolumeVO> volumesVOs = _usageVolumeDao.search(sc, null);	if (volumesVOs.size() > 0) {	}	for (UsageVolumeVO volumesVO : volumesVOs) {	if (s_logger.isDebugEnabled()) {	}	volumesVO.setDeleted(event.getCreateDate());	_usageVolumeDao.update(volumesVO);	}	if (s_logger.isDebugEnabled()) {	
create volume with id for account 

Account acct = _accountDao.findByIdIncludingRemoved(event.getAccountId());	UsageVolumeVO volumeVO = new UsageVolumeVO(volId, event.getZoneId(), event.getAccountId(), acct.getDomainId(), event.getOfferingId(), event.getTemplateId(), event.getSize(), event.getCreateDate(), null);	_usageVolumeDao.persist(volumeVO);	} else if (EventTypes.EVENT_VOLUME_DELETE.equals(event.getType())) {	SearchCriteria<UsageVolumeVO> sc = _usageVolumeDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, volId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageVolumeVO> volumesVOs = _usageVolumeDao.search(sc, null);	if (volumesVOs.size() > 1) {	
more that one usage entry for volume assigned to account marking them all as deleted 

} else if (EventTypes.EVENT_VOLUME_DELETE.equals(event.getType())) {	SearchCriteria<UsageVolumeVO> sc = _usageVolumeDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, volId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageVolumeVO> volumesVOs = _usageVolumeDao.search(sc, null);	if (volumesVOs.size() > 1) {	}	for (UsageVolumeVO volumesVO : volumesVOs) {	if (s_logger.isDebugEnabled()) {	
deleting volume from account 

private void createTemplateHelperEvent(UsageEventVO event) {	long templateId = -1L;	long zoneId = -1L;	long templateSize = -1L;	templateId = event.getResourceId();	zoneId = event.getZoneId();	if (EventTypes.EVENT_TEMPLATE_CREATE.equals(event.getType()) || EventTypes.EVENT_TEMPLATE_COPY.equals(event.getType())) {	templateSize = event.getSize();	if (templateSize < 1) {	
incorrect size for template with id 

long zoneId = -1L;	long templateSize = -1L;	templateId = event.getResourceId();	zoneId = event.getZoneId();	if (EventTypes.EVENT_TEMPLATE_CREATE.equals(event.getType()) || EventTypes.EVENT_TEMPLATE_COPY.equals(event.getType())) {	templateSize = event.getSize();	if (templateSize < 1) {	return;	}	if (zoneId == -1L) {	
incorrect zoneid for template with id 

templateSize = event.getSize();	if (templateSize < 1) {	return;	}	if (zoneId == -1L) {	return;	}	}	if (EventTypes.EVENT_TEMPLATE_CREATE.equals(event.getType()) || EventTypes.EVENT_TEMPLATE_COPY.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
create template with id for account 

}	if (zoneId == -1L) {	return;	}	}	if (EventTypes.EVENT_TEMPLATE_CREATE.equals(event.getType()) || EventTypes.EVENT_TEMPLATE_COPY.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	}	List<UsageStorageVO> storageVOs = _usageStorageDao.listByIdAndZone(event.getAccountId(), templateId, StorageTypes.TEMPLATE, zoneId);	if (storageVOs.size() > 0) {	
usage entry for template assigned to account already exists in zone 

UsageStorageVO storageVO = new UsageStorageVO(templateId, zoneId, event.getAccountId(), acct.getDomainId(), StorageTypes.TEMPLATE, event.getTemplateId(), templateSize, event.getVirtualSize(), event.getCreateDate(), null);	_usageStorageDao.persist(storageVO);	} else if (EventTypes.EVENT_TEMPLATE_DELETE.equals(event.getType())) {	List<UsageStorageVO> storageVOs;	if (zoneId != -1L) {	storageVOs = _usageStorageDao.listByIdAndZone(event.getAccountId(), templateId, StorageTypes.TEMPLATE, zoneId);	} else {	storageVOs = _usageStorageDao.listById(event.getAccountId(), templateId, StorageTypes.TEMPLATE);	}	if (storageVOs.size() > 1) {	
more that one usage entry for storage assigned to account marking them all as deleted 

List<UsageStorageVO> storageVOs;	if (zoneId != -1L) {	storageVOs = _usageStorageDao.listByIdAndZone(event.getAccountId(), templateId, StorageTypes.TEMPLATE, zoneId);	} else {	storageVOs = _usageStorageDao.listById(event.getAccountId(), templateId, StorageTypes.TEMPLATE);	}	if (storageVOs.size() > 1) {	}	for (UsageStorageVO storageVO : storageVOs) {	if (s_logger.isDebugEnabled()) {	
deleting template from account 

private void createISOHelperEvent(UsageEventVO event) {	long isoSize = -1L;	long isoId = event.getResourceId();	long zoneId = event.getZoneId();	if (EventTypes.EVENT_ISO_CREATE.equals(event.getType()) || EventTypes.EVENT_ISO_COPY.equals(event.getType())) {	isoSize = event.getSize();	}	if (EventTypes.EVENT_ISO_CREATE.equals(event.getType()) || EventTypes.EVENT_ISO_COPY.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
create iso with id for account 

long isoId = event.getResourceId();	long zoneId = event.getZoneId();	if (EventTypes.EVENT_ISO_CREATE.equals(event.getType()) || EventTypes.EVENT_ISO_COPY.equals(event.getType())) {	isoSize = event.getSize();	}	if (EventTypes.EVENT_ISO_CREATE.equals(event.getType()) || EventTypes.EVENT_ISO_COPY.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	}	List<UsageStorageVO> storageVOs = _usageStorageDao.listByIdAndZone(event.getAccountId(), isoId, StorageTypes.ISO, zoneId);	if (storageVOs.size() > 0) {	
usage entry for iso assigned to account already exists in zone 

UsageStorageVO storageVO = new UsageStorageVO(isoId, zoneId, event.getAccountId(), acct.getDomainId(), StorageTypes.ISO, null, isoSize, isoSize, event.getCreateDate(), null);	_usageStorageDao.persist(storageVO);	} else if (EventTypes.EVENT_ISO_DELETE.equals(event.getType())) {	List<UsageStorageVO> storageVOs;	if (zoneId != -1L) {	storageVOs = _usageStorageDao.listByIdAndZone(event.getAccountId(), isoId, StorageTypes.ISO, zoneId);	} else {	storageVOs = _usageStorageDao.listById(event.getAccountId(), isoId, StorageTypes.ISO);	}	if (storageVOs.size() > 1) {	
more that one usage entry for storage assigned to account marking them all as deleted 

List<UsageStorageVO> storageVOs;	if (zoneId != -1L) {	storageVOs = _usageStorageDao.listByIdAndZone(event.getAccountId(), isoId, StorageTypes.ISO, zoneId);	} else {	storageVOs = _usageStorageDao.listById(event.getAccountId(), isoId, StorageTypes.ISO);	}	if (storageVOs.size() > 1) {	}	for (UsageStorageVO storageVO : storageVOs) {	if (s_logger.isDebugEnabled()) {	
deleting iso from account 

private void createSnapshotHelperEvent(UsageEventVO event) {	long snapSize = -1L;	long zoneId = -1L;	long snapId = event.getResourceId();	if (EventTypes.EVENT_SNAPSHOT_CREATE.equals(event.getType())) {	snapSize = event.getSize();	zoneId = event.getZoneId();	}	if (EventTypes.EVENT_SNAPSHOT_CREATE.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
create snapshot with id for account 

}	if (EventTypes.EVENT_SNAPSHOT_CREATE.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	}	Account acct = _accountDao.findByIdIncludingRemoved(event.getAccountId());	UsageStorageVO storageVO = new UsageStorageVO(snapId, zoneId, event.getAccountId(), acct.getDomainId(), StorageTypes.SNAPSHOT, null, snapSize, event.getCreateDate(), null);	_usageStorageDao.persist(storageVO);	} else if (EventTypes.EVENT_SNAPSHOT_DELETE.equals(event.getType())) {	List<UsageStorageVO> storageVOs = _usageStorageDao.listById(event.getAccountId(), snapId, StorageTypes.SNAPSHOT);	if (storageVOs.size() > 1) {	
more that one usage entry for storage assigned to account marking them all as deleted 

}	Account acct = _accountDao.findByIdIncludingRemoved(event.getAccountId());	UsageStorageVO storageVO = new UsageStorageVO(snapId, zoneId, event.getAccountId(), acct.getDomainId(), StorageTypes.SNAPSHOT, null, snapSize, event.getCreateDate(), null);	_usageStorageDao.persist(storageVO);	} else if (EventTypes.EVENT_SNAPSHOT_DELETE.equals(event.getType())) {	List<UsageStorageVO> storageVOs = _usageStorageDao.listById(event.getAccountId(), snapId, StorageTypes.SNAPSHOT);	if (storageVOs.size() > 1) {	}	for (UsageStorageVO storageVO : storageVOs) {	if (s_logger.isDebugEnabled()) {	
deleting snapshot from account 

private void createLoadBalancerHelperEvent(UsageEventVO event) {	long zoneId = -1L;	long id = event.getResourceId();	if (EventTypes.EVENT_LOAD_BALANCER_CREATE.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
creating load balancer for account 

Account acct = _accountDao.findByIdIncludingRemoved(event.getAccountId());	UsageLoadBalancerPolicyVO lbVO = new UsageLoadBalancerPolicyVO(id, zoneId, event.getAccountId(), acct.getDomainId(), event.getCreateDate(), null);	_usageLoadBalancerPolicyDao.persist(lbVO);	} else if (EventTypes.EVENT_LOAD_BALANCER_DELETE.equals(event.getType())) {	SearchCriteria<UsageLoadBalancerPolicyVO> sc = _usageLoadBalancerPolicyDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, id);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageLoadBalancerPolicyVO> lbVOs = _usageLoadBalancerPolicyDao.search(sc, null);	if (lbVOs.size() > 1) {	
more that one usage entry for load balancer policy assigned to account marking them all as deleted 

} else if (EventTypes.EVENT_LOAD_BALANCER_DELETE.equals(event.getType())) {	SearchCriteria<UsageLoadBalancerPolicyVO> sc = _usageLoadBalancerPolicyDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, id);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageLoadBalancerPolicyVO> lbVOs = _usageLoadBalancerPolicyDao.search(sc, null);	if (lbVOs.size() > 1) {	}	for (UsageLoadBalancerPolicyVO lbVO : lbVOs) {	if (s_logger.isDebugEnabled()) {	
deleting load balancer policy from account 

private void createPortForwardingHelperEvent(UsageEventVO event) {	long zoneId = -1L;	long id = event.getResourceId();	if (EventTypes.EVENT_NET_RULE_ADD.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
creating port forwarding rule for account 

Account acct = _accountDao.findByIdIncludingRemoved(event.getAccountId());	UsagePortForwardingRuleVO pfVO = new UsagePortForwardingRuleVO(id, zoneId, event.getAccountId(), acct.getDomainId(), event.getCreateDate(), null);	_usagePortForwardingRuleDao.persist(pfVO);	} else if (EventTypes.EVENT_NET_RULE_DELETE.equals(event.getType())) {	SearchCriteria<UsagePortForwardingRuleVO> sc = _usagePortForwardingRuleDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, id);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsagePortForwardingRuleVO> pfVOs = _usagePortForwardingRuleDao.search(sc, null);	if (pfVOs.size() > 1) {	
more that one usage entry for port forwarding rule assigned to account marking them all as deleted 

} else if (EventTypes.EVENT_NET_RULE_DELETE.equals(event.getType())) {	SearchCriteria<UsagePortForwardingRuleVO> sc = _usagePortForwardingRuleDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("id", SearchCriteria.Op.EQ, id);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsagePortForwardingRuleVO> pfVOs = _usagePortForwardingRuleDao.search(sc, null);	if (pfVOs.size() > 1) {	}	for (UsagePortForwardingRuleVO pfVO : pfVOs) {	if (s_logger.isDebugEnabled()) {	
deleting port forwarding rule from account 

private void createNetworkOfferingEvent(UsageEventVO event) {	long zoneId = -1L;	long vmId = event.getResourceId();	long networkOfferingId = event.getOfferingId();	long nicId = 0;	try {	nicId = Long.parseLong(event.getResourceName());	} catch (Exception e) {	
failed to get nic id from resource name resource name is 

long zoneId = -1L;	long vmId = event.getResourceId();	long networkOfferingId = event.getOfferingId();	long nicId = 0;	try {	nicId = Long.parseLong(event.getResourceName());	} catch (Exception e) {	}	if (EventTypes.EVENT_NETWORK_OFFERING_CREATE.equals(event.getType()) || EventTypes.EVENT_NETWORK_OFFERING_ASSIGN.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
creating networking offering for vm for account 

_usageNetworkOfferingDao.persist(networkOffering);	} else if (EventTypes.EVENT_NETWORK_OFFERING_DELETE.equals(event.getType()) || EventTypes.EVENT_NETWORK_OFFERING_REMOVE.equals(event.getType())) {	SearchCriteria<UsageNetworkOfferingVO> sc = _usageNetworkOfferingDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, vmId);	sc.addAnd("nicId", SearchCriteria.Op.EQ, nicId);	sc.addAnd("networkOfferingId", SearchCriteria.Op.EQ, networkOfferingId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageNetworkOfferingVO> noVOs = _usageNetworkOfferingDao.search(sc, null);	if (noVOs.size() > 1) {	
more that one usage entry for networking offering for vm assigned to account marking them all as deleted 

sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, vmId);	sc.addAnd("nicId", SearchCriteria.Op.EQ, nicId);	sc.addAnd("networkOfferingId", SearchCriteria.Op.EQ, networkOfferingId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageNetworkOfferingVO> noVOs = _usageNetworkOfferingDao.search(sc, null);	if (noVOs.size() > 1) {	}	for (UsageNetworkOfferingVO noVO : noVOs) {	if (s_logger.isDebugEnabled()) {	
deleting network offering from vm 

private void createVPNUserEvent(UsageEventVO event) {	long zoneId = 0L;	long userId = event.getResourceId();	if (EventTypes.EVENT_VPN_USER_ADD.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
creating vpn user for account 

String userName = event.getResourceName();	UsageVPNUserVO vpnUser = new UsageVPNUserVO(zoneId, event.getAccountId(), acct.getDomainId(), userId, userName, event.getCreateDate(), null);	_usageVPNUserDao.persist(vpnUser);	} else if (EventTypes.EVENT_VPN_USER_REMOVE.equals(event.getType())) {	SearchCriteria<UsageVPNUserVO> sc = _usageVPNUserDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("userId", SearchCriteria.Op.EQ, userId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageVPNUserVO> vuVOs = _usageVPNUserDao.search(sc, null);	if (vuVOs.size() > 1) {	
more that one usage entry for vpn user assigned to account marking them all as deleted 

} else if (EventTypes.EVENT_VPN_USER_REMOVE.equals(event.getType())) {	SearchCriteria<UsageVPNUserVO> sc = _usageVPNUserDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("userId", SearchCriteria.Op.EQ, userId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageVPNUserVO> vuVOs = _usageVPNUserDao.search(sc, null);	if (vuVOs.size() > 1) {	}	for (UsageVPNUserVO vuVO : vuVOs) {	if (s_logger.isDebugEnabled()) {	
deleting vpn user 

private void createSecurityGroupEvent(UsageEventVO event) {	long zoneId = -1L;	long vmId = event.getResourceId();	long sgId = event.getOfferingId();	if (EventTypes.EVENT_SECURITY_GROUP_ASSIGN.equals(event.getType())) {	if (s_logger.isDebugEnabled()) {	
assigning security group to vm for account 

UsageSecurityGroupVO securityGroup = new UsageSecurityGroupVO(zoneId, event.getAccountId(), acct.getDomainId(), vmId, sgId, event.getCreateDate(), null);	_usageSecurityGroupDao.persist(securityGroup);	} else if (EventTypes.EVENT_SECURITY_GROUP_REMOVE.equals(event.getType())) {	SearchCriteria<UsageSecurityGroupVO> sc = _usageSecurityGroupDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, vmId);	sc.addAnd("securityGroupId", SearchCriteria.Op.EQ, sgId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageSecurityGroupVO> sgVOs = _usageSecurityGroupDao.search(sc, null);	if (sgVOs.size() > 1) {	
more that one usage entry for security group for vm assigned to account marking them all as deleted 

SearchCriteria<UsageSecurityGroupVO> sc = _usageSecurityGroupDao.createSearchCriteria();	sc.addAnd("accountId", SearchCriteria.Op.EQ, event.getAccountId());	sc.addAnd("vmInstanceId", SearchCriteria.Op.EQ, vmId);	sc.addAnd("securityGroupId", SearchCriteria.Op.EQ, sgId);	sc.addAnd("deleted", SearchCriteria.Op.NULL);	List<UsageSecurityGroupVO> sgVOs = _usageSecurityGroupDao.search(sc, null);	if (sgVOs.size() > 1) {	}	for (UsageSecurityGroupVO sgVO : sgVOs) {	if (s_logger.isDebugEnabled()) {	
deleting security group from vm 

protected void runInContext() {	TransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);	try {	if (!_heartbeatLock.lock(3)) {	
heartbeat lock is in use by others returning true as someone else will take over the job if required 

long timeToJob = _jobExecTime.getTimeInMillis() - now;	long timeSinceJob = 0;	long aggregationDurationMillis = _aggregationDuration * 60L * 1000L;	long lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();	if (lastSuccess > 0) {	timeSinceJob = now - lastSuccess;	}	if ((timeSinceJob > 0) && (timeSinceJob > (aggregationDurationMillis - 100))) {	if (timeToJob > (aggregationDurationMillis / 2)) {	if (s_logger.isDebugEnabled()) {	
it s been ms since last usage job and ms until next job scheduling an immediate job to catch up aggregation duration is minutes 

}	boolean changeOwner = updateJob(jobId, _hostname, Integer.valueOf(_pid), new Date(), UsageJobVO.JOB_NOT_SCHEDULED);	if (changeOwner) {	deleteOneOffJobs(_hostname, _pid);	}	}	} finally {	_heartbeatLock.unlock();	}	} catch (Exception ex) {	
error in heartbeat 

jobForUpdate.setPid(pid);	}	if (heartbeat != null) {	jobForUpdate.setHeartbeat(heartbeat);	}	jobForUpdate.setScheduled(scheduled);	_usageJobDao.update(job.getId(), jobForUpdate);	txn.commit();	} catch (Exception dbEx) {	txn.rollback();	
error updating usage job 

protected void runInContext() {	UsageSanityChecker usc = new UsageSanityChecker();	try {	String errors = usc.runSanityCheck();	if (errors.length() > 0) {	_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SANITY_RESULT, 0, new Long(0), "Usage Sanity Check failed", errors);	} else {	_alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SANITY_RESULT, 0, 0);	}	} catch (SQLException e) {	
error in sanity check 

========================= cloudstack sample_2645 =========================

public Answer execute(final OvsSetupBridgeCommand command, final LibvirtComputingResource libvirtComputingResource) {	final boolean findResult = libvirtComputingResource.findOrCreateTunnelNetwork(command.getBridgeName());	final boolean configResult = libvirtComputingResource.configureTunnelNetwork(command.getNetworkId(), command.getHostId(), command.getBridgeName());	final boolean finalResult = findResult && configResult;	if (!finalResult) {	
failure ovs bridge was not configured properly 

========================= cloudstack sample_1069 =========================

public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	if (_vpcOffDao.findByUniqueName(VpcOffering.defaultVPCOfferingName) == null) {	
creating default vpc offering 

lbProviders.add(Provider.VPCVirtualRouter);	lbProviders.add(Provider.InternalLbVm);	svcProviderMap.put(svc, lbProviders);	} else {	svcProviderMap.put(svc, defaultProviders);	}	}	createVpcOffering(VpcOffering.defaultVPCOfferingName, VpcOffering.defaultVPCOfferingName, svcProviderMap, true, State.Enabled, null, false, false, false);	}	if (_vpcOffDao.findByUniqueName(VpcOffering.defaultVPCNSOfferingName) == null) {	
creating default vpc offering with netscaler as lb provider 

lbProviders.add(Provider.Netscaler);	lbProviders.add(Provider.InternalLbVm);	svcProviderMap.put(svc, lbProviders);	} else {	svcProviderMap.put(svc, defaultProviders);	}	}	createVpcOffering(VpcOffering.defaultVPCNSOfferingName, VpcOffering.defaultVPCNSOfferingName, svcProviderMap, false, State.Enabled, null, false, false, false);	}	if (_vpcOffDao.findByUniqueName(VpcOffering.redundantVPCOfferingName) == null) {	
creating redundant vpc offering 

sdnProviders.add(Provider.JuniperContrailVpcRouter);	sdnProviders.add(Provider.NuageVsp);	boolean sourceNatSvc = false;	boolean firewallSvs = false;	for (final String serviceName : supportedServices) {	final Service service = Network.Service.getService(serviceName);	if (service == null || nonSupportedServices.contains(service)) {	throw new InvalidParameterValueException("Service " + serviceName + " is not supported in VPC");	}	if (service == Service.Connectivity) {	
applying connectivity workaround setting provider to niciranvp 

svcProviderMap.put(service, defaultProviders);	}	if (service == Service.NetworkACL) {	firewallSvs = true;	}	if (service == Service.SourceNat) {	sourceNatSvc = true;	}	}	if (!sourceNatSvc) {	
automatically adding source nat service to the list of vpc services 

firewallSvs = true;	}	if (service == Service.SourceNat) {	sourceNatSvc = true;	}	}	if (!sourceNatSvc) {	svcProviderMap.put(Service.SourceNat, defaultProviders);	}	if (!firewallSvs) {	
automatically adding network acl service to the list of vpc services 

protected VpcOffering createVpcOffering(final String name, final String displayText, final Map<Network.Service, Set<Network.Provider>> svcProviderMap, final boolean isDefault, final State state, final Long serviceOfferingId, final boolean supportsDistributedRouter, final boolean offersRegionLevelVPC, final boolean redundantRouter) {	return Transaction.execute(new TransactionCallback<VpcOffering>() {	public VpcOffering doInTransaction(final TransactionStatus status) {	VpcOfferingVO offering = new VpcOfferingVO(name, displayText, isDefault, serviceOfferingId, supportsDistributedRouter, offersRegionLevelVPC, redundantRouter);	if (state != null) {	offering.setState(state);	}	
adding vpc offering 

offering.setState(state);	}	offering = _vpcOffDao.persist(offering);	if (svcProviderMap != null) {	for (final Network.Service service : svcProviderMap.keySet()) {	final Set<Provider> providers = svcProviderMap.get(service);	if (providers != null && !providers.isEmpty()) {	for (final Network.Provider provider : providers) {	final VpcOfferingServiceMapVO offService = new VpcOfferingServiceMapVO(offering.getId(), service, provider);	_vpcOffSvcMapDao.persist(offService);	
added service for the vpc offering with provider 

if (!NetUtils.verifyDomainName(vpc.getNetworkDomain())) {	throw new InvalidParameterValueException("Invalid network domain. Total length shouldn't exceed 190 chars. Each domain " + "label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', " + "the digits '0' through '9', " + "and the hyphen ('-'); can't start or end with \"-\"");	}	return Transaction.execute(new TransactionCallback<VpcVO>() {	public VpcVO doInTransaction(final TransactionStatus status) {	if (displayVpc != null) {	vpc.setDisplay(displayVpc);	}	final VpcVO persistedVpc = _vpcDao.persist(vpc, finalizeServicesAndProvidersForVpc(vpc.getZoneId(), vpc.getVpcOfferingId()));	_resourceLimitMgr.incrementResourceCount(vpc.getAccountId(), ResourceType.vpc);	
created vpc 

public boolean destroyVpc(final Vpc vpc, final Account caller, final Long callerUserId) throws ConcurrentOperationException, ResourceUnavailableException {	
destroying vpc 

public boolean destroyVpc(final Vpc vpc, final Account caller, final Long callerUserId) throws ConcurrentOperationException, ResourceUnavailableException {	final int networksCount = _ntwkDao.getNonSystemNetworkCountByVpcId(vpc.getId());	if (networksCount > 0) {	throw new InvalidParameterValueException("Can't delete VPC " + vpc + " as its used by " + networksCount + " networks");	}	if (vpc.getState() != Vpc.State.Inactive) {	
updating vpc with state as a part of vpc delete 

final VpcVO vpcVO = _vpcDao.findById(vpc.getId());	vpcVO.setState(Vpc.State.Inactive);	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	_vpcDao.update(vpc.getId(), vpcVO);	_resourceLimitMgr.decrementResourceCount(vpc.getAccountId(), ResourceType.vpc);	}	});	}	if (!shutdownVpc(vpc.getId())) {	
failed to shutdown vpc as a part of vpc destroy process 

public void doInTransactionWithoutResult(final TransactionStatus status) {	_vpcDao.update(vpc.getId(), vpcVO);	_resourceLimitMgr.decrementResourceCount(vpc.getAccountId(), ResourceType.vpc);	}	});	}	if (!shutdownVpc(vpc.getId())) {	return false;	}	if (!cleanupVpcResources(vpc.getId(), caller, callerUserId)) {	
failed to cleanup resources for vpc 

}	});	}	if (!shutdownVpc(vpc.getId())) {	return false;	}	if (!cleanupVpcResources(vpc.getId(), caller, callerUserId)) {	return false;	}	if (_vpcDao.remove(vpc.getId())) {	
vpc is destroyed succesfully 

}	if (!shutdownVpc(vpc.getId())) {	return false;	}	if (!cleanupVpcResources(vpc.getId(), caller, callerUserId)) {	return false;	}	if (_vpcDao.remove(vpc.getId())) {	return true;	} else {	
vpc failed to destroy 

ex.addProxyObject(String.valueOf(vpcId), "VPC");	throw ex;	}	_accountMgr.checkAccess(caller, null, false, vpc);	final DataCenter dc = _entityMgr.findById(DataCenter.class, vpc.getZoneId());	final DeployDestination dest = new DeployDestination(dc, null, null, null);	final ReservationContext context = new ReservationContextImpl(null, null, callerUser, _accountMgr.getAccount(vpc.getAccountId()));	boolean result = true;	try {	if (!startVpc(vpc, dest, context)) {	
failed to start vpc 

_accountMgr.checkAccess(caller, null, false, vpc);	final DataCenter dc = _entityMgr.findById(DataCenter.class, vpc.getZoneId());	final DeployDestination dest = new DeployDestination(dc, null, null, null);	final ReservationContext context = new ReservationContextImpl(null, null, callerUser, _accountMgr.getAccount(vpc.getAccountId()));	boolean result = true;	try {	if (!startVpc(vpc, dest, context)) {	result = false;	}	} catch (final Exception ex) {	
failed to start vpc due to 

final ReservationContext context = new ReservationContextImpl(null, null, callerUser, _accountMgr.getAccount(vpc.getAccountId()));	boolean result = true;	try {	if (!startVpc(vpc, dest, context)) {	result = false;	}	} catch (final Exception ex) {	result = false;	} finally {	if (!result && destroyOnFailure) {	
destroying vpc that failed to start 

boolean result = true;	try {	if (!startVpc(vpc, dest, context)) {	result = false;	}	} catch (final Exception ex) {	result = false;	} finally {	if (!result && destroyOnFailure) {	if (destroyVpc(vpc, caller, callerUser.getId())) {	
successfully destroyed vpc that failed to start 

try {	if (!startVpc(vpc, dest, context)) {	result = false;	}	} catch (final Exception ex) {	result = false;	} finally {	if (!result && destroyOnFailure) {	if (destroyVpc(vpc, caller, callerUser.getId())) {	} else {	
failed to destroy vpc that failed to start 

protected boolean startVpc(final Vpc vpc, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	boolean success = true;	final List<Provider> providersToImplement = getVpcProviders(vpc.getId());	for (final VpcProvider element : getVpcElements()) {	if (providersToImplement.contains(element.getProvider())) {	if (element.implementVpc(vpc, dest, context)) {	
vpc has started succesfully 

protected boolean startVpc(final Vpc vpc, final DeployDestination dest, final ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	boolean success = true;	final List<Provider> providersToImplement = getVpcProviders(vpc.getId());	for (final VpcProvider element : getVpcElements()) {	if (providersToImplement.contains(element.getProvider())) {	if (element.implementVpc(vpc, dest, context)) {	} else {	
vpc failed to start 

public boolean shutdownVpc(final long vpcId) throws ConcurrentOperationException, ResourceUnavailableException {	final CallContext ctx = CallContext.current();	final Account caller = ctx.getCallingAccount();	final Vpc vpc = _vpcDao.findById(vpcId);	if (vpc == null) {	throw new InvalidParameterValueException("Unable to find vpc by id " + vpcId);	}	_accountMgr.checkAccess(caller, null, false, vpc);	
shutting down vpc 

if (vpc == null) {	throw new InvalidParameterValueException("Unable to find vpc by id " + vpcId);	}	_accountMgr.checkAccess(caller, null, false, vpc);	boolean success = true;	final List<Provider> providersToImplement = getVpcProviders(vpc.getId());	final ReservationContext context = new ReservationContextImpl(null, null, _accountMgr.getActiveUser(ctx.getCallingUserId()), caller);	for (final VpcProvider element : getVpcElements()) {	if (providersToImplement.contains(element.getProvider())) {	if (element.shutdownVpc(vpc, context)) {	
vpc has been shutdown succesfully 

throw new InvalidParameterValueException("Unable to find vpc by id " + vpcId);	}	_accountMgr.checkAccess(caller, null, false, vpc);	boolean success = true;	final List<Provider> providersToImplement = getVpcProviders(vpc.getId());	final ReservationContext context = new ReservationContextImpl(null, null, _accountMgr.getActiveUser(ctx.getCallingUserId()), caller);	for (final VpcProvider element : getVpcElements()) {	if (providersToImplement.contains(element.getProvider())) {	if (element.shutdownVpc(vpc, context)) {	} else {	
vpc failed to shutdown 

if (vpc.getAccountId() != networkOwner.getId()) {	throw new InvalidParameterValueException("Vpc " + vpc + " owner is different from the network owner " + networkOwner);	}	if (!networkDomain.equalsIgnoreCase(vpc.getNetworkDomain())) {	throw new InvalidParameterValueException("Network domain of the new network should match network" + " domain of vpc " + vpc);	}	if (NetUtils.getCidrSubNet(cidr).equalsIgnoreCase(gateway)) {	throw new InvalidParameterValueException("Invalid gateway specified. It should never be equal to the cidr subnet value");	}	} finally {	
releasing lock for 

public boolean cleanupVpcResources(final long vpcId, final Account caller, final long callerUserId) throws ResourceUnavailableException, ConcurrentOperationException {	s_logger.debug("Cleaning up resources for vpc id=" + vpcId);	boolean success = true;	
cleaning up existed site to site vpn connections 

public boolean cleanupVpcResources(final long vpcId, final Account caller, final long callerUserId) throws ResourceUnavailableException, ConcurrentOperationException {	s_logger.debug("Cleaning up resources for vpc id=" + vpcId);	boolean success = true;	_s2sVpnMgr.cleanupVpnConnectionByVpc(vpcId);	
cleaning up existed site to site vpn gateways 

boolean success = true;	_s2sVpnMgr.cleanupVpnConnectionByVpc(vpcId);	_s2sVpnMgr.cleanupVpnGatewayByVpc(vpcId);	final List<IPAddressVO> ipsToRelease = _ipAddressDao.listByAssociatedVpc(vpcId, null);	s_logger.debug("Releasing ips for vpc id=" + vpcId + " as a part of vpc cleanup");	for (final IPAddressVO ipToRelease : ipsToRelease) {	if (ipToRelease.isPortable()) {	ipToRelease.setVpcId(null);	ipToRelease.setAssociatedWithNetworkId(null);	_ipAddressDao.update(ipToRelease.getId(), ipToRelease);	
portable ip address is no longer associated with any vpc 

s_logger.warn("Failed to cleanup ip " + ipToRelease + " as a part of vpc id=" + vpcId + " cleanup");	}	}	}	if (success) {	s_logger.debug("Released ip addresses for vpc id=" + vpcId + " as a part of cleanup vpc process");	} else {	s_logger.warn("Failed to release ip addresses for vpc id=" + vpcId + " as a part of cleanup vpc process");	}	if (!revokeStaticRoutesForVpc(vpcId, caller)) {	
failed to revoke static routes for vpc as a part of cleanup vpc process 

} else {	s_logger.warn("Failed to release ip addresses for vpc id=" + vpcId + " as a part of cleanup vpc process");	}	if (!revokeStaticRoutesForVpc(vpcId, caller)) {	return false;	}	final List<PrivateGateway> gateways = getVpcPrivateGateways(vpcId);	if (gateways != null) {	for (final PrivateGateway gateway : gateways) {	if (gateway != null) {	
deleting private gateway as a part of vpc resources cleanup 

}	if (!revokeStaticRoutesForVpc(vpcId, caller)) {	return false;	}	final List<PrivateGateway> gateways = getVpcPrivateGateways(vpcId);	if (gateways != null) {	for (final PrivateGateway gateway : gateways) {	if (gateway != null) {	if (!deleteVpcPrivateGateway(gateway.getId())) {	success = false;	
failed to delete private gateway as a part of vpc resources cleanup 

if (!revokeStaticRoutesForVpc(vpcId, caller)) {	return false;	}	final List<PrivateGateway> gateways = getVpcPrivateGateways(vpcId);	if (gateways != null) {	for (final PrivateGateway gateway : gateways) {	if (gateway != null) {	if (!deleteVpcPrivateGateway(gateway.getId())) {	success = false;	} else {	
deleted private gateway as a part of vpc resources cleanup 

public boolean restartVpc(final long vpcId, final boolean cleanUp, final boolean makeRedundant) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	final Account caller = CallContext.current().getCallingAccount();	final Vpc vpc = getActiveVpc(vpcId);	if (vpc == null) {	final InvalidParameterValueException ex = new InvalidParameterValueException("Unable to find Enabled VPC by id specified");	ex.addProxyObject(String.valueOf(vpcId), "VPC");	throw ex;	}	_accountMgr.checkAccess(caller, null, false, vpc);	
restarting vpc 

boolean forceCleanup = cleanUp;	if (!vpc.isRedundant() && makeRedundant) {	final VpcOfferingVO redundantOffering = _vpcOffDao.findByUniqueName(VpcOffering.redundantVPCOfferingName);	final VpcVO entity = _vpcDao.findById(vpcId);	entity.setRedundant(makeRedundant);	entity.setVpcOfferingId(redundantOffering.getId());	_vpcDao.update(vpc.getId(), entity);	forceCleanup = true;	}	if (forceCleanup) {	
shutting down vpc as a part of vpc restart process 

if (!vpc.isRedundant() && makeRedundant) {	final VpcOfferingVO redundantOffering = _vpcOffDao.findByUniqueName(VpcOffering.redundantVPCOfferingName);	final VpcVO entity = _vpcDao.findById(vpcId);	entity.setRedundant(makeRedundant);	entity.setVpcOfferingId(redundantOffering.getId());	_vpcDao.update(vpc.getId(), entity);	forceCleanup = true;	}	if (forceCleanup) {	if (!shutdownVpc(vpcId)) {	
failed to shutdown vpc as a part of vpc restart process 

entity.setVpcOfferingId(redundantOffering.getId());	_vpcDao.update(vpc.getId(), entity);	forceCleanup = true;	}	if (forceCleanup) {	if (!shutdownVpc(vpcId)) {	restartRequired = true;	return false;	}	} else {	
will not shutdown vpc as a part of vpc restart process 

_vpcDao.update(vpc.getId(), entity);	forceCleanup = true;	}	if (forceCleanup) {	if (!shutdownVpc(vpcId)) {	restartRequired = true;	return false;	}	} else {	}	
starting vpc as a part of vpc restart process 

forceCleanup = true;	}	if (forceCleanup) {	if (!shutdownVpc(vpcId)) {	restartRequired = true;	return false;	}	} else {	}	if (!startVpc(vpcId, false)) {	
failed to start vpc as a part of vpc restart process 

if (!shutdownVpc(vpcId)) {	restartRequired = true;	return false;	}	} else {	}	if (!startVpc(vpcId, false)) {	restartRequired = true;	return false;	}	
vpc was restarted successfully 

if (physNet == null) {	physNet = _entityMgr.findById(PhysicalNetwork.class, physicalNetworkId);	}	final Long dcId = physNet.getDataCenterId();	final Long physicalNetworkIdFinal = physicalNetworkId;	final PhysicalNetwork physNetFinal = physNet;	VpcGatewayVO gatewayVO = null;	try {	gatewayVO = Transaction.execute(new TransactionCallbackWithException<VpcGatewayVO, Exception>() {	public VpcGatewayVO doInTransaction(final TransactionStatus status) throws ResourceAllocationException, ConcurrentOperationException, InsufficientCapacityException {	
creating private gateway for vpc 

VpcGatewayVO gatewayVO = null;	try {	gatewayVO = Transaction.execute(new TransactionCallbackWithException<VpcGatewayVO, Exception>() {	public VpcGatewayVO doInTransaction(final TransactionStatus status) throws ResourceAllocationException, ConcurrentOperationException, InsufficientCapacityException {	Network privateNtwk = null;	if (BroadcastDomainType.getSchemeValue(BroadcastDomainType.fromString(broadcastUri)) == BroadcastDomainType.Lswitch) {	final String cidr = NetUtils.ipAndNetMaskToCidr(gateway, netmask);	privateNtwk = _ntwkDao.getPrivateNetwork(broadcastUri, cidr, gatewayOwnerId, dcId, networkOfferingId);	}	if (privateNtwk == null) {	
creating new network for vpc using broadcast uri 

public VpcGatewayVO doInTransaction(final TransactionStatus status) throws ResourceAllocationException, ConcurrentOperationException, InsufficientCapacityException {	Network privateNtwk = null;	if (BroadcastDomainType.getSchemeValue(BroadcastDomainType.fromString(broadcastUri)) == BroadcastDomainType.Lswitch) {	final String cidr = NetUtils.ipAndNetMaskToCidr(gateway, netmask);	privateNtwk = _ntwkDao.getPrivateNetwork(broadcastUri, cidr, gatewayOwnerId, dcId, networkOfferingId);	}	if (privateNtwk == null) {	final String networkName = "vpc-" + vpc.getName() + "-privateNetwork";	privateNtwk = _ntwkSvc.createPrivateNetwork(networkName, networkName, physicalNetworkIdFinal, broadcastUri, ipAddress, null, gateway, netmask, gatewayOwnerId, vpcId, isSourceNat, networkOfferingId);	} else {	
found and using existing network for vpc 

privateNtwk = _ntwkSvc.createPrivateNetwork(networkName, networkName, physicalNetworkIdFinal, broadcastUri, ipAddress, null, gateway, netmask, gatewayOwnerId, vpcId, isSourceNat, networkOfferingId);	} else {	final DataCenterVO dc = _dcDao.lockRow(physNetFinal.getDataCenterId(), true);	PrivateIpVO privateIp = _privateIpDao.findByIpAndSourceNetworkId(privateNtwk.getId(), ipAddress);	if (privateIp != null) {	throw new InvalidParameterValueException("Private ip address " + ipAddress + " already used for private gateway" + " in zone " + _entityMgr.findById(DataCenter.class, dcId).getName());	}	final Long mac = dc.getMacAddress();	final Long nextMac = mac + 1;	dc.setMacAddress(nextMac);	
creating private ip adress for vpc 

}	networkAclId = aclId;	}	{	final NetworkVO gatewaynet = _ntwkDao.findById(privateNtwk.getId());	gatewaynet.setVpcId(null);	_ntwkDao.persist(gatewaynet);	}	final VpcGatewayVO gatewayVO = new VpcGatewayVO(ipAddress, VpcGateway.Type.Private, vpcId, privateNtwk.getDataCenterId(), privateNtwk.getId(), broadcastUri, gateway, netmask, vpc.getAccountId(), vpc.getDomainId(), isSourceNat, networkAclId);	_vpcGatewayDao.persist(gatewayVO);	
created vpc gateway entry 

final List<Provider> providersToImplement = getVpcProviders(vo.getVpcId());	final PrivateGateway gateway = getVpcPrivateGateway(gatewayId);	for (final VpcProvider provider : getVpcElements()) {	if (providersToImplement.contains(provider.getProvider())) {	if (!provider.createPrivateGateway(gateway)) {	success = false;	}	}	}	if (success) {	
private gateway was applied succesfully on the backend 

if (providersToImplement.contains(provider.getProvider())) {	if (!provider.createPrivateGateway(gateway)) {	success = false;	}	}	}	if (success) {	if (vo.getState() != VpcGateway.State.Ready) {	vo.setState(VpcGateway.State.Ready);	_vpcGatewayDao.update(vo.getId(), vo);	
marke gateway with state 

}	}	if (success) {	if (vo.getState() != VpcGateway.State.Ready) {	vo.setState(VpcGateway.State.Ready);	_vpcGatewayDao.update(vo.getId(), vo);	}	CallContext.current().setEventDetails("Private Gateway Id: " + gatewayId);	return getVpcPrivateGateway(gatewayId);	} else {	
private gateway failed to apply on the backend 

_vpcGatewayDao.update(vo.getId(), vo);	}	CallContext.current().setEventDetails("Private Gateway Id: " + gatewayId);	return getVpcPrivateGateway(gatewayId);	} else {	return null;	}	} finally {	if (!success) {	if (destroyOnFailure) {	
destroying private gateway that failed to start 

}	CallContext.current().setEventDetails("Private Gateway Id: " + gatewayId);	return getVpcPrivateGateway(gatewayId);	} else {	return null;	}	} finally {	if (!success) {	if (destroyOnFailure) {	if (deletePrivateGatewayFromTheDB(getVpcPrivateGateway(gatewayId))) {	
successfully destroyed vpc that failed to start 

CallContext.current().setEventDetails("Private Gateway Id: " + gatewayId);	return getVpcPrivateGateway(gatewayId);	} else {	return null;	}	} finally {	if (!success) {	if (destroyOnFailure) {	if (deletePrivateGatewayFromTheDB(getVpcPrivateGateway(gatewayId))) {	} else {	
failed to destroy vpc that failed to start 

}	try {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final long routeCount = _staticRouteDao.countRoutesByGateway(gatewayVO.getId());	if (routeCount > 0) {	throw new CloudRuntimeException("Can't delete private gateway " + gatewayVO + " as it has " + routeCount + " static routes applied. Remove the routes first");	}	gatewayVO.setState(VpcGateway.State.Deleting);	_vpcGatewayDao.update(gatewayVO.getId(), gatewayVO);	
marked gateway with state 

}	gatewayVO.setState(VpcGateway.State.Deleting);	_vpcGatewayDao.update(gatewayVO.getId(), gatewayVO);	}	});	final List<Provider> providersToImplement = getVpcProviders(gatewayVO.getVpcId());	final PrivateGateway gateway = getVpcPrivateGateway(gatewayId);	for (final VpcProvider provider : getVpcElements()) {	if (providersToImplement.contains(provider.getProvider())) {	if (provider.deletePrivateGateway(gateway)) {	
private gateway was applied succesfully on the backend 

gatewayVO.setState(VpcGateway.State.Deleting);	_vpcGatewayDao.update(gatewayVO.getId(), gatewayVO);	}	});	final List<Provider> providersToImplement = getVpcProviders(gatewayVO.getVpcId());	final PrivateGateway gateway = getVpcPrivateGateway(gatewayId);	for (final VpcProvider provider : getVpcElements()) {	if (providersToImplement.contains(provider.getProvider())) {	if (provider.deletePrivateGateway(gateway)) {	} else {	
private gateway failed to apply on the backend 

}	});	final List<Provider> providersToImplement = getVpcProviders(gatewayVO.getVpcId());	final PrivateGateway gateway = getVpcPrivateGateway(gatewayId);	for (final VpcProvider provider : getVpcElements()) {	if (providersToImplement.contains(provider.getProvider())) {	if (provider.deletePrivateGateway(gateway)) {	} else {	gatewayVO.setState(VpcGateway.State.Ready);	_vpcGatewayDao.update(gatewayVO.getId(), gatewayVO);	
marked gateway with state 

final Map<Long, VpcGateway> gatewayMap = new HashMap<Long, VpcGateway>();	for (final StaticRoute route : routes) {	VpcGateway gateway = gatewayMap.get(route.getVpcGatewayId());	if (gateway == null) {	gateway = _vpcGatewayDao.findById(route.getVpcGatewayId());	gatewayMap.put(gateway.getId(), gateway);	}	staticRouteProfiles.add(new StaticRouteProfile(route, gateway));	}	if (!applyStaticRoutes(staticRouteProfiles)) {	
routes are not completely applied 

}	staticRouteProfiles.add(new StaticRouteProfile(route, gateway));	}	if (!applyStaticRoutes(staticRouteProfiles)) {	return false;	} else {	if (updateRoutesInDB) {	for (final StaticRoute route : routes) {	if (route.getState() == StaticRoute.State.Revoke) {	_staticRouteDao.remove(route.getId());	
removed route from the db 

return false;	} else {	if (updateRoutesInDB) {	for (final StaticRoute route : routes) {	if (route.getState() == StaticRoute.State.Revoke) {	_staticRouteDao.remove(route.getId());	} else if (route.getState() == StaticRoute.State.Add) {	final StaticRouteVO ruleVO = _staticRouteDao.findById(route.getId());	ruleVO.setState(StaticRoute.State.Active);	_staticRouteDao.update(ruleVO.getId(), ruleVO);	
marked route with state 

protected boolean applyStaticRoutes(final List<StaticRouteProfile> routes) throws ResourceUnavailableException {	if (routes.isEmpty()) {	
no static routes to apply 

protected boolean applyStaticRoutes(final List<StaticRouteProfile> routes) throws ResourceUnavailableException {	if (routes.isEmpty()) {	return true;	}	final Vpc vpc = _vpcDao.findById(routes.get(0).getVpcId());	
applying static routes for vpc 

if (routes.isEmpty()) {	return true;	}	final Vpc vpc = _vpcDao.findById(routes.get(0).getVpcId());	final String staticNatProvider = _vpcSrvcDao.getProviderForServiceInVpc(vpc.getId(), Service.StaticNat);	for (final VpcProvider provider : getVpcElements()) {	if (!(provider instanceof StaticNatServiceProvider && provider.getName().equalsIgnoreCase(staticNatProvider))) {	continue;	}	if (provider.applyStaticRoutes(vpc, routes)) {	
applied static routes for vpc 

return true;	}	final Vpc vpc = _vpcDao.findById(routes.get(0).getVpcId());	final String staticNatProvider = _vpcSrvcDao.getProviderForServiceInVpc(vpc.getId(), Service.StaticNat);	for (final VpcProvider provider : getVpcElements()) {	if (!(provider instanceof StaticNatServiceProvider && provider.getName().equalsIgnoreCase(staticNatProvider))) {	continue;	}	if (provider.applyStaticRoutes(vpc, routes)) {	} else {	
failed to apply static routes for vpc 

protected boolean revokeStaticRoutesForVpc(final long vpcId, final Account caller) throws ResourceUnavailableException {	final List<StaticRouteVO> routes = _staticRouteDao.listByVpcId(vpcId);	
found to revoke for the vpc 

}	if (NetUtils.isNetworksOverlap(vpc.getCidr(), NetUtils.getLinkLocalCIDR())) {	throw new InvalidParameterValueException("CIDR should be outside of link local cidr " + NetUtils.getLinkLocalCIDR());	}	if (isCidrBlacklisted(cidr, vpc.getZoneId())) {	throw new InvalidParameterValueException("The static gateway cidr overlaps with one of the blacklisted routes of the zone the VPC belongs to");	}	return Transaction.execute(new TransactionCallbackWithException<StaticRouteVO, NetworkRuleConflictException>() {	public StaticRouteVO doInTransaction(final TransactionStatus status) throws NetworkRuleConflictException {	StaticRouteVO newRoute = new StaticRouteVO(gateway.getId(), cidr, vpc.getId(), vpc.getAccountId(), vpc.getDomainId());	
adding static route 

protected void markStaticRouteForRevoke(final StaticRouteVO route, final Account caller) {	
revoking static route 

protected void markStaticRouteForRevoke(final StaticRouteVO route, final Account caller) {	if (caller != null) {	_accountMgr.checkAccess(caller, null, false, route);	}	if (route.getState() == StaticRoute.State.Staged) {	if (s_logger.isDebugEnabled()) {	
found a static route that is still in stage state so just removing it 

if (caller != null) {	_accountMgr.checkAccess(caller, null, false, route);	}	if (route.getState() == StaticRoute.State.Staged) {	if (s_logger.isDebugEnabled()) {	}	_staticRouteDao.remove(route.getId());	} else if (route.getState() == StaticRoute.State.Add || route.getState() == StaticRoute.State.Active) {	route.setState(StaticRoute.State.Revoke);	_staticRouteDao.update(route.getId(), route);	
marked static route with state 

protected void runInContext() {	try {	final GlobalLock lock = GlobalLock.getInternLock("VpcCleanup");	if (lock == null) {	
couldn t get the global lock 

protected void runInContext() {	try {	final GlobalLock lock = GlobalLock.getInternLock("VpcCleanup");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	
couldn t lock the db 

final GlobalLock lock = GlobalLock.getInternLock("VpcCleanup");	if (lock == null) {	return;	}	if (!lock.lock(30)) {	return;	}	try {	final List<VpcVO> inactiveVpcs = _vpcDao.listInactiveVpcs();	if (inactiveVpcs != null) {	
found removed vpcs to cleanup 

if (lock == null) {	return;	}	if (!lock.lock(30)) {	return;	}	try {	final List<VpcVO> inactiveVpcs = _vpcDao.listInactiveVpcs();	if (inactiveVpcs != null) {	for (final VpcVO vpc : inactiveVpcs) {	
cleaning up 

return;	}	try {	final List<VpcVO> inactiveVpcs = _vpcDao.listInactiveVpcs();	if (inactiveVpcs != null) {	for (final VpcVO vpc : inactiveVpcs) {	destroyVpc(vpc, _accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM), User.UID_SYSTEM);	}	}	} catch (final Exception e) {	
exception 

if (inactiveVpcs != null) {	for (final VpcVO vpc : inactiveVpcs) {	destroyVpc(vpc, _accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM), User.UID_SYSTEM);	}	}	} catch (final Exception e) {	} finally {	lock.unlock();	}	} catch (final Exception e) {	
exception 

public IpAddress associateIPToVpc(final long ipId, final long vpcId) throws ResourceAllocationException, ResourceUnavailableException, InsufficientAddressCapacityException, ConcurrentOperationException {	final Account caller = CallContext.current().getCallingAccount();	Account owner = null;	final IpAddress ipToAssoc = _ntwkModel.getIp(ipId);	if (ipToAssoc != null) {	_accountMgr.checkAccess(caller, null, true, ipToAssoc);	owner = _accountMgr.getAccount(ipToAssoc.getAllocatedToAccountId());	} else {	
unable to find ip address by id 

}	final Vpc vpc = _vpcDao.findById(vpcId);	if (vpc == null) {	throw new InvalidParameterValueException("Invalid VPC id provided");	}	_accountMgr.checkAccess(caller, null, true, owner, vpc);	boolean isSourceNat = false;	if (getExistingSourceNatInVpc(owner.getId(), vpcId) == null) {	isSourceNat = true;	}	
associating ip to vpc 

final boolean isSourceNatFinal = isSourceNat;	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(final TransactionStatus status) {	final IPAddressVO ip = _ipAddressDao.findById(ipId);	ip.setVpcId(vpcId);	ip.setSourceNat(isSourceNatFinal);	_ipAddressDao.update(ipId, ip);	_ipAddrMgr.markPublicIpAsAllocated(ip);	}	});	
successfully assigned ip to vpc 

} catch (final ResourceUnavailableException ex) {	throw new CloudRuntimeException("Failed to apply ip associations for network id=" + networkId + " as a part of unassigning ip " + ipId + " from vpc", ex);	}	if (success) {	ip.setAssociatedWithNetworkId(null);	_ipAddressDao.update(ipId, ip);	s_logger.debug("IP address " + ip + " is no longer associated with the network inside vpc id=" + vpcId);	} else {	throw new CloudRuntimeException("Failed to apply ip associations for network id=" + networkId + " as a part of unassigning ip " + ipId + " from vpc");	}	
successfully released vpc ip address back to vpc pool 

========================= cloudstack sample_2350 =========================

public static void globalSetUp() throws Exception {	ApiConnectorFactory.setImplementation(ApiConnectorMock.class);	
mysql server is getting launched 

public static void globalSetUp() throws Exception {	ApiConnectorFactory.setImplementation(ApiConnectorMock.class);	s_mysqlSrverPort = TestDbSetup.init(null);	
mysql server launched on port 

public static void globalTearDown() throws Exception {	s_lockMaster.cleanupForServer(s_msId);	JmxUtil.unregisterMBean("Locks", "Locks");	s_lockMaster = null;	AbstractApplicationContext ctx = (AbstractApplicationContext)ComponentContext.getApplicationContext();	Map<String, ComponentLifecycle> lifecycleComponents = ctx.getBeansOfType(ComponentLifecycle.class);	for (ComponentLifecycle bean : lifecycleComponents.values()) {	bean.stop();	}	ctx.close();	
destroying mysql server instance running at port 

private void purgeTestNetwork() {	Account system = _accountMgr.getSystemAccount();	DataCenter zone = _server.getZone();	List<? extends Network> list = _networkService.getIsolatedNetworksOwnedByAccountInZone(zone.getId(), system);	for (Network net : list) {	
delete network 

public void deleteFloatingIp(IPAddressVO ip) throws Exception {	BaseCmd cmd = new DisableStaticNatCmd();	BaseCmd proxy = ComponentContext.inject(cmd);	ManagementServerMock.setParameter(proxy, "ipAddressId", BaseCmd.CommandType.LONG, ip.getId());	try {	proxy.execute();	} catch (Exception e) {	
disablestaticnatcmd exception 

Account system = _accountMgr.getSystemAccount();	DataCenter zone = _server.getZone();	ManagementServerMock.setParameter(proxy, "accountName", BaseCmd.CommandType.STRING, system.getAccountName());	ManagementServerMock.setParameter(proxy, "domainId", BaseCmd.CommandType.LONG, Domain.ROOT_DOMAIN);	ManagementServerMock.setParameter(proxy, "zoneId", BaseCmd.CommandType.LONG, zone.getId());	ManagementServerMock.setParameter(proxy, "networkId", BaseCmd.CommandType.LONG, network.getId());	try {	((AssociateIPAddrCmd)cmd).create();	((AssociateIPAddrCmd)cmd).execute();	} catch (Exception e) {	
associateipaddrcmd exception 

List<IPAddressVO> publicIps = _ipAddressDao.search(sc, null);	assertNotNull(publicIps);	cmd = new EnableStaticNatCmd();	proxy = ComponentContext.inject(cmd);	ManagementServerMock.setParameter(proxy, "ipAddressId", BaseCmd.CommandType.LONG, publicIps.get(0).getId());	ManagementServerMock.setParameter(proxy, "networkId", BaseCmd.CommandType.LONG, network.getId());	ManagementServerMock.setParameter(proxy, "virtualMachineId", BaseCmd.CommandType.LONG, vm.getId());	try {	proxy.execute();	} catch (Exception e) {	
enablestaticnatcmd exception 

BaseCmd proxy = ComponentContext.inject(cmd);	Account system = _accountMgr.getSystemAccount();	ManagementServerMock.setParameter(proxy, "accountName", BaseCmd.CommandType.STRING, system.getAccountName());	ManagementServerMock.setParameter(proxy, "domainId", BaseCmd.CommandType.LONG, Domain.ROOT_DOMAIN);	ManagementServerMock.setParameter(proxy, "name", BaseCmd.CommandType.STRING, name);	ManagementServerMock.setParameter(proxy, "displayText", BaseCmd.CommandType.STRING, name);	try {	((CreateProjectCmd)proxy).create();	((CreateProjectCmd)proxy).execute();	} catch (Exception e) {	
createprojectcmd exception 

ip_obj.setVirtualNetwork(net);	ip_obj.setVirtualMachineInterface(vmi);	try {	assertTrue(_api.create(ip_obj));	assertTrue(_api.read(ip_obj));	assertNotNull(ip_obj.getAddress());	} catch (IOException ex) {	fail(ex.getMessage());	}	if (_dbSync.syncAll(DBSyncGeneric.SYNC_MODE_UPDATE) == ServerDBSync.SYNC_STATE_OUT_OF_SYNC) {	
cloudstack db vnc are out of sync resync done 

try {	assertTrue(_api.create(ip_obj));	assertTrue(_api.read(ip_obj));	assertNotNull(ip_obj.getAddress());	} catch (IOException ex) {	fail(ex.getMessage());	}	if (_dbSync.syncAll(DBSyncGeneric.SYNC_MODE_UPDATE) == ServerDBSync.SYNC_STATE_OUT_OF_SYNC) {	}	if (_dbSync.syncAll(DBSyncGeneric.SYNC_MODE_CHECK) == ServerDBSync.SYNC_STATE_OUT_OF_SYNC) {	
cloudstack db vnc are still out of sync 

========================= cloudstack sample_1858 =========================

protected ReadyAnswer execute(ReadyCommand cmd) {	
pxe resource is ready 

========================= cloudstack sample_895 =========================

public ClusterService getPeerService(String strPeer) throws RemoteException {	try {	init();	} catch (ConfigurationException e) {	
unable to init clusterserviceservletadapter 

public String getServiceEndpointName(String strPeer) {	try {	init();	} catch (ConfigurationException e) {	
unable to init clusterserviceservletadapter 

private void init() throws ConfigurationException {	if (_mshostDao != null) return;	Properties dbProps = DbProperties.getDbProperties();	_clusterServicePort = NumbersUtil.parseInt(dbProps.getProperty("cluster.servlet.port"), DEFAULT_SERVICE_PORT);	
cluster servlet port 

========================= cloudstack sample_483 =========================

StringBuilder buff = new StringBuilder();	while (reader.ready()) {	buff.append(reader.readLine());	}	_process.destroy();	try {	while (reader.ready()) {	buff.append(reader.readLine());	}	} catch (IOException e) {	
ignored can not append line to buffer 

========================= cloudstack sample_2798 =========================

private LdapContext createInitialDirContext(final String principal, final String password, final String providerUrl, final boolean isSystemContext) throws NamingException, IOException {	Hashtable<String, String> environment = getEnvironment(principal, password, providerUrl, isSystemContext);	
initializing ldap with provider url 

private void enableSSL(final Hashtable<String, String> environment) {	final boolean sslStatus = _ldapConfiguration.getSSLStatus();	if (sslStatus) {	
ldap ssl enabled 

========================= cloudstack sample_1337 =========================

if (args.length < 3) {	printHelpMessage();	System.exit(1);	}	String host = args[0];	String port = args[1];	String password = args[2];	try {	new VncClient(host, Integer.parseInt(port), password, false, null);	} catch (NumberFormatException e) {	
incorrect vnc server port number 

System.exit(1);	}	String host = args[0];	String port = args[1];	String password = args[2];	try {	new VncClient(host, Integer.parseInt(port), password, false, null);	} catch (NumberFormatException e) {	System.exit(1);	} catch (UnknownHostException e) {	
incorrect vnc server host name 

String host = args[0];	String port = args[1];	String password = args[2];	try {	new VncClient(host, Integer.parseInt(port), password, false, null);	} catch (NumberFormatException e) {	System.exit(1);	} catch (UnknownHostException e) {	System.exit(1);	} catch (IOException e) {	
cannot communicate with vnc server 

String password = args[2];	try {	new VncClient(host, Integer.parseInt(port), password, false, null);	} catch (NumberFormatException e) {	System.exit(1);	} catch (UnknownHostException e) {	System.exit(1);	} catch (IOException e) {	System.exit(1);	} catch (Throwable e) {	
an error happened 

public void shutdown() {	if (sender != null) sender.closeConnection();	if (receiver != null) receiver.closeConnection();	if (is != null) {	try {	is.close();	} catch (Throwable e) {	
ignored failed to close resource for input 

if (is != null) {	try {	is.close();	} catch (Throwable e) {	}	}	if (os != null) {	try {	os.close();	} catch (Throwable e) {	
ignored failed to get close resource for output 

if (os != null) {	try {	os.close();	} catch (Throwable e) {	}	}	if (socket != null) {	try {	socket.close();	} catch (Throwable e) {	
ignored failed to get close resource for socket 

public void connectTo(String host, int port, String password) throws UnknownHostException, IOException {	
connecting to vnc server 

private void doConnect(String password) throws IOException {	is = new DataInputStream(socket.getInputStream());	os = new DataOutputStream(socket.getOutputStream());	handshake();	authenticate(password);	initialize();	
connecting to vnc server succeeded start session 

private void handshake() throws IOException {	byte[] buf = new byte[12];	is.readFully(buf);	String rfbProtocol = new String(buf);	if (!rfbProtocol.contains(RfbConstants.RFB_PROTOCOL_VERSION_MAJOR)) {	
cannot handshake with vnc server unsupported protocol version rfbprotocol 

private void authenticate(String password) throws IOException {	int authType = is.readInt();	switch (authType) {	case RfbConstants.CONNECTION_FAILED: {	int length = is.readInt();	byte[] buf = new byte[length];	is.readFully(buf);	String reason = new String(buf, RfbConstants.CHARSET);	
authentication to vnc server is failed reason 

int length = is.readInt();	byte[] buf = new byte[length];	is.readFully(buf);	String reason = new String(buf, RfbConstants.CHARSET);	throw new RuntimeException("Authentication to VNC server is failed. Reason: " + reason);	}	case RfbConstants.NO_AUTH: {	break;	}	case RfbConstants.VNC_AUTH: {	
vnc server requires password authentication 

String reason = new String(buf, RfbConstants.CHARSET);	throw new RuntimeException("Authentication to VNC server is failed. Reason: " + reason);	}	case RfbConstants.NO_AUTH: {	break;	}	case RfbConstants.VNC_AUTH: {	doVncAuth(password);	break;	}	
unsupported vnc protocol authorization scheme scheme code 

private void doVncAuth(String password) throws IOException {	byte[] challenge = new byte[16];	is.readFully(challenge);	byte[] response;	try {	response = encodePassword(challenge, password);	} catch (Exception e) {	
cannot encrypt client password to send to server 

} catch (Exception e) {	throw new RuntimeException("Cannot encrypt client password to send to server: " + e.getMessage());	}	os.write(response);	os.flush();	int authResult = is.readInt();	switch (authResult) {	case RfbConstants.VNC_AUTH_OK: {	break;	}	
connection to vnc server failed too many wrong attempts 

throw new RuntimeException("Cannot encrypt client password to send to server: " + e.getMessage());	}	os.write(response);	os.flush();	int authResult = is.readInt();	switch (authResult) {	case RfbConstants.VNC_AUTH_OK: {	break;	}	throw new RuntimeException("Connection to VNC server failed: too many wrong attempts.");	
connection to vnc server failed wrong password 

}	os.write(response);	os.flush();	int authResult = is.readInt();	switch (authResult) {	case RfbConstants.VNC_AUTH_OK: {	break;	}	throw new RuntimeException("Connection to VNC server failed: too many wrong attempts.");	throw new RuntimeException("Connection to VNC server failed: wrong password.");	
connection to vnc server failed reason code 

========================= cloudstack sample_4973 =========================

public static String checkTemplateFormat(String path, String uripath) {	String command = "file ";	if (isCompressedExtension(uripath)) {	command = "file -z ";	}	String output = Script.runSimpleBashScript(command + path + " | cut -d: -f2", 60000);	if ((output.contains("VMware") || output.contains("data")) && isCorrectExtension(uripath, "vmdk")) {	
file at path looks like a vmware image 

public static String checkTemplateFormat(String path, String uripath) {	String command = "file ";	if (isCompressedExtension(uripath)) {	command = "file -z ";	}	String output = Script.runSimpleBashScript(command + path + " | cut -d: -f2", 60000);	if ((output.contains("VMware") || output.contains("data")) && isCorrectExtension(uripath, "vmdk")) {	return "";	}	if ((output.contains("x86 boot") || output.contains("data")) && (isCorrectExtension(uripath, "raw") || isCorrectExtension(uripath, "img"))) {	
file at path looks like a raw image 

command = "file -z ";	}	String output = Script.runSimpleBashScript(command + path + " | cut -d: -f2", 60000);	if ((output.contains("VMware") || output.contains("data")) && isCorrectExtension(uripath, "vmdk")) {	return "";	}	if ((output.contains("x86 boot") || output.contains("data")) && (isCorrectExtension(uripath, "raw") || isCorrectExtension(uripath, "img"))) {	return "";	}	if (output.contains("QEMU QCOW") && isCorrectExtension(uripath, "qcow2")) {	
file at path looks like 

if ((output.contains("VMware") || output.contains("data")) && isCorrectExtension(uripath, "vmdk")) {	return "";	}	if ((output.contains("x86 boot") || output.contains("data")) && (isCorrectExtension(uripath, "raw") || isCorrectExtension(uripath, "img"))) {	return "";	}	if (output.contains("QEMU QCOW") && isCorrectExtension(uripath, "qcow2")) {	return "";	}	if (output.contains("Microsoft Disk Image") && (isCorrectExtension(uripath, "vhd") || isCorrectExtension(uripath, "vhdx"))) {	
file at path looks like vhd 

if ((output.contains("x86 boot") || output.contains("data")) && (isCorrectExtension(uripath, "raw") || isCorrectExtension(uripath, "img"))) {	return "";	}	if (output.contains("QEMU QCOW") && isCorrectExtension(uripath, "qcow2")) {	return "";	}	if (output.contains("Microsoft Disk Image") && (isCorrectExtension(uripath, "vhd") || isCorrectExtension(uripath, "vhdx"))) {	return "";	}	if (output.contains("POSIX tar") && isCorrectExtension(uripath, "ova")) {	
file at path looks like ova 

if (output.contains("QEMU QCOW") && isCorrectExtension(uripath, "qcow2")) {	return "";	}	if (output.contains("Microsoft Disk Image") && (isCorrectExtension(uripath, "vhd") || isCorrectExtension(uripath, "vhdx"))) {	return "";	}	if (output.contains("POSIX tar") && isCorrectExtension(uripath, "ova")) {	return "";	}	if (output.contains("POSIX tar") && isCorrectExtension(uripath, "tar")) {	
file at path looks like just tar 

if (output.contains("Microsoft Disk Image") && (isCorrectExtension(uripath, "vhd") || isCorrectExtension(uripath, "vhdx"))) {	return "";	}	if (output.contains("POSIX tar") && isCorrectExtension(uripath, "ova")) {	return "";	}	if (output.contains("POSIX tar") && isCorrectExtension(uripath, "tar")) {	return "";	}	if (output.contains("ISO 9660") && isCorrectExtension(uripath, "iso")) {	
file at path looks like an iso 

========================= cloudstack sample_2720 =========================

public void testMessageDetector() {	MessageDetector detector = new MessageDetector();	detector.open(_messageBus, new String[] {"VM", "Host"});	Thread thread = new Thread(new Runnable() {	public void run() {	for (int i = 0; i < 2; i++) {	try {	Thread.sleep(3000);	} catch (InterruptedException e) {	
ignored 

while (count < 2) {	detector.waitAny(1000);	count = count + 1;	}	} finally {	detector.close();	}	try {	thread.join();	} catch (InterruptedException e) {	
ignored 

========================= cloudstack sample_591 =========================

public void wakeupExisting() throws InterruptedException {	final ConstantTimeBackoff backoff = new ConstantTimeBackoff();	backoff.setTimeToWait(10);	Thread thread = new Thread(new Runnable() {	public void run() {	
before 

public void wakeupExisting() throws InterruptedException {	final ConstantTimeBackoff backoff = new ConstantTimeBackoff();	backoff.setTimeToWait(10);	Thread thread = new Thread(new Runnable() {	public void run() {	backoff.waitBeforeRetry();	
after 

public void wakeupExisting() throws InterruptedException {	final ConstantTimeBackoff backoff = new ConstantTimeBackoff();	backoff.setTimeToWait(10);	Thread thread = new Thread(new Runnable() {	public void run() {	backoff.waitBeforeRetry();	}	});	thread.start();	
thread started 

public void wakeupExisting() throws InterruptedException {	final ConstantTimeBackoff backoff = new ConstantTimeBackoff();	backoff.setTimeToWait(10);	Thread thread = new Thread(new Runnable() {	public void run() {	backoff.waitBeforeRetry();	}	});	thread.start();	Thread.sleep(100);	
testing wakeup 

========================= cloudstack sample_2665 =========================

if (config != null) {	String message = config.getJsonResponse();	if (message != null) {	String objectType = message.split(":")[0].substring(2).replace("\"", "");	String objectData = message.substring(message.indexOf(':') + 1, message.length() - 1);	if (objectType != null) {	Class<?> clz = null;	try {	clz = Class.forName(objectType);	} catch (ClassNotFoundException e) {	
ignored ping returned class 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	if (!super.configure(name, params)) {	
base class was unable to configure 

========================= cloudstack sample_987 =========================

ImageStoreResponse storeResponse;	if (result != null) {	storeResponse = _responseGenerator.createImageStoreResponse(result);	storeResponse.setResponseName(getCommandName());	storeResponse.setObjectName("imagestore");	setResponseObject(storeResponse);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to add S3 Image Store.");	}	} catch (DiscoveryException ex) {	
exception 

========================= cloudstack sample_3218 =========================

public Answer execute(final FenceCommand command, final XenServer56Resource xenServer56) {	final Connection conn = xenServer56.getConnection();	try {	final Boolean alive = xenServer56.checkHeartbeat(command.getHostGuid());	if ( alive == null ) {	
failed to check heartbeat so unable to fence 

public Answer execute(final FenceCommand command, final XenServer56Resource xenServer56) {	final Connection conn = xenServer56.getConnection();	try {	final Boolean alive = xenServer56.checkHeartbeat(command.getHostGuid());	if ( alive == null ) {	return new FenceAnswer(command, false, "Failed to check heartbeat, so unable to fence");	}	if ( alive ) {	
heart beat is still going so unable to fence 

final Set<VM> vms = VM.getByNameLabel(conn, command.getVmName());	for (final VM vm : vms) {	final Set<VDI> vdis = new HashSet<VDI>();	final Set<VBD> vbds = vm.getVBDs(conn);	for (final VBD vbd : vbds) {	final VDI vdi = vbd.getVDI(conn);	if (!xenServer56.isRefNull(vdi)) {	vdis.add(vdi);	}	}	
fence command for vm 

for (final String key : smConfig.keySet()) {	if (key.startsWith("host_")) {	vdi.removeFromSmConfig(conn, key);	break;	}	}	}	}	return new FenceAnswer(command);	} catch (final XmlRpcException e) {	
unable to fence 

vdi.removeFromSmConfig(conn, key);	break;	}	}	}	}	return new FenceAnswer(command);	} catch (final XmlRpcException e) {	return new FenceAnswer(command, false, e.getMessage());	} catch (final XenAPIException e) {	
unable to fence 

}	}	}	}	return new FenceAnswer(command);	} catch (final XmlRpcException e) {	return new FenceAnswer(command, false, e.getMessage());	} catch (final XenAPIException e) {	return new FenceAnswer(command, false, e.getMessage());	} catch (final Exception e) {	
unable to fence 

========================= cloudstack sample_1225 =========================

pstmt.setLong(1, accountId);	pstmt.setLong(2, volId);	pstmt.setInt(3, storageType);	pstmt.executeUpdate();	}catch(SQLException e) {	throw new CloudException("removeBy:Exception:"+e.getMessage(),e);	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error removing usagestoragevo 

pstmt.setLong(5, usage.getZoneId());	pstmt.executeUpdate();	}	}catch (SQLException e) {	throw new CloudException("UsageStorageVO update Error:"+e.getMessage(),e);	}	}	txn.commit();	} catch (Exception e) {	txn.rollback();	
error updating usagestoragevo 

if (deletedTS != null) {	deletedDate = DateUtil.parseDateString(s_gmtTimeZone, deletedTS);	}	usageRecords.add(new UsageStorageVO(id, zoneId, acctId, dId, type, sourceId, size, virtualSize, createdDate, deletedDate));	}	}catch(SQLException e) {	throw new CloudException("getUsageRecords:"+e.getMessage(),e);	}	}catch (Exception e) {	txn.rollback();	
getusagerecords exception 

========================= cloudstack sample_4477 =========================

public AsyncJobVO findInstancePendingAsyncJob(String instanceType, long instanceId) {	SearchCriteria<AsyncJobVO> sc = pendingAsyncJobSearch.create();	sc.setParameters("instanceType", instanceType);	sc.setParameters("instanceId", instanceId);	sc.setParameters("status", JobInfo.Status.IN_PROGRESS);	List<AsyncJobVO> l = listIncludingRemovedBy(sc);	if (l != null && l.size() > 0) {	if (l.size() > 1) {	
instance has multiple pending async job 

try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setInt(1, JobInfo.Status.FAILED.ordinal());	pstmt.setInt(2, jobResultCode);	pstmt.setString(3, jobResultMessage);	pstmt.setInt(4, JobInfo.Status.IN_PROGRESS.ordinal());	pstmt.setLong(5, msid);	pstmt.setLong(6, msid);	pstmt.execute();	} catch (SQLException e) {	
unable to reset job status for management server 

pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setInt(1, JobInfo.Status.FAILED.ordinal());	pstmt.setInt(2, jobResultCode);	pstmt.setString(3, jobResultMessage);	pstmt.setInt(4, JobInfo.Status.IN_PROGRESS.ordinal());	pstmt.setLong(5, msid);	pstmt.setLong(6, msid);	pstmt.execute();	} catch (SQLException e) {	} catch (Throwable e) {	
unable to reset job status for management server 

========================= cloudstack sample_712 =========================

public void mainLoop() {	while (true) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored 

========================= cloudstack sample_587 =========================

public void create() {	try {	StickinessPolicy result = _lbService.createLBStickinessPolicy(this);	this.setEntityId(result.getId());	this.setEntityUuid(result.getUuid());	} catch (NetworkRuleConflictException e) {	
exception 

========================= cloudstack sample_3432 =========================

u.setState(State.valueOf(rs.getString(5)));	AccountVO a = new AccountVO(rs.getLong(6));	a.setAccountName(rs.getString(7));	a.setType(rs.getShort(8));	a.setRoleId(rs.getLong(9));	a.setDomainId(rs.getLong(10));	a.setState(State.valueOf(rs.getString(11)));	userAcctPair = new Pair<User, Account>(u, a);	}	} catch (Exception e) {	
exception finding user acct by api key 

public long getDomainIdForGivenAccountId(long id) {	long domain_id = -1;	try {	AccountVO account_vo = findById(id);	domain_id = account_vo.getDomainId();	}	catch (Exception e) {	
getdomainidforgivenaccountid exception 

========================= cloudstack sample_4524 =========================

public void initialize(String serverAddress, int serverPort) {	_serverAddress = serverAddress;	_serverPort = serverPort;	_executor = Executors.newFixedThreadPool(_poolSize, new NamedThreadFactory("Transport-Worker"));	_connection = new ClientTransportConnection(this);	_executor.execute(new ManagedContextRunnable() {	protected void runInContext() {	try {	_connection.connect(_serverAddress, _serverPort);	} catch (Throwable e) {	
ignored error during ipc client initialization 

========================= cloudstack sample_641 =========================

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setString(1, syncObjType);	pstmt.setLong(2, syncObjId);	pstmt.setString(3, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), dt));	pstmt.setString(4, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), dt));	pstmt.execute();	} catch (SQLException e) {	
unable to create sync queue 

PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setString(1, syncObjType);	pstmt.setLong(2, syncObjId);	pstmt.setString(3, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), dt));	pstmt.setString(4, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), dt));	pstmt.execute();	} catch (SQLException e) {	} catch (Throwable e) {	
unable to create sync queue 

========================= cloudstack sample_704 =========================

public String callHostPlugin(final Connection conn, final String plugin, final String cmd, final String... params) {	final Map<String, String> args = new HashMap<String, String>();	String msg;	try {	for (int i = 0; i < params.length; i += 2) {	args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	
callhostplugin executing for command with 

String msg;	try {	for (int i = 0; i < params.length; i += 2) {	args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	}	final Host host = Host.getByUuid(conn, _host.getUuid());	final String result = host.callPlugin(conn, plugin, cmd, args);	if (s_logger.isTraceEnabled()) {	
callhostplugin result 

protected String callHostPluginAsync(final Connection conn, final String plugin, final String cmd, final int wait, final Map<String, String> params) {	final int timeout = wait * 1000;	final Map<String, String> args = new HashMap<String, String>();	Task task = null;	try {	for (final Map.Entry<String, String> entry : params.entrySet()) {	args.put(entry.getKey(), entry.getValue());	}	if (s_logger.isTraceEnabled()) {	
callhostplugin executing for command with 

args.put(entry.getKey(), entry.getValue());	}	if (s_logger.isTraceEnabled()) {	}	final Host host = Host.getByUuid(conn, _host.getUuid());	task = host.callPluginAsync(conn, plugin, cmd, args);	waitForTask(conn, task, 1000, timeout);	checkForSuccess(conn, task);	final String result = task.getResult(conn);	if (s_logger.isTraceEnabled()) {	
callhostplugin result 

}	final Host host = Host.getByUuid(conn, _host.getUuid());	task = host.callPluginAsync(conn, plugin, cmd, args);	waitForTask(conn, task, 1000, timeout);	checkForSuccess(conn, task);	final String result = task.getResult(conn);	if (s_logger.isTraceEnabled()) {	}	return result.replace("<value>", "").replace("</value>", "").replace("\n", "");	} catch (final Types.HandleInvalid e) {	
callhostplugin failed for cmd with args due to handleinvalid clazz handle 

final Host host = Host.getByUuid(conn, _host.getUuid());	task = host.callPluginAsync(conn, plugin, cmd, args);	waitForTask(conn, task, 1000, timeout);	checkForSuccess(conn, task);	final String result = task.getResult(conn);	if (s_logger.isTraceEnabled()) {	}	return result.replace("<value>", "").replace("</value>", "").replace("\n", "");	} catch (final Types.HandleInvalid e) {	} catch (final Exception e) {	
callhostplugin failed for cmd with args due to 

if (s_logger.isTraceEnabled()) {	}	return result.replace("<value>", "").replace("</value>", "").replace("\n", "");	} catch (final Types.HandleInvalid e) {	} catch (final Exception e) {	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e1) {	
unable to destroy task on host due to 

protected String callHostPluginAsync(final Connection conn, final String plugin, final String cmd, final int wait, final String... params) {	final int timeout = wait * 1000;	final Map<String, String> args = new HashMap<String, String>();	Task task = null;	try {	for (int i = 0; i < params.length; i += 2) {	args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	
callhostplugin executing for command with 

args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	}	final Host host = Host.getByUuid(conn, _host.getUuid());	task = host.callPluginAsync(conn, plugin, cmd, args);	waitForTask(conn, task, 1000, timeout);	checkForSuccess(conn, task);	final String result = task.getResult(conn);	if (s_logger.isTraceEnabled()) {	
callhostplugin result 

}	final Host host = Host.getByUuid(conn, _host.getUuid());	task = host.callPluginAsync(conn, plugin, cmd, args);	waitForTask(conn, task, 1000, timeout);	checkForSuccess(conn, task);	final String result = task.getResult(conn);	if (s_logger.isTraceEnabled()) {	}	return result.replace("<value>", "").replace("</value>", "").replace("\n", "");	} catch (final Types.HandleInvalid e) {	
callhostplugin failed for cmd with args due to handleinvalid clazz handle 

final Host host = Host.getByUuid(conn, _host.getUuid());	task = host.callPluginAsync(conn, plugin, cmd, args);	waitForTask(conn, task, 1000, timeout);	checkForSuccess(conn, task);	final String result = task.getResult(conn);	if (s_logger.isTraceEnabled()) {	}	return result.replace("<value>", "").replace("</value>", "").replace("\n", "");	} catch (final Types.HandleInvalid e) {	} catch (final XenAPIException e) {	
callhostplugin failed for cmd with args due to 

task = host.callPluginAsync(conn, plugin, cmd, args);	waitForTask(conn, task, 1000, timeout);	checkForSuccess(conn, task);	final String result = task.getResult(conn);	if (s_logger.isTraceEnabled()) {	}	return result.replace("<value>", "").replace("</value>", "").replace("\n", "");	} catch (final Types.HandleInvalid e) {	} catch (final XenAPIException e) {	} catch (final Exception e) {	
callhostplugin failed for cmd with args due to 

}	return result.replace("<value>", "").replace("</value>", "").replace("\n", "");	} catch (final Types.HandleInvalid e) {	} catch (final XenAPIException e) {	} catch (final Exception e) {	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e1) {	
unable to destroy task on host due to 

try {	final Map<Pool, Pool.Record> poolRecs = Pool.getAllRecords(conn);	if (poolRecs.size() != 1) {	throw new CloudRuntimeException("There are " + poolRecs.size() + " pool for host :" + _host.getUuid());	}	final Host master = poolRecs.values().iterator().next().master;	for (int i = 0; i < params.length; i += 2) {	args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	
callhostplugin executing for command with 

throw new CloudRuntimeException("There are " + poolRecs.size() + " pool for host :" + _host.getUuid());	}	final Host master = poolRecs.values().iterator().next().master;	for (int i = 0; i < params.length; i += 2) {	args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	}	final String result = master.callPlugin(conn, plugin, cmd, args);	if (s_logger.isTraceEnabled()) {	
callhostplugin result 

for (int i = 0; i < params.length; i += 2) {	args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	}	final String result = master.callPlugin(conn, plugin, cmd, args);	if (s_logger.isTraceEnabled()) {	}	return result.replace("\n", "");	} catch (final Types.HandleInvalid e) {	
callhostplugin failed for cmd with args due to handleinvalid clazz handle 

args.put(params[i], params[i + 1]);	}	if (s_logger.isTraceEnabled()) {	}	final String result = master.callPlugin(conn, plugin, cmd, args);	if (s_logger.isTraceEnabled()) {	}	return result.replace("\n", "");	} catch (final Types.HandleInvalid e) {	} catch (final XenAPIException e) {	
callhostplugin failed for cmd with args due to 

}	if (s_logger.isTraceEnabled()) {	}	final String result = master.callPlugin(conn, plugin, cmd, args);	if (s_logger.isTraceEnabled()) {	}	return result.replace("\n", "");	} catch (final Types.HandleInvalid e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
callhostplugin failed for cmd with args due to 

public void checkForSuccess(final Connection c, final Task task) throws XenAPIException, XmlRpcException {	if (task.getStatus(c) == Types.TaskStatusType.SUCCESS) {	if (s_logger.isTraceEnabled()) {	
task completed 

protected boolean checkSR(final Connection conn, final SR sr) {	try {	final SR.Record srr = sr.getRecord(conn);	final Set<PBD> pbds = sr.getPBDs(conn);	if (pbds.size() == 0) {	final String msg = "There is no PBDs for this SR: " + srr.nameLabel + " on host:" + _host.getUuid();	s_logger.warn(msg);	return false;	}	if (s_logger.isDebugEnabled()) {	
checking or sr on 

for (final Map.Entry<VM, VM.Record> entry : vms.entrySet()) {	final VM vm = entry.getKey();	final VM.Record vmRec = entry.getValue();	if (vmRec.isATemplate || vmRec.isControlDomain) {	continue;	}	if (VmPowerState.HALTED.equals(vmRec.powerState) && vmRec.affinity.equals(host) && !isAlienVm(vm, conn)) {	try {	vm.destroy(conn);	} catch (final Exception e) {	
catch exception unable to destroy vm due to 

if (correctVif != null) {	network = correctVif.getNetwork(conn);	networkUsage(conn, routerIp, "deleteVif", "eth" + correctVif.getDevice(conn));	correctVif.unplug(conn);	correctVif.destroy(conn);	disableVlanNetwork(conn, network);	}	}	}	} catch (final Exception e) {	
ip assoc failure on applying one ip due to exception 

public void cleanupTemplateSR(final Connection conn) {	Set<PBD> pbds = null;	try {	final Host host = Host.getByUuid(conn, _host.getUuid());	pbds = host.getPBDs(conn);	} catch (final XenAPIException e) {	
unable to get the srs 

} catch (final Exception e) {	throw new CloudRuntimeException("Unable to get SRs " + e.getMessage(), e);	}	for (final PBD pbd : pbds) {	SR sr = null;	SR.Record srRec = null;	try {	sr = pbd.getSR(conn);	srRec = sr.getRecord(conn);	} catch (final Exception e) {	
pbd getsr get exception due to 

final String type = srRec.type;	if (srRec.shared) {	continue;	}	if (SRType.NFS.equals(type) || SRType.ISO.equals(type) && srRec.nameDescription.contains("template")) {	try {	pbd.unplug(conn);	pbd.destroy(conn);	sr.forget(conn);	} catch (final Exception e) {	
forget sr catch exception due to 

final Set<VIF> dom0Vifs = dom0.getVIFs(conn);	for (final VIF v : dom0Vifs) {	String vifName = "unknown";	try {	final VIF.Record vifr = v.getRecord(conn);	if (v.getNetwork(conn).getUuid(conn).equals(nw.getUuid(conn))) {	if (vifr != null) {	final Map<String, String> config = vifr.otherConfig;	vifName = config.get("nameLabel");	}	
a vif in for the network is found so destroy the vif 

for (final VIF v : dom0Vifs) {	String vifName = "unknown";	try {	final VIF.Record vifr = v.getRecord(conn);	if (v.getNetwork(conn).getUuid(conn).equals(nw.getUuid(conn))) {	if (vifr != null) {	final Map<String, String> config = vifr.otherConfig;	vifName = config.get("nameLabel");	}	v.destroy(conn);	
destroy temp vif success 

try {	final VIF.Record vifr = v.getRecord(conn);	if (v.getNetwork(conn).getUuid(conn).equals(nw.getUuid(conn))) {	if (vifr != null) {	final Map<String, String> config = vifr.otherConfig;	vifName = config.get("nameLabel");	}	v.destroy(conn);	}	} catch (final Exception e) {	
destroy temp vif failed 

task = vdi.copyAsync(conn, sr);	waitForTask(conn, task, 1000, (long) wait * 1000);	checkForSuccess(conn, task);	final VDI dvdi = Types.toVDI(task, conn);	return dvdi;	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e) {	
unable to destroy task on host due to 

} else {	result = callHostPlugin(conn, "ovstunnel", "setup_ovs_bridge", "bridge", bridge, "key", bridgeName, "xs_nw_uuid", nw.getUuid(conn), "cs_host_id", ((Long) hostId).toString());	}	final String[] res = result.split(":");	if (res.length != 2 || !res[0].equalsIgnoreCase("SUCCESS")) {	throw new CloudRuntimeException("Unable to pre-configure OVS bridge " + bridge);	}	}	return nw;	} catch (final Exception e) {	
createandconfiguretunnelnetwork failed 

final String msg = "VM " + vmName + " is not running";	s_logger.warn(msg);	return msg;	}	} catch (final Exception e) {	final String msg = "VM.getByNameLabel " + vmName + " failed due to " + e.toString();	s_logger.warn(msg, e);	return msg;	}	if (s_logger.isDebugEnabled()) {	
trying to connect to attempt of 

public ExecutionResult createFileInVR(final String routerIp, final String path, final String filename, final String content) {	final Connection conn = getConnection();	final String hostPath = "/tmp/";	
copying vr with ip config file into host 

public ExecutionResult createFileInVR(final String routerIp, final String path, final String filename, final String content) {	final Connection conn = getConnection();	final String hostPath = "/tmp/";	try {	SshHelper.scpTo(_host.getIp(), 22, _username, null, _password.peek(), hostPath, content.getBytes(Charset.defaultCharset()), filename, null);	} catch (final Exception e) {	
scp vr config file into host failed with exception 

public ExecutionResult createFileInVR(final String routerIp, final String path, final String filename, final String content) {	final Connection conn = getConnection();	final String hostPath = "/tmp/";	try {	SshHelper.scpTo(_host.getIp(), 22, _username, null, _password.peek(), hostPath, content.getBytes(Charset.defaultCharset()), filename, null);	} catch (final Exception e) {	}	final String rc = callHostPlugin(conn, "vmops", "createFileInDomr", "domrip", routerIp, "srcfilepath", hostPath + filename, "dstfilepath", path);	
vr config file got created in vr ip with content 

protected SR createNfsSRbyURI(final Connection conn, final URI uri, final boolean shared) {	try {	if (s_logger.isDebugEnabled()) {	
creating a shared sr for not shared sr for 

}	}	final Host host = Host.getByUuid(conn, _host.getUuid());	final Map<String, String> smConfig = new HashMap<String, String>();	smConfig.put("nosubdir", "true");	final SR sr = SR.create(conn, host, deviceConfig, new Long(0), name, uri.getHost() + uri.getPath(), SRType.NFS.toString(), "user", shared, smConfig);	if (!checkSR(conn, sr)) {	throw new Exception("no attached PBD");	}	if (s_logger.isDebugEnabled()) {	
created a sr uuid is device config is 

vbdr.type = Types.VbdType.DISK;	vbdr.unpluggable = (volume.getType() == Volume.Type.ROOT) ? false : true;	vbdr.userdevice = "autodetect";	final Long deviceId = volume.getDiskSeq();	if (deviceId != null && (!isDeviceUsed(conn, vm, deviceId) || deviceId > 3)) {	vbdr.userdevice = deviceId.toString();	}	}	final VBD vbd = VBD.create(conn, vbdr);	if (s_logger.isDebugEnabled()) {	
vbd created for 

public VIF createVif(final Connection conn, final String vmName, final VM vm, final VirtualMachineTO vmSpec, final NicTO nic) throws XmlRpcException, XenAPIException {	assert nic.getUuid() != null : "Nic should have a uuid value";	if (s_logger.isDebugEnabled()) {	
creating vif for on nic 

if (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) {	vifr.qosAlgorithmType = "ratelimit";	vifr.qosAlgorithmParams = new HashMap<String, String>();	vifr.qosAlgorithmParams.put("kbps", Integer.toString(nic.getNetworkRateMbps() * 128));	}	vifr.lockingMode = Types.VifLockingMode.NETWORK_DEFAULT;	final VIF vif = VIF.create(conn, vifr);	if (s_logger.isDebugEnabled()) {	vifr = vif.getRecord(conn);	if (vifr != null) {	
created a vif on 

vmr.memoryDynamicMax = vmSpec.getMaxRam();	if (guestOsTypeName.toLowerCase().contains("windows")) {	vmr.VCPUsMax = (long) vmSpec.getCpus();	} else {	if (vmSpec.getVcpuMaxLimit() != null) {	vmr.VCPUsMax = (long) vmSpec.getVcpuMaxLimit();	}	}	} else {	if (vmSpec.isEnableDynamicallyScaleVm() && !isDmcEnabled(conn, host)) {	
host does not support dynamic scaling so the vm is not dynamically scalable 

vmr.memoryStaticMax = vmSpec.getMaxRam();	vmr.memoryDynamicMin = vmSpec.getMinRam();	;	vmr.memoryDynamicMax = vmSpec.getMaxRam();	vmr.VCPUsMax = (long) vmSpec.getCpus();	}	vmr.VCPUsAtStartup = (long) vmSpec.getCpus();	vmr.consoles.clear();	final VM vm = VM.create(conn, vmr);	if (s_logger.isDebugEnabled()) {	
created vm for 

vcpuParams.put("cap", Integer.toString(utilization));	}	if (vcpuParams.size() > 0) {	vm.setVCPUsParams(conn, vcpuParams);	}	final String bootArgs = vmSpec.getBootArgs();	if (bootArgs != null && bootArgs.length() > 0) {	String pvargs = vm.getPVArgs(conn);	pvargs = pvargs + vmSpec.getBootArgs().replaceAll(" ", "%");	if (s_logger.isDebugEnabled()) {	
pv args are 

final VM template = getVM(conn, guestOsTypeName);	final VM vm = template.createClone(conn, vmName);	vm.setIsATemplate(conn, false);	final Map<VDI, VolumeObjectTO> vdiMap = new HashMap<VDI, VolumeObjectTO>();	for (final VolumeObjectTO volume : listVolumeTo) {	final String vdiUuid = volume.getPath();	try {	final VDI vdi = VDI.getByUuid(conn, vdiUuid);	vdiMap.put(vdi, volume);	} catch (final Types.UuidInvalid e) {	
unable to find vdi by uuid skip it 

final Set<VBD> vbds = vm.getVBDs(conn);	for (final VBD vbd : vbds) {	if (vbd.getType(conn) == Types.VbdType.CD) {	vbd.eject(conn);	vbd.destroy(conn);	break;	}	}	}	} catch (final Exception e) {	
cannot destory cd rom device for vm due to 

public synchronized void destroyTunnelNetwork(final Connection conn, final Network nw, final long hostId) {	try {	final String bridge = nw.getBridge(conn);	final String result = callHostPlugin(conn, "ovstunnel", "destroy_ovs_bridge", "bridge", bridge, "cs_host_id", ((Long) hostId).toString());	final String[] res = result.split(":");	if (res.length != 2 || !res[0].equalsIgnoreCase("SUCCESS")) {	throw new CloudRuntimeException("Unable to remove OVS bridge " + bridge + ":" + result);	}	return;	} catch (final Exception e) {	
destroytunnelnetwork failed 

sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final String cmd = "ping -c 2 " + computingHostIp;	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, cmd)) {	throw new CloudRuntimeException("Cannot ping host " + computingHostIp + " from host " + _host.getIp());	}	return true;	} catch (final Exception e) {	
catch exception 

protected Network enableVlanNetwork(final Connection conn, final long tag, final XsLocalNetwork network) throws XenAPIException, XmlRpcException {	Network vlanNetwork = null;	final String oldName = "VLAN" + Long.toString(tag);	final String newName = "VLAN-" + network.getNetworkRecord(conn).uuid + "-" + tag;	XsLocalNetwork vlanNic = getNetworkByName(conn, newName);	if (vlanNic == null) {	if (s_logger.isDebugEnabled()) {	
couldn t find vlan network with the new name so trying old name 

protected Network enableVlanNetwork(final Connection conn, final long tag, final XsLocalNetwork network) throws XenAPIException, XmlRpcException {	Network vlanNetwork = null;	final String oldName = "VLAN" + Long.toString(tag);	final String newName = "VLAN-" + network.getNetworkRecord(conn).uuid + "-" + tag;	XsLocalNetwork vlanNic = getNetworkByName(conn, newName);	if (vlanNic == null) {	if (s_logger.isDebugEnabled()) {	}	vlanNic = getNetworkByName(conn, oldName);	if (vlanNic != null) {	
renaming vlan with old name to 

if (vlanNic == null) {	if (s_logger.isDebugEnabled()) {	}	vlanNic = getNetworkByName(conn, oldName);	if (vlanNic != null) {	vlanNic.getNetwork().setNameLabel(conn, newName);	}	}	if (vlanNic == null) {	if (s_logger.isDebugEnabled()) {	
creating vlan network for on host 

throw new CloudRuntimeException("Could not find/create vlan network with name: " + newName);	}	}	final PIF nPif = network.getPif(conn);	final PIF.Record nPifr = network.getPifRecord(conn);	vlanNetwork = vlanNic.getNetwork();	if (vlanNic.getPif(conn) != null) {	return vlanNetwork;	}	if (s_logger.isDebugEnabled()) {	
creating vlan on host on device 

if (vlanNic.getPif(conn) != null) {	return vlanNetwork;	}	if (s_logger.isDebugEnabled()) {	}	final VLAN vlan = VLAN.create(conn, nPif, tag, vlanNetwork);	if (vlan != null) {	final VLAN.Record vlanr = vlan.getRecord(conn);	if (vlanr != null) {	if (s_logger.isDebugEnabled()) {	
vlan is created for the uuid is 

public ExecutionResult executeInVR(final String routerIP, final String script, final String args, final Duration timeout) {	Pair<Boolean, String> result;	String cmdline = "/opt/cloud/bin/router_proxy.sh " + script + " " + routerIP + " " + args;	cmdline = cmdline.replaceAll(";", "\\\\;");	try {	
executing command in vr 

for (final VM vm : vms) {	if (vm.getIsControlDomain(conn)) {	dom0Ram = vm.getMemoryStaticMax(conn);	break;	}	}	ram = (long) ((ram - dom0Ram - _xsMemoryUsed) * _xsVirtualizationFactor);	cmd.setMemory(ram);	cmd.setDom0MinMemory(dom0Ram);	if (s_logger.isDebugEnabled()) {	
total ram ram 

cmd.setIqn(configs.get("iscsi_iqn"));	cmd.setPod(_pod);	cmd.setVersion(CitrixResourceBase.class.getPackage().getImplementationVersion());	try {	final String cmdLine = "xe sm-list | grep \"resigning of duplicates\"";	final XenServerUtilitiesHelper xenServerUtilitiesHelper = getXenServerUtilitiesHelper();	Pair<Boolean, String> result = xenServerUtilitiesHelper.executeSshWrapper(_host.getIp(), 22, _username, null, getPwdFromQueue(), cmdLine);	boolean supportsClonedVolumes = result != null && result.first() != null && result.first() && result.second() != null && result.second().length() > 0;	cmd.setSupportsClonedVolumes(supportsClonedVolumes);	} catch (NumberFormatException ex) {	
issue sending xe sm list via ssh to xenserver host 

final Network.Record rec = new Network.Record();	final Set<Network> networks = Network.getByNameLabel(conn, nwName);	if (networks.size() == 0) {	rec.nameDescription = "tunnel network id# " + nwName;	rec.nameLabel = nwName;	final Map<String, String> otherConfig = new HashMap<String, String>();	otherConfig.put("ovs-host-setup", "");	otherConfig.put("assume_network_is_shared", "true");	rec.otherConfig = otherConfig;	nw = Network.create(conn, rec);	
xenserver network for tunnels created 

if (networks.size() == 0) {	rec.nameDescription = "tunnel network id# " + nwName;	rec.nameLabel = nwName;	final Map<String, String> otherConfig = new HashMap<String, String>();	otherConfig.put("ovs-host-setup", "");	otherConfig.put("assume_network_is_shared", "true");	rec.otherConfig = otherConfig;	nw = Network.create(conn, rec);	} else {	nw = networks.iterator().next();	
xenserver network for tunnels found 

final Map<String, String> otherConfig = new HashMap<String, String>();	otherConfig.put("ovs-host-setup", "");	otherConfig.put("assume_network_is_shared", "true");	rec.otherConfig = otherConfig;	nw = Network.create(conn, rec);	} else {	nw = networks.iterator().next();	}	return nw;	} catch (final Exception e) {	
createtunnelnetwork failed 

public PingCommand getCurrentStatus(final long id) {	try {	if (!pingXAPI()) {	Thread.sleep(1000);	if (!pingXAPI()) {	
can not ping xenserver 

if (!_canBridgeFirewall && !_isOvs) {	return new PingRoutingCommand(getType(), id, getHostVmStateReport(conn));	} else if (_isOvs) {	final List<Pair<String, Long>> ovsStates = ovsFullSyncStates();	return new PingRoutingWithOvsCommand(getType(), id, getHostVmStateReport(conn), ovsStates);	} else {	final HashMap<String, Pair<Long, Long>> nwGrpStates = syncNetworkGroups(conn, id);	return new PingRoutingWithNwGroupsCommand(getType(), id, getHostVmStateReport(conn), nwGrpStates);	}	} catch (final Exception e) {	
unable to get current status 

if (!Double.isInfinite(value) && !Double.isNaN(value)) {	return value;	} else {	s_logger.warn("Found an invalid value (infinity/NaN) in getDataAverage(), numRows=0");	return dummy;	}	} else {	if (!Double.isInfinite(value / numRowsUsed) && !Double.isNaN(value / numRowsUsed)) {	return value / numRowsUsed;	} else {	
found an invalid value infinity nan in getdataaverage numrows 

protected String getGuestOsType(String platformEmulator) {	if (org.apache.commons.lang.StringUtils.isBlank(platformEmulator)) {	
no guest os type start it as hvm guest 

_host.setProductVersion(CitrixHelper.getProductVersion(hr));	final XsLocalNetwork privateNic = getManagementNetwork(conn);	_privateNetworkName = privateNic.getNetworkRecord(conn).nameLabel;	_host.setPrivatePif(privateNic.getPifRecord(conn).uuid);	_host.setPrivateNetwork(privateNic.getNetworkRecord(conn).uuid);	_host.setSystemvmisouuid(null);	XsLocalNetwork guestNic = null;	if (_guestNetworkName != null && !_guestNetworkName.equals(_privateNetworkName)) {	guestNic = getNetworkByName(conn, _guestNetworkName);	if (guestNic == null) {	
unable to find guest network 

} else {	guestNic = privateNic;	_guestNetworkName = _privateNetworkName;	}	_host.setGuestNetwork(guestNic.getNetworkRecord(conn).uuid);	_host.setGuestPif(guestNic.getPifRecord(conn).uuid);	XsLocalNetwork publicNic = null;	if (_publicNetworkName != null && !_publicNetworkName.equals(_guestNetworkName)) {	publicNic = getNetworkByName(conn, _publicNetworkName);	if (publicNic == null) {	
unable to find public network for host 

_publicNetworkName = _guestNetworkName;	}	_host.setPublicPif(publicNic.getPifRecord(conn).uuid);	_host.setPublicNetwork(publicNic.getNetworkRecord(conn).uuid);	if (_storageNetworkName1 == null) {	_storageNetworkName1 = _guestNetworkName;	}	XsLocalNetwork storageNic1 = null;	storageNic1 = getNetworkByName(conn, _storageNetworkName1);	if (storageNic1 == null) {	
unable to find storage network for host 

_host.setStorageNetwork1(storageNic1.getNetworkRecord(conn).uuid);	_host.setStoragePif1(storageNic1.getPifRecord(conn).uuid);	}	XsLocalNetwork storageNic2 = null;	if (_storageNetworkName2 != null) {	storageNic2 = getNetworkByName(conn, _storageNetworkName2);	if (storageNic2 != null) {	_host.setStoragePif2(storageNic2.getPifRecord(conn).uuid);	}	}	
xenserver version is for host 

_host.setStorageNetwork1(storageNic1.getNetworkRecord(conn).uuid);	_host.setStoragePif1(storageNic1.getPifRecord(conn).uuid);	}	XsLocalNetwork storageNic2 = null;	if (_storageNetworkName2 != null) {	storageNic2 = getNetworkByName(conn, _storageNetworkName2);	if (storageNic2 != null) {	_host.setStoragePif2(storageNic2.getPifRecord(conn).uuid);	}	}	
private network is for host 

_host.setStorageNetwork1(storageNic1.getNetworkRecord(conn).uuid);	_host.setStoragePif1(storageNic1.getPifRecord(conn).uuid);	}	XsLocalNetwork storageNic2 = null;	if (_storageNetworkName2 != null) {	storageNic2 = getNetworkByName(conn, _storageNetworkName2);	if (storageNic2 != null) {	_host.setStoragePif2(storageNic2.getPifRecord(conn).uuid);	}	}	
guest network is for host 

_host.setStorageNetwork1(storageNic1.getNetworkRecord(conn).uuid);	_host.setStoragePif1(storageNic1.getPifRecord(conn).uuid);	}	XsLocalNetwork storageNic2 = null;	if (_storageNetworkName2 != null) {	storageNic2 = getNetworkByName(conn, _storageNetworkName2);	if (storageNic2 != null) {	_host.setStoragePif2(storageNic2.getPifRecord(conn).uuid);	}	}	
public network is for host 

}	XsLocalNetwork storageNic2 = null;	if (_storageNetworkName2 != null) {	storageNic2 = getNetworkByName(conn, _storageNetworkName2);	if (storageNic2 != null) {	_host.setStoragePif2(storageNic2.getPifRecord(conn).uuid);	}	}	return true;	} catch (final XenAPIException e) {	
unable to get host information for 

if (_storageNetworkName2 != null) {	storageNic2 = getNetworkByName(conn, _storageNetworkName2);	if (storageNic2 != null) {	_host.setStoragePif2(storageNic2.getPifRecord(conn).uuid);	}	}	return true;	} catch (final XenAPIException e) {	return false;	} catch (final Exception e) {	
unable to get host information for 

protected HashMap<String, HostVmStateReportEntry> getHostVmStateReport(final Connection conn) {	final HashMap<String, HostVmStateReportEntry> vmStates = new HashMap<String, HostVmStateReportEntry>();	Map<VM, VM.Record> vm_map = null;	for (int i = 0; i < 2; i++) {	try {	vm_map = VM.getAllRecords(conn);	break;	} catch (final Throwable e) {	
unable to get vms 

if (record.isControlDomain || record.isASnapshot || record.isATemplate) {	continue;	}	final VmPowerState ps = record.powerState;	final Host host = record.residentOn;	String host_uuid = null;	if (!isRefNull(host)) {	try {	host_uuid = host.getUuid(conn);	} catch (final BadServerResponse e) {	
failed to get host uuid for host 

continue;	}	final VmPowerState ps = record.powerState;	final Host host = record.residentOn;	String host_uuid = null;	if (!isRefNull(host)) {	try {	host_uuid = host.getUuid(conn);	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	
failed to get host uuid for host 

}	final VmPowerState ps = record.powerState;	final Host host = record.residentOn;	String host_uuid = null;	if (!isRefNull(host)) {	try {	host_uuid = host.getUuid(conn);	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
failed to get host uuid for host 

final List<Integer> usedDeviceNums = new ArrayList<Integer>();	final Set<VIF> vifs = vm.getVIFs(conn);	final Iterator<VIF> vifIter = vifs.iterator();	while (vifIter.hasNext()) {	final VIF vif = vifIter.next();	try {	final String deviceId = vif.getDevice(conn);	if (vm.getIsControlDomain(conn) || vif.getCurrentlyAttached(conn)) {	usedDeviceNums.add(Integer.valueOf(deviceId));	} else {	
found unplugged vif in vm destroy it 

vif.destroy(conn);	}	} catch (final NumberFormatException e) {	final String msg = "Obtained an invalid value for an allocated VIF device number for VM: " + vmName;	s_logger.debug(msg, e);	throw new CloudRuntimeException(msg);	}	}	for (Integer i = 0; i < _maxNics; i++) {	if (!usedDeviceNums.contains(i)) {	
lowest available vif device number for vm 

public XsLocalNetwork getNativeNetworkForTraffic(final Connection conn, final TrafficType type, final String name) throws XenAPIException, XmlRpcException {	if (name != null) {	if (s_logger.isDebugEnabled()) {	
looking for network named 

public Network getNetwork(final Connection conn, final NicTO nic) throws XenAPIException, XmlRpcException {	final String name = nic.getName();	final XsLocalNetwork network = getNativeNetworkForTraffic(conn, nic.getType(), name);	if (network == null) {	
network is not configured on the backend for nic 

public XsLocalNetwork getNetworkByName(final Connection conn, final String name) throws XenAPIException, XmlRpcException {	final Set<Network> networks = Network.getByNameLabel(conn, name);	if (networks.size() == 1) {	return new XsLocalNetwork(this, networks.iterator().next(), null, null, null);	}	if (networks.size() == 0) {	return null;	}	if (s_logger.isDebugEnabled()) {	
found more than one network with the name 

protected abstract String getPatchFilePath();	public String getPerfMon(final Connection conn, final Map<String, String> params, final int wait) {	String result = null;	try {	result = callHostPluginAsync(conn, "vmopspremium", "asmonitor", 60, params);	if (result != null) {	return result;	}	} catch (final Exception e) {	
can not get performance monitor for as due to 

protected Object[] getRRDData(final Connection conn, final int flag) {	Document doc = null;	try {	doc = getStatsRawXML(conn, flag == 1 ? true : false);	} catch (final Exception e1) {	
error whilst collecting raw stats from plugin 

private long getStaticMax(final String os, final boolean b, final long dynamicMinRam, final long dynamicMaxRam) {	final long recommendedValue = CitrixHelper.getXenServerStaticMax(os, b);	if (recommendedValue == 0) {	
no recommended value found for dynamic max setting static max and dynamic max equal 

private long getStaticMax(final String os, final boolean b, final long dynamicMinRam, final long dynamicMaxRam) {	final long recommendedValue = CitrixHelper.getXenServerStaticMax(os, b);	if (recommendedValue == 0) {	return dynamicMaxRam;	}	final long staticMax = Math.min(recommendedValue, 4l * dynamicMinRam);	if (dynamicMaxRam > staticMax) {	
dynamixmax cant be greater than static max can lead to stability issues setting static max as much as dynamic max 

private long getStaticMin(final String os, final boolean b, final long dynamicMinRam, final long dynamicMaxRam) {	final long recommendedValue = CitrixHelper.getXenServerStaticMin(os, b);	if (recommendedValue == 0) {	
no recommended value found for dynamic min 

private long getStaticMin(final String os, final boolean b, final long dynamicMinRam, final long dynamicMaxRam) {	final long recommendedValue = CitrixHelper.getXenServerStaticMin(os, b);	if (recommendedValue == 0) {	return dynamicMinRam;	}	if (dynamicMinRam < recommendedValue) {	
vm is set to dynamixmin less than the recommended static min could lead to stability issues 

URL url;	BufferedReader in = null;	try {	url = new URL(urlStr);	url.openConnection();	final URLConnection uc = url.openConnection();	in = new BufferedReader(new InputStreamReader(uc.getInputStream()));	final InputSource statsSource = new InputSource(in);	return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(statsSource);	} catch (final MalformedURLException e) {	
malformed url come on 

try {	url = new URL(urlStr);	url.openConnection();	final URLConnection uc = url.openConnection();	in = new BufferedReader(new InputStreamReader(uc.getInputStream()));	final InputSource statsSource = new InputSource(in);	return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(statsSource);	} catch (final MalformedURLException e) {	return null;	} catch (final IOException e) {	
problems getting stats using 

url.openConnection();	final URLConnection uc = url.openConnection();	in = new BufferedReader(new InputStreamReader(uc.getInputStream()));	final InputSource statsSource = new InputSource(in);	return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(statsSource);	} catch (final MalformedURLException e) {	return null;	} catch (final IOException e) {	return null;	} catch (final SAXException e) {	
problems getting stats using 

in = new BufferedReader(new InputStreamReader(uc.getInputStream()));	final InputSource statsSource = new InputSource(in);	return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(statsSource);	} catch (final MalformedURLException e) {	return null;	} catch (final IOException e) {	return null;	} catch (final SAXException e) {	return null;	} catch (final ParserConfigurationException e) {	
problems getting stats using 

return null;	} catch (final SAXException e) {	return null;	} catch (final ParserConfigurationException e) {	return null;	} finally {	if (in != null) {	try {	in.close();	} catch (final IOException e) {	
unable to close the buffer 

} catch (final XenAPIException e) {	throw new CloudRuntimeException("Unable to get SR " + srNameLabel + " due to " + e.toString(), e);	} catch (final Exception e) {	throw new CloudRuntimeException("Unable to get SR " + srNameLabel + " due to " + e.getMessage(), e);	}	if (srs.size() > 1) {	throw new CloudRuntimeException("More than one storage repository was found for pool with uuid: " + srNameLabel);	} else if (srs.size() == 1) {	final SR sr = srs.iterator().next();	if (s_logger.isDebugEnabled()) {	
sr retrieved for 

public String getVhdParent(final Connection conn, final String primaryStorageSRUuid, final String snapshotUuid, final Boolean isISCSI) {	final String parentUuid = callHostPlugin(conn, "vmopsSnapshot", "getVhdParent", "primaryStorageSRUuid", primaryStorageSRUuid, "snapshotUuid", snapshotUuid, "isISCSI", isISCSI.toString());	if (parentUuid == null || parentUuid.isEmpty() || parentUuid.equalsIgnoreCase("None")) {	
unable to get parent of vhd in sr 

vms = VM.getByNameLabel(conn, vmName);	} catch (final XenAPIException e) {	throw new CloudRuntimeException("Unable to get " + vmName + ": " + e.toString(), e);	} catch (final Exception e) {	throw new CloudRuntimeException("Unable to get " + vmName + ": " + e.getMessage(), e);	}	if (vms.size() == 0) {	throw new CloudRuntimeException("VM with name: " + vmName + " does not exist.");	}	if (vms.size() > 1) {	
found vms with name 

try {	if (vdi.getIsASnapshot(conn) && vdi.getSmConfig(conn).get("vhd-parent") != null) {	final String parentUuid = vdi.getSmConfig(conn).get("vhd-parent");	final VDI parentVDI = VDI.getByUuid(conn, parentUuid);	size = size + vdi.getPhysicalUtilisation(conn);	if (!isRefNull(parentVDI)) {	size = size + parentVDI.getPhysicalUtilisation(conn).longValue();	}	}	} catch (final Exception e) {	
exception occurs when calculate snapshot capacity for volumes due to 

final VDI memoryVDI = vmr.getSuspendVDI(conn);	if (!isRefNull(memoryVDI)) {	size = size + memoryVDI.getPhysicalUtilisation(conn);	final VDI pMemoryVDI = memoryVDI.getParent(conn);	if (!isRefNull(pMemoryVDI)) {	size = size + pMemoryVDI.getPhysicalUtilisation(conn);	}	}	}	} catch (final Exception e) {	
exception occurs when calculate snapshot capacity for memory due to 

public PowerState getVmState(final Connection conn, final String vmName) {	int retry = 3;	while (retry-- > 0) {	try {	final Set<VM> vms = VM.getByNameLabel(conn, vmName);	for (final VM vm : vms) {	return convertToPowerState(vm.getPowerState(conn));	}	} catch (final BadServerResponse e) {	
unable to get a vm powerstate due to we are retrying count 

}	}	}	for (final Map.Entry<String, VmStatsEntry> entry : vmResponseMap.entrySet()) {	final VmStatsEntry vmStatsAnswer = entry.getValue();	if (vmStatsAnswer.getNumCPUs() != 0) {	vmStatsAnswer.setCPUUtilization(vmStatsAnswer.getCPUUtilization() / vmStatsAnswer.getNumCPUs());	}	vmStatsAnswer.setCPUUtilization(vmStatsAnswer.getCPUUtilization() * 100);	if (s_logger.isDebugEnabled()) {	
vm cpu utilization 

public String getVncUrl(final Connection conn, final VM vm) {	VM.Record record;	Console c;	try {	record = vm.getRecord(conn);	final Set<Console> consoles = record.consoles;	if (consoles.isEmpty()) {	
there are no consoles available to the vm 

protected void destroyUnattachedVBD(Connection conn, VM vm) {	try {	for (VBD vbd : vm.getVBDs(conn)) {	if (Types.VbdType.DISK.equals(vbd.getType(conn)) && !vbd.getCurrentlyAttached(conn)) {	vbd.destroy(conn);	}	}	} catch (final Exception e) {	
failed to destroy unattached vbd due to 

}	try {	final VM.Record vmr = vm.getRecord(conn);	final List<Network> networks = new ArrayList<Network>();	for (final VIF vif : vmr.VIFs) {	try {	final VIF.Record rec = vif.getRecord(conn);	if (rec != null) {	networks.add(rec.network);	} else {	
unable to cleanup vif as vif record is null 

final VM.Record vmr = vm.getRecord(conn);	final List<Network> networks = new ArrayList<Network>();	for (final VIF vif : vmr.VIFs) {	try {	final VIF.Record rec = vif.getRecord(conn);	if (rec != null) {	networks.add(rec.network);	} else {	}	} catch (final Exception e) {	
unable to cleanup vif 

networks.add(rec.network);	} else {	}	} catch (final Exception e) {	}	}	if (vmr.powerState == VmPowerState.RUNNING) {	try {	vm.hardShutdown(conn);	} catch (final Exception e) {	
vm hardshutdown failed due to 

if (vmr.powerState == VmPowerState.RUNNING) {	try {	vm.hardShutdown(conn);	} catch (final Exception e) {	}	}	if (vm.getPowerState(conn) == VmPowerState.HALTED) {	try {	vm.destroy(conn);	} catch (final Exception e) {	
vm destroy failed due to 

try {	vm.destroy(conn);	} catch (final Exception e) {	}	}	for (final VBD vbd : vmr.VBDs) {	try {	vbd.unplug(conn);	vbd.destroy(conn);	} catch (final Exception e) {	
unable to clean up vbd due to 

vbd.unplug(conn);	vbd.destroy(conn);	} catch (final Exception e) {	}	}	for (final VIF vif : vmr.VIFs) {	try {	vif.unplug(conn);	vif.destroy(conn);	} catch (final Exception e) {	
unable to cleanup vif 

vif.destroy(conn);	} catch (final Exception e) {	}	}	for (final Network network : networks) {	if (network.getNameLabel(conn).startsWith("VLAN")) {	disableVlanNetwork(conn, network);	}	}	} catch (final Exception e) {	
vm getrecord failed due to 

public StartupCommand[] initialize() throws IllegalArgumentException {	final Connection conn = getConnection();	if (!getHostInfo(conn)) {	
unable to get host information for 

final StartupRoutingCommand cmd = new StartupRoutingCommand();	fillHostInfo(conn, cmd);	cmd.setHypervisorType(HypervisorType.XenServer);	cmd.setCluster(_cluster);	cmd.setPoolSync(false);	try {	final Pool pool = Pool.getByUuid(conn, _host.getPool());	final Pool.Record poolr = pool.getRecord(conn);	poolr.master.getRecord(conn);	} catch (final Throwable e) {	
check for master failed failing the full cluster sync command 

public boolean isNetworkSetupByName(final String nameTag) throws XenAPIException, XmlRpcException {	if (nameTag != null) {	if (s_logger.isDebugEnabled()) {	
looking for network setup by name 

public boolean launchHeartBeat(final Connection conn) {	final String result = callHostPluginPremium(conn, "heartbeat", "host", _host.getUuid(), "timeout", Integer.toString(_heartbeatTimeout), "interval", Integer.toString(_heartbeatInterval));	if (result == null || !result.contains("> DONE <")) {	
unable to launch the heartbeat process on 

}	} catch (final XenAPIException e) {	final String msg = "Unable to migrate VM(" + vmName + ") from host(" + _host.getUuid() + ")";	s_logger.warn(msg, e);	throw new CloudRuntimeException(msg);	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e1) {	
unable to destroy task on host due to 

private List<Pair<String, Long>> ovsFullSyncStates() {	final Connection conn = getConnection();	final String result = callHostPlugin(conn, "ovsgre", "ovs_get_vm_log", "host_uuid", _host.getUuid());	final String[] logs = result != null ? result.split(";") : new String[0];	final List<Pair<String, Long>> states = new ArrayList<Pair<String, Long>>();	for (final String log : logs) {	final String[] info = log.split(",");	if (info.length != 5) {	
wrong element number in ovs log 

protected Pair<Long, Integer> parseTimestamp(final String timeStampStr) {	final String[] tokens = timeStampStr.split("-");	if (tokens.length != 3) {	
timestamp in network has wrong pattern 

protected Pair<Long, Integer> parseTimestamp(final String timeStampStr) {	final String[] tokens = timeStampStr.split("-");	if (tokens.length != 3) {	return null;	}	if (!tokens[0].equals("CsCreateTime")) {	
timestamp in network doesn t start with cscreatetime 

private void pbdPlug(final Connection conn, final PBD pbd, final String uuid) {	try {	if (s_logger.isDebugEnabled()) {	
plugging in pbd for 

public boolean pingXAPI() {	final Connection conn = getConnection();	try {	final Host host = Host.getByUuid(conn, _host.getUuid());	if (!host.getEnabled(conn)) {	
host is not enabled 

public boolean pingXAPI() {	final Connection conn = getConnection();	try {	final Host host = Host.getByUuid(conn, _host.getUuid());	if (!host.getEnabled(conn)) {	return false;	}	} catch (final Exception e) {	
cannot get host enabled status host due to 

final Host host = Host.getByUuid(conn, _host.getUuid());	if (!host.getEnabled(conn)) {	return false;	}	} catch (final Exception e) {	return false;	}	try {	callHostPlugin(conn, "echo", "main");	} catch (final Exception e) {	
cannot ping host due to 

if (templateDescription == null) {	templateDescription = "";	}	if (checksum == null) {	checksum = "";	}	final String result = callHostPlugin(conn, "vmopsSnapshot", "post_create_private_template", "templatePath", templatePath, "templateFilename", tmpltFilename, "templateName", templateName, "templateDescription", templateDescription, "checksum", checksum, "size", String.valueOf(size), "virtualSize", String.valueOf(virtualSize), "templateId", String.valueOf(templateId));	boolean success = false;	if (result != null && !result.isEmpty()) {	if (result.equalsIgnoreCase("1")) {	
successfully created template properties file on secondary storage for 

}	if (checksum == null) {	checksum = "";	}	final String result = callHostPlugin(conn, "vmopsSnapshot", "post_create_private_template", "templatePath", templatePath, "templateFilename", tmpltFilename, "templateName", templateName, "templateDescription", templateDescription, "checksum", checksum, "size", String.valueOf(size), "virtualSize", String.valueOf(virtualSize), "templateId", String.valueOf(templateId));	boolean success = false;	if (result != null && !result.isEmpty()) {	if (result.equalsIgnoreCase("1")) {	success = true;	} else {	
could not create template properties file on secondary storage for for templateid 

final SR sr = prepareManagedSr(conn, details);	VDI vdi = getVDIbyUuid(conn, path, false);	final Long volumeSize = Long.parseLong(details.get(DiskTO.VOLUME_SIZE));	Set<VDI> vdisInSr = sr.getVDIs(conn);	if (vdisInSr.size() == 1) {	vdi = vdisInSr.iterator().next();	}	if (vdi == null) {	vdi = createVdi(sr, vdiNameLabel, volumeSize);	} else {	
checking for the resize of the datadisk 

final Long volumeSize = Long.parseLong(details.get(DiskTO.VOLUME_SIZE));	Set<VDI> vdisInSr = sr.getVDIs(conn);	if (vdisInSr.size() == 1) {	vdi = vdisInSr.iterator().next();	}	if (vdi == null) {	vdi = createVdi(sr, vdiNameLabel, volumeSize);	} else {	final long vdiVirtualSize = vdi.getVirtualSize(conn);	if (vdiVirtualSize != volumeSize) {	
resizing the data disk vdi from vdivirtualsize to volumesize 

vdi = vdisInSr.iterator().next();	}	if (vdi == null) {	vdi = createVdi(sr, vdiNameLabel, volumeSize);	} else {	final long vdiVirtualSize = vdi.getVirtualSize(conn);	if (vdiVirtualSize != volumeSize) {	try {	vdi.resize(conn, volumeSize);	} catch (final Exception e) {	
unable to resize volume 

if (vdiVirtualSize != volumeSize) {	try {	vdi.resize(conn, volumeSize);	} catch (final Exception e) {	}	}	if (!Objects.equals(vdi.getNameLabel(conn), vdiNameLabel)) {	try {	vdi.setNameLabel(conn, vdiNameLabel);	} catch (final Exception e) {	
unable to rename volume 

}	if (ip.isAdd() && correctVif == null) {	throw new InternalErrorException("Failed to find DomR VIF to associate/disassociate IP with.");	}	if (correctVif != null) {	ip.setNicDevId(Integer.valueOf(correctVif.getDevice(conn)));	ip.setNewNic(addVif);	}	}	} catch (final InternalErrorException e) {	
ip assoc failure on applying one ip due to exception 

final Connection conn = getConnection();	final String routerName = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME);	try {	final IpAddressTO[] ips = cmd.getIpAddresses();	for (final IpAddressTO ip : ips) {	final VM router = getVM(conn, routerName);	final VIF correctVif = getVifByMac(conn, router, ip.getVifMacAddress());	setNicDevIdIfCorrectVifIsNotNull(conn, ip, correctVif);	}	} catch (final Exception e) {	
ip assoc failure on applying one ip due to exception 

waitForTask(conn, task, 1000, 10 * 60 * 1000);	checkForSuccess(conn, task);	} catch (final Types.HandleInvalid e) {	if (vm.getPowerState(conn) == VmPowerState.RUNNING) {	task = null;	return;	}	throw new CloudRuntimeException("Reboot VM catch HandleInvalid and VM is not in RUNNING state");	}	} catch (final XenAPIException e) {	
unable to clean reboot vm on host due to try hard reboot 

} catch (final Exception e1) {	final String msg = "Unable to hard Reboot VM(" + vmName + ") on host(" + _host.getUuid() + ") due to " + e.toString();	s_logger.warn(msg, e1);	throw new CloudRuntimeException(msg);	}	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e1) {	
unable to destroy task on host due to 

protected void skipOrRemoveSR(Connection conn, SR sr) {	if (sr == null) {	return;	}	if (s_logger.isDebugEnabled()) {	
removing sr 

Set<VDI> vdis = sr.getVDIs(conn);	for (VDI vdi : vdis) {	if (MapUtils.isEmpty(vdi.getCurrentOperations(conn))) {	continue;	}	return;	}	removeSR(conn, sr);	return;	} catch (XenAPIException | XmlRpcException e) {	
unable to get current opertions 

public void removeSR(final Connection conn, final SR sr) {	if (sr == null) {	return;	}	if (s_logger.isDebugEnabled()) {	
removing sr 

}	for (int i = 0; i < 2; i++) {	try {	final Set<VDI> vdis = sr.getVDIs(conn);	for (final VDI vdi : vdis) {	vdi.forget(conn);	}	Set<PBD> pbds = sr.getPBDs(conn);	for (final PBD pbd : pbds) {	if (s_logger.isDebugEnabled()) {	
unplugging pbd 

Set<PBD> pbds = sr.getPBDs(conn);	for (final PBD pbd : pbds) {	if (s_logger.isDebugEnabled()) {	}	pbd.unplug(conn);	pbd.destroy(conn);	}	pbds = sr.getPBDs(conn);	if (pbds.size() == 0) {	if (s_logger.isDebugEnabled()) {	
Forgetting 

pbd.destroy(conn);	}	pbds = sr.getPBDs(conn);	if (pbds.size() == 0) {	if (s_logger.isDebugEnabled()) {	}	sr.forget(conn);	return;	}	if (s_logger.isDebugEnabled()) {	
there is still one or more pbds attached 

pbds = sr.getPBDs(conn);	if (pbds.size() == 0) {	if (s_logger.isDebugEnabled()) {	}	sr.forget(conn);	return;	}	if (s_logger.isDebugEnabled()) {	if (s_logger.isTraceEnabled()) {	for (final PBD pbd : pbds) {	
still attached 

sr.forget(conn);	return;	}	if (s_logger.isDebugEnabled()) {	if (s_logger.isTraceEnabled()) {	for (final PBD pbd : pbds) {	}	}	}	} catch (final XenAPIException e) {	
catch xenapiexception 

return;	}	if (s_logger.isDebugEnabled()) {	if (s_logger.isTraceEnabled()) {	for (final PBD pbd : pbds) {	}	}	}	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
catch exception 

if (s_logger.isDebugEnabled()) {	if (s_logger.isTraceEnabled()) {	for (final PBD pbd : pbds) {	}	}	}	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	}	}	
unable to remove sr 

protected String removeSRSync(final Connection conn, final SR sr) {	if (sr == null) {	return null;	}	if (s_logger.isDebugEnabled()) {	
removing sr 

}	waittime += 30000;	try {	Thread.sleep(30000);	} catch (final InterruptedException ex) {	}	}	removeSR(conn, sr);	return null;	} catch (final XenAPIException e) {	
unable to get current opertions 

waittime += 30000;	try {	Thread.sleep(30000);	} catch (final InterruptedException ex) {	}	}	removeSR(conn, sr);	return null;	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
unable to get current opertions 

protected void setNicDevIdIfCorrectVifIsNotNull(final Connection conn, final IpAddressTO ip, final VIF correctVif) throws InternalErrorException, BadServerResponse, XenAPIException, XmlRpcException {	if (correctVif == null) {	if (ip.isAdd()) {	throw new InternalErrorException("Failed to find DomR VIF to associate IP with.");	} else {	
vif to deassociate ip with does not exist return success 

final SR.Record srRec = sr.getRecord(conn);	final String srUuid = srRec.uuid;	if (!srRec.shared || !SRType.LVMOHBA.equals(srRec.type) && !SRType.LVMOISCSI.equals(srRec.type) && !SRType.NFS.equals(srRec.type)) {	return srUuid;	}	String result = null;	final Host host = Host.getByUuid(conn, _host.getUuid());	final Set<String> tags = host.getTags(conn);	if (force || !tags.contains("cloud-heartbeat-" + srUuid)) {	if (s_logger.isDebugEnabled()) {	
setting up the heartbeat sr for host and sr 

final Map<String, String> otherConfig = vif.getOtherConfig(conn);	if (otherConfig != null) {	final String nameLabel = otherConfig.get("nameLabel");	if (nameLabel != null && nameLabel.equalsIgnoreCase("link_local_network_vif")) {	dom0vif = vif;	}	}	}	}	if (dom0vif == null) {	
can t find a vif on for link local creating a new one 

dom0vif = vif;	}	}	}	}	if (dom0vif == null) {	final VIF.Record vifr = new VIF.Record();	vifr.VM = dom0;	vifr.device = getLowestAvailableVIFDeviceNum(conn, dom0);	if (vifr.device == null) {	
failed to create link local network no vif available 

}	final Map<String, String> config = new HashMap<String, String>();	config.put("nameLabel", "link_local_network_vif");	vifr.otherConfig = config;	vifr.MAC = "FE:FF:FF:FF:FF:FF";	vifr.network = linkLocal;	vifr.lockingMode = Types.VifLockingMode.NETWORK_DEFAULT;	dom0vif = VIF.create(conn, vifr);	plugDom0Vif(conn, dom0vif);	} else {	
already have a vif on for link local network 

plugDom0Vif(conn, dom0vif);	} else {	if (!dom0vif.getCurrentlyAttached(conn)) {	plugDom0Vif(conn, dom0vif);	}	}	final String brName = linkLocal.getBridge(conn);	callHostPlugin(conn, "vmops", "setLinkLocalIP", "brName", brName);	_host.setLinkLocalNetwork(linkLocal.getUuid(conn));	} catch (final XenAPIException e) {	
unable to create local link network 

if (!dom0vif.getCurrentlyAttached(conn)) {	plugDom0Vif(conn, dom0vif);	}	}	final String brName = linkLocal.getBridge(conn);	callHostPlugin(conn, "vmops", "setLinkLocalIP", "brName", brName);	_host.setLinkLocalNetwork(linkLocal.getUuid(conn));	} catch (final XenAPIException e) {	throw new CloudRuntimeException("Unable to create local link network due to " + e.toString(), e);	} catch (final XmlRpcException e) {	
unable to create local link network 

public boolean setupServer(final Connection conn, final Host host) {	final String packageVersion = CitrixResourceBase.class.getPackage().getImplementationVersion();	final String version = this.getClass().getName() + "-" + (packageVersion == null ? Long.toString(System.currentTimeMillis()) : packageVersion);	try {	final Host.Record hr = host.getRecord(conn);	final Iterator<String> it = hr.tags.iterator();	while (it.hasNext()) {	final String tag = it.next();	if (tag.startsWith("vmops-version-")) {	if (tag.contains(version)) {	
host is already setup 

}	final String directoryPath = tokens[tokens.length - 1];	f = f.replace('/', File.separatorChar);	String permissions = "0755";	if (tokens.length == 3) {	permissions = tokens[1];	} else if (tokens.length == 2) {	permissions = tokens[0];	}	if (!new File(f).exists()) {	
we cannot locate 

String permissions = "0755";	if (tokens.length == 3) {	permissions = tokens[1];	} else if (tokens.length == 2) {	permissions = tokens[0];	}	if (!new File(f).exists()) {	continue;	}	if (s_logger.isDebugEnabled()) {	
copying to on with permission 

permissions = tokens[1];	} else if (tokens.length == 2) {	permissions = tokens[0];	}	if (!new File(f).exists()) {	continue;	}	if (s_logger.isDebugEnabled()) {	}	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, "mkdir -m 700 -p " + directoryPath)) {	
unable to create destination path on 

rec.nameDescription = "vswitch network for " + nwName;	rec.nameLabel = nwName;	vswitchNw = Network.create(conn, rec);	} else {	vswitchNw = networks.iterator().next();	}	_host.setVswitchNetwork(vswitchNw);	}	return _host.getVswitchNetwork();	} catch (final BadServerResponse e) {	
failed to setup vswitch network 

rec.nameLabel = nwName;	vswitchNw = Network.create(conn, rec);	} else {	vswitchNw = networks.iterator().next();	}	_host.setVswitchNetwork(vswitchNw);	}	return _host.getVswitchNetwork();	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	
failed to setup vswitch network 

vswitchNw = Network.create(conn, rec);	} else {	vswitchNw = networks.iterator().next();	}	_host.setVswitchNetwork(vswitchNw);	}	return _host.getVswitchNetwork();	} catch (final BadServerResponse e) {	} catch (final XenAPIException e) {	} catch (final XmlRpcException e) {	
failed to setup vswitch network 

throw new CloudRuntimeException("Shutdown VM catch HandleInvalid and VM is not in HALTED state");	}	} catch (final XenAPIException e) {	s_logger.debug("Unable to shutdown VM(" + vmName + ") with force=" + forcedStop + " on host(" + _host.getUuid() + ") due to " + e.toString());	try {	VmPowerState state = vm.getPowerState(conn);	if (state == VmPowerState.RUNNING) {	try {	vm.hardShutdown(conn);	} catch (final Exception e1) {	
unable to hardshutdown vm on host due to 

} catch (final Exception e1) {	final String msg = "Unable to hardShutdown VM(" + vmName + ") on host(" + _host.getUuid() + ") due to " + e.toString();	s_logger.warn(msg, e1);	throw new CloudRuntimeException(msg);	}	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e1) {	
unable to destroy task on host due to 

public void startVM(final Connection conn, final Host host, final VM vm, final String vmName) throws Exception {	Task task = null;	try {	task = vm.startOnAsync(conn, host, false, true);	try {	waitForTask(conn, task, 1000, 10 * 60 * 1000);	checkForSuccess(conn, task);	} catch (final Types.HandleInvalid e) {	if (vm.getPowerState(conn) == VmPowerState.RUNNING) {	
vm is in running status 

waitForTask(conn, task, 1000, 10 * 60 * 1000);	checkForSuccess(conn, task);	} catch (final Types.HandleInvalid e) {	if (vm.getPowerState(conn) == VmPowerState.RUNNING) {	task = null;	return;	}	throw new CloudRuntimeException("Start VM " + vmName + " catch HandleInvalid and VM is not in RUNNING state");	} catch (final TimeoutException e) {	if (vm.getPowerState(conn) == VmPowerState.RUNNING) {	
vm is in running status 

}	} catch (final XenAPIException e) {	final String msg = "Unable to start VM(" + vmName + ") on host(" + _host.getUuid() + ") due to " + e.toString();	s_logger.warn(msg, e);	throw new CloudRuntimeException(msg);	} finally {	if (task != null) {	try {	task.destroy(conn);	} catch (final Exception e1) {	
unable to destroy task on host due to 

int count = 0;	while (count < 10) {	try {	Thread.sleep(10000);	hostUuid = host.getUuid(conn);	if (hostUuid != null) {	break;	}	++count;	} catch (final XmlRpcException e) {	
waiting for host to come back 

while (count < 10) {	try {	Thread.sleep(10000);	hostUuid = host.getUuid(conn);	if (hostUuid != null) {	break;	}	++count;	} catch (final XmlRpcException e) {	} catch (final XenAPIException e) {	
waiting for host to come back 

try {	Thread.sleep(10000);	hostUuid = host.getUuid(conn);	if (hostUuid != null) {	break;	}	++count;	} catch (final XmlRpcException e) {	} catch (final XenAPIException e) {	} catch (final InterruptedException e) {	
gotta run 

break;	}	++count;	} catch (final XmlRpcException e) {	} catch (final XenAPIException e) {	} catch (final InterruptedException e) {	return false;	}	}	if (hostUuid == null) {	
unable to transfer the management network from 

public void umountSnapshotDir(final Connection conn, final Long dcId) {	try {	callHostPlugin(conn, "vmopsSnapshot", "unmountSnapshotsDir", "dcId", dcId.toString());	} catch (final Exception e) {	
failed to umount snapshot dir 

public void waitForTask(final Connection c, final Task task, final long pollInterval, final long timeout) throws XenAPIException, XmlRpcException, TimeoutException {	final long beginTime = System.currentTimeMillis();	if (s_logger.isTraceEnabled()) {	
task sent to is pending completion with a ms timeout 

public void waitForTask(final Connection c, final Task task, final long pollInterval, final long timeout) throws XenAPIException, XmlRpcException, TimeoutException {	final long beginTime = System.currentTimeMillis();	if (s_logger.isTraceEnabled()) {	}	while (task.getStatus(c) == Types.TaskStatusType.PENDING) {	try {	if (s_logger.isTraceEnabled()) {	
task is pending sleeping for ms 

public boolean createAndAttachConfigDriveIsoForVM(final Connection conn, final VM vm, final List<String[]> vmDataList, final String configDriveLabel) throws XenAPIException, XmlRpcException {	final String vmName = vm.getNameLabel(conn);	final SR sr =  createLocalIsoSR(conn, _configDriveSRName+_host.getIp());	if (sr == null) {	
failed to create local sr for the config drive 

public boolean createAndAttachConfigDriveIsoForVM(final Connection conn, final VM vm, final List<String[]> vmDataList, final String configDriveLabel) throws XenAPIException, XmlRpcException {	final String vmName = vm.getNameLabel(conn);	final SR sr =  createLocalIsoSR(conn, _configDriveSRName+_host.getIp());	if (sr == null) {	return false;	}	
creating vm data files in config drive for vm 

public boolean createAndAttachConfigDriveIsoForVM(final Connection conn, final VM vm, final List<String[]> vmDataList, final String configDriveLabel) throws XenAPIException, XmlRpcException {	final String vmName = vm.getNameLabel(conn);	final SR sr =  createLocalIsoSR(conn, _configDriveSRName+_host.getIp());	if (sr == null) {	return false;	}	if (!createVmdataFiles(vmName, vmDataList, configDriveLabel)) {	
failed to create vm data files in config drive for vm 

public boolean createVmdataFiles(final String vmName, final List<String[]> vmDataList, final String configDriveLabel) {	final String isoPath = "/tmp/"+vmName+"/configDrive/";	final String configDriveName = "cloudstack/";	try {	deleteLocalFolder("/tmp/"+isoPath);	} catch (final IOException e) {	
failed to delete the exiting config drive for vm 

public boolean createVmdataFiles(final String vmName, final List<String[]> vmDataList, final String configDriveLabel) {	final String isoPath = "/tmp/"+vmName+"/configDrive/";	final String configDriveName = "cloudstack/";	try {	deleteLocalFolder("/tmp/"+isoPath);	} catch (final IOException e) {	} catch (final Exception e) {	
failed to delete the exiting config drive for vm 

if (dataType != null && !dataType.isEmpty()) {	final String  folder = isoPath+configDriveName+dataType;	if (folder != null && !folder.isEmpty()) {	final File dir = new File(folder);	final boolean result = true;	try {	if (!dir.exists()) {	dir.mkdirs();	}	}catch (final SecurityException ex) {	
failed to create dir 

}	}catch (final SecurityException ex) {	return false;	}	if (result && content != null && !content.isEmpty()) {	File file = new File(folder+"/"+fileName+".txt");	try (OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(file.getAbsoluteFile()),"UTF-8");	BufferedWriter bw = new BufferedWriter(fw);	) {	bw.write(content);	
created file in folder 

}catch (final SecurityException ex) {	return false;	}	if (result && content != null && !content.isEmpty()) {	File file = new File(folder+"/"+fileName+".txt");	try (OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(file.getAbsoluteFile()),"UTF-8");	BufferedWriter bw = new BufferedWriter(fw);	) {	bw.write(content);	} catch (final IOException ex) {	
failed to create file 

BufferedWriter bw = new BufferedWriter(fw);	) {	bw.write(content);	} catch (final IOException ex) {	return false;	}	}	}	}	}	
created the vm data in 

final String cmd =  "mkisofs -iso-level 3 -V "+ configDriveLabel +" -o "+ isoPath+vmName +".iso " + isoPath;	final Process p = Runtime.getRuntime().exec(cmd);	final BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream(),Charset.defaultCharset()));	final BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream(),Charset.defaultCharset()));	while ((s = stdInput.readLine()) != null) {	s_logger.debug(s);	}	while ((s = stdError.readLine()) != null) {	s_logger.debug(s);	}	
created config drive iso using the command in the host 

public boolean copyConfigDriveIsoToHost(final Connection conn, final SR sr, final String vmName) {	final String vmIso = "/tmp/"+vmName+"/configDrive/"+vmName+".iso";	final com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_host.getIp(), 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	
scp config drive iso file to host path 

final com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_host.getIp(), 22);	try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final SCPClient scp = new SCPClient(sshConnection);	final String p = "0755";	scp.put(vmIso, _configDriveIsopath, p);	sr.scan(conn);	
copied config drive iso to host 

try {	sshConnection.connect(null, 60000, 60000);	if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final SCPClient scp = new SCPClient(sshConnection);	final String p = "0755";	scp.put(vmIso, _configDriveIsopath, p);	sr.scan(conn);	} catch (final IOException e) {	
failed to copy configdrive iso to host 

if (!sshConnection.authenticateWithPassword(_username, _password.peek())) {	throw new CloudRuntimeException("Unable to authenticate");	}	final SCPClient scp = new SCPClient(sshConnection);	final String p = "0755";	scp.put(vmIso, _configDriveIsopath, p);	sr.scan(conn);	} catch (final IOException e) {	return false;	} catch (final XmlRpcException e) {	
failed to scan config drive iso sr in host 

sr.scan(conn);	} catch (final IOException e) {	return false;	} catch (final XmlRpcException e) {	return false;	} finally {	sshConnection.close();	final String configDir = "/tmp/"+vmName;	try {	deleteLocalFolder(configDir);	
successfully cleaned up config drive directory after copying it to host 

} catch (final IOException e) {	return false;	} catch (final XmlRpcException e) {	return false;	} finally {	sshConnection.close();	final String configDir = "/tmp/"+vmName;	try {	deleteLocalFolder(configDir);	} catch (final Exception e) {	
failed to delete config drive folder for vm 

final String vmName = vm.getNameLabel(conn);	final String isoURL = _configDriveIsopath + vmName+".iso";	VDI srVdi;	try {	final Set<VDI> vdis = VDI.getByNameLabel(conn, vmName+".iso");	if (vdis.isEmpty()) {	throw new CloudRuntimeException("Could not find ISO with URL: " + isoURL);	}	srVdi =  vdis.iterator().next();	} catch (final XenAPIException e) {	
unable to get config drive iso due to 

VDI srVdi;	try {	final Set<VDI> vdis = VDI.getByNameLabel(conn, vmName+".iso");	if (vdis.isEmpty()) {	throw new CloudRuntimeException("Could not find ISO with URL: " + isoURL);	}	srVdi =  vdis.iterator().next();	} catch (final XenAPIException e) {	return false;	} catch (final Exception e) {	
unable to get config drive iso due to 

if (isoVBD == null) {	final VBD.Record cfgDriveVbdr = new VBD.Record();	cfgDriveVbdr.VM = vm;	cfgDriveVbdr.empty = true;	cfgDriveVbdr.bootable = false;	cfgDriveVbdr.userdevice = "autodetect";	cfgDriveVbdr.mode = Types.VbdMode.RO;	cfgDriveVbdr.type = Types.VbdType.CD;	final VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr);	isoVBD = cfgDriveVBD;	
created cd rom vbd for vm 

cfgDriveVbdr.type = Types.VbdType.CD;	final VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr);	isoVBD = cfgDriveVBD;	}	if (isoVBD != null) {	if (isoVBD.getEmpty(conn) == false) {	isoVBD.eject(conn);	}	try {	isoVBD.insert(conn, srVdi);	
attached config drive iso to vm 

final VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr);	isoVBD = cfgDriveVBD;	}	if (isoVBD != null) {	if (isoVBD.getEmpty(conn) == false) {	isoVBD.eject(conn);	}	try {	isoVBD.insert(conn, srVdi);	}catch (final XmlRpcException ex) {	
failed to attach config drive iso to vm 

public SR createLocalIsoSR(final Connection conn, final String srName) throws XenAPIException, XmlRpcException {	SR sr = getSRByNameLabelandHost(conn, _configDriveSRName+_host.getIp());	if (sr != null) {	
config drive sr already exist returing it 

}	final String cmd = "mkdir -p " + _configDriveIsopath;	if (!SSHCmdHelper.sshExecuteCmd(sshConnection, cmd)) {	throw new CloudRuntimeException("Cannot create directory configdrive_iso on XenServer hosts");	}	} catch (final IOException e) {	throw new CloudRuntimeException("Unable to create iso folder", e);	} finally {	sshConnection.close();	}	
created the config drive sr folder path 

sshConnection.close();	}	deviceConfig.put("location",  _configDriveIsopath);	deviceConfig.put("legacy_mode", "true");	final Host host = Host.getByUuid(conn, _host.getUuid());	final String type = SRType.ISO.toString();	sr = SR.create(conn, host, deviceConfig, new Long(0),  _configDriveIsopath, "iso", type, "iso", false, new HashMap<String, String>());	sr.setNameLabel(conn, srName);	sr.setNameDescription(conn, deviceConfig.get("location"));	sr.scan(conn);	
config drive iso sr at the path got created in host 

public boolean attachConfigDriveToMigratedVm(Connection conn, String vmName, String ipAddr) {	try {	
attaching config drive iso device for the vm in host 

public boolean attachConfigDriveToMigratedVm(Connection conn, String vmName, String ipAddr) {	try {	Set<VM> vms = VM.getByNameLabel(conn, vmName);	SR sr = getSRByNameLabel(conn, _configDriveSRName + ipAddr);	Set<VDI> vdis = VDI.getByNameLabel(conn, vmName + ".iso");	if (vdis.isEmpty()) {	
could not find config drive iso 

SR sr = getSRByNameLabel(conn, _configDriveSRName + ipAddr);	Set<VDI> vdis = VDI.getByNameLabel(conn, vmName + ".iso");	if (vdis.isEmpty()) {	return false;	}	VDI configdriveVdi = null;	for (VDI vdi : vdis) {	SR vdiSr = vdi.getSR(conn);	if (vdiSr.getUuid(conn).equals(sr.getUuid(conn))) {	configdriveVdi = vdi;	
vdi for the config drive iso 

Set<VDI> vdis = VDI.getByNameLabel(conn, vmName + ".iso");	if (vdis.isEmpty()) {	return false;	}	VDI configdriveVdi = null;	for (VDI vdi : vdis) {	SR vdiSr = vdi.getSR(conn);	if (vdiSr.getUuid(conn).equals(sr.getUuid(conn))) {	configdriveVdi = vdi;	} else {	
removing the source host vdi for the config drive iso 

VDI configdriveVdi = null;	for (VDI vdi : vdis) {	SR vdiSr = vdi.getSR(conn);	if (vdiSr.getUuid(conn).equals(sr.getUuid(conn))) {	configdriveVdi = vdi;	} else {	vdi.destroy(conn);	}	}	if (configdriveVdi == null) {	
config drive iso vdi is not found 

}	for (VM vm : vms) {	VBD.Record cfgDriveVbdr = new VBD.Record();	cfgDriveVbdr.VM = vm;	cfgDriveVbdr.empty = true;	cfgDriveVbdr.bootable = false;	cfgDriveVbdr.userdevice = "autodetect";	cfgDriveVbdr.mode = Types.VbdMode.RO;	cfgDriveVbdr.type = Types.VbdType.CD;	VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr);	
inserting vbd 

cfgDriveVbdr.bootable = false;	cfgDriveVbdr.userdevice = "autodetect";	cfgDriveVbdr.mode = Types.VbdMode.RO;	cfgDriveVbdr.type = Types.VbdType.CD;	VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr);	cfgDriveVBD.insert(conn, configdriveVdi);	break;	}	return true;	} catch (BadServerResponse e) {	
failed to attach config drive iso to the vm in host due to a bad server response 

cfgDriveVbdr.mode = Types.VbdMode.RO;	cfgDriveVbdr.type = Types.VbdType.CD;	VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr);	cfgDriveVBD.insert(conn, configdriveVdi);	break;	}	return true;	} catch (BadServerResponse e) {	return false;	} catch (XenAPIException e) {	
failed to attach config drive iso to the vm in host due to a xapi problem 

VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr);	cfgDriveVBD.insert(conn, configdriveVdi);	break;	}	return true;	} catch (BadServerResponse e) {	return false;	} catch (XenAPIException e) {	return false;	} catch (XmlRpcException e) {	
failed to attach config drive iso to the vm in host due to a problem in a remote call 

========================= cloudstack sample_1233 =========================

for (HostVO neighbor : neighbors) {	if (neighbor.getId() == agent.getId() || neighbor.getHypervisorType() != Hypervisor.HypervisorType.Hyperv) {	continue;	}	try {	Answer answer = _agentMgr.easySend(neighbor.getId(), cmd);	if (answer != null) {	return answer.getResult() ? Status.Down : Status.Up;	}	} catch (Exception e) {	
failed to send command to host 

========================= cloudstack sample_929 =========================

private boolean cleanupProject(final Project project, AccountVO caller, Long callerUserId) {	boolean result = true;	AccountVO account = _accountDao.findById(project.getProjectAccountId());	s_logger.debug("Deleting projects " + project + " internal account id=" + account.getId() + " as a part of project cleanup...");	result = result && _accountMgr.deleteAccount(account, callerUserId, caller);	if (result) {	result = Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean result = true;	
unassigning all accounts from project as a part of project cleanup 

s_logger.debug("Deleting projects " + project + " internal account id=" + account.getId() + " as a part of project cleanup...");	result = result && _accountMgr.deleteAccount(account, callerUserId, caller);	if (result) {	result = Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean result = true;	List<? extends ProjectAccount> projectAccounts = _projectAccountDao.listByProjectId(project.getId());	for (ProjectAccount projectAccount : projectAccounts) {	result = result && unassignAccountFromProject(projectAccount.getProjectId(), projectAccount.getAccountId());	}	
removing all invitations for the project as a part of project cleanup 

boolean result = true;	List<? extends ProjectAccount> projectAccounts = _projectAccountDao.listByProjectId(project.getId());	for (ProjectAccount projectAccount : projectAccounts) {	result = result && unassignAccountFromProject(projectAccount.getProjectId(), projectAccount.getAccountId());	}	_projectInvitationDao.cleanupInvitations(project.getId());	return result;	}	});	if (result) {	
accounts are unassign successfully from project as a part of project cleanup 

for (ProjectAccount projectAccount : projectAccounts) {	result = result && unassignAccountFromProject(projectAccount.getProjectId(), projectAccount.getAccountId());	}	_projectInvitationDao.cleanupInvitations(project.getId());	return result;	}	});	if (result) {	}	} else {	
failed to cleanup project s internal account 

public boolean deleteAccountFromProject(final long projectId, final long accountId) {	return Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean success = true;	ProjectAccountVO projectAccount = _projectAccountDao.findByProjectIdAccountId(projectId, accountId);	success = _projectAccountDao.remove(projectAccount.getId());	if (success) {	
removed account from project cleaning up old invitations for account project 

if (invite != null) {	if (invite.getState() == ProjectInvitation.State.Completed || (invite.getState() == ProjectInvitation.State.Pending && _projectInvitationDao.isActive(invite.getId(), _invitationTimeOut))) {	return true;	} else {	if (invite.getState() == ProjectInvitation.State.Pending) {	expireInvitation(invite);	}	if (accountId != null) {	s_logger.debug("Removing invitation in state " + invite.getState() + " for account id=" + accountId + " to project " + project);	} else if (email != null) {	
removing invitation in state for email to project 

expireInvitation(invite);	throw new InvalidParameterValueException("Invitation is expired for account id=" + accountName + " to the project id=" + projectId);	} else {	final ProjectInvitationVO inviteFinal = invite;	final Long accountIdFinal = accountId;	final String accountNameFinal = accountName;	result = Transaction.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	boolean result = true;	ProjectInvitation.State newState = accept ? ProjectInvitation.State.Completed : ProjectInvitation.State.Declined;	
marking invitation with state 

inviteFinal.setState(newState);	result = _projectInvitationDao.update(inviteFinal.getId(), inviteFinal);	if (result && accept) {	ProjectAccount projectAccount =  _projectAccountDao.findByProjectIdAccountId(projectId, accountIdFinal);	if (projectAccount != null) {	s_logger.debug("Account " + accountNameFinal + " already added to the project id=" + projectId);	} else {	assignAccountToProject(project, accountIdFinal, ProjectAccount.Role.Regular);	}	} else {	
failed to update project invitation with state 

private boolean suspendProject(ProjectVO project) throws ConcurrentOperationException, ResourceUnavailableException {	
marking project with state as a part of project suspend 

private boolean suspendProject(ProjectVO project) throws ConcurrentOperationException, ResourceUnavailableException {	project.setState(State.Suspended);	boolean updateResult = _projectDao.update(project.getId(), project);	if (updateResult) {	long projectAccountId = project.getProjectAccountId();	if (!_accountMgr.disableAccount(projectAccountId)) {	
failed to suspend all project s resources the resources will be suspended later by background thread 

public void sendInvite(String token, String email, long projectId) throws MessagingException, UnsupportedEncodingException {	if (_smtpSession != null) {	InternetAddress address = null;	if (email != null) {	try {	address = new InternetAddress(email, email);	} catch (Exception ex) {	
exception creating address for 

protected void runInContext() {	try {	TimeZone.getDefault();	List<ProjectInvitationVO> invitationsToExpire = _projectInvitationDao.listInvitationsToExpire(_invitationTimeOut);	if (!invitationsToExpire.isEmpty()) {	
found projects to expire 

TimeZone.getDefault();	List<ProjectInvitationVO> invitationsToExpire = _projectInvitationDao.listInvitationsToExpire(_invitationTimeOut);	if (!invitationsToExpire.isEmpty()) {	for (ProjectInvitationVO invitationToExpire : invitationsToExpire) {	invitationToExpire.setState(ProjectInvitation.State.Expired);	_projectInvitationDao.update(invitationToExpire.getId(), invitationToExpire);	s_logger.trace("Expired project invitation id=" + invitationToExpire.getId());	}	}	} catch (Exception ex) {	
exception while running expired invitations cleanup 

========================= cloudstack sample_2274 =========================

}	List<StoragePoolVO> clusterPools = _storagePoolDao.listPoolsByCluster(agent.getClusterId());	boolean hasNfs = false;	for (StoragePoolVO pool : clusterPools) {	if (pool.getPoolType() == StoragePoolType.NetworkFilesystem) {	hasNfs = true;	break;	}	}	if (!hasNfs) {	
agent investigation was requested on host but host does not support investigation because it has no nfs storage skipping investigation 

}	Status hostStatus = null;	Status neighbourStatus = null;	CheckOnHostCommand cmd = new CheckOnHostCommand(agent);	try {	Answer answer = _agentMgr.easySend(agent.getId(), cmd);	if (answer != null) {	hostStatus = answer.getResult() ? Status.Down : Status.Up;	}	} catch (Exception e) {	
failed to send command to host 

} catch (Exception e) {	}	if (hostStatus == null) {	hostStatus = Status.Disconnected;	}	List<HostVO> neighbors = _resourceMgr.listHostsInClusterByStatus(agent.getClusterId(), Status.Up);	for (HostVO neighbor : neighbors) {	if (neighbor.getId() == agent.getId() || (neighbor.getHypervisorType() != Hypervisor.HypervisorType.KVM && neighbor.getHypervisorType() != Hypervisor.HypervisorType.LXC)) {	continue;	}	
investigating host via neighbouring host 

}	List<HostVO> neighbors = _resourceMgr.listHostsInClusterByStatus(agent.getClusterId(), Status.Up);	for (HostVO neighbor : neighbors) {	if (neighbor.getId() == agent.getId() || (neighbor.getHypervisorType() != Hypervisor.HypervisorType.KVM && neighbor.getHypervisorType() != Hypervisor.HypervisorType.LXC)) {	continue;	}	try {	Answer answer = _agentMgr.easySend(neighbor.getId(), cmd);	if (answer != null) {	neighbourStatus = answer.getResult() ? Status.Down : Status.Up;	
neighbouring host returned status for the investigated host 

}	try {	Answer answer = _agentMgr.easySend(neighbor.getId(), cmd);	if (answer != null) {	neighbourStatus = answer.getResult() ? Status.Down : Status.Up;	if (neighbourStatus == Status.Up) {	break;	}	}	} catch (Exception e) {	
failed to send command to host 

========================= cloudstack sample_1008 =========================

String publicIp = st.nextToken();	Long bytesSent = new Long(st.nextToken());	Long bytesRcvd = new Long(st.nextToken());	long[] bytesSentAndReceived = new long[2];	bytesSentAndReceived[0] = bytesSent;	bytesSentAndReceived[1] = bytesRcvd;	answer.put(publicIp, bytesSentAndReceived);	}	}	} catch (MalformedURLException e1) {	
invalid traffic sentinel url 

Long bytesRcvd = new Long(st.nextToken());	long[] bytesSentAndReceived = new long[2];	bytesSentAndReceived[0] = bytesSent;	bytesSentAndReceived[1] = bytesRcvd;	answer.put(publicIp, bytesSentAndReceived);	}	}	} catch (MalformedURLException e1) {	throw new ExecutionException(e1.getMessage());	} catch (IOException e) {	
error in direct network usage accounting 

========================= cloudstack sample_66 =========================

List<StoragePoolHostVO> result = new ArrayList<StoragePoolHostVO>();	try(PreparedStatement pstmt = txn.prepareStatement(sql);) {	pstmt.setLong(1, poolId);	pstmt.setString(2, hostStatus.toString());	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (SQLException e) {	
listbyhoststatus exception 

pstmt.setLong(1, poolId);	pstmt.setString(2, hostStatus.toString());	try(ResultSet rs = pstmt.executeQuery();) {	while (rs.next()) {	long id = rs.getLong(1);	result.add(findById(id));	}	}catch (SQLException e) {	}	} catch (Exception e) {	
listbyhoststatus exception 

TransactionLegacy txn = TransactionLegacy.currentTxn();	PreparedStatement pstmt = null;	try {	pstmt = txn.prepareAutoCloseStatement(sql);	pstmt.setLong(1, dcId);	ResultSet rs = pstmt.executeQuery();	while (rs.next()) {	l.add(new Pair<Long, Integer>(rs.getLong(1), rs.getInt(2)));	}	} catch (SQLException e) {	
sqlexception 

========================= cloudstack sample_4573 =========================

protected synchronized boolean isExcluded(Object bean) {	String name = RegistryUtils.getName(bean);	if (excludes == null) {	loadExcluded();	}	boolean result = excludes.contains(name);	if (result) {	
excluding extension based on configuration 

public void start() {	Iterator<Object> iter = beans.iterator();	Registry<Object> registry = lookupRegistry();	while (iter.hasNext()) {	Object next = iter.next();	if (registry.register(next)) {	
registered 

========================= cloudstack sample_753 =========================

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	
we currently don t handle conversion from to vhd 

public FormatInfo process(String templatePath, ImageFormat format, String templateName) throws InternalErrorException {	if (format != null) {	return null;	}	String vhdPath = templatePath + File.separator + templateName + "." + ImageFormat.VHD.getFileExtension();	if (!_storage.exists(vhdPath)) {	
unable to find the vhd file 

return null;	}	File vhdFile = _storage.getFile(vhdPath);	FormatInfo info = new FormatInfo();	info.format = ImageFormat.VHD;	info.filename = templateName + "." + ImageFormat.VHD.getFileExtension();	info.size = _storage.getSize(vhdPath);	try {	info.virtualSize = getTemplateVirtualSize(vhdFile);	} catch (IOException e) {	
unable to get the virtual size for 

public long getVirtualSize(File file) throws IOException {	try {	long size = getTemplateVirtualSize(file);	return size;	} catch (Exception e) {	
ignored failed to get template virtual size for vhd 

byte[] currentSize = new byte[8];	byte[] cookie = new byte[8];	byte[] creatorApp = new byte[4];	BufferedInputStream fileStream = new BufferedInputStream(new FileInputStream(file));	InputStream strm = fileStream;	boolean isCompressed = checkCompressed(file.getAbsolutePath());	if ( isCompressed ) {	try {	strm = new CompressorStreamFactory().createCompressorInputStream(fileStream);	} catch (CompressorException e) {	
error opening compressed vhd file 

}	skipped = strm.skip(vhdFooterCurrentSizeOffset - vhdFooterCreatorVerOffset - vhdCookieOffset);	if (skipped == -1) {	throw new IOException("Unexpected end-of-file");	}	read = strm.read(currentSize);	if (read == -1) {	throw new IOException("Unexpected end-of-file");	}	} catch (IOException e) {	
error reading virtual size from vhd file vhd 

========================= cloudstack sample_401 =========================

public boolean destroy() throws Exception {	ManagedObjectReference morTask = _context.getService().destroyTask(_mor);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware destroy task failed due to 

public boolean rename(String newName) throws Exception {	ManagedObjectReference morTask = _context.getService().renameTask(_mor, newName);	boolean result = _context.getVimClient().waitForTask(morTask);	if (result) {	_context.waitForTaskProgressDone(morTask);	return true;	} else {	
vmware rename task failed due to 

========================= cloudstack sample_2063 =========================

String uploadUrl = _templateService.extract(this);	if (uploadUrl != null) {	ExtractResponse response = _responseGenerator.createExtractResponse(id, zoneId, getEntityOwnerId(), mode, uploadUrl);	response.setResponseName(getCommandName());	response.setObjectName("iso");	this.setResponseObject(response);	} else {	throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to extract ISO");	}	} catch (InternalErrorException ex) {	
exception 

========================= cloudstack sample_3367 =========================

} else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Lswitch) {	logicalSwitchUuid = Networks.BroadcastDomainType.getValue(nic.getBroadcastUri());	} else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Pvlan) {	vlanId = NetUtils.getPrimaryPvlanFromUri(nic.getBroadcastUri());	}	String trafficLabel = nic.getName();	if (nic.getType() == Networks.TrafficType.Guest) {	Integer networkRateKBps = (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) ? nic.getNetworkRateMbps().intValue() * 128 : 0;	if ((nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan || nic.getBroadcastType() == Networks.BroadcastDomainType.Pvlan) && !vlanId.equalsIgnoreCase("untagged")) {	if (trafficLabel != null && !trafficLabel.isEmpty()) {	
creating a vlan dev and bridge for guest traffic per traffic label 

Integer networkRateKBps = (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) ? nic.getNetworkRateMbps().intValue() * 128 : 0;	if ((nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan || nic.getBroadcastType() == Networks.BroadcastDomainType.Pvlan) && !vlanId.equalsIgnoreCase("untagged")) {	if (trafficLabel != null && !trafficLabel.isEmpty()) {	intf.defBridgeNet(_pifs.get(trafficLabel), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);	intf.setVlanTag(Integer.parseInt(vlanId));	} else {	intf.defBridgeNet(_pifs.get("private"), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);	intf.setVlanTag(Integer.parseInt(vlanId));	}	} else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Lswitch || nic.getBroadcastType() == Networks.BroadcastDomainType.OpenDaylight) {	
nic needs to be connected to logicalswitch 

intf.defBridgeNet(_pifs.get("private"), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);	intf.setVlanTag(Integer.parseInt(vlanId));	}	} else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Lswitch || nic.getBroadcastType() == Networks.BroadcastDomainType.OpenDaylight) {	intf.setVirtualPortInterfaceId(nic.getUuid());	String brName = (trafficLabel != null && !trafficLabel.isEmpty()) ? _pifs.get(trafficLabel) : _pifs.get("private");	intf.defBridgeNet(brName, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);	} else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Vswitch) {	String vnetId = Networks.BroadcastDomainType.getValue(nic.getBroadcastUri());	String brName = "OVSTunnel" + vnetId;	
nic needs to be connected to logicalswitch 

} else {	intf.defBridgeNet(_bridges.get("guest"), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);	}	} else if (nic.getType() == Networks.TrafficType.Control) {	createControlNetwork(_bridges.get("linklocal"));	intf.defBridgeNet(_bridges.get("linklocal"), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter));	} else if (nic.getType() == Networks.TrafficType.Public) {	Integer networkRateKBps = (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) ? nic.getNetworkRateMbps().intValue() * 128 : 0;	if (nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan && !vlanId.equalsIgnoreCase("untagged")) {	if (trafficLabel != null && !trafficLabel.isEmpty()) {	
creating a vlan dev and bridge for public traffic per traffic label 

========================= cloudstack sample_1024 =========================

public StartupCommand[] initialize() {	
resource intializing 

public StartupCommand[] initialize() {	try {	StartupRoutingCommand srCmd = new StartupRoutingCommand();	StartupStorageCommand ssCmd = new StartupStorageCommand();	hypervisorsupport.fillHostInfo(srCmd);	hypervisorsupport.vmStateMapClear();	
pool 

public StartupCommand[] initialize() {	try {	StartupRoutingCommand srCmd = new StartupRoutingCommand();	StartupStorageCommand ssCmd = new StartupStorageCommand();	hypervisorsupport.fillHostInfo(srCmd);	hypervisorsupport.vmStateMapClear();	return new StartupCommand[] { srCmd, ssCmd };	} catch (Exception e) {	
resource initializes failed 

public PingCommand getCurrentStatus(long id) {	try {	Common test = new Common(c);	String ping = "put";	String pong = test.echo(ping);	if (pong.contains(ping)) {	hypervisorsupport.syncState();	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (!cSp.dom0CheckStorageHealthCheck(configuration .getAgentScriptsDir(), configuration.getAgentCheckStorageScript(), configuration.getCsHostGuid(), configuration.getAgentStorageCheckTimeout(), configuration.getAgentStorageCheckInterval()) && !cSp.dom0CheckStorageHealthCheck()) {	
storage health check not running on 

public PingCommand getCurrentStatus(long id) {	try {	Common test = new Common(c);	String ping = "put";	String pong = test.echo(ping);	if (pong.contains(ping)) {	hypervisorsupport.syncState();	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (!cSp.dom0CheckStorageHealthCheck(configuration .getAgentScriptsDir(), configuration.getAgentCheckStorageScript(), configuration.getCsHostGuid(), configuration.getAgentStorageCheckTimeout(), configuration.getAgentStorageCheckInterval()) && !cSp.dom0CheckStorageHealthCheck()) {	} else if (cSp.dom0CheckStorageHealthCheck()) {	
storage health check started on 

try {	Common test = new Common(c);	String ping = "put";	String pong = test.echo(ping);	if (pong.contains(ping)) {	hypervisorsupport.syncState();	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (!cSp.dom0CheckStorageHealthCheck(configuration .getAgentScriptsDir(), configuration.getAgentCheckStorageScript(), configuration.getCsHostGuid(), configuration.getAgentStorageCheckTimeout(), configuration.getAgentStorageCheckInterval()) && !cSp.dom0CheckStorageHealthCheck()) {	} else if (cSp.dom0CheckStorageHealthCheck()) {	} else {	
storage health check running on 

String pong = test.echo(ping);	if (pong.contains(ping)) {	hypervisorsupport.syncState();	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (!cSp.dom0CheckStorageHealthCheck(configuration .getAgentScriptsDir(), configuration.getAgentCheckStorageScript(), configuration.getCsHostGuid(), configuration.getAgentStorageCheckTimeout(), configuration.getAgentStorageCheckInterval()) && !cSp.dom0CheckStorageHealthCheck()) {	} else if (cSp.dom0CheckStorageHealthCheck()) {	} else {	}	return new PingRoutingCommand(getType(), id, hypervisorsupport.hostVmStateReport());	} else {	
agent did not respond correctly but got 

hypervisorsupport.syncState();	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (!cSp.dom0CheckStorageHealthCheck(configuration .getAgentScriptsDir(), configuration.getAgentCheckStorageScript(), configuration.getCsHostGuid(), configuration.getAgentStorageCheckTimeout(), configuration.getAgentStorageCheckInterval()) && !cSp.dom0CheckStorageHealthCheck()) {	} else if (cSp.dom0CheckStorageHealthCheck()) {	} else {	}	return new PingRoutingCommand(getType(), id, hypervisorsupport.hostVmStateReport());	} else {	}	} catch (Ovm3ResourceException | NullPointerException e) {	
check agent status failed 

public Answer executeRequest(Command cmd) {	Class<? extends Command> clazz = cmd.getClass();	
executerequest called 

return vmsupport.execute((PlugNicCommand) cmd);	} else if (clazz == UnPlugNicCommand.class) {	return vmsupport.execute((UnPlugNicCommand) cmd);	} else if (clazz == StartCommand.class) {	return execute((StartCommand) cmd);	} else if (clazz == StopCommand.class) {	return execute((StopCommand) cmd);	} else if (clazz == RebootCommand.class) {	return execute((RebootCommand) cmd);	}	
can t find class for executerequest is your direct call missing 

public void disconnected() {	
disconnected seems unused everywhere else 

public IAgentControl getAgentControl() {	
we don t use iagentcontrol 

public void setAgentControl(IAgentControl agentControl) {	
no use in setting iagentcontrol 

public void setRunLevel(int level) {	
runlevel seems unused in other hypervisors 

public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {	
configure with params 

public void setConnection(Connection con) {	
override connection 

try {	hypervisorsupport.setVmStateStarting(vmName);	Xen.Vm vm = xen.getVmConfig();	vm.setVmCpus(vmSpec.getCpus());	vm.setVmMemory(vmSpec.getMinRam() / 1024 / 1024);	vm.setVmUuid(UUID.nameUUIDFromBytes(vmSpec.getName(). getBytes(Charset.defaultCharset())).toString());	vm.setVmName(vmName);	String domType = guesttypes.getOvm3GuestType(vmSpec.getOs());	if (domType == null || domType.isEmpty()) {	domType = "default";	
vm virt type missing setting to 

hypervisorsupport.setVmStateStarting(vmName);	Xen.Vm vm = xen.getVmConfig();	vm.setVmCpus(vmSpec.getCpus());	vm.setVmMemory(vmSpec.getMinRam() / 1024 / 1024);	vm.setVmUuid(UUID.nameUUIDFromBytes(vmSpec.getName(). getBytes(Charset.defaultCharset())).toString());	vm.setVmName(vmName);	String domType = guesttypes.getOvm3GuestType(vmSpec.getOs());	if (domType == null || domType.isEmpty()) {	domType = "default";	} else {	
vm virt type set to for 

vm.setVmMemory(vmSpec.getMinRam() / 1024 / 1024);	vm.setVmUuid(UUID.nameUUIDFromBytes(vmSpec.getName(). getBytes(Charset.defaultCharset())).toString());	vm.setVmName(vmName);	String domType = guesttypes.getOvm3GuestType(vmSpec.getOs());	if (domType == null || domType.isEmpty()) {	domType = "default";	} else {	}	vm.setVmDomainType(domType);	if (vmSpec.getBootloader() == BootloaderType.CD) {	
cd booting is not supported 

for (int count = 0; count < 60; count++) {	CloudstackPlugin cSp = new CloudstackPlugin(c);	if (hypervisorsupport.getVmState(vmName) == null && count > 1) {	String msg = "VM " + vmName + " went missing on " + configuration.getAgentHostname() + ", returning stopped";	LOGGER.debug(msg);	state = State.Stopped;	return new StartAnswer(cmd, msg);	}	try {	Boolean res = cSp.domrCheckSsh(controlIp);	
connected to on attempt result 

LOGGER.debug(msg);	state = State.Stopped;	return new StartAnswer(cmd, msg);	}	try {	Boolean res = cSp.domrCheckSsh(controlIp);	if (res) {	break;	}	} catch (Exception x) {	
unable to connect to on attempt 

}	Thread.sleep(5000);	}	}	if (configuration.getAgentInOvm3Pool() && configuration.getAgentInOvm3Cluster()) {	xen.configureVmHa(ovmObject.deDash(vm.getPrimaryPoolUuid()), vm.getVmUuid(), true);	}	state = State.Running;	return new StartAnswer(cmd);	} catch (Exception e) {	
start vm failed 

public StopAnswer execute(StopCommand cmd) {	String vmName = cmd.getVmName();	State state = State.Error;	hypervisorsupport.setVmState(vmName, State.Stopping);	try {	Xen vms = new Xen(c);	Xen.Vm vm = null;	vm = vms.getRunningVmConfig(vmName);	if (vm == null) {	state = State.Stopping;	
unable to get details of vm treating it as stopping 

vms.deleteVm(repoId, vmId);	vmsupport.cleanup(vm);	if (vms.getRunningVmConfig(vmName) != null) {	String msg = "Stop " + vmName + " failed ";	LOGGER.debug(msg);	return new StopAnswer(cmd, msg, false);	}	state = State.Stopped;	return new StopAnswer(cmd, "success", true);	} catch (Exception e) {	
stop failed 

Xen xen = new Xen(c);	Xen.Vm vm = xen.getRunningVmConfig(vmName);	if (vm == null) {	return new RebootAnswer(cmd, vmName + " not present", false);	}	xen.rebootVm(ovmObject.deDash(vm.getVmRootDiskPoolId()), vm.getVmUuid());	vm = xen.getRunningVmConfig(vmName);	Integer vncPort = vm.getVncPort();	return new RebootAnswer(cmd, null, vncPort);	} catch (Exception e) {	
reboot failed 

========================= cloudstack sample_840 =========================

protected void upgradeDomR(Connection conn, long dcId, long domrId, Long publicNetworkId, long guestNetworkId, long controlNetworkId, String zoneType, String vnet) throws SQLException {	
upgrading domr 

protected void upgradeSsvm(Connection conn, long dataCenterId, long publicNetworkId, long managementNetworkId, long controlNetworkId, String zoneType) throws SQLException {	
upgrading ssvm in 

protected void upgradeSsvm(Connection conn, long dataCenterId, long publicNetworkId, long managementNetworkId, long controlNetworkId, String zoneType) throws SQLException {	try ( PreparedStatement selectInstance = conn.prepareStatement("SELECT vm_instance.id, vm_instance.state, vm_instance.private_mac_address, vm_instance.private_ip_address, vm_instance.private_netmask, secondary_storage_vm.public_mac_address, secondary_storage_vm.public_ip_address, secondary_storage_vm.public_netmask, secondary_storage_vm.guest_mac_address, secondary_storage_vm.guest_ip_address, secondary_storage_vm.guest_netmask, secondary_storage_vm.gateway, vm_instance.type FROM vm_instance INNER JOIN secondary_storage_vm ON vm_instance.id=secondary_storage_vm.id WHERE vm_instance.removed is NULL AND vm_instance.data_center_id=? AND vm_instance.type='SecondaryStorageVm'");	) {	selectInstance.setLong(1, dataCenterId);	try (ResultSet instanceResult = selectInstance.executeQuery();) {	if (!instanceResult.next()) {	
unable to find ssvm in data center 

String publicIp = instanceResult.getString(7);	String publicNetmask = instanceResult.getString(8);	String guestMac = instanceResult.getString(9);	String guestIp = instanceResult.getString(10);	String guestNetmask = instanceResult.getString(11);	String gateway = instanceResult.getString(12);	try (PreparedStatement selectHost = conn.prepareStatement("SELECT host_pod_ref.gateway from host_pod_ref INNER JOIN vm_instance ON vm_instance.pod_id=host_pod_ref.id WHERE vm_instance.removed is NULL AND vm_instance.data_center_id=? AND vm_instance.type='SecondaryStorageVm'");) {	selectHost.setLong(1, dataCenterId);	try (ResultSet hostResult = selectHost.executeQuery();) {	if (!hostResult.next()) {	
unable to find ssvm in data center 

protected void upgradeConsoleProxy(Connection conn, long dcId, long cpId, long publicNetworkId, long managementNetworkId, long controlNetworkId, String zoneType) throws SQLException {	
upgrading cp 

List<Object[]> vms = new ArrayList<Object[]>();	while (rs.next()) {	Object[] vm = new Object[10];	vm[0] = rs.getLong(1);	vm[1] = rs.getString(2);	vm[2] = rs.getString(3);	vm[3] = rs.getString(4);	vm[4] = rs.getString(5);	vms.add(vm);	}	
upgrading vms for router 

protected void upgradeDirectUserIpAddress(Connection conn, long dcId, long networkId, String vlanType) throws SQLException {	
upgrading user ip address for data center network vlan type 

try (ResultSet rs = pstmt.executeQuery();) {	ArrayList<Object[]> allocatedIps = new ArrayList<Object[]>();	while (rs.next()) {	Object[] ip = new Object[10];	ip[0] = rs.getLong(1);	ip[1] = rs.getString(2);	ip[2] = rs.getLong(3);	ip[3] = rs.getDate(4);	allocatedIps.add(ip);	}	
marking ip addresses to belong to network 

protected void upgradePublicUserIpAddress(Connection conn, long dcId, long networkId, String vlanType) throws SQLException {	
upgrading user ip address for data center network vlan type 

if (_basicZone) {	for (Object[] dc : dcs) {	updateBasicNetworkingDataCenter(conn, managementNetworkOfferingId, controlNetworkOfferingId, storageNetworkOfferingId, dc);	}	} else {	for (Object[] dc : dcs) {	updateAdvancedNetworkingDataCenter(conn, managementNetworkOfferingId, publicNetworkOfferingId, controlNetworkOfferingId, storageNetworkOfferingId, dc);	}	}	} catch (SQLException e) {	
can t update data center 

private long retrieveNetworkOfferingId(Connection conn, String type) throws SQLException, CloudRuntimeException {	long networkOfferingId;	try ( PreparedStatement pstmt = conn.prepareStatement("SELECT id FROM network_offerings WHERE name=?");	) {	pstmt.setString(1, type);	try (ResultSet rs = pstmt.executeQuery();) {	if (!rs.next()) {	
unable to find the network offering for networktype 

HashMap<String, Long> vlanNetworkMap = new HashMap<String, Long>();	while (vlanData.next()) {	long vlanId = vlanData.getLong(1);	String tag = vlanData.getString(2);	String gateway = vlanData.getString(3);	String netmask = vlanData.getString(4);	String cidr = NetUtils.getCidrFromGatewayAndNetmask(gateway, netmask);	retrieveAccountDataAndCreateNetwork(conn, dc, dcId, vlanNetworkMap, vlanId, tag, gateway, cidr);	updateNetworkInVlanTableforTag(conn, vlanNetworkMap, vlanId, tag);	upgradeDirectUserIpAddress(conn, dcId, vlanNetworkMap.get(tag), "DirectAttached");	
created direct networks and upgraded direct ip addresses 

ResultSet rs = selectUserStatistics.executeQuery();	) {	while (rs.next()) {	Long id = rs.getLong(1);	Long accountId = rs.getLong(2);	Long dataCenterId = rs.getLong(3);	try (PreparedStatement selectNetworkType = conn.prepareStatement("SELECT networktype from data_center where id=?");) {	selectNetworkType.setLong(1, dataCenterId);	try (ResultSet dcSet = selectNetworkType.executeQuery();) {	if (!dcSet.next()) {	
unable to get data center information as a part of user statistics update 

}	try (PreparedStatement updateUserStatistics = conn.prepareStatement("UPDATE user_statistics SET device_id=? where id=?");) {	updateUserStatistics.setLong(1, deviceId);	updateUserStatistics.setLong(2, id);	updateUserStatistics.executeUpdate();	}	}	}	}	}	
upgraded userstatistcis with deviceid s 

Object[] rule = new Object[10];	rule[0] = rs.getLong(1);	rule[1] = rs.getString(2);	rule[2] = rs.getString(3);	rule[3] = rs.getString(4);	rule[4] = rs.getString(5);	rule[5] = rs.getString(6);	rules.add(rule);	}	if (!rules.isEmpty()) {	
found port forwarding rules to upgrade 

if (!rules.isEmpty()) {	for (Object[] rule : rules) {	long id = (Long)rule[0];	String sourcePort = (String)rule[2];	String protocol = (String)rule[5];	String publicIp = (String)rule[1];	try (PreparedStatement selectUserIpAddressData = conn.prepareStatement("SELECT id, account_id, domain_id, network_id FROM user_ip_address WHERE public_ip_address=?");) {	selectUserIpAddressData.setString(1, publicIp);	try (ResultSet userIpAddressData = selectUserIpAddressData.executeQuery();) {	if (!userIpAddressData.next()) {	
unable to find public ip address 

selectUserIpAddressData.setString(1, publicIp);	try (ResultSet userIpAddressData = selectUserIpAddressData.executeQuery();) {	if (!userIpAddressData.next()) {	throw new CloudRuntimeException("Unable to find public IP address " + publicIp);	}	int ipAddressId = userIpAddressData.getInt(1);	long accountId = userIpAddressData.getLong(2);	long domainId = userIpAddressData.getLong(3);	long networkId = userIpAddressData.getLong(4);	String privateIp = (String)rule[3];	
updating port forwarding rules table 

long networkId = userIpAddressData.getLong(4);	String privateIp = (String)rule[3];	try (PreparedStatement selectInstanceId = conn.prepareStatement("SELECT instance_id FROM nics where network_id=? AND ip4_address=?");) {	selectInstanceId.setLong(1, networkId);	selectInstanceId.setString(2, privateIp);	try (ResultSet selectedInstanceId = selectInstanceId.executeQuery();) {	if (!selectedInstanceId.next()) {	s_logger.warn("Unable to find vmId for private ip address " + privateIp + " for account id=" + accountId + "; assume that the vm is expunged");	} else {	long instanceId = selectedInstanceId.getLong(1);	
instance id is 

long networkId = userIpAddressData.getLong(4);	String privateIp = (String)rule[3];	try (PreparedStatement selectInstanceId = conn.prepareStatement("SELECT instance_id FROM nics where network_id=? AND ip4_address=?");) {	selectInstanceId.setLong(1, networkId);	selectInstanceId.setString(2, privateIp);	try (ResultSet selectedInstanceId = selectInstanceId.executeQuery();) {	if (!selectedInstanceId.next()) {	s_logger.warn("Unable to find vmId for private ip address " + privateIp + " for account id=" + accountId + "; assume that the vm is expunged");	} else {	long instanceId = selectedInstanceId.getLong(1);	
updating firewall rules table as a part of pf rules upgrade 

insertFirewallRules.setLong(1, id);	insertFirewallRules.setInt(2, ipAddressId);	insertFirewallRules.setInt(3, Integer.parseInt(sourcePort.trim()));	insertFirewallRules.setInt(4, Integer.parseInt(sourcePort.trim()));	insertFirewallRules.setString(5, protocol);	insertFirewallRules.setLong(6, accountId);	insertFirewallRules.setLong(7, domainId);	insertFirewallRules.setLong(8, networkId);	insertFirewallRules.setString(9, UUID.randomUUID().toString());	insertFirewallRules.executeUpdate();	
firewall rules table is updated as a part of pf rules upgrade 

}	String privatePort = (String)rule[4];	try (PreparedStatement insertPortForwardingRules = conn.prepareStatement("INSERT INTO port_forwarding_rules VALUES (?,    ?,      ?,      ?,       ?)");) {	insertPortForwardingRules.setLong(1, id);	insertPortForwardingRules.setLong(2, instanceId);	insertPortForwardingRules.setString(3, privateIp);	insertPortForwardingRules.setInt(4, Integer.parseInt(privatePort.trim()));	insertPortForwardingRules.setInt(5, Integer.parseInt(privatePort.trim()));	insertPortForwardingRules.executeUpdate();	}	
port forwarding rules table is updated 

insertPortForwardingRules.setInt(5, Integer.parseInt(privatePort.trim()));	insertPortForwardingRules.executeUpdate();	}	}	}	}	}	}	}	}	
port forwarding rules are updated 

Object[] lb = new Object[10];	lb[0] = rs.getString(1);	lb[1] = rs.getString(2);	lb[2] = rs.getString(3);	lb[3] = rs.getString(4);	lb[4] = rs.getString(5);	lb[5] = rs.getLong(6);	lbs.add(lb);	}	if (!lbs.isEmpty()) {	
found lb rules to upgrade 

try (PreparedStatement deleteLoadBalancer = conn.prepareStatement("DELETE from load_balancer where id=?");) {	deleteLoadBalancer.setLong(1, originalLbId);	deleteLoadBalancer.executeUpdate();	}	continue;	}	int ipAddressId = ipData.getInt(1);	long accountId = ipData.getLong(2);	long domainId = ipData.getLong(3);	long networkId = ipData.getLong(4);	
updating firewall rules table as a part of lb rules upgrade 

insertFirewallRules.setInt(2, ipAddressId);	insertFirewallRules.setInt(3, Integer.parseInt(sourcePort));	insertFirewallRules.setInt(4, Integer.parseInt(sourcePort));	insertFirewallRules.setString(5, "tcp");	insertFirewallRules.setLong(6, accountId);	insertFirewallRules.setLong(7, domainId);	insertFirewallRules.setLong(8, networkId);	insertFirewallRules.setString(9, UUID.randomUUID().toString());	insertFirewallRules.executeUpdate();	}	
firewall rules table is updated as a part of lb rules upgrade 

insertFirewallRules.setInt(4, Integer.parseInt(sourcePort));	insertFirewallRules.setString(5, "tcp");	insertFirewallRules.setLong(6, accountId);	insertFirewallRules.setLong(7, domainId);	insertFirewallRules.setLong(8, networkId);	insertFirewallRules.setString(9, UUID.randomUUID().toString());	insertFirewallRules.executeUpdate();	}	}	}	
updating load balancing rules table as a part of lb rules upgrade 

}	}	try (PreparedStatement insertLoadBalancer = conn.prepareStatement("INSERT INTO load_balancing_rules VALUES (?,      ?,      NULL,      ?,       ?,      ?)");) {	insertLoadBalancer.setLong(1, newLbId);	insertLoadBalancer.setString(2, name);	insertLoadBalancer.setInt(3, Integer.parseInt(destPort));	insertLoadBalancer.setInt(4, Integer.parseInt(destPort));	insertLoadBalancer.setString(5, algorithm);	insertLoadBalancer.executeUpdate();	}	
load balancing rules table is updated as a part of lb rules upgrade 

}	}	try (PreparedStatement insertLoadBalancer = conn.prepareStatement("INSERT INTO load_balancing_rules VALUES (?,      ?,      NULL,      ?,       ?,      ?)");) {	insertLoadBalancer.setLong(1, newLbId);	insertLoadBalancer.setString(2, name);	insertLoadBalancer.setInt(3, Integer.parseInt(destPort));	insertLoadBalancer.setInt(4, Integer.parseInt(destPort));	insertLoadBalancer.setString(5, algorithm);	insertLoadBalancer.executeUpdate();	}	
updating load balancer vm map table as a part of lb rules upgrade 

lbMap[0] = selectedInstance.getLong(1);	lbMaps.add(lbMap);	}	}	}	try (PreparedStatement updateLoadBalancer = conn.prepareStatement("UPDATE load_balancer_vm_map SET load_balancer_id=? WHERE load_balancer_id=?");) {	updateLoadBalancer.setLong(1, newLbId);	updateLoadBalancer.setLong(2, originalLbId);	updateLoadBalancer.executeUpdate();	}	
load balancer vm map table is updated as a part of lb rules upgrade 

}	}	}	try (PreparedStatement updateLoadBalancer = conn.prepareStatement("UPDATE load_balancer_vm_map SET load_balancer_id=? WHERE load_balancer_id=?");) {	updateLoadBalancer.setLong(1, newLbId);	updateLoadBalancer.setLong(2, originalLbId);	updateLoadBalancer.executeUpdate();	}	}	}	
lb rules are upgraded 

private void migrateEvents(Connection conn) {	try ( PreparedStatement pstmt1 = conn.prepareStatement("SHOW DATABASES LIKE 'cloud_usage'");	ResultSet rs1 = pstmt1.executeQuery();	) {	if (!rs1.next()) {	
cloud usage db doesn t exist skipping events migration 

private void migrateEvents(Connection conn) {	try ( PreparedStatement pstmt1 = conn.prepareStatement("SHOW DATABASES LIKE 'cloud_usage'");	ResultSet rs1 = pstmt1.executeQuery();	) {	if (!rs1.next()) {	return;	}	Long lastProcessedEvent = getMostRecentEvent(conn);	String sql = "SELECT type, description, user_id, account_id, created, level, parameters FROM cloud.event vmevt WHERE vmevt.id > ? and vmevt.state = 'Completed' ";	if (lastProcessedEvent == null) {	
no events are processed earlier copying all events 

String sql = "SELECT type, description, user_id, account_id, created, level, parameters FROM cloud.event vmevt WHERE vmevt.id > ? and vmevt.state = 'Completed' ";	if (lastProcessedEvent == null) {	sql = "SELECT type, description, user_id, account_id, created, level, parameters FROM cloud.event vmevt WHERE vmevt.state = 'Completed' ";	}	try (PreparedStatement pstmt = conn.prepareStatement(sql);) {	int i = 1;	if (lastProcessedEvent != null) {	pstmt.setLong(i++, lastProcessedEvent);	}	try (ResultSet rs = pstmt.executeQuery();) {	
begin migrating events 

event.setDescription(rs.getString(2));	event.setUserId(rs.getLong(3));	event.setAccountId(rs.getLong(4));	event.setCreatedDate(DateUtil.parseDateString(TimeZone.getTimeZone("GMT"), rs.getString(5)));	event.setLevel(rs.getString(6));	event.setParameters(rs.getString(7));	convertEvent(event, conn);	}	}	}	
migrating events completed 

createLoadBalancerEvents(conn);	createNetworkOfferingEvents(conn);	hypervisorTypeUpdate.executeUpdate();	instanceUpdate.executeUpdate();	updateUserStats(conn);	deleteOrphanedTemplateRef(conn);	cleanupVolumes(conn);	modifyIndexes(conn);	cleanupLbVmMaps(conn);	} catch (SQLException e) {	
can t perform data migration 

private void deleteOrphanedTemplateRef(Connection conn) {	try ( PreparedStatement selectStoragePoolRef = conn.prepareStatement("SELECT id, pool_id from template_spool_ref");	ResultSet rs = selectStoragePoolRef.executeQuery();	) {	if (!rs.next()) {	
no records in template spool ref skipping this upgrade part 

if (!selectedStoragePool.next()) {	s_logger.debug("Orphaned template_spool_ref record is found (storage pool doesn't exist any more0) id=" + id + "; so removing the record");	try (PreparedStatement delete = conn.prepareStatement("DELETE FROM template_spool_ref where id=?");) {	delete.setLong(1, id);	delete.executeUpdate();	}	}	}	}	}	
finished deleting orphaned template spool ref s 

s_logger.debug("Orphaned template_spool_ref record is found (storage pool doesn't exist any more0) id=" + id + "; so removing the record");	try (PreparedStatement delete = conn.prepareStatement("DELETE FROM template_spool_ref where id=?");) {	delete.setLong(1, id);	delete.executeUpdate();	}	}	}	}	}	} catch (Exception e) {	
failed to delete orphaned template spool ref s 

private void cleanupVolumes(Connection conn) {	try ( PreparedStatement selectVolumes = conn.prepareStatement("SELECT id, instance_id, account_id from volumes where destroyed=127");	ResultSet selectedVolumes = selectVolumes.executeQuery();	){	while (selectedVolumes.next()) {	Long id = selectedVolumes.getLong(1);	
volume id is 

if (removeVolume) {	try(PreparedStatement pstmt = conn.prepareStatement("UPDATE volumes SET state='Destroy' WHERE id=?");) {	pstmt.setLong(1, id);	pstmt.executeUpdate();	s_logger.debug("Volume with id=" + id + " is marked with Destroy state as a part of volume cleanup (it's Destroyed had 127 value)");	}	}	}	}	}	
finished cleaning up volumes with incorrect destroyed field 

try(PreparedStatement pstmt = conn.prepareStatement("UPDATE volumes SET state='Destroy' WHERE id=?");) {	pstmt.setLong(1, id);	pstmt.executeUpdate();	s_logger.debug("Volume with id=" + id + " is marked with Destroy state as a part of volume cleanup (it's Destroyed had 127 value)");	}	}	}	}	}	} catch (Exception e) {	
failed to cleanup volumes with incorrect destroyed field 

private void modifyIndexes(Connection conn) {	try ( PreparedStatement show__Index = conn.prepareStatement("SHOW INDEX FROM security_group WHERE KEY_NAME = 'fk_network_group__account_id'");	ResultSet result__index = show__Index.executeQuery();	) {	if (result__index.next()) {	try (PreparedStatement alterTable = conn.prepareStatement("ALTER TABLE `cloud`.`security_group` DROP INDEX `fk_network_group__account_id`");) {	alterTable.executeUpdate();	
unique key fk network group account id is removed successfully 

try (PreparedStatement alterTable = conn.prepareStatement("ALTER TABLE `cloud`.`security_group` DROP INDEX `fk_network_group__account_id`");) {	alterTable.executeUpdate();	}	}	try ( PreparedStatement show___Index = conn.prepareStatement("SHOW INDEX FROM security_group WHERE KEY_NAME = 'fk_network_group___account_id'");	ResultSet result___index = show___Index.executeQuery();	) {	if (result___index.next()) {	try (PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`security_group` DROP INDEX `fk_network_group___account_id`");) {	pstmt.executeUpdate();	
unique key fk network group account id is removed successfully 

private void createPortForwardingEvents(Connection conn) {	
creating port forwarding usage events 

try ( PreparedStatement pstmt1 = conn.prepareStatement("INSERT INTO usage_event (usage_event.type, usage_event.created, usage_event.account_id, usage_event.zone_id, usage_event.resource_id)" + " VALUES (?, ?, ?, ?, ?)");	) {	pstmt1.setString(1, EventTypes.EVENT_NET_RULE_ADD);	pstmt1.setString(2, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), now));	pstmt1.setLong(3, accountId);	pstmt1.setLong(4, zoneId);	pstmt1.setLong(5, ruleId);	pstmt1.executeUpdate();	}	}	
completed creating port forwarding usage events 

private void createLoadBalancerEvents(Connection conn) {	
creating load balancer usage events 

try ( PreparedStatement pstmt1 = conn.prepareStatement("INSERT INTO usage_event (usage_event.type, usage_event.created, usage_event.account_id, usage_event.zone_id, usage_event.resource_id)" + " VALUES (?, ?, ?, ?, ?)");	) {	pstmt1.setString(1, EventTypes.EVENT_LOAD_BALANCER_CREATE);	pstmt1.setString(2, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), now));	pstmt1.setLong(3, accountId);	pstmt1.setLong(4, zoneId);	pstmt1.setLong(5, ruleId);	pstmt1.executeUpdate();	}	}	
completed creating load balancer usage events 

private void createNetworkOfferingEvents(Connection conn) {	
creating network offering usage events 

pstmt1.setString(2, DateUtil.getDateDisplayString(TimeZone.getTimeZone("GMT"), now));	pstmt1.setLong(3, accountId);	pstmt1.setLong(4, zoneId);	pstmt1.setLong(5, vmId);	pstmt1.setString(6, vmName);	pstmt1.setLong(7, nw_offering_id);	pstmt1.setLong(8, isDefault);	pstmt1.executeUpdate();	}	}	
completed creating network offering usage events 

========================= cloudstack sample_4226 =========================

public void execute() {	boolean result = false;	try {	result = _autoScaleService.deleteCondition(getId());	} catch (ResourceInUseException ex) {	
exception 

boolean result = false;	try {	result = _autoScaleService.deleteCondition(getId());	} catch (ResourceInUseException ex) {	throw new ServerApiException(ApiErrorCode.RESOURCE_IN_USE_ERROR, ex.getMessage());	}	if (result) {	SuccessResponse response = new SuccessResponse(getCommandName());	setResponseObject(response);	} else {	
failed to delete condition 

========================= cloudstack sample_3449 =========================

protected void doGet(HttpServletRequest req, HttpServletResponse resp) {	try {	if (_accountMgr == null || _vmMgr == null || _ms == null) {	sendResponse(resp, "Service is not ready");	return;	}	if (_keysMgr.getHashKey() == null) {	
console thumbnail access denied ticket service is not ready yet 

Account accountObj = null;	Map<String, Object[]> params = new HashMap<String, Object[]>();	params.putAll(req.getParameterMap());	HttpSession session = req.getSession(false);	if (session == null) {	if (verifyRequest(params)) {	userId = (String)params.get("userid")[0];	account = (String)params.get("account")[0];	accountObj = (Account)params.get("accountobj")[0];	} else {	
invalid web session or api key in request reject console thumbnail access 

} else {	if (session.getAttribute("userid") != null) {	userId = ((Long)session.getAttribute("userid")).toString();	}	accountObj = (Account)session.getAttribute("accountobj");	if (accountObj != null) {	account = "" + accountObj.getId();	}	}	if ((userId == null) || (account == null) || (accountObj == null) || !verifyUser(Long.valueOf(userId))) {	
invalid user account reject console thumbnail access 

if (accountObj != null) {	account = "" + accountObj.getId();	}	}	if ((userId == null) || (account == null) || (accountObj == null) || !verifyUser(Long.valueOf(userId))) {	sendResponse(resp, "Access denied. Invalid or inconsistent account is found");	return;	}	String cmd = req.getParameter("cmd");	if (cmd == null || !isValidCmd(cmd)) {	
invalid console servlet command 

return;	}	String cmd = req.getParameter("cmd");	if (cmd == null || !isValidCmd(cmd)) {	sendResponse(resp, "");	return;	}	String vmIdString = req.getParameter("vm");	VirtualMachine vm = _entityMgr.findByUuid(VirtualMachine.class, vmIdString);	if (vm == null) {	
invalid console servlet command parameter 

return;	}	if (cmd.equalsIgnoreCase("thumbnail")) {	handleThumbnailRequest(req, resp, vmId);	} else if (cmd.equalsIgnoreCase("access")) {	handleAccessRequest(req, resp, vmId);	} else {	handleAuthRequest(req, resp, vmId);	}	} catch (Throwable e) {	
unexepected exception in consoleproxyservlet 

private void handleThumbnailRequest(HttpServletRequest req, HttpServletResponse resp, long vmId) {	VirtualMachine vm = _vmMgr.findById(vmId);	if (vm == null) {	
vm does not exist sending blank response for thumbnail request 

private void handleThumbnailRequest(HttpServletRequest req, HttpServletResponse resp, long vmId) {	VirtualMachine vm = _vmMgr.findById(vmId);	if (vm == null) {	sendResponse(resp, "");	return;	}	if (vm.getHostId() == null) {	
vm lost host info sending blank response for thumbnail request 

if (vm == null) {	sendResponse(resp, "");	return;	}	if (vm.getHostId() == null) {	sendResponse(resp, "");	return;	}	HostVO host = _ms.getHostBy(vm.getHostId());	if (host == null) {	
vm s host does not exist sending blank response for thumbnail request 

if (rootUrl == null) {	sendResponse(resp, "");	return;	}	int w = DEFAULT_THUMBNAIL_WIDTH;	int h = DEFAULT_THUMBNAIL_HEIGHT;	String value = req.getParameter("w");	try {	w = Integer.parseInt(value);	} catch (NumberFormatException e) {	
ignored not a number 

int h = DEFAULT_THUMBNAIL_HEIGHT;	String value = req.getParameter("w");	try {	w = Integer.parseInt(value);	} catch (NumberFormatException e) {	}	value = req.getParameter("h");	try {	h = Integer.parseInt(value);	} catch (NumberFormatException e) {	
ignored not a number 

} catch (NumberFormatException e) {	}	value = req.getParameter("h");	try {	h = Integer.parseInt(value);	} catch (NumberFormatException e) {	}	try {	resp.sendRedirect(composeThumbnailUrl(rootUrl, vm, host, w, h));	} catch (IOException e) {	
client may already close the connection 

private void handleAccessRequest(HttpServletRequest req, HttpServletResponse resp, long vmId) {	VirtualMachine vm = _vmMgr.findById(vmId);	if (vm == null) {	
vm does not exist sending blank response for console access request 

private void handleAccessRequest(HttpServletRequest req, HttpServletResponse resp, long vmId) {	VirtualMachine vm = _vmMgr.findById(vmId);	if (vm == null) {	sendResponse(resp, "");	return;	}	if (vm.getHostId() == null) {	
vm lost host info sending blank response for console access request 

if (vm == null) {	sendResponse(resp, "");	return;	}	if (vm.getHostId() == null) {	sendResponse(resp, "");	return;	}	HostVO host = _ms.getHostBy(vm.getHostId());	if (host == null) {	
vm s host does not exist sending blank response for console access request 

if (vm.getType() == VirtualMachine.Type.User) {	UserVm userVm = _entityMgr.findById(UserVm.class, vmId);	String displayName = userVm.getDisplayName();	if (displayName != null && !displayName.isEmpty() && !displayName.equals(vmName)) {	vmName += "(" + displayName + ")";	}	}	StringBuffer sb = new StringBuffer();	sb.append("<html><title>").append(escapeHTML(vmName)).append("</title><frameset><frame src=\"").append(composeConsoleAccessUrl(rootUrl, vm, host));	sb.append("\"></frame></frameset></html>");	
the console url is 

private void handleAuthRequest(HttpServletRequest req, HttpServletResponse resp, long vmId) {	VirtualMachine vm = _vmMgr.findById(vmId);	if (vm == null) {	
vm does not exist sending failed response for authentication request from console proxy 

private void handleAuthRequest(HttpServletRequest req, HttpServletResponse resp, long vmId) {	VirtualMachine vm = _vmMgr.findById(vmId);	if (vm == null) {	sendResponse(resp, "failed");	return;	}	if (vm.getHostId() == null) {	
vm lost host info failed response for authentication request from console proxy 

if (vm == null) {	sendResponse(resp, "failed");	return;	}	if (vm.getHostId() == null) {	sendResponse(resp, "failed");	return;	}	HostVO host = _ms.getHostBy(vm.getHostId());	if (host == null) {	
vm s host does not exist sending failed response for authentication request from console proxy 

sendResponse(resp, "failed");	return;	}	HostVO host = _ms.getHostBy(vm.getHostId());	if (host == null) {	sendResponse(resp, "failed");	return;	}	String sid = req.getParameter("sid");	if (sid == null || !sid.equals(vm.getVncPassword())) {	
sid in url does not match stored sid 

static public Ternary<String, String, String> parseHostInfo(String hostInfo) {	String host = null;	String tunnelUrl = null;	String tunnelSession = null;	
parse host info returned from executing getvncportcommand host info 

param.setUsername(_ms.findDetail(hostVo.getId(), "username").getValue());	param.setPassword(_ms.findDetail(hostVo.getId(), "password").getValue());	}	if (parsedHostInfo.second() != null && parsedHostInfo.third() != null) {	param.setClientTunnelUrl(parsedHostInfo.second());	param.setClientTunnelSession(parsedHostInfo.third());	}	sb.append("/ajaximg?token=" + encryptor.encryptObject(ConsoleProxyClientParam.class, param));	sb.append("&w=").append(w).append("&h=").append(h).append("&key=0");	if (s_logger.isDebugEnabled()) {	
compose thumbnail url 

private String composeConsoleAccessUrl(String rootUrl, VirtualMachine vm, HostVO hostVo) {	StringBuffer sb = new StringBuffer(rootUrl);	String host = hostVo.getPrivateIpAddress();	Pair<String, Integer> portInfo = _ms.getVncPort(vm);	
port info 

}	if (parsedHostInfo.second() != null  && parsedHostInfo.third() != null) {	param.setClientTunnelUrl(parsedHostInfo.second());	param.setClientTunnelSession(parsedHostInfo.third());	}	sb.append("/ajax?token=" + encryptor.encryptObject(ConsoleProxyClientParam.class, param));	long guestOs = vm.getGuestOSId();	GuestOSVO guestOsVo = _ms.getGuestOs(guestOs);	if (guestOsVo.getCategoryId() == 6) sb.append("&guest=windows");	if (s_logger.isDebugEnabled()) {	
compose console url 

Mac mac = Mac.getInstance("HmacSHA1");	long ts = normalizedHashTime.getTime();	ts = ts String secretKey = s_keysMgr.getHashKey();	SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), "HmacSHA1");	mac.init(keySpec);	mac.update(params.getBytes());	mac.update(String.valueOf(ts).getBytes());	byte[] encryptedBytes = mac.doFinal();	return Base64.encodeBase64String(encryptedBytes);	} catch (Exception e) {	
unexpected exception 

private void sendResponse(HttpServletResponse resp, String content) {	try {	resp.setContentType("text/html");	resp.getWriter().print(content);	} catch (IOException e) {	
client may already close the connection 

private boolean checkSessionPermision(HttpServletRequest req, long vmId, Account accountObj) {	VirtualMachine vm = _vmMgr.findById(vmId);	if (vm == null) {	
console thumbnail access denied vm does not exist in system any more 

if (vm == null) {	return false;	}	if (_accountMgr.isRootAdmin(accountObj.getId())) return true;	switch (vm.getType()) {	case User: try {	_accountMgr.checkAccess(accountObj, null, true, vm);	} catch (PermissionDeniedException ex) {	if (_accountMgr.isNormalUser(accountObj.getId())) {	if (s_logger.isDebugEnabled()) {	
vm access is denied vm owner account does not match the account id in session and caller is a normal user 

if (_accountMgr.isRootAdmin(accountObj.getId())) return true;	switch (vm.getType()) {	case User: try {	_accountMgr.checkAccess(accountObj, null, true, vm);	} catch (PermissionDeniedException ex) {	if (_accountMgr.isNormalUser(accountObj.getId())) {	if (s_logger.isDebugEnabled()) {	}	} else if (_accountMgr.isDomainAdmin(accountObj.getId()) || accountObj.getType() == Account.ACCOUNT_TYPE_READ_ONLY_ADMIN) {	if(s_logger.isDebugEnabled()) {	
vm access is denied vm owner account does not match the account id in session and the domain admin caller does not manage the target domain 

if (s_logger.isDebugEnabled()) {	}	} else if (_accountMgr.isDomainAdmin(accountObj.getId()) || accountObj.getType() == Account.ACCOUNT_TYPE_READ_ONLY_ADMIN) {	if(s_logger.isDebugEnabled()) {	}	}	return false;	}	break;	case DomainRouter: case ConsoleProxy: case SecondaryStorageVm: return false;	
unrecoginized virtual machine type deny access by default type 

}	if (unsignedRequest == null) {	unsignedRequest = paramName + "=" + URLEncoder.encode(paramValue, "UTF-8").replaceAll("\\+", "%20");	} else {	unsignedRequest = unsignedRequest + "&" + paramName + "=" + URLEncoder.encode(paramValue, "UTF-8").replaceAll("\\+", "%20");	}	}	}	if ((signature == null) || (apiKey == null)) {	if (s_logger.isDebugEnabled()) {	
expired session missing signature or missing apikey ignoring request sig apikey 

if ((signature == null) || (apiKey == null)) {	if (s_logger.isDebugEnabled()) {	}	return false;	}	TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);	txn.close();	User user = null;	Pair<User, Account> userAcctPair = _accountMgr.findUserByApiKey(apiKey);	if (userAcctPair == null) {	
apikey does not map to a valid user ignoring request apikey 

return false;	}	user = userAcctPair.first();	Account account = userAcctPair.second();	if (!user.getState().equals(Account.State.enabled) || !account.getState().equals(Account.State.enabled)) {	s_logger.debug("disabled or locked user accessing the api, userid = " + user.getId() + "; name = " + user.getUsername() + "; state: " + user.getState() + "; accountState: " + account.getState());	return false;	}	secretKey = user.getSecretKey();	if (secretKey == null) {	
user does not have a secret key associated with the account ignoring request username 

}	unsignedRequest = unsignedRequest.toLowerCase();	Mac mac = Mac.getInstance("HmacSHA1");	SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), "HmacSHA1");	mac.init(keySpec);	mac.update(unsignedRequest.getBytes());	byte[] encryptedBytes = mac.doFinal();	String computedSignature = Base64.encodeBase64String(encryptedBytes);	boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);	if (!equalSig) {	
user signature is not equaled to computed signature 

boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);	if (!equalSig) {	}	if (equalSig) {	requestParameters.put("userid", new Object[] {String.valueOf(user.getId())});	requestParameters.put("account", new Object[] {account.getAccountName()});	requestParameters.put("accountobj", new Object[] {account});	}	return equalSig;	} catch (Exception ex) {	
unable to verifty request signature 

========================= cloudstack sample_2258 =========================

public void testVirtualMachineDBLookup() {	ModelDatabase db = new ModelDatabase();	VMInstanceVO vm  = mock(VMInstanceVO.class);	VirtualMachineModel  vm0 = new VirtualMachineModel(vm, "fbc1f8fa-4b78-45ee-bba0-b551dbf72353");	db.getVirtualMachines().add(vm0);	VirtualMachineModel  vm1 = new VirtualMachineModel(vm, "fbc1f8fa-4b78-45ee-bba0-b551dbf83464");	db.getVirtualMachines().add(vm1);	VirtualMachineModel  vm2 = new VirtualMachineModel(vm, "fbc1f8fa-4b78-45ee-bba0-b551dbf94575");	db.getVirtualMachines().add(vm2);	
no of vitual machines added to database 

========================= cloudstack sample_1862 =========================

String temp = "bash xen/" + this.commandName;	Set<?> c = this.urlParam.entrySet();	Iterator<?> it = c.iterator();	while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	try {	temp = temp + " -" + key + " " + value;	} catch (Exception ex) {	
unable to set parameter for the command 

String temp = this.commandName + " where ";	Set<?> c = this.urlParam.entrySet();	Iterator<?> it = c.iterator();	while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	try {	temp = temp + key + "=" + value;	} catch (Exception ex) {	
unable to set parameter for the command 

while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	try {	temp = temp + key + "=" + value;	} catch (Exception ex) {	}	}	this.command = temp;	
the command is 

String temp = this.host + ":8096/?command=" + this.commandName;	Set<?> c = this.urlParam.entrySet();	Iterator<?> it = c.iterator();	while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	try {	temp = temp + "&" + key + "=" + URLEncoder.encode(value, "UTF-8");	} catch (Exception ex) {	
unable to set parameter for the command 

this.urlParam.put("command", this.commandName);	Set<?> c = this.urlParam.entrySet();	Iterator<?> it = c.iterator();	while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	try {	temp = temp + key + "=" + URLEncoder.encode(value, "UTF-8") + "&";	} catch (Exception ex) {	
unable to set parameter for the command 

public void sendCommand(HttpClient client, Connection conn) {	if (TestCaseEngine.s_printUrl == true) {	
url is 

public void sendCommand(HttpClient client, Connection conn) {	if (TestCaseEngine.s_printUrl == true) {	}	if (this.getCommandType() == CommandType.SCRIPT) {	try {	
executing command 

Runtime rtime = Runtime.getRuntime();	Process child = rtime.exec(this.command);	Thread.sleep(10000);	int retCode = child.waitFor();	if (retCode != 0) {	this.responseCode = retCode;	} else {	this.responseCode = 200;	}	} catch (Exception ex) {	
unable to execute a command 

}	} catch (Exception ex) {	}	} else if (this.getCommandType() == CommandType.MYSQL) {	try {	Statement stmt = conn.createStatement();	this.result = stmt.executeQuery(this.command);	this.responseCode = 200;	} catch (Exception ex) {	this.responseCode = 400;	
unable to execute mysql query 

DocumentBuilder builder = factory.newDocumentBuilder();	Document doc = builder.parse(is);	doc.getDocumentElement().normalize();	if (!(this.isAsync)) {	this.responseBody = doc.getDocumentElement();	} else {	Element jobTag = (Element)doc.getDocumentElement().getElementsByTagName("jobid").item(0);	String jobId = jobTag.getTextContent();	Element responseBodyAsyncEl = queryAsyncJobResult(jobId);	if (responseBodyAsyncEl == null) {	
can t get a async result 

this.responseBody = responseBodyAsyncEl;	Element jobStatusTag = (Element)responseBodyAsyncEl.getElementsByTagName("jobstatus").item(0);	String jobStatus = jobStatusTag.getTextContent();	if (!jobStatus.equals("1")) {	this.responseCode = 400;	}	}	}	}	if (TestCaseEngine.s_printUrl == true) {	
response code is 

String jobStatus = jobStatusTag.getTextContent();	if (!jobStatus.equals("1")) {	this.responseCode = 400;	}	}	}	}	if (TestCaseEngine.s_printUrl == true) {	}	} catch (Exception ex) {	
command failed with exception 

public boolean setParam(HashMap<String, String> param) {	if ((this.responseBody == null) && (this.commandType == CommandType.HTTP)) {	
response body is empty 

String key = (String)me.getKey();	String value = (String)me.getValue();	try {	String itemName = null;	while (this.result.next()) {	itemName = this.result.getString(value);	}	if (itemName != null) {	param.put(key, itemName);	} else {	
following return parameter is missing 

String itemName = null;	while (this.result.next()) {	itemName = this.result.getString(value);	}	if (itemName != null) {	param.put(key, itemName);	} else {	result = false;	}	} catch (Exception ex) {	
unable to set parameter 

NodeList itemName = this.responseBody.getElementsByTagName(value);	if ((itemName != null) && (itemName.getLength() != 0)) {	for (int i = 0; i < itemName.getLength(); i++) {	Element itemNameElement = (Element)itemName.item(i);	if (itemNameElement.getChildNodes().getLength() <= 1) {	param.put(key, itemNameElement.getTextContent());	break;	}	}	} else {	
following return parameter is missing 

Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	NodeList itemName = fstElmnt.getElementsByTagName(value);	if ((itemName != null) && (itemName.getLength() != 0)) {	Element itemNameElement = (Element)itemName.item(0);	if (itemNameElement.getChildNodes().getLength() <= 1) {	param.put(key, itemNameElement.getTextContent());	}	} else {	
following return parameter is missing 

boolean result = true;	if (this.getCommandType() == CommandType.HTTP) {	if (this.list == false) {	Set<?> set = verifyParam.entrySet();	Iterator<?> it = set.iterator();	while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	if (value == null) {	
parameter is missing in the list of global parameters 

if (value == null) {	return false;	}	NodeList itemName = this.responseBody.getElementsByTagName(key);	if ((itemName.getLength() != 0) && (itemName != null)) {	Element itemNameElement = (Element)itemName.item(0);	if (itemNameElement.hasChildNodes()) {	continue;	}	if (!(verifyParam.get(key).equals("no value")) && !(itemNameElement.getTextContent().equals(verifyParam.get(key)))) {	
incorrect value for the following tag expected value is while actual value is 

NodeList itemName = this.responseBody.getElementsByTagName(key);	if ((itemName.getLength() != 0) && (itemName != null)) {	Element itemNameElement = (Element)itemName.item(0);	if (itemNameElement.hasChildNodes()) {	continue;	}	if (!(verifyParam.get(key).equals("no value")) && !(itemNameElement.getTextContent().equals(verifyParam.get(key)))) {	result = false;	}	} else {	
following xml element is missing in the response 

Iterator<?> it = set.iterator();	NodeList returnLst = this.responseBody.getElementsByTagName(this.listName.getTextContent());	Node requiredNode = returnLst.item(Integer.parseInt(this.listId.getTextContent()));	if (requiredNode.getNodeType() == Node.ELEMENT_NODE) {	Element fstElmnt = (Element)requiredNode;	while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	if (value == null) {	
parameter is missing in the list of global parameters 

Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	if (value == null) {	return false;	}	NodeList itemName = fstElmnt.getElementsByTagName(key);	if ((itemName.getLength() != 0) && (itemName != null)) {	Element itemNameElement = (Element)itemName.item(0);	if (!(verifyParam.get(key).equals("no value")) && !(itemNameElement.getTextContent().equals(verifyParam.get(key)))) {	
incorrect value for the following tag expected value is while actual value is 

if (value == null) {	return false;	}	NodeList itemName = fstElmnt.getElementsByTagName(key);	if ((itemName.getLength() != 0) && (itemName != null)) {	Element itemNameElement = (Element)itemName.item(0);	if (!(verifyParam.get(key).equals("no value")) && !(itemNameElement.getTextContent().equals(verifyParam.get(key)))) {	result = false;	}	} else {	
following xml element is missing in the response 

}	}	} else if (this.getCommandType() == CommandType.MYSQL) {	Set<?> set = verifyParam.entrySet();	Iterator<?> it = set.iterator();	while (it.hasNext()) {	Map.Entry<?, ?> me = (Map.Entry<?, ?>)it.next();	String key = (String)me.getKey();	String value = (String)me.getValue();	if (value == null) {	
parameter is missing in the list of global parameters 

String value = (String)me.getValue();	if (value == null) {	return false;	}	String itemName = null;	try {	while (this.result.next()) {	itemName = this.result.getString(key);	}	} catch (Exception ex) {	
unable to get element from result set 

return false;	}	String itemName = null;	try {	while (this.result.next()) {	itemName = this.result.getString(key);	}	} catch (Exception ex) {	}	if (!(value.equals("no value")) && !(itemName.equals(verifyParam.get(key)))) {	
incorrect value for the following tag expected value is while actual value is 

Properties pro = new Properties();	try {	FileInputStream in = new FileInputStream(file);	pro.load(in);	Enumeration<?> en = pro.propertyNames();	while (en.hasMoreElements()) {	key = (String)en.nextElement();	expectedEvents.put(key, Integer.parseInt(pro.getProperty(key)));	}	String url = host + "/?command=listEvents&account=" + account + "&level=" + level + "&domainid=1&pagesize=100";	
getting events with the following url 

Integer expected;	Integer actual;	int fail = 0;	while (iterator.hasNext()) {	expected = null;	actual = null;	String type = iterator.next().toString();	expected = expectedEvents.get(type);	actual = actualEvents.get(type);	if (actual == null) {	
event of type and level is missing in the listevents response expected number of these events is 

while (iterator.hasNext()) {	expected = null;	actual = null;	String type = iterator.next().toString();	expected = expectedEvents.get(type);	actual = actualEvents.get(type);	if (actual == null) {	fail++;	} else if (expected.compareTo(actual) != 0) {	fail++;	
amount of events of type and level is incorrect expected number of these events is actual number is 

fail++;	}	}	if (fail == 0) {	result = true;	}	} catch (Exception ex) {	s_logger.error(ex);	}	} else {	
file not found 

Integer expected;	Integer actual;	int fail = 0;	while (iterator.hasNext()) {	expected = null;	actual = null;	String type = iterator.next().toString();	expected = expectedEvents.get(type);	actual = actualEvents.get(type);	if (actual == null) {	
event of type and level is missing in the listevents response expected number of these events is 

while (iterator.hasNext()) {	expected = null;	actual = null;	String type = iterator.next().toString();	expected = expectedEvents.get(type);	actual = actualEvents.get(type);	if (actual == null) {	fail++;	} else if (expected.compareTo(actual) != 0) {	fail++;	
amount of events of type and level is incorrect expected number of these events is actual number is 

DocumentBuilder builder = factory.newDocumentBuilder();	Document doc = builder.parse(is);	doc.getDocumentElement().normalize();	returnBody = doc.getDocumentElement();	Element jobStatusTag = (Element)returnBody.getElementsByTagName("jobstatus").item(0);	String jobStatus = jobStatusTag.getTextContent();	if (jobStatus.equals("0")) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
ignored interupted while during async job result query 

if (jobStatus.equals("0")) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	} else {	break;	}	method.releaseConnection();	} else {	
error during queryjobasync error code is 

========================= cloudstack sample_456 =========================

public void prepareVlan(BaremetalVlanStruct struct) {	String link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/vlan/%s", struct.getVlan()));	HttpHeaders headers = createBasicAuthenticationHeader(struct);	HttpEntity<String> request = new HttpEntity<>(headers);	ResponseEntity rsp = rest.exchange(link, HttpMethod.GET, request, String.class);	
http get s 

public void prepareVlan(BaremetalVlanStruct struct) {	String link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/vlan/%s", struct.getVlan()));	HttpHeaders headers = createBasicAuthenticationHeader(struct);	HttpEntity<String> request = new HttpEntity<>(headers);	ResponseEntity rsp = rest.exchange(link, HttpMethod.GET, request, String.class);	if (rsp.getStatusCode() == HttpStatus.NOT_FOUND) {	PortInfo port = new PortInfo(struct);	XmlObject xml = new XmlObject("vlan").putElement("vlan-id", new XmlObject("vlan-id").setText(String.valueOf(struct.getVlan()))).putElement("untagged", new XmlObject("untagged").putElement(port.interfaceType, new XmlObject(port.interfaceType) .putElement("name", new XmlObject("name").setText(port.port))) ).putElement("shutdown", new XmlObject("shutdown").setText("false"));	request = new HttpEntity<>(xml.dump(), headers);	link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/"));	
http get s body s 

ResponseEntity rsp = rest.exchange(link, HttpMethod.GET, request, String.class);	if (rsp.getStatusCode() == HttpStatus.NOT_FOUND) {	PortInfo port = new PortInfo(struct);	XmlObject xml = new XmlObject("vlan").putElement("vlan-id", new XmlObject("vlan-id").setText(String.valueOf(struct.getVlan()))).putElement("untagged", new XmlObject("untagged").putElement(port.interfaceType, new XmlObject(port.interfaceType) .putElement("name", new XmlObject("name").setText(port.port))) ).putElement("shutdown", new XmlObject("shutdown").setText("false"));	request = new HttpEntity<>(xml.dump(), headers);	link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/"));	rsp = rest.exchange(link, HttpMethod.POST, request, String.class);	if (!successHttpStatusCode.contains(rsp.getStatusCode())) {	throw new CloudRuntimeException(String.format("unable to create vlan[%s] on force10 switch[ip:%s]. HTTP status code:%s, body dump:%s", struct.getVlan(), struct.getSwitchIp(),rsp.getStatusCode(), rsp.getBody()));	} else {	
successfully programmed vlan s on ip s port s http response status code s body s 

}	} else if (successHttpStatusCode.contains(rsp.getStatusCode())) {	PortInfo port = new PortInfo(struct);	XmlObject xml = XmlObjectParser.parseFromString((String)rsp.getBody());	List<XmlObject> ports = xml.getAsList("untagged.tengigabitethernet");	ports.addAll(xml.<XmlObject>getAsList("untagged.gigabitethernet"));	ports.addAll(xml.<XmlObject>getAsList("untagged.fortyGigE"));	for (XmlObject pxml : ports) {	XmlObject name = pxml.get("name");	if (port.port.equals(name.getText())) {	
port s has joined in vlan s no need to program again 

xml.removeElement("mtu");	xml.setText(null);	XmlObject tag = xml.get("untagged");	if (tag == null) {	tag = new XmlObject("untagged");	xml.putElement("untagged", tag);	}	tag.putElement(port.interfaceType, new XmlObject(port.interfaceType) .putElement("name", new XmlObject("name").setText(port.port)));	request = new HttpEntity<>(xml.dump(), headers);	link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/vlan/%s", struct.getVlan()));	
http get s body s 

tag = new XmlObject("untagged");	xml.putElement("untagged", tag);	}	tag.putElement(port.interfaceType, new XmlObject(port.interfaceType) .putElement("name", new XmlObject("name").setText(port.port)));	request = new HttpEntity<>(xml.dump(), headers);	link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/vlan/%s", struct.getVlan()));	rsp = rest.exchange(link, HttpMethod.PUT, request, String.class);	if (!successHttpStatusCode.contains(rsp.getStatusCode())) {	throw new CloudRuntimeException(String.format("failed to program vlan[%s] for port[%s] on force10[ip:%s]. http status:%s, body dump:%s", struct.getVlan(), struct.getPort(), struct.getSwitchIp(), rsp.getStatusCode(), rsp.getBody()));	} else {	
successfully join port s into vlan s on ip s http response status code s body s 

public void removePortFromVlan(BaremetalVlanStruct struct) {	String link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/vlan/%s", struct.getVlan()));	HttpHeaders headers = createBasicAuthenticationHeader(struct);	HttpEntity<String> request = new HttpEntity<>(headers);	
http get s body s 

public void removePortFromVlan(BaremetalVlanStruct struct) {	String link = buildLink(struct.getSwitchIp(), String.format("/api/running/ftos/interface/vlan/%s", struct.getVlan()));	HttpHeaders headers = createBasicAuthenticationHeader(struct);	HttpEntity<String> request = new HttpEntity<>(headers);	ResponseEntity rsp = rest.exchange(link, HttpMethod.GET, request, String.class);	if (rsp.getStatusCode() == HttpStatus.NOT_FOUND) {	
vlan s has been deleted on ip s no need to remove the port s anymore 

return;	}	xml.setText(null);	xml.removeElement("mtu");	XmlObject tagged = xml.get("untagged");	tagged.removeAllChildren();	for (XmlObject p : newPorts) {	tagged.putElement(p.getTag(), p);	}	request = new HttpEntity<>(xml.dump(), headers);	
http get s body s 

XmlObject tagged = xml.get("untagged");	tagged.removeAllChildren();	for (XmlObject p : newPorts) {	tagged.putElement(p.getTag(), p);	}	request = new HttpEntity<>(xml.dump(), headers);	rsp = rest.exchange(link, HttpMethod.PUT, request, String.class);	if (!successHttpStatusCode.contains(rsp.getStatusCode())) {	throw new CloudRuntimeException(String.format("failed to program vlan[%s] for port[%s] on force10[ip:%s]. http status:%s, body dump:%s", struct.getVlan(), struct.getPort(), struct.getSwitchIp(), rsp.getStatusCode(), rsp.getBody()));	} else {	
removed port s from vlan s on ip s 

========================= cloudstack sample_905 =========================

public void init(byte[] ksBits, String ksPassword) {	
start initializing ssl 

public void init(byte[] ksBits, String ksPassword) {	if (ksBits == null) {	
no certificates passed recheck global configuration and certificates 

public void init(byte[] ksBits, String ksPassword) {	if (ksBits == null) {	} else {	char[] passphrase = ksPassword != null ? ksPassword.toCharArray() : null;	try {	
initializing ssl from passed in certificate 

public void init(byte[] ksBits, String ksPassword) {	if (ksBits == null) {	} else {	char[] passphrase = ksPassword != null ? ksPassword.toCharArray() : null;	try {	KeyStore ks = KeyStore.getInstance("JKS");	ks.load(new ByteArrayInputStream(ksBits), passphrase);	KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");	kmf.init(ks, passphrase);	
key manager factory is initialized 

if (ksBits == null) {	} else {	char[] passphrase = ksPassword != null ? ksPassword.toCharArray() : null;	try {	KeyStore ks = KeyStore.getInstance("JKS");	ks.load(new ByteArrayInputStream(ksBits), passphrase);	KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");	kmf.init(ks, passphrase);	TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");	tmf.init(ks);	
trust manager factory is initialized 

char[] passphrase = ksPassword != null ? ksPassword.toCharArray() : null;	try {	KeyStore ks = KeyStore.getInstance("JKS");	ks.load(new ByteArrayInputStream(ksBits), passphrase);	KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");	kmf.init(ks, passphrase);	TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");	tmf.init(ks);	sslContext = SSLUtils.getSSLContext();	sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);	
ssl context is initialized 

try {	KeyStore ks = KeyStore.getInstance("JKS");	ks.load(new ByteArrayInputStream(ksBits), passphrase);	KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");	kmf.init(ks, passphrase);	TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");	tmf.init(ks);	sslContext = SSLUtils.getSSLContext();	sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);	} catch (Exception e) {	
unable to init factory due to exception 

try {	HttpsServer server = HttpsServer.create(new InetSocketAddress(port), 5);	server.setHttpsConfigurator(new HttpsConfigurator(sslContext) {	public void configure(HttpsParameters params) {	InetSocketAddress remote = params.getClientAddress();	SSLContext c = getSSLContext();	SSLParameters sslparams = c.getDefaultSSLParameters();	params.setSSLParameters(sslparams);	}	});	
create https server instance on port 

public SSLServerSocket createSSLServerSocket(int port) throws IOException {	try {	SSLServerSocket srvSock = null;	SSLServerSocketFactory ssf = sslContext.getServerSocketFactory();	srvSock = (SSLServerSocket)ssf.createServerSocket(port);	srvSock.setEnabledProtocols(SSLUtils.getSupportedProtocols(srvSock.getEnabledProtocols()));	
create ssl server socket on port 

========================= cloudstack sample_4949 =========================

nfsServiceCmd.putCommandParameter("mapuserstoroot", "yes");	nfsServiceCmd.putCommandParameter("readonly", "no");	NfsServiceResponse nfsServiceResponse = (NfsServiceResponse) getElastistorRestClient().executeCommand(nfsServiceCmd);	if (nfsServiceResponse.getNfsService().getUuid() != null) {	UpdateControllerCmd controllerCmd = new UpdateControllerCmd();	controllerCmd.putCommandParameter("nfsid", nfsServiceResponse.getNfsService().getUuid());	controllerCmd.putCommandParameter("type", "configurenfs");	controllerCmd.putCommandParameter("id", nfsServiceResponse.getNfsService().getControllerid());	UpdateControllerResponse controllerResponse = (UpdateControllerResponse) getElastistorRestClient().executeCommand(controllerCmd);	if (controllerResponse.getController().getUuid() != null) {	
updated nfs service to all 

public static boolean deleteElastistorTsm(String tsmid, boolean managed) throws Throwable {	if (!managed) {	
elastistor pool is not a managed storage hence deleting the volume then tsm 

String esvolumeid = null;	ListTsmsResponse listTsmsResponse = listTsm(tsmid);	if (listTsmsResponse.getTsmsCount() != 0) {	if (listTsmsResponse.getTsms().getTsm(0).checkvolume()) {	esvolumeid = listTsmsResponse.getTsms().getTsm(0).getVolumeProperties(0).getid();	DeleteVolumeResponse deleteVolumeResponse = deleteVolume(esvolumeid, null);	if (deleteVolumeResponse != null) {	String jobid = deleteVolumeResponse.getJobId();	int jobstatus = queryAsyncJobResult(jobid);	if (jobstatus == 1) {	
elastistor volume successfully deleted 

ListTsmsResponse listTsmsResponse = listTsm(tsmid);	if (listTsmsResponse.getTsmsCount() != 0) {	if (listTsmsResponse.getTsms().getTsm(0).checkvolume()) {	esvolumeid = listTsmsResponse.getTsms().getTsm(0).getVolumeProperties(0).getid();	DeleteVolumeResponse deleteVolumeResponse = deleteVolume(esvolumeid, null);	if (deleteVolumeResponse != null) {	String jobid = deleteVolumeResponse.getJobId();	int jobstatus = queryAsyncJobResult(jobid);	if (jobstatus == 1) {	} else {	
now farce deleting the volume 

int jobstatus = queryAsyncJobResult(jobid);	if (jobstatus == 1) {	} else {	while (jobstatus != 1) {	DeleteVolumeResponse deleteVolumeResponse1 = deleteVolume(esvolumeid, "true");	if (deleteVolumeResponse1 != null) {	String jobid1 = deleteVolumeResponse1.getJobId();	jobstatus = queryAsyncJobResult(jobid1);	}	}	
elastistor volume successfully deleted 

while (jobstatus != 1) {	DeleteVolumeResponse deleteVolumeResponse1 = deleteVolume(esvolumeid, "true");	if (deleteVolumeResponse1 != null) {	String jobid1 = deleteVolumeResponse1.getJobId();	jobstatus = queryAsyncJobResult(jobid1);	}	}	}	}	} else {	
no volume present in on the given tsm 

String jobid1 = deleteVolumeResponse1.getJobId();	jobstatus = queryAsyncJobResult(jobid1);	}	}	}	}	} else {	}	}	}	
now trying to delete elastistor tsm 

}	}	}	if (tsmid != null) {	DeleteTsmCmd deleteTsmCmd = new DeleteTsmCmd();	deleteTsmCmd.putCommandParameter(ElastistorUtil.REST_PARAM_ID, tsmid);	DeleteTsmResponse deleteTsmResponse = (DeleteTsmResponse) getElastistorRestClient().executeCommand(deleteTsmCmd);	if (deleteTsmResponse != null) {	String jobstatus = deleteTsmResponse.getJobStatus();	if (jobstatus.equalsIgnoreCase("true")) {	
deletion of elastistor tsm successful 

}	if (tsmid != null) {	DeleteTsmCmd deleteTsmCmd = new DeleteTsmCmd();	deleteTsmCmd.putCommandParameter(ElastistorUtil.REST_PARAM_ID, tsmid);	DeleteTsmResponse deleteTsmResponse = (DeleteTsmResponse) getElastistorRestClient().executeCommand(deleteTsmCmd);	if (deleteTsmResponse != null) {	String jobstatus = deleteTsmResponse.getJobStatus();	if (jobstatus.equalsIgnoreCase("true")) {	return true;	} else {	
failed to delete elastistor tsm 

deleteTsmCmd.putCommandParameter(ElastistorUtil.REST_PARAM_ID, tsmid);	DeleteTsmResponse deleteTsmResponse = (DeleteTsmResponse) getElastistorRestClient().executeCommand(deleteTsmCmd);	if (deleteTsmResponse != null) {	String jobstatus = deleteTsmResponse.getJobStatus();	if (jobstatus.equalsIgnoreCase("true")) {	return true;	} else {	return false;	}	} else {	
elastistor tsm id not present 

if (deleteTsmResponse != null) {	String jobstatus = deleteTsmResponse.getJobStatus();	if (jobstatus.equalsIgnoreCase("true")) {	return true;	} else {	return false;	}	} else {	}	}	
tsm id is null 

public static boolean deleteElastistorVolume(String esvolumeid) throws Throwable {	FileSystem fileSystem = listVolume(esvolumeid);	if (fileSystem != null) {	DeleteVolumeResponse deleteVolumeResponse = deleteVolume(esvolumeid, null);	if (deleteVolumeResponse != null) {	String jobid = deleteVolumeResponse.getJobId();	int jobstatus = queryAsyncJobResult(jobid);	if (jobstatus == 1) {	
elastistor volume successfully deleted 

public static boolean deleteElastistorVolume(String esvolumeid) throws Throwable {	FileSystem fileSystem = listVolume(esvolumeid);	if (fileSystem != null) {	DeleteVolumeResponse deleteVolumeResponse = deleteVolume(esvolumeid, null);	if (deleteVolumeResponse != null) {	String jobid = deleteVolumeResponse.getJobId();	int jobstatus = queryAsyncJobResult(jobid);	if (jobstatus == 1) {	return true;	} else {	
now force deleting the volume 

if (jobstatus == 1) {	return true;	} else {	while (jobstatus != 1) {	DeleteVolumeResponse deleteVolumeResponse1 = deleteVolume(esvolumeid, "true");	if (deleteVolumeResponse1 != null) {	String jobid1 = deleteVolumeResponse1.getJobId();	jobstatus = queryAsyncJobResult(jobid1);	}	}	
elastistor volume successfully deleted 

while (jobstatus != 1) {	DeleteVolumeResponse deleteVolumeResponse1 = deleteVolume(esvolumeid, "true");	if (deleteVolumeResponse1 != null) {	String jobid1 = deleteVolumeResponse1.getJobId();	jobstatus = queryAsyncJobResult(jobid1);	}	}	return true;	}	} else {	
the given volume is not present on elastistor datasetrespone is null 

String jobid1 = deleteVolumeResponse1.getJobId();	jobstatus = queryAsyncJobResult(jobid1);	}	}	return true;	}	} else {	return false;	}	} else {	
the given volume is not present on elastistor 

public static UpdateTsmStorageCmdResponse updateElastistorTsmStorage(String capacityBytes,String uuid) throws Throwable{	Long size = (Long.parseLong(capacityBytes)/(1024 * 1024 * 1024));	String quotasize = null;	if(size > 1024){	quotasize = (String.valueOf(Long.parseLong(capacityBytes)/(1024)) + "T");	}else{	quotasize = String.valueOf(quotasize) + "G";	}	
elastistor tsm storage is updating to 

public static UpdateTsmCmdResponse updateElastistorTsmIOPS(String capacityIOPs,String uuid) throws Throwable{	
elastistor tsm iops is updating to 

========================= cloudstack sample_1931 =========================

private void fixRelatedFkeyOnNetworksTable(Connection conn) throws SQLException {	PreparedStatement pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`networks` DROP FOREIGN KEY `fk_networks__related`");	try {	pstmt.executeUpdate();	} catch (SQLException e) {	
ignore if the key is not there 

pstmtUpdate.executeUpdate();	pstmtUpdate.close();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to update the cluster Ids in Op_Host_capacity table", e);	} finally {	if (pstmtUpdate != null) {	try {	pstmtUpdate.close();	} catch (SQLException e) {	
ignored 

if (pstmtUpdate != null) {	try {	pstmtUpdate.close();	} catch (SQLException e) {	}	}	if (rs != null) {	try {	rs.close();	} catch (SQLException e) {	
ignored 

if (rs != null) {	try {	rs.close();	} catch (SQLException e) {	}	}	if (pstmt != null) {	try {	pstmt.close();	} catch (SQLException e) {	
ignored 

if (networkId != null) {	pstmt = conn.prepareStatement("UPDATE user_statistics SET network_id=?, device_type='DomainRouter' where id=?");	pstmt.setLong(1, networkId);	pstmt.setLong(2, id);	pstmt.executeUpdate();	}	}	}	rs.close();	pstmt.close();	
upgraded user statistics with networkid for domainrouter device type 

pstmt.setLong(2, id);	pstmt.executeUpdate();	}	}	}	rs.close();	pstmt.close();	PreparedStatement pstmt1 = conn.prepareStatement("update user_statistics us, user_ip_address uip set us.network_id = uip.network_id where us.public_ip_address = uip.public_ip_address " + "and us.device_type in ('ExternalFirewall' , 'ExternalLoadBalancer')");	pstmt1.executeUpdate();	pstmt1.close();	
upgraded user statistics with networkid for externalfirewall and externalloadbalancer device types 

pstmt.setLong(2, id);	pstmt.executeUpdate();	}	}	}	rs.close();	pstmt.close();	PreparedStatement pstmt1 = conn.prepareStatement("update user_statistics us, user_ip_address uip set us.network_id = uip.network_id where us.public_ip_address = uip.public_ip_address " + "and us.device_type in ('ExternalFirewall' , 'ExternalLoadBalancer')");	pstmt1.executeUpdate();	pstmt1.close();	
successfully update user statistics table with network ids as a part of to upgrade 

private void dropIndexIfExists(Connection conn) {	try {	PreparedStatement pstmt = conn.prepareStatement("SHOW INDEX FROM domain WHERE KEY_NAME = 'path'");	ResultSet rs = pstmt.executeQuery();	if (rs.next()) {	pstmt = conn.prepareStatement("ALTER TABLE `cloud`.`domain` DROP INDEX `path`");	pstmt.executeUpdate();	
unique key path is removed successfully 

pstmt = conn.prepareStatement("SELECT count(*) from vm_instance where name like 'i-%' and (state='Running' or state='Starting' or state='Stopping')");	rs = pstmt.executeQuery();	if (rs.next()) {	vmCount = rs.getLong(1);	}	pstmt = conn.prepareStatement("UPDATE op_networks set nics_count=? where id=?");	pstmt.setLong(1, vmCount);	pstmt.setLong(2, networkId);	pstmt.executeUpdate();	}	
basic zones are updated with correct nic counts successfully 

private void updateTotalCPUInOpHostCapacity(Connection conn) {	PreparedStatement pstmt = null;	ResultSet rs = null;	PreparedStatement pstmtUpdate = null;	try {	
updating total cpu capacity entries in op host capacity 

pstmtUpdate.executeUpdate();	pstmtUpdate.close();	}	} catch (SQLException e) {	throw new CloudRuntimeException("Unable to update the total host CPU capacity in Op_Host_capacity table", e);	} finally {	if (pstmtUpdate != null) {	try {	pstmtUpdate.close();	} catch (SQLException e) {	
ignored 

if (pstmtUpdate != null) {	try {	pstmtUpdate.close();	} catch (SQLException e) {	}	}	if (rs != null) {	try {	rs.close();	} catch (SQLException e) {	
ignored 

if (rs != null) {	try {	rs.close();	} catch (SQLException e) {	}	}	if (pstmt != null) {	try {	pstmt.close();	} catch (SQLException e) {	
ignored 

private void upgradeGuestOs(Connection conn) {	try {	PreparedStatement pstmt = conn.prepareStatement("SELECT * from guest_os WHERE id=138");	ResultSet rs = pstmt.executeQuery();	if (!rs.next()) {	pstmt = conn.prepareStatement("INSERT INTO `cloud`.`guest_os` (id, category_id, display_name) VALUES (138, 7, 'None')");	pstmt.executeUpdate();	
inserted none category to guest os table 

keysToAdd.add("ALTER TABLE `cloud`.`networks` ADD INDEX `i_networks__removed` (`removed`)");	indexesToAdd.add("ALTER TABLE `cloud`.`networks` ADD CONSTRAINT `fk_networks__network_offering_id` FOREIGN KEY (`network_offering_id`) REFERENCES `network_offerings`(`id`)");	indexesToAdd.add("ALTER TABLE `cloud`.`networks` ADD CONSTRAINT `fk_networks__data_center_id` FOREIGN KEY (`data_center_id`) REFERENCES `data_center` (`id`)");	indexesToAdd.add("ALTER TABLE `cloud`.`networks` ADD CONSTRAINT `fk_networks__account_id` FOREIGN KEY (`account_id`) REFERENCES `account` (`id`)");	indexesToAdd.add("ALTER TABLE `cloud`.`networks` ADD CONSTRAINT `fk_networks__domain_id` FOREIGN KEY (`domain_id`) REFERENCES `domain` (`id`)");	for (String key : keysToDrop) {	PreparedStatement pstmt = conn.prepareStatement(key);	try {	pstmt.executeUpdate();	} catch (SQLException e) {	
ignore if the key is not there 

pstmt.executeUpdate();	} catch (SQLException e) {	}	pstmt.close();	}	for (String index : indexesToDrop) {	PreparedStatement pstmt = conn.prepareStatement(index);	try {	pstmt.executeUpdate();	} catch (SQLException e) {	
ignore if the index is not there 

}	}	rs.close();	for (Long domainId : domainIpsCount.keySet()) {	pstmt = conn.prepareStatement("UPDATE resource_count set count=? where domain_id=? and type='public_ip'");	pstmt.setLong(1, domainIpsCount.get(domainId));	pstmt.setLong(2, domainId);	pstmt.executeUpdate();	}	pstmt.close();	
resource limit is cleaned up successfully as a part of db upgrade 

========================= cloudstack sample_4230 =========================

public Answer execute(final PrepareForMigrationCommand command, final LibvirtComputingResource libvirtComputingResource) {	final VirtualMachineTO vm = command.getVirtualMachine();	if (s_logger.isDebugEnabled()) {	
preparing host for migrating 

========================= cloudstack sample_1032 =========================

protected HttpMethod createMethod(final String type, final String uri, final int port) throws BigSwitchBcfApiException {	String url;	try {	url = new URL(S_PROTOCOL, host, port, uri).toString();	} catch (MalformedURLException e) {	
unable to build big switch api url 

public BigSwitchBcfApi() {	_client = createHttpClient();	_client.getParams().setCookiePolicy(CookiePolicy.BROWSER_COMPATIBILITY);	try {	Protocol.registerProtocol("https", new Protocol("https", (ProtocolSocketFactory) new TrustingProtocolSocketFactory(), _port));	} catch (IOException e) {	
failed to register the trustingprotocolsocketfactory falling back to default sslsocketfactory 

nameValuePairs.add(new NameValuePair(e.getKey(), e.getValue()));	}	gm.setQueryString(nameValuePairs.toArray(new NameValuePair[0]));	}	executeMethod(gm);	String hash = checkResponse(gm, "BigSwitch HTTP get failed: ");	T returnValue;	try {	returnValue = (T)gson.fromJson(gm.getResponseBodyAsString(2048), returnObjectType);	} catch (IOException e) {	
ioexception while retrieving response body 

protected void executeMethod(final HttpMethodBase method) throws BigSwitchBcfApiException {	try {	_client.executeMethod(method);	if (method.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {	method.releaseConnection();	}	} catch (HttpException e) {	
httpexception caught while trying to connect to the bigswitch controller 

protected void executeMethod(final HttpMethodBase method) throws BigSwitchBcfApiException {	try {	_client.executeMethod(method);	if (method.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {	method.releaseConnection();	}	} catch (HttpException e) {	method.releaseConnection();	throw new BigSwitchBcfApiException("API call to BigSwitch Controller Failed", e);	} catch (IOException e) {	
ioexception caught while trying to connect to the bigswitch controller 

private String responseToErrorMessage(final HttpMethodBase method) {	assert method.isRequestSent() : "no use getting an error message unless the request is sent";	if ("text/html".equals(method.getResponseHeader(CONTENT_TYPE).getValue())) {	try {	return method.getResponseBodyAsString(2048);	} catch (IOException e) {	
error while loading response body 

========================= cloudstack sample_1527 =========================

repeat = Boolean.parseBoolean(iter.next());	}	if (arg.equals("-u")) {	numOfUsers = Integer.parseInt(iter.next());	}	if (arg.equals("-i")) {	internet = Boolean.parseBoolean(iter.next());	}	}	final String server = host + ":" + port + testUrl;	
starting test against server with thread s 

repeat = Boolean.parseBoolean(iter.next());	}	if (arg.equals("-u")) {	numOfUsers = Integer.parseInt(iter.next());	}	if (arg.equals("-i")) {	internet = Boolean.parseBoolean(iter.next());	}	}	final String server = host + ":" + port + testUrl;	
clean up is enabled each test will wait ms before cleaning up 

}	if (arg.equals("-u")) {	numOfUsers = Integer.parseInt(iter.next());	}	if (arg.equals("-i")) {	internet = Boolean.parseBoolean(iter.next());	}	}	final String server = host + ":" + port + testUrl;	if (numOfUsers > 0) {	
pre generating users for test of size 

try {	long now = System.currentTimeMillis();	Random ran = new Random();	if (users != null) {	username = users[Math.abs(ran.nextInt()) % numOfUsers];	} else {	username = Math.abs(ran.nextInt()) + "-user";	}	NDC.push(username);	String url = server + "?email=" + username + "&password=" + username + "&command=deploy";	
launching test for user with url 

}	NDC.push(username);	String url = server + "?email=" + username + "&password=" + username + "&command=deploy";	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	boolean success = false;	String reason = null;	if (responseCode == 200) {	if (internet) {	
deploy successful waiting minute before ssh tests 

NDC.push(username);	String url = server + "?email=" + username + "&password=" + username + "&command=deploy";	HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	boolean success = false;	String reason = null;	if (responseCode == 200) {	if (internet) {	Thread.sleep(300000L);	
begin linux ssh test 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	boolean success = false;	String reason = null;	if (responseCode == 200) {	if (internet) {	Thread.sleep(300000L);	reason = sshTest(method.getResponseHeader("linuxIP").getValue());	if (reason == null) {	
linux ssh test successful 

HttpClient client = new HttpClient();	HttpMethod method = new GetMethod(url);	int responseCode = client.executeMethod(method);	boolean success = false;	String reason = null;	if (responseCode == 200) {	if (internet) {	Thread.sleep(300000L);	reason = sshTest(method.getResponseHeader("linuxIP").getValue());	if (reason == null) {	
begin windows ssh test 

if (responseCode == 200) {	if (internet) {	Thread.sleep(300000L);	reason = sshTest(method.getResponseHeader("linuxIP").getValue());	if (reason == null) {	reason = sshWinTest(method.getResponseHeader("windowsIP").getValue());	}	}	if (reason == null) {	if (internet) {	
windows ssh test successful 

if (internet) {	Thread.sleep(300000L);	reason = sshTest(method.getResponseHeader("linuxIP").getValue());	if (reason == null) {	reason = sshWinTest(method.getResponseHeader("windowsIP").getValue());	}	}	if (reason == null) {	if (internet) {	} else {	
deploy test successful now cleaning up 

Thread.sleep(300000L);	reason = sshTest(method.getResponseHeader("linuxIP").getValue());	if (reason == null) {	reason = sshWinTest(method.getResponseHeader("windowsIP").getValue());	}	}	if (reason == null) {	if (internet) {	} else {	if (cleanUp) {	
waiting ms before cleaning up vms 

if (reason == null) {	if (internet) {	} else {	if (cleanUp) {	Thread.sleep(sleepTime);	} else {	success = true;	}	}	if (users == null) {	
sending cleanup command 

} else {	if (cleanUp) {	Thread.sleep(sleepTime);	} else {	success = true;	}	}	if (users == null) {	url = server + "?email=" + username + "&password=" + username + "&command=cleanup";	} else {	
sending stop domr destroy vm command 

url = server + "?email=" + username + "&password=" + username + "&command=stopDomR";	}	method = new GetMethod(url);	responseCode = client.executeMethod(method);	if (responseCode == 200) {	success = true;	} else {	reason = method.getStatusText();	}	} else {	
ssh test failed with reason stopping vms 

success = true;	} else {	reason = method.getStatusText();	}	} else {	url = server + "?email=" + username + "&password=" + username + "&command=stop";	responseCode = client.executeMethod(new GetMethod(url));	}	} else {	reason = method.getStatusText();	
deploy test failed with reason stopping vms 

} else {	url = server + "?email=" + username + "&password=" + username + "&command=stop";	responseCode = client.executeMethod(new GetMethod(url));	}	} else {	reason = method.getStatusText();	url = server + "?email=" + username + "&password=" + username + "&command=stop";	client.executeMethod(new GetMethod(url));	}	if (success) {	
completed test for user in seconds 

url = server + "?email=" + username + "&password=" + username + "&command=stop";	responseCode = client.executeMethod(new GetMethod(url));	}	} else {	reason = method.getStatusText();	url = server + "?email=" + username + "&password=" + username + "&command=stop";	client.executeMethod(new GetMethod(url));	}	if (success) {	} else {	
failed test for user in seconds with reason 

}	} else {	reason = method.getStatusText();	url = server + "?email=" + username + "&password=" + username + "&command=stop";	client.executeMethod(new GetMethod(url));	}	if (success) {	} else {	}	} catch (Exception e) {	
error in thread 

}	if (success) {	} else {	}	} catch (Exception e) {	try {	HttpClient client = new HttpClient();	String url = server + "?email=" + username + "&password=" + username + "&command=stop";	client.executeMethod(new GetMethod(url));	} catch (Exception e1) {	
ignored error while executing last resort stop attampt 

private static String sshWinTest(String host) {	if (host == null) {	
did not receive a host back from test ignoring win ssh test 

private static String sshWinTest(String host) {	if (host == null) {	return null;	}	int retry = 0;	while (true) {	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt 

private static String sshWinTest(String host) {	if (host == null) {	return null;	}	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(300000);	}	
attempting to ssh into windows host with retry attempt 

return null;	}	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(300000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
sshed successfully into windows host 

SCPClient scp = new SCPClient(conn);	scp.put("wget.exe", "");	Session sess = conn.openSession();	s_logger.info("Executing : wget http: sess.execCommand("wget http: InputStream stdout = sess.getStdout();	InputStream stderr = sess.getStderr();	byte[] buffer = new byte[8192];	while (true) {	if ((stdout.available() == 0) && (stderr.available() == 0)) {	int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);	if ((conditions & ChannelCondition.TIMEOUT) != 0) {	
timeout while waiting for data from peer 

private static String sshTest(String host) {	if (host == null) {	
did not receive a host back from test ignoring ssh test 

private static String sshTest(String host) {	if (host == null) {	return null;	}	int retry = 0;	while (true) {	try {	if (retry > 0) {	
retry attempt sleeping seconds before next attempt 

private static String sshTest(String host) {	if (host == null) {	return null;	}	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	
attempting to ssh into linux host with retry attempt 

return null;	}	int retry = 0;	while (true) {	try {	if (retry > 0) {	Thread.sleep(120000);	}	Connection conn = new Connection(host);	conn.connect(null, 60000, 60000);	
sshed successfully into linux host 

}	boolean success = false;	Session sess = conn.openSession();	s_logger.info("Executing : wget http: sess.execCommand("wget http: InputStream stdout = sess.getStdout();	InputStream stderr = sess.getStderr();	byte[] buffer = new byte[8192];	while (true) {	if ((stdout.available() == 0) && (stderr.available() == 0)) {	int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);	if ((conditions & ChannelCondition.TIMEOUT) != 0) {	
timeout while waiting for data from peer 

========================= cloudstack sample_440 =========================

protected void runInContext() {	GetVmIpAddressCommand cmd = new GetVmIpAddressCommand(vmName, networkCidr, isWindows);	boolean decrementCount = true;	try {	
trying for vm nic id ip retrieval 

boolean decrementCount = true;	try {	Answer answer = _agentMgr.send(hostId, cmd);	NicVO nic = _nicDao.findById(nicId);	if (answer.getResult()) {	String vmIp = answer.getDetails();	if (NetUtils.isValidIp(vmIp)) {	if (nic != null) {	nic.setIPv4Address(vmIp);	_nicDao.update(nicId, nic);	
vm ip got retrieved successfully 

decrementCount = false;	ActionEventUtils.onActionEvent(User.UID_SYSTEM, Account.ACCOUNT_ID_SYSTEM, Domain.ROOT_DOMAIN, EventTypes.EVENT_NETWORK_EXTERNAL_DHCP_VM_IPFETCH, "VM " + vmId + " nic id " + nicId + " ip address " + vmIp + " got fetched successfully");	}	}	} else {	if (nic.getIPv4Address() != null) {	nic.setIPv4Address(null);	_nicDao.update(nicId, nic);	}	if (answer.getDetails() != null) {	
failed to get vm ip for vm 

}	} else {	if (nic.getIPv4Address() != null) {	nic.setIPv4Address(null);	_nicDao.update(nicId, nic);	}	if (answer.getDetails() != null) {	}	}	} catch (OperationTimedoutException e) {	
timed out 

} else {	if (nic.getIPv4Address() != null) {	nic.setIPv4Address(null);	_nicDao.update(nicId, nic);	}	if (answer.getDetails() != null) {	}	}	} catch (OperationTimedoutException e) {	} catch (AgentUnavailableException e) {	
agent unavailable 

}	if (answer.getDetails() != null) {	}	}	} catch (OperationTimedoutException e) {	} catch (AgentUnavailableException e) {	} finally {	if (decrementCount) {	VmAndCountDetails vmAndCount = vmIdCountMap.get(nicId);	vmAndCount.decrementCount();	
ip is not retrieved for vm nic decremented count to 

UserVmVO userVm = _vmDao.findById(cmd.getId());	if (userVm == null) {	throw new InvalidParameterValueException("unable to find a virtual machine with id " + cmd.getId());	}	_vmDao.loadDetails(userVm);	VMTemplateVO template = _templateDao.findByIdIncludingRemoved(userVm.getTemplateId());	if (template == null || !template.getEnablePassword()) {	throw new InvalidParameterValueException("Fail to reset password for the virtual machine, the template is not password enabled");	}	if (userVm.getState() == State.Error || userVm.getState() == State.Expunging) {	
vm is not in the right state 

private boolean resetVMPasswordInternal(Long vmId, String password) throws ResourceUnavailableException, InsufficientCapacityException {	Long userId = CallContext.current().getCallingUserId();	VMInstanceVO vmInstance = _vmDao.findById(vmId);	if (password == null || password.equals("")) {	return false;	}	VMTemplateVO template = _templateDao.findByIdIncludingRemoved(vmInstance.getTemplateId());	if (template.getEnablePassword()) {	Nic defaultNic = _networkModel.getDefaultNic(vmId);	if (defaultNic == null) {	
unable to reset password for vm as the instance doesn t have default nic 

Network defaultNetwork = _networkDao.findById(defaultNic.getNetworkId());	NicProfile defaultNicProfile = new NicProfile(defaultNic, defaultNetwork, null, null, null, _networkModel.isSecurityGroupSupportedInNetwork(defaultNetwork), _networkModel.getNetworkTag(template.getHypervisorType(), defaultNetwork));	VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vmInstance);	vmProfile.setParameter(VirtualMachineProfile.Param.VmPassword, password);	UserDataServiceProvider element = _networkMgr.getPasswordResetProvider(defaultNetwork);	if (element == null) {	throw new CloudRuntimeException("Can't find network element for " + Service.UserData.getName() + " provider needed for password reset");	}	boolean result = element.savePassword(defaultNetwork, defaultNicProfile, vmProfile);	if (!result) {	
failed to reset password for the virutal machine no need to reboot the vm 

vmProfile.setParameter(VirtualMachineProfile.Param.VmPassword, password);	UserDataServiceProvider element = _networkMgr.getPasswordResetProvider(defaultNetwork);	if (element == null) {	throw new CloudRuntimeException("Can't find network element for " + Service.UserData.getName() + " provider needed for password reset");	}	boolean result = element.savePassword(defaultNetwork, defaultNicProfile, vmProfile);	if (!result) {	return false;	} else {	if (vmInstance.getState() == State.Stopped) {	
vm is stopped not rebooting it as a part of password reset 

throw new CloudRuntimeException("Can't find network element for " + Service.UserData.getName() + " provider needed for password reset");	}	boolean result = element.savePassword(defaultNetwork, defaultNicProfile, vmProfile);	if (!result) {	return false;	} else {	if (vmInstance.getState() == State.Stopped) {	return true;	}	if (rebootVirtualMachine(userId, vmId) == null) {	
failed to reboot the vm 

boolean result = element.savePassword(defaultNetwork, defaultNicProfile, vmProfile);	if (!result) {	return false;	} else {	if (vmInstance.getState() == State.Stopped) {	return true;	}	if (rebootVirtualMachine(userId, vmId) == null) {	return false;	} else {	
vm is rebooted successfully as a part of password reset 

return true;	}	if (rebootVirtualMachine(userId, vmId) == null) {	return false;	} else {	return true;	}	}	} else {	if (s_logger.isDebugEnabled()) {	
reset password called for a vm that is not using a password enabled template 

Account caller = CallContext.current().getCallingAccount();	Account owner = _accountMgr.finalizeOwner(caller, cmd.getAccountName(), cmd.getDomainId(), cmd.getProjectId());	Long vmId = cmd.getId();	UserVmVO userVm = _vmDao.findById(cmd.getId());	if (userVm == null) {	throw new InvalidParameterValueException("unable to find a virtual machine by id" + cmd.getId());	}	_vmDao.loadDetails(userVm);	VMTemplateVO template = _templateDao.findByIdIncludingRemoved(userVm.getTemplateId());	if (userVm.getState() == State.Error || userVm.getState() == State.Expunging) {	
vm is not in the right state 

UserVmVO userVm = _vmDao.findById(cmd.getId());	if (userVm == null) {	throw new InvalidParameterValueException("unable to find a virtual machine by id" + cmd.getId());	}	_vmDao.loadDetails(userVm);	VMTemplateVO template = _templateDao.findByIdIncludingRemoved(userVm.getTemplateId());	if (userVm.getState() == State.Error || userVm.getState() == State.Expunging) {	throw new InvalidParameterValueException("Vm with specified id is not in the right state");	}	if (userVm.getState() != State.Stopped) {	
vm is not in the right state 

private boolean resetVMSSHKeyInternal(Long vmId, String sshPublicKey, String password) throws ResourceUnavailableException, InsufficientCapacityException {	Long userId = CallContext.current().getCallingUserId();	VMInstanceVO vmInstance = _vmDao.findById(vmId);	VMTemplateVO template = _templateDao.findByIdIncludingRemoved(vmInstance.getTemplateId());	Nic defaultNic = _networkModel.getDefaultNic(vmId);	if (defaultNic == null) {	
unable to reset ssh key for vm as the instance doesn t have default nic 

VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vmInstance);	if (template.getEnablePassword()) {	vmProfile.setParameter(VirtualMachineProfile.Param.VmPassword, password);	}	UserDataServiceProvider element = _networkMgr.getSSHKeyResetProvider(defaultNetwork);	if (element == null) {	throw new CloudRuntimeException("Can't find network element for " + Service.UserData.getName() + " provider needed for SSH Key reset");	}	boolean result = element.saveSSHKey(defaultNetwork, defaultNicProfile, vmProfile, sshPublicKey);	if (!result) {	
failed to reset ssh key for the virutal machine no need to reboot the vm 

}	UserDataServiceProvider element = _networkMgr.getSSHKeyResetProvider(defaultNetwork);	if (element == null) {	throw new CloudRuntimeException("Can't find network element for " + Service.UserData.getName() + " provider needed for SSH Key reset");	}	boolean result = element.saveSSHKey(defaultNetwork, defaultNicProfile, vmProfile, sshPublicKey);	if (!result) {	return false;	} else {	if (vmInstance.getState() == State.Stopped) {	
vm is stopped not rebooting it as a part of ssh key reset 

throw new CloudRuntimeException("Can't find network element for " + Service.UserData.getName() + " provider needed for SSH Key reset");	}	boolean result = element.saveSSHKey(defaultNetwork, defaultNicProfile, vmProfile, sshPublicKey);	if (!result) {	return false;	} else {	if (vmInstance.getState() == State.Stopped) {	return true;	}	if (rebootVirtualMachine(userId, vmId) == null) {	
failed to reboot the vm 

boolean result = element.saveSSHKey(defaultNetwork, defaultNicProfile, vmProfile, sshPublicKey);	if (!result) {	return false;	} else {	if (vmInstance.getState() == State.Stopped) {	return true;	}	if (rebootVirtualMachine(userId, vmId) == null) {	return false;	} else {	
vm is rebooted successfully as a part of ssh key reset 

public boolean stopVirtualMachine(long userId, long vmId) {	boolean status = false;	if (s_logger.isDebugEnabled()) {	s_logger.debug("Stopping vm=" + vmId);	}	UserVmVO vm = _vmDao.findById(vmId);	if (vm == null || vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	
vm is either removed or deleted 

if (vm == null || vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	}	return true;	}	_userDao.findById(userId);	try {	VirtualMachineEntity vmEntity = _orchSrvc.getVirtualMachine(vm.getUuid());	status = vmEntity.stop(Long.toString(userId));	} catch (ResourceUnavailableException e) {	
unable to stop due to 

DataCenterVO dc = _dcDao.findById(vm.getDataCenterId());	try {	if (dc.getNetworkType() == DataCenter.NetworkType.Advanced) {	List<Long> vmNetworks = _vmNetworkMapDao.getNetworks(vmId);	List<DomainRouterVO> routers = new ArrayList<DomainRouterVO>();	for(long vmNetworkId : vmNetworks) {	List<DomainRouterVO> router = _routerDao.listStopped(vmNetworkId);	routers.addAll(router);	}	for(DomainRouterVO routerToStart : routers) {	
trying to start router as part of vm reboot 

}	for(DomainRouterVO routerToStart : routers) {	_virtualNetAppliance.startRouter(routerToStart.getId(),true);	}	}	} catch (ConcurrentOperationException e) {	throw new CloudRuntimeException("Concurrent operations on starting router. " + e);	} catch (Exception ex){	throw new CloudRuntimeException("Router start failed due to" + ex);	}finally {	
rebooting vm 

_itMgr.removeVmFromNetwork(vmInstance, network, null);	} catch (ResourceUnavailableException e) {	throw new CloudRuntimeException("Error while cleaning up NIC " + e);	}	}	}	if (guestNic == null) {	throw new CloudRuntimeException("Unable to add NIC to " + vmInstance);	}	CallContext.current().putContextParameter(Nic.class, guestNic.getUuid());	
successful addition of from 

try {	nicremoved = _itMgr.removeNicFromVm(vmInstance, nic);	} catch (ResourceUnavailableException e) {	throw new CloudRuntimeException("Unable to remove " + network + " from " + vmInstance + ": " + e);	} catch (ConcurrentOperationException e) {	throw new CloudRuntimeException("Concurrent operations on removing " + network + " from " + vmInstance + ": " + e);	}	if (!nicremoved) {	throw new CloudRuntimeException("Unable to remove " + network + " from " + vmInstance);	}	
successful removal of from 

throw new CloudRuntimeException("refusing to set default " + vmInstance + " is not Running or Stopped");	}	NicProfile existing = null;	List<NicProfile> nicProfiles = _networkMgr.getNicProfiles(vmInstance);	for (NicProfile nicProfile : nicProfiles) {	if (nicProfile.isDefaultNic() && existingdefaultnet != null && nicProfile.getNetworkId() == existingdefaultnet.getId()) {	existing = nicProfile;	}	}	if (existing == null) {	
failed to update default nic no nic profile found for existing default network 

existingVO.setDefaultNic(true);	existingVO.setDeviceId(existingID);	nic = _nicDao.persist(nic);	_nicDao.persist(existingVO);	newdefault = _networkModel.getDefaultNetworkForVm(vmId);	if (newdefault.getId() == existingdefaultnet.getId()) {	throw new CloudRuntimeException("Setting a default nic failed, and we had no default nic, but we were able to set it back to the original");	}	throw new CloudRuntimeException("Failed to change default nic to " + nic + " and now we have no default");	} else if (newdefault.getId() == nic.getNetworkId()) {	
successfully set default network to for 

if (offering == null) {	throw new InvalidParameterValueException("There is no network offering with the network");	}	if (!_networkModel.listNetworkOfferingServices(offering.getId()).isEmpty() && vm.getState() != State.Stopped) {	InvalidParameterValueException ex = new InvalidParameterValueException( "VM is not Stopped, unable to update the vm nic having the specified id");	ex.addProxyObject(vm.getUuid(), "vmId");	throw ex;	}	_accountMgr.checkAccess(caller, null, true, vm);	Account ipOwner = _accountDao.findByIdIncludingRemoved(vm.getAccountId());	
calling the ip allocation 

IPAddressVO oldIP = _ipAddressDao.findByAssociatedVmId(vm.getId());	if (oldIP != null) {	oldIP.setVmIp(ipaddr);	_ipAddressDao.persist(oldIP);	}	}	if (!_networkModel.listNetworkOfferingServices(offering.getId()).isEmpty() && network.getState() == Network.State.Implemented) {	User callerUser = _accountMgr.getActiveUser(CallContext.current().getCallingUserId());	ReservationContext context = new ReservationContextImpl(null, null, callerUser, caller);	DeployDestination dest = new DeployDestination(_dcDao.findById(network.getDataCenterId()), null, null, null);	
implementing the network elements and resources as a part of vm nic ip update 

_ipAddressDao.persist(oldIP);	}	}	if (!_networkModel.listNetworkOfferingServices(offering.getId()).isEmpty() && network.getState() == Network.State.Implemented) {	User callerUser = _accountMgr.getActiveUser(CallContext.current().getCallingUserId());	ReservationContext context = new ReservationContextImpl(null, null, callerUser, caller);	DeployDestination dest = new DeployDestination(_dcDao.findById(network.getDataCenterId()), null, null, null);	try {	_networkMgr.implementNetworkElementsAndResources(dest, context, network, offering);	} catch (Exception ex) {	
failed to implement network elements and resources as a part of vm nic ip update due to 

final IPAddressVO ip = _ipAddressDao.findByIpAndSourceNetworkId(nicVO.getNetworkId(), nicVO.getIPv4Address());	if (ip != null) {	Transaction.execute(new TransactionCallbackNoReturn() {	public void doInTransactionWithoutResult(TransactionStatus status) {	_ipAddrMgr.markIpAsUnavailable(ip.getId());	_ipAddressDao.unassignIpAddress(ip.getId());	}	});	}	} catch (InsufficientAddressCapacityException e) {	
allocating ip to guest nic failed for insufficient address capacity 

public void doInTransactionWithoutResult(TransactionStatus status) {	_ipAddrMgr.markIpAsUnavailable(ip.getId());	_ipAddressDao.unassignIpAddress(ip.getId());	}	});	}	} catch (InsufficientAddressCapacityException e) {	return null;	}	} else {	
updatevmnicipcmd is not supported in this network 

if (vmIds.isEmpty()) {	return vmDiskStatsById;	}	List<String> vmNames = new ArrayList<String>();	for (Long vmId : vmIds) {	UserVmVO vm = _vmDao.findById(vmId);	vmNames.add(vm.getInstanceName());	}	Answer answer = _agentMgr.easySend(hostId, new GetVmDiskStatsCommand(vmNames, _hostDao.findById(hostId).getGuid(), hostName));	if (answer == null || !answer.getResult()) {	
unable to obtain vm disk statistics 

for (Long vmId : vmIds) {	UserVmVO vm = _vmDao.findById(vmId);	vmNames.add(vm.getInstanceName());	}	Answer answer = _agentMgr.easySend(hostId, new GetVmDiskStatsCommand(vmNames, _hostDao.findById(hostId).getGuid(), hostName));	if (answer == null || !answer.getResult()) {	return null;	} else {	HashMap<String, List<VmDiskStatsEntry>> vmDiskStatsByName = ((GetVmDiskStatsAnswer)answer).getVmDiskStatsMap();	if (vmDiskStatsByName == null) {	
unable to obtain vm disk statistics 

private boolean upgradeRunningVirtualMachine(Long vmId, Long newServiceOfferingId, Map<String, String> customParameters) throws ResourceUnavailableException, ConcurrentOperationException, ManagementServerException, VirtualMachineMigrationException {	Account caller = CallContext.current().getCallingAccount();	VMInstanceVO vmInstance = _vmInstanceDao.findById(vmId);	if (vmInstance.getHypervisorType() != HypervisorType.XenServer && vmInstance.getHypervisorType() != HypervisorType.VMware && vmInstance.getHypervisorType() != HypervisorType.Simulator) {	
scaling the vm dynamically is not supported for vms running on hypervisor 

saveCustomOfferingDetails(vmId, newServiceOffering);	}	vmInstance = _vmInstanceDao.findById(vmId);	_itMgr.reConfigureVm(vmInstance.getUuid(), currentServiceOffering, existingHostHasCapacity);	success = true;	if (currentServiceOffering.isDynamic() && !newServiceOffering.isDynamic()) {	removeCustomOfferingDetails(vmId);	}	return success;	} catch (InsufficientCapacityException e) {	
received exception while scaling 

}	vmInstance = _vmInstanceDao.findById(vmId);	_itMgr.reConfigureVm(vmInstance.getUuid(), currentServiceOffering, existingHostHasCapacity);	success = true;	if (currentServiceOffering.isDynamic() && !newServiceOffering.isDynamic()) {	removeCustomOfferingDetails(vmId);	}	return success;	} catch (InsufficientCapacityException e) {	} catch (ResourceUnavailableException e) {	
received exception while scaling 

vmInstance = _vmInstanceDao.findById(vmId);	_itMgr.reConfigureVm(vmInstance.getUuid(), currentServiceOffering, existingHostHasCapacity);	success = true;	if (currentServiceOffering.isDynamic() && !newServiceOffering.isDynamic()) {	removeCustomOfferingDetails(vmId);	}	return success;	} catch (InsufficientCapacityException e) {	} catch (ResourceUnavailableException e) {	} catch (ConcurrentOperationException e) {	
received exception while scaling 

_itMgr.reConfigureVm(vmInstance.getUuid(), currentServiceOffering, existingHostHasCapacity);	success = true;	if (currentServiceOffering.isDynamic() && !newServiceOffering.isDynamic()) {	removeCustomOfferingDetails(vmId);	}	return success;	} catch (InsufficientCapacityException e) {	} catch (ResourceUnavailableException e) {	} catch (ConcurrentOperationException e) {	} catch (Exception e) {	
received exception while scaling 

if (vmIds.isEmpty()) {	return vmStatsById;	}	List<String> vmNames = new ArrayList<String>();	for (Long vmId : vmIds) {	UserVmVO vm = _vmDao.findById(vmId);	vmNames.add(vm.getInstanceName());	}	Answer answer = _agentMgr.easySend(hostId, new GetVmStatsCommand(vmNames, _hostDao.findById(hostId).getGuid(), hostName));	if (answer == null || !answer.getResult()) {	
unable to obtain vm statistics 

for (Long vmId : vmIds) {	UserVmVO vm = _vmDao.findById(vmId);	vmNames.add(vm.getInstanceName());	}	Answer answer = _agentMgr.easySend(hostId, new GetVmStatsCommand(vmNames, _hostDao.findById(hostId).getGuid(), hostName));	if (answer == null || !answer.getResult()) {	return null;	} else {	HashMap<String, VmStatsEntry> vmStatsByName = ((GetVmStatsAnswer)answer).getVmStatsMap();	if (vmStatsByName == null) {	
unable to obtain vm statistics 

final Long userId = caller.getAccountId();	final UserVmVO vm = _vmDao.findById(vmId);	if (vm == null) {	throw new InvalidParameterValueException("unable to find a virtual machine with id " + vmId);	}	if (!_accountMgr.isAdmin(userId) && !AllowUserExpungeRecoverVm.valueIn(userId)) {	throw new PermissionDeniedException("Recovering a vm can only be done by an Admin. Or when the allow.user.expunge.recover.vm key is set.");	}	if (vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	
unable to find vm or vm is removed 

if (!_accountMgr.isAdmin(userId) && !AllowUserExpungeRecoverVm.valueIn(userId)) {	throw new PermissionDeniedException("Recovering a vm can only be done by an Admin. Or when the allow.user.expunge.recover.vm key is set.");	}	if (vm.getRemoved() != null) {	if (s_logger.isDebugEnabled()) {	}	throw new InvalidParameterValueException("Unable to find vm by id " + vmId);	}	if (vm.getState() != State.Destroyed) {	if (s_logger.isDebugEnabled()) {	
vm is not in the right state 

if (s_logger.isDebugEnabled()) {	}	throw new InvalidParameterValueException("Unable to find vm by id " + vmId);	}	if (vm.getState() != State.Destroyed) {	if (s_logger.isDebugEnabled()) {	}	throw new InvalidParameterValueException("Vm with id " + vmId + " is not in the right state");	}	if (s_logger.isDebugEnabled()) {	
recovering vm 

public void doInTransactionWithoutResult(TransactionStatus status) throws ResourceAllocationException {	Account account = _accountDao.lockRow(vm.getAccountId(), true);	if (account.getRemoved() != null) {	throw new CloudRuntimeException("Unable to recover VM as the account is deleted");	}	ServiceOfferingVO serviceOffering = _serviceOfferingDao.findById(vm.getId(), vm.getServiceOfferingId());	resourceLimitCheck(account, vm.isDisplayVm(), new Long(serviceOffering.getCpu()), new Long(serviceOffering.getRamSize()));	_haMgr.cancelDestroy(vm, vm.getHostId());	try {	if (!_itMgr.stateTransitTo(vm, VirtualMachine.Event.RecoveryRequested, null)) {	
unable to recover the vm because it is not in the correct state 

} else if (_usageAggregationRange == HOURLY_TIME) {	_dailyOrHourly = true;	} else {	_dailyOrHourly = false;	}	_itMgr.registerGuru(VirtualMachine.Type.User, this);	VirtualMachine.State.getStateMachine().registerListener(new UserVmStateListener(_usageEventDao, _networkDao, _nicDao, _offeringDao, _vmDao, this, _configDao));	String value = _configDao.getValue(Config.SetVmInternalNameUsingDisplayName.key());	_instanceNameFlag = (value == null) ? false : Boolean.parseBoolean(value);	_scaleRetry = NumbersUtil.parseInt(configs.get(Config.ScaleRetry.key()), 2);	
user vm manager is configured 

}	try {	releaseNetworkResourcesOnExpunge(vm.getId());	List<VolumeVO> rootVol = _volsDao.findByInstanceAndType(vm.getId(), Volume.Type.ROOT);	_itMgr.advanceExpunge(vm.getUuid());	if (vm.getAccountId() != Account.ACCOUNT_ID_SYSTEM && !rootVol.isEmpty()) {	_resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume);	_resourceLimitMgr.recalculateResourceCount(vm.getAccountId(), vm.getDomainId(), ResourceType.primary_storage.getOrdinal());	}	if (vm.getRemoved() == null) {	
starting cleaning up vm resources 

try {	releaseNetworkResourcesOnExpunge(vm.getId());	List<VolumeVO> rootVol = _volsDao.findByInstanceAndType(vm.getId(), Volume.Type.ROOT);	_itMgr.advanceExpunge(vm.getUuid());	if (vm.getAccountId() != Account.ACCOUNT_ID_SYSTEM && !rootVol.isEmpty()) {	_resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume);	_resourceLimitMgr.recalculateResourceCount(vm.getAccountId(), vm.getDomainId(), ResourceType.primary_storage.getOrdinal());	}	if (vm.getRemoved() == null) {	if (cleanupVmResources(vm.getId())) {	
successfully cleaned up vm resources as a part of expunge process 

releaseNetworkResourcesOnExpunge(vm.getId());	List<VolumeVO> rootVol = _volsDao.findByInstanceAndType(vm.getId(), Volume.Type.ROOT);	_itMgr.advanceExpunge(vm.getUuid());	if (vm.getAccountId() != Account.ACCOUNT_ID_SYSTEM && !rootVol.isEmpty()) {	_resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume);	_resourceLimitMgr.recalculateResourceCount(vm.getAccountId(), vm.getDomainId(), ResourceType.primary_storage.getOrdinal());	}	if (vm.getRemoved() == null) {	if (cleanupVmResources(vm.getId())) {	} else {	
failed to cleanup resources as a part of vm expunge 

}	if (vm.getRemoved() == null) {	if (cleanupVmResources(vm.getId())) {	} else {	return false;	}	_vmDao.remove(vm.getId());	}	return true;	} catch (ResourceUnavailableException e) {	
unable to expunge 

if (cleanupVmResources(vm.getId())) {	} else {	return false;	}	_vmDao.remove(vm.getId());	}	return true;	} catch (ResourceUnavailableException e) {	return false;	} catch (OperationTimedoutException e) {	
operation time out on expunging 

return false;	}	_vmDao.remove(vm.getId());	}	return true;	} catch (ResourceUnavailableException e) {	return false;	} catch (OperationTimedoutException e) {	return false;	} catch (ConcurrentOperationException e) {	
concurrent operations on expunging 

private void updateVmStateForFailedVmCreation(Long vmId, Long hostId) {	UserVmVO vm = _vmDao.findById(vmId);	if (vm != null) {	if (vm.getState().equals(State.Stopped)) {	
destroying vm as it failed to create on host with id 

GlobalLock scanLock = GlobalLock.getInternLock("vmIpFetch");	try {	if (scanLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_COOPERATION)) {	try {	for (Entry<Long, VmAndCountDetails> entry:   vmIdCountMap.entrySet()) {	long nicId = entry.getKey();	VmAndCountDetails vmIdAndCount = entry.getValue();	long vmId = vmIdAndCount.getVmId();	if (vmIdAndCount.getRetrievalCount() <= 0) {	vmIdCountMap.remove(nicId);	
vm nic count is zero removing vm nic from map 

UserVm userVm = _vmDao.findById(vmId);	VMInstanceVO vmInstance = _vmInstanceDao.findById(vmId);	NicVO nicVo = _nicDao.findById(nicId);	NetworkVO network = _networkDao.findById(nicVo.getNetworkId());	VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(userVm);	VirtualMachine vm = vmProfile.getVirtualMachine();	boolean isWindows = _guestOSCategoryDao.findById(_guestOSDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase("Windows");	_vmIpFetchThreadExecutor.execute(new VmIpAddrFetchThread(vmId, nicId, vmInstance.getInstanceName(), isWindows, vm.getHostId(), network.getCidr()));	}	} catch (Exception e) {	
caught the exception in vmipfetchtask 

protected void runInContext() {	GlobalLock scanLock = GlobalLock.getInternLock("UserVMExpunge");	try {	if (scanLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_COOPERATION)) {	try {	List<UserVmVO> vms = _vmDao.findDestroyedVms(new Date(System.currentTimeMillis() - ((long)_expungeDelay << 10)));	if (s_logger.isInfoEnabled()) {	if (vms.size() == 0) {	
found vms to expunge 

protected void runInContext() {	GlobalLock scanLock = GlobalLock.getInternLock("UserVMExpunge");	try {	if (scanLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_COOPERATION)) {	try {	List<UserVmVO> vms = _vmDao.findDestroyedVms(new Date(System.currentTimeMillis() - ((long)_expungeDelay << 10)));	if (s_logger.isInfoEnabled()) {	if (vms.size() == 0) {	} else {	
found vms to expunge 

List<UserVmVO> vms = _vmDao.findDestroyedVms(new Date(System.currentTimeMillis() - ((long)_expungeDelay << 10)));	if (s_logger.isInfoEnabled()) {	if (vms.size() == 0) {	} else {	}	}	for (UserVmVO vm : vms) {	try {	expungeVm(vm.getId());	} catch (Exception e) {	
unable to expunge 

} else {	}	}	for (UserVmVO vm : vms) {	try {	expungeVm(vm.getId());	} catch (Exception e) {	}	}	} catch (Exception e) {	
caught the following exception 

if (vm == null) {	throw new CloudRuntimeException("Unable to find virtual machine with id " + id);	}	if(instanceName != null){	VMInstanceVO vmInstance = _vmInstanceDao.findVMByInstanceName(instanceName);	if(vmInstance != null && vmInstance.getId() != id){	throw new CloudRuntimeException("Instance name : " + instanceName + " is not unique");	}	}	if (vm.getState() == State.Error || vm.getState() == State.Expunging) {	
vm is not in the right state 

_securityGroupMgr.removeInstanceFromGroups(id);	_securityGroupMgr.addInstanceToGroups(id, securityGroupIdList);	} else {	throw new InvalidParameterValueException("Virtual machine must be stopped prior to update security groups ");	}	}	}	if (hostName != null) {	checkNameForRFCCompliance(hostName);	if (vm.getHostName().equalsIgnoreCase(hostName)) {	
vm is already set with the hostname specified 

private boolean updateUserDataInternal(UserVm vm) throws ResourceUnavailableException, InsufficientCapacityException {	VMTemplateVO template = _templateDao.findByIdIncludingRemoved(vm.getTemplateId());	List<? extends Nic> nics = _nicDao.listByVmId(vm.getId());	if (nics == null || nics.isEmpty()) {	
unable to find any nics for vm 

Network network = _networkDao.findById(nic.getNetworkId());	NicProfile nicProfile = new NicProfile(nic, network, null, null, null, _networkModel.isSecurityGroupSupportedInNetwork(network), _networkModel.getNetworkTag( hyperVisorType, network));	VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm);	if (_networkModel.areServicesSupportedByNetworkOffering(network.getNetworkOfferingId(), Service.UserData)) {	UserDataServiceProvider element = _networkModel.getUserDataUpdateProvider(network);	if (element == null) {	throw new CloudRuntimeException("Can't find network element for " + Service.UserData.getName() + " provider needed for UserData update");	}	boolean result = element.saveUserData(network, nicProfile, vmProfile);	if (!result) {	
failed to update userdata for vm and nic 

protected InstanceGroupVO createVmGroup(String groupName, long accountId) {	Account account = null;	try {	account = _accountDao.acquireInLockTable(accountId);	if (account == null) {	
failed to acquire lock on account 

public InstanceGroupVO getGroupForVm(long vmId) {	try {	List<InstanceGroupVMMapVO> groupsToVmMap = _groupVMMapDao.listByInstanceId(vmId);	if (groupsToVmMap != null && groupsToVmMap.size() != 0) {	InstanceGroupVO group = _vmGroupDao.findById(groupsToVmMap.get(0).getGroupId());	return group;	} else {	return null;	}	} catch (Exception e) {	
error trying to get group for a vm 

public void removeInstanceFromInstanceGroup(long vmId) {	try {	List<InstanceGroupVMMapVO> groupVmMaps = _groupVMMapDao.listByInstanceId(vmId);	for (InstanceGroupVMMapVO groupMap : groupVmMaps) {	SearchCriteria<InstanceGroupVMMapVO> sc = _groupVMMapDao.createSearchCriteria();	sc.addAnd("instanceId", SearchCriteria.Op.EQ, groupMap.getInstanceId());	_groupVMMapDao.expunge(sc);	}	} catch (Exception e) {	
error trying to remove vm from group 

} else if (!isVmWare && _networkModel.isSecurityGroupSupportedInNetwork(defaultNetwork) && _networkModel.canAddDefaultSecurityGroup()) {	if (securityGroupIdList == null || securityGroupIdList.isEmpty()) {	if (securityGroupIdList == null) {	securityGroupIdList = new ArrayList<Long>();	}	SecurityGroup defaultGroup = _securityGroupMgr.getDefaultSecurityGroup(owner.getId());	if (defaultGroup != null) {	securityGroupIdList.add(defaultGroup.getId());	} else {	if (s_logger.isDebugEnabled()) {	
couldn t find default security group for the account so creating a new one 

if (isSecurityGroupEnabledNetworkUsed && !isVmWare && _networkModel.canAddDefaultSecurityGroup()) {	if (securityGroupIdList == null || securityGroupIdList.isEmpty()) {	if (securityGroupIdList == null) {	securityGroupIdList = new ArrayList<Long>();	}	SecurityGroup defaultGroup = _securityGroupMgr.getDefaultSecurityGroup(owner.getId());	if (defaultGroup != null) {	securityGroupIdList.add(defaultGroup.getId());	} else {	if (s_logger.isDebugEnabled()) {	
couldn t find default security group for the account so creating a new one 

throw new InvalidParameterValueException("Hypervisor " + hypervisorType + " does not support rootdisksize override");	}	VMTemplateVO templateVO = _templateDao.findById(template.getId());	if (templateVO == null) {	throw new InvalidParameterValueException("Unable to look up template by id " + template.getId());	}	if ((rootDiskSize << 30) < templateVO.getSize()) {	Long templateVOSizeGB = templateVO.getSize() / 1024 / 1024 / 1024;	throw new InvalidParameterValueException("unsupported: rootdisksize override is smaller than template size " + templateVO.getSize() + "B (" + templateVOSizeGB + "GB)");	} else {	
rootdisksize of was larger than template size of 

}	VMTemplateVO templateVO = _templateDao.findById(template.getId());	if (templateVO == null) {	throw new InvalidParameterValueException("Unable to look up template by id " + template.getId());	}	if ((rootDiskSize << 30) < templateVO.getSize()) {	Long templateVOSizeGB = templateVO.getSize() / 1024 / 1024 / 1024;	throw new InvalidParameterValueException("unsupported: rootdisksize override is smaller than template size " + templateVO.getSize() + "B (" + templateVOSizeGB + "GB)");	} else {	}	
found root disk size of 

long guestOSId = template.getGuestOSId();	GuestOSVO guestOS = _guestOSDao.findById(guestOSId);	long guestOSCategoryId = guestOS.getCategoryId();	GuestOSCategoryVO guestOSCategory = _guestOSCategoryDao.findById(guestOSCategoryId);	if (hypervisorType.equals(HypervisorType.VMware)) {	if (guestOS.getDisplayName().toLowerCase().contains("apple mac os")) {	vm.setDetail("smc.present", "TRUE");	vm.setDetail(VmDetailConstants.ROOT_DISK_CONTROLLER, "scsi");	vm.setDetail(VmDetailConstants.DATA_DISK_CONTROLLER, "scsi");	vm.setDetail("firmware", "efi");	
guestos is osx overwrite root disk controller to scsi use smc and efi 

vm.setDetail(VmDetailConstants.DATA_DISK_CONTROLLER, "osdefault");	}	}	}	}	_vmDao.persist(vm);	for (String key : customParameters.keySet()) {	vm.setDetail(key, Integer.toString(Integer.parseInt(customParameters.get(key))));	}	_vmDao.saveDetails(vm);	
allocating in the db for vm 

List<String> computeTags = new ArrayList<String>();	computeTags.add(offering.getHostTag());	List<String> rootDiskTags = new ArrayList<String>();	rootDiskTags.add(offering.getTags());	if (isIso) {	_orchSrvc.createVirtualMachineFromScratch(vm.getUuid(), Long.toString(owner.getAccountId()), vm.getIsoId().toString(), hostName, displayName, hypervisorType.name(), guestOSCategory.getName(), offering.getCpu(), offering.getSpeed(), offering.getRamSize(), diskSize, computeTags, rootDiskTags, networkNicMap, plan);	} else {	_orchSrvc.createVirtualMachine(vm.getUuid(), Long.toString(owner.getAccountId()), Long.toString(template.getId()), hostName, displayName, hypervisorType.name(), offering.getCpu(), offering.getSpeed(), offering.getRamSize(), diskSize, computeTags, rootDiskTags, networkNicMap, plan, rootDiskSize);	}	if (s_logger.isDebugEnabled()) {	
successfully allocated db entry for 

protected UserVm startVirtualMachine(DeployVMCmd cmd, Map<VirtualMachineProfile.Param, Object> additonalParams, String deploymentPlannerToUse) throws ResourceUnavailableException, InsufficientCapacityException, ConcurrentOperationException {	long vmId = cmd.getEntityId();	Long hostId = cmd.getHostId();	UserVmVO vm = _vmDao.findById(vmId);	Pair<UserVmVO, Map<VirtualMachineProfile.Param, Object>> vmParamPair = null;	try {	vmParamPair = startVirtualMachine(vmId, hostId, additonalParams, deploymentPlannerToUse);	vm = vmParamPair.first();	UserVmVO tmpVm = _vmDao.findById(vm.getId());	if (!tmpVm.getState().equals(State.Running)) {	
vm unexpectedly went to state 

op = "delete";	}	Network network = _networkDao.findById(nic.getNetworkId());	Host host = _hostDao.findById(hostId);	String networkTag = _networkModel.getNetworkTag(host.getHypervisorType(), network);	PvlanSetupCommand cmd = PvlanSetupCommand.createVmSetup(op, nic.getBroadCastUri(), networkTag, nic.getMacAddress());	Answer answer = null;	try {	answer = _agentMgr.send(hostId, cmd);	} catch (OperationTimedoutException e) {	
timed out 

Network network = _networkDao.findById(nic.getNetworkId());	Host host = _hostDao.findById(hostId);	String networkTag = _networkModel.getNetworkTag(host.getHypervisorType(), network);	PvlanSetupCommand cmd = PvlanSetupCommand.createVmSetup(op, nic.getBroadCastUri(), networkTag, nic.getMacAddress());	Answer answer = null;	try {	answer = _agentMgr.send(hostId, cmd);	} catch (OperationTimedoutException e) {	return false;	} catch (AgentUnavailableException e) {	
agent unavailable 

public boolean finalizeStart(VirtualMachineProfile profile, long hostId, Commands cmds, ReservationContext context) {	UserVmVO vm = _vmDao.findById(profile.getId());	Answer[] answersToCmds = cmds.getAnswers();	if (answersToCmds == null) {	if (s_logger.isDebugEnabled()) {	
returning from finalizestart since there are no answers to read 

ipChanged = true;	}	}	if (ipChanged) {	_dcDao.findById(vm.getDataCenterId());	UserVmVO userVm = _vmDao.findById(profile.getId());	if (_ntwkSrvcDao.canProviderSupportServiceInNetwork(guestNetwork.getId(), Service.Dhcp, Provider.ExternalDhcpServer)) {	_nicDao.update(guestNic.getId(), guestNic);	userVm.setPrivateIpAddress(guestNic.getIPv4Address());	_vmDao.update(userVm.getId(), userVm);	
detected that ip changed in the answer updated nic in the db with new ip 

UserVmVO userVm = _vmDao.findById(profile.getId());	if (_ntwkSrvcDao.canProviderSupportServiceInNetwork(guestNetwork.getId(), Service.Dhcp, Provider.ExternalDhcpServer)) {	_nicDao.update(guestNic.getId(), guestNic);	userVm.setPrivateIpAddress(guestNic.getIPv4Address());	_vmDao.update(userVm.getId(), userVm);	}	}	try {	_rulesMgr.getSystemIpAndEnableStaticNatForVm(profile.getVirtualMachine(), false);	} catch (Exception ex) {	
failed to get system ip and enable static nat for the vm due to exception 

IPAddressVO ip = _ipAddressDao.findByAssociatedVmId(profile.getId());	if (ip != null && ip.getSystem()) {	CallContext ctx = CallContext.current();	try {	long networkId = ip.getAssociatedWithNetworkId();	Network guestNetwork = _networkDao.findById(networkId);	NetworkOffering offering = _entityMgr.findById(NetworkOffering.class, guestNetwork.getNetworkOfferingId());	assert (offering.getAssociatePublicIP() == true) : "User VM should not have system owned public IP associated with it when offering configured not to associate public IP.";	_rulesMgr.disableStaticNat(ip.getId(), ctx.getCallingAccount(), ctx.getCallingUserId(), true);	} catch (Exception ex) {	
failed to disable static nat and release system ip as a part of vm stop due to exception 

if (!_accountService.isRootAdmin(account.getId())) {	throw new PermissionDeniedException( "Parameter hostid can only be specified by a Root Admin, permission denied");	}	destinationHost = _hostDao.findById(hostId);	if (destinationHost == null) {	throw new InvalidParameterValueException("Unable to find the host to deploy the VM, host id=" + hostId);	}	}	if (_securityGroupMgr.isVmSecurityGroupEnabled(vmId) && _securityGroupMgr.getSecurityGroupsForVm(vmId).isEmpty() && !_securityGroupMgr.isVmMappedToDefaultSecurityGroup(vmId) && _networkModel.canAddDefaultSecurityGroup()) {	if (s_logger.isDebugEnabled()) {	
vm is security group enabled but not mapped to default security group creating the mapping automatically 

}	SecurityGroup defaultSecurityGroup = _securityGroupMgr.getDefaultSecurityGroup(vm.getAccountId());	if (defaultSecurityGroup != null) {	List<Long> groupList = new ArrayList<Long>();	groupList.add(defaultSecurityGroup.getId());	_securityGroupMgr.addInstanceToGroups(vmId, groupList);	}	}	DataCenterDeployment plan = null;	if (destinationHost != null) {	
destination host to deploy the vm is specified specifying a deployment plan to deploy the vm 

public void collectVmDiskStatistics(final UserVmVO userVm) {	if (!userVm.getHypervisorType().equals(HypervisorType.KVM)) return;	
collect vm disk statistics from host before stopping vm 

public void collectVmDiskStatistics(final UserVmVO userVm) {	if (!userVm.getHypervisorType().equals(HypervisorType.KVM)) return;	long hostId = userVm.getHostId();	List<String> vmNames = new ArrayList<String>();	vmNames.add(userVm.getInstanceName());	final HostVO host = _hostDao.findById(hostId);	GetVmDiskStatsAnswer diskStatsAnswer = null;	try {	diskStatsAnswer = (GetVmDiskStatsAnswer)_agentMgr.easySend(hostId, new GetVmDiskStatsCommand(vmNames, host.getGuid(), host.getName()));	} catch (Exception e) {	
error while collecting disk stats for vm from host 

vmNames.add(userVm.getInstanceName());	final HostVO host = _hostDao.findById(hostId);	GetVmDiskStatsAnswer diskStatsAnswer = null;	try {	diskStatsAnswer = (GetVmDiskStatsAnswer)_agentMgr.easySend(hostId, new GetVmDiskStatsCommand(vmNames, host.getGuid(), host.getName()));	} catch (Exception e) {	return;	}	if (diskStatsAnswer != null) {	if (!diskStatsAnswer.getResult()) {	
error while collecting disk stats vm from host details 

if (vmDiskStats == null) return;	for (VmDiskStatsEntry vmDiskStat : vmDiskStats) {	SearchCriteria<VolumeVO> sc_volume = _volsDao.createSearchCriteria();	sc_volume.addAnd("path", SearchCriteria.Op.EQ, vmDiskStat.getPath());	List<VolumeVO> volumes = _volsDao.search(sc_volume, null);	if ((volumes == null) || (volumes.size() == 0)) break;	VolumeVO volume = volumes.get(0);	VmDiskStatisticsVO previousVmDiskStats = _vmDiskStatsDao.findBy(userVm.getAccountId(), userVm.getDataCenterId(), userVm.getId(), volume.getId());	VmDiskStatisticsVO vmDiskStat_lock = _vmDiskStatsDao.lock(userVm.getAccountId(), userVm.getDataCenterId(), userVm.getId(), volume.getId());	if ((vmDiskStat.getIORead() == 0) && (vmDiskStat.getIOWrite() == 0) && (vmDiskStat.getBytesRead() == 0) && (vmDiskStat.getBytesWrite() == 0)) {	
read write of io and bytes are both not updating vm disk statistics 

sc_volume.addAnd("path", SearchCriteria.Op.EQ, vmDiskStat.getPath());	List<VolumeVO> volumes = _volsDao.search(sc_volume, null);	if ((volumes == null) || (volumes.size() == 0)) break;	VolumeVO volume = volumes.get(0);	VmDiskStatisticsVO previousVmDiskStats = _vmDiskStatsDao.findBy(userVm.getAccountId(), userVm.getDataCenterId(), userVm.getId(), volume.getId());	VmDiskStatisticsVO vmDiskStat_lock = _vmDiskStatsDao.lock(userVm.getAccountId(), userVm.getDataCenterId(), userVm.getId(), volume.getId());	if ((vmDiskStat.getIORead() == 0) && (vmDiskStat.getIOWrite() == 0) && (vmDiskStat.getBytesRead() == 0) && (vmDiskStat.getBytesWrite() == 0)) {	continue;	}	if (vmDiskStat_lock == null) {	
unable to find vm disk stats from host for account with vmid and volumeid 

VolumeVO volume = volumes.get(0);	VmDiskStatisticsVO previousVmDiskStats = _vmDiskStatsDao.findBy(userVm.getAccountId(), userVm.getDataCenterId(), userVm.getId(), volume.getId());	VmDiskStatisticsVO vmDiskStat_lock = _vmDiskStatsDao.lock(userVm.getAccountId(), userVm.getDataCenterId(), userVm.getId(), volume.getId());	if ((vmDiskStat.getIORead() == 0) && (vmDiskStat.getIOWrite() == 0) && (vmDiskStat.getBytesRead() == 0) && (vmDiskStat.getBytesWrite() == 0)) {	continue;	}	if (vmDiskStat_lock == null) {	continue;	}	if (previousVmDiskStats != null && ((previousVmDiskStats.getCurrentIORead() != vmDiskStat_lock.getCurrentIORead()) || ((previousVmDiskStats.getCurrentIOWrite() != vmDiskStat_lock .getCurrentIOWrite()) || (previousVmDiskStats.getCurrentBytesRead() != vmDiskStat_lock.getCurrentBytesRead()) || (previousVmDiskStats .getCurrentBytesWrite() != vmDiskStat_lock.getCurrentBytesWrite())))) {	
vm disk stats changed from the time getvmdiskstatscommand was sent ignoring current answer host vm io read io write bytes read bytes write 

continue;	}	if (vmDiskStat_lock == null) {	continue;	}	if (previousVmDiskStats != null && ((previousVmDiskStats.getCurrentIORead() != vmDiskStat_lock.getCurrentIORead()) || ((previousVmDiskStats.getCurrentIOWrite() != vmDiskStat_lock .getCurrentIOWrite()) || (previousVmDiskStats.getCurrentBytesRead() != vmDiskStat_lock.getCurrentBytesRead()) || (previousVmDiskStats .getCurrentBytesWrite() != vmDiskStat_lock.getCurrentBytesWrite())))) {	continue;	}	if (vmDiskStat_lock.getCurrentIORead() > vmDiskStat.getIORead()) {	if (s_logger.isDebugEnabled()) {	
read of io that s less than the last one assuming something went wrong and persisting it host vm reported stored 

continue;	}	if (vmDiskStat_lock.getCurrentIORead() > vmDiskStat.getIORead()) {	if (s_logger.isDebugEnabled()) {	}	vmDiskStat_lock.setNetIORead(vmDiskStat_lock.getNetIORead() + vmDiskStat_lock.getCurrentIORead());	}	vmDiskStat_lock.setCurrentIORead(vmDiskStat.getIORead());	if (vmDiskStat_lock.getCurrentIOWrite() > vmDiskStat.getIOWrite()) {	if (s_logger.isDebugEnabled()) {	
write of io that s less than the last one assuming something went wrong and persisting it host vm reported stored 

}	vmDiskStat_lock.setCurrentIORead(vmDiskStat.getIORead());	if (vmDiskStat_lock.getCurrentIOWrite() > vmDiskStat.getIOWrite()) {	if (s_logger.isDebugEnabled()) {	}	vmDiskStat_lock.setNetIOWrite(vmDiskStat_lock.getNetIOWrite() + vmDiskStat_lock.getCurrentIOWrite());	}	vmDiskStat_lock.setCurrentIOWrite(vmDiskStat.getIOWrite());	if (vmDiskStat_lock.getCurrentBytesRead() > vmDiskStat.getBytesRead()) {	if (s_logger.isDebugEnabled()) {	
read of bytes that s less than the last one assuming something went wrong and persisting it host vm reported stored 

}	vmDiskStat_lock.setCurrentIOWrite(vmDiskStat.getIOWrite());	if (vmDiskStat_lock.getCurrentBytesRead() > vmDiskStat.getBytesRead()) {	if (s_logger.isDebugEnabled()) {	}	vmDiskStat_lock.setNetBytesRead(vmDiskStat_lock.getNetBytesRead() + vmDiskStat_lock.getCurrentBytesRead());	}	vmDiskStat_lock.setCurrentBytesRead(vmDiskStat.getBytesRead());	if (vmDiskStat_lock.getCurrentBytesWrite() > vmDiskStat.getBytesWrite()) {	if (s_logger.isDebugEnabled()) {	
write of bytes that s less than the last one assuming something went wrong and persisting it host vm reported stored 

vmDiskStat_lock.setAggIORead(vmDiskStat_lock.getNetIORead() + vmDiskStat_lock.getCurrentIORead());	vmDiskStat_lock.setAggIOWrite(vmDiskStat_lock.getNetIOWrite() + vmDiskStat_lock.getCurrentIOWrite());	vmDiskStat_lock.setAggBytesRead(vmDiskStat_lock.getNetBytesRead() + vmDiskStat_lock.getCurrentBytesRead());	vmDiskStat_lock.setAggBytesWrite(vmDiskStat_lock.getNetBytesWrite() + vmDiskStat_lock.getCurrentBytesWrite());	}	_vmDiskStatsDao.update(vmDiskStat_lock.getId(), vmDiskStat_lock);	}	}	});	} catch (Exception e) {	
unable to update vm disk statistics for vm from host 

public VirtualMachine vmStorageMigration(Long vmId, StoragePool destPool) {	Account caller = CallContext.current().getCallingAccount();	if (!_accountMgr.isRootAdmin(caller.getId())) {	if (s_logger.isDebugEnabled()) {	
caller is not a root admin permission denied to migrate the vm 

public VirtualMachine migrateVirtualMachine(Long vmId, Host destinationHost) throws ResourceUnavailableException, ConcurrentOperationException, ManagementServerException, VirtualMachineMigrationException {	Account caller = CallContext.current().getCallingAccount();	if (!_accountMgr.isRootAdmin(caller.getId())) {	if (s_logger.isDebugEnabled()) {	
caller is not a root admin permission denied to migrate the vm 

if (s_logger.isDebugEnabled()) {	}	throw new PermissionDeniedException("No permission to migrate VM, Only Root Admin can migrate a VM!");	}	VMInstanceVO vm = _vmInstanceDao.findById(vmId);	if (vm == null) {	throw new InvalidParameterValueException("Unable to find the VM by id=" + vmId);	}	if (vm.getState() != State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is not running unable to migrate the vm 

}	InvalidParameterValueException ex = new InvalidParameterValueException("VM is not Running, unable to migrate the vm with specified id");	ex.addProxyObject(vm.getUuid(), "vmId");	throw ex;	}	if(serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {	throw new InvalidParameterValueException("Live Migration of GPU enabled VM is not supported");	}	if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM) && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC) && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {	if (s_logger.isDebugEnabled()) {	
is not xenserver vmware kvm ovm hyperv cannot migrate this vm 

if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM) && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC) && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {	if (s_logger.isDebugEnabled()) {	}	throw new InvalidParameterValueException("Unsupported Hypervisor Type for VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only");	}	if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {	throw new InvalidParameterValueException("Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only");	}	if (isVMUsingLocalStorage(vm)) {	if (s_logger.isDebugEnabled()) {	
is using local storage cannot migrate this vm 

}	}	checkHostsDedication(vm, srcHostId, destinationHost.getId());	DataCenterVO dcVO = _dcDao.findById(destinationHost.getDataCenterId());	HostPodVO pod = _podDao.findById(destinationHost.getPodId());	Cluster cluster = _clusterDao.findById(destinationHost.getClusterId());	DeployDestination dest = new DeployDestination(dcVO, pod, cluster, destinationHost);	HostVO destinationHostVO = _hostDao.findById(destinationHost.getId());	if (_capacityMgr.checkIfHostReachMaxGuestLimit(destinationHostVO)) {	if (s_logger.isDebugEnabled()) {	
host name hostid already has max running vms count includes system vms cannot migrate to this host 

private boolean checkIfAllVmsCreatedInStrictMode(Long accountId, List<VMInstanceVO> allVmsOnHost) {	boolean createdByImplicitStrict = true;	if (allVmsOnHost.isEmpty()) return false;	for (VMInstanceVO vm : allVmsOnHost) {	if (!isImplicitPlannerUsedByOffering(vm.getServiceOfferingId()) || vm.getAccountId() != accountId) {	
host found to be running a vm created by a planner other than implicit or running vms of other account 

private boolean checkIfAllVmsCreatedInStrictMode(Long accountId, List<VMInstanceVO> allVmsOnHost) {	boolean createdByImplicitStrict = true;	if (allVmsOnHost.isEmpty()) return false;	for (VMInstanceVO vm : allVmsOnHost) {	if (!isImplicitPlannerUsedByOffering(vm.getServiceOfferingId()) || vm.getAccountId() != accountId) {	createdByImplicitStrict = false;	break;	} else if (isServiceOfferingUsingPlannerInPreferredMode(vm.getServiceOfferingId()) || vm.getAccountId() != accountId) {	
host found to be running a vm created by an implicit planner in preferred mode or running vms of other account 

private boolean isImplicitPlannerUsedByOffering(long offeringId) {	boolean implicitPlannerUsed = false;	ServiceOfferingVO offering = _serviceOfferingDao.findByIdIncludingRemoved(offeringId);	if (offering == null) {	
couldn t retrieve the offering by the given id 

public VirtualMachine migrateVirtualMachineWithVolume(Long vmId, Host destinationHost, Map<String, String> volumeToPool) throws ResourceUnavailableException, ConcurrentOperationException, ManagementServerException, VirtualMachineMigrationException {	Account caller = CallContext.current().getCallingAccount();	if (!_accountMgr.isRootAdmin(caller.getId())) {	if (s_logger.isDebugEnabled()) {	
caller is not a root admin permission denied to migrate the vm 

if (s_logger.isDebugEnabled()) {	}	throw new PermissionDeniedException("No permission to migrate VM, Only Root Admin can migrate a VM!");	}	VMInstanceVO vm = _vmInstanceDao.findById(vmId);	if (vm == null) {	throw new InvalidParameterValueException("Unable to find the vm by id " + vmId);	}	if (vm.getState() != State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is not running unable to migrate the vm 

public UserVm moveVMToUser(final AssignVMCmd cmd) throws ResourceAllocationException, ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {	Account caller = CallContext.current().getCallingAccount();	if (!_accountMgr.isRootAdmin(caller.getId()) && !_accountMgr.isDomainAdmin(caller.getId())) {	throw new InvalidParameterValueException("Only domain admins are allowed to assign VMs and not " + caller.getType());	}	final UserVmVO vm = _vmDao.findById(cmd.getVmId());	if (vm == null) {	throw new InvalidParameterValueException("There is no vm by that id " + cmd.getVmId());	} else if (vm.getState() == State.Running) {	if (s_logger.isDebugEnabled()) {	
vm is running unable to move the vm 

if (securityGroupId.longValue() == defaultGroup.getId()) {	defaultGroupPresent = true;	break;	}	}	if (!defaultGroupPresent) {	securityGroupIdList.add(defaultGroup.getId());	}	} else {	if (s_logger.isDebugEnabled()) {	
couldn t find default security group for the account so creating a new one 

}	}	LinkedHashMap<Network, List<? extends NicProfile>> networks = new LinkedHashMap<Network, List<? extends NicProfile>>();	NicProfile profile = new NicProfile();	profile.setDefaultNic(true);	networks.put(networkList.get(0), new ArrayList<NicProfile>(Arrays.asList(profile)));	VirtualMachine vmi = _itMgr.findById(vm.getId());	VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmi);	_networkMgr.allocate(vmProfile, networks);	_securityGroupMgr.addInstanceToGroups(vm.getId(), securityGroupIdList);	
assignvm basic zone adding security groups no to 

if (physicalNetwork == null) {	throw new InvalidParameterValueException("Unable to find physical network with id: " + physicalNetworkId + " and tag: " + requiredOfferings.get(0).getTags());	}	s_logger.debug("Creating network for account " + newAccount + " from the network offering id=" + requiredOfferings.get(0).getId() + " as a part of deployVM process");	Network newNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), newAccount.getAccountName() + "-network", newAccount.getAccountName() + "-network", null, null, null, null, newAccount, null, physicalNetwork, zone.getId(), ACLType.Account, null, null, null, null, true, null);	if (requiredOfferings.get(0).getIsPersistent()) {	DeployDestination dest = new DeployDestination(zone, null, null, null);	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + newNetwork, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, caller);	
implementing the network for account as a part of network provision for persistent networks 

s_logger.debug("Creating network for account " + newAccount + " from the network offering id=" + requiredOfferings.get(0).getId() + " as a part of deployVM process");	Network newNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), newAccount.getAccountName() + "-network", newAccount.getAccountName() + "-network", null, null, null, null, newAccount, null, physicalNetwork, zone.getId(), ACLType.Account, null, null, null, null, true, null);	if (requiredOfferings.get(0).getIsPersistent()) {	DeployDestination dest = new DeployDestination(zone, null, null, null);	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + newNetwork, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, caller);	try {	Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(newNetwork.getId(), dest, context);	if (implementedNetwork == null || implementedNetwork.first() == null) {	
failed to implement the network 

DeployDestination dest = new DeployDestination(zone, null, null, null);	UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());	Journal journal = new Journal.LogJournal("Implementing " + newNetwork, s_logger);	ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, caller);	try {	Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(newNetwork.getId(), dest, context);	if (implementedNetwork == null || implementedNetwork.first() == null) {	}	newNetwork = implementedNetwork.second();	} catch (Exception ex) {	
failed to implement network elements and resources as a part of network provision for persistent network due to 

NicProfile defaultNic = new NicProfile();	if (toggle == 0) {	defaultNic.setDefaultNic(true);	toggle++;	}	networks.put(appNet, new ArrayList<NicProfile>(Arrays.asList(defaultNic)));	}	VirtualMachine vmi = _itMgr.findById(vm.getId());	VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmi);	_networkMgr.allocate(vmProfile, networks);	
assignvm advance virtual adding networks no to 

defaultNic.setDefaultNic(true);	toggle++;	}	networks.put(appNet, new ArrayList<NicProfile>(Arrays.asList(defaultNic)));	}	VirtualMachine vmi = _itMgr.findById(vm.getId());	VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmi);	_networkMgr.allocate(vmProfile, networks);	}	}	
assignvm vm now belongs to account 

}	}	TemplateDataStoreVO tmplStore = _templateStoreDao.findByTemplateZoneReady(template.getId(), vm.getDataCenterId());	if (tmplStore == null) {	throw new InvalidParameterValueException("Cannot restore the vm as the template " + template.getUuid() + " isn't available in the zone");	}	if (needRestart) {	try {	_itMgr.stop(vm.getUuid());	} catch (ResourceUnavailableException e) {	
stop vm failed 

_resourceLimitMgr.incrementResourceCount(newVol.getAccountId(), ResourceType.primary_storage, newVol.isDisplay(), new Long(newVol.getSize()));	UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_VOLUME_CREATE, newVol.getAccountId(), newVol.getDataCenterId(), newVol.getId(), newVol.getName(), newVol.getDiskOfferingId(), template.getId(), newVol.getSize());	_usageEventDao.persist(usageEvent);	handleManagedStorage(vm, root);	_volsDao.attachVolume(newVol.getId(), vmId, newVol.getDeviceId());	_volsDao.detachVolume(root.getId());	volumeMgr.destroyVolume(root);	if (vm.getHypervisorType() == HypervisorType.VMware) {	VolumeInfo volumeInStorage = volFactory.getVolume(root.getId());	if (volumeInStorage != null) {	
expunging volume from primary data store 

_volsDao.attachVolume(newVol.getId(), vmId, newVol.getDeviceId());	_volsDao.detachVolume(root.getId());	volumeMgr.destroyVolume(root);	if (vm.getHypervisorType() == HypervisorType.VMware) {	VolumeInfo volumeInStorage = volFactory.getVolume(root.getId());	if (volumeInStorage != null) {	AsyncCallFuture<VolumeApiResult> future = _volService.expungeVolumeAsync(volFactory.getVolume(root.getId()));	try {	future.get();	} catch (Exception e) {	
failed to expunge volume 

if (vm.isUpdateParameters()) {	vm.setUpdateParameters(false);	_vmDao.loadDetails(vm);	if (vm.getDetail("password") != null) {	_vmDetailsDao.remove(_vmDetailsDao.findDetail(vm.getId(), "password").getId());	}	_vmDao.update(vm.getId(), vm);	}	}	} catch (Exception e) {	
unable to start vm 

_vmDao.update(vm.getId(), vm);	}	}	} catch (Exception e) {	CloudRuntimeException ex = new CloudRuntimeException("Unable to start VM with specified id" + e.getMessage());	ex.addProxyObject(vm.getUuid(), "vmId");	throw ex;	}	}	}	
restore vm done successfully 

cmds.addCommand(cmd);	try {	_agentMgr.send(hostId, cmds);	}	catch (Exception ex) {	throw new CloudRuntimeException(ex.getMessage());	}	if (!cmds.isSuccessful()) {	for (Answer answer : cmds.getAnswers()) {	if (!answer.getResult()) {	
failed to reset vm due to 

private void encryptAndStorePassword(UserVmVO vm, String password) {	String sshPublicKey = vm.getDetail("SSH.PublicKey");	if (sshPublicKey != null && !sshPublicKey.equals("") && password != null && !password.equals("saved_password")) {	if (!sshPublicKey.startsWith("ssh-rsa")) {	
only rsa public keys can be used to encrypt a vm password 

========================= cloudstack sample_2472 =========================

final LibvirtUtilitiesHelper libvirtUtilitiesHelper = libvirtComputingResource.getLibvirtUtilitiesHelper();	final Connect conn = libvirtUtilitiesHelper.getConnectionByVmName(dhcpName);	final List<InterfaceDef> ifaces = libvirtComputingResource.getInterfaces(conn, dhcpName);	final InterfaceDef guestNic = ifaces.get(0);	script.add(opr, "-b", guestBridgeName, "-p", primaryPvlan, "-i", isolatedPvlan, "-n", dhcpName, "-d", dhcpIp, "-m", dhcpMac, "-I", guestNic.getDevName());	} else {	script.add(opr, "-b", guestBridgeName, "-p", primaryPvlan, "-i", isolatedPvlan, "-n", dhcpName, "-d", dhcpIp, "-m", dhcpMac);	}	result = script.execute();	if (result != null) {	
failed to program pvlan for dhcp server with mac 

final List<InterfaceDef> ifaces = libvirtComputingResource.getInterfaces(conn, dhcpName);	final InterfaceDef guestNic = ifaces.get(0);	script.add(opr, "-b", guestBridgeName, "-p", primaryPvlan, "-i", isolatedPvlan, "-n", dhcpName, "-d", dhcpIp, "-m", dhcpMac, "-I", guestNic.getDevName());	} else {	script.add(opr, "-b", guestBridgeName, "-p", primaryPvlan, "-i", isolatedPvlan, "-n", dhcpName, "-d", dhcpIp, "-m", dhcpMac);	}	result = script.execute();	if (result != null) {	return new Answer(command, false, result);	} else {	
programmed pvlan for dhcp server with mac 

if (result != null) {	return new Answer(command, false, result);	} else {	}	} else if (command.getType() == PvlanSetupCommand.Type.VM) {	final String ovsPvlanVmPath = libvirtComputingResource.getOvsPvlanVmPath();	final Script script = new Script(ovsPvlanVmPath, timeout, s_logger);	script.add(opr, "-b", guestBridgeName, "-p", primaryPvlan, "-i", isolatedPvlan, "-v", vmMac);	result = script.execute();	if (result != null) {	
failed to program pvlan for vm with mac 

} else {	}	} else if (command.getType() == PvlanSetupCommand.Type.VM) {	final String ovsPvlanVmPath = libvirtComputingResource.getOvsPvlanVmPath();	final Script script = new Script(ovsPvlanVmPath, timeout, s_logger);	script.add(opr, "-b", guestBridgeName, "-p", primaryPvlan, "-i", isolatedPvlan, "-v", vmMac);	result = script.execute();	if (result != null) {	return new Answer(command, false, result);	} else {	
programmed pvlan for vm with mac 

========================= cloudstack sample_1065 =========================

public boolean expirePendingInvitations(long timeout) {	boolean success = true;	SearchCriteria<ProjectInvitationVO> sc = InactiveSearch.create();	sc.setParameters("created", new Date((DateUtil.currentGMTTime().getTime() >> 10) - timeout));	sc.setParameters("state", State.Pending);	List<ProjectInvitationVO> invitationsToExpire = listBy(sc);	for (ProjectInvitationVO invitationToExpire : invitationsToExpire) {	invitationToExpire.setState(State.Expired);	if (!update(invitationToExpire.getId(), invitationToExpire)) {	
fail to expire invitation 

public boolean isActive(long id, long timeout) {	SearchCriteria<ProjectInvitationVO> sc = InactiveSearch.create();	sc.setParameters("id", id);	if (findOneBy(sc) == null) {	
unable to find project invitation by id 

========================= cloudstack sample_4267 =========================

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	
parsing all vpn user usage events for account 

public static boolean parse(AccountVO account, Date startDate, Date endDate) {	if (s_logger.isDebugEnabled()) {	}	if ((endDate == null) || endDate.after(new Date())) {	endDate = new Date();	}	List<UsageVPNUserVO> usageVUs = s_usageVPNUserDao.getUsageRecords(account.getId(), account.getDomainId(), startDate, endDate, false, 0);	if (usageVUs.isEmpty()) {	
no vpn user usage events for this period 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long userId, String userName, long zoneId) {	if (s_logger.isDebugEnabled()) {	
total running time ms 

private static void createUsageRecord(int type, long runningTime, Date startDate, Date endDate, AccountVO account, long userId, String userName, long zoneId) {	if (s_logger.isDebugEnabled()) {	}	float usage = runningTime / 1000f / 60f / 60f;	DecimalFormat dFormat = new DecimalFormat("#.######");	String usageDisplay = dFormat.format(usage);	if (s_logger.isDebugEnabled()) {	
creating vpn user usage record usage startdate enddate for account 

========================= cloudstack sample_2649 =========================

txn.start();	MockVolumeVO volume = _mockVolumeDao.findByName(cmd.getTemplatePath());	if (volume == null) {	return new Answer(cmd, false, "cant' find volume:" + cmd.getTemplatePath());	}	String md5 = null;	try {	MessageDigest md = MessageDigest.getInstance("md5");	md5 = String.format("%032x", new BigInteger(1, md.digest(cmd.getTemplatePath().getBytes())));	} catch (NoSuchAlgorithmException e) {	
failed to gernerate 

========================= cloudstack sample_944 =========================

protected synchronized void cancel(final long seq) {	if (s_logger.isDebugEnabled()) {	
cancelling 

protected void registerListener(final long seq, final Listener listener) {	if (s_logger.isTraceEnabled()) {	
registering listener 

protected Listener unregisterListener(final long sequence) {	if (s_logger.isTraceEnabled()) {	
unregistering listener 

List<Listener> nonRecurringListenersList = new ArrayList<Listener>();	if (_waitForList.isEmpty()) {	return 0;	} else {	final Set<Map.Entry<Long, Listener>> entries = _waitForList.entrySet();	final Iterator<Map.Entry<Long, Listener>> it = entries.iterator();	while (it.hasNext()) {	final Map.Entry<Long, Listener> entry = it.next();	final Listener monitor = entry.getValue();	if (!monitor.isRecurring()) {	
listener is waiting on 

resp.logD("Processing: ", true);	final Answer[] answers = resp.getAnswers();	boolean processed = false;	try {	Listener monitor = getListener(seq);	if (monitor == null) {	if (answers[0] != null && answers[0].getResult()) {	processed = true;	}	if (s_logger.isDebugEnabled()) {	
unable to find listener 

Listener monitor = getListener(seq);	if (monitor == null) {	if (answers[0] != null && answers[0].getResult()) {	processed = true;	}	if (s_logger.isDebugEnabled()) {	}	} else {	processed = monitor.processAnswers(_id, seq, answers);	if (s_logger.isTraceEnabled()) {	
did not processed 

protected void cancelAllCommands(final Status state, final boolean cancelActive) {	if (cancelActive) {	final Set<Map.Entry<Long, Listener>> entries = _waitForList.entrySet();	final Iterator<Map.Entry<Long, Listener>> it = entries.iterator();	while (it.hasNext()) {	final Map.Entry<Long, Listener> entry = it.next();	it.remove();	final Listener monitor = entry.getValue();	if (s_logger.isDebugEnabled()) {	
sending disconnect to 

public void send(final Request req, final Listener listener) throws AgentUnavailableException {	checkAvailability(req.getCommands());	long seq = req.getSequence();	if (listener != null) {	registerListener(seq, listener);	} else if (s_logger.isDebugEnabled()) {	
routed from 

if (req.executeInSequence() && _currentSequence != null) {	req.logD("Waiting for Seq " + _currentSequence + " Scheduling: ", true);	addRequest(req);	return;	}	req.logD("Sending ", true);	send(req);	if (req.executeInSequence() && _currentSequence == null) {	_currentSequence = seq;	if (s_logger.isTraceEnabled()) {	
is current sequence 

return;	}	req.logD("Sending ", true);	send(req);	if (req.executeInSequence() && _currentSequence == null) {	_currentSequence = seq;	if (s_logger.isTraceEnabled()) {	}	}	} catch (AgentUnavailableException e) {	
unable to send due to 

send(req);	if (req.executeInSequence() && _currentSequence == null) {	_currentSequence = seq;	if (s_logger.isTraceEnabled()) {	}	}	} catch (AgentUnavailableException e) {	cancel(seq);	throw e;	} catch (Exception e) {	
unable to send due to 

public Answer[] send(final Request req, final int wait) throws AgentUnavailableException, OperationTimedoutException {	SynchronousListener sl = new SynchronousListener(null);	long seq = req.getSequence();	send(req, sl);	try {	for (int i = 0; i < 2; i++) {	Answer[] answers = null;	try {	answers = sl.waitFor(wait);	} catch (final InterruptedException e) {	
Interrupted 

if (answers != null) {	if (s_logger.isDebugEnabled()) {	new Response(req, answers).logD("Received after timeout: ", true);	}	_agentMgr.notifyAnswersToMonitors(_id, seq, answers);	return answers;	}	final Long current = _currentSequence;	if (current != null && seq != current) {	if (s_logger.isDebugEnabled()) {	
waited too long 

_agentMgr.notifyAnswersToMonitors(_id, seq, answers);	return answers;	}	final Long current = _currentSequence;	if (current != null && seq != current) {	if (s_logger.isDebugEnabled()) {	}	throw new OperationTimedoutException(req.getCommands(), _id, seq, wait, false);	}	if (s_logger.isDebugEnabled()) {	
waiting some more time because this is the current command 

if (current != null && seq != current) {	if (s_logger.isDebugEnabled()) {	}	throw new OperationTimedoutException(req.getCommands(), _id, seq, wait, false);	}	if (s_logger.isDebugEnabled()) {	}	}	throw new OperationTimedoutException(req.getCommands(), _id, seq, wait * 2, true);	} catch (OperationTimedoutException e) {	
timed out on 

}	throw new OperationTimedoutException(req.getCommands(), _id, seq, wait * 2, true);	} catch (OperationTimedoutException e) {	cancel(seq);	final Long current = _currentSequence;	if (req.executeInSequence() && (current != null && current == seq)) {	sendNext(seq);	}	throw e;	} catch (Exception e) {	
exception while waiting for answer 

protected synchronized void sendNext(final long seq) {	_currentSequence = null;	if (_requests.isEmpty()) {	if (s_logger.isDebugEnabled()) {	
no more commands found 

protected synchronized void sendNext(final long seq) {	_currentSequence = null;	if (_requests.isEmpty()) {	if (s_logger.isDebugEnabled()) {	}	return;	}	Request req = _requests.pop();	if (s_logger.isDebugEnabled()) {	
sending now is current sequence 

}	return;	}	Request req = _requests.pop();	if (s_logger.isDebugEnabled()) {	}	try {	send(req);	} catch (AgentUnavailableException e) {	if (s_logger.isDebugEnabled()) {	
unable to send the next sequence 

_seq = seq;	}	protected void runInContext() {	try {	Listener listener = unregisterListener(_seq);	if (listener != null) {	cancel(_seq);	listener.processTimeout(_id, _seq);	}	} catch (Exception e) {	
exception 

========================= cloudstack sample_4772 =========================

String volId = command.getPath();	long newSize = command.getNewSize();	try {	if (command.isManaged()) {	resizeSr(conn, command);	}	VDI vdi = citrixResourceBase.getVDIbyUuid(conn, volId);	vdi.resize(conn, newSize);	return new ResizeVolumeAnswer(command, true, "success", newSize);	} catch (Exception ex) {	
unable to resize volume 

String iScsiName = command.get_iScsiName();	try {	Set<SR> srs = SR.getByNameLabel(conn, iScsiName);	Set<PBD> allPbds = new HashSet<>();	for (SR sr : srs) {	if (!CitrixResourceBase.SRType.LVMOISCSI.equals(sr.getType(conn))) {	continue;	}	Set<PBD> pbds = sr.getPBDs(conn);	if (pbds.size() <= 0) {	
no pbds found for the following sr 

========================= cloudstack sample_1209 =========================

