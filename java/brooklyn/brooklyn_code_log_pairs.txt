public void customize(JcloudsLocation location, ComputeService computeService, TemplateOptions templateOptions) {	if (templateOptions instanceof EC2TemplateOptions) {	((EC2TemplateOptions) templateOptions).mapNewVolumeToDeviceName(ec2DeviceName, sizeInGib, deleteOnTermination);	} else {	
skipping configuration of non templateoptions 

public void customize(JcloudsLocation location, ComputeService computeService, JcloudsMachineLocation machine) {	if (computeService instanceof EC2ComputeService) {	createFilesystem((JcloudsSshMachineLocation) machine, filesystemType);	mountFilesystem((JcloudsSshMachineLocation) machine);	} else {	
skipping configuration of non computeservice 

public void customize(JcloudsLocation location, ComputeService computeService, TemplateOptions templateOptions) {	if (templateOptions instanceof EC2TemplateOptions) {	((EC2TemplateOptions) templateOptions).mapEBSSnapshotToDeviceName(ec2DeviceName, snapshotId, sizeInGib, deleteOnTermination);	} else {	
skipping configuration of non templateoptions 

public void customize(JcloudsLocation location, ComputeService computeService, JcloudsMachineLocation machine) {	if (computeService instanceof EC2ComputeService) {	mountFilesystem((JcloudsSshMachineLocation) machine);	} else {	
skipping configuration of non computeservice 

public void customize(JcloudsLocation location, ComputeService computeService, JcloudsMachineLocation machine) {	if (computeService instanceof EC2ComputeService) {	AWSEC2Api ec2Client = computeService.getContext().unwrapApi(AWSEC2Api.class);	ElasticBlockStoreApi ebsClient = ec2Client.getElasticBlockStoreApi().get();	ebsClient.attachVolumeInRegion(region, volumeId, machine.getJcloudsId(), ec2DeviceName);	mountFilesystem((JcloudsSshMachineLocation) machine);	} else {	
skipping configuration of non computeservice 

========================= brooklyn sample_2631 =========================

public void init() {	super.init();	sensors().set(SERVICE_UP, false);	ConfigToAttributes.apply(this, BROKER_SPEC);	ConfigToAttributes.apply(this, ZOOKEEPER);	ConfigToAttributes.apply(this, ZOOKEEPER_SPEC);	
creating zookeeper child for 

public void init() {	super.init();	sensors().set(SERVICE_UP, false);	ConfigToAttributes.apply(this, BROKER_SPEC);	ConfigToAttributes.apply(this, ZOOKEEPER);	ConfigToAttributes.apply(this, ZOOKEEPER_SPEC);	ZooKeeperNode zookeeper = getAttribute(ZOOKEEPER);	if (zookeeper == null) {	EntitySpec<KafkaZooKeeper> zookeeperSpec = getAttribute(ZOOKEEPER_SPEC);	if (zookeeperSpec == null) {	
creating zookeeper using default spec for 

ConfigToAttributes.apply(this, BROKER_SPEC);	ConfigToAttributes.apply(this, ZOOKEEPER);	ConfigToAttributes.apply(this, ZOOKEEPER_SPEC);	ZooKeeperNode zookeeper = getAttribute(ZOOKEEPER);	if (zookeeper == null) {	EntitySpec<KafkaZooKeeper> zookeeperSpec = getAttribute(ZOOKEEPER_SPEC);	if (zookeeperSpec == null) {	zookeeperSpec = EntitySpec.create(KafkaZooKeeper.class);	sensors().set(ZOOKEEPER_SPEC, zookeeperSpec);	} else {	
creating zookeeper using custom spec for 

if (zookeeper == null) {	EntitySpec<KafkaZooKeeper> zookeeperSpec = getAttribute(ZOOKEEPER_SPEC);	if (zookeeperSpec == null) {	zookeeperSpec = EntitySpec.create(KafkaZooKeeper.class);	sensors().set(ZOOKEEPER_SPEC, zookeeperSpec);	} else {	}	zookeeper = addChild(zookeeperSpec);	sensors().set(ZOOKEEPER, zookeeper);	}	
creating cluster child for 

if (zookeeperSpec == null) {	zookeeperSpec = EntitySpec.create(KafkaZooKeeper.class);	sensors().set(ZOOKEEPER_SPEC, zookeeperSpec);	} else {	}	zookeeper = addChild(zookeeperSpec);	sensors().set(ZOOKEEPER, zookeeper);	}	EntitySpec<KafkaBroker> brokerSpec = getAttribute(BROKER_SPEC);	if (brokerSpec == null) {	
creating default broker spec for 

========================= brooklyn sample_480 =========================

protected void assertNotUpIndicatorIncludesEventually(final Entity entity, final String expectedKey, final String expectedVal) throws Exception {	EntityAsserts.assertAttributeEventually(entity, Attributes.SERVICE_NOT_UP_INDICATORS, new Predicate<Map<?,?>>() {	public boolean apply(Map<?, ?> input) {	if (input == null) return false;	for (Map.Entry<?, ?> entry : input.entrySet()) {	boolean keyMatches = expectedKey.equals(entry.getKey());	boolean valueMatches = expectedVal.equals(entry.getValue());	if (keyMatches && valueMatches) return true;	}	
entity not up indicators 

========================= brooklyn sample_2261 =========================

public static String processTemplateFile(String templateFileName, Map<String, ? extends Object> substitutions) {	String templateContents;	try {	templateContents = Files.toString(new File(templateFileName), Charsets.UTF_8);	} catch (IOException e) {	
error loading file 

public static String processTemplateFile(String templateFileName, EntityDriver driver, Map<String, ? extends Object> extraSubstitutions) {	String templateContents;	try {	templateContents = Files.toString(new File(templateFileName), Charsets.UTF_8);	} catch (IOException e) {	
error loading file 

if ("location".equals(key)) {	if (driver!=null && driver.getLocation()!=null) return wrapAsTemplateModel( driver.getLocation() );	if (entity!=null) return wrapAsTemplateModel( Iterables.getOnlyElement( entity.getLocations() ) );	}	if ("attribute".equals(key)) {	return new EntityAttributeTemplateModel(entity);	}	if (mgmt!=null) {	Object result = mgmt.getConfig().getConfig(ConfigKeys.builder(Object.class).name(key).build());	if (result!=null) {	
deprecated access of global brooklyn properties value for should be qualified with mgmt 

if ("location".equals(key)) return wrapAsTemplateModel( location );	if ("config".equals(key)) {	return new LocationConfigTemplateModel(location);	}	if ("mgmt".equals(key)) {	return new MgmtConfigTemplateModel(mgmt);	}	if (mgmt!=null) {	Object result = mgmt.getConfig().getConfig(ConfigKeys.builder(Object.class).name(key).build());	if (result!=null) {	
deprecated access of global brooklyn properties value for should be qualified with mgmt 

StringTemplateLoader templateLoader = new StringTemplateLoader();	templateLoader.putTemplate("config", templateContents);	cfg.setTemplateLoader(templateLoader);	Template template = cfg.getTemplate("config");	ByteArrayOutputStream baos = new ByteArrayOutputStream();	Writer out = new OutputStreamWriter(baos);	template.process(substitutions, out);	out.flush();	return new String(baos.toByteArray());	} catch (Exception e) {	
error processing template propagating 

StringTemplateLoader templateLoader = new StringTemplateLoader();	templateLoader.putTemplate("config", templateContents);	cfg.setTemplateLoader(templateLoader);	Template template = cfg.getTemplate("config");	ByteArrayOutputStream baos = new ByteArrayOutputStream();	Writer out = new OutputStreamWriter(baos);	template.process(substitutions, out);	out.flush();	return new String(baos.toByteArray());	} catch (Exception e) {	
template which could not be parsed causing is 

========================= brooklyn sample_1508 =========================

private void writeToStream(ByteArrayOutputStream stream, String string) {	try {	stream.write(string.getBytes());	} catch (IOException e) {	
problem populating one of the std streams for task of entity 

public void rebootAndWait(String hostname) {	try {	if (hostname != null) {	getLocation().executePsScript(ImmutableMap.of(WinRmTool.COMPUTER_NAME, hostname), ImmutableList.of("Restart-Computer -Force"));	} else {	getLocation().executePsScript(ImmutableList.of("Restart-Computer -Force"));	}	} catch (Exception e) {	Throwable interestingCause = findExceptionCausedByWindowsRestart(e);	if (interestingCause != null) {	
restarting exception while closing winrm session from the restart command 

========================= brooklyn sample_2324 =========================

protected static void checkConnectionRepeatedly(int totalAttemptsAllowed, int numRetriesPerAttempt, Iterable<? extends Entity> nodes) throws Exception {	int attemptNum = 0;	while (true) {	try {	checkConnection(numRetriesPerAttempt, nodes);	return;	} catch (Exception e) {	attemptNum++;	if (attemptNum >= totalAttemptsAllowed) {	
cassandra not usable attempts failing 

int attemptNum = 0;	while (true) {	try {	checkConnection(numRetriesPerAttempt, nodes);	return;	} catch (Exception e) {	attemptNum++;	if (attemptNum >= totalAttemptsAllowed) {	throw e;	}	
cassandra not usable attempt of trying again after delay 

CassandraNode first = (CassandraNode) Iterables.get(nodes, 0);	String uniqueName = Identifiers.makeRandomId(8);	AstyanaxSample astyanaxFirst = AstyanaxSample.builder().node(first).columnFamilyName(uniqueName).build();	Map<String, List<String>> versions;	AstyanaxContext<Cluster> context = astyanaxFirst.newAstyanaxContextForCluster();	try {	versions = context.getEntity().describeSchemaVersions();	} finally {	context.shutdown();	}	
cassandra schema versions are 

========================= brooklyn sample_316 =========================

LOG.debug(classAndMethodName+": iteration="+i);	TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class));	entity.sensors().set(byteArrayAttrib, new BigObject(10*1000*1000));	entity.invoke(TestEntity.MY_EFFECTOR, ImmutableMap.<String,Object>of()).get();	Entities.unmanage(entity);	forceGc();	} catch (OutOfMemoryError e) {	LOG.warn(classAndMethodName+": OOME at iteration="+i);	ExecutionManager em = app.getManagementContext().getExecutionManager();	Collection<Task<?>> tasks = ((BasicExecutionManager)em).getAllTasks();	
tasks count 

========================= brooklyn sample_603 =========================

protected abstract void reconfigureService(Collection<HostGeoInfo> targetHosts);	protected void startTracker() {	synchronized (trackerLock) {	if (targetEntityProvider == null || !getManagementSupport().isDeployed()) {	
tracker for not yet active 

protected void startTracker() {	synchronized (trackerLock) {	if (targetEntityProvider == null || !getManagementSupport().isDeployed()) {	return;	}	endTracker();	ImmutableSet.Builder<Sensor<?>> sensorsToTrack = ImmutableSet.<Sensor<?>>builder().add( HOSTNAME, ADDRESS, Attributes.MAIN_URI, WebAppService.ROOT_URL);	if (Boolean.TRUE.equals(config().get(FILTER_FOR_RUNNING))) {	sensorsToTrack.add(Attributes.SERVICE_STATE_ACTUAL);	}	
initializing tracker for following 

public abstract String getHostname();	long lastUpdate = -1;	protected void refreshGroupMembership() {	try {	
geodns refreshing targets 

public abstract String getHostname();	long lastUpdate = -1;	protected void refreshGroupMembership() {	try {	if (targetEntityProvider == null) return;	if (targetEntityProvider instanceof DynamicGroup) ((DynamicGroup) targetEntityProvider).rescanEntities();	Set<Entity> pool = MutableSet.copyOf(targetEntityProvider instanceof Group ? targetEntityProvider.getMembers(): targetEntityProvider.getChildren());	
geodns refreshing targets pool now 

changed |= addTargetHost(e);	}	}	for (Entity e: previousOnes) {	changed |= removeTargetHost(e, false);	}	if (changed || (lastUpdate > 0 && Time.hasElapsedSince(lastUpdate, Duration.ONE_HOUR))) {	update();	}	} catch (Exception e) {	
problem refreshing group membership 

protected boolean addTargetHost(Entity entity) {	try {	HostGeoInfo oldGeo = targetHosts.get(entity);	String hostname = inferHostname(entity);	String ip = inferIp(entity);	String addr = (getConfig(USE_HOSTNAMES) || ip == null) ? hostname : ip;	if (addr==null) addr = ip;	if (addr == null) {	if (entitiesWithoutHostname.add(entity)) {	
geodns ignoring no hostname ip url info yet available 

String addr = (getConfig(USE_HOSTNAMES) || ip == null) ? hostname : ip;	if (addr==null) addr = ip;	if (addr == null) {	if (entitiesWithoutHostname.add(entity)) {	}	return false;	}	HostGeoInfo geo = HostGeoInfo.fromEntity(entity);	if (geo==null) geo = inferHostGeoInfo(hostname, ip);	if (Networking.isPrivateSubnet(addr) && ip!=null && !Networking.isPrivateSubnet(ip)) {	
geodns using ip for as addr resolves to private subnet 

return false;	}	HostGeoInfo geo = HostGeoInfo.fromEntity(entity);	if (geo==null) geo = inferHostGeoInfo(hostname, ip);	if (Networking.isPrivateSubnet(addr) && ip!=null && !Networking.isPrivateSubnet(ip)) {	addr = ip;	}	if (Networking.isPrivateSubnet(addr)) {	if (getConfig(INCLUDE_HOMELESS_ENTITIES)) {	if (entitiesWithoutGeoInfo.add(entity)) {	
geodns including even though is a private subnet homeless entities included 

if (geo==null) geo = inferHostGeoInfo(hostname, ip);	if (Networking.isPrivateSubnet(addr) && ip!=null && !Networking.isPrivateSubnet(ip)) {	addr = ip;	}	if (Networking.isPrivateSubnet(addr)) {	if (getConfig(INCLUDE_HOMELESS_ENTITIES)) {	if (entitiesWithoutGeoInfo.add(entity)) {	}	} else {	if (entitiesWithoutGeoInfo.add(entity)) {	
geodns ignoring private subnet detected for 

}	} else {	if (entitiesWithoutGeoInfo.add(entity)) {	}	return false;	}	}	if (geo == null) {	if (getConfig(INCLUDE_HOMELESS_ENTITIES)) {	if (entitiesWithoutGeoInfo.add(entity)) {	
geodns including even though no geography info available for 

return false;	}	}	if (geo == null) {	if (getConfig(INCLUDE_HOMELESS_ENTITIES)) {	if (entitiesWithoutGeoInfo.add(entity)) {	}	geo = HostGeoInfo.create(addr, "unknownLocation("+addr+")", 0, 0);	} else {	if (entitiesWithoutGeoInfo.add(entity)) {	
geodns ignoring no geography info available for 

}	if (oldGeo != null && geo.getAddress().equals(oldGeo.getAddress())) {	return false;	}	entitiesWithoutHostname.remove(entity);	entitiesWithoutGeoInfo.remove(entity);	log.info("GeoDns adding "+entity+" at "+geo+(oldGeo != null ? " (previously "+oldGeo+")" : ""));	targetHosts.put(entity, geo);	return true;	} catch (Exception ee) {	
geodns ignoring error analysing location 

protected boolean removeTargetHost(Entity e, boolean doUpdate) {	if (targetHosts.remove(e) != null) {	
geodns removing reference to 

protected void update() {	lastUpdate = System.currentTimeMillis();	Map<Entity, HostGeoInfo> m;	synchronized(targetHosts) { m = ImmutableMap.copyOf(targetHosts); }	
full update of target hosts 

protected void update() {	lastUpdate = System.currentTimeMillis();	Map<Entity, HostGeoInfo> m;	synchronized(targetHosts) { m = ImmutableMap.copyOf(targetHosts); }	Map<String,String> entityIdToAddress = Maps.newLinkedHashMap();	for (Map.Entry<Entity, HostGeoInfo> entry : m.entrySet()) {	entityIdToAddress.put(entry.getKey().getId(), entry.getValue().address);	}	reconfigureService(new LinkedHashSet<HostGeoInfo>(m.values()));	
targets being set as 

protected String inferHostname(Entity entity) {	String hostname = entity.getAttribute(Attributes.HOSTNAME);	URI url = entity.getAttribute(Attributes.MAIN_URI);	if (url!=null) {	try {	URL u = url.toURL();	String hostname2 = u.getHost();	if (hostname==null) {	
geodns using url to redirect to hostname attribute is preferred but not available 

protected String inferHostname(Entity entity) {	String hostname = entity.getAttribute(Attributes.HOSTNAME);	URI url = entity.getAttribute(Attributes.MAIN_URI);	if (url!=null) {	try {	URL u = url.toURL();	String hostname2 = u.getHost();	if (hostname==null) {	hostname = hostname2;	} else if (!hostname.equals(hostname2)) {	
geodns url of does not match advertised hostname using hostname not url 

URI url = entity.getAttribute(Attributes.MAIN_URI);	if (url!=null) {	try {	URL u = url.toURL();	String hostname2 = u.getHost();	if (hostname==null) {	hostname = hostname2;	} else if (!hostname.equals(hostname2)) {	}	if (u.getPort() > 0 && u.getPort() != 80 && u.getPort() != 443) {	
geodns detected non standard port in url for forwarding may not work 

try {	URL u = url.toURL();	String hostname2 = u.getHost();	if (hostname==null) {	hostname = hostname2;	} else if (!hostname.equals(hostname2)) {	}	if (u.getPort() > 0 && u.getPort() != 80 && u.getPort() != 443) {	}	} catch (MalformedURLException e) {	
invalid url for entity in 

if (hostname != null) {	try {	InetAddress addr = Networking.getInetAddressWithFixedName(hostname);	geoH = HostGeoInfo.fromIpAddress(addr);	} catch (RuntimeException e) {	Exceptions.propagateIfFatal(e);	if (ip == null) {	if (log.isTraceEnabled()) log.trace("inferHostGeoInfo failing ("+Exceptions.getFirstInteresting(e)+"): hostname="+hostname+"; ip="+ip);	throw e;	} else {	
geodns failed to infer geoinfo from hostname will try with ip 

if (log.isTraceEnabled()) log.trace("inferHostGeoInfo failing ("+Exceptions.getFirstInteresting(e)+"): hostname="+hostname+"; ip="+ip);	throw e;	} else {	}	}	}	if (ip != null) {	if (geoH == null) {	InetAddress addr = Networking.getInetAddressWithFixedName(ip);	geoH = HostGeoInfo.fromIpAddress(addr);	
geodns inferred geoinfo from ip could not infer from hostname 

} else {	}	}	}	if (ip != null) {	if (geoH == null) {	InetAddress addr = Networking.getInetAddressWithFixedName(ip);	geoH = HostGeoInfo.fromIpAddress(addr);	} else {	geoH = HostGeoInfo.create(ip, geoH.displayName, geoH.latitude, geoH.longitude);	
geodns inferred geoinfo from hostname switching it to ip 

}	}	if (ip != null) {	if (geoH == null) {	InetAddress addr = Networking.getInetAddressWithFixedName(ip);	geoH = HostGeoInfo.fromIpAddress(addr);	} else {	geoH = HostGeoInfo.create(ip, geoH.displayName, geoH.latitude, geoH.longitude);	}	} else {	
geodns inferred geoinfo from hostname 

========================= brooklyn sample_253 =========================

public final T get() {	
queuing task to resolve called by 

try {	result = exec.submit(task).get();	} catch (InterruptedException | ExecutionException e) {	Task<?> currentTask = Tasks.current();	if (currentTask != null && currentTask.isCancelled()) {	task.cancel(true);	}	throw Exceptions.propagate(e);	}	if (log.isDebugEnabled()) {	
resolved 

========================= brooklyn sample_1764 =========================

public AbstractEntityAdjunct configure(Map flags) {	boolean isFirstTime = true;	for (Iterator<Map.Entry> iter = flags.entrySet().iterator(); iter.hasNext();) {	Map.Entry entry = iter.next();	if (entry.getKey() instanceof ConfigKey) {	ConfigKey key = (ConfigKey)entry.getKey();	if (adjunctType.getConfigKeys().contains(key)) {	config().set(key, entry.getValue());	} else {	
unknown configuration key for policy ignoring 

FlagUtils.setFieldsFromFlags(this, bag, isFirstTime);	FlagUtils.setAllConfigKeys(this, bag, false);	leftoverProperties.putAll(bag.getUnusedConfig());	if (!groovyTruth(name) && leftoverProperties.containsKey("displayName")) {	Preconditions.checkArgument(leftoverProperties.get("displayName") instanceof CharSequence, "'displayName' property should be a string");	setDisplayName(leftoverProperties.remove("displayName").toString());	}	for (Object flag: leftoverProperties.keySet()) {	ConfigKey<Object> key = ConfigKeys.newConfigKey(Object.class, Strings.toString(flag));	if (config().getRaw(key).isPresent()) {	
config on conflicts with key already set ignoring 

========================= brooklyn sample_1334 =========================

public void testFeedDeDupe() throws Exception {	testReturnsSshStdoutAndInfersMachine();	entity.addFeed(feed);	
feed is 

public void testFeedDeDupe() throws Exception {	testReturnsSshStdoutAndInfersMachine();	entity.addFeed(feed);	testReturnsSshStdoutAndInfersMachine();	
feed is 

Supplier<String> cmdSupplier = new Supplier<String>() {	public String get() {	return "echo count-"+count.incrementAndGet()+"-$COUNT";	}	};	feed = SshFeed.builder() .entity(entity2) .poll(new CommandPollConfig<String>(SENSOR_STRING) .env(envSupplier) .command(cmdSupplier) .onSuccess(SshValueFunctions.stdout())) .build();	EntityAsserts.assertAttributeEventuallyNonNull(entity2, SENSOR_STRING);	final String val1 = assertDifferentOneInOutput(entity2);	EntityAsserts.assertAttributeEventually(entity2, SENSOR_STRING, Predicates.not(Predicates.equalTo(val1)));	final String val2 = assertDifferentOneInOutput(entity2);	
vals from dynamic sensors are and 

========================= brooklyn sample_984 =========================

URI uri = URI.create(Urls.mergePaths(baseUri, path));	HttpToolResponse result;	try {	result = httpCall.call(client, uri);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	throw new IllegalStateException("Invalid response invoking " + uri + ": " + e, e);	}	Tasks.addTagDynamically(BrooklynTaskTags.tagForStream("http_response", Streams.byteArray(result.getContent())));	if (!responseSuccess.apply(result.getResponseCode())) {	
invalid response invoking response code 

========================= brooklyn sample_2373 =========================

public void myEffector() {	
in myeffector for 

public Object identityEffector(Object arg) {	
in identityeffector for 

public void sleepEffector(Duration duration) {	
in sleepeffector for 

public void start(Collection<? extends Location> locs) {	ConfigToAttributes.apply(this);	
starting 

public void stop() {	
stopping 

public void restart() {	
restarting 

========================= brooklyn sample_711 =========================

public void testWithAppEnricher() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-app-with-enricher.yaml"));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-app-with-enricher");	
app started 

public void testWithEntityEnricher() throws Exception {	final Entity app = createAndStartApplication(loadYaml("test-entity-with-enricher.yaml"));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-with-enricher");	
app started 

public void testWithEntityEnricherAndParameters() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  id: parentId", "  brooklyn.parameters:", "    - name: test.fqdn", "      type: string", "      default: \"www.example.org\"", "  brooklyn.enrichers:", "    - enricherType: org.apache.brooklyn.enricher.stock.Transformer", "      brooklyn.config:", "        enricher.triggerSensors:", "          - $brooklyn:sensor(\"test.sequence\")", "        enricher.targetSensor: $brooklyn:sensor(\"main.uri\")", "        enricher.targetValue:", "          $brooklyn:formatString:", "            - \"http: "            - $brooklyn:config(\"test.fqdn\")", "            - $brooklyn:attributeWhenReady(\"test.sequence\")"));	waitForApplicationTasks(app);	
app started 

public void testWithTransformerValueFunctionUsingDsl() throws Exception {	AttributeSensor<Object> sourceSensor = Sensors.newSensor(Object.class, "mySourceSensor");	AttributeSensor<Object> targetSensor = Sensors.newSensor(Object.class, "myTargetSensor");	AttributeSensor<Object> otherSensor = Sensors.newSensor(Object.class, "myOtherSensor");	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  id: parentId", "  brooklyn.enrichers:", "    - enricherType: org.apache.brooklyn.enricher.stock.Transformer", "      brooklyn.config:", "        enricher.sourceSensor: $brooklyn:sensor(\""+sourceSensor.getName()+"\")", "        enricher.targetSensor: $brooklyn:sensor(\""+targetSensor.getName()+"\")", "        enricher.transformation:", "          $brooklyn:object:", "            type: "+Functions.class.getName(), "            factoryMethod.name: forMap", "            factoryMethod.args:", "            - \"MASTER\": $brooklyn:attributeWhenReady(\""+otherSensor.getName()+"\")", "            - \"not master\""));	waitForApplicationTasks(app);	
app started 

public void testWithTransformerEventFunctionUsingDsl() throws Exception {	AttributeSensor<Object> sourceSensor = Sensors.newSensor(Object.class, "mySourceSensor");	AttributeSensor<Object> targetSensor = Sensors.newSensor(Object.class, "myTargetSensor");	AttributeSensor<Object> otherSensor = Sensors.newSensor(Object.class, "myOtherSensor");	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  id: parentId", "  brooklyn.enrichers:", "    - enricherType: org.apache.brooklyn.enricher.stock.Transformer", "      brooklyn.config:", "        enricher.sourceSensor: $brooklyn:sensor(\""+sourceSensor.getName()+"\")", "        enricher.targetSensor: $brooklyn:sensor(\""+targetSensor.getName()+"\")", "        enricher.transformation.fromevent:", "          $brooklyn:object:", "            type: "+EnrichersYamlTest.class.getName(), "            factoryMethod.name: constantOfSingletonMapValue", "            factoryMethod.args:", "            - \"IGNORED\": $brooklyn:attributeWhenReady(\""+otherSensor.getName()+"\")"));	waitForApplicationTasks(app);	
app started 

public void testPropagatingEnricher() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-propagating-enricher.yaml"));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-propagating-enricher");	
app started 

public void testPropogateChildSensor() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  brooklyn.config:", "    test.confName: parent entity", "  id: parentId", "  brooklyn.enrichers:", "  - enricherType: org.apache.brooklyn.enricher.stock.Propagator", "    brooklyn.config:", "      enricher.producer: $brooklyn:component(\"childId\")", "      enricher.propagating.propagatingAll: true", "  brooklyn.children:", "  - serviceType: org.apache.brooklyn.core.test.entity.TestEntity", "    id: childId", "    brooklyn.config:", "      test.confName: Child Name"));	waitForApplicationTasks(app);	
app started 

========================= brooklyn sample_1676 =========================

public void testReloadBrooklynPropertiesDeploy() {	brooklynMgmt.reloadBrooklynProperties();	CampPlatform reloadedPlatform = brooklynMgmt.getScratchpad().get(BrooklynCampConstants.CAMP_PLATFORM);	Assert.assertNotNull(reloadedPlatform);	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("test-entity-basic-template.yaml"));	AssemblyTemplate template = reloadedPlatform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = template.getInstantiator().newInstance().instantiate(template, reloadedPlatform);	
test created 

public void testReloadBrooklynPropertiesDeploy() {	brooklynMgmt.reloadBrooklynProperties();	CampPlatform reloadedPlatform = brooklynMgmt.getScratchpad().get(BrooklynCampConstants.CAMP_PLATFORM);	Assert.assertNotNull(reloadedPlatform);	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("test-entity-basic-template.yaml"));	AssemblyTemplate template = reloadedPlatform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = template.getInstantiator().newInstance().instantiate(template, reloadedPlatform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	
app 

CampPlatform reloadedPlatform = brooklynMgmt.getScratchpad().get(BrooklynCampConstants.CAMP_PLATFORM);	Assert.assertNotNull(reloadedPlatform);	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("test-entity-basic-template.yaml"));	AssemblyTemplate template = reloadedPlatform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = template.getInstantiator().newInstance().instantiate(template, reloadedPlatform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	Assert.assertEquals(app.getDisplayName(), "test-entity-basic-template");	EntityAsserts.assertAttributeEqualsEventually(app, Startable.SERVICE_UP, true);	} catch (Exception e) {	
unable to instantiate rethrowing 

========================= brooklyn sample_1699 =========================

private synchronized void checkHealth() {	CalculatedStatus status = calculateStatus();	boolean healthy = status.isHealthy();	long now = System.currentTimeMillis();	if (healthy) {	stateLastGood.set(now);	if (lastPublished == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	
check for now recovering 

CalculatedStatus status = calculateStatus();	boolean healthy = status.isHealthy();	long now = System.currentTimeMillis();	if (healthy) {	stateLastGood.set(now);	if (lastPublished == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	currentRecoveryStartTime = now;	schedulePublish();	} else {	
check for continuing recovering 

if (healthy) {	stateLastGood.set(now);	if (lastPublished == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	currentRecoveryStartTime = now;	schedulePublish();	} else {	}	} else {	if (currentFailureStartTime != null) {	
check for now healthy 

if (lastPublished == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	currentRecoveryStartTime = now;	schedulePublish();	} else {	}	} else {	if (currentFailureStartTime != null) {	currentFailureStartTime = null;	} else {	
check for still healthy 

} else {	if (currentFailureStartTime != null) {	currentFailureStartTime = null;	} else {	}	}	} else {	stateLastFail.set(now);	if (lastPublished != LastPublished.FAILED) {	if (currentFailureStartTime == null) {	
check for now failing 

} else {	}	}	} else {	stateLastFail.set(now);	if (lastPublished != LastPublished.FAILED) {	if (currentFailureStartTime == null) {	currentFailureStartTime = now;	schedulePublish();	} else {	
check for continuing failing 

} else {	stateLastFail.set(now);	if (lastPublished != LastPublished.FAILED) {	if (currentFailureStartTime == null) {	currentFailureStartTime = now;	schedulePublish();	} else {	}	} else {	if (currentRecoveryStartTime != null) {	
check for now failing 

if (lastPublished != LastPublished.FAILED) {	if (currentFailureStartTime == null) {	currentFailureStartTime = now;	schedulePublish();	} else {	}	} else {	if (currentRecoveryStartTime != null) {	currentRecoveryStartTime = null;	} else {	
check for still failed 

protected void schedulePublish(long delay) {	if (isRunning() && executorQueued.compareAndSet(false, true)) {	long now = System.currentTimeMillis();	delay = Math.max(0, Math.max(delay, (executorTime + MIN_PERIOD_BETWEEN_EXECS_MILLIS) - now));	
scheduling publish in ms 

Long lastDownTime = stateLastFail.get();	long serviceFailedStabilizationDelay = getFailedStabilizationDelay().toMilliseconds();	long serviceRecoveredStabilizationDelay = getRecoveredStabilizationDelay().toMilliseconds();	long now = System.currentTimeMillis();	if (healthy) {	if (lastPublished == LastPublished.FAILED) {	long currentRecoveryPeriod = getTimeDiff(now, currentRecoveryStartTime);	long sinceLastDownPeriod = getTimeDiff(now, lastDownTime);	if (currentRecoveryPeriod > serviceRecoveredStabilizationDelay && sinceLastDownPeriod > serviceRecoveredStabilizationDelay) {	String description = getDescription(calculatedStatus);	
check for publishing recovered 

long nextAttemptTime = Math.max(serviceRecoveredStabilizationDelay - currentRecoveryPeriod, serviceRecoveredStabilizationDelay - sinceLastDownPeriod);	schedulePublish(nextAttemptTime);	}	}	} else {	if (lastPublished != LastPublished.FAILED) {	long currentFailurePeriod = getTimeDiff(now, currentFailureStartTime);	long sinceLastUpPeriod = getTimeDiff(now, lastUpTime);	if (currentFailurePeriod > serviceFailedStabilizationDelay && sinceLastUpPeriod > serviceFailedStabilizationDelay) {	String description = getDescription(calculatedStatus);	
connectivity check for publishing failed 

========================= brooklyn sample_3061 =========================

StringTemplateLoader templateLoader = new StringTemplateLoader();	templateLoader.putTemplate("config", basevalue);	cfg.setTemplateLoader(templateLoader);	Template template = cfg.getTemplate("config");	ByteArrayOutputStream baos = new ByteArrayOutputStream();	Writer out = new OutputStreamWriter(baos);	template.process(substitutions, out);	out.flush();	return new String(baos.toByteArray());	} catch (IOException e) {	
error processing template 

========================= brooklyn sample_1230 =========================

if (closed.get()) {	throw new IllegalStateException("Pool closed for "+this);	}	if (pool.size() > 0) {	existing = pool.removeLast();	}	}	if (existing != null) {	if (viabilityChecker.apply(existing)) {	currentLeasedCount.incrementAndGet();	
reusing existing pool entry 

if (pool.size() > 0) {	existing = pool.removeLast();	}	}	if (existing != null) {	if (viabilityChecker.apply(existing)) {	currentLeasedCount.incrementAndGet();	return new BasicLease(existing);	} else {	totalClosedCount.incrementAndGet();	
not reusing entry as no longer viable discarding and trying again 

return new BasicLease(existing);	} else {	totalClosedCount.incrementAndGet();	closer.apply(existing);	}	}	} while (existing != null);	T result = supplier.get();	totalCreatedCount.incrementAndGet();	currentLeasedCount.incrementAndGet();	
acquired and returning new entry 

public <R> R exec(Function<? super T,R> receiver) {	Lease<T> lease = leaseObject();	try {	
executing with leasee 

public void close() throws IOException {	synchronized (pool) {	
closing with resources 

private void returnLeasee(T val) {	currentLeasedCount.decrementAndGet();	synchronized (pool) {	if (closed.get()) {	totalClosedCount.incrementAndGet();	
closing returned leasee because pool closed 

private void returnLeasee(T val) {	currentLeasedCount.decrementAndGet();	synchronized (pool) {	if (closed.get()) {	totalClosedCount.incrementAndGet();	closer.apply(val);	} else {	
adding back into pool 

========================= brooklyn sample_2109 =========================

public void testGenerateGroupIdInVcloud() {	ConfigBag cfg = new ConfigBag() .configure(JcloudsLocationConfig.CLOUD_PROVIDER, "vcloud") .configure(JcloudsLocationConfig.CALLER_CONTEXT, "!mycontext!");	String result = new JcloudsMachineNamer().generateNewGroupId(cfg);	
test mycontext vcloud group id gives 

========================= brooklyn sample_2559 =========================

protected void connectSensors() {	super.connectSensors();	ConfigToAttributes.apply(this);	HostAndPort accessible = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, getHttpPort());	String nodeJsUrl = String.format("http: if (isHttpMonitoringEnabled()) {	
connecting to 

========================= brooklyn sample_212 =========================

public MachineLocation call() throws Exception {	entity().getConfig(BrooklynConfigKeys.PROVISION_LATCH);	final Map<String, Object> flags = obtainProvisioningFlags(location);	
starting obtaining a new location instance in with ports inboundPorts 

try {	machine = Tasks.withBlockingDetails("Provisioning machine in " + location, new ObtainLocationTask(location, flags));	entity().sensors().set(INTERNAL_PROVISIONED_MACHINE, machine);	} finally {	entity().sensors().remove(AttributesInternal.INTERNAL_PROVISIONING_TASK_STATE);	}	if (machine == null) {	throw new NoMachinesAvailableException("Failed to obtain machine in " + location.toString());	}	if (log.isDebugEnabled()) {	
while starting obtained new location instance details 

public void run() {	
starting on machine 

public void run() {	Collection<Location> oldLocs = entity().getLocations();	if (!oldLocs.isEmpty()) {	List<MachineLocation> oldSshLocs = ImmutableList.copyOf(Iterables.filter(oldLocs, MachineLocation.class));	if (!oldSshLocs.isEmpty()) {	
entity had machine locations when starting at checking if they are compatible 

Collection<Location> oldLocs = entity().getLocations();	if (!oldLocs.isEmpty()) {	List<MachineLocation> oldSshLocs = ImmutableList.copyOf(Iterables.filter(oldLocs, MachineLocation.class));	if (!oldSshLocs.isEmpty()) {	for (MachineLocation oldLoc : oldSshLocs) {	if (!"localhost".equals(machine.getConfig(AbstractLocation.ORIGINAL_SPEC))) {	checkLocationParametersCompatible(machine, oldLoc, "hostname", oldLoc.getAddress().getHostName(), machine.getAddress().getHostName());	checkLocationParametersCompatible(machine, oldLoc, "address", oldLoc.getAddress().getHostAddress(), machine.getAddress().getHostAddress());	}	}	
entity old machine locations were compatible removing them to start at 

if (machine instanceof SshMachineLocation) {	SshMachineLocation sshMachine = (SshMachineLocation) machine;	UserAndHostAndPort sshAddress = UserAndHostAndPort.fromParts( sshMachine.getUser(), sshMachine.getAddress().getHostName(), sshMachine.getPort());	entity().sensors().set(Attributes.SSH_ADDRESS, sshAddress);	}	if (Boolean.TRUE.equals(entity().getConfig(SoftwareProcess.OPEN_IPTABLES))) {	if (machine instanceof SshMachineLocation) {	Iterable<Integer> inboundPorts = (Iterable<Integer>) machine.config().get(CloudLocationConfig.INBOUND_PORTS);	machineInitTasks.openIptablesAsync(inboundPorts, (SshMachineLocation)machine);	} else {	
ignoring flag open iptables on non ssh location 

if (machine instanceof SshMachineLocation) {	Iterable<Integer> inboundPorts = (Iterable<Integer>) machine.config().get(CloudLocationConfig.INBOUND_PORTS);	machineInitTasks.openIptablesAsync(inboundPorts, (SshMachineLocation)machine);	} else {	}	}	if (Boolean.TRUE.equals(entity().getConfig(SoftwareProcess.STOP_IPTABLES))) {	if (machine instanceof SshMachineLocation) {	machineInitTasks.stopIptablesAsync((SshMachineLocation)machine);	} else {	
ignoring flag stop iptables on non ssh location 

if (Boolean.TRUE.equals(entity().getConfig(SoftwareProcess.STOP_IPTABLES))) {	if (machine instanceof SshMachineLocation) {	machineInitTasks.stopIptablesAsync((SshMachineLocation)machine);	} else {	}	}	if (Boolean.TRUE.equals(entity().getConfig(SoftwareProcess.DONT_REQUIRE_TTY_FOR_SUDO))) {	if (machine instanceof SshMachineLocation) {	machineInitTasks.dontRequireTtyForSudoAsync((SshMachineLocation)machine);	} else {	
ignoring flag dont require tty for sudo on non ssh location 

if (base!=null && Boolean.TRUE.equals(entity.getConfig(ON_BOX_BASE_DIR_RESOLVED))) return base;	if (base==null) base = entity.getManagementContext().getConfig().getConfig(BrooklynConfigKeys.ONBOX_BASE_DIR);	if (base==null) base = entity.getConfig(BrooklynConfigKeys.BROOKLYN_DATA_DIR);	if (base==null) base = machine.getConfig(BrooklynConfigKeys.BROOKLYN_DATA_DIR);	if (base==null) base = entity.getManagementContext().getConfig().getConfig(BrooklynConfigKeys.BROOKLYN_DATA_DIR);	if (base==null) base = "~/brooklyn-managed-processes";	if (base.equals("~")) base=".";	if (base.startsWith("~/")) base = "."+base.substring(1);	String resolvedBase = null;	if (entity.getConfig(BrooklynConfigKeys.SKIP_ON_BOX_BASE_DIR_RESOLUTION) || machine.getConfig(BrooklynConfigKeys.SKIP_ON_BOX_BASE_DIR_RESOLUTION)) {	
skipping on box base dir resolution for at 

resolvedBase = Os.tidyPath(base);	} else if (machine instanceof SshMachineLocation) {	SshMachineLocation ms = (SshMachineLocation)machine;	ProcessTaskWrapper<Integer> baseTask = SshEffectorTasks.ssh( BashCommands.alternatives("mkdir -p \"${BASE_DIR}\"", BashCommands.chain( BashCommands.sudo("mkdir -p \"${BASE_DIR}\""), BashCommands.sudo("chown "+ms.getUser()+" \"${BASE_DIR}\""))), "cd ~", "cd ${BASE_DIR}", "echo BASE_DIR_RESULT':'`pwd`:BASE_DIR_RESULT") .environmentVariable("BASE_DIR", base) .requiringExitCodeZero() .summary("initializing on-box base dir "+base).newTask();	DynamicTasks.queueIfPossible(baseTask).orSubmitAsync(entity);	resolvedBase = Strings.getFragmentBetween(baseTask.block().getStdout(), "BASE_DIR_RESULT:", ":BASE_DIR_RESULT");	}	if (resolvedBase==null) {	if (!Os.isAbsolutish(base)) base = "~/"+base;	resolvedBase = Os.tidyPath(base);	
could not resolve on box directory for at using though this may not be accurate at the target and may fail shortly 

protected void doStop(ConfigBag parameters, Callable<StopMachineDetails<Integer>> stopTask) {	preStopConfirmCustom();	
stopping in 

protected void doStop(ConfigBag parameters, Callable<StopMachineDetails<Integer>> stopTask) {	preStopConfirmCustom();	StopMode stopMachineMode = getStopMachineMode(parameters);	StopMode stopProcessMode = parameters.get(StopSoftwareParameters.STOP_PROCESS_MODE);	DynamicTasks.queue("pre-stop", new PreStopCustomTask());	Maybe<MachineLocation> machine = Machines.findUniqueMachineLocation(entity().getLocations());	ProvisioningTaskState provisioningState = entity().sensors().get(AttributesInternal.INTERNAL_PROVISIONING_TASK_STATE);	if (machine.isAbsent() && provisioningState == ProvisioningTaskState.RUNNING) {	Duration maxWait = entity().config().get(STOP_WAIT_PROVISIONING_TIMEOUT);	
when stopping waiting for up to for the machine to finish provisioning before terminating it 

Maybe<MachineLocation> machine = Machines.findUniqueMachineLocation(entity().getLocations());	ProvisioningTaskState provisioningState = entity().sensors().get(AttributesInternal.INTERNAL_PROVISIONING_TASK_STATE);	if (machine.isAbsent() && provisioningState == ProvisioningTaskState.RUNNING) {	Duration maxWait = entity().config().get(STOP_WAIT_PROVISIONING_TIMEOUT);	boolean success = Repeater.create("Wait for a machine to appear") .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	ProvisioningTaskState state = entity().sensors().get(AttributesInternal.INTERNAL_PROVISIONING_TASK_STATE);	return (state != ProvisioningTaskState.RUNNING);	}}) .backoffTo(Duration.FIVE_SECONDS) .limitTimeTo(maxWait) .run();	if (!success) {	
when stopping timed out after waiting for the machine to finish provisioning machine may we left running 

stoppingProcess.get();	}	}	} catch (Throwable e) {	ServiceStateLogic.setExpectedState(entity(), Lifecycle.ON_FIRE);	Exceptions.propagate(e);	}	entity().sensors().set(SoftwareProcess.SERVICE_UP, false);	ServiceStateLogic.setExpectedState(entity(), Lifecycle.STOPPED);	DynamicTasks.queue("post-stop", new PostStopCustomTask());	
stopped software process entity 

public String call() {	if (entity().getAttribute(SoftwareProcess.SERVICE_STATE_ACTUAL) == Lifecycle.STOPPED) {	
skipping stop of entity when already stopped 

protected abstract String stopProcessesAtMachine();	protected StopMachineDetails<Integer> stopAnyProvisionedMachines() {	MachineProvisioningLocation<MachineLocation> provisioner = entity().getAttribute(SoftwareProcess.PROVISIONING_LOCATION);	if (Iterables.isEmpty(entity().getLocations())) {	
no machine decommissioning necessary for no locations 

protected abstract String stopProcessesAtMachine();	protected StopMachineDetails<Integer> stopAnyProvisionedMachines() {	MachineProvisioningLocation<MachineLocation> provisioner = entity().getAttribute(SoftwareProcess.PROVISIONING_LOCATION);	if (Iterables.isEmpty(entity().getLocations())) {	return new StopMachineDetails<Integer>("No machine decommissioning necessary - no locations", 0);	}	if (provisioner==null) {	
no machine decommissioning necessary for did not provision 

protected StopMachineDetails<Integer> stopAnyProvisionedMachines() {	MachineProvisioningLocation<MachineLocation> provisioner = entity().getAttribute(SoftwareProcess.PROVISIONING_LOCATION);	if (Iterables.isEmpty(entity().getLocations())) {	return new StopMachineDetails<Integer>("No machine decommissioning necessary - no locations", 0);	}	if (provisioner==null) {	return new StopMachineDetails<Integer>("No machine decommissioning necessary - did not provision", 0);	}	Location machine = getLocation(null);	if (!(machine instanceof MachineLocation)) {	
no decommissioning necessary for not a machine location 

protected StopMachineDetails<Integer> suspendAnyProvisionedMachines() {	MachineProvisioningLocation<MachineLocation> provisioner = entity().getAttribute(SoftwareProcess.PROVISIONING_LOCATION);	if (Iterables.isEmpty(entity().getLocations())) {	
no machine decommissioning necessary for no locations 

protected StopMachineDetails<Integer> suspendAnyProvisionedMachines() {	MachineProvisioningLocation<MachineLocation> provisioner = entity().getAttribute(SoftwareProcess.PROVISIONING_LOCATION);	if (Iterables.isEmpty(entity().getLocations())) {	return new StopMachineDetails<>("No machine suspend necessary - no locations", 0);	}	if (provisioner == null) {	
no machine decommissioning necessary for did not provision 

protected StopMachineDetails<Integer> suspendAnyProvisionedMachines() {	MachineProvisioningLocation<MachineLocation> provisioner = entity().getAttribute(SoftwareProcess.PROVISIONING_LOCATION);	if (Iterables.isEmpty(entity().getLocations())) {	return new StopMachineDetails<>("No machine suspend necessary - no locations", 0);	}	if (provisioner == null) {	return new StopMachineDetails<>("No machine suspend necessary - did not provision", 0);	}	Location machine = getLocation(null);	if (!(machine instanceof MachineLocation)) {	
no decommissioning necessary for not a machine location 

return new StopMachineDetails<>("No machine suspend necessary - no locations", 0);	}	if (provisioner == null) {	return new StopMachineDetails<>("No machine suspend necessary - did not provision", 0);	}	Location machine = getLocation(null);	if (!(machine instanceof MachineLocation)) {	return new StopMachineDetails<>("No machine suspend necessary - not a machine (" + machine + ")", 0);	}	if (!(provisioner instanceof SuspendsMachines)) {	
location provisioner cannot suspend machines 

private static ReleaseableLatch waitForLatch(EntityInternal entity, ConfigKey<Boolean> configKey) {	Maybe<?> rawValue = entity.config().getRaw(configKey);	if (rawValue.isAbsent()) {	return ReleaseableLatch.NOP;	} else {	ValueResolverIterator<Boolean> iter = resolveLatchIterator(entity, rawValue.get(), configKey);	Maybe<ReleaseableLatch> releasableLatchMaybe = iter.next(ReleaseableLatch.class);	if (releasableLatchMaybe.isPresent()) {	ReleaseableLatch latch = releasableLatchMaybe.get();	
finished waiting for value waiting to acquire the latch 

ValueResolverIterator<Boolean> iter = resolveLatchIterator(entity, rawValue.get(), configKey);	Maybe<ReleaseableLatch> releasableLatchMaybe = iter.next(ReleaseableLatch.class);	if (releasableLatchMaybe.isPresent()) {	ReleaseableLatch latch = releasableLatchMaybe.get();	Tasks.setBlockingDetails("Acquiring " + configKey + " " + latch);	try {	latch.acquire(entity);	} finally {	Tasks.resetBlockingDetails();	}	
acquired latch value continuing 

========================= brooklyn sample_2332 =========================

public Void call() throws Exception {	try {	
calling command 

public Void call() throws Exception {	try {	command.call();	return null;	} catch (Throwable t) {	
error executing command 

========================= brooklyn sample_2762 =========================

if (ld==null) ld = mgmt.getLocationRegistry().getDefinedLocationById(lp.getId());	if (ld!=null) {	if (spec==null) spec = ld.getSpec();	specId = ld.getId();	}	}	lp = lp.getParent();	}	if (specId==null && spec!=null) {	if (LEGACY_SPEC_WARNING==false) {	
legacy spec lookup required for rest summary of 

========================= brooklyn sample_2918 =========================

private AdjunctType(Class<? extends EntityAdjunct> clazz, AbstractEntityAdjunct adjunct) {	name = clazz.getCanonicalName();	configKeys = Collections.unmodifiableMap(findConfigKeys(clazz, null));	configKeysSet = ImmutableSet.copyOf(this.configKeys.values());	
policy config keys 

Field definitiveField = alternativeField != null ? inferSubbestField(alternativeField, f) : f;	boolean skip = false;	if (definitiveField != f) {	if (alternativeField.get(optionalInstance) == f.get(optionalInstance)) skip = true;	}	if (skip) {	} else if (definitiveField == f) {	result.put(k.getName(), k);	configFields.put(k.getName(), f);	} else if (definitiveField != null) {	
multiple definitions for config key on preferring that in sub class to 

if (definitiveField != f) {	if (alternativeField.get(optionalInstance) == f.get(optionalInstance)) skip = true;	}	if (skip) {	} else if (definitiveField == f) {	result.put(k.getName(), k);	configFields.put(k.getName(), f);	} else if (definitiveField != null) {	k.getName(), optionalInstance!=null ? optionalInstance : clazz, alternativeField, f});	} else if (definitiveField == null) {	
multiple definitions for config key on preferring to 

========================= brooklyn sample_1322 =========================

public static synchronized DatabaseReader getDatabaseReader() {	if (databaseReader!=null) return databaseReader;	try {	File f = new File(MAXMIND_DB_PATH);	databaseReader = new DatabaseReader.Builder(f).build();	} catch (IOException e) {	lookupFailed = true;	
maxmind geo lookup unavailable either download and unpack the latest binary from into or specify a different hostgeolookup implementation with the key error trying to read 

public HostGeoInfo getHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	if (lookupFailed) return null;	DatabaseReader ll = getDatabaseReader();	if (ll==null) return null;	InetAddress extAddress = address;	if (Networking.isPrivateSubnet(extAddress)) extAddress = InetAddress.getByName(LocalhostExternalIpLoader.getLocalhostIpQuicklyOrDefault());	try {	CityResponse l = ll.city(extAddress);	if (l==null) {	
geo info failed to find location for address using 

}	}	if (l.getCountry()!=null) {	if (name.length()==0) {	name.append(l.getCountry().getName());	} else {	name.append(" ("); name.append(l.getCountry().getIsoCode()); name.append(")");	}	}	HostGeoInfo geo = new HostGeoInfo(address.getHostName(), name.toString(), l.getLocation().getLatitude(), l.getLocation().getLongitude());	
geo info lookup maxmind db for returned 

if (l.getCountry()!=null) {	if (name.length()==0) {	name.append(l.getCountry().getName());	} else {	name.append(" ("); name.append(l.getCountry().getIsoCode()); name.append(")");	}	}	HostGeoInfo geo = new HostGeoInfo(address.getHostName(), name.toString(), l.getLocation().getLatitude(), l.getLocation().getLongitude());	return geo;	} catch (Exception e) {	
geo info lookup failed 

========================= brooklyn sample_1288 =========================

public void testAppServerPct() {	CampPlatform p = MockWebPlatform.newPlatform();	DtoFactory f = new DtoFactory(p, "");	ApplicationComponentTemplate t = MockWebPlatform.WAR;	ApplicationComponentTemplateDto dto = f.adapt(t);	
war pct serialized as 

========================= brooklyn sample_1772 =========================

protected void doRun() throws Exception {	Preconditions.checkState(rebindManager.getRebindMode()==ManagementNodeState.MASTER, "Partial rebind only supported in master mode, not "+rebindManager.getRebindMode());	Preconditions.checkState(readOnlyRebindCount.get()==Integer.MIN_VALUE, "Rebind count should be MIN when running in master mode");	Preconditions.checkNotNull(objectsToRebindInitial, "Objects to rebind must be set");	
partial rebind rebinding from 

========================= brooklyn sample_1135 =========================

public static int terminateAll() {	int closed=0,dangling=0;	for (LocalManagementContext context : getInstances()) {	try {	context.terminate();	closed++;	}catch (Throwable t) {	Exceptions.propagateIfFatal(t);	
failed to terminate management context 

if (brooklynAdditionalProperties != null) configMap.addFromMap(brooklynAdditionalProperties);	BrooklynFeatureEnablement.init(configMap);	this.locationManager = new LocalLocationManager(this);	this.accessManager = new LocalAccessManager();	this.usageManager = new LocalUsageManager(this);	if (configMap.getConfig(OsgiManager.USE_OSGI)) {	this.osgiManager = new OsgiManager(this);	osgiManager.start();	}	INSTANCES.add(this);	
created management context 

public void setManagementPlaneId(String newPlaneId) {	if (managementPlaneId != null && !managementPlaneId.equals(newPlaneId)) {	
management plane id at changed from to can happen on concurrent startup of multiple nodes 

public void setManagementPlaneId(String newPlaneId) {	if (managementPlaneId != null && !managementPlaneId.equals(newPlaneId)) {	
management plane id at changed from to can happen on concurrent startup of multiple nodes stack trace for setmanagementplaneid 

public void terminate() {	if (terminated.getAndSet(true)) {	
already terminated management context 

public void terminate() {	if (terminated.getAndSet(true)) {	return;	}	
terminating management context 

}	INSTANCES.remove(this);	super.terminate();	if (osgiManager!=null) {	osgiManager.stop();	osgiManager = null;	}	if (usageManager != null) usageManager.terminate();	if (execution != null) execution.shutdownNow();	if (gc != null) gc.shutdownNow();	
terminated management context 

protected <T> Task<T> runAtEntity(final Entity entity, final Effector<T> eff, @SuppressWarnings("rawtypes") final Map parameters) {	manageIfNecessary(entity, eff);	ExecutionContext ec = BasicExecutionContext.getCurrentExecutionContext();	if (ec == null) {	
top level effector invocation on 

public void reloadBrooklynProperties() {	
reloading brooklyn properties from 

public void reloadBrooklynProperties() {	
when reloading mgmt context properties are fixed so reload will be of limited utility 

public void reloadBrooklynProperties() {	BrooklynProperties properties = builder.build();	configMap = new DeferredBrooklynProperties(properties, this);	if (brooklynAdditionalProperties != null && !brooklynAdditionalProperties.isEmpty()) {	
reloading additional brooklyn properties from 

========================= brooklyn sample_1070 =========================

public void testDescendantsInSimpleDeployedApplication() throws InterruptedException, TimeoutException, IOException {	Response response = clientDeploy(simpleSpec);	assertTrue(response.getStatus()/100 == 2, "response is "+response);	Application application = Iterables.getOnlyElement( getManagementContext().getApplications() );	List<Entity> entities = MutableList.copyOf( application.getChildren() );	
created app with children entities 

========================= brooklyn sample_2826 =========================

public void customize() {	
customizing cluster 

public void launch() {	String subnetHostname = Machines.findSubnetOrPublicHostname(entity).get();	Set<Entity> seeds = getEntity().getConfig(CassandraNode.INITIAL_SEEDS);	List<Entity> ancestors = getCassandraAncestors();	
launching cluster hostname public hostname subnet seeds from 

public void launch() {	String subnetHostname = Machines.findSubnetOrPublicHostname(entity).get();	Set<Entity> seeds = getEntity().getConfig(CassandraNode.INITIAL_SEEDS);	List<Entity> ancestors = getCassandraAncestors();	boolean isFirst = seeds.iterator().next().equals(entity);	if (isClustered() && !isFirst && CassandraDatacenter.WAIT_FOR_FIRST) {	long firstStartTime = Entities.submit(entity, DependentConfiguration.attributeWhenReady( ancestors.get(ancestors.size()-1), CassandraDatacenter.FIRST_NODE_STARTED_TIME_UTC)).getUnchecked();	Duration toWait = Duration.millis(firstStartTime + CassandraDatacenter.DELAY_AFTER_FIRST.toMilliseconds() -  System.currentTimeMillis());	if (toWait.toMilliseconds()>0) {	
launching delaying launch of non first node by to prevent schema disagreements 

========================= brooklyn sample_394 =========================

public InMemoryObjectStore(Map<String,byte[]> map, Map<String, Date> fileModTimesByName) {	filesByName = map;	this.fileModTimesByName = fileModTimesByName;	
using memory based objectstore 

========================= brooklyn sample_681 =========================

assertTrue(allowCompletion.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));	return result;	}});	data.put(1, "a");	Task<?> t2 = em.submit(MutableMap.of("tag", "A"), t);	assertEquals(t, t2);	assertFalse(t.isDone());	assertTrue(signalStarted.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));	assertEquals("b", data.get(1));	assertFalse(t.isDone());	
runbasictaskwithwaits basictask status 

public void runMultipleBasicTasks() throws Exception {	data.put(1, 1);	BasicExecutionManager em = new BasicExecutionManager("mycontext");	for (int i = 0; i < 2; i++) {	em.submit(MutableMap.of("tag", "A"), new BasicTask<Integer>(newIncrementCallable(1)));	em.submit(MutableMap.of("tag", "B"), new BasicTask<Integer>(newIncrementCallable((1))));	}	int total = 0;	for (Object tag : em.getTaskTags()) {	
tag 

public void runMultipleBasicTasks() throws Exception {	data.put(1, 1);	BasicExecutionManager em = new BasicExecutionManager("mycontext");	for (int i = 0; i < 2; i++) {	em.submit(MutableMap.of("tag", "A"), new BasicTask<Integer>(newIncrementCallable(1)));	em.submit(MutableMap.of("tag", "B"), new BasicTask<Integer>(newIncrementCallable((1))));	}	int total = 0;	for (Object tag : em.getTaskTags()) {	for (Task<?> task : em.getTasksWithTag(tag)) {	
basictask has 

public void runMultipleBasicTasksMultipleTags() throws Exception {	data.put(1, 1);	Collection<Task<Integer>> tasks = Lists.newArrayList();	tasks.add(em.submit(MutableMap.of("tag", "A"), new BasicTask<Integer>(newIncrementCallable(1))));	tasks.add(em.submit(MutableMap.of("tags", ImmutableList.of("A","B")), new BasicTask<Integer>(newIncrementCallable(1))));	tasks.add(em.submit(MutableMap.of("tags", ImmutableList.of("B","C")), new BasicTask<Integer>(newIncrementCallable(1))));	tasks.add(em.submit(MutableMap.of("tags", ImmutableList.of("D")), new BasicTask<Integer>(newIncrementCallable(1))));	int total = 0;	for (Task<Integer> t : tasks) {	
basictask has 

assertTrue(t.isError());	em.submit(MutableMap.of("tag", "A"), t);	try {	t.get();	fail("get should have failed due to cancel");	} catch (CancellationException e) {	}	assertTrue(t.isCancelled());	assertTrue(t.isDone());	assertTrue(t.isError());	
cancelbeforerun status 

try {	t.get();	fail("get should have failed due to error");	} catch (Exception eo) {	Throwable e = Throwables.getRootCause(eo);	assertEquals("Simulating failure in errorDuringRun", e.getMessage());	}	assertFalse(t.isCancelled());	assertTrue(t.isError());	assertTrue(t.isDone());	
errorduringrun status 

em.submit(MutableMap.of("tag", "A"), t);	assertTrue(signalStarted.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));	assertTrue(t.submitTimeUtc > 0);	assertTrue(t.startTimeUtc >= t.submitTimeUtc);	assertNotNull(t.getInternalFuture());	assertEquals(-1, t.endTimeUtc);	assertEquals(false, t.isCancelled());	allowCompletion.countDown();	assertEquals(t.get(), (Integer)42);	assertTrue(t.endTimeUtc >= t.startTimeUtc);	
basictask duration millis 

assertEquals( 46, tb.get() );	assertEquals( t, em.getTasksWithTag("A").iterator().next() );	assertNull( t.getSubmittedByTask() );	BasicTask<?> submitter = (BasicTask<?>) tb.getSubmittedByTask();	assertNotNull(submitter);	assertEquals("sample", submitter.displayName);	assertEquals("some descr", submitter.description);	assertEquals(t, submitter);	assertTrue(submitter.submitTimeUtc <= tb.submitTimeUtc);	assertTrue(submitter.endTimeUtc <= tb.endTimeUtc);	
basictask was submitted by 

========================= brooklyn sample_906 =========================

public Object fromString(String str) {	if (lookupContext == null) {	
cannot unmarshal from persisted xml no lookup context supplied 

if (source == null) return;	if (((Task<?>)source).isDone() && !((Task<?>)source).isError()) {	try {	Object nextItem = ((Task<?>)source).get();	if (nextItem != null) {	context.convertAnother(nextItem);	}	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	} catch (ExecutionException e) {	
unexpected exception getting done and non error task result for continuing 

Object nextItem = ((Task<?>)source).get();	if (nextItem != null) {	context.convertAnother(nextItem);	}	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	} catch (ExecutionException e) {	}	} else {	if (!loggedTaskWarning) {	
intercepting and skipping request to serialize a task at only logging this once 

========================= brooklyn sample_1162 =========================

protected void onEntityEvent(EventType type, Entity member) {	
event received for in 

switch (where) {	case ENTITY: execute(entity, command, type.name(), member.getId());	break;	case MEMBER: execute(member, command, type.name(), member.getId());	break;	case ALL_MEMBERS: highlightAction("Run at all members ("+getGroup().getMembers().size()+")", null);	for (Entity each : getGroup().getMembers()) {	execute(each, command, type.name(), member.getId(), false);	}	break;	
unknown value passed as execution target 

private void execute(Entity target, String command, String type, String memberId, boolean highlight) {	if (Entities.isNoLongerManaged(target)) return;	Lifecycle state = target.getAttribute(Attributes.SERVICE_STATE_ACTUAL);	if (state==Lifecycle.STOPPING || state==Lifecycle.STOPPED) return;	Collection<? extends Location> locations = Locations.getLocationsCheckingAncestors(target.getLocations(), target);	Maybe<SshMachineLocation> machine = Machines.findUniqueMachineLocation(locations, SshMachineLocation.class);	if (machine.isAbsentOrNull()) {	
no machine available to execute command 

private void execute(Entity target, String command, String type, String memberId, boolean highlight) {	if (Entities.isNoLongerManaged(target)) return;	Lifecycle state = target.getAttribute(Attributes.SERVICE_STATE_ACTUAL);	if (state==Lifecycle.STOPPING || state==Lifecycle.STOPPED) return;	Collection<? extends Location> locations = Locations.getLocationsCheckingAncestors(target.getLocations(), target);	Maybe<SshMachineLocation> machine = Machines.findUniqueMachineLocation(locations, SshMachineLocation.class);	if (machine.isAbsentOrNull()) {	return;	}	
executing command on 

} catch (InterruptedException | ExecutionException e) {	throw Exceptions.propagate(e);	}	ShellEnvironmentSerializer serializer = new ShellEnvironmentSerializer(getManagementContext());	SshEffectorTasks.SshEffectorTaskFactory<String> task = SshEffectorTasks.ssh(sshCommand) .machine(machine.get()) .requiringZeroAndReturningStdout() .summary("group-" + CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_HYPHEN, type)) .environmentVariables(serializer.serialize(env));	Task<String> taskI = DynamicTasks.submit(task.newTask(), target);	if (highlight) {	highlightAction("Run at "+machine.get().getAddress().getHostAddress(), taskI);	}	String output = taskI.getUnchecked();	
command returned 

========================= brooklyn sample_1532 =========================

BasicRegisteredTypeLoadingContext constraint = new BasicRegisteredTypeLoadingContext(source);	if (source==null) source = constraint;	if (superType==null) return source;	constraint.expectedSuperType = superType;	if (source.getExpectedJavaSuperType()==null || source.getExpectedJavaSuperType().isAssignableFrom( superType )) {	return constraint;	}	if (superType.isAssignableFrom( source.getExpectedJavaSuperType() )) {	return source;	}	
ambiguous bean supertypes for target it is recommended that any registered type constraint for a spec be compatible with the spec type 

BasicRegisteredTypeLoadingContext constraint = new BasicRegisteredTypeLoadingContext(source);	if (source==null) source = constraint;	if (superType==null) return source;	constraint.expectedSuperType = superType;	if (source.getExpectedJavaSuperType()==null || source.getExpectedJavaSuperType().isAssignableFrom( superType )) {	return constraint;	}	if (superType.isAssignableFrom( source.getExpectedJavaSuperType() )) {	return source;	}	
ambiguous spec supertypes for target it is recommended that any registered type constraint for a spec be compatible with the spec type 

if (specSuperType==null) return BrooklynObject.class;	BrooklynObjectType best = null;	for (BrooklynObjectType t: BrooklynObjectType.values()) {	if (t.getSpecType()==null) continue;	if (!t.getSpecType().isAssignableFrom(specSuperType)) continue;	if (t.getSpecType().equals(specSuperType)) return t.getInterfaceType();	if (best==null) { best = t; continue; }	if (best.getSpecType().isAssignableFrom(t.getSpecType())) { best = t; continue; }	}	if (best==null) {	
unexpected spec supertype treating as any trace for unexpected spec supertype 

if (targetSuperType==null) return null;	BrooklynObjectType best = null;	for (BrooklynObjectType t: BrooklynObjectType.values()) {	if (t.getInterfaceType()==null) continue;	if (!t.getInterfaceType().isAssignableFrom(targetSuperType)) continue;	if (t.getInterfaceType().equals(targetSuperType)) return t.getSpecType();	if (best==null) { best = t; continue; }	if (best.getInterfaceType().isAssignableFrom(t.getInterfaceType())) { best = t; continue; }	}	if (best==null) {	
unexpected target supertype unable to infer spec type 

========================= brooklyn sample_1027 =========================

public BasicExecutionContext(Map<?, ?> flags, ExecutionManager executionManager) {	this.executionManager = executionManager;	if (flags.get("tag") != null) tags.add(flags.remove("tag"));	if (flags.containsKey("tags")) tags.addAll((Collection<?>)flags.remove("tags"));	for (Object tag: tags) {	if (tag instanceof BrooklynTaskTags.WrappedEntity) {	if (Proxy.isProxyClass(((WrappedEntity)tag).entity.getClass())) {	
has entity proxy in 

taskTags = new ArrayList();	} else {	taskTags = new ArrayList((Collection)properties.get("tags"));	}	properties.put("tags", taskTags);	if (task instanceof Task<?>) taskTags.addAll( ((Task<?>)task).getTags() );	Entity target = BrooklynTaskTags.getWrappedEntityOfType(taskTags, BrooklynTaskTags.TARGET_ENTITY);	checkUserSuppliedContext(task, taskTags);	if (target!=null && !tags.contains(BrooklynTaskTags.tagForContextEntity(target))) {	final ExecutionContext tc = ((EntityInternal)target).getExecutionContext();	
switching task context on execution of from to in 

========================= brooklyn sample_1477 =========================

LocalManagementContextForTests mgmt = new LocalManagementContextForTests(BrooklynProperties.Factory.newDefault());	JcloudsLocation location = (JcloudsLocation) mgmt.getLocationRegistry().getLocationManaged(locationSpec);	String identity = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_IDENTITY), "identity must not be null");	String credential = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_CREDENTIAL), "credential must not be null");	String provider = checkNotNull(location.getConfig(LocationConfigKeys.CLOUD_PROVIDER), "provider must not be null");	String endpoint = location.getConfig(CloudLocationConfig.CLOUD_ENDPOINT);	BlobStoreContext context = ContextBuilder.newBuilder(provider) .credentials(identity, credential) .endpoint(endpoint) .buildView(BlobStoreContext.class);	PageSet<? extends StorageMetadata> containers = context.getBlobStore().list();	for (StorageMetadata container: containers) {	if (container.getName().matches("brooklyn.*-test.*") ) {	
killing 

String identity = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_IDENTITY), "identity must not be null");	String credential = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_CREDENTIAL), "credential must not be null");	String provider = checkNotNull(location.getConfig(LocationConfigKeys.CLOUD_PROVIDER), "provider must not be null");	String endpoint = location.getConfig(CloudLocationConfig.CLOUD_ENDPOINT);	BlobStoreContext context = ContextBuilder.newBuilder(provider) .credentials(identity, credential) .endpoint(endpoint) .buildView(BlobStoreContext.class);	PageSet<? extends StorageMetadata> containers = context.getBlobStore().list();	for (StorageMetadata container: containers) {	if (container.getName().matches("brooklyn.*-test.*") ) {	context.getBlobStore().deleteContainer(container.getName());	} else {	
keeping 

========================= brooklyn sample_2488 =========================

protected BrooklynMementoRawData transform(ManagementContext mgmt, CompoundTransformer transformer) throws Exception {	BrooklynMementoPersisterToObjectStore reader = (BrooklynMementoPersisterToObjectStore) mgmt.getRebindManager().getPersister();	RebindExceptionHandler exceptionHandler = new RecordingRebindExceptionHandler(RebindFailureMode.FAIL_FAST, RebindFailureMode.FAIL_FAST);	BrooklynMementoRawData result = transformer.transform(reader, exceptionHandler);	
test transformed persisted state 

protected File persist(BrooklynMementoRawData rawData) throws Exception {	File newMementoDir = Os.newTempDir(getClass());	FileBasedObjectStore objectStore = new FileBasedObjectStore(newMementoDir);	objectStore.injectManagementContext(origManagementContext);	objectStore.prepareForSharedUse(PersistMode.CLEAN, HighAvailabilityMode.DISABLED);	BrooklynMementoPersisterToObjectStore persister = new BrooklynMementoPersisterToObjectStore( objectStore, origManagementContext);	persister.enableWriteAccess();	PersistenceExceptionHandler exceptionHandler = PersistenceExceptionHandlerImpl.builder().build();	persister.checkpoint(rawData, exceptionHandler);	
test persisted raw data to 

========================= brooklyn sample_639 =========================

double dd = 0;	if (timeString.length()>0) {	dd = parseElapsedTimeAsDouble(timeString);	if (dd==-1) {	throw new NumberFormatException("Cannot combine '"+timeString+"' with '"+num+" "+s+"'");	}	}	return d*multiplier + dd;	} catch (Exception ex) {	if (ex instanceof NumberFormatException) throw (NumberFormatException)ex;	
details of parse failure 

if (dateString == null) {	throw new NumberFormatException("GeneralHelper.parseDateString cannot parse a null string");	}	Preconditions.checkNotNull(format, "date format");	dateString = dateString.trim();	ParsePosition p = new ParsePosition(0);	Date result = format.parse(dateString, p);	if (result!=null) {	return Maybe.of(newCalendarFromDate(result));	}	
could not parse date using format 

========================= brooklyn sample_2037 =========================

public synchronized ProcessTaskWrapper<RET> newTask() {	Entity entity = BrooklynTaskTags.getTargetOrContextEntity(Tasks.current());	if (machine==null) {	
using an ssh task not in an effector without any machine will attempt to infer the machine 

public SshPutTaskWrapper newTask() {	Entity entity = BrooklynTaskTags.getTargetOrContextEntity(Tasks.current());	if (machine==null) {	
using an ssh put task not in an effector without any machine will attempt to infer the machine 

public SshFetchTaskWrapper newTask() {	Entity entity = BrooklynTaskTags.getTargetOrContextEntity(Tasks.current());	if (machine==null) {	
using an ssh fetch task not in an effector without any machine will attempt to infer the machine 

========================= brooklyn sample_1174 =========================

protected void assertNotYetManaged() {	if (!inConstruction && Locations.isManaged(this)) {	
configuration being made to after deployment may not be supported in future versions 

Map<String, String> extensions = getConfig(LocationConfigKeys.EXTENSIONS);	if (extensions != null) {	for (Map.Entry<String, String> extension: extensions.entrySet()) {	try {	Class<?> extensionClassType =  new ClassLoaderUtils(this, getManagementContext()).loadClass(extension.getKey());	if (!hasExtension(extensionClassType)) {	Object extensionClass = new ClassLoaderUtils(this, getManagementContext()).loadClass(extension.getValue()).newInstance();	addExtension((Class)extensionClassType, extensionClass);	}	} catch (Exception e) {	
location extension can not be loaded rethrowing 

========================= brooklyn sample_1318 =========================

protected Object transformSpecialFlags(Object flag) {	if (flag instanceof EntitySpecConfiguration) {	EntitySpecConfiguration specConfig = (EntitySpecConfiguration) flag;	Map<String, Object> resolvedConfig = (Map<String, Object>)transformSpecialFlags(specConfig.getSpecConfiguration());	specConfig.setSpecConfiguration(resolvedConfig);	EntitySpec<?> entitySpec = Factory.newInstance(getLoader(), specConfig.getSpecConfiguration()).resolveSpec(encounteredRegisteredTypeIds);	return EntityManagementUtils.unwrapEntity(entitySpec);	}	if (flag instanceof ManagementContextInjectable) {	
injecting brooklyn management context info object 

========================= brooklyn sample_1748 =========================

public StubHostLocation createLocation(Map<String, ?> flags) {	StubInfrastructure infrastructure = getInfrastructure();	StubInfrastructureLocation docker = infrastructure.getDynamicLocation();	SshMachineLocation machine = Machines.findUniqueMachineLocation(getLocations(), SshMachineLocation.class).get();	String locationName = docker.getId() + "-" + getId();	StubHostLocation location = getManagementContext().getLocationManager().createLocation(LocationSpec.create(StubHostLocation.class) .parent(infrastructure.getDynamicLocation()) .displayName("Docker Host("+getId()+")") .configure(flags) .configure("owner", getProxy()) .configure("machine", machine) .configure("locationName", locationName));	LocationDefinition definition = location.register();	sensors().set(LOCATION_SPEC, definition.getSpec());	sensors().set(LOCATION_NAME, locationName);	sensors().set(DYNAMIC_LOCATION, location);	
new docker host location created 

========================= brooklyn sample_2164 =========================

public void tearDownClass() throws Exception {	try {	try {	if (location != null) location.release(machine);	} finally {	if (mgmt != null) Entities.destroyAll(mgmt);	}	} catch (Throwable t) {	
caught exception in teardownclass method 

public void tearDown() throws Exception {	try {	try {	if (app != null) Entities.destroy(app);	} catch (Throwable t) {	
caught exception in teardown method 

public void doTest() {	ImmutableMap<String, String> installTemplates = new ImmutableMap.Builder<String, String>() .put("classpath: .put("classpath: .put("classpath: .put("classpath: .put("classpath: .build();	VanillaWindowsProcess entity = app.createAndManageChild(EntitySpec.create(VanillaWindowsProcess.class) .configure(VanillaWindowsProcess.INSTALL_TEMPLATES, installTemplates) .configure(VanillaWindowsProcess.INSTALL_POWERSHELL_COMMAND, "C:\\install_mongodb.ps1") .configure(VanillaWindowsProcess.CUSTOMIZE_POWERSHELL_COMMAND, "C:\\configure_mongodb.ps1") .configure(VanillaWindowsProcess.LAUNCH_POWERSHELL_COMMAND, "C:\\launch_mongodb.ps1") .configure(VanillaWindowsProcess.CHECK_RUNNING_POWERSHELL_COMMAND, "C:\\checkrunning_mongodb.ps1") .configure(VanillaWindowsProcess.STOP_POWERSHELL_COMMAND, "C:\\stop_mongodb.ps1") .configure(VanillaWindowsProcess.PROVISIONING_PROPERTIES, ImmutableMap.<String, Object> of("required.ports", "27017")) .configure("mongodb.download.url", "https: .configure("mongodb.instance.name", "Instance1"));	app.start(ImmutableList.of(machine));	
app started asserting up 

public void doTest() {	ImmutableMap<String, String> installTemplates = new ImmutableMap.Builder<String, String>() .put("classpath: .put("classpath: .put("classpath: .put("classpath: .put("classpath: .build();	VanillaWindowsProcess entity = app.createAndManageChild(EntitySpec.create(VanillaWindowsProcess.class) .configure(VanillaWindowsProcess.INSTALL_TEMPLATES, installTemplates) .configure(VanillaWindowsProcess.INSTALL_POWERSHELL_COMMAND, "C:\\install_mongodb.ps1") .configure(VanillaWindowsProcess.CUSTOMIZE_POWERSHELL_COMMAND, "C:\\configure_mongodb.ps1") .configure(VanillaWindowsProcess.LAUNCH_POWERSHELL_COMMAND, "C:\\launch_mongodb.ps1") .configure(VanillaWindowsProcess.CHECK_RUNNING_POWERSHELL_COMMAND, "C:\\checkrunning_mongodb.ps1") .configure(VanillaWindowsProcess.STOP_POWERSHELL_COMMAND, "C:\\stop_mongodb.ps1") .configure(VanillaWindowsProcess.PROVISIONING_PROPERTIES, ImmutableMap.<String, Object> of("required.ports", "27017")) .configure("mongodb.download.url", "https: .configure("mongodb.instance.name", "Instance1"));	app.start(ImmutableList.of(machine));	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_UP, true);	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.RUNNING);	entity.stop();	
stopping entity 

========================= brooklyn sample_290 =========================

protected void doRun() throws Exception {	
rebinding iteration from 

protected void loadManifestFiles() throws Exception {	checkEnteringPhase(1);	Preconditions.checkState(mementoRawData==null, "Memento raw data should not yet be set when calling this");	mementoRawData = persistenceStoreAccess.loadMementoRawData(exceptionHandler);	preprocessManifestFiles();	if (!isEmpty) {	if (!ManagementNodeState.isHotProxy(mode) || readOnlyRebindCount.get()==1) {	
rebinding from for 

protected void loadManifestFiles() throws Exception {	checkEnteringPhase(1);	Preconditions.checkState(mementoRawData==null, "Memento raw data should not yet be set when calling this");	mementoRawData = persistenceStoreAccess.loadMementoRawData(exceptionHandler);	preprocessManifestFiles();	if (!isEmpty) {	if (!ManagementNodeState.isHotProxy(mode) || readOnlyRebindCount.get()==1) {	}	} else {	if (!ManagementNodeState.isHotProxy(mode)) {	
rebind check no existing state will persist new items to 

}	} else {	if (!ManagementNodeState.isHotProxy(mode)) {	}	}	if (!ManagementNodeState.isHotProxy(mode)) {	if (!managementContext.getEntityManager().getEntities().isEmpty() || !managementContext.getLocationManager().getLocations().isEmpty()) {	Entity anEntity = Iterables.getFirst(managementContext.getEntityManager().getEntities(), null);	if (anEntity!=null && !((EntityInternal)anEntity).getManagementSupport().isReadOnly()) {	overwritingMaster = true;	
rebind requested for node when it already has active state discouraged will likely overwrite and and more 

protected void cleanupOldLocations(Set<String> oldLocations) {	LocationManagerInternal locationManager = (LocationManagerInternal)managementContext.getLocationManager();	
destroying unused locations on rebind 

protected void cleanupOldEntities(Set<String> oldEntities) {	EntityManagerInternal entityManager = (EntityManagerInternal)managementContext.getEntityManager();	
destroying unused entities on rebind 

========================= brooklyn sample_1123 =========================

boolean retrieveUsageMetrics = getConfig(RETRIEVE_USAGE_METRICS);	if (machine.isPresent()) {	String cmd = getDriver().getStatusCmd();	feed = SshFeed.builder() .entity(this) .period(config().get(SERVICE_PROCESS_IS_RUNNING_POLL_PERIOD)) .machine(machine.get()) .poll(new SshPollConfig<Double>(QUERIES_PER_SECOND_FROM_MYSQL) .command(cmd) .onSuccess(new Function<SshPollValue, Double>() {	public Double apply(SshPollValue input) {	String q = Strings.getFirstWordAfter(input.getStdout(), "Queries per second avg:");	if (q==null) return null;	return Double.parseDouble(q);	}}) .setOnFailureOrException(null) .enabled(retrieveUsageMetrics)) .poll(new SshPollConfig<Boolean>(SERVICE_PROCESS_IS_RUNNING) .command(cmd) .setOnSuccess(true) .setOnFailureOrException(false) .suppressDuplicates(true)) .build();	} else {	
location s not an ssh machine location so not polling for status setting serviceup immediately 

========================= brooklyn sample_101 =========================

protected void doTestStandbyTakesOver(boolean stopGracefully) throws Exception {	
starting standby takeover test 

protected void doTestStandbyTakesOver(boolean stopGracefully) throws Exception {	primary = BrooklynLauncher.newInstance();	primary.webconsole(false) .brooklynProperties(LocalManagementContextForTests.setEmptyCatalogAsDefault(BrooklynProperties.Factory.newEmpty())) .highAvailabilityMode(HighAvailabilityMode.AUTO) .persistMode(PersistMode.AUTO) .persistenceDir(persistenceDir) .persistPeriod(Duration.millis(10)) .haHeartbeatPeriod(Duration.millis(10)) .haHeartbeatTimeout(Duration.millis(1000)) .application(EntitySpec.create(TestApplication.class)) .start();	ManagementContext primaryManagementContext = primary.getServerDetails().getManagementContext();	
started mgmt primary 

protected void doTestStandbyTakesOver(boolean stopGracefully) throws Exception {	primary = BrooklynLauncher.newInstance();	primary.webconsole(false) .brooklynProperties(LocalManagementContextForTests.setEmptyCatalogAsDefault(BrooklynProperties.Factory.newEmpty())) .highAvailabilityMode(HighAvailabilityMode.AUTO) .persistMode(PersistMode.AUTO) .persistenceDir(persistenceDir) .persistPeriod(Duration.millis(10)) .haHeartbeatPeriod(Duration.millis(10)) .haHeartbeatTimeout(Duration.millis(1000)) .application(EntitySpec.create(TestApplication.class)) .start();	ManagementContext primaryManagementContext = primary.getServerDetails().getManagementContext();	assertOnlyApp(primary.getServerDetails().getManagementContext(), TestApplication.class);	primaryManagementContext.getRebindManager().getPersister().waitForWritesCompleted(TIMEOUT);	secondary = BrooklynLauncher.newInstance();	secondary.webconsole(false) .brooklynProperties(LocalManagementContextForTests.setEmptyCatalogAsDefault(BrooklynProperties.Factory.newEmpty())) .highAvailabilityMode(HighAvailabilityMode.AUTO) .persistMode(PersistMode.AUTO) .persistenceDir(persistenceDir) .persistPeriod(Duration.millis(10)) .haHeartbeatPeriod(Duration.millis(10)) .haHeartbeatTimeout(Duration.millis(1000)) .start();	ManagementContext secondaryManagementContext = secondary.getServerDetails().getManagementContext();	
started mgmt secondary 

((ManagementContextInternal)primaryManagementContext).terminate();	} else {	ManagementPlaneSyncRecordPersister planePersister = ((ManagementContextInternal)primaryManagementContext).getHighAvailabilityManager().getPersister();	planePersister.stop();	((ManagementContextInternal)primaryManagementContext).terminate();	}	assertOnlyAppEventually(secondaryManagementContext, TestApplication.class);	tertiary = BrooklynLauncher.newInstance();	tertiary.webconsole(false) .brooklynProperties(LocalManagementContextForTests.setEmptyCatalogAsDefault(BrooklynProperties.Factory.newEmpty())) .highAvailabilityMode(HighAvailabilityMode.STANDBY) .persistMode(PersistMode.AUTO) .persistenceDir(persistenceDir) .persistPeriod(Duration.millis(10)) .haHeartbeatPeriod(Duration.millis(10)) .haHeartbeatTimeout(Duration.millis(1000)) .start();	ManagementContext tertiaryManagementContext = tertiary.getServerDetails().getManagementContext();	
started mgmt tertiary 

========================= brooklyn sample_551 =========================

protected void connectSensors() {	super.connectSensors();	HostAndPort hp = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, getAttribute(MANAGEMENT_HTTP_PORT) + getConfig(PORT_INCREMENT));	String managementUri = String.format("http: hp.getHostText(), hp.getPort());	sensors().set(MANAGEMENT_URL, managementUri);	if (isHttpMonitoringEnabled()) {	
jboss sensors for reading from 

========================= brooklyn sample_228 =========================

public Set<V> asImmutableCopy() {	try {	return ImmutableSet.copyOf(this);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error converting list to immutable using unmodifiable instead 

========================= brooklyn sample_2099 =========================

public static void main(String[] args) throws Exception {	ActivityRestTest me = new ActivityRestTest();	me.setUpClass();	int i=0;	do {	me.initEntity(i);	try {	
trying seed 

me.initEntity(i);	try {	me.testGood(Duration.millis(200));	break;	} catch (Throwable e) {	log.info("  "+Exceptions.collapseText(e));	}	i++;	} while (true);	Tasks.dumpInfo(me.lastTask);	
seed is good 

public void testGetActivitiesChildren() {	Task<?> t = entity.invoke(effector, null);	Task<?> leaf = waitForCompletedDescendantWithChildAndSibling(t, t, CountdownTimer.newInstanceStarted(Duration.ONE_SECOND), 0);	Response response = client().path("/activities/"+leaf.getSubmittedByTask().getId()+"/children") .accept(MediaType.APPLICATION_JSON) .get();	assertHealthy(response);	List<TaskSummary> tasks = response.readEntity(new GenericType<List<TaskSummary>>() {});	
tasks children 

public void testGetEntityActivitiesAndWithLimit() {	Task<?> t = entity.invoke(effector, null);	Task<?> leaf = waitForCompletedDescendantWithChildAndSibling(t, t, CountdownTimer.newInstanceStarted(Duration.ONE_SECOND), 0);	Response response = client().path("/applications/"+entity.getApplicationId()+ "/entities/"+entity.getId()+"/activities") .accept(MediaType.APPLICATION_JSON) .get();	assertHealthy(response);	List<TaskSummary> tasks = response.readEntity(new GenericType<List<TaskSummary>>() {});	
tasks now 

Task<?> t = entity.invoke(effector, null);	Task<?> leaf = waitForCompletedDescendantWithChildAndSibling(t, t, CountdownTimer.newInstanceStarted(Duration.ONE_SECOND), 0);	Response response = client().path("/applications/"+entity.getApplicationId()+ "/entities/"+entity.getId()+"/activities") .accept(MediaType.APPLICATION_JSON) .get();	assertHealthy(response);	List<TaskSummary> tasks = response.readEntity(new GenericType<List<TaskSummary>>() {});	Assert.assertTrue(tasks.size() > 4, "tasks should have been big; was "+tasks);	Assert.assertTrue(tasksContain(tasks, leaf), "tasks should have included leaf "+leaf+"; was "+tasks);	response = client().path("/applications/"+entity.getApplicationId()+ "/entities/"+entity.getId()+"/activities") .query("limit", 3) .accept(MediaType.APPLICATION_JSON) .get();	assertHealthy(response);	tasks = response.readEntity(new GenericType<List<TaskSummary>>() {});	
tasks limited 

========================= brooklyn sample_2830 =========================

public void tearDown() throws Exception {	for (KubernetesMachineLocation machine : machines) {	try {	loc.release(machine);	} catch (Exception e) {	
error releasing machine in location 

========================= brooklyn sample_2451 =========================

public List<SensorSummary> list(final String application, final String entityToken) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to see entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	List<SensorSummary> result = Lists.newArrayList();	for (AttributeSensor<?> sensor : filter(entity.getEntityType().getSensors(), AttributeSensor.class)) {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {	
user not authorized to see sensor of entity excluding from attributesensor list results 

public Map<String, Object> batchSensorRead(final String application, final String entityToken, final Boolean raw) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to see entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	Map<String, Object> sensorMap = Maps.newHashMap();	Iterable<AttributeSensor> sensors = filter(entity.getEntityType().getSensors(), AttributeSensor.class);	for (AttributeSensor<?> sensor : sensors) {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {	
user not authorized to see sensor of entity excluding from current state results 

public void setFromMap(String application, String entityToken, Map newValues) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to modify entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	
rest user setting sensors 

public void set(String application, String entityToken, String sensorName, Object newValue) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to modify entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	AttributeSensor sensor = findSensor(entity, sensorName);	
rest user setting sensor to 

public void delete(String application, String entityToken, String sensorName) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to modify entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	AttributeSensor<?> sensor = findSensor(entity, sensorName);	
rest user deleting sensor 

========================= brooklyn sample_2902 =========================

continue;	}	}	if (!Modifier.isStatic(f.getModifiers())) {	LOG.warn("Discouraged use of non-static config key "+f+" defined in " + (optionalInstance!=null ? optionalInstance : clazz));	if (optionalInstance==null) continue;	}	try {	Object v = f.get(optionalInstance);	if (v == null) {	
no value defined for config key field skipping 

if (optionalInstance==null) continue;	}	try {	Object v = f.get(optionalInstance);	if (v == null) {	} else {	ConfigKey<?> k = isConfigKey ? (ConfigKey<?>) v : ((HasConfigKey<?>) v).getConfigKey();	configKeysAll.put(k.getName(), new FieldAndValue<ConfigKey<?>>(f, k));	}	} catch (IllegalAccessException e) {	
cannot access config key skipping 

}	kk = Lists.newArrayList(configKeysAll.get(kn));	FieldAndValue<ConfigKey<?>> best = null;	for (FieldAndValue<ConfigKey<?>> k: kk) {	if (best==null) {	best=k;	} else {	Field lower = Reflections.inferSubbestField(k.field, best.field);	ConfigKey<? extends Object> lowerV = lower==null ? null : lower.equals(k.field) ? k.value : best.value;	if (best.value == k.value) {	
multiple definitions for config key on same value from and preferring 

for (FieldAndValue<ConfigKey<?>> k: kk) {	if (best==null) {	best=k;	} else {	Field lower = Reflections.inferSubbestField(k.field, best.field);	ConfigKey<? extends Object> lowerV = lower==null ? null : lower.equals(k.field) ? k.value : best.value;	if (best.value == k.value) {	best.value.getName(), optionalInstance!=null ? optionalInstance : clazz, best.value.getDefaultValue(), k.field, best.field, lower});	best = new FieldAndValue<ConfigKey<?>>(lower!=null ? lower : best.field, best.value);	} else if (lower!=null) {	
multiple definitions for config key on from and preferring lower value 

} else {	Field lower = Reflections.inferSubbestField(k.field, best.field);	ConfigKey<? extends Object> lowerV = lower==null ? null : lower.equals(k.field) ? k.value : best.value;	if (best.value == k.value) {	best.value.getName(), optionalInstance!=null ? optionalInstance : clazz, best.value.getDefaultValue(), k.field, best.field, lower});	best = new FieldAndValue<ConfigKey<?>>(lower!=null ? lower : best.field, best.value);	} else if (lower!=null) {	best.value.getName(), optionalInstance!=null ? optionalInstance : clazz, k.field, best.field, lower, lowerV.getDefaultValue() });	best = new FieldAndValue<ConfigKey<?>>(lower, lowerV);	} else {	
multiple ambiguous definitions for config key on from and values and keeping latter arbitrarily 

========================= brooklyn sample_1338 =========================

public HostGeoInfo getHostGeoInfo(final InetAddress address, Duration timeout) throws MalformedURLException, IOException {	final AtomicReference<HostGeoInfo> result = new AtomicReference<HostGeoInfo>();	Thread lt = new Thread() {	public void run() {	try {	result.set(retrieveHostGeoInfo(address));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (loggedInternetIssues) {	
error computing geo info for internet issues or too many requests to free servers for see previous warn message for detail 

final AtomicReference<HostGeoInfo> result = new AtomicReference<HostGeoInfo>();	Thread lt = new Thread() {	public void run() {	try {	result.set(retrieveHostGeoInfo(address));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (loggedInternetIssues) {	} else {	loggedInternetIssues = true;	
error computing geo info for internet issues or too many requests to free servers for subsequent errors at debug 

final AtomicReference<HostGeoInfo> result = new AtomicReference<HostGeoInfo>();	Thread lt = new Thread() {	public void run() {	try {	result.set(retrieveHostGeoInfo(address));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (loggedInternetIssues) {	} else {	loggedInternetIssues = true;	
detail of host geo error 

};	lt.start();	try {	Durations.join(lt, timeout);	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	}	if (lt.isAlive()) {	lt.interrupt();	LAST_FAILURE_UTC = System.currentTimeMillis();	
geo info lookup for timed out after 

public HostGeoInfo retrieveHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	String url = getLookupUrlFor(address);	
geo info lookup for at 

public HostGeoInfo retrieveHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	String url = getLookupUrlFor(address);	Node xml;	try {	xml = new XmlParser().parse(getLookupUrlFor(address));	} catch (Exception e) {	LAST_FAILURE_UTC = System.currentTimeMillis();	
geo info lookup for failed 

public HostGeoInfo retrieveHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	String url = getLookupUrlFor(address);	Node xml;	try {	xml = new XmlParser().parse(getLookupUrlFor(address));	} catch (Exception e) {	LAST_FAILURE_UTC = System.currentTimeMillis();	if (!LOGGED_GEO_LOOKUP_UNAVAILABLE) {	LOGGED_GEO_LOOKUP_UNAVAILABLE = true;	
geo info lookup unavailable for cause 

String org = getXmlResultsField(xml, "org").trim();	if (org.isEmpty()) org = getXmlResultsField(xml, "isp").trim();	String region = getXmlResultsField(xml, "region").trim();	if (!org.isEmpty()) {	if (!region.isEmpty()) region = org+", "+region;	else region = org;	}	if (region.isEmpty()) region = getXmlResultsField(xml, "isp").trim();	if (region.isEmpty()) region = address.toString();	HostGeoInfo geo = new HostGeoInfo(address.getHostName(), region+ " ("+getXmlResultsField(xml, "countrycode")+")", Double.parseDouble(""+getXmlResultsField(xml, "latitude")), Double.parseDouble(""+getXmlResultsField(xml, "longitude")));	
geo info lookup for returned 

String region = getXmlResultsField(xml, "region").trim();	if (!org.isEmpty()) {	if (!region.isEmpty()) region = org+", "+region;	else region = org;	}	if (region.isEmpty()) region = getXmlResultsField(xml, "isp").trim();	if (region.isEmpty()) region = address.toString();	HostGeoInfo geo = new HostGeoInfo(address.getHostName(), region+ " ("+getXmlResultsField(xml, "countrycode")+")", Double.parseDouble(""+getXmlResultsField(xml, "latitude")), Double.parseDouble(""+getXmlResultsField(xml, "longitude")));	return geo;	} catch (Exception e) {	
geo info lookup failed for at due to response is 

========================= brooklyn sample_1292 =========================

public void testExampleWar() {	String url = BrooklynMavenArtifacts.localUrl("example", "brooklyn-example-hello-world-sql-webapp", "war");	ResourceUtils.create(this).checkUrlExists(url);	
found example war at 

public void testHostedIsHttp() {	String common = BrooklynMavenArtifacts.hostedUrlForJar("brooklyn-utils-common");	
online should be at 

public void testHistoricHosted() {	String snapshot = MavenRetriever.hostedUrl(MavenArtifact.fromCoordinate("org.apache.brooklyn:brooklyn-utils-common:jar:0.7.0-SNAPSHOT"));	
sample snapshot url is 

public void testHistoricHosted() {	String snapshot = MavenRetriever.hostedUrl(MavenArtifact.fromCoordinate("org.apache.brooklyn:brooklyn-utils-common:jar:0.7.0-SNAPSHOT"));	checkValidArchive(snapshot);	ResourceUtils.create(this).checkUrlExists(snapshot);	String release = MavenRetriever.hostedUrl(MavenArtifact.fromCoordinate("io.brooklyn:brooklyn-utils-common:jar:0.6.0"));	
sample release url is 

========================= brooklyn sample_875 =========================

this.targetSensor = targetSensorSpecified!=null ? (Sensor<U>) targetSensorSpecified : (Sensor<U>) this.sourceSensor;	if (targetSensor == null) {	throw new IllegalArgumentException("Enricher "+JavaClassNames.simpleClassName(this)+" has no "+TARGET_SENSOR.getName()+", and it cannot be inferred as "+SOURCE_SENSOR.getName()+" is also not set");	}	if (sourceSensor == null && triggerSensors.isEmpty()) {	throw new IllegalArgumentException("Enricher "+JavaClassNames.simpleClassName(this)+" has no "+SOURCE_SENSOR.getName()+" and no "+TRIGGER_SENSORS.getName());	}	if (producer.equals(entity) && (targetSensor.equals(sourceSensor) || triggerSensors.contains(targetSensor))) {	boolean allowCyclicPublishing = Boolean.TRUE.equals(getConfig(ALLOW_CYCLIC_PUBLISHING));	if (allowCyclicPublishing) {	
permitting cyclic publishing though detected enricher will read and publish on the same sensor computing transformation with 

if (targetSensor == null) {	throw new IllegalArgumentException("Enricher "+JavaClassNames.simpleClassName(this)+" has no "+TARGET_SENSOR.getName()+", and it cannot be inferred as "+SOURCE_SENSOR.getName()+" is also not set");	}	if (sourceSensor == null && triggerSensors.isEmpty()) {	throw new IllegalArgumentException("Enricher "+JavaClassNames.simpleClassName(this)+" has no "+SOURCE_SENSOR.getName()+" and no "+TRIGGER_SENSORS.getName());	}	if (producer.equals(entity) && (targetSensor.equals(sourceSensor) || triggerSensors.contains(targetSensor))) {	boolean allowCyclicPublishing = Boolean.TRUE.equals(getConfig(ALLOW_CYCLIC_PUBLISHING));	if (allowCyclicPublishing) {	} else {	
refusing to add an enricher which reads and publishes on the same sensor computing transformation with 

protected Object compute(SensorEvent<T> event) {	U result = getTransformation().apply(event);	
enricher computed from 

========================= brooklyn sample_1011 =========================

} else {	log.warn("Misconfiguration for "+this+": ENABLED_PROTOCOLS='"+protos+"' for "+s+" but sslConfig="+sslConfig);	}	p = s.getAttribute(Attributes.HTTPS_PORT);	if (p == null) log.warn("Misconfiguration for "+this+": sslConfig="+sslConfig+" but no HTTPS_PORT on "+s);	}	if (p == null) {	p = s.getAttribute(Attributes.HTTP_PORT);	}	if (groovyTruth(h) && p != null) return h+":"+p;	
unable to construct hostname port representation for skipping in 

========================= brooklyn sample_199 =========================

public static void assertPortsAvailableEventually(final Map<String, Integer> ports, final Duration timeout) {	Asserts.succeedsEventually(ImmutableMap.of("timeout", Duration.minutes(4)), new Runnable() {	private boolean logged = false;	public void run() {	try {	assertPortsAvailable(ports);	} catch (Throwable t) {	if (!logged) {	
port s not available waiting for up to 

public void run() {	try {	assertPortsAvailable(ports);	} catch (Throwable t) {	if (!logged) {	logged = true;	}	throw Exceptions.propagate(t);	}	}});	
ports are available 

========================= brooklyn sample_2778 =========================

public synchronized <T> Future<T> submit(Callable<T> c) {	if (running.compareAndSet(false, true)) {	return executeNow(c);	} else {	WrappingFuture<T> f = new WrappingFuture<T>();	order.add(new QueuedSubmission<T>(c, f));	queueSize++;	if (queueSize>0 && (queueSize == 50 || (queueSize<=500 && (queueSize%100)==0) || (queueSize%1000)==0) && queueSize!=lastSizeWarn) {	
is backing up tasks queued 

public synchronized <T> Future<T> submit(Callable<T> c) {	if (running.compareAndSet(false, true)) {	return executeNow(c);	} else {	WrappingFuture<T> f = new WrappingFuture<T>();	order.add(new QueuedSubmission<T>(c, f));	queueSize++;	if (queueSize>0 && (queueSize == 50 || (queueSize<=500 && (queueSize%100)==0) || (queueSize%1000)==0) && queueSize!=lastSizeWarn) {	if (LOG.isDebugEnabled()) {	
task queue backing up detail queue task context is latest task is first task is 

========================= brooklyn sample_1504 =========================

public static TimeDuration toTimeDuration(Object duration) {	if (duration == null) {	return null;	} else if (duration instanceof TimeDuration) {	return (TimeDuration) duration;	} else if (duration instanceof Number) {	long d = ((Number)duration).longValue();	if (d <= Integer.MAX_VALUE && d >= Integer.MIN_VALUE) {	return new TimeDuration(0,0,0,(int)d);	} else {	
number too large to convert to timeduration using integer max value instead 

========================= brooklyn sample_2113 =========================

public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {	HttpServletRequest httpRequest = (HttpServletRequest) request;	HttpServletResponse httpResponse = (HttpServletResponse) response;	String uri = httpRequest.getRequestURI();	if (provider == null) {	
no security provider available disallowing web access to brooklyn 

originalRequest.set(uri);	}	boolean authenticated = provider.isAuthenticated(httpRequest.getSession());	if ("/logout".equals(uri) || "/v1/logout".equals(uri)) {	httpResponse.setHeader("WWW-Authenticate", "Basic realm=\"brooklyn\"");	if (authenticated && httpRequest.getSession().getAttributeNames().hasMoreElements()) {	logout(httpRequest);	httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED);	} else {	RequestDispatcher dispatcher = httpRequest.getRequestDispatcher("/");	
not authenticated forwarding request for to 

========================= brooklyn sample_2810 =========================

public void testDns(@Optional String locationSpec) throws Exception {	if (Strings.isBlank(locationSpec)) {	
got no spec skipping test 

========================= brooklyn sample_121 =========================

for (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {	context.setAttribute(attributeEntry.getKey(), attributeEntry.getValue());	}	try {	final CustomResourceLocator locator = new CustomResourceLocator(managementContext.getConfig(), ResourceUtils.create(this));	final InputStream resource = locator.getResourceFromUrl(warUrl);	final String warName = isRoot ? "ROOT" : ("embedded-" + pathSpec);	File tmpWarFile = Os.writeToTempFile(resource, warName, ".war");	context.setWar(tmpWarFile.getAbsolutePath());	} catch (Exception e) {	
failed to deploy webapp from launching run without war rethrowing 

try {	final CustomResourceLocator locator = new CustomResourceLocator(managementContext.getConfig(), ResourceUtils.create(this));	final InputStream resource = locator.getResourceFromUrl(warUrl);	final String warName = isRoot ? "ROOT" : ("embedded-" + pathSpec);	File tmpWarFile = Os.writeToTempFile(resource, warName, ".war");	context.setWar(tmpWarFile.getAbsolutePath());	} catch (Exception e) {	if (!ignoreFailures) {	throw new IllegalStateException("Failed to deploy webapp " + pathSpec + " from " + warUrl + ": " + Exceptions.collapseText(e), e);	}	
detail on failure to deploy webapp 

========================= brooklyn sample_571 =========================

public void testLocalhostSingle() throws Exception {	SingleMachineProvisioningLocation<SshMachineLocation> l = (SingleMachineProvisioningLocation<SshMachineLocation>) managementContext.getLocationRegistry().getLocationManaged("single:(target='localhost')");	l.setManagementContext(managementContext);	SshMachineLocation m1 = l.obtain();	assertNotNull(m1);	
got 

========================= brooklyn sample_967 =========================

Server server = new Server(threadPool);	ServerConnector httpConnector = new ServerConnector(server);	httpConnector.setPort(port);	server.addConnector(httpConnector);	server.setHandler(context);	try {	server.start();	} catch (Exception e) {	throw Exceptions.propagate(e);	}	
camp rest server started on 

Server server = new Server(threadPool);	ServerConnector httpConnector = new ServerConnector(server);	httpConnector.setPort(port);	server.addConnector(httpConnector);	server.setHandler(context);	try {	server.start();	} catch (Exception e) {	throw Exceptions.propagate(e);	}	
http return server 

========================= brooklyn sample_1800 =========================

public ZooKeeperTestSupport(final HostAndPort hostAndPort) throws Exception {	final int sessionTimeout = 3000;	zk = new ZooKeeper(hostAndPort.toString(), sessionTimeout, new Watcher() {	public void process(WatchedEvent event) {	if (event.getState() == Event.KeeperState.SyncConnected) {	
connected to zookeeper at 

public ZooKeeperTestSupport(final HostAndPort hostAndPort) throws Exception {	final int sessionTimeout = 3000;	zk = new ZooKeeper(hostAndPort.toString(), sessionTimeout, new Watcher() {	public void process(WatchedEvent event) {	if (event.getState() == Event.KeeperState.SyncConnected) {	connSignal.countDown();	} else {	
watchedevent at 

========================= brooklyn sample_434 =========================

public void acquire(Entity caller) {	if (!ownerEntities.add(caller)) {	
entity acquiring permit multiple times with permits available and threads waiting in queue 

public void acquire(Entity caller) {	if (!ownerEntities.add(caller)) {	if (LOG.isDebugEnabled()) {	
entity double acquire call stack call stack for permit double acquire 

========================= brooklyn sample_1396 =========================

public Map<K,V> asImmutableCopy() {	try {	return ImmutableMap.copyOf(this);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error converting list to immutable using unmodifiable instead 

========================= brooklyn sample_2105 =========================

public <T> SubscriptionHandle subscribe(Entity producer, Sensor<T> sensor, Closure c) {	
use of groovy lang closure is deprecated in basicsubscriptioncontext subscribe 

public <T> SubscriptionHandle subscribe(Map<String, ?> newFlags, Entity producer, Sensor<T> sensor, Closure c) {	
use of groovy lang closure is deprecated in basicsubscriptioncontext subscribe 

public <T> SubscriptionHandle subscribeToChildren(Entity parent, Sensor<T> sensor, Closure c) {	
use of groovy lang closure is deprecated in basicsubscriptioncontext subscribetochildren 

public <T> SubscriptionHandle subscribeToChildren(Map<String, Object> newFlags, Entity parent, Sensor<T> sensor, Closure c) {	
use of groovy lang closure is deprecated in basicsubscriptioncontext subscribetochildren 

public <T> SubscriptionHandle subscribeToMembers(Group parent, Sensor<T> sensor, Closure c) {	
use of groovy lang closure is deprecated in basicsubscriptioncontext subscribetomembers 

public <T> SubscriptionHandle subscribeToMembers(Map<String, Object> newFlags, Group parent, Sensor<T> sensor, Closure c) {	
use of groovy lang closure is deprecated in basicsubscriptioncontext subscribetomembers 

public int unsubscribeAll() {	int count = 0;	Set<SubscriptionHandle> subscriptions = getSubscriptions();	Collection<SubscriptionHandle> subscriptionsCopy;	synchronized (subscriptions) {	subscriptionsCopy = ImmutableList.copyOf(subscriptions);	}	for (SubscriptionHandle s : subscriptionsCopy) {	count++;	boolean result = unsubscribe(s);	
when unsubscribing from all of unsubscribe of returned false 

========================= brooklyn sample_1050 =========================

public static Map tabularDataToMap(TabularData table) {	Map<String, Object> result = Maps.newLinkedHashMap();	for (Object entry : table.values()) {	CompositeData data = (CompositeData) entry;	for (String key : data.getCompositeType().keySet()) {	Object old = result.put(key, data.get(key));	if (old != null) {	
tablulardatatomap has overwritten key 

public static Map<String, Object> compositeDataToMap(CompositeData data) {	Map<String, Object> result = Maps.newLinkedHashMap();	for (String key : data.getCompositeType().keySet()) {	Object old = result.put(key, data.get(key));	if (old != null) {	
compositedatatomap has overwritten key 

========================= brooklyn sample_2386 =========================

private List<String> installLinux(List<String> urls, String saveAs) {	
installing using couchbase server 

public DownloadLinkSegmentComputer(@Nullable OsDetails os, boolean isV3OrLater, @Nonnull String context) {	this.os = os;	this.isV3OrLater = isV3OrLater;	this.context = context;	if (os == null) {	
no details known for os of assuming bit rpm distribution of couchbase 

public String getOsTag() {	String family;	if (osName.contains("debian")) family = "debian7_";	else if (osName.contains("ubuntu")) family = "ubuntu12.04_";	else if (osName.contains("centos") || osName.contains("rhel") || (osName.contains("red") && osName.contains("hat"))) family = "centos6.";	else {	
unrecognised os of assuming rpm distribution of couchbase 

public String getOsTag() {	String family;	if (osName.contains("debian")) family = "debian7_";	else if (osName.contains("ubuntu")) family = "ubuntu12.04_";	else if (osName.contains("centos") || osName.contains("rhel") || (osName.contains("red") && osName.contains("hat"))) family = "centos6.";	else {	family = "centos6.";	}	if (!is64bit && !isV3OrLater) {	
bit binaries for couchbase might not be available when deploying 

}	return true;	}	}) .run();	}	}) .build();	Boolean completed = DynamicTasks.queueIfPossible(reBalance) .orSubmitAndBlock() .andWaitForSuccess();	if (completed) {	entity.sensors().set(CouchbaseNode.REBALANCE_STATUS, "completed");	ServiceStateLogic.ServiceNotUpLogic.clearNotUpIndicator(getEntity(), "rebalancing");	
rebalanced cluster via primary node 

}) .run();	}	}) .build();	Boolean completed = DynamicTasks.queueIfPossible(reBalance) .orSubmitAndBlock() .andWaitForSuccess();	if (completed) {	entity.sensors().set(CouchbaseNode.REBALANCE_STATUS, "completed");	ServiceStateLogic.ServiceNotUpLogic.clearNotUpIndicator(getEntity(), "rebalancing");	} else {	entity.sensors().set(CouchbaseNode.REBALANCE_STATUS, "timed out");	ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator(getEntity(), "rebalancing", "rebalance did not complete within time limit");	
timeout rebalancing cluster via primary node 

public void bucketCreate(String bucketName, String bucketType, Integer bucketPort, Integer bucketRamSize, Integer bucketReplica) {	
adding bucket to cluster primary node 

public void addReplicationRule(Entity toCluster, String fromBucket, String toBucket) {	DynamicTasks.queue(DependentConfiguration.attributeWhenReady(toCluster, Attributes.SERVICE_UP)).getUnchecked();	String destName = CouchbaseClusterImpl.getClusterName(toCluster);	
setting up xdcr for from via to 

========================= brooklyn sample_422 =========================

}	List<String> suppliedTokensDefault = EnumerationUtils.toList(request.getHeaders(CSRF_TOKEN_VALUE_HEADER));	List<String> suppliedTokensAngular = EnumerationUtils.toList(request.getHeaders(CSRF_TOKEN_VALUE_HEADER_ANGULAR_NAME));	List<String> suppliedTokens = Lists.newArrayList(suppliedTokensDefault);	suppliedTokens.addAll(suppliedTokensAngular);	Object requiredToken = request.getSession().getAttribute(CSRF_TOKEN_VALUE_ATTR);	CsrfTokenRequiredForRequests whenRequired = (CsrfTokenRequiredForRequests) request.getSession().getAttribute(CSRF_TOKEN_REQUIRED_ATTR);	boolean isRequired;	if (whenRequired==null) {	if (suppliedTokens.isEmpty()) {	
no csrf token expected or supplied but a cookie session is active client should be updated in future csrf tokens or instructions may be required for session based clients 

}	request.getSession().setAttribute(CSRF_TOKEN_REQUIRED_ATTR, whenRequired);	}	switch (whenRequired) {	case NONE: isRequired = false;	break;	case WRITE: isRequired = !org.eclipse.jetty.http.HttpMethod.GET.toString().equals(requestContext.getMethod());	break;	case ALL: isRequired = true;	break;	
unexpected value 

break;	case ALL: isRequired = true;	break;	isRequired = true;	}	if (Iterables.any(suppliedTokens, Predicates.equalTo(requiredToken))) {	return;	}	if (!isRequired) {	if (requiredToken!=null) {	
csrf optional token mismatch client did not send valid token but it isn t required so proceeding 

========================= brooklyn sample_2914 =========================

public void tearDown() throws Exception {	for (MachineLocation machine : machines) {	try {	loc.release(machine);	} catch (Exception e) {	
error releasing machine in location 

protected void assertPasswordIsSecure(String val) {	if (!val.matches(".*[0-9].*")) {	fail("Password '" + val + "' does not contain a digit");	}	if (!val.matches(".*[A-Z].*")) {	fail("Password '" + val + "' does not contain an upper-case letter");	}	if (val.trim().length() < 7) {	fail("Password '" + val + "' is too short");	}	
password passes basic security check 

========================= brooklyn sample_2447 =========================

include = true;	}	if (include) {	args.putStringKey(keyName, config().get(entry.getKey()));	}	}	args.putAll(props);	args.configure(SshTool.PROP_HOST, getAddress().getHostAddress());	args.configure(WinRmTool.USE_NTLM, getConfig(WinRmMachineLocation.USE_NTLM));	args.configure(WinRmTool.PROP_PORT, getPort());	
creating winrm session for 

args.putAll(props);	args.configure(SshTool.PROP_HOST, getAddress().getHostAddress());	args.configure(WinRmTool.USE_NTLM, getConfig(WinRmMachineLocation.USE_NTLM));	args.configure(WinRmTool.PROP_PORT, getPort());	String toolClass = args.get(WINRM_TOOL_CLASS);	if (toolClass == null) toolClass = Winrm4jTool.class.getName();	WinRmTool tool = (WinRmTool) new ClassLoaderUtils(this, getManagementContext()).loadClass(toolClass).getConstructor(Map.class).newInstance(args.getAllConfig());	if (tool instanceof ManagementContextInjectable) {	((ManagementContextInjectable)tool).setManagementContext(getManagementContext());	}	
using ssh tool of type props 

========================= brooklyn sample_2152 =========================

protected long tickerAdvance(Duration duration) {	
sleeping for 

========================= brooklyn sample_619 =========================

private void stopAfter(final Duration time) {	final TestHttpServer serverCached = server;	executor.schedule(new Runnable() {	public void run() {	
stopping server elapsed 

private void startAfter(final Duration time) {	server = initializeServerUnstarted();	server.basePort(Networking.nextAvailablePort(50606));	initVars();	executor.schedule(new Runnable() {	public void run() {	
starting server elapsed 

public void shouldAssertUrlUnreachableEventuallyWithFlags() throws Exception {	String baseUrlOrig = baseUrl;	
testing server 

public void shouldAssertUrlUnreachableEventuallyWithFlags() throws Exception {	String baseUrlOrig = baseUrl;	stopAfter(DELAY_FOR_SERVER_TO_SETTLE);	startAfter(DELAY_FOR_SERVER_TO_SETTLE.add(DELAY_FOR_SERVER_TO_SETTLE).add(DELAY_FOR_SERVER_TO_SETTLE));	
queued server changes 

public void shouldAssertHttpStatusCodeEventuallyEquals() throws Exception {	stopServer();	HttpAsserts.assertUrlUnreachable(simpleEndpoint);	startAfter(DELAY_FOR_SERVER_TO_SETTLE);	try {	HttpAsserts.assertHttpStatusCodeEventuallyEquals(simpleEndpoint, 200);	} catch (Throwable t) {	
failed waiting for simple with start after 

public void shouldAssertHttpStatusCodeEventuallyEquals() throws Exception {	stopServer();	HttpAsserts.assertUrlUnreachable(simpleEndpoint);	startAfter(DELAY_FOR_SERVER_TO_SETTLE);	try {	HttpAsserts.assertHttpStatusCodeEventuallyEquals(simpleEndpoint, 200);	} catch (Throwable t) {	
detail server at looking at 

public void shouldAssertAsyncHttpStatusCodeContinuallyEqualsFails() throws Exception {	stopServer();	ListeningExecutorService listeningExecutor = MoreExecutors.listeningDecorator(executor);	final ListenableFuture<?> future = HttpAsserts.assertAsyncHttpStatusCodeContinuallyEquals(listeningExecutor, testUri("/missing"), 200);	startAfter(DELAY_FOR_SERVER_TO_SETTLE.add(Duration.seconds(1)));	Time.sleep(DELAY_FOR_SERVER_TO_SETTLE);	if (future.isDone()) {	Object result = future.get();	
should have failed instead gave accessing 

public void shouldAssertAsyncHttpStatusCodeContinuallyEqualsFails() throws Exception {	stopServer();	ListeningExecutorService listeningExecutor = MoreExecutors.listeningDecorator(executor);	final ListenableFuture<?> future = HttpAsserts.assertAsyncHttpStatusCodeContinuallyEquals(listeningExecutor, testUri("/missing"), 200);	startAfter(DELAY_FOR_SERVER_TO_SETTLE.add(Duration.seconds(1)));	Time.sleep(DELAY_FOR_SERVER_TO_SETTLE);	if (future.isDone()) {	Object result = future.get();	} else {	
future should have been done 

========================= brooklyn sample_1904 =========================

protected void connectSensors() {	super.connectSensors();	String serverInfoMBeanName = "org.apache.qpid:type=ServerInformation,name=ServerInformation";	jmxFeed = JmxFeed.builder() .entity(this) .period(500, TimeUnit.MILLISECONDS) .pollAttribute(new JmxAttributePollConfig<Boolean>(SERVICE_UP) .objectName(serverInfoMBeanName) .attributeName("ProductVersion") .onSuccess(new Function<Object,Boolean>() {	private boolean hasWarnedOfVersionMismatch;	if (input == null) return false;	if (!hasWarnedOfVersionMismatch && !getConfig(QpidBroker.SUGGESTED_VERSION).equals(input)) {	
qpid version mismatch productversion is requested version is 

========================= brooklyn sample_475 =========================

public void testWithAppPolicy() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-app-with-policy.yaml"));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-app-with-policy");	
app started 

public void testWithEntityPolicy() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-with-policy.yaml"));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-with-policy");	
app started 

========================= brooklyn sample_1705 =========================

public static BrooklynClassLoadingContext getClassLoadingContext(Entity entity) {	ManagementContext mgmt = ((EntityInternal)entity).getManagementContext();	String catId = entity.getCatalogItemId();	if (Strings.isBlank(catId)) return JavaBrooklynClassLoadingContext.create(mgmt);	Maybe<RegisteredType> cat = RegisteredTypes.tryValidate(mgmt.getTypeRegistry().get(catId), RegisteredTypeLoadingContexts.spec(Entity.class));	if (cat.isNull()) {	
cannot load to get classloader for will try with standard loader but might fail subsequently 

if (fi<0) return false;	int li = versionedId.lastIndexOf(VERSION_DELIMITER);	if (li!=fi) {	return false;	}	String candidateVersion = versionedId.substring(li+1);	if (!candidateVersion.matches("[0-9]+(|(\\.|_).*)")) {	return false;	}	if (!RegisteredTypeNaming.isUsableTypeColonVersion(versionedId)) {	
reference is being treated as a versioned type but it contains deprecated characters slashes or whitespace likely to be unsupported in future versions 

}	}	RegisteredType item = managementContext.getTypeRegistry().get(itemId);	if (item != null) {	BrooklynClassLoadingContext itemLoader = newClassLoadingContext(managementContext, item);	loader.add(itemLoader);	didSomething = true;	}	if (!didSomething) {	if (warnIfNotFound) {	
can t find catalog item when searching a search path may be incomplete and other errors may follow 

}	RegisteredType item = managementContext.getTypeRegistry().get(itemId);	if (item != null) {	BrooklynClassLoadingContext itemLoader = newClassLoadingContext(managementContext, item);	loader.add(itemLoader);	didSomething = true;	}	if (!didSomething) {	if (warnIfNotFound) {	} else {	
can t find catalog item when searching ignoring as this can be normal in setup scans but it can also mean a search path may be incomplete and other errors may follow 

========================= brooklyn sample_1355 =========================

public static void setEntitlementContext(EntitlementContext context) {	EntitlementContext oldContext = PerThreadEntitlementContextHolder.perThreadEntitlementsContextHolder.get();	if (oldContext!=null && context!=null) {	
changing entitlement context from to context should have been reset or extended not replaced 

public static void setEntitlementContext(EntitlementContext context) {	EntitlementContext oldContext = PerThreadEntitlementContextHolder.perThreadEntitlementsContextHolder.get();	if (oldContext!=null && context!=null) {	
trace for entitlement context duplicate overwrite trace for entitlement context overwrite 

========================= brooklyn sample_1139 =========================

if (result.code!=null) return ReferenceWithError.newInstanceWithoutError(result);	assert inferredMetadata.isNameResolved() : "Should have resolved "+inferredMetadata;	assert inferredMetadata instanceof BasicManagedBundle : "Only BasicManagedBundles supported";	((BasicManagedBundle)inferredMetadata).setChecksum(getChecksum(new ZipFile(zipFile)));	final boolean updating;	result.metadata = osgiManager.getManagedBundle(inferredMetadata.getVersionedName());	if (result.getMetadata()!=null) {	if (suppliedKnownBundleMetadata!=null && suppliedKnownBundleMetadata.getUrl()!=null) {	String knownIdForThisUrl = osgiManager.managedBundlesRecord.getManagedBundleIdFromUrl(suppliedKnownBundleMetadata.getUrl());	if (knownIdForThisUrl==null) {	
request to install from which is not recognized but appears to match now associating with the latter 

assert inferredMetadata instanceof BasicManagedBundle : "Only BasicManagedBundles supported";	((BasicManagedBundle)inferredMetadata).setChecksum(getChecksum(new ZipFile(zipFile)));	final boolean updating;	result.metadata = osgiManager.getManagedBundle(inferredMetadata.getVersionedName());	if (result.getMetadata()!=null) {	if (suppliedKnownBundleMetadata!=null && suppliedKnownBundleMetadata.getUrl()!=null) {	String knownIdForThisUrl = osgiManager.managedBundlesRecord.getManagedBundleIdFromUrl(suppliedKnownBundleMetadata.getUrl());	if (knownIdForThisUrl==null) {	osgiManager.managedBundlesRecord.setManagedBundleUrl(suppliedKnownBundleMetadata.getUrl(), result.getMetadata().getId());	} else if (!knownIdForThisUrl.equals(result.getMetadata().getId())) {	
request to install from which is associated to but appears to match now associating with the latter 

String knownIdForThisUrl = osgiManager.managedBundlesRecord.getManagedBundleIdFromUrl(suppliedKnownBundleMetadata.getUrl());	if (knownIdForThisUrl==null) {	osgiManager.managedBundlesRecord.setManagedBundleUrl(suppliedKnownBundleMetadata.getUrl(), result.getMetadata().getId());	} else if (!knownIdForThisUrl.equals(result.getMetadata().getId())) {	osgiManager.managedBundlesRecord.setManagedBundleUrl(suppliedKnownBundleMetadata.getUrl(), result.getMetadata().getId());	}	}	if (canUpdate()) {	result.bundle = osgiManager.framework.getBundleContext().getBundle(result.getMetadata().getOsgiUniqueUrl());	if (result.getBundle()==null) {	
brooklyn thought is was already managing bundle but it s not installed to framework reinstalling it 

}	if (canUpdate()) {	result.bundle = osgiManager.framework.getBundleContext().getBundle(result.getMetadata().getOsgiUniqueUrl());	if (result.getBundle()==null) {	updating = false;	} else {	updating = true;	}	} else {	if (result.getMetadata().getChecksum()==null || inferredMetadata.getChecksum()==null) {	
missing bundle checksum data for assuming bundle replacement is permitted 

} else if (!Objects.equal(result.getMetadata().getChecksum(), inferredMetadata.getChecksum())) {	throw new IllegalArgumentException("Bundle "+result.getMetadata().getVersionedName()+" already installed; " + "cannot install a different bundle at a same non-snapshot version");	}	result.setIgnoringAlreadyInstalled();	return ReferenceWithError.newInstanceWithoutError(result);	}	} else {	result.metadata = inferredMetadata;	Maybe<Bundle> b = Osgis.bundleFinder(osgiManager.framework).symbolicName(result.getMetadata().getSymbolicName()).version(result.getMetadata().getSuppliedVersionString()).find();	if (b.isPresent()) {	
brooklyn install of detected already loaded in osgi uninstalling that to reinstall as brooklyn managed 

result.message = "Installed Brooklyn catalog bundle "+result.getMetadata().getVersionedName()+" with ID "+result.getMetadata().getId()+" ["+result.bundle.getBundleId()+"]";	((BasicManagedBundle)result.getMetadata()).setPersistenceNeeded(true);	mgmt().getRebindManager().getChangeListener().onManaged(result.getMetadata());	} else {	oldZipFile = osgiManager.managedBundlesRecord.updateManagedBundleFile(result, zipFile);	result.code = OsgiBundleInstallationResult.ResultCode.UPDATED_EXISTING_BUNDLE;	result.message = "Updated Brooklyn catalog bundle "+result.getMetadata().getVersionedName()+" as existing ID "+result.getMetadata().getId()+" ["+result.bundle.getBundleId()+"]";	((BasicManagedBundle)result.getMetadata()).setPersistenceNeeded(true);	mgmt().getRebindManager().getChangeListener().onChanged(result.getMetadata());	}	
in osgi container 

mgmt().getRebindManager().getChangeListener().onChanged(result.getMetadata());	}	zipFile.delete();	zipFile = null;	Runnable startRunnable = new Runnable() {	private void rollbackBundle() {	if (updating) {	if (oldZipFile==null) {	throw new IllegalStateException("Did not have old ZIP file to install");	}	
rolling back bundle to state from 

private void rollbackBundle() {	if (updating) {	if (oldZipFile==null) {	throw new IllegalStateException("Did not have old ZIP file to install");	}	try {	File zipFileNow = osgiManager.managedBundlesRecord.rollbackManagedBundleFile(result, oldZipFile);	result.bundle.update(new FileInputStream(Preconditions.checkNotNull(zipFileNow, "Couldn't find contents of old version of bundle")));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error rolling back following failed install of updated installation will likely be corrupted and correct version should be manually installed 

}	try {	File zipFileNow = osgiManager.managedBundlesRecord.rollbackManagedBundleFile(result, oldZipFile);	result.bundle.update(new FileInputStream(Preconditions.checkNotNull(zipFileNow, "Couldn't find contents of old version of bundle")));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	}	((BasicManagedBundle)result.getMetadata()).setPersistenceNeeded(true);	mgmt().getRebindManager().getChangeListener().onChanged(result.getMetadata());	} else {	
uninstalling bundle roll back of failed fresh install no previous version to revert to 

mgmt().getRebindManager().getChangeListener().onChanged(result.getMetadata());	} else {	osgiManager.uninstallUploadedBundle(result.getMetadata());	((BasicManagedBundle)result.getMetadata()).setPersistenceNeeded(true);	mgmt().getRebindManager().getChangeListener().onUnmanaged(result.getMetadata());	}	}	public void run() {	if (start) {	try {	
starting bundle 

osgiManager.uninstallUploadedBundle(result.getMetadata());	((BasicManagedBundle)result.getMetadata()).setPersistenceNeeded(true);	mgmt().getRebindManager().getChangeListener().onUnmanaged(result.getMetadata());	}	}	public void run() {	if (start) {	try {	result.bundle.start();	} catch (BundleException e) {	
error starting bundle uninstalling restoring any old bundle then re throwing error 

}	public void run() {	if (start) {	try {	result.bundle.start();	} catch (BundleException e) {	try {	rollbackBundle();	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	
error rolling back after bundle start problem server may be in inconsistent state swallowing this error and propagating installation error 

if (loadCatalogBom) {	Iterable<RegisteredType> itemsFromOldBundle = null;	Map<RegisteredType, RegisteredType> itemsReplacedHere = null;	try {	if (updating) {	itemsFromOldBundle = osgiManager.uninstallCatalogItemsFromBundle( result.getVersionedName() );	}	itemsReplacedHere = MutableMap.of();	osgiManager.loadCatalogBom(result.bundle, force, validateTypes, itemsReplacedHere);	Iterable<RegisteredType> items = mgmt().getTypeRegistry().getMatching(RegisteredTypePredicates.containingBundle(result.getMetadata()));	
adding items from bundle 

if (updating) {	itemsFromOldBundle = osgiManager.uninstallCatalogItemsFromBundle( result.getVersionedName() );	}	itemsReplacedHere = MutableMap.of();	osgiManager.loadCatalogBom(result.bundle, force, validateTypes, itemsReplacedHere);	Iterable<RegisteredType> items = mgmt().getTypeRegistry().getMatching(RegisteredTypePredicates.containingBundle(result.getMetadata()));	for (RegisteredType ci: items) {	result.catalogItemsInstalled.add(ci.getId());	}	} catch (Exception e) {	
error adding brooklyn items from bundle uninstalling restoring any old bundle and items then re throwing error 

osgiManager.loadCatalogBom(result.bundle, force, validateTypes, itemsReplacedHere);	Iterable<RegisteredType> items = mgmt().getTypeRegistry().getMatching(RegisteredTypePredicates.containingBundle(result.getMetadata()));	for (RegisteredType ci: items) {	result.catalogItemsInstalled.add(ci.getId());	}	} catch (Exception e) {	try {	rollbackBundle();	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	
error rolling back after catalog install problem server may be in inconsistent state swallowing this error and propagating installation error 

} catch (Exception e) {	try {	rollbackBundle();	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	throw Exceptions.propagate(new BundleException("Failure loading catalog items, and also failed rolling back; server may be in inconsistent state regarding bundle "+result.getVersionedName()+". " + "Rollback failure ("+Exceptions.collapseText(t)+") detailed in log. Installation error is: "+Exceptions.collapseText(e), e));	}	if (itemsFromOldBundle!=null) {	for (RegisteredType oldItem: itemsFromOldBundle) {	if (log.isTraceEnabled()) {	
restoring replaced bundle item 

}	((BasicBrooklynTypeRegistry)mgmt().getTypeRegistry()).addToLocalUnpersistedTypeRegistry(oldItem, true);	}	}	if (itemsReplacedHere!=null) {	MutableList<RegisteredType> replaced = MutableList.copyOf(itemsReplacedHere.values());	Collections.reverse(replaced);	for (RegisteredType oldItem: replaced) {	if (oldItem!=null) {	if (log.isTraceEnabled()) {	
restoring replaced external item 

}	}	}	throw Exceptions.propagate(e);	}	}	}	};	if (deferredStart) {	result.deferredStart = startRunnable;	
brooklyn load deferred 

}	}	};	if (deferredStart) {	result.deferredStart = startRunnable;	} else {	startRunnable.run();	if (!result.catalogItemsInstalled.isEmpty()) {	final int MAX_TO_LIST_EXPLICITLY = 5;	MutableList<String> firstN = MutableList.copyOf(Iterables.limit(result.catalogItemsInstalled, MAX_TO_LIST_EXPLICITLY));	
items and others total 

}	};	if (deferredStart) {	result.deferredStart = startRunnable;	} else {	startRunnable.run();	if (!result.catalogItemsInstalled.isEmpty()) {	final int MAX_TO_LIST_EXPLICITLY = 5;	MutableList<String> firstN = MutableList.copyOf(Iterables.limit(result.catalogItemsInstalled, MAX_TO_LIST_EXPLICITLY));	if (log.isDebugEnabled() && result.catalogItemsInstalled.size()>MAX_TO_LIST_EXPLICITLY) {	
all items 

if (deferredStart) {	result.deferredStart = startRunnable;	} else {	startRunnable.run();	if (!result.catalogItemsInstalled.isEmpty()) {	final int MAX_TO_LIST_EXPLICITLY = 5;	MutableList<String> firstN = MutableList.copyOf(Iterables.limit(result.catalogItemsInstalled, MAX_TO_LIST_EXPLICITLY));	if (log.isDebugEnabled() && result.catalogItemsInstalled.size()>MAX_TO_LIST_EXPLICITLY) {	}	} else {	
into brooklyn with no catalog items 

========================= brooklyn sample_1093 =========================

public synchronized T obtain(Map flags) throws NoMachinesAvailableException {	if (flags != null && !flags.isEmpty()) {	
flags passed to singlemachineprovisioninglocation obtain will be ignored using 

========================= brooklyn sample_1586 =========================

if (instantiator instanceof AssemblyTemplateSpecInstantiator) {	return ((AssemblyTemplateSpecInstantiator) instantiator).createApplicationSpec(at, camp, loader, MutableSet.<String>of());	} else {	if (at.getPlatformComponentTemplates()==null || at.getPlatformComponentTemplates().isEmpty()) {	if (at.getCustomAttributes().containsKey(BrooklynCampReservedKeys.BROOKLYN_CATALOG)) throw new IllegalArgumentException("Unrecognized application blueprint format: expected an application, not a brooklyn.catalog");	throw new UnsupportedTypePlanException("Unrecognized application blueprint format: no services defined");	}	throw new UnsupportedTypePlanException("Unrecognized application blueprint format");	}	} catch (Exception e) {	
failed to create entity from camp spec 

========================= brooklyn sample_1752 =========================

public void testEntityWithDelayedJmxStartupWillKeepRetrying() {	Thread t = new Thread(new Runnable() {	public void run() {	try {	Thread.sleep(2000);	jmxService = new JmxService("localhost", 40123);	jmxService.registerMBean(ImmutableMap.of(attributeName, "myval"), objectName);	} catch (Exception e) {	
error in testentitywithdelayedjmxstartupwillkeepretrying 

========================= brooklyn sample_2191 =========================

public List<UsageStatistics> listApplicationsUsage(@Nullable String start, @Nullable String end) {	
rest call to get application usage for all applications dates 

public UsageStatistics getApplicationUsage(String application, String start, String end) {	
rest call to get application usage for application dates 

private List<UsageStatistic> retrieveApplicationUsage(ApplicationUsage usage, Date startDate, Date endDate) {	
determining application usage for application dates 

private List<UsageStatistic> retrieveApplicationUsage(ApplicationUsage usage, Date startDate, Date endDate) {	
considering application usage events of 

continue;	}	if (eventStartDate.compareTo(startDate) < 0) {	eventStartDate = startDate;	}	if (eventEndDate.compareTo(endDate) > 0) {	eventEndDate = endDate;	}	long duration = eventEndDate.getTime() - eventStartDate.getTime();	UsageStatistic statistic = new UsageStatistic(ApplicationTransformer.statusFromLifecycle(current.getState()), usage.getApplicationId(), usage.getApplicationId(), format(eventStartDate), format(eventEndDate), duration, usage.getMetadata());	
adding application usage statistic to response for app 

public List<UsageStatistics> listMachinesUsage(final String application, final String start, final String end) {	
rest call to get machine usage for application dates 

public UsageStatistics getMachineUsage(final String machine, final String start, final String end) {	
rest call to get machine usage for machine dates 

private List<UsageStatistic> retrieveMachineUsage(LocationUsage usage, Date startDate, Date endDate) {	
determining machine usage for location 

private List<UsageStatistic> retrieveMachineUsage(LocationUsage usage, Date startDate, Date endDate) {	
considering machine usage events of 

continue;	}	if (eventStartDate.compareTo(startDate) < 0) {	eventStartDate = startDate;	}	if (eventEndDate.compareTo(endDate) > 0) {	eventEndDate = endDate;	}	long duration = eventEndDate.getTime() - eventStartDate.getTime();	UsageStatistic statistic = new UsageStatistic(ApplicationTransformer.statusFromLifecycle(current.getState()), usage.getLocationId(), current.getApplicationId(), format(eventStartDate), format(eventEndDate), duration, usage.getMetadata());	
adding machine usage statistic to response for app 

========================= brooklyn sample_2892 =========================

public void setManagementContext(ManagementContext managementContext) {	
detected injection of 

public <T> T set(ConfigKey<T> key, T val) {	
detected configuration injection for 

protected Entity setupAndCheckTestEntityInBasicYamlWith(String ...extras) throws Exception {	managementContextInjected.set(false);	configKeys.clear();	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", extras));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-basic-template");	
app started 

========================= brooklyn sample_1617 =========================

if (v == null) {	} else if (v instanceof CharSequence) {	} else if (TypeCoercions.isPrimitiveOrBoxer(v.getClass())) {	v = "" + v;	} else {	throw new IllegalArgumentException("cannot convert value " + v + " of type " + v.getClass() + " to string to pass as JVM property; use a post-processor");	}	}	return "-D" + k + (v != null ? "=" + v : "");	} catch (Exception e) {	
error resolving java option key propagating 

protected boolean checkForAndInstallJava(String requiredVersion) {	int requiredJavaMinor = getJavaMinorVersion(requiredVersion);	Optional<String> installedJavaVersion = getInstalledJavaVersion();	if (installedJavaVersion.isPresent()) {	List<String> installedVersionParts = Splitter.on(".").splitToList(installedJavaVersion.get());	int javaMajor = Integer.valueOf(installedVersionParts.get(0));	int javaMinor = Integer.valueOf(installedVersionParts.get(1));	if (javaMajor == 1 && javaMinor >= requiredJavaMinor) {	
java already installed at 

private int getJavaMinorVersion(String requiredVersion){	int requiredJavaMinor;	if (requiredVersion.contains(".")) {	List<String> requiredVersionParts = Splitter.on(".").splitToList(requiredVersion);	requiredJavaMinor = Integer.valueOf(requiredVersionParts.get(1));	} else if (requiredVersion.length() == 1) {	requiredJavaMinor = Integer.valueOf(requiredVersion);	} else {	
java version required is not supported 

private int tryJavaInstall(String version, String command) {	getLocation().acquireMutex("installing", "installing Java at " + getLocation());	try {	
installing java at 

private int tryJavaInstall(String version, String command) {	getLocation().acquireMutex("installing", "installing Java at " + getLocation());	try {	ProcessTaskFactory<Integer> taskFactory = SshTasks.newSshExecTaskFactory(getLocation(), command) .summary("install java ("+version+")") .configure(ShellTool.PROP_EXEC_ASYNC, true);	ProcessTaskWrapper<Integer> installCommand = Entities.submit(getEntity(), taskFactory);	int result = installCommand.get();	if (result != 0) {	
installation of java failed at 

protected Optional<String> getInstalledJavaVersion() {	
checking java version at 

protected Optional<String> getInstalledJavaVersion() {	ProcessTaskWrapper<Integer> versionCommand = Entities.submit(getEntity(), SshTasks.newSshExecTaskFactory( getLocation(), "java -version 2>&1 | grep \" version\" | sed 's/.*\"\\(.*\\).*\"/\\1/'"));	versionCommand.get();	String stdOut = versionCommand.getStdout().trim();	if (!Strings.isBlank(stdOut)) {	
found java version at 

protected Optional<String> getInstalledJavaVersion() {	ProcessTaskWrapper<Integer> versionCommand = Entities.submit(getEntity(), SshTasks.newSshExecTaskFactory( getLocation(), "java -version 2>&1 | grep \" version\" | sed 's/.*\"\\(.*\\).*\"/\\1/'"));	versionCommand.get();	String stdOut = versionCommand.getStdout().trim();	if (!Strings.isBlank(stdOut)) {	return Optional.of(stdOut);	} else {	
found no java installed at 

protected Optional<String> getCurrentJavaVendor() {	
checking java vendor at 

protected Optional<String> getCurrentJavaVendor() {	ProcessTaskWrapper<Integer> versionCommand = Entities.submit(getEntity(), SshTasks.newSshExecTaskFactory( getLocation(), "java -version 2>&1 | awk 'NR==2 {print $1}'"));	versionCommand.get();	String stdOut = versionCommand.getStdout().trim();	if (Strings.isBlank(stdOut)) {	
found no java installed at 

protected Optional<String> getCurrentJavaVendor() {	ProcessTaskWrapper<Integer> versionCommand = Entities.submit(getEntity(), SshTasks.newSshExecTaskFactory( getLocation(), "java -version 2>&1 | awk 'NR==2 {print $1}'"));	versionCommand.get();	String stdOut = versionCommand.getStdout().trim();	if (Strings.isBlank(stdOut)) {	return Optional.absent();	} else if ("Java(TM)".equals(stdOut)) {	
found java version at 

public boolean installJava() {	if (entity instanceof UsesJava) {	String version = entity.getConfig(UsesJava.JAVA_VERSION_REQUIRED);	if (checkForAndInstallJava(version)) return true;	String incrementedVersion = String.valueOf(getJavaMinorVersion(version)+1);	
java install failed trying java 

public boolean installJava() {	if (entity instanceof UsesJava) {	String version = entity.getConfig(UsesJava.JAVA_VERSION_REQUIRED);	if (checkForAndInstallJava(version)) return true;	String incrementedVersion = String.valueOf(getJavaMinorVersion(version)+1);	return checkForAndInstallJava(incrementedVersion);	}	if (checkForAndInstallJava("1.7")) return true;	
java install failed trying java 

public void checkJavaHostnameBug() {	checkNoHostnameBug();	try {	ProcessTaskWrapper<Integer> hostnameTask = DynamicTasks.queue(SshEffectorTasks.ssh("echo FOREMARKER; hostname -f; echo AFTMARKER")).block();	String stdout = Strings.getFragmentBetween(hostnameTask.getStdout(), "FOREMARKER", "AFTMARKER");	if (hostnameTask.getExitCode() == 0 && Strings.isNonBlank(stdout)) {	String hostname = stdout.trim();	Integer len = hostname.length();	if (len > 63) {	String newHostname = "br-"+getEntity().getId().toLowerCase();	
detected likelihood of java hostname bug with hostname length for renaming to hostname 

ProcessTaskWrapper<Integer> hostnameTask = DynamicTasks.queue(SshEffectorTasks.ssh("echo FOREMARKER; hostname -f; echo AFTMARKER")).block();	String stdout = Strings.getFragmentBetween(hostnameTask.getStdout(), "FOREMARKER", "AFTMARKER");	if (hostnameTask.getExitCode() == 0 && Strings.isNonBlank(stdout)) {	String hostname = stdout.trim();	Integer len = hostname.length();	if (len > 63) {	String newHostname = "br-"+getEntity().getId().toLowerCase();	DynamicTasks.queue(SshEffectorTasks.ssh(BashCommands.setHostname(newHostname, null))).block();	}	} else {	
hostname length could not be determined for location not doing java hostname bug check 

String hostname = stdout.trim();	Integer len = hostname.length();	if (len > 63) {	String newHostname = "br-"+getEntity().getId().toLowerCase();	DynamicTasks.queue(SshEffectorTasks.ssh(BashCommands.setHostname(newHostname, null))).block();	}	} else {	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error checking fixing java hostname bug continuing 

========================= brooklyn sample_2312 =========================

if (parametersArray.length == method.getParameterTypes().length) {	try {	return (T) method.invoke(entity, parametersArray);	} catch (Exception e) {	throw Exceptions.propagate(e);	}	}	}	}	String msg = "Could not find method for effector "+getName()+" with "+parametersArray.length+" parameters on "+entity;	
throwing available methods are 

========================= brooklyn sample_1181 =========================

app.start(ImmutableList.of(targetLocation));	Entities.submit(psql, SshEffectorTasks.ssh("ps aux | grep [p]ostgres").requiringExitCodeZero());	SshMachineLocation targetMachine = EffectorTasks.getSshMachine(psql);	psql.stop();	try {	ProcessTaskWrapper<Integer> t = Entities.submit(app, SshEffectorTasks.ssh("ps aux | grep [p]ostgres").machine(targetMachine).allowingNonZeroExitCode());	t.getTask().blockUntilEnded(Duration.TEN_SECONDS);	if (!t.isDone()) Assert.fail("Task not finished yet: "+t.getTask());	Assert.assertNotEquals(t.get(), 0, "Task ended with code "+t.get()+"; output: "+t.getStdout() );	} catch (Exception e) {	
machine destroyed on stop expected 

public void testPostgresScriptAndAccess() throws Exception {	ChefLiveTestSupport.installBrooklynChefHostedConfig(app);	PortRange randomPort = PortRanges.fromString(String.format("%d+", 5420 + new Random().nextInt(10)));	psql = app.createAndManageChild(PostgreSqlSpecs.specChef() .configure(DatastoreCommon.CREATION_SCRIPT_CONTENTS, PostgreSqlIntegrationTest.CREATION_SCRIPT) .configure(PostgreSqlNode.POSTGRESQL_PORT, randomPort) .configure(PostgreSqlNode.SHARED_MEMORY, "8MB") );	app.start(ImmutableList.of(targetLocation));	String url = psql.getAttribute(DatastoreCommon.DATASTORE_URL);	
trying to connect to at 

========================= brooklyn sample_53 =========================

public void tearDown() throws Exception {	try {	List<Exception> exceptions = Lists.newArrayList();	for (ManagementContext mgmt : mgmts) {	try {	if (mgmt.isRunning()) Entities.destroyAll(mgmt);	} catch (Exception e) {	
error destroying management context 

========================= brooklyn sample_2492 =========================

public void onCallback(String childId, boolean success) {	Optional<Entity> child = Iterables.tryFind(getChildren(), EntityPredicates.idEqualTo(childId));	if (child.isPresent()) {	((AsyncEntity)child.get()).onCallback(success);	} else {	
child not found with resourceid not injecting state from callback 

========================= brooklyn sample_789 =========================

public <T> Class<? extends T> getType(@Nonnull Class<T> type) {	try {	return getClassLoadingContext().loadClass(getTypeName().get(), type);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to resolve rethrowing in spec 

========================= brooklyn sample_1744 =========================

protected synchronized void setApplication(Application app) {	if (app.getId().equals(getId())) {	application = getProxy()!=null ? (Application)getProxy() : app;	} else {	application = app;	if (getParent()==null) {	
setting application of to but is not parented 

protected synchronized void setApplication(Application app) {	if (app.getId().equals(getId())) {	application = getProxy()!=null ? (Application)getProxy() : app;	} else {	application = app;	if (getParent()==null) {	} else if (getParent().getApplicationId().equals(app.getParent())) {	
setting application of to but parent has different app 

public void stop() {	logApplicationLifecycle("Stopping");	setExpectedStateAndRecordLifecycleEvent(Lifecycle.STOPPING);	ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator(this, Attributes.SERVICE_STATE_ACTUAL, "Application stopping");	sensors().set(SERVICE_UP, false);	try {	doStop();	} catch (Exception e) {	setExpectedStateAndRecordLifecycleEvent(Lifecycle.ON_FIRE);	
error stopping application rethrowing 

protected void recordApplicationEvent(Lifecycle state) {	try {	((ManagementContextInternal)getManagementContext()).getUsageManager().recordApplicationEvent(this, state);	} catch (RuntimeInterruptedException e) {	throw e;	} catch (RuntimeException e) {	if (getManagementContext().isRunning()) {	
problem recording application event for 

========================= brooklyn sample_1251 =========================

private void checkValidArchive(String url, long minSize) {	byte[] bytes;	try {	bytes = Streams.readFullyAndClose(ResourceUtils.create(this).getResourceFromUrl(url));	
read bytes from for 

private void checkValidArchive(String url, long minSize) {	byte[] bytes;	try {	bytes = Streams.readFullyAndClose(ResourceUtils.create(this).getResourceFromUrl(url));	} catch (Exception e) {	
unable to read url for this test may require hosted sonatype mavencentral repo to be populated 

========================= brooklyn sample_2187 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof AWSEC2TemplateOptions) {	((AWSEC2TemplateOptions) t).subnetId((String) v);	} else {	if (isGoogleComputeTemplateOptions(t)) {	} else if (t instanceof SoftLayerTemplateOptions) {	
networkname is not be supported in softlayer use templateoptions with primarynetworkcomponentnetworkvlanid or primarynetworkbackendcomponentnetworkvlanid 

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof AWSEC2TemplateOptions) {	((AWSEC2TemplateOptions) t).subnetId((String) v);	} else {	if (isGoogleComputeTemplateOptions(t)) {	} else if (t instanceof SoftLayerTemplateOptions) {	} else if (!(t instanceof CloudStackTemplateOptions) && !(t instanceof NovaTemplateOptions)) {	
networkname is experimental in many jclouds endpoints may not be supported in this cloud 

========================= brooklyn sample_2611 =========================

public <T> T setAttribute(AttributeSensor<T> attribute, T val) {	
mocks item setting to 

public void moveNonEffector(Entity rawDestination) {	
mocks moving item from to 

public void stop() {	
mocks stopping item was in container 

========================= brooklyn sample_3000 =========================

public void customize() {	Preconditions.checkState(Strings.isNonBlank(getManagementUsername()), "User for management realm required");	String managementPassword = getManagementPassword();	if (Strings.isBlank(managementPassword)) {	
has no password specified for using a random string 

========================= brooklyn sample_224 =========================

public void onEvent(SensorEvent<Duration> event) {	synchronized (eventLock) {	if (!config().get(FIRED_STOP)) {	if (config().get(LIFETIME).subtract(event.getValue()).isNegative()) {	
stopping lifetime has expired 

========================= brooklyn sample_3057 =========================

protected void renameServerToPublicHostname() {	URI apiUri = null;	try {	HostAndPort accessible = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, getAttribute(COUCHBASE_WEB_ADMIN_PORT));	apiUri = URI.create(String.format("http: UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(getConfig(COUCHBASE_ADMIN_USERNAME), getConfig(COUCHBASE_ADMIN_PASSWORD));	HttpToolResponse response = HttpTool.httpPost( HttpTool.httpClientBuilder().uri(apiUri).credentials(credentials).build(), apiUri, MutableMap.of( HttpHeaders.CONTENT_TYPE, MediaType.FORM_DATA.toString(), HttpHeaders.ACCEPT, "*/*", HttpHeaders.AUTHORIZATION, HttpTool.toBasicAuthorizationValue(credentials)), Charsets.UTF_8.encode("hostname="+Urls.encode(accessible.getHostText())).array());	
renamed couchbase server via 

protected void renameServerToPublicHostname() {	URI apiUri = null;	try {	HostAndPort accessible = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, getAttribute(COUCHBASE_WEB_ADMIN_PORT));	apiUri = URI.create(String.format("http: UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(getConfig(COUCHBASE_ADMIN_USERNAME), getConfig(COUCHBASE_ADMIN_PASSWORD));	HttpToolResponse response = HttpTool.httpPost( HttpTool.httpClientBuilder().uri(apiUri).credentials(credentials).build(), apiUri, MutableMap.of( HttpHeaders.CONTENT_TYPE, MediaType.FORM_DATA.toString(), HttpHeaders.ACCEPT, "*/*", HttpHeaders.AUTHORIZATION, HttpTool.toBasicAuthorizationValue(credentials)), Charsets.UTF_8.encode("hostname="+Urls.encode(accessible.getHostText())).array());	if (!HttpTool.isStatusCodeHealthy(response.getResponseCode())) {	
invalid response code renaming 

protected void renameServerToPublicHostname() {	URI apiUri = null;	try {	HostAndPort accessible = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, getAttribute(COUCHBASE_WEB_ADMIN_PORT));	apiUri = URI.create(String.format("http: UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(getConfig(COUCHBASE_ADMIN_USERNAME), getConfig(COUCHBASE_ADMIN_PASSWORD));	HttpToolResponse response = HttpTool.httpPost( HttpTool.httpClientBuilder().uri(apiUri).credentials(credentials).build(), apiUri, MutableMap.of( HttpHeaders.CONTENT_TYPE, MediaType.FORM_DATA.toString(), HttpHeaders.ACCEPT, "*/*", HttpHeaders.AUTHORIZATION, HttpTool.toBasicAuthorizationValue(credentials)), Charsets.UTF_8.encode("hostname="+Urls.encode(accessible.getHostText())).array());	if (!HttpTool.isStatusCodeHealthy(response.getResponseCode())) {	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error renaming server using 

========================= brooklyn sample_419 =========================

public void addSecondary(BrooklynClassLoadingContext target) {	if (!(target instanceof JavaBrooklynClassLoadingContext)) {	
only java classloaders should be secondary 

========================= brooklyn sample_1084 =========================

private LoadingCache<Map<String, ?>, Pool<SshTool>> buildSshToolPoolCacheLoader() {	Duration expiryDuration = getConfig(SSH_CACHE_EXPIRY_DURATION);	LoadingCache<Map<String, ?>, Pool<SshTool>> delegate = CacheBuilder.newBuilder() .maximumSize(10) .expireAfterAccess(expiryDuration.toMilliseconds(), TimeUnit.MILLISECONDS) .recordStats() .removalListener(new RemovalListener<Map<String, ?>, Pool<SshTool>>() {	public void onRemoval(RemovalNotification<Map<String, ?>, Pool<SshTool>> notification) {	Pool<SshTool> removed = notification.getValue();	if (removed == null) {	if (LOG.isDebugEnabled()) {	
pool evicted from sshtool cache is null so we can t call pool close it s probably already been garbage collected eviction cause 

private LoadingCache<Map<String, ?>, Pool<SshTool>> buildSshToolPoolCacheLoader() {	Duration expiryDuration = getConfig(SSH_CACHE_EXPIRY_DURATION);	LoadingCache<Map<String, ?>, Pool<SshTool>> delegate = CacheBuilder.newBuilder() .maximumSize(10) .expireAfterAccess(expiryDuration.toMilliseconds(), TimeUnit.MILLISECONDS) .recordStats() .removalListener(new RemovalListener<Map<String, ?>, Pool<SshTool>>() {	public void onRemoval(RemovalNotification<Map<String, ?>, Pool<SshTool>> notification) {	Pool<SshTool> removed = notification.getValue();	if (removed == null) {	if (LOG.isDebugEnabled()) {	}	} else {	if (LOG.isDebugEnabled()) {	
evicted from sshtool cache eviction cause 

if (removed == null) {	if (LOG.isDebugEnabled()) {	}	} else {	if (LOG.isDebugEnabled()) {	}	try {	removed.close();	} catch (IOException e) {	if (LOG.isDebugEnabled()) {	
exception closing 

removed.close();	} catch (IOException e) {	if (LOG.isDebugEnabled()) {	}	}	}	}	}) .build(new CacheLoader<Map<String, ?>, Pool<SshTool>>() {	public Pool<SshTool> load(Map<String, ?> properties) {	if (LOG.isDebugEnabled()) {	
building ssh pool for with properties 

protected void addSshPoolCacheCleanupTask() {	if (cleanupTask!=null && !cleanupTask.isDone()) {	return;	}	if (getManagementContext()==null || getManagementContext().getExecutionManager()==null) {	
no management context for ssh pool cache will only be closed when machine is closed 

protected void addSshPoolCacheCleanupTask() {	if (cleanupTask!=null && !cleanupTask.isDone()) {	return;	}	if (getManagementContext()==null || getManagementContext().getExecutionManager()==null) {	return;	}	if (Boolean.TRUE.equals(config().get(LocalLocationManager.CREATE_UNMANAGED))) {	
create unmanaged for no explicit cleanup task ssh pool cache will only be closed when machine is closed 

LoadingCache<Map<String, ?>, Pool<SshTool>> sshPoolCacheOrNullRef = sshPoolCacheOrNull;	Task<?> cleanupTaskRef = cleanupTask;	if (sshPoolCacheOrNullRef != null) sshPoolCacheOrNullRef.cleanUp();	if (!SshMachineLocation.this.isManaged()) {	if (sshPoolCacheOrNullRef != null) sshPoolCacheOrNullRef.invalidateAll();	if (cleanupTaskRef != null) cleanupTaskRef.cancel(false);	sshPoolCacheOrNull = null;	}	return null;	} catch (Exception e) {	
problem cleaning up ssh pool cache 

if (sshPoolCacheOrNullRef != null) sshPoolCacheOrNullRef.cleanUp();	if (!SshMachineLocation.this.isManaged()) {	if (sshPoolCacheOrNullRef != null) sshPoolCacheOrNullRef.invalidateAll();	if (cleanupTaskRef != null) cleanupTaskRef.cancel(false);	sshPoolCacheOrNull = null;	}	return null;	} catch (Exception e) {	return null;	} catch (Throwable t) {	
problem cleaning up ssh pool cache rethrowing 

public void close() throws IOException {	LoadingCache<Map<String, ?>, Pool<SshTool>> sshPoolCacheOrNullRef = sshPoolCacheOrNull;	Task<?> cleanupTaskRef = cleanupTask;	if (sshPoolCacheOrNullRef != null) {	if (LOG.isDebugEnabled()) {	
invalidating all entries in ssh pool cache final stats 

public String getUser() {	if (!groovyTruth(user)) {	if (config().getLocalRaw(SshTool.PROP_USER).isPresent()) {	
user configuration for set after deployment deprecated behaviour may not be supported in future versions 

protected <T> T execSsh(final Map<String, ?> props, final Function<ShellTool, T> task) {	final LoadingCache<Map<String, ?>, Pool<SshTool>> sshPoolCache = getSshPoolCache();	Pool<SshTool> pool = sshPoolCache.getUnchecked(props);	if (LOG.isTraceEnabled()) {	
execssh got pool 

protected <T> T execSsh(final Map<String, ?> props, final Function<ShellTool, T> task) {	final LoadingCache<Map<String, ?>, Pool<SshTool>> sshPoolCache = getSshPoolCache();	Pool<SshTool> pool = sshPoolCache.getUnchecked(props);	if (LOG.isTraceEnabled()) {	}	if (groovyTruth(props.get(CLOSE_CONNECTION.getName()))) {	Function<SshTool, T> close = new Function<SshTool, T>() {	public T apply(SshTool input) {	T result = task.apply(input);	if (LOG.isDebugEnabled()) {	
invalidating all sshpoolcache entries 

include = true;	}	if (ALL_SSH_CONFIG_KEY_NAMES.contains(keyName)) {	include = true;	}	if (include) {	args.putStringKey(keyName, config().get(entry.getKey()));	}	}	args.putAll(props);	
creating ssh session for 

}	if (ALL_SSH_CONFIG_KEY_NAMES.contains(keyName)) {	include = true;	}	if (include) {	args.putStringKey(keyName, config().get(entry.getKey()));	}	}	args.putAll(props);	if (!user.equals(args.get(SshTool.PROP_USER))) {	
user mismatch configuring ssh for preferring user over 

sshToolClass = legacySshToolClass;	msg = "Using deprecated config "+SshTool.PROP_TOOL_CLASS.getName()+"="+legacySshToolClass +", preferring "+SSH_TOOL_CLASS.getName()+"="+sshToolClass+" for "+SshMachineLocation.this;	}	if (!loggedLegcySshToolClassConfig) {	LOG.warn(msg);	loggedLegcySshToolClassConfig = true;	}	}	if (sshToolClass==null) sshToolClass = SshjTool.class.getName();	SshTool ssh = (SshTool) new ClassLoaderUtils(this, getManagementContext()).loadClass(sshToolClass).getConstructor(Map.class).newInstance(args.getAllConfig());	
using ssh tool of type props 

public int installTo(ResourceUtils utils, Map<String,?> props, String url, String destPath) {	
installing to on attempting remote curl 

try {	PipedInputStream insO = new PipedInputStream(); OutputStream outO = new PipedOutputStream(insO);	PipedInputStream insE = new PipedInputStream(); OutputStream outE = new PipedOutputStream(insE);	StreamGobbler sgsO = new StreamGobbler(insO, null, LOG); sgsO.setLogPrefix("[curl @ "+address+":stdout] ").start();	StreamGobbler sgsE = new StreamGobbler(insE, null, LOG); sgsE.setLogPrefix("[curl @ "+address+":stdout] ").start();	Map<String, ?> sshProps = MutableMap.<String, Object>builder().putAll(props).put("out", outO).put("err", outE).build();	int result = execScript(sshProps, "copying remote resource "+url+" to server",  ImmutableList.of( BashCommands.INSTALL_CURL, "mkdir -p `dirname '"+destPath+"'`", "curl "+url+" -L --silent --insecure --show-error --fail --connect-timeout 60 --max-time 600 --retry 5 -o '"+destPath+"'"));	sgsO.close();	sgsE.close();	if (result != 0) {	
installing to on curl failed attempting local fetch and copy 

try {	Tasks.setBlockingDetails("retrieving resource "+url+" for copying across");	InputStream stream = utils.getResourceFromUrl(url);	Tasks.setBlockingDetails("copying resource "+url+" to server");	result = copyTo(props, stream, destPath);	} finally {	Tasks.setBlockingDetails(null);	}	}	if (result == 0) {	
installing complete on 

Tasks.setBlockingDetails("retrieving resource "+url+" for copying across");	InputStream stream = utils.getResourceFromUrl(url);	Tasks.setBlockingDetails("copying resource "+url+" to server");	result = copyTo(props, stream, destPath);	} finally {	Tasks.setBlockingDetails(null);	}	}	if (result == 0) {	} else {	
installing failed on 

public int obtainPort(PortRange range) {	synchronized (usedPorts) {	for (int p: range) if (obtainSpecificPort(p)) return p;	
unable to find port in on returning 

public boolean isSshable() {	String cmd = "date";	try {	try {	Socket s = new Socket();	s.connect(new InetSocketAddress(getAddress(), getPort()), SSHABLE_CONNECT_TIMEOUT);	s.close();	} catch (IOException e) {	
not yet reachable socket 

Socket s = new Socket();	s.connect(new InetSocketAddress(getAddress(), getPort()), SSHABLE_CONNECT_TIMEOUT);	s.close();	} catch (IOException e) {	return false;	}	int result = execCommands(MutableMap.<String,Object>of(), "isSshable", ImmutableList.of(cmd));	if (result == 0) {	return true;	} else {	
not reachable executing exit code 

} catch (IOException e) {	return false;	}	int result = execCommands(MutableMap.<String,Object>of(), "isSshable", ImmutableList.of(cmd));	if (result == 0) {	return true;	} else {	return false;	}	} catch (SshException e) {	
exception checking if is reachable assuming not 

}	int result = execCommands(MutableMap.<String,Object>of(), "isSshable", ImmutableList.of(cmd));	if (result == 0) {	return true;	} else {	return false;	}	} catch (SshException e) {	return false;	} catch (IllegalStateException e) {	
exception checking if is reachable assuming not 

return true;	} else {	return false;	}	} catch (SshException e) {	return false;	} catch (IllegalStateException e) {	return false;	} catch (RuntimeException e) {	if (Exceptions.getFirstThrowableOfType(e, IOException.class) != null) {	
exception checking if is reachable assuming not 

========================= brooklyn sample_1591 =========================

try {	Set<ItemType> items = model.getItems();	Map<ItemType, Map<Location, Double>> directSendsToItemByLocation = model.getDirectSendsToItemByLocation();	for (ItemType item : items) {	String itemName = model.getName(item);	Location activeLocation = model.getItemLocation(item);	ContainerType activeContainer = model.getItemContainer(item);	Map<Location, Double> sendsByLocation = directSendsToItemByLocation.get(item);	if (sendsByLocation == null) sendsByLocation = Collections.emptyMap();	if (parameters.excludedLocations.contains(activeLocation)) {	
ignoring segment as it is in 

for (ItemType item : items) {	String itemName = model.getName(item);	Location activeLocation = model.getItemLocation(item);	ContainerType activeContainer = model.getItemContainer(item);	Map<Location, Double> sendsByLocation = directSendsToItemByLocation.get(item);	if (sendsByLocation == null) sendsByLocation = Collections.emptyMap();	if (parameters.excludedLocations.contains(activeLocation)) {	continue;	}	if (!model.isItemMoveable(item)) {	
policy skipping any migration of it is not moveable 

ContainerType activeContainer = model.getItemContainer(item);	Map<Location, Double> sendsByLocation = directSendsToItemByLocation.get(item);	if (sendsByLocation == null) sendsByLocation = Collections.emptyMap();	if (parameters.excludedLocations.contains(activeLocation)) {	continue;	}	if (!model.isItemMoveable(item)) {	continue;	}	if (model.hasActiveMigration(item)) {	
policy skipping any migration of it is involved in an active migration already 

if (parameters.excludedLocations.contains(activeLocation)) {	continue;	}	if (!model.isItemMoveable(item)) {	continue;	}	if (model.hasActiveMigration(item)) {	continue;	}	double total = DefaultFollowTheSunModel.sum(sendsByLocation.values());	
policy detected msgs sec in split up as 

while (!locationsWtd.isEmpty()) {	WeightedObject<Location> weightedObject = locationsWtd.remove(0);	highestMsgRate = weightedObject.getWeight();	highestLocation = weightedObject.getObject();	optimalContainerInHighest = findOptimal(model.getAvailableContainersFor(item, highestLocation));	if (optimalContainerInHighest != null) {	break;	}	}	if (optimalContainerInHighest == null) {	
policy detected is already in optimal permitted location of msgs sec 

Location nextHighestLocation = weightedObject.getObject();	optimalContainerInNextHighest = findOptimal(model.getAvailableContainersFor(item, nextHighestLocation));	if (optimalContainerInNextHighest != null) {	break;	}	}	if (optimalContainerInNextHighest == null) {	nextHighestMsgRate = current;	}	if (parameters.isTriggered(highestMsgRate, total, nextHighestMsgRate, current)) {	
policy detected should be in location on of msgs sec migrating 

if (optimalContainerInNextHighest != null) {	break;	}	}	if (optimalContainerInNextHighest == null) {	nextHighestMsgRate = current;	}	if (parameters.isTriggered(highestMsgRate, total, nextHighestMsgRate, current)) {	try {	if (activeContainer.equals(optimalContainerInHighest)) {	
policy detected should move to of msgs sec but it is already there with msgs sec 

nextHighestMsgRate = current;	}	if (parameters.isTriggered(highestMsgRate, total, nextHighestMsgRate, current)) {	try {	if (activeContainer.equals(optimalContainerInHighest)) {	} else {	item.move(optimalContainerInHighest);	model.onItemMoved(item, optimalContainerInHighest);	}	} catch (Exception e) {	
policy detected should be on but can t move it 

if (parameters.isTriggered(highestMsgRate, total, nextHighestMsgRate, current)) {	try {	if (activeContainer.equals(optimalContainerInHighest)) {	} else {	item.move(optimalContainerInHighest);	model.onItemMoved(item, optimalContainerInHighest);	}	} catch (Exception e) {	}	} else {	
policy detected need not move to of msgs sec not much better than at 

} else {	item.move(optimalContainerInHighest);	model.onItemMoved(item, optimalContainerInHighest);	}	} catch (Exception e) {	}	} else {	}	}	} catch (Exception e) {	
error in policy ignoring 

========================= brooklyn sample_3056 =========================

DynamicTasks.queue( SshEffectorTasks.ssh( "mkdir "+dir(entity), "cd "+dir(entity), BashCommands.downloadToStdout(downloadUrl(entity, isLocalhost(machineS)))+" | tar xvz" ).summary("download mysql").returning(SshTasks.returningStdoutLoggingInfo(log, true)));	if (isLinux(machineS)) {	DynamicTasks.queue(SshEffectorTasks.ssh(BashCommands.installPackage("libaio1")));	}	DynamicTasks.queue( SshEffectorTasks.put(".my.cnf") .contents(String.format("[mysqld]\nbasedir=%s/%s\n", dir(entity), installDir(entity, isLocalhost(machineS)))), SshEffectorTasks.ssh( "cd "+dir(entity)+"/*", "./scripts/mysql_install_db", "./support-files/mysql.server start > out.log 2> err.log < /dev/null" ).summary("setup and run mysql").returning(SshTasks.returningStdoutLoggingInfo(log, true)));	return "submitted start";	}	protected void postStartCustom() {	Time.sleep(Duration.FIVE_SECONDS);	if (!DynamicTasks.queue(SshEffectorTasks.isPidFromFileRunning(dir(entity)+"/*/data/*.pid")).get()) {	
mysql did not start 

if (isLinux(machineS)) {	DynamicTasks.queue(SshEffectorTasks.ssh(BashCommands.installPackage("libaio1")));	}	DynamicTasks.queue( SshEffectorTasks.put(".my.cnf") .contents(String.format("[mysqld]\nbasedir=%s/%s\n", dir(entity), installDir(entity, isLocalhost(machineS)))), SshEffectorTasks.ssh( "cd "+dir(entity)+"/*", "./scripts/mysql_install_db", "./support-files/mysql.server start > out.log 2> err.log < /dev/null" ).summary("setup and run mysql").returning(SshTasks.returningStdoutLoggingInfo(log, true)));	return "submitted start";	}	protected void postStartCustom() {	Time.sleep(Duration.FIVE_SECONDS);	if (!DynamicTasks.queue(SshEffectorTasks.isPidFromFileRunning(dir(entity)+"/*/data/*.pid")).get()) {	ProcessTaskWrapper<Integer> info = DynamicTasks.queue(SshEffectorTasks.ssh( "cd "+dir(entity)+"/*", "cat out.log", "cat err.log > /dev/stderr")).block();	
stdout 

if (isLinux(machineS)) {	DynamicTasks.queue(SshEffectorTasks.ssh(BashCommands.installPackage("libaio1")));	}	DynamicTasks.queue( SshEffectorTasks.put(".my.cnf") .contents(String.format("[mysqld]\nbasedir=%s/%s\n", dir(entity), installDir(entity, isLocalhost(machineS)))), SshEffectorTasks.ssh( "cd "+dir(entity)+"/*", "./scripts/mysql_install_db", "./support-files/mysql.server start > out.log 2> err.log < /dev/null" ).summary("setup and run mysql").returning(SshTasks.returningStdoutLoggingInfo(log, true)));	return "submitted start";	}	protected void postStartCustom() {	Time.sleep(Duration.FIVE_SECONDS);	if (!DynamicTasks.queue(SshEffectorTasks.isPidFromFileRunning(dir(entity)+"/*/data/*.pid")).get()) {	ProcessTaskWrapper<Integer> info = DynamicTasks.queue(SshEffectorTasks.ssh( "cd "+dir(entity)+"/*", "cat out.log", "cat err.log > /dev/stderr")).block();	
stderr 

throw new IllegalStateException("MySQL appears not to be running");	}	entity().sensors().set(Attributes.PID, Integer.parseInt(DynamicTasks.queue(SshEffectorTasks.ssh("cat "+dir(entity)+"/*/data/*.pid")).block().getStdout().trim()));	entity().sensors().set(Attributes.SERVICE_UP, true);	super.postStartCustom();	}	protected String stopProcessesAtMachine() {	entity().sensors().set(Attributes.SERVICE_UP, false);	Integer pid = entity().getAttribute(Attributes.PID);	if (pid==null) {	
mysql not running 

========================= brooklyn sample_2217 =========================

File tmpWarFile = Os.writeToTempFile( ResourceUtils.create(this).getResourceFromUrl(ROOT_WAR_URL), "TestHttpService", ".war");	WebAppContext context = new WebAppContext();	context.setWar(tmpWarFile.getAbsolutePath());	context.setContextPath("/");	context.setParentLoaderPriority(true);	if (securityHandler.isPresent()) {	context.setSecurityHandler(securityHandler.get());	}	server.setHandler(context);	server.start();	
started test httpservice at 

context.setParentLoaderPriority(true);	if (securityHandler.isPresent()) {	context.setSecurityHandler(securityHandler.get());	}	server.setHandler(context);	server.start();	} catch (Exception e) {	try {	shutdown();	} catch (Exception e2) {	
error shutting down httpservice while recovering from earlier error re throwing earlier error 

public void shutdown() throws Exception {	if (server==null) return;	if (shutdownHook != null) Threads.removeShutdownHook(shutdownHook);	String url = getUrl();	
stopping test httpservice at 

public void shutdown() throws Exception {	if (server==null) return;	if (shutdownHook != null) Threads.removeShutdownHook(shutdownHook);	String url = getUrl();	server.stop();	try {	server.join();	} catch (Exception e) {	}	LocalhostMachineProvisioningLocation.releasePort(addr, actualPort);	
stopped test httpservice at 

private void addShutdownHook() {	shutdownHook = Threads.addShutdownHook(new Runnable() {	public void run() {	
test httpservice detected shut down stopping 

private void addShutdownHook() {	shutdownHook = Threads.addShutdownHook(new Runnable() {	public void run() {	try {	shutdown();	} catch (Exception e) {	
failure shutting down web console 

========================= brooklyn sample_730 =========================

if (sg==null) {	org.jclouds.domain.Location sgLoc = null;	try {	sg = sgExt.createSecurityGroup(getName(), sgLoc);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	sg = findSecurityGroupWithName(sgExt, getName());	if (sg==null) {	throw Exceptions.propagate(e);	} else {	
looks like parallel thread created security group ignoring error in our thread as we now have an sg 

protected void applyOldEc2(AWSEC2Api client) {	String region = location.getConfig(JcloudsLocationConfig.CLOUD_REGION_ID);	if (region==null) {	
no region set for assuming 

String id = null;	if (groups.isEmpty()) {	try {	id = client.getSecurityGroupApi().get().createSecurityGroupInRegionAndReturnId(region , getName(), "Brooklyn-managed security group "+getName());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	groups = client.getSecurityGroupApi().get().describeSecurityGroupsInRegion(region, getName());	if (groups.isEmpty()) {	throw Exceptions.propagate(e);	} else {	
looks like parallel thread created security group ignoring error in our thread as we now have an sg 

} catch (Exception e) {	Exceptions.propagateIfFatal(e);	groups = client.getSecurityGroupApi().get().describeSecurityGroupsInRegion(region, getName());	if (groups.isEmpty()) {	throw Exceptions.propagate(e);	} else {	}	}	}	if (!groups.isEmpty()) {	
multiple security groups matching using the first 

========================= brooklyn sample_2581 =========================

public void setUp() throws Exception {	super.setUp();	
in abstractloadbalancingpolicytest before 

protected MockContainerEntity newAsyncContainer(TestApplication app, String name, double lowThreshold, double highThreshold, long delay) {	MockContainerEntity container = app.createAndManageChild(EntitySpec.create(MockContainerEntity.class) .displayName(name) .configure(MockContainerEntity.DELAY, delay) .configure(LOW_THRESHOLD_CONFIG_KEY, lowThreshold) .configure(HIGH_THRESHOLD_CONFIG_KEY, highThreshold));	
managed new container 

protected static MockItemEntity newItem(TestApplication app, MockContainerEntity container, String name, double workrate) {	MockItemEntity item = app.createAndManageChild(EntitySpec.create(MockItemEntity.class) .displayName(name));	
managing new item on container 

protected static MockItemEntity newLockedItem(TestApplication app, MockContainerEntity container, String name, double workrate) {	MockItemEntity item = app.createAndManageChild(EntitySpec.create(MockItemEntity.class) .displayName(name) .configure(Movable.IMMOVABLE, true));	
managed new item on container 

========================= brooklyn sample_3001 =========================

public void test_localhost() throws Exception {	PostgreSqlNode pgsql = app.createAndManageChild(EntitySpec.create(PostgreSqlNode.class) .configure(DatastoreCommon.CREATION_SCRIPT_CONTENTS, CREATION_SCRIPT) .configure(PostgreSqlNode.MAX_CONNECTIONS, 10) .configure(PostgreSqlNode.SHARED_MEMORY, "512kB"));	app.start(ImmutableList.of(loc));	String url = pgsql.getAttribute(DatastoreCommon.DATASTORE_URL);	
postgresql started on 

public void test_localhost() throws Exception {	PostgreSqlNode pgsql = app.createAndManageChild(EntitySpec.create(PostgreSqlNode.class) .configure(DatastoreCommon.CREATION_SCRIPT_CONTENTS, CREATION_SCRIPT) .configure(PostgreSqlNode.MAX_CONNECTIONS, 10) .configure(PostgreSqlNode.SHARED_MEMORY, "512kB"));	app.start(ImmutableList.of(loc));	String url = pgsql.getAttribute(DatastoreCommon.DATASTORE_URL);	new VogellaExampleAccess("org.postgresql.Driver", url).readModifyAndRevertDataBase();	
ran vogella postgresql example success 

public void test_localhost_initialisingDb() throws Exception {	PostgreSqlNode pgsql = app.createAndManageChild(EntitySpec.create(PostgreSqlNode.class) .configure(DatastoreCommon.CREATION_SCRIPT_CONTENTS, CREATION_SCRIPT) .configure(PostgreSqlNode.MAX_CONNECTIONS, 10) .configure(PostgreSqlNode.SHARED_MEMORY, "512kB") .configure(PostgreSqlNode.INITIALIZE_DB, true) );	app.start(ImmutableList.of(loc));	String url = pgsql.getAttribute(DatastoreCommon.DATASTORE_URL);	
postgresql started on 

public void test_localhost_initialisingDb() throws Exception {	PostgreSqlNode pgsql = app.createAndManageChild(EntitySpec.create(PostgreSqlNode.class) .configure(DatastoreCommon.CREATION_SCRIPT_CONTENTS, CREATION_SCRIPT) .configure(PostgreSqlNode.MAX_CONNECTIONS, 10) .configure(PostgreSqlNode.SHARED_MEMORY, "512kB") .configure(PostgreSqlNode.INITIALIZE_DB, true) );	app.start(ImmutableList.of(loc));	String url = pgsql.getAttribute(DatastoreCommon.DATASTORE_URL);	new VogellaExampleAccess("org.postgresql.Driver", url).readModifyAndRevertDataBase();	
ran vogella postgresql example success 

public void test_localhost_withRoles() throws Exception {	PostgreSqlNode pgsql = app.createAndManageChild(EntitySpec.create(PostgreSqlNode.class) .configure(PostgreSqlNode.MAX_CONNECTIONS, 10) .configure(PostgreSqlNode.SHARED_MEMORY, "512kB") .configure(PostgreSqlNode.INITIALIZE_DB, true) .configure(PostgreSqlNode.ROLES, ImmutableMap.<String, Map<String, ?>>of( "Developer", ImmutableMap.<String, Object>of( "properties", "CREATEDB LOGIN", "privileges", ImmutableList.of( "SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public", "EXECUTE ON ALL FUNCTIONS IN SCHEMA public")), "Analyst", ImmutableMap.<String, Object>of( "properties", "LOGIN", "privileges", "SELECT ON ALL TABLES IN SCHEMA public"))) );	app.start(ImmutableList.of(loc));	String url = pgsql.getAttribute(DatastoreCommon.DATASTORE_URL);	
postgresql started on 

========================= brooklyn sample_52 =========================

public synchronized void delta(Delta delta) {	if (!running) {	
persister not running ignoring checkpointed delta of manager memento 

========================= brooklyn sample_622 =========================

public void install() {	SaltConfig.SaltMode mode = getEntity().config().get(SaltConfig.SALT_MODE);	Preconditions.checkNotNull(mode, "Required config " + SaltConfig.SALT_MODE + " not provided for entity: " + entity);	
starting salt in mode at 

public void launch() {	String name = "apply top states";	final ProcessTaskWrapper<Integer> topStates = queueAndBlock(SaltSshTasks.applyTopStates(false).summary(name));	final Matcher failCount = FAILURES.matcher(topStates.getStdout());	if (!failCount.matches() || !ZERO.equals(failCount.group(1))) {	
encountered error in applying salt top states 

public void stop() {	final Set<? extends String> stopStates = getEntity().config().get(SaltConfig.STOP_STATES);	
executing salt stopprocessesatmachine with states 

public void restart() {	ServiceStateLogic.setExpectedState(getEntity(), Lifecycle.STOPPING);	try {	final Set<? extends String> restartStates = getEntity().config().get(SaltConfig.RESTART_STATES);	
executing salt restart with states 

private void restartBasedOnStartStates() {	final Set<? extends String> startStates = getEntity().config().get(SaltConfig.START_STATES);	final MutableSet<String> restartStates = addSuffix(startStates, ".restart");	final ProcessTaskWrapper<Integer> queued = queueAndBlock(SaltSshTasks.findStates(restartStates, false).summary("check restart states"));	final String stdout = queued.getStdout();	String[] foundStates = Strings.isNonBlank(stdout) ? stdout.split("\\n") : null;	if (restartStates.size() > 0 && foundStates != null && (restartStates.size() == foundStates.length)) {	
all start states have matching restart states applying these 

private void restartBasedOnStartStates() {	final Set<? extends String> startStates = getEntity().config().get(SaltConfig.START_STATES);	final MutableSet<String> restartStates = addSuffix(startStates, ".restart");	final ProcessTaskWrapper<Integer> queued = queueAndBlock(SaltSshTasks.findStates(restartStates, false).summary("check restart states"));	final String stdout = queued.getStdout();	String[] foundStates = Strings.isNonBlank(stdout) ? stdout.split("\\n") : null;	if (restartStates.size() > 0 && foundStates != null && (restartStates.size() == foundStates.length)) {	applyStates(restartStates);	} else if (foundStates != null && foundStates.length > 0) {	
only some start states have matching restart states treating as restart failure 

final Set<? extends String> startStates = getEntity().config().get(SaltConfig.START_STATES);	final MutableSet<String> restartStates = addSuffix(startStates, ".restart");	final ProcessTaskWrapper<Integer> queued = queueAndBlock(SaltSshTasks.findStates(restartStates, false).summary("check restart states"));	final String stdout = queued.getStdout();	String[] foundStates = Strings.isNonBlank(stdout) ? stdout.split("\\n") : null;	if (restartStates.size() > 0 && foundStates != null && (restartStates.size() == foundStates.length)) {	applyStates(restartStates);	} else if (foundStates != null && foundStates.length > 0) {	throw new RuntimeException("unable to find restart state for all applied states");	} else {	
no stop states available invoking stop and start effectors 

========================= brooklyn sample_272 =========================

public static Task<BasicMachineDetails> taskForSshMachineLocation(SshMachineLocation location) {	BufferedReader reader = new BufferedReader(Streams.reader( new ResourceUtils(BasicMachineDetails.class).getResourceFromUrl( "classpath: List<String> script;	try {	script = CharStreams.readLines(reader);	} catch (IOException e) {	
error reading os details script 

public static Task<BasicMachineDetails> taskForSshMachineLocation(SshMachineLocation location) {	BufferedReader reader = new BufferedReader(Streams.reader( new ResourceUtils(BasicMachineDetails.class).getResourceFromUrl( "classpath: List<String> script;	try {	script = CharStreams.readLines(reader);	} catch (IOException e) {	throw Throwables.propagate(e);	} finally {	try {	reader.close();	} catch (IOException e) {	
error closing os details script reader 

private static Function<ProcessTaskWrapper<?>, BasicMachineDetails> taskToMachineDetailsFunction(final SshMachineLocation location) {	return new Function<ProcessTaskWrapper<?>, BasicMachineDetails>() {	public BasicMachineDetails apply(ProcessTaskWrapper<?> input) {	if (input.getExitCode() != 0) {	
non zero exit code when fetching machine details for guessing anonymous linux 

private static Function<ProcessTaskWrapper<?>, BasicMachineDetails> taskToMachineDetailsFunction(final SshMachineLocation location) {	return new Function<ProcessTaskWrapper<?>, BasicMachineDetails>() {	public BasicMachineDetails apply(ProcessTaskWrapper<?> input) {	if (input.getExitCode() != 0) {	return new BasicMachineDetails(new BasicHardwareDetails(null, null), BasicOsDetails.Factory.ANONYMOUS_LINUX);	}	String stdout = input.getStdout();	if (LOG.isDebugEnabled()) {	
found following details at 

if (detail.isPresent()) {	details.put(detail.get().getKey(), detail.get().getValue());	}	}	String name = details.remove("name");	String version = details.remove("version");	String architecture = details.remove("architecture");	Integer ram = intOrNull(details, "ram");	Integer cpuCount = intOrNull(details, "cpus");	if (!details.isEmpty()) {	
unused keys from os details script 

String name = details.remove("name");	String version = details.remove("version");	String architecture = details.remove("architecture");	Integer ram = intOrNull(details, "ram");	Integer cpuCount = intOrNull(details, "cpus");	if (!details.isEmpty()) {	}	OsDetails osDetails = new BasicOsDetails(name, architecture, version);	HardwareDetails hardwareDetails = new BasicHardwareDetails(cpuCount, ram);	BasicMachineDetails machineDetails = new BasicMachineDetails(hardwareDetails, osDetails);	
machine details for 

========================= brooklyn sample_1315 =========================

protected void finalize() {	
functionfeed builder created but build never called 

========================= brooklyn sample_1600 =========================

if (symbolicName != null) {	if (className == null) {	className = brooklynProperties.getConfig(BrooklynWebConfig.SECURITY_PROVIDER_CLASSNAME);	}	if (className != null) {	try {	Collection<Bundle> bundles = getMatchingBundles(symbolicName, version);	if (bundles.isEmpty()) {	throw new IllegalStateException("No bundle " + symbolicName + ":" + version + " found");	} else if (bundles.size() > 1) {	
found multiple bundles matching symbolicname and version while trying to load security provider will use first one that loads the class successfully 

provider = tryLoadClass(className, bundles);	if (provider == null) {	throw new ClassNotFoundException("Unable to load class " + className + " from bundle " + symbolicName + ":" + version);	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	throw new IllegalStateException("Can not load or create security provider " + className + " for bundle " + symbolicName + ":" + version, e);	}	}	} else {	
delegating security provider loading to brooklyn 

throw new ClassNotFoundException("Unable to load class " + className + " from bundle " + symbolicName + ":" + version);	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	throw new IllegalStateException("Can not load or create security provider " + className + " for bundle " + symbolicName + ":" + version, e);	}	}	} else {	provider = createDefaultSecurityProvider(getManagementContext());	}	
using security provider 

========================= brooklyn sample_2885 =========================

public static void start(Entity e, Collection<? extends Location> locations) {	if (!isManaged(e) && !manage(e)) {	
using deprecated discouraged mechanism to start management entities start application locations caller should create and use the preferred management context 

public static void destroy(Entity e) {	if (isManaged(e)) {	if (isReadOnly(e)) {	unmanage(e);	
destroyed and unmanaged read only copy of 

if (isManaged(e)) {	if (isReadOnly(e)) {	unmanage(e);	} else {	if (e instanceof Startable) Entities.invokeEffector(e, e, Startable.STOP).getUnchecked();	if (e instanceof EntityInternal) ((EntityInternal)e).destroy();	unmanage(e);	log.debug("destroyed and unmanaged "+e+"; mgmt now "+ (e.getApplicationId()==null ? "(no app)" : e.getApplication().getManagementContext())+" - managed? "+isManaged(e));	}	} else {	
skipping destroy of not managed 

public static void destroyCatching(Entity entity) {	try {	destroy(entity);	} catch (Exception e) {	
error destroying ignoring 

public static void destroy(Location loc) {	if (loc instanceof Closeable) {	Streams.closeQuietly((Closeable)loc);	
closed 

public static void destroyCatching(Location loc) {	try {	destroy(loc);	} catch (Exception e) {	
error destroying ignoring 

public static void destroyAll(final ManagementContext mgmt) {	final int MAX_THREADS = 100;	if (mgmt instanceof NonDeploymentManagementContext) {	
entities destroyall invoked on non deployment not likely to have much effect this usually means the mgmt context has been taken from an entity that has been destroyed to destroy other things on the management context ensure you keep a handle to the context before the entity is destroyed such as by creating the management context first 

public static void destroyAll(final ManagementContext mgmt) {	final int MAX_THREADS = 100;	if (mgmt instanceof NonDeploymentManagementContext) {	}	if (!mgmt.isRunning()) return;	ListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_THREADS));	List<ListenableFuture<?>> futures = Lists.newArrayList();	final AtomicReference<Exception> error = Atomics.newReference();	try {	
destroying all apps in 

if (mgmt instanceof NonDeploymentManagementContext) {	}	if (!mgmt.isRunning()) return;	ListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_THREADS));	List<ListenableFuture<?>> futures = Lists.newArrayList();	final AtomicReference<Exception> error = Atomics.newReference();	try {	for (final Application app: mgmt.getApplications()) {	futures.add(executor.submit(new Runnable() {	public void run() {	
destroying app managed mgmt is 

if (!mgmt.isRunning()) return;	ListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_THREADS));	List<ListenableFuture<?>> futures = Lists.newArrayList();	final AtomicReference<Exception> error = Atomics.newReference();	try {	for (final Application app: mgmt.getApplications()) {	futures.add(executor.submit(new Runnable() {	public void run() {	try {	destroy(app);	
destroyed app mgmt now 

ListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_THREADS));	List<ListenableFuture<?>> futures = Lists.newArrayList();	final AtomicReference<Exception> error = Atomics.newReference();	try {	for (final Application app: mgmt.getApplications()) {	futures.add(executor.submit(new Runnable() {	public void run() {	try {	destroy(app);	} catch (Exception e) {	
problems destroying app mgmt now will rethrow at least one exception 

Futures.allAsList(futures).get();	for (Location loc : mgmt.getLocationManager().getLocations()) {	destroyCatching(loc);	}	if (mgmt instanceof ManagementContextInternal) {	((ManagementContextInternal)mgmt).terminate();	}	if (error.get() != null) throw Exceptions.propagate(error.get());	} catch (Exception e) {	if (!mgmt.isRunning()) {	
destroying apps gave an error but mgmt context was concurrently stopped so not really a problem swallowing unless fatal 

public static void destroyAllCatching(ManagementContext mgmt) {	try {	destroyAll(mgmt);	} catch (Exception e) {	
error destroying ignoring 

public static AbstractEntity deproxy(Entity e) {	if (!(Proxy.isProxyClass(e.getClass()))) {	
attempt to deproxy non proxy location of attempt to deproxy non proxy 

public static boolean manage(Entity e) {	if (Entities.isManaged(e)) {	return true;	}	
deprecated use of entities manage entity for unmanaged entity 

public static ManagementContext startManagement(Entity e) {	
deprecated use of entities startmanagement entity for entity 

while (o.getParent()!=null) {	if (!isManaged(o)) eum = o;	o = o.getParent();	}	if (isManaged(o)) {	ManagementContext mgmt = ((EntityInternal)o).getManagementContext();	mgmt.getEntityManager().manage(eum);	return mgmt;	}	if (!(o instanceof Application)) throw new IllegalStateException("Can't manage "+e+" because it is not rooted at an application");	
deprecated invocation of startmanagement for without a management context present a new local management context is being created not recommended unless you really know what you are doing 

public static ManagementContext startManagement(Application app, ManagementContext mgmt) {	
deprecated use of entities startmanagement application managementcontext for app 

public static ManagementContext startManagement(Application app, BrooklynProperties props) {	
deprecated use of entities startmanagement application brooklynproperties for app 

public static void warnOnIgnoringConfig(Entity entity, ConfigKey<?> key) {	
ignoring set on 

try {	String description = "Waiting for " + condition + " on " + entity;	Tasks.setBlockingDetails(description);	Repeater repeater = Repeater.create(description) .until(isSatisfied(entity, condition)) .limitTimeTo(timeout) .backoffTo(Duration.ONE_SECOND) .rethrowException();	if (!repeater.run()) {	throw new IllegalStateException("Timeout waiting for " + condition + " on " + entity);	}	} finally {	Tasks.resetBlockingDetails();	}	
detected for 

========================= brooklyn sample_1250 =========================

public void create() {	
adding queue to broker BrokerName 

========================= brooklyn sample_458 =========================

protected void finalize() throws Throwable {	
task was modified but modification was never used 

========================= brooklyn sample_1495 =========================

public void shouldSetSensorsOnEntity() throws Exception {	String contents = getTestYaml();	TestApplication app = TestApplication.Factory.newManagedInstanceForTests();	entity = app.createAndManageChild(EntitySpec.create(SaltEntity.class) .configure(SaltEntity.START_STATES, ImmutableSet.of("apache")));	SaltHighstate.applyHighstate(contents, entity);	final List<String> states = entity.sensors().get(SaltEntity.STATES);	
test states are 

========================= brooklyn sample_264 =========================

public void testRenewAuthSucceedsInSwiftObjectStore() throws Exception {	injectShortLivedTokenForSwiftAuth();	context.getBlobStore().createContainerInLocation(null, testContainerName);	assertContainerFound();	
created container now sleeping for expiration 

public static HttpToolResponse requestTokenWithExplicitLifetime(URL url, String user, String key, Duration expiration) throws URISyntaxException {	HttpClient client = HttpTool.httpClientBuilder().build();	HttpToolResponse response = HttpTool.httpGet(client, url.toURI(), MutableMap.<String,String>of() .add(AuthHeaders.AUTH_USER, user) .add(AuthHeaders.AUTH_KEY, key) .add("Host", url.getHost()) .add("X-Auth-New-Token", "" + true) .add("X-Auth-Token-Lifetime", "" + expiration.toSeconds()) );	
requested token with explicit lifetime at 

========================= brooklyn sample_2485 =========================

public void testHttpFeedCleansUpAfterHaDisabledAndRunsAtFailover() throws Exception {	TestEntity origEntity = origApp.createAndManageChild(EntitySpec.create(TestEntity.class).impl(RebindFeedTest.MyEntityWithHttpFeedImpl.class) .configure(RebindFeedTest.MyEntityWithHttpFeedImpl.BASE_URL, baseUrl));	EntityAsserts.assertAttributeEqualsEventually(origEntity, SENSOR_INT, 200);	EntityAsserts.assertAttributeEqualsEventually(origEntity, SENSOR_STRING, "{\"foo\":\"myfoo\"}");	assertEquals(origEntity.feeds().getFeeds().size(), 1);	origManagementContext.getRebindManager().forcePersistNow();	List<Task<?>> tasksBefore = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getAllTasks();	
tasks before disabling ha 

assertEquals(origEntity.feeds().getFeeds().size(), 1);	origManagementContext.getRebindManager().forcePersistNow();	List<Task<?>> tasksBefore = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getAllTasks();	Assert.assertFalse(tasksBefore.isEmpty());	origManagementContext.getHighAvailabilityManager().changeMode(HighAvailabilityMode.DISABLED);	origApp = null;	Repeater.create().every(Duration.millis(20)).backoffTo(Duration.ONE_SECOND).limitTimeTo(Duration.THIRTY_SECONDS).until(new Callable<Boolean>() {	public Boolean call() throws Exception {	origManagementContext.getGarbageCollector().gcIteration();	List<Task<?>> tasksAfter = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getAllTasks();	
tasks after disabling ha 

========================= brooklyn sample_634 =========================

private static void waitBrieflyForServiceUpIfStateIsRunning(Entity entity, Lifecycle state) {	if (state==Lifecycle.RUNNING) {	Boolean up = ((EntityInternal)entity).getAttribute(Attributes.SERVICE_UP);	if (!Boolean.TRUE.equals(up) && !Boolean.TRUE.equals(Entities.isReadOnly(entity))) {	Stopwatch timer = Stopwatch.createStarted();	boolean nowUp = Repeater.create() .every(ValueResolver.REAL_QUICK_PERIOD) .limitTimeTo(ValueResolver.PRETTY_QUICK_WAIT) .until(entity, EntityPredicates.attributeEqualTo(Attributes.SERVICE_UP, true)) .run();	if (nowUp) {	
had to wait for to be true before setting 

protected void setActualState(Maybe<Lifecycle> state) {	
setting actual state 

protected void updateMapSensor(AttributeSensor<Map<String, Object>> sensor, Object value) {	
updating map sensor with 

========================= brooklyn sample_1246 =========================

public PerUserEntitlementManager(BrooklynProperties properties) {	this(load(properties, properties.getConfig(DEFAULT_MANAGER)));	Set<ConfigKey<?>> users = properties.findKeysPresent(ConfigPredicates.nameStartsWith(PER_USER_ENTITLEMENTS_CONFIG_PREFIX+"."));	for (ConfigKey<?> key: users) {	if (key.getName().equals(DEFAULT_MANAGER.getName())) continue;	String user = Strings.removeFromStart(key.getName(), PER_USER_ENTITLEMENTS_CONFIG_PREFIX+".");	addUser(user, load(properties, Strings.toString(properties.getConfig(key))));	}	
created with user and default users 

========================= brooklyn sample_1138 =========================

public ManagementPlaneSyncRecordPersisterToObjectStore(ManagementContext mgmt, PersistenceObjectStore objectStore, ClassLoader classLoader) {	this.mgmt = mgmt;	this.objectStore = checkNotNull(objectStore, "objectStore");	MementoSerializer<Object> rawSerializer = new XmlMementoSerializer<Object>(checkNotNull(classLoader, "classLoader"));	this.serializer = new RetryingMementoSerializer<Object>(rawSerializer, MAX_SERIALIZATION_ATTEMPTS);	objectStore.createSubPath(NODES_SUB_PATH);	
managementplanememento persister will use store 

public void stop() {	running = false;	try {	for (StoreObjectAccessorWithLock writer : nodeWriters.values()) {	try {	writer.waitForCurrentWrites(SHUTDOWN_TIMEOUT);	} catch (TimeoutException e) {	
timeout during shutdown waiting for write of continuing 

try {	for (StoreObjectAccessorWithLock writer : nodeWriters.values()) {	try {	writer.waitForCurrentWrites(SHUTDOWN_TIMEOUT);	} catch (TimeoutException e) {	}	}	try {	masterWriter.waitForCurrentWrites(SHUTDOWN_TIMEOUT);	} catch (TimeoutException e) {	
timeout during shutdown waiting for write of continuing 

public ManagementPlaneSyncRecord loadSyncRecord() throws IOException {	if (!running) {	throw new IllegalStateException("Persister not running; cannot load memento from "+ objectStore.getSummaryName());	}	init();	
loading management plane memento from 

public ManagementPlaneSyncRecord loadSyncRecord() throws IOException {	if (!running) {	throw new IllegalStateException("Persister not running; cannot load memento from "+ objectStore.getSummaryName());	}	init();	Stopwatch stopwatch = Stopwatch.createStarted();	ManagementPlaneSyncRecordImpl.Builder builder = ManagementPlaneSyncRecordImpl.builder();	String masterNodeId = masterWriter.get();	if (masterNodeId == null) {	
no master memento deserialized from file ignoring and continuing normal on startup should cause an error later in live operation 

init();	Stopwatch stopwatch = Stopwatch.createStarted();	ManagementPlaneSyncRecordImpl.Builder builder = ManagementPlaneSyncRecordImpl.builder();	String masterNodeId = masterWriter.get();	if (masterNodeId == null) {	} else {	builder.masterNodeId(masterNodeId);	}	builder.planeId(Strings.emptyToNull(planeIdReader.get()));	List<String> nodeFiles = objectStore.listContentsWithSubPath(NODES_SUB_PATH);	
loading nodes from nodes 

try {	nodeContents = objectAccessor.get();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	problem = e;	}	if (problem!=null || Strings.isBlank(nodeContents)) {	if (objectAccessor.exists()) {	throw Exceptions.propagate(new IllegalStateException("Node record "+nodeFile+" could not be read when "+mgmt.getManagementNodeId()+" was scanning", problem));	} else {	
node record went away while was scanning ignoring it has probably been terminated 

continue;	}	}	ManagementNodeSyncRecord memento = (ManagementNodeSyncRecord) serializer.fromString(nodeContents);	if (memento == null) {	throw Exceptions.propagate(new IllegalStateException("Node record "+nodeFile+" could not be deserialized when "+mgmt.getManagementNodeId()+" was scanning: "+nodeContents, problem));	} else {	if (memento.getRemoteTimestamp()!=null && preferRemoteTimestampInMemento) {	} else {	if (memento.getRemoteTimestamp()!=null) {	
ignoring remote timestamp in memento file looks like this data has been manually copied in 

if (memento.getRemoteTimestamp()!=null && preferRemoteTimestampInMemento) {	} else {	if (memento.getRemoteTimestamp()!=null) {	}	Date lastModifiedDate = objectAccessor.getLastModifiedDate();	((BasicManagementNodeSyncRecord)memento).setRemoteTimestamp(lastModifiedDate!=null ? lastModifiedDate.getTime() : null);	}	builder.node(memento);	}	}	
loaded management plane memento nodes took 

public void delta(Delta delta) {	if (!running) {	
persister not running ignoring checkpointed delta of manager memento 

public void delta(Delta delta) {	if (!running) {	return;	}	init();	Stopwatch stopwatch = Stopwatch.createStarted();	
checkpointing delta of manager memento updating 

deleteNode(id);	}	switch (delta.getMasterChange()) {	case NO_CHANGE: break;	case SET_MASTER: persistMaster(checkNotNull(delta.getNewMasterOrNull()), null);	break;	case CLEAR_MASTER: persistMaster("", delta.getExpectedMasterToClear());	break;	default: throw new IllegalStateException("Unknown state for master-change: "+delta.getMasterChange());	}	
checkpointed delta of manager memento in 

private void persistMaster(String nodeId, String optionalExpectedId) {	if (optionalExpectedId!=null) {	String currentRemoteMaster = masterWriter.get();	if (currentRemoteMaster==null) {	} else if (!currentRemoteMaster.trim().equals(optionalExpectedId.trim())) {	
master at server is none expected and would set as and would clear so not applying yet 

========================= brooklyn sample_1092 =========================

level = 0;	message = ""+count+" ManagementContexts terminated";	} else if (count<0) {	level = 1;	message = ""+(-count)+" ManagementContexts left dangling";	} else {	level = -1;	message = ""+count+" ManagementContexts terminated";	}	} catch (ClassNotFoundException e) {	
class not found in testng listener so not attempting to terminate all extant managementcontexts continuing 

level = 1;	message = ""+(-count)+" ManagementContexts left dangling";	} else {	level = -1;	message = ""+count+" ManagementContexts terminated";	}	} catch (ClassNotFoundException e) {	level = 0;	message = "no "+clazzName+" available, so skipped";	} catch (Throwable e) {	
error in testng listener attempting to terminate all extant managementcontexts 

========================= brooklyn sample_2128 =========================

public void testRestoresSimpleApp() throws Exception {	messages.clear();	messages.add("creating");	origApp.createAndManageChild(EntitySpec.create(Entity.class, MyEntityForClassInitializationTesting.class));	messages.add("created");	messages.add("rebinding");	newApp = rebind();	messages.add("rebinded");	
create and rebind message sequence is 

========================= brooklyn sample_663 =========================

public SecurityGroup createSecurityGroup(final String name) {	
creating security group in 

public boolean removeSecurityGroup(final SecurityGroup group) {	
removing security group in 

public boolean removeSecurityGroup(final String groupId) {	
removing security group in 

public SecurityGroup addPermission(final SecurityGroup group, final IpPermission permission) {	
adding permission to security group 

public SecurityGroup removePermission(final SecurityGroup group, final IpPermission permission) {	
removing permission from security group 

protected <T> T runOperationWithRetry(Callable<T> operation) {	int backoff = 64;	Exception lastException = null;	
running operation 

protected <T> T runOperationWithRetry(Callable<T> operation) {	int backoff = 64;	Exception lastException = null;	for (int retries = 0; retries < 12; retries++) {	try {	return operation.call();	} catch (Exception e) {	lastException = e;	if (isExceptionRetryable.apply(e)) {	
attempt failed to run operation due to 

========================= brooklyn sample_2578 =========================

public void deploy(String url, String targetName) {	checkNotNull(url, "url");	checkNotNull(targetName, "targetName");	targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);	addToWarsByContext(this, url, targetName);	
deploying across cluster wars now 

public void undeploy(String targetName) {	checkNotNull(targetName, "targetName");	targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);	if (!removeFromWarsByContext(this, targetName)) {	DynamicTasks.submit(Tasks.warning("Context "+targetName+" not known at "+this+"; attempting to undeploy regardless", null), this);	}	
undeploying across cluster wars now 

public void redeployAll() {	Map<String, String> wars = MutableMap.copyOf(getConfig(WARS_BY_CONTEXT));	String redeployPrefix = "Redeploy all WARs (count "+wars.size()+")";	
redeplying all wars across cluster 

========================= brooklyn sample_233 =========================

public void testProvisioningProperties() throws Exception {	final Entity app = createAndStartApplication(loadYaml("example-with-CreatePasswordSensor.yaml"));	waitForApplicationTasks(app);	Entity entity = Iterables.getOnlyElement(app.getChildren());	
passwords are 

========================= brooklyn sample_1704 =========================

public void testInvocationSensorAndEnricher() throws Exception {	Preconditions.checkArgument(Networking.isPortAvailable(4321), "port 4321 must not be in use (no leaked nc instances) for this test to succeed!");	Entity app = createAndStartApplication(loadYaml("vanilla-bash-netcat-w-client.yaml"));	waitForApplicationTasks(app);	
app started 

Assert.assertTrue(netcatI.iterator().hasNext(), "no 'netcat-server' child of app: "+app.getChildren());	Entity netcat = Iterables.getOnlyElement(netcatI);	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.equalTo(Lifecycle.RUNNING));	Iterable<Entity> pingerI = Iterables.filter(app.getChildren(), EntityPredicates.displayNameEqualTo("Simple Pinger"));	Assert.assertTrue(pingerI.iterator().hasNext(), "no 'Simple Pinger' child of app: "+app.getChildren());	Entity pinger = Iterables.getOnlyElement(pingerI);	Task<String> ping;	ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of());	Assert.assertEquals(ping.get().trim(), "hello");	EntityAsserts.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral("hi netcat"));	
invoked ping from to all sensor shows 

Entity netcat = Iterables.getOnlyElement(netcatI);	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.equalTo(Lifecycle.RUNNING));	Iterable<Entity> pingerI = Iterables.filter(app.getChildren(), EntityPredicates.displayNameEqualTo("Simple Pinger"));	Assert.assertTrue(pingerI.iterator().hasNext(), "no 'Simple Pinger' child of app: "+app.getChildren());	Entity pinger = Iterables.getOnlyElement(pingerI);	Task<String> ping;	ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of());	Assert.assertEquals(ping.get().trim(), "hello");	EntityAsserts.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral("hi netcat"));	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.not(Predicates.equalTo(Lifecycle.RUNNING)));	
detected failure state is 

EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.equalTo(Lifecycle.RUNNING));	Iterable<Entity> pingerI = Iterables.filter(app.getChildren(), EntityPredicates.displayNameEqualTo("Simple Pinger"));	Assert.assertTrue(pingerI.iterator().hasNext(), "no 'Simple Pinger' child of app: "+app.getChildren());	Entity pinger = Iterables.getOnlyElement(pingerI);	Task<String> ping;	ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of());	Assert.assertEquals(ping.get().trim(), "hello");	EntityAsserts.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral("hi netcat"));	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.not(Predicates.equalTo(Lifecycle.RUNNING)));	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.equalTo(Lifecycle.RUNNING));	
detected recovery state is 

Entity pinger = Iterables.getOnlyElement(pingerI);	Task<String> ping;	ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of());	Assert.assertEquals(ping.get().trim(), "hello");	EntityAsserts.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral("hi netcat"));	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.not(Predicates.equalTo(Lifecycle.RUNNING)));	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.equalTo(Lifecycle.RUNNING));	ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of("message", "yo yo yo"));	Assert.assertEquals(ping.get().trim(), "hello");	EntityAsserts.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral("yo yo yo"));	
invoked ping again from to all sensor shows 

Task<String> ping;	ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of());	Assert.assertEquals(ping.get().trim(), "hello");	EntityAsserts.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral("hi netcat"));	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.not(Predicates.equalTo(Lifecycle.RUNNING)));	EntityAsserts.assertAttributeEventually(netcat, Attributes.SERVICE_STATE_ACTUAL, Predicates.equalTo(Lifecycle.RUNNING));	ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of("message", "yo yo yo"));	Assert.assertEquals(ping.get().trim(), "hello");	EntityAsserts.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral("yo yo yo"));	EntityAsserts.assertAttributeEventually(app, Sensors.newStringSensor("output.last"), StringPredicates.containsLiteral("yo yo yo"));	
after all is said and done app is 

========================= brooklyn sample_1641 =========================

numJcloudsPrefixes++;	result.providerOrApi = result.parameter;	result.parameter = null;	split = result.providerOrApi.indexOf(':');	if (split>=0) {	result.parameter = result.providerOrApi.substring(split+1);	result.providerOrApi = result.providerOrApi.substring(0, split);	}	}	if (!dryrun && numJcloudsPrefixes > 1) {	
use of deprecated location spec in future use a single prefix 

result.parameter = result.providerOrApi.substring(split+1);	result.providerOrApi = result.providerOrApi.substring(0, split);	}	}	if (!dryrun && numJcloudsPrefixes > 1) {	}	}	if (result.parameter==null && AWS_REGIONS.contains(result.providerOrApi)) {	result.parameter = result.providerOrApi;	result.providerOrApi = "aws-ec2";	
use of deprecated location in future refer to with explicit provider 

========================= brooklyn sample_2597 =========================

public void testSnapshotRetrieval() throws Exception {	MavenArtifact m = MavenArtifact.fromCoordinate(THIS_PROJECT_COORDINATE);	if (!m.isSnapshot()) {	
skipping snapshot testing as this is not a snapshot project 

public void testRetrievalHostedSnapshotIntegration() throws Exception {	MavenArtifact m = MavenArtifact.fromCoordinate( "org.apache.brooklyn:brooklyn-utils-common:jar:0.12.0");	String localPath = new MavenRetriever().getLocalPath(m);	File f = new File(localPath);	if (!f.exists()) Assert.fail("Could not load "+localPath+" when testing MavenRetriever: do a maven build with no integration tests first to ensure this is installed, then rerun");	String l = new MavenRetriever().getLocalUrl(m);	Assert.assertEquals(new URL(l), new URL("file: checkAvailableUrl(l);	String h = new MavenRetriever().getHostedUrl(m);	if (!m.isSnapshot()) {	
skipping snapshot testing as this is not a snapshot build 

String l = new MavenRetriever().getLocalUrl(m);	Assert.assertEquals(new URL(l), new URL("file: checkAvailableUrl(l);	String h = new MavenRetriever().getHostedUrl(m);	if (!m.isSnapshot()) {	} else {	Assert.assertTrue(h.contains("repository.apache.org"), "h="+h);	}	try {	checkAvailableUrl(h);	} catch (Exception e) {	
could not download snapshot build for is it installed to sonatype 

private URL followRedirects(URL url) throws Exception {	if ("file".equalsIgnoreCase(url.getProtocol())) return url;	HttpURLConnection conn = (HttpURLConnection) url.openConnection();	conn.setReadTimeout(5000);	int status = conn.getResponseCode();	boolean redirect = (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER);	if (redirect) {	String newUrl = conn.getHeaderField("Location");	
following redirect for to 

========================= brooklyn sample_1905 =========================

public void serializeFromError(JsonStreamContext ctxt, @Nullable Exception error, Object value, JsonGenerator jgen, SerializerProvider configurableSerializerProvider) throws IOException {	
recovering from json serialization error serializing 

public void serializeFromError(JsonStreamContext ctxt, @Nullable Exception error, Object value, JsonGenerator jgen, SerializerProvider configurableSerializerProvider) throws IOException {	if (BidiSerialization.isStrictSerialization()) throw new JsonMappingException("Cannot serialize " + (ctxt!=null && !ctxt.inRoot() ? "object containing " : "") + value.getClass().getName()+" when strict serialization requested");	if (WARNED_CLASSES.add(value.getClass().getCanonicalName())) {	
standard serialization not possible for 

========================= brooklyn sample_1456 =========================

public void setEnableCors(boolean enabled) {	this.enableCors = Boolean.TRUE.equals(enabled);	setFindResourceMethod(false);	if (enableCors) {	
cors brooklyn feature enabled 

public void setEnableCors(boolean enabled) {	this.enableCors = Boolean.TRUE.equals(enabled);	setFindResourceMethod(false);	if (enableCors) {	} else {	
cors brooklyn feature disabled 

========================= brooklyn sample_2915 =========================

protected Map<String, Object> getMatchingProperties(String fullPreferredPrefix, String fullDeprecatedPrefix, Map<String, ?> properties) {	Map<String, Object> deprecatedResults = getMatchingProperties(fullDeprecatedPrefix, properties);	Map<String, Object> results = getMatchingProperties(fullPreferredPrefix, properties);	if (deprecatedResults.size() > 0) {	
deprecated use of properties prefix instead use 

protected Map<String, Object> getMatchingSingleWordProperties(String fullPreferredPrefix, String fullDeprecatedPrefix, Map<String, ?> properties) {	Map<String, Object> deprecatedResults = getMatchingSingleWordProperties(fullDeprecatedPrefix, properties);	Map<String, Object> results = getMatchingSingleWordProperties(fullPreferredPrefix, properties);	if (deprecatedResults.size() > 0) {	
deprecated use of properties prefix instead use 

protected Map<String, Object> transformDeprecated(Map<String, ?> properties) {	Map<String,Object> result = Maps.newLinkedHashMap();	Map<String, String> deprecatedKeysMapping = getDeprecatedKeysMapping();	for (Map.Entry<String,?> entry : properties.entrySet()) {	String key = entry.getKey();	Object value = entry.getValue();	if (deprecatedKeysMapping.containsKey(key)) {	String transformedKey = deprecatedKeysMapping.get(key);	
deprecated key transformed to will not be supported in future versions 

========================= brooklyn sample_1285 =========================

public <T> T updateWithoutPublishing(AttributeSensor<T> attribute, T newValue) {	if (log.isTraceEnabled()) {	Object oldValue = getValue(attribute);	if (!Objects.equal(oldValue, newValue != null)) {	
setting attribute to was on 

public <T> T updateWithoutPublishing(AttributeSensor<T> attribute, T newValue) {	if (log.isTraceEnabled()) {	Object oldValue = getValue(attribute);	if (!Objects.equal(oldValue, newValue != null)) {	} else {	
setting attribute to unchanged on 

public <T> T modify(AttributeSensor<T> attribute, Function<? super T, Maybe<T>> modifier) {	synchronized (values) {	T oldValue = getValue(attribute);	Maybe<? extends T> newValue = modifier.apply(oldValue);	if (newValue.isPresent()) {	
modified attribute to was on 

public <T> T modify(AttributeSensor<T> attribute, Function<? super T, Maybe<T>> modifier) {	synchronized (values) {	T oldValue = getValue(attribute);	Maybe<? extends T> newValue = modifier.apply(oldValue);	if (newValue.isPresent()) {	return update(attribute, newValue.get());	} else {	
modified attribute unchanged not emitting on 

public void remove(Collection<String> path) {	checkPath(path);	if (log.isTraceEnabled()) {	
removing sensor for 

========================= brooklyn sample_1401 =========================

public void testGetMachineDetails() {	Task<BasicMachineDetails> detailsTask = app.getExecutionContext().submit( BasicMachineDetails.taskForSshMachineLocation(host));	MachineDetails machine = detailsTask.getUnchecked();	
found the following on localhost 

========================= brooklyn sample_835 =========================

public void testUpdateCalledWhenChildHostnameAndPortChanges() throws Exception {	
adding child no effect until up 

public void testUpdateCalledWhenChildHostnameAndPortChanges() throws Exception {	TestEntity child = cluster.addChild(EntitySpec.create(TestEntity.class));	cluster.addMember(child);	List<Collection<String>> u = Lists.newArrayList(controller.getUpdates());	assertTrue(u.isEmpty(), "expected no updates, but got "+u);	
setting child service up 

public void testUpdateCalledWhenChildHostnameAndPortChanges() throws Exception {	TestEntity child = cluster.addChild(EntitySpec.create(TestEntity.class));	cluster.addMember(child);	List<Collection<String>> u = Lists.newArrayList(controller.getUpdates());	assertTrue(u.isEmpty(), "expected no updates, but got "+u);	child.sensors().set(Startable.SERVICE_UP, true);	
setting mymachine 

public void testUpdateCalledWhenChildHostnameAndPortChanges() throws Exception {	TestEntity child = cluster.addChild(EntitySpec.create(TestEntity.class));	cluster.addMember(child);	List<Collection<String>> u = Lists.newArrayList(controller.getUpdates());	assertTrue(u.isEmpty(), "expected no updates, but got "+u);	child.sensors().set(Startable.SERVICE_UP, true);	child.sensors().set(WebServerEntity.HOSTNAME, "mymachine");	child.sensors().set(Attributes.SUBNET_HOSTNAME, "mymachine");	child.sensors().set(WebServerEntity.HTTP_PORT, 1234);	assertEventuallyExplicitAddressesMatch(ImmutableList.of("mymachine:1234"));	
setting 

List<Collection<String>> u = Lists.newArrayList(controller.getUpdates());	assertTrue(u.isEmpty(), "expected no updates, but got "+u);	child.sensors().set(Startable.SERVICE_UP, true);	child.sensors().set(WebServerEntity.HOSTNAME, "mymachine");	child.sensors().set(Attributes.SUBNET_HOSTNAME, "mymachine");	child.sensors().set(WebServerEntity.HTTP_PORT, 1234);	assertEventuallyExplicitAddressesMatch(ImmutableList.of("mymachine:1234"));	child.sensors().set(WebServerEntity.HOSTNAME, "mymachine2");	child.sensors().set(Attributes.SUBNET_HOSTNAME, "mymachine2");	assertEventuallyExplicitAddressesMatch(ImmutableList.of("mymachine2:1234"));	
setting 

child.sensors().set(Startable.SERVICE_UP, true);	child.sensors().set(WebServerEntity.HOSTNAME, "mymachine");	child.sensors().set(Attributes.SUBNET_HOSTNAME, "mymachine");	child.sensors().set(WebServerEntity.HTTP_PORT, 1234);	assertEventuallyExplicitAddressesMatch(ImmutableList.of("mymachine:1234"));	child.sensors().set(WebServerEntity.HOSTNAME, "mymachine2");	child.sensors().set(Attributes.SUBNET_HOSTNAME, "mymachine2");	assertEventuallyExplicitAddressesMatch(ImmutableList.of("mymachine2:1234"));	child.sensors().set(WebServerEntity.HTTP_PORT, 1235);	assertEventuallyExplicitAddressesMatch(ImmutableList.of("mymachine2:1235"));	
clearing 

private void assertAddressesMatch(final Collection<String> expectedAddresses) {	List<Collection<String>> u = Lists.newArrayList(controller.getUpdates());	Collection<String> last = Iterables.getLast(u, null);	
test updates expecting actual 

========================= brooklyn sample_136 =========================

public void testObtainsMovesThroughSubLocations() throws Exception {	Assert.assertEquals(multiLoc.obtain().getAddress().getHostAddress(), "1.1.1.1");	Assert.assertEquals(multiLoc.obtain().getAddress().getHostAddress(), "1.1.1.2");	Assert.assertEquals(multiLoc.obtain().getAddress().getHostAddress(), "1.1.1.3");	Assert.assertEquals(multiLoc.obtain().getAddress().getHostAddress(), "1.1.1.4");	try {	multiLoc.obtain();	Assert.fail();	} catch (NoMachinesAvailableException e) {	
error when no machines available across locations is 

========================= brooklyn sample_970 =========================

protected void assertNotSshable(Map<?,?> machineConfig) {	try {	assertSshable(machineConfig);	Assert.fail("ssh should not have succeeded "+machineConfig);	} catch (Exception e) {	
exception as expected when testing sshable 

private void moveSshKeyFiles() throws Exception {	privateRsaFileMoved = false;	privateDsaFileMoved = false;	publicRsaFileMoved = false;	publicDsaFileMoved = false;	if (privateRsaFile.exists()) {	
moving to 

private void moveSshKeyFiles() throws Exception {	privateRsaFileMoved = false;	privateDsaFileMoved = false;	publicRsaFileMoved = false;	publicDsaFileMoved = false;	if (privateRsaFile.exists()) {	Runtime.getRuntime().exec("mv "+privateRsaFile.getAbsolutePath()+" "+privateRsaFileTmp.getAbsolutePath());	privateRsaFileMoved = true;	}	if (privateDsaFile.exists()) {	
moving to 

publicDsaFileMoved = false;	if (privateRsaFile.exists()) {	Runtime.getRuntime().exec("mv "+privateRsaFile.getAbsolutePath()+" "+privateRsaFileTmp.getAbsolutePath());	privateRsaFileMoved = true;	}	if (privateDsaFile.exists()) {	Runtime.getRuntime().exec("mv "+privateDsaFile.getAbsolutePath()+" "+privateDsaFileTmp.getAbsolutePath());	privateDsaFileMoved = true;	}	if (publicRsaFile.exists()) {	
moving to 

}	if (privateDsaFile.exists()) {	Runtime.getRuntime().exec("mv "+privateDsaFile.getAbsolutePath()+" "+privateDsaFileTmp.getAbsolutePath());	privateDsaFileMoved = true;	}	if (publicRsaFile.exists()) {	Runtime.getRuntime().exec("mv "+publicRsaFile.getAbsolutePath()+" "+publicRsaFileTmp.getAbsolutePath());	publicRsaFileMoved = true;	}	if (publicDsaFile.exists()) {	
moving to 

private void restoreSshKeyFiles() throws Exception {	if (privateRsaFileMoved) {	
restoring form 

private void restoreSshKeyFiles() throws Exception {	if (privateRsaFileMoved) {	Runtime.getRuntime().exec("mv "+privateRsaFileTmp.getAbsolutePath()+" "+privateRsaFile.getAbsolutePath());	privateRsaFileMoved = false;	}	if (privateDsaFileMoved) {	
restoring form 

private void restoreSshKeyFiles() throws Exception {	if (privateRsaFileMoved) {	Runtime.getRuntime().exec("mv "+privateRsaFileTmp.getAbsolutePath()+" "+privateRsaFile.getAbsolutePath());	privateRsaFileMoved = false;	}	if (privateDsaFileMoved) {	Runtime.getRuntime().exec("mv "+privateDsaFileTmp.getAbsolutePath()+" "+privateDsaFile.getAbsolutePath());	privateDsaFileMoved = false;	}	if (publicRsaFileMoved) {	
restoring form 

}	if (privateDsaFileMoved) {	Runtime.getRuntime().exec("mv "+privateDsaFileTmp.getAbsolutePath()+" "+privateDsaFile.getAbsolutePath());	privateDsaFileMoved = false;	}	if (publicRsaFileMoved) {	Runtime.getRuntime().exec("mv "+publicRsaFileTmp.getAbsolutePath()+" "+publicRsaFile.getAbsolutePath());	publicRsaFileMoved = false;	}	if (publicDsaFileMoved) {	
restoring form 

========================= brooklyn sample_2554 =========================

public BrooklynLauncher shutdownOnExit(boolean val) {	
call to deprecated shutdownonexit source of deprecated call 

protected void startWebApps() {	ManagementContext managementContext = getManagementContext();	BrooklynProperties brooklynProperties = (BrooklynProperties) managementContext.getConfig();	String securityProvider = managementContext.getConfig().getConfig(BrooklynWebConfig.SECURITY_PROVIDER_CLASSNAME);	boolean anyoneSecurityProvider = AnyoneSecurityProvider.class.getName().equals(securityProvider);	boolean noSecurityOptions = BrooklynWebConfig.hasNoSecurityOptions(managementContext.getConfig());	boolean skipSecurity = Boolean.TRUE.equals(skipSecurityFilter) || anyoneSecurityProvider || noSecurityOptions;	if (Boolean.TRUE.equals(skipSecurityFilter)) {	if (bindAddress == null) {	
starting brooklyn web console with security explicitly disabled on loopback because no bind address specified 

ManagementContext managementContext = getManagementContext();	BrooklynProperties brooklynProperties = (BrooklynProperties) managementContext.getConfig();	String securityProvider = managementContext.getConfig().getConfig(BrooklynWebConfig.SECURITY_PROVIDER_CLASSNAME);	boolean anyoneSecurityProvider = AnyoneSecurityProvider.class.getName().equals(securityProvider);	boolean noSecurityOptions = BrooklynWebConfig.hasNoSecurityOptions(managementContext.getConfig());	boolean skipSecurity = Boolean.TRUE.equals(skipSecurityFilter) || anyoneSecurityProvider || noSecurityOptions;	if (Boolean.TRUE.equals(skipSecurityFilter)) {	if (bindAddress == null) {	bindAddress = Networking.LOOPBACK;	} else {	
starting brooklyn web console with security explicitly disabled on bind address 

boolean anyoneSecurityProvider = AnyoneSecurityProvider.class.getName().equals(securityProvider);	boolean noSecurityOptions = BrooklynWebConfig.hasNoSecurityOptions(managementContext.getConfig());	boolean skipSecurity = Boolean.TRUE.equals(skipSecurityFilter) || anyoneSecurityProvider || noSecurityOptions;	if (Boolean.TRUE.equals(skipSecurityFilter)) {	if (bindAddress == null) {	bindAddress = Networking.LOOPBACK;	} else {	}	} else if (anyoneSecurityProvider) {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	
starting brooklyn web console with anyonesecurityprovider no authentication on bind address 

boolean skipSecurity = Boolean.TRUE.equals(skipSecurityFilter) || anyoneSecurityProvider || noSecurityOptions;	if (Boolean.TRUE.equals(skipSecurityFilter)) {	if (bindAddress == null) {	bindAddress = Networking.LOOPBACK;	} else {	}	} else if (anyoneSecurityProvider) {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	} else if (noSecurityOptions) {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	
starting brooklyn web console with no security options defaulting to no authentication on bind address 

bindAddress = Networking.LOOPBACK;	} else {	}	} else if (anyoneSecurityProvider) {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	} else if (noSecurityOptions) {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	} else {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	Map<?,?> securityProps = brooklynProperties.submap(ConfigPredicates.nameStartsWith(BrooklynWebConfig.BASE_NAME_SECURITY)).asMapWithStringKeys();	
starting brooklyn bind address using security properties 

}	} else if (anyoneSecurityProvider) {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	} else if (noSecurityOptions) {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	} else {	String bindAddressMsg = (bindAddress == null ? "<any>" : bindAddress.getHostAddress());	Map<?,?> securityProps = brooklynProperties.submap(ConfigPredicates.nameStartsWith(BrooklynWebConfig.BASE_NAME_SECURITY)).asMapWithStringKeys();	}	if (bindAddress == null) bindAddress = Networking.ANY_NIC;	
starting brooklyn web console with bindaddress and properties 

if (port!=null) webServer.setPort(port);	if (useHttps!=null) webServer.setHttpsEnabled(useHttps);	webServer.setShutdownHandler(shutdownHandler);	webServer.putAttributes(brooklynProperties.asMapWithStringKeys());	webServer.skipSecurity(skipSecurity);	for (WebAppContextProvider webapp : webApps) {	webServer.addWar(webapp);	}	webServer.start();	} catch (Exception e) {	
failed to start brooklyn web console rethrowing on port constraint 

protected void startBrooklynNode() {	if (webServer == null || !startWebApps) {	
skipping brooklynnode entity creation brooklynwebserver not running 

public void terminate() {	if (!isStarted()) return;	if (webServer != null) {	try {	webServer.stop();	} catch (Exception e) {	
error stopping web server continuing with termination 

}	}	ManagementContext managementContext = getManagementContext();	if (getPersistMode() != PersistMode.DISABLED) {	try {	Stopwatch stopwatch = Stopwatch.createStarted();	if (managementContext.getHighAvailabilityManager() != null && managementContext.getHighAvailabilityManager().getPersister() != null) {	managementContext.getHighAvailabilityManager().getPersister().waitForWritesCompleted(Duration.TEN_SECONDS);	}	managementContext.getRebindManager().waitForPendingComplete(Duration.TEN_SECONDS, true);	
finished waiting for persist took 

ManagementContext managementContext = getManagementContext();	if (getPersistMode() != PersistMode.DISABLED) {	try {	Stopwatch stopwatch = Stopwatch.createStarted();	if (managementContext.getHighAvailabilityManager() != null && managementContext.getHighAvailabilityManager().getPersister() != null) {	managementContext.getHighAvailabilityManager().getPersister().waitForWritesCompleted(Duration.TEN_SECONDS);	}	managementContext.getRebindManager().waitForPendingComplete(Duration.TEN_SECONDS, true);	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	
persistence interrupted during shutdown 

try {	Stopwatch stopwatch = Stopwatch.createStarted();	if (managementContext.getHighAvailabilityManager() != null && managementContext.getHighAvailabilityManager().getPersister() != null) {	managementContext.getHighAvailabilityManager().getPersister().waitForWritesCompleted(Duration.TEN_SECONDS);	}	managementContext.getRebindManager().waitForPendingComplete(Duration.TEN_SECONDS, true);	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
persistence interrupted during shutdown 

Stopwatch stopwatch = Stopwatch.createStarted();	if (managementContext.getHighAvailabilityManager() != null && managementContext.getHighAvailabilityManager().getPersister() != null) {	managementContext.getHighAvailabilityManager().getPersister().waitForWritesCompleted(Duration.TEN_SECONDS);	}	managementContext.getRebindManager().waitForPendingComplete(Duration.TEN_SECONDS, true);	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (TimeoutException e) {	
timeout after seconds waiting for persistence to write all data continuing 

========================= brooklyn sample_570 =========================

public void onItemAdded(final Item item) {	executor.submit(MutableMap.of("tag", delegate), new Runnable() {	public void run() {	try {	delegate.onItemAdded(item);	} catch (Throwable t) {	
error notifying listener of itemadded 

public void onItemRemoved(final Item item) {	executor.submit(MutableMap.of("tag", delegate), new Runnable() {	public void run() {	try {	delegate.onItemRemoved(item);	} catch (Throwable t) {	
error notifying listener of itemadded 

========================= brooklyn sample_1047 =========================

public void testHostsAgreeOnExternalIp() {	Set<String> ips = Sets.newHashSet();	for (String url : LocalhostExternalIpLoader.getIpAddressWebsites()) {	String ip = LocalhostExternalIpLoader.getIpAddressFrom(url);	
ip from 

========================= brooklyn sample_823 =========================

public Response postYaml(@Context UriInfo info, String yaml) {	
yaml pdp 

public Response postArchive(@Context UriInfo info, InputStream archiveInput) {	
archive pdp 

========================= brooklyn sample_1801 =========================

public void setLocationSpec(@Optional String locationSpec) {	this.locationSpec = !Strings.isBlank(locationSpec) ? locationSpec : DEFAULT_LOCATION;	
running with in 

Set<Integer> nodeIds = Sets.newHashSet();	for (Entity zkNode : ensemble.getMembers()) {	nodeIds.add(zkNode.config().get(ZooKeeperNode.MY_ID));	}	assertEquals(nodeIds.size(), initialSize, "expected " + initialSize + " node ids, found " + Iterables.toString(nodeIds));	List<String> servers = ensemble.sensors().get(ZooKeeperEnsemble.ZOOKEEPER_SERVERS);	assertNotNull(servers, "value for sensor should not be null: " + ZooKeeperEnsemble.ZOOKEEPER_SERVERS);	assertEquals(servers.size(), initialSize, "expected " + initialSize + " entries in " + servers);	String firstServer = servers.get(0);	HostAndPort conn = HostAndPort.fromString(firstServer);	
writing data to 

assertNotNull(servers, "value for sensor should not be null: " + ZooKeeperEnsemble.ZOOKEEPER_SERVERS);	assertEquals(servers.size(), initialSize, "expected " + initialSize + " entries in " + servers);	String firstServer = servers.get(0);	HostAndPort conn = HostAndPort.fromString(firstServer);	try (ZooKeeperTestSupport zkts = new ZooKeeperTestSupport(conn)) {	zkts.create(zkDataPath, "data".getBytes());	assertEquals(new String(zkts.get(zkDataPath)), "data");	}	for (int i = 1; i < servers.size(); i++) {	conn = HostAndPort.fromString(servers.get(i));	
asserting that data can be read from 

========================= brooklyn sample_435 =========================

public void testSimpleYamlDeploy() throws IOException {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-simple.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	
test created 

public void testSimpleYamlDeploy() throws IOException {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-simple.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	
app 

public void testSimpleYamlDeploy() throws IOException {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-simple.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	Assert.assertEquals(app.getDisplayName(), "sample-single-jboss");	Asserts.assertSize(app.getLocations(), 1);	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	
waiting on task s 

AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	Assert.assertEquals(app.getDisplayName(), "sample-single-jboss");	Asserts.assertSize(app.getLocations(), 1);	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	for (Task<?> t: tasks) {	t.blockUntilEnded();	}	
app started 

public void testWithDbDeploy() throws IOException {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-and-db-with-function.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	
test created 

public void testWithDbDeploy() throws IOException {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-and-db-with-function.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	
app 

Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	Asserts.assertSize(app.getLocations(), 1);	Iterator<ResolvableLink<PlatformComponent>> pcs = assembly.getPlatformComponents().links().iterator();	PlatformComponent pc1 = pcs.next().resolve();	Entity cluster = brooklynMgmt.getEntityManager().getEntity(pc1.getId());	log.info("pc1 - "+pc1+" - "+cluster);	PlatformComponent pc2 = pcs.next().resolve();	log.info("pc2 - "+pc2);	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	
waiting on task s 

Iterator<ResolvableLink<PlatformComponent>> pcs = assembly.getPlatformComponents().links().iterator();	PlatformComponent pc1 = pcs.next().resolve();	Entity cluster = brooklynMgmt.getEntityManager().getEntity(pc1.getId());	log.info("pc1 - "+pc1+" - "+cluster);	PlatformComponent pc2 = pcs.next().resolve();	log.info("pc2 - "+pc2);	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	AtomicInteger i = new AtomicInteger(0);	for (Task<?> t: tasks) {	t.blockUntilEnded();	
completed task 

PlatformComponent pc1 = pcs.next().resolve();	Entity cluster = brooklynMgmt.getEntityManager().getEntity(pc1.getId());	log.info("pc1 - "+pc1+" - "+cluster);	PlatformComponent pc2 = pcs.next().resolve();	log.info("pc2 - "+pc2);	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	AtomicInteger i = new AtomicInteger(0);	for (Task<?> t: tasks) {	t.blockUntilEnded();	}	
app started 

public void testWithPolicyDeploy() {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-and-db-with-policy.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	
test created 

public void testWithPolicyDeploy() {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-and-db-with-policy.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	
app 

public void testWithPolicyDeploy() {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-and-db-with-policy.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	Asserts.assertSize(app.getLocations(), 1);	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	
waiting on task s 

Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-and-db-with-policy.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	try {	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	final Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	Asserts.assertSize(app.getLocations(), 1);	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	for (Task<?> t: tasks) {	t.blockUntilEnded();	}	
app started 

========================= brooklyn sample_29 =========================

List<Exception> exceptions = Lists.newArrayList();	try {	if (machines != null) {	exceptions.addAll(releaseMachineSafely(machines));	machines.clear();	}	} finally {	try {	if (managementContext != null) Entities.destroyAll(managementContext);	} catch (Exception e) {	
error destroying management context 

protected List<Exception> releaseMachineSafely(Iterable<? extends JcloudsMachineLocation> machines) {	List<Exception> exceptions = Lists.newArrayList();	for (JcloudsMachineLocation machine : machines) {	try {	releaseMachine(machine);	} catch (Exception e) {	
error releasing machine continuing 

========================= brooklyn sample_2542 =========================

public void onEvent(SensorEvent<Object> event) {	Entity e = event.getSource();	if (entityFilter.apply(e)) {	synchronized (values) {	Map<Entity,Object> vs = values.get(event.getSensor().getName());	if (vs==null) {	
received event when no entry for sensor likely just added or removed and will initialize subsequently if needed 

========================= brooklyn sample_1010 =========================

return true;	}	});	URLConnection connection = url.openConnection();	TrustingSslSocketFactory.configure(connection);	connection.connect();	connection.getContentLength();	return connection;	} catch (Exception e) {	exception.set(e);	
error connecting to url propagating 

public static int getHttpStatusCode(String url) throws Exception {	URLConnection connection = connectToUrl(url);	long startTime = System.currentTimeMillis();	int status = ((HttpURLConnection) connection).getResponseCode();	consumeAndCloseQuietly((HttpURLConnection) connection);	
connection to ms gives 

public static void assertContentContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String contents = getContent(url);	Assert.assertTrue(contents != null && contents.length() > 0);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (!contents.contains(text)) {	
contents of url missing text 

public static void assertContentNotContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String contents = getContent(url);	Assert.assertTrue(contents != null);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (contents.contains(text)) {	
contents of url has text 

public static void assertErrorContentContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String contents = getErrorContent(url);	Assert.assertTrue(contents != null && contents.length() > 0);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (!contents.contains(text)) {	
contents of url missing text 

public static void assertErrorContentNotContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String err = getErrorContent(url);	Assert.assertTrue(err != null);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (err.contains(text)) {	
contents of url has text 

long startTime = System.currentTimeMillis();	String err;	int status;	try {	InputStream errStream = connection.getErrorStream();	err = Streams.readFullyStringAndClose(errStream);	status = connection.getResponseCode();	} finally {	closeQuietly(connection);	}	
read of err ms complete http code 

========================= brooklyn sample_2779 =========================

public void test_Centos_6() throws Exception { }	protected void doTest(Location loc) throws Exception {	
testing in 

public void test_Centos_6() throws Exception { }	protected void doTest(Location loc) throws Exception {	final EmptySoftwareProcess server = app.createAndManageChild(EntitySpec.create(EmptySoftwareProcess.class));	app.start(ImmutableList.of(loc));	
app started waiting for running 

========================= brooklyn sample_2283 =========================

public Maybe<T> getMaybe() {	Maybe<T> result = getMaybeInternal();	if (log.isTraceEnabled()) {	
evaluated as 

if (allowImmediateExecution && isEvaluatingImmediately()) {	Maybe<T> result = null;	try {	result = exec.getImmediately(v);	return (result.isPresent()) ? recursive ? new ValueResolver<T>(result.get(), type, this).getMaybe() : result : result;	} catch (ImmediateSupplier.ImmediateUnsupportedException e) {	if (bailOutAfterImmediateExecution) {	throw new ImmediateSupplier.ImmediateUnsupportedException("Cannot get immediately: "+v);	}	if (log.isTraceEnabled()) {	
unable to resolve immediately for unsupported type falling back to executing with timeout 

return Maybe.of((T) result);	} else {	return TypeCoercions.tryCoerce(v, TypeToken.of(type));	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	String msg = "Error resolving "+(description!=null ? description+", " : "")+v+", in "+exec;	String eTxt = Exceptions.collapseText(e);	IllegalArgumentException problem = eTxt.startsWith(msg) ? new IllegalArgumentException(e) : new IllegalArgumentException(msg+": "+eTxt, e);	if (swallowExceptions) {	
resolution of failed swallowing and returning 

return TypeCoercions.tryCoerce(v, TypeToken.of(type));	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	String msg = "Error resolving "+(description!=null ? description+", " : "")+v+", in "+exec;	String eTxt = Exceptions.collapseText(e);	IllegalArgumentException problem = eTxt.startsWith(msg) ? new IllegalArgumentException(e) : new IllegalArgumentException(msg+": "+eTxt, e);	if (swallowExceptions) {	return Maybe.absent(problem);	}	
resolution of failed throwing 

========================= brooklyn sample_1505 =========================

URI uri = null;	try {	String yamlUrl = yaml.trim();	if (Urls.isUrlWithProtocol(yamlUrl)) {	uri = new URI(yamlUrl);	}	} catch (URISyntaxException e) {	uri = null;	}	if (uri != null) {	
create app called with uri retrieving contents 

uri = null;	}	if (uri != null) {	try {	yaml = ResourceUtils.create(mgmt()).getResourceAsString(uri.toString());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	throw new UserFacingException("Cannot resolve URL: "+uri, e);	}	}	
creating app from yaml 

} catch (Exception e) {	Exceptions.propagateIfFatal(e);	throw new UserFacingException("Cannot resolve URL: "+uri, e);	}	}	EntitySpec<? extends Application> spec;	try {	spec = createEntitySpecForApplication(yaml);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
failed rest deployment could not create spec 

throw new UserFacingException("Cannot resolve URL: "+uri, e);	}	}	EntitySpec<? extends Application> spec;	try {	spec = createEntitySpecForApplication(yaml);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	UserFacingException userFacing = Exceptions.getFirstThrowableOfType(e, UserFacingException.class);	if (userFacing!=null) {	
throwing wrapped in 

throw userFacing;	}	throw WebResourceUtils.badRequest(e, "Error in blueprint");	}	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.DEPLOY_APPLICATION, spec)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to start application %s", Entitlements.getEntitlementContext().user(), yaml);	}	try {	return launch(yaml, spec, appId);	} catch (IdAlreadyExistsException e) {	
failed rest deployment launching 

}	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.DEPLOY_APPLICATION, spec)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to start application %s", Entitlements.getEntitlementContext().user(), yaml);	}	try {	return launch(yaml, spec, appId);	} catch (IdAlreadyExistsException e) {	throw WebResourceUtils.throwWebApplicationException(Response.Status.CONFLICT, e, "Error launching blueprint, id already exists");	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
failed rest deployment launching 

private Response launch(String yaml, EntitySpec<? extends Application> spec, Optional<String> entityId) {	try {	Application app = EntityManagementUtils.createUnstarted(mgmt(), spec, entityId);	boolean isEntitled = Entitlements.isEntitled( mgmt().getEntitlementManager(), Entitlements.INVOKE_EFFECTOR, EntityAndItem.of(app, StringAndArgument.of(Startable.START.getName(), null)));	if (!isEntitled) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to start application %s", Entitlements.getEntitlementContext().user(), spec.getType());	}	CreationResult<Application,Void> result = EntityManagementUtils.start(app);	waitForStart(app, Duration.millis(100));	
launched from yaml 

public Response createPoly(byte[] inputToAutodetectType) {	
creating app from autodetecting input 

Exception legacyFormatException = null;	try {	ApplicationSpec appSpec = mapper().readValue(inputToAutodetectType, ApplicationSpec.class);	if (appSpec.getType() != null || appSpec.getEntities() != null) {	looksLikeLegacy = true;	}	return createFromAppSpec(appSpec);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	legacyFormatException = e;	
input is not legacy applicationspec json will try others 

} catch (Exception e) {	Exceptions.propagateIfFatal(e);	legacyFormatException = e;	}	String potentialYaml = new String(inputToAutodetectType);	EntitySpec<? extends Application> spec;	try {	spec = createEntitySpecForApplication(potentialYaml);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
failed rest deployment could not create spec autodetecting 

spec = createEntitySpecForApplication(potentialYaml);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	throw WebResourceUtils.badRequest(e, "Error in blueprint");	}	if (spec != null) {	try {	return launch(potentialYaml, spec, Optional.absent());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
failed rest deployment launching 

public Response createFromForm(String contents) {	
creating app from form 

private void checkSpecTypeIsValid(String type, Class<? extends BrooklynObject> subType) {	Maybe<RegisteredType> typeV = RegisteredTypes.tryValidate(mgmt().getTypeRegistry().get(type), RegisteredTypeLoadingContexts.spec(subType));	if (!typeV.isNull()) {	typeV.get();	return;	}	try {	brooklyn().getCatalogClassLoader().loadClass(type);	} catch (ClassNotFoundException e) {	
class not found for type reporting 

Maybe<RegisteredType> typeV = RegisteredTypes.tryValidate(mgmt().getTypeRegistry().get(type), RegisteredTypeLoadingContexts.spec(subType));	if (!typeV.isNull()) {	typeV.get();	return;	}	try {	brooklyn().getCatalogClassLoader().loadClass(type);	} catch (ClassNotFoundException e) {	throw WebResourceUtils.notFound("Undefined type '%s'", type);	}	
type not defined in catalog but is on classpath continuing 

Map<String, Object> result = MutableMap.of();	Iterator<Entity> di = descs.iterator();	Sensor<?> s = null;	while (di.hasNext()) {	Entity potentialSource = di.next();	s = potentialSource.getEntityType().getSensor(sensor);	if (s!=null) break;	}	if (s==null) s = Sensors.newSensor(Object.class, sensor);	if (!(s instanceof AttributeSensor<?>)) {	
cannot retrieve non attribute sensor for entities returning empty map 

if (s==null) s = Sensors.newSensor(Object.class, sensor);	if (!(s instanceof AttributeSensor<?>)) {	return result;	}	for (Entity e: descs) {	Object v = null;	try {	v = e.getAttribute((AttributeSensor<?>)s);	} catch (Exception exc) {	Exceptions.propagateIfFatal(exc);	
error retrieving sensor for ignoring 

========================= brooklyn sample_2903 =========================

protected ExecutionContext getExecutionContext(BrooklynObject bo) {	Entity contextEntity = BrooklynTaskTags.getTargetOrContextEntity(Tasks.current());	if (contextEntity != null) {	return ((EntityInternal)contextEntity).getExecutionContext();	} else {	
no resolving context found will use global execution context could lead to npe on dsl resolving 

========================= brooklyn sample_1293 =========================

public void testDeployApplication() throws Exception {	Response response = clientDeploy(simpleSpec);	HttpAsserts.assertHealthyStatusCode(response.getStatus());	assertEquals(getManagementContext().getApplications().size(), 1);	assertRegexMatches(response.getLocation().getPath(), "/applications/.*");	TaskSummary task = response.readEntity(TaskSummary.class);	
deployed got 

public void testListApplications() {	Set<ApplicationSummary> applications = client().path("/applications") .get(new GenericType<Set<ApplicationSummary>>() { });	
applications listed are 

public void testGetApplicationOnFire() {	Application app = Iterables.find(manager.getApplications(), EntityPredicates.displayNameEqualTo(simpleSpec.getName()));	Lifecycle origState = app.getAttribute(Attributes.SERVICE_STATE_ACTUAL);	ApplicationSummary summary = client().path("/applications/"+app.getId()) .get(ApplicationSummary.class);	assertEquals(summary.getStatus(), Status.RUNNING);	app.sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.ON_FIRE);	try {	ApplicationSummary summary2 = client().path("/applications/"+app.getId()) .get(ApplicationSummary.class);	
application 

public void testFetchApplicationsAndEntity() {	Collection apps = client().path("/applications/fetch").get(Collection.class);	
applications fetched are 

Assert.assertFalse(Strings.isBlank((String) app.get("serviceState")), "expected value for serviceState, was: " + app.get("serviceState"));	Assert.assertNotNull(app.get("serviceUp"), "expected non-null value for serviceUp");	Collection children = (Collection) app.get("children");	Assert.assertEquals(children.size(), 2);	Map entitySummary = (Map) Iterables.find(children, withValueForKey("name", "simple-ent"), null);	Map groupSummary = (Map) Iterables.find(children, withValueForKey("name", "simple-group"), null);	Assert.assertNotNull(entitySummary);	Assert.assertNotNull(groupSummary);	String itemIds = app.get("id") + "," + entitySummary.get("id") + "," + groupSummary.get("id");	Collection entities = client().path("/applications/fetch").query("items", itemIds) .get(Collection.class);	
applications entities fetched are 

Assert.assertNull(groupDetails.get("children"));	Collection entityGroupIds = (Collection) entityDetails.get("groupIds");	Assert.assertNotNull(entityGroupIds);	Assert.assertEquals(entityGroupIds.size(), 1);	Assert.assertEquals(entityGroupIds.iterator().next(), groupDetails.get("id"));	Collection groupMembers = (Collection) groupDetails.get("members");	Assert.assertNotNull(groupMembers);	for (Application appi : getManagementContext().getApplications()) {	Entities.dumpInfo(appi);	}	
members 

public void testPolicyWhichCapitalizes() throws Exception {	String policiesEndpoint = "/applications/simple-app/entities/simple-ent/policies";	Set<PolicySummary> policies = client().path(policiesEndpoint).get(new GenericType<Set<PolicySummary>>(){});	assertEquals(policies.size(), 0);	Response response = client().path(policiesEndpoint) .query("type", CapitalizePolicy.class.getCanonicalName()) .type(MediaType.APPLICATION_JSON_TYPE) .post(toJsonEntity(ImmutableMap.of()));	assertEquals(response.getStatus(), 200);	PolicySummary policy = response.readEntity(PolicySummary.class);	assertNotNull(policy.getId());	String newPolicyId = policy.getId();	
policy created 

Set<PolicySummary> policies = client().path(policiesEndpoint).get(new GenericType<Set<PolicySummary>>(){});	assertEquals(policies.size(), 0);	Response response = client().path(policiesEndpoint) .query("type", CapitalizePolicy.class.getCanonicalName()) .type(MediaType.APPLICATION_JSON_TYPE) .post(toJsonEntity(ImmutableMap.of()));	assertEquals(response.getStatus(), 200);	PolicySummary policy = response.readEntity(PolicySummary.class);	assertNotNull(policy.getId());	String newPolicyId = policy.getId();	policies = client().path(policiesEndpoint).get(new GenericType<Set<PolicySummary>>() {});	assertEquals(policies.size(), 1);	Lifecycle status = client().path(policiesEndpoint + "/" + newPolicyId).get(Lifecycle.class);	
policy status 

assertEquals(response.getStatus(), 204);	status = client().path(policiesEndpoint + "/" + newPolicyId).get(Lifecycle.class);	assertEquals(status, Lifecycle.RUNNING);	response = client().path(policiesEndpoint+"/"+newPolicyId+"/stop") .post(null);	assertEquals(response.getStatus(), 204);	status = client().path(policiesEndpoint + "/" + newPolicyId).get(Lifecycle.class);	assertEquals(status, Lifecycle.STOPPED);	response = client().path(policiesEndpoint+"/"+newPolicyId+"/destroy") .post(null);	assertEquals(response.getStatus(), 204);	response = client().path(policiesEndpoint+"/"+newPolicyId).get();	
policy status response after destroy 

public void testLocatedLocation() {	
starting testlocatedlocations 

public void testLocatedLocation() {	testListApplications();	LocationInternal l = (LocationInternal) getManagementContext().getApplications().iterator().next().getLocations().iterator().next();	if (l.config().getLocalRaw(LocationConfigKeys.LATITUDE).isAbsent()) {	
supplying fake locations for localhost because could not be autodetected 

public void testLocatedLocation() {	testListApplications();	LocationInternal l = (LocationInternal) getManagementContext().getApplications().iterator().next().getLocations().iterator().next();	if (l.config().getLocalRaw(LocationConfigKeys.LATITUDE).isAbsent()) {	((AbstractLocation) l).setHostGeoInfo(new HostGeoInfo("localhost", "localhost", 50, 0));	}	Map result = client().path("/locations/usage/LocatedLocations") .get(Map.class);	
locations 

public void testDeleteApplication() throws TimeoutException, InterruptedException {	waitForPageFoundResponse("/applications/simple-app", ApplicationSummary.class);	Collection<Application> apps = getManagementContext().getApplications();	
deleting simple app from 

public void testDeleteApplication() throws TimeoutException, InterruptedException {	waitForPageFoundResponse("/applications/simple-app", ApplicationSummary.class);	Collection<Application> apps = getManagementContext().getApplications();	int size = apps.size();	Response response = client().path("/applications/simple-app") .delete();	assertEquals(response.getStatus(), Response.Status.ACCEPTED.getStatusCode());	TaskSummary task = response.readEntity(TaskSummary.class);	assertTrue(task.getDescription().toLowerCase().contains("destroy"), task.getDescription());	assertTrue(task.getDescription().toLowerCase().contains("simple-app"), task.getDescription());	waitForPageNotFoundResponse("/applications/simple-app", ApplicationSummary.class);	
app appears gone apps are 

========================= brooklyn sample_2846 =========================

public void apply(final EntityLocal entity) {	super.apply(entity);	if (LOG.isDebugEnabled()) {	
adding winrm sensor to 

========================= brooklyn sample_2145 =========================

public void launch() {	AbstractMongoDBServer server = getServer();	String host = server.getAttribute(AbstractMongoDBServer.HOSTNAME);	Integer port = server.getAttribute(AbstractMongoDBServer.PORT);	List<String> scripts = entity.getConfig(MongoDBClient.STARTUP_JS_SCRIPTS);	if (scripts!=null) {	for (String scriptName : scripts) {	try {	
running mongodb script at 

public void launch() {	AbstractMongoDBServer server = getServer();	String host = server.getAttribute(AbstractMongoDBServer.HOSTNAME);	Integer port = server.getAttribute(AbstractMongoDBServer.PORT);	List<String> scripts = entity.getConfig(MongoDBClient.STARTUP_JS_SCRIPTS);	if (scripts!=null) {	for (String scriptName : scripts) {	try {	runScript("", scriptName, host, port);	} catch (Exception e) {	
error running mongodb script at throwing 

private AbstractMongoDBServer getServer() {	AbstractMongoDBServer server = entity.getConfig(MongoDBClient.SERVER);	MongoDBShardedDeployment deployment = entity.getConfig(MongoDBClient.SHARDED_DEPLOYMENT);	if (server == null) {	Preconditions.checkNotNull(deployment, "Either server or shardedDeployment must be specified for %s", this);	server = DependentConfiguration.builder() .attributeWhenReady(deployment.getRouterCluster(), MongoDBRouterCluster.ANY_ROUTER) .blockingDetails("any available router") .runNow();	DependentConfiguration.builder() .attributeWhenReady(server, MongoDBRouter.SHARD_COUNT) .readiness(MathPredicates.<Integer>greaterThan(0)) .runNow();	} else {	if (deployment != null) {	
server and shardeddeployment defined for using server instead of 

========================= brooklyn sample_383 =========================

public List<V> asImmutableCopy() {	try {	return ImmutableList.copyOf(this);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error converting list to immutable using unmodifiable instead 

========================= brooklyn sample_2098 =========================

public void stop() {	JmxAgentModes jmxMode = entity.getConfig(UsesJmx.JMX_AGENT_MODE);	if (jmxMode == JmxAgentModes.JMX_RMI_CUSTOM_AGENT) {	String host = entity.getAttribute(Attributes.HOSTNAME);	Integer port = entity.getAttribute(UsesJmx.RMI_REGISTRY_PORT);	List<String> shutdownScript = new LinkedList<String>();	shutdownScript.add(format("%s/bin/shutdown.sh --host %s --port %s -S", getExpandedInstallDir(), host, port));	
invoking shutdown script for 

JmxAgentModes jmxMode = entity.getConfig(UsesJmx.JMX_AGENT_MODE);	if (jmxMode == JmxAgentModes.JMX_RMI_CUSTOM_AGENT) {	String host = entity.getAttribute(Attributes.HOSTNAME);	Integer port = entity.getAttribute(UsesJmx.RMI_REGISTRY_PORT);	List<String> shutdownScript = new LinkedList<String>();	shutdownScript.add(format("%s/bin/shutdown.sh --host %s --port %s -S", getExpandedInstallDir(), host, port));	Map<String, Object> flags = new LinkedHashMap<String, Object>();	flags.put("env", new LinkedHashMap<String, String>());	int result = execute(flags, shutdownScript, "shutdown " + entity + " on " + getMachine());	if (result != 0) log.warn("non-zero result code terminating {}: {}", entity, result);	
done invoking shutdown script for 

========================= brooklyn sample_229 =========================

public void testTagsDoNotSerializeTooMuch() throws Exception {	entity.tags().addTag("foo");	entity.tags().addTag(entity.getParent());	Response response = client().path(entityEndpoint + "/tags") .accept(MediaType.APPLICATION_JSON) .get();	String raw = response.readEntity(String.class);	
tags raw 

Response response = client().path(entityEndpoint + "/tags") .accept(MediaType.APPLICATION_JSON) .get();	String raw = response.readEntity(String.class);	HttpAsserts.assertHealthyStatusCode(response.getStatus());	Assert.assertTrue(raw.contains(entity.getParent().getId()), "unexpected app tag, does not include ID: "+raw);	Assert.assertTrue(raw.length() < 1000, "unexpected app tag, includes too much mgmt info (len "+raw.length()+"): "+raw);	Assert.assertFalse(raw.contains(entity.getManagementContext().getManagementNodeId()), "unexpected app tag, includes too much mgmt info: "+raw);	Assert.assertFalse(raw.contains("managementContext"), "unexpected app tag, includes too much mgmt info: "+raw);	Assert.assertFalse(raw.contains("localhost"), "unexpected app tag, includes too much mgmt info: "+raw);	Assert.assertFalse(raw.contains("catalog"), "unexpected app tag, includes too much mgmt info: "+raw);	List<Object> tags = mapper().readValue(raw, List.class);	
tags are 

========================= brooklyn sample_2831 =========================

public static void assertContentContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String contents = HttpTool.getContent(url);	Asserts.assertTrue(contents != null && contents.length() > 0);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (!contents.contains(text)) {	
contents of url missing text 

public static void assertContentNotContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String contents = HttpTool.getContent(url);	Asserts.assertTrue(contents != null);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (contents.contains(text)) {	
contents of url has text 

public static void assertErrorContentContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String contents = HttpTool.getErrorContent(url);	Asserts.assertTrue(contents != null && contents.length() > 0);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (!contents.contains(text)) {	
contents of url missing text 

public static void assertErrorContentNotContainsText(final String url, final String phrase, final String ...additionalPhrases) {	try {	String err = HttpTool.getErrorContent(url);	Asserts.assertTrue(err != null);	for (String text: Lists.asList(phrase, additionalPhrases)) {	if (err.contains(text)) {	
contents of url has text 

========================= brooklyn sample_2077 =========================

final Duration backoffToPeriod = getConfig(BACKOFF_TO_PERIOD);	final HttpAssertionTarget target = getRequiredConfig(ASSERTION_TARGET);	final boolean trustAll = getRequiredConfig(TRUST_ALL);	if (!getChildren().isEmpty()) {	throw new RuntimeException(String.format("The entity [%s] cannot have child entities", getClass().getName()));	}	doRequestAndCheckAssertions(MutableMap.of("timeout", timeout, "backoffToPeriod", backoffToPeriod, "maxAttempts", maxAttempts), assertions, target, method, url, headers, trustAll, body);	setUpAndRunState(true, Lifecycle.RUNNING);	} catch (Throwable t) {	if (url != null) {	
url test failed rethrowing 

final HttpAssertionTarget target = getRequiredConfig(ASSERTION_TARGET);	final boolean trustAll = getRequiredConfig(TRUST_ALL);	if (!getChildren().isEmpty()) {	throw new RuntimeException(String.format("The entity [%s] cannot have child entities", getClass().getName()));	}	doRequestAndCheckAssertions(MutableMap.of("timeout", timeout, "backoffToPeriod", backoffToPeriod, "maxAttempts", maxAttempts), assertions, target, method, url, headers, trustAll, body);	setUpAndRunState(true, Lifecycle.RUNNING);	} catch (Throwable t) {	if (url != null) {	} else {	
url test failed no url rethrowing 

private void doRequestAndCheckAssertions(Map<String, ?> flags, List<Map<String, Object>> assertions, HttpAssertionTarget target, final HttpMethod method, final String url, final Map<String, String> headers, final boolean trustAll, final String body) {	switch (target) {	case body: Supplier<String> getBody = new Supplier<String>() {	public String get() {	try {	final HttpRequestBase httpMethod = createHttpMethod(method, url, headers, body);	return HttpTool.execAndConsume(HttpTool.httpClientBuilder().uri(url).trustAll(trustAll).build(), httpMethod).getContentAsString();	} catch (Exception e) {	
http call to failed due to 

public Integer get() {	try {	final HttpRequestBase httpMethod = createHttpMethod(method, url, headers, body);	final Maybe<HttpResponse> response = HttpTool.execAndConsume(HttpTool.httpClientBuilder().uri(url).trustAll(trustAll).build(), httpMethod).getResponse();	if (response.isPresentAndNonNull()) {	return response.get().getStatusLine().getStatusCode();	} else {	throw new Exception("HTTP call did not return any response");	}	} catch (Exception e) {	
http call to failed due to 

========================= brooklyn sample_2427 =========================

public void testGroupDetectsChangedEntitiesMatchingFilter() throws Exception {	final AttributeSensor<String> MY_ATTRIBUTE = Sensors.newStringSensor("test.myAttribute", "My test attribute");	group.setEntityFilter(new Predicate<Entity>() {	if (!("yes".equals(input.getAttribute(MY_ATTRIBUTE)))) {	return false;	} else if (input.equals(e1)) {	
testgroupdetectschangedentitiesmatchingfilter scanned when my attribute is yes not a bug but indicates things may be running slowly 

public void onEvent(SensorEvent<Entity> event) {	try {	TestEntity val = (TestEntity) event.getValue();	LOG.debug("Notified of member added: member={}, thread={}", val.getId(), Thread.currentThread().getName());	assertEquals(group, event.getSource());	assertTrue(entitiesNotified.add(val));	addedNotifications.incrementAndGet();	} catch (Throwable t) {	
error on event event 

public void onEvent(SensorEvent<Entity> event) {	try {	TestEntity val = (TestEntity) event.getValue();	LOG.debug("Notified of member removed: member={}, thread={}", val.getId(), Thread.currentThread().getName());	assertEquals(group, event.getSource());	assertTrue(entitiesNotified.remove(val));	removedNotifications.incrementAndGet();	} catch (Throwable t) {	
error on event event 

========================= brooklyn sample_946 =========================

private void validateAllTypes(Set<RegisteredType> installedTypes) {	Stopwatch sw = Stopwatch.createStarted();	
getting catalog to validate all types 

private void validateAllTypes(Set<RegisteredType> installedTypes) {	Stopwatch sw = Stopwatch.createStarted();	final BrooklynCatalog catalog = this.managementContext.getCatalog();	
got catalog in now validate 

private void validateAllTypes(Set<RegisteredType> installedTypes) {	Stopwatch sw = Stopwatch.createStarted();	final BrooklynCatalog catalog = this.managementContext.getCatalog();	sw.reset(); sw.start();	Map<RegisteredType, Collection<Throwable>> validationErrors = catalog.validateTypes( installedTypes );	
validation done in 

protected void instantiateLocationsAndEntities() {	checkEnteringPhase(3);	logRebindingDebug("RebindManager instantiating locations: {}", mementoManifest.getLocationIdToType().keySet());	for (Map.Entry<String, String> entry : mementoManifest.getLocationIdToType().entrySet()) {	String locId = entry.getKey();	String locType = entry.getValue();	
rebindmanager instantiating location 

Location location = instantiator.newLocation(locId, locType);	rebindContext.registerLocation(locId, location);	} catch (Exception e) {	exceptionHandler.onCreateFailed(BrooklynObjectType.LOCATION, locId, locType, e);	}	}	logRebindingDebug("RebindManager instantiating entities: {}", mementoManifest.getEntityIdToManifest().keySet());	for (Map.Entry<String, EntityMementoManifest> entry : mementoManifest.getEntityIdToManifest().entrySet()) {	String entityId = entry.getKey();	EntityMementoManifest entityManifest = entry.getValue();	
rebindmanager instantiating entity 

protected void initPlaneId() {	String persistedPlaneId = mementoRawData.getPlaneId();	if (persistedPlaneId == null) {	if (!mementoRawData.isEmpty()) {	
rebinding against existing persisted state but no planeid found will generate a new one expected if this is the first rebind after upgrading to brooklyn 

} catch (Exception e) {	exceptionHandler.onCreateFailed(BrooklynObjectType.ENRICHER, enricherMemento.getId(), enricherMemento.getType(), e);	}	}	} else {	logRebindingDebug("Not rebinding enrichers; feature disabled: {}", memento.getEnricherIds());	}	if (rebindManager.persistFeedsEnabled) {	logRebindingDebug("RebindManager instantiating feeds: {}", memento.getFeedIds());	for (FeedMemento feedMemento : memento.getFeedMementos().values()) {	
rebindmanager instantiating feed 

String fixedSearchItemId = null;	RegisteredType t1 = managementContext.getTypeRegistry().get(searchItemId);	if (t1!=null) fixedSearchItemId = t1.getId();	if (fixedSearchItemId==null) {	CatalogItem<?, ?> ci = findCatalogItemInReboundCatalog(bType, searchItemId, contextSuchAsId);	if (ci!=null) fixedSearchItemId = ci.getCatalogItemId();	}	if (fixedSearchItemId != null) {	reboundSearchPath.add(fixedSearchItemId);	} else {	
unable to load catalog item for search path of attempting to load nevertheless 

transformedCatalogItemId = catalogItem.getCatalogItemId();	}	}	if (transformedCatalogItemId!=null) {	try {	BrooklynClassLoadingContextSequential loader = new BrooklynClassLoadingContextSequential(managementContext);	loader.add(newClassLoadingContextForCatalogItems(managementContext, transformedCatalogItemId, reboundSearchPath));	return new LoadedClass<T>(loader.loadClass(jType, bType), transformedCatalogItemId, reboundSearchPath);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to load class needed for for via loader will try reflections 

}	if (transformedCatalogItemId!=null) {	try {	BrooklynClassLoadingContextSequential loader = new BrooklynClassLoadingContextSequential(managementContext);	loader.add(newClassLoadingContextForCatalogItems(managementContext, transformedCatalogItemId, reboundSearchPath));	return new LoadedClass<T>(loader.loadClass(jType, bType), transformedCatalogItemId, reboundSearchPath);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	}	} else {	
unable to load catalog item for will try reflection 

} catch (Exception e) {	Exceptions.propagateIfFatal(e);	}	} else {	}	}	try {	return new LoadedClass<T>((Class<T>)loadClass(jType), catalogItemId, reboundSearchPath);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to load class needed for for via reflections may try others will throw if fails 

Exceptions.propagateIfFatal(e);	}	if (catalogItemId != null) {	throw new IllegalStateException("Unable to load "+jType+" for catalog item " + catalogItemId + " for " + contextSuchAsId);	} else if (BrooklynFeatureEnablement.isEnabled(FEATURE_BACKWARDS_COMPATIBILITY_INFER_CATALOG_ITEM_ON_REBIND)) {	BrooklynCatalog catalog = managementContext.getCatalog();	for (CatalogItem<?, ?> item : catalog.getCatalogItemsLegacy()) {	BrooklynClassLoadingContext catalogLoader = CatalogUtils.newClassLoadingContext(managementContext, item);	Maybe<Class<?>> catalogClass = catalogLoader.tryLoadClass(jType);	if (catalogClass.isPresent()) {	
found only by scanning catalog item search paths 

========================= brooklyn sample_1122 =========================

public ManagementNodeSyncRecord choose(ManagementPlaneSyncRecord memento, Duration heartbeatTimeout, String ownNodeId) {	
choosing new master from 

public ManagementNodeSyncRecord choose(ManagementPlaneSyncRecord memento, Duration heartbeatTimeout, String ownNodeId) {	ManagementNodeSyncRecord me = memento.getManagementNodes().get(ownNodeId);	if (me==null) {	
management node details not known when choosing new master 

public ManagementNodeSyncRecord choose(ManagementPlaneSyncRecord memento, Duration heartbeatTimeout, String ownNodeId) {	ManagementNodeSyncRecord me = memento.getManagementNodes().get(ownNodeId);	if (me==null) {	return null;	}	Long nowIsh = me.getRemoteTimestamp();	if (nowIsh==null) {	
management node for self missing timestamp when choosing new master 

========================= brooklyn sample_1088 =========================

private Future<ReplicationSnapshot> createMasterReplicationSnapshot(final MySqlNode master, final String dumpName) {	
mysql cluster generating new replication snapshot on master node with name 

private Future<ReplicationSnapshot> createSlaveReplicationSnapshot(final MySqlNode slave, final String dumpName) {	MySqlClusterUtils.executeSqlOnNodeAsync(slave, "STOP SLAVE SQL_THREAD;");	try {	
mysql cluster generating new replication snapshot on slave node with name 

private MySqlNode getSnapshotNode() {	String snapshotNodeId = cluster.getConfig(MySqlCluster.REPLICATION_PREFERRED_SOURCE);	if (snapshotNodeId != null) {	Optional<Entity> preferredNode = Iterables.tryFind(cluster.getMembers(), EntityPredicates.idEqualTo(snapshotNodeId));	if (preferredNode.isPresent()) {	return (MySqlNode) preferredNode.get();	} else {	
mysql cluster configured with preferred snapshot node but it s not a member defaulting to a random slave 

private boolean isReplicationInfoValid(ReplicationSnapshot replicationSnapshot) {	MySqlNode master = getMaster();	String dataDir = Strings.nullToEmpty(master.getConfig(MySqlNode.DATA_DIR));	if (!checkFileExistsOnEntity(master, Os.mergePathsUnix(dataDir, replicationSnapshot.getBinLogName()))) {	return false;	}	if (replicationSnapshot.getEntityId() != null) {	Optional<Entity> snapshotSlave = Iterables.tryFind(cluster.getChildren(), EntityPredicates.idEqualTo(replicationSnapshot.getEntityId()));	if (!snapshotSlave.isPresent()) {	
mysql cluster missing node with last snapshot will generate new snapshot 

String dataDir = Strings.nullToEmpty(master.getConfig(MySqlNode.DATA_DIR));	if (!checkFileExistsOnEntity(master, Os.mergePathsUnix(dataDir, replicationSnapshot.getBinLogName()))) {	return false;	}	if (replicationSnapshot.getEntityId() != null) {	Optional<Entity> snapshotSlave = Iterables.tryFind(cluster.getChildren(), EntityPredicates.idEqualTo(replicationSnapshot.getEntityId()));	if (!snapshotSlave.isPresent()) {	return false;	}	if (!checkFileExistsOnEntity(snapshotSlave.get(), replicationSnapshot.getSnapshotPath())) {	
mysql cluster node missing replication snapshot will generate new snapshot 

========================= brooklyn sample_100 =========================

public static void manage(Location loc, ManagementContext managementContext) {	if (!managementContext.getLocationManager().isManaged(loc)) {	
deprecated use of unmanaged location will be managed automatically now but not supported in future versions 

public static void manage(Location loc, ManagementContext managementContext) {	if (!managementContext.getLocationManager().isManaged(loc)) {	
stack trace for location of deprecated use of unmanaged location will be managed automatically now but not supported in future versions trace for deprecated use of unmanaged location 

========================= brooklyn sample_1319 =========================

try {	policyType = (Class<? extends Policy>) new ClassLoaderUtils(this, mgmt()).loadClass(policyTypeName);	} catch (ClassNotFoundException e) {	throw WebResourceUtils.badRequest("No policy with type %s found", policyTypeName);	} catch (ClassCastException e) {	throw WebResourceUtils.badRequest("No policy with type %s found", policyTypeName);	} catch (Exception e) {	throw Exceptions.propagate(e);	}	Policy policy = entity.policies().add(PolicySpec.create(policyType).configure(config));	
rest api added policy to 

========================= brooklyn sample_2889 =========================

return serviceUriBuilder(ub, CatalogApi.class, "getApplication").build(itemId, item.getVersion());	} else if (item.getSuperTypes().contains(Entity.class)) {	return serviceUriBuilder(ub, CatalogApi.class, "getEntity").build(itemId, item.getVersion());	} else if (item.getSuperTypes().contains(Policy.class)) {	return serviceUriBuilder(ub, CatalogApi.class, "getPolicy").build(itemId, item.getVersion());	} else if (item.getSuperTypes().contains(Enricher.class)) {	return serviceUriBuilder(ub, CatalogApi.class, "getEnricher").build(itemId, item.getVersion());	} else if (item.getSuperTypes().contains(Location.class)) {	return serviceUriBuilder(ub, CatalogApi.class, "getLocation").build(itemId, item.getVersion());	} else {	
unexpected catalog item type when getting self link not supplying self link 

========================= brooklyn sample_2923 =========================

if (imageMetadata.matches(osFamily, osVersionRegex)) {	String imageDescription = imageMetadata.getImageDescription();	LOG.debug("Setting default image regex to {}, for obtain call in {}; removing osFamily={} and osVersionRegex={}", new Object[]{imageDescription, this, osFamily, osVersionRegex});	setup.configure(JcloudsLocation.IMAGE_DESCRIPTION_REGEX, imageDescription);	setup.configure(OS_FAMILY, null);	setup.configure(OS_VERSION_REGEX, null);	break;	}	}	} else if (Strings.isNonBlank(defaultImageDescriptionRegex)) {	
setting default image regex to for obtain call in 

========================= brooklyn sample_2466 =========================

private void addFutureListener(Task<String> t, final String key) {	t.addListener(new Runnable() { @Override public void run() {	synchronized (data) {	
notifying for 

private void assertSoonGetsData(String key) throws InterruptedException {	for (int i=0; i<10; i++) {	if (Boolean.TRUE.equals(data.get(key))) {	
got data for 

private <T> Task<T> waitForSemaphore(final Duration time, final boolean requireSemaphore, final T result) {	return Tasks.<T>builder().body(new Callable<T>() {	public T call() {	try {	started.release();	
waiting up to to acquire before returning 

private <T> Task<T> waitForSemaphore(final Duration time, final boolean requireSemaphore, final T result) {	return Tasks.<T>builder().body(new Callable<T>() {	public T call() {	try {	started.release();	if (!waitInTask.tryAcquire(time.toMilliseconds(), TimeUnit.MILLISECONDS)) {	
did not get semaphore 

private <T> Task<T> waitForSemaphore(final Duration time, final boolean requireSemaphore, final T result) {	return Tasks.<T>builder().body(new Callable<T>() {	public T call() {	try {	started.release();	if (!waitInTask.tryAcquire(time.toMilliseconds(), TimeUnit.MILLISECONDS)) {	if (requireSemaphore) Assert.fail("task did not get semaphore");	} else {	
got semaphore 

private <T> Task<T> waitForSemaphore(final Duration time, final boolean requireSemaphore, final T result) {	return Tasks.<T>builder().body(new Callable<T>() {	public T call() {	try {	started.release();	if (!waitInTask.tryAcquire(time.toMilliseconds(), TimeUnit.MILLISECONDS)) {	if (requireSemaphore) Assert.fail("task did not get semaphore");	} else {	}	} catch (Exception e) {	
cancelled before returning 

try {	started.release();	if (!waitInTask.tryAcquire(time.toMilliseconds(), TimeUnit.MILLISECONDS)) {	if (requireSemaphore) Assert.fail("task did not get semaphore");	} else {	}	} catch (Exception e) {	cancelledWhileSleeping.release();	throw Exceptions.propagate(e);	}	
task returning 

public void doTestCancelTriggersListenableFuture(Duration delay) throws Exception {	Task<String> t = waitForSemaphore(Duration.TEN_SECONDS, true, "x");	addFutureListener(t, "before");	Stopwatch watch = Stopwatch.createStarted();	ec.submit(t);	addFutureListener(t, "during");	
test cancelling after 

========================= brooklyn sample_907 =========================

try {	for (BrooklynObjectType type: BrooklynPersistenceUtils.STANDARD_BROOKLYN_OBJECT_TYPE_PERSISTENCE_ORDER) {	subPathDataBuilder.putAll(type, makeIdSubPathMap(objectStore.listContentsWithSubPath(type.getSubPathName())));	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	exceptionHandler.onLoadMementoFailed(BrooklynObjectType.UNKNOWN, "Failed to list files", e);	throw new IllegalStateException("Failed to list memento files in "+objectStore, e);	}	BrooklynMementoRawData subPathData = subPathDataBuilder.build();	
loaded rebind lists took entities locations policies enrichers feeds catalog items bundles from 

}	String contents = null;	try {	contents = read(contentsSubpath);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	exceptionHandler.onLoadMementoFailed(type, "memento "+id+" read error", e);	}	String xmlId = (String) XmlUtil.xpathHandlingIllegalChars(contents, "/"+type.toCamelCase()+"/id");	String safeXmlId = Strings.makeValidFilename(xmlId);	
id mismatch on from path from xml 

builder.bundleJar(id, ByteSource.wrap(jarData));	}	builder.put(type, xmlId, contents);	}	};	Stopwatch stopwatch = Stopwatch.createStarted();	builder.planeId(Strings.emptyToNull(read(PLANE_ID_FILE_NAME)));	visitMemento("loading raw", subPathData, loaderVisitor, exceptionHandler);	BrooklynMementoRawData result = builder.build();	if (LOG.isDebugEnabled()) {	
loaded rebind raw data took entities locations policies enrichers feeds catalog items bundles from 

public void visit(BrooklynObjectType type, String objectId, final String contents) throws Exception {	XPathHelper x = new XPathHelper(contents, "/"+type.toCamelCase()+"/");	switch (type) {	case ENTITY: builder.entity(x.get("id"), x.get("type"), Strings.emptyToNull(x.get("parent")), Strings.emptyToNull(x.get("catalogItemId")), x.getStringList("searchPath"));	break;	case LOCATION: case POLICY: case ENRICHER: case FEED: builder.putType(type, x.get("id"), x.get("type"));	break;	case CATALOG_ITEM: try {	CatalogItemMemento memento = (CatalogItemMemento) getSerializerWithStandardClassLoader().fromString(contents);	if (memento == null) {	
no memento deserialized from ignoring and continuing 

}	break;	default: throw new IllegalStateException("Unexpected brooklyn type: "+type);	}	}	};	Stopwatch stopwatch = Stopwatch.createStarted();	visitMemento("manifests", mementoData, visitor, exceptionHandler);	BrooklynMementoManifest result = builder.build();	if (LOG.isDebugEnabled()) {	
loaded rebind manifests took entities locations policies enrichers feeds catalog items bundles from 

public BrooklynMemento loadMemento(BrooklynMementoRawData mementoData, final LookupContext lookupContext, final RebindExceptionHandler exceptionHandler) throws IOException {	if (mementoData==null) mementoData = loadMementoRawData(exceptionHandler);	Stopwatch stopwatch = Stopwatch.createStarted();	final BrooklynMementoImpl.Builder builder = BrooklynMementoImpl.builder();	builder.planeId(mementoData.getPlaneId());	Visitor visitor = new Visitor() {	public void visit(BrooklynObjectType type, String objectId, String contents) throws Exception {	try {	Memento memento = (Memento) getSerializerWithCustomClassLoader(lookupContext, type, objectId).fromString(contents);	if (memento == null) {	
no memento deserialized from ignoring and continuing 

}	};	getSerializerWithStandardClassLoader().setLookupContext(lookupContext);	try {	visitMemento("deserialization", mementoData, visitor, exceptionHandler);	} finally {	getSerializerWithStandardClassLoader().unsetLookupContext();	}	BrooklynMemento result = builder.build();	if (LOG.isDebugEnabled()) {	
loaded rebind mementos took entities locations policies enrichers feeds catalog items bundles from 

} catch (Exception e) {	Exceptions.propagateIfFatal(e);	List<Exception> exceptions = Lists.newArrayList();	for (ListenableFuture<?> future : futures) {	if (future.isDone()) {	try {	future.get();	} catch (InterruptedException e2) {	throw Exceptions.propagate(e2);	} catch (ExecutionException e2) {	
problem loading memento 

addPersistContentIfManagedBundle(type, entry.getKey(), futures, exceptionHandler);	futures.add(asyncPersist(type.getSubPathName(), type, entry.getKey(), entry.getValue(), exceptionHandler));	}	}	try {	Futures.successfulAsList(futures).get();	Futures.allAsList(futures).get();	} catch (Exception e) {	throw Exceptions.propagate(e);	}	
checkpointed entire memento in 

protected void doDelta(Delta delta, PersistenceExceptionHandler exceptionHandler, boolean previouslyQueued) {	Stopwatch stopwatch = deltaImpl(delta, exceptionHandler);	
checkpointed previously queued delta of memento in updated entities locations policies enrichers catalog items bundles removed entities locations policies enrichers catalog items bundles 

private void addPersistContentIfManagedBundle(final BrooklynObjectType type, final String id, List<ListenableFuture<?>> futures, final PersistenceExceptionHandler exceptionHandler) {	if (type==BrooklynObjectType.MANAGED_BUNDLE) {	if (mgmt==null) {	throw new IllegalStateException("Cannot persist bundles without a management context");	}	final ManagedBundle mb = ((ManagementContextInternal)mgmt).getOsgiManager().get().getManagedBundles().get(id);	if (mb==null) {	
cannot find managed bundle for added bundle ignoring 

private void persist(String subPath, BrooklynObjectType type, String id, String content, PersistenceExceptionHandler exceptionHandler) {	try {	if (content==null) {	
null content for 

private void updatePlaneId(String planeId, PersistenceExceptionHandler exceptionHandler) {	try {	if (planeId==null) {	
null content for planeid not updating at server 

========================= brooklyn sample_1163 =========================

public void setEntity(EntityLocal entity) {	super.setEntity(entity);	Group group = getGroup();	if (group != null) {	if (uniqueTag==null) {	uniqueTag = JavaClassNames.simpleClassName(this)+":"+group;	}	subscribeToGroup(group);	} else {	
deprecated use of group should be set as config 

public void setGroup(Group group) {	
deprecated use of setgroup in group should be set as config 

protected <T> void doReconfigureConfig(ConfigKey<T> key, T val) {	if (GROUP.getName().equals(key.getName())) {	Preconditions.checkNotNull(val, "%s value must not be null", GROUP.getName());	Preconditions.checkNotNull(val, "%s value must be a group, but was %s (of type %s)", GROUP.getName(), val, val.getClass());	if (val.equals(getConfig(GROUP))) {	
no op for reconfigure group of group is still 

protected <T> void doReconfigureConfig(ConfigKey<T> key, T val) {	if (GROUP.getName().equals(key.getName())) {	Preconditions.checkNotNull(val, "%s value must not be null", GROUP.getName());	Preconditions.checkNotNull(val, "%s value must be a group, but was %s (of type %s)", GROUP.getName(), val, val.getClass());	if (val.equals(getConfig(GROUP))) {	} else {	
membership tracker resubscribing to group previously was 

========================= brooklyn sample_1533 =========================

public void testChangeModeFailureStopsTasksButHappyUponResumption() throws Exception {	DynamicCluster origServerPool = origApp.createAndManageChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(TomcatServer.class).configure("war", getTestWar())) .configure("initialSize", 1));	NginxController origNginx = origApp.createAndManageChild(EntitySpec.create(NginxController.class) .configure("serverPool", origServerPool) .configure("domain", "localhost"));	origApp.start(ImmutableList.of(loc));	Assert.assertTrue(RecordingSshjTool.connectionCount.get()>0);	Collection<Feed> origFeeds = ((EntityInternal)origNginx).feeds().getFeeds();	
feeds before rebind are 

public void testChangeModeFailureStopsTasksButHappyUponResumption() throws Exception {	DynamicCluster origServerPool = origApp.createAndManageChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(TomcatServer.class).configure("war", getTestWar())) .configure("initialSize", 1));	NginxController origNginx = origApp.createAndManageChild(EntitySpec.create(NginxController.class) .configure("serverPool", origServerPool) .configure("domain", "localhost"));	origApp.start(ImmutableList.of(loc));	Assert.assertTrue(RecordingSshjTool.connectionCount.get()>0);	Collection<Feed> origFeeds = ((EntityInternal)origNginx).feeds().getFeeds();	Assert.assertTrue(origFeeds.size() >= 1);	origManagementContext.getRebindManager().forcePersistNow(false, null);	List<Task<?>> tasksBefore = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getAllTasks();	
tasks before disabling ha 

Assert.assertTrue(origFeeds.size() >= 1);	origManagementContext.getRebindManager().forcePersistNow(false, null);	List<Task<?>> tasksBefore = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getAllTasks();	Assert.assertFalse(tasksBefore.isEmpty());	origManagementContext.getHighAvailabilityManager().changeMode(HighAvailabilityMode.DISABLED);	origApp = null;	Repeater.create().every(Duration.millis(20)).backoffTo(Duration.ONE_SECOND).limitTimeTo(Duration.THIRTY_SECONDS).until(new Callable<Boolean>() {	public Boolean call() throws Exception {	origManagementContext.getGarbageCollector().gcIteration();	List<Task<?>> tasksAfter = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getAllTasks();	
tasks after disabling ha 

origManagementContext.getGarbageCollector().gcIteration();	List<Task<?>> tasksAfter = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getAllTasks();	return tasksAfter.isEmpty();	}	}).runRequiringTrue();	RecordingSshjTool.forbidden.set(true);	newManagementContext = createNewManagementContext();	newApp = (TestApplication) RebindTestUtils.rebind( RebindOptions.create().newManagementContext(newManagementContext).classLoader(classLoader));	NginxController newNginx = Iterables.getOnlyElement(Entities.descendantsAndSelf(newApp, NginxController.class));	Collection<Feed> newFeeds = ((EntityInternal)newNginx).feeds().getFeeds();	
feeds after rebind are 

========================= brooklyn sample_141 =========================

private boolean orSubmitInternal() {	if (!wasQueued()) {	if (isQueuedOrSubmitted()) {	
redundant call to execute skipping 

public static <T> Task<T> queueInTaskHierarchy(Task<T> task) {	Preconditions.checkNotNull(task, "Task to queue cannot be null");	Preconditions.checkState(!Tasks.isQueuedOrSubmitted(task), "Task to queue must not yet be submitted: {}", task);	TaskQueueingContext adder = getTaskQueuingContext();	if (adder!=null) {	if (Tasks.tryQueueing(adder, task)) {	
queued task at context no hierarchy 

if (adder!=null) {	if (Tasks.tryQueueing(adder, task)) {	return task;	}	}	Task<?> t = Tasks.current();	Preconditions.checkState(t!=null || adder!=null, "No task addition context available for queueing task "+task);	while (t!=null) {	if (t instanceof TaskQueueingContext) {	if (Tasks.tryQueueing((TaskQueueingContext)t, task)) {	
queued task at hierarchical context 

try {	Preconditions.checkNotNull(task, "Task to queue cannot be null");	Preconditions.checkState(!Tasks.isQueued(task), "Task to queue must not yet be queued: %s", task);	TaskQueueingContext adder = getTaskQueuingContext();	if (adder==null) {	throw new IllegalStateException("Task "+task+" cannot be queued here; no queueing context available");	}	adder.queue(task.asTask());	return task;	} catch (Throwable e) {	
error queueing rethrowing 

========================= brooklyn sample_1476 =========================

try {	Properties properties = new Properties();	properties.setProperty(Constants.PROPERTY_TRUST_ALL_CERTS, Boolean.toString(true));	properties.setProperty(Constants.PROPERTY_RELAX_HOSTNAME, Boolean.toString(true));	context = ContextBuilder.newBuilder("docker") .endpoint(docker.getEndpoint()) .credentials(docker.getIdentity(), docker.getCredential()) .overrides(properties) .modules(ImmutableSet.<Module>of(new SLF4JLoggingModule(), new SshjSshClientModule())) .build(ComputeServiceContext.class);	DockerApi api = context.unwrapApi(DockerApi.class);	Container container = api.getContainerApi().inspectContainer(containerId);	Map<Integer, Integer> portMappings = Maps.newLinkedHashMap();	Map<String, List<Map<String, String>>> ports = container.networkSettings().ports();	if (ports == null) ports = ImmutableMap.<String, List<Map<String,String>>>of();	
docker will forward these ports 

========================= brooklyn sample_2574 =========================

Object value = entity.config().get(k);	Maybe<PortRange> maybePortRange = TypeCoercions.tryCoerce(value, new TypeToken<PortRange>() {	});	if (maybePortRange.isPresentAndNonNull()) {	PortRange p = maybePortRange.get();	if (p != null && !p.isEmpty()) ports.add(p.iterator().next());	}	}	}	}	
getrequiredopenports detected default for 

========================= brooklyn sample_2348 =========================

protected void connectSensors() {	super.connectSensors();	if (LOG.isDebugEnabled()) {	
connecting sensors for node 

protected void connectSensors() {	super.connectSensors();	if (LOG.isDebugEnabled()) {	}	HostAndPort hp = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, getNodePort());	String nodeUri = String.format("http: sensors().set(Attributes.MAIN_URI, URI.create(nodeUri));	if (LOG.isDebugEnabled()) {	
node is using as a main uri 

protected void disconnectSensors() {	if (httpFeed != null) {	httpFeed.stop();	}	if (LOG.isDebugEnabled()) {	
disconnecting sensors for node 

public String getListenAddress() {	String listenAddress = getPrivateIpAddress();	if (Strings.isBlank(listenAddress)) {	listenAddress = getAttribute(ADDRESS);	}	if (LOG.isInfoEnabled()) {	
node is listening on 

========================= brooklyn sample_403 =========================

public void testDynamicFabricStartsAndStopsEntitiesInParallelManyTimes() throws Exception {	for (int i = 0; i < 100; i++) {	
running testdynamicfabricstartsandstopsentitiesinparallel iteration 

========================= brooklyn sample_950 =========================

protected Entity setupAndCheckTestEntityInBasicYamlWith(String ...extras) throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-reference-map-template.yaml", extras));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-reference-map-template");	
app started 

========================= brooklyn sample_1636 =========================

static <T> void addNamedAction(MutableMap.Builder<String, URI> lb, RendererHints.NamedAction na, T value, Object context, Entity contextEntity) {	if (na instanceof RendererHints.NamedActionWithUrl) {	try {	String v = ((RendererHints.NamedActionWithUrl<T>) na).getUrlFromValue(value);	if (Strings.isNonBlank(v)) {	String action = na.getActionName().toLowerCase();	lb.putIfAbsent("action:"+action, URI.create(v));	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to make action from on 

========================= brooklyn sample_2919 =========================

public AbstractBrooklynObject(Map<?, ?> properties) {	_legacyConstruction = !InternalFactory.FactoryConstructionTracker.isConstructing();	if (!_legacyConstruction && properties != null && !properties.isEmpty()) {	
forcing use of deprecated old style construction for because properties were specified instead use specs e g locationspec entityspec etc 

public AbstractBrooklynObject(Map<?, ?> properties) {	_legacyConstruction = !InternalFactory.FactoryConstructionTracker.isConstructing();	if (!_legacyConstruction && properties != null && !properties.isEmpty()) {	
source of use of old style construction source of use of old style construction 

protected void requestPersist() {	if (getManagementContext() != null) {	getManagementContext().getRebindManager().getChangeListener().onChanged(this);	} else {	if (log.isTraceEnabled() && !hasWarnedOfNoManagementContextWhenPersistRequested) {	
cannot fulfil request to persist because it has no management context this warning will not be logged for this object again 

========================= brooklyn sample_1323 =========================

startAttemptToLoadIp = true;	}	else {	startAttemptToLoadIp = false;	}	attemptToRetrieveLocalExternalIp = retrievingLocalExternalIp;	}	if (startAttemptToLoadIp) {	final List<String> candidateUrls = getIpAddressWebsites();	if (candidateUrls.isEmpty()) {	
no candidate urls to use to determine external ip of localhost 

}	if (startAttemptToLoadIp) {	final List<String> candidateUrls = getIpAddressWebsites();	if (candidateUrls.isEmpty()) {	return null;	}	new Thread() {	public void run() {	for (String url : candidateUrls) {	try {	
looking up external ip of this host from in private thread 

final List<String> candidateUrls = getIpAddressWebsites();	if (candidateUrls.isEmpty()) {	return null;	}	new Thread() {	public void run() {	for (String url : candidateUrls) {	try {	final String loadedIp = new IpLoader(url).call();	localExternalIp = loadedIp;	
finished looking up external ip of this host from in private thread result 

return null;	}	new Thread() {	public void run() {	for (String url : candidateUrls) {	try {	final String loadedIp = new IpLoader(url).call();	localExternalIp = loadedIp;	break;	} catch (Throwable t) {	
unable to look up external ip of this host from probably offline 

========================= brooklyn sample_1289 =========================

public void onEvent(SensorEvent<Object> event) {	
received event 

========================= brooklyn sample_3037 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof EC2TemplateOptions) {	((EC2TemplateOptions) t).keyPair(v.toString());	} else if (t instanceof NovaTemplateOptions) {	((NovaTemplateOptions) t).keyPairName(v.toString());	} else if (t instanceof CloudStackTemplateOptions) {	((CloudStackTemplateOptions) t).keyPair(v.toString());	} else {	
ignoring keypair in vm creation because not supported for cloud type 

========================= brooklyn sample_2626 =========================

public void attachLifecycleEffectors(Entity entity) {	if (getPidFile()==null && getServiceName()==null && getClass().equals(ChefLifecycleEffectorTasks.class)) {	
uses of must define a pid file or a service name or subclass and override start stop methods as per javadoc in order for check running and stop to work 

public static ChefModes detectChefMode(Entity entity) {	ChefModes mode = entity.getConfig(ChefConfig.CHEF_MODE);	if (mode == ChefModes.AUTODETECT) {	ProcessTaskWrapper<Boolean> installCheck = DynamicTasks.queue( ChefServerTasks.isKnifeInstalled());	mode = installCheck.get() ? ChefModes.KNIFE : ChefModes.SOLO;	
using chef in mode due to autodetect exit code 

protected void startWithChefSoloAsync() {	String baseDir = MachineLifecycleEffectorTasks.resolveOnBoxDir(entity(), Machines.findUniqueMachineLocation(entity().getLocations(), SshMachineLocation.class).get());	String installDir = Urls.mergePaths(baseDir, "installs/chef");	Map<String, String> cookbooks = (Map) ConfigBag.newInstance( entity().getConfig(CHEF_COOKBOOK_URLS) ) .putIfAbsent( entity().getConfig(CHEF_COOKBOOK_URLS) ) .getAllConfig();	
no cookbook urls set for launch will likely fail subsequently 

protected void postStartCustom() {	boolean result = false;	result |= tryCheckStartPid();	result |= tryCheckStartService();	result |= tryCheckStartWindowsService();	if (!result) {	
no way to check whether is running assuming yes 

protected boolean tryStopPid() {	Integer pid = entity().getAttribute(Attributes.PID);	if (pid==null) {	if (entity().getAttribute(Attributes.SERVICE_STATE_ACTUAL)==Lifecycle.RUNNING && getPidFile()==null) log.warn("No PID recorded for "+entity()+" when running, with PID file "+getPidFile()+"; skipping kill in "+Tasks.current());	
no pid recorded for skipping 

========================= brooklyn sample_2299 =========================

private void setVotingMembers() {	
setting voting and non voting members of replica set 

private void setVotingMembers() {	boolean seenPrimary = false;	String expectedPrimary = primary.isPresent() ? primary.get().getHostText() + ":" + primary.get().getPort() : "";	int setSize = this.members.size();	int nonPrimaryVotingMembers = Math.min(setSize % 2 == 0 ? setSize - 1 : setSize, MAXIMUM_VOTING_MEMBERS);	if (primary.isPresent()) {	
reserving vote for primary 

if (primary.isPresent()) {	nonPrimaryVotingMembers -= 1;	}	for (Object member : this.members) {	if (member instanceof BasicBSONObject) {	BasicBSONObject bsonObject = BasicBSONObject.class.cast(member);	String host = bsonObject.getString("host");	if (this.primary.isPresent() && expectedPrimary.equals(host)) {	bsonObject.put("votes", 1);	seenPrimary = true;	
voting member primary of set 

}	for (Object member : this.members) {	if (member instanceof BasicBSONObject) {	BasicBSONObject bsonObject = BasicBSONObject.class.cast(member);	String host = bsonObject.getString("host");	if (this.primary.isPresent() && expectedPrimary.equals(host)) {	bsonObject.put("votes", 1);	seenPrimary = true;	} else if (nonPrimaryVotingMembers-- > 0) {	bsonObject.put("votes", 1);	
voting member of set 

if (member instanceof BasicBSONObject) {	BasicBSONObject bsonObject = BasicBSONObject.class.cast(member);	String host = bsonObject.getString("host");	if (this.primary.isPresent() && expectedPrimary.equals(host)) {	bsonObject.put("votes", 1);	seenPrimary = true;	} else if (nonPrimaryVotingMembers-- > 0) {	bsonObject.put("votes", 1);	} else {	bsonObject.put("votes", 0);	
non voting member of set 

String host = bsonObject.getString("host");	if (this.primary.isPresent() && expectedPrimary.equals(host)) {	bsonObject.put("votes", 1);	seenPrimary = true;	} else if (nonPrimaryVotingMembers-- > 0) {	bsonObject.put("votes", 1);	} else {	bsonObject.put("votes", 0);	}	} else {	
unexpected entry in replica set members list 

seenPrimary = true;	} else if (nonPrimaryVotingMembers-- > 0) {	bsonObject.put("votes", 1);	} else {	bsonObject.put("votes", 0);	}	} else {	}	}	if (primary.isPresent() && !seenPrimary) {	
cannot give replica set primary a vote in reconfigured set primary was indicated as but no member with that host and port was seen in the set the replica set now has an even number of voters 

========================= brooklyn sample_356 =========================

super.setUp();	localhost = mgmt().getLocationRegistry().getLocationManaged("localhost");	provisioningTimes = Collections.synchronizedList(Lists.<Duration>newArrayList());	executor = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());	executor.submit(new Callable<Void>() {	public Void call() {	try {	mgmt().getExecutionManager();	while (true) {	String usage = ((LocalManagementContext)mgmt()).getGarbageCollector().getUsageString();	
loadtest using 

public Void call() {	try {	mgmt().getExecutionManager();	while (true) {	String usage = ((LocalManagementContext)mgmt()).getGarbageCollector().getUsageString();	Thread.sleep(1000);	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (Exception e) {	
error getting usage info 

protected ManagementContext setUpPlatform() {	persistenceDir = Files.createTempDir();	launcher = BrooklynLauncher.newInstance() .persistMode(PersistMode.CLEAN) .highAvailabilityMode(HighAvailabilityMode.MASTER) .persistenceDir(persistenceDir) .start();	String webServerUrl = launcher.getServerDetails().getWebServerUrl();	
brooklyn web console running at 

protected Callable<Entity> newProvisionAppTask(final String yaml) {	return new Callable<Entity>() {	public Entity call() throws Exception {	try {	Stopwatch stopwatch = Stopwatch.createStarted();	Entity app = createAndStartApplication(yaml);	Duration duration = Duration.of(stopwatch.elapsed(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);	
provisioning time 

protected Callable<Entity> newProvisionAppTask(final String yaml) {	return new Callable<Entity>() {	public Entity call() throws Exception {	try {	Stopwatch stopwatch = Stopwatch.createStarted();	Entity app = createAndStartApplication(yaml);	Duration duration = Duration.of(stopwatch.elapsed(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);	provisioningTimes.add(duration);	return app;	} catch (Throwable t) {	
error deploying app rethrowing 

protected <T extends StartableApplication> Callable<T> newProvisionAppTask(final EntitySpec<T> appSpec) {	return new Callable<T>() {	public T call() {	try {	Stopwatch stopwatch = Stopwatch.createStarted();	T app = mgmt().getEntityManager().createEntity(appSpec);	app.start(ImmutableList.of(localhost));	Duration duration = Duration.of(stopwatch.elapsed(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);	
provisioning time 

return new Callable<T>() {	public T call() {	try {	Stopwatch stopwatch = Stopwatch.createStarted();	T app = mgmt().getEntityManager().createEntity(appSpec);	app.start(ImmutableList.of(localhost));	Duration duration = Duration.of(stopwatch.elapsed(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);	provisioningTimes.add(duration);	return app;	} catch (Throwable t) {	
error deploying app rethrowing 

========================= brooklyn sample_33 =========================

public void testRegisterVm() throws Exception {	JcloudsSshMachineLocation machine = obtainMachine(ImmutableMap.of("imageId", EUWEST_IMAGE_ID));	assertTrue(machine.isSshable());	
obtained 

JcloudsSshMachineLocation machine = obtainMachine(ImmutableMap.of("imageId", EUWEST_IMAGE_ID));	assertTrue(machine.isSshable());	String id = checkNotNull(machine.getJcloudsId(), "id");	InetAddress address = checkNotNull(machine.getAddress(), "address");	String hostname = checkNotNull(address.getHostName(), "hostname");	String user = checkNotNull(machine.getUser(), "user");	JcloudsLocation loc2 = (JcloudsLocation) managementContext.getLocationRegistry().getLocationManaged(AWS_EC2_PROVIDER+":"+AWS_EC2_EUWEST_REGION_NAME);	MachineLocation machineLocation = loc2.registerMachine(ImmutableMap.of("id", id, "hostname", hostname, "user", user));	assertTrue(machineLocation instanceof SshMachineLocation);	SshMachineLocation machine2 = (SshMachineLocation) machineLocation;	
registered 

========================= brooklyn sample_2558 =========================

Map<String, String> feeds = MutableMap.copyOf(rawData.getFeeds());	Map<String, String> catalogItems = MutableMap.copyOf(rawData.getCatalogItems());	Map<String, String> bundles = MutableMap.copyOf(rawData.getBundles());	Map<String, ByteSource> bundleJars = MutableMap.copyOf(rawData.getBundleJars());	for (BrooklynObjectType type : BrooklynObjectType.values()) {	Set<String> itemsToDelete = ImmutableSet.copyOf(deletions.get(type));	Set<String> missing;	switch (type) {	case ENTITY: missing = Sets.difference(itemsToDelete, entities.keySet());	if (missing.size() > 0) {	
unable to delete id because not found in persisted state continuing 

Set<String> itemsToDelete = ImmutableSet.copyOf(deletions.get(type));	Set<String> missing;	switch (type) {	case ENTITY: missing = Sets.difference(itemsToDelete, entities.keySet());	if (missing.size() > 0) {	}	entities.keySet().removeAll(itemsToDelete);	break;	case LOCATION: missing = Sets.difference(itemsToDelete, locations.keySet());	if (missing.size() > 0) {	
unable to delete id because not found in persisted state continuing 

}	entities.keySet().removeAll(itemsToDelete);	break;	case LOCATION: missing = Sets.difference(itemsToDelete, locations.keySet());	if (missing.size() > 0) {	}	locations.keySet().removeAll(itemsToDelete);	break;	case POLICY: missing = Sets.difference(itemsToDelete, policies.keySet());	if (missing.size() > 0) {	
unable to delete id because not found in persisted state continuing 

}	locations.keySet().removeAll(itemsToDelete);	break;	case POLICY: missing = Sets.difference(itemsToDelete, policies.keySet());	if (missing.size() > 0) {	}	policies.keySet().removeAll(itemsToDelete);	break;	case ENRICHER: missing = Sets.difference(itemsToDelete, enrichers.keySet());	if (missing.size() > 0) {	
unable to delete id because not found in persisted state continuing 

}	policies.keySet().removeAll(itemsToDelete);	break;	case ENRICHER: missing = Sets.difference(itemsToDelete, enrichers.keySet());	if (missing.size() > 0) {	}	enrichers.keySet().removeAll(itemsToDelete);	break;	case FEED: missing = Sets.difference(itemsToDelete, feeds.keySet());	if (missing.size() > 0) {	
unable to delete id because not found in persisted state continuing 

}	enrichers.keySet().removeAll(itemsToDelete);	break;	case FEED: missing = Sets.difference(itemsToDelete, feeds.keySet());	if (missing.size() > 0) {	}	feeds.keySet().removeAll(itemsToDelete);	break;	case CATALOG_ITEM: missing = Sets.difference(itemsToDelete, catalogItems.keySet());	if (missing.size() > 0) {	
unable to delete id because not found in persisted state continuing 

}	feeds.keySet().removeAll(itemsToDelete);	break;	case CATALOG_ITEM: missing = Sets.difference(itemsToDelete, catalogItems.keySet());	if (missing.size() > 0) {	}	catalogItems.keySet().removeAll(itemsToDelete);	break;	case MANAGED_BUNDLE: missing = Sets.difference(itemsToDelete, bundles.keySet());	if (missing.size() > 0) {	
unable to delete id because not found in persisted state continuing 

========================= brooklyn sample_1118 =========================

public Application launchAppYaml(String url, boolean waitForTasksToComplete) {	try {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl(url));	Application app = launchAppYaml(input, waitForTasksToComplete);	
application started from yaml file 

public Application launchAppYaml(Reader input, boolean waitForTasksToComplete) {	try {	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	
launching 

public Application launchAppYaml(Reader input, boolean waitForTasksToComplete) {	try {	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	if (getShutdownAppsOnExit()) BrooklynShutdownHooks.invokeStopOnShutdown(app);	if (waitForTasksToComplete) {	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	
waiting on task s 

AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, platform);	Entity app = brooklynMgmt.getEntityManager().getEntity(assembly.getId());	if (getShutdownAppsOnExit()) BrooklynShutdownHooks.invokeStopOnShutdown(app);	if (waitForTasksToComplete) {	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	for (Task<?> t: tasks) {	t.blockUntilEnded();	}	}	
application started from yaml 

public void destroyAll() {	Entities.destroyAll(getManagementContext());	try {	platformLauncher.stopServers();	} catch (Exception e) {	
unable to stop servers ignoring 

========================= brooklyn sample_1732 =========================

public void reconfigureService() {	String cfg = getConfigFile();	if (cfg == null) return;	
reconfiguring targetting and 

public void reconfigureService() {	String cfg = getConfigFile();	if (cfg == null) return;	
reconfiguring config file 

public void reconfigureService() {	String cfg = getConfigFile();	if (cfg == null) return;	NginxSshDriver driver = (NginxSshDriver) getDriver();	if (!driver.isCustomizationCompleted()) {	
reconfiguring but driver s customization not yet complete so aborting 

========================= brooklyn sample_205 =========================

public void testTransformerResolvesResolvableValues() {	
starting iterations of testtransformerresolvesresolvablevalues 

public void testTransformerResolvesResolvableValuesIntegration() {	
starting iterations of testtransformerresolvesresolvablevalues 

========================= brooklyn sample_1620 =========================

protected void findServices() {	Iterable<LocationResolver> loader = FrameworkLookup.lookupAll(LocationResolver.class, mgmt.getCatalogClassLoader());	MutableList<LocationResolver> loadedResolvers;	try {	loadedResolvers = MutableList.copyOf(loader);	} catch (Throwable e) {	
error loading resolvers rethrowing 

Iterable<LocationResolver> loader = FrameworkLookup.lookupAll(LocationResolver.class, mgmt.getCatalogClassLoader());	MutableList<LocationResolver> loadedResolvers;	try {	loadedResolvers = MutableList.copyOf(loader);	} catch (Throwable e) {	throw Exceptions.propagate(e);	}	for (LocationResolver r: loadedResolvers) {	registerResolver(r);	}	
location resolvers are 

Iterable<LocationResolver> loader = FrameworkLookup.lookupAll(LocationResolver.class, mgmt.getCatalogClassLoader());	MutableList<LocationResolver> loadedResolvers;	try {	loadedResolvers = MutableList.copyOf(loader);	} catch (Throwable e) {	throw Exceptions.propagate(e);	}	for (LocationResolver r: loadedResolvers) {	registerResolver(r);	}	
no location resolvers detected is src main resources correctly included 

}	} else {	for (LocationDefinition l: definedLocations.values()) {	if (l.getName().equals(nameOrId)) return l;	}	}	}	lt = mgmt.getTypeRegistry().get(nameOrId);	if (lt!=null && lt.getSuperTypes().isEmpty()) {	if (lt.getKind()!=RegisteredTypeKind.UNRESOLVED) {	
location registry only found when ignoring supertypes check it is correctly resolved 

public void removeDefinedLocation(String id) {	LocationDefinition removed;	synchronized (definedLocations) {	removed = definedLocations.remove(id);	}	if (removed == null && log.isDebugEnabled()) {	
was asked to remove location with id but no such location was registered 

for (String k: namedLocationProps.asMapWithStringKeys().keySet()) {	String name = k.substring(NAMED_LOCATION_PREFIX.length());	if (!name.contains(".")) {	String spec = (String) namedLocationProps.asMapWithStringKeys().get(k);	String id = Identifiers.makeRandomId(8);	BrooklynProperties config = ConfigUtils.filterForPrefixAndStrip(namedLocationProps.asMapWithStringKeys(), k+".");	definedLocations.put(id, new BasicLocationDefinition(id, name, spec, config.asMapWithStringKeys()));	count++;	}	}	
found defined locations from properties named syntax 

String orig = cfg.get(LocationInternal.ORIGINAL_SPEC);	String named = cfg.get(LocationInternal.NAMED_SPEC_NAME);	if (Strings.isNonBlank(named) && !named.equals(spec) && !named.equals(orig)) {	errmsg += " when looking up '"+named+"'";	}	if (Strings.isNonBlank(orig) && !orig.equals(spec)) {	errmsg += " when resolving '"+orig+"'";	}	if (spec == null || specsWarnedOnException.add(spec)) {	if (resolvers.get("id")==null || resolvers.get("named")==null) {	
standard location resolvers not installed location resolution will fail shortly this usually indicates a classpath problem such as when running from an ide which has not properly copied meta inf services from src main resources known resolvers are 

if (Strings.isNonBlank(named) && !named.equals(spec) && !named.equals(orig)) {	errmsg += " when looking up '"+named+"'";	}	if (Strings.isNonBlank(orig) && !orig.equals(spec)) {	errmsg += " when resolving '"+orig+"'";	}	if (spec == null || specsWarnedOnException.add(spec)) {	if (resolvers.get("id")==null || resolvers.get("named")==null) {	errmsg = errmsg+": " + "Problem detected with location resolver configuration; " + resolvers.keySet()+" are the only available location resolvers. " + "More information can be found in the logs.";	} else {	
if this is being loaded it will fail shortly known resolvers are 

}	if (Strings.isNonBlank(orig) && !orig.equals(spec)) {	errmsg += " when resolving '"+orig+"'";	}	if (spec == null || specsWarnedOnException.add(spec)) {	if (resolvers.get("id")==null || resolvers.get("named")==null) {	errmsg = errmsg+": " + "Problem detected with location resolver configuration; " + resolvers.keySet()+" are the only available location resolvers. " + "More information can be found in the logs.";	} else {	}	} else {	
with retry already warned 

========================= brooklyn sample_1270 =========================

protected void testOperatingSystemProvider(String imageId, String provider, String region, String description) throws Exception {	
testing cassandra on using 

========================= brooklyn sample_317 =========================

public void onManagementStarted() {	super.onManagementStarted();	try {	applyConfig();	} catch (Exception e) {	
geoscaling did not come up correctly 

checkNotNull(username, "The GeoScaling username is not specified");	checkNotNull(password, "The GeoScaling password is not specified");	checkNotNull(primaryDomainName, "The GeoScaling primary domain name is not specified");	if (randomizeSmartSubdomainName) {	if (smartSubdomainName != null) smartSubdomainName += "-";	else smartSubdomainName = "";	smartSubdomainName += Identifiers.makeRandomId(8);	}	checkNotNull(smartSubdomainName, "The GeoScaling smart subdomain name is not specified or randomized");	String fullDomain = smartSubdomainName+"."+primaryDomainName;	
geoscaling service will configure redirection for domain 

public long getTimeToLiveSeconds() { return 5*60; }	public void destroy() {	setServiceState(Lifecycle.STOPPING);	if (!isConfigured) return;	if (randomizeSmartSubdomainName) {	webClient.login(username, password);	Domain primaryDomain = webClient.getPrimaryDomain(primaryDomainName);	SmartSubdomain smartSubdomain = (primaryDomain != null) ? primaryDomain.getSmartSubdomain(smartSubdomainName) : null;	if (smartSubdomain != null) {	
deleting randomized geoscaling smart subdomain 

protected void reconfigureService(Collection<HostGeoInfo> targetHosts) {	if (!isConfigured) {	this.rememberedTargetHosts = MutableSet.copyOf(targetHosts);	return;	}	webClient.login(username, password);	Domain primaryDomain = webClient.getPrimaryDomain(primaryDomainName);	if (primaryDomain==null) throw new NullPointerException(this+" got null from web client for primary domain "+primaryDomainName);	SmartSubdomain smartSubdomain = primaryDomain.getSmartSubdomain(smartSubdomainName);	if (smartSubdomain == null) {	
geoscaling smart subdomain does not exist creating it now 

}	webClient.login(username, password);	Domain primaryDomain = webClient.getPrimaryDomain(primaryDomainName);	if (primaryDomain==null) throw new NullPointerException(this+" got null from web client for primary domain "+primaryDomainName);	SmartSubdomain smartSubdomain = primaryDomain.getSmartSubdomain(smartSubdomainName);	if (smartSubdomain == null) {	primaryDomain.createSmartSubdomain(smartSubdomainName);	smartSubdomain = primaryDomain.getSmartSubdomain(smartSubdomainName);	}	if (smartSubdomain != null) {	
geoscaling being reconfigured to use 

setServiceState(Lifecycle.CREATED);	sensors().set(ROOT_URL, null);	sensors().set(MAIN_URI, null);	} else {	setServiceState(Lifecycle.RUNNING);	String domain = getAttribute(MANAGED_DOMAIN);	if (!Strings.isEmpty(domain)) {	sensors().set(ROOT_URL, "http: sensors().set(MAIN_URI, URI.create("http: }	}	} else {	
failed to retrieve or create geoscaling smart subdomain aborting attempt to configure service 

========================= brooklyn sample_252 =========================

if ((parsedNode instanceof FunctionWithArgs) && ((FunctionWithArgs)parsedNode).getArgs()==null) {	if (node.getRoleInParent() == Role.MAP_KEY) {	node.setNewValue(parsedNode);	} else {	throw new IllegalStateException("Invalid function-only expression '"+((FunctionWithArgs)parsedNode).getFunction()+"'");	}	} else {	node.setNewValue( evaluate(parsedNode, true) );	}	} catch (Exception e) {	
error evaluating node rethrowing 

for (Object vi: (Iterable<?>)value.getNewValue()) args.add(vi);	} else {	args.add(value.getNewValue());	}	try {	if (mapIn.size()!=1) throw new IllegalStateException("Map-entry DSL syntax only supported with single item in map, not "+mapIn);	if (mapOut.size()!=0) throw new IllegalStateException("Map-entry DSL syntax only supported with empty output map-so-far, not "+mapOut);	node.setNewValue( evaluate(new FunctionWithArgs(f.getFunction(), args), false) );	return false;	} catch (Exception e) {	
error evaluating map entry rethrowing 

========================= brooklyn sample_1765 =========================

public void apply(EntityLocal entity) {	final String sensorName = JcloudsLocationConfig.CONNECTIVITY_RESOLVER.getName();	ConfigKey<Object> subkey = BrooklynConfigKeys.PROVISIONING_PROPERTIES.subKey(sensorName);	entity.config().set(subkey, this);	
set itself as the on 

contextEntity.sensors().set(Attributes.ADDRESS, hapChoice.getHostText());	}	if (!isNetworkModeSet() && !options.isWindows()) {	final boolean lookupAwsHostname = Boolean.TRUE.equals(config.get(JcloudsLocationConfig.LOOKUP_AWS_HOSTNAME));	String provider = config.get(JcloudsLocationConfig.CLOUD_PROVIDER);	if (provider == null) {	provider = location.getProvider();	}	if (options.waitForConnectable() && "aws-ec2".equals(provider) && lookupAwsHostname) {	try {	
resolving aws hostname of 

if (!isNetworkModeSet() && !options.isWindows()) {	final boolean lookupAwsHostname = Boolean.TRUE.equals(config.get(JcloudsLocationConfig.LOOKUP_AWS_HOSTNAME));	String provider = config.get(JcloudsLocationConfig.CLOUD_PROVIDER);	if (provider == null) {	provider = location.getProvider();	}	if (options.waitForConnectable() && "aws-ec2".equals(provider) && lookupAwsHostname) {	try {	String result = location.getHostnameAws(hapChoice, credChoice, config);	hapChoice = HostAndPort.fromParts(result, hapChoice.getPort());	
resolved aws hostname of 

final boolean lookupAwsHostname = Boolean.TRUE.equals(config.get(JcloudsLocationConfig.LOOKUP_AWS_HOSTNAME));	String provider = config.get(JcloudsLocationConfig.CLOUD_PROVIDER);	if (provider == null) {	provider = location.getProvider();	}	if (options.waitForConnectable() && "aws-ec2".equals(provider) && lookupAwsHostname) {	try {	String result = location.getHostnameAws(hapChoice, credChoice, config);	hapChoice = HostAndPort.fromParts(result, hapChoice.getPort());	} catch (Exception e) {	
failed to resolve aws hostname of 

}	if (options.waitForConnectable() && "aws-ec2".equals(provider) && lookupAwsHostname) {	try {	String result = location.getHostnameAws(hapChoice, credChoice, config);	hapChoice = HostAndPort.fromParts(result, hapChoice.getPort());	} catch (Exception e) {	}	}	}	ManagementAddressResolveResult result = new ManagementAddressResolveResult(hapChoice, credChoice);	
resolved management parameters for in 

protected Iterable<HostAndPort> getManagementCandidates( JcloudsLocation location, NodeMetadata node, ConfigBag config, ConnectivityResolverOptions options) {	final Optional<HostAndPort> portForwardSshOverride = options.portForwardSshOverride();	if (portForwardSshOverride.isPresent()) {	int port = portForwardSshOverride.get().hasPort() ? portForwardSshOverride.get().getPort() : options.defaultLoginPort();	final HostAndPort override = HostAndPort.fromParts(portForwardSshOverride.get().getHostText(), port);	switch (getNetworkMode()) {	
ignoring mode in favour of port forwarding override for management candidates of 

protected Iterable<HostAndPort> getManagementCandidates( JcloudsLocation location, NodeMetadata node, ConfigBag config, ConnectivityResolverOptions options) {	final Optional<HostAndPort> portForwardSshOverride = options.portForwardSshOverride();	if (portForwardSshOverride.isPresent()) {	int port = portForwardSshOverride.get().hasPort() ? portForwardSshOverride.get().getPort() : options.defaultLoginPort();	final HostAndPort override = HostAndPort.fromParts(portForwardSshOverride.get().getHostText(), port);	switch (getNetworkMode()) {	break;	
using host and port override for management candidates of 

final Optional<HostAndPort> portForwardSshOverride = options.portForwardSshOverride();	if (portForwardSshOverride.isPresent()) {	int port = portForwardSshOverride.get().hasPort() ? portForwardSshOverride.get().getPort() : options.defaultLoginPort();	final HostAndPort override = HostAndPort.fromParts(portForwardSshOverride.get().getHostText(), port);	switch (getNetworkMode()) {	break;	}	return ImmutableList.of(override);	}	if (options.pollForReachableAddresses() && options.reachableAddressPredicate() != null) {	
using reachable addresses for management candidates of 

return ImmutableList.of(override);	}	if (options.pollForReachableAddresses() && options.reachableAddressPredicate() != null) {	try {	final Predicate<? super HostAndPort> predicate = options.reachableAddressPredicate();	return getReachableAddresses(node, predicate, options.reachableAddressTimeout());	} catch (RuntimeException e) {	if (options.propagatePollForReachableFailure()) {	throw Exceptions.propagate(e);	} else {	
no reachable address falling back to any advertised address may cause future failures 

} catch (RuntimeException e) {	if (options.propagatePollForReachableFailure()) {	throw Exceptions.propagate(e);	} else {	}	}	} else if (options.pollForReachableAddresses()) {	throw new IllegalStateException(this + " was configured to expect " + node + " to be reachable " + "and to poll for its reachable addresses but the predicate to determine reachability was null");	}	Iterable<String> addresses = getResolvableAddressesWithMode(node);	
using first resolvable address in for management candidates of 

}	}	} else if (options.pollForReachableAddresses()) {	throw new IllegalStateException(this + " was configured to expect " + node + " to be reachable " + "and to poll for its reachable addresses but the predicate to determine reachability was null");	}	Iterable<String> addresses = getResolvableAddressesWithMode(node);	for (String address : addresses) {	if (isAddressResolvable(address)) {	return ImmutableList.of(HostAndPort.fromParts(address, options.defaultLoginPort()));	} else {	
unresolvable address 

} else if (options.pollForReachableAddresses()) {	throw new IllegalStateException(this + " was configured to expect " + node + " to be reachable " + "and to poll for its reachable addresses but the predicate to determine reachability was null");	}	Iterable<String> addresses = getResolvableAddressesWithMode(node);	for (String address : addresses) {	if (isAddressResolvable(address)) {	return ImmutableList.of(HostAndPort.fromParts(address, options.defaultLoginPort()));	} else {	}	}	
no resolvable address in using first may cause future failures 

protected Entity getContextEntity(ConfigBag configBag) {	Object context = configBag.get(LocationConfigKeys.CALLER_CONTEXT);	if (context instanceof Entity) {	return (Entity) context;	} else {	Entity taskContext = BrooklynTaskTags.getContextEntity(Tasks.current());	if (taskContext != null) {	return taskContext;	}	}	
no context entity found in config or current task 

========================= brooklyn sample_2630 =========================

try {	entity.start(ImmutableList.of(loc));	Assert.fail();	} catch (Exception e) {	IllegalStateException cause = Throwables2.getFirstThrowableOfType(e, IllegalStateException.class);	if (cause == null || !cause.toString().contains("Simulating start error")) throw e;	}	try {	entity.stop();	} catch (Exception e) {	
error during stop after simulating error during start 

========================= brooklyn sample_2260 =========================

public void testSetsOnFireWhenFailToReplaceMember() throws Exception {	app.subscriptions().subscribe(null, ServiceReplacer.ENTITY_REPLACEMENT_FAILED, eventListener);	final DynamicCluster cluster = app.createAndManageChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(FailingEntity.class) .configure(FailingEntity.FAIL_ON_START_CONDITION, predicateOnlyTrueForCallAtOrAfter(2))) .configure(DynamicCluster.INITIAL_SIZE, 1) .configure(DynamicCluster.QUARANTINE_FAILED_ENTITIES, true) .configure(ComputeServiceIndicatorsFromChildrenAndMembers.UP_QUORUM_CHECK, QuorumCheck.QuorumChecks.alwaysTrue()) .configure(ComputeServiceIndicatorsFromChildrenAndMembers.RUNNING_QUORUM_CHECK, QuorumCheck.QuorumChecks.alwaysTrue()));	app.start(ImmutableList.<Location>of(loc));	Assert.assertNotEquals(cluster.getAttribute(Attributes.SERVICE_STATE_ACTUAL), Lifecycle.ON_FIRE);	EntityAsserts.assertAttributeEqualsEventually(cluster, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.RUNNING);	
started for 

========================= brooklyn sample_3021 =========================

String shortVersion = majorMinorVersion.replace(".", "");	String altTarget = "/opt/brooklyn/postgres/";	String altInstallDir = Urls.mergePaths(altTarget, "install/"+majorMinorVersion);	Iterable<String> pgctlLocations = ImmutableList.of( altInstallDir+"/bin", "/usr/lib/postgresql/"+majorMinorVersion+"/bin/", "/opt/local/lib/postgresql"+shortVersion+"/bin/", "/usr/pgsql-"+majorMinorVersion+"/bin", "/usr/local/bin/", "/usr/bin/", "/bin/");	DynamicTasks.queueIfPossible(SshTasks.dontRequireTtyForSudo(getMachine(), OnFailingTask.FAIL)).orSubmitAndBlock();	DynamicTasks.waitForLast();	MutableList<String> findOrInstall = MutableList.<String>of() .append("which pg_ctl") .appendAll(Iterables.transform(pgctlLocations, StringFunctions.formatter("test -x %s/pg_ctl"))) .append(installPackage(ImmutableMap.of( "yum", "postgresql"+shortVersion+" postgresql"+shortVersion+"-server", "apt", "postgresql-"+majorMinorVersion, "port", "postgresql"+shortVersion+" postgresql"+shortVersion+"-server" ), null)) .append(warn(format("WARNING: failed to find or install postgresql %s binaries", majorMinorVersion)));	MutableList<String> linkFromHere = MutableList.<String>of() .append(ifExecutableElse1("pg_ctl", chainGroup( "PG_EXECUTABLE=`which pg_ctl`", "PG_DIR=`dirname $PG_EXECUTABLE`", "echo 'found pg_ctl in '$PG_DIR' on path so linking PG bin/ to that dir'", "ln -s $PG_DIR bin"))) .appendAll(Iterables.transform(pgctlLocations, givenDirIfFileExistsInItLinkToDir("pg_ctl", "bin"))) .append(fail(format("WARNING: failed to find postgresql %s binaries for pg_ctl, may already have another version installed; aborting", majorMinorVersion), 9));	newScript(INSTALLING) .body.append( dontRequireTtyForSudo(), ifExecutableElse0("yum", getYumRepository(version, majorMinorVersion, shortVersion)), ifExecutableElse0("apt-get", getAptRepository()), "rm -f bin", alternativesGroup(findOrInstall), alternativesGroup(linkFromHere)) .failOnNonZeroResultCode() .queue();	if (DynamicTasks.queue(SshEffectorTasks.ssh(sudoAsUser("postgres", "ls "+getInstallDir())).allowingNonZeroExitCode() .summary("check postgres user can access install dir")).asTask().getUnchecked()!=0) {	
postgres install dir for is not accessible to user postgres using instead 

private String getYumRepository(String version, String majorMinorVersion, String shortVersion) {	OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();	String arch = osDetails.getArch();	String osMajorVersion = osDetails.getVersion();	String osName = osDetails.getName();	
postgres detecting yum information for at 

String arch = osDetails.getArch();	String osMajorVersion = osDetails.getVersion();	String osName = osDetails.getName();	if (osName==null) osName = ""; else osName = osName.toLowerCase();	if (osName.equals("ubuntu")) return "echo skipping yum repo setup as this is not an rpm environment";	if (osName.equals("rhel") || osName.contains("red hat")) osName = "redhat";	else if (osName.equals("centos")) osName = "centos";	else if (osName.equals("sl") || osName.startsWith("scientific")) osName = "sl";	else if (osName.equals("fedora")) osName = "fedora";	else {	
insufficient os family information for when installing yum repos treating as centos 

if (osName==null) osName = ""; else osName = osName.toLowerCase();	if (osName.equals("ubuntu")) return "echo skipping yum repo setup as this is not an rpm environment";	if (osName.equals("rhel") || osName.contains("red hat")) osName = "redhat";	else if (osName.equals("centos")) osName = "centos";	else if (osName.equals("sl") || osName.startsWith("scientific")) osName = "sl";	else if (osName.equals("fedora")) osName = "fedora";	else {	osName = "centos";	}	if (Strings.isBlank(arch)) {	
insuffient architecture information for when installing treating as 

else if (osName.equals("fedora")) osName = "fedora";	else {	osName = "centos";	}	if (Strings.isBlank(arch)) {	arch = "x86_64";	}	if (Strings.isBlank(osMajorVersion)) {	if (osName.equals("fedora")) osMajorVersion = "20";	else osMajorVersion = "6";	
insuffient os version information for when installing yum repos treating as 

private String getConfigOrDefault(BasicAttributeSensorAndConfigKey<String> key, String def) {	String val = entity.getConfig(key);	if (Strings.isEmpty(val)) {	val = entity.sensors().get(key);	if (Strings.isEmpty(val)) {	val = def;	
has no config specified for using default 

public void launch() {	
starting entity s at s 

========================= brooklyn sample_79 =========================

public void testListAllEntities() {	List<CatalogEntitySummary> entities = client().path("/catalog/entities") .get(new GenericType<List<CatalogEntitySummary>>() {});	
entities 

public void testFilterListOfEntitiesByName() {	List<CatalogEntitySummary> entities = client().path("/catalog/entities") .query("fragment", "vaNIllasOFTWAREpROCESS").get(new GenericType<List<CatalogEntitySummary>>() {});	
matching entities 

========================= brooklyn sample_2841 =========================

private JmxService newJmxServiceRetrying(String host, int retries) throws Exception {	Exception lastexception = null;	for (int i = 0; i < retries; i++) {	try {	return new JmxService(host, (int)(11000+(500*Math.random())));	} catch (Exception e) {	
unable to create jmx service during test retries remaining 

========================= brooklyn sample_2284 =========================

synchronized (MUTEX) {	for (Map.Entry<String, Object> entry : props.asMapWithStringKeys().entrySet()) {	String property = entry.getKey();	if (property.startsWith(FEATURE_PROPERTY_PREFIX)) {	found = true;	Boolean oldVal = isEnabled(property);	boolean val = Boolean.parseBoolean(""+entry.getValue());	FEATURE_ENABLEMENTS_PROPERTIES.put(property, val);	Boolean newVal = isEnabled(property);	if (Objects.equal(oldVal, newVal)) {	
enablement of set to from brooklyn properties no op as continues to resolve to 

for (Map.Entry<String, Object> entry : props.asMapWithStringKeys().entrySet()) {	String property = entry.getKey();	if (property.startsWith(FEATURE_PROPERTY_PREFIX)) {	found = true;	Boolean oldVal = isEnabled(property);	boolean val = Boolean.parseBoolean(""+entry.getValue());	FEATURE_ENABLEMENTS_PROPERTIES.put(property, val);	Boolean newVal = isEnabled(property);	if (Objects.equal(oldVal, newVal)) {	} else {	
enablement of set to from brooklyn properties resolved value previously 

Boolean oldVal = isEnabled(property);	boolean val = Boolean.parseBoolean(""+entry.getValue());	FEATURE_ENABLEMENTS_PROPERTIES.put(property, val);	Boolean newVal = isEnabled(property);	if (Objects.equal(oldVal, newVal)) {	} else {	}	}	}	if (!found) {	
init feature enablement did nothing as no settings in brooklyn properties 

public static boolean setEnablement(String property, boolean val) {	synchronized (MUTEX) {	boolean oldVal = isEnabled(property);	FEATURE_ENABLEMENTS.put(property, val);	if (val == oldVal) {	
enablement of set to explicit no op as resolved to same value previously 

public static boolean setEnablement(String property, boolean val) {	synchronized (MUTEX) {	boolean oldVal = isEnabled(property);	FEATURE_ENABLEMENTS.put(property, val);	if (val == oldVal) {	} else {	
enablement of set to explicit previously resolved to 

public static void setDefault(String property, boolean val) {	synchronized (MUTEX) {	Boolean oldDefaultVal = FEATURE_ENABLEMENT_DEFAULTS.get(property);	FEATURE_ENABLEMENT_DEFAULTS.put(property, val);	if (oldDefaultVal != null) {	if (oldDefaultVal.equals(val)) {	
default enablement of set to no op as same as previous default value 

public static void setDefault(String property, boolean val) {	synchronized (MUTEX) {	Boolean oldDefaultVal = FEATURE_ENABLEMENT_DEFAULTS.get(property);	FEATURE_ENABLEMENT_DEFAULTS.put(property, val);	if (oldDefaultVal != null) {	if (oldDefaultVal.equals(val)) {	} else {	
default enablement of set to overwriting previous default of 

public static void setDefault(String property, boolean val) {	synchronized (MUTEX) {	Boolean oldDefaultVal = FEATURE_ENABLEMENT_DEFAULTS.get(property);	FEATURE_ENABLEMENT_DEFAULTS.put(property, val);	if (oldDefaultVal != null) {	if (oldDefaultVal.equals(val)) {	} else {	}	} else {	
default enablement of set to 

========================= brooklyn sample_1386 =========================

private static void addPropertiesFromUrl(BrooklynProperties p, String url, boolean warnIfNotFound) {	if (url==null) return;	try {	p.addFrom(ResourceUtils.create(BrooklynProperties.class).getResourceFromUrl(url));	} catch (Exception e) {	
could not load continuing 

private static void addPropertiesFromUrl(BrooklynProperties p, String url, boolean warnIfNotFound) {	if (url==null) return;	try {	p.addFrom(ResourceUtils.create(BrooklynProperties.class).getResourceFromUrl(url));	} catch (Exception e) {	
could not load continuing 

========================= brooklyn sample_1369 =========================

public void createVm() {	String groupId = "mygroup-"+System.getProperty("user.name")+"-"+UUID.randomUUID().toString();	Properties properties = new Properties();	properties.setProperty(Constants.PROPERTY_TRUST_ALL_CERTS, Boolean.toString(true));	properties.setProperty(Constants.PROPERTY_RELAX_HOSTNAME, Boolean.toString(true));	ComputeServiceContext computeServiceContext = ContextBuilder.newBuilder(PROVIDER). modules(Arrays.asList(new SshjSshClientModule(), new SLF4JLoggingModule())). credentials(identity, credential). overrides(properties). build(ComputeServiceContext.class);	final ComputeService computeService = computeServiceContext.getComputeService();	NodeMetadata node = null;	try {	
creating vm for 

try {	TemplateBuilder templateBuilder = computeService.templateBuilder();	templateBuilder.locationId(REGION);	Template template = templateBuilder.build();	Set<? extends NodeMetadata> nodes = computeService.createNodesInGroup(groupId, 1, template);	node = Iterables.getOnlyElement(nodes, null);	if (node == null) throw new IllegalStateException("No nodes returned");	assertNotNull(node.getOperatingSystem());	Credentials nodeCredentials = node.getCredentials();	final LoginCredentials expectedCredentials = LoginCredentials.fromCredentials(nodeCredentials);	
started vm waiting for it to be sshable 

if (node == null) throw new IllegalStateException("No nodes returned");	assertNotNull(node.getOperatingSystem());	Credentials nodeCredentials = node.getCredentials();	final LoginCredentials expectedCredentials = LoginCredentials.fromCredentials(nodeCredentials);	boolean reachable = false;	for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(expectedCredentials));	if (response.getExitStatus() == 0) {	
ssh date succeeded 

final LoginCredentials expectedCredentials = LoginCredentials.fromCredentials(nodeCredentials);	boolean reachable = false;	for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(expectedCredentials));	if (response.getExitStatus() == 0) {	reachable = true;	break;	}	
ssh date failed exit but still in retry loop 

boolean reachable = false;	for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(expectedCredentials));	if (response.getExitStatus() == 0) {	reachable = true;	break;	}	} catch (Exception e) {	
ssh date failed but still in retry loop 

for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(expectedCredentials));	if (response.getExitStatus() == 0) {	reachable = true;	break;	}	} catch (Exception e) {	else {	
ssh date failed after timeout 

}	Thread.sleep(1000);	}	if (!reachable) {	throw new IllegalStateException("SSH failed, never reachable");	}	} catch (RunNodesException e) {	if (e.getNodeErrors().size() > 0) {	node = Iterables.get(e.getNodeErrors().keySet(), 0);	}	
failed to start vm 

}	if (!reachable) {	throw new IllegalStateException("SSH failed, never reachable");	}	} catch (RunNodesException e) {	if (e.getNodeErrors().size() > 0) {	node = Iterables.get(e.getNodeErrors().keySet(), 0);	}	throw Throwables.propagate(e);	} catch (Exception e) {	
failed to start vm 

throw new IllegalStateException("SSH failed, never reachable");	}	} catch (RunNodesException e) {	if (e.getNodeErrors().size() > 0) {	node = Iterables.get(e.getNodeErrors().keySet(), 0);	}	throw Throwables.propagate(e);	} catch (Exception e) {	throw Throwables.propagate(e);	} finally {	
now destroying vm 

public void createVmWithAdminUser() {	String groupId = "mygroup-"+System.getProperty("user.name")+"-"+UUID.randomUUID().toString();	Properties properties = new Properties();	properties.setProperty(Constants.PROPERTY_TRUST_ALL_CERTS, Boolean.toString(true));	properties.setProperty(Constants.PROPERTY_RELAX_HOSTNAME, Boolean.toString(true));	ComputeServiceContext computeServiceContext = ContextBuilder.newBuilder(PROVIDER). modules(Arrays.asList(new SshjSshClientModule(), new SLF4JLoggingModule())). credentials(identity, credential). overrides(properties). build(ComputeServiceContext.class);	final ComputeService computeService = computeServiceContext.getComputeService();	NodeMetadata node = null;	try {	
creating vm for 

TemplateOptions opts = new TemplateOptions();	templateBuilder.imageId(PRIVATE_IMAGE_ID);	opts.overrideLoginUser("ec2-user");	AdminAccess.Builder adminBuilder = AdminAccess.builder(). adminUsername("bob"). grantSudoToAdminUser(true). authorizeAdminPublicKey(true).adminPublicKey(myPubKey). lockSsh(true).adminPassword(Identifiers.makeRandomId(12)). resetLoginPassword(false).loginPassword(Identifiers.makeRandomId(12)). installAdminPrivateKey(false).adminPrivateKey("ignored");	opts.runScript(adminBuilder.build());	templateBuilder.options(opts);	Template template = templateBuilder.build();	Set<? extends NodeMetadata> nodes = computeService.createNodesInGroup(groupId, 1, template);	node = Iterables.getOnlyElement(nodes, null);	if (node == null) throw new IllegalStateException("No nodes returned");	
started vm waiting for it to be sshable on 

Set<? extends NodeMetadata> nodes = computeService.createNodesInGroup(groupId, 1, template);	node = Iterables.getOnlyElement(nodes, null);	if (node == null) throw new IllegalStateException("No nodes returned");	final LoginCredentials crds = LoginCredentials.builder().user("bob").privateKey(myPrivKey).build();	boolean reachable = false;	for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(crds));	if (response.getExitStatus() == 0) {	
ssh date succeeded 

final LoginCredentials crds = LoginCredentials.builder().user("bob").privateKey(myPrivKey).build();	boolean reachable = false;	for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(crds));	if (response.getExitStatus() == 0) {	reachable = true;	break;	}	
ssh date failed exit but still in retry loop 

boolean reachable = false;	for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(crds));	if (response.getExitStatus() == 0) {	reachable = true;	break;	}	} catch (Exception e) {	
ssh date failed but still in retry loop 

for (int i=0; i<120; i++) {	try {	Statement statement = Statements.newStatementList(Statements.exec("date"));	ExecResponse response = computeService.runScriptOnNode(node.getId(), statement, RunScriptOptions.Builder.overrideLoginCredentials(crds));	if (response.getExitStatus() == 0) {	reachable = true;	break;	}	} catch (Exception e) {	else {	
ssh date failed after timeout 

}	Thread.sleep(1000);	}	if (!reachable) {	throw new IllegalStateException("SSH failed, never reachable");	}	} catch (RunNodesException e) {	if (e.getNodeErrors().size() > 0) {	node = Iterables.get(e.getNodeErrors().keySet(), 0);	}	
failed to start vm 

}	if (!reachable) {	throw new IllegalStateException("SSH failed, never reachable");	}	} catch (RunNodesException e) {	if (e.getNodeErrors().size() > 0) {	node = Iterables.get(e.getNodeErrors().keySet(), 0);	}	throw Throwables.propagate(e);	} catch (Exception e) {	
failed to start vm 

throw new IllegalStateException("SSH failed, never reachable");	}	} catch (RunNodesException e) {	if (e.getNodeErrors().size() > 0) {	node = Iterables.get(e.getNodeErrors().keySet(), 0);	}	throw Throwables.propagate(e);	} catch (Exception e) {	throw Throwables.propagate(e);	} finally {	
now destroying vm 

========================= brooklyn sample_2545 =========================

public void testLocalhostGetsLocation() throws Exception {	LocalhostMachineProvisioningLocation ll = new LocalhostMachineProvisioningLocation();	SshMachineLocation l = ll.obtain();	HostGeoInfo geo = HostGeoInfo.fromLocation(l);	Assert.assertNotNull(geo, "host lookup unavailable - is the maxmind database installed? or else network unavailable or too slow?");	
localhost is in 

public void testMaxmindLookup() throws Exception {	HostGeoInfo geo = new MaxMind2HostGeoLookup().getHostGeoInfo(InetAddress.getByName("maxmind.com"));	Assert.assertNotNull(geo, "host lookup unavailable - is the maxmind database installed?");	
maxmind com at 

========================= brooklyn sample_824 =========================

public void apply(final EntityLocal entity) {	super.apply(entity);	if (LOG.isDebugEnabled()) {	
adding ssh sensor to 

========================= brooklyn sample_1410 =========================

public void testUpDownManyTimes() throws Exception {	final int NUM_ITERS = 10;	up(); down(); up(); down();	forceGc();	long memUsed0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	Stopwatch sF = Stopwatch.createUnstarted();	Stopwatch sG = Stopwatch.createStarted();	for (int i=0; i<NUM_ITERS; i++) {	
iteration 

for (int i=0; i<NUM_ITERS; i++) {	sF.start();	up();	down();	sF.stop();	forceGc();	}	forceGc();	sG.stop();	long memUsed1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	
after 

up();	down();	sF.stop();	forceGc();	}	forceGc();	sG.stop();	long memUsed1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	long memLeakBytesPerIter = (memUsed1-memUsed0)/NUM_ITERS;	long upDownTimeMillisPerIter = sF.elapsed(TimeUnit.MILLISECONDS)/NUM_ITERS;	
per iter over per up down per up down gc 

========================= brooklyn sample_598 =========================

public void setUp() throws Exception {	super.setUp();	String workingDir = System.getProperty("user.dir");	
qpid working dir 

});	sendMessages(connection, number, queue.getQueueName(), content);	Asserts.succeedsEventually(new Runnable() {	public void run() {	assertEquals(queue.getAttribute(QpidQueue.QUEUE_DEPTH_MESSAGES), Integer.valueOf(number));	assertEquals(queue.getAttribute(QpidQueue.QUEUE_DEPTH_BYTES), Integer.valueOf(number * content.length()));	}	});	connection.close();	} catch (JMSException jmse) {	
jms exception caught 

private Connection getQpidConnection(QpidBroker qpid) {	int port = qpid.getAttribute(Attributes.AMQP_PORT);	System.setProperty(ClientProperties.AMQP_VERSION, "0-10");	System.setProperty(ClientProperties.DEST_SYNTAX, "ADDR");	String connectionUrl = String.format("amqp: try {	AMQConnectionFactory factory = new AMQConnectionFactory(connectionUrl);	Connection connection = factory.createConnection();	connection.start();	return connection;	} catch (Exception e) {	
error connecting to qpid s 

========================= brooklyn sample_432 =========================

public List<Entity> entitiesToRemove(Multimap<Location, Entity> currentMembers, int numToRemove) {	if (currentMembers.isEmpty()) {	throw new IllegalArgumentException("No members supplied, when requesting removal of "+numToRemove+" nodes");	}	if (currentMembers.size() < numToRemove) {	
request to remove when only members continuing 

========================= brooklyn sample_1555 =========================

public void tearDown() throws Exception {	List<Exception> exceptions = Lists.newArrayList();	for (ManagementContext mgmt : mgmts) {	try {	if (mgmt.isRunning()) Entities.destroyAll(mgmt);	} catch (Exception e) {	
error destroying management context 

========================= brooklyn sample_2553 =========================

public static void main(String[] args) throws Exception {	startJavascriptAndRest();	
press ctrl c to quit 

public static Server startJavascriptWithoutRest() throws Exception {	WebAppContext context = new WebAppContext( BrooklynRestApiLauncher.findJsguiWebappInSource().isPresent() ? BrooklynRestApiLauncher.findJsguiWebappInSource().get() : ResourceUtils.create(BrooklynJavascriptGuiLauncher.class).doesUrlExist("classpath: ? Os.writeToTempFile(ResourceUtils.create(BrooklynJavascriptGuiLauncher.class).getResourceFromUrl("classpath: : throwingReturning("could not find jsgui war or source", "missing-brooklyn.war"), "/");	context.setSecurityHandler(new NopSecurityHandler());	Server server = new Server(new InetSocketAddress(Networking.LOOPBACK, Networking.nextAvailablePort(FAVOURITE_PORT)));	BrooklynRestApiLauncher.initJaasLoginService(server);	server.setHandler(context);	server.start();	
js gui server started no rest at http return server 

========================= brooklyn sample_561 =========================

public void start(java.util.Collection<? extends Location> locations) {	ServiceStateLogic.setExpectedState(entity(), Lifecycle.STARTING);	
starting 

public void stop(ConfigBag parameters) {	ServiceStateLogic.setExpectedState(entity(), Lifecycle.STOPPING);	
stopping 

========================= brooklyn sample_131 =========================

protected void stopIptablesImpl(final SshMachineLocation machine) {	
stopping iptables for at 

protected void openIptablesImpl(Iterable<Integer> inboundPorts, SshMachineLocation machine) {	if (inboundPorts == null || Iterables.isEmpty(inboundPorts)) {	
no ports to open in iptables no inbound ports for at 

protected void openIptablesImpl(Iterable<Integer> inboundPorts, SshMachineLocation machine) {	if (inboundPorts == null || Iterables.isEmpty(inboundPorts)) {	} else {	
opening ports in iptables for at 

========================= brooklyn sample_2380 =========================

class ResolveValue implements Callable<Maybe<T>> {	public Maybe<T> call() throws Exception {	return Tasks.resolving(value).as((Class<T>)sensor.getType()).timeout(timeout).getMaybe();	}	}	final Task<Maybe<T>> resolveValue = Tasks.<Maybe<T>>builder().displayName("resolving " + value).body(new ResolveValue()).build();	class SetValue implements Callable<T> {	public T call() throws Exception {	Maybe<T> v = resolveValue.get();	if (!v.isPresent()) {	
not setting sensor on cannot resolve after timeout 

return Tasks.resolving(value).as((Class<T>)sensor.getType()).timeout(timeout).getMaybe();	}	}	final Task<Maybe<T>> resolveValue = Tasks.<Maybe<T>>builder().displayName("resolving " + value).body(new ResolveValue()).build();	class SetValue implements Callable<T> {	public T call() throws Exception {	Maybe<T> v = resolveValue.get();	if (!v.isPresent()) {	return null;	}	
setting sensor to on 

========================= brooklyn sample_1406 =========================

public void init() {	super.init();	if (Boolean.TRUE.equals(getConfig(SUPPRESS_DUPLICATES))) {	
suppress duplicates must not be set on because map is updated in place unsetting config will always implicitly suppress duplicates 

if (v == null && Boolean.TRUE.equals(removingIfResultIsNull)) {	v = Entities.REMOVE;	}	if (v == Entities.UNCHANGED) {	} else {	TKey key = this.key;	if (key==null) key = (TKey) sourceSensor.getName();	ServiceStateLogic.updateMapSensorEntry(entity, targetSensor, key, (TVal) v);	}	} catch (Throwable t) {	
error calculating map update for enricher 

========================= brooklyn sample_998 =========================

public void testNamedLocationsPropertyDefinedLocations() {	BrooklynProperties properties = BrooklynProperties.Factory.newEmpty();	properties.put("brooklyn.location.named.foo", "byon:(hosts=\"root@192.168.1.{1,2,3,4}\")");	properties.put("brooklyn.location.named.foo.privateKeyFile", "~/.ssh/foo.id_rsa");	mgmt = LocalManagementContextForTests.newInstance(properties);	
foo properties gave defined locations 

public void testResolvesByNamedAndId() {	BrooklynProperties properties = BrooklynProperties.Factory.newEmpty();	properties.put("brooklyn.location.named.foo", "byon:(hosts=\"root@192.168.1.{1,2,3,4}\")");	properties.put("brooklyn.location.named.foo.privateKeyFile", "~/.ssh/foo.id_rsa");	mgmt = LocalManagementContextForTests.newInstance(properties);	locdef = mgmt.getLocationRegistry().getDefinedLocationByName("foo");	
testresovlesby has defined locations 

public void testCircularReference() {	BrooklynProperties properties = BrooklynProperties.Factory.newEmpty();	properties.put("brooklyn.location.named.bar", "named:bar");	mgmt = LocalManagementContextForTests.newInstance(properties);	
bar properties gave defined locations 

public void testLocalhostNotPresentByDefault() {	BrooklynProperties properties = BrooklynProperties.Factory.newEmpty();	properties.put(LocalhostLocationResolver.LOCALHOST_ENABLED.getName(), false);	mgmt = LocalManagementContextForTests.newInstance(properties);	
defined locations 

========================= brooklyn sample_832 =========================

protected int getInitialQuorumSize() {	int initialSize = getConfig(INITIAL_SIZE).intValue();	int initialQuorumSize = getConfig(INITIAL_QUORUM_SIZE).intValue();	if (initialQuorumSize < 0) initialQuorumSize = initialSize;	if (initialQuorumSize > initialSize) {	
on start of cluster misconfigured initial quorum size greater than initial size using 

sensors().set(QUARANTINE_GROUP, quarantineGroup);	}	}	int initialSize = getConfig(INITIAL_SIZE).intValue();	int initialQuorumSize = getInitialQuorumSize();	Exception internalError = null;	try {	resize(initialSize);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error resizing to size collecting and handling 

}	if (firstError!=null) {	if (severalFailed) {	message += "; first failure is: "+Exceptions.collapseText(firstError);	} else {	message += ": "+Exceptions.collapseText(firstError);	}	}	throw new IllegalStateException(message, firstError);	} else if (currentSize < initialSize) {	
on start of cluster size reached initial minimum quorum size of but did not reach desired size continuing 

}	} else {	subLocations = zoneExtension.getAllSubLocations();	}	} else {	subLocations = zoneExtension.getSubLocationsByName(StringPredicates.equalToAny(zoneNames), zoneNames.size());	if (zoneNames.size() > subLocations.size()) {	throw new IllegalStateException("Number of required zones (" + zoneNames.size() + " - " + zoneNames + ") not satisfied in " + loc + "; only " + subLocations.size() + " available: " + subLocations);	}	}	
returning sub locations 

public Integer resize(Integer desiredSize) {	synchronized (mutex) {	Optional<Integer> optionalMaxSize = Optional.fromNullable(config().get(MAX_SIZE));	if (optionalMaxSize.isPresent() && desiredSize > optionalMaxSize.get()) {	throw new Resizable.InsufficientCapacityException("Desired cluster size " + desiredSize + " exceeds maximum size of " + optionalMaxSize.get());	}	int originalSize = getCurrentSize();	int delta = desiredSize - originalSize;	if (delta != 0) {	
resize from to 

public Integer resize(Integer desiredSize) {	synchronized (mutex) {	Optional<Integer> optionalMaxSize = Optional.fromNullable(config().get(MAX_SIZE));	if (optionalMaxSize.isPresent() && desiredSize > optionalMaxSize.get()) {	throw new Resizable.InsufficientCapacityException("Desired cluster size " + desiredSize + " exceeds maximum size of " + optionalMaxSize.get());	}	int originalSize = getCurrentSize();	int delta = desiredSize - originalSize;	if (delta != 0) {	} else {	
resize no op from to 

public String replaceMember(String memberId) {	Entity member = getEntityManager().getEntity(memberId);	
in replacing member 

List<Location> subLocations = findSubLocations(getLocation(true));	Collection<Location> actualMemberLocs = member.getLocations();	boolean foundMatch = false;	for (Iterator<Location> iter = actualMemberLocs.iterator(); !foundMatch && iter.hasNext();) {	Location actualMemberLoc = iter.next();	Location contenderMemberLoc = actualMemberLoc;	do {	if (subLocations.contains(contenderMemberLoc)) {	memberLoc = contenderMemberLoc;	foundMatch = true;	
in replacing member inferred its sub location is 

if (subLocations.contains(contenderMemberLoc)) {	memberLoc = contenderMemberLoc;	foundMatch = true;	}	contenderMemberLoc = contenderMemberLoc.getParent();	} while (!foundMatch && contenderMemberLoc != null);	}	if (!foundMatch) {	if (actualMemberLocs.isEmpty()) {	memberLoc = subLocations.get(0);	
in replacing member has no locations falling back to first availability zone 

foundMatch = true;	}	contenderMemberLoc = contenderMemberLoc.getParent();	} while (!foundMatch && contenderMemberLoc != null);	}	if (!foundMatch) {	if (actualMemberLocs.isEmpty()) {	memberLoc = subLocations.get(0);	} else {	memberLoc = Iterables.tryFind(actualMemberLocs, Predicates.instanceOf(MachineProvisioningLocation.class)).or(Iterables.getFirst(actualMemberLocs, null));	
in replacing member could not find matching sub location falling back to its actual location 

failed.add(subLocation);	} else {	result.add(subLocation);	}	}	Set<Location> newlyFailed = Sets.difference(failed, oldFailedSubLocations);	Set<Location> newlyRecovered = Sets.difference(oldFailedSubLocations, failed);	sensors().set(FAILED_SUB_LOCATIONS, failed);	sensors().set(SUB_LOCATIONS, result);	if (newlyFailed.size() > 0) {	
detected probably zone failures for 

result.add(subLocation);	}	}	Set<Location> newlyFailed = Sets.difference(failed, oldFailedSubLocations);	Set<Location> newlyRecovered = Sets.difference(oldFailedSubLocations, failed);	sensors().set(FAILED_SUB_LOCATIONS, failed);	sensors().set(SUB_LOCATIONS, result);	if (newlyFailed.size() > 0) {	}	if (newlyRecovered.size() > 0) {	
detected probably zone recoveries for 

protected Collection<Entity> grow(int delta) {	Preconditions.checkArgument(delta > 0, "Must call grow with positive delta.");	List<Location> chosenLocations;	EntitySpec<?> memberSpec = getMemberSpec();	boolean memberSpecHasLocation = memberSpec!=null && (!memberSpec.getLocationSpecs().isEmpty() || !memberSpec.getLocations().isEmpty());	if (memberSpecHasLocation) {	if (isAvailabilityZoneEnabled()) {	
cluster has availability zone enabled but memberspec overrides location with using memberspec s location availability zone behaviour will not apply 

protected Collection<Entity> shrink(int delta) {	Preconditions.checkArgument(delta < 0, "Must call shrink with negative delta.");	int size = getCurrentSize();	if (-delta > size) {	
call to shrink by when size is amending 

protected void quarantineFailedNodes(Map<Entity, Throwable> failedEntities) {	for (Map.Entry<Entity, Throwable> entry : failedEntities.entrySet()) {	Entity entity = entry.getKey();	Throwable cause = entry.getValue();	if (cause == null || getQuarantineFilter().apply(cause)) {	sensors().emit(ENTITY_QUARANTINED, entity);	getQuarantineGroup().addMember(entity);	removeMember(entity);	} else {	
cluster discarding failed node rather than quarantining 

Map<Entity, Throwable> errors = Maps.newLinkedHashMap();	for (Map.Entry<? extends Entity,? extends Task<?>> entry : tasks.entrySet()) {	Entity entity = entry.getKey();	Task<?> task = entry.getValue();	try {	task.get();	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	} catch (Throwable t) {	Throwable interesting = Exceptions.getFirstInteresting(t);	
cluster failed to start entity removing 

Map<Entity, Throwable> errors = Maps.newLinkedHashMap();	for (Map.Entry<? extends Entity,? extends Task<?>> entry : tasks.entrySet()) {	Entity entity = entry.getKey();	Task<?> task = entry.getValue();	try {	task.get();	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	} catch (Throwable t) {	Throwable interesting = Exceptions.getFirstInteresting(t);	
trace for cluster failed to start entity removing 

public Entity addNode(@Nullable Location loc, Map<?, ?> extraFlags) {	initialiseMemberId();	Map<?, ?> createFlags = MutableMap.builder() .putAll(getCustomChildFlags()) .putAll(extraFlags) .put(CLUSTER_MEMBER_ID, sensors().get(NEXT_CLUSTER_MEMBER_ID).get()) .build();	if (LOG.isTraceEnabled()) {	
creating and adding a node to cluster with properties 

protected List<Entity> pickAndRemoveMembers(int delta) {	if (delta==0) return Lists.newArrayList();	if (delta == 1 && !isAvailabilityZoneEnabled()) {	Maybe<Entity> member = tryPickAndRemoveMember();	return (member.isPresent()) ? ImmutableList.of(member.get()) : ImmutableList.<Entity>of();	}	Preconditions.checkState(getMembers().size() > 0, "Attempt to remove a node (delta "+delta+") when members is empty, from cluster " + this);	
removing a node from 

private Maybe<Entity> tryPickAndRemoveMember() {	assert !isAvailabilityZoneEnabled() : "should instead call pickAndRemoveMembers(int) if using availability zones";	Collection<Entity> members = getMembers();	if (members.isEmpty()) return Maybe.absent();	
removing a node from 

protected void discardNode(Entity entity) {	removeMember(entity);	try {	Entities.unmanage(entity);	} catch (IllegalStateException e) {	
exception during removing member of cluster unmanaging node the node is probably already unmanaged 

public void run() {	String oldDetails = Tasks.setBlockingDetails(description);	
acquiring permit from 

public void run() {	if (wasPermitObtained.get()) {	
releasing permit from 

public void run() {	if (wasPermitObtained.get()) {	permit.release();	} else {	
not releasing a permit from because it appears one was never obtained 

========================= brooklyn sample_1543 =========================

for (Effector<?> eff : memento.getEffectors()) {	entity.getMutableEntityType().addEffector(eff);	}	for (Map.Entry<AttributeSensor<?>, Object> entry : memento.getAttributes().entrySet()) {	try {	AttributeSensor<?> key = entry.getKey();	Object value = entry.getValue();	Class<?> type = (key.getType() != null) ? key.getType() : rebindContext.loadClass(key.getTypeName());	entity.sensors().setWithoutPublishing((AttributeSensor<Object>)key, value);	} catch (Exception e) {	
error adding custom sensor when rebinding rethrowing 

public void addPolicies(RebindContext rebindContext, EntityMemento memento) {	for (String policyId : memento.getPolicies()) {	AbstractPolicy policy = (AbstractPolicy) rebindContext.lookup().lookupPolicy(policyId);	if (policy != null) {	try {	entity.policies().add(policy);	} catch (Exception e) {	rebindContext.getExceptionHandler().onAddPolicyFailed(entity, policy, e);	}	} else {	
policy not found discarding policy of entity 

public void addEnrichers(RebindContext rebindContext, EntityMemento memento) {	for (String enricherId : memento.getEnrichers()) {	AbstractEnricher enricher = (AbstractEnricher) rebindContext.lookup().lookupEnricher(enricherId);	if (enricher != null) {	try {	entity.enrichers().add(enricher);	} catch (Exception e) {	rebindContext.getExceptionHandler().onAddEnricherFailed(entity, enricher, e);	}	} else {	
enricher not found discarding enricher of entity 

rebindContext.getExceptionHandler().onAddFeedFailed(entity, feed, e);	}	try {	if (!rebindContext.isReadOnly(feed)) {	feed.start();	}	} catch (Exception e) {	rebindContext.getExceptionHandler().onRebindFailed(BrooklynObjectType.ENTITY, entity, e);	}	} else {	
feed not found discarding feed of entity 

protected void addMembers(RebindContext rebindContext, EntityMemento memento) {	if (memento.getMembers().size() > 0) {	if (entity instanceof AbstractGroupImpl) {	for (String memberId : memento.getMembers()) {	Entity member = rebindContext.lookup().lookupEntity(memberId);	if (member != null) {	((AbstractGroupImpl)entity).addMemberInternal(member);	} else {	
entity not found discarding member of group 

protected void addChildren(RebindContext rebindContext, EntityMemento memento) {	for (String childId : memento.getChildren()) {	Entity child = rebindContext.lookup().lookupEntity(childId);	if (child != null) {	entity.addChild(proxy(child));	} else {	
entity not found discarding child of entity 

protected void setParent(RebindContext rebindContext, EntityMemento memento) {	Entity parent = (memento.getParent() != null) ? rebindContext.lookup().lookupEntity(memento.getParent()) : null;	if (parent != null) {	entity.setParent(proxy(parent));	} else if (memento.getParent() != null){	
entity not found discarding parent of entity so entity will be orphaned and unmanaged 

protected void addLocations(RebindContext rebindContext, EntityMemento memento) {	for (String id : memento.getLocations()) {	Location loc = rebindContext.lookup().lookupLocation(id);	if (loc != null) {	entity.addLocationsWithoutPublishing(ImmutableList.of(loc));	} else {	
location not found discarding location of entity 

protected void markTransitioningEntityOnFireOnRebind(EntityInternal entity, Lifecycle expectedState) {	LOG.warn("Entity {} being marked as on-fire because it was in state {} on rebind; indicators={}", new Object[] {entity, expectedState, entity.getAttribute(Attributes.SERVICE_NOT_UP_INDICATORS)});	ServiceStateLogic.setExpectedState(entity, Lifecycle.ON_FIRE);	ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator( entity, "Task aborted on rebind", "Set to on-fire (from previous expected state "+expectedState+") because tasks aborted on shutdown");	Maybe<MachineLocation> machine = Machines.findUniqueMachineLocation(entity.getLocations());	ProvisioningTaskState provisioningState = entity.sensors().get(AttributesInternal.INTERNAL_PROVISIONING_TASK_STATE);	if (machine.isAbsent() && provisioningState == ProvisioningTaskState.RUNNING) {	
entity was provisioning vm may have been left running 

LOG.warn("Entity {} being marked as on-fire because it was in state {} on rebind; indicators={}", new Object[] {entity, expectedState, entity.getAttribute(Attributes.SERVICE_NOT_UP_INDICATORS)});	ServiceStateLogic.setExpectedState(entity, Lifecycle.ON_FIRE);	ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator( entity, "Task aborted on rebind", "Set to on-fire (from previous expected state "+expectedState+") because tasks aborted on shutdown");	Maybe<MachineLocation> machine = Machines.findUniqueMachineLocation(entity.getLocations());	ProvisioningTaskState provisioningState = entity.sensors().get(AttributesInternal.INTERNAL_PROVISIONING_TASK_STATE);	if (machine.isAbsent() && provisioningState == ProvisioningTaskState.RUNNING) {	ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator( entity, "VM may be lost on rebind", "VM provisioning may have been in-progress and now lost, because tasks aborted on shutdown");	}	ProvisioningTaskState terminationState = entity.sensors().get(AttributesInternal.INTERNAL_TERMINATION_TASK_STATE);	if (machine.isAbsent() && terminationState == ProvisioningTaskState.RUNNING) {	
entity was terminating vm may have been left running 

========================= brooklyn sample_1113 =========================

public void init() {	
initializing the couchbase cluster 

Tasks.setBlockingDetails("Pausing while Couchbase stabilizes");	Time.sleep(getConfig(NODES_STARTED_STABILIZATION_DELAY));	Optional<Set<Entity>> upNodes = Optional.<Set<Entity>>fromNullable(getAttribute(COUCHBASE_CLUSTER_UP_NODES));	if (upNodes.isPresent() && !upNodes.get().isEmpty()) {	Tasks.setBlockingDetails("Adding servers to Couchbase");	Entity primaryNode = upNodes.get().iterator().next();	((EntityInternal) primaryNode).sensors().set(CouchbaseNode.IS_PRIMARY_NODE, true);	sensors().set(COUCHBASE_PRIMARY_NODE, primaryNode);	Set<Entity> serversToAdd = MutableSet.<Entity>copyOf(getUpNodes());	if (serversToAdd.size() >= getQuorumSize() && serversToAdd.size() > 1) {	
number of service up nodes in cluster reached quorum adding the servers 

addServers(serversToAdd);	try {	Tasks.setBlockingDetails("Delaying before advertising cluster up");	Time.sleep(getConfig(DELAY_BEFORE_ADVERTISING_CLUSTER));	} finally {	Tasks.resetBlockingDetails();	}	getPrimaryNode().rebalance();	} else {	if (getQuorumSize()>1) {	
is not quorate will likely fail later but proceeding for now 

protected synchronized void onServerPoolMemberChanged(Entity member) {	
for considering membership of which is in locations 

sensors().set(COUCHBASE_CLUSTER_UP_NODES, newNodes);	if (isClusterInitialized()) {	addServer(member);	}	}	} else {	Set<Entity> upNodes = getUpNodes();	if (upNodes != null && upNodes.contains(member)) {	upNodes.remove(member);	sensors().set(COUCHBASE_CLUSTER_UP_NODES, upNodes);	
removing couchbase node from cluster 

addServer(member);	}	}	} else {	Set<Entity> upNodes = getUpNodes();	if (upNodes != null && upNodes.contains(member)) {	upNodes.remove(member);	sensors().set(COUCHBASE_CLUSTER_UP_NODES, upNodes);	}	}	
done checkentity 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	
members of checking eliminating because not up 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getMembers().contains(member)) {	
members of checking eliminating because not member 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getMembers().contains(member)) {	return false;	}	
members of checking approving 

protected void addServerSeveralTimes(Entity s, int numRetries, Duration delayOnFailure) {	try {	addServer(s);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (numRetries<=0) throw Exceptions.propagate(e);	
error adding to retries remaining will retry after delay 

========================= brooklyn sample_424 =========================

protected void connectSensors() {	sensors().set(DATASTORE_URL, String.format("postgresql: Maybe<SshMachineLocation> machine = Locations.findUniqueSshMachineLocation(getLocations());	if (machine.isPresent()) {	feed = SshFeed.builder() .entity(this) .machine(machine.get()) .poll(new SshPollConfig<Boolean>(SERVICE_UP) .command("ps -ef | grep [p]ostgres") .setOnSuccess(true) .setOnFailureOrException(false)) .build();	} else {	
location s not an ssh machine location so not polling for status setting serviceup immediately 

========================= brooklyn sample_80 =========================

public String load(String path) {	try {	String base = "http: String x = path.startsWith(base) ? path : Urls.mergePaths(base, path);	
reading from 

public String load(String path) {	try {	String base = "http: String x = path.startsWith(base) ? path : Urls.mergePaths(base, path);	String s = Files.streamToString(new URL(x).openStream());	
result from 

========================= brooklyn sample_1778 =========================

protected SshPollValue exec(String command, Map<String,String> env) throws IOException {	WinRmMachineLocation machine = (WinRmMachineLocation)getMachine();	
winrm polling for executing with env 

========================= brooklyn sample_2154 =========================

public void testJcloudsSingle() throws Exception {	location = resolve("single:(target='"+JCLOUDS_LOCATION_SPEC+"')");	MachineLocation m1 = obtainMachine();	assertNotNull(m1);	
got 

public void testJcloudsSingleRelease() throws Exception {	location = resolve("single:(target='"+JCLOUDS_LOCATION_SPEC+"')");	JcloudsSshMachineLocation m1 = obtainMachine();	
got 

public void testJcloudsSingleRelease() throws Exception {	location = resolve("single:(target='"+JCLOUDS_LOCATION_SPEC+"')");	JcloudsSshMachineLocation m1 = obtainMachine();	JcloudsSshMachineLocation m2 = obtainMachine();	
got 

public void testJcloudsSingleObtainReleaseObtain() throws Exception {	location = resolve("single:(target='"+JCLOUDS_LOCATION_SPEC+"')");	JcloudsSshMachineLocation m1 = obtainMachine();	
got 

========================= brooklyn sample_2504 =========================

public void onEvent(SensorEvent<Object> event) {	Sensor<?> destinationSensor = getConfig(TARGET_SENSOR);	List<Object> values = Lists.newArrayList();	for (AttributeSensor<?> sourceSensor : subscribedSensors) {	Object resolvedSensorValue = entity.sensors().get(sourceSensor);	values.add(resolvedSensorValue);	}	Object result = reducerFunction.apply(values);	
enricher got propagating via as 

========================= brooklyn sample_1001 =========================

public AggregatingCampPlatform(PlatformRootSummary root, CampPlatform platformWhereTransactionsOccur) {	super(root);	
creating with main platform 

protected void addPlatform(CampPlatform platform) {	
adding child platform to 

========================= brooklyn sample_1847 =========================

public Void call() throws Exception {	Map<String, Object> result;	result = populateDescriptors();	String json = toJson(result);	if (outputFolder == null) {	System.out.println(json);	} else {	
outputting item list size to 

String enricherHtml = TemplateProcessor.processTemplateContents(enricherTemplateHtml, ImmutableMap.of("type", type, "name", name));	Files.write(enricherHtml, new File(Os.mergePaths(outputFolder, "enrichers", type + ".html")), Charsets.UTF_8);	}	List<Map<String, Object>> locations = (List<Map<String, Object>>) result.get("locations");	String locationTemplateHtml = resourceUtils.getResourceAsString(Urls.mergePaths(BASE_TEMPLATES, "location.html"));	for (Map<String, Object> location : locations) {	String type = (String) location.get("type");	String locationHtml = TemplateProcessor.processTemplateContents(locationTemplateHtml, ImmutableMap.of("type", type));	Files.write(locationHtml, new File(Os.mergePaths(outputFolder, "locations", type + ".html")), Charsets.UTF_8);	}	
finished outputting item list to 

protected Map<String, Object> populateDescriptors() throws MalformedURLException, IOException {	Map<String, Object> result;	List<Map<?,?>> entities = new ArrayList<>();	List<Map<?,?>> policies = new ArrayList<>();	List<Map<?,?>> enrichers = new ArrayList<>();	List<Map<?,?>> locations = new ArrayList<>();	List<Object> locationResolvers = new ArrayList<>();	if (!getJars().isEmpty() || yamlToScan.isEmpty()) {	List<URL> urls = getJarUrls();	
retrieving classes from 

if (!getJars().isEmpty() || yamlToScan.isEmpty()) {	List<URL> urls = getJarUrls();	entities.addAll(ItemDescriptors.toItemDescriptors(getTypes(urls, Entity.class), headingsOnly, "name"));	policies.addAll(ItemDescriptors.toItemDescriptors(getTypes(urls, Policy.class), headingsOnly, "name"));	enrichers.addAll(ItemDescriptors.toItemDescriptors(getTypes(urls, Enricher.class), headingsOnly, "name"));	locations.addAll(ItemDescriptors.toItemDescriptors(getTypes(urls, Location.class, false), headingsOnly, "type"));	locationResolvers.addAll(ItemDescriptors.toItemDescriptors( ImmutableList.copyOf(FrameworkLookup.lookupAll(LocationResolver.class)), true));	}	if (!yamlToScan.isEmpty()) {	List<URL> urls = getYamlUrls();	
retrieving items from 

for (CatalogItem<?,?> item: items) {	Map<String,Object> itemDescriptor = ItemDescriptors.toItemDescriptor(catalog, item, headingsOnly);	itemCount++;	if (item.getCatalogItemType() == CatalogItem.CatalogItemType.ENTITY || item.getCatalogItemType() == CatalogItem.CatalogItemType.TEMPLATE) {	entities.add(itemDescriptor);	} else if (item.getCatalogItemType() == CatalogItem.CatalogItemType.POLICY) {	policies.add(itemDescriptor);	} else if (item.getCatalogItemType() == CatalogItem.CatalogItemType.LOCATION) {	locations.add(itemDescriptor);	} else {	
skipping unknown catalog item type 

protected List<URL> getJarUrls() throws MalformedURLException, IOException {	List<URL> urls = Lists.newArrayList();	if (!getJars().isEmpty()) {	for (String jar : getJars()) {	List<URL> expanded = ClassFinder.toJarUrls(jar);	
no jars found at 

========================= brooklyn sample_2768 =========================

public static List<Entity> addChildrenUnstarted(final Entity parent, String yaml) {	
creating child of from yaml 

========================= brooklyn sample_1144 =========================

Object value;	if (type==null && reader.hasMoreChildren()) {	reader.moveDown();	value = readItem(reader, context, map);	reader.moveUp();	} else {	Class typeC = type!=null ? mapper().realClass(type) : String.class;	try {	value = TypeCoercions.coerce(reader.getValue(), typeC);	} catch (Exception e) {	
failed to coerce to 

========================= brooklyn sample_1514 =========================

public void connectSensors() {	super.connectSensors();	if (getDriver().isJmxEnabled()) {	String serverMbeanName = "org.mortbay.jetty:type=server,id=0";	String statsMbeanName = "org.mortbay.jetty.handler:type=atomicstatisticshandler,id=0";	jmxFeedJetty = JmxFeed.builder() .entity(this) .period(500, TimeUnit.MILLISECONDS) .pollAttribute(new JmxAttributePollConfig<Boolean>(SERVICE_UP) .objectName(serverMbeanName) .attributeName("running") .onSuccess(Functions.forPredicate(Predicates.<Object>equalTo(true))) .setOnFailureOrException(false)) .pollAttribute(new JmxAttributePollConfig<Integer>(REQUEST_COUNT) .objectName(statsMbeanName) .attributeName("requests") .onFailureOrException(EntityFunctions.attribute(this, REQUEST_COUNT))) .pollAttribute(new JmxAttributePollConfig<Integer>(RESPONSES_4XX_COUNT) .objectName(statsMbeanName) .attributeName("responses4xx")) .pollAttribute(new JmxAttributePollConfig<Integer>(RESPONSES_5XX_COUNT) .objectName(statsMbeanName) .attributeName("responses5xx")) .pollAttribute(new JmxAttributePollConfig<Integer>(TOTAL_PROCESSING_TIME) .objectName(statsMbeanName) .attributeName("requestTimeTotal")) .pollAttribute(new JmxAttributePollConfig<Integer>(MAX_PROCESSING_TIME) .objectName(statsMbeanName) .attributeName("requestTimeMax")) .build();	enrichers().add(Enrichers.builder() .combining(RESPONSES_4XX_COUNT, RESPONSES_5XX_COUNT) .publishing(ERROR_COUNT) .computingSum() .build());	jmxFeedMx = JavaAppUtils.connectMXBeanSensors(this);	} else {	
jetty running without jmx monitoring limited visibility of service available 

========================= brooklyn sample_234 =========================

public void init() {	if (jcloudsParent != null) {	super.init();	} else {	
not doing init of because parent not set presuming rebinding 

public void rebind() {	super.rebind();	if (jcloudsParent == null) {	
location does not have parent cannot retrieve jclouds compute service later operations may fail continuing 

protected void setNode(NodeMetadata node) {	this.node = null;	config().removeKey("node");	nodeId = node.getId();	imageId = node.getImageId();	publicAddresses = node.getPublicAddresses();	_node = Optional.of(node);	Boolean useMachinePublicAddressAsPrivateAddress = config().get(USE_MACHINE_PUBLIC_ADDRESS_AS_PRIVATE_ADDRESS);	if(useMachinePublicAddressAsPrivateAddress) {	
overriding private address as public address as config is set to true 

public Optional<NodeMetadata> getOptionalNode() {	if (_node == null) {	try {	ComputeService computeService = getComputeServiceOrNull();	if (computeService == null) {	
cannot get node for because cannot get compute service from parent 

if (_node == null) {	try {	ComputeService computeService = getComputeServiceOrNull();	if (computeService == null) {	_node = Optional.absent();	} else {	_node = Optional.fromNullable(computeService.getNodeMetadata(nodeId));	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem getting node metadata for node id continuing 

protected Optional<Image> getOptionalImage() {	if (_image == null) {	if (imageId == null) {	_image = Optional.absent();	} else {	try {	ComputeService computeService = getComputeServiceOrNull();	if (computeService == null) {	
cannot get image with id for because cannot get compute service from parent 

} else {	try {	ComputeService computeService = getComputeServiceOrNull();	if (computeService == null) {	_image = Optional.absent();	} else {	_image = Optional.fromNullable(computeService.getImage(imageId));	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem getting image for image id continuing 

public Template getTemplate() {	Optional<Template> result = getOptionalTemplate();	if (result.isPresent()) {	String msg = "Deprecated use of getTemplate() for "+this;	
see debug log for stacktrace 

public Template getTemplate() {	Optional<Template> result = getOptionalTemplate();	if (result.isPresent()) {	String msg = "Deprecated use of getTemplate() for "+this;	
for stacktrace 

requestPersist();	} else {	if (groovyTruth(getPublicAddresses())) {	hostname = getPublicAddresses().iterator().next();	} else if (groovyTruth(getPrivateAddresses())) {	hostname = getPrivateAddresses().iterator().next();	} else {	hostname = getAddress().getHostAddress();	}	}	
resolved hostname for 

privateHostname = p;	break;	}	if (Strings.isBlank(privateHostname) && groovyTruth(getPublicAddresses())) {	privateHostname = getPublicAddresses().iterator().next();	} else if (Strings.isBlank(privateHostname)) {	privateHostname = getHostname();	}	}	requestPersist();	
resolved subnet hostname for 

String versionRaw = os.get().getVersion();	boolean is64Bit = os.get().is64Bit();	name = Optional.fromNullable(family != null && !OsFamily.UNRECOGNIZED.equals(family) ? family.toString() : null);	version = Optional.fromNullable(Strings.isNonBlank(versionRaw) ? versionRaw : null);	architecture = Optional.fromNullable(is64Bit ? BasicOsDetails.OsArchs.X_86_64 : BasicOsDetails.OsArchs.I386);	}	Optional<Integer> ram = hardware.isPresent() ? Optional.fromNullable(hardware.get().getRam()) : Optional.<Integer>absent();	Optional<Integer> cpus = hardware.isPresent() ? Optional.fromNullable(hardware.get().getProcessors() != null ? hardware.get().getProcessors().size() : null) : Optional.<Integer>absent();	if (name.isPresent() && version.isPresent() && architecture.isPresent() && ram.isPresent() && cpus.isPresent()) {	if (LOG.isTraceEnabled()) {	
gathered machine details from jclouds skipping ssh test on 

putIfNotNull(builder, "instanceTypeId", (hardware.isPresent() ? hardware.get().getProviderId() : null));	putIfNotNull(builder, "ram", "" + (hardware.isPresent() ? hardware.get().getRam() : null));	putIfNotNull(builder, "cpus", "" + (processors != null ? processors.size() : null));	try {	OsDetails osDetails = getOsDetails();	putIfNotNull(builder, "osName", osDetails.getName());	putIfNotNull(builder, "osArch", osDetails.getArch());	putIfNotNull(builder, "is64bit", osDetails.is64bit() ? "true" : "false");	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to get os details for continuing 

========================= brooklyn sample_2590 =========================

public void onEvent(SensorEvent<Object> event) {	
received event 

executorTime = System.currentTimeMillis();	executorQueued.set(false);	strategy.rebalance();	if (LOG.isDebugEnabled()) LOG.debug("{} post-rebalance: poolSize={}; workrate={}; lowThreshold={}; " + "highThreshold={}", new Object[] {this, model.getPoolSize(), model.getCurrentPoolWorkrate(), model.getPoolLowThreshold(), model.getPoolHighThreshold()});	if (model.isCold()) {	Map eventVal = ImmutableMap.of( AutoScalerPolicy.POOL_CURRENT_SIZE_KEY, model.getPoolSize(), AutoScalerPolicy.POOL_CURRENT_WORKRATE_KEY, model.getCurrentPoolWorkrate(), AutoScalerPolicy.POOL_LOW_THRESHOLD_KEY, model.getPoolLowThreshold(), AutoScalerPolicy.POOL_HIGH_THRESHOLD_KEY, model.getPoolHighThreshold());	poolEntity.sensors().emit(AutoScalerPolicy.DEFAULT_POOL_COLD_SENSOR, eventVal);	if (LOG.isInfoEnabled()) {	int desiredPoolSize = (int) Math.ceil(model.getCurrentPoolWorkrate() / (model.getPoolLowThreshold()/model.getPoolSize()));	if (desiredPoolSize != lastEmittedDesiredPoolSize || lastEmittedPoolTemperature != TemperatureStates.COLD) {	
emitted cold suggesting 

lastEmittedDesiredPoolSize = desiredPoolSize;	lastEmittedPoolTemperature = TemperatureStates.COLD;	}	}	} else if (model.isHot()) {	Map eventVal = ImmutableMap.of( AutoScalerPolicy.POOL_CURRENT_SIZE_KEY, model.getPoolSize(), AutoScalerPolicy.POOL_CURRENT_WORKRATE_KEY, model.getCurrentPoolWorkrate(), AutoScalerPolicy.POOL_LOW_THRESHOLD_KEY, model.getPoolLowThreshold(), AutoScalerPolicy.POOL_HIGH_THRESHOLD_KEY, model.getPoolHighThreshold());	poolEntity.sensors().emit(AutoScalerPolicy.DEFAULT_POOL_HOT_SENSOR, eventVal);	if (LOG.isInfoEnabled()) {	int desiredPoolSize = (int) Math.ceil(model.getCurrentPoolWorkrate() / (model.getPoolHighThreshold()/model.getPoolSize()));	if (desiredPoolSize != lastEmittedDesiredPoolSize || lastEmittedPoolTemperature != TemperatureStates.HOT) {	
emitted hot suggesting 

if (desiredPoolSize != lastEmittedDesiredPoolSize || lastEmittedPoolTemperature != TemperatureStates.HOT) {	lastEmittedDesiredPoolSize = desiredPoolSize;	lastEmittedPoolTemperature = TemperatureStates.HOT;	}	}	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (isRunning()) {	if (retriesRemaining>0) {	
error rebalancing ignoring and retrying left 

lastEmittedPoolTemperature = TemperatureStates.HOT;	}	}	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (isRunning()) {	if (retriesRemaining>0) {	runWithRetries(retriesRemaining-1);	} else {	
error rebalancing ignoring another event may trigger a rebalance 

}	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (isRunning()) {	if (retriesRemaining>0) {	runWithRetries(retriesRemaining-1);	} else {	}	} else {	
error rebalancing but no longer running 

private void onContainerAdded(NodeType newContainer, boolean rebalanceNow) {	Preconditions.checkArgument(newContainer instanceof BalanceableContainer, "Added container must be a BalanceableContainer");	
recording addition of container 

private void onContainerAdded(NodeType newContainer, boolean rebalanceNow) {	Preconditions.checkArgument(newContainer instanceof BalanceableContainer, "Added container must be a BalanceableContainer");	Number lowThreshold = newContainer.getConfig(ConfigKeys.newConfigKey(Number.class, lowThresholdConfigKeyName));	Number highThreshold = newContainer.getConfig(ConfigKeys.newConfigKey(Number.class, highThresholdConfigKeyName));	if (lowThreshold == null || highThreshold == null) {	
balanceable container does not define low and high threshold configuration keys and skipping 

private void onContainerRemoved(NodeType oldContainer, boolean rebalanceNow) {	
recording removal of container 

private void onItemAdded(ItemType item, NodeType parentContainer, boolean rebalanceNow) {	Preconditions.checkArgument(item instanceof Movable, "Added item "+item+" must implement Movable");	
recording addition of item in container 

private void onItemRemoved(ItemType item, NodeType parentContainer, boolean rebalanceNow) {	
recording removal of item 

private void onItemMoved(ItemType item, NodeType parentContainer, boolean rebalanceNow) {	
recording moving of item to 

private void onItemMetricUpdate(ItemType item, double newValue, boolean rebalanceNow) {	
recording metric update for item new value 

========================= brooklyn sample_3047 =========================

public void testVmMetadata() {	loc = (JcloudsLocation) mgmt().getLocationRegistry().getLocationManaged(PROVIDER + (REGION_NAME == null ? "" : ":" + REGION_NAME));	SshMachineLocation machine = obtainMachine(MutableMap.of("imageId", IMAGE_ID, "userMetadata", MutableMap.of("mykey", "myval"), JcloudsLocation.MACHINE_CREATE_ATTEMPTS, 2));	
provisioned vm checking metadata and if ssh able 

========================= brooklyn sample_2528 =========================

private void start() throws IOException {	
monitoring 

} else {	int numVals = values.size();	long startTime = (numVals > 0) ? values.get(0).getTimestamp() : 0;	long endTime = (numVals > 0) ? values.get(values.size()-1).getTimestamp() : 0;	LOG.info("Insufficient vals in time-window to determine cycling behaviour over period ("+prefs.webProcessesCyclingPeriod+"secs): "+ "numVals="+numVals+"; startTime="+startTime+"; endTime="+endTime+"; periodCovered="+(endTime-startTime)/1000);	}	}	}	}	} catch (Throwable t) {	
error during periodic checks 

}	} catch (Throwable t) {	throw Throwables.propagate(t);	}	try {	recorder.record(record);	listener.onRecord(record);	if (failureMsg.length() > 0) {	listener.onFailure(record, failureMsg.toString());	if (prefs.abortOnError) {	
aborting on error 

try {	recorder.record(record);	listener.onRecord(record);	if (failureMsg.length() > 0) {	listener.onFailure(record, failureMsg.toString());	if (prefs.abortOnError) {	System.exit(1);	}	}	} catch (Throwable t) {	
error recording monitor info 

========================= brooklyn sample_43 =========================

public Assembly instantiate(AssemblyTemplate template, CampPlatform platform) {	Application app = create(template, platform);	CreationResult<Application, Void> start = EntityManagementUtils.start(app);	
camp created starting in 

private Application create(AssemblyTemplate template, CampPlatform platform) {	ManagementContext mgmt = getManagementContext(platform);	BrooklynClassLoadingContext loader = JavaBrooklynClassLoadingContext.create(mgmt);	EntitySpec<? extends Application> spec = createApplicationSpec(template, platform, loader, MutableSet.<String>of());	Application instance = mgmt.getEntityManager().createEntity(spec);	
camp created 

public EntitySpec<? extends Application> createApplicationSpec( AssemblyTemplate template, CampPlatform platform, BrooklynClassLoadingContext loader, Set<String> encounteredTypeSymbolicNames) {	
camp creating application instance for 

========================= brooklyn sample_1754 =========================

if (parameter instanceof Map) {	Map<?, ?> param = (Map) parameter;	parameters = MutableMap.of();	for (Map.Entry<?, ?> entry : param.entrySet()) {	String key = TypeCoercions.coerce(entry.getKey(), String.class);	parameters.put(key, entry.getValue());	}	} else {	parameters = MutableMap.of(getConfig(PARAMETER_NAME), parameter);	}	
invoking on with parameters 

========================= brooklyn sample_1611 =========================

public void removeRegion(String id) {	Entity entity = getManagementContext().getEntityManager().getEntity(id);	Preconditions.checkNotNull(entity, "No entity found for %s", id);	Preconditions.checkArgument(this.equals(entity.getParent()), "Wrong parent (%s) for %s", entity.getParent(), entity);	Collection<Location> childLocations = entity.getLocations();	if (entity instanceof Startable) {	try {	Entities.invokeEffector(this, entity, Startable.STOP).get();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error stopping proceeding to remove it anyway 

public void removeRegion(String id) {	Entity entity = getManagementContext().getEntityManager().getEntity(id);	Preconditions.checkNotNull(entity, "No entity found for %s", id);	Preconditions.checkArgument(this.equals(entity.getParent()), "Wrong parent (%s) for %s", entity.getParent(), entity);	Collection<Location> childLocations = entity.getLocations();	if (entity instanceof Startable) {	try {	Entities.invokeEffector(this, entity, Startable.STOP).get();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error stopping proceeding to remove it anyway 

========================= brooklyn sample_1538 =========================

MockItemEntity item = newLockedItem(app, container, "item-locked-"+locName+"-"+j);	lockedItems.put(loc, item);	}	}	for (int i = 1; i <= numMovableItems; i++) {	MockContainerEntity container = Iterables.get(containers.values(), i%containers.size());	MockItemEntity item = newItem(app, container, "item-movable"+i);	movableItems.add(item);	}	for (int i = 1; i <= numCycles; i++) {	
cycle 

for (int i = 1; i <= numMovableItems; i++) {	MockContainerEntity container = Iterables.get(containers.values(), i%containers.size());	MockItemEntity item = newItem(app, container, "item-movable"+i);	movableItems.add(item);	}	for (int i = 1; i <= numCycles; i++) {	for (int j = 1; j <= numItemStopsPerCycle; j++) {	int itemIndex = random.nextInt(numMovableItems);	MockItemEntity itemToStop = movableItems.get(itemIndex);	itemToStop.stop();	
unmanaging item 

workrates.put(source, jitteredWorkrate);	}	item.sensors().set(MockItemEntity.ITEM_USAGE_METRIC, workrates);	}	for (int j = 1; j <= numContainerStopsPerCycle; j++) {	int containerIndex = random.nextInt(containers.size());	MockContainerEntity containerToStop = Iterables.get(containers.values(), containerIndex);	Location location = Iterables.get(containerToStop.getLocations(), 0);	MockContainerEntity otherContainerInLocation = Iterables.find(containers.get(location), Predicates.not(Predicates.equalTo(containerToStop)), null);	containerToStop.offloadAndStop(otherContainerInLocation);	
unmanaging container 

========================= brooklyn sample_3010 =========================

ownNodeId = mgmt.getManagementNodeId();	objectStore = new ListeningObjectStore(newPersistenceObjectStore());	objectStore.injectManagementContext(mgmt);	objectStore.prepareForSharedUse(PersistMode.CLEAN, HighAvailabilityMode.DISABLED);	persister = new ManagementPlaneSyncRecordPersisterToObjectStore(mgmt, objectStore, classLoader);	((ManagementPlaneSyncRecordPersisterToObjectStore)persister).preferRemoteTimestampInMemento();	BrooklynMementoPersisterToObjectStore persisterObj = new BrooklynMementoPersisterToObjectStore(objectStore, mgmt, classLoader);	((RebindManagerImpl)mgmt.getRebindManager()).setPeriodicPersistPeriod(persistOrRebindPeriod);	mgmt.getRebindManager().setPersister(persisterObj, PersistenceExceptionHandlerImpl.builder().build());	ha = ((HighAvailabilityManagerImpl)mgmt.getHighAvailabilityManager()) .setPollPeriod(Duration.PRACTICALLY_FOREVER) .setHeartbeatTimeout(Duration.THIRTY_SECONDS) .setPersister(persister);	
created 

private Application expectRebindSequenceNumber(HaMgmtNode master, HaMgmtNode hotStandby, Application app, int expectedSensorSequenceValue, boolean immediate) {	Application appRO = hotStandby.mgmt.lookup(app.getId(), Application.class);	if (immediate) {	forcePersistNow(master);	forceRebindNow(hotStandby);	EntityAsserts.assertAttributeEquals(appRO, TestEntity.SEQUENCE, expectedSensorSequenceValue);	} else {	EntityAsserts.assertAttributeEqualsEventually(appRO, TestEntity.SEQUENCE, expectedSensorSequenceValue);	}	
got sequence number from 

protected long noteUsedMemory(String message) {	Time.sleep(Duration.millis(200));	for (HaMgmtNode n: nodes) {	((AbstractManagementContext)n.mgmt).getGarbageCollector().gcIteration();	}	System.gc(); System.gc();	Time.sleep(Duration.millis(50));	System.gc(); System.gc();	long mem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	usedMemory.addLast(mem);	
memory used 

public void testHotStandbyDoesNotLeakLotsOfRebinds() throws Exception {	
starting test 

public void testHotStandbyDoesNotLeakBigObjects() throws Exception {	
starting test 

public void testHotStandbyDoesNotLeakLotsOfRebindsCreatingAndDestroyingAChildEntity() throws Exception {	
starting test 

========================= brooklyn sample_625 =========================

private SaltHighstate() {}	public static void applyHighstate(String contents, Entity entity) {	final String adaptedYaml = adaptForSaltYamlTypes(contents);	
parsing salt highstate yaml 

if (isSaltInternal(id)) {	return;	}	addStateSensor(id, entity);	try {	Map<String, List<Object>> stateInfo = (Map<String, List<Object>>)stateData;	for (String stateModule : stateInfo.keySet()) {	addStateModuleValue(id, entity, stateInfo, stateModule);	}	} catch (ClassCastException e) {	
unexpected structure for state skipping 

for (Object entry : stateEntries) {	if (entry instanceof Map) {	moduleSettings.putAll((Map<String, Object>)entry);	} else {	stateFunction = entry.toString();	}	}	final String name = sensorName(id, stateModule, stateFunction);	final AttributeSensor<Map<String, Object>> newSensor = Sensors.newSensor(STATE_FUNCTION_TYPE, HIGHSTATE_SENSOR_PREFIX + "." + name, name);	entity.sensors().set(newSensor, moduleSettings);	
sensor set for 

if (entry instanceof Map) {	moduleSettings.putAll((Map<String, Object>)entry);	} else {	stateFunction = entry.toString();	}	}	final String name = sensorName(id, stateModule, stateFunction);	final AttributeSensor<Map<String, Object>> newSensor = Sensors.newSensor(STATE_FUNCTION_TYPE, HIGHSTATE_SENSOR_PREFIX + "." + name, name);	entity.sensors().set(newSensor, moduleSettings);	} catch (ClassCastException e) {	
unexpected structure for state module skipping 

========================= brooklyn sample_275 =========================

public static EntitySpec<? extends Entity> spec() {	EntitySpec<? extends Entity> spec = specBase();	
created entity spec for mysql 

public static EntitySpec<? extends Entity> specSolo() {	EntitySpec<? extends Entity> spec = specBase();	spec.configure(ChefConfig.CHEF_MODE, ChefConfig.ChefModes.SOLO);	
created entity spec for mysql 

public static EntitySpec<? extends Entity> specKnife() {	EntitySpec<? extends Entity> spec = specBase();	spec.configure(ChefConfig.CHEF_MODE, ChefConfig.ChefModes.KNIFE);	
created entity spec for mysql 

========================= brooklyn sample_2181 =========================

public void reloaded() {	
reloading security provider 

private synchronized SecurityProvider loadDelegate() {	StringConfigMap brooklynProperties = mgmt.getConfig();	SecurityProvider presetDelegate = brooklynProperties.getConfig(BrooklynWebConfig.SECURITY_PROVIDER_INSTANCE);	if (presetDelegate!=null) {	
rest using pre set security provider 

private synchronized SecurityProvider loadDelegate() {	StringConfigMap brooklynProperties = mgmt.getConfig();	SecurityProvider presetDelegate = brooklynProperties.getConfig(BrooklynWebConfig.SECURITY_PROVIDER_INSTANCE);	if (presetDelegate!=null) {	return presetDelegate;	}	String className = brooklynProperties.getConfig(BrooklynWebConfig.SECURITY_PROVIDER_CLASSNAME);	if (delegate != null && BrooklynWebConfig.hasNoSecurityOptions(mgmt.getConfig())) {	
refusing to change from no security provider set in reloaded properties 

private synchronized SecurityProvider loadDelegate() {	StringConfigMap brooklynProperties = mgmt.getConfig();	SecurityProvider presetDelegate = brooklynProperties.getConfig(BrooklynWebConfig.SECURITY_PROVIDER_INSTANCE);	if (presetDelegate!=null) {	return presetDelegate;	}	String className = brooklynProperties.getConfig(BrooklynWebConfig.SECURITY_PROVIDER_CLASSNAME);	if (delegate != null && BrooklynWebConfig.hasNoSecurityOptions(mgmt.getConfig())) {	return delegate;	}	
rest using security provider 

ClassLoaderUtils clu = new ClassLoaderUtils(this, mgmt);	Class<? extends SecurityProvider> clazz;	try {	clazz = (Class<? extends SecurityProvider>) clu.loadClass(className);	} catch (Exception e) {	String oldPackage = "brooklyn.web.console.security.";	if (className.startsWith(oldPackage)) {	className = Strings.removeFromStart(className, oldPackage);	className = DelegatingSecurityProvider.class.getPackage().getName() + "." + className;	clazz = (Class<? extends SecurityProvider>) clu.loadClass(className);	
deprecated package detected please update security provider to point to 

} catch (Exception e) {	String oldPackage = "brooklyn.web.console.security.";	if (className.startsWith(oldPackage)) {	className = Strings.removeFromStart(className, oldPackage);	className = DelegatingSecurityProvider.class.getPackage().getName() + "." + className;	clazz = (Class<? extends SecurityProvider>) clu.loadClass(className);	} else throw e;	}	delegate = createSecurityProviderInstance(mgmt, clazz);	} catch (Exception e) {	
rest unable to instantiate security provider all logins are being disallowed 

public boolean authenticate(HttpSession session, String user, String password) {	boolean authenticated = getDelegate().authenticate(session, user, password);	if (authenticated) {	session.setAttribute(getModificationCountKey(), modCount.get());	}	if (log.isTraceEnabled() && authenticated) {	
user authenticated with provider 

public boolean authenticate(HttpSession session, String user, String password) {	boolean authenticated = getDelegate().authenticate(session, user, password);	if (authenticated) {	session.setAttribute(getModificationCountKey(), modCount.get());	}	if (log.isTraceEnabled() && authenticated) {	} else if (!authenticated && log.isDebugEnabled()) {	
failed authentication for user with provider 

========================= brooklyn sample_2882 =========================

public void customize() {	
customizing 

========================= brooklyn sample_449 =========================

protected void finalize() throws Throwable {	
task was modified but modification was never used 

========================= brooklyn sample_1484 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof EC2TemplateOptions) {	byte[] bytes = toByteArray(v);	((EC2TemplateOptions) t).userData(bytes);	} else if (t instanceof SoftLayerTemplateOptions) {	((SoftLayerTemplateOptions) t).userData(Strings.toString(v));	} else {	
ignoring userdata in vm creation because not supported for cloud type 

========================= brooklyn sample_2617 =========================

public void testTmp() {	
tmp dir is 

public void testHome() {	
home dir is 

public void testUser() {	
user name is 

public void testNewTempFile() {	int CREATE_CNT = 5000;	Collection<File> folders = new ArrayList<File>(CREATE_CNT);	try {	for (int i = 0; i < CREATE_CNT; i++) {	try {	folders.add(Os.newTempFile(OsTest.class, "test"));	} catch (IllegalStateException e) {	
testnewtempfile failed at iteration 

public void testNewTempDir() {	int CREATE_CNT = 5000;	Collection<File> folders = new ArrayList<File>(CREATE_CNT);	try {	for (int i = 0; i < CREATE_CNT; i++) {	try {	folders.add(Os.newTempDir(OsTest.class));	} catch (IllegalStateException e) {	
testnewtempdir failed at iteration 

========================= brooklyn sample_1938 =========================

public static Optional<Task<?>> findTaskOrSubTask(Iterable<? extends Task<?>> tasks, Predicate<? super Task<?>> matcher) {	List<String> taskNames = Lists.newArrayList();	Optional<Task<?>> result = findTaskOrSubTaskImpl(tasks, matcher, taskNames);	if (!result.isPresent() && log.isDebugEnabled()) {	
task not found matching contender names were 

========================= brooklyn sample_2247 =========================

if (!(provider.equals(SoftLayerConstants.SOFTLAYER_PROVIDER_NAME) && templateOptions instanceof SoftLayerTemplateOptions)) {	String message = String.format("Invalid location provider or template options: %s/%s", provider, templateOptions.getClass().getSimpleName());	LOG.warn(message);	throw new IllegalArgumentException(message);	}	String scopeUid = getScopeUid(location);	SoftLayerTemplateOptions softLayerOptions = (SoftLayerTemplateOptions) templateOptions;	Integer publicVlanId = softLayerOptions.getPrimaryNetworkComponentNetworkVlanId();	Integer privateVlanId = softLayerOptions.getPrimaryBackendNetworkComponentNetworkVlanId();	if (publicVlanId != null && privateVlanId != null) {	
softlayer vlans private and public already configured in template options for scope 

LOG.warn(message);	throw new IllegalArgumentException(message);	}	String scopeUid = getScopeUid(location);	SoftLayerTemplateOptions softLayerOptions = (SoftLayerTemplateOptions) templateOptions;	Integer publicVlanId = softLayerOptions.getPrimaryNetworkComponentNetworkVlanId();	Integer privateVlanId = softLayerOptions.getPrimaryBackendNetworkComponentNetworkVlanId();	if (publicVlanId != null && privateVlanId != null) {	return;	}	
looking up saved vlan details 

publicVlanId = lookupPublicVlanId(location, scopeUid);	privateVlanId = lookupPrivateVlanId(location, scopeUid);	if (publicVlanId != null && privateVlanId != null) {	saveVlanTemplateOptions(scopeUid, softLayerOptions, publicVlanId, privateVlanId);	return;	}	CountDownLatch latch = null;	synchronized (lock) {	latch = lookupCountDownLatch(location, scopeUid);	if (latch == null) {	
creating new latch for scope 

synchronized (lock) {	latch = lookupCountDownLatch(location, scopeUid);	if (latch == null) {	latch = createCountDownLatch(location, scopeUid);	return;	}	}	Duration timeout = getTimeout(location);	Tasks.setBlockingDetails("Waiting for VLAN details");	try {	
waiting for vlan details for scope 

Tasks.setBlockingDetails("Waiting for VLAN details");	try {	if (!Uninterruptibles.awaitUninterruptibly(latch, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)) {	latch.countDown();	removeCountDownLatch(location, scopeUid);	throw new IllegalStateException("Timeout waiting on VLAN info in " + location + " for scope: " + scopeUid);	}	} finally {	Tasks.resetBlockingDetails();	}	
looking up saved vlan details 

private void saveVlanTemplateOptions(String scopeUid, SoftLayerTemplateOptions softLayerOptions, Integer publicVlanId, Integer privateVlanId) {	
setting vlan template options private and public for scope 

}	String scopeUid = getScopeUid(location);	CountDownLatch latch = null;	synchronized (lock) {	latch = lookupCountDownLatch(location, scopeUid);	if (latch == null) {	throw new IllegalStateException("No latch available for scope: " + scopeUid);	}	}	try {	
looking up saved vlan details 

synchronized (lock) {	latch = lookupCountDownLatch(location, scopeUid);	if (latch == null) {	throw new IllegalStateException("No latch available for scope: " + scopeUid);	}	}	try {	Integer publicVlanId = lookupPublicVlanId(location, scopeUid);	Integer privateVlanId = lookupPrivateVlanId(location, scopeUid);	if (privateVlanId != null && publicVlanId != null) {	
softlayer vlans private and public already configured for location scope 

throw new IllegalStateException("No latch available for scope: " + scopeUid);	}	}	try {	Integer publicVlanId = lookupPublicVlanId(location, scopeUid);	Integer privateVlanId = lookupPrivateVlanId(location, scopeUid);	if (privateVlanId != null && publicVlanId != null) {	saveVlanDetails(machine, scopeUid, privateVlanId, publicVlanId);	return;	}	
requesting vlan details from api for scope 

Integer privateVlanId = lookupPrivateVlanId(location, scopeUid);	if (privateVlanId != null && publicVlanId != null) {	saveVlanDetails(machine, scopeUid, privateVlanId, publicVlanId);	return;	}	VirtualGuestApi api = computeService.getContext().unwrapApi(SoftLayerApi.class).getVirtualGuestApi();	Long serverId = Long.parseLong(machine.getJcloudsId());	VirtualGuest guest = api.getVirtualGuestFiltered(serverId, "primaryNetworkComponent;" + "primaryNetworkComponent.networkVlan;" + "primaryBackendNetworkComponent;" + "primaryBackendNetworkComponent.networkVlan");	publicVlanId = guest.getPrimaryNetworkComponent().getNetworkVlan().getId();	privateVlanId = guest.getPrimaryBackendNetworkComponent().getNetworkVlan().getId();	
saving vlan details private and public for location scope 

========================= brooklyn sample_2569 =========================

public static List<String> unwrapJsonishListIfPossible(String input) {	try {	return unwrapOptionallyQuotedJavaStringList(input);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (e instanceof IllegalArgumentException) {	
unable to parse json list treating as single element string list 

public static List<String> unwrapJsonishListIfPossible(String input) {	try {	return unwrapOptionallyQuotedJavaStringList(input);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (e instanceof IllegalArgumentException) {	} else {	
unable to parse json list treating as single element string list 

========================= brooklyn sample_2093 =========================

public void customize() {	
customizing 

========================= brooklyn sample_388 =========================

try {	BrooklynMementoRawData memento = managementContext.getRebindManager().retrieveMementoRawData();	if (transformer != null) memento = transformer.transform(memento);	ManagementPlaneSyncRecord planeState = managementContext.getHighAvailabilityManager().loadManagementPlaneSyncRecord(true);	LOG.info("Copying persisted state to "+destinationDir+(destinationLocationSpec!=null ? " @ "+destinationLocationSpec : ""));	PersistenceObjectStore destinationObjectStore = BrooklynPersistenceUtils.newPersistenceObjectStore( managementContext, destinationLocationSpec, destinationDir);	BrooklynPersistenceUtils.writeMemento(managementContext, memento, destinationObjectStore);	BrooklynPersistenceUtils.writeManagerMemento(managementContext, planeState, destinationObjectStore);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error copying persisted state rethrowing 

protected void handleSubsystemStartupError(boolean ignoreSuchErrors, String system, Exception e) {	Exceptions.propagateIfFatal(e);	if (ignoreSuchErrors) {	
subsystem for had startup error continuing with startup 

protected void initPersistence() {	final PersistenceObjectStore objectStore;	if (persistMode == PersistMode.DISABLED) {	
persistence disabled 

objectStore = BrooklynPersistenceUtils.newPersistenceObjectStore(managementContext, persistenceLocation, persistenceDir, persistMode, highAvailabilityMode);	RebindManager rebindManager = managementContext.getRebindManager();	BrooklynMementoPersisterToObjectStore persister = new BrooklynMementoPersisterToObjectStore( objectStore, managementContext);	PersistenceExceptionHandler persistenceExceptionHandler = PersistenceExceptionHandlerImpl.builder().build();	((RebindManagerImpl) rebindManager).setPeriodicPersistPeriod(persistPeriod);	rebindManager.setPersister(persister, persistenceExceptionHandler);	} catch (FatalConfigurationRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error initializing persistence subsystem rethrowing 

((RebindManagerImpl) rebindManager).setPeriodicPersistPeriod(persistPeriod);	rebindManager.setPersister(persister, persistenceExceptionHandler);	} catch (FatalConfigurationRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	throw new FatalRuntimeException("Error initializing persistence subsystem: "+ Exceptions.collapseText(e), e);	}	}	if (highAvailabilityMode == HighAvailabilityMode.DISABLED) {	
high availability disabled 

startPersistenceWithoutHA();	}	} else {	HighAvailabilityMode startMode=null;	switch (highAvailabilityMode) {	case AUTO: case MASTER: case STANDBY: case HOT_STANDBY: case HOT_BACKUP: startMode = highAvailabilityMode;	break;	case DISABLED: throw new IllegalStateException("Unexpected code-branch for high availability mode "+highAvailabilityMode);	}	if (startMode==null) throw new IllegalStateException("Unexpected high availability mode "+highAvailabilityMode);	
management node with ha starting 

private void startPersistenceWithoutHA() {	RebindManager rebindManager = managementContext.getRebindManager();	
management node no ha rebinding to entities at in 

private void startPersistenceWithoutHA() {	RebindManager rebindManager = managementContext.getRebindManager();	
management node no ha rebinding to entities on file system in 

private void startPersistenceWithoutHA() {	RebindManager rebindManager = managementContext.getRebindManager();	ClassLoader classLoader = managementContext.getCatalogClassLoader();	try {	rebindManager.rebind(classLoader, null, ManagementNodeState.MASTER);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error rebinding to persisted state rethrowing 

protected void startBrooklynNode() {	final String classpath = System.getenv("INITIAL_CLASSPATH");	if (Strings.isBlank(classpath)) {	
cannot find initial classpath environment variable skipping brooklynnode entity creation 

protected EntitySpec<LocalBrooklynNode> customizeBrooklynNodeSpec(EntitySpec<LocalBrooklynNode> brooklynNodeSpec) {	
skipping brooklynnode registration configure a loopback rest endpoint configured for the node 

((Startable)app).start(locations);	Entities.dumpInfo(app);	String sensors = "";	if (app.getAttribute(Attributes.MAIN_URI_MAPPED_PUBLIC)!=null) {	sensors = ": "+app.getAttribute(Attributes.MAIN_URI_MAPPED_PUBLIC);	} else if (app.getAttribute(Attributes.MAIN_URI)!=null) {	sensors += ": "+app.getAttribute(Attributes.MAIN_URI);	}	LOG.info("Started brooklyn application {} in location{} {}{}", new Object[] { app, locations.size()!=1?"s":"", locations, sensors });	} catch (Exception e) {	
error starting 

String sensors = "";	if (app.getAttribute(Attributes.MAIN_URI_MAPPED_PUBLIC)!=null) {	sensors = ": "+app.getAttribute(Attributes.MAIN_URI_MAPPED_PUBLIC);	} else if (app.getAttribute(Attributes.MAIN_URI)!=null) {	sensors += ": "+app.getAttribute(Attributes.MAIN_URI);	}	LOG.info("Started brooklyn application {} in location{} {}{}", new Object[] { app, locations.size()!=1?"s":"", locations, sensors });	} catch (Exception e) {	appExceptions.add(Exceptions.collapse(e));	if (Thread.currentThread().isInterrupted()) {	
interrupted while starting applications aborting 

========================= brooklyn sample_2990 =========================

protected Entity setupAndCheckTestEntityInBasicYamlWith(String... extras) throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", extras));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-basic-template");	
app started 

========================= brooklyn sample_1715 =========================

public Maybe<Object> getConfigRaw(ConfigKey<?> key, boolean includeInherited) {	if (ownConfig.containsKey(key)) {	return Maybe.of(ownConfig.get(key));	}	for (String deprecatedName : key.getDeprecatedNames()) {	ConfigKey<?> deprecatedKey = ConfigKeys.newConfigKeyRenamed(deprecatedName, key);	if (ownConfig.containsKey(deprecatedKey)) {	
retrieving value with deprecated config key name for key 

protected Maybe<Object> resolveRawValueFromContainer(TContainer container, ConfigKey<?> key, Maybe<Object> value) {	Maybe<Object> result = resolveRawValueFromContainerIgnoringDeprecatedNames(container, key, value);	if (result.isPresent()) return result;	for (String deprecatedName : key.getDeprecatedNames()) {	ConfigKey<?> deprecatedKey = ConfigKeys.newConfigKeyRenamed(deprecatedName, key);	result = resolveRawValueFromContainerIgnoringDeprecatedNames(container, deprecatedKey, value);	if (result.isPresent()) {	
retrieving value with deprecated config key name for key 

synchronized (oc) {	ownCopy = MutableMap.copyOf(oc);	}	Maybe<Object> result = Maybe.of((Object) ((ConfigKeySelfExtracting<?>) key).extractValue(ownCopy, getExecutionContext(container)) );	postLocalEvaluate(key, bo, value, result);	return result;	} else {	return Maybe.absent();	}	} else {	
unexpected key type in ignoring value 

========================= brooklyn sample_1200 =========================

ConfigBag provisioningProperties = ConfigBag.newInstance(entity.config().get(BrooklynConfigKeys.PROVISIONING_PROPERTIES));	Collection<JcloudsLocationCustomizer> existingCustomizers = provisioningProperties.get(JcloudsLocationConfig.JCLOUDS_LOCATION_CUSTOMIZERS);	List<? super JcloudsLocationCustomizer> merged;	if (existingCustomizers == null) {	merged = ImmutableList.<JcloudsLocationCustomizer>of(this);	} else {	merged = Lists.newArrayListWithCapacity(1 + existingCustomizers.size());	merged.addAll(existingCustomizers);	merged.add(this);	}	
set location customizers on 

========================= brooklyn sample_2640 =========================

public void onEvent(SensorEvent<Object> event) {	
received event 

private void scheduleLatencyReductionJig() {	if (isRunning() && executorQueued.compareAndSet(false, true)) {	long now = System.currentTimeMillis();	long delay = Math.max(0, (executorTime + minPeriodBetweenExecs) - now);	executor.schedule(new Runnable() {	public void run() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	
executing follow the sun migration strategy 

long now = System.currentTimeMillis();	long delay = Math.max(0, (executorTime + minPeriodBetweenExecs) - now);	executor.schedule(new Runnable() {	public void run() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	strategy.rebalance();	} catch (RuntimeException e) {	if (isRunning()) {	
error during latency reduction jig 

long delay = Math.max(0, (executorTime + minPeriodBetweenExecs) - now);	executor.schedule(new Runnable() {	public void run() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	strategy.rebalance();	} catch (RuntimeException e) {	if (isRunning()) {	} else {	
error during latency reduction jig but no longer running 

private void onContainerAdded(Entity container, boolean rebalanceNow) {	subscriptions().subscribe(container, Attributes.LOCATION_CHANGED, eventHandler);	Location location = locationFinder.apply(container);	
recording addition of container in location 

private void onContainerRemoved(Entity container, boolean rebalanceNow) {	
recording removal of container 

private void onItemAdded(Movable item, boolean rebalanceNow) {	Entity parentContainer = item.getAttribute(Movable.CONTAINER);	
recording addition of item in container 

private void onItemRemoved(Movable item, boolean rebalanceNow) {	
recording removal of item 

private void onItemMoved(Movable item, Entity parentContainer, boolean rebalanceNow) {	
recording moving of item to 

private void onContainerLocationUpdated(Entity container, boolean rebalanceNow) {	Location location = locationFinder.apply(container);	
recording location for container new value 

private void onItemMetricUpdated(Movable item, Map<? extends Movable, Double> newValues, boolean rebalanceNow) {	
recording usage update for item new value 

========================= brooklyn sample_3051 =========================

protected void finalize() {	
sshfeed builder created but build never called 

========================= brooklyn sample_1596 =========================

public void setUp() throws Exception {	super.setUp();	
resetting 

public void setUp() throws Exception {	super.setUp();	cluster = app.createAndManageChild(EntitySpec.create(TestSizeRecordingCluster.class) .configure(TestCluster.INITIAL_SIZE, CLUSTER_INIITIAL_SIZE) .configure(TestCluster.MEMBER_SPEC, EntitySpec.create(BasicStartable.class)) );	PolicySpec<AutoScalerPolicy> policySpec = PolicySpec.create(AutoScalerPolicy.class) .configure(AutoScalerPolicy.RESIZE_OPERATOR, new ResizeOperator() {	public Integer resize(Entity entity, Integer desiredSize) {	
resizing to 

========================= brooklyn sample_3026 =========================

public void testOpenHttpConsoleWebPort() throws Exception {	BrooklynNodeWithOpenedPorts brooklynNode = app.createAndManageChild( EntitySpec.create(BrooklynNodeWithOpenedPorts.class) .configure(BrooklynNode.ON_EXISTING_PROPERTIES_FILE, BrooklynNode.ExistingFileBehaviour.DO_NOT_USE) .configure(BrooklynNode.NO_WEB_CONSOLE_AUTHENTICATION, true) .configure(BrooklynNode.HTTP_PORT, PortRanges.fromString("8082+")));	app.start(ImmutableList.of(loc));	assertNotNull(app);	
started containing for 

========================= brooklyn sample_2267 =========================

public static long getProcessCpuTime() {	try {	MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();	ObjectName osMBeanName = ObjectName.getInstance(ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME);	return (Long) mbeanServer.getAttribute(osMBeanName, "ProcessCpuTime");	} catch (Exception e) {	if (!hasLoggedProcessCpuTimeUnavailable) {	hasLoggedProcessCpuTimeUnavailable = true;	
processcuutime not available in local jvm mxbean only available in sun jvm 

public static double getProcessCpuAverage() {	try {	MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();	ObjectName osMBeanName = ObjectName.getInstance(ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME);	return (Double) mbeanServer.getAttribute(osMBeanName, "ProcessCpuLoad");	} catch (Exception e) {	if (!hasLoggedProcessCpuLoadUnavailable) {	hasLoggedProcessCpuLoadUnavailable = true;	
processcpuload not available in local jvm mxbean only available in sun jvm 

========================= brooklyn sample_2772 =========================

tools.add(localtool);	try {	localtool.connect();	Map<String,Object> props = new LinkedHashMap<String, Object>();	ByteArrayOutputStream out = new ByteArrayOutputStream();	ByteArrayOutputStream err = new ByteArrayOutputStream();	props.put("out", out);	props.put("err", err);	int exitcode = localtool.execScript(props, Arrays.asList("echo hello err > /dev/stderr"), null);	Assert.assertEquals(0, exitcode, "exitCode="+exitcode+", but expected 0");	
out from ssh vvv command is 

tools.add(localtool);	try {	localtool.connect();	Map<String,Object> props = new LinkedHashMap<String, Object>();	ByteArrayOutputStream out = new ByteArrayOutputStream();	ByteArrayOutputStream err = new ByteArrayOutputStream();	props.put("out", out);	props.put("err", err);	int exitcode = localtool.execScript(props, Arrays.asList("echo hello err > /dev/stderr"), null);	Assert.assertEquals(0, exitcode, "exitCode="+exitcode+", but expected 0");	
err from ssh vvv command is 

========================= brooklyn sample_890 =========================

public void testMapModUsage() throws Exception {	entity.config().set(TestEntity.CONF_MAP_OBJ_THING, MapModifications.add(MutableMap.<String,Object>of("a", 1)));	
map mod 

public void testMapSubkeyUsage() throws Exception {	entity.config().set(TestEntity.CONF_MAP_OBJ_THING.subKey("a"), 1);	
map subkey 

public void testMapDirectUsage() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_MAP_OBJ_THING.getName()), ImmutableMap.<String,Object>of("a", 1));	
map direct 

public void testMapDotExtensionUsage() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_MAP_OBJ_THING.getName()+".a"), 1);	
map dotext 

public void testMapManyWays() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_MAP_OBJ_THING.getName()), ImmutableMap.<String,Object>of("map", 1, "subkey", 0, "dotext", 0));	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_MAP_OBJ_THING.getName()+".dotext"), 1);	entity.config().set(TestEntity.CONF_MAP_OBJ_THING.subKey("subkey"), 1);	
map manyways 

public void testMapEmpty() throws Exception {	
map empty 

public void testMapEmpty() throws Exception {	Assert.assertEquals(entity.getConfig(TestEntity.CONF_MAP_THING), null);	entity.config().set((MapConfigKey)TestEntity.CONF_MAP_THING, MutableMap.of());	
map empty 

public void testSetModUsage() throws Exception {	entity.config().set(TestEntity.CONF_SET_THING, SetModifications.addItem("x"));	
set mod 

public void testSetSubKeyUsage() throws Exception {	entity.config().set(TestEntity.CONF_SET_THING.subKey(), "x");	
set subkey 

public void testSetPutDirectUsage() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_SET_THING.getName()), ImmutableSet.of("x"));	
set direct 

public void testSetDotExtensionUsage() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_SET_THING.getName()+".a"), "x");	
set dotext 

public void testSetManyWays() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_SET_THING.getName()), ImmutableSet.of("directX"));	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_SET_THING.getName()+".dotext"), "dotextX");	entity.config().set(TestEntity.CONF_SET_THING.subKey(), "subkeyX");	
set manyways 

public void testSetCollectionUsage() throws Exception {	entity.config().set(TestEntity.CONF_SET_OBJ_THING, SetModifications.addItem("w"));	entity.config().set(TestEntity.CONF_SET_OBJ_THING, MutableSet.of("x"));	entity.config().set(TestEntity.CONF_SET_OBJ_THING, MutableSet.of("y"));	entity.config().set(TestEntity.CONF_SET_OBJ_THING, MutableSet.of("a", "b"));	entity.config().set(TestEntity.CONF_SET_OBJ_THING, SetModifications.addItem("z"));	entity.config().set(TestEntity.CONF_SET_OBJ_THING, SetModifications.addItem(MutableSet.of("c", "d")));	entity.config().set(TestEntity.CONF_SET_OBJ_THING, MutableSet.of(MutableSet.of("e", "f")));	
set coll 

public void testSetEmpty() throws Exception {	
set empty 

public void testSetEmpty() throws Exception {	Assert.assertEquals(entity.getConfig(TestEntity.CONF_SET_THING), null);	entity.config().set((SetConfigKey)TestEntity.CONF_SET_THING, MutableSet.of());	
set empty 

public void testListModUsage() throws Exception {	entity.config().set(TestEntity.CONF_LIST_THING, ListModifications.add("x", "x"));	
list mod 

public void testListSubKeyUsage() throws Exception {	entity.config().set(TestEntity.CONF_LIST_THING.subKey(), "x");	entity.config().set(TestEntity.CONF_LIST_THING.subKey(), "x");	
list subkey 

public void testListPutDirectUsage() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()), ImmutableList.of("x", "x"));	
list direct 

public void testListDotExtensionUsage() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()+".a"), "x");	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()+".b"), "x");	
list dotext 

public void testListModUsageMultiValues() throws Exception {	entity.config().set(TestEntity.CONF_LIST_THING, ListModifications.add("x", "w", "x"));	
list mod 

public void testListSubKeyUsageMultiValues() throws Exception {	entity.config().set(TestEntity.CONF_LIST_THING.subKey(), "x");	entity.config().set(TestEntity.CONF_LIST_THING.subKey(), "w");	entity.config().set(TestEntity.CONF_LIST_THING.subKey(), "x");	
list subkey 

public void testListPutDirectUsageMultiValues() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()), ImmutableList.of("x", "w", "x"));	
list direct 

public void testListDotExtensionUsageMultiValues() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()+".a"), "x");	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()+".c"), "w");	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()+".b"), "x");	
list dotext 

public void testListManyWaysMultiValues() throws Exception {	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()), ImmutableList.of("x1", "w1"));	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()+".dotext"), "x2");	entity.config().set(ConfigKeys.newConfigKey(Object.class, TestEntity.CONF_LIST_THING.getName()+".dotext"), "w2");	entity.config().set(TestEntity.CONF_LIST_THING.subKey(), "x3");	entity.config().set(TestEntity.CONF_LIST_THING.subKey(), "w3");	
list manyways 

public void testListCollectionUsage() throws Exception {	entity.config().set(TestEntity.CONF_LIST_OBJ_THING, ListModifications.addItem("w"));	entity.config().set(TestEntity.CONF_LIST_OBJ_THING, MutableList.of("x"));	entity.config().set(TestEntity.CONF_LIST_OBJ_THING, MutableList.of("y"));	entity.config().set(TestEntity.CONF_LIST_OBJ_THING, MutableList.of("a", "b"));	entity.config().set(TestEntity.CONF_LIST_OBJ_THING, ListModifications.addItem("z"));	entity.config().set(TestEntity.CONF_LIST_OBJ_THING, ListModifications.addItem(MutableList.of("c", "d")));	entity.config().set(TestEntity.CONF_LIST_OBJ_THING, MutableList.of(MutableList.of("e", "f")));	
list coll 

public void testListEmpty() throws Exception {	
list empty 

public void testListEmpty() throws Exception {	Assert.assertEquals(entity.getConfig(TestEntity.CONF_LIST_THING), null);	entity.config().set((ListConfigKey)TestEntity.CONF_LIST_THING, MutableList.of());	
list empty 

========================= brooklyn sample_740 =========================

public LocationSpec<? extends Location> newLocationSpecFromString(String spec, Map<?, ?> locationFlags, LocationRegistry registry) {	String name = spec;	ConfigBag lfBag = ConfigBag.newInstance(locationFlags).putIfAbsent(LocationInternal.ORIGINAL_SPEC, name);	name = Strings.removeFromStart(spec, getPrefix()+":");	if (name.toLowerCase().startsWith(NAMED+":")) {	
deprecated use of named prefix with wrong case support may be removed in future versions 

========================= brooklyn sample_1298 =========================

public void tearDownClass() throws Exception {	try {	if (location != null && machine != null) location.release(machine);	} catch (Throwable t) {	
caught exception in teardownclass method 

public void tearDown() throws Exception {	try {	if (app != null) Entities.destroy(app);	} catch (Throwable t) {	
caught exception in teardown method 

========================= brooklyn sample_2230 =========================

public void testFeedDeDupe() throws Exception {	testPollsFunctionRepeatedlyToSetAttribute();	entity.addFeed(feed);	
feed is 

public void testFeedDeDupe() throws Exception {	testPollsFunctionRepeatedlyToSetAttribute();	entity.addFeed(feed);	Feed feed0 = feed;	testPollsFunctionRepeatedlyToSetAttribute();	entity.addFeed(feed);	
feed is 

========================= brooklyn sample_982 =========================

public void customize(MachineLocation machine) {	if (config.get(MACHINE_FILTER).apply(machine)) {	
sethostnamecustomizer setting hostname on 

public void customize(MachineLocation machine) {	if (config.get(MACHINE_FILTER).apply(machine)) {	} else {	
sethostnamecustomizer ignoring non ssh machine 

if (config.get(MACHINE_FILTER).apply(machine)) {	} else {	return;	}	try {	String localHostname = setLocalHostname((SshMachineLocation) machine);	machine.config().set(LOCAL_HOSTNAME, localHostname);	String localIp = execHostnameMinusI((SshMachineLocation) machine);	machine.config().set(LOCAL_IP, localIp);	} catch (Exception e) {	
sethostnamecustomizer failed to set hostname on rethrowing 

public String setLocalHostname(SshMachineLocation machine, String hostName, String domainFixed) {	
setting local hostname of to 

protected String execHostname(SshMachineLocation machine) {	
retrieve hostname via ssh for 

protected String execHostname(SshMachineLocation machine) {	ProcessTaskWrapper<Integer> cmd = exec(machine, false, "echo hostname=`hostname`");	for (String line : cmd.getStdout().split("\n")) {	if (line.contains("hostname=") && !line.contains("`hostname`")) {	return line.substring(line.indexOf("hostname=") + "hostname=".length()).trim();	}	}	
no hostname found for got 

protected String execHostnameMinusI(SshMachineLocation machine) {	
retrieve hostname i via ssh for 

protected String execHostnameMinusI(SshMachineLocation machine) {	ProcessTaskWrapper<Integer> cmd = exec(machine, false, "echo localip=`hostname -I`");	for (String line : cmd.getStdout().split("\n")) {	if (line.contains("localip=") && !line.contains("`hostname -I`")) {	return line.substring(line.indexOf("localip=") + "localip=".length()).trim();	}	}	
no local ip found for got 

========================= brooklyn sample_2375 =========================

public void testGetOsgiSha1() {	String sha1 = BrooklynVersion.INSTANCE.getSha1FromOsgiManifest();	log.info("sha1: " + sha1);	if (Strings.isNonBlank(sha1) || BrooklynVersion.isDevelopmentEnvironment()) return;	
this build does not have git information 

public void testDevEnv() {	URL sp = getClass().getClassLoader().getResource("brooklyn/config/sample.properties");	if (sp == null) Assert.fail("Can't find test resources");	
test for dev env dev env path 

========================= brooklyn sample_594 =========================

public boolean getLocalDefaultResolvesWithAncestorValue() {	if (localDefaultResolvesWithAncestorValue==null) {	
encountered legacy with null localdefaultresolveswithancestorvalue transforming stack trace for legacy 

public boolean getAncestorDefaultInheritable() {	if (ancestorDefaultInheritable==null) {	
encountered legacy with null ancestordefaultinheritable transforming stack trace for legacy 

========================= brooklyn sample_1220 =========================

public void stop() {	int exitCode = newScript(MutableMap.of("usePidFile", false), STOPPING) .body.append("./bin/redis-cli -p " + getEntity().getAttribute(RedisStore.REDIS_PORT) + " shutdown") .execute();	if (exitCode != 0) {	
unexpected exit code when stopping 

========================= brooklyn sample_347 =========================

public void setEntity(final EntityLocal entity) {	super.setEntity(entity);	pfmListener = new PortForwardManager.AssociationListener() {	public void onAssociationCreated(PortForwardManager.AssociationMetadata metadata) {	Maybe<MachineLocation> machine = getMachine();	if (!(machine.isPresent() && machine.get().equals(metadata.getLocation()))) {	return;	}	
attempting transformations triggered by port association with machine of entity 

========================= brooklyn sample_1365 =========================

public void setEntity(final EntityLocal entity) {	Preconditions.checkArgument(entity instanceof Startable, "Restarter must take a Startable, not "+entity);	super.setEntity(entity);	subscriptions().subscribe(entity, getConfig(FAILURE_SENSOR_TO_MONITOR), new SensorEventListener<Object>() {	if (isRunning()) {	
servicerestarter notified dispatching job for 

public void setEntity(final EntityLocal entity) {	Preconditions.checkArgument(entity instanceof Startable, "Restarter must take a Startable, not "+entity);	super.setEntity(entity);	subscriptions().subscribe(entity, getConfig(FAILURE_SENSOR_TO_MONITOR), new SensorEventListener<Object>() {	if (isRunning()) {	((EntityInternal)entity).getExecutionContext().submit(MutableMap.of(), new Runnable() {	onDetectedFailure(event);	}});	} else {	
servicerestarter not running so not acting on failure detected at 

protected synchronized void onDetectedFailure(SensorEvent<Object> event) {	if (isSuspended()) {	highlightViolation("Failure detected but policy suspended");	
servicerestarter suspended so not acting on failure detected at 

protected synchronized void onDetectedFailure(SensorEvent<Object> event) {	if (isSuspended()) {	highlightViolation("Failure detected but policy suspended");	return;	}	
servicerestarter acting on failure detected at 

protected void onRestartFailed(String msg) {	
servicerestarter failed for 

========================= brooklyn sample_3067 =========================

Object result = null;	if (v!=null) {	if (v instanceof Map) {	if (config().get(JOIN_MAP_ENTRIES)) {	v = ((Map<?,?>) v).entrySet();	} else {	v = ((Map<?,?>) v).values();	}	}	if (!(v instanceof Iterable)) {	
enricher received a non iterable value refusing to join 

MutableList<Object> c2 = MutableList.of();	for (Object ci: c1) {	c2.add(StringEscapes.BashStringEscapes.wrapBash((String)ci));	}	c1 = c2;	}	result = Strings.join(c1, config().get(SEPARATOR));	}	}	}	
enricher computed from 

========================= brooklyn sample_994 =========================

private void selectMaster(ConfigBag parameters) {	String newMasterId = parameters.get(NEW_MASTER_ID);	Preconditions.checkNotNull(newMasterId, NEW_MASTER_ID.getName() + " parameter is required");	final Entity oldMaster = entity().getAttribute(BrooklynCluster.MASTER_NODE);	if (oldMaster != null && oldMaster.getId().equals(newMasterId)) {	
is already the current master no change needed 

private void waitMasterHandover(final Entity oldMaster, final Entity newMaster) {	boolean masterChanged = Repeater.create() .backoff(Repeater.DEFAULT_REAL_QUICK_PERIOD, 1.5, Duration.FIVE_SECONDS) .limitTimeTo(Duration.ONE_MINUTE) .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	Entity master = getMasterNode();	return !Objects.equal(master, oldMaster) && master != null;	}	}) .run();	if (!masterChanged) {	
timeout waiting for node to become master 

private void demoteOldMaster(Entity oldMaster, HighAvailabilityMode mode) {	ManagementNodeState oldState = DynamicTasks.queue( Effectors.invocation( oldMaster, BrooklynNode.SET_HIGH_AVAILABILITY_MODE, MutableMap.of(SetHighAvailabilityModeEffector.MODE, mode)) ).asTask().getUnchecked();	if (oldState != ManagementNodeState.MASTER) {	
the previous ha state on node was while the expected value is 

private void toggleNodePriority(Entity node, int newPriority) {	Integer oldPriority = DynamicTasks.queue( Effectors.invocation( node, BrooklynNode.SET_HIGH_AVAILABILITY_PRIORITY, MutableMap.of(SetHighAvailabilityPriorityEffector.PRIORITY, newPriority)) ).asTask().getUnchecked();	Integer expectedPriority = (newPriority == HA_MASTER_PRIORITY ? HA_STANDBY_PRIORITY : HA_MASTER_PRIORITY);	if (oldPriority != expectedPriority) {	
the previous ha priority on node was while the expected value is while setting priority 

========================= brooklyn sample_2363 =========================

public void install() {	DownloadResolver resolver = Entities.newDownloader(this);	List<String> urls = resolver.getTargets();	String saveAs = resolver.getFilename();	OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();	
installing couchbase sync gateway version 

========================= brooklyn sample_428 =========================

public void testMoreEntityV2AutoscanWithClasspath() throws Exception {	TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), "/brooklyn/osgi/brooklyn-test-osgi-more-entities_0.2.0.jar");	TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), "/brooklyn/osgi/brooklyn-test-osgi-entities.jar");	addCatalogItems(getLocalResource("more-entities-osgi-catalog-scan.yaml"));	
autoscan for osgi found catalog items 

public void testMorePolicyV2AutoscanWithClasspath() throws Exception {	TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), "/brooklyn/osgi/brooklyn-test-osgi-more-entities_0.2.0.jar");	TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), "/brooklyn/osgi/brooklyn-test-osgi-entities.jar");	addCatalogItems(getLocalResource("more-policies-osgi-catalog-scan.yaml"));	
autoscan for osgi found catalog items 

public void testAutoscanWithClasspathCanCreateSpecs() throws Exception {	TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), "/brooklyn/osgi/brooklyn-test-osgi-more-entities_0.2.0.jar");	TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), "/brooklyn/osgi/brooklyn-test-osgi-entities.jar");	addCatalogItems(getLocalResource("more-entities-osgi-catalog-scan.yaml"));	
autoscan for osgi found catalog items 

========================= brooklyn sample_1666 =========================

public void testFormatString() throws Exception {	final Path tempFile = Files.createTempFile("testFormatString", ".txt");	
temp file is 

========================= brooklyn sample_1689 =========================

private void createMemento() throws Exception {	setUp();	origApp = super.createApp();	origApp.config().set(TEST_KEY,  new VersionedName("foo", Version.parseVersion("1.0.0.foo")));	RebindTestUtils.stopPersistence(origApp);	String fn = mementoDir + File.separator + "entities" + File.separator + origApp.getApplicationId();	
persisted to 

private void createMemento() throws Exception {	setUp();	origApp = super.createApp();	origApp.config().set(TEST_KEY,  new VersionedName("foo", Version.parseVersion("1.0.0.foo")));	RebindTestUtils.stopPersistence(origApp);	String fn = mementoDir + File.separator + "entities" + File.separator + origApp.getApplicationId();	String yyyyMM = Time.makeDateString(new Date(), "yyyy-MM");	
set up your tests by copying from the persistence dir cp src test resources entity memento 

private void createMemento() throws Exception {	setUp();	origApp = super.createApp();	origApp.config().set(TEST_KEY,  new VersionedName("foo", Version.parseVersion("1.0.0.foo")));	RebindTestUtils.stopPersistence(origApp);	String fn = mementoDir + File.separator + "entities" + File.separator + origApp.getApplicationId();	String yyyyMM = Time.makeDateString(new Date(), "yyyy-MM");	String content = Streams.readFullyString(new FileInputStream(new File(fn)));	
or paste the following contents there 

private void createMemento() throws Exception {	setUp();	origApp = super.createApp();	origApp.config().set(TEST_KEY,  new VersionedName("foo", Version.parseVersion("1.0.0.foo")));	RebindTestUtils.stopPersistence(origApp);	String fn = mementoDir + File.separator + "entities" + File.separator + origApp.getApplicationId();	String yyyyMM = Time.makeDateString(new Date(), "yyyy-MM");	String content = Streams.readFullyString(new FileInputStream(new File(fn)));	
then add the apache comment header there and write your test doing loadentitymemento yyyymm origapp getapplicationid 

========================= brooklyn sample_644 =========================

DynamicTasks.queue(copyTaskMsg, new Runnable() {	public void run() {	int result = copyResource(url, tmpDest);	if (result != 0) {	throw new IllegalStateException("Invalid result " + result + " while " + copyTaskMsg);	}	}	});	DynamicTasks.queue(SshTasks.newSshExecTaskFactory(getMachine(), String.format("mv -f %s %s.bak", dest, dest)) .allowingNonZeroExitCode());	DynamicTasks.queue(SshTasks.newSshExecTaskFactory(getMachine(), String.format("mv -f %s %s", tmpDest, dest)) .requiringExitCodeZero());	
deployed to 

public void undeploy(String targetName) {	String dest = getDeployDir() + "/" + getFilenameContextMapper().convertDeploymentTargetNameToFilename(targetName);	
undeploying 

public void undeploy(String targetName) {	String dest = getDeployDir() + "/" + getFilenameContextMapper().convertDeploymentTargetNameToFilename(targetName);	int result = getMachine().execCommands("removing war on undeploy", ImmutableList.of(String.format("rm -f %s", dest)));	
undeployed result 

========================= brooklyn sample_214 =========================

public void setUp() throws Exception {	super.setUp();	
resetting 

public void setUp() throws Exception {	super.setUp();	cluster = app.createAndManageChild(EntitySpec.create(TestCluster.class).configure(TestCluster.INITIAL_SIZE, 1));	resizable = cluster.addChild(EntitySpec.create(LocallyResizableEntity.class) .configure(LocallyResizableEntity.TEST_CLUSTER, cluster));	PolicySpec<AutoScalerPolicy> policySpec = PolicySpec.create(AutoScalerPolicy.class).configure(AutoScalerPolicy.RESIZE_OPERATOR, new ResizeOperator() {	public Integer resize(Entity entity, Integer desiredSize) {	
resizing to 

========================= brooklyn sample_3030 =========================

String value = props.getProperty(key);	result.put(key, value);	}	return result;	} catch (IOException e) {	throw Exceptions.propagate(e);	} finally {	Streams.closeQuietly(resource);	}	} catch (Exception e) {	
failed to load properties file from continuing 

========================= brooklyn sample_1148 =========================

public void testChildAddedLate() {	app.start( ImmutableList.of(westChild, eastChildWithLocationAndWithPrivateHostname) );	publishSensors(2, true, false, false);	assertAttributeEventually(geoDns, AbstractGeoDnsService.TARGETS, CollectionFunctionals.<String>mapSizeEquals(2));	String id3 = fabric.addRegion("test:north");	publishSensors(3, true, false, false);	try {	assertAttributeEventually(geoDns, AbstractGeoDnsService.TARGETS, CollectionFunctionals.<String>mapSizeEquals(3));	} catch (Throwable e) {	
did not pick up third entity targets are rethrowing 

publishSensors(2, true, false, false);	assertAttributeEventually(geoDns, AbstractGeoDnsService.TARGETS, CollectionFunctionals.<String>mapSizeEquals(2));	String id3 = fabric.addRegion("test:north");	publishSensors(3, true, false, false);	try {	assertAttributeEventually(geoDns, AbstractGeoDnsService.TARGETS, CollectionFunctionals.<String>mapSizeEquals(3));	} catch (Throwable e) {	Exceptions.propagate(e);	}	assertIsTarget("North child");	
targets 

public Map<String, HostGeoInfo> getTargetHostsByName() {	synchronized (targetHostsByName) {	return ImmutableMap.copyOf(targetHostsByName);	}	}	protected boolean addTargetHost(Entity e) {	if (!getConfig(ADD_ANYTHING)) {	return super.addTargetHost(e);	} else {	if (e.getLocations().isEmpty()) {	
geodns testservice ignoring target host no location 

}	protected boolean addTargetHost(Entity e) {	if (!getConfig(ADD_ANYTHING)) {	return super.addTargetHost(e);	} else {	if (e.getLocations().isEmpty()) {	return false;	}	Location l = Iterables.getOnlyElement(e.getLocations());	HostGeoInfo geoInfo = new HostGeoInfo("<address-ignored>", l.getDisplayName(), l.getConfig(LocationConfigKeys.LATITUDE), l.getConfig(LocationConfigKeys.LONGITUDE));	
geodns testservice adding target host 

========================= brooklyn sample_185 =========================

gatherOutput();	resultCodeCheck = new Predicate<Integer>() {	public boolean apply(@Nullable Integer input) {	if (input==0) return true;	try {	String notes = "";	if (!getResultStderr().isEmpty()) notes += "STDERR\n" + getResultStderr()+"\n";	if (!getResultStdout().isEmpty()) notes += "\n" + "STDOUT\n" + getResultStdout()+"\n";	Tasks.setExtraStatusDetails(notes.trim());	} catch (Exception e) {	
unable to collect additional metadata on failure of 

}	});	try {	ByteArrayOutputStream stdin = new ByteArrayOutputStream();	for (String line: getLines()) {	stdin.write(line.getBytes());	stdin.write("\n".getBytes());	}	tb.tag(BrooklynTaskTags.tagForStreamSoft(BrooklynTaskTags.STREAM_STDIN, stdin));	} catch (IOException e) {	
error registering stream on 

public int executeInternal() {	if (!executionCheck.apply(this)) {	return 0;	}	List<String> lines = getLines();	
executing 

}	flags.put(ShellTool.PROP_NO_EXTRA_OUTPUT.getName(), noExtraOutput);	result = runner.execute(flags, lines, summary);	} catch (RuntimeInterruptedException e) {	throw logWithDetailsAndThrow(format("Execution failed, invocation error for %s: %s", summary, e.getMessage()), e);	} catch (Exception e) {	throw logWithDetailsAndThrow(format("Execution failed, invocation error for %s: %s", summary, e.getMessage()), e);	} finally {	mutexRelease.run();	}	
finished executing result code 

========================= brooklyn sample_2334 =========================

protected void testOperatingSystemProvider(String imageId, String provider, String region, String description) throws Exception {	
testing solr on using 

========================= brooklyn sample_306 =========================

checkNotNull(targetName, "targetName");	JavaWebAppDriver driver = getDriver();	String deployedName = driver.deploy(url, targetName);	Set<String> deployedWars = getAttribute(DEPLOYED_WARS);	if (deployedWars == null) {	deployedWars = Sets.newLinkedHashSet();	}	deployedWars.add(deployedName);	sensors().set(DEPLOYED_WARS, deployedWars);	} catch (RuntimeException e) {	
error deploying to on rethrowing 

public void undeploy( try {	JavaWebAppDriver driver = getDriver();	driver.undeploy(targetName);	Set<String> deployedWars = getAttribute(DEPLOYED_WARS);	if (deployedWars == null) {	deployedWars = Sets.newLinkedHashSet();	}	deployedWars.remove( driver.getFilenameContextMapper().convertDeploymentTargetNameToContext(targetName) );	sensors().set(DEPLOYED_WARS, deployedWars);	} catch (RuntimeException e) {	
error undeploying on rethrowing 

========================= brooklyn sample_243 =========================

public void test_localhost() throws Exception {	String dataDir = "/tmp/mariadb-data-" + Strings.makeRandomId(8);	MariaDbNode mariadb = app.createAndManageChild(EntitySpec.create(MariaDbNode.class) .configure(MariaDbNode.MARIADB_SERVER_CONF, MutableMap.<String, Object>of("skip-name-resolve","")) .configure(DatastoreCommon.CREATION_SCRIPT_CONTENTS, CREATION_SCRIPT) .configure(MariaDbNode.DATA_DIR, dataDir));	LocalhostMachineProvisioningLocation location = new LocalhostMachineProvisioningLocation();	app.start(ImmutableList.of(location));	
mariadb started 

public void test_localhost() throws Exception {	String dataDir = "/tmp/mariadb-data-" + Strings.makeRandomId(8);	MariaDbNode mariadb = app.createAndManageChild(EntitySpec.create(MariaDbNode.class) .configure(MariaDbNode.MARIADB_SERVER_CONF, MutableMap.<String, Object>of("skip-name-resolve","")) .configure(DatastoreCommon.CREATION_SCRIPT_CONTENTS, CREATION_SCRIPT) .configure(MariaDbNode.DATA_DIR, dataDir));	LocalhostMachineProvisioningLocation location = new LocalhostMachineProvisioningLocation();	app.start(ImmutableList.of(location));	new VogellaExampleAccess("com.mysql.jdbc.Driver", mariadb.getAttribute(DatastoreCommon.DATASTORE_URL)).readModifyAndRevertDataBase();	
ran vogella mysql example success 

========================= brooklyn sample_63 =========================

if (!isNewStyle(clazz)) {	throw new IllegalStateException("Class "+clazz+" must have a no-arg constructor");	}	try {	FactoryConstructionTracker.setConstructing();	try {	Constructor<T> constructor = clazz.getDeclaredConstructor(new Class[0]);	if (!(Modifier.isPublic(clazz.getModifiers()) && Modifier.isPublic(constructor.getModifiers())) && !constructor.isAccessible()) {	try {	constructor.setAccessible(true);	
set no arg constructor accessible for deprecated should have public no arg constructor 

throw new IllegalStateException("Class "+clazz+" must have a no-arg constructor");	}	try {	FactoryConstructionTracker.setConstructing();	try {	Constructor<T> constructor = clazz.getDeclaredConstructor(new Class[0]);	if (!(Modifier.isPublic(clazz.getModifiers()) && Modifier.isPublic(constructor.getModifiers())) && !constructor.isAccessible()) {	try {	constructor.setAccessible(true);	} catch (SecurityException e) {	
unable to set no arg constructor accessible for continuing but may subsequently fail 

========================= brooklyn sample_1324 =========================

public void testAppServerPct() {	CampPlatform p = MockWebPlatform.newPlatform();	DtoFactory f = new DtoFactory(p, "");	PlatformComponentTemplate t = MockWebPlatform.APPSERVER;	PlatformComponentTemplateDto dto = f.adapt(t);	
web pct serialized as 

========================= brooklyn sample_1774 =========================

String message = "Persisting "+contextName+" - encountered task "+value;	Object result = null;	if (task.isDone() && !task.isError()) {	result = task.getUnchecked();	message += "; persisting result "+result;	} else {	message += "; persisting as null";	result = null;	}	if (WARNED_ON_PERSISTING_TASK_CONFIG.add(contextName)) {	
subsequent values for this key will be at null 

========================= brooklyn sample_1099 =========================

public T getMemento() {	T memento = (T) MementosGenerators.newBasicMemento(instance);	
created memento 

public void reconstruct(RebindContext rebindContext, T memento) {	
reconstructing 

protected void addRelations(RebindContext rebindContext, T memento) {	for (Map.Entry<String,Set<String>> rEntry : memento.getRelations().entrySet()) {	RelationshipType<? extends BrooklynObject, ? extends BrooklynObject> r = EntityRelations.lookup(instance.getManagementContext(), rEntry.getKey());	if (r==null) throw new IllegalStateException("Unsupported relationship -- "+rEntry.getKey() + " -- in "+memento);	for (String itemId: rEntry.getValue()) {	BrooklynObject item = rebindContext.lookup().lookup(null, itemId);	if (item != null) {	instance.relations().add((RelationshipType)r, item);	} else {	
item not found discarding item relation of entity 

========================= brooklyn sample_1133 =========================

public HostAndPort findOpenSocketOnNode(final Iterable<? extends HostAndPort> sockets, Duration timeout) {	checkNotNull(sockets, "sockets");	checkState(!Iterables.isEmpty(sockets), "No hostAndPort sockets supplied");	checkNotNull(timeout, "timeout");	Iterable<HostAndPort> reachable = Optional.presentInstances(tryReachable(sockets, timeout, false));	Iterator<HostAndPort> iter = reachable.iterator();	if (iter.hasNext()) {	return iter.next();	} else {	
no sockets in reachable after 

private Iterable<Optional<HostAndPort>> tryReachable( Iterable<? extends HostAndPort> sockets, final Duration timeout, final boolean useGracePeriod) {	
blocking on reachable sockets in for 

private void reschedule() {	checker = executor.submit(new SocketChecker(socket, socketTester));	}	private boolean gracePeriodExpired() {	Stopwatch firstCompleted = sinceFirstCompleted.get();	return firstCompleted != null && (!useGracePeriod || gracePeriod.subtract(Duration.of(firstCompleted)).isNegative());	}	private boolean isComplete() throws ExecutionException, InterruptedException {	final boolean currentCheckComplete = checker.isDone();	if (currentCheckComplete && checker.get()) {	
determined that is reachable 

private boolean gracePeriodExpired() {	Stopwatch firstCompleted = sinceFirstCompleted.get();	return firstCompleted != null && (!useGracePeriod || gracePeriod.subtract(Duration.of(firstCompleted)).isNegative());	}	private boolean isComplete() throws ExecutionException, InterruptedException {	final boolean currentCheckComplete = checker.isDone();	if (currentCheckComplete && checker.get()) {	sinceFirstCompleted.compareAndSet(null, Stopwatch.createStarted());	return true;	} else if (currentCheckComplete) {	
unsure if is reachable scheduling another check 

final boolean currentCheckComplete = checker.isDone();	if (currentCheckComplete && checker.get()) {	sinceFirstCompleted.compareAndSet(null, Stopwatch.createStarted());	return true;	} else if (currentCheckComplete) {	reschedule();	}	return false;	}	public Optional<HostAndPort> call() throws Exception {	
checking reachability of 

return false;	}	public Optional<HostAndPort> call() throws Exception {	reschedule();	Repeater.create() .limitTimeTo(timeout) .backoffTo(Duration.FIVE_SECONDS) .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	return isComplete() || gracePeriodExpired();	}	}) .run();	if (checker.isDone() && checker.get()) {	
finished checking reachability of success 

public Optional<HostAndPort> call() throws Exception {	reschedule();	Repeater.create() .limitTimeTo(timeout) .backoffTo(Duration.FIVE_SECONDS) .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	return isComplete() || gracePeriodExpired();	}	}) .run();	if (checker.isDone() && checker.get()) {	return Optional.of(socket);	} else {	
finished checking reachability of failure 

}	}));	}	ImmutableList.Builder<Optional<HostAndPort>> results = ImmutableList.builder();	for (ListenableFuture<Optional<HostAndPort>> f : futures) {	try {	results.add(f.get());	} catch (InterruptedException e) {	throw new RuntimeInterruptedException(e);	} catch (ExecutionException e) {	
suppressed exception waiting for 

for (ListenableFuture<Optional<HostAndPort>> f : futures) {	try {	results.add(f.get());	} catch (InterruptedException e) {	throw new RuntimeInterruptedException(e);	} catch (ExecutionException e) {	}	}	executor.shutdownNow();	List<Optional<HostAndPort>> builtList = results.build();	
determined reachability of sockets 

========================= brooklyn sample_1975 =========================

private static Map<String, Object> getFieldsWithFlagsInternal(Object o, Collection<Field> fields) {	Map<String, Object> result = Maps.newLinkedHashMap();	for (Field f: fields) {	SetFromFlag cf = f.getAnnotation(SetFromFlag.class);	if (cf != null) {	String flagName = elvis(cf.value(), f.getName());	if (groovyTruth(flagName)) {	result.put(flagName, getField(o, f));	} else {	
ignoring field of object as no flag name available 

public static void setConfig(Object objectOfField, ConfigKey<?> key, Object value, SetFromFlag optionalAnnotation) {	if (objectOfField instanceof Configurable) {	((Configurable)objectOfField).config().set((ConfigKey)key, value);	return;	} else {	if (optionalAnnotation==null) {	
cannot set key on containing class is not configurable 

public static void setConfig(Object objectOfField, ConfigKey<?> key, Object value, SetFromFlag optionalAnnotation) {	if (objectOfField instanceof Configurable) {	((Configurable)objectOfField).config().set((ConfigKey)key, value);	return;	} else {	if (optionalAnnotation==null) {	} else if (!key.getName().equals(optionalAnnotation.value())) {	
cannot set key on from flag containing class is not configurable 

public static void setConfig(Object objectOfField, ConfigKey<?> key, Object value, SetFromFlag optionalAnnotation) {	if (objectOfField instanceof Configurable) {	((Configurable)objectOfField).config().set((ConfigKey)key, value);	return;	} else {	if (optionalAnnotation==null) {	} else if (!key.getName().equals(optionalAnnotation.value())) {	} else {	
cannot set key on from flag containing class is not configurable 

========================= brooklyn sample_1426 =========================

public Set<Entity> get() {	synchronized (seedMutex) {	boolean hasPublishedSeeds = Boolean.TRUE.equals(getAttribute(HAS_PUBLISHED_SEEDS));	int quorumSize = getSeedQuorumSize();	Set<Entity> potentialSeeds = gatherPotentialSeeds();	Set<Entity> potentialRunningSeeds = gatherPotentialRunningSeeds();	boolean stillWaitingForQuorum = (!hasPublishedSeeds) && (potentialSeeds.size() < quorumSize);	if (stillWaitingForQuorum) {	
not refreshed seeds of cluster because still waiting for quorum need have potentials 

if (stillWaitingForQuorum) {	return ImmutableSet.of();	} else if (hasPublishedSeeds) {	Set<Entity> currentSeeds = getAttribute(CURRENT_SEEDS);	if (getAttribute(SERVICE_STATE_ACTUAL) == Lifecycle.STARTING) {	if (Sets.intersection(currentSeeds, potentialSeeds).isEmpty()) {	log.warn("Cluster {} lost all its seeds while starting! Subsequent failure likely, but changing seeds during startup would risk split-brain: seeds={}", new Object[] {CassandraDatacenterImpl.this, currentSeeds});	}	return currentSeeds;	} else if (potentialRunningSeeds.isEmpty()) {	
cluster has no running seeds yet leaving seeds as is but risks split brain if these seeds come back up 

protected Entity createNode(@Nullable Location loc, Map<?,?> flags) {	Map<Object, Object> allflags = MutableMap.copyOf(flags);	if (flags.containsKey("token") || flags.containsKey("cassandra.token")) {	
cassandra token no longer supported use tokens in 

protected void onEntityChange(Entity member) {	
node updated in cluster 

protected void onEntityAdded(Entity member) {	
node added to cluster 

protected void onEntityRemoved(Entity member) {	
node removed from cluster 

public void onMemberRemoved(Entity member) {	Set<Entity> seeds = getSeeds();	boolean maybeRemove = seeds.contains(member);	memberUpness.remove(member);	if (maybeRemove) {	refreshSeeds();	} else {	
seeds considered stable for cluster node removed 

public void onHostnameChanged(Entity member, String hostname) {	Set<Entity> seeds = getSeeds();	int quorum = getSeedQuorumSize();	boolean isViable = isViableSeed(member);	boolean maybeAdd = isViable && seeds.size() < quorum;	boolean maybeRemove = seeds.contains(member) && !isViable;	if (maybeAdd || maybeRemove) {	refreshSeeds();	} else {	
seeds considered stable for cluster node changed hostname 

public void onServiceUpChanged(Entity member, Boolean serviceUp) {	Boolean oldVal = memberUpness.put(member, serviceUp);	if (Objects.equal(oldVal, serviceUp)) {	
ignoring duplicate service up in for 

public void onServiceUpChanged(Entity member, Boolean serviceUp) {	Boolean oldVal = memberUpness.put(member, serviceUp);	if (Objects.equal(oldVal, serviceUp)) {	}	Set<Entity> seeds = getSeeds();	int quorum = getSeedQuorumSize();	boolean isViable = isViableSeed(member);	boolean maybeAdd = isViable && seeds.size() < quorum;	boolean maybeRemove = seeds.contains(member) && !isViable;	
considering refresh of seeds for because is now 

if (Objects.equal(oldVal, serviceUp)) {	}	Set<Entity> seeds = getSeeds();	int quorum = getSeedQuorumSize();	boolean isViable = isViableSeed(member);	boolean maybeAdd = isViable && seeds.size() < quorum;	boolean maybeRemove = seeds.contains(member) && !isViable;	if (maybeAdd || maybeRemove) {	refreshSeeds();	} else {	
seeds considered stable for cluster node changed serviceup 

public Set<Entity> gatherPotentialSeeds() {	Set<Entity> result = Sets.newLinkedHashSet();	for (Entity member : getMembers()) {	if (isViableSeed(member)) {	result.add(member);	}	}	
viable seeds in cluster 

public Set<Entity> gatherPotentialRunningSeeds() {	Set<Entity> result = Sets.newLinkedHashSet();	for (Entity member : getMembers()) {	if (isRunningSeed(member)) {	result.add(member);	}	}	
viable running seeds in cluster 

========================= brooklyn sample_392 =========================

public void testCount() {	SoftwareProcess r1 = app.createAndManageChild(EntitySpec.create(SoftwareProcess.class, RestMockSimpleEntity.class));	SoftwareProcess r2 = app.createAndManageChild(EntitySpec.create(SoftwareProcess.class, RestMockSimpleEntity.class));	Entities.start(app, Arrays.<Location>asList(loc));	Entities.dumpInfo(app);	log.info("r2loc: "+r2.getLocations());	
props 

public void testCount() {	SoftwareProcess r1 = app.createAndManageChild(EntitySpec.create(SoftwareProcess.class, RestMockSimpleEntity.class));	SoftwareProcess r2 = app.createAndManageChild(EntitySpec.create(SoftwareProcess.class, RestMockSimpleEntity.class));	Entities.start(app, Arrays.<Location>asList(loc));	Entities.dumpInfo(app);	log.info("r2loc: "+r2.getLocations());	Map<Location, Integer> counts = new EntityLocationUtils(mgmt).countLeafEntitiesByLocatedLocations();	
count 

========================= brooklyn sample_2820 =========================

public void init() {	
deserializingjcloudsrenamesprovider osgiconfigloader init registering loader 

public void destroy() {	
deserializingjcloudsrenamesprovider osgiconfigloader destroy unregistering loader 

public void updateProperties(Map properties) {	
deserializingjcloudsrenamesprovider osgiconfigloader updateproperties clearing cache so jclouds renames will be reloaded 

========================= brooklyn sample_516 =========================

public LdapSecurityProvider(ManagementContext mgmt) {	StringConfigMap properties = mgmt.getConfig();	ldapUrl = properties.getConfig(BrooklynWebConfig.LDAP_URL);	Strings.checkNonEmpty(ldapUrl, "LDAP security provider configuration missing required property "+BrooklynWebConfig.LDAP_URL);	ldapRealm = CharMatcher.isNot('"').retainFrom(properties.getConfig(BrooklynWebConfig.LDAP_REALM));	Strings.checkNonEmpty(ldapRealm, "LDAP security provider configuration missing required property "+BrooklynWebConfig.LDAP_REALM);	if(Strings.isBlank(properties.getConfig(BrooklynWebConfig.LDAP_OU))) {	
setting ldap ou attribute to users 

========================= brooklyn sample_2877 =========================

public void testWhichKnife() throws IOException, InterruptedException {	Process p = Runtime.getRuntime().exec(new String[] { "bash", "-l", "-c", "which knife" });	ByteArrayOutputStream out = new ByteArrayOutputStream();	new StreamGobbler(p.getInputStream(), out, log).start();	new StreamGobbler(p.getErrorStream(), out, log).start();	
bash l c which knife gives exit code 

public void testWhichKnife() throws IOException, InterruptedException {	Process p = Runtime.getRuntime().exec(new String[] { "bash", "-l", "-c", "which knife" });	ByteArrayOutputStream out = new ByteArrayOutputStream();	new StreamGobbler(p.getInputStream(), out, log).start();	new StreamGobbler(p.getErrorStream(), out, log).start();	Time.sleep(Duration.millis(1000));	
output 

public void testKnifeWithoutConfig() {	ProcessTaskWrapper<Boolean> t = Entities.submit(app, ChefServerTasks.isKnifeInstalled());	
isknifeinstalled without config returned err 

public void testKnifeWithConfig() {	ChefLiveTestSupport.installBrooklynChefHostedConfig(app);	ProcessTaskWrapper<Boolean> t = Entities.submit(app, ChefServerTasks.isKnifeInstalled());	
isknifeinstalled with config returned err 

========================= brooklyn sample_2174 =========================

public void tearDown() {	List<Exception> exceptions = Lists.newArrayList();	for (SshMachineLocation machine : machines) {	try {	loc.release(machine);	} catch (Exception e) {	
error releasing continuing 

public void tearDown() {	List<Exception> exceptions = Lists.newArrayList();	for (SshMachineLocation machine : machines) {	try {	loc.release(machine);	} catch (Exception e) {	exceptions.add(e);	}	}	if (!exceptions.isEmpty()) {	
exception during teardown 

public void testProvisionVmUsingImageId(String regionName, String imageId, String imageOwner) {	loc = (JcloudsLocation) mgmt().getLocationRegistry().getLocationManaged(provider + (regionName == null ? "" : ":" + regionName));	SshMachineLocation machine = obtainMachine(MutableMap.of("imageId", imageId, "imageOwner", imageOwner, JcloudsLocation.MACHINE_CREATE_ATTEMPTS, 2));	
provisioned vm checking if ssh able 

public void testProvisionVmUsingImageNamePattern(String regionName, String imageNamePattern, String imageOwner) {	loc = (JcloudsLocation) mgmt().getLocationRegistry().getLocationManaged(provider + (regionName == null ? "" : ":" + regionName));	SshMachineLocation machine = obtainMachine(MutableMap.of("imageNameRegex", imageNamePattern, "imageOwner", imageOwner, JcloudsLocation.MACHINE_CREATE_ATTEMPTS, 2));	
provisioned vm checking if ssh able 

public void testProvisionVmUsingImageDescriptionPattern(String regionName, String imageDescriptionPattern, String imageOwner) {	loc = (JcloudsLocation) mgmt().getLocationRegistry().getLocationManaged(provider + (regionName == null ? "" : ":" + regionName));	SshMachineLocation machine = obtainMachine(MutableMap.of("imageDescriptionRegex", imageDescriptionPattern, "imageOwner", imageOwner, JcloudsLocation.MACHINE_CREATE_ATTEMPTS, 2));	
provisioned vm checking if ssh able 

protected SshMachineLocation obtainMachine(Map<?,?> flags) {	try {	SshMachineLocation result = (SshMachineLocation)loc.obtain(flags);	machines.add(result);	return result;	} catch (NoMachinesAvailableException nmae) {	
no machines available 

========================= brooklyn sample_2524 =========================

public String apply(SshPollValue input) {	String process = Strings.getFirstWordAfter(input.getStdout(), "Process");	return process;	}	}) .setOnFailureOrException(null)) .poll(new SshPollConfig<String>(MONIT_TARGET_PROCESS_STATUS) .command(cmd) .onSuccess(new Function<SshPollValue, String>() {	public String apply(SshPollValue input) {	return Strings.trim(Strings.getRemainderOfLineAfter(input.getStdout(), "status"));	}	}) .setOnFailureOrException(null)) .build();	} else {	
location s not an ssh machine location so not polling for status setting serviceup immediately 

========================= brooklyn sample_279 =========================

private void warnIfWrapping(Throwable cause) {	if (LOG.isTraceEnabled() && cause instanceof PropagatedRuntimeException) {	
wrapping a propagatedruntimeexception in another propagatedruntimeexception call chain 

========================= brooklyn sample_2027 =========================

public static String insert(AbstractMongoDBServer entity, String key, Object value) {	
inserting at 

public static DBObject getById(AbstractMongoDBServer entity, String id) {	
getting from 

public static List<String> getDatabaseNames(AbstractMongoDBServer entity) {	
getting database names from 

public static boolean isConfigServer(AbstractMongoDBServer entity) {	
checking if is a config server 

========================= brooklyn sample_296 =========================

public void start(Collection<? extends Location> locations) {	try {	ServiceStateLogic.setExpectedState(this, Lifecycle.STARTING);	Object val = config().get(START_LATCH);	if (val != null) log.debug("{} finished waiting for start-latch; continuing...", this);	addLocations(locations);	locations = Locations.getLocationsCheckingAncestors(locations, this);	
starting entity at 

addLocations(locations);	locations = Locations.getLocationsCheckingAncestors(locations, this);	Locations.LocationsFilter filter = getConfig(LOCATIONS_FILTER);	Iterable<Entity> startables = filterStartableManagedEntities(getChildren());	if (!Iterables.isEmpty(startables)) {	List<Task<?>> tasks = Lists.newArrayListWithCapacity(Iterables.size(startables));	for (final Entity entity : startables) {	Collection<? extends Location> l2 = locations;	if (filter != null) {	l2 = filter.filterForContext(new ArrayList<Location>(locations), entity);	
child of being started in filtered location list 

========================= brooklyn sample_1575 =========================

public void testSendMultipleInOrderThenUnsubscribe() throws Exception {	HelloEntity h = app.createAndManageChild(EntitySpec.create(HelloEntity.class));	app.start(ImmutableList.of(loc));	final List<Integer> data = Lists.newArrayList();	final CountDownLatch latch = new CountDownLatch(5);	app.subscriptions().subscribe(h, HelloEntity.AGE, new SensorEventListener<Integer>() {	data.add(event.getValue());	Time.sleep((int)(20*Math.random()));	
thread notify on subscription received for data is 

public void testConfigSetFromAttributeWhenReady() throws Exception {	app.config().set(HelloEntity.MY_NAME, "Bob");	final HelloEntity dad = app.createAndManageChild(EntitySpec.create(HelloEntity.class));	final HelloEntity son = dad.addChild(EntitySpec.create(HelloEntity.class) .configure(HelloEntity.MY_NAME, attributeWhenReady(dad, HelloEntity.FAVOURITE_NAME , { it!=null && it.length()>0 && it!="Jebediah" }	app.start(ImmutableList.of(loc));	final Semaphore s1 = new Semaphore(0);	final Object[] sonsConfig = new Object[1];	Thread t = new Thread(new Runnable() {	public void run() {	
started 

public void testConfigSetFromAttributeWhenReady() throws Exception {	app.config().set(HelloEntity.MY_NAME, "Bob");	final HelloEntity dad = app.createAndManageChild(EntitySpec.create(HelloEntity.class));	final HelloEntity son = dad.addChild(EntitySpec.create(HelloEntity.class) .configure(HelloEntity.MY_NAME, attributeWhenReady(dad, HelloEntity.FAVOURITE_NAME , { it!=null && it.length()>0 && it!="Jebediah" }	app.start(ImmutableList.of(loc));	final Semaphore s1 = new Semaphore(0);	final Object[] sonsConfig = new Object[1];	Thread t = new Thread(new Runnable() {	public void run() {	s1.release();	
getting config 

app.config().set(HelloEntity.MY_NAME, "Bob");	final HelloEntity dad = app.createAndManageChild(EntitySpec.create(HelloEntity.class));	final HelloEntity son = dad.addChild(EntitySpec.create(HelloEntity.class) .configure(HelloEntity.MY_NAME, attributeWhenReady(dad, HelloEntity.FAVOURITE_NAME , { it!=null && it.length()>0 && it!="Jebediah" }	app.start(ImmutableList.of(loc));	final Semaphore s1 = new Semaphore(0);	final Object[] sonsConfig = new Object[1];	Thread t = new Thread(new Runnable() {	public void run() {	s1.release();	sonsConfig[0] = son.getConfig(HelloEntity.MY_NAME);	
got config 

final HelloEntity son = dad.addChild(EntitySpec.create(HelloEntity.class) .configure(HelloEntity.MY_NAME, attributeWhenReady(dad, HelloEntity.FAVOURITE_NAME , { it!=null && it.length()>0 && it!="Jebediah" }	app.start(ImmutableList.of(loc));	final Semaphore s1 = new Semaphore(0);	final Object[] sonsConfig = new Object[1];	Thread t = new Thread(new Runnable() {	public void run() {	s1.release();	sonsConfig[0] = son.getConfig(HelloEntity.MY_NAME);	s1.release();	}});	
starting 

final Semaphore s1 = new Semaphore(0);	final Object[] sonsConfig = new Object[1];	Thread t = new Thread(new Runnable() {	public void run() {	s1.release();	sonsConfig[0] = son.getConfig(HelloEntity.MY_NAME);	s1.release();	}});	long startTime = System.currentTimeMillis();	t.start();	
waiting 

sonsConfig[0] = son.getConfig(HelloEntity.MY_NAME);	s1.release();	}});	long startTime = System.currentTimeMillis();	t.start();	if (!s1.tryAcquire(2, TimeUnit.SECONDS)) fail("race mismatch, missing permits");	assertTrue(t.isAlive());	assertTrue(System.currentTimeMillis() - startTime < 1500);	synchronized (sonsConfig) {	assertEquals(null, sonsConfig[0]);	
task at dad 

sonsConfig[0] = son.getConfig(HelloEntity.MY_NAME);	s1.release();	}});	long startTime = System.currentTimeMillis();	t.start();	if (!s1.tryAcquire(2, TimeUnit.SECONDS)) fail("race mismatch, missing permits");	assertTrue(t.isAlive());	assertTrue(System.currentTimeMillis() - startTime < 1500);	synchronized (sonsConfig) {	assertEquals(null, sonsConfig[0]);	
task at son 

long startTime = System.currentTimeMillis();	t.start();	if (!s1.tryAcquire(2, TimeUnit.SECONDS)) fail("race mismatch, missing permits");	assertTrue(t.isAlive());	assertTrue(System.currentTimeMillis() - startTime < 1500);	synchronized (sonsConfig) {	assertEquals(null, sonsConfig[0]);	dad.sensors().set(HelloEntity.FAVOURITE_NAME, "Dan");	if (!s1.tryAcquire(2, TimeUnit.SECONDS)) fail("race mismatch, missing permits");	}	
dad 

long startTime = System.currentTimeMillis();	t.start();	if (!s1.tryAcquire(2, TimeUnit.SECONDS)) fail("race mismatch, missing permits");	assertTrue(t.isAlive());	assertTrue(System.currentTimeMillis() - startTime < 1500);	synchronized (sonsConfig) {	assertEquals(null, sonsConfig[0]);	dad.sensors().set(HelloEntity.FAVOURITE_NAME, "Dan");	if (!s1.tryAcquire(2, TimeUnit.SECONDS)) fail("race mismatch, missing permits");	}	
son 

========================= brooklyn sample_804 =========================

public boolean isCreating() {	if (getModeBefore()!=BrooklynObjectManagementMode.NONEXISTENT) return false;	if (getModeAfter()==BrooklynObjectManagementMode.LOADED_READ_ONLY) {	
iscreating set on ro object highly irregular 

========================= brooklyn sample_1060 =========================

do {	attemptNum++;	try {	Tasks.setBlockingDetails("Installing "+urlToInstall+" at "+machine);	return machine.installTo(resolver, props, urlToInstall, target);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	lastError = e;	String stack = StackTraceSimplifier.toString(e);	if (stack.contains("net.schmizz.sshj.sftp.RemoteFile.write")) {	
failed to transfer to retryable error attempt 

try {	Tasks.setBlockingDetails("Installing "+urlToInstall+" at "+machine);	return machine.installTo(resolver, props, urlToInstall, target);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	lastError = e;	String stack = StackTraceSimplifier.toString(e);	if (stack.contains("net.schmizz.sshj.sftp.RemoteFile.write")) {	continue;	}	
failed to transfer to not a retryable error so failing 

========================= brooklyn sample_1430 =========================

protected Entity setupAndCheckTestEntityInBasicYamlWith(String ...extras) throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", extras));	waitForApplicationTasks(app);	Entities.dumpInfo(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-basic-template");	
app started 

public void testEmptyConfig() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  brooklyn.config:", "    test.confName: \"\"", "    test.confListPlain: !!seq []", "    test.confMapPlain: !!map {}", "    test.confSetPlain: !!set {}", "    test.confObject: \"\""));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-basic-template");	
app started 

public void testEmptyStructuredConfig() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  brooklyn.config:", "    test.confName: \"\"", "    test.confListThing: !!seq []", "    test.confSetThing: !!set {}", "    test.confMapThing: !!map {}"));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-basic-template");	
app started 

public void testSensor() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  brooklyn.config:", "    test.confObject: $brooklyn:sensor(\"org.apache.brooklyn.core.test.entity.TestEntity\", \"test.sequence\")"));	waitForApplicationTasks(app);	Assert.assertEquals(app.getDisplayName(), "test-entity-basic-template");	
app started 

public void testSensorOnArbitraryClass() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-entity-basic-template.yaml", "  brooklyn.config:", "    test.confObject: $brooklyn:sensor(\""+EntitiesYamlTest.class.getName()+"$ArbitraryClassWithSensor\", \"mysensor\")"));	waitForApplicationTasks(app);	
app started 

TestEntityWithInitConfig testWithConfigInit = null;	TestEntity testEntity = null;	Assert.assertEquals(app.getChildren().size(), 2);	for (Entity entity : app.getChildren()) {	if (entity instanceof TestEntity) testEntity = (TestEntity) entity;	if (entity instanceof TestEntityWithInitConfig) testWithConfigInit = (TestEntityWithInitConfig) entity;	}	Assert.assertNotNull(testEntity, "Expected app to contain TestEntity child");	Assert.assertNotNull(testWithConfigInit, "Expected app to contain TestEntityWithInitConfig child");	Assert.assertEquals(testWithConfigInit.getEntityCachedOnInit(), testEntity);	
app started 

========================= brooklyn sample_1719 =========================

MongoClient client = client();	try {	final DB db = client.getDB(database);	final CommandResult[] status = new CommandResult[1];	boolean commandResult = Repeater.create().backoff(Duration.ONE_SECOND, 1.5, null).limitIterationsTo(5) .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	try {	status[0] = db.command(command);	return true;	} catch (Exception e) {	
command on failed 

return true;	} catch (Exception e) {	return false;	}	}	}).run();	if (!commandResult) {	return Optional.absent();	}	if (!status[0].ok()) {	
unexpected result of on 

public boolean ping() {	MongoClient client = fastClient();	DBObject command = new BasicDBObject("ping", "1");	final DB db = client.getDB("admin");	try {	CommandResult status = db.command(command);	return status.ok();	} catch (MongoException e) {	
pinging server failed with 

public boolean initializeReplicaSet(String replicaSetName, Integer id) {	HostAndPort primary = getServerHostAndPort();	BasicBSONObject config = ReplicaSetConfig.builder(replicaSetName) .member(primary, id) .build();	BasicDBObject dbObject = new BasicDBObject("replSetInitiate", config);	
initiating replica set with 

public boolean initializeReplicaSet(String replicaSetName, Integer id) {	HostAndPort primary = getServerHostAndPort();	BasicBSONObject config = ReplicaSetConfig.builder(replicaSetName) .member(primary, id) .build();	BasicDBObject dbObject = new BasicDBObject("replSetInitiate", config);	Optional<CommandResult> result = runDBCommand("admin", dbObject);	if (result.isPresent() && result.get().ok() && LOG.isDebugEnabled()) {	
completed initiating mongodb replica set on entity 

private BSONObject getReplicaSetConfig() {	MongoClient client = client();	try {	return client.getDB("local").getCollection("system.replset").findOne();	} catch (MongoException e) {	
failed to get replica set config on 

public boolean addMemberToReplicaSet(MongoDBServer secondary, Integer id) {	BSONObject existingConfig = getReplicaSetConfig();	if (existingConfig == null) {	
couldn t load existing config for replica set from server not added 

public boolean removeMemberFromReplicaSet(MongoDBServer server) {	BSONObject existingConfig = getReplicaSetConfig();	if (existingConfig == null) {	
couldn t load existing config for replica set from server not removed 

private boolean reconfigureReplicaSet(BasicBSONObject newConfig) {	BasicDBObject command = new BasicDBObject("replSetReconfig", newConfig);	
reconfiguring replica set to 

public boolean addShardToRouter(String hostAndPort) {	
adding shard 

========================= brooklyn sample_384 =========================

Maybe<Effector<?>> effector = EffectorUtils.findEffectorDeclared(entity, "resetPassword");	final String sensitiveField1 = "newPassword";	final String sensitiveField2 = "secretPin";	Task<?> t = entity.invoke(effector.get(), ImmutableMap.of(sensitiveField1, "#$%'332985$23$#\"sd'", "secretPin", 1234));	TaskSummary summary = TaskTransformer.taskSummary(t, uriBuilder);	try {	t.get();	} catch (InterruptedException|ExecutionException e) {	throw Exceptions.propagate(e);	}	
result description 

========================= brooklyn sample_2837 =========================

public void prepareForSharedUse(@Nullable PersistMode persistMode, HighAvailabilityMode haMode) {	if (mgmt==null) throw new NullPointerException("Must inject ManagementContext before preparing "+this);	getBlobStoreContext();	if (persistMode==null || persistMode==PersistMode.DISABLED) {	
should not be using when persistmode is 

public void prepareForSharedUse(@Nullable PersistMode persistMode, HighAvailabilityMode haMode) {	if (mgmt==null) throw new NullPointerException("Must inject ManagementContext before preparing "+this);	getBlobStoreContext();	if (persistMode==null || persistMode==PersistMode.DISABLED) {	return;	}	Boolean backups = mgmt.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_BACKUPS_REQUIRED);	if (Boolean.TRUE.equals(backups)) {	
using legacy backup for functionality will be removed in future versions in favor of promotion demotion specific backups to a configurable backup location 

========================= brooklyn sample_2564 =========================

public void start(final Collection<? extends Location> locations) {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STARTING);	try {	final TaskAdaptable<?> taskAdaptable = StartableMethods.startingChildren(this, locations);	
taskadaptable 

public void start(final Collection<? extends Location> locations) {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STARTING);	try {	final TaskAdaptable<?> taskAdaptable = StartableMethods.startingChildren(this, locations);	submitTaskAndWait(taskAdaptable);	
tasks successfully run update state of to running 

public void start(final Collection<? extends Location> locations) {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STARTING);	try {	final TaskAdaptable<?> taskAdaptable = StartableMethods.startingChildren(this, locations);	submitTaskAndWait(taskAdaptable);	setServiceState(true, Lifecycle.RUNNING);	} catch (Throwable t) {	
tasks not successfully run update state of to on fire 

public void stop() {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STOPPING);	final TaskAdaptable<?> taskAdaptable = StartableMethods.stoppingChildren(this);	
taskadaptable 

public void stop() {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STOPPING);	final TaskAdaptable<?> taskAdaptable = StartableMethods.stoppingChildren(this);	try {	submitTaskAndWait(taskAdaptable);	
tasks successfully run update state of to stopped 

public void stop() {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STOPPING);	final TaskAdaptable<?> taskAdaptable = StartableMethods.stoppingChildren(this);	try {	submitTaskAndWait(taskAdaptable);	setServiceState(false, Lifecycle.STOPPED);	} catch (Throwable t) {	
tasks not successfully run update state of to on fire 

public void restart() {	setServiceState(false, Lifecycle.STARTING);	final TaskAdaptable<?> taskAdaptable = StartableMethods.restartingChildren(this);	
taskadaptable 

public void restart() {	setServiceState(false, Lifecycle.STARTING);	final TaskAdaptable<?> taskAdaptable = StartableMethods.restartingChildren(this);	try {	submitTaskAndWait(taskAdaptable);	
tasks successfully run update state of to running 

public void restart() {	setServiceState(false, Lifecycle.STARTING);	final TaskAdaptable<?> taskAdaptable = StartableMethods.restartingChildren(this);	try {	submitTaskAndWait(taskAdaptable);	setServiceState(true, Lifecycle.RUNNING);	} catch (Throwable t) {	
tasks not successfully run update state of to on fire 

========================= brooklyn sample_2421 =========================

public void testWaitForServiceUpDefaultsToNotChecking() throws Exception {	DynamicCluster cluster = app.addChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(TestEntity.class)) .configure("initialSize", 1));	ServiceStateLogic.updateMapSensorEntry(cluster, ServiceStateLogic.SERVICE_NOT_UP_INDICATORS, "simulateNotUpKey", "myVal");	Stopwatch stopwatch = Stopwatch.createStarted();	app.start(ImmutableList.of());	Duration startTime = Duration.of(stopwatch);	
start time 

DynamicCluster cluster = app.addChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.START_TIMEOUT, Duration.ONE_MILLISECOND) .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(TestEntity.class)) .configure("initialSize", 1));	ServiceStateLogic.updateMapSensorEntry(cluster, ServiceStateLogic.SERVICE_NOT_UP_INDICATORS, "simulateNotUpKey", "myVal");	Stopwatch stopwatch = Stopwatch.createStarted();	try {	app.start(ImmutableList.of());	Asserts.shouldHaveFailedPreviously();	} catch (Exception e) {	Asserts.expectedFailureContains(e, "Timeout waiting for SERVICE_UP");	}	Duration startTime = Duration.of(stopwatch);	
start time 

========================= brooklyn sample_940 =========================

try {	listener.apply(ProcessTaskWrapper.this);	} catch (Exception e) {	logWithDetailsAndThrow("Error in "+taskTypeShortName()+" task "+getSummary()+": "+e, e);	}	}	if (exitCode!=0 && !Boolean.FALSE.equals(requireExitCodeZero)) {	if (Boolean.TRUE.equals(requireExitCodeZero)) {	logWithDetailsAndThrow(taskTypeShortName()+" task ended with exit code "+exitCode+" when 0 was required, in "+Tasks.current()+": "+getSummary(), null);	} else {	
task ended with exit code when non zero was not explicitly allowed error may be thrown in future in 

========================= brooklyn sample_1489 =========================

}	public List<String> call(ConfigBag params) {	params = getMergedParams(effector, params);	String blueprint = blueprintBase;	if (!params.isEmpty()) {	Map<?,?> m = ((Map<?,?>)Iterables.getOnlyElement( Yamls.parseAll(blueprint) ));	if ( m.containsKey("brooklyn.config") ) {	Map<?,?> cfg1 = (Map<?,?>) m.get("brooklyn.config");	Map<Object,Object> cfgMergeFlat = MutableMap.<Object,Object>copyOf(cfg1).add(params.getAllConfig());	if (cfgMergeFlat.size() < cfg1.size() + params.size()) {	
adding blueprint where same config key is supplied in blueprint and as parameters preferring parameter no merge but behaviour may change recommended to use distinct keys 

blueprint = toJson(m);	} else {	if (isJsonNotYaml(blueprint)) {	((Map<Object,Object>)m).put("brooklyn.config", params.getAllConfig());	blueprint = toJson(m);	} else {	blueprint = blueprint+"\n"+"brooklyn.config: "+ toJson(params.getAllConfig());	}	}	}	
adding children to 

} else {	if (isJsonNotYaml(blueprint)) {	((Map<Object,Object>)m).put("brooklyn.config", params.getAllConfig());	blueprint = toJson(m);	} else {	blueprint = blueprint+"\n"+"brooklyn.config: "+ toJson(params.getAllConfig());	}	}	}	CreationResult<List<Entity>, List<String>> result = EntityManagementUtils.addChildren(entity(), blueprint, autostart);	
added children to 

========================= brooklyn sample_1173 =========================

public void deployStorm() throws Exception {	try {	zooKeeperEnsemble = app.createAndManageChild(EntitySpec.create( ZooKeeperEnsemble.class).configure( ZooKeeperEnsemble.INITIAL_SIZE, 3));	nimbus = app.createAndManageChild(EntitySpec .create(Storm.class) .configure(Storm.ROLE, NIMBUS) .configure(NIMBUS_HOSTNAME, "localhost") .configure(ZOOKEEPER_ENSEMBLE, zooKeeperEnsemble) );	supervisor = app.createAndManageChild(EntitySpec .create(Storm.class) .configure(Storm.ROLE, SUPERVISOR) .configure(ZOOKEEPER_ENSEMBLE, zooKeeperEnsemble) .configure(NIMBUS_HOSTNAME, attributeWhenReady(nimbus, Attributes.HOSTNAME)));	ui = app.createAndManageChild(EntitySpec .create(Storm.class) .configure(Storm.ROLE, UI) .configure(ZOOKEEPER_ENSEMBLE, zooKeeperEnsemble) .configure(NIMBUS_HOSTNAME, attributeWhenReady(nimbus, Attributes.HOSTNAME)));	
started storm deployment on 

app.start(ImmutableList.of(location));	Entities.dumpInfo(app);	EntityAsserts.assertAttributeEqualsEventually(app, Startable.SERVICE_UP, true);	EntityAsserts.assertAttributeEqualsEventually(zooKeeperEnsemble, Startable.SERVICE_UP, true);	EntityAsserts.assertAttributeEqualsEventually(nimbus, Startable.SERVICE_UP, true);	EntityAsserts.assertAttributeEqualsEventually(supervisor, Startable.SERVICE_UP, true);	EntityAsserts.assertAttributeEqualsEventually(ui, Startable.SERVICE_UP, true);	StormTopology stormTopology = createTopology();	submitTopology(stormTopology, "myExclamation", 3, true, 60000);	} catch (Exception e) {	
failed to deploy storm 

========================= brooklyn sample_444 =========================

public void testReportsServiceDownWhenKilled() throws Exception {	LOG.info("test=testReportsServiceDownWithKilled; entity="+entity+"; app="+entity.getApplication());	Entities.start(entity.getApplication(), ImmutableList.of(loc));	EntityAsserts.assertAttributeEqualsEventually(MutableMap.of("timeout", Duration.minutes(2)), entity, Startable.SERVICE_UP, true);	killEntityBehindBack(entity);	
killed behind mgmt s back waiting for service up false in mgmt context 

public void testReportsServiceDownWhenKilled() throws Exception {	LOG.info("test=testReportsServiceDownWithKilled; entity="+entity+"; app="+entity.getApplication());	Entities.start(entity.getApplication(), ImmutableList.of(loc));	EntityAsserts.assertAttributeEqualsEventually(MutableMap.of("timeout", Duration.minutes(2)), entity, Startable.SERVICE_UP, true);	killEntityBehindBack(entity);	EntityAsserts.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, false);	
success getting service up false in primary mgmt universe 

========================= brooklyn sample_151 =========================

manage(loc);	} else {	Location parent = loc.getParent();	if (parent!=null) {	((AbstractLocation)parent).removeChild(loc);	}	preRegisteredLocationsById.remove(loc.getId());	}	return loc;	} catch (Throwable e) {	
failed to create location using spec rethrowing 

public Location manage(Location loc) {	if (isManaged(loc)) {	return loc;	}	Location parent = loc.getParent();	if (parent != null && !managementContext.getLocationManager().isManaged(parent)) {	
parent location of is not managed attempting to manage it in future this may be disallowed 

private void unmanage(final Location loc, final ManagementTransitionMode mode, boolean hasBeenReplaced) {	if (shouldSkipUnmanagement(loc)) return;	if (hasBeenReplaced) {	if (mode.wasReadOnly()) {	} else {	if (!mode.wasPrimary()) {	
unexpected mode for unmanage replace applying anyway 

if (mode.wasReadOnly()) {	} else {	if (!mode.wasPrimary()) {	}	managementContext.getRebindManager().getChangeListener().onUnmanaged(loc);	if (managementContext.gc != null) managementContext.gc.onUnmanaged(loc);	}	return;	} else if ((mode.wasPrimary() && mode.isReadOnly()) || (mode.wasReadOnly() && mode.isNoLongerLoaded())) {	if (mode.isReadOnly() && mode.wasPrimary()) {	
unmanaging on demotion 

managementContext.getRebindManager().getChangeListener().onUnmanaged(loc);	if (managementContext.gc != null) managementContext.gc.onUnmanaged(loc);	unmanageNonRecursiveClearItsFields(loc, mode);	} else if (mode.isNoLongerLoaded()) {	recursively(loc, new Predicate<AbstractLocation>() { @Override public boolean apply(AbstractLocation it) {	if (shouldSkipUnmanagement(it)) return false;	boolean result = unmanageNonRecursiveRemoveFromRecords(it, mode);	if (result) {	ManagementTransitionMode mode = getLastManagementTransitionMode(it.getId());	if (mode==null) {	
missing transition mode for when unmanaging assuming primary destroying 

}	if (mode.wasPrimary()) it.onManagementStopped();	managementContext.getRebindManager().getChangeListener().onUnmanaged(it);	if (mode.isDestroying()) recordLocationEvent(it, Lifecycle.DESTROYED);	if (managementContext.gc != null) managementContext.gc.onUnmanaged(it);	}	unmanageNonRecursiveClearItsFields(loc, mode);	return result;	} });	} else {	
invalid mode for unmanage on ignoring 

private void recordLocationEvent(LocationInternal loc, Lifecycle state) {	try {	managementContext.getUsageManager().recordLocationEvent(loc, state);	} catch (RuntimeInterruptedException e) {	throw e;	} catch (RuntimeException e) {	
failed to store location lifecycle event for ignoring 

private synchronized boolean manageNonRecursive(Location loc, ManagementTransitionMode mode) {	Location old = locationsById.put(loc.getId(), loc);	preRegisteredLocationsById.remove(loc.getId());	locationTypes.put(loc.getId(), loc.getClass().getName());	if (old!=null && mode.wasNotLoaded()) {	if (old.equals(loc)) {	
redundant call to start management of location 

private synchronized void unmanageNonRecursiveClearItsFields(Location loc, ManagementTransitionMode mode) {	if (mode.isDestroying()) {	((AbstractLocation)loc).setParent(null, true);	Location parent = ((AbstractLocation)loc).getParent();	if (parent instanceof ProvisioningLocation<?>) {	try {	((ProvisioningLocation)parent).release(loc);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error releasing in its parent 

private synchronized boolean unmanageNonRecursiveRemoveFromRecords(Location loc, ManagementTransitionMode mode) {	Object old = locationsById.remove(loc.getId());	locationTypes.remove(loc.getId());	locationModesById.remove(loc.getId());	if (old==null) {	
call to stop management of unknown location already unmanaged ignoring 

private synchronized boolean unmanageNonRecursiveRemoveFromRecords(Location loc, ManagementTransitionMode mode) {	Object old = locationsById.remove(loc.getId());	locationTypes.remove(loc.getId());	locationModesById.remove(loc.getId());	if (old==null) {	return false;	} else if (!old.equals(loc)) {	
call to stop management of location removed different location ignoring 

private synchronized boolean unmanageNonRecursiveRemoveFromRecords(Location loc, ManagementTransitionMode mode) {	Object old = locationsById.remove(loc.getId());	locationTypes.remove(loc.getId());	locationModesById.remove(loc.getId());	if (old==null) {	return false;	} else if (!old.equals(loc)) {	return true;	} else {	
stopped management of location 

private boolean shouldSkipUnmanagement(Location loc) {	if (loc==null) {	
call to unmanage null location skipping source of null unmanagement call to 

private boolean shouldSkipUnmanagement(Location loc) {	if (loc==null) {	return true;	}	if (!isManaged(loc)) {	
call to stop management of unknown location already unmanaged skipping and all descendants 

========================= brooklyn sample_1036 =========================

protected Entity createMysql() {	Entity mysql = app.createAndManageChild(DynamicToyMySqlEntityChef.spec());	
created 

========================= brooklyn sample_2175 =========================

public void tearDown() throws Exception {	List<Exception> exceptions = new ArrayList<>();	for (SshMachineLocation machine : machines) {	try {	loc.release(machine);	} catch (Exception e) {	
error releasing machine it continuing 

public void testProvisionWindowsVm() throws NoMachinesAvailableException {	JcloudsSshMachineLocation machine = (JcloudsSshMachineLocation) obtainMachine(MutableMap.of( "imageId", WINDOWS_IMAGE_ID));	
provisioned windows vm checking if has password 

public void testProvisionWindowsVm() throws NoMachinesAvailableException {	JcloudsSshMachineLocation machine = (JcloudsSshMachineLocation) obtainMachine(MutableMap.of( "imageId", WINDOWS_IMAGE_ID));	String password = machine.waitForPassword();	assertNotNull(password);	
checking can ssh to windows machine using password 

========================= brooklyn sample_2525 =========================

public SpecT configure(Map<?, ?> val) {	if (val == null) {	
null supplied when configuring 

public SpecT configure(Map<?, ?> val) {	if (val == null) {	
source for null supplied when configuring source for null supplied when configuring 

public SpecT configure(Map<?, ?> val) {	if (val == null) {	return self();	}	for (Map.Entry<?, ?> entry : val.entrySet()) {	if (entry.getKey() == null) throw new NullPointerException("Null key not permitted");	if (entry.getKey() instanceof CharSequence) flags.put(entry.getKey().toString(), entry.getValue());	else if (entry.getKey() instanceof ConfigKey<?>) config.put((ConfigKey<?>) entry.getKey(), entry.getValue());	else if (entry.getKey() instanceof HasConfigKey<?>) config.put(((HasConfigKey<?>) entry.getKey()).getConfigKey(), entry.getValue());	else {	
spec ignoring unknown config key 

========================= brooklyn sample_2749 =========================

private Integer sequence(Entity entity) {	String format = config().get(SEQUENCE_FORMAT);	Integer increment = config().get(SEQUENCE_INCREMENT);	AtomicInteger state = sensors().get(SEQUENCE_STATE);	Integer current = state.getAndAdd(increment);	String string = String.format(format, current);	AttributeSensor<Integer> valueSensor = config().get(SEQUENCE_VALUE_SENSOR);	AttributeSensor<String> stringSensor = config().get(SEQUENCE_STRING_SENSOR);	entity.sensors().set(valueSensor, current);	entity.sensors().set(stringSensor, string);	
sequence on set to to 

String format = config().get(SEQUENCE_FORMAT);	Integer increment = config().get(SEQUENCE_INCREMENT);	AtomicInteger state = sensors().get(SEQUENCE_STATE);	Integer current = state.getAndAdd(increment);	String string = String.format(format, current);	AttributeSensor<Integer> valueSensor = config().get(SEQUENCE_VALUE_SENSOR);	AttributeSensor<String> stringSensor = config().get(SEQUENCE_STRING_SENSOR);	entity.sensors().set(valueSensor, current);	entity.sensors().set(stringSensor, string);	sensors().set(SEQUENCE_CURRENT, entity);	
sequence for incremented to 

========================= brooklyn sample_1535 =========================

public BasicTask(Callable<T> job) { this(Collections.emptyMap(), job); }	public BasicTask(Map<?,?> flags, Callable<T> job) {	this.job = job;	if (flags.containsKey("tag")) tags.add(flags.remove("tag"));	Object ftags = flags.remove("tags");	if (ftags!=null) {	if (ftags instanceof Iterable) Iterables.addAll(tags, (Iterable<?>)ftags);	else {	
deprecated use of non collection argument for tags in trace of discouraged use of non colleciton tags argument 

public synchronized boolean cancel(TaskCancellationMode mode) {	if (isDone()) return false;	if (log.isTraceEnabled()) {	
bt cancelling mode from thread 

if (!started) return false;	if (timeout==null) {	internalFuture.get();	} else {	long remaining = endTime - System.currentTimeMillis();	if (remaining>0) internalFuture.get(remaining, TimeUnit.MILLISECONDS);	}	return isDone();	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	
call from blocking until finishes ended with error 

public void onTaskFinalization(Task<?> t);	}	public static final TaskFinalizer WARN_IF_NOT_RUN = new TaskFinalizer() {	public void onTaskFinalization(Task<?> t) {	if (!Tasks.isAncestorCancelled(t) && !t.isSubmitted()) {	
was never submitted did the code create it and forget to run it cancel the task to suppress this message 

public void onTaskFinalization(Task<?> t);	}	public static final TaskFinalizer WARN_IF_NOT_RUN = new TaskFinalizer() {	public void onTaskFinalization(Task<?> t) {	if (!Tasks.isAncestorCancelled(t) && !t.isSubmitted()) {	
detail of unsubmitted task 

public void onTaskFinalization(Task<?> t);	}	public static final TaskFinalizer WARN_IF_NOT_RUN = new TaskFinalizer() {	public void onTaskFinalization(Task<?> t) {	if (!Tasks.isAncestorCancelled(t) && !t.isSubmitted()) {	return;	}	if (!t.isDone()) {	
task is being finalized before completion 

public void execute(Runnable command) {	if (isShutdown()) {	
skipping execution of task callback hook because executor is shutdown 

public void execute(Runnable command) {	if (isShutdown()) {	return;	}	try {	target.execute(command);	} catch (Exception e) {	if (isShutdown()) {	
ignoring failed execution of task callback hook because executor is shutdown 

public void execute(Runnable command) {	if (isShutdown()) {	return;	}	try {	target.execute(command);	} catch (Exception e) {	if (isShutdown()) {	} else {	
execution of task callback hook failed 

========================= brooklyn sample_1470 =========================

public void testStartsWithGlobalSsl_withCertificateAndKeyCopy() {	cluster = app.createAndManageChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(JBoss7Server.class)) .configure("initialSize", 1) .configure(JavaWebAppService.ROOT_WAR, getTestWar()));	ProxySslConfig ssl = ProxySslConfig.builder() .certificateSourceUrl(CERTIFICATE_URL) .keySourceUrl(KEY_URL) .build();	nginx = app.createAndManageChild(EntitySpec.create(NginxController.class) .configure("sticky", false) .configure("serverPool", cluster) .configure("domain", "localhost") .configure("httpsPort", "8453+") .configure("ssl", ssl));	app.start(ImmutableList.of(localLoc));	urlContainsPort(nginx, LoadBalancer.PROXY_HTTPS_PORT, "8453+");	final String url = nginx.getAttribute(WebAppService.ROOT_URL);	
url for nginx is 

public void testStartsNonSslThenBecomesSsl() {	cluster = app.createAndManageChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(JBoss7Server.class)) .configure("initialSize", 1) .configure(JavaWebAppService.ROOT_WAR, getTestWar()));	nginx = app.createAndManageChild(EntitySpec.create(NginxController.class) .configure("serverPool", cluster) .configure("domain", "localhost"));	app.start(ImmutableList.of(localLoc));	urlContainsPort(nginx, LoadBalancer.PROXY_HTTP_PORT, "8000-8100");	ProxySslConfig ssl = ProxySslConfig.builder() .certificateDestination(getFile("ssl/certs/localhost/server.crt")) .keyDestination(getFile("ssl/certs/localhost/server.key")) .build();	((EntityInternal)nginx).config().set(LoadBalancer.PROXY_HTTPS_PORT, PortRanges.fromString("8443+"));	((EntityInternal)nginx).config().set(NginxController.SSL_CONFIG, ssl);	try {	
restarting nginx as ssl 

========================= brooklyn sample_147 =========================

public OsgiLauncherImpl startPartOne() {	brooklynVersion.getVersion();	Configuration brooklynConfig = getConfiguration(configAdmin, BROOKLYN_CONFIG_PID);	if (brooklynConfig == null && Strings.isEmpty(globalBrooklynProperties) && Strings.isEmpty(localBrooklynProperties)) {	
config admin pid not found not using external configuration create a brooklyn cfg file in etc folder 

public void initOsgi() {	synchronized (reloadLock) {	final Stopwatch startupTimer = Stopwatch.createStarted();	BrooklynShutdownHooks.resetShutdownFlag();	
osgilauncher init catalog 

public void initOsgi() {	synchronized (reloadLock) {	final Stopwatch startupTimer = Stopwatch.createStarted();	BrooklynShutdownHooks.resetShutdownFlag();	catalogInitialization(new CatalogInitialization(String.format("file:%s", defaultCatalogLocation), false, null, false));	startPartOne();	startupTimer.stop();	
brooklyn initialisation part one complete after 

public void startOsgi() {	synchronized (reloadLock) {	final Stopwatch startupTimer = Stopwatch.createStarted();	
osgilauncher start 

public void startOsgi() {	synchronized (reloadLock) {	final Stopwatch startupTimer = Stopwatch.createStarted();	startPartTwo();	startupTimer.stop();	
brooklyn initialisation part two complete after 

public void destroyOsgi() {	
notified of system shutdown calling shutdown hooks 

protected void startingUp() {	super.startingUp();	ManagementContext managementContext = getManagementContext();	BrooklynProperties brooklynProperties = (BrooklynProperties) managementContext.getConfig();	if (BrooklynWebConfig.hasNoSecurityOptions(brooklynProperties)) {	
no security provider options specified define a security provider or users to prevent a random password being created and logged 

public void updateProperties(Map<?, ?> props) {	synchronized (reloadLock) {	
updating brooklyn config because of config admin changes 

========================= brooklyn sample_517 =========================

public void stop() {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STOPPING);	try {	for (Entity child : this.getChildren()) {	if (child instanceof Startable) ((Startable) child).stop();	}	
tasks successfully run update state of to stopped 

public void stop() {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STOPPING);	try {	for (Entity child : this.getChildren()) {	if (child instanceof Startable) ((Startable) child).stop();	}	setUpAndRunState(false, Lifecycle.STOPPED);	} catch (Throwable t) {	
tasks not successfully run update state of to on fire 

========================= brooklyn sample_2437 =========================

protected LocationMemento getMementoWithProperties(Map<String,?> props) {	LocationMemento memento = MementosGenerators.newLocationMementoBuilder(location).customFields(props).build();	
creating memento for location 

protected void addChildren(RebindContext rebindContext, LocationMemento memento) {	for (String childId : memento.getChildren()) {	Location child = rebindContext.lookup().lookupLocation(childId);	if (child != null) {	location.addChild(child);	} else {	
ignoring child of location as cannot be found 

protected void setParent(RebindContext rebindContext, LocationMemento memento) {	Location parent = (memento.getParent() != null) ? rebindContext.lookup().lookupLocation(memento.getParent()) : null;	if (parent != null) {	location.setParent(parent);	} else if (memento.getParent() != null) {	
ignoring parent of location as cannot be found 

========================= brooklyn sample_1132 =========================

public void setUp() throws Exception {	mementoDir = Os.newTempDir(getClass());	mgmt = createOrigManagementContext();	
test persisting to 

public void tearDown() throws Exception {	try {	if (mgmt != null) {	for (Application app: mgmt.getApplications()) {	
destroying app managed mgmt is 

public void tearDown() throws Exception {	try {	if (mgmt != null) {	for (Application app: mgmt.getApplications()) {	try {	Entities.destroy(app);	
destroyed app mgmt now 

public void tearDown() throws Exception {	try {	if (mgmt != null) {	for (Application app: mgmt.getApplications()) {	try {	Entities.destroy(app);	} catch (Exception e) {	
problems destroying app 

Entities.destroy(app);	} catch (Exception e) {	}	}	}	if (launcher != null) launcher.destroyAll();	if (viewer != null) viewer.terminate();	if (mgmt != null) Entities.destroyAll(mgmt);	if (mementoDir != null) FileBasedObjectStore.deleteCompletely(mementoDir);	} catch (Throwable t) {	
caught exception in teardown method 

========================= brooklyn sample_540 =========================

private void propagateIfCauseNotClassNotFound(IllegalStateException e) {	ClassNotFoundException cnfe = Exceptions.getFirstThrowableOfType(e, ClassNotFoundException.class);	NoClassDefFoundError ncdfe = Exceptions.getFirstThrowableOfType(e, NoClassDefFoundError.class);	if (cnfe == null && ncdfe == null) {	throw e;	} else {	if (ncdfe != null) {	
class loading failure 

private void propagateIfCauseNotClassNotFound(IllegalStateException e) {	ClassNotFoundException cnfe = Exceptions.getFirstThrowableOfType(e, ClassNotFoundException.class);	NoClassDefFoundError ncdfe = Exceptions.getFirstThrowableOfType(e, NoClassDefFoundError.class);	if (cnfe == null && ncdfe == null) {	throw e;	} else {	if (ncdfe != null) {	} else if (cnfe != null) {	BundleException bundleException = Exceptions.getFirstThrowableOfType(cnfe, BundleException.class);	if (bundleException != null) {	
class loading failure 

========================= brooklyn sample_1427 =========================

public static Entity getTargetOrContextEntity(Task<?> t) {	if (t==null) return null;	Entity result = getWrappedEntityOfType(t, CONTEXT_ENTITY);	if (result!=null) return result;	result = getWrappedEntityOfType(t, TARGET_ENTITY);	if (result!=null) {	
context entity found by looking at target entity tag not context entity 

public static Entity getTargetOrContextEntity(Task<?> t) {	if (t==null) return null;	Entity result = getWrappedEntityOfType(t, CONTEXT_ENTITY);	if (result!=null) return result;	result = getWrappedEntityOfType(t, TARGET_ENTITY);	if (result!=null) {	return result;	}	result = Tasks.tag(t, Entity.class, false);	if (result!=null) {	
context entity found by looking at entity tag not wrapped entity 

========================= brooklyn sample_1077 =========================

private DeferredSupplier<String> deferredSupplier() {	return new DeferredSupplier<String>() {	try {	
acquiring 

private DeferredSupplier<String> deferredSupplier() {	return new DeferredSupplier<String>() {	try {	if (!latch.tryAcquire()) latch.acquire();	latch.release();	
acquired and released 

private DeferredSupplier<String> deferredSupplier() {	return new DeferredSupplier<String>() {	try {	if (!latch.tryAcquire()) latch.acquire();	latch.release();	} catch (InterruptedException e) {	
interrupted 

private DeferredSupplier<String> immediateSupplier(final boolean withSleep) {	class DeferredImmediateSupplier implements DeferredSupplier<String>, ImmediateSupplier<String> {	public Maybe<String> getImmediately() {	try {	sleepIfNeeded();	
acquiring 

public Maybe<String> getImmediately() {	try {	sleepIfNeeded();	if (latch.tryAcquire()) {	latch.release();	return Maybe.of("myval");	} else {	return Maybe.absent(new ImmediateSupplier.ImmediateValueNotAvailableException());	}	} catch (InterruptedException e) {	
interrupted 

return Maybe.of("myval");	} else {	return Maybe.absent(new ImmediateSupplier.ImmediateValueNotAvailableException());	}	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	}	}	try {	sleepIfNeeded();	
acquiring 

return Maybe.absent(new ImmediateSupplier.ImmediateValueNotAvailableException());	}	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	}	}	try {	sleepIfNeeded();	if (!latch.tryAcquire()) latch.acquire();	latch.release();	
acquired and released 

}	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	}	}	try {	sleepIfNeeded();	if (!latch.tryAcquire()) latch.acquire();	latch.release();	} catch (InterruptedException e) {	
interrupted 

} catch (InterruptedException e) {	throw Exceptions.propagate(e);	}	return "myval";	}	private void sleepIfNeeded() throws InterruptedException {	if (withSleep) {	try {	Thread.sleep(1);	} catch (InterruptedException e) {	
sleep was interrupted during eval expected in many cases 

protected void runGetConfigNonBlockingInKey() throws Exception {	Preconditions.checkNotNull(blockingVal, "Fixture must set blocking val before running this");	TestEntity entity = (TestEntity) mgmt.getEntityManager().createEntity(EntitySpec.create(TestEntity.class) .configure((ConfigKey<Object>)(ConfigKey<?>)TestEntity.CONF_NAME, blockingVal));	
get non blocking 

protected void runGetConfigNonBlockingInKey() throws Exception {	Preconditions.checkNotNull(blockingVal, "Fixture must set blocking val before running this");	TestEntity entity = (TestEntity) mgmt.getEntityManager().createEntity(EntitySpec.create(TestEntity.class) .configure((ConfigKey<Object>)(ConfigKey<?>)TestEntity.CONF_NAME, blockingVal));	assertTrue(entity.config().getNonBlocking(TestEntity.CONF_NAME).isAbsent());	
got absent 

protected void runGetConfigNonBlockingInKey() throws Exception {	Preconditions.checkNotNull(blockingVal, "Fixture must set blocking val before running this");	TestEntity entity = (TestEntity) mgmt.getEntityManager().createEntity(EntitySpec.create(TestEntity.class) .configure((ConfigKey<Object>)(ConfigKey<?>)TestEntity.CONF_NAME, blockingVal));	assertTrue(entity.config().getNonBlocking(TestEntity.CONF_NAME).isAbsent());	latch.release();	
get blocking 

protected void runGetConfigNonBlockingInKey() throws Exception {	Preconditions.checkNotNull(blockingVal, "Fixture must set blocking val before running this");	TestEntity entity = (TestEntity) mgmt.getEntityManager().createEntity(EntitySpec.create(TestEntity.class) .configure((ConfigKey<Object>)(ConfigKey<?>)TestEntity.CONF_NAME, blockingVal));	assertTrue(entity.config().getNonBlocking(TestEntity.CONF_NAME).isAbsent());	latch.release();	assertEquals(entity.config().get(TestEntity.CONF_NAME), expectedVal);	
got blocking 

protected void runGetConfigNonBlockingInKey() throws Exception {	Preconditions.checkNotNull(blockingVal, "Fixture must set blocking val before running this");	TestEntity entity = (TestEntity) mgmt.getEntityManager().createEntity(EntitySpec.create(TestEntity.class) .configure((ConfigKey<Object>)(ConfigKey<?>)TestEntity.CONF_NAME, blockingVal));	assertTrue(entity.config().getNonBlocking(TestEntity.CONF_NAME).isAbsent());	latch.release();	assertEquals(entity.config().get(TestEntity.CONF_NAME), expectedVal);	assertEquals(entity.config().getNonBlocking(TestEntity.CONF_NAME).get(), expectedVal);	latch.acquire();	
finished 

========================= brooklyn sample_757 =========================

protected void assertNotSshable(Map<?,?> machineConfig) {	try {	assertSshable(machineConfig);	Assert.fail("ssh should not have succeeded "+machineConfig);	} catch (Exception e) {	
exception as expected when testing sshable 

========================= brooklyn sample_2509 =========================

public void release(StubContainerLocation machine) {	DynamicCluster cluster = dockerHost.getDockerContainerCluster();	StubContainer container = machine.getOwner();	if (cluster.removeMember(container)) {	
docker host member released 

public void release(StubContainerLocation machine) {	DynamicCluster cluster = dockerHost.getDockerContainerCluster();	StubContainer container = machine.getOwner();	if (cluster.removeMember(container)) {	} else {	
docker host member not found for release 

public void release(StubContainerLocation machine) {	DynamicCluster cluster = dockerHost.getDockerContainerCluster();	StubContainer container = machine.getOwner();	if (cluster.removeMember(container)) {	} else {	}	try {	container.stop();	machine.close();	} catch (Exception e) {	
error stopping container 

========================= brooklyn sample_2159 =========================

public void resetPassword(String newPassword, Integer secretPin) {	
invoked effector from resetpassword with params 

public void resetPasswordThrowsException(String newPassword, Integer secretPin) {	
invoked effector from resetpasswordthrowsexception with params 

public void invokeUserAndPassword(String user,String newPassword, String paramDefault) {	
invoked effector from invokeuserandpassword with params 

========================= brooklyn sample_612 =========================

if (spec.getFlags().containsKey("parent")) {	throw new IllegalArgumentException("Spec's flags must not contain parent; use spec.parent() instead for "+spec);	}	if (spec.getFlags().containsKey("id")) {	throw new IllegalArgumentException("Spec's flags must not contain id; use spec.id() instead for "+spec);	}	try {	Class<? extends T> clazz = spec.getType();	T loc = construct(clazz, spec, null);	if (Locations.isManaged(loc)) {	
location factory returning pre existing location skipping initialization of 

========================= brooklyn sample_1325 =========================

public void testCanStartAndStop() throws Exception {	BrooklynCluster cluster = app.createAndManageChild(EntitySpec.create(BrooklynCluster.class) .configure(BrooklynCluster.INITIAL_SIZE, 1) .configure(BrooklynNode.WEB_CONSOLE_BIND_ADDRESS, Networking.ANY_NIC) .configure(BrooklynNode.ON_EXISTING_PROPERTIES_FILE, ExistingFileBehaviour.DO_NOT_USE));	app.start(locs);	Entity brooklynNode = Iterables.find(cluster.getMembers(), Predicates.instanceOf(BrooklynNode.class));	
started containing for 

========================= brooklyn sample_2270 =========================

} else if (t instanceof NovaTemplateOptions) {	String[] securityGroups = toStringArray(v);	t.securityGroups(securityGroups);	} else if (t instanceof SoftLayerTemplateOptions) {	String[] securityGroups = toStringArray(v);	t.securityGroups(securityGroups);	} else if (isGoogleComputeTemplateOptions(t)) {	String[] securityGroups = toStringArray(v);	t.securityGroups(securityGroups);	} else {	
ignoring securitygroups in vm creation because not supported for cloud type 

========================= brooklyn sample_2620 =========================

log.debug(""+this+" updated on "+event+", "+"enabled="+computeEnablement());	updateEnablement();	}	}	});	Object currentVal = entity.getAttribute(urlSensor);	if (currentVal != null) {	Function<String, String> postProcessor = getConfig(URL_POST_PROCESSING);	String newVal = (postProcessor != null) ? postProcessor.apply(currentVal.toString()) : currentVal.toString();	if (AtomicReferences.setIfDifferent(url, newVal)) {	
updated url on initial connectionon to 

========================= brooklyn sample_3031 =========================

public <T> boolean isEntitled(EntitlementContext context, EntitlementClass<T> entitlementClass, T entitlementClassArgument) {	if (context == null || context.user() == null) {	
simulating npe in entitlement manager 

========================= brooklyn sample_184 =========================

while (toscan.size() > 0) {	File file = toscan.remove(0);	if (file.isFile()) {	if (file.getName().toLowerCase().endsWith(".jar")) {	result.add(new URL("file: }	} else if (file.isDirectory()) {	for (File subfile : file.listFiles()) {	toscan.add(subfile);	}	} else {	
cannot read not a file or directory 

========================= brooklyn sample_2765 =========================

public <T> boolean isEntitled(EntitlementContext context, EntitlementClass<T> entitlementClass, T entitlementClassArgument) {	String type = entitlementClass.entitlementClassIdentifier();	if (Entitlements.INVOKE_EFFECTOR.entitlementClassIdentifier().equals(type)) {	String effectorName = ((EntityAndItem<StringAndArgument>)entitlementClassArgument).getItem().getString();	if ("myEffector".equals(effectorName)) {	
simulating npe in entitlement manager 

========================= brooklyn sample_700 =========================

public void testMachineUsableAfterRebindRepeatedly() throws Exception {	try {	testMachineUsableAfterRebind();	} catch (Exception e) {	
test failed 

========================= brooklyn sample_645 =========================

public Void call(ConfigBag parameters) {	if (!upgradeInProgress.compareAndSet(false, true)) {	throw new IllegalStateException("An upgrade is already in progress.");	}	EntitySpec<?> origMemberSpec = entity().getConfig(BrooklynCluster.MEMBER_SPEC);	Preconditions.checkNotNull(origMemberSpec, BrooklynCluster.MEMBER_SPEC.getName() + " is required for " + UpgradeClusterEffector.class.getName());	
upgrading changing from 

boolean success = false;	try {	String newDownloadUrl = parameters.get(DOWNLOAD_URL);	EntitySpec<?> newMemberSpec = EntitySpec.create(origMemberSpec);	ConfigBag newConfig = ConfigBag.newInstance();	newConfig.putIfNotNull(DOWNLOAD_URL, newDownloadUrl);	newConfig.put(BrooklynNode.DISTRO_UPLOAD_URL, inferUploadUrl(newDownloadUrl));	newConfig.putAll(ConfigBag.newInstance(parameters.get(EXTRA_CONFIG)).getAllConfigAsConfigKeyMap());	newMemberSpec.configure(newConfig.getAllConfigAsConfigKeyMap());	entity().config().set(BrooklynCluster.MEMBER_SPEC, newMemberSpec);	
upgrading new adding 

ConfigBag newConfig = ConfigBag.newInstance();	newConfig.putIfNotNull(DOWNLOAD_URL, newDownloadUrl);	newConfig.put(BrooklynNode.DISTRO_UPLOAD_URL, inferUploadUrl(newDownloadUrl));	newConfig.putAll(ConfigBag.newInstance(parameters.get(EXTRA_CONFIG)).getAllConfigAsConfigKeyMap());	newMemberSpec.configure(newConfig.getAllConfigAsConfigKeyMap());	entity().config().set(BrooklynCluster.MEMBER_SPEC, newMemberSpec);	upgrade(parameters);	success = true;	} finally {	if (!success) {	
upgrading failed will rethrow after restoring to 

========================= brooklyn sample_2362 =========================

public void init() {	super.init();	
mysampleimpl init with config 

public void start(Collection<? extends Location> locs) {	
mysampleimpl start 

public void stop() {	
mysampleimpl stop 

public void restart() {	
mysampleimpl restart 

public void myEffector(String arg1) {	
mysampleimpl myeffector 

========================= brooklyn sample_23 =========================

protected void deleteItem(ManagementContext mgmt, String symbolicName, String version) {	mgmt.getCatalog().deleteCatalogItem(symbolicName, version);	
deleted item from catalog 

========================= brooklyn sample_653 =========================

if (checkExists==0) {	switch (onExisting) {	case USE_EXISTING: doUpload = false; break;	case OVERWRITE: break;	case DO_NOT_USE: throw new IllegalStateException("Properties file "+brooklynGlobalPropertiesContents+" already exists and "+ "even though it is not being used, content for it was supplied");	case FAIL: throw new IllegalStateException("Properties file "+brooklynGlobalPropertiesContents+" already exists and "+ BrooklynNode.ON_EXISTING_PROPERTIES_FILE+" response is to fail");	default: throw new IllegalStateException("Properties file "+brooklynGlobalPropertiesContents+" already exists and "+ BrooklynNode.ON_EXISTING_PROPERTIES_FILE+" response "+onExisting+" is unknown");	}	}	if (onExisting==ExistingFileBehaviour.DO_NOT_USE) {	
global properties supplied when told not to use them no global properties exists so it will be installed but it will not be used 

if (publicAddress != null) {	cmd += " --publicAddress "+publicAddress.getHostName();	}	if (getEntity().getAttribute(BrooklynNode.NO_WEB_CONSOLE_AUTHENTICATION)) {	cmd += " --noConsoleSecurity";	}	if (Strings.isNonBlank(getEntity().getConfig(BrooklynNode.EXTRA_LAUNCH_PARAMETERS))) {	cmd += " "+getEntity().getConfig(BrooklynNode.EXTRA_LAUNCH_PARAMETERS);	}	cmd += format(" >> %s/console 2>&1 </dev/null &", getRunDir());	
starting brooklyn on using command 

========================= brooklyn sample_2374 =========================

public PortForwardManagerImpl() {	super();	if (isLegacyConstruction()) {	
deprecated construction of instead use location resolver 

public void init() {	super.init();	Integer portStartingPoint;	Object rawPort = getAllConfigBag().getStringKey(PORT_FORWARD_MANAGER_STARTING_PORT.getName());	if (rawPort != null) {	portStartingPoint = getConfig(PORT_FORWARD_MANAGER_STARTING_PORT);	} else {	portStartingPoint = getManagementContext().getConfig().getConfig(PORT_FORWARD_MANAGER_STARTING_PORT);	}	portReserved.set(portStartingPoint);	
set initial port to 

public int acquirePublicPort(String publicIpId) {	int port;	synchronized (mutex) {	port = getNextPort();	PortMapping mapping = new PortMapping(publicIpId, port, null, -1);	
allocating public port on no association info yet 

private void emitAssociationCreatedEvent(String publicIpId, HostAndPort publicEndpoint, Location location, int privatePort) {	AssociationMetadata metadata = new AssociationMetadata(publicIpId, publicEndpoint, location, privatePort);	for (Map.Entry<AssociationListener, Predicate<? super AssociationMetadata>> entry : associationListeners.entrySet()) {	if (entry.getValue().apply(metadata)) {	try {	entry.getKey().onAssociationCreated(metadata);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
exception thrown when emitting association creation event 

public boolean forgetPortMapping(String publicIpId, int publicPort) {	PortMapping old;	synchronized (mutex) {	old = mappings.remove(makeKey(publicIpId, publicPort));	if (old != null) {	emitAssociationDeletedEvent(associationMetadataFromPortMapping(old));	}	
cleared port mapping for 

synchronized (mutex) {	for (Iterator<PortMapping> iter = mappings.values().iterator(); iter.hasNext();) {	PortMapping m = iter.next();	if (l.equals(m.target)) {	iter.remove();	result.add(m);	emitAssociationDeletedEvent(associationMetadataFromPortMapping(m));	}	}	}	
cleared all port mappings for 

synchronized (mutex) {	for (Iterator<PortMapping> iter = mappings.values().iterator(); iter.hasNext();) {	PortMapping m = iter.next();	if (publicIpId.equals(m.publicIpId)) {	iter.remove();	result.add(m);	emitAssociationDeletedEvent(associationMetadataFromPortMapping(m));	}	}	}	
cleared all port mappings for 

private void emitAssociationDeletedEvent(AssociationMetadata metadata) {	for (Map.Entry<AssociationListener, Predicate<? super AssociationMetadata>> entry : associationListeners.entrySet()) {	if (entry.getValue().apply(metadata)) {	try {	entry.getKey().onAssociationDeleted(metadata);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
exception thrown when emitting association creation event 

public PortMapping acquirePublicPortExplicit(String publicIpId, int port) {	PortMapping mapping = new PortMapping(publicIpId, port, null, -1);	
assigning explicit public port at 

public void recordPublicIpHostname(String publicIpId, String hostnameOrPublicIpAddress) {	
recording public ip associated with 

public boolean forgetPublicIpHostname(String publicIpId) {	
forgetting public ip association 

public int acquirePublicPort(String publicIpId, Location l, int privatePort) {	int publicPort;	synchronized (mutex) {	PortMapping old = getPortMappingWithPrivateSide(l, privatePort);	if (old!=null && old.publicIpId.equals(publicIpId)) {	
request to acquire public port at for reusing old assignment 

public int acquirePublicPort(String publicIpId, Location l, int privatePort) {	int publicPort;	synchronized (mutex) {	PortMapping old = getPortMappingWithPrivateSide(l, privatePort);	if (old!=null && old.publicIpId.equals(publicIpId)) {	return old.getPublicPort();	}	publicPort = acquirePublicPort(publicIpId);	
request to acquire public port at for allocating 

========================= brooklyn sample_1276 =========================

public DeprecatedKeysMappingBuilder camelToHyphen(String key) {	String hyphen = toHyphen(key);	if (key.equals(hyphen)) {	
invalid attempt to convert camel case key to deprecated hyphen case both the same 

========================= brooklyn sample_1299 =========================

protected BrooklynTypeSnapshot(String name, Map<String, ConfigKey<?>> configKeys) {	this.name = name;	this.configKeys = ImmutableMap.copyOf(configKeys);	this.configKeysSet = ImmutableSet.copyOf(this.configKeys.values());	this.configKeysByDeprecatedName = new LinkedHashMap<>();	for (ConfigKey<?> key : configKeysSet) {	for (String deprecatedName : key.getDeprecatedNames()) {	if (configKeys.containsKey(deprecatedName)) {	
conflicting config key name used in and as deprecated name of will prefer but may cause problems 

protected BrooklynTypeSnapshot(String name, Map<String, ConfigKey<?>> configKeys) {	this.name = name;	this.configKeys = ImmutableMap.copyOf(configKeys);	this.configKeysSet = ImmutableSet.copyOf(this.configKeys.values());	this.configKeysByDeprecatedName = new LinkedHashMap<>();	for (ConfigKey<?> key : configKeysSet) {	for (String deprecatedName : key.getDeprecatedNames()) {	if (configKeys.containsKey(deprecatedName)) {	} else if (configKeysByDeprecatedName.containsKey(deprecatedName)) {	
conflicting config key name used as deprecated name in both and may cause problems 

========================= brooklyn sample_1333 =========================

assertSlave(masterDb, slaveDb, 2);	masterDb.revertDatabase();	masterDb.execute("items", "delete from INVENTORY where myuser= ?;", "Test");	assertSlave(masterDb, slaveDb, 1);	Set<String> dbSchemas = slaveDb.getSchemas();	for (String schema : notReplicatedSchemas) {	assertFalse(dbSchemas.contains(schema), "Database " + schema + " exists on slave");	}	masterDb.close();	slaveDb.close();	
ran vogella mysql example success 

public static MySqlCluster initCluster(TestApplication app, Location location, EntitySpec<MySqlCluster> spec) {	MySqlCluster mysql = app.createAndManageChild(spec);	app.start(ImmutableList.of(location));	
mysql started 

========================= brooklyn sample_74 =========================

public JcloudsLocation configure(Map<?,?> properties) {	super.configure(properties);	if (config().getLocalBag().containsKey("providerLocationId")) {	
using deprecated providerlocationid key in 

Map<String,Object> result = Maps.newLinkedHashMap();	Collection<String> unmatchedTags = Lists.newArrayList();	for (String it : tags) {	if (groovyTruth(tagMapping.get(it)) && !groovyTruth(result)) {	result.putAll(tagMapping.get(it));	} else {	unmatchedTags.add(it);	}	}	if (unmatchedTags.size() > 0) {	
location failed to match provisioning tags 

return input.getConfigKey().getName();	}	}));	Set<ConfigKey<?>> configKeysInList = ImmutableSet.<ConfigKey<?>>builder() .addAll(SUPPORTED_TEMPLATE_BUILDER_PROPERTIES.keySet()) .addAll(SUPPORTED_TEMPLATE_OPTIONS_PROPERTIES.keySet()) .build();	Set<String> configsInList = Sets.newLinkedHashSet( Iterables.transform(configKeysInList, new Function<ConfigKey<?>,String>() {	public String apply(@Nullable ConfigKey<?> input) {	return input.getName();	}	}));	SetView<String> extrasInList = Sets.difference(configsInList, configsOnClass);	
jcloudslocation supported properties differs from config defined on class 

public void killMachine(String cloudServiceId) {	Set<? extends NodeMetadata> destroyed = getComputeService().destroyNodesMatching(withIds(cloudServiceId));	
destroyed nodes s n 

Map<String, Object> baseTemplateOptions = config().get(TEMPLATE_OPTIONS);	Map<String, Object> templateOptions = (Map<String, Object>) shallowMerge(Maybe.fromNullable(flagTemplateOptions), Maybe.fromNullable(baseTemplateOptions), TEMPLATE_OPTIONS).orNull();	setup.put(TEMPLATE_OPTIONS, templateOptions);	Integer attempts = setup.get(MACHINE_CREATE_ATTEMPTS);	List<Exception> exceptions = Lists.newArrayList();	if (attempts == null || attempts < 1) attempts = 1;	for (int i = 1; i <= attempts; i++) {	try {	return obtainOnce(setup);	} catch (RuntimeException e) {	
attempt to obtain machine threw error 

NodeMetadata node = null;	JcloudsMachineLocation machineLocation = null;	Duration semaphoreTimestamp = null;	Duration templateTimestamp = null;	Duration provisionTimestamp = null;	Duration usableTimestamp = null;	Duration customizedTimestamp = null;	Stopwatch provisioningStopwatch = Stopwatch.createStarted();	JcloudsLocationCustomizer customizersDelegate = LocationCustomizerDelegate.newInstance(getManagementContext(), setup);	try {	
creating vm in 

Duration templateTimestamp = null;	Duration provisionTimestamp = null;	Duration usableTimestamp = null;	Duration customizedTimestamp = null;	Stopwatch provisioningStopwatch = Stopwatch.createStarted();	JcloudsLocationCustomizer customizersDelegate = LocationCustomizerDelegate.newInstance(getManagementContext(), setup);	try {	Semaphore machineCreationSemaphore = getMachineCreationSemaphore();	boolean acquired = machineCreationSemaphore.tryAcquire(0, TimeUnit.SECONDS);	if (!acquired) {	
waiting in for machine creation permit other queuing requests already 

Duration usableTimestamp = null;	Duration customizedTimestamp = null;	Stopwatch provisioningStopwatch = Stopwatch.createStarted();	JcloudsLocationCustomizer customizersDelegate = LocationCustomizerDelegate.newInstance(getManagementContext(), setup);	try {	Semaphore machineCreationSemaphore = getMachineCreationSemaphore();	boolean acquired = machineCreationSemaphore.tryAcquire(0, TimeUnit.SECONDS);	if (!acquired) {	Stopwatch blockStopwatch = Stopwatch.createStarted();	machineCreationSemaphore.acquire();	
acquired in machine creation permit after waiting 

Duration customizedTimestamp = null;	Stopwatch provisioningStopwatch = Stopwatch.createStarted();	JcloudsLocationCustomizer customizersDelegate = LocationCustomizerDelegate.newInstance(getManagementContext(), setup);	try {	Semaphore machineCreationSemaphore = getMachineCreationSemaphore();	boolean acquired = machineCreationSemaphore.tryAcquire(0, TimeUnit.SECONDS);	if (!acquired) {	Stopwatch blockStopwatch = Stopwatch.createStarted();	machineCreationSemaphore.acquire();	} else {	
acquired in machine creation permit immediately 

Set<? extends NodeMetadata> nodes;	Template template;	try {	if ("azurecompute-arm".equals(this.getProvider())) {	DefaultAzureArmNetworkCreator.createDefaultNetworkAndAddToTemplateOptionsIfRequired(computeService, setup);	}	template = buildTemplate(computeService, setup, ImmutableList.of(customizersDelegate));	boolean expectWindows = isWindows(template, setup);	if (!options.skipJcloudsSshing()) {	if (expectWindows) {	
ignoring invalid configuration for windows provisioning of should be false 

if (context instanceof Entity) {	Entity entity = (Entity)context;	template.getOptions().getUserMetadata().put("brooklyn-app-id", entity.getApplicationId());	template.getOptions().getUserMetadata().put("brooklyn-app-name", entity.getApplication().getDisplayName());	template.getOptions().getUserMetadata().put("brooklyn-entity-id", entity.getId());	template.getOptions().getUserMetadata().put("brooklyn-entity-name", entity.getDisplayName());	template.getOptions().getUserMetadata().put("brooklyn-server-creation-date", Time.makeDateSimpleStampString());	}	}	customizeTemplate(computeService, template, customizersDelegate);	
jclouds using template options to provision machine in 

template.getOptions().getUserMetadata().put("brooklyn-server-creation-date", Time.makeDateSimpleStampString());	}	}	customizeTemplate(computeService, template, customizersDelegate);	nodes = computeService.createNodesInGroup(groupId, 1, template);	provisionTimestamp = Duration.of(provisioningStopwatch);	} finally {	machineCreationSemaphore.release();	}	node = Iterables.getOnlyElement(nodes, null);	
jclouds created for 

} finally {	machineCreationSemaphore.release();	}	node = Iterables.getOnlyElement(nodes, null);	if (node == null) throw new IllegalStateException("No nodes returned by jclouds create-nodes in " + getCreationString(setup));	customizersDelegate.customize(this, node, setup);	boolean windows = isWindows(node, setup);	if (windows) {	int newLoginPort = node.getLoginPort() == 22 ? (setup.get(WinRmMachineLocation.USE_HTTPS_WINRM) ? 5986 : 5985) : node.getLoginPort();	String newLoginUser = "root".equals(node.getCredentials().getUser()) ? "Administrator" : node.getCredentials().getUser();	
jclouds created windows vm transforming connection details loginport from to loginuser from to 

}	node = NodeMetadataBuilder.fromNodeMetadata(node).credentials(null).build();	usableTimestamp = Duration.of(provisioningStopwatch);	if (windows) {	machineLocation = registerWinRmMachineLocation(computeService, node, Optional.fromNullable(template), userCredentials, managementHostAndPort, setup);	} else {	machineLocation = registerJcloudsSshMachineLocation(computeService, node, Optional.fromNullable(template), userCredentials, managementHostAndPort, setup);	}	PortForwardManager portForwardManager = setup.get(PORT_FORWARDING_MANAGER);	if (portForwardManager == null) {	
no portforwardmanager using default 

throw new IllegalStateException("Command 'Customizing node " + this + "' failed with exit code " + resp.getStatusCode() + " for location " + machineLocation);	}	} else {	executeCommandThrowingOnError( (SshMachineLocation)machineLocation, "Customizing node " + this, ImmutableList.of(script));	}	}	}	Boolean dontRequireTtyForSudo = setup.get(JcloudsLocationConfig.DONT_REQUIRE_TTY_FOR_SUDO);	if (Boolean.TRUE.equals(dontRequireTtyForSudo) || (dontRequireTtyForSudo == null && setup.get(DONT_CREATE_USER))) {	if (windows) {	
ignoring flag dont require tty for sudo on windows location 

Boolean dontRequireTtyForSudo = setup.get(JcloudsLocationConfig.DONT_REQUIRE_TTY_FOR_SUDO);	if (Boolean.TRUE.equals(dontRequireTtyForSudo) || (dontRequireTtyForSudo == null && setup.get(DONT_CREATE_USER))) {	if (windows) {	} else {	customisationForLogging.add("patch /etc/sudoers to disable requiretty");	queueLocationTask("patch /etc/sudoers to disable requiretty", SshTasks.dontRequireTtyForSudo((SshMachineLocation)machineLocation, true).newTask().asTask());	}	}	if (setup.get(JcloudsLocationConfig.MAP_DEV_RANDOM_TO_DEV_URANDOM)) {	if (windows) {	
ignoring flag map dev random to dev urandom on windows location 

}	if (setup.get(JcloudsLocationConfig.MAP_DEV_RANDOM_TO_DEV_URANDOM)) {	if (windows) {	} else {	customisationForLogging.add("point /dev/random to urandom");	executeCommandThrowingOnError( (SshMachineLocation)machineLocation, "using urandom instead of random", Arrays.asList( BashCommands.sudo("mv /dev/random /dev/random-real"), BashCommands.sudo("ln -s /dev/urandom /dev/random")));	}	}	if (setup.get(GENERATE_HOSTNAME)) {	if (windows) {	
ignoring flag generate hostname on windows location 

}	if (setup.get(GENERATE_HOSTNAME)) {	if (windows) {	} else {	customisationForLogging.add("configure hostname");	executeCommandThrowingOnError( (SshMachineLocation)machineLocation, "Generate hostname " + node.getName(), ImmutableList.of(BashCommands.chainGroup( String.format("echo '127.0.0.1 %s' | ( %s )", node.getName(), BashCommands.sudo("tee -a /etc/hosts")), "{ " + BashCommands.sudo("sed -i \"s/HOSTNAME=.*/HOSTNAME=" + node.getName() + "/g\" /etc/sysconfig/network") + " || true ; }", BashCommands.sudo("hostname " + node.getName()))));	}	}	if (setup.get(OPEN_IPTABLES)) {	if (windows) {	
ignoring deprecated flag open iptables on windows location 

if (setup.get(GENERATE_HOSTNAME)) {	if (windows) {	} else {	customisationForLogging.add("configure hostname");	executeCommandThrowingOnError( (SshMachineLocation)machineLocation, "Generate hostname " + node.getName(), ImmutableList.of(BashCommands.chainGroup( String.format("echo '127.0.0.1 %s' | ( %s )", node.getName(), BashCommands.sudo("tee -a /etc/hosts")), "{ " + BashCommands.sudo("sed -i \"s/HOSTNAME=.*/HOSTNAME=" + node.getName() + "/g\" /etc/sysconfig/network") + " || true ; }", BashCommands.sudo("hostname " + node.getName()))));	}	}	if (setup.get(OPEN_IPTABLES)) {	if (windows) {	} else {	
using deprecated flag open iptables will not be supported in future versions for at 

} else {	customisationForLogging.add("configure hostname");	executeCommandThrowingOnError( (SshMachineLocation)machineLocation, "Generate hostname " + node.getName(), ImmutableList.of(BashCommands.chainGroup( String.format("echo '127.0.0.1 %s' | ( %s )", node.getName(), BashCommands.sudo("tee -a /etc/hosts")), "{ " + BashCommands.sudo("sed -i \"s/HOSTNAME=.*/HOSTNAME=" + node.getName() + "/g\" /etc/sysconfig/network") + " || true ; }", BashCommands.sudo("hostname " + node.getName()))));	}	}	if (setup.get(OPEN_IPTABLES)) {	if (windows) {	} else {	Iterable<Integer> inboundPorts = Ints.asList(template.getOptions().getInboundPorts());	if (inboundPorts == null || Iterables.isEmpty(inboundPorts)) {	
no ports to open in iptables no inbound ports for at 

}	if (batch.size() > 0) {	executeCommandWarningOnError( (SshMachineLocation)machineLocation, "Inserting iptables rules", batch);	}	executeCommandWarningOnError( (SshMachineLocation)machineLocation, "List iptables rules", ImmutableList.of(IptablesCommands.listIptablesRule()));	}	}	}	if (setup.get(STOP_IPTABLES)) {	if (windows) {	
ignoring deprecated flag open iptables on windows location 

if (batch.size() > 0) {	executeCommandWarningOnError( (SshMachineLocation)machineLocation, "Inserting iptables rules", batch);	}	executeCommandWarningOnError( (SshMachineLocation)machineLocation, "List iptables rules", ImmutableList.of(IptablesCommands.listIptablesRule()));	}	}	}	if (setup.get(STOP_IPTABLES)) {	if (windows) {	} else {	
using deprecated flag stop iptables will not be supported in future versions for at 

cmds = ImmutableList.of(IptablesCommands.firewalldServiceStop(), IptablesCommands.firewalldServiceStatus());	} else {	cmds = ImmutableList.of(IptablesCommands.iptablesServiceStop(), IptablesCommands.iptablesServiceStatus());	}	executeCommandWarningOnError( (SshMachineLocation)machineLocation, "Stopping iptables", cmds);	}	}	List<String> extraKeyUrlsToAuth = setup.get(EXTRA_PUBLIC_KEY_URLS_TO_AUTH);	if (extraKeyUrlsToAuth!=null && !extraKeyUrlsToAuth.isEmpty()) {	if (windows) {	
ignoring flag extra public key urls to auth on windows location 

List<String> extraKeyDataToAuth = MutableList.of();	for (String keyUrl : extraKeyUrlsToAuth) {	extraKeyDataToAuth.add(ResourceUtils.create().getResourceAsString(keyUrl));	}	executeCommandThrowingOnError( (SshMachineLocation)machineLocation, "Authorizing ssh keys from URLs", ImmutableList.of(new AuthorizeRSAPublicKeys(extraKeyDataToAuth).render(org.jclouds.scriptbuilder.domain.OsFamily.UNIX)));	}	}	String extraKeyDataToAuth = setup.get(EXTRA_PUBLIC_KEY_DATA_TO_AUTH);	if (extraKeyDataToAuth!=null && !extraKeyDataToAuth.isEmpty()) {	if (windows) {	
ignoring flag extra public key data to auth on windows location 

if (e.toString().contains("VPCResourceNotSpecified")) {	String message = "Detected that your EC2 account is a legacy 'EC2 Classic' account, " + "but the most appropriate hardware instance type requires 'VPC'. " + "One quick fix is to use the 'eu-central-1' region. " + "Other remedies are described at " + AWS_VPC_HELP_URL;	LOG.error(message);	e = new UserFacingException(message, e);	}	LOG.error("Failed to start VM for "+getCreationString(setup) + (destroyNode ? " (destroying)" : "") + (node != null ? "; node "+node : "") + " after "+Duration.of(provisioningStopwatch).toStringRounded() + (semaphoreTimestamp != null ? " (" + "semaphore obtained in "+Duration.of(semaphoreTimestamp).toStringRounded()+";" + (templateTimestamp != null && semaphoreTimestamp != null ? " template built in "+Duration.of(templateTimestamp).subtract(semaphoreTimestamp).toStringRounded()+";" : "") + (provisionTimestamp != null && templateTimestamp != null ? " node provisioned in "+Duration.of(provisionTimestamp).subtract(templateTimestamp).toStringRounded()+";" : "") + (usableTimestamp != null && provisioningStopwatch != null ? " connection usable in "+Duration.of(usableTimestamp).subtract(provisionTimestamp).toStringRounded()+";" : "") + (customizedTimestamp != null && usableTimestamp != null ? " and OS customized in "+Duration.of(customizedTimestamp).subtract(usableTimestamp).toStringRounded() : "") + ")" : "") + ": "+e.getMessage());	LOG.debug(Throwables.getStackTraceAsString(e));	try {	customizersDelegate.preReleaseOnObtainError(this, machineLocation, e);	} catch (Exception customizerException) {	
got exception on calling customizer prereleaseonobtainerror ignoring location is machine location is node is 

Stopwatch destroyingStopwatch = Stopwatch.createStarted();	if (machineLocation != null) {	releaseSafely(machineLocation);	} else {	releaseNodeSafely(node);	}	LOG.info("Destroyed " + (machineLocation != null ? "machine " + machineLocation : "node " + node) + " in " + Duration.of(destroyingStopwatch).toStringRounded());	try {	customizersDelegate.postReleaseOnObtainError(this, machineLocation, e);	} catch (Exception customizerException) {	
got exception on calling customizer postreleaseonobtainerror ignoring location is machine location is node is 

private void executeCommandWarningOnError(SshMachineLocation loc, String name, List<String> commands) {	Task<Integer> task = SshTasks.newSshExecTaskFactory(loc, commands) .summary(name) .allowingNonZeroExitCode() .newTask() .asTask();	int ret = queueLocationTask("waiting for '" + name + "' on machine " + loc, task);	if (ret != 0) {	
command failed with exit code for location 

public void suspendMachine(MachineLocation rawLocation) {	String instanceId = vmInstanceIds.remove(rawLocation);	if (instanceId == null) {	
attempt to suspend unknown machine in 

public void suspendMachine(MachineLocation rawLocation) {	String instanceId = vmInstanceIds.remove(rawLocation);	if (instanceId == null) {	throw new IllegalArgumentException("Unknown machine " + rawLocation);	}	
suspending machine in instance id 

public void suspendMachine(MachineLocation rawLocation) {	String instanceId = vmInstanceIds.remove(rawLocation);	if (instanceId == null) {	throw new IllegalArgumentException("Unknown machine " + rawLocation);	}	Exception toThrow = null;	try {	getComputeService().suspendNode(instanceId);	} catch (Exception e) {	toThrow = e;	
problem suspending machine in instance id 

public JcloudsMachineLocation resumeMachine(Map<?, ?> flags) {	ConfigBag setup = ConfigBag.newInstanceExtending(config().getBag(), flags);	
using resuming node matching properties 

public JcloudsMachineLocation resumeMachine(Map<?, ?> flags) {	ConfigBag setup = ConfigBag.newInstanceExtending(config().getBag(), flags);	ComputeService computeService = getComputeService(setup);	NodeMetadata node = findNodeOrThrow(setup);	
resuming 

public JcloudsMachineLocation resumeMachine(Map<?, ?> flags) {	ConfigBag setup = ConfigBag.newInstanceExtending(config().getBag(), flags);	ComputeService computeService = getComputeService(setup);	NodeMetadata node = findNodeOrThrow(setup);	computeService.resumeNode(node.getId());	node = findNodeOrThrow(setup);	
resumed 

public JcloudsMachineLocation resumeMachine(Map<?, ?> flags) {	ConfigBag setup = ConfigBag.newInstanceExtending(config().getBag(), flags);	ComputeService computeService = getComputeService(setup);	NodeMetadata node = findNodeOrThrow(setup);	computeService.resumeNode(node.getId());	node = findNodeOrThrow(setup);	JcloudsMachineLocation registered = registerMachineLocation(setup, node);	
resumed and registered 

public Template buildTemplate(ComputeService computeService, ConfigBag config, JcloudsLocationCustomizer customizersDelegate) {	TemplateBuilder templateBuilder = config.get(TEMPLATE_BUILDER);	if (templateBuilder==null) {	templateBuilder = new PortableTemplateBuilder<PortableTemplateBuilder<?>>();	} else {	
jclouds using templatebuilder as custom base for provisioning in for 

} else {	templateBuilder, this, getCreationString(config)});	}	if (templateBuilder instanceof PortableTemplateBuilder<?>) {	if (((PortableTemplateBuilder<?>)templateBuilder).imageChooser()==null) {	Function<Iterable<? extends Image>, Image> chooser = getImageChooser(computeService, config);	templateBuilder.imageChooser(chooser);	} else {	}	} else {	
cannot check imagechooser status for due to manually supplied black box templatebuilder it is recommended to use a portabletemplatebuilder if you supply a templatebuilder 

}	} else {	}	if (!Strings.isEmpty(config.get(CLOUD_REGION_ID))) {	templateBuilder.locationId(config.get(CLOUD_REGION_ID));	}	if (Strings.isNonBlank(config.get(HARDWARE_ID))) {	String oldHardwareId = config.get(HARDWARE_ID);	String newHardwareId = transformHardwareId(oldHardwareId, config);	if (!Objects.equal(oldHardwareId, newHardwareId)) {	
transforming hardwareid from to in 

}	if (templateBuilder instanceof PortableTemplateBuilder) {	((PortableTemplateBuilder<?>)templateBuilder).attachComputeService(computeService);	if (groovyTruth(config.get(DEFAULT_IMAGE_ID))) {	if (((PortableTemplateBuilder<?>)templateBuilder).isBlank()) {	templateBuilder.imageId(config.get(DEFAULT_IMAGE_ID).toString());	}	}	}	customizersDelegate.customize(this, computeService, templateBuilder);	
jclouds using templatebuilder for provisioning in for 

}	}	customizersDelegate.customize(this, computeService, templateBuilder);	templateBuilder, this, getCreationString(config)});	Template template = null;	Image image;	try {	template = templateBuilder.build();	if (template==null) throw new IllegalStateException("No matching template; check image and hardware constraints (e.g. OS, RAM); using "+templateBuilder);	image = template.getImage();	
jclouds found template image for provisioning in for 

customizersDelegate.customize(this, computeService, templateBuilder);	templateBuilder, this, getCreationString(config)});	Template template = null;	Image image;	try {	template = templateBuilder.build();	if (template==null) throw new IllegalStateException("No matching template; check image and hardware constraints (e.g. OS, RAM); using "+templateBuilder);	image = template.getImage();	if (image==null) throw new IllegalStateException("No matching image in template at "+toStringNice()+"; check image constraints (OS, providers, ID); using "+templateBuilder);	} catch (AuthorizationException e) {	
error resolving template not authorized rethrowing template is 

template = templateBuilder.build();	if (template==null) throw new IllegalStateException("No matching template; check image and hardware constraints (e.g. OS, RAM); using "+templateBuilder);	image = template.getImage();	if (image==null) throw new IllegalStateException("No matching image in template at "+toStringNice()+"; check image constraints (OS, providers, ID); using "+templateBuilder);	} catch (AuthorizationException e) {	throw new IllegalStateException("Not authorized to access cloud "+toStringNice()+"; "+ "check identity, credentials, and endpoint (identity='"+getIdentity()+"', credential length "+getCredential().length()+")", e);	} catch (Exception e) {	try {	IOException ioe = Exceptions.getFirstThrowableOfType(e, IOException.class);	if (ioe != null) {	
ioexception found 

if (image==null) throw new IllegalStateException("No matching image in template at "+toStringNice()+"; check image constraints (OS, providers, ID); using "+templateBuilder);	} catch (AuthorizationException e) {	throw new IllegalStateException("Not authorized to access cloud "+toStringNice()+"; "+ "check identity, credentials, and endpoint (identity='"+getIdentity()+"', credential length "+getCredential().length()+")", e);	} catch (Exception e) {	try {	IOException ioe = Exceptions.getFirstThrowableOfType(e, IOException.class);	if (ioe != null) {	throw ioe;	}	if (listedAvailableTemplatesOnNoSuchTemplate.compareAndSet(false, true)) {	
unable to match required vm template constraints when trying to provision vm in rethrowing 

} catch (Exception e) {	try {	IOException ioe = Exceptions.getFirstThrowableOfType(e, IOException.class);	if (ioe != null) {	throw ioe;	}	if (listedAvailableTemplatesOnNoSuchTemplate.compareAndSet(false, true)) {	logAvailableTemplates(config);	}	} catch (Exception e2) {	
error loading available images to report following original error matching template which will be rethrown 

boolean windows = isWindows(template, config);	if (windows) {	String initScript = WinRmMachineLocation.getDefaultUserMetadataString(config());	String provider = getProvider();	if ("google-compute-engine".equals(provider)) {	String startupScriptKey = "sysprep-specialize-script-cmd";	Object metadataMapRaw = config.get(USER_METADATA_MAP);	if (metadataMapRaw instanceof Map) {	Map<?,?> metadataMap = (Map<?, ?>) metadataMapRaw;	if (metadataMap.containsKey(startupScriptKey)) {	
not adding startup script for windows vm on because already has key in config 

if ("google-compute-engine".equals(provider)) {	String startupScriptKey = "sysprep-specialize-script-cmd";	Object metadataMapRaw = config.get(USER_METADATA_MAP);	if (metadataMapRaw instanceof Map) {	Map<?,?> metadataMap = (Map<?, ?>) metadataMapRaw;	if (metadataMap.containsKey(startupScriptKey)) {	} else {	Map<Object, Object> metadataMapReplacement = MutableMap.copyOf(metadataMap);	metadataMapReplacement.put(startupScriptKey, initScript);	config.put(USER_METADATA_MAP, metadataMapReplacement);	
adding startup script to enable winrm for windows vm on 

Map<?,?> metadataMap = (Map<?, ?>) metadataMapRaw;	if (metadataMap.containsKey(startupScriptKey)) {	} else {	Map<Object, Object> metadataMapReplacement = MutableMap.copyOf(metadataMap);	metadataMapReplacement.put(startupScriptKey, initScript);	config.put(USER_METADATA_MAP, metadataMapReplacement);	}	} else if (metadataMapRaw == null) {	Map<String, String> metadataMapReplacement = MutableMap.of(startupScriptKey, initScript);	config.put(USER_METADATA_MAP, metadataMapReplacement);	
adding startup script to enable winrm for windows vm on 

}	} else if (metadataMapRaw == null) {	Map<String, String> metadataMapReplacement = MutableMap.of(startupScriptKey, initScript);	config.put(USER_METADATA_MAP, metadataMapReplacement);	}	} else {	boolean userMetadataString = config.containsKey(JcloudsLocationConfig.USER_METADATA_STRING);	boolean userMetadataMap = config.containsKey(JcloudsLocationConfig.USER_METADATA_MAP);	if (!(userMetadataString || userMetadataMap)) {	config.put(JcloudsLocationConfig.USER_METADATA_STRING, WinRmMachineLocation.getDefaultUserMetadataString(config()));	
adding startup script to enable winrm for windows vm on 

} else if (metadataMapRaw == null) {	Map<String, String> metadataMapReplacement = MutableMap.of(startupScriptKey, initScript);	config.put(USER_METADATA_MAP, metadataMapReplacement);	}	} else {	boolean userMetadataString = config.containsKey(JcloudsLocationConfig.USER_METADATA_STRING);	boolean userMetadataMap = config.containsKey(JcloudsLocationConfig.USER_METADATA_MAP);	if (!(userMetadataString || userMetadataMap)) {	config.put(JcloudsLocationConfig.USER_METADATA_STRING, WinRmMachineLocation.getDefaultUserMetadataString(config()));	} else {	
not adding startup script for windows vm on because already has config 

String region = getRegion();	if (Strings.isBlank(region)) region = config.get(CLOUD_REGION_ID);	if (!"google-compute-engine".equals(provider)) {	return hardwareId;	}	if (hardwareId.toLowerCase().startsWith("http") || hardwareId.contains("/")) {	return hardwareId;	}	if (Strings.isNonBlank(region)) {	return String.format("https: } else {	
cannot transform gce hardwareid to long form because region unknown in 

protected NodeMetadata findNodeOrThrow(ConfigBag config) {	String user = checkNotNull(getUser(config), "user");	String rawId = (String) config.getStringKey("id");	String rawHostname = (String) config.getStringKey("hostname");	Predicate<ComputeMetadata> predicate = getRebindToMachinePredicate(config);	
finding vm in jclouds location for provider matching 

protected JcloudsSshMachineLocation createJcloudsSshMachineLocation( ComputeService computeService, NodeMetadata node, Optional<Template> template, LoginCredentials userCredentials, HostAndPort managementHostAndPort, ConfigBag setup) throws IOException {	Collection<JcloudsLocationCustomizer> customizers = getCustomizers(setup);	Collection<MachineLocationCustomizer> machineCustomizers = getMachineCustomizers(setup);	Map<?,?> sshConfig = extractSshConfig(setup, node);	String nodeAvailabilityZone = extractAvailabilityZone(setup, node);	String nodeRegion = extractRegion(setup, node);	if (nodeRegion == null) {	nodeRegion = extractProvider(setup, node);	}	if (LOG.isDebugEnabled()) {	
creating jcloudssshmachinelocation representation for for 

}	String address = managementHostAndPort.getHostText();	int port = managementHostAndPort.hasPort() ? managementHostAndPort.getPort() : node.getLoginPort();	String displayName = getPublicHostnameGeneric(node, setup, Optional.of(address));	final Object password = sshConfig.get(SshMachineLocation.PASSWORD.getName()) != null ? sshConfig.get(SshMachineLocation.PASSWORD.getName()) : userCredentials.getOptionalPassword().orNull();	final Object privateKeyData = sshConfig.get(SshMachineLocation.PRIVATE_KEY_DATA.getName()) != null ? sshConfig.get(SshMachineLocation.PRIVATE_KEY_DATA.getName()) : userCredentials.getOptionalPrivateKey().orNull();	if (isManaged()) {	final LocationSpec<JcloudsSshMachineLocation> spec = LocationSpec.create(JcloudsSshMachineLocation.class) .configure(sshConfig) .configure("displayName", displayName) .configure("address", address) .configure(JcloudsSshMachineLocation.SSH_PORT, port) .configure("user", userCredentials.getUser()) .configure(SshMachineLocation.PASSWORD.getName(), password) .configure(SshMachineLocation.PRIVATE_KEY_DATA.getName(), privateKeyData) .configure("jcloudsParent", this) .configure("node", node) .configure("template", template.orNull()) .configureIfNotNull(CLOUD_AVAILABILITY_ZONE_ID, nodeAvailabilityZone) .configureIfNotNull(CLOUD_REGION_ID, nodeRegion) .configure(CALLER_CONTEXT, setup.get(CALLER_CONTEXT)) .configure(SshMachineLocation.DETECT_MACHINE_DETAILS, setup.get(SshMachineLocation.DETECT_MACHINE_DETAILS)) .configureIfNotNull(SshMachineLocation.SCRIPT_DIR, setup.get(SshMachineLocation.SCRIPT_DIR)) .configureIfNotNull(USE_PORT_FORWARDING, setup.get(USE_PORT_FORWARDING)) .configureIfNotNull(PORT_FORWARDER, setup.get(PORT_FORWARDER)) .configureIfNotNull(PORT_FORWARDING_MANAGER, setup.get(PORT_FORWARDING_MANAGER)) .configureIfNotNull(SshMachineLocation.PRIVATE_ADDRESSES, node.getPrivateAddresses()) .configureIfNotNull(JCLOUDS_LOCATION_CUSTOMIZERS, customizers.size() > 0 ? customizers : null) .configureIfNotNull(MACHINE_LOCATION_CUSTOMIZERS, machineCustomizers.size() > 0 ? machineCustomizers : null);	return getManagementContext().getLocationManager().createLocation(spec);	} else {	
using deprecated jcloudssshmachinelocation constructor because is not managed 

public void release(MachineLocation rawMachine) {	String instanceId = vmInstanceIds.remove(rawMachine);	if (instanceId == null) {	
attempted release of unknown machine in 

public void release(MachineLocation rawMachine) {	String instanceId = vmInstanceIds.remove(rawMachine);	if (instanceId == null) {	throw new IllegalArgumentException("Unknown machine "+rawMachine);	}	JcloudsMachineLocation machine = (JcloudsMachineLocation) rawMachine;	
releasing machine in instance id 

protected void releaseNodeSafely(NodeMetadata node) {	String instanceId = node.getId();	
releasing node in instance id 

protected void releaseNodeSafely(NodeMetadata node) {	String instanceId = node.getId();	try {	releaseNode(instanceId);	} catch (Exception e) {	
problem releasing node in instance id discarding instance and continuing 

protected void releaseNode(String instanceId) {	ComputeService computeService;	try {	computeService = getComputeService(config().getBag());	Set<? extends NodeMetadata> destroyed = computeService.destroyNodesMatching(withIds(instanceId));	
destroyed nodes s n 

protected void releaseNode(String instanceId) {	ComputeService computeService;	try {	computeService = getComputeService(config().getBag());	Set<? extends NodeMetadata> destroyed = computeService.destroyNodesMatching(withIds(instanceId));	} finally {	if (computeService != null) {	try {	computeService.getContext().close();	} catch (Exception e) {	
problem closing compute service s context continuing 

protected void releasePortForwarding(final JcloudsMachineLocation machine) {	boolean usePortForwarding = Boolean.TRUE.equals(machine.getConfig(USE_PORT_FORWARDING));	final JcloudsPortForwarderExtension portForwarder = machine.getConfig(PORT_FORWARDER);	final String nodeId = machine.getJcloudsId();	final Map<String, Runnable> subtasks = Maps.newLinkedHashMap();	PortForwardManager portForwardManager = machine.getConfig(PORT_FORWARDING_MANAGER);	if (portForwardManager == null) {	
no portforwardmanager using default 

protected void releasePortForwarding(final JcloudsMachineLocation machine) {	boolean usePortForwarding = Boolean.TRUE.equals(machine.getConfig(USE_PORT_FORWARDING));	final JcloudsPortForwarderExtension portForwarder = machine.getConfig(PORT_FORWARDER);	final String nodeId = machine.getJcloudsId();	final Map<String, Runnable> subtasks = Maps.newLinkedHashMap();	PortForwardManager portForwardManager = machine.getConfig(PORT_FORWARDING_MANAGER);	if (portForwardManager == null) {	portForwardManager = (PortForwardManager) getManagementContext().getLocationRegistry().getLocationManaged(PortForwardManagerLocationResolver.PFM_GLOBAL_SPEC);	}	if (portForwarder == null) {	
no port forwarding to close because portforwarder null on release of 

int port = ((WinRmMachineLocation)machine).getPort();	hostAndPortOverride = HostAndPort.fromParts(host, port);	} else {	LOG.warn("Unexpected machine {} of type {}; expected SSH or WinRM", machine, (machine != null ? machine.getClass() : null));	hostAndPortOverride = null;	}	if (hostAndPortOverride != null) {	final int loginPort = node.get().getLoginPort();	subtasks.put( "Close port-forward "+hostAndPortOverride+"->"+loginPort, new Runnable() {	public void run() {	
closing port forwarding at for machine 

if (nodeId != null) {	mappings.addAll(portForwardManager.getPortMappingWithPublicIpId(nodeId));	}	for (final PortMapping mapping : mappings) {	final HostAndPort publicEndpoint = mapping.getPublicEndpoint();	final int targetPort = mapping.getPrivatePort();	final Protocol protocol = Protocol.TCP;	if (publicEndpoint != null && node.isPresent()) {	subtasks.put( "Close port-forward "+publicEndpoint+"->"+targetPort, new Runnable() {	public void run() {	
closing port forwarding at for machine 

final Task<Void> task = builder.build();	final DynamicTasks.TaskQueueingResult<Void> queueResult = DynamicTasks.queueIfPossible(task);	if(queueResult.isQueuedOrSubmitted()){	final String origDetails = Tasks.setBlockingDetails("waiting for closing port-forwarding of "+machine);	try {	task.blockUntilEnded();	} finally {	Tasks.setBlockingDetails(origDetails);	}	} else {	
releasing port forwarding of not executing in execution context e g not invoked inside effector falling back to executing sequentially 

protected String getFirstReachableAddress(NodeMetadata node, ConfigBag setup) {	String pollForFirstReachable = setup.get(POLL_FOR_FIRST_REACHABLE_ADDRESS);	boolean enabled = !"false".equalsIgnoreCase(pollForFirstReachable);	String result;	if (enabled) {	Duration timeout = "true".equals(pollForFirstReachable) ? Duration.FIVE_MINUTES : Duration.of(pollForFirstReachable);	Predicate<? super HostAndPort> predicate = getReachableAddressesPredicate(setup);	
polling for first reachable address with 

protected String getFirstReachableAddress(NodeMetadata node, ConfigBag setup) {	String pollForFirstReachable = setup.get(POLL_FOR_FIRST_REACHABLE_ADDRESS);	boolean enabled = !"false".equalsIgnoreCase(pollForFirstReachable);	String result;	if (enabled) {	Duration timeout = "true".equals(pollForFirstReachable) ? Duration.FIVE_MINUTES : Duration.of(pollForFirstReachable);	Predicate<? super HostAndPort> predicate = getReachableAddressesPredicate(setup);	result = JcloudsUtil.getFirstReachableAddress(node, timeout, predicate);	
using first reachable address for node in 

String result;	if (enabled) {	Duration timeout = "true".equals(pollForFirstReachable) ? Duration.FIVE_MINUTES : Duration.of(pollForFirstReachable);	Predicate<? super HostAndPort> predicate = getReachableAddressesPredicate(setup);	result = JcloudsUtil.getFirstReachableAddress(node, timeout, predicate);	} else {	result = Iterables.getFirst(Iterables.concat(node.getPublicAddresses(), node.getPrivateAddresses()), null);	if (result == null) {	throw new IllegalStateException("No addresses available for node "+node+" in "+this);	}	
using first address for node in 

return true;	}	Predicate<WinRmMachineLocation> machineReachable = new Predicate<WinRmMachineLocation>() {	public boolean apply(@Nullable WinRmMachineLocation machine) {	try {	WinRmToolResponse response = machine.executeCommand("echo testing");	int statusCode = response.getStatusCode();	return statusCode == 0;	} catch (RuntimeException e) {	if (getFirstThrowableOfType(e, IOException.class) != null || getFirstThrowableOfType(e, WebServiceException.class) != null) {	
winrm connectivity lost 

return false;	} else {	throw e;	}	}	}	};	Duration verifyWindowsUpTime = Duration.of(verifyWindowsUp);	boolean restartHappened = Predicates2.retry(Predicates.not(machineReachable), verifyWindowsUpTime.toMilliseconds(), Duration.FIVE_SECONDS.toMilliseconds(), Duration.THIRTY_SECONDS.toMilliseconds(), TimeUnit.MILLISECONDS).apply(machine);	if (restartHappened) {	
connectivity to the machine was lost probably windows have restarted as part of the provisioning process retrying to connect 

if (groovyTruth(originalUser)) {	if (setHostname(setup, metadata, false)) return;	usersTried.add(originalUser);	}	LoginCredentials credentials = metadata.getCredentials();	if (credentials!=null) {	if (Strings.isNonBlank(credentials.getUser())) setup.put(USER, credentials.getUser());	if (Strings.isNonBlank(credentials.getOptionalPrivateKey().orNull())) setup.put(PRIVATE_KEY_DATA, credentials.getOptionalPrivateKey().orNull());	if (setHostname(setup, metadata, false)) {	if (originalUser!=null && !originalUser.equals(getUser(setup))) {	
switching to cloud specified user at as failed to connect using 

if (setHostname(setup, metadata, false)) {	if (originalUser!=null && !originalUser.equals(getUser(setup))) {	}	return;	}	usersTried.add(getUser(setup));	}	for (String u: COMMON_USER_NAMES_TO_TRY) {	setup.put(USER, u);	if (setHostname(setup, metadata, false)) {	
auto detected user at as failed to connect using 

}	usersTried.add(getUser(setup));	}	for (String u: COMMON_USER_NAMES_TO_TRY) {	setup.put(USER, u);	if (setHostname(setup, metadata, false)) {	return;	}	usersTried.add(getUser(setup));	}	
failed to log in to tried as users throwing original exception 

protected boolean setHostname(ConfigBag setup, NodeMetadata metadata, boolean rethrow) {	try {	setup.put(SshTool.PROP_HOST, getPublicHostname(metadata, Optional.<HostAndPort>absent(), setup));	return true;	} catch (Exception e) {	if (rethrow) {	
couldn t connect to when trying to discover hostname rethrowing 

========================= brooklyn sample_2636 =========================

protected EntitySpec<BrooklynNode> newBrooklynNodeSpecForTest() {	
creating entity spec for 

public void testCanStartAndStop() throws Exception {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest());	app.start(locs);	
started containing for 

public void testSetsGlobalBrooklynPropertiesFromContents() throws Exception {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.BROOKLYN_GLOBAL_PROPERTIES_REMOTE_PATH, pseudoBrooklynPropertiesFile.getAbsolutePath()) .configure(BrooklynNode.BROOKLYN_GLOBAL_PROPERTIES_CONTENTS, "abc=def"));	app.start(locs);	
started containing for 

public void testSetsLocalBrooklynPropertiesFromContents() throws Exception {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_REMOTE_PATH, pseudoBrooklynPropertiesFile.getAbsolutePath()) .configure(BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_CONTENTS, "abc=def"));	app.start(locs);	
started containing for 

public void testSetsBrooklynPropertiesFromUri() throws Exception {	File brooklynPropertiesSourceFile = File.createTempFile("brooklynnode-test", ".properties");	Files.write("abc=def", brooklynPropertiesSourceFile, Charsets.UTF_8);	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.BROOKLYN_GLOBAL_PROPERTIES_REMOTE_PATH, pseudoBrooklynPropertiesFile.getAbsolutePath()) .configure(BrooklynNode.BROOKLYN_GLOBAL_PROPERTIES_URI, brooklynPropertiesSourceFile.toURI().toString()));	app.start(locs);	
started containing for 

public void testCopiesResources() throws Exception {	File sourceFile = File.createTempFile("brooklynnode-test", ".properties");	Files.write("abc=def", sourceFile, Charsets.UTF_8);	File tempDir = Files.createTempDir();	File expectedFile = new File(tempDir, "myfile.txt");	try {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.RUN_DIR, tempDir.getAbsolutePath()) .configure(BrooklynNode.COPY_TO_RUNDIR, ImmutableMap.of(sourceFile.getAbsolutePath(), "${RUN}/myfile.txt")));	app.start(locs);	
started containing for 

File classpathEntry2 = File.createTempFile("second", ".properties");	Files.write(content, classpathEntry1, Charsets.UTF_8);	Files.write(content, classpathEntry2, Charsets.UTF_8);	File tempDir = Files.createTempDir();	File destDir = new File(new File(tempDir, "lib"), "dropins");	File expectedFile1 = new File(destDir, classpathEntry1.getName());	File expectedFile2 = new File(destDir, classpathEntry2.getName());	try {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.RUN_DIR, tempDir.getAbsolutePath()) .configure(BrooklynNode.CLASSPATH, ImmutableList.of(classpathEntry1.getAbsolutePath(), classpathEntry2.getAbsolutePath())) );	app.start(locs);	
started containing for 

String testName1 = "test_" + classpathEntry1.getName();	File destDir = new File(new File(tempDir, "lib"), "dropins");	File expectedFile1 = new File(destDir, testName1);	String testName2 = "test_" + classpathEntry2.getName();	File expectedFile2 = new File(destDir, testName2);	Map entry1 = ImmutableMap.of("url", classpathEntry1.getAbsolutePath(), "filename", testName1);	Map entry2 = ImmutableMap.of("url", classpathEntry2.getAbsolutePath(), "filename", testName2);	try {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.RUN_DIR, tempDir.getAbsolutePath()) .configure(BrooklynNode.CLASSPATH, ImmutableList.of(entry1, entry2)) );	app.start(locs);	
started containing for 

Files.write(content, classpathEntry2, Charsets.UTF_8);	File tempDir = Files.createTempDir();	File expectedFile1 = new File(new File(tempDir, "lib"), classpathEntry1.getName());	File expectedFile2 = new File(new File(tempDir, "lib"), classpathEntry2.getName());	try {	String propName = BrooklynNode.CLASSPATH.getName();	String propValue = classpathEntry1.toURI().toString() + "," + classpathEntry2.toURI().toString();	((BrooklynProperties)app.getManagementContext().getConfig()).put(propName, propValue);	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.RUN_DIR, tempDir.getAbsolutePath()) );	app.start(locs);	
started containing for 

public void testSetsBrooklynWebConsolePort() throws Exception {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.HTTP_PORT, PortRanges.fromString("45000+")));	app.start(locs);	
started containing for 

public void testStartsAppOnStartup() throws Exception {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.APP, BasicApplicationImpl.class.getName()));	app.start(locs);	
started containing for 

public void testStartsAppViaEffector() throws Exception {	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest());	app.start(locs);	
started containing for 

public void testUsesLocation() throws Exception {	String brooklynPropertiesContents = "brooklyn.location.named.mynamedloc=localhost:(name=myname)\n"+ "brooklyn.location.named.mynamedloc.latitude=123\n"+ "brooklyn.location.named.mynamedloc.longitude=45.6\n";	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_CONTENTS, brooklynPropertiesContents) .configure(BrooklynNode.APP, BasicApplicationImpl.class.getName()) .configure(BrooklynNode.LOCATIONS, "named:mynamedloc"));	app.start(locs);	
started containing for 

public void testAuthenticationAndHttps() throws Exception {	String adminPassword = "p4ssw0rd";	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.ENABLED_HTTP_PROTOCOLS, ImmutableList.of("https")) .configure(BrooklynNode.MANAGEMENT_PASSWORD, adminPassword) .configure(BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_CONTENTS, Strings.lines( "brooklyn.webconsole.security.https.required=true", "brooklyn.webconsole.security.users=admin", "brooklyn.webconsole.security.user.admin.password="+adminPassword, "brooklyn.location.localhost.enabled=false") ) );	app.start(locs);	
started containing for 

} catch (Exception e) {	IllegalStateException ise = Exceptions.getFirstThrowableOfType(e, IllegalStateException.class);	if (ise != null && ise.toString().contains("Can't stop instance with running applications")) {	} else {	throw e;	}	} finally {	try {	brooklynNode.invoke(BrooklynNode.STOP_NODE_AND_KILL_APPS, ImmutableMap.of(StopNodeAndKillAppsEffector.TIMEOUT.getName(), Duration.THIRTY_SECONDS)).getUnchecked();	} catch (Exception e) {	
error in stopnodeandkillapps for continuing 

public void testStopAndRestartProcess() throws Exception {	persistenceDir = Files.createTempDir();	BrooklynNode brooklynNode = app.createAndManageChild(newBrooklynNodeSpecForTest() .configure(BrooklynNode.EXTRA_LAUNCH_PARAMETERS, "--persist auto --persistenceDir "+persistenceDir.getAbsolutePath()) .configure(BrooklynNode.APP, BasicApplicationImpl.class.getName()));	app.start(locs);	
started containing for 

private BrooklynNode setUpBrooklynNodeWithApp() throws InterruptedException, ExecutionException {	BrooklynNode brooklynNode = app.createAndManageChild(EntitySpec.create(BrooklynNode.class) .configure(BrooklynNode.NO_WEB_CONSOLE_AUTHENTICATION, Boolean.TRUE));	app.start(locs);	
started containing for 

========================= brooklyn sample_2266 =========================

try {	String dateStr = new SimpleDateFormat(Time.DATE_FORMAT_PREFERRED).format(date);	dir.mkdirs();	File file = new File(dir, "auto-test-results.txt");	file.createNewFile();	Files.append("date="+dateStr+"; test="+options+"; result="+result+"\n", file, Charsets.UTF_8);	File summaryFile = new File(dir, "auto-test-summary.txt");	summaryFile.createNewFile();	Files.append( dateStr +"\t"+options.summary +"\t"+roundToSignificantFigures(result.ratePerSecond, 6) +"\t"+result.duration +(result.cpuTotalFraction != null ? "\t"+"cpu="+roundToSignificantFigures(result.cpuTotalFraction, 3) : "") +"\n", summaryFile, Charsets.UTF_8);	} catch (IOException e) {	
failed to persist performance results to continuing 

========================= brooklyn sample_2773 =========================

public static ProxySslConfig fromMap(Map<?,?> map) {	Builder b = new Builder();	Map<?, ?> unused = FlagUtils.setFieldsFromFlags(map, b);	
unused flags when populating ignoring 

========================= brooklyn sample_192 =========================

public void setPersister(BrooklynMementoPersister val, PersistenceExceptionHandler exceptionHandler) {	if (persistenceStoreAccess != null && persistenceStoreAccess != val) {	throw new IllegalStateException("Dynamically changing persister is not supported: old="+persistenceStoreAccess+"; new="+val);	}	if (persistenceRealChangeListener!=null) {	
persister reset after listeners have been set source of persister reset 

public void startPersistence() {	if (readOnlyRunning) {	throw new IllegalStateException("Cannot start read-only when already running with persistence");	}	
starting persistence mgmt 

public void stopPersistence() {	
stopping persistence mgmt 

public void stopPersistence() {	persistenceRunning = false;	if (persistenceRealChangeListener != null) persistenceRealChangeListener.stop();	if (persistenceStoreAccess != null) persistenceStoreAccess.disableWriteAccess(true);	
stopped rebind persistence mgmt 

public void startReadOnly(final ManagementNodeState mode) {	if (!ManagementNodeState.isHotProxy(mode)) {	throw new IllegalStateException("Read-only rebind thread only permitted for hot proxy modes; not "+mode);	}	if (persistenceRunning) {	throw new IllegalStateException("Cannot start read-only when already running with persistence");	}	if (readOnlyRunning || readOnlyTask!=null) {	
cannot request read only mode for when already running ignoring 

public void startReadOnly(final ManagementNodeState mode) {	if (!ManagementNodeState.isHotProxy(mode)) {	throw new IllegalStateException("Read-only rebind thread only permitted for hot proxy modes; not "+mode);	}	if (persistenceRunning) {	throw new IllegalStateException("Cannot start read-only when already running with persistence");	}	if (readOnlyRunning || readOnlyTask!=null) {	return;	}	
starting read only rebinding mgmt 

} catch (Exception e) {	throw Exceptions.propagate(e);	}	Callable<Task<?>> taskFactory = new Callable<Task<?>>() {	return Tasks.<Void>builder().dynamic(false).displayName("rebind (periodic run").body(new Callable<Void>() {	public Void call() {	try {	rebind(null, null, mode);	return null;	} catch (RuntimeInterruptedException e) {	
interrupted rebinding re interrupting 

} catch (Exception e) {	throw Exceptions.propagate(e);	}	Callable<Task<?>> taskFactory = new Callable<Task<?>>() {	return Tasks.<Void>builder().dynamic(false).displayName("rebind (periodic run").body(new Callable<Void>() {	public Void call() {	try {	rebind(null, null, mode);	return null;	} catch (RuntimeInterruptedException e) {	
interrupted rebinding re interrupting details 

return Tasks.<Void>builder().dynamic(false).displayName("rebind (periodic run").body(new Callable<Void>() {	public Void call() {	try {	rebind(null, null, mode);	return null;	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	return null;	} catch (Exception e) {	if (!readOnlyRunning) {	
problem rebinding read only running has probably just been turned off 

public Void call() {	try {	rebind(null, null, mode);	return null;	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	return null;	} catch (Exception e) {	if (!readOnlyRunning) {	if (LOG.isTraceEnabled()) {	
problem rebinding read only running has probably just been turned off details 

rebind(null, null, mode);	return null;	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	return null;	} catch (Exception e) {	if (!readOnlyRunning) {	if (LOG.isTraceEnabled()) {	}	} else {	
problem rebinding 

Thread.currentThread().interrupt();	return null;	} catch (Exception e) {	if (!readOnlyRunning) {	if (LOG.isTraceEnabled()) {	}	} else {	}	return null;	} catch (Throwable t) {	
problem rebinding rethrowing 

public void stopReadOnly() {	readOnlyRunning = false;	if (readOnlyTask!=null) {	
stopping read only rebinding mgmt 

public void stopReadOnly() {	readOnlyRunning = false;	if (readOnlyTask!=null) {	readOnlyTask.cancel(true);	readOnlyTask.blockUntilEnded();	boolean reallyEnded = Tasks.blockUntilInternalTasksEnded(readOnlyTask, Duration.TEN_SECONDS);	if (!reallyEnded) {	
rebind read only tasks took too long to die after interrupt ignoring 

public void stopReadOnly() {	readOnlyRunning = false;	if (readOnlyTask!=null) {	readOnlyTask.cancel(true);	readOnlyTask.blockUntilEnded();	boolean reallyEnded = Tasks.blockUntilInternalTasksEnded(readOnlyTask, Duration.TEN_SECONDS);	if (!reallyEnded) {	}	readOnlyTask = null;	
stopped read only rebinding mgmt 

public void start() {	ManagementNodeState target = getRebindMode();	if (target==ManagementNodeState.HOT_STANDBY || target==ManagementNodeState.HOT_BACKUP) {	startReadOnly(target);	} else if (target==ManagementNodeState.MASTER) {	startPersistence();	} else {	
nothing to start in when ha mode is 

public void forcePersistNow(boolean full, PersistenceExceptionHandler exceptionHandler) {	if (persistenceStoreAccess == null || persistenceRealChangeListener == null) {	
skipping forced persist no persistence mechanism available 

public void onManaged(BrooklynObject instance) {	try {	delegate.onManaged(instance);	} catch (Throwable t) {	
error persisting mememento onmanaged continuing 

public void onChanged(BrooklynObject instance) {	try {	delegate.onChanged(instance);	} catch (Throwable t) {	
error persisting mememento onchanged continuing 

public void onUnmanaged(BrooklynObject instance) {	try {	delegate.onUnmanaged(instance);	} catch (Throwable t) {	
error persisting mememento onunmanaged continuing 

========================= brooklyn sample_1128 =========================

try {	ss = new ServerSocket();	ss.setSoTimeout(250);	if (allowReuse!=null) { ss.setReuseAddress(allowReuse); }	ss.bind(new InetSocketAddress(localAddress, port));	ds = new DatagramSocket(null);	ds.setSoTimeout(250);	if (allowReuse!=null) { ss.setReuseAddress(allowReuse); }	ds.bind(new InetSocketAddress(localAddress, port));	} catch (IOException e) {	
failed binding to 

throw Exceptions.propagate(e);	}	boolean foundAvailableInterface = false;	while (nis.hasMoreElements()) {	NetworkInterface ni = nis.nextElement();	Enumeration<InetAddress> as = ni.getInetAddresses();	while (as.hasMoreElements()) {	InetAddress a = as.nextElement();	if (!isPortAvailable(a, port, allowReuse)) {	if (isAddressValid(a)) {	
port is taken and the address is valid 

try {	ss = new ServerSocket();	ss.setSoTimeout(250);	} catch (IOException e) {	throw Exceptions.propagate(e);	}	try {	ss.bind(new InetSocketAddress(addr, 0));	return true;	} catch (IOException e) {	
binding on failed interface could be down being reconfigured file handle exhaustion port exhaustion etc 

public static boolean isLocalOnly(String hostnameOrIp) {	Preconditions.checkNotNull(hostnameOrIp, "hostnameOrIp");	if ("127.0.0.1".equals(hostnameOrIp)) return true;	if ("localhost".equals(hostnameOrIp)) return true;	if ("localhost.localdomain".equals(hostnameOrIp)) return true;	try {	InetAddress ia = getInetAddressWithFixedName(hostnameOrIp);	return isLocalOnly(ia);	} catch (Exception e) {	
networking cannot resolve assuming it is not a local only address but it is a private address 

public static boolean isPrivateSubnet(String hostnameOrIp) {	Preconditions.checkNotNull(hostnameOrIp, "hostnameOrIp");	try {	InetAddress ia = getInetAddressWithFixedName(hostnameOrIp);	return isPrivateSubnet(ia);	} catch (Exception e) {	
networking cannot resolve assuming it is a private address 

public synchronized static String getAddressOfUnresolvableHostname() {	if (triedUnresolvableHostname) return cachedAddressOfUnresolvableHostname;	String h = "noexistent-machine-"+Identifiers.makeRandomBase64Id(8);	try {	cachedAddressOfUnresolvableHostname = InetAddress.getByName(h).getHostAddress();	
networking detected being returned by dns for bogus hostnames 

public synchronized static String getAddressOfUnresolvableHostname() {	if (triedUnresolvableHostname) return cachedAddressOfUnresolvableHostname;	String h = "noexistent-machine-"+Identifiers.makeRandomBase64Id(8);	try {	cachedAddressOfUnresolvableHostname = InetAddress.getByName(h).getHostAddress();	} catch (Exception e) {	
networking detected failure on dns resolution of unknown hostname throws 

public static InetAddress resolve(String hostname) {	try {	InetAddress a = InetAddress.getByName(hostname);	if (a==null) return null;	String ha = a.getHostAddress();	
networking resolved as 

public static InetAddress resolve(String hostname) {	try {	InetAddress a = InetAddress.getByName(hostname);	if (a==null) return null;	String ha = a.getHostAddress();	if (ha.equals(getAddressOfUnresolvableHostname())) return null;	if (ha.startsWith("169.")) return null;	return a;	} catch (Exception e) {	
networking failed to resolve threw 

}	if (failIfNone) {	throw new IllegalStateException("No reachable local addresses could be found; ensure that localhost is correctly configured on this machine" + ", and if required that network security permits local access to localhost ports");	} else {	InetAddress result;	try {	result = InetAddress.getLocalHost();	} catch (UnknownHostException e2) {	result = getInetAddressWithFixedName("127.0.0.1");	}	
localhost is not resolvable using 

public static Map<String,InetAddress> getLocalAddresses() {	Map<String, InetAddress> result = new LinkedHashMap<String, InetAddress>();	Enumeration<NetworkInterface> ne;	try {	ne = NetworkInterface.getNetworkInterfaces();	} catch (SocketException e) {	
local network interfaces are not resolvable 

}	while (ne != null && ne.hasMoreElements()) {	NetworkInterface nic = ne.nextElement();	Enumeration<InetAddress> inets = nic.getInetAddresses();	while (inets.hasMoreElements()) {	InetAddress inet = inets.nextElement();	result.put(inet.getHostAddress(), inet);	}	}	if (result.isEmpty()) {	
no local network addresses found assuming 

modifiedIpV6Address = modifiedIpV6Address.substring(0, modifiedIpV6Address.indexOf("%"));	}	if ("0:0:0:0:0:0:0:1".equals(modifiedIpV6Address)) return true;	if ("::1".equals(modifiedIpV6Address)) return true;	if (addresses.containsKey(remoteAddress) || addresses.containsKey(modifiedIpV6Address)) return true;	try {	InetAddress remote = InetAddress.getByName(remoteAddress);	if (addresses.values().contains(remote)) return true;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error resolving address when checking if it is local assuming not 

s.setReuseAddress(false);	s.setSoLinger(false, 1);	}	if (timeout>0) {	s.setSoTimeout(timeout);	}	s.connect(new InetSocketAddress(endpoint.getHostText(), endpoint.getPort()), timeout);	closeQuietly(s);	return true;	} catch (Exception e) {	
error reaching during reachability check return false 

========================= brooklyn sample_1981 =========================

protected void preStop() {	
disconnecting sensors for in entity prestop 

protected void callRebindHooks() {	Duration configuredMaxDelay = getConfig(MAXIMUM_REBIND_SENSOR_CONNECT_DELAY);	if (configuredMaxDelay == null || Duration.ZERO.equals(configuredMaxDelay)) {	connectSensors();	} else {	long delay = (long) (Math.random() * configuredMaxDelay.toMilliseconds());	
scheduled reconnection of sensors on in ms 

Duration configuredMaxDelay = getConfig(MAXIMUM_REBIND_SENSOR_CONNECT_DELAY);	if (configuredMaxDelay == null || Duration.ZERO.equals(configuredMaxDelay)) {	connectSensors();	} else {	long delay = (long) (Math.random() * configuredMaxDelay.toMilliseconds());	Map<?,?> flags = MutableMap.of("delay", Duration.millis(delay), "maxIterations", 1, "cancelOnException", true);	Callable<Void> job = new Callable<Void>() {	public Void call() {	try {	if (getManagementSupport().isNoLongerManaged()) {	
entity no longer managed ignoring scheduled connect sensors on rebind 

long delay = (long) (Math.random() * configuredMaxDelay.toMilliseconds());	Map<?,?> flags = MutableMap.of("delay", Duration.millis(delay), "maxIterations", 1, "cancelOnException", true);	Callable<Void> job = new Callable<Void>() {	public Void call() {	try {	if (getManagementSupport().isNoLongerManaged()) {	return null;	}	connectSensors();	} catch (Throwable e) {	
problem connecting sensors on rebind of 

public void rebind() {	Lifecycle expectedState = ServiceStateLogic.getExpectedState(this);	if (expectedState == null || expectedState != Lifecycle.RUNNING) {	
on rebind of not calling software process rebind hooks because expected state is 

public void rebind() {	Lifecycle expectedState = ServiceStateLogic.getExpectedState(this);	if (expectedState == null || expectedState != Lifecycle.RUNNING) {	return;	}	Lifecycle actualState = ServiceStateLogic.getActualState(this);	if (actualState == null || actualState != Lifecycle.RUNNING) {	
rebinding entity even though actual state is expected state is 

public void rebind() {	Lifecycle expectedState = ServiceStateLogic.getExpectedState(this);	if (expectedState == null || expectedState != Lifecycle.RUNNING) {	return;	}	Lifecycle actualState = ServiceStateLogic.getActualState(this);	if (actualState == null || actualState != Lifecycle.RUNNING) {	}	
rebind connecting to pre running service 

if (expectedState == null || expectedState != Lifecycle.RUNNING) {	return;	}	Lifecycle actualState = ServiceStateLogic.getActualState(this);	if (actualState == null || actualState != Lifecycle.RUNNING) {	}	MachineLocation machine = getMachineOrNull();	if (machine != null) {	initDriver(machine);	driver.rebind();	
on rebind of re created driver 

return;	}	Lifecycle actualState = ServiceStateLogic.getActualState(this);	if (actualState == null || actualState != Lifecycle.RUNNING) {	}	MachineLocation machine = getMachineOrNull();	if (machine != null) {	initDriver(machine);	driver.rebind();	} else {	
on rebind of no machinelocation found with locations so not generating driver 

protected Map<String,Object> obtainProvisioningFlags(MachineProvisioningLocation location) {	ConfigBag result = ConfigBag.newInstance(location.getProvisioningFlags(ImmutableList.of(getClass().getName())));	Map<String, Object> raw1 = PROVISIONING_PROPERTIES.rawValue(config().getBag().getAllConfigRaw());	Maybe<Object> raw2 = config().getRaw(PROVISIONING_PROPERTIES);	if (raw2.isPresentAndNonNull()) {	Object pp = raw2.get();	if (!(pp instanceof Map)) {	
when obtaining provisioning properties for to deploy to detected that coercion was needed so coercing sooner than we would otherwise 

protected SoftwareProcessDriver doInitDriver(MachineLocation machine) {	if (driver!=null) {	if ((driver instanceof AbstractSoftwareProcessDriver) && machine.equals(((AbstractSoftwareProcessDriver)driver).getLocation())) {	return driver;	} else {	
driver location change is untested for at changing driver and continuing 

public void waitForEntityStart() {	
waiting to ensure doesn t abort prematurely 

public void waitForEntityStart() {	Duration startTimeout = getConfig(START_TIMEOUT);	CountdownTimer timer = startTimeout.countdownTimer();	boolean isRunningResult = false;	long delay = 100;	Exception firstFailure = null;	while (!isRunningResult && timer.isNotExpired()) {	Time.sleep(delay);	try {	isRunningResult = driver.isRunning();	
checked is running returned 

Exceptions.propagateIfFatal(e);	isRunningResult = false;	if (driver != null) {	String msg = "checked " + this + ", 'is running' threw an exception; logging subsequent exceptions at debug level";	if (firstFailure == null) {	LOG.error(msg, e);	} else {	LOG.debug(msg, e);	}	} else {	
concurrent start and shutdown detected 

firstFailure = e;	}	}	delay = Math.min(delay*11/10, 5000);	}	if (!isRunningResult) {	String msg = "Software process entity "+this+" did not pass is-running check within "+ "the required "+startTimeout+" limit ("+timer.getDurationElapsed().toStringRounded()+" elapsed)";	if (firstFailure != null) {	msg += "; check failed at least once with exception: " + firstFailure.getMessage() + ", see logs for details";	}	
throwing 

========================= brooklyn sample_2354 =========================

public void init() {	if (jcloudsParent != null) {	super.init();	if (node != null) {	setNode(node);	}	if (template != null) {	setTemplate(template);	}	} else {	
not doing init of because parent not set presuming rebinding 

public Template getTemplate() {	Optional<Template> result = getOptionalTemplate();	if (result.isPresent()) {	String msg = "Deprecated use of getTemplate() for "+this;	
see debug log for stacktrace 

public Template getTemplate() {	Optional<Template> result = getOptionalTemplate();	if (result.isPresent()) {	String msg = "Deprecated use of getTemplate() for "+this;	
for stacktrace 

========================= brooklyn sample_2641 =========================

public void onContainerLocationUpdated(ContainerType container, Location location) {	if (!containers.contains(container)) {	
ignoring setting of location for unknown container to 

public void onItemUsageUpdated(ItemType item, Map<? extends ItemType, Double> newValue) {	if (hasItem(item)) {	itemUsage.put(item, newValue);	} else {	
ignoring setting of usage for unknown item to 

========================= brooklyn sample_3050 =========================

protected void finalize() {	
shellfeed builder created but build never called 

protected ProcessTaskFactory<?> newTaskFactory(final String command, Map<String,String> env, File dir, String input, final String summary, final long timeout) {	if (timeout > 0) {	
timeout ms not currently supported for shellfeed 

========================= brooklyn sample_1597 =========================

public void testAttributeWhenReadyAbortsWhenOnFireByDefault() {	
starting test 

public void testAttributeWhenReadyAbortsWhenOnFireByDefault() {	final Task<String> t = submit(DependentConfiguration.builder() .attributeWhenReady(entity, TestEntity.NAME) .build());	ServiceStateLogic.setExpectedState(entity, Lifecycle.ON_FIRE);	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.ON_FIRE);	try {	assertDoneEventually(t);	fail("Should have failed already!");	} catch (Throwable e) {	if (e.toString().contains("Aborted waiting for ready")) return;	
did not abort as expected 

========================= brooklyn sample_809 =========================

public List<JcloudsMachineLocation> get() {	List<JcloudsMachineLocation> result = Lists.newArrayList();	JcloudsLocation jcloudsLocation = (JcloudsLocation) managementContext.getLocationManager().createLocation(jcloudsLocationSpec.get());	for (Map<?,?> machineFlags : machinesFlags) {	try {	jcloudsLocation.config().putAll(machineFlags);	JcloudsMachineLocation machine = jcloudsLocation.registerMachine(ImmutableMap.of());	result.add(machine);	} catch (NoMachinesAvailableException e) {	Map<?,?> sanitizedMachineFlags = Sanitizer.sanitize(machineFlags);	
error rebinding to jclouds machine in 

for (Map<?,?> machineFlags : machinesFlags) {	try {	jcloudsLocation.config().putAll(machineFlags);	JcloudsMachineLocation machine = jcloudsLocation.registerMachine(ImmutableMap.of());	result.add(machine);	} catch (NoMachinesAvailableException e) {	Map<?,?> sanitizedMachineFlags = Sanitizer.sanitize(machineFlags);	Exceptions.propagate(e);	}	}	
created machines for jclouds byon location 

========================= brooklyn sample_2568 =========================

protected void confirmSensorEntitlement(boolean shouldSucceed) {	
confirmsensorentitlement still required 

========================= brooklyn sample_673 =========================

final List<MockItemEntity> items = new ArrayList<MockItemEntity>();	for (int i = 1; i <= numContainers; i++) {	MockContainerEntity container = newContainer(app, "container-"+i, lowThreshold, highThreshold);	containers.add(container);	}	for (int i = 1; i <= numItems; i++) {	MockItemEntity item = newItem(app, containers.get(0), "item-"+i, 5);	items.add(item);	}	for (int i = 1; i <= numCycles; i++) {	
cycle 

}	for (int i = 1; i <= numItems; i++) {	MockItemEntity item = newItem(app, containers.get(0), "item-"+i, 5);	items.add(item);	}	for (int i = 1; i <= numCycles; i++) {	for (int j = 1; j <= numItemStopsPerCycle; j++) {	int itemIndex = random.nextInt(numItems);	MockItemEntity itemToStop = items.get(itemIndex);	itemToStop.stop();	
unmanaging item 

}	final List<Integer> itemRates = randomlyDivideLoad(numItems, totalRate, 0, (int)highThreshold);	for (int j = 0; j < numItems; j++) {	MockItemEntity item = items.get(j);	item.sensors().set(MockItemEntity.TEST_METRIC, itemRates.get(j));	}	for (int j = 1; j <= numContainerStopsPerCycle; j++) {	int containerIndex = random.nextInt(numContainers);	MockContainerEntity containerToStop = containers.get(containerIndex);	containerToStop.offloadAndStop(containers.get((containerIndex+1)%numContainers));	
unmanaging container 

========================= brooklyn sample_3007 =========================

private ServerSocket connectToPort() throws Exception {	ServerSocket result = new ServerSocket(0);	
acquired port for test 

========================= brooklyn sample_1893 =========================

mgmt = newLocalManagementContext();	ownNodeId = mgmt.getManagementNodeId();	objectStore = new ListeningObjectStore(newPersistenceObjectStore());	objectStore.injectManagementContext(mgmt);	objectStore.prepareForSharedUse(PersistMode.CLEAN, HighAvailabilityMode.DISABLED);	persister = new ManagementPlaneSyncRecordPersisterToObjectStore(mgmt, objectStore, classLoader);	((ManagementPlaneSyncRecordPersisterToObjectStore)persister).preferRemoteTimestampInMemento();	BrooklynMementoPersisterToObjectStore persisterObj = new BrooklynMementoPersisterToObjectStore(objectStore, mgmt, classLoader);	mgmt.getRebindManager().setPersister(persisterObj, PersistenceExceptionHandlerImpl.builder().build());	ha = ((HighAvailabilityManagerImpl)mgmt.getHighAvailabilityManager()) .setPollPeriod(Duration.PRACTICALLY_FOREVER) .setHeartbeatTimeout(Duration.THIRTY_SECONDS) .setPersister(persister);	
created 

========================= brooklyn sample_624 =========================

for (Entity entity : elasticSearchCluster.getMembers()) {	ElasticSearchNode node = (ElasticSearchNode)entity;	String getBaseUri = "http: HttpToolResponse getResponse = HttpTool.execAndConsume( HttpTool.httpClientBuilder().build(), new HttpGet(getBaseUri + "/mydocuments/docs/1/_source"));	assertEquals(getResponse.getResponseCode(), 200);	assertEquals(HttpValueFunctions.jsonContents("foo", String.class).apply(getResponse), "bar");	}	Asserts.succeedsEventually(new Runnable() {	public void run() {	int count = clusterDocumentCount();	assertTrue(count >= 1, "count="+count);	
document count is 

========================= brooklyn sample_331 =========================

protected Entity createMysql() {	ChefLiveTestSupport.installBrooklynChefHostedConfig(app);	Entity mysql = app.createAndManageChild(DynamicToyMySqlEntityChef.specKnife());	
created 

========================= brooklyn sample_2180 =========================

public BrooklynUserWithRandomPasswordSecurityProvider() {	this.password = Identifiers.makeRandomId(10);	
allowing access to web console from localhost or with 

private boolean isRemoteAddressLocalhost(HttpSession session) {	Object remoteAddress = session.getAttribute(BrooklynWebConfig.REMOTE_ADDRESS_SESSION_ATTRIBUTE);	if (!(remoteAddress instanceof String)) return false;	if (Networking.isLocalhost((String)remoteAddress)) {	if (LOG.isTraceEnabled()) {	
granting passwordless access to originating from 

private boolean isRemoteAddressLocalhost(HttpSession session) {	Object remoteAddress = session.getAttribute(BrooklynWebConfig.REMOTE_ADDRESS_SESSION_ATTRIBUTE);	if (!(remoteAddress instanceof String)) return false;	if (Networking.isLocalhost((String)remoteAddress)) {	if (LOG.isTraceEnabled()) {	}	return true;	} else {	
password required for originating from 

========================= brooklyn sample_2883 =========================

protected void connectSensors() {	super.connectSensors();	Maybe<SshMachineLocation> machine = Locations.findUniqueSshMachineLocation(getLocations());	if (machine.isPresent()) {	String cmd = getDriver().getStatusCmd();	feed = SshFeed.builder() .entity(this) .period(config().get(SERVICE_PROCESS_IS_RUNNING_POLL_PERIOD)) .machine(machine.get()) .poll(new SshPollConfig<Boolean>(SERVICE_UP) .command(cmd) .setOnSuccess(true) .setOnFailureOrException(false)) .build();	} else {	
location s not an ssh machine location so not polling for status setting serviceup immediately 

========================= brooklyn sample_262 =========================

public void shutdown(final boolean stopAppsFirst, final boolean forceShutdownOnError, String shutdownTimeoutRaw, String requestTimeoutRaw, String delayForHttpReturnRaw, Long delayMillis) {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) throw WebResourceUtils.forbidden("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user());	log.info("REST call to shutdown server, stopAppsFirst="+stopAppsFirst+", delayForHttpReturn="+shutdownTimeoutRaw);	if (stopAppsFirst && !isMaster()) {	
rest call to shutdown non master server while stopping apps is disallowed 

log.info("REST call to shutdown server, stopAppsFirst="+stopAppsFirst+", delayForHttpReturn="+shutdownTimeoutRaw);	if (stopAppsFirst && !isMaster()) {	throw WebResourceUtils.forbidden("Not allowed to stop all apps when server is not master");	}	final Duration shutdownTimeout = parseDuration(shutdownTimeoutRaw, Duration.of(20, TimeUnit.SECONDS));	Duration requestTimeout = parseDuration(requestTimeoutRaw, Duration.of(20, TimeUnit.SECONDS));	final Duration delayForHttpReturn;	if (delayMillis == null) {	delayForHttpReturn = parseDuration(delayForHttpReturnRaw, Duration.FIVE_SECONDS);	} else {	
delaymillis is deprecated use delayforhttpreturn instead 

final ManagementContext mgmt = mgmt();	new Thread("shutdown") {	public void run() {	boolean terminateTried = false;	try {	if (stopAppsFirst) {	CountdownTimer shutdownTimeoutTimer = null;	if (!shutdownTimeout.equals(Duration.ZERO)) {	shutdownTimeoutTimer = shutdownTimeout.countdownTimer();	}	
stopping applications 

shutdownTimeoutTimer = shutdownTimeout.countdownTimer();	}	List<Task<?>> stoppers = new ArrayList<Task<?>>();	int allStoppableApps = 0;	for (Application app: mgmt.getApplications()) {	allStoppableApps++;	Lifecycle appState = app.getAttribute(Attributes.SERVICE_STATE_ACTUAL);	if (app instanceof StartableApplication && appState != Lifecycle.STOPPING) {	stoppers.add(Entities.invokeEffector(app, app, StartableApplication.STOP));	} else {	
app is already stopping will not stop second time will wait for original stop to complete 

List<Task<?>> stoppers = new ArrayList<Task<?>>();	int allStoppableApps = 0;	for (Application app: mgmt.getApplications()) {	allStoppableApps++;	Lifecycle appState = app.getAttribute(Attributes.SERVICE_STATE_ACTUAL);	if (app instanceof StartableApplication && appState != Lifecycle.STOPPING) {	stoppers.add(Entities.invokeEffector(app, app, StartableApplication.STOP));	} else {	}	}	
waiting for apps to stop of which stopped explicitly 

stoppers.add(Entities.invokeEffector(app, app, StartableApplication.STOP));	} else {	}	}	for (Task<?> t: stoppers) {	if (!waitAppShutdown(shutdownTimeoutTimer, t)) {	hasAppErrorsOrTimeout.set(true);	}	}	if (hasStoppableApps(mgmt)) {	
apps are still stopping wait for proper unmanage 

if (hasStoppableApps(mgmt)) {	hasAppErrorsOrTimeout.set(true);	}	}	}	terminateTried = true;	((ManagementContextInternal)mgmt).terminate();	} catch (Throwable e) {	Throwable interesting = Exceptions.getFirstInteresting(e);	if (interesting instanceof TimeoutException) {	
timeout shutting down 

if (hasStoppableApps(mgmt)) {	hasAppErrorsOrTimeout.set(true);	}	}	}	terminateTried = true;	((ManagementContextInternal)mgmt).terminate();	} catch (Throwable e) {	Throwable interesting = Exceptions.getFirstInteresting(e);	if (interesting instanceof TimeoutException) {	
timeout shutting down 

}	}	}	terminateTried = true;	((ManagementContextInternal)mgmt).terminate();	} catch (Throwable e) {	Throwable interesting = Exceptions.getFirstInteresting(e);	if (interesting instanceof TimeoutException) {	hasAppErrorsOrTimeout.set(true);	} else {	
unexpected error shutting down 

if (!terminateTried) {	mgmtInternal().terminate();	}	} finally {	complete();	if (!hasAppErrorsOrTimeout.get() || forceShutdownOnError) {	Time.sleep(delayForHttpReturn);	if (handler != null) {	handler.onShutdownRequest();	} else {	
shutdownhandler not set exiting process 

} finally {	complete();	if (!hasAppErrorsOrTimeout.get() || forceShutdownOnError) {	Time.sleep(delayForHttpReturn);	if (handler != null) {	handler.onShutdownRequest();	} else {	System.exit(0);	}	} else {	
abandoning shutdown because there were errors and shutdown was not forced 

}	} else {	}	}	}	private boolean hasStoppableApps(ManagementContext mgmt) {	for (Application app : mgmt.getApplications()) {	if (app instanceof StartableApplication) {	Lifecycle state = app.getAttribute(Attributes.SERVICE_STATE_ACTUAL);	if (state != Lifecycle.STOPPING && state != Lifecycle.STOPPED) {	
shutting down expecting all apps to be in stopping state but found application to be in state just started 

completed.notifyAll();	}	}	private boolean waitAppShutdown(CountdownTimer shutdownTimeoutTimer, Task<?> t) throws TimeoutException {	Duration waitInterval = null;	if (shutdownTimeoutTimer != null) {	waitInterval = Duration.of(SHUTDOWN_TIMEOUT_CHECK_INTERVAL, TimeUnit.MILLISECONDS);	}	while(!t.blockUntilEnded(waitInterval)) {	if (shutdownTimeoutTimer.isExpired()) {	
timeout while waiting for applications to stop at 

Duration waitInterval = null;	if (shutdownTimeoutTimer != null) {	waitInterval = Duration.of(SHUTDOWN_TIMEOUT_CHECK_INTERVAL, TimeUnit.MILLISECONDS);	}	while(!t.blockUntilEnded(waitInterval)) {	if (shutdownTimeoutTimer.isExpired()) {	throw new TimeoutException();	}	}	if (t.isError()) {	
error stopping application during shutdown ignoring 

public VersionSummary getVersion() {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SERVER_STATUS, null)) throw WebResourceUtils.forbidden("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user());	InputStream input = ResourceUtils.create(this).getResourceFromUrl("classpath: Properties properties = new Properties();	String gitSha1 = null, gitBranch = null;	try {	properties.load(input);	gitSha1 = properties.getProperty(BUILD_SHA_1_PROPERTY);	gitBranch = properties.getProperty(BUILD_BRANCH_PROPERTY);	} catch (IOException e) {	
failed to load build metadata properties 

PersistenceObjectStore targetStore = BrooklynPersistenceUtils.newPersistenceObjectStore(mgmt(), null, "tmp/web-persistence-"+label+"-"+Identifiers.makeRandomId(4));	dir = ((FileBasedObjectStore)targetStore).getBaseDir();	Os.deleteOnExitEmptyParentsUpTo(dir.getParentFile(), dir.getParentFile());	BrooklynPersistenceUtils.writeMemento(mgmt(), targetStore, preferredOrigin);	ByteArrayOutputStream baos = new ByteArrayOutputStream();	ArchiveBuilder.zip().addDirContentsAt( ((FileBasedObjectStore)targetStore).getBaseDir(), ((FileBasedObjectStore)targetStore).getBaseDir().getName() ).stream(baos);	Os.deleteRecursively(dir);	String filename = "brooklyn-state-"+label+".zip";	return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM_TYPE) .header("Content-Disposition","attachment; filename = "+filename) .build();	} catch (Exception e) {	
unable to serve persistence data rethrowing 

ByteArrayOutputStream baos = new ByteArrayOutputStream();	ArchiveBuilder.zip().addDirContentsAt( ((FileBasedObjectStore)targetStore).getBaseDir(), ((FileBasedObjectStore)targetStore).getBaseDir().getName() ).stream(baos);	Os.deleteRecursively(dir);	String filename = "brooklyn-state-"+label+".zip";	return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM_TYPE) .header("Content-Disposition","attachment; filename = "+filename) .build();	} catch (Exception e) {	if (dir!=null) {	try {	Os.deleteRecursively(dir);	} catch (Exception e2) {	
ignoring error deleting after another error throwing original error ignored error deleting is 

========================= brooklyn sample_2895 =========================

public void tearDown() throws Exception {	for (Application app : getManagementContext().getApplications()) {	try {	((StartableApplication) app).stop();	} catch (Exception e) {	
error stopping app during test teardown 

========================= brooklyn sample_3 =========================

public void init() {	super.init();	
initializing the riak cluster 

Duration delay = getConfig(DELAY_BEFORE_ADVERTISING_CLUSTER);	Tasks.setBlockingDetails("Sleeping for "+delay+" before advertising cluster available");	Time.sleep(delay);	} finally {	Tasks.resetBlockingDetails();	}	Optional<Entity> anyNode = Iterables.tryFind(getMembers(), Predicates.and( Predicates.instanceOf(RiakNode.class), EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true), EntityPredicates.attributeEqualTo(RiakNode.SERVICE_UP, true)));	if (anyNode.isPresent()) {	sensors().set(IS_CLUSTER_INIT, true);	} else {	
no riak nodes are found on the cluster initialization failed 

protected void onServerPoolMemberChanged(final Entity member) {	synchronized (mutex) {	
for considering membership of which is in locations 

nodes = Maps.newLinkedHashMap();	}	String riakName = getRiakName(member);	Preconditions.checkNotNull(riakName);	Boolean firstNode = getAttribute(IS_FIRST_NODE_SET);	if (!Boolean.TRUE.equals(firstNode)) {	sensors().set(IS_FIRST_NODE_SET, Boolean.TRUE);	nodes.put(member, riakName);	sensors().set(RIAK_CLUSTER_NODES, nodes);	((EntityInternal) member).sensors().set(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.TRUE);	
added initial riak node to new cluster 

sensors().set(RIAK_CLUSTER_NODES, nodes);	((EntityInternal) member).sensors().set(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.TRUE);	} else {	Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), Predicates.and( Predicates.instanceOf(RiakNode.class), EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true)));	if (anyNodeInCluster.isPresent()) {	if (!nodes.containsKey(member) && member.getAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER) == null) {	String anyNodeName = anyNodeInCluster.get().getAttribute(RiakNode.RIAK_NODE_NAME);	Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, anyNodeName).blockUntilEnded();	nodes.put(member, riakName);	sensors().set(RIAK_CLUSTER_NODES, nodes);	
added riak node to cluster 

} else {	Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), Predicates.and( Predicates.instanceOf(RiakNode.class), EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true)));	if (anyNodeInCluster.isPresent()) {	if (!nodes.containsKey(member) && member.getAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER) == null) {	String anyNodeName = anyNodeInCluster.get().getAttribute(RiakNode.RIAK_NODE_NAME);	Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, anyNodeName).blockUntilEnded();	nodes.put(member, riakName);	sensors().set(RIAK_CLUSTER_NODES, nodes);	}	} else {	
isfirstnodeset but no cluster members found to add 

}	} else {	if (nodes != null && nodes.containsKey(member)) {	DependentConfiguration.attributeWhenReady(member, RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Predicates.equalTo(false)).blockUntilEnded(Duration.TWO_MINUTES);	Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), Predicates.and( EntityPredicates.isManaged(), Predicates.instanceOf(RiakNode.class), EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true), Predicates.not(Predicates.equalTo(member))));	if (anyNodeInCluster.isPresent()) {	Entities.invokeEffectorWithArgs(this, anyNodeInCluster.get(), RiakNode.REMOVE_FROM_CLUSTER, getRiakName(member)).blockUntilEnded();	}	nodes.remove(member);	sensors().set(RIAK_CLUSTER_NODES, nodes);	
removed riak node from cluster 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	
members of checking eliminating because not up 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getMembers().contains(member)) {	
members of checking eliminating because not member 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getMembers().contains(member)) {	return false;	}	
members of checking approving 

========================= brooklyn sample_409 =========================

public void changeMode(HighAvailabilityMode startMode, boolean preventElectionOnExplicitStandbyMode, boolean failOnExplicitModesIfUnusual) {	if (!running) {	
ha changing mode to from when not running forcing an intermediate start as disabled then will convert to 

setInternalNodeState(ManagementNodeState.STANDBY);	startMode = HighAvailabilityMode.HOT_BACKUP;	case HOT_STANDBY: case STANDBY: if (getInternalNodeState()==ManagementNodeState.STANDBY && oldState==ManagementNodeState.INITIALIZING && startMode!=HighAvailabilityMode.HOT_BACKUP && BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_DEFAULT_STANDBY_IS_HOT_PROPERTY)) {	startMode = HighAvailabilityMode.HOT_STANDBY;	}	ManagementPlaneSyncRecord newState = loadManagementPlaneSyncRecord(true);	String masterNodeId = newState.getMasterNodeId();	ManagementNodeSyncRecord masterNodeDetails = newState.getManagementNodes().get(masterNodeId);	LOG.info("Management node "+ownNodeId+" in "+managementContext.getManagementPlaneIdMaybe().or("<new-plane>")+" running as HA " + getInternalNodeState() + " autodetected" + (startMode == HighAvailabilityMode.HOT_STANDBY || startMode == HighAvailabilityMode.HOT_BACKUP ? " (will change to "+startMode+")" : "") + ", " + (Strings.isBlank(masterNodeId) ? "no master currently (other node should promote itself soon)" : "master " + (existingMaster==null ? "(new) " : "") + "is "+masterNodeId + (masterNodeDetails==null || masterNodeDetails.getUri()==null ? " (no url)" : " at "+masterNodeDetails.getUri())));	break;	
management node in new plane running as ha master autodetected 

ManagementNodeSyncRecord masterNodeDetails = newState.getManagementNodes().get(masterNodeId);	LOG.info("Management node "+ownNodeId+" in "+managementContext.getManagementPlaneIdMaybe().or("<new-plane>")+" running as HA " + getInternalNodeState() + " autodetected" + (startMode == HighAvailabilityMode.HOT_STANDBY || startMode == HighAvailabilityMode.HOT_BACKUP ? " (will change to "+startMode+")" : "") + ", " + (Strings.isBlank(masterNodeId) ? "no master currently (other node should promote itself soon)" : "master " + (existingMaster==null ? "(new) " : "") + "is "+masterNodeId + (masterNodeDetails==null || masterNodeDetails.getUri()==null ? " (no url)" : " at "+masterNodeDetails.getUri())));	break;	break;	default: throw new IllegalStateException("Management node "+ownNodeId+" in "+managementContext.getManagementPlaneIdMaybe().or("<new-plane>")+" set to HA AUTO, encountered unexpected mode "+getInternalNodeState());	}	break;	case MASTER: if (!failOnExplicitModesIfUnusual || existingMaster==null) {	promoteToMaster();	if (existingMaster!=null) {	
management node in new plane running as ha master explicitly 

LOG.info("Management node "+ownNodeId+" in "+managementContext.getManagementPlaneIdMaybe().or("<new-plane>")+" running as HA " + getInternalNodeState() + " autodetected" + (startMode == HighAvailabilityMode.HOT_STANDBY || startMode == HighAvailabilityMode.HOT_BACKUP ? " (will change to "+startMode+")" : "") + ", " + (Strings.isBlank(masterNodeId) ? "no master currently (other node should promote itself soon)" : "master " + (existingMaster==null ? "(new) " : "") + "is "+masterNodeId + (masterNodeDetails==null || masterNodeDetails.getUri()==null ? " (no url)" : " at "+masterNodeDetails.getUri())));	break;	break;	default: throw new IllegalStateException("Management node "+ownNodeId+" in "+managementContext.getManagementPlaneIdMaybe().or("<new-plane>")+" set to HA AUTO, encountered unexpected mode "+getInternalNodeState());	}	break;	case MASTER: if (!failOnExplicitModesIfUnusual || existingMaster==null) {	promoteToMaster();	if (existingMaster!=null) {	} else {	
management node in new plane running as ha master explicitly stealing from 

}	break;	case MASTER: if (!failOnExplicitModesIfUnusual || existingMaster==null) {	promoteToMaster();	if (existingMaster!=null) {	} else {	}	} else if (!weAreRecognisedAsMaster) {	throw new IllegalStateException("Master already exists; cannot run as master (master "+existingMaster.toVerboseString()+"); " + "to trigger a promotion, set a priority and demote the current master");	} else {	
management node in new plane already running as ha master when set explicitly 

setInternalNodeState(ManagementNodeState.HOT_STANDBY);	} else {	setInternalNodeState(ManagementNodeState.STANDBY);	}	}	if (ManagementNodeState.isStandby(getInternalNodeState())) {	if (!preventElectionOnExplicitStandbyMode) {	publishAndCheck(true);	}	if (failOnExplicitModesIfUnusual && existingMaster==null) {	
management node in new plane detected no master when requested and existing master required failing 

ManagementPlaneSyncRecord newState = loadManagementPlaneSyncRecord(true);	if (Strings.isBlank(newState.getMasterNodeId())) {	message += "); no master currently";	if (startMode != HighAvailabilityMode.HOT_BACKUP) message += " (subsequent election may repair)";	} else {	message += "); master "+newState.getMasterNodeId();	}	}	LOG.info(message);	break;	
management node in new plane ha disabled was 

if (!ManagementNodeState.isHotProxy(oldState)) {	nodeStateTransitionComplete = false;	if (startMode==HighAvailabilityMode.HOT_STANDBY) {	publishHealth();	}	try {	activateHotProxy(ManagementNodeState.of(startMode).get()).get();	nodeStateTransitionComplete = true;	publishHealth();	if (getNodeState()==ManagementNodeState.HOT_STANDBY || getNodeState()==ManagementNodeState.HOT_BACKUP) {	
management node in new plane now running as ha application loaded 

nodeStateTransitionComplete = false;	if (startMode==HighAvailabilityMode.HOT_STANDBY) {	publishHealth();	}	try {	activateHotProxy(ManagementNodeState.of(startMode).get()).get();	nodeStateTransitionComplete = true;	publishHealth();	if (getNodeState()==ManagementNodeState.HOT_STANDBY || getNodeState()==ManagementNodeState.HOT_BACKUP) {	} else {	
management node in new plane unable to promote to currently see log for further details 

publishHealth();	}	try {	activateHotProxy(ManagementNodeState.of(startMode).get()).get();	nodeStateTransitionComplete = true;	publishHealth();	if (getNodeState()==ManagementNodeState.HOT_STANDBY || getNodeState()==ManagementNodeState.HOT_BACKUP) {	} else {	}	} catch (Exception e) {	
management node in new plane unable to promote to currently rethrowing 

public void stop() {	
stopping 

private void stop(ManagementNodeState newState) {	boolean wasRunning = running;	running = false;	setInternalNodeState(newState);	if (pollingTask != null) pollingTask.cancel(true);	if (wasRunning) {	try {	publishHealth();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem publishing manager node health on termination continuing 

protected void registerPollTask() {	final Runnable job = new Runnable() {	private boolean lastFailed;	try {	publishAndCheck(false);	lastFailed = false;	} catch (Exception e) {	if (running) {	if (lastFailed) {	
recurring problem in ha poller 

protected void registerPollTask() {	final Runnable job = new Runnable() {	private boolean lastFailed;	try {	publishAndCheck(false);	lastFailed = false;	} catch (Exception e) {	if (running) {	if (lastFailed) {	} else {	
problem in ha poller 

try {	publishAndCheck(false);	lastFailed = false;	} catch (Exception e) {	if (running) {	if (lastFailed) {	} else {	lastFailed = true;	}	} else {	
problem in ha poller but no longer running 

lastFailed = false;	} catch (Exception e) {	if (running) {	if (lastFailed) {	} else {	lastFailed = true;	}	} else {	}	} catch (Throwable t) {	
problem in ha poller 

protected synchronized void publishHealth() {	if (persister == null) {	
cannot publish management node health as no persister 

protected synchronized void publishHealth() {	if (persister == null) {	return;	}	Stopwatch timer = Stopwatch.createStarted();	try {	ManagementNodeSyncRecord memento = createManagementNodeSyncRecord(false);	Delta delta = ManagementPlaneSyncRecordDeltaImpl.builder().node(memento).build();	persister.delta(delta);	managementStateWritePersistenceMetrics.noteSuccess(Duration.of(timer));	
published management node health 

}	Stopwatch timer = Stopwatch.createStarted();	try {	ManagementNodeSyncRecord memento = createManagementNodeSyncRecord(false);	Delta delta = ManagementPlaneSyncRecordDeltaImpl.builder().node(memento).build();	persister.delta(delta);	managementStateWritePersistenceMetrics.noteSuccess(Duration.of(timer));	} catch (Throwable t) {	managementStateWritePersistenceMetrics.noteFailure(Duration.of(timer));	managementStateWritePersistenceMetrics.noteError(t.toString());	
error publishing management node health rethrowing 

public void publishClearNonMaster() {	ManagementPlaneSyncRecord plane = getLastManagementPlaneSyncRecord();	if (plane==null || persister==null) {	
cannot clear ha node records ha not active or not yet loaded 

protected synchronized void publishDemotion(boolean demotingFromMaster) {	checkState(getNodeState() != ManagementNodeState.MASTER, "node status must not be master when demoting", getNodeState());	if (persister == null) {	
cannot publish management node health as no persister 

if (persister == null) {	return;	}	ManagementNodeSyncRecord memento = createManagementNodeSyncRecord(false);	ManagementPlaneSyncRecordDeltaImpl.Builder deltaBuilder = ManagementPlaneSyncRecordDeltaImpl.builder() .node(memento);	if (demotingFromMaster) {	deltaBuilder.clearMaster(ownNodeId);	}	Delta delta = deltaBuilder.build();	persister.delta(delta);	
published management node health 

protected synchronized void publishPromotionToMaster() {	checkState(getNodeState() == ManagementNodeState.MASTER, "node status must be master on publish, but is %s", getNodeState());	if (persister == null) {	
cannot publish management node health as no persister 

protected synchronized void publishPromotionToMaster() {	checkState(getNodeState() == ManagementNodeState.MASTER, "node status must be master on publish, but is %s", getNodeState());	if (persister == null) {	return;	}	ManagementNodeSyncRecord memento = createManagementNodeSyncRecord(false);	Delta delta = ManagementPlaneSyncRecordDeltaImpl.builder() .node(memento) .setMaster(ownNodeId) .build();	persister.delta(delta);	
published management node health 

ManagementNodeSyncRecord currMasterNodeRecord = memento.getManagementNodes().get(currMasterNodeId);	ManagementNodeSyncRecord ownNodeRecord = memento.getManagementNodes().get(ownNodeId);	ManagementNodeSyncRecord newMasterNodeRecord = null;	boolean demotingSelfInFavourOfOtherMaster = false;	if (currMasterNodeRecord != null && currMasterNodeRecord.getStatus() == ManagementNodeState.MASTER && isHeartbeatOk(currMasterNodeRecord, ownNodeRecord)) {	if (ownNodeId.equals(currMasterNodeId)) {	if (LOG.isTraceEnabled()) LOG.trace("Existing master healthy (us): master={}", currMasterNodeRecord.toVerboseString());	return;	} else {	if (ownNodeRecord!=null && ownNodeRecord.getStatus() == ManagementNodeState.MASTER) {	
management node detected master change stolen from us deferring to 

if (ownNodeRecord!=null && ownNodeRecord.getStatus() == ManagementNodeState.MASTER) {	newMasterNodeRecord = currMasterNodeRecord;	demotingSelfInFavourOfOtherMaster = true;	} else {	if (LOG.isTraceEnabled()) LOG.trace("Existing master healthy (remote): master={}", currMasterNodeRecord.toVerboseString());	return;	}	}	} else if (ownNodeRecord == null || !isHeartbeatOk(ownNodeRecord, ownNodeRecord)) {	if (ownNodeRecord == null) {	
no management node memento for self perhaps persister unwritable master reported failed but no op as cannot tell conclusively 

if (ownNodeRecord == null) {	} else {	LOG.error("This management node ("+ownNodeId+") memento heartbeats out-of-date; perhaps perister unwritable? " + "Master ("+currMasterNodeId+") reported failed but no-op as cannot tell conclusively" + ": self="+ownNodeRecord.toVerboseString());	}	return;	} else if (ownNodeId.equals(currMasterNodeId)) {	LOG.warn("This management node ("+ownNodeId+") supposed to be master but reportedly unhealthy? " + "no-op as expect other node to fix: self="+ownNodeRecord.toVerboseString());	return;	}	if (demotingSelfInFavourOfOtherMaster) {	
master change for this node only demoting in favour of official master 

}	return;	} else if (ownNodeId.equals(currMasterNodeId)) {	LOG.warn("This management node ("+ownNodeId+") supposed to be master but reportedly unhealthy? " + "no-op as expect other node to fix: self="+ownNodeRecord.toVerboseString());	return;	}	if (demotingSelfInFavourOfOtherMaster) {	demoteTo( BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_DEFAULT_STANDBY_IS_HOT_PROPERTY) ? ManagementNodeState.HOT_STANDBY : ManagementNodeState.STANDBY);	return;	} else {	
detected master heartbeat timeout initiating a new master election master was 

protected void promoteToMaster() {	if (!running) {	
ignoring promote to master request as highavailabilitymanager is not running 

protected void promoteToMaster() {	if (!running) {	return;	}	if (promotionListener != null) {	try {	promotionListener.promotingToMaster();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem in promption listener continuing 

promotionListener.promotingToMaster();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	}	}	setInternalNodeState(ManagementNodeState.MASTER);	publishPromotionToMaster();	try {	managementContext.getRebindManager().rebind(managementContext.getCatalogClassLoader(), null, getInternalNodeState());	} catch (Exception e) {	
management node enountered problem during rebind when promoting self to master demoting to failed and rethrowing 

protected void demoteTo(ManagementNodeState toState) {	if (toState!=ManagementNodeState.FAILED && !running) {	
ignoring demote from master request as highavailabilitymanager is no longer running 

protected ReferenceWithError<Boolean> activateHotProxy(ManagementNodeState toState) {	try {	Preconditions.checkState(nodeStateTransitionComplete==false, "Must be in transitioning state to go into "+toState);	setInternalNodeState(toState);	managementContext.getRebindManager().startReadOnly(toState);	return ReferenceWithError.newInstanceWithoutError(true);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to change to switching to failed 

private ManagementPlaneSyncRecord loadManagementPlaneSyncRecordInternal(boolean useLocalKnowledgeForThisNode) {	if (disabled) {	Builder builder = ManagementPlaneSyncRecordImpl.builder() .planeId(managementContext.getManagementPlaneIdMaybe().orNull()) .node(createManagementNodeSyncRecord(true));	if (getTransitionTargetNodeState() == ManagementNodeState.MASTER) {	builder.masterNodeId(ownNodeId);	}	return builder.build();	}	if (persister == null) {	
high availablity manager has no persister returning empty record 

}	result = builder.build();	}	if (i>0) {	managementStateReadPersistenceMetrics.noteError("Succeeded only on attempt "+(i+1)+": "+lastException);	}	managementStateReadPersistenceMetrics.noteSuccess(Duration.of(timer));	return result;	} catch (IOException e) {	if (i < (maxLoadAttempts - 1)) {	
problem loading mangement plane memento attempt retrying 

========================= brooklyn sample_1094 =========================

private void sequence() {	Integer increment = config().get(SEQUENCE_INCREMENT);	AtomicInteger state = sensors().get(SEQUENCE_STATE);	Integer current = state.addAndGet(increment);	sensors().set(SEQUENCE_VALUE, current);	
sequence for set to 

========================= brooklyn sample_1581 =========================

public void onItemMoved(ItemType item, ContainerType newNode) {	if (!itemToContainer.containsKey(item)) {	
balanceable pool model ignoring onitemmoved for unknown item to container if onitemadded subsequently received will get new container then 

public void onContainerAdded(ContainerType newContainer, double lowThreshold, double highThreshold) {	boolean added = containers.add(newContainer);	if (!added) {	
duplicate container added event for ignoring 

public void onItemWorkrateUpdated(ItemType item, double newValue) {	if (hasItem(item)) {	Double oldValue = itemToWorkrate.put(item, newValue);	double delta = ( newValue - (oldValue != null ? oldValue : 0) );	currentPoolWorkrate += delta;	} else {	
ignoring setting of workrate for unknown item to 

========================= brooklyn sample_3046 =========================

public void tearDown() throws Exception {	try {	if (app != null) {	app.stop();	}	} catch (Exception e) {	
error stopping app continuing with shutdown 

private SecurityGroup createTestGroup(String securityGroupName, SecurityGroupEditor editor) {	
creating security group in 

========================= brooklyn sample_2207 =========================

protected void addShards() {	MongoDBRouter router = getParent().getAttribute(MongoDBShardedDeployment.ROUTER_CLUSTER).getAttribute(MongoDBRouterCluster.ANY_RUNNING_ROUTER);	if (router == null) {	
not adding shards because no running router in 

protected void addShards() {	MongoDBRouter router = getParent().getAttribute(MongoDBShardedDeployment.ROUTER_CLUSTER).getAttribute(MongoDBRouterCluster.ANY_RUNNING_ROUTER);	if (router == null) {	return;	}	for (Entity member : this.getMembers()) {	if (member.getAttribute(Startable.SERVICE_UP) && !addingMembers.contains(member)) {	
adding shard 

protected void addShardAsync(final Entity replicaSet) {	final Duration timeout = Duration.minutes(20);	final Stopwatch stopwatch = Stopwatch.createStarted();	final AtomicInteger attempts = new AtomicInteger();	executor.submit(new Runnable() {	public void run() {	boolean reschedule;	MongoDBRouter router = getParent().getAttribute(MongoDBShardedDeployment.ROUTER_CLUSTER).getAttribute(MongoDBRouterCluster.ANY_RUNNING_ROUTER);	if (router == null) {	
rescheduling adding shard because no running router for cluster 

} catch (UnknownHostException e) {	throw Exceptions.propagate(e);	}	try {	MongoDBServer primary = replicaSet.getAttribute(MongoDBReplicaSet.PRIMARY_ENTITY);	if (primary != null) {	String addr = String.format("%s:%d", primary.getAttribute(MongoDBServer.SUBNET_HOSTNAME), primary.getAttribute(MongoDBServer.PORT));	String replicaSetURL = ((MongoDBReplicaSet) replicaSet).getName() + "/" + addr;	boolean added = client.addShardToRouter(replicaSetURL);	if (added) {	
added shard via 

try {	MongoDBServer primary = replicaSet.getAttribute(MongoDBReplicaSet.PRIMARY_ENTITY);	if (primary != null) {	String addr = String.format("%s:%d", primary.getAttribute(MongoDBServer.SUBNET_HOSTNAME), primary.getAttribute(MongoDBServer.PORT));	String replicaSetURL = ((MongoDBReplicaSet) replicaSet).getName() + "/" + addr;	boolean added = client.addShardToRouter(replicaSetURL);	if (added) {	addedMembers.add(replicaSet);	reschedule = false;	} else {	
rescheduling addition of shard because add failed via router 

String addr = String.format("%s:%d", primary.getAttribute(MongoDBServer.SUBNET_HOSTNAME), primary.getAttribute(MongoDBServer.PORT));	String replicaSetURL = ((MongoDBReplicaSet) replicaSet).getName() + "/" + addr;	boolean added = client.addShardToRouter(replicaSetURL);	if (added) {	addedMembers.add(replicaSet);	reschedule = false;	} else {	reschedule = true;	}	} else {	
rescheduling addition of shard because primary is null 

if (added) {	addedMembers.add(replicaSet);	reschedule = false;	} else {	reschedule = true;	}	} else {	reschedule = true;	}	} catch (Exception e) {	
failed to add shard to router 

}	} catch (Exception e) {	throw Exceptions.propagate(e);	}	}	if (reschedule) {	int numAttempts = attempts.incrementAndGet();	if (numAttempts > 1 && timeout.toMilliseconds() > stopwatch.elapsed(TimeUnit.MILLISECONDS)) {	executor.schedule(this, 3, TimeUnit.SECONDS);	} else {	
timeout after attempts adding shard aborting 

========================= brooklyn sample_370 =========================

public ProcessTool(Map<String,?> flags) {	super(getOptionalVal(flags, PROP_LOCAL_TEMP_DIR));	if (flags!=null) {	MutableMap<String, Object> flags2 = MutableMap.copyOf(flags);	flags2.remove(PROP_LOCAL_TEMP_DIR.getName());	
ignoring unsupported constructor flags 

public int execScript(final Map<String,?> props, final List<String> commands, final Map<String,?> env) {	return new ToolAbstractExecScript(props) {	public int run() {	try {	String directory = getOptionalVal(props, PROP_DIRECTORY);	File directoryDir = (directory != null) ? new File(Os.tidyPath(directory)) : null;	String scriptContents = toScript(props, commands, env);	
running shell process process as script 

throw new IllegalArgumentException("Cannot exec non-blocking: command="+commands);	}	OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);	OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);	String separator = getOptionalVal(props, PROP_SEPARATOR);	String directory = getOptionalVal(props, PROP_DIRECTORY);	File directoryDir = (directory != null) ? new File(Os.tidyPath(directory)) : null;	List<String> allcmds = toCommandSequence(commands, null);	String singlecmd = Joiner.on(separator).join(allcmds);	if (Boolean.TRUE.equals(getOptionalVal(props, PROP_RUN_AS_ROOT))) {	
cannot run as root when executing as command run as a script instead will run as normal user 

}	OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);	OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);	String separator = getOptionalVal(props, PROP_SEPARATOR);	String directory = getOptionalVal(props, PROP_DIRECTORY);	File directoryDir = (directory != null) ? new File(Os.tidyPath(directory)) : null;	List<String> allcmds = toCommandSequence(commands, null);	String singlecmd = Joiner.on(separator).join(allcmds);	if (Boolean.TRUE.equals(getOptionalVal(props, PROP_RUN_AS_ROOT))) {	}	
running shell command process 

========================= brooklyn sample_1450 =========================

public void onShutdownRequest() {	
shutting down server when running in rest api dev mode using background thread 

public void onShutdownRequest() {	new Thread(new Runnable() {	public void run() {	Time.sleep(Duration.millis(250));	
shutting down server in background thread closing and 

public void onShutdownRequest() {	new Thread(new Runnable() {	public void run() {	Time.sleep(Duration.millis(250));	if (server!=null) {	try {	server.stop();	server.join();	} catch (Exception e) {	
stopping server gave an error not usually a concern 

========================= brooklyn sample_2786 =========================

protected void finalize() throws Throwable {	if (!committed.get()) {	
transaction was never applied 

========================= brooklyn sample_1846 =========================

public static void main(String... args) {	
launching brooklyn via cli with 

public Void call() throws Exception {	super.call();	BrooklynLauncher launcher;	AppShutdownHandler shutdownHandler = new AppShutdownHandler();	failIfArguments();	try {	
invoked launch command 

stdout.println("Launching brooklyn server (no app)");	}	}	PersistMode persistMode = computePersistMode();	HighAvailabilityMode highAvailabilityMode = computeHighAvailabilityMode(persistMode);	StopWhichAppsOnShutdown stopWhichAppsOnShutdownMode = computeStopWhichAppsOnShutdown();	computeLocations();	ResourceUtils utils = ResourceUtils.create(this);	GroovyClassLoader loader = new GroovyClassLoader(getClass().getClassLoader());	if (script != null) {	
use of script for groovy script execution is deprecated 

throw e;	} catch (Exception e) {	throw new FatalConfigurationRuntimeException("Fatal error configuring Brooklyn launch: "+e.getMessage(), e);	}	try {	launcher.start();	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error launching brooklyn 

}	try {	launcher.start();	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	try {	launcher.terminate();	} catch (Exception e2) {	
subsequent error during termination 

}	try {	launcher.start();	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	try {	launcher.terminate();	} catch (Exception e2) {	
details of subsequent error during termination 

protected void computeLocations() {	boolean hasLocations = !Strings.isBlank(locations);	if (app != null) {	if (hasLocations && isYamlApp()) {	
yaml app combined with command line locations yaml locations will take precedence this behaviour may change in subsequent versions 

protected void computeLocations() {	boolean hasLocations = !Strings.isBlank(locations);	if (app != null) {	if (hasLocations && isYamlApp()) {	} else if (!hasLocations && isYamlApp()) {	
no locations supplied defaulting to locations defined in yaml if any 

protected void computeLocations() {	boolean hasLocations = !Strings.isBlank(locations);	if (app != null) {	if (hasLocations && isYamlApp()) {	} else if (!hasLocations && isYamlApp()) {	} else if (!hasLocations) {	
no locations supplied starting with no locations 

protected void computeLocations() {	boolean hasLocations = !Strings.isBlank(locations);	if (app != null) {	if (hasLocations && isYamlApp()) {	} else if (!hasLocations && isYamlApp()) {	} else if (!hasLocations) {	}	} else if (hasLocations) {	
locations specified without any applications ignoring locations 

protected BrooklynLauncher createLauncher() {	BrooklynLauncher launcher;	launcher = BrooklynLauncher.newInstance();	launcher.localBrooklynPropertiesFile(localBrooklynProperties) .ignorePersistenceErrors(!startupFailOnPersistenceErrors) .ignoreCatalogErrors(!startupFailOnCatalogErrors) .ignoreWebErrors(startupContinueOnWebErrors) .ignoreAppErrors(!startupFailOnManagedAppsErrors) .locations(Strings.isBlank(locations) ? ImmutableList.<String>of() : JavaStringEscapes.unwrapJsonishListIfPossible(locations));	launcher.webconsole(!noConsole);	if (useHttps) {	launcher.webconsoleHttps(useHttps);	}	launcher.webconsolePort(port);	if (noGlobalBrooklynProperties) {	
configuring to disable global brooklyn properties 

launcher.localBrooklynPropertiesFile(localBrooklynProperties) .ignorePersistenceErrors(!startupFailOnPersistenceErrors) .ignoreCatalogErrors(!startupFailOnCatalogErrors) .ignoreWebErrors(startupContinueOnWebErrors) .ignoreAppErrors(!startupFailOnManagedAppsErrors) .locations(Strings.isBlank(locations) ? ImmutableList.<String>of() : JavaStringEscapes.unwrapJsonishListIfPossible(locations));	launcher.webconsole(!noConsole);	if (useHttps) {	launcher.webconsoleHttps(useHttps);	}	launcher.webconsolePort(port);	if (noGlobalBrooklynProperties) {	launcher.globalBrooklynPropertiesFile(null);	}	if (noConsoleSecurity) {	
configuring to disable console security 

launcher.webconsoleHttps(useHttps);	}	launcher.webconsolePort(port);	if (noGlobalBrooklynProperties) {	launcher.globalBrooklynPropertiesFile(null);	}	if (noConsoleSecurity) {	launcher.installSecurityFilter(false);	}	if (startBrooklynNode) {	
configuring brooklynnode entity startup 

if (noGlobalBrooklynProperties) {	launcher.globalBrooklynPropertiesFile(null);	}	if (noConsoleSecurity) {	launcher.installSecurityFilter(false);	}	if (startBrooklynNode) {	launcher.startBrooklynNode(true);	}	if (Strings.isNonEmpty(bindAddress)) {	
configuring bind address as 

if (noConsoleSecurity) {	launcher.installSecurityFilter(false);	}	if (startBrooklynNode) {	launcher.startBrooklynNode(true);	}	if (Strings.isNonEmpty(bindAddress)) {	launcher.bindAddress(Networking.getInetAddressWithFixedName(bindAddress));	}	if (Strings.isNonEmpty(publicAddress)) {	
configuring public address as 

if (startBrooklynNode) {	launcher.startBrooklynNode(true);	}	if (Strings.isNonEmpty(bindAddress)) {	launcher.bindAddress(Networking.getInetAddressWithFixedName(bindAddress));	}	if (Strings.isNonEmpty(publicAddress)) {	launcher.publicAddress(Networking.getInetAddressWithFixedName(publicAddress));	}	if (explicitManagementContext!=null) {	
configuring explicit management context 

protected void computeAndSetApp(BrooklynLauncher launcher, ResourceUtils utils, GroovyClassLoader loader) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {	if (app != null) {	
loading the user s application 

protected void computeAndSetApp(BrooklynLauncher launcher, ResourceUtils utils, GroovyClassLoader loader) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {	if (app != null) {	if (isYamlApp()) {	
loading application as yaml spec 

protected void waitAfterLaunch(ManagementContext ctx, AppShutdownHandler shutdownHandler) throws IOException {	if (stopOnKeyPress) {	
server started press return to stop 

readTask.get(Duration.ONE_SECOND);	break;	} catch (TimeoutException e) {	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	throw Exceptions.propagate(e);	} catch (ExecutionException e) {	throw Exceptions.propagate(e);	}	}	
shutting down applications 

} catch (TimeoutException e) {	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	throw Exceptions.propagate(e);	} catch (ExecutionException e) {	throw Exceptions.propagate(e);	}	}	stopAllApps(ctx.getApplications());	} else {	
launched brooklyn will now block until shutdown command received via gui api recommended or process interrupt 

protected void execGroovyScript(ResourceUtils utils, GroovyClassLoader loader, String script) {	
running the user provided script 

protected EntitySpec<? extends Application> loadApplicationFromClasspathOrParse(ResourceUtils utils, GroovyClassLoader loader, String app) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {	Class<?> clazz;	
loading application as class on classpath 

protected void stopAllApps(Collection<? extends Application> applications) {	for (Application application : applications) {	try {	if (application instanceof Startable) {	((Startable)application).stop();	}	} catch (Exception e) {	
error stopping 

public Void call() throws Exception {	checkNotNull(destinationDir, "destinationDir");	BrooklynLauncher launcher;	failIfArguments();	try {	
retrieving and copying persisted state to with orphaned state deleted 

throw e;	} catch (Exception e) {	throw new FatalConfigurationRuntimeException("Fatal error configuring Brooklyn launch: "+e.getMessage(), e);	}	try {	launcher.cleanOrphanedState(destinationDir, destinationLocation);	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error retrieving persisted state 

launcher.cleanOrphanedState(destinationDir, destinationLocation);	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	Exceptions.propagate(e);	} finally {	try {	launcher.terminate();	} catch (Exception e2) {	
subsequent error during termination 

launcher.cleanOrphanedState(destinationDir, destinationLocation);	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	Exceptions.propagate(e);	} finally {	try {	launcher.terminate();	} catch (Exception e2) {	
details of subsequent error during termination 

public Void call() throws Exception {	checkNotNull(destinationDir, "destinationDir");	BrooklynLauncher launcher;	failIfArguments();	try {	
retrieving and copying persisted state to 

throw e;	} catch (Exception e) {	throw new FatalConfigurationRuntimeException("Fatal error configuring Brooklyn launch: "+e.getMessage(), e);	}	try {	launcher.copyPersistedState(destinationDir, destinationLocation, loadTransformer(transformations));	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error retrieving persisted state 

launcher.copyPersistedState(destinationDir, destinationLocation, loadTransformer(transformations));	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	Exceptions.propagate(e);	} finally {	try {	launcher.terminate();	} catch (Exception e2) {	
subsequent error during termination 

launcher.copyPersistedState(destinationDir, destinationLocation, loadTransformer(transformations));	} catch (FatalRuntimeException e) {	throw e;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	Exceptions.propagate(e);	} finally {	try {	launcher.terminate();	} catch (Exception e2) {	
details of subsequent error during termination 

========================= brooklyn sample_2769 =========================

public KnifeConvergeTaskFactory<RET> knifePort(int port) {	if (portOmittedToUseKnifeDefault!=null) {	
port specified to for when already explicitly told to use a default overriding previous see subsequent warning for more details 

public KnifeConvergeTaskFactory<RET> knifePortUseKnifeDefault() {	if (port!=null) {	
knifeportuseknifedefault specified to when already told to use explicitly overriding previous see subsequent warning for more details 

public KnifeConvergeTaskFactory<RET> knifePortUseMachineSshPort() {	if (port!=null) {	
knifeportusemachinesshport specified to when already told to use explicitly overriding previous see subsequent warning for more details 

protected Integer knifeWhichPort(HostAndPort hostAndPort) {	if (port==null) {	if (Boolean.TRUE.equals(portOmittedToUseKnifeDefault)) return null;	return hostAndPort.getPort();	}	if (port==-1) {	port = null;	Integer whichPort = knifeWhichPort(hostAndPort);	
knife port conflicting instructions for at entity on using default 

if (port==null) {	if (Boolean.TRUE.equals(portOmittedToUseKnifeDefault)) return null;	return hostAndPort.getPort();	}	if (port==-1) {	port = null;	Integer whichPort = knifeWhichPort(hostAndPort);	return whichPort;	}	if (portOmittedToUseKnifeDefault!=null) {	
knife port conflicting instructions for at entity on using supplied port 

========================= brooklyn sample_2293 =========================

public void setExpandedInstallDir(String val) {	String oldVal = getEntity().getAttribute(SoftwareProcess.EXPANDED_INSTALL_DIR);	if (Strings.isNonBlank(oldVal) && !oldVal.equals(val)) {	
resetting expandedinstalldir to from for 

public void copyInstallResources() {	getLocation().acquireMutex("installing " + elvis(entity, this), "installation lock at host for files and templates");	try {	super.copyInstallResources();	} catch (Exception e) {	
error copying install resources 

public void copyCustomizeResources() {	getLocation().acquireMutex("customizing " + elvis(entity, this), "installation lock at host for files and templates");	try {	super.copyCustomizeResources();	} catch (Exception e) {	
error copying customize resources 

private void executeSuccessfully(ConfigKey<String> configKey, String label) {	if(Strings.isNonBlank(getEntity().getConfig(configKey))) {	
executing on entity 

private void executeSuccessfully(ConfigKey<String> configKey, String label) {	if(Strings.isNonBlank(getEntity().getConfig(configKey))) {	int result = execute(ImmutableList.of(getEntity().getConfig(configKey)), label);	if (0 != result) {	
executing failed with return code 

if (createParentDir) {	int lastSlashIndex = destination.lastIndexOf("/");	String parent = (lastSlashIndex > 0) ? destination.substring(0, lastSlashIndex) : null;	if (parent != null) {	getMachine().execCommands("createParentDir", ImmutableList.of("mkdir -p "+parent));	}	}	int result = getMachine().installTo(resource, flags, source, destination);	if (result == 0) {	if (log.isDebugEnabled()) {	
copied file for to result 

}	}	int result;	String prevBlockingDetails = Tasks.setBlockingDetails("copying resource to server at "+destination);	try {	result = getMachine().copyTo(flags, source, destination);	} finally {	Tasks.setBlockingDetails(prevBlockingDetails);	}	if (result == 0) {	
copying stream complete on 

}	int result;	String prevBlockingDetails = Tasks.setBlockingDetails("copying resource to server at "+destination);	try {	result = getMachine().copyTo(flags, source, destination);	} finally {	Tasks.setBlockingDetails(prevBlockingDetails);	}	if (result == 0) {	} else {	
copying stream failed on 

public void checkNoHostnameBug() {	try {	ProcessTaskWrapper<Integer> hostnameTask = DynamicTasks.queue(SshEffectorTasks.ssh("echo FOREMARKER; hostname; echo AFTMARKER")).block();	String stdout = Strings.getFragmentBetween(hostnameTask.getStdout(), "FOREMARKER", "AFTMARKER");	if (hostnameTask.getExitCode() == 0 && Strings.isNonBlank(stdout)) {	String hostname = stdout.trim();	if (hostname.equals("(none)")) {	String newHostname = "br-"+getEntity().getId().toLowerCase();	
detected no hostname bug with hostname for renaming to hostname 

try {	ProcessTaskWrapper<Integer> hostnameTask = DynamicTasks.queue(SshEffectorTasks.ssh("echo FOREMARKER; hostname; echo AFTMARKER")).block();	String stdout = Strings.getFragmentBetween(hostnameTask.getStdout(), "FOREMARKER", "AFTMARKER");	if (hostnameTask.getExitCode() == 0 && Strings.isNonBlank(stdout)) {	String hostname = stdout.trim();	if (hostname.equals("(none)")) {	String newHostname = "br-"+getEntity().getId().toLowerCase();	DynamicTasks.queue(SshEffectorTasks.ssh(BashCommands.setHostname(newHostname, null))).block();	}	} else {	
hostname could not be determined for location not doing no hostname bug check 

if (hostnameTask.getExitCode() == 0 && Strings.isNonBlank(stdout)) {	String hostname = stdout.trim();	if (hostname.equals("(none)")) {	String newHostname = "br-"+getEntity().getId().toLowerCase();	DynamicTasks.queue(SshEffectorTasks.ssh(BashCommands.setHostname(newHostname, null))).block();	}	} else {	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error checking fixing no hostname bug continuing 

} else {	s.body.append( "export PID=$(cat "+pidFile+")", "test -n \"$PID\" || exit 0", "kill -9 $PID", "rm -f "+pidFile );	}	} else if (RESTARTING.equals(phase)) {	if (processOwner != null) {	s.footer.prepend( BashCommands.sudoAsUser(processOwner, "test -f "+pidFile) + " || exit 1", "ps -p $(" + BashCommands.sudoAsUser(processOwner, "cat "+pidFile) + ") || exit 1" );	} else {	s.footer.prepend( "test -f "+pidFile+" || exit 1", "ps -p $(cat "+pidFile+") || exit 1" );	}	} else {	
script option not valid for 

========================= brooklyn sample_2339 =========================

public static void writeMemento(ManagementContext mgmt, PersistenceObjectStore targetStore, MementoCopyMode source) {	if (source==null || source==MementoCopyMode.AUTO) source = (mgmt.getHighAvailabilityManager().getNodeState()==ManagementNodeState.MASTER ? MementoCopyMode.LOCAL : MementoCopyMode.REMOTE);	Stopwatch timer = Stopwatch.createStarted();	BrooklynMementoRawData dataRecord = newStateMemento(mgmt, source);	ManagementPlaneSyncRecord mgmtRecord = newManagerMemento(mgmt, source);	writeMemento(mgmt, dataRecord, targetStore);	writeManagerMemento(mgmt, mgmtRecord, targetStore);	
wrote full memento to in 

if (source==null || source==MementoCopyMode.AUTO) {	switch (mode) {	case PROMOTION: source = MementoCopyMode.REMOTE; break;	case DEMOTION: source = MementoCopyMode.LOCAL; break;	default: throw new IllegalArgumentException("Cannot detect copy mode for "+mode+"/"+source);	}	}	BrooklynMementoRawData memento = null;	ManagementPlaneSyncRecord planeState = null;	try {	
loading persisted state on for backup purposes 

}	}	BrooklynMementoRawData memento = null;	ManagementPlaneSyncRecord planeState = null;	try {	memento = newStateMemento(managementContext, source);	try {	planeState = newManagerMemento(managementContext, source);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to access management plane sync state on ignoring 

planeState = newManagerMemento(managementContext, source);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	}	PersistenceObjectStore destinationObjectStore = null;	String backupSpec = managementContext.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_BACKUPS_LOCATION_SPEC);	String nonBackupSpec = managementContext.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_LOCATION_SPEC);	try {	String backupContainer = BrooklynServerPaths.newBackupPersistencePathResolver(managementContext) .location(backupSpec).nonBackupLocation(nonBackupSpec).resolveWithSubpathFor(managementContext, mode.toString());	destinationObjectStore = BrooklynPersistenceUtils.newPersistenceObjectStore(managementContext, backupSpec, backupContainer);	
backing up persisted state on to 

}	PersistenceObjectStore destinationObjectStore = null;	String backupSpec = managementContext.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_BACKUPS_LOCATION_SPEC);	String nonBackupSpec = managementContext.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_LOCATION_SPEC);	try {	String backupContainer = BrooklynServerPaths.newBackupPersistencePathResolver(managementContext) .location(backupSpec).nonBackupLocation(nonBackupSpec).resolveWithSubpathFor(managementContext, mode.toString());	destinationObjectStore = BrooklynPersistenceUtils.newPersistenceObjectStore(managementContext, backupSpec, backupContainer);	BrooklynPersistenceUtils.writeMemento(managementContext, memento, destinationObjectStore);	BrooklynPersistenceUtils.writeManagerMemento(managementContext, planeState, destinationObjectStore);	if (!memento.isEmpty()) {	
back up of persisted state created on in 

PersistenceObjectStore destinationObjectStore = null;	String backupSpec = managementContext.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_BACKUPS_LOCATION_SPEC);	String nonBackupSpec = managementContext.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_LOCATION_SPEC);	try {	String backupContainer = BrooklynServerPaths.newBackupPersistencePathResolver(managementContext) .location(backupSpec).nonBackupLocation(nonBackupSpec).resolveWithSubpathFor(managementContext, mode.toString());	destinationObjectStore = BrooklynPersistenceUtils.newPersistenceObjectStore(managementContext, backupSpec, backupContainer);	BrooklynPersistenceUtils.writeMemento(managementContext, memento, destinationObjectStore);	BrooklynPersistenceUtils.writeManagerMemento(managementContext, planeState, destinationObjectStore);	if (!memento.isEmpty()) {	} else {	
back up of empty persisted state created on in 

}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	PersistenceObjectStore failedStore = destinationObjectStore;	if (!Strings.isBlank(backupSpec) && !"localhost".equals(backupSpec)) {	String failedSpec = backupSpec;	backupSpec = "localhost";	String backupContainer = BrooklynServerPaths.newBackupPersistencePathResolver(managementContext) .location(backupSpec).nonBackupLocation(nonBackupSpec).resolveWithSubpathFor(managementContext, mode.toString());	destinationObjectStore = BrooklynPersistenceUtils.newPersistenceObjectStore(managementContext, backupSpec, backupContainer);	log.warn("Persisted state back-up to "+(failedStore!=null ? failedStore.getSummaryName() : failedSpec) +" failed with "+e, e);	
backing up persisted state on locally because remote failed to 

Exceptions.propagateIfFatal(e);	PersistenceObjectStore failedStore = destinationObjectStore;	if (!Strings.isBlank(backupSpec) && !"localhost".equals(backupSpec)) {	String failedSpec = backupSpec;	backupSpec = "localhost";	String backupContainer = BrooklynServerPaths.newBackupPersistencePathResolver(managementContext) .location(backupSpec).nonBackupLocation(nonBackupSpec).resolveWithSubpathFor(managementContext, mode.toString());	destinationObjectStore = BrooklynPersistenceUtils.newPersistenceObjectStore(managementContext, backupSpec, backupContainer);	log.warn("Persisted state back-up to "+(failedStore!=null ? failedStore.getSummaryName() : failedSpec) +" failed with "+e, e);	BrooklynPersistenceUtils.writeMemento(managementContext, memento, destinationObjectStore);	BrooklynPersistenceUtils.writeManagerMemento(managementContext, planeState, destinationObjectStore);	
back up of persisted state created on locally because remote failed in 

backupSpec = "localhost";	String backupContainer = BrooklynServerPaths.newBackupPersistencePathResolver(managementContext) .location(backupSpec).nonBackupLocation(nonBackupSpec).resolveWithSubpathFor(managementContext, mode.toString());	destinationObjectStore = BrooklynPersistenceUtils.newPersistenceObjectStore(managementContext, backupSpec, backupContainer);	log.warn("Persisted state back-up to "+(failedStore!=null ? failedStore.getSummaryName() : failedSpec) +" failed with "+e, e);	BrooklynPersistenceUtils.writeMemento(managementContext, memento, destinationObjectStore);	BrooklynPersistenceUtils.writeManagerMemento(managementContext, planeState, destinationObjectStore);	}	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to backup management plane sync state on ignoring 

========================= brooklyn sample_1145 =========================

public static void setFilePermissionsTo700(File file) throws IOException {	createNewFile(file);	try {	permissions700.apply(file);	
set permissions to for file 

public static void setFilePermissionsTo600(File file) throws IOException {	createNewFile(file);	try {	permissions600.apply(file);	
set permissions to for file 

public static Maybe<String> getFilePermissions(File file) {	if (!file.exists()) return Maybe.absent("File "+file+" does not exist");	if (Os.isMicrosoftWindows()) {	return Maybe.absent("Cannot determine permissions on windows");	} else {	ByteArrayOutputStream out = new ByteArrayOutputStream();	ByteArrayOutputStream err = new ByteArrayOutputStream();	int exitcode = exec(ImmutableList.of("ls", "-ld", file.getAbsolutePath()), out, err);	if (exitcode != 0) {	
could not determine permissions of file exit code stderr 

========================= brooklyn sample_2010 =========================

public void stop() {	
stopping simple command 

public void restart() {	
restarting simple command 

protected void handle(Result result) {	
result is with output and error 

========================= brooklyn sample_2440 =========================

private synchronized void infer() {	if (!dirty) return;	warningMessages.clear();	
inferring os credentials 

if (Strings.isNonBlank(privateKeyFiles)) {	Iterator<String> fi = Arrays.asList(privateKeyFiles.split(File.pathSeparator)).iterator();	while (fi.hasNext()) {	String file = fi.next();	if (Strings.isNonBlank(file)) {	try {	if (file!=null) privateKeyData = ResourceUtils.create().getResourceAsString(file);	privateKey = getValidatedPrivateKey(file);	if (privateKeyData==null) {	} else if (Strings.isNonBlank(publicKeyData)) {	
loaded private key data from public key data explicitly set 

try {	if (file!=null) privateKeyData = ResourceUtils.create().getResourceAsString(file);	privateKey = getValidatedPrivateKey(file);	if (privateKeyData==null) {	} else if (Strings.isNonBlank(publicKeyData)) {	break;	} else {	String publicKeyFile = (file!=null ? file+".pub" : "(data)");	try {	publicKeyData = ResourceUtils.create().getResourceAsString(publicKeyFile);	
loaded private key data from and public key data from 

if (privateKeyData==null) {	} else if (Strings.isNonBlank(publicKeyData)) {	break;	} else {	String publicKeyFile = (file!=null ? file+".pub" : "(data)");	try {	publicKeyData = ResourceUtils.create().getResourceAsString(publicKeyFile);	break;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
no public key file will try extracting from private key 

try {	publicKeyData = ResourceUtils.create().getResourceAsString(publicKeyFile);	break;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	publicKeyData = AuthorizedKeysParser.encodePublicKey(privateKey.getPublic());	if (publicKeyData==null) {	if (requirePublicKey) {	addWarning("Unable to find or extract public key for "+file, "skipping");	} else {	
loaded private key data from public key data not found but not required 

} catch (Exception e) {	Exceptions.propagateIfFatal(e);	publicKeyData = AuthorizedKeysParser.encodePublicKey(privateKey.getPublic());	if (publicKeyData==null) {	if (requirePublicKey) {	addWarning("Unable to find or extract public key for "+file, "skipping");	} else {	break;	}	} else {	
loaded private key data from public key data extracted 

privateKey = getValidatedPrivateKey("(data)");	}	if (privateKeyData!=null) {	if (requirePublicKey && Strings.isBlank(publicKeyData)) {	if (privateKey!=null) {	publicKeyData = AuthorizedKeysParser.encodePublicKey(privateKey.getPublic());	}	if (Strings.isBlank(publicKeyData)) {	error("If explicit "+LocationConfigKeys.PRIVATE_KEY_DATA.getName()+" is supplied, then " + "the corresponding "+LocationConfigKeys.PUBLIC_KEY_DATA.getName()+" must also be supplied.", null);	} else {	
public key data extracted 

decoded = AuthorizedKeysParser.decodePublicKey(publicKeyData);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	addWarning("Invalid public key: "+decoded);	}	if (decoded!=null && !privateKey.getPublic().equals( decoded )) {	error("Public key inferred from does not match public key extracted from private key", null);	}	}	}	
os credential inference 

private KeyPair getValidatedPrivateKey(String label) {	KeyPair privateKey = null;	String passphrase = config.get(CloudLocationConfig.PRIVATE_KEY_PASSPHRASE);	try {	privateKey = SecureKeys.readPem(privateKeyData.getBytes(), passphrase);	if (passphrase!=null) {	privateKeyData = SecureKeys.toPem(privateKey);	}	} catch (PassphraseProblem e) {	if (doKeyValidation) {	
encountered error handling key 

String data = config.get(dataKey);	if (Strings.isNonBlank(data) && !unused) {	return data.trim();	}	String file = config.get(fileKey);	if (groovyTruth(file)) {	List<String> files = Arrays.asList(file.split(File.pathSeparator));	List<String> filesTidied = tidyFilePaths(files);	String fileData = getFileContents(filesTidied);	if (fileData == null) {	
invalid file s for given converted to may fail provisioning 

if (Strings.isNonBlank(data) && !unused) {	return data.trim();	}	String file = config.get(fileKey);	if (groovyTruth(file)) {	List<String> files = Arrays.asList(file.split(File.pathSeparator));	List<String> filesTidied = tidyFilePaths(files);	String fileData = getFileContents(filesTidied);	if (fileData == null) {	} else if (groovyTruth(data)) {	
and both specified preferring the former 

private static String getFileContents(Iterable<String> files) {	Iterator<String> fi = files.iterator();	while (fi.hasNext()) {	String file = fi.next();	if (groovyTruth(file)) {	try {	String result = ResourceUtils.create().getResourceAsString(file);	if (result!=null) return result;	
invalid file no more files to try trying next file null 

private static String getFileContents(Iterable<String> files) {	Iterator<String> fi = files.iterator();	while (fi.hasNext()) {	String file = fi.next();	if (groovyTruth(file)) {	try {	String result = ResourceUtils.create().getResourceAsString(file);	if (result!=null) return result;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
invalid file no more files to try trying next file 

========================= brooklyn sample_1283 =========================

public void testPlatformIncludesList() {	PlatformDto p = load(PlatformRestResource.CAMP_URI_PATH, PlatformDto.class);	PlatformComponentTemplateDto pct = load(p.getPlatformComponentTemplates().get(0).getHref(), PlatformComponentTemplateDto.class);	
loaded pct via rest 

========================= brooklyn sample_1779 =========================

boolean started = Repeater.create("Wait for application startup") .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	Status status = getApplicationStatus(applicationRef);	if (status == Status.ERROR) {	Assert.fail("Application failed with ERROR");	}	return status == Status.RUNNING;	}	}) .backoffTo(Duration.ONE_SECOND) .limitTimeTo(timeout) .run();	if (!started) {	
did not start application 

========================= brooklyn sample_2856 =========================

public <T extends Entity> T createEntityProxy(EntitySpec<T> spec, T entity) {	Set<Class<?>> interfaces = Sets.newLinkedHashSet();	if (spec.getType().isInterface()) {	interfaces.add(spec.getType());	} else {	
entityspec declared in terms of concrete type should be supplied in terms of interface 

Class<? extends T> clazz = getImplementedBy(spec);	T entity = constructEntity(clazz, spec, entityId);	loadUnitializedEntity(entity, spec);	entitiesByEntityId.put(entity.getId(), entity);	specsByEntityId.put(entity.getId(), spec);	for (EntitySpec<?> childSpec : spec.getChildren()) {	if (childSpec.getParent()!=null) {	if (!childSpec.getParent().equals(entity)) {	throw new IllegalStateException("Spec "+childSpec+" has parent "+childSpec.getParent()+" defined, " + "but it is defined as a child of "+entity);	}	
child spec is already set with parent how did this happen 

protected <T extends Entity> void initEntityAndDescendants(String entityId, final Map<String,Entity> entitiesByEntityId, final Map<String,EntitySpec<?>> specsByEntityId) {	final Entity entity = entitiesByEntityId.get(entityId);	final EntitySpec<?> spec = specsByEntityId.get(entityId);	if (entity==null || spec==null) {	
skipping initialization of found as child of entity being initialized but this child is not one we created likely it was created by an initializer and thus it should be already fully initialized 

========================= brooklyn sample_1329 =========================

protected void finalize() {	
windowsperformancecounterfeed builder created but build never called 

protected void preStart() {	Collection<WindowsPerformanceCounterPollConfig<?>> polls = getConfig(POLLS);	long minPeriod = Integer.MAX_VALUE;	List<String> performanceCounterNames = Lists.newArrayList();	for (WindowsPerformanceCounterPollConfig<?> config : polls) {	minPeriod = Math.min(minPeriod, config.getPeriod());	performanceCounterNames.add(config.getPerformanceCounterName());	}	Iterable<String> allParams = ImmutableList.<String>builder() .add("$ProgressPreference = \"SilentlyContinue\";") .add("(Get-Counter") .add("-Counter") .add(JOINER_ON_COMMA.join(Iterables.transform(performanceCounterNames, QuoteStringFunction.INSTANCE))) .add("-SampleInterval") .add("2") .add(").CounterSamples") .add("|") .add("Format-Table") .add(String.format("@{Expression={$_.Path};width=%d},@{Expression={$_.CookedValue};width=%<d}", OUTPUT_COLUMN_WIDTH)) .add("-HideTableHeaders") .add("|") .add("Out-String") .add("-Width") .add(String.valueOf(OUTPUT_COLUMN_WIDTH * 2)) .build();	String command = JOINER_ON_SPACE.join(allParams);	
windows performance counter poll command for will be 

String rawValue = pollResponse.substring(OUTPUT_COLUMN_WIDTH).replaceAll("^\\s+", "");	WindowsPerformanceCounterPollConfig<?> config = getPollConfig(name);	Class<?> clazz = config.getSensor().getType();	AttributeSensor<Object> attribute = (AttributeSensor<Object>) Sensors.newSensor(clazz, config.getSensor().getName(), config.getDescription());	try {	Object value = TypeCoercions.coerce(rawValue, TypeToken.of(clazz));	entity.sensors().set(attribute, value);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (failedAttributes.add(attribute)) {	
failed to coerce value to for 

WindowsPerformanceCounterPollConfig<?> config = getPollConfig(name);	Class<?> clazz = config.getSensor().getType();	AttributeSensor<Object> attribute = (AttributeSensor<Object>) Sensors.newSensor(clazz, config.getSensor().getName(), config.getDescription());	try {	Object value = TypeCoercions.coerce(rawValue, TypeToken.of(clazz));	entity.sensors().set(attribute, value);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (failedAttributes.add(attribute)) {	} else {	
failed repeatedly to coerce value to for 

public void onFailure(WinRmToolResponse val) {	if (val == null) {	
windows performance counter not executed since there is still now winrmmachinelocation 

public void onException(Exception exception) {	
detected exception while retrieving windows performance counters from entity 

========================= brooklyn sample_2155 =========================

public void testJcloudsCreateBogStandard() throws Exception {	
test testjcloudscreatebogstandard 

public void testJcloudsCreateBogStandard() throws Exception {	JcloudsSshMachineLocation m1 = obtainMachine(ImmutableMap.of());	Map details = MutableMap.of("id", m1.getJcloudsId(), "hostname", m1.getAddress().getHostAddress(), "user", m1.getUser());	
got machine at now trying to rebind 

public void testJcloudsCreateBogStandard() throws Exception {	JcloudsSshMachineLocation m1 = obtainMachine(ImmutableMap.of());	Map details = MutableMap.of("id", m1.getJcloudsId(), "hostname", m1.getAddress().getHostAddress(), "user", m1.getUser());	String result;	result = execWithOutput(m1, Arrays.asList("echo trying  m1", "hostname", "date"));	Assert.assertTrue(result.contains("trying m1"));	
now trying rebind 

public void testJcloudsCreateBogStandardWithUserBrooklyn() throws Exception {	
test testjcloudscreatebogstandardwithuserbrooklyn 

public void testJcloudsCreateBogStandardWithUserBrooklyn() throws Exception {	JcloudsSshMachineLocation m1 = obtainMachine(MutableMap.of("user", "brooklyn"));	Map details = MutableMap.of("id", m1.getJcloudsId(), "hostname", m1.getAddress().getHostAddress(), "user", m1.getUser());	
got machine at now trying to rebind 

public void testJcloudsCreateBogStandardWithUserBrooklyn() throws Exception {	JcloudsSshMachineLocation m1 = obtainMachine(MutableMap.of("user", "brooklyn"));	Map details = MutableMap.of("id", m1.getJcloudsId(), "hostname", m1.getAddress().getHostAddress(), "user", m1.getUser());	String result;	result = execWithOutput(m1, Arrays.asList("echo trying  m1", "hostname", "date"));	Assert.assertTrue(result.contains("trying m1"));	
now trying rebind 

public void testJcloudsCreateUserMetadata() throws Exception {	
test testjcloudscreatebogstandard 

public void testJcloudsCreateUserMetadata() throws Exception {	String key = "brooklyn-test-user-data";	String value = "test-"+Identifiers.makeRandomId(4);	JcloudsSshMachineLocation m1 = obtainMachine(MutableMap.of("userMetadata", key+"="+value));	Map details = MutableMap.of("id", m1.getJcloudsId(), "hostname", m1.getAddress().getHostAddress(), "user", m1.getUser(), "userMetadata", key+"="+value);	Assert.assertEquals(m1.node.getUserMetadata().get(key), value);	
got machine at now trying to rebind 

public void testJcloudsCreateUserMetadata() throws Exception {	String key = "brooklyn-test-user-data";	String value = "test-"+Identifiers.makeRandomId(4);	JcloudsSshMachineLocation m1 = obtainMachine(MutableMap.of("userMetadata", key+"="+value));	Map details = MutableMap.of("id", m1.getJcloudsId(), "hostname", m1.getAddress().getHostAddress(), "user", m1.getUser(), "userMetadata", key+"="+value);	Assert.assertEquals(m1.node.getUserMetadata().get(key), value);	String result;	result = execWithOutput(m1, Arrays.asList("echo trying  m1", "hostname", "date"));	Assert.assertTrue(result.contains("trying m1"));	
now trying rebind 

public void testJcloudsMissingUser() throws Exception {	
test testjcloudsmissinguser 

public void testJcloudsMissingUser() throws Exception {	try {	obtainMachine(MutableMap.of("imageId", EC2_CENTOS_IMAGE, "waitForSshable", 30*1000));	
whoops we logged in 

public void testJcloudsMissingUser() throws Exception {	try {	obtainMachine(MutableMap.of("imageId", EC2_CENTOS_IMAGE, "waitForSshable", 30*1000));	} catch (NoMachinesAvailableException e) {	
got error as expected for missing user 

public void testJcloudsCreateWithNoSudoGranted() throws Exception {	
test testjcloudscreatewithnosudogranted 

private int exec(SshMachineLocation m, List<String> commands, ByteArrayOutputStream stdout, ByteArrayOutputStream stderr) {	Map<String, Object> flags = Maps.newLinkedHashMap();	flags.put("out", stdout);	flags.put("err", stderr);	int exitCode = m.execCommands(flags, "test", commands);	
stdout from 

private int exec(SshMachineLocation m, List<String> commands, ByteArrayOutputStream stdout, ByteArrayOutputStream stderr) {	Map<String, Object> flags = Maps.newLinkedHashMap();	flags.put("out", stdout);	flags.put("err", stderr);	int exitCode = m.execCommands(flags, "test", commands);	
stderr from 

private int exec(SshMachineLocation m, List<String> commands, ByteArrayOutputStream stdout, ByteArrayOutputStream stderr) {	Map<String, Object> flags = Maps.newLinkedHashMap();	flags.put("out", stdout);	flags.put("err", stderr);	int exitCode = m.execCommands(flags, "test", commands);	
exit code 

========================= brooklyn sample_2505 =========================

setUpServer();	String catalogItemId = "test-catalog-item:1.0";	String catalogItemIdGA = "test-catalog-item:1.0-GA";	serverApp.sensors().set(TestApplication.MY_ATTRIBUTE, "austria");	serverApp.setCatalogItemId(catalogItemId);	String serviceId = serverApp.getId();	Entity mirror = localApp.addChild(EntitySpec.create(BrooklynEntityMirror.class) .configure(BrooklynEntityMirror.POLL_PERIOD, Duration.millis(100)) .configure(BrooklynEntityMirror.MIRRORED_ENTITY_ID, serviceId) .configure(BrooklynEntityMirror.MIRRORED_ENTITY_URL, getBaseUri()+"/v1/applications/"+serviceId+"/entities/"+serviceId) );	EntityAsserts.assertAttributeEqualsEventually(mirror, TestApplication.MY_ATTRIBUTE, "austria");	EntityAsserts.assertAttributeEqualsEventually(mirror, BrooklynEntityMirror.MIRROR_CATALOG_ITEM_ID, catalogItemId);	assertTrue(mirror.getAttribute(BrooklynEntityMirror.MIRROR_SUMMARY) != null, "entity summary is null");	
sensors mirrored are 

mgmtHttps.getBrooklynProperties().put("brooklyn.webconsole.security.https.required", true);	mgmtHttps.getBrooklynProperties().put("brooklyn.webconsole.security.users", "admin");	mgmtHttps.getBrooklynProperties().put("brooklyn.webconsole.security.user.admin.password", "P5ssW0rd");	setUpServer(mgmtHttps, false);	Assert.assertTrue(getBaseUri().startsWith("https:"), "URL is not https: "+getBaseUri());	HttpTestUtils.assertHttpStatusCodeEquals(getBaseUri(), 401);	serverApp.sensors().set(TestApplication.MY_ATTRIBUTE, "austria");	String serviceId = serverApp.getId();	Entity mirror = localApp.addChild(EntitySpec.create(BrooklynEntityMirror.class) .configure(BrooklynEntityMirror.POLL_PERIOD, Duration.millis(100)) .configure(BrooklynEntityMirror.MANAGEMENT_USER, "admin") .configure(BrooklynEntityMirror.MANAGEMENT_PASSWORD, "P5ssW0rd") .configure(BrooklynEntityMirror.MIRRORED_ENTITY_ID, serviceId) .configure(BrooklynEntityMirror.MIRRORED_ENTITY_URL, getBaseUri()+"/v1/applications/"+serviceId+"/entities/"+serviceId) );	EntityAsserts.assertAttributeEqualsEventually(mirror, TestApplication.MY_ATTRIBUTE, "austria");	
sensors mirrored are 

========================= brooklyn sample_560 =========================

protected void setEntityLoadingConfig() {	super.setEntityLoadingConfig();	this.sourceSensor = (Sensor<T>) getRequiredConfig(SOURCE_SENSOR);	this.transformation = (Function<? super Collection<T>, ? extends U>) config().get(TRANSFORMATION);	Object t1 = config().get(TRANSFORMATION_UNTYPED);	Function<? super Collection<?>, ?> t2 = null;	if (t1 instanceof String) {	t2 = lookupTransformation((String)t1);	if (t2==null) {	
unknown transformation for will use default transformation 

T vo = values.get(producer);	if (vo==null) {	T initialVal;	if (sourceSensor instanceof AttributeSensor) {	initialVal = producer.getAttribute((AttributeSensor<T>)sourceSensor);	} else {	initialVal = null;	}	values.put(producer, initialVal != null ? initialVal : defaultMemberValue);	} else {	
already had value for producer but that producer has just been added 

public void onEvent(SensorEvent<T> event) {	Entity e = event.getSource();	synchronized (values) {	if (values.containsKey(e)) {	values.put(e, event.getValue());	} else {	
received event for unknown producer presumably that producer has recently been removed 

protected void onUpdated() {	try {	emit(targetSensor, compute());	} catch (Throwable t) {	
error calculating and setting aggregate for enricher 

========================= brooklyn sample_999 =========================

Maybe<? extends Location> lo = Locations.findUniqueMachineLocation(locations);	if (!lo.isPresent()) {	Iterator<? extends Location> li = Iterables.filter(locations, Predicates.not(Predicates.instanceOf(MachineProvisioningLocation.class))).iterator();	if (li.hasNext()) lo = Maybe.of(li.next());	if (li.hasNext()) lo = Maybe.absent();	}	if (!lo.isPresent() && locations.size() == 1) {	lo = Maybe.of(locations.iterator().next());	}	if (LOG.isTraceEnabled()) {	
convert config to sensor for found locations selected 

Location l = lo.get();	Optional<Boolean> locationRunning = Optional.fromNullable(l.getConfig(BrooklynConfigKeys.SKIP_ENTITY_START_IF_RUNNING));	Optional<Boolean> entityRunning = Optional.fromNullable(entity.getConfig(BrooklynConfigKeys.SKIP_ENTITY_START_IF_RUNNING));	Optional<Boolean> locationInstalled = Optional.fromNullable(l.getConfig(BrooklynConfigKeys.SKIP_ENTITY_INSTALLATION));	Optional<Boolean> entityInstalled = Optional.fromNullable(entity.getConfig(BrooklynConfigKeys.SKIP_ENTITY_INSTALLATION));	Optional<Boolean> entityStarted = Optional.fromNullable(entity.getConfig(BrooklynConfigKeys.SKIP_ENTITY_START));	boolean skipCheck = locationRunning.or(entityRunning).or(locationInstalled).or(entityInstalled).or(entityStarted).or(false);	if (l instanceof PortSupplier) {	int p = ((PortSupplier) l).obtainPort(value);	if (p != -1) {	
choosing port for 

Optional<Boolean> entityStarted = Optional.fromNullable(entity.getConfig(BrooklynConfigKeys.SKIP_ENTITY_START));	boolean skipCheck = locationRunning.or(entityRunning).or(locationInstalled).or(entityInstalled).or(entityStarted).or(false);	if (l instanceof PortSupplier) {	int p = ((PortSupplier) l).obtainPort(value);	if (p != -1) {	return p;	}	if (!skipCheck) {	int rangeSize = Iterables.size(value);	if (rangeSize == 0) {	
no port available for empty range 

int p = ((PortSupplier) l).obtainPort(value);	if (p != -1) {	return p;	}	if (!skipCheck) {	int rangeSize = Iterables.size(value);	if (rangeSize == 0) {	} else if (rangeSize == 1) {	Integer pp = value.iterator().next();	if (pp > 1024) {	
port not available for 

if (p != -1) {	return p;	}	if (!skipCheck) {	int rangeSize = Iterables.size(value);	if (rangeSize == 0) {	} else if (rangeSize == 1) {	Integer pp = value.iterator().next();	if (pp > 1024) {	} else {	
port not available for root may be required 

}	if (!skipCheck) {	int rangeSize = Iterables.size(value);	if (rangeSize == 0) {	} else if (rangeSize == 1) {	Integer pp = value.iterator().next();	if (pp > 1024) {	} else {	}	} else {	
no port available for tried range 

Integer pp = value.iterator().next();	if (pp > 1024) {	} else {	}	} else {	}	return null;	}	}	Integer v = (value.isEmpty() ? null : value.iterator().next());	
choosing port unconfirmed for 

} else {	}	} else {	}	return null;	}	}	Integer v = (value.isEmpty() ? null : value.iterator().next());	return v;	} else {	
ports not applicable or not yet applicable because has multiple locations ignoring 

} else {	}	return null;	}	}	Integer v = (value.isEmpty() ? null : value.iterator().next());	return v;	} else {	}	} else {	
ports not applicable or not yet applicable because has no locations ignoring 

protected Integer convertConfigToSensor(PortRange value, ManagementContext managementContext) {	
ports not applicable because given managementcontext rather than entity ignoring 

========================= brooklyn sample_1407 =========================

} else if (it instanceof BasicParameterType && ((BasicParameterType)it).hasDefaultValue()) {	v = ((BasicParameterType)it).getDefaultValue();	} else {	throw new IllegalArgumentException("Invalid arguments (missing argument "+it+") for effector "+eff+": "+Sanitizer.sanitize(m));	}	newArgs.add(TypeCoercions.coerce(v, it.getParameterClass()));	newArgsNeeded--;	}	if (newArgsNeeded>0) throw new IllegalArgumentException("Invalid arguments (missing "+newArgsNeeded+") for effector "+eff+": "+Sanitizer.sanitize(m));	if (!m.isEmpty()) {	
unsupported parameter to ignoring 

public static <T> T invokeMethodEffector(Entity entity, Effector<T> eff, Map<String,?> args) {	Object[] parametersArray = EffectorUtils.prepareArgsForEffector(eff, args);	String name = eff.getName();	try {	
invoking effector on 

public static <T> T invokeMethodEffector(Entity entity, Effector<T> eff, Map<String,?> args) {	Object[] parametersArray = EffectorUtils.prepareArgsForEffector(eff, args);	String name = eff.getName();	try {	
invoking effector on with args 

public static <T> Task<T> invokeEffectorAsync(Entity entity, Effector<T> eff, Map<String,?> parameters) {	String name = eff.getName();	
invoking async effector on 

public static <T> Task<T> invokeEffectorAsync(Entity entity, Effector<T> eff, Map<String,?> parameters) {	String name = eff.getName();	
invoking async effector on with args 

========================= brooklyn sample_1057 =========================

protected void onErrorImpl(String errmsg, Exception e, boolean isNew) {	Exceptions.propagateIfFatal(e);	if (isActive()) {	if (!isNew) {	
repeating problem 

protected void onErrorImpl(String errmsg, Exception e, boolean isNew) {	Exceptions.propagateIfFatal(e);	if (isActive()) {	if (!isNew) {	} else {	
problem persisting ignoring 

protected void onErrorImpl(String errmsg, Exception e, boolean isNew) {	Exceptions.propagateIfFatal(e);	if (isActive()) {	if (!isNew) {	} else {	}	} else {	if (!isNew) {	
repeating problem but no longer active ignoring 

protected void onErrorImpl(String errmsg, Exception e, boolean isNew) {	Exceptions.propagateIfFatal(e);	if (isActive()) {	if (!isNew) {	} else {	}	} else {	if (!isNew) {	} else {	
problem but no longer active ignoring 

========================= brooklyn sample_1112 =========================

public Assembly instantiate(AssemblyTemplate template, CampPlatform platform) {	
ignoring request to instantiate 

========================= brooklyn sample_1811 =========================

public static boolean isUrlUp(URL url) {	try {	HttpToolResponse result = HttpTool.httpGet( HttpTool.httpClientBuilder().trustAll().build(), URI.create(url.toString()), ImmutableMap.<String,String>of());	int statuscode = result.getResponseCode();	if (statuscode != 200) {	
error reading url 

public static boolean isUrlUp(URL url) {	try {	HttpToolResponse result = HttpTool.httpGet( HttpTool.httpClientBuilder().trustAll().build(), URI.create(url.toString()), ImmutableMap.<String,String>of());	int statuscode = result.getResponseCode();	if (statuscode != 200) {	return false;	} else {	return true;	}	} catch (Exception e) {	
error reading url 

public static boolean isPidRunning(int pid, String regex) {	Process process = exec("ps -p " + pid);	String out = waitFor(process);	if (process.exitValue() > 0) {	String err = toString(process.getErrorStream());	
pid s not running s 

String regex2 = "^\\s*" + pid + ".*" + regex;	boolean found = false;	for (String line : out.split("\n")) {	if (hasAtLeastOneMatch(line, regex2)) {	found = true;	break;	}	}	if (!found) {	String txt = toString(process.getInputStream());	
process did not match regular expression 

public static Process exec(String cmd) {	
executing cmd 

========================= brooklyn sample_39 =========================

public void tearDownClass() throws Exception {	try {	if (location != null) location.release(machine);	} catch (Throwable t) {	
caught exception in teardownclass method 

public void tearDown() {	try {	if (app != null) Entities.destroy(app);	} catch (Throwable t) {	
caught exception in teardown method 

String cmdFailed = (taskRegexFailed == null) ? null : TASK_REGEX_TO_COMMAND.get(taskRegexFailed);	List<String> yaml = Lists.newArrayList();	yaml.addAll(yamlLocation);	yaml.addAll(ImmutableList.of( "services:", "- type: org.apache.brooklyn.entity.software.base.VanillaWindowsProcess", "  brooklyn.config:", "    onbox.base.dir.skipResolution: true", "    templates.preinstall:", "      classpath: "      classpath: "    files.preinstall:", "      classpath: "      classpath: "      classpath: "      classpath: "      classpath: "      classpath: ""));	for (Map.Entry<String, String> entry : commands.entrySet()) {	yaml.add("    "+entry.getKey()+": "+entry.getValue());	}	if (Strings.isBlank(cmdFailed)) {	app = createAndStartApplication(Joiner.on("\n").join(yaml));	waitForApplicationTasks(app);	
app started 

if (Strings.isBlank(cmdFailed)) {	app = createAndStartApplication(Joiner.on("\n").join(yaml));	waitForApplicationTasks(app);	Entities.dumpInfo(app);	VanillaWindowsProcess entity = (VanillaWindowsProcess) app.getChildren().iterator().next();	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_UP, true);	assertStreams(entity, stdouts);	} else if (cmdFailed.equals("stop-command")) {	app = createAndStartApplication(Joiner.on("\n").join(yaml));	waitForApplicationTasks(app);	
app started 

========================= brooklyn sample_1684 =========================

public void apply(final EntityLocal entity) {	super.apply(entity);	if (LOG.isDebugEnabled()) {	
adding http json sensor to 

========================= brooklyn sample_1411 =========================

public void updateBindConfiguration() {	
updating bind configuration at 

public void updateBindConfiguration() {	copyAsRoot(entity.getConfig(BindDnsServer.NAMED_CONF_TEMPLATE), getOsSupport().getRootConfigFile());	copyAsRoot(entity.getConfig(BindDnsServer.DOMAIN_ZONE_FILE_TEMPLATE), getDomainZoneFile());	copyAsRoot(entity.getConfig(BindDnsServer.REVERSE_ZONE_FILE_TEMPLATE), getReverseZoneFile());	int result = getMachine().execScript("restart bind", ImmutableList.of(BashCommands.sudo("service " + getOsSupport().getServiceName() + " restart")));	
updated named configuration and zone file for on exit code 

========================= brooklyn sample_126 =========================

public void apply(EntityLocal entity) {	SshFeed machineMetricsFeed = createMachineMetricsFeed(entity);	((EntityInternal) entity).feeds().add(machineMetricsFeed);	addMachineMetricsEnrichers(entity);	
configured machine metrics feed and enrichers on 

========================= brooklyn sample_2378 =========================

public void positiveTest(final Object data, final List<Map<String, ?>> assertions) {	final Supplier<Object> supplier = new Supplier<Object>() {	public Object get() {	
supplier invoked for data 

public void positiveAbortTest(final Object data, final List<Map<String, ?>> abortConditions) {	final Supplier<Object> supplier = new Supplier<Object>() {	public Object get() {	
supplier invoked for data 

public void negativeTests(final Object data, String condition, Object expected, final List<Map<String, ?>> assertions) {	final Supplier<Object> supplier = new Supplier<Object>() {	public Object get() {	
supplier invoked for data 

public void negativeAbortTest(final Object data, String condition, Object expected, final List<Map<String, ?>> assertions) {	final Supplier<Object> supplier = new Supplier<Object>() {	public Object get() {	
supplier invoked for data 

public void testUnknownAssertion() {	final String randomId = Identifiers.makeRandomId(8);	final Map<String, Object> assertions = new HashMap<>();	assertions.put(randomId, randomId);	final Supplier<String> supplier = new Supplier<String>() {	public String get() {	
supplier invoked for data 

========================= brooklyn sample_2401 =========================

public T get(String id) {	RegisteredType item = bmc.getTypeRegistry().get(id);	if (item==null) {	
could not find item in brooklyn catalog returning null 

========================= brooklyn sample_1738 =========================

public OsgiConfigLoader(String propertiesPath) {	this.propertiesPath = propertiesPath;	
osgiconfigloader instance created 

public abstract void init();	public abstract void destroy();	public abstract void updateProperties(Map properties);	public Map<String, String> load() {	if (configAdmin == null) {	
no osgi configuration admin available cannot load cfg 

public abstract void updateProperties(Map properties);	public Map<String, String> load() {	if (configAdmin == null) {	return ImmutableMap.of();	}	String filter = '(' + Constants.SERVICE_PID + '=' + propertiesPath + ')';	Configuration[] configs;	try {	configs = configAdmin.listConfigurations(filter);	} catch (InvalidSyntaxException | IOException e) {	
cannot list osgi configurations 

} catch (InvalidSyntaxException | IOException e) {	throw Exceptions.propagate(e);	}	final MutableMap<String, String> map = MutableMap.of();	if (configs != null) {	for (Configuration config : configs) {	LOG.debug("Reading OSGi configuration from {}; bundleLocation={}", config.getPid(), config.getBundleLocation());	map.putAll(dictToMap(config.getProperties()));	}	} else {	
no osgi configuration found for cfg 

========================= brooklyn sample_521 =========================

private SshCliTool(Builder<?,?> builder) {	super(builder);	sshExecutable = checkNotNull(builder.sshExecutable);	sshFlags = checkNotNull(builder.sshFlags);	scpExecutable = checkNotNull(builder.scpExecutable);	
created sshclitool 

public void disconnect() {	
disconnecting sshclitool no op 

public int copyToServer(Map<String,?> props, File f, String pathAndFileOnRemoteServer) {	if (hasVal(props, PROP_LAST_MODIFICATION_DATE)) {	
unsupported ssh feature setting lastmodificationdate for 

public int copyToServer(Map<String,?> props, File f, String pathAndFileOnRemoteServer) {	if (hasVal(props, PROP_LAST_MODIFICATION_DATE)) {	}	if (hasVal(props, PROP_LAST_ACCESS_DATE)) {	
unsupported ssh feature setting lastaccessdate for 

}	String permissions = getOptionalVal(props, PROP_PERMISSIONS);	int uid = getOptionalVal(props, PROP_OWNER_UID);	int result = scpToServer(props, f, pathAndFileOnRemoteServer);	if (result == 0) {	result = chmodOnServer(props, permissions, pathAndFileOnRemoteServer);	if (result == 0) {	if (uid != -1) {	result = chownOnServer(props, uid, pathAndFileOnRemoteServer);	if (result != 0) {	
error setting file owner to after copying file to exit code 

int result = scpToServer(props, f, pathAndFileOnRemoteServer);	if (result == 0) {	result = chmodOnServer(props, permissions, pathAndFileOnRemoteServer);	if (result == 0) {	if (uid != -1) {	result = chownOnServer(props, uid, pathAndFileOnRemoteServer);	if (result != 0) {	}	}	} else {	
error setting file permissions to after copying file to exit code 

result = chmodOnServer(props, permissions, pathAndFileOnRemoteServer);	if (result == 0) {	if (uid != -1) {	result = chownOnServer(props, uid, pathAndFileOnRemoteServer);	if (result != 0) {	}	}	} else {	}	} else {	
error copying file to exit code 

public int execScript(final Map<String,?> props, final List<String> commands, final Map<String,?> env) {	return new ToolAbstractExecScript(props) {	public int run() {	String scriptContents = toScript(props, commands, env);	
running shell command at as script 

if (!strictHostKeyChecking) {	cmd.add("-o");	cmd.add("StrictHostKeyChecking=no");	}	if (port != 22) {	cmd.add("-P");	cmd.add(""+port);	}	cmd.add(from);	cmd.add(to);	
executing with command 

cmd.add("-o");	cmd.add("StrictHostKeyChecking=no");	}	if (port != 22) {	cmd.add("-P");	cmd.add(""+port);	}	cmd.add(from);	cmd.add(to);	int result = execProcess(props, cmd);	
executed command exit code 

}	if (port != 22) {	cmd.add("-P");	cmd.add(""+port);	}	if (allocatePTY) {	cmd.add("-tt");	}	cmd.add((Strings.isEmpty(getUsername()) ? "" : getUsername()+"@")+getHostAddress());	cmd.add("bash -c "+BashStringEscapes.wrapBash(command));	
executing ssh with command with 

if (port != 22) {	cmd.add("-P");	cmd.add(""+port);	}	if (allocatePTY) {	cmd.add("-tt");	}	cmd.add((Strings.isEmpty(getUsername()) ? "" : getUsername()+"@")+getHostAddress());	cmd.add("bash -c "+BashStringEscapes.wrapBash(command));	int result = execProcess(props, cmd);	
executed command exit code 

========================= brooklyn sample_1446 =========================

public static boolean checkPortAvailable(InetAddress localAddress, int portNumber, Boolean reuseAddr) {	if (portNumber<1024) {	
skipping system availability check for privileged localhost port 

public static int obtainPort(InetAddress localAddress, PortRange range, Boolean reuseAddr) {	for (int p: range) if (obtainSpecificPort(localAddress, p, reuseAddr)) return p;	
unable to find port in on returning 

public int obtainPort(PortRange range) {	int r = LocalhostMachineProvisioningLocation.obtainPort(getAddress(), range);	synchronized (portsObtained) {	if (r>0) portsObtained.add(r);	}	
localhost obtainport returning 

private static synchronized void checkIfNeeded() {	if (Time.hasElapsedSince(lastSudoCheckTime, Duration.FIVE_MINUTES)) {	try {	lastSudoResult = new ProcessTool().execCommands(MutableMap.<String,Object>of(), Arrays.asList( BashCommands.sudo("date"))) == 0;	} catch (Exception e) {	lastSudoResult = false;	
error checking sudo at localhost 

========================= brooklyn sample_1594 =========================

public void setUpClass() throws Exception {	executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_EXECUTOR_THREADS));	mgmt = new LocalManagementContextForTests(BrooklynProperties.Factory.newDefault());	loc = newLoc(mgmt);	machine = loc.obtain(ImmutableMap.of());	
provisioned 

public void tearDownClass() throws Exception {	try {	if (executor != null) executor.shutdownNow();	if (machine != null) loc.release(machine);	if (mgmt != null) Entities.destroyAll(mgmt);	} catch (Throwable t) {	
caught exception in teardown method 

continue;	}	methodsToRun.add(method);	}	LOG.info("Executing "+methodsToRun.size()+" methods "+NUM_RUNS+" times each, with "+MAX_EXECUTOR_THREADS+" threads for concurrent execution; max permitted time "+TIMEOUT_MINS+"mins; methods="+methodsToRun);	List<ListenableFuture<?>> results = Lists.newArrayList();	for (int i = 0; i < NUM_RUNS; i++) {	for (final Method method : methodsToRun) {	results.add(executor.submit(new Callable<Void>() {	public Void call() throws Exception {	
executing in thread 

}	LOG.info("Executing "+methodsToRun.size()+" methods "+NUM_RUNS+" times each, with "+MAX_EXECUTOR_THREADS+" threads for concurrent execution; max permitted time "+TIMEOUT_MINS+"mins; methods="+methodsToRun);	List<ListenableFuture<?>> results = Lists.newArrayList();	for (int i = 0; i < NUM_RUNS; i++) {	for (final Method method : methodsToRun) {	results.add(executor.submit(new Callable<Void>() {	public Void call() throws Exception {	Stopwatch stopwatch = Stopwatch.createStarted();	try {	method.invoke(WinRmMachineLocationLiveTest.this);	
executed in in thread total methods done 

List<ListenableFuture<?>> results = Lists.newArrayList();	for (int i = 0; i < NUM_RUNS; i++) {	for (final Method method : methodsToRun) {	results.add(executor.submit(new Callable<Void>() {	public Void call() throws Exception {	Stopwatch stopwatch = Stopwatch.createStarted();	try {	method.invoke(WinRmMachineLocationLiveTest.this);	return null;	} catch (Exception e) {	
execute failed for after in thread total methods done 

========================= brooklyn sample_2212 =========================

public void testBrooklynNodeRestDeployAndMirror() {	final SimpleYamlLauncher l = new SimpleYamlLauncherForTests();	try {	TestApplication app = TestApplication.Factory.newManagedInstanceForTests(l.getManagementContext());	BrooklynNode bn = app.createAndManageChild(EntitySpec.create(BrooklynNode.class, SameBrooklynNodeImpl.class));	bn.start(MutableSet.<Location>of());	URI uri = bn.getAttribute(BrooklynNode.WEB_CONSOLE_URI);	Assert.assertNotNull(uri);	EntityAsserts.assertAttributeEqualsEventually(bn, Attributes.SERVICE_UP, true);	
created brooklynnode 

public void testBrooklynNodeRestDeployAndMirror() {	final SimpleYamlLauncher l = new SimpleYamlLauncherForTests();	try {	TestApplication app = TestApplication.Factory.newManagedInstanceForTests(l.getManagementContext());	BrooklynNode bn = app.createAndManageChild(EntitySpec.create(BrooklynNode.class, SameBrooklynNodeImpl.class));	bn.start(MutableSet.<Location>of());	URI uri = bn.getAttribute(BrooklynNode.WEB_CONSOLE_URI);	Assert.assertNotNull(uri);	EntityAsserts.assertAttributeEqualsEventually(bn, Attributes.SERVICE_UP, true);	Task<?> t = bn.invoke(BrooklynNode.DEPLOY_BLUEPRINT, ConfigBag.newInstance() .configure(BrooklynNode.DeployBlueprintEffector.BLUEPRINT_TYPE, TestApplication.class.getName()) .configure(BrooklynNode.DeployBlueprintEffector.BLUEPRINT_CONFIG, MutableMap.<String,Object>of("x", 1, "y", "Y")) .getAllConfig());	
deployment result 

apps.remove(app);	Application newApp = Iterables.getOnlyElement(apps);	Entities.dumpInfo(newApp);	Assert.assertEquals(newApp.getConfig(new BasicConfigKey<Integer>(Integer.class, "x")), (Integer)1);	String newAppId = newApp.getId();	BrooklynEntityMirror mirror = app.createAndManageChild(EntitySpec.create(BrooklynEntityMirror.class) .configure(BrooklynEntityMirror.MIRRORED_ENTITY_URL, Urls.mergePaths(uri.toString(), "/v1/applications/"+newAppId+"/entities/"+newAppId)) .configure(BrooklynEntityMirror.MIRRORED_ENTITY_ID, newAppId) .configure(BrooklynEntityMirror.POLL_PERIOD, Duration.millis(10)));	Entities.dumpInfo(mirror);	EntityAsserts.assertAttributeEqualsEventually(mirror, Attributes.SERVICE_UP, true);	((EntityInternal)newApp).sensors().set(TestEntity.NAME, "foo");	EntityAsserts.assertAttributeEqualsEventually(mirror, TestEntity.NAME, "foo");	
mirror successfully validated 

Entities.dumpInfo(newApp);	Assert.assertEquals(newApp.getConfig(new BasicConfigKey<Integer>(Integer.class, "x")), (Integer)1);	String newAppId = newApp.getId();	BrooklynEntityMirror mirror = app.createAndManageChild(EntitySpec.create(BrooklynEntityMirror.class) .configure(BrooklynEntityMirror.MIRRORED_ENTITY_URL, Urls.mergePaths(uri.toString(), "/v1/applications/"+newAppId+"/entities/"+newAppId)) .configure(BrooklynEntityMirror.MIRRORED_ENTITY_ID, newAppId) .configure(BrooklynEntityMirror.POLL_PERIOD, Duration.millis(10)));	Entities.dumpInfo(mirror);	EntityAsserts.assertAttributeEqualsEventually(mirror, Attributes.SERVICE_UP, true);	((EntityInternal)newApp).sensors().set(TestEntity.NAME, "foo");	EntityAsserts.assertAttributeEqualsEventually(mirror, TestEntity.NAME, "foo");	HttpClient client = HttpTool.httpClientBuilder().build();	HttpToolResponse result = HttpTool.httpPost(client, URI.create(Urls.mergePaths(uri.toString(), "/v1/applications/"+app.getId()+"/entities/"+bn.getId() +"/effectors/deployBlueprint")), MutableMap.of(com.google.common.net.HttpHeaders.CONTENT_TYPE, "application/json"), Jsonya.newInstance() .put("blueprintType", TestApplication.class.getName()) .put("blueprintConfig", MutableMap.of(TestEntity.CONF_NAME.getName(), "foo")) .toString().getBytes());	
deploy effector invoked result 

}).limitTimeTo(Duration.TEN_SECONDS).runRequiringTrue();	apps = MutableSet.copyOf( l.getManagementContext().getApplications() );	apps.removeAll( MutableSet.of(app, newApp) );	Application newApp2 = Iterables.getOnlyElement(apps);	Entities.dumpInfo(newApp2);	EntityAsserts.assertAttributeEqualsEventually(newApp2, Attributes.SERVICE_UP, true);	Assert.assertEquals(newApp2.getConfig(TestEntity.CONF_NAME), "foo");	} finally {	l.destroyAll();	}	
DONE 

========================= brooklyn sample_559 =========================

private void removePermissionsInternal(JcloudsMachineLocation location, Iterable<IpPermission> permissions) {	ComputeService computeService = location.getParent().getComputeService();	String nodeId = location.getNode().getId();	final Optional<SecurityGroupExtension> securityApi = computeService.getSecurityGroupExtension();	if (!securityApi.isPresent()) {	
security group extension for absent cannot update node with 

private Map<String, SecurityGroup> addPermissionsInternal(Iterable<IpPermission> permissions, JcloudsMachineLocation location) {	String nodeId = location.getNode().getId();	final Location nodeLocation = location.getNode().getLocation();	ComputeService computeService = location.getParent().getComputeService();	final Optional<SecurityGroupExtension> securityApi = computeService.getSecurityGroupExtension();	if (!securityApi.isPresent()) {	
security group extension for absent cannot update node with 

unique = it.next();	} else {	unique = shared;	shared = it.next();	}	if (!shared.getName().endsWith(expectedSharedName)) {	LOG.warn("Couldn't determine which security group is shared between instances in app {}. Expected={}, found={}", new Object[]{ applicationId, expectedSharedName, groupsOnNode });	return null;	}	SecurityGroup old = sharedGroupCache.asMap().putIfAbsent(shared.getLocation(), shared);	
loaded unique security group for node in 

} else {	unique = shared;	shared = it.next();	}	if (!shared.getName().endsWith(expectedSharedName)) {	LOG.warn("Couldn't determine which security group is shared between instances in app {}. Expected={}, found={}", new Object[]{ applicationId, expectedSharedName, groupsOnNode });	return null;	}	SecurityGroup old = sharedGroupCache.asMap().putIfAbsent(shared.getLocation(), shared);	if (old == null) {	
proactively set shared group for app to 

}	if (!shared.getName().endsWith(expectedSharedName)) {	LOG.warn("Couldn't determine which security group is shared between instances in app {}. Expected={}, found={}", new Object[]{ applicationId, expectedSharedName, groupsOnNode });	return null;	}	SecurityGroup old = sharedGroupCache.asMap().putIfAbsent(shared.getLocation(), shared);	if (old == null) {	}	return unique;	} else {	
expected to find two security groups on node in app one shared one unique found 

public void customize(JcloudsLocation location, ComputeService computeService, Template template) {	final Optional<SecurityGroupExtension> securityApi = computeService.getSecurityGroupExtension();	if (!securityApi.isPresent()) {	
security group extension for absent cannot configure security groups in context 

public void customize(JcloudsLocation location, ComputeService computeService, Template template) {	final Optional<SecurityGroupExtension> securityApi = computeService.getSecurityGroupExtension();	if (!securityApi.isPresent()) {	} else if (template.getLocation() == null) {	
no location has been set on cannot configure security groups in context 

public void customize(JcloudsLocation location, ComputeService computeService, Template template) {	final Optional<SecurityGroupExtension> securityApi = computeService.getSecurityGroupExtension();	if (!securityApi.isPresent()) {	} else if (template.getLocation() == null) {	} else {	
configuring security groups on location in context 

private SecurityGroup getOrCreateSharedSecurityGroup(Location location, SecurityGroupEditor groupEditor) {	final String groupName = getNameForSharedSecurityGroup();	Optional<SecurityGroup> shared = groupEditor.findSecurityGroupByName(groupName);	if (shared.isPresent()) {	
found existing shared security group in for app 

private SecurityGroup getOrCreateSharedSecurityGroup(Location location, SecurityGroupEditor groupEditor) {	final String groupName = getNameForSharedSecurityGroup();	Optional<SecurityGroup> shared = groupEditor.findSecurityGroupByName(groupName);	if (shared.isPresent()) {	return shared.get();	} else {	
creating new shared security group in for app 

========================= brooklyn sample_2584 =========================

protected void assertLatencyAttributesNonNull(Entity entity) {	EntityAsserts.assertAttributeEventuallyNonNull(entity, HttpLatencyDetector.REQUEST_LATENCY_IN_SECONDS_MOST_RECENT);	EntityAsserts.assertAttributeEventuallyNonNull(entity, HttpLatencyDetector.REQUEST_LATENCY_IN_SECONDS_IN_WINDOW);	
latency to is 

protected void assertLatencyAttributesNonNull(Entity entity) {	EntityAsserts.assertAttributeEventuallyNonNull(entity, HttpLatencyDetector.REQUEST_LATENCY_IN_SECONDS_MOST_RECENT);	EntityAsserts.assertAttributeEventuallyNonNull(entity, HttpLatencyDetector.REQUEST_LATENCY_IN_SECONDS_IN_WINDOW);	
mean latency to is 

========================= brooklyn sample_2992 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	List<String> tags = Strings.toStringList(v);	if (LOG.isDebugEnabled()) {	
setting vm tags for 

========================= brooklyn sample_2615 =========================

public void testJclousMachineIsExpungedWhenStoppedDuringStart() throws Exception {	Map<String,?> allFlags = ImmutableMap.<String,Object>builder() .put("tags", ImmutableList.of(getClass().getName())) .put(JcloudsLocation.IMAGE_ID.getName(), IMAGE_ID) .put(JcloudsLocation.HARDWARE_ID.getName(), HARDWARE_ID) .put(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS.getName(), "") .put(JcloudsLocation.MACHINE_CREATE_ATTEMPTS.getName(), 1) .put(JcloudsLocation.OPEN_IPTABLES.getName(), true) .build();	JcloudsLocation jcloudsLocation = (JcloudsLocation)mgmt.getLocationRegistry().getLocationManaged(LOCATION_SPEC, allFlags);	final VanillaSoftwareProcess entity = app.createAndManageChild(EntitySpec.create(VanillaSoftwareProcess.class) .configure(VanillaSoftwareProcess.INSTALL_COMMAND, "echo install") .configure(VanillaSoftwareProcess.LAUNCH_COMMAND, "echo launch") .configure(VanillaSoftwareProcess.CHECK_RUNNING_COMMAND, "echo running"));	app.addLocations(ImmutableList.of(jcloudsLocation));	Task<Void> startTask = Entities.invokeEffector(app, app, Startable.START, ImmutableMap.of("locations", MutableList.of()));	EntityAsserts.assertAttributeEqualsEventually(entity, AttributesInternal.INTERNAL_PROVISIONING_TASK_STATE, AttributesInternal.ProvisioningTaskState.RUNNING);	Stopwatch stopwatch = Stopwatch.createStarted();	Entities.destroyCatching(app);	
time for expunging 

========================= brooklyn sample_2245 =========================

public void onManagementStarting(ManagementTransitionInfo info) {	try {	synchronized (this) {	boolean alreadyManaging = isDeployed();	if (alreadyManaging) {	
already managed onmanagementstarting is no op 

public void onManagementStarted(ManagementTransitionInfo info) {	try {	synchronized (this) {	boolean alreadyManaged = isFullyManaged();	if (alreadyManaged) {	
already managed onmanagementstarted is no op 

public void onManagementStopping(ManagementTransitionInfo info) {	synchronized (this) {	if (managementContext != info.getManagementContext()) {	throw new IllegalStateException("onManagementStopping encountered different management context for "+entity+ (!wasDeployed() ? " (wasn't deployed)" : !isDeployed() ? " (no longer deployed)" : "")+ ": "+managementContext+"; expected "+info.getManagementContext()+" (may be a pre-registered entity which was never properly managed)");	}	Stopwatch startTime = Stopwatch.createStarted();	while (!managementFailed.get() && nonDeploymentManagementContext!=null && nonDeploymentManagementContext.getMode()==NonDeploymentManagementContextMode.MANAGEMENT_STARTING) {	try {	if (startTime.elapsed(TimeUnit.SECONDS) > 30) {	
management stopping event in timed out waiting for start proceeding to stopping 

public void attemptLegacyAutodeployment(String effectorName) {	synchronized (this) {	if (managementContext != null) {	
autodeployment suggested but not required for 

public void attemptLegacyAutodeployment(String effectorName) {	synchronized (this) {	if (managementContext != null) {	return;	}	if (entity instanceof Application) {	
autodeployment with new management context triggered for will not be supported in future explicit manage call required 

initialManagementContext.getEntityManager().manage(entity);	} else {	Entities.startManagement(entity);	}	return;	}	}	if ("start".equals(effectorName)) {	Entity e=entity;	if (e.getParent()!=null && ((EntityInternal)e.getParent()).getManagementSupport().isDeployed()) {	
autodeployment in parent s management context triggered for will not be supported in future explicit manage call required 

return;	}	}	if ("start".equals(effectorName)) {	Entity e=entity;	if (e.getParent()!=null && ((EntityInternal)e.getParent()).getManagementSupport().isDeployed()) {	((EntityInternal)e.getParent()).getManagementContext().getEntityManager().manage(entity);	return;	}	}	
autodeployment not available for 

========================= brooklyn sample_1039 =========================

public T machine(SshMachineLocation machine) {	
not permitted to set machines on ignoring 

public T machine(SshMachineLocation machine) {	
source of attempt to set machines on source of attempt to set machines on 

========================= brooklyn sample_1486 =========================

public void testComplexOrdering() throws Exception {	List<String> data = new CopyOnWriteArrayList<String>();	SequentialTask<String> taskA = new SequentialTask<String>( appendAfterDelay(data, "a1"), appendAfterDelay(data, "a2"), appendAfterDelay(data, "a3"), appendAfterDelay(data, "a4"));	SequentialTask<String> taskB = new SequentialTask<String>( appendAfterDelay(data, "b1"), appendAfterDelay(data, "b2"), appendAfterDelay(data, "b3"), appendAfterDelay(data, "b4"));	Task<List<String>> t = ec.submit(new ParallelTask<String>(taskA, taskB));	t.get();	
tasks happened in order 

private BasicTask<String> appendAfterDelay(final List<String> list, final String value) {	return new BasicTask<String>(new Callable<String>() {	try {	Thread.sleep((int) (100 * Math.random()));	} catch (InterruptedException e) {	throw Throwables.propagate(e);	}	
running 

========================= brooklyn sample_918 =========================

public static MachineProvisioningLocation<? extends SshMachineLocation> createLocation(ManagementContext mgmt) {	LocationSpec<?> bestLocation = mgmt.getLocationRegistry().getLocationSpec("named:ChefTests").orNull();	if (bestLocation==null) {	
using aws for chef tests because named cheftests does not exist 

========================= brooklyn sample_2183 =========================

public void rebind() {	if (throwOnRebind) {	
throwing intentional exception to simulate failure of rebinding 

========================= brooklyn sample_627 =========================

public void setUp() throws Exception {	super.setUp();	
in abstractfollowthesunpolicytest setup 

protected MockContainerEntity newAsyncContainer(TestApplication app, Location loc, String name, long delay) {	MockContainerEntity container = app.createAndManageChild(EntitySpec.create(MockContainerEntity.class) .displayName(name) .configure(MockContainerEntity.DELAY, delay));	
managed new container 

protected static MockItemEntity newLockedItem(TestApplication app, MockContainerEntity container, String name) {	MockItemEntity item = app.createAndManageChild(EntitySpec.create(MockItemEntity.class) .displayName(name) .configure(MockItemEntity.IMMOVABLE, true));	
managed new locked item 

protected static MockItemEntity newItem(TestApplication app, MockContainerEntity container, String name) {	MockItemEntity item = app.createAndManageChild(EntitySpec.create(MockItemEntity.class) .displayName(name));	
managed new item at 

========================= brooklyn sample_3012 =========================

protected void finalize() throws Throwable {	
task was modified but modification was never used 

========================= brooklyn sample_1490 =========================

public List<LocationSummary> list() {	Function<LocationDefinition, LocationSummary> transformer = new Function<LocationDefinition, LocationSummary>() {	public LocationSummary apply(LocationDefinition l) {	try {	return LocationTransformer.newInstance(mgmt(), l, LocationDetailLevel.LOCAL_EXCLUDING_SECRET, ui.getBaseUriBuilder());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	String spec = l.getSpec();	if (spec == null || specsWarnedOnException.add(spec)) {	
unable to find details of location in rest call to list ignoring location 

public List<LocationSummary> list() {	Function<LocationDefinition, LocationSummary> transformer = new Function<LocationDefinition, LocationSummary>() {	public LocationSummary apply(LocationDefinition l) {	try {	return LocationTransformer.newInstance(mgmt(), l, LocationDetailLevel.LOCAL_EXCLUDING_SECRET, ui.getBaseUriBuilder());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	String spec = l.getSpec();	if (spec == null || specsWarnedOnException.add(spec)) {	
error details for location 

public List<LocationSummary> list() {	Function<LocationDefinition, LocationSummary> transformer = new Function<LocationDefinition, LocationSummary>() {	public LocationSummary apply(LocationDefinition l) {	try {	return LocationTransformer.newInstance(mgmt(), l, LocationDetailLevel.LOCAL_EXCLUDING_SECRET, ui.getBaseUriBuilder());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	String spec = l.getSpec();	if (spec == null || specsWarnedOnException.add(spec)) {	} else {	
unable again to find details of location in rest call to list ignoring location 

========================= brooklyn sample_2896 =========================

public static TaskFactory<?> runAnsible(final String dir, Object extraVars, String playbookName) {	String cmd = sudo(String.format("ansible-playbook " + optionalExtraVarsParameter(extraVars) + " -s %s.yaml", playbookName));	if (LOG.isDebugEnabled()) {	
ansible command 

========================= brooklyn sample_261 =========================

try {	Path configPath = Paths.get(configFile);	Path configFolder = configPath.normalize().getParent();	Config kubeconfig = KubeConfigUtils.parseConfig(configPath.toFile());	String currentContext = Optional.fromNullable(conf.get(KubernetesLocationConfig.KUBECONFIG_CONTEXT)).or(kubeconfig.getCurrentContext());	Optional<NamedContext> foundContext = Iterables.tryFind(kubeconfig.getContexts(), c -> c.getName().equals(currentContext));	if (!foundContext.isPresent()) {	throw new IllegalStateException(String.format("Context %s not found", currentContext));	}	Context context = foundContext.get().getContext();	
context additional properties 

throw new IllegalStateException(String.format("Context %s not found", currentContext));	}	Context context = foundContext.get().getContext();	configBuilder.withNamespace(context.getNamespace());	String user = context.getUser();	Optional<NamedAuthInfo> foundAuthInfo = Iterables.tryFind(kubeconfig.getUsers(), u -> u.getName().equals(user));	if (!foundAuthInfo.isPresent()) {	throw new IllegalStateException(String.format("Auth info %s not found", user));	}	AuthInfo auth = foundAuthInfo.get().getUser();	
auth info additional properties 

Optional<NamedCluster> foundCluster = Iterables.tryFind(kubeconfig.getClusters(), c -> c.getName().equals(clusterName));	if (!foundCluster.isPresent()) {	throw new IllegalStateException(String.format("Cluster %s not found", clusterName));	}	Cluster cluster = foundCluster.get().getCluster();	configBuilder.withMasterUrl(cluster.getServer());	configBuilder.withCaCertFile(getRelativeFile(cluster.getCertificateAuthority(), configFolder));	configBuilder.withCaCertData(cluster.getCertificateAuthorityData());	configBuilder.withApiVersion(Optional.fromNullable(cluster.getApiVersion()).or("v1"));	configBuilder.withTrustCerts(Boolean.TRUE.equals(cluster.getInsecureSkipTlsVerify()));	
cluster server 

Optional<NamedCluster> foundCluster = Iterables.tryFind(kubeconfig.getClusters(), c -> c.getName().equals(clusterName));	if (!foundCluster.isPresent()) {	throw new IllegalStateException(String.format("Cluster %s not found", clusterName));	}	Cluster cluster = foundCluster.get().getCluster();	configBuilder.withMasterUrl(cluster.getServer());	configBuilder.withCaCertFile(getRelativeFile(cluster.getCertificateAuthority(), configFolder));	configBuilder.withCaCertData(cluster.getCertificateAuthorityData());	configBuilder.withApiVersion(Optional.fromNullable(cluster.getApiVersion()).or("v1"));	configBuilder.withTrustCerts(Boolean.TRUE.equals(cluster.getInsecureSkipTlsVerify()));	
cluster additional properties 

========================= brooklyn sample_2480 =========================

public boolean isRunning() {	int exitCode = 1;	try {	exitCode = executeCommandInTask( getEntity().getConfig(VanillaWindowsProcess.CHECK_RUNNING_COMMAND), getEntity().getConfig(VanillaWindowsProcess.CHECK_RUNNING_POWERSHELL_COMMAND), "is-running-command");	} catch (Exception e) {	Throwable interestingCause = findExceptionCausedByWindowsRestart(e);	if (interestingCause != null) {	
isrunning check failed executing winrm command failed 

exitCode = executeCommandInTask( getEntity().getConfig(VanillaWindowsProcess.CHECK_RUNNING_COMMAND), getEntity().getConfig(VanillaWindowsProcess.CHECK_RUNNING_POWERSHELL_COMMAND), "is-running-command");	} catch (Exception e) {	Throwable interestingCause = findExceptionCausedByWindowsRestart(e);	if (interestingCause != null) {	return false;	} else {	throw e;	}	}	if(exitCode != 0) {	
isrunning check failed exit code 

========================= brooklyn sample_2341 =========================

final List<Exception> exceptions = Lists.newCopyOnWriteArrayList();	final Runnable work = new Runnable() {	public void run() {	int numConcurrentCalls = concurrentCallCount.incrementAndGet();	try {	if (numConcurrentCalls > 1) throw new IllegalStateException("numConcurrentCalls="+numConcurrentCalls);	int val = counter.incrementAndGet();	if (val >= numIterations) completionLatch.countDown();	} catch (Exception e) {	exceptions.add(e);	
exception in runnable of testexecutewithsinglethreadedscheduler 

exceptions.add(e);	throw Exceptions.propagate(e);	} finally {	concurrentCallCount.decrementAndGet();	}	}	};	measure(PerformanceTestDescriptor.create() .summary("TaskPerformanceTest.testExecuteWithSingleThreadedScheduler") .iterations(numIterations) .minAcceptablePerSecond(minRatePerSec) .job(new Runnable() {	public void run() {	while (submitCount.get() > counter.get() + 5000) {	
delaying because submitted and only run 

========================= brooklyn sample_723 =========================

public void setUp() throws Exception {	mementoDir = Os.newTempDir(getClass());	File mementoDirParent = mementoDir.getParentFile();	mementoDirBackup = new File(mementoDirParent, mementoDir.getName()+"."+Identifiers.makeRandomId(4)+".bak");	origApp = null;	newApp = null;	newManagementContext = null;	origManagementContext = createOrigManagementContext();	origApp = createApp();	
test persisting to 

for (Task<?> t: tasks) {	if (!t.isDone()) {	if (skipKnownBackgroundTasks) {	if (t.toString().indexOf("ssh-location cache cleaner")>=0) {	extraAllowedMax++;	}	}	unendedTasks++;	}	}	
count of incomplete tasks now unended allowed tasks remembered are 

========================= brooklyn sample_666 =========================

protected Optional<Task<?>> findTaskOrSubTask(Iterable<? extends Task<?>> tasks, Predicate<? super Task<?>> matcher) {	List<String> taskNames = Lists.newArrayList();	Optional<Task<?>> result = findTaskOrSubTaskImpl(tasks, matcher, taskNames);	if (!result.isPresent() && log.isDebugEnabled()) {	
task not found matching contender names were 

========================= brooklyn sample_1701 =========================

public Map<String, String> loadDeserializingMapping() {	synchronized (this) {	if (cache == null) {	MutableMap.Builder<String, String> builder = MutableMap.<String, String>builder();	for (ConfigLoader loader : loaders) {	builder.putAll(loader.load());	}	cache = builder.build();	
config cache loaded size 

========================= brooklyn sample_1146 =========================

public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {	Map map = (Map) source;	try {	for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) {	Map.Entry entry = (Map.Entry) iterator.next();	marshalEntry(writer, context, entry);	}	} catch (ConcurrentModificationException e) {	
map at modified while serializing will fail and retry may be attempted 

========================= brooklyn sample_1516 =========================

public static TaskFactory<?> installCookbook(final String chefDirectory, final String cookbookName, final String cookbookArchiveUrl, final boolean force) {	return new TaskFactory<TaskAdaptable<?>>() {	public TaskAdaptable<?> newTask() {	TaskBuilder<Void> tb = Tasks.<Void>builder().displayName("install cookbook "+cookbookName);	String cookbookDir = Urls.mergePaths(chefDirectory, cookbookName);	String privateTmpDirContainingUnpackedCookbook = Urls.mergePaths(chefDirectory, "tmp-"+Strings.makeValidFilename(cookbookName)+"-"+Identifiers.makeRandomId(4));	String destName = null;	if (ArchiveType.of(cookbookArchiveUrl)==ArchiveType.UNKNOWN) {	destName = cookbookName + ".tgz";	
assuming tgz type for chef cookbook url it will be downloaded as 

========================= brooklyn sample_2290 =========================

return tryLoadFromBundle(dispatcher, symbolicName, version, className);	}	if (symbolicName != null) {	cls = tryLoadFromBundle(dispatcher, symbolicName, version, className);	if (cls.isPresent()) {	return cls;	}	Maybe<T> result = loadClass(name, dispatcher, className);	String notFoundWithSymbolicNameMessage = "No class '"+className+"' in bundle '"+symbolicName+"' (using spec '"+name+"')";	if (result.isPresent()) {	
found using deprecated no bundle syntax but this behaviour is deprecated and likely to be unsupported in future change so invalid bundle is not supplied 

}	CatalogItem<?, ?> item = CatalogUtils.getCatalogItemOptionalVersion(mgmt, catalogItemId);	if (item != null) {	BrooklynClassLoadingContextSequential loader = new BrooklynClassLoadingContextSequential(mgmt);	loader.add(newClassLoadingContextForCatalogItems(mgmt, item.getCatalogItemId(), item.getCatalogItemIdSearchPath()));	cls = dispatcher.tryLoadFrom(loader, className);	if (cls.isPresent()) {	return cls;	}	} else {	
entity refers to non existent catalog item trying to load class 

protected <T> Maybe<T> tryLoadFromBundle(LoaderDispatcher<T> dispatcher, String symbolicName, String version, String name) {	Framework framework = getFramework();	if (framework != null) {	Maybe<Bundle> bundle = Osgis.bundleFinder(framework) .symbolicName(symbolicName) .version(version) .find();	if (bundle.isAbsent()) {	throw new IllegalStateException("Bundle " + toBundleString(symbolicName, version) + " not found to load " + name);	}	return dispatcher.tryLoadFrom(bundle.get(), name);	} else {	
request for bundle will be ignored as no framework available will look for in plain old classpath 

========================= brooklyn sample_1453 =========================

public static WebApplicationException notFound(String format, Object... args) {	String msg = String.format(format, args);	
returning notfound 

public static WebApplicationException preconditionFailed(String format, Object... args) {	String msg = String.format(format, args);	
returning preconditionfailed 

========================= brooklyn sample_1795 =========================

final AtomicReference<String> lastSeenState = new AtomicReference<>();	app.subscriptions().subscribe(app, TEST_SENSOR, new SensorEventListener<String>() {	public void onEvent(SensorEvent<String> event) {	lastSeenState.set(event.getValue());	log.debug("seen event=" + event);	}	});	Task<?> first = mgmt.getExecutionManager().submit(new Runnable() {	public void run() {	app.sensors().set(TEST_SENSOR, "first");	
set first 

}	});	Task<?> first = mgmt.getExecutionManager().submit(new Runnable() {	public void run() {	app.sensors().set(TEST_SENSOR, "first");	}	});	Task<?> second = mgmt.getExecutionManager().submit(new Runnable() {	public void run() {	app.sensors().set(TEST_SENSOR, "second");	
set second 

========================= brooklyn sample_758 =========================

protected void onErrorImpl(String errmsg, Exception e) {	if (rebindFailureMode == RebindManager.RebindFailureMode.FAIL_FAST) {	throw new IllegalStateException("Rebind: aborting due to "+errmsg, e);	} else {	if (Thread.currentThread().isInterrupted()) {	
rebind while interrupted received throwing interruption 

if (totalDangling>0) {	int totalFound = context.getAllBrooklynObjects().size();	int totalItems = totalFound + totalDangling;	if (context==null) {	allExceptions.add(new IllegalStateException("Dangling references ("+totalDangling+" of "+totalItems+") present without rebind context"));	} else {	if (!danglingRefsQuorumRequiredHealthy.isQuorate(totalFound, totalItems)) {	warn("Dangling item"+Strings.s(totalDangling)+" ("+totalDangling+" of "+totalItems+") found on rebind exceeds quorum, assuming failed: "+danglingIds);	allExceptions.add(new IllegalStateException("Too many dangling references: "+totalDangling+" of "+totalItems));	} else {	
dangling item of found on rebind assuming deleted 

if (rebindFailureMode != RebindManager.RebindFailureMode.CONTINUE) {	allExceptions.addAll(exceptions);	}	if (!started) {	allExceptions.add(new IllegalStateException(this+" was not informed of start of rebind run"));	}	if (allExceptions.isEmpty()) {	return;	} else {	RuntimeException compoundException = Exceptions.create("Failure rebinding", allExceptions);	
rethrowing 

========================= brooklyn sample_1111 =========================

protected void reconfigureService() {	Set<String> addresses = getServerPoolAddresses();	
test controller reconfigure targets 

========================= brooklyn sample_133 =========================

public <T> T loadInstance(Constructor<T> constructor, Object...argValues) throws IllegalArgumentException, ReflectionAccessException {	try {	try {	return constructor.newInstance(argValues);	} catch (IllegalArgumentException e) {	try {	
failure passing provided arguments attempting to reconstitute 

public <T> T loadInstance(Constructor<T> constructor, Object...argValues) throws IllegalArgumentException, ReflectionAccessException {	try {	try {	return constructor.newInstance(argValues);	} catch (IllegalArgumentException e) {	try {	argValues = (Object[]) updateFromNewClassLoader(argValues);	return constructor.newInstance(argValues);	} catch (Throwable e2) {	
reconstitution attempt failed will rethrow original excaption 

public final Object updateFromNewClassLoader(Object data) throws IOException, ClassNotFoundException {	ByteArrayOutputStream bytes = new ByteArrayOutputStream();	new ObjectOutputStream(bytes).writeObject(data);	Object reconstituted = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray())).readObject();	
reconstituted data class loader 

========================= brooklyn sample_2044 =========================

protected ConfigKey<?> getConfigKey(String key) {	ConfigKey<?> result = null;	if (configKeys!=null) {	result = configKeys.get(key);	if (result!=null && !LEGACY_KEY_DESCRIPTION.equals(result.getDescription())) return result;	}	ConfigKey<?> resultStatic = getStaticConfigKeys().get(key);	if (resultStatic!=null) return resultStatic;	if (result!=null) return result;	
config key 

protected AttributeSensor<?> getAttributeKey(String key) {	AttributeSensor<?> result=null;	if (attributeKeys!=null) {	result = attributeKeys.get(key);	if (result!=null && !LEGACY_KEY_DESCRIPTION.equals(result.getDescription())) return result;	}	AttributeSensor<?> resultStatic = (AttributeSensor<?>) getStaticSensorKeys().get(key);	if (resultStatic!=null) return resultStatic;	if (result!=null) return result;	
sensor 

========================= brooklyn sample_1107 =========================

RegisteredType item = internal.getManagementContext().getTypeRegistry().get(internal.getCatalogItemId());	if (item != null) {	final List<String> searchPath = internal.getCatalogItemIdSearchPath();	final ManagementContext managementContext = internal.getManagementContext();	BrooklynClassLoadingContextSequential seqLoader = new BrooklynClassLoadingContextSequential(managementContext);	seqLoader.add(newClassLoadingContextForCatalogItems(managementContext, inputCatalogItemId, searchPath));	JavaBrooklynClassLoadingContext entityLoader = JavaBrooklynClassLoadingContext.create(input.getClass().getClassLoader());	seqLoader.add(entityLoader);	return seqLoader;	} else {	
can t find catalog item used for instantiating entity falling back to application classpath 

========================= brooklyn sample_1042 =========================

public void testReadAManifest() throws Exception {	Enumeration<URL> manifests = this.getClass().getClassLoader().getResources("META-INF/MANIFEST.MF");	
bundles and exported packages 

public void testReadAManifest() throws Exception {	Enumeration<URL> manifests = this.getClass().getClassLoader().getResources("META-INF/MANIFEST.MF");	MutableSet<String> allPackages = MutableSet.of();	while (manifests.hasMoreElements()) {	ManifestHelper mf = ManifestHelper.forManifestContents(Streams.readFullyStringAndClose(manifests.nextElement().openStream()));	List<String> mfPackages = mf.getExportedPackages();	log.info("  " + mf.getSymbolicNameVersion() + ": " + mfPackages);	allPackages.addAll(mfPackages);	}	
total export package count 

========================= brooklyn sample_1853 =========================

public void testXpathWithEachEscapeCharacterAndXmlVersion() throws Exception {	List<Integer> errsInXml1_1 = Lists.newArrayList();	List<Integer> errsInXmlUnversioned = Lists.newArrayList();	for (int i = 0; i < Integer.valueOf("FFFF", 16); i++) {	String unicode = Integer.toHexString(i);	try {	String xml = Joiner.on("\n").join( "<?xml version=\"1.1\" encoding=\"UTF-8\"?>", "<a><b>myb</b><c>&#x"+unicode+";</c></a>");	assertEquals(XmlUtil.xpath(xml, "/a/b[text()]"), "myb");	assertTrue(isValidUnicodeInXml1_1(i), "i="+i+"; unicode="+unicode);	} catch (Throwable t) {	
failed for code 

assertTrue(isValidUnicodeInXml1_1(i), "i="+i+"; unicode="+unicode);	} catch (Throwable t) {	errsInXml1_1.add(Integer.valueOf(unicode, 16));	assertFalse(isValidUnicodeInXml1_1(i), "i="+i+"; unicode="+unicode);	}	try {	String xml = "<a><b>myb</b><c>&#x"+unicode+";</c></a>";	assertEquals(XmlUtil.xpath(xml, "/a/b[text()]"), "myb");	assertTrue(isValidUnicodeInXml1_0(i), "i="+i+"; unicode="+unicode);	} catch (Throwable t) {	
failed for code 

========================= brooklyn sample_934 =========================

public void imposeBackoffExponentialDelay(long period, long maxPeriod, int pow, int failureCount, int max, String commandDescription) {	long delayMs = (long) (period * Math.pow(failureCount, pow));	delayMs = (delayMs > maxPeriod) ? maxPeriod : delayMs;	
retry delaying for ms 

========================= brooklyn sample_1445 =========================

public boolean apply(@Nullable RegisteredType item) {	try {	String thingToCompare = item.getVersionedName().toString()+"\n"+ item.getVersionedName().toOsgiString()+"\n"+ item.getTags()+"\n"+ item.getDisplayName()+"\n"+ item.getAliases()+"\n"+ item.getDescription()+"\n"+ RegisteredTypes.getImplementationDataStringForSpec(item);	return filter.apply(thingToCompare);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem producing string representation of assuming no match and continuing 

========================= brooklyn sample_1015 =========================

protected void doOnce(int startingPort) {	final List<Integer> inboundPorts = getPorts(startingPort);	JcloudsSshMachineLocation machine;	try {	machine = obtainMachine(inboundPorts);	} catch (Exception e) {	
problem obtaining machine 

final List<Integer> inboundPorts = getPorts(startingPort);	JcloudsSshMachineLocation machine;	try {	machine = obtainMachine(inboundPorts);	} catch (Exception e) {	throw Exceptions.propagate(e);	}	try {	releaseMachine(machine);	} catch (Exception e) {	
problem releasing machine 

protected void doSecurityEditor(int n) throws Exception {	jcloudsLocation = (JcloudsLocation) managementContext.getLocationRegistry().getLocationManaged(LOCATION_SPEC);	final List<Integer> inboundPorts = ImmutableList.of(9999);	JcloudsSshMachineLocation machine;	try {	machine = obtainMachine(inboundPorts);	testSecurityEditorOnMachine(n, machine);	} catch (Exception e) {	
problem obtaining machine 

JcloudsSshMachineLocation machine;	try {	machine = obtainMachine(inboundPorts);	testSecurityEditorOnMachine(n, machine);	} catch (Exception e) {	throw Exceptions.propagate(e);	}	try {	releaseMachine(machine);	} catch (Exception e) {	
problem releasing machine 

========================= brooklyn sample_2510 =========================

public void testFeedDeDupe() throws Exception {	testReturnsStdoutAndInfersMachine();	entity.addFeed(feed);	
feed is 

public void testFeedDeDupe() throws Exception {	testReturnsStdoutAndInfersMachine();	entity.addFeed(feed);	testReturnsStdoutAndInfersMachine();	
feed is 

Supplier<String> cmdSupplier = new Supplier<String>() {	public String get() {	return "echo count-"+count.incrementAndGet()+"-%COUNT%";	}	};	feed = CmdFeed.builder() .entity(entity2) .poll(new CommandPollConfig<String>(SENSOR_STRING) .env(envSupplier) .command(cmdSupplier) .onSuccess(SshValueFunctions.stdout())) .build();	EntityAsserts.assertAttributeEventuallyNonNull(entity2, SENSOR_STRING);	final String val1 = assertDifferentOneInOutput(entity2);	EntityAsserts.assertAttributeEventually(entity2, SENSOR_STRING, Predicates.not(Predicates.equalTo(val1)));	final String val2 = assertDifferentOneInOutput(entity2);	
vals from dynamic sensors are and 

========================= brooklyn sample_2140 =========================

private LocationSpec<?> getLocationSpec(String spec) {	
obtaining location spec 

private KubernetesLocation resolve(String spec) {	
resolving location spec 

========================= brooklyn sample_2455 =========================

final String loginUser = groovyTruth(explicitLoginUser) ? explicitLoginUser : (image != null && image.getDefaultCredentials() != null) ? image.getDefaultCredentials().identity : null;	final boolean dontCreateUser = config.get(JcloudsLocation.DONT_CREATE_USER);	final boolean grantUserSudo = config.get(JcloudsLocation.GRANT_USER_SUDO);	final LocationConfigUtils.OsCredential credential = LocationConfigUtils.getOsCredential(config);	credential.checkNoErrors().logAnyWarnings();	final String passwordToSet = Strings.isNonBlank(credential.getPassword()) ? credential.getPassword() : Identifiers.makeRandomId(12);	final List<Statement> statements = Lists.newArrayList();	LoginCredentials createdUserCreds = null;	if (dontCreateUser) {	if (Strings.isBlank(user)) {	
not setting up user subsequently using loginuser 

final boolean grantUserSudo = config.get(JcloudsLocation.GRANT_USER_SUDO);	final LocationConfigUtils.OsCredential credential = LocationConfigUtils.getOsCredential(config);	credential.checkNoErrors().logAnyWarnings();	final String passwordToSet = Strings.isNonBlank(credential.getPassword()) ? credential.getPassword() : Identifiers.makeRandomId(12);	final List<Statement> statements = Lists.newArrayList();	LoginCredentials createdUserCreds = null;	if (dontCreateUser) {	if (Strings.isBlank(user)) {	config.put(JcloudsLocation.USER, loginUser);	} else {	
not creating user and not installing its password or authorizing keys assuming it exists 

if (credential.isUsingPassword()) {	createdUserCreds = LoginCredentials.builder().user(user).password(credential.getPassword()).build();	if (Boolean.FALSE.equals(config.get(JcloudsLocation.DISABLE_ROOT_AND_PASSWORD_SSH))) {	statements.add(SshStatements.sshdConfig(ImmutableMap.of("PasswordAuthentication", "yes")));	}	} else if (credential.hasKey()) {	createdUserCreds = LoginCredentials.builder().user(user).privateKey(credential.getPrivateKeyData()).build();	}	}	} else if (isWindows) {	
not creating or configuring user on windows vm despite set to false 

statements.add(SshStatements.sshdConfig(ImmutableMap.of("PasswordAuthentication", "yes")));	if (user.equals(JcloudsLocation.ROOT_USERNAME)) {	statements.add(SshStatements.sshdConfig(ImmutableMap.of("PermitRootLogin", "yes")));	}	}	} else {	String pubKey = credential.getPublicKeyData();	String privKey = credential.getPrivateKeyData();	if (credential.isEmpty()) {	if (!config.containsKey(JcloudsLocation.PRIVATE_KEY_FILE)) {	
default ssh keys not found or not usable will create new keys for each machine create ssh id rsa or set as appropriate for this location if you wish to be able to log in without brooklyn 

}	} else {	String pubKey = credential.getPublicKeyData();	String privKey = credential.getPrivateKeyData();	if (credential.isEmpty()) {	if (!config.containsKey(JcloudsLocation.PRIVATE_KEY_FILE)) {	}	KeyPair newKeyPair = SecureKeys.newKeyPair();	pubKey = SecureKeys.toPub(newKeyPair);	privKey = SecureKeys.toPem(newKeyPair);	
brooklyn key being created for at new machine is 

}	KeyPair newKeyPair = SecureKeys.newKeyPair();	pubKey = SecureKeys.toPub(newKeyPair);	privKey = SecureKeys.toPem(newKeyPair);	}	AdminAccess.Builder adminBuilder = AdminAccess.builder() .adminUsername(user) .grantSudoToAdminUser(grantUserSudo);	adminBuilder.cryptFunction(Sha512Crypt.function());	boolean useKey = Strings.isNonBlank(pubKey);	adminBuilder.cryptFunction(Sha512Crypt.function());	adminBuilder.adminPassword(passwordToSet);	
password being created for user at the machine we are about to provision in however a key will be used to access it this will be the only way to log in 

createdUserCreds = LoginCredentials.builder().user(user).password(passwordToSet).build();	}	if (!useKey || Boolean.FALSE.equals(config.get(JcloudsLocation.DISABLE_ROOT_AND_PASSWORD_SSH))) {	statements.add(SshStatements.sshdConfig(ImmutableMap.of("PasswordAuthentication", "yes")));	}	}	String customTemplateOptionsScript = config.get(JcloudsLocation.CUSTOM_TEMPLATE_OPTIONS_SCRIPT_CONTENTS);	if (Strings.isNonBlank(customTemplateOptionsScript)) {	statements.add(new LiteralStatement(customTemplateOptionsScript));	}	
machine we are about to create in will be customized with 

========================= brooklyn sample_2567 =========================

private Object transform(ConfigKey<?> key, Object value) {	if (value instanceof CharSequence) {	String raw = value.toString();	if (raw.startsWith(BROOKLYN_YAML_PREFIX)) {	CampYamlParser parser = mgmt.getScratchpad().get(CampYamlParser.YAML_PARSER_KEY);	if (parser == null) {	
not transforming external config as no camp yaml parser available 

========================= brooklyn sample_1062 =========================

for (ConfigKey<?> deprecatedKey: deprecatedKeys) {	Object x = null;	boolean foundX = false;	if (containsKey(deprecatedKey)) {	x = get(deprecatedKey);	foundX = true;	}	if (foundX) {	if (found) {	if (!Objects.equal(result, x)) {	
conflicting value from deprecated key value using preferred key value 

Object x = null;	boolean foundX = false;	if (containsKey(deprecatedKey)) {	x = get(deprecatedKey);	foundX = true;	}	if (foundX) {	if (found) {	if (!Objects.equal(result, x)) {	} else {	
deprecated key ignored has same value as preferred key 

x = get(deprecatedKey);	foundX = true;	}	if (foundX) {	if (found) {	if (!Objects.equal(result, x)) {	} else {	}	} else if (foundDeprecated) {	if (!Objects.equal(result, x)) {	
conflicting values from deprecated keys using instead of value instead of 

foundX = true;	}	if (foundX) {	if (found) {	if (!Objects.equal(result, x)) {	} else {	}	} else if (foundDeprecated) {	if (!Objects.equal(result, x)) {	} else {	
deprecated key ignored has same value as other deprecated key 

if (foundX) {	if (found) {	if (!Objects.equal(result, x)) {	} else {	}	} else if (foundDeprecated) {	if (!Objects.equal(result, x)) {	} else {	}	} else {	
deprecated key detected supplying value recommend changing to preferred key this will not be supported in future versions 

private synchronized Maybe<Object> getKeyMaybeInternal(ConfigKey<?> key, Function<String, Maybe<Object>> getKey) {	Maybe<Object> val = getKey.apply(key.getName());	String firstDeprecatedName = null;	Maybe<Object> firstDeprecatedVal = null;	for (String deprecatedName : key.getDeprecatedNames()) {	Maybe<Object> deprecatedVal = getKey.apply(deprecatedName);	if (deprecatedVal.isPresent()) {	if (val.isPresent()) {	if (!Objects.equal(val.get(), deprecatedVal.get())) {	
conflicting value for key from deprecated name using value from preferred name 

private synchronized Maybe<Object> getKeyMaybeInternal(ConfigKey<?> key, Function<String, Maybe<Object>> getKey) {	Maybe<Object> val = getKey.apply(key.getName());	String firstDeprecatedName = null;	Maybe<Object> firstDeprecatedVal = null;	for (String deprecatedName : key.getDeprecatedNames()) {	Maybe<Object> deprecatedVal = getKey.apply(deprecatedName);	if (deprecatedVal.isPresent()) {	if (val.isPresent()) {	if (!Objects.equal(val.get(), deprecatedVal.get())) {	} else {	
duplicate value for key from deprecated name using same value from preferred name 

Maybe<Object> firstDeprecatedVal = null;	for (String deprecatedName : key.getDeprecatedNames()) {	Maybe<Object> deprecatedVal = getKey.apply(deprecatedName);	if (deprecatedVal.isPresent()) {	if (val.isPresent()) {	if (!Objects.equal(val.get(), deprecatedVal.get())) {	} else {	}	} else if (firstDeprecatedVal != null && firstDeprecatedVal.isPresent()) {	if (!Objects.equal(firstDeprecatedVal.get(), deprecatedVal.get())) {	
conflicting value for key from deprecated name using earlier deprecated name 

for (String deprecatedName : key.getDeprecatedNames()) {	Maybe<Object> deprecatedVal = getKey.apply(deprecatedName);	if (deprecatedVal.isPresent()) {	if (val.isPresent()) {	if (!Objects.equal(val.get(), deprecatedVal.get())) {	} else {	}	} else if (firstDeprecatedVal != null && firstDeprecatedVal.isPresent()) {	if (!Objects.equal(firstDeprecatedVal.get(), deprecatedVal.get())) {	} else {	
duplicate value for key from deprecated name using same value from earlier depreated name 

if (deprecatedVal.isPresent()) {	if (val.isPresent()) {	if (!Objects.equal(val.get(), deprecatedVal.get())) {	} else {	}	} else if (firstDeprecatedVal != null && firstDeprecatedVal.isPresent()) {	if (!Objects.equal(firstDeprecatedVal.get(), deprecatedVal.get())) {	} else {	}	} else {	
value for key found with deprecated name recommend changing to preferred name this will not be supported in future versions 

========================= brooklyn sample_1432 =========================

private void checkImmutable(Object in) {	
node original value at should be immutable 

========================= brooklyn sample_1824 =========================

} else {	commands.addAll(installFromPackageCloud());	}	} else if (osDetails.isMac()) {	commands.addAll(installMac());	} else if (osDetails.isWindows()) {	throw new UnsupportedOperationException("RiakNode not supported on Windows instances");	} else {	throw new IllegalStateException("Machine was not detected as linux, mac or windows! Installation does not know how to proceed with " + getMachine() + ". Details: " + getMachine().getMachineDetails().getOsDetails());	}	
installing to using commands 

public void joinCluster(String nodeName) {	if (getRiakName().equals(nodeName)) {	
cannot join riak node to itself 

if (getRiakName().equals(nodeName)) {	} else {	if (!hasJoinedCluster()) {	ScriptHelper joinClusterScript = newScript("joinCluster") .body.append(sudo(format("%s cluster join %s", getRiakAdminCmd(), nodeName))) .body.append(sudo(format("%s cluster plan", getRiakAdminCmd()))) .body.append(sudo(format("%s cluster commit", getRiakAdminCmd()))) .failOnNonZeroResultCode();	if (!isRiakOnPath()) {	addRiakOnPath(joinClusterScript);	}	joinClusterScript.execute();	entity.sensors().set(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.TRUE);	} else {	
entity is already in the riak cluster 

public void leaveCluster() {	if (hasJoinedCluster()) {	ScriptHelper leaveClusterScript = newScript("leaveCluster") .body.append(sudo(format("%s cluster leave", getRiakAdminCmd()))) .body.append(sudo(format("%s cluster plan", getRiakAdminCmd()))) .body.append(sudo(format("%s cluster commit", getRiakAdminCmd()))) .failOnNonZeroResultCode();	if (!isRiakOnPath()) {	addRiakOnPath(leaveClusterScript);	}	leaveClusterScript.execute();	entity.sensors().set(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.FALSE);	} else {	
entity has already left the riak cluster 

String stopCommand = format("%s stop", getRiakCmd());	stopCommand = isPackageInstall() ? sudo(stopCommand) : stopCommand;	String startCommand = format("%s start > /dev/null 2>&1 < /dev/null &", getRiakCmd());	startCommand = isPackageInstall() ? sudo(startCommand) : startCommand;	ScriptHelper recoverNodeScript = newScript("recoverNode") .body.append(stopCommand) .body.append(format("%s down %s", getRiakAdminCmd(), failedNodeName)) .body.append(sudo(format("rm -rf %s", getRingStateDir()))) .body.append(startCommand) .body.append(sudo(format("%s cluster join %s", getRiakAdminCmd(), nodeName))) .body.append(sudo(format("%s cluster plan", getRiakAdminCmd()))) .body.append(sudo(format("%s cluster commit", getRiakAdminCmd()))) .failOnNonZeroResultCode();	if (!isRiakOnPath()) {	addRiakOnPath(recoverNodeScript);	}	recoverNodeScript.execute();	} else {	
entity is not in the riak cluster 

========================= brooklyn sample_410 =========================

private StartableMethods() {}	public static void start(Entity e, Collection<? extends Location> locations) {	
starting entity at 

public static void stop(Entity e) {	
stopping entity 

public static void stop(Entity e) {	DynamicTasks.queueIfPossible(stoppingChildren(e)).orSubmitAsync(e).getTask().getUnchecked();	
stopped entity 

public static void restart(Entity e) {	
restarting entity 

public static void restart(Entity e) {	DynamicTasks.queueIfPossible(restartingChildren(e)).orSubmitAsync(e).getTask().getUnchecked();	
restarted entity 

public static void stopSequentially(Iterable<? extends Startable> entities) {	List<Exception> exceptions = Lists.newArrayList();	List<Startable> failedEntities = Lists.newArrayList();	for (final Startable entity : entities) {	if (!Entities.isManaged((Entity)entity)) {	
not stopping because it is not managed continuing 

List<Exception> exceptions = Lists.newArrayList();	List<Startable> failedEntities = Lists.newArrayList();	for (final Startable entity : entities) {	if (!Entities.isManaged((Entity)entity)) {	continue;	}	try {	TaskAdaptable<Void> task = TaskTags.markInessential(Effectors.invocation((Entity)entity, Startable.STOP, Collections.emptyMap()));	DynamicTasks.submit(task, (Entity)entity).getUnchecked();	} catch (Exception e) {	
error stopping continuing with shutdown 

========================= brooklyn sample_1259 =========================

protected void finalize() {	
httpfeed builder created but build never called 

Set<HttpPollConfig<?>> configs = polls.get(pollInfo);	long minPeriod = Integer.MAX_VALUE;	Set<AttributePollHandler<? super HttpToolResponse>> handlers = Sets.newLinkedHashSet();	for (HttpPollConfig<?> config : configs) {	handlers.add(new AttributePollHandler<HttpToolResponse>(config, entity, this));	if (config.getPeriod() > 0) minPeriod = Math.min(minPeriod, config.getPeriod());	}	Callable<HttpToolResponse> pollJob;	pollJob = new Callable<HttpToolResponse>() {	public HttpToolResponse call() throws Exception {	
http polling for sensors at 

========================= brooklyn sample_1609 =========================

public void doStart(Collection<? extends Location> locations) {	sensors().set(SERVICE_UP, Boolean.FALSE);	Location provisioner = Iterables.getOnlyElement(locations);	
creating new dockerlocation wrapping 

public void stop() {	setExpectedStateAndRecordLifecycleEvent(Lifecycle.STOPPING);	sensors().set(SERVICE_UP, Boolean.FALSE);	try {	Iterable<Entity> entities = Iterables.filter(getManagementContext().getEntityManager().getEntities(), StubUtils.sameInfrastructure(this));	Set<Application> applications = ImmutableSet.copyOf(Iterables.transform(entities, new Function<Entity, Application>() {	public Application apply(Entity input) {	return input.getApplication();	}	}));	
stopping applications 

sensors().set(SERVICE_UP, Boolean.FALSE);	try {	Iterable<Entity> entities = Iterables.filter(getManagementContext().getEntityManager().getEntities(), StubUtils.sameInfrastructure(this));	Set<Application> applications = ImmutableSet.copyOf(Iterables.transform(entities, new Function<Entity, Application>() {	public Application apply(Entity input) {	return input.getApplication();	}	}));	Entities.invokeEffectorList(this, applications, Startable.STOP).get(Duration.THIRTY_SECONDS);	} catch (Exception e) {	
error stopping applications 

Set<Application> applications = ImmutableSet.copyOf(Iterables.transform(entities, new Function<Entity, Application>() {	public Application apply(Entity input) {	return input.getApplication();	}	}));	Entities.invokeEffectorList(this, applications, Startable.STOP).get(Duration.THIRTY_SECONDS);	} catch (Exception e) {	}	try {	DynamicCluster hosts = sensors().get(DOCKER_HOST_CLUSTER);	
stopping hosts 

return input.getApplication();	}	}));	Entities.invokeEffectorList(this, applications, Startable.STOP).get(Duration.THIRTY_SECONDS);	} catch (Exception e) {	}	try {	DynamicCluster hosts = sensors().get(DOCKER_HOST_CLUSTER);	Entities.invokeEffectorList(this, hosts.getMembers(), Startable.STOP).get(Duration.THIRTY_SECONDS);	} catch (Exception e) {	
error stopping hosts 

========================= brooklyn sample_2160 =========================

final List<MockContainerEntity> containersToStop = Lists.newArrayList();	for (int i = 0; i < NUM_CONTAINERS/2; i++) {	containersToStop.add(containers.remove(0));	}	for (final MockContainerEntity containerToStop : containersToStop) {	scheduledExecutor.submit(new Callable<Void>() {	try {	containerToStop.offloadAndStop(containers.get(containers.size()-1));	Entities.unmanage(containerToStop);	} catch (Throwable t) {	
error stopping container 

items.add(newItemWithPeriodicWorkrates(app, containers.get(i%NUM_CONTAINERS), "item"+i, 20));	}	for (int i = 0; i < NUM_CONTAINERS; i++) {	int indexToStop = (i < NUM_CONTAINERS/2) ? NUM_CONTAINERS : 0;	final MockItemEntity itemToStop = items.remove(indexToStop);	scheduledExecutor.submit(new Callable<Void>() {	try {	itemToStop.stop();	Entities.unmanage(itemToStop);	} catch (Throwable t) {	
error stopping item 

========================= brooklyn sample_3008 =========================

watcher.assertHasEventEventually();	} finally {	watcher.close();	}	assertFalse(stopFuture.isDone());	loc.getObtainResumeLatch(0).countDown();	stopFuture.get(Asserts.DEFAULT_LONG_TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);	try {	startFuture.get(Asserts.DEFAULT_LONG_TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);	} catch (ExecutionException e) {	
start failed during concurrent stop acceptable 

try {	int count = obtainCount.getAndIncrement();	calls.add("obtain");	getObtainCalledLatch(count).countDown();	getObtainResumeLatch(count).await();	if (obtainsToFail.contains(count)) {	throw new RuntimeException("Simulate failure in obtain");	}	SshMachineLocation result = getManagementContext().getLocationManager().createLocation(LocationSpec.create(SshMachineLocation.class) .parent(this) .configure(SshMachineLocation.SSH_TOOL_CLASS, RecordingSshTool.class.getName()) .configure("address","localhost"));	obtainedMachines.add(result);	
simulated obtain of machine 

public void release(SshMachineLocation machine) {	calls.add("release");	
simulated release of machine 

========================= brooklyn sample_2249 =========================

public abstract void setBrokerUrl();	public void preStop() {	try {	for (JMSDestination queue : queues.values()) {	queue.destroy();	}	} catch (Exception e) {	
error deleting queues from broker continuing with stop 

for (JMSDestination queue : queues.values()) {	queue.destroy();	}	} catch (Exception e) {	}	try {	for (JMSDestination topic : topics.values()) {	topic.destroy();	}	} catch (Exception e) {	
error deleting topics from broker continuing with stop 

========================= brooklyn sample_502 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof NovaTemplateOptions) {	((NovaTemplateOptions) t).generateKeyPair((Boolean) v);	} else if (t instanceof CloudStackTemplateOptions) {	((CloudStackTemplateOptions) t).generateKeyPair((Boolean) v);	} else {	
ignoring auto generate keypairs in vm creation because not supported for cloud type 

========================= brooklyn sample_2619 =========================

Collection<String> compiledFieldNames = findOuterClassFieldNames(type);	if (compiledFieldNames.size() == 0) {	throw new IllegalStateException("Unable to find any outer class fields in " + type + ", searching specifically for " + serializedFieldName);	}	Set<String> uniqueFieldNames = new HashSet<String>(compiledFieldNames);	String deserializeFieldName;	if (!compiledFieldNames.contains(serializedFieldName)) {	String msg = "Unable to find outer class field " + serializedFieldName + " in class " + type + ". " + "This could be caused by " + "1) changing the class (or one of its parents) to a static or " + "2) moving the class to a different lexical level (enclosing classes) or " + "3) using a different compiler (i.e eclipse vs oracle) at the time the object was serialized. ";	if (uniqueFieldNames.size() == 1) {	deserializeFieldName = compiledFieldNames.iterator().next();	
will use the field instead 

if (compiledFieldNames.size() == 0) {	throw new IllegalStateException("Unable to find any outer class fields in " + type + ", searching specifically for " + serializedFieldName);	}	Set<String> uniqueFieldNames = new HashSet<String>(compiledFieldNames);	String deserializeFieldName;	if (!compiledFieldNames.contains(serializedFieldName)) {	String msg = "Unable to find outer class field " + serializedFieldName + " in class " + type + ". " + "This could be caused by " + "1) changing the class (or one of its parents) to a static or " + "2) moving the class to a different lexical level (enclosing classes) or " + "3) using a different compiler (i.e eclipse vs oracle) at the time the object was serialized. ";	if (uniqueFieldNames.size() == 1) {	deserializeFieldName = compiledFieldNames.iterator().next();	} else {	
will fail with a field not found exception edit the persistence state manually and update the field names existing field names are 

String deserializeFieldName;	if (!compiledFieldNames.contains(serializedFieldName)) {	String msg = "Unable to find outer class field " + serializedFieldName + " in class " + type + ". " + "This could be caused by " + "1) changing the class (or one of its parents) to a static or " + "2) moving the class to a different lexical level (enclosing classes) or " + "3) using a different compiler (i.e eclipse vs oracle) at the time the object was serialized. ";	if (uniqueFieldNames.size() == 1) {	deserializeFieldName = compiledFieldNames.iterator().next();	} else {	deserializeFieldName = serializedFieldName;	}	} else {	if (uniqueFieldNames.size() > 1) {	
deserializing the non static class with multiple outer class fields when changing compilers it s possible that the instance won t be able to be deserialized due to changed outer class field names in those cases deserialization could fail with field not found exception or class cast exception following this log line 

========================= brooklyn sample_1520 =========================

timestamps.add(System.currentTimeMillis());	}});	}};	ScheduledTask t = new ScheduledTask(taskFactory).period(period);	em.submit(t);	t.cancel();	long cancelTime = System.currentTimeMillis();	int countImmediatelyAfterCancel = timestamps.size();	Thread.sleep(checkPeriod);	int countWellAfterCancel = timestamps.size();	
testcancancelscheduledtask saw then cancel then total 

========================= brooklyn sample_914 =========================

protected void testOperatingSystemProvider(String imageId, String provider, String region, String description) throws Exception {	
testing couchdb on using 

========================= brooklyn sample_282 =========================

protected Entity createMysql() {	Entity mysql = app.createAndManageChild(DynamicToyMySqlEntityChef.specSolo());	
created 

========================= brooklyn sample_2176 =========================

protected String initialValue() {	
no original name recorded for thread task 

public BasicExecutionManager(String contextid) {	threadFactory = newThreadFactory(contextid);	daemonThreadFactory = new ThreadFactoryBuilder() .setThreadFactory(threadFactory) .setDaemon(true) .build();	runner = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), daemonThreadFactory);	delayedRunner = new ScheduledThreadPoolExecutor(1, daemonThreadFactory);	if (jitterThreads) {	
task startup jittering enabled with a maximum of delay 

public void uncaughtException(Thread t, Throwable e) {	
uncaught exception in thread 

tasks.remove(task);	if (tasks.isEmpty()) {	tasksByTag.remove(tag);	}	}	}	}	Task<?> removed = tasksById.remove(task.getId());	incompleteTaskIds.remove(task.getId());	if (removed!=null && removed.isSubmitted() && !removed.isDone()) {	
deleting submitted task before completion this task will continue to run in the background outwith but perhaps it should have been cancelled 

private boolean shouldResubmitOnException(Callable<?> oldJob, Exception e) {	String message = "Error executing " + oldJob + " (scheduled job of " + task + " - " + task.getDescription() + ")";	if (Tasks.isInterrupted()) {	
cancelling scheduled execution 

private boolean shouldResubmitOnException(Callable<?> oldJob, Exception e) {	String message = "Error executing " + oldJob + " (scheduled job of " + task + " - " + task.getDescription() + ")";	if (Tasks.isInterrupted()) {	return false;	} else if (task.cancelOnException) {	
cancelling scheduled execution 

result = ((TaskInternal<T>)task).getJob().call();	} else throw new CancellationException();	} catch(Throwable e) {	error = e;	} finally {	afterEndAtomicTask(flags, task);	}	if (error!=null) {	if (log.isDebugEnabled()) {	if (error instanceof InterruptedException || error instanceof RuntimeInterruptedException) {	
detected interruption on task rethrowing 

} else throw new CancellationException();	} catch(Throwable e) {	error = e;	} finally {	afterEndAtomicTask(flags, task);	}	if (error!=null) {	if (log.isDebugEnabled()) {	if (error instanceof InterruptedException || error instanceof RuntimeInterruptedException) {	} else if (error instanceof NullPointerException || error instanceof IndexOutOfBoundsException || error instanceof ClassCastException) {	
exception running task rethrowing 

} catch(Throwable e) {	error = e;	} finally {	afterEndAtomicTask(flags, task);	}	if (error!=null) {	if (log.isDebugEnabled()) {	if (error instanceof InterruptedException || error instanceof RuntimeInterruptedException) {	} else if (error instanceof NullPointerException || error instanceof IndexOutOfBoundsException || error instanceof ClassCastException) {	} else {	
exception running task rethrowing 

} finally {	afterEndAtomicTask(flags, task);	}	if (error!=null) {	if (log.isDebugEnabled()) {	if (error instanceof InterruptedException || error instanceof RuntimeInterruptedException) {	} else if (error instanceof NullPointerException || error instanceof IndexOutOfBoundsException || error instanceof ClassCastException) {	} else {	}	if (log.isTraceEnabled()) {	
trace for exception running task rethrowing 

public boolean cancel(TaskCancellationMode mode) {	boolean result = false;	if (log.isTraceEnabled()) {	
clfft cancelling mode 

if (!task.isCancelled()) result |= ((TaskInternal<T>)task).cancel(mode);	result |= delegate().cancel(mode.isAllowedToInterruptTask());	if (mode.isAllowedToInterruptDependentSubmittedTasks()) {	int subtasksFound=0;	int subtasksReallyCancelled=0;	if (task instanceof HasTaskChildren) {	MutableList<Task<?>> childrenReversed = MutableList.copyOf( ((HasTaskChildren)task).getChildren() );	Collections.reverse(childrenReversed);	for (Task<?> child: childrenReversed) {	if (log.isTraceEnabled()) {	
cancelling on recursive cancellation of 

if (((TaskInternal<?>)child).cancel(mode)) {	result = true;	subtasksReallyCancelled++;	}	}	}	for (Task<?> t: execMgmt.getAllTasks()) {	if (task.equals(t.getSubmittedByTask())) {	if (mode.isAllowedToInterruptAllSubmittedTasks() || BrooklynTaskTags.isTransient(t)) {	if (log.isTraceEnabled()) {	
cancelling on recursive cancellation of 

}	subtasksFound++;	if (((TaskInternal<?>)t).cancel(mode)) {	result = true;	subtasksReallyCancelled++;	}	}	}	}	if (log.isTraceEnabled()) {	
on cancel of applicable subtask count of which were actively cancelled 

public void run() {	try {	((TaskInternal<?>)task).runListeners();	} catch (Exception e) {	
error running task listeners for task done 

public void run() {	try {	((TaskInternal<?>)task).runListeners();	} catch (Exception e) {	}	for (ExecutionListener listener : listeners) {	try {	listener.onTaskDone(task);	} catch (Exception e) {	
error running execution listener of task done 

protected <T> Task<T> submitNewTask(final Map<?,?> flags, final Task<T> task) {	if (log.isTraceEnabled()) {	
submitting task with flags and tags job caller unavailable 

protected <T> Task<T> submitNewTask(final Map<?,?> flags, final Task<T> task) {	if (log.isTraceEnabled()) {	if (Tasks.current()==null && BrooklynTaskTags.isTransient(task)) {	
stack trace for unparented submission of transient trace only not an error 

Set<TaskScheduler> schedulers = null;	for (Object tago: task.getTags()) {	TaskScheduler scheduler = getTaskSchedulerForTag(tago);	if (scheduler!=null) {	if (schedulers==null) schedulers = new LinkedHashSet<TaskScheduler>(2);	schedulers.add(scheduler);	}	}	Future<T> future;	if (schedulers!=null && !schedulers.isEmpty()) {	
multiple schedulers detected using only the first for 

protected void internalBeforeStart(Map<?,?> flags, Task<?> task) {	int count = activeTaskCount.incrementAndGet();	if (count % 1000==0) {	
high number of active tasks task is 

protected void internalBeforeStart(Map<?,?> flags, Task<?> task) {	int count = activeTaskCount.incrementAndGet();	if (count % 1000==0) {	}	
beforestart task running on thread 

private void jitterThreadStart(Task<?> task) {	if (jitterThreads) {	try {	Thread.sleep(ThreadLocalRandom.current().nextInt(jitterThreadsMaxDelay));	} catch (InterruptedException e) {	
task got cancelled before starting because of jitter 

static Object invokeCallback(Object callable, Task<?> task) {	if (callable instanceof Closure) {	if (!loggedClosureDeprecatedInInvokeCallback) {	
use of groovy lang closure is deprecated in executionmanager invokecallback 

protected void internalAfterEnd(Map<?,?> flags, Task<?> task, boolean startedInThisThread, boolean isEndingAllIterations) {	
afterend task 

if (isEndingAllIterations) {	incompleteTaskIds.remove(task.getId());	invokeCallback(flags.get("newTaskEndCallback"), task);	((TaskInternal<?>)task).setEndTimeUtc(System.currentTimeMillis());	}	if (startedInThisThread) {	PerThreadCurrentTaskHolder.perThreadCurrentTask.remove();	if (RENAME_THREADS && startedInThisThread) {	Thread thread = task.getThread();	if (thread==null) {	
basictask afterend invoked without corresponding beforestart 

public void setJitterThreads(boolean jitterThreads) {	this.jitterThreads = jitterThreads;	if (jitterThreads) {	
task startup jittering enabled with a maximum of delay 

public void setJitterThreads(boolean jitterThreads) {	this.jitterThreads = jitterThreads;	if (jitterThreads) {	} else {	
disabled task startup jittering 

public void setJitterThreadsMaxDelay(int jitterThreadsMaxDelay) {	this.jitterThreadsMaxDelay = jitterThreadsMaxDelay;	
setting task startup jittering maximum delay to 

========================= brooklyn sample_1473 =========================

String message = String.format("Invoking %s/%s on entity %s", eff, eff1Body, entity);	if (eff != eff2) {	Object eff2Body = (eff2 instanceof EffectorWithBody<?> ? ((EffectorWithBody<?>) eff2).getBody() : "bodyless");	message += String.format(" (actually %s/%s)", eff2, eff2Body);	}	log.trace(message);	}	if (eff2 != null) {	if (eff2 != eff) {	if (eff2 instanceof EffectorWithBody) {	
replacing invocation of on with which is the impl defined at that entity 

Object eff2Body = (eff2 instanceof EffectorWithBody<?> ? ((EffectorWithBody<?>) eff2).getBody() : "bodyless");	message += String.format(" (actually %s/%s)", eff2, eff2Body);	}	log.trace(message);	}	if (eff2 != null) {	if (eff2 != eff) {	if (eff2 instanceof EffectorWithBody) {	return ((EffectorWithBody<T>)eff2).getBody().newTask(entity, eff2, ConfigBag.newInstance().putAll(parameters));	} else {	
effector defined on has no body invoking caller supplied instead 

log.trace(message);	}	if (eff2 != null) {	if (eff2 != eff) {	if (eff2 instanceof EffectorWithBody) {	return ((EffectorWithBody<T>)eff2).getBody().newTask(entity, eff2, ConfigBag.newInstance().putAll(parameters));	} else {	}	}	} else {	
effector does not exist on attempting to invoke anyway 

========================= brooklyn sample_1166 =========================

Task<Void> task = Effectors.invocation(member, Startable.STOP, ImmutableMap.of()).asTask();	tasks.put(member, task);	}	}	DynamicTasks.queueIfPossible(Tasks.parallel("stopping "+tasks.size()+" member"+Strings.s(tasks.size())+" (parallel)", tasks.values())).orSubmitAsync(this);	try {	waitForTasksOnExpungeMembers(tasks);	} catch (RuntimeException e) {	Exceptions.propagateIfFatal(e);	exception = e;	
problem stopping members of quarantine group rethrowing after unmanaging members 

Map<Entity, Throwable> errors = Maps.newLinkedHashMap();	for (Map.Entry<? extends Entity,? extends Task<?>> entry : tasks.entrySet()) {	Entity member = entry.getKey();	Task<?> task = entry.getValue();	try {	task.get();	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	} catch (Throwable t) {	Throwable interesting = Exceptions.getFirstInteresting(t);	
quarantine group failed to stop quarantined entity removing 

Map<Entity, Throwable> errors = Maps.newLinkedHashMap();	for (Map.Entry<? extends Entity,? extends Task<?>> entry : tasks.entrySet()) {	Entity member = entry.getKey();	Task<?> task = entry.getValue();	try {	task.get();	} catch (InterruptedException e) {	throw Exceptions.propagate(e);	} catch (Throwable t) {	Throwable interesting = Exceptions.getFirstInteresting(t);	
trace for quarantine group failed to stop quarantined entity removing 

========================= brooklyn sample_1536 =========================

private static double parseDouble(String text, double defaultValue) {	try {	double d = Double.parseDouble(text);	if (!Double.isNaN(d)) return d;	} catch (Exception e) {	
illegal double value using default 

========================= brooklyn sample_3049 =========================

protected void doTest(Location loc) throws Exception {	Entity testEntity = app.createAndManageChild(EntitySpec.create(EmptySoftwareProcess.class));	app.start(ImmutableList.of(loc));	EntityAsserts.assertAttributeEqualsEventually(MutableMap.of("timeout", TIMEOUT_MS), testEntity, Startable.SERVICE_UP, true);	SshMachineLocation sshLoc = Locations.findUniqueSshMachineLocation(testEntity.getLocations()).get();	MachineDetails machine = app.getExecutionContext() .submit(BasicMachineDetails.taskForSshMachineLocation(sshLoc)) .getUnchecked();	
found the following at 

========================= brooklyn sample_2208 =========================

protected EntitySpec<?> getMemberSpec() {	EntitySpec<?> spec = EntitySpec.create(config().get(HazelcastCluster.MEMBER_SPEC));	spec.configure(HazelcastNode.NODE_CLUSTER_NAME, config().get(HazelcastCluster.CLUSTER_NAME));	spec.configure(HazelcastNode.GROUP_NAME, config().get(HazelcastCluster.CLUSTER_NAME));	if (LOG.isInfoEnabled()) {	
cluster name used as a group name 

public void init() {	super.init();	String clusterPassword = getClusterPassword();	if (Strings.isBlank(clusterPassword)) {	if (LOG.isInfoEnabled()) {	
cluster password not provided for generating random password 

protected void onEntityAdded(Entity member) {	if (member.getAttribute(HazelcastNode.NODE_NAME) == null) {	((EntityInternal) member).sensors().set(HazelcastNode.NODE_NAME, "hazelcast-" + nextMemberId.incrementAndGet());	if (LOG.isInfoEnabled()) {	
node added to the cluster 

========================= brooklyn sample_406 =========================

public boolean addMember(Entity member) {	synchronized (getAttributesSynchObjectInternal()) {	synchronized (members) {	if (Entities.isNoLongerManaged(member)) {	
group ignoring new member because it is no longer managed 

if (Entities.isNoLongerManaged(member)) {	return false;	}	Entity first = getAttribute(FIRST);	if (first == null) {	sensors().set(FIRST, member);	}	((EntityInternal)member).groups().add((Group)getProxyIfAvailable());	boolean changed = addMemberInternal(member);	if (changed) {	
group got new member 

if (first == null) {	sensors().set(FIRST, member);	}	((EntityInternal)member).groups().add((Group)getProxyIfAvailable());	boolean changed = addMemberInternal(member);	if (changed) {	sensors().set(GROUP_SIZE, getCurrentSize());	sensors().set(GROUP_MEMBERS, getMembers());	sensors().emit(MEMBER_ADDED, member);	if (Boolean.TRUE.equals(getConfig(MEMBER_DELEGATE_CHILDREN))) {	
use of deprecated configkey in as of 

public boolean removeMember(final Entity member) {	synchronized (getAttributesSynchObjectInternal()) {	synchronized (members) {	boolean changed = (member != null && members.remove(member));	if (changed) {	
group lost member 

Exception errorRemoving = null;	try {	((EntityInternal)member).groups().remove((Group)getProxyIfAvailable());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	errorRemoving = e;	}	getManagementSupport().getEntityChangeListener().onMembersChanged();	if (errorRemoving!=null) {	if (Entities.isNoLongerManaged(member)) {	
ignoring error when telling group unmanaged member is is removed 

public void setMembers(Collection<Entity> mm, Predicate<Entity> filter) {	synchronized (getAttributesSynchObjectInternal()) {	synchronized (members) {	
group members set explicitly to of which some possibly filtered 

========================= brooklyn sample_1561 =========================

public void connect() throws Exception {	try {	String jdbcUrl = "jdbc:" + url + dbName + "?" + "user=sqluser&password=sqluserpw";	
connecting to 

private void writeMetaData(ResultSet resultSet) throws SQLException {	
the columns in the table are 

private void writeMetaData(ResultSet resultSet) throws SQLException {	
table 

private void writeMetaData(ResultSet resultSet) throws SQLException {	for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {	
column 

private void writeResultSet(List<List<String>> resultSet) throws SQLException {	for (List<String> row : resultSet) {	String user = row.get(0);	String website = row.get(1);	String date = row.get(2);	String summary = row.get(3);	String comment = row.get(4);	
user 

private void writeResultSet(List<List<String>> resultSet) throws SQLException {	for (List<String> row : resultSet) {	String user = row.get(0);	String website = row.get(1);	String date = row.get(2);	String summary = row.get(3);	String comment = row.get(4);	
website 

private void writeResultSet(List<List<String>> resultSet) throws SQLException {	for (List<String> row : resultSet) {	String user = row.get(0);	String website = row.get(1);	String date = row.get(2);	String summary = row.get(3);	String comment = row.get(4);	
summary 

private void writeResultSet(List<List<String>> resultSet) throws SQLException {	for (List<String> row : resultSet) {	String user = row.get(0);	String website = row.get(1);	String date = row.get(2);	String summary = row.get(3);	String comment = row.get(4);	
date 

private void writeResultSet(List<List<String>> resultSet) throws SQLException {	for (List<String> row : resultSet) {	String user = row.get(0);	String website = row.get(1);	String date = row.get(2);	String summary = row.get(3);	String comment = row.get(4);	
comment 

========================= brooklyn sample_61 =========================

protected void doTest(Location loc) throws Exception {	
testing solr on 

========================= brooklyn sample_304 =========================

public void testJcloudsInheritanceAndPasswordSecret() throws Exception {	String yaml = Joiner.on("\n").join( "location:", "  " + LOCATION_CATALOG_ID + ":", "    password: $brooklyn:external(\"myprovider\", \"mykey\")", "    my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")", "services:", "- type: "+EmptySoftwareProcess.class.getName());	Application app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	
location 

public void testJcloudsInheritanceAndPasswordSecret() throws Exception {	String yaml = Joiner.on("\n").join( "location:", "  " + LOCATION_CATALOG_ID + ":", "    password: $brooklyn:external(\"myprovider\", \"mykey\")", "    my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")", "services:", "- type: "+EmptySoftwareProcess.class.getName());	Application app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	assertEquals(l.config().get(MY_CONFIG_KEY), "myval");	Maybe<Object> rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(MY_CONFIG_KEY);	
raw config 

public void testJcloudsInheritanceAndPasswordSecret() throws Exception {	String yaml = Joiner.on("\n").join( "location:", "  " + LOCATION_CATALOG_ID + ":", "    password: $brooklyn:external(\"myprovider\", \"mykey\")", "    my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")", "services:", "- type: "+EmptySoftwareProcess.class.getName());	Application app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	assertEquals(l.config().get(MY_CONFIG_KEY), "myval");	Maybe<Object> rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(MY_CONFIG_KEY);	Assert.assertTrue(rawConfig.isPresentAndNonNull());	Assert.assertTrue(rawConfig.get() instanceof DeferredSupplier, "Expected deferred raw value; got "+rawConfig.get());	rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(SshTool.PROP_PASSWORD);	
raw config password 

public void testProvisioningPropertyInheritance() throws Exception {	String yaml = Joiner.on("\n").join( "location: " + LOCATION_CATALOG_ID, "services:", "- type: "+EmptySoftwareProcess.class.getName(), "  provisioning.properties:", "      password: $brooklyn:external(\"myprovider\", \"mykey\")", "      simple: 42", "      my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")");	StartableApplication app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	
location 

public void testProvisioningPropertyInheritance() throws Exception {	String yaml = Joiner.on("\n").join( "location: " + LOCATION_CATALOG_ID, "services:", "- type: "+EmptySoftwareProcess.class.getName(), "  provisioning.properties:", "      password: $brooklyn:external(\"myprovider\", \"mykey\")", "      simple: 42", "      my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")");	StartableApplication app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	assertEquals(l.config().get(JcloudsLocation.PASSWORD), "myval");	Maybe<Object> rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(ConfigKeys.newStringConfigKey("password"));	
raw config password 

public void testProvisioningPropertyInheritance() throws Exception {	String yaml = Joiner.on("\n").join( "location: " + LOCATION_CATALOG_ID, "services:", "- type: "+EmptySoftwareProcess.class.getName(), "  provisioning.properties:", "      password: $brooklyn:external(\"myprovider\", \"mykey\")", "      simple: 42", "      my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")");	StartableApplication app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	assertEquals(l.config().get(JcloudsLocation.PASSWORD), "myval");	Maybe<Object> rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(ConfigKeys.newStringConfigKey("password"));	Assert.assertTrue(rawConfig.isPresentAndNonNull());	Assert.assertTrue(rawConfig.get() instanceof DeferredSupplier, "Expected deferred raw value; got "+rawConfig.get());	
my config key 

public void testProvisioningPropertyInheritance() throws Exception {	String yaml = Joiner.on("\n").join( "location: " + LOCATION_CATALOG_ID, "services:", "- type: "+EmptySoftwareProcess.class.getName(), "  provisioning.properties:", "      password: $brooklyn:external(\"myprovider\", \"mykey\")", "      simple: 42", "      my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")");	StartableApplication app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	assertEquals(l.config().get(JcloudsLocation.PASSWORD), "myval");	Maybe<Object> rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(ConfigKeys.newStringConfigKey("password"));	Assert.assertTrue(rawConfig.isPresentAndNonNull());	Assert.assertTrue(rawConfig.get() instanceof DeferredSupplier, "Expected deferred raw value; got "+rawConfig.get());	
my config key raw 

public void testProvisioningPropertyInheritance() throws Exception {	String yaml = Joiner.on("\n").join( "location: " + LOCATION_CATALOG_ID, "services:", "- type: "+EmptySoftwareProcess.class.getName(), "  provisioning.properties:", "      password: $brooklyn:external(\"myprovider\", \"mykey\")", "      simple: 42", "      my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")");	StartableApplication app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	assertEquals(l.config().get(JcloudsLocation.PASSWORD), "myval");	Maybe<Object> rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(ConfigKeys.newStringConfigKey("password"));	Assert.assertTrue(rawConfig.isPresentAndNonNull());	Assert.assertTrue(rawConfig.get() instanceof DeferredSupplier, "Expected deferred raw value; got "+rawConfig.get());	
simple simple 

public void testProvisioningPropertyInheritance() throws Exception {	String yaml = Joiner.on("\n").join( "location: " + LOCATION_CATALOG_ID, "services:", "- type: "+EmptySoftwareProcess.class.getName(), "  provisioning.properties:", "      password: $brooklyn:external(\"myprovider\", \"mykey\")", "      simple: 42", "      my.config.key: $brooklyn:external(\"myprovider\", \"mykey\")");	StartableApplication app = (StartableApplication) createAndStartApplication(new StringReader(yaml));	Entity entity = Iterables.getOnlyElement( app.getChildren() );	Location l = Iterables.getOnlyElement( entity.getLocations() );	assertEquals(l.config().get(JcloudsLocation.PASSWORD), "myval");	Maybe<Object> rawConfig = ((BrooklynObjectInternal.ConfigurationSupportInternal)l.config()).getRaw(ConfigKeys.newStringConfigKey("password"));	Assert.assertTrue(rawConfig.isPresentAndNonNull());	Assert.assertTrue(rawConfig.get() instanceof DeferredSupplier, "Expected deferred raw value; got "+rawConfig.get());	
simple raw simple 

========================= brooklyn sample_1633 =========================

public static List<Map<String, Object>> toItemDescriptors(Iterable<? extends Class<? extends BrooklynObject>> types, boolean headingsOnly, final String sortField) {	List<Map<String, Object>> itemDescriptors = Lists.newArrayList();	for (Class<? extends BrooklynObject> type : types) {	try {	Map<String, Object> itemDescriptor = toItemDescriptor(type, headingsOnly);	itemDescriptors.add(itemDescriptor);	} catch (Throwable throwable) {	if (throwable instanceof InterruptedException) throw new RuntimeInterruptedException((InterruptedException) throwable);	if (throwable instanceof RuntimeInterruptedException) throw (RuntimeInterruptedException) throwable;	
could not load 

========================= brooklyn sample_2766 =========================

public void testOutputAsExpected() throws Exception {	final String CONTENTS = "hello world\n" + "bye bye\n";	execCommands("cat > "+Os.mergePaths(Os.tmp(), "test1")+" << X\n" + CONTENTS + "X\n");	String read = execCommands("echo START_FOO", "cat "+Os.mergePaths(Os.tmp(), "test1"), "echo END_FOO");	
read back data written as 

========================= brooklyn sample_884 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof SoftLayerTemplateOptions) {	((SoftLayerTemplateOptions) t).domainName(TypeCoercions.coerce(v, String.class));	} else {	
ignoring domain name in vm creation because not supported for cloud type 

========================= brooklyn sample_2623 =========================

public void testObtain() {	String localUrl = MavenRetriever.localUrl(BrooklynMavenArtifacts.artifact("", "brooklyn-dist", "tar.gz", "dist"));	String userName = "admin";	String userPassword = Identifiers.makeRandomPassword(6);	String remoteConfig = Joiner.on('\n').join(MutableList.of( "brooklyn.webconsole.security.users=" + userName, "brooklyn.webconsole.security.user.admin.password=" + userPassword) .appendAll(getLocationConfig()) .append("\n"));	
using distribution 

public void testObtain() {	String localUrl = MavenRetriever.localUrl(BrooklynMavenArtifacts.artifact("", "brooklyn-dist", "tar.gz", "dist"));	String userName = "admin";	String userPassword = Identifiers.makeRandomPassword(6);	String remoteConfig = Joiner.on('\n').join(MutableList.of( "brooklyn.webconsole.security.users=" + userName, "brooklyn.webconsole.security.user.admin.password=" + userPassword) .appendAll(getLocationConfig()) .append("\n"));	
remote credentials are 

public void testObtain() {	String localUrl = MavenRetriever.localUrl(BrooklynMavenArtifacts.artifact("", "brooklyn-dist", "tar.gz", "dist"));	String userName = "admin";	String userPassword = Identifiers.makeRandomPassword(6);	String remoteConfig = Joiner.on('\n').join(MutableList.of( "brooklyn.webconsole.security.users=" + userName, "brooklyn.webconsole.security.user.admin.password=" + userPassword) .appendAll(getLocationConfig()) .append("\n"));	
remote config 

========================= brooklyn sample_36 =========================

public void obtainLocationWithGeography() throws Exception {	mgmt.getBrooklynProperties().put("brooklyn.location.named.lhx", "localhost");	mgmt.getBrooklynProperties().put("brooklyn.location.named.lhx.latitude", 42d);	mgmt.getBrooklynProperties().put("brooklyn.location.named.lhx.longitude", -20d);	MachineProvisioningLocation<?> p = (MachineProvisioningLocation<?>) mgmt.getLocationRegistry().getLocationManaged("named:lhx");	SshMachineLocation m = (SshMachineLocation) p.obtain(MutableMap.of());	HostGeoInfo geo = HostGeoInfo.fromLocation(m);	
geo info for is 

========================= brooklyn sample_979 =========================

public Void call(ConfigBag parametersO) {	if (!isPersistenceModeEnabled(entity())) {	DynamicTasks.queue( Tasks.warning("Check persistence", new IllegalStateException("Persistence does not appear to be enabled at this cluster. " + "In-place node upgrade will not succeed unless a custom launch script enables it.")) );	}	final ConfigBag parameters = ConfigBag.newInstanceCopying(parametersO);	if (parameters.containsKey(EXTRA_CONFIG)) {	Map<String, Object> extra = parameters.get(EXTRA_CONFIG);	parameters.remove(EXTRA_CONFIG);	parameters.putAll(extra);	}	
upgrading using 

if(doDryRunFirst) {	bkName = dryRunUpdate(parameters);	} else {	bkName = "direct-"+Identifiers.makeRandomId(4);	}	DynamicTasks.queue(Tasks.builder().displayName("shutdown node") .add(Effectors.invocation(entity(), BrooklynNode.STOP_NODE_BUT_LEAVE_APPS, ImmutableMap.of(StopSoftwareParameters.STOP_MACHINE_MODE, StopMode.NEVER))) .build());	DynamicTasks.queue(Tasks.builder().displayName("backup old version").body(new Runnable() {	public void run() {	String runDir = entity().getAttribute(SoftwareProcess.RUN_DIR);	String bkDir = Urls.mergePaths(runDir, "..", Urls.getBasename(runDir)+"-backups", bkName);	
storing backup of previous version in 

========================= brooklyn sample_2361 =========================

private long startApp() {	Stopwatch stopwatch = Stopwatch.createStarted();	app.start(Collections.singleton(localhost));	long result = stopwatch.elapsed(TimeUnit.MILLISECONDS);	
took for app start to complete 

private void checkChildComesUpSoon() {	Stopwatch stopwatch = Stopwatch.createStarted();	EntityAsserts.assertAttributeEqualsEventually(p2, Attributes.SERVICE_UP, true);	
took for child process to be service up 

private long timediff() {	Long d1 = getRunTimeUtc(p1);	Long d2 = getRunTimeUtc(p2);	
timestamps for have difference 

private void prep(ChildStartableMode mode) {	String parentCmd = "echo utc `date +%s` > DATE ; echo human `date` >> DATE ; " + "{ nohup sleep 60 & } ; echo $! > $PID_FILE ; sleep "+PARENT_TASK_SLEEP_LENGTH_SECS;	String childCmd = "echo utc `date +%s` > DATE ; echo human `date` >> DATE ; " + "{ nohup sleep 60 & } ; echo $! > $PID_FILE ; sleep "+CHILD_TASK_SLEEP_LENGTH_SECS;	p1 = app.createAndManageChild(EntitySpec.create(VanillaSoftwareProcess.class) .configure(VanillaSoftwareProcess.LAUNCH_COMMAND, parentCmd) .configure(VanillaSoftwareProcess.CHILDREN_STARTABLE_MODE, mode) );	p2 = p1.addChild(EntitySpec.create(VanillaSoftwareProcess.class) .configure(VanillaSoftwareProcess.LAUNCH_COMMAND, childCmd));	
testing using and 

========================= brooklyn sample_2224 =========================

public void apply(@SuppressWarnings("deprecation") final org.apache.brooklyn.api.entity.EntityLocal entity) {	final AttributeSensor<ReleaseableLatch> sensor = Sensors.newSensor(ReleaseableLatch.class, sensorName);	((EntityInternal) entity).getMutableEntityType().addSensor(sensor);	final Task<ReleaseableLatch> resolveValueTask = DependentConfiguration.maxConcurrency(maxConcurrency);	class SetValue implements Runnable {	public void run() {	ReleaseableLatch releaseableLatch = resolveValueTask.getUnchecked();	
setting sensor to on 

========================= brooklyn sample_1408 =========================

protected void onUpdated() {	try {	emit(targetSensor, compute());	} catch (Throwable t) {	
error calculating and setting combination for enricher 

========================= brooklyn sample_996 =========================

super.setEntity(entity);	checkConfig();	sensors = resolveSensorsConfig();	if (sensors.isEmpty()) {	mapMatching = Optional.of(resolveMapMatchingConfig());	} else {	mapMatching = Optional.absent();	}	sensorNameConverter = getRequiredConfig(SENSOR_NAME_CONVERTER);	subscriptions().subscribe(entity, AbstractEntity.LOCATION_ADDED, new SensorEventListener<Location>() {	
attempting transformations triggered by location added to 

}	Maybe<MachineLocation> machine = getMachine();	if (machine.isAbsent()) {	return;	}	for (AttributeSensor<?> sensor : sensors) {	try {	tryTransform(machine.get(), sensor);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem transforming sensor of 

Exceptions.propagateIfFatal(e);	}	}	if (mapMatching.isPresent()) {	for (Sensor<?> sensor : entity.getEntityType().getSensors()) {	if (sensor instanceof AttributeSensor && mapMatching.get().apply(sensor)) {	try {	tryTransform(machine.get(), (AttributeSensor<?>)sensor);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem transforming sensor of 

return;	}	Maybe<String> newVal = transformVal(machine, sensor, sensorVal);	if (newVal.isAbsent()) {	return;	}	AttributeSensor<String> mappedSensor = Sensors.newStringSensor(sensorNameConverter.apply(sensor.getName()));	if (newVal.get().equals(entity.sensors().get(mappedSensor))) {	return;	}	
publishing value original sensor value for mapped sensor of entity 

protected Maybe<String> transformUri(Entity source, MachineLocation machine, String sensorVal) {	URI uri = URI.create(sensorVal);	int port = uri.getPort();	if (port == -1 && "http".equalsIgnoreCase(uri.getScheme())) port = 80;	if (port == -1 && "https".equalsIgnoreCase(uri.getScheme())) port = 443;	if (port != -1) {	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, port);	if (!mappedEndpoint.isPresent()) {	
network facing enricher not transforming uri because no port mapping for 

URI uri = URI.create(sensorVal);	int port = uri.getPort();	if (port == -1 && "http".equalsIgnoreCase(uri.getScheme())) port = 80;	if (port == -1 && "https".equalsIgnoreCase(uri.getScheme())) port = 443;	if (port != -1) {	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, port);	if (!mappedEndpoint.isPresent()) {	return Maybe.absent();	}	if (!mappedEndpoint.get().hasPort()) {	
network facing enricher not transforming uri because no port in target for 

if (!mappedEndpoint.isPresent()) {	return Maybe.absent();	}	if (!mappedEndpoint.get().hasPort()) {	return Maybe.absent();	}	URI result;	try {	result = new URI(uri.getScheme(), uri.getUserInfo(), mappedEndpoint.get().getHostText(), mappedEndpoint.get().getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());	} catch (URISyntaxException e) {	
error transforming uri using target rethrowing 

return Maybe.absent();	}	URI result;	try {	result = new URI(uri.getScheme(), uri.getUserInfo(), mappedEndpoint.get().getHostText(), mappedEndpoint.get().getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());	} catch (URISyntaxException e) {	throw Exceptions.propagateAnnotated("Error transforming URI "+uri+", using target "+mappedEndpoint, e);	}	return Maybe.of(result.toString());	} else {	
sensor mapper not transforming uri because no port defined 

protected Maybe<String> transformHostAndPort(Entity source, MachineLocation machine, String sensorVal) {	HostAndPort hostAndPort = HostAndPort.fromString(sensorVal);	if (hostAndPort.hasPort()) {	int port = hostAndPort.getPort();	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, port);	if (!mappedEndpoint.isPresent()) {	
network facing enricher not transforming host and port because no port mapping for 

protected Maybe<String> transformHostAndPort(Entity source, MachineLocation machine, String sensorVal) {	HostAndPort hostAndPort = HostAndPort.fromString(sensorVal);	if (hostAndPort.hasPort()) {	int port = hostAndPort.getPort();	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, port);	if (!mappedEndpoint.isPresent()) {	return Maybe.absent();	}	if (!mappedEndpoint.get().hasPort()) {	
network facing enricher not transforming host and port because no port in target for 

int port = hostAndPort.getPort();	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, port);	if (!mappedEndpoint.isPresent()) {	return Maybe.absent();	}	if (!mappedEndpoint.get().hasPort()) {	return Maybe.absent();	}	return Maybe.of(mappedEndpoint.get().toString());	} else {	
network facing enricher not transforming host and port because defines no port 

protected Maybe<String> transformPort(Entity source, MachineLocation machine, int sensorVal) {	if (Networking.isPortValid(sensorVal)) {	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, sensorVal);	if (!mappedEndpoint.isPresent()) {	
network facing enricher not transforming port because no port mapping for 

protected Maybe<String> transformPort(Entity source, MachineLocation machine, int sensorVal) {	if (Networking.isPortValid(sensorVal)) {	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, sensorVal);	if (!mappedEndpoint.isPresent()) {	return Maybe.absent();	}	if (!mappedEndpoint.get().hasPort()) {	
network facing enricher not transforming port because no port in target for 

if (Networking.isPortValid(sensorVal)) {	Optional<HostAndPort> mappedEndpoint = getMappedEndpoint(source, machine, sensorVal);	if (!mappedEndpoint.isPresent()) {	return Maybe.absent();	}	if (!mappedEndpoint.get().hasPort()) {	return Maybe.absent();	}	return Maybe.of(mappedEndpoint.get().toString());	} else {	
network facing enricher not transforming port because not a valid port 

========================= brooklyn sample_1367 =========================

public void testCustomSerializerWithSerializableSillyManagementExample() throws Exception {	ManagementContext mgmt = LocalManagementContextForTests.newInstance();	try {	ObjectMapper mapper = BrooklynJacksonJsonProvider.newPrivateObjectMapper(mgmt);	SillyClassWithManagementContext silly = new SillyClassWithManagementContext("123", mgmt);	
silly is 

public void testCustomSerializerWithSerializableSillyManagementExample() throws Exception {	ManagementContext mgmt = LocalManagementContextForTests.newInstance();	try {	ObjectMapper mapper = BrooklynJacksonJsonProvider.newPrivateObjectMapper(mgmt);	SillyClassWithManagementContext silly = new SillyClassWithManagementContext("123", mgmt);	String sillyS = mapper.writeValueAsString(silly);	
silly json is 

public void testCustomSerializerWithSerializableSillyManagementExample() throws Exception {	ManagementContext mgmt = LocalManagementContextForTests.newInstance();	try {	ObjectMapper mapper = BrooklynJacksonJsonProvider.newPrivateObjectMapper(mgmt);	SillyClassWithManagementContext silly = new SillyClassWithManagementContext("123", mgmt);	String sillyS = mapper.writeValueAsString(silly);	SillyClassWithManagementContext silly2 = mapper.readValue(sillyS, SillyClassWithManagementContext.class);	
is 

========================= brooklyn sample_2818 =========================

config.append("    server_name "+domain+";\n");	boolean hasRoot = false;	ProxySslConfig localSslConfig = null;	for (UrlMapping mappingInDomain : mappingsByDomain.get(domain)) {	ProxySslConfig sslConfig = mappingInDomain.getConfig(UrlMapping.SSL_CONFIG);	if (sslConfig!=null) {	verifyConfig(sslConfig);	if (localSslConfig!=null) {	if (localSslConfig.equals(sslConfig)) {	} else {	
mapping provides ssl config for when a different config had already been provided by another mapping ignoring this one 

ProxySslConfig sslConfig = mappingInDomain.getConfig(UrlMapping.SSL_CONFIG);	if (sslConfig!=null) {	verifyConfig(sslConfig);	if (localSslConfig!=null) {	if (localSslConfig.equals(sslConfig)) {	} else {	}	} else if (globalSslConfig!=null) {	if (globalSslConfig.equals(sslConfig)) {	} else {	
mapping provides ssl config for when a different config had been provided at root nginx scope ignoring this one 

}	}	}	if (localSslConfig != null) {	appendSslConfig(domain, config, "    ", localSslConfig, true, true);	appendCodeForProxySSLConfig(domain, config, "    ", localSslConfig);	}	for (UrlMapping mappingInDomain : mappingsByDomain.get(domain)) {	boolean isRoot = mappingInDomain.getPath()==null || mappingInDomain.getPath().length()==0 || mappingInDomain.getPath().equals("/");	if (isRoot && hasRoot) {	
mapping provides a duplicate proxy ignoring 

========================= brooklyn sample_200 =========================

public void testBasicConfigInheritanceProgrammatic() throws Exception {	origApp.config().set(key1, "1");	rebind();	String entityFile = Streams.readFully(new FileReader(new File(mementoDir, "entities/"+origApp.getApplicationId())));	
persisted file with config inheritance programmatic 

========================= brooklyn sample_650 =========================

public void onSuccess(V val) {	if (lastWasProblem) {	if (currentProblemLoggedAsWarning) {	
success following previous problem reading 

public void onSuccess(V val) {	if (lastWasProblem) {	if (currentProblemLoggedAsWarning) {	} else {	
success following previous problem reading 

public void onSuccess(V val) {	if (lastWasProblem) {	if (currentProblemLoggedAsWarning) {	} else {	}	lastWasProblem = false;	currentProblemStartTime = null;	currentProblemLoggedAsWarning = false;	}	lastSuccessTime = System.currentTimeMillis();	
poll for got 

public void onException(Exception exception) {	if (!feed.isConnected()) {	
read of in gave exception while not connected or not yet connected 

protected void setSensor(Object v) {	if (Entities.isNoLongerManaged(entity)) {	if (Tasks.isInterrupted()) return;	
is not managed feed setting to at this time is not supported 

========================= brooklyn sample_1388 =========================

public synchronized void resetDelegate(Entity thisProxy, Entity preferredProxy, Entity newDelegate) {	if (LOG.isTraceEnabled()) {	
updating to be the same as pointing at temporary proxies 

protected boolean isMaster() {	if (isMaster!=null) return isMaster;	ManagementContext mgmt = ((EntityInternal)delegate).getManagementContext();	ManagementTransitionMode mode = ((EntityManagerInternal)mgmt.getEntityManager()).getLastManagementTransitionMode(delegate.getId());	Boolean ro = ((EntityInternal)delegate).getManagementSupport().isReadOnlyRaw();	if (mode==null || ro==null) {	return false;	}	boolean isMasterX = !mode.isReadOnly();	if (isMasterX != !ro) {	
inconsistent read only state for possibly rebinding management thinks but entity thinks 

========================= brooklyn sample_1330 =========================

private void runMany(Runnable task, String context, int iterations) throws Exception {	MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();	ObjectName osMBeanName = ObjectName.getInstance(ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME);	long preCpuTime = (Long) mbeanServer.getAttribute(osMBeanName, "ProcessCpuTime");	Stopwatch stopwatch = Stopwatch.createStarted();	for (int i = 0; i < iterations; i++) {	task.run();	long postCpuTime = (Long) mbeanServer.getAttribute(osMBeanName, "ProcessCpuTime");	long elapsedTime = stopwatch.elapsed(TimeUnit.MILLISECONDS);	double fractionCpu = (elapsedTime > 0) ? ((double)postCpuTime-preCpuTime) / TimeUnit.MILLISECONDS.toNanos(elapsedTime) : -1;	
executing completed took fraction cpu 

========================= brooklyn sample_892 =========================

public void onFailure(Object problem) {	if (log != null) {	
detected failure in monitor accessing 

========================= brooklyn sample_2770 =========================

protected void addServerPoolMemberTrackingPolicy() {	Group serverPool = getServerPool();	if (serverPool == null) {	return;	}	if (serverPoolMemberTrackerPolicy != null) {	
call to addserverpoolmembertrackingpolicy when serverpoolmembertrackingpolicy already exists removing and re adding in 

protected void addServerPoolMemberTrackingPolicy() {	Group serverPool = getServerPool();	if (serverPool == null) {	return;	}	if (serverPoolMemberTrackerPolicy != null) {	removeServerPoolMemberTrackingPolicy();	}	for (Policy p: policies()) {	if (p instanceof ServerPoolMemberTrackerPolicy) {	
picking up as the tracker already set often due to rebind 

AttributeSensor<?> hostAndPortSensor = getConfig(HOST_AND_PORT_SENSOR);	AttributeSensor<?> hostnameSensor = getConfig(HOSTNAME_SENSOR);	AttributeSensor<?> portSensor = getConfig(PORT_NUMBER_SENSOR);	Set<AttributeSensor<?>> sensorsToTrack;	if (hostAndPortSensor != null) {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostAndPortSensor);	} else {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostnameSensor, portSensor);	}	serverPoolMemberTrackerPolicy = policies().add(PolicySpec.create(ServerPoolMemberTrackerPolicy.class) .displayName("Controller targets tracker") .configure("group", serverPool) .configure("sensorsToTrack", sensorsToTrack));	
added policy to 

if (hostAndPortSensor != null) {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostAndPortSensor);	} else {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostnameSensor, portSensor);	}	serverPoolMemberTrackerPolicy = policies().add(PolicySpec.create(ServerPoolMemberTrackerPolicy.class) .displayName("Controller targets tracker") .configure("group", serverPool) .configure("sensorsToTrack", sensorsToTrack));	synchronized (serverPoolAddresses) {	Map<Entity,String> serverPoolTargets = Maps.newLinkedHashMap();	for (Entity member : serverPool.getMembers()) {	if (belongsInServerPool(member)) {	
done checkentity 

}	serverPoolMemberTrackerPolicy = policies().add(PolicySpec.create(ServerPoolMemberTrackerPolicy.class) .displayName("Controller targets tracker") .configure("group", serverPool) .configure("sensorsToTrack", sensorsToTrack));	synchronized (serverPoolAddresses) {	Map<Entity,String> serverPoolTargets = Maps.newLinkedHashMap();	for (Entity member : serverPool.getMembers()) {	if (belongsInServerPool(member)) {	String address = getAddressOfEntity(member);	serverPoolTargets.put(member, address);	}	}	
resetting server pool targets 

private URI createUriOrNull(String val) {	if (val == null) {	return null;	}	try {	return URI.create(val);	} catch (IllegalArgumentException e) {	
invalid uri for 

protected abstract void reconfigureService();	public void updateNeeded() {	synchronized (serverPoolAddresses) {	if (updateNeeded) return;	updateNeeded = true;	
queueing an update needed task for update will occur shortly 

public Task<?> updateAsync() {	synchronized (serverPoolAddresses) {	Task<?> result = null;	if (!isActive()) updateNeeded = true;	else {	updateNeeded = false;	
updating in response to changes 

public Task<?> updateAsync() {	synchronized (serverPoolAddresses) {	Task<?> result = null;	if (!isActive()) updateNeeded = true;	else {	updateNeeded = false;	
updating server pool targets 

public Task<?> updateAsync() {	synchronized (serverPoolAddresses) {	Task<?> result = null;	if (!isActive()) updateNeeded = true;	else {	updateNeeded = false;	reconfigureService();	
reloading in response to changes 

protected void onServerPoolMemberChanged(Entity member) {	synchronized (serverPoolAddresses) {	
for considering membership of which is in locations 

protected void onServerPoolMemberChanged(Entity member) {	synchronized (serverPoolAddresses) {	if (belongsInServerPool(member)) {	addServerPoolMember(member);	} else {	removeServerPoolMember(member);	}	
done checkentity 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	
members of checking eliminating because not up 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getServerPool().getMembers().contains(member)) {	
members of checking eliminating because not member 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getServerPool().getMembers().contains(member)) {	return false;	}	
members of checking approving 

protected void addServerPoolMember(Entity member) {	synchronized (serverPoolAddresses) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	
ignoring unchanged address 

protected void addServerPoolMember(Entity member) {	synchronized (serverPoolAddresses) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	
removing from member with old address because inferred address is now null 

protected void addServerPoolMember(Entity member) {	synchronized (serverPoolAddresses) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	} else {	if (oldAddress != null) {	
replacing in member with old address new address 

protected void addServerPoolMember(Entity member) {	synchronized (serverPoolAddresses) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	} else {	if (oldAddress != null) {	} else {	
adding to new member with address 

String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	} else {	if (oldAddress != null) {	} else {	}	}	if (Objects.equal(oldAddress, newAddress)) {	
for ignoring change in member because address still 

protected void removeServerPoolMember(Entity member) {	synchronized (serverPoolAddresses) {	if (!getAttribute(SERVER_POOL_TARGETS).containsKey(member)) {	
for not removing as don t have member 

protected void removeServerPoolMember(Entity member) {	synchronized (serverPoolAddresses) {	if (!getAttribute(SERVER_POOL_TARGETS).containsKey(member)) {	return;	}	String address = MapAttribute.remove(this, SERVER_POOL_TARGETS, member);	
removing from member with address 

protected String getAddressOfEntity(Entity member) {	AttributeSensor<String> hostAndPortSensor = getHostAndPortSensor();	if (hostAndPortSensor != null) {	String result = member.getAttribute(hostAndPortSensor);	if (result != null) {	return result;	} else {	
no host port set for using attribute skipping in 

return result;	} else {	return null;	}	} else {	String ip = member.getAttribute(getHostnameSensor());	Integer port = member.getAttribute(getPortNumberSensor());	if (ip!=null && port!=null) {	return ip+":"+port;	}	
unable to construct hostname port representation for skipping in 

========================= brooklyn sample_190 =========================

private void masterFailover(Entity member) {	
master failover to 

========================= brooklyn sample_2264 =========================

public void testYamlServiceMatchAndBrooklynInstantiate() throws Exception {	Reader input = new InputStreamReader(getClass().getResourceAsStream("test-app-service-blueprint.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	
at is 

========================= brooklyn sample_1624 =========================

protected void doTestUpdatesSeedsOnFailuresAndAdditions(boolean fast, boolean checkSeedsConstantOnRejoining) throws Exception {	cluster = app.createAndManageChild(EntitySpec.create(CassandraDatacenter.class) .configure(CassandraDatacenter.INITIAL_SIZE, 2) .configure(CassandraDatacenter.TOKEN_SHIFT, BigInteger.ZERO) .configure(CassandraDatacenter.DELAY_BEFORE_ADVERTISING_CLUSTER, Duration.ZERO) .configure(CassandraDatacenter.MEMBER_SPEC, EntitySpec.create(EmptySoftwareProcess.class)));	app.start(ImmutableList.of(loc));	EmptySoftwareProcess e1 = (EmptySoftwareProcess) Iterables.get(cluster.getMembers(), 0);	EmptySoftwareProcess e2 = (EmptySoftwareProcess) Iterables.get(cluster.getMembers(), 1);	EntityAsserts.assertAttributeEqualsEventually(cluster, CassandraDatacenter.CURRENT_SEEDS, ImmutableSet.<Entity>of(e1, e2));	log.debug("Test "+JavaClassNames.niceClassAndMethod()+", cluster "+cluster+" has "+cluster.getMembers()+"; e1="+e1+" e2="+e2);	
simulating failure of cassandra node 

log.debug("Test "+JavaClassNames.niceClassAndMethod()+", cluster "+cluster+" has "+cluster.getMembers()+"; e1="+e1+" e2="+e2);	e1.getDriver().stop();	if (fast) e1.sensors().set(Attributes.SERVICE_UP, false);	EntityAsserts.assertAttributeEqualsEventually(cluster, CassandraDatacenter.CURRENT_SEEDS, ImmutableSet.<Entity>of(e2));	cluster.resize(3);	EmptySoftwareProcess e3 = (EmptySoftwareProcess) Iterables.getOnlyElement(Sets.difference(ImmutableSet.copyOf(cluster.getMembers()), ImmutableSet.of(e1,e2)));	log.debug("Test "+JavaClassNames.niceClassAndMethod()+", cluster "+cluster+" has "+cluster.getMembers()+"; e3="+e3);	try {	EntityAsserts.assertAttributeEqualsEventually(cluster, CassandraDatacenter.CURRENT_SEEDS, ImmutableSet.<Entity>of(e2, e3));	} finally {	
test cluster has seeds 

public void testUpdatesSeedsFastishManyTimes() throws Exception {	final int COUNT = 20;	for (int i=0; i<COUNT; i++) {	
test iteration of 

public void testUpdatesSeedsFastishManyTimes() throws Exception {	final int COUNT = 20;	for (int i=0; i<COUNT; i++) {	try {	doTestUpdatesSeedsOnFailuresAndAdditions(true, true);	tearDown();	setUp();	} catch (Exception e) {	
error in iteration of 

public void testUpdateSeedsSlowAndRejoining() throws Exception {	final int COUNT = 1;	for (int i=0; i<COUNT; i++) {	
test iteration of 

========================= brooklyn sample_313 =========================

protected void initEnrichers() {	
adding machine metrics enrichers 

protected void connectSensors() {	super.connectSensors();	Maybe<SshMachineLocation> location = Machines.findUniqueMachineLocation(getLocations(), SshMachineLocation.class);	if (location.isPresent() && location.get().getOsDetails().isLinux()) {	
adding machine metrics feed 

protected void connectSensors() {	super.connectSensors();	Maybe<SshMachineLocation> location = Machines.findUniqueMachineLocation(getLocations(), SshMachineLocation.class);	if (location.isPresent() && location.get().getOsDetails().isLinux()) {	machineMetrics = AddMachineMetrics.createMachineMetricsFeed(this);	} else {	
not adding machine metrics feed as no suitable location available on entity 

========================= brooklyn sample_2376 =========================

public void testDuplicateBundle() throws Exception {	MavenArtifact artifact = new MavenArtifact("org.apache.brooklyn", "brooklyn-api", "jar", "0.12.0");	String localUrl = MavenRetriever.localUrl(artifact);	if ("file".equals(Urls.getProtocol(localUrl))) {	helperDuplicateBundle(localUrl);	} else {	
skipping test osgistandalonetest testduplicatebundle due to not available in local repo 

========================= brooklyn sample_597 =========================

public void testFeedDeDupe() throws Exception {	testReturnsShellExitStatus();	entity.addFeed(feed);	
feed is 

public void testFeedDeDupe() throws Exception {	testReturnsShellExitStatus();	entity.addFeed(feed);	testReturnsShellExitStatus();	
feed is 

========================= brooklyn sample_981 =========================

public ResizeOperator apply(final Closure closure) {	
use of groovy lang closure is deprecated in autoscalerpolicy type coercion closure resizeoperator 

public void setMetricLowerBound(Number val) {	
changing metriclowerbound from to 

public void setMetricUpperBound(Number val) {	
changing metricupperbound from to 

public int getResizeUpIterationIncrement() { return getConfig(RESIZE_UP_ITERATION_INCREMENT); }	public void setResizeUpIterationIncrement(Integer val) {	
changing resizeupiterationincrement from to 

public int getResizeDownIterationIncrement() { return getConfig(RESIZE_DOWN_ITERATION_INCREMENT); }	public void setResizeDownIterationIncrement(Integer val) {	
changing resizedowniterationincrement from to 

public int getResizeUpIterationMax() { return getConfig(RESIZE_UP_ITERATION_MAX); }	public void setResizeUpIterationMax(Integer val) {	
changing resizeupiterationmax from to 

public int getResizeDownIterationMax() { return getConfig(RESIZE_DOWN_ITERATION_MAX); }	public void setResizeDownIterationMax(Integer val) {	
changing resizedowniterationmax from to 

public void setMinPeriodBetweenExecs(Duration val) {	
changing minperiodbetweenexecs from to 

public void setResizeUpStabilizationDelay(Duration val) {	
changing resizeupstabilizationdelay from to 

public void setResizeDownStabilizationDelay(Duration val) {	
changing resizedownstabilizationdelay from to 

public void setMinPoolSize(int val) {	
changing minpoolsize from to 

public void setMaxPoolSize(int val) {	
changing maxpoolsize from to 

} else if (key.equals(MAX_POOL_SIZE)) {	int newMax = (Integer) val;	if (newMax < getConfig(MIN_POOL_SIZE)) {	throw new IllegalArgumentException("Min pool size "+val+" must not be greater than max pool size "+getConfig(MAX_POOL_SIZE));	}	onPoolSizeLimitsChanged(getConfig(MIN_POOL_SIZE), newMax);	} else if (key.equals(INSUFFICIENT_CAPACITY_HIGH_WATER_MARK)) {	Integer newVal = (Integer) val;	Integer oldVal = config().get(INSUFFICIENT_CAPACITY_HIGH_WATER_MARK);	if (oldVal != null && (newVal == null || newVal > oldVal)) {	
resetting to which will enable resizing above previous level of 

private void onPoolSizeLimitsChanged(final int min, final int max) {	
checking pool size on limits changed for between and 

private void onPoolSizeLimitsChanged(final int min, final int max) {	if (isRunning() && isEntityUp()) {	executor.submit(new Runnable() {	try {	int currentSize = getCurrentSizeOperator().apply(entity);	int desiredSize = Math.min(max, Math.max(min, currentSize));	if (currentSize != desiredSize) {	
resizing pool immediateley from to due to new pool size limits 

if (isRunning() && isEntityUp()) {	executor.submit(new Runnable() {	try {	int currentSize = getCurrentSizeOperator().apply(entity);	int desiredSize = Math.min(max, Math.max(min, currentSize));	if (currentSize != desiredSize) {	getResizeOperator().resize(poolEntity, desiredSize);	}	} catch (Exception e) {	if (isRunning()) {	
error resizing 

executor.submit(new Runnable() {	try {	int currentSize = getCurrentSizeOperator().apply(entity);	int desiredSize = Math.min(max, Math.max(min, currentSize));	if (currentSize != desiredSize) {	getResizeOperator().resize(poolEntity, desiredSize);	}	} catch (Exception e) {	if (isRunning()) {	} else {	
error resizing but no longer running 

int currentSize = getCurrentSizeOperator().apply(entity);	int desiredSize = Math.min(max, Math.max(min, currentSize));	if (currentSize != desiredSize) {	getResizeOperator().resize(poolEntity, desiredSize);	}	} catch (Exception e) {	if (isRunning()) {	} else {	}	} catch (Throwable t) {	
error resizing 

private void onMetricChanged(Number val) {	
recording pool metric for 

private void onMetricChanged(Number val) {	if (val==null) {	
not resizing pool inbound metric is null 

private void onPoolCold(Map<String, ?> properties) {	
recording pool cold for 

private void onPoolHot(Map<String, ?> properties) {	
recording pool hot for 

if (data.isHot()) {	highlightViolation("Metric "+String.format("%.02f", data.currentMetricValue)+" too hot " + "(target range "+String.format("%.02f", data.metricLowerBound)+"-"+String.format("%.02f", data.metricUpperBound)+")");	desiredSizeUnconstrained = (int)Math.ceil(data.getCurrentTotalActivity() / data.metricUpperBound);	data.scalingMode = ScalingType.HOT;	} else if (data.isCold()) {	highlightViolation("Metric "+String.format("%.02f", data.currentMetricValue)+" too cold " + "(target range "+String.format("%.02f", data.metricLowerBound)+"-"+String.format("%.02f", data.metricUpperBound)+")");	desiredSizeUnconstrained = (int)Math.floor(data.getCurrentTotalActivity() / data.metricLowerBound);	data.scalingMode = ScalingType.COLD;	} else {	highlightConfirmation("Metric "+String.format("%.02f", data.currentMetricValue)+" in " + "target range "+String.format("%.02f", data.metricLowerBound)+"-"+String.format("%.02f", data.metricUpperBound));	
not resizing pool from within range 

data.scalingMode = ScalingType.HOT;	} else if (data.isCold()) {	highlightViolation("Metric "+String.format("%.02f", data.currentMetricValue)+" too cold " + "(target range "+String.format("%.02f", data.metricLowerBound)+"-"+String.format("%.02f", data.metricUpperBound)+")");	desiredSizeUnconstrained = (int)Math.floor(data.getCurrentTotalActivity() / data.metricLowerBound);	data.scalingMode = ScalingType.COLD;	} else {	highlightConfirmation("Metric "+String.format("%.02f", data.currentMetricValue)+" in " + "target range "+String.format("%.02f", data.metricLowerBound)+"-"+String.format("%.02f", data.metricUpperBound));	abortResize(data.currentSize);	return;	}	
detected unconstrained desired size 

int scaleIncrement = getResizeDownIterationIncrement();	int scaleMax = getResizeDownIterationMax();	if (delta>scaleMax) {	delta=scaleMax;	} else if (delta % scaleIncrement != 0) {	delta += scaleIncrement - (delta % scaleIncrement);	}	desiredSize = data.currentSize - delta;	if (data.metricUpperBound!=null) {	while (desiredSize < data.currentSize && data.getCurrentTotalActivity() > data.metricUpperBound * desiredSize) {	
when resizing back pool from tweaking from to prevent thrashing 

} else if (delta % scaleIncrement != 0) {	delta += scaleIncrement - (delta % scaleIncrement);	}	desiredSize = data.currentSize + delta;	desiredSize = applyMinMaxConstraints(desiredSize);	if (desiredSize <= data.currentSize) data.scalingMode = null;	} else {	data.scalingMode = null;	}	if (data.scalingMode!=null) {	
provisionally resizing from to ideal size 

}	desiredSize = data.currentSize + delta;	desiredSize = applyMinMaxConstraints(desiredSize);	if (desiredSize <= data.currentSize) data.scalingMode = null;	} else {	data.scalingMode = null;	}	if (data.scalingMode!=null) {	scheduleResize(desiredSize, "metric "+data.currentMetricValue+" out of range");	} else {	
not resizing from to out of healthy range but unconstrained size blocked by bounds check 

private void onPoolOk(Map<String, ?> properties) {	
recording pool ok for 

private void onPoolOk(Map<String, ?> properties) {	int poolCurrentSize = (Integer) properties.get(POOL_CURRENT_SIZE_KEY);	
not resizing ok pool from 

private void scheduleResize(String reason) {	if (isRunning() && isEntityUp() && executorQueued.compareAndSet(false, true)) {	long now = System.currentTimeMillis();	long delay = Math.max(0, (executorTime + getMinPeriodBetweenExecs().toMilliseconds()) - now);	
scheduling resize in ms 

long now = System.currentTimeMillis();	long delay = Math.max(0, (executorTime + getMinPeriodBetweenExecs().toMilliseconds()) - now);	executor.schedule(new Runnable() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	resizeNow(reason);	notifyMaxReachedIfRequiredNow(reason);	} catch (Exception e) {	if (isRunning()) {	
error resizing 

long delay = Math.max(0, (executorTime + getMinPeriodBetweenExecs().toMilliseconds()) - now);	executor.schedule(new Runnable() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	resizeNow(reason);	notifyMaxReachedIfRequiredNow(reason);	} catch (Exception e) {	if (isRunning()) {	} else {	
error resizing but no longer running 

try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	resizeNow(reason);	notifyMaxReachedIfRequiredNow(reason);	} catch (Exception e) {	if (isRunning()) {	} else {	}	} catch (Throwable t) {	
error resizing 

return;	}	WindowSummary valsSummary = recentUnboundedResizes.summarizeWindow(getMaxReachedNotificationDelay());	long timeWindowSize = getMaxReachedNotificationDelay().toMilliseconds();	long currentPoolSize = getCurrentSizeOperator().apply(poolEntity);	int maxAllowedPoolSize = getMaxPoolSize();	long unboundedSustainedMaxPoolSize = valsSummary.min;	long unboundedCurrentPoolSize = valsSummary.latest;	if (maxReachedLastNotifiedTime > 0) {	} else if (unboundedSustainedMaxPoolSize > maxAllowedPoolSize) {	
notifying listener of max pool size reached current max unbounded current unbounded max 

long currentPoolSize = getCurrentSizeOperator().apply(poolEntity);	int maxAllowedPoolSize = getMaxPoolSize();	long unboundedSustainedMaxPoolSize = valsSummary.min;	long unboundedCurrentPoolSize = valsSummary.latest;	if (maxReachedLastNotifiedTime > 0) {	} else if (unboundedSustainedMaxPoolSize > maxAllowedPoolSize) {	maxReachedLastNotifiedTime = System.currentTimeMillis();	MaxPoolSizeReachedEvent event = MaxPoolSizeReachedEvent.builder() .currentPoolSize(currentPoolSize) .maxAllowed(maxAllowedPoolSize) .currentUnbounded(unboundedCurrentPoolSize) .maxUnbounded(unboundedSustainedMaxPoolSize) .timeWindow(timeWindowSize) .build();	entity.sensors().emit(maxSizeReachedSensor, event);	} else if (valsSummary.max > maxAllowedPoolSize) {	
re scheduling max reached check for as unbounded size not stable min max latest 

private void resizeNow(String reason) {	final int currentPoolSize = getCurrentSizeOperator().apply(poolEntity);	CalculatedDesiredPoolSize calculatedDesiredPoolSize = calculateDesiredPoolSize(currentPoolSize);	long desiredPoolSize = calculatedDesiredPoolSize.size;	boolean stable = calculatedDesiredPoolSize.stable;	final int targetPoolSize = applyMinMaxConstraints(desiredPoolSize);	if (!stable) {	
re scheduling resize check for as desired size not stable current desired continuing with resize 

private void resizeNow(String reason) {	final int currentPoolSize = getCurrentSizeOperator().apply(poolEntity);	CalculatedDesiredPoolSize calculatedDesiredPoolSize = calculateDesiredPoolSize(currentPoolSize);	long desiredPoolSize = calculatedDesiredPoolSize.size;	boolean stable = calculatedDesiredPoolSize.stable;	final int targetPoolSize = applyMinMaxConstraints(desiredPoolSize);	if (!stable) {	scheduleResize(reason);	}	if (currentPoolSize == targetPoolSize) {	
not resizing pool from to 

CalculatedDesiredPoolSize calculatedDesiredPoolSize = calculateDesiredPoolSize(currentPoolSize);	long desiredPoolSize = calculatedDesiredPoolSize.size;	boolean stable = calculatedDesiredPoolSize.stable;	final int targetPoolSize = applyMinMaxConstraints(desiredPoolSize);	if (!stable) {	scheduleResize(reason);	}	if (currentPoolSize == targetPoolSize) {	return;	}	
requesting resize to current min max 

}	if (currentPoolSize == targetPoolSize) {	return;	}	Task<Void> t = Entities.submit(entity, Tasks.<Void>builder().displayName("Auto-scaler") .description("Auto-scaler recommending resize from "+currentPoolSize+" to "+targetPoolSize) .tag(BrooklynTaskTags.NON_TRANSIENT_TASK_TAG) .body(new Callable<Void>() {	public Void call() throws Exception {	try {	getResizeOperator().resize(poolEntity, targetPoolSize);	} catch (Resizable.InsufficientCapacityException e) {	int insufficientCapacityHighWaterMark = getCurrentSizeOperator().apply(poolEntity);	
failed to resize due to insufficient capacity setting high water mark to and will not attempt to resize above that level again 

if (currentPoolSize < maxDesiredPoolSize) {	desiredPoolSize = maxDesiredPoolSize;	stable = stableForGrowing;	} else if (currentPoolSize > minDesiredPoolSize) {	desiredPoolSize = minDesiredPoolSize;	stable = stableForShrinking;	} else {	desiredPoolSize = currentPoolSize;	stable = stableForGrowing && stableForShrinking;	}	
calculated desired pool size from to mindesired maxdesired stable now downsizehistory upsizehistory 

========================= brooklyn sample_3072 =========================

StopCommandSoftwareProcess entity = app.createAndManageChild(EntitySpec.create(StopCommandSoftwareProcess.class, StopCommandSoftwareProcessImpl.class));	entity.start(ImmutableList.of(loc));	VanillaSoftwareProcessSshDriver driver = (VanillaSoftwareProcessSshDriver) entity.getDriver();	String launchContents = Joiner.on('\n') .join("#!/usr/bin/env bash", "function trap_handler_command {", "  while true; do", "    echo \"Do nothing.\"", "    sleep 1", "  done", "}", "trap \"trap_handler_command\" SIGTERM", "while true; do", "  sleep 1", "done");	driver.copyResource(ImmutableMap.of(), new ReaderInputStream(new StringReader(launchContents), "UTF-8"), "launch.sh", true);	driver.executeLaunchCommand("nohup bash launch.sh > /dev/null &");	ByteArrayOutputStream stdOut = new ByteArrayOutputStream(15);	SshMachineLocation machineLocation = (SshMachineLocation) Iterables.getFirst(entity.getLocations(), null);	machineLocation.execCommands( ImmutableMap.<String, Object>of(ExecWithLoggingHelpers.STDOUT.getName(), stdOut), "check process is stopped", ImmutableList.of("cat "+driver.getRunDir() + '/' + VanillaSoftwareProcessSshDriver.PID_FILENAME), MutableMap.<String,Object>of());	int launchedProcessPid = Integer.parseInt(Strings.trimEnd(new String(stdOut.toByteArray())));	
pid of launched long running process d 

public void stop() {	
stop 

public void install() {	
install 

public void customize() {	
customize 

public void launch() {	
launch 

========================= brooklyn sample_2233 =========================

public void testAggregatesNewMembersOfGroup() {	BasicGroup group = app.createAndManageChild(EntitySpec.create(BasicGroup.class));	TestEntity p1 = app.createAndManageChild(EntitySpec.create(TestEntity.class));	TestEntity p2 = app.createAndManageChild(EntitySpec.create(TestEntity.class));	
created and the entities it will contain 

========================= brooklyn sample_578 =========================

protected void onEntityChange(Entity member) {	if (LOG.isTraceEnabled()) {	
state of on change 

protected void onEntityAdded(Entity member) {	if (LOG.isTraceEnabled()) {	
state of on added 

public void update() {	Lifecycle serverState = getAttribute(Attributes.SERVICE_STATE_ACTUAL);	if (Lifecycle.STOPPED.equals(serverState) || Lifecycle.STOPPING.equals(serverState) || Lifecycle.DESTROYED.equals(serverState) || !getAttribute(Attributes.SERVICE_UP)) {	
skipped update of when service state is and running is 

public void update() {	Lifecycle serverState = getAttribute(Attributes.SERVICE_STATE_ACTUAL);	if (Lifecycle.STOPPED.equals(serverState) || Lifecycle.STOPPING.equals(serverState) || Lifecycle.DESTROYED.equals(serverState) || !getAttribute(Attributes.SERVICE_UP)) {	return;	}	synchronized (this) {	Iterable<Entity> availableEntities = FluentIterable.from(getEntities().getMembers()) .filter(new HasHostnameAndValidLifecycle());	
updating with entities 

Multimap<String, String> ipToAllNames = MultimapBuilder.hashKeys().hashSetValues().build();	for (Map.Entry<String, Entity> entry : hostnameToEntity.entries()) {	String domainName = entry.getKey();	Entity entity = entry.getValue();	String address = null;	AttributeSensor<String> addressSensor = getConfig(ADDRESS_SENSOR);	if (addressSensor!=null) {	address = entity.getAttribute(addressSensor);	} else {	if (!hasLoggedDeprecationAboutAddressSensor) {	
bind entity is using legacy machine inspection to determine ip address set the config to ensure compatibility with future versions 

String address = null;	AttributeSensor<String> addressSensor = getConfig(ADDRESS_SENSOR);	if (addressSensor!=null) {	address = entity.getAttribute(addressSensor);	} else {	if (!hasLoggedDeprecationAboutAddressSensor) {	hasLoggedDeprecationAboutAddressSensor = true;	}	Maybe<SshMachineLocation> location = Machines.findUniqueMachineLocation(entity.getLocations(), SshMachineLocation.class);	if (!location.isPresent()) {	
member of does not have an hostname so will not be configured 

protected void configureResolver(Entity entity) {	Maybe<SshMachineLocation> machine = Machines.findUniqueMachineLocation(entity.getLocations(), SshMachineLocation.class);	if (machine.isPresent()) {	if (getConfig(REPLACE_RESOLV_CONF)) {	machine.get().copyTo(new StringReader(getConfig(RESOLV_CONF_TEMPLATE)), "/etc/resolv.conf");	} else {	appendTemplate(getConfig(INTERFACE_CONFIG_TEMPLATE), "/etc/sysconfig/network-scripts/ifcfg-eth0", machine.get());	machine.get().execScript("reload network", ImmutableList.of(BashCommands.sudo("service network reload")));	}	
configured resolver on 

protected void configureResolver(Entity entity) {	Maybe<SshMachineLocation> machine = Machines.findUniqueMachineLocation(entity.getLocations(), SshMachineLocation.class);	if (machine.isPresent()) {	if (getConfig(REPLACE_RESOLV_CONF)) {	machine.get().copyTo(new StringReader(getConfig(RESOLV_CONF_TEMPLATE)), "/etc/resolv.conf");	} else {	appendTemplate(getConfig(INTERFACE_CONFIG_TEMPLATE), "/etc/sysconfig/network-scripts/ifcfg-eth0", machine.get());	machine.get().execScript("reload network", ImmutableList.of(BashCommands.sudo("service network reload")));	}	} else {	
can t configure resolver at no sshmachinelocation 

========================= brooklyn sample_128 =========================

private static Map<String, ?> castToMapWithStringKeys(Map<?, ?> map) {	if (map == null) return ImmutableMap.of();	for (Object key : map.keySet()) {	if (!(key instanceof String)) {	IllegalArgumentException e = new IllegalArgumentException("Invalid non-string key(s), type " + key.getClass().getName()+" in map");	e.fillInStackTrace();	
deprecated invalid key s in map continuing 

========================= brooklyn sample_1223 =========================

public void start() {	
starting feed for 

public void stop() {	if (!activated) {	
ignoring attempt to stop feed of entity when not running 

public void stop() {	if (!activated) {	return;	}	
stopping feed for 

========================= brooklyn sample_1389 =========================

protected void setActualState(Maybe<Lifecycle> state) {	long now = System.currentTimeMillis();	synchronized (mutex) {	if (state.orNull() == Lifecycle.ON_FIRE) {	if (config().get(LAST_PUBLISHED) == LastPublished.FAILED) {	if (currentRecoveryStartTime != null) {	
health check for component was recovering now failing 

protected void setActualState(Maybe<Lifecycle> state) {	long now = System.currentTimeMillis();	synchronized (mutex) {	if (state.orNull() == Lifecycle.ON_FIRE) {	if (config().get(LAST_PUBLISHED) == LastPublished.FAILED) {	if (currentRecoveryStartTime != null) {	currentRecoveryStartTime = null;	publishEntityRecoveredTime = null;	} else {	
health check for component still failed 

if (state.orNull() == Lifecycle.ON_FIRE) {	if (config().get(LAST_PUBLISHED) == LastPublished.FAILED) {	if (currentRecoveryStartTime != null) {	currentRecoveryStartTime = null;	publishEntityRecoveredTime = null;	} else {	}	} else {	if (firstUpTime == null && getConfig(ENTITY_FAILED_ONLY_IF_PREVIOUSLY_UP)) {	} else if (currentFailureStartTime == null) {	
health check for component now failing 

currentRecoveryStartTime = null;	publishEntityRecoveredTime = null;	} else {	}	} else {	if (firstUpTime == null && getConfig(ENTITY_FAILED_ONLY_IF_PREVIOUSLY_UP)) {	} else if (currentFailureStartTime == null) {	currentFailureStartTime = now;	publishEntityFailedTime = currentFailureStartTime + getConfig(ENTITY_FAILED_STABILIZATION_DELAY).toMilliseconds();	} else {	
health check for component continuing failing 

}	}	if (setEntityOnFireTime == null) {	setEntityOnFireTime = now + getConfig(SERVICE_ON_FIRE_STABILIZATION_DELAY).toMilliseconds();	}	currentRecoveryStartTime = null;	publishEntityRecoveredTime = null;	} else if (state.orNull() == Lifecycle.RUNNING) {	if (config().get(LAST_PUBLISHED) == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	
health check for component now recovering 

setEntityOnFireTime = now + getConfig(SERVICE_ON_FIRE_STABILIZATION_DELAY).toMilliseconds();	}	currentRecoveryStartTime = null;	publishEntityRecoveredTime = null;	} else if (state.orNull() == Lifecycle.RUNNING) {	if (config().get(LAST_PUBLISHED) == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	currentRecoveryStartTime = now;	publishEntityRecoveredTime = currentRecoveryStartTime + getConfig(ENTITY_RECOVERED_STABILIZATION_DELAY).toMilliseconds();	} else {	
health check for component continuing recovering 

publishEntityRecoveredTime = null;	} else if (state.orNull() == Lifecycle.RUNNING) {	if (config().get(LAST_PUBLISHED) == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	currentRecoveryStartTime = now;	publishEntityRecoveredTime = currentRecoveryStartTime + getConfig(ENTITY_RECOVERED_STABILIZATION_DELAY).toMilliseconds();	} else {	}	} else {	if (currentFailureStartTime != null) {	
health check for component was failing now healthy 

} else if (state.orNull() == Lifecycle.RUNNING) {	if (config().get(LAST_PUBLISHED) == LastPublished.FAILED) {	if (currentRecoveryStartTime == null) {	currentRecoveryStartTime = now;	publishEntityRecoveredTime = currentRecoveryStartTime + getConfig(ENTITY_RECOVERED_STABILIZATION_DELAY).toMilliseconds();	} else {	}	} else {	if (currentFailureStartTime != null) {	} else {	
health check for component still healthy 

}	} else {	if (currentFailureStartTime != null) {	} else {	}	}	currentFailureStartTime = null;	publishEntityFailedTime = null;	setEntityOnFireTime = null;	} else {	
health check for in unconfirmed sate 

protected void recomputeAfterDelay(long delay) {	if (!isRunning()) return;	long now = System.currentTimeMillis();	delay = Math.max(0, Math.max(delay, (executorTime + MIN_PERIOD_BETWEEN_EXECS_MILLIS) - now));	
scheduling publish in ms 

if (!isRunning()) return;	long now = System.currentTimeMillis();	delay = Math.max(0, Math.max(delay, (executorTime + MIN_PERIOD_BETWEEN_EXECS_MILLIS) - now));	Runnable job = new Runnable() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	onEvent(null);	} catch (Exception e) {	if (isRunning()) {	
error in enricher 

long now = System.currentTimeMillis();	delay = Math.max(0, Math.max(delay, (executorTime + MIN_PERIOD_BETWEEN_EXECS_MILLIS) - now));	Runnable job = new Runnable() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	onEvent(null);	} catch (Exception e) {	if (isRunning()) {	} else {	
error in enricher but no longer running 

Runnable job = new Runnable() {	try {	executorTime = System.currentTimeMillis();	executorQueued.set(false);	onEvent(null);	} catch (Exception e) {	if (isRunning()) {	} else {	}	} catch (Throwable t) {	
error in enricher 

========================= brooklyn sample_3064 =========================

public String toString() {	try {	return source+"."+sensor+"="+value+" @ "+timestamp;	} catch (ConcurrentModificationException e) {	String result = getClass()+":"+source+"."+sensor+"@"+timestamp;	
error creating string for ignoring 

public String toString() {	try {	return source+"."+sensor+"="+value+" @ "+timestamp;	} catch (ConcurrentModificationException e) {	String result = getClass()+":"+source+"."+sensor+"@"+timestamp;	
trace for error creating string for ignoring 

========================= brooklyn sample_1409 =========================

ClassLoader classLoader = checkNotNull(options.classLoader, "classLoader");	ManagementContextInternal origManagementContext = (ManagementContextInternal) options.origManagementContext;	ManagementContextInternal newManagementContext = (ManagementContextInternal) options.newManagementContext;	PersistenceObjectStore objectStore = options.objectStore;	HighAvailabilityMode haMode = (options.haMode == null ? HighAvailabilityMode.DISABLED : options.haMode);	RebindExceptionHandler exceptionHandler = options.exceptionHandler;	boolean hasPersister = newManagementContext != null && newManagementContext.getRebindManager().getPersister() != null;	boolean checkSerializable = options.checkSerializable;	boolean terminateOrigManagementContext = options.terminateOrigManagementContext;	Function<BrooklynMementoPersister, Void> stateTransformer = options.stateTransformer;	
rebinding app using mementodir object store 

try {	store = new FileBasedObjectStore(dir);	store.injectManagementContext(mgmt);	store.prepareForSharedUse(PersistMode.AUTO, HighAvailabilityMode.HOT_STANDBY);	persister = new BrooklynMementoPersisterToObjectStore(store, mgmt, RebindTestUtils.class.getClassLoader());	BrooklynMementoRawData data = persister.loadMementoRawData(RebindExceptionHandlerImpl.builder().build());	List<BrooklynObjectType> types = ImmutableList.of(BrooklynObjectType.ENTITY, BrooklynObjectType.LOCATION, BrooklynObjectType.POLICY, BrooklynObjectType.ENRICHER, BrooklynObjectType.FEED, BrooklynObjectType.CATALOG_ITEM, BrooklynObjectType.MANAGED_BUNDLE);	for (BrooklynObjectType type : types) {	LOG.info(type+" ("+data.getObjectsOfType(type).keySet()+"):");	for (Map.Entry<String, String> entry : data.getObjectsOfType(type).entrySet()) {	
t 

========================= brooklyn sample_647 =========================

protected <T> Maybe<T> tryCoerceInternal(Object value, TypeToken<T> targetTypeToken, Class<T> targetType) {	if (value==null) return Maybe.of((T)null);	Maybe<T> result = null;	Maybe<T> firstError = null;	targetType = TypeTokens.getRawType(targetTypeToken, targetType);	if (targetTypeToken!=null && targetTypeToken.getType() instanceof ParameterizedType) {	if (value instanceof Iterable && Iterable.class.isAssignableFrom(targetType)) {	result = tryCoerceIterable(value, targetTypeToken, targetType);	if (result != null && result.isAbsent() && targetType.isInstance(value)) {	
failed to coerce iterable from to returning uncoerced result to preserve deprecated backwards compatibility 

Maybe<T> firstError = null;	targetType = TypeTokens.getRawType(targetTypeToken, targetType);	if (targetTypeToken!=null && targetTypeToken.getType() instanceof ParameterizedType) {	if (value instanceof Iterable && Iterable.class.isAssignableFrom(targetType)) {	result = tryCoerceIterable(value, targetTypeToken, targetType);	if (result != null && result.isAbsent() && targetType.isInstance(value)) {	}	} else if (value.getClass().isArray() && Iterable.class.isAssignableFrom(targetType)) {	result = tryCoerceArray(value, targetTypeToken, targetType);	if (result != null && result.isAbsent() && targetType.isInstance(value)) {	
failed to coerce array from to returning uncoerced result to preserve deprecated backwards compatibility 

result = tryCoerceIterable(value, targetTypeToken, targetType);	if (result != null && result.isAbsent() && targetType.isInstance(value)) {	}	} else if (value.getClass().isArray() && Iterable.class.isAssignableFrom(targetType)) {	result = tryCoerceArray(value, targetTypeToken, targetType);	if (result != null && result.isAbsent() && targetType.isInstance(value)) {	}	} else if (value instanceof Map && Map.class.isAssignableFrom(targetType)) {	result = tryCoerceMap(value, targetTypeToken);	if (result != null && result.isAbsent() && targetType.isInstance(value)) {	
failed to coerce map from to returning uncoerced result to preserve deprecated backwards compatibility 

========================= brooklyn sample_2049 =========================

public void testRoutesToExpectedLocation() {	geoDns.config().set(GeoscalingDnsService.INCLUDE_HOMELESS_ENTITIES, true);	target.sensors().set(Attributes.HOSTNAME,addrWithGeo.getHostName());	app.start(ImmutableList.of(locWithGeo));	
geo scaling test using expect to be wired to 

public void testIgnoresAddressWithoutGeography() throws Exception {	System.setProperty(BrooklynSystemProperties.HOST_GEO_LOOKUP_IMPL.getPropertyName(), StubHostGeoLookup.class.getName());	geoDns.config().set(GeoscalingDnsService.INCLUDE_HOMELESS_ENTITIES, false);	app.start(ImmutableList.of(locWithoutGeo));	target.sensors().set(Attributes.HOSTNAME, StubHostGeoLookup.HOMELESS_IP);	
geo scaling test using expect not to be wired to 

public void testIncludesAddressWithoutGeography() {	System.setProperty(BrooklynSystemProperties.HOST_GEO_LOOKUP_IMPL.getPropertyName(), StubHostGeoLookup.class.getName());	geoDns.config().set(GeoscalingDnsService.INCLUDE_HOMELESS_ENTITIES, true);	app.start(ImmutableList.of(locWithoutGeo));	target.sensors().set(Attributes.HOSTNAME, StubHostGeoLookup.HOMELESS_IP);	
geo scaling test using expect to be wired to 

========================= brooklyn sample_186 =========================

public Void call() throws Exception {	
invoked help command 

public Void call() throws Exception {	
invoked info command 

protected void execCli(Cli<BrooklynCommand> parser, String ...args) {	try {	
parsing command line arguments 

protected void execCli(Cli<BrooklynCommand> parser, String ...args) {	try {	BrooklynCommand command = parser.parse(args);	
executing command 

protected void execCli(Cli<BrooklynCommand> parser, String ...args) {	try {	BrooklynCommand command = parser.parse(args);	command.call();	System.exit(SUCCESS);	} catch (ParseException pe) {	System.err.println("Parse error: " + pe.getMessage());	System.err.println(getUsageInfo(parser));	System.exit(PARSE_ERROR);	} catch (FatalConfigurationRuntimeException e) {	
configuration error 

command.call();	System.exit(SUCCESS);	} catch (ParseException pe) {	System.err.println("Parse error: " + pe.getMessage());	System.err.println(getUsageInfo(parser));	System.exit(PARSE_ERROR);	} catch (FatalConfigurationRuntimeException e) {	System.err.println("Configuration error: " + e.getMessage());	System.exit(CONFIGURATION_ERROR);	} catch (FatalRuntimeException e) {	
startup error 

System.err.println("Parse error: " + pe.getMessage());	System.err.println(getUsageInfo(parser));	System.exit(PARSE_ERROR);	} catch (FatalConfigurationRuntimeException e) {	System.err.println("Configuration error: " + e.getMessage());	System.exit(CONFIGURATION_ERROR);	} catch (FatalRuntimeException e) {	System.err.println("Startup error: "+e.getMessage());	System.exit(EXECUTION_ERROR);	} catch (Exception e) {	
execution error 

========================= brooklyn sample_2767 =========================

public void onEvent(SensorEvent<T> event, long eventTime) {	Number current = event.getValue();	if (current == null) {	double deltaPostProcessed = getPostProcessor().apply(0d);	entity.sensors().set((AttributeSensor<Double>)target, deltaPostProcessed);	
set to at 

public void onEvent(SensorEvent<T> event, long eventTime) {	Number current = event.getValue();	if (current == null) {	double deltaPostProcessed = getPostProcessor().apply(0d);	entity.sensors().set((AttributeSensor<Double>)target, deltaPostProcessed);	return;	}	if (eventTime > 0 && eventTime > lastTime) {	if (lastValue == null || lastTime <= 0) {	
received event but no last value so will not emit null at 

return;	}	if (eventTime > 0 && eventTime > lastTime) {	if (lastValue == null || lastTime <= 0) {	} else {	double duration = (lastTime < 0) ? unitMillis : eventTime - lastTime;	if (eventTime == lastTime) duration = 0.1;	double delta = (current.doubleValue() - lastValue.doubleValue()) / (duration / unitMillis);	double deltaPostProcessed = getPostProcessor().apply(delta);	entity.sensors().set((AttributeSensor<Double>)target, deltaPostProcessed);	
set to at 

========================= brooklyn sample_3033 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	int[] inboundPorts = toIntPortArray(v);	
opening inbound ports for cloud type 

========================= brooklyn sample_2622 =========================

public static void main(String[] args) {	BasicCampPlatform p = new BasicCampPlatform();	MockWebPlatform.populate(p);	CampServer s = new CampServer(p, "").start();	
running at 

========================= brooklyn sample_1777 =========================

public void init() {	super.init();	ConfigToAttributes.apply(this, MEMBER_SPEC);	ConfigToAttributes.apply(this, CONTROLLER);	ConfigToAttributes.apply(this, CONTROLLER_SPEC);	ConfigToAttributes.apply(this, WEB_CLUSTER_SPEC);	ConfigToAttributes.apply(this, CONTROLLED_GROUP);	EntitySpec<? extends WebAppService> webServerSpec = getAttribute(MEMBER_SPEC);	if (webServerSpec == null) {	
creating default web server spec for 

ConfigToAttributes.apply(this, MEMBER_SPEC);	ConfigToAttributes.apply(this, CONTROLLER);	ConfigToAttributes.apply(this, CONTROLLER_SPEC);	ConfigToAttributes.apply(this, WEB_CLUSTER_SPEC);	ConfigToAttributes.apply(this, CONTROLLED_GROUP);	EntitySpec<? extends WebAppService> webServerSpec = getAttribute(MEMBER_SPEC);	if (webServerSpec == null) {	webServerSpec = EntitySpec.create(TomcatServer.class);	sensors().set(MEMBER_SPEC, webServerSpec);	}	
creating cluster child for 

ConfigToAttributes.apply(this, WEB_CLUSTER_SPEC);	ConfigToAttributes.apply(this, CONTROLLED_GROUP);	EntitySpec<? extends WebAppService> webServerSpec = getAttribute(MEMBER_SPEC);	if (webServerSpec == null) {	webServerSpec = EntitySpec.create(TomcatServer.class);	sensors().set(MEMBER_SPEC, webServerSpec);	}	EntitySpec<? extends DynamicWebAppCluster> webClusterSpec = getAttribute(WEB_CLUSTER_SPEC);	Map<String,Object> webClusterFlags = MutableMap.<String,Object>of("memberSpec", webServerSpec);	if (webClusterSpec == null) {	
creating default web cluster spec for 

}	EntitySpec<? extends DynamicWebAppCluster> webClusterSpec = getAttribute(WEB_CLUSTER_SPEC);	Map<String,Object> webClusterFlags = MutableMap.<String,Object>of("memberSpec", webServerSpec);	if (webClusterSpec == null) {	webClusterSpec = EntitySpec.create(DynamicWebAppCluster.class);	}	boolean hasMemberSpec = webClusterSpec.getConfig().containsKey(DynamicWebAppCluster.MEMBER_SPEC) || webClusterSpec.getFlags().containsKey("memberSpec");	if (!hasMemberSpec) {	webClusterSpec.configure(webClusterFlags);	} else {	
in not setting cluster s because already set on webclusterspec 

} else {	}	sensors().set(WEB_CLUSTER_SPEC, webClusterSpec);	DynamicWebAppCluster cluster = addChild(webClusterSpec);	sensors().set(CLUSTER, cluster);	setEntityFilter(EntityPredicates.isMemberOf(cluster));	LoadBalancer controller = getAttribute(CONTROLLER);	if (controller == null) {	EntitySpec<? extends LoadBalancer> controllerSpec = getAttribute(CONTROLLER_SPEC);	if (controllerSpec == null) {	
creating controller using default spec for 

DynamicWebAppCluster cluster = addChild(webClusterSpec);	sensors().set(CLUSTER, cluster);	setEntityFilter(EntityPredicates.isMemberOf(cluster));	LoadBalancer controller = getAttribute(CONTROLLER);	if (controller == null) {	EntitySpec<? extends LoadBalancer> controllerSpec = getAttribute(CONTROLLER_SPEC);	if (controllerSpec == null) {	controllerSpec = EntitySpec.create(NginxController.class);	sensors().set(CONTROLLER_SPEC, controllerSpec);	} else {	
creating controller using custom spec for 

controllerSpec = EntitySpec.create(NginxController.class);	sensors().set(CONTROLLER_SPEC, controllerSpec);	} else {	}	controller = addChild(controllerSpec);	enrichers().add(Enrichers.builder() .propagating(LoadBalancer.PROXY_HTTP_PORT, LoadBalancer.PROXY_HTTPS_PORT) .from(controller) .build());	sensors().set(CONTROLLER, controller);	}	Group controlledGroup = getAttribute(CONTROLLED_GROUP);	if (controlledGroup == null) {	
using cluster as controlledgroup for 

}	controller = addChild(controllerSpec);	enrichers().add(Enrichers.builder() .propagating(LoadBalancer.PROXY_HTTP_PORT, LoadBalancer.PROXY_HTTPS_PORT) .from(controller) .build());	sensors().set(CONTROLLER, controller);	}	Group controlledGroup = getAttribute(CONTROLLED_GROUP);	if (controlledGroup == null) {	controlledGroup = cluster;	sensors().set(CONTROLLED_GROUP, cluster);	} else {	
using custom controlledgroup for 

========================= brooklyn sample_240 =========================

public static void registerGroovyAdapters() {	registerAdapter(Closure.class, Predicate.class, new Function<Closure,Predicate>() {	public Predicate<?> apply(final Closure closure) {	
use of groovy lang closure is deprecated in typecoercions closure predicate 

public Function apply(final Closure closure) {	
use of groovy lang closure is deprecated in typecoercions closure function 

public TimeDuration apply(final Object input) {	
deprecated automatic coercion of object to timeduration set breakpoint in typecoercions to inspect convert to duration 

public Long apply(final TimeDuration input) {	
deprecated automatic coercion of timeduration to long set breakpoint in typecoercions to inspect use duration instead of long 

========================= brooklyn sample_1425 =========================

protected void doTest(Location loc) throws Exception {	Entity testEntity = app.createAndManageChild(EntitySpec.create(EmptySoftwareProcess.class));	app.start(ImmutableList.of(loc));	EntityAsserts.assertAttributeEqualsEventually(testEntity, Startable.SERVICE_UP, true);	SshMachineLocation sshLoc = Locations.findUniqueSshMachineLocation(testEntity.getLocations()).get();	MachineDetails machine = app.getExecutionContext() .submit(BasicMachineDetails.taskForSshMachineLocation(sshLoc)) .getUnchecked();	
found the following at 

========================= brooklyn sample_2209 =========================

public void tearDown() throws Exception {	super.tearDown();	for (ManagementContext mgmt : mgmts) {	try {	if (mgmt != null) Entities.destroyAll(mgmt);	} catch (Throwable t) {	
caught exception in teardown method 

public void testCleanedCopiedPersistedState() throws Exception {	
taking persistence from 

========================= brooklyn sample_542 =========================

public void start() {	synchronized (startStopMutex) {	if (state==ListenerState.RUNNING || (scheduledTask!=null && !scheduledTask.isDone())) {	
request to start when already running ignoring 

private boolean persistNowSafely(boolean alreadyHasMutex) {	Stopwatch timer = Stopwatch.createStarted();	try {	persistNowInternal(alreadyHasMutex);	metrics.noteSuccess(Duration.of(timer));	return true;	} catch (RuntimeInterruptedException e) {	
interrupted persisting change delta rethrowing 

try {	persistNowInternal(alreadyHasMutex);	metrics.noteSuccess(Duration.of(timer));	return true;	} catch (RuntimeInterruptedException e) {	metrics.noteFailure(Duration.of(timer));	metrics.noteError(e.toString());	Thread.currentThread().interrupt();	return false;	} catch (Exception e) {	
problem persisting change delta 

} catch (RuntimeInterruptedException e) {	metrics.noteFailure(Duration.of(timer));	metrics.noteError(e.toString());	Thread.currentThread().interrupt();	return false;	} catch (Exception e) {	metrics.noteFailure(Duration.of(timer));	metrics.noteError(e.toString());	return false;	} catch (Throwable t) {	
problem persisting change delta rethrowing 

if (!isActive() && state != ListenerState.STOPPING) return;	updatePlaneIdIfTimedOut();	DeltaCollector prevDeltaCollector;	synchronized (this) {	prevDeltaCollector = deltaCollector;	deltaCollector = new DeltaCollector();	}	if (LOG.isDebugEnabled() && shouldLogCheckpoint()) LOG.debug("Checkpointing delta of memento: " + "updating entities={}, locations={}, policies={}, enrichers={}, catalog items={}, bundles={}; " + "removing entities={}, locations={}, policies={}, enrichers={}, catalog items={}, bundles={}", new Object[] {	limitedCountString(prevDeltaCollector.entities), limitedCountString(prevDeltaCollector.locations), limitedCountString(prevDeltaCollector.policies), limitedCountString(prevDeltaCollector.enrichers), limitedCountString(prevDeltaCollector.catalogItems), limitedCountString(prevDeltaCollector.bundles), limitedCountString(prevDeltaCollector.removedEntityIds), limitedCountString(prevDeltaCollector.removedLocationIds), limitedCountString(prevDeltaCollector.removedPolicyIds), limitedCountString(prevDeltaCollector.removedEnricherIds), limitedCountString(prevDeltaCollector.removedCatalogItemIds), limitedCountString(prevDeltaCollector.removedBundleIds)});	addReferencedObjects(prevDeltaCollector);	
checkpointing delta of memento with references updating entities locations policies enrichers catalog items bundles removing entities locations policies enrichers catalog items bundles 

DeltaCollector prevDeltaCollector;	synchronized (this) {	prevDeltaCollector = deltaCollector;	deltaCollector = new DeltaCollector();	}	if (LOG.isDebugEnabled() && shouldLogCheckpoint()) LOG.debug("Checkpointing delta of memento: " + "updating entities={}, locations={}, policies={}, enrichers={}, catalog items={}, bundles={}; " + "removing entities={}, locations={}, policies={}, enrichers={}, catalog items={}, bundles={}", new Object[] {	limitedCountString(prevDeltaCollector.entities), limitedCountString(prevDeltaCollector.locations), limitedCountString(prevDeltaCollector.policies), limitedCountString(prevDeltaCollector.enrichers), limitedCountString(prevDeltaCollector.catalogItems), limitedCountString(prevDeltaCollector.bundles), limitedCountString(prevDeltaCollector.removedEntityIds), limitedCountString(prevDeltaCollector.removedLocationIds), limitedCountString(prevDeltaCollector.removedPolicyIds), limitedCountString(prevDeltaCollector.removedEnricherIds), limitedCountString(prevDeltaCollector.removedCatalogItemIds), limitedCountString(prevDeltaCollector.removedBundleIds)});	addReferencedObjects(prevDeltaCollector);	prevDeltaCollector.entities.size(), prevDeltaCollector.locations.size(), prevDeltaCollector.policies.size(), prevDeltaCollector.enrichers.size(), prevDeltaCollector.catalogItems.size(), prevDeltaCollector.bundles.size(), prevDeltaCollector.removedEntityIds.size(), prevDeltaCollector.removedLocationIds.size(), prevDeltaCollector.removedPolicyIds.size(), prevDeltaCollector.removedEnricherIds.size(), prevDeltaCollector.removedCatalogItemIds.size(), prevDeltaCollector.removedBundleIds.size()});	if (prevDeltaCollector.isEmpty()) {	
no changes to persist since last delta 

persisterDelta.removed(type, prevDeltaCollector.getRemovedIdsOfType(type));	}	synchronized (new Object()) {}	persister.delta(persisterDelta, exceptionHandler);	}	} catch (Exception e) {	if (isActive()) {	throw Exceptions.propagate(e);	} else {	Exceptions.propagateIfFatal(e);	
problem persisting but no longer active ignoring 

public synchronized void onManaged(BrooklynObject instance) {	
onmanaged 

public synchronized void onUnmanaged(BrooklynObject instance) {	
onunmanaged 

public synchronized void onChanged(BrooklynObject instance) {	
onchanged 

========================= brooklyn sample_1130 =========================

Supplier<?> supplier = new Supplier<Object>() {	public Object get() {	final Object sensorValue = target.sensors().get(Sensors.newSensor(Object.class, sensor.get()));	return sensorValue;	}	};	TestFrameworkAssertions.checkAssertionsEventually(new AssertionOptions(sensor.get(), supplier) .maxAttempts(getConfig(ITERATION_LIMIT)).timeout(timeout).backoffToPeriod(backoffToPeriod) .assertions(assertions).abortConditions(abortConditions));	setUpAndRunState(true, Lifecycle.RUNNING);	} catch (Throwable t) {	if (sensor.get() != null) {	
sensor test failed for rethrowing 

public Object get() {	final Object sensorValue = target.sensors().get(Sensors.newSensor(Object.class, sensor.get()));	return sensorValue;	}	};	TestFrameworkAssertions.checkAssertionsEventually(new AssertionOptions(sensor.get(), supplier) .maxAttempts(getConfig(ITERATION_LIMIT)).timeout(timeout).backoffToPeriod(backoffToPeriod) .assertions(assertions).abortConditions(abortConditions));	setUpAndRunState(true, Lifecycle.RUNNING);	} catch (Throwable t) {	if (sensor.get() != null) {	} else {	
sensor test failed for no sensor rethrowing 

========================= brooklyn sample_2435 =========================

entity.getContentLength();	durationMillisOfFirstResponse = Duration.sinceUtc(startTime).toMilliseconds();	ByteStreams.copy(entity.getContent(), out);	content = out.toByteArray();	entity.getContentLength();	} else {	durationMillisOfFirstResponse = Duration.sinceUtc(startTime).toMilliseconds();	content = new byte[0];	}	durationMillisOfFullContent = Duration.sinceUtc(startTime).toMilliseconds();	
httppollvalue latency content size 

========================= brooklyn sample_2065 =========================

public BrooklynProperties.Factory.Builder createPropertiesBuilder() {	if (brooklynProperties == null) {	BrooklynProperties.Factory.Builder builder = BrooklynProperties.Factory.builderDefault();	if (Strings.isNonEmpty(globalBrooklynPropertiesFile)) {	File globalProperties = new File(Os.tidyPath(globalBrooklynPropertiesFile));	if (globalProperties.exists()) {	globalProperties = resolveSymbolicLink(globalProperties);	checkFileReadable(globalProperties);	checkFilePermissionsX00(globalProperties);	
using global properties file 

public BrooklynProperties.Factory.Builder createPropertiesBuilder() {	if (brooklynProperties == null) {	BrooklynProperties.Factory.Builder builder = BrooklynProperties.Factory.builderDefault();	if (Strings.isNonEmpty(globalBrooklynPropertiesFile)) {	File globalProperties = new File(Os.tidyPath(globalBrooklynPropertiesFile));	if (globalProperties.exists()) {	globalProperties = resolveSymbolicLink(globalProperties);	checkFileReadable(globalProperties);	checkFilePermissionsX00(globalProperties);	} else {	
global properties file does not exist will ignore 

if (Strings.isNonEmpty(globalBrooklynPropertiesFile)) {	File globalProperties = new File(Os.tidyPath(globalBrooklynPropertiesFile));	if (globalProperties.exists()) {	globalProperties = resolveSymbolicLink(globalProperties);	checkFileReadable(globalProperties);	checkFilePermissionsX00(globalProperties);	} else {	}	builder.globalPropertiesFile(globalProperties.getAbsolutePath());	} else {	
global properties file disabled 

private File resolveSymbolicLink(File f) {	File f2 = f;	try {	f2 = f.getCanonicalFile();	if (Files.isSymbolicLink(f.toPath())) {	
resolved symbolic link 

private File resolveSymbolicLink(File f) {	File f2 = f;	try {	f2 = f.getCanonicalFile();	if (Files.isSymbolicLink(f.toPath())) {	}	} catch (IOException e) {	
could not determine canonical name of file returning original file 

private void checkFilePermissionsX00(File f) {	Maybe<String> permission = FileUtil.getFilePermissions(f);	if (permission.isAbsent()) {	
could not determine permissions of file assuming ok 

========================= brooklyn sample_2989 =========================

protected void checkExtraLocalhosts() throws Exception {	Set<String> failedHosts = Sets.newLinkedHashSet();	List<String> allHosts = ImmutableList.of("localhost", "localhost1", "localhost2", "localhost3", "localhost4");	for (String host : allHosts) {	try {	InetAddress i = InetAddress.getByName(host);	byte[] b = ((Inet4Address)i).getAddress();	if (b[0]!=127 || b[1]!=0 || b[2]!=0 || b[3]!=1) {	
failed to resolve test will subsequently fail but looking for more errors first see subsequent failure for more info wrong ip 

Set<String> failedHosts = Sets.newLinkedHashSet();	List<String> allHosts = ImmutableList.of("localhost", "localhost1", "localhost2", "localhost3", "localhost4");	for (String host : allHosts) {	try {	InetAddress i = InetAddress.getByName(host);	byte[] b = ((Inet4Address)i).getAddress();	if (b[0]!=127 || b[1]!=0 || b[2]!=0 || b[3]!=1) {	failedHosts.add(host);	}	} catch (Exception e) {	
failed to resolve test will subsequently fail but looking for more errors first see subsequent failure for more info 

========================= brooklyn sample_145 =========================

public void onShutdownRequest() {	try {	
osgi shutdown handler invoked stopping container framework 

========================= brooklyn sample_515 =========================

AbstractBrooklynObjectSpec<?, ?> result = createSpec(type, context);	result.stackCatalogItemId(type.getId());	return result;	} catch (Exception e) { throw Exceptions.propagate(e); }	}	try {	return createBean(type, context);	} catch (Exception e) { throw Exceptions.propagate(e); }	}	try {	
request for to validate unresolved kind trying as spec 

result.stackCatalogItemId(type.getId());	return result;	} catch (Exception e) { throw Exceptions.propagate(e); }	}	try {	return createBean(type, context);	} catch (Exception e) { throw Exceptions.propagate(e); }	}	try {	Object result = visitSpec();	
request to use from unresolved state succeeded treating is as a spec 

result.stackCatalogItemId(type.getId());	return result;	} catch (Exception e) { throw Exceptions.propagate(e); }	}	try {	return createBean(type, context);	} catch (Exception e) { throw Exceptions.propagate(e); }	}	try {	Object result = visitSpec();	
trace for request to use in unresolved state succeeding location of request to use in unresolved state 

========================= brooklyn sample_1022 =========================

public static <T> T withBlockingDetails(String description, Callable<T> code) throws Exception {	Task current = current();	if (code==null) {	
legacy invocation of withblockingdetails with null code block ignoring 

public static boolean tryQueueing(TaskQueueingContext adder, TaskAdaptable<?> task) {	if (task==null || isQueued(task)) return false;	try {	adder.queue(task.asTask());	return true;	} catch (Exception e) {	
could not add task at 

t.blockUntilEnded(timer.getDurationRemaining());	while (true) {	if (t.getEndTimeUtc()>=0) return true;	Thread tt = t.getThread();	if (t instanceof ScheduledTask) {	((ScheduledTask)t).blockUntilNextRunFinished(timer.getDurationRemaining());	return true;	} else {	if (tt==null || !tt.isAlive()) {	if (!t.isCancelled()) {	
internal task thread is dead or null but task not ended 

========================= brooklyn sample_1472 =========================

protected void doTest(Location loc) throws Exception {	
testing cassandra on 

========================= brooklyn sample_283 =========================

try {	for (int i = 0; i < NUM_GETTER_THREADS; i++) {	ListenableFuture<?> future = executor.submit(new Callable<Void>() {	public Void call() throws Exception {	int numCycles = 0;	try {	while (running.get()) {	((LocalEntityManager)entityManager).getAllEntitiesInApplication(app);	numCycles++;	}	
executed getallentitiesinapplication times 

ListenableFuture<?> future = executor.submit(new Callable<Void>() {	public Void call() throws Exception {	int numCycles = 0;	try {	while (running.get()) {	((LocalEntityManager)entityManager).getAllEntitiesInApplication(app);	numCycles++;	}	return null;	} catch (Exception e) {	
error in task for getallentitiesinapplication cycle 

TestEntity entity = app.addChild(EntitySpec.create(TestEntity.class));	entities.add(entity);	if (!running.get()) break;	}	for (int i = 0; i < 10; i++) {	Entities.unmanage(entities.remove(0));	if (!running.get()) break;	}	numCycles++;	}	
executed add remove children cycles entities 

if (!running.get()) break;	}	for (int i = 0; i < 10; i++) {	Entities.unmanage(entities.remove(0));	if (!running.get()) break;	}	numCycles++;	}	return null;	} catch (Exception e) {	
error in task for add remove children cycle 

========================= brooklyn sample_796 =========================

public Response toResponse(Throwable throwable1) {	if (throwable1.getClass().getName().equals("org.eclipse.jetty.io.EofException")) {	if (LOG.isTraceEnabled()) {	
rest request running as was disconnected threw 

public Response toResponse(Throwable throwable1) {	if (throwable1.getClass().getName().equals("org.eclipse.jetty.io.EofException")) {	if (LOG.isTraceEnabled()) {	}	return null;	}	Throwable throwable2 = Exceptions.getFirstInteresting(throwable1);	if (isSevere(throwable2)) {	
rest request running as threw 

public Response toResponse(Throwable throwable1) {	if (throwable1.getClass().getName().equals("org.eclipse.jetty.io.EofException")) {	if (LOG.isTraceEnabled()) {	}	return null;	}	Throwable throwable2 = Exceptions.getFirstInteresting(throwable1);	if (isSevere(throwable2)) {	} else {	
rest request running as threw 

return ApiError.of(throwable2.getMessage()).asBadRequestResponseJson();	}	if (throwable2 instanceof ClassCoercionException || throwable2 instanceof IllegalArgumentException) {	return ApiError.of(throwable2).asBadRequestResponseJson();	}	if (throwable2 instanceof YAMLException) {	return ApiError.builder().message(throwable2.getMessage()).prefixMessage("Invalid YAML").build().asBadRequestResponseJson();	}	if (!Exceptions.isPrefixBoring(throwable2)) {	if ( encounteredUnknownExceptions.add( throwable2.getClass() )) {	
rest call generated exception type unrecognized in subsequent occurrences will be logged debug only 

========================= brooklyn sample_2874 =========================

MockItemEntity item1 = newItem(app, containerA, "1");	MockItemEntity item2 = newItem(app, containerB, "2");	MockItemEntity item3 = newItem(app, containerA, "3");	FollowTheSunPolicy customPolicy = new FollowTheSunPolicy( MutableMap.of("minPeriodBetweenExecs", minPeriodBetweenExecs), MockItemEntity.ITEM_USAGE_METRIC, model, FollowTheSunParameters.newDefault());	pool.policies().add(customPolicy);	final Stopwatch stopwatch = Stopwatch.createStarted();	final List<Long> eventTimes = Lists.newCopyOnWriteArrayList();	final Semaphore semaphore = new Semaphore(0);	app.subscriptions().subscribe(item1, Movable.CONTAINER, new SensorEventListener<Entity>() {	long eventTime = stopwatch.elapsed(TimeUnit.MILLISECONDS);	
received at 

========================= brooklyn sample_3009 =========================

if (flags.containsKey("subscriberExecutionManagerTag")) {	s.subscriberExecutionManagerTag = flags.remove("subscriberExecutionManagerTag");	s.subscriberExecutionManagerTagSupplied = true;	} else {	s.subscriberExecutionManagerTag = s.subscriber instanceof Entity ? "subscription-delivery-entity-"+((Entity)s.subscriber).getId() : s.subscriber instanceof String ? "subscription-delivery-string["+s.subscriber+"]" : "subscription-delivery-object["+s.subscriber+"]";	s.subscriberExecutionManagerTagSupplied = false;	}	s.eventFilter = (Predicate<SensorEvent<T>>) flags.remove("eventFilter");	boolean notifyOfInitialValue = Boolean.TRUE.equals(flags.remove("notifyOfInitialValue"));	s.flags = flags;	
creating subscription for on in 

allSubscriptions.put(s.id, s);	addToMapOfSets(subscriptionsByToken, makeEntitySensorToken(s.producer, s.sensor), s);	if (s.subscriber!=null) {	addToMapOfSets(subscriptionsBySubscriber, s.subscriber, s);	}	if (!s.subscriberExecutionManagerTagSupplied && s.subscriberExecutionManagerTag!=null) {	((BasicExecutionManager) em).setTaskSchedulerForTag(s.subscriberExecutionManagerTag, SingleThreadedScheduler.class);	}	if (notifyOfInitialValue) {	if (producer == null) {	
cannot notifyofinitialvalue for subscription with wildcard producer 

addToMapOfSets(subscriptionsByToken, makeEntitySensorToken(s.producer, s.sensor), s);	if (s.subscriber!=null) {	addToMapOfSets(subscriptionsBySubscriber, s.subscriber, s);	}	if (!s.subscriberExecutionManagerTagSupplied && s.subscriberExecutionManagerTag!=null) {	((BasicExecutionManager) em).setTaskSchedulerForTag(s.subscriberExecutionManagerTag, SingleThreadedScheduler.class);	}	if (notifyOfInitialValue) {	if (producer == null) {	} else if (sensor == null) {	
cannot notifyofinitialvalue for subscription with wilcard sensor 

if (s.subscriber!=null) {	addToMapOfSets(subscriptionsBySubscriber, s.subscriber, s);	}	if (!s.subscriberExecutionManagerTagSupplied && s.subscriberExecutionManagerTag!=null) {	((BasicExecutionManager) em).setTaskSchedulerForTag(s.subscriberExecutionManagerTag, SingleThreadedScheduler.class);	}	if (notifyOfInitialValue) {	if (producer == null) {	} else if (sensor == null) {	} else if (!(sensor instanceof AttributeSensor)) {	
cannot notifyofinitialvalue for subscription with non attribute sensor 

addToMapOfSets(subscriptionsBySubscriber, s.subscriber, s);	}	if (!s.subscriberExecutionManagerTagSupplied && s.subscriberExecutionManagerTag!=null) {	((BasicExecutionManager) em).setTaskSchedulerForTag(s.subscriberExecutionManagerTag, SingleThreadedScheduler.class);	}	if (notifyOfInitialValue) {	if (producer == null) {	} else if (sensor == null) {	} else if (!(sensor instanceof AttributeSensor)) {	} else {	
sending initial value of to 

public <T> void publish(final SensorEvent<T> event) {	
got event 

public <T> void publish(final SensorEvent<T> event) {	totalEventsPublishedCount.incrementAndGet();	Set<Subscription> subs = (Set<Subscription>) ((Set<?>) getSubscriptionsForEntitySensor(event.getSource(), event.getSensor()));	if (groovyTruth(subs)) {	
sending to 

return "LSM.publish("+event+")";	}	}	public void run() {	try {	int count = s.eventCount.incrementAndGet();	if (count > 0 && count % 1000 == 0) LOG.debug("{} events for subscriber {}", count, s);	s.listener.onEvent(event);	} catch (Throwable t) {	if (event!=null && event.getSource()!=null && Entities.isNoLongerManaged(event.getSource())) {	
error processing subscriptions to after entity unmanaged 

}	}	public void run() {	try {	int count = s.eventCount.incrementAndGet();	if (count > 0 && count % 1000 == 0) LOG.debug("{} events for subscriber {}", count, s);	s.listener.onEvent(event);	} catch (Throwable t) {	if (event!=null && event.getSource()!=null && Entities.isNoLongerManaged(event.getSource())) {	} else {	
error processing subscriptions to 

========================= brooklyn sample_1034 =========================

this.computeServiceRegistry = new StubbedComputeServiceRegistry(nodeCreator, false);	final Map<ConfigKey<?>, Object> defaults = ImmutableMap.<ConfigKey<?>, Object>builder() .put(JcloudsLocationConfig.COMPUTE_SERVICE_REGISTRY, computeServiceRegistry) .put(JcloudsLocationConfig.TEMPLATE_BUILDER, JcloudsStubTemplateBuilder.create(getProvider(), getRegion())) .put(JcloudsLocationConfig.ACCESS_IDENTITY, "stub-identity") .put(JcloudsLocationConfig.ACCESS_CREDENTIAL, "stub-credential") .put(SshMachineLocation.SSH_TOOL_CLASS, RecordingSshTool.class.getName()) .put(WinRmMachineLocation.WINRM_TOOL_CLASS, RecordingWinRmTool.class.getName()) .put(JcloudsLocation.POLL_FOR_FIRST_REACHABLE_ADDRESS_PREDICATE, Predicates.alwaysTrue()) .put(JcloudsLocationConfig.LOOKUP_AWS_HOSTNAME, Boolean.FALSE) .build();	final ImmutableMap.Builder<Object, Object> flags = ImmutableMap.builder() .putAll(jcloudsLocationConfig);	for (Map.Entry<ConfigKey<?>, Object> entry : defaults.entrySet()) {	ConfigKey<?> key = entry.getKey();	if (!jcloudsLocationConfig.containsKey(key) && !jcloudsLocationConfig.containsKey(key.getName())) {	flags.put(key, entry.getValue());	} else {	Object overrideVal = jcloudsLocationConfig.get(key);	if (overrideVal == null) overrideVal = jcloudsLocationConfig.get(key.getName());	
overridden default value for with 

========================= brooklyn sample_2531 =========================

public void terminate() {	Duration timeout = managementContext.getBrooklynProperties().getConfig(UsageManager.USAGE_LISTENER_TERMINATION_TIMEOUT);	if (listenerQueueSize.get() > 0) {	
usage manager waiting for listener events for up to 

if (listenerQueueSize.get() > 0) {	}	List<ListenableFuture<?>> futures = Lists.newArrayList();	for (final UsageListener listener : listeners) {	ListenableFuture<?> future = listenerExecutor.submit(new Runnable() {	public void run() {	if (listener instanceof Closeable) {	try {	((Closeable)listener).close();	} catch (IOException e) {	
problem closing usage listener continuing 

} catch (IOException e) {	}	}	}});	futures.add(future);	}	try {	Futures.successfulAsList(futures).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem terminiating usage listeners continuing 

private void execOnListeners(final Function<UsageListener, Void> job) {	for (final UsageListener listener : listeners) {	listenerQueueSize.incrementAndGet();	listenerExecutor.execute(new Runnable() {	public void run() {	try {	job.apply(listener);	} catch (RuntimeException e) {	
problem notifying listener of 

public void recordApplicationEvent(final Application app, final Lifecycle state) {	
storing application lifecycle usage event application in state 

public void recordLocationEvent(final Location loc, final Lifecycle state) {	checkNotNull(loc, "location");	if (loc.getConfig(AbstractLocation.TEMPORARY_LOCATION)) {	
ignoring location lifecycle usage event for state because location is a temporary location 

public void recordLocationEvent(final Location loc, final Lifecycle state) {	checkNotNull(loc, "location");	if (loc.getConfig(AbstractLocation.TEMPORARY_LOCATION)) {	return;	}	checkNotNull(state, "state of location %s", loc);	if (loc.getId() == null) {	
ignoring location lifecycle usage event for state because location has no id 

public void recordLocationEvent(final Location loc, final Lifecycle state) {	checkNotNull(loc, "location");	if (loc.getConfig(AbstractLocation.TEMPORARY_LOCATION)) {	return;	}	checkNotNull(state, "state of location %s", loc);	if (loc.getId() == null) {	return;	}	if (managementContext.getStorage() == null) {	
cannot store location lifecycle usage event for state because storage not available 

return;	}	if (managementContext.getStorage() == null) {	return;	}	Object callerContext = loc.getConfig(LocationConfigKeys.CALLER_CONTEXT);	if (callerContext != null && callerContext instanceof Entity) {	Entity caller = (Entity) callerContext;	recordLocationEvent(loc, caller, state);	} else {	
not recording location lifecycle usage event for in state because no caller context 

protected void recordLocationEvent(final Location loc, final Entity caller, final Lifecycle state) {	
storing location lifecycle usage event location in state caller context 

========================= brooklyn sample_1063 =========================

throw Exceptions.propagate(e);	}	}	return input;	}	protected ExecutionContext getExecutionContext() {	Entity contextEntity = BrooklynTaskTags.getTargetOrContextEntity(Tasks.current());	if (contextEntity instanceof EntityInternal) {	return ((EntityInternal)contextEntity).getExecutionContext();	} else {	
no entity context found will use global execution context could lead to npe on dsl resolving in location config 

========================= brooklyn sample_1433 =========================

private void configureInternalNetworking() {	Location location = getDriver().getLocation();	if (!(location instanceof JcloudsSshMachineLocation)) {	
not running in a jcloudssshmachinelocation not adding ip permissions to 

private void configureInternalNetworking() {	Location location = getDriver().getLocation();	if (!(location instanceof JcloudsSshMachineLocation)) {	return;	}	JcloudsMachineLocation machine = (JcloudsMachineLocation) location;	JcloudsLocationSecurityGroupCustomizer customizer = JcloudsLocationSecurityGroupCustomizer.getInstance(getApplicationId());	String cidr = Cidr.UNIVERSAL.toString();	Collection<IpPermission> permissions = MutableList.<IpPermission>builder() .add(IpPermission.builder() .ipProtocol(IpProtocol.TCP) .fromPort(sensors().get(ERLANG_PORT_RANGE_START)) .toPort(sensors().get(ERLANG_PORT_RANGE_END)) .cidrBlock(cidr) .build()) .add(IpPermission.builder() .ipProtocol(IpProtocol.TCP) .fromPort(config().get(HANDOFF_LISTENER_PORT)) .toPort(config().get(HANDOFF_LISTENER_PORT)) .cidrBlock(cidr) .build()) .add(IpPermission.builder() .ipProtocol(IpProtocol.TCP) .fromPort(config().get(EPMD_LISTENER_PORT)) .toPort(config().get(EPMD_LISTENER_PORT)) .cidrBlock(cidr) .build()) .build();	
applying custom security groups to 

========================= brooklyn sample_411 =========================

public JCloudsPropertiesBuilder setCustomJcloudsProperties() {	Map<String, Object> extra = Maps.filterKeys(conf.getAllConfig(), Predicates.containsPattern("^jclouds\\."));	if (extra.size() > 0) {	String provider = getProviderFromConfig(conf);	
configuring custom jclouds property overrides for 

private String getDeprecatedProperty(ConfigBag conf, String key) {	if (conf.containsKey(key)) {	
jclouds using deprecated brooklyn jclouds property 

========================= brooklyn sample_2589 =========================

public void customize(JcloudsLocation location, ComputeService computeService, JcloudsMachineLocation machineLocation) {	for (JcloudsLocationCustomizer customizer : customizers) {	
customizing machine using customizer 

public void customize(JcloudsLocation location, ComputeService computeService, JcloudsMachineLocation machineLocation) {	for (JcloudsLocationCustomizer customizer : customizers) {	customizer.customize(location, computeService, machineLocation);	}	for (MachineLocationCustomizer customizer : machineCustomizers) {	
customizing machine using customizer 

========================= brooklyn sample_2566 =========================

public void customize() {	newScript(CUSTOMIZING) .body.append(format("cp -R %s %s", getExpandedInstallDir(), getRunDir())) .failOnNonZeroResultCode() .execute();	try {	customizeConfiguration();	} catch (Exception e) {	
failed to configure rubyrep replication is unlikely to succeed 

protected void customizeConfiguration() throws ExecutionException, InterruptedException, URISyntaxException {	
copying creation script 

========================= brooklyn sample_95 =========================

public static HostAndPort getBrooklynAccessibleAddress(Entity entity, int port) {	String host;	EntityInternal entityInternal = (EntityInternal) entity;	PortForwardManager pfw = entity.getConfig(PORT_FORWARDING_MANAGER);	if (pfw == null) {	
no portforwardmanager using default 

EntityInternal entityInternal = (EntityInternal) entity;	PortForwardManager pfw = entity.getConfig(PORT_FORWARDING_MANAGER);	if (pfw == null) {	pfw = (PortForwardManager) entityInternal.getManagementContext().getLocationRegistry().getLocationManaged(PortForwardManagerLocationResolver.PFM_GLOBAL_SPEC);	}	Collection<Location> ll = entity.getLocations();	synchronized (BrooklynAccessUtils.class) {	for (MachineLocation machine : Iterables.filter(ll, MachineLocation.class)) {	HostAndPort hp = pfw.lookup(machine, port);	if (hp!=null) {	
brooklynaccessutils found port forwarded address for entity port using machine 

HostAndPort hp = pfw.lookup(machine, port);	if (hp!=null) {	return hp;	}	}	Maybe<SupportsPortForwarding> supportPortForwardingLoc = Machines.findUniqueElement(ll, SupportsPortForwarding.class);	if (supportPortForwardingLoc.isPresent()) {	Cidr source = entity.getConfig(MANAGEMENT_ACCESS_CIDR);	SupportsPortForwarding loc = supportPortForwardingLoc.get();	if (source!=null) {	
brooklynaccessutils requesting new port forwarding rule to access on at enabled for 

return hp;	}	}	Maybe<SupportsPortForwarding> supportPortForwardingLoc = Machines.findUniqueElement(ll, SupportsPortForwarding.class);	if (supportPortForwardingLoc.isPresent()) {	Cidr source = entity.getConfig(MANAGEMENT_ACCESS_CIDR);	SupportsPortForwarding loc = supportPortForwardingLoc.get();	if (source!=null) {	HostAndPort hp = loc.getSocketEndpointFor(source, port);	if (hp!=null) {	
brooklynaccessutils created port forwarded address for entity port using 

Maybe<SupportsPortForwarding> supportPortForwardingLoc = Machines.findUniqueElement(ll, SupportsPortForwarding.class);	if (supportPortForwardingLoc.isPresent()) {	Cidr source = entity.getConfig(MANAGEMENT_ACCESS_CIDR);	SupportsPortForwarding loc = supportPortForwardingLoc.get();	if (source!=null) {	HostAndPort hp = loc.getSocketEndpointFor(source, port);	if (hp!=null) {	return hp;	}	} else {	
no configured for so cannot forward port even though was supplied and have location supporting port forwarding 

public static String getResolvedAddress(Entity entity, SshMachineLocation origin, String hostnameTarget) {	ProcessTaskWrapper<Integer> task = SshTasks.newSshExecTaskFactory(origin, "ping -c 1 -t 1 "+hostnameTarget) .summary("checking resolution of "+hostnameTarget).allowingNonZeroExitCode().newTask();	DynamicTasks.queueIfPossible(task).orSubmitAndBlock(entity).asTask().blockUntilEnded();	if (task.asTask().isError()) {	
ping could not be run at 

public static String getResolvedAddress(Entity entity, SshMachineLocation origin, String hostnameTarget) {	ProcessTaskWrapper<Integer> task = SshTasks.newSshExecTaskFactory(origin, "ping -c 1 -t 1 "+hostnameTarget) .summary("checking resolution of "+hostnameTarget).allowingNonZeroExitCode().newTask();	DynamicTasks.queueIfPossible(task).orSubmitAndBlock(entity).asTask().blockUntilEnded();	if (task.asTask().isError()) {	return "";	}	if (task.getExitCode()==null || task.getExitCode()!=0) {	if (task.getExitCode()!=null && task.getExitCode()<10) {	
not able to resolve from for because exit code was 

public static String getResolvedAddress(Entity entity, SshMachineLocation origin, String hostnameTarget) {	ProcessTaskWrapper<Integer> task = SshTasks.newSshExecTaskFactory(origin, "ping -c 1 -t 1 "+hostnameTarget) .summary("checking resolution of "+hostnameTarget).allowingNonZeroExitCode().newTask();	DynamicTasks.queueIfPossible(task).orSubmitAndBlock(entity).asTask().blockUntilEnded();	if (task.asTask().isError()) {	return "";	}	if (task.getExitCode()==null || task.getExitCode()!=0) {	if (task.getExitCode()!=null && task.getExitCode()<10) {	return null;	}	
ping not run as expected at code 

========================= brooklyn sample_1278 =========================

public FileBasedObjectStore(File basedir) {	this.basedir = checkPersistenceDirPlausible(basedir);	this.executor = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());	
file based objectstore will use directory 

public synchronized void prepareForMasterUse() {	if (doneFirstContentiousWrite) return;	try {	if (deferredBackupNeeded) {	File backup = backupDirByCopying(basedir);	
persistence deferred backup directory backed up to 

public void createSubPath(String subPath) {	if (!prepared) throw new IllegalStateException("Not yet prepared: "+this);	File dir = new File(getBaseDir(), subPath);	if (dir.mkdir()) {	try {	FileUtil.setFilePermissionsTo700(dir);	} catch (IOException e) {	
unable to set sub directory permissions to continuing 

public void prepareForSharedUse(@Nullable PersistMode persistMode, HighAvailabilityMode haMode) {	if (mgmt==null) throw new NullPointerException("Must inject ManagementContext before preparing "+this);	if (persistMode==null || persistMode==PersistMode.DISABLED) {	prepared = true;	return;	}	Boolean backups = mgmt.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_BACKUPS_REQUIRED);	if (Boolean.TRUE.equals(backups)) {	
using legacy backup for functionality will be removed in future versions in favor of promotion demotion specific backups to a configurable backup location 

if (backups==null) backups = false;	File dir = getBaseDir();	try {	String persistencePath = dir.getAbsolutePath();	switch (persistMode) {	case CLEAN: if (dir.exists()) {	checkPersistenceDirAccessible(dir);	try {	if (backups) {	File old = backupDirByMoving(dir);	
persistence mode clean directory backed up to 

try {	String persistencePath = dir.getAbsolutePath();	switch (persistMode) {	case CLEAN: if (dir.exists()) {	checkPersistenceDirAccessible(dir);	try {	if (backups) {	File old = backupDirByMoving(dir);	} else {	deleteCompletely();	
persistence mode clean directory deleted 

try {	if (backups) {	File old = backupDirByMoving(dir);	} else {	deleteCompletely();	}	} catch (IOException e) {	throw new FatalConfigurationRuntimeException("Error using existing persistence directory "+dir.getAbsolutePath(), e);	}	} else {	
persistence mode clean directory no previous state 

}	} else {	}	break;	case REBIND: checkPersistenceDirAccessible(dir);	checkPersistenceDirNonEmpty(dir);	try {	if (backups) {	if (haMode==HighAvailabilityMode.MASTER) {	File backup = backupDirByCopying(dir);	
persistence mode rebind directory backed up to 

}	break;	case AUTO: if (dir.exists()) {	checkPersistenceDirAccessible(dir);	}	if (dir.exists() && !isMementoDirExistButEmpty(dir)) {	try {	if (backups) {	if (haMode==HighAvailabilityMode.MASTER) {	File backup = backupDirByCopying(dir);	
persistence mode rebind directory backed up to 

if (haMode==HighAvailabilityMode.MASTER) {	File backup = backupDirByCopying(dir);	} else {	deferredBackupNeeded = true;	}	}	} catch (IOException e) {	throw new FatalConfigurationRuntimeException("Error backing up persistence directory "+dir.getAbsolutePath(), e);	}	} else {	
persistence mode auto directory no previous state 

protected void checkPersistenceDirAccessible(File dir) {	if (!(dir.exists() && dir.isDirectory() && dir.canRead() && dir.canWrite())) {	FatalConfigurationRuntimeException problem = new FatalConfigurationRuntimeException("Invalid persistence directory " + dir + ": " + (!dir.exists() ? "does not exist" : (!dir.isDirectory() ? "not a directory" : (!dir.canRead() ? "not readable" : (!dir.canWrite() ? "not writable" : "unknown reason")))));	
invalid persistence directory rethrowing 

protected void checkPersistenceDirAccessible(File dir) {	if (!(dir.exists() && dir.isDirectory() && dir.canRead() && dir.canWrite())) {	FatalConfigurationRuntimeException problem = new FatalConfigurationRuntimeException("Invalid persistence directory " + dir + ": " + (!dir.exists() ? "does not exist" : (!dir.isDirectory() ? "not a directory" : (!dir.canRead() ? "not readable" : (!dir.canWrite() ? "not writable" : "unknown reason")))));	} else {	
created dir for 

protected void checkPersistenceDirNonEmpty(File persistenceDir) {	FatalConfigurationRuntimeException problem;	if (!persistenceDir.exists()) {	problem = new FatalConfigurationRuntimeException("Invalid persistence directory "+persistenceDir+" because directory does not exist");	
invalid persistence directory rethrowing 

protected void checkPersistenceDirNonEmpty(File persistenceDir) {	FatalConfigurationRuntimeException problem;	if (!persistenceDir.exists()) {	problem = new FatalConfigurationRuntimeException("Invalid persistence directory "+persistenceDir+" because directory does not exist");	throw problem;	} if (isMementoDirExistButEmpty(persistenceDir)) {	problem = new FatalConfigurationRuntimeException("Invalid persistence directory "+persistenceDir+" because directory is empty");	
invalid persistence directory rethrowing 

static void moveFile(File srcFile, File destFile) throws IOException, InterruptedException {	if (destFile.isDirectory()) {	deleteCompletely(destFile);	}	try {	Files.move(srcFile.toPath(), destFile.toPath(), StandardCopyOption.ATOMIC_MOVE);	} catch (AtomicMoveNotSupportedException e) {	if (!WARNED_ON_NON_ATOMIC_FILE_UPDATES) {	WARNED_ON_NON_ATOMIC_FILE_UPDATES = true;	
unable to perform atomic file update to file system not recommended for production ha dr 

}	try {	Files.move(srcFile.toPath(), destFile.toPath(), StandardCopyOption.ATOMIC_MOVE);	} catch (AtomicMoveNotSupportedException e) {	if (!WARNED_ON_NON_ATOMIC_FILE_UPDATES) {	WARNED_ON_NON_ATOMIC_FILE_UPDATES = true;	}	Files.move(srcFile.toPath(), destFile.toPath(), StandardCopyOption.REPLACE_EXISTING);	}	if (log.isTraceEnabled()) {	
completly moved from to completed 

public static void deleteCompletely(File d) {	DeletionResult result = Os.deleteRecursively(d);	
unable to delete persistence dir 

========================= brooklyn sample_1151 =========================

protected SshjTool(Builder<?,?> builder) {	super(builder);	sshTries = builder.sshTries;	sshTriesTimeout = builder.sshTriesTimeout;	backoffLimitedRetryHandler = new BackoffLimitedRetryHandler(sshTries, builder.sshRetryDelay);	sshClientConnection = SshjClientConnection.builder() .hostAndPort(HostAndPort.fromParts(host, port)) .username(user) .password(password) .privateKeyPassphrase(privateKeyPassphrase) .privateKeyData(privateKeyData) .privateKeyFile(privateKeyFile) .strictHostKeyChecking(strictHostKeyChecking) .connectTimeout(builder.connectTimeout) .sessionTimeout(builder.sessionTimeout) .build();	
created sshtool 

public void connect() {	try {	
connecting sshjtool 

public void connect() {	try {	acquire(sshClientConnection);	} catch (Exception e) {	
failed to connect rethrowing 

public void disconnect() {	
disconnecting sshjtool 

public void disconnect() {	try {	Stopwatch perfStopwatch = Stopwatch.createStarted();	sshClientConnection.clear();	
ssh performance disconnect took 

public int execScript(final Map<String,?> props, final List<String> commands, final Map<String,?> env) {	Boolean execAsync = getOptionalVal(props, PROP_EXEC_ASYNC);	if (Boolean.TRUE.equals(execAsync) && BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_SSH_ASYNC_EXEC)) {	return execScriptAsyncAndPoll(props, commands, env);	} else {	if (Boolean.TRUE.equals(execAsync)) {	
ignoring ssh exec async configuration because feature is disabled 

public int execScript(final Map<String,?> props, final List<String> commands, final Map<String,?> env) {	Boolean execAsync = getOptionalVal(props, PROP_EXEC_ASYNC);	if (Boolean.TRUE.equals(execAsync) && BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_SSH_ASYNC_EXEC)) {	return execScriptAsyncAndPoll(props, commands, env);	} else {	if (Boolean.TRUE.equals(execAsync)) {	}	return new ToolAbstractExecScript(props) {	public int run() {	String scriptContents = toScript(props, commands, env);	
running shell command at as script 

private Duration maxDelayBetweenPolls = Duration.seconds(20);	private Duration pollTimeout = getOptionalVal(props, PROP_EXEC_ASYNC_POLLING_TIMEOUT, Duration.FIVE_MINUTES);	private int iteration = 0;	private int consecutiveSshFailures = 0;	private int stdoutCount = 0;	private int stderrCount = 0;	private Stopwatch timer;	public int run() {	timer = Stopwatch.createStarted();	final String scriptContents = toScript(props, commands, env);	
running shell command at as async script 

LOG.trace(msg);	} else {	LOG.debug(msg);	}	}	copyToServer(ImmutableMap.of("permissions", "0700"), scriptContents.getBytes(), scriptPath);	return true;	}}) .run();	if (!uploadSuccess) {	String msg = "Unexpected state: repeated failure for async script upload on "+SshjTool.this.toString()+" ("+getSummary()+")";	
rethrowing 

boolean success = Repeater.create("async script long-poll on "+SshjTool.this.toString()+" (for "+getSummary()+")") .backoffTo(maxDelayBetweenPolls) .limitTimeTo(execTimeout) .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	iteration++;	if (LOG.isDebugEnabled()) LOG.debug("Doing long-poll (iteration="+iteration+") for async script to complete on "+SshjTool.this.toString()+" (for "+getSummary()+")");	Integer exitstatus = longPoll();	result.set(exitstatus);	return exitstatus != null;	}}) .run();	if (!success) {	String msg = "Timeout for async script to complete on "+SshjTool.this.toString()+" ("+getSummary()+")";	
rethrowing 

Integer exitstatus = longPoll();	result.set(exitstatus);	return exitstatus != null;	}}) .run();	if (!success) {	String msg = "Timeout for async script to complete on "+SshjTool.this.toString()+" ("+getSummary()+")";	throw new TimeoutException(msg);	}	return result.get();	} catch (Exception e) {	
problem polling for async script on for rethrowing after deleting temporary files 

String msg = "Timeout for async script to complete on "+SshjTool.this.toString()+" ("+getSummary()+")";	throw new TimeoutException(msg);	}	return result.get();	} catch (Exception e) {	throw Exceptions.propagate(e);	} finally {	try {	int execDeleteResult = asInt(acquire(new ShellAction(deleteTemporaryFilesCommand(), out, err, pollTimeout)), -1);	if (execDeleteResult != 0) {	
problem deleting temporary files of async script on for exit status 

return result.get();	} catch (Exception e) {	throw Exceptions.propagate(e);	} finally {	try {	int execDeleteResult = asInt(acquire(new ShellAction(deleteTemporaryFilesCommand(), out, err, pollTimeout)), -1);	if (execDeleteResult != 0) {	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
problem deleting temporary files of async script on for continuing 

Duration nextPollTimeout = Duration.min(pollTimeout, Duration.millis(execTimeout.toMilliseconds()-timer.elapsed(TimeUnit.MILLISECONDS)));	CountingOutputStream countingOut = (out == null) ? null : new CountingOutputStream(out);	CountingOutputStream countingErr = (err == null) ? null : new CountingOutputStream(err);	List<String> pollCommand = buildLongPollCommand(stdoutCount, stderrCount, nextPollTimeout);	Duration sshJoinTimeout = nextPollTimeout.add(Duration.TEN_SECONDS);	ShellAction action = new ShellAction(pollCommand, countingOut, countingErr, sshJoinTimeout);	int longPollResult;	try {	longPollResult = asInt(acquire(action, 3, nextPollTimeout), -1);	} catch (RuntimeTimeoutException e) {	
long poll timed out on for 

ShellAction action = new ShellAction(pollCommand, countingOut, countingErr, sshJoinTimeout);	int longPollResult;	try {	longPollResult = asInt(acquire(action, 3, nextPollTimeout), -1);	} catch (RuntimeTimeoutException e) {	return null;	}	stdoutCount += (countingOut == null) ? 0 : countingOut.getCount();	stderrCount += (countingErr == null) ? 0 : countingErr.getCount();	if (longPollResult == 0) {	
long poll succeeded exit status on for 

try {	longPollResult = asInt(acquire(action, 3, nextPollTimeout), -1);	} catch (RuntimeTimeoutException e) {	return null;	}	stdoutCount += (countingOut == null) ? 0 : countingOut.getCount();	stderrCount += (countingErr == null) ? 0 : countingErr.getCount();	if (longPollResult == 0) {	return longPollResult;	} else if (longPollResult == -1) {	
long poll received exit status will retry on for 

} catch (RuntimeTimeoutException e) {	return null;	}	stdoutCount += (countingOut == null) ? 0 : countingOut.getCount();	stderrCount += (countingErr == null) ? 0 : countingErr.getCount();	if (longPollResult == 0) {	return longPollResult;	} else if (longPollResult == -1) {	return null;	} else if (longPollResult == 125) {	
long poll received exit status most likely timeout retrieving actual status on for 

}	stdoutCount += (countingOut == null) ? 0 : countingOut.getCount();	stderrCount += (countingErr == null) ? 0 : countingErr.getCount();	if (longPollResult == 0) {	return longPollResult;	} else if (longPollResult == -1) {	return null;	} else if (longPollResult == 125) {	return retrieveStatusCommand();	} else {	
long poll received exit status retrieving actual status on for 

} else if (longPollResult == 125) {	return retrieveStatusCommand();	} else {	Integer result = retrieveStatusCommand();	if (result != null) {	return result;	}	}	consecutiveSshFailures++;	if (consecutiveSshFailures > maxConsecutiveSshFailures) {	
aborting on consecutive ssh connection errors return when polling for async script to complete on 

} else {	Integer result = retrieveStatusCommand();	if (result != null) {	return result;	}	}	consecutiveSshFailures++;	if (consecutiveSshFailures > maxConsecutiveSshFailures) {	return -1;	} else {	
retrying after ssh connection error when polling for async script to complete on 

return null;	}	}	Integer retrieveStatusCommand() throws IOException {	ByteArrayOutputStream statusOut = new ByteArrayOutputStream();	ByteArrayOutputStream statusErr = new ByteArrayOutputStream();	int statusResult = asInt(acquire(new ShellAction(buildRetrieveStatusCommand(), statusOut, statusErr, execTimeout)), -1);	if (statusResult == 0) {	String statusOutStr = new String(statusOut.toByteArray()).trim();	if (Strings.isEmpty(statusOutStr)) {	
long poll retrieved status directly command successful but no result available on for 

}	Integer retrieveStatusCommand() throws IOException {	ByteArrayOutputStream statusOut = new ByteArrayOutputStream();	ByteArrayOutputStream statusErr = new ByteArrayOutputStream();	int statusResult = asInt(acquire(new ShellAction(buildRetrieveStatusCommand(), statusOut, statusErr, execTimeout)), -1);	if (statusResult == 0) {	String statusOutStr = new String(statusOut.toByteArray()).trim();	if (Strings.isEmpty(statusOutStr)) {	return null;	} else {	
long poll retrieved status directly returning on for 

int statusResult = asInt(acquire(new ShellAction(buildRetrieveStatusCommand(), statusOut, statusErr, execTimeout)), -1);	if (statusResult == 0) {	String statusOutStr = new String(statusOut.toByteArray()).trim();	if (Strings.isEmpty(statusOutStr)) {	return null;	} else {	int result = Integer.parseInt(statusOutStr);	return result;	}	} else if (statusResult == -1) {	
long poll retrieving status directly received exit status will retry on for 

return null;	} else {	if (out != null) {	out.write(toUTF8ByteArray("retrieving status failed with exit code "+statusResult+" (stdout follow)"));	out.write(statusOut.toByteArray());	}	if (err != null) {	err.write(toUTF8ByteArray("retrieving status failed with exit code "+statusResult+" (stderr follow)"));	err.write(statusErr.toByteArray());	}	
long poll retrieving status failed returning on for 

public int execShellDirect(Map<String,?> props, List<String> commands, Map<String,?> env) {	OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);	OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);	Duration execTimeout = getOptionalVal(props, PROP_EXEC_TIMEOUT);	List<String> cmdSequence = toCommandSequence(commands, env);	List<String> allcmds = ImmutableList.<String>builder() .add(getOptionalVal(props, PROP_DIRECT_HEADER)) .addAll(cmdSequence) .add("exit $?") .build();	
running shell command at 

public int execShellDirect(Map<String,?> props, List<String> commands, Map<String,?> env) {	OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);	OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);	Duration execTimeout = getOptionalVal(props, PROP_EXEC_TIMEOUT);	List<String> cmdSequence = toCommandSequence(commands, env);	List<String> allcmds = ImmutableList.<String>builder() .add(getOptionalVal(props, PROP_DIRECT_HEADER)) .addAll(cmdSequence) .add("exit $?") .build();	Integer result = acquire(new ShellAction(allcmds, out, err, execTimeout));	
running shell command at completed return status 

if (Boolean.TRUE.equals(execAsync) && BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_SSH_ASYNC_EXEC)) {	return execScriptAsyncAndPoll(props, commands, env);	}	OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);	OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);	String separator = getOptionalVal(props, PROP_SEPARATOR);	Duration execTimeout = getOptionalVal(props, PROP_EXEC_TIMEOUT);	List<String> allcmds = toCommandSequence(commands, env);	String singlecmd = Joiner.on(separator).join(allcmds);	if (Boolean.TRUE.equals(getOptionalVal(props, PROP_RUN_AS_ROOT))) {	
cannot run as root when executing as command run as a script instead will run as normal user 

return execScriptAsyncAndPoll(props, commands, env);	}	OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);	OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);	String separator = getOptionalVal(props, PROP_SEPARATOR);	Duration execTimeout = getOptionalVal(props, PROP_EXEC_TIMEOUT);	List<String> allcmds = toCommandSequence(commands, env);	String singlecmd = Joiner.on(separator).join(allcmds);	if (Boolean.TRUE.equals(getOptionalVal(props, PROP_RUN_AS_ROOT))) {	}	
running command at 

}	OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);	OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);	String separator = getOptionalVal(props, PROP_SEPARATOR);	Duration execTimeout = getOptionalVal(props, PROP_EXEC_TIMEOUT);	List<String> allcmds = toCommandSequence(commands, env);	String singlecmd = Joiner.on(separator).join(allcmds);	if (Boolean.TRUE.equals(getOptionalVal(props, PROP_RUN_AS_ROOT))) {	}	Command result = acquire(new ExecAction(singlecmd, out, err, execTimeout));	
running command at completed exit code 

protected <T, C extends SshAction<T>> T acquire(C action, int sshTries, Duration sshTriesTimeout) {	Stopwatch stopwatch = Stopwatch.createStarted();	for (int i = 0; i < sshTries; i++) {	try {	action.clear();	
acquiring 

for (int i = 0; i < sshTries; i++) {	try {	action.clear();	Stopwatch perfStopwatch = Stopwatch.createStarted();	T returnVal;	try {	returnVal = action.create();	} catch (AssertionError e) {	throw new IllegalStateException("Problem in "+toString()+" for "+action, e);	}	
acquired 

for (int i = 0; i < sshTries; i++) {	try {	action.clear();	Stopwatch perfStopwatch = Stopwatch.createStarted();	T returnVal;	try {	returnVal = action.create();	} catch (AssertionError e) {	throw new IllegalStateException("Problem in "+toString()+" for "+action, e);	}	
ssh performance took 

throw new IllegalStateException("Problem in "+toString()+" for "+action, e);	}	sshClientConnection.getHostAndPort(), action.getClass().getSimpleName() != null ? action.getClass().getSimpleName() : action, Time.makeTimeStringRounded(perfStopwatch)});	return returnVal;	} catch (Exception e) {	String errorMessage = String.format("(%s) error acquiring %s", toString(), action);	String fullMessage = String.format("%s (attempt %s/%s, in time %s/%s)", errorMessage, (i+1), sshTries, Time.makeTimeStringRounded(stopwatch.elapsed(TimeUnit.MILLISECONDS)), (sshTriesTimeout.equals(Duration.PRACTICALLY_FOREVER) ? "unlimited" : Time.makeTimeStringRounded(sshTriesTimeout)));	try {	disconnect();	} catch (Exception e2) {	
error closing connection 

sshClientConnection.getHostAndPort(), action.getClass().getSimpleName() != null ? action.getClass().getSimpleName() : action, Time.makeTimeStringRounded(perfStopwatch)});	return returnVal;	} catch (Exception e) {	String errorMessage = String.format("(%s) error acquiring %s", toString(), action);	String fullMessage = String.format("%s (attempt %s/%s, in time %s/%s)", errorMessage, (i+1), sshTries, Time.makeTimeStringRounded(stopwatch.elapsed(TimeUnit.MILLISECONDS)), (sshTriesTimeout.equals(Duration.PRACTICALLY_FOREVER) ? "unlimited" : Time.makeTimeStringRounded(sshTriesTimeout)));	try {	disconnect();	} catch (Exception e2) {	}	if (i + 1 == sshTries) {	
rethrowing out of retries 

} catch (Exception e) {	String errorMessage = String.format("(%s) error acquiring %s", toString(), action);	String fullMessage = String.format("%s (attempt %s/%s, in time %s/%s)", errorMessage, (i+1), sshTries, Time.makeTimeStringRounded(stopwatch.elapsed(TimeUnit.MILLISECONDS)), (sshTriesTimeout.equals(Duration.PRACTICALLY_FOREVER) ? "unlimited" : Time.makeTimeStringRounded(sshTriesTimeout)));	try {	disconnect();	} catch (Exception e2) {	}	if (i + 1 == sshTries) {	throw propagate(e, fullMessage + "; out of retries");	} else if (sshTriesTimeout.isShorterThan(stopwatch)) {	
rethrowing out of time max 

}	try {	output.join((int)Math.min(timeout.toMilliseconds(), Integer.MAX_VALUE), TimeUnit.MILLISECONDS);	return output;	} finally {	try {	long joinTimeout = 10*1000;	if (outgobbler != null) outgobbler.join(joinTimeout);	if (errgobbler != null) errgobbler.join(joinTimeout);	} catch (InterruptedException e) {	
interrupted gobbling streams from ssh 

errgobbler = new StreamGobbler(errstream, err, (Logger)null);	errgobbler.start();	}	OutputStream output = shell.getOutputStream();	for (CharSequence cmd : commands) {	try {	output.write(toUTF8ByteArray(cmd+"\n"));	output.flush();	} catch (ConnectionException e) {	if (!shell.isOpen()) {	
shell closed to when executing 

try {	shell.join(1000, TimeUnit.MILLISECONDS);	} catch (ConnectionException e) {	last = e;	}	if (endBecauseReturned) {	break;	}	} while (System.currentTimeMillis() < timeoutEnd);	if (shell.isOpen() && ((SessionChannel)session).getExitStatus()==null) {	
timeout in ssh shell to 

long joinTimeout = (timedOut) ? 1000 : 10*1000;	if (outgobbler != null) {	outgobbler.join(joinTimeout);	outgobbler.close();	}	if (errgobbler != null) {	errgobbler.join(joinTimeout);	errgobbler.close();	}	} catch (InterruptedException e) {	
interrupted gobbling streams from ssh 

========================= brooklyn sample_1444 =========================

private void assert12StandardChecks(RuntimeException e, boolean isPropagated) {	String collapseText = Exceptions.collapseText(e);	
exception collapsing got 

========================= brooklyn sample_1917 =========================

if (m.getOperatingSystem() == null || !template.getOsFamily().equals(m.getOperatingSystem().getFamily())) return false;	}	if (template.getOsNameMatchesRegex()!=null) {	if (m.getOperatingSystem() == null || m.getOperatingSystem().getName()==null || !m.getOperatingSystem().getName().matches(template.getOsNameMatchesRegex())) return false;	}	if (template.getLocationId()!=null) {	if (!isLocationContainedIn(m.getLocation(), template.getLocationId())) return false;	}	return true;	} catch (Exception e) {	
error rethrowing trying to match against 

========================= brooklyn sample_2638 =========================

protected void destroyManagementContextSafely(ManagementContext mgmt) {	try {	if (mgmt != null) Entities.destroyAll(mgmt);	} catch (Throwable t) {	
caught exception destroying management context 

========================= brooklyn sample_718 =========================

public AssemblyTemplateDto get( return dto().adapt(lookup(camp().assemblyTemplates(), id));	}	) public Response post( try {	
camp rest instantiating at 

public AssemblyTemplateDto get( return dto().adapt(lookup(camp().assemblyTemplates(), id));	}	) public Response post( try {	AssemblyTemplate at = lookup(camp().assemblyTemplates(), id);	Assembly assembly = at.getInstantiator().newInstance().instantiate(at, camp());	URI assemblyUri = info.getBaseUriBuilder().path( dto().adapt(assembly).getUri() ).build();	return Response.created(assemblyUri).build();	} catch (Exception e) {	
unable to create at 

========================= brooklyn sample_1805 =========================

public void canStartupAndShutdown() throws Exception {	activeMQ = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class));	activeMQ.start(ImmutableList.of(testLocation));	EntityAsserts.assertAttributeEqualsEventually(ImmutableMap.of("timeout", 10*60*1000), activeMQ, Startable.SERVICE_UP, true);	
jmx url is 

public void canStartupAndShutdownWithCustomJmx() throws Exception {	activeMQ = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class) .configure("jmxPort", "11099+"));	activeMQ.start(ImmutableList.of(testLocation));	EntityAsserts.assertAttributeEqualsEventually(ImmutableMap.of("timeout", 10*60*1000), activeMQ, Startable.SERVICE_UP, true);	
jmx url is 

public void canStartupAndShutdownWithCustomBrokerName() throws Exception {	activeMQ = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class) .configure("jmxPort", "11099+") .configure("brokerName", "bridge"));	activeMQ.start(ImmutableList.of(testLocation));	EntityAsserts.assertAttributeEqualsEventually(ImmutableMap.of("timeout", 10*60*1000), activeMQ, Startable.SERVICE_UP, true);	
jmx url is 

public void canStartTwo() throws Exception {	ActiveMQBroker activeMQ1 = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class));	ActiveMQBroker activeMQ2 = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class));	activeMQ1.start(ImmutableList.of(testLocation));	EntityAsserts.assertAttributeEqualsEventually(ImmutableMap.of("timeout", 10 * 60 * 1000), activeMQ1, Startable.SERVICE_UP, true);	
jmx url is 

public void canStartTwo() throws Exception {	ActiveMQBroker activeMQ1 = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class));	ActiveMQBroker activeMQ2 = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class));	activeMQ1.start(ImmutableList.of(testLocation));	EntityAsserts.assertAttributeEqualsEventually(ImmutableMap.of("timeout", 10 * 60 * 1000), activeMQ1, Startable.SERVICE_UP, true);	activeMQ2.start(ImmutableList.of(testLocation));	EntityAsserts.assertAttributeEqualsEventually(ImmutableMap.of("timeout", 10*60*1000), activeMQ2, Startable.SERVICE_UP, true);	
jmx url is 

public String testCreatingQueuesInternal(JmxAgentModes mode) throws Exception {	String queueName = "testQueue";	int number = 20;	String content = "01234567890123456789012345678901";	activeMQ = app.createAndManageChild(EntitySpec.create(ActiveMQBroker.class) .configure("queue", queueName) .configure(UsesJmx.JMX_AGENT_MODE, mode));	activeMQ.start(ImmutableList.of(testLocation));	EntityAsserts.assertAttributeEqualsEventually(ImmutableMap.of("timeout", 10 * 60 * 1000), activeMQ, Startable.SERVICE_UP, true);	String jmxUrl = activeMQ.getAttribute(UsesJmx.JMX_URL);	
jmx url is 

========================= brooklyn sample_431 =========================

public final synchronized Entity get() {	try {	
queuing task to resolve child 

public final synchronized Entity get() {	try {	Entity result = Entities.submit(entity(), newTask()).get();	
resolved from child 

========================= brooklyn sample_574 =========================

public void testGenerateGroupIdWithEntity() {	TestApplication app = mgmt.getEntityManager().createEntity(EntitySpec.create(TestApplication.class).displayName("TistApp"));	TestEntity child = app.createAndManageChild(EntitySpec.create(TestEntity.class).displayName("TestEnt"));	ConfigBag cfg = new ConfigBag() .configure(CloudLocationConfig.CALLER_CONTEXT, child);	String result = new BasicCloudMachineNamer().generateNewGroupId(cfg);	
test entity child group id gives 

========================= brooklyn sample_827 =========================

public void prePreManage(Entity entity) {	
ignoring call to prepremanage on 

public void prePreManage(Location location) {	
ignoring call to prepremanage on 

========================= brooklyn sample_1043 =========================

machine = createEc2Machine(ImmutableMap.<String,Object>of());	assertSshable(machine);	String locationAddress = machine.getAddress().getHostName();	InetAddress address = machine.getAddress();	Set<String> publicAddresses = machine.getPublicAddresses();	Set<String> privateAddresses = machine.getPrivateAddresses();	String subnetIp = machine.getSubnetIp();	String subnetHostname = machine.getSubnetHostname();	String hostname = machine.getHostname();	String msg = "locationAddress="+locationAddress+"; address="+address+"; publicAddrs="+publicAddresses+"; privateAddrs="+privateAddresses+"; subnetIp="+subnetIp+"; hostname="+hostname+"; subnetHostname="+subnetHostname;	
node 

machine = createRackspaceMachine(ImmutableMap.<String,Object>of());	assertSshable(machine);	String locationAddress = machine.getAddress().getHostAddress();	InetAddress address = machine.getAddress();	Set<String> publicAddresses = machine.getPublicAddresses();	Set<String> privateAddresses = machine.getPrivateAddresses();	String subnetIp = machine.getSubnetIp();	String hostname = machine.getHostname();	String subnetHostname = machine.getSubnetHostname();	String msg = "locationAddress="+locationAddress+"; address="+address+"; publicAddrs="+publicAddresses+"; privateAddrs="+privateAddresses+"; subnetIp="+subnetIp+"; hostname="+hostname+"; subnetHostname="+subnetHostname;	
node 

========================= brooklyn sample_2550 =========================

try {	V val = job.call();	loggedPreviousException = false;	if (handler.checkSuccess(val)) {	handler.onSuccess(val);	} else {	handler.onFailure(val);	}	} catch (Exception e) {	if (loggedPreviousException) {	
polljob for repeated consecutive failures handling using 

V val = job.call();	loggedPreviousException = false;	if (handler.checkSuccess(val)) {	handler.onSuccess(val);	} else {	handler.onFailure(val);	}	} catch (Exception e) {	if (loggedPreviousException) {	} else {	
polljob for handling using 

public void start() {	
starting poll for using 

return task;	}	};	Map<String, ?> taskFlags = MutableMap.of("displayName", "scheduled:" + scheduleName);	ScheduledTask task = new ScheduledTask(taskFlags, pollingTaskFactory) .period(pollJob.pollPeriod) .cancelOnException(false);	tasks.add(Entities.submit(entity, task));	if (minPeriod==null || (pollJob.pollPeriod.isShorterThan(minPeriod))) {	minPeriod = pollJob.pollPeriod;	}	} else {	
activating poll but leaving off as period for using 

public void stop() {	
stopping poll for using 

public boolean isRunning() {	boolean hasActiveTasks = false;	for (Task<?> task: tasks) {	if (task.isBegun() && !task.isDone()) {	hasActiveTasks = true;	break;	}	}	if (!started && hasActiveTasks) {	
poller should not be running but has active tasks tasks 

========================= brooklyn sample_1393 =========================

public void testSimpleYamlArtifactParse() throws IOException {	BasicCampPlatform platform = MockWebPlatform.populate(new BasicCampPlatform());	Reader input = Streams.reader(getClass().getResourceAsStream("pdp-single-artifact.yaml"));	DeploymentPlan plan = platform.pdp().parseDeploymentPlan(input);	
dp is 

public void testSimpleYamlServiceParse() throws IOException {	BasicCampPlatform platform = MockWebPlatform.populate(new BasicCampPlatform());	Reader input = Streams.reader(getClass().getResourceAsStream("pdp-single-service.yaml"));	DeploymentPlan plan = platform.pdp().parseDeploymentPlan(input);	
dp is 

public void testSimpleYamlMatch() throws IOException {	BasicCampPlatform platform = MockWebPlatform.populate(new BasicCampPlatform());	Reader input = new InputStreamReader(getClass().getResourceAsStream("pdp-single-artifact.yaml"));	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	
at is 

========================= brooklyn sample_1813 =========================

long preCpuTime = PerformanceTestUtils.getProcessCpuTime();	Stopwatch stopwatch = Stopwatch.createStarted();	for (int i = 0; i < iterations; i++) {	List<ListenableFuture<?>> futures = Lists.newArrayList();	for (int j = 0; j < concurrentRuns; j++) {	futures.add(executor.submit(new Runnable() {	public void run() {	try {	task.run();	} catch (Exception e) {	
error for executing 

task.run();	} catch (Exception e) {	throw Throwables.propagate(e);	}	}}));	}	Futures.allAsList(futures).get();	long postCpuTime = PerformanceTestUtils.getProcessCpuTime();	long elapsedTime = stopwatch.elapsed(TimeUnit.MILLISECONDS);	double fractionCpu = (elapsedTime > 0) ? ((double)postCpuTime-preCpuTime) / TimeUnit.MILLISECONDS.toNanos(elapsedTime) : -1;	
executing completed took fraction cpu 

========================= brooklyn sample_974 =========================

protected void runFeedsDoNotPollUntilManaged(int numEntities, Duration delayAfterRebind) throws Exception {	List<MyServiceWithFeeds> origEs = Lists.newArrayList();	
creating entities 

protected void runFeedsDoNotPollUntilManaged(int numEntities, Duration delayAfterRebind) throws Exception {	List<MyServiceWithFeeds> origEs = Lists.newArrayList();	for (int i = 0; i < numEntities; i++) {	origEs.add(origApp.createAndManageChild(EntitySpec.create(MyServiceWithFeeds.class) .configure(SoftwareProcess.SERVICE_PROCESS_IS_RUNNING_POLL_PERIOD, Duration.millis(10)) .configure(BrooklynConfigKeys.SKIP_ON_BOX_BASE_DIR_RESOLUTION, true)));	}	
starting entities 

for (int i = 0; i < numEntities; i++) {	origEs.add(origApp.createAndManageChild(EntitySpec.create(MyServiceWithFeeds.class) .configure(SoftwareProcess.SERVICE_PROCESS_IS_RUNNING_POLL_PERIOD, Duration.millis(10)) .configure(BrooklynConfigKeys.SKIP_ON_BOX_BASE_DIR_RESOLUTION, true)));	}	MyProvisioningLocation origLoc = mgmt().getLocationManager().createLocation(LocationSpec.create(MyProvisioningLocation.class) .displayName("mylocname"));	origApp.start(ImmutableList.of(origLoc));	for (Entity child : origApp.getChildren()) {	EntityAsserts.assertAttributeEquals(child, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.RUNNING);	EntityAsserts.assertAttributeEquals(child, Attributes.SERVICE_UP, Boolean.TRUE);	EntityAsserts.assertAttributeEqualsEventually(child, SoftwareProcess.SERVICE_PROCESS_IS_RUNNING, Boolean.TRUE);	}	
rebinding entities 

}	MyProvisioningLocation origLoc = mgmt().getLocationManager().createLocation(LocationSpec.create(MyProvisioningLocation.class) .displayName("mylocname"));	origApp.start(ImmutableList.of(origLoc));	for (Entity child : origApp.getChildren()) {	EntityAsserts.assertAttributeEquals(child, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.RUNNING);	EntityAsserts.assertAttributeEquals(child, Attributes.SERVICE_UP, Boolean.TRUE);	EntityAsserts.assertAttributeEqualsEventually(child, SoftwareProcess.SERVICE_PROCESS_IS_RUNNING, Boolean.TRUE);	}	newApp = rebind();	Duration.sleep(delayAfterRebind);	
checking state of entities after rebind 

========================= brooklyn sample_2229 =========================

public Response disallowResponse(String problem, Object info) {	
disallowing web request as caller should set to force 

========================= brooklyn sample_2911 =========================

protected void finalize() {	
sshfeed builder created but build never called 

final Set<ChefAttributePollConfig<?>> polls = getConfig(POLLS);	long minPeriod = Integer.MAX_VALUE;	for (ChefAttributePollConfig<?> config : polls) {	minPeriod = Math.min(minPeriod, config.getPeriod());	}	knifeTaskFactory = new KnifeNodeAttributeQueryTaskFactory(nodeName);	final Callable<SshPollValue> getAttributesFromKnife = new Callable<SshPollValue>() {	public SshPollValue call() throws Exception {	ProcessTaskWrapper<String> taskWrapper = knifeTaskFactory.newTask();	final ExecutionContext executionContext = ((EntityInternal) entity).getExecutionContext();	
start running knife to query attributes of chef node 

for (ChefAttributePollConfig<?> config : polls) {	minPeriod = Math.min(minPeriod, config.getPeriod());	}	knifeTaskFactory = new KnifeNodeAttributeQueryTaskFactory(nodeName);	final Callable<SshPollValue> getAttributesFromKnife = new Callable<SshPollValue>() {	public SshPollValue call() throws Exception {	ProcessTaskWrapper<String> taskWrapper = knifeTaskFactory.newTask();	final ExecutionContext executionContext = ((EntityInternal) entity).getExecutionContext();	executionContext.submit(taskWrapper);	taskWrapper.block();	
done running knife to query attributes of chef node 

return true;	}	public void onSuccess(SshPollValue val) {	String stdout = val.getStdout();	int jsonStarts = stdout.indexOf('{');	if (jsonStarts > 0) stdout = stdout.substring(jsonStarts);	JsonElement jsonElement = new Gson().fromJson(stdout, JsonElement.class);	for (Map.Entry<String, AttributeSensor<?>> attribute : chefAttributeSensors.entrySet()) {	String chefAttributeName = attribute.getKey();	AttributeSensor<?> sensor = attribute.getValue();	
finding value for attribute sensor 

for (Map.Entry<String, AttributeSensor<?>> attribute : chefAttributeSensors.entrySet()) {	String chefAttributeName = attribute.getKey();	AttributeSensor<?> sensor = attribute.getValue();	Iterable<String> path = SPLITTER.split(chefAttributeName);	JsonElement elementForSensor = null;	for(String prefix : PREFIXES) {	Iterable<String> prefixedPath = !Strings.isNullOrEmpty(prefix) ? Iterables.concat(ImmutableList.of(prefix), path) : path;	try {	elementForSensor = getElementByPath(jsonElement.getAsJsonObject(), prefixedPath);	} catch(IllegalArgumentException e) {	
entity bad chef attribute for sensor 

JsonElement elementForSensor = null;	for(String prefix : PREFIXES) {	Iterable<String> prefixedPath = !Strings.isNullOrEmpty(prefix) ? Iterables.concat(ImmutableList.of(prefix), path) : path;	try {	elementForSensor = getElementByPath(jsonElement.getAsJsonObject(), prefixedPath);	} catch(IllegalArgumentException e) {	entity.getDisplayName(), Joiner.on('.').join(prefixedPath), sensor.getName(), e.getMessage()});	throw Throwables.propagate(e);	}	if (elementForSensor != null) {	
entity apply chef attribute to sensor with value 

throw Throwables.propagate(e);	}	if (elementForSensor != null) {	entity.getDisplayName(), Joiner.on('.').join(prefixedPath), sensor.getName(), elementForSensor.getAsString()});	break;	}	}	if (elementForSensor != null) {	entity.sensors().set((AttributeSensor)sensor, TypeCoercions.coerce(elementForSensor.getAsString(), sensor.getTypeToken()));	} else {	
entity no chef attribute matching setting sensor to null 

}	}	public void onFailure(SshPollValue val) {	log.error("Chef attribute query did not respond as expected. exitcode={} stdout={} stderr={}", new Object[]{val.getExitStatus(), val.getStdout(), val.getStderr()});	for (AttributeSensor<?> attribute : chefAttributeSensors.values()) {	if (!attribute.getName().startsWith(CHEF_ATTRIBUTE_PREFIX)) continue;	entity.sensors().set(attribute, null);	}	}	public void onException(Exception exception) {	
detected exception while retrieving chef attributes from entity 

========================= brooklyn sample_2291 =========================

public void tearDown() throws Exception {	try {	if (server != null) server.stop();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
failed to stop server 

public void testWithAcceptsPlainText() throws Exception {	setConfig(mgmt);	String content = getConfigValueAsText();	
config mgmt is 

public void testWithServer() throws Exception {	setConfig(server);	Map<?, ?> values = getConfigValueAsJson();	String content = getRestValue(configUri, MediaType.APPLICATION_JSON);	
config is 

protected Map<?, ?> getRestValueAsJson(URI url) {	String content = getRestValue(url, MediaType.APPLICATION_JSON);	
config is 

========================= brooklyn sample_2784 =========================

protected abstract void addProducerHardcoded(Entity producer);	protected abstract void addProducerMember(Entity producer);	protected abstract void addProducerChild(Entity producer);	protected void removeProducer(Entity producer) {	
stopped listening to 

protected abstract void onProducerAdded(Entity producer);	protected abstract void onProducerRemoved(Entity producer);	protected void onUpdated() {	try {	emit(targetSensor, compute());	} catch (Throwable t) {	
error calculating and setting aggregate for enricher 

========================= brooklyn sample_1002 =========================

PersistenceObjectStore objectStore = ((BrooklynMementoPersisterToObjectStore)input).getObjectStore();	for (BrooklynObjectType type : BrooklynObjectType.values()) {	final List<String> contents = objectStore.listContentsWithSubPath(type.getSubPathName());	for (String path : contents) {	if (path.endsWith(".jar")) {	continue;	}	StoreObjectAccessor accessor = objectStore.newAccessor(path);	String memento = checkNotNull(accessor.get(), path);	String replacement = transformed.getObjectsOfType(type).get(idFromPath(type, path));	
replacing with 

========================= brooklyn sample_1645 =========================

protected JsonObject apiGet(String path, ImmutableMap<String, String> headers) {	try {	String uri = Urls.mergePaths(endpoint, path);	
vault request get 

protected JsonObject apiGet(String path, ImmutableMap<String, String> headers) {	try {	String uri = Urls.mergePaths(endpoint, path);	HttpToolResponse response = HttpTool.httpGet(httpClient, Urls.toUri(uri), headers);	
vault response code 

protected JsonObject apiPost(String path, ImmutableMap<String, String> headers, ImmutableMap<String, String> requestData) {	try {	String body = gson.toJson(requestData);	String uri = Urls.mergePaths(endpoint, path);	
vault request post 

protected JsonObject apiPost(String path, ImmutableMap<String, String> headers, ImmutableMap<String, String> requestData) {	try {	String body = gson.toJson(requestData);	String uri = Urls.mergePaths(endpoint, path);	HttpToolResponse response = HttpTool.httpPost(httpClient, Urls.toUri(uri), headers, body.getBytes(CHARSET_NAME));	
vault response code 

========================= brooklyn sample_1215 =========================

public void launch() {	MutableMap<String, Integer> ports = MutableMap.of("httpPort", getHttpPort(), "jmxPort", getJmxPort(), "rmiRegistryPort", getRmiRegistryPort());	Networking.checkPortsValid(ports);	newScript(MutableMap.of(USE_PID_FILE, false), LAUNCHING) .body.append( "mv "+getLogFileLocation()+" "+getLogFileLocation()+"-$(date +\"%Y%m%d.%H%M.%S\") || true", "./bin/jetty.sh start jetty-brooklyn.xml jetty.xml jetty-logging.xml jetty-stats.xml " + (Strings.isEmpty(getConfigXmlTemplateUrl()) ? "" : "jetty-custom.xml ") + ">> $RUN_DIR/console 2>&1 < /dev/null", BashCommands.waitForFileExists(getLogFileLocation(), Duration.TEN_SECONDS, false), "sleep 5", "cat $RUN_DIR/console" ) .execute();	
launched jetty 

========================= brooklyn sample_237 =========================

public void tearDown() throws Exception {	for (Application app : getManagementContext().getApplications()) {	try {	((StartableApplication) app).stop();	} catch (Exception e) {	
error stopping app during test teardown 

public void testLocationApi() throws Exception {	
testing location api 

public void testLocationApi() throws Exception {	Map<String, Map<String, Object>> locations = api.getLocationApi().getLocatedLocations();	
locations located are 

public void testApplicationApiList() throws Exception {	List<ApplicationSummary> apps = api.getApplicationApi().list(null);	
apps are 

public void testApplicationApiCreate() throws Exception {	Response r1 = api.getApplicationApi().createFromYaml("name: test-1234\n" + "services: [ { type: "+TestEntity.class.getName()+" } ]");	HttpAsserts.assertHealthyStatusCode(r1.getStatus());	
creation result 

public void testApplicationApiCreate() throws Exception {	Response r1 = api.getApplicationApi().createFromYaml("name: test-1234\n" + "services: [ { type: "+TestEntity.class.getName()+" } ]");	HttpAsserts.assertHealthyStatusCode(r1.getStatus());	List<ApplicationSummary> apps = api.getApplicationApi().list(null);	
apps with test 

========================= brooklyn sample_1 =========================

public void testGetJavaVersion() throws Exception {	SshMachineLocation sshLocation = app.getManagementContext().getLocationManager().createLocation( LocationSpec.create(SshMachineLocation.class).configure("address", "localhost"));	JavaSoftwareProcessSshDriver driver = new ConcreteJavaSoftwareProcessSshDriver(app, sshLocation);	Optional<String> version = driver.getInstalledJavaVersion();	assertNotNull(version);	assertTrue(version.isPresent());	
testgetjavaversion found on localhost 

========================= brooklyn sample_2194 =========================

public Response invoke(String application, String entityToken, String effectorName, String timeout, Map<String, Object> parameters) {	final Entity entity = brooklyn().getEntity(application, entityToken);	Maybe<Effector<?>> effector = EffectorUtils.findEffectorDeclared(entity, effectorName);	if (effector.isAbsentOrNull()) {	throw WebResourceUtils.notFound("Entity '%s' has no effector with name '%s'", entityToken, effectorName);	} else if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.INVOKE_EFFECTOR, Entitlements.EntityAndItem.of(entity, StringAndArgument.of(effector.get().getName(), null)))) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to invoke effector %s on entity %s", Entitlements.getEntitlementContext().user(), effector.get().getName(), entity);	}	String userInfo = Entitlements.getEntitlementContext() != null ? "by user " + Entitlements.getEntitlementContext().user() : "(no user info available)";	
rest invocation of 

========================= brooklyn sample_2897 =========================

public void setEntity(EntityLocal entity) {	super.setEntity(entity);	Preconditions.checkNotNull(getConfig(EFFECTOR), EFFECTOR);	sensor = getSensor();	subscriptions().subscribe(entity, sensor, this);	
subscribed to events on 

========================= brooklyn sample_1612 =========================

public Map<String, Object> getProvisioningFlags(Collection<String> tags) {	if (tags.size() > 0) {	
location ignoring provisioning tags 

========================= brooklyn sample_1307 =========================

String factoryMethodName = (String) config.getStringKeyMaybe("factoryMethod.name").orNull();	List<Object> factoryMethodArgs = (List<Object>) config.getStringKeyMaybe("factoryMethod.args").or(ImmutableList.of());	Map<String,Object> objectFields = (Map<String, Object>) config.getStringKeyMaybe("object.fields").or(MutableMap.of());	Map<String,Object> brooklynConfig = (Map<String, Object>) config.getStringKeyMaybe(BrooklynCampReservedKeys.BROOKLYN_CONFIG).or(MutableMap.of());	boolean deferred = TypeCoercions.coerce(config.getStringKeyMaybe("deferred").or(Boolean.FALSE), Boolean.class);	String mappedTypeName = DeserializingClassRenamesProvider.INSTANCE.findMappedName(typeName);	Class<?> type;	try {	type = new ClassLoaderUtils(BrooklynDslCommon.class).loadClass(mappedTypeName);	} catch (ClassNotFoundException e) {	
cannot load class for dls object assuming it is in osgi bundle will defer its loading 

public static <T> T create(Class<T> type, List<?> constructorArgs, Map<String,?> fields, Map<String,?> config) {	try {	T bean = Reflections.invokeConstructorFromArgs(type, constructorArgs.toArray()).get();	BeanUtils.populate(bean, fields);	if (config.size() > 0) {	if (bean instanceof Configurable) {	ConfigBag configBag = ConfigBag.newInstance(config);	FlagUtils.setFieldsFromFlags(bean, configBag);	FlagUtils.setAllConfigKeys((Configurable) bean, configBag, true);	} else {	
while building object type is not configurable cannot apply supplied config continuing 

========================= brooklyn sample_1757 =========================

public void init() {	
deserializingclassrenamesprovider osgiconfigloader init registering loader 

public void destroy() {	
deserializingclassrenamesprovider osgiconfigloader destroy unregistering loader 

public void updateProperties(Map properties) {	
deserializingclassrenamesprovider osgiconfigloader updateproperties clearing cache so class renames will be reloaded 

========================= brooklyn sample_519 =========================

int exitCodeOfCreate = -1;	try {	int li = remoteDir.lastIndexOf("/");	if (li>=0) {	remoteDir = remoteDir.substring(0, li+1);	exitCodeOfCreate = getMachine().execCommands("creating directory for "+getSummary(), Arrays.asList("mkdir -p "+remoteDir));	} else {	exitCodeOfCreate = 0;	}	} catch (Exception e) {	
ssh put create dir in task to threw exception 

exception = new IllegalStateException(getSummary()+" (creating dir "+remoteDir+" SSH put task) ended with exit code "+exitCodeOfCreate+", in "+Tasks.current());	throw exception;	}	}	return null;	}	}	ConfigBag config = ConfigBag.newInstanceCopying(getConfig());	if (permissions!=null) config.put(SshTool.PROP_PERMISSIONS, permissions);	exitCodeOfCopy = getMachine().copyTo(config.getAllConfig(), contents.get(), remoteFile);	
ssh put task to completed with exit code 

throw exception;	}	}	return null;	}	}	ConfigBag config = ConfigBag.newInstanceCopying(getConfig());	if (permissions!=null) config.put(SshTool.PROP_PERMISSIONS, permissions);	exitCodeOfCopy = getMachine().copyTo(config.getAllConfig(), contents.get(), remoteFile);	} catch (Exception e) {	
ssh put task to threw exception 

========================= brooklyn sample_1491 =========================

if (flags.get("owner") != null && parent != null && flags.get("owner") != parent) {	throw new IllegalArgumentException("Multiple parents supplied with flags.parent, "+flags.get("owner")+" and "+parent);	}	if (flags.get("parent") != null && flags.get("owner") != null && flags.get("parent") != flags.get("owner")) {	throw new IllegalArgumentException("Multiple parents supplied with flags.parent and flags.owner, "+flags.get("parent")+" and "+flags.get("owner"));	}	if (parent != null) {	flags.put("parent", parent);	}	if (flags.get("owner") != null) {	
use of deprecated instead of for entity 

public AbstractEntity configure(Map flags) {	if (!inConstruction && getManagementSupport().isDeployed()) {	
bulk flag configuration being made to after deployment may not be supported in future versions 

for (Iterator<Map.Entry> fi = flags.entrySet().iterator(); fi.hasNext();) {	Map.Entry entry = fi.next();	Object k = entry.getKey();	if (k instanceof HasConfigKey) k = ((HasConfigKey)k).getConfigKey();	if (k instanceof ConfigKey) {	setConfigEvenIfOwned((ConfigKey)k, entry.getValue());	fi.remove();	}	}	if (!flags.isEmpty()) {	
unsupported flags when configuring storing 

protected String getEntityTypeName() {	try {	Class<?> typeClazz = getManagementContext().getEntityManager().getEntityTypeRegistry().getEntityTypeOf(getClass());	String typeName = typeClazz.getCanonicalName();	if (typeName == null) typeName = typeClazz.getName();	return typeName;	} catch (IllegalArgumentException e) {	String typeName = getClass().getCanonicalName();	if (typeName == null) typeName = getClass().getName();	
entity type interface not found for entity instead using as entity type name 

protected void addLocationsImpl(Collection<? extends Location> newLocations, boolean publish) {	if (newLocations==null || newLocations.isEmpty()) {	return;	}	for (Location loc : newLocations) {	NamedStringTag ownerEntityTag = BrooklynTags.findFirst(BrooklynTags.OWNER_ENTITY_ID, loc.tags().getTags());	if (ownerEntityTag != null) {	if (!getId().equals(ownerEntityTag.getContents())) {	
adding location to entity which is already owned by another entity locations owned by a specific entity will be unmanaged together with their owner regardless of other references to them therefore care should be taken if sharing the location with other entities 

public <T> T set(AttributeSensor<T> attribute, T val) {	
setattribute 

if (Boolean.TRUE.equals(getManagementSupport().isReadOnlyRaw())) {	T oldVal = getAttribute(attribute);	if (Equals.approximately(val, oldVal)) {	} else {	String message = AbstractEntity.this+" setting "+attribute+" = "+val+" (was "+oldVal+") in read only mode; will have very little effect";	if (!getManagementSupport().isDeployed()) {	if (getManagementSupport().wasDeployed()) message += " (no longer deployed)";	else message += " (not yet deployed)";	}	if (WARNED_READ_ONLY_ATTRIBUTES.add(attribute.getName())) {	
future messages for this sensor logged at trace 

public <T> T setWithoutPublishing(AttributeSensor<T> attribute, T val) {	
setattributewithoutpublishing 

public <T> T modify(AttributeSensor<T> attribute, Function<? super T, Maybe<T>> modifier) {	
modifyattribute 

public <T> T modify(AttributeSensor<T> attribute, Function<? super T, Maybe<T>> modifier) {	if (Boolean.TRUE.equals(getManagementSupport().isReadOnlyRaw())) {	String message = AbstractEntity.this+" modifying "+attribute+" = "+modifier+" in read only mode; will have very little effect";	if (!getManagementSupport().isDeployed()) {	if (getManagementSupport().wasDeployed()) message += " (no longer deployed)";	else message += " (not yet deployed)";	}	if (WARNED_READ_ONLY_ATTRIBUTES.add(attribute.getName())) {	
future messages for this sensor logged at trace 

public void remove(AttributeSensor<?> attribute) {	
removeattribute 

public Map<AttributeSensor<?>, Object> getAll() {	Map<AttributeSensor<?>, Object> result = Maps.newLinkedHashMap();	Map<String, Object> attribs = attributesInternal.asMap();	for (Map.Entry<String,Object> entry : attribs.entrySet()) {	AttributeSensor<?> attribKey = (AttributeSensor<?>) entityType.getSensor(entry.getKey());	if (attribKey == null) {	
when retrieving all attributes of no attributesensor for attribute creating synthetic 

public <T> void emit(Sensor<T> sensor, T val) {	if (sensor instanceof AttributeSensor) {	
strongly discouraged use of emit with attribute sensor use setattribute instead location of discouraged attribute emit 

public <T> void emit(Sensor<T> sensor, T val) {	if (sensor instanceof AttributeSensor) {	}	if (val instanceof SensorEvent) {	
strongly discouraged use of emit with sensor event as value value should be unpacked location of discouraged event emit 

public void add(Policy policy) {	Policy old = findApparentlyEqualAndWarnIfNotSameUniqueTag(policiesInternal, policy);	if (old!=null) {	
removing when adding to 

public void add(Enricher enricher) {	Enricher old = findApparentlyEqualAndWarnIfNotSameUniqueTag(enrichersInternal, enricher);	if (old!=null) {	
removing when adding to 

T oldItem = findApparentlyEqual(items, newItem, true);	if (oldItem!=null) {	String oldItemTag = oldItem.getUniqueTag();	String newItemTag = newItem.getUniqueTag();	if (oldItemTag!=null || newItemTag!=null) {	if (Objects.equal(oldItemTag, newItemTag)) {	return oldItem;	}	T tagged = oldItemTag!=null ? oldItem : newItem;	T tagless = oldItemTag!=null ? newItem : oldItem;	
apparently equal items and but one has a unique tag applying to the other 

String newItemTag = newItem.getUniqueTag();	if (oldItemTag!=null || newItemTag!=null) {	if (Objects.equal(oldItemTag, newItemTag)) {	return oldItem;	}	T tagged = oldItemTag!=null ? oldItem : newItem;	T tagless = oldItemTag!=null ? newItem : oldItem;	((AdjunctTagSupport)tagless.tags()).setUniqueTag(tagged.getUniqueTag());	}	if (isRebinding()) {	
adding to appears identical to existing will replace underlying addition should be modified so it is not added twice during rebind or unique tag should be used to indicate it is identical 

if (Objects.equal(oldItemTag, newItemTag)) {	return oldItem;	}	T tagged = oldItemTag!=null ? oldItem : newItem;	T tagless = oldItemTag!=null ? newItem : oldItem;	((AdjunctTagSupport)tagless.tags()).setUniqueTag(tagged.getUniqueTag());	}	if (isRebinding()) {	return oldItem;	} else {	
adding to appears identical to existing may get removed on rebind underlying addition should be modified so it is not added twice 

public <T extends Feed> T addFeed(T feed) {	Feed old = findApparentlyEqualAndWarnIfNotSameUniqueTag(feedsInternal, feed);	if (old != null) {	if (old == feed) {	if (!BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_FEED_REGISTRATION_PROPERTY)) {	
feed already added not adding a second time 

public <T extends Feed> T addFeed(T feed) {	Feed old = findApparentlyEqualAndWarnIfNotSameUniqueTag(feedsInternal, feed);	if (old != null) {	if (old == feed) {	if (!BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_FEED_REGISTRATION_PROPERTY)) {	}	return feed;	} else {	
removing when adding to 

========================= brooklyn sample_1254 =========================

private synchronized void initialize() {	if (allowedUsers != null) return;	StringConfigMap properties = mgmt.getConfig();	allowedUsers = new LinkedHashSet<String>();	String users = properties.getConfig(BrooklynWebConfig.USERS);	if (users == null) {	
rest has no users configured no one will be able to log in 

private synchronized void initialize() {	if (allowedUsers != null) return;	StringConfigMap properties = mgmt.getConfig();	allowedUsers = new LinkedHashSet<String>();	String users = properties.getConfig(BrooklynWebConfig.USERS);	if (users == null) {	} else if ("*".equals(users)) {	
rest allowing any user so long as valid password is set 

allowedUsers = new LinkedHashSet<String>();	String users = properties.getConfig(BrooklynWebConfig.USERS);	if (users == null) {	} else if ("*".equals(users)) {	allowAnyUserWithValidPass = true;	} else {	StringTokenizer t = new StringTokenizer(users, ",");	while (t.hasMoreElements()) {	allowedUsers.add(("" + t.nextElement()).trim());	}	
rest allowing users 

public boolean authenticate(HttpSession session, String user, String password) {	if (session==null || user==null) return false;	if (!allowAnyUserWithValidPass) {	if (!allowedUsers.contains(user)) {	
rest rejecting unknown user 

========================= brooklyn sample_2881 =========================

protected Optional<String> getData(ConfigKey<String> dataKey, ConfigKey<String> fileKey, ConfigBag config) {	String data = Strings.isNonBlank(config.get(dataKey)) ? config.get(dataKey).trim() : null;	String file = config.get(fileKey);	String fileData = Strings.isNonBlank(file) ? getFileContents(file).trim() : null;	if (Strings.isNonBlank(data) && Strings.isNonBlank(fileData)) {	if (data.equals(fileData)) {	
duplicate matching configuration for and continuing 

========================= brooklyn sample_2478 =========================

public void test_localhost() throws Exception {	final MonitNode monitNode = app.createAndManageChild(EntitySpec.create(MonitNode.class) .configure(MonitNode.CONTROL_FILE_URL, "classpath: app.start(ImmutableSet.of(loc));	
monit started 

SameServerEntity sameServerEntity = app.createAndManageChild(EntitySpec.create(SameServerEntity.class));	MySqlNode mySqlNode = sameServerEntity.addChild(EntitySpec.create(MySqlNode.class));	Function<String, Map<String, Object>> controlFileSubstitutionsFunction = new Function<String, Map<String, Object>>() {	public Map<String, Object> apply(String input) {	return ImmutableMap.<String, Object>of("targetPidFile", input);	}	};	EntitySpec<MonitNode> monitSpec = EntitySpec.create(MonitNode.class) .configure(MonitNode.CONTROL_FILE_URL, "classpath: .configure(MonitNode.CONTROL_FILE_SUBSTITUTIONS, DependentConfiguration.valueWhenAttributeReady(mySqlNode, SoftwareProcess.PID_FILE, controlFileSubstitutionsFunction));	final MonitNode monitNode = sameServerEntity.addChild(monitSpec);	app.start(ImmutableSet.of(loc));	
monit and mysql started 

}	};	EntitySpec<MonitNode> monitSpec = EntitySpec.create(MonitNode.class) .configure(MonitNode.CONTROL_FILE_URL, "classpath: .configure(MonitNode.CONTROL_FILE_SUBSTITUTIONS, DependentConfiguration.valueWhenAttributeReady(mySqlNode, SoftwareProcess.PID_FILE, controlFileSubstitutionsFunction));	final MonitNode monitNode = sameServerEntity.addChild(monitSpec);	app.start(ImmutableSet.of(loc));	EntityAsserts.assertAttributeEqualsEventually(monitNode, MonitNode.MONIT_TARGET_PROCESS_STATUS, "Running");	mySqlNode.stop();	Asserts.succeedsEventually(new Runnable() {	public void run() {	String targetStatus = monitNode.getAttribute(MonitNode.MONIT_TARGET_PROCESS_STATUS);	
monitnode target status 

final String mySqlVersion = MySqlNode.SUGGESTED_VERSION.getDefaultValue();	SameServerEntity sameServerEntity = app.createAndManageChild(EntitySpec.create(SameServerEntity.class));	final MySqlNode mySqlNode = sameServerEntity.addChild(EntitySpec.create(MySqlNode.class) .configure(MySqlNode.INSTALL_DIR, mySqlInstallDir) .configure(MySqlNode.RUN_DIR, mySqlRunDir) .configure(MySqlNode.DATA_DIR, mySqlDataDir));	Function<String, Map<String, Object>> controlFileSubstitutionsFunction = new Function<String, Map<String, Object>>() {	public Map<String, Object> apply(String input) {	return ImmutableMap.<String, Object>of( "targetPidFile", input, "mySqlInstallDir", mySqlInstallDir, "mySqlRunDir", mySqlRunDir, "mySqlVersion", mySqlVersion, "mySqlOsFlavor", osFlavor );	}	};	final MonitNode monitNode = sameServerEntity.addChild(EntitySpec.create(MonitNode.class) .configure(MonitNode.CONTROL_FILE_URL, "classpath: .configure(MonitNode.CONTROL_FILE_SUBSTITUTIONS, DependentConfiguration.valueWhenAttributeReady(mySqlNode, SoftwareProcess.PID_FILE, controlFileSubstitutionsFunction)));	app.start(ImmutableSet.of(loc));	
monit and mysql started 

public Map<String, Object> apply(String input) {	return ImmutableMap.<String, Object>of( "targetPidFile", input, "mySqlInstallDir", mySqlInstallDir, "mySqlRunDir", mySqlRunDir, "mySqlVersion", mySqlVersion, "mySqlOsFlavor", osFlavor );	}	};	final MonitNode monitNode = sameServerEntity.addChild(EntitySpec.create(MonitNode.class) .configure(MonitNode.CONTROL_FILE_URL, "classpath: .configure(MonitNode.CONTROL_FILE_SUBSTITUTIONS, DependentConfiguration.valueWhenAttributeReady(mySqlNode, SoftwareProcess.PID_FILE, controlFileSubstitutionsFunction)));	app.start(ImmutableSet.of(loc));	final String[] initialPid = {""};	Asserts.succeedsEventually(new Runnable() {	public void run() {	String targetStatus = monitNode.getAttribute(MonitNode.MONIT_TARGET_PROCESS_STATUS);	
monitnode target status 

};	final MonitNode monitNode = sameServerEntity.addChild(EntitySpec.create(MonitNode.class) .configure(MonitNode.CONTROL_FILE_URL, "classpath: .configure(MonitNode.CONTROL_FILE_SUBSTITUTIONS, DependentConfiguration.valueWhenAttributeReady(mySqlNode, SoftwareProcess.PID_FILE, controlFileSubstitutionsFunction)));	app.start(ImmutableSet.of(loc));	final String[] initialPid = {""};	Asserts.succeedsEventually(new Runnable() {	public void run() {	String targetStatus = monitNode.getAttribute(MonitNode.MONIT_TARGET_PROCESS_STATUS);	assertEquals(targetStatus, "Running");	try {	initialPid[0] = Files.readFirstLine(new File(mySqlNode.getAttribute(SoftwareProcess.PID_FILE)), Charset.defaultCharset());	
initial pid 

}	}	});	mySqlNode.stop();	EntityAsserts.assertAttributeEqualsEventually(monitNode, MonitNode.MONIT_TARGET_PROCESS_STATUS, "Running");	Asserts.succeedsEventually(new Runnable() {	public void run() {	try {	String pidFileLocation = mySqlNode.getAttribute(SoftwareProcess.PID_FILE);	String newPid = Files.readFirstLine(new File(pidFileLocation), Charset.defaultCharset());	
old pid new pid read from pid file 

Asserts.succeedsEventually(new Runnable() {	public void run() {	try {	String pidFileLocation = mySqlNode.getAttribute(SoftwareProcess.PID_FILE);	String newPid = Files.readFirstLine(new File(pidFileLocation), Charset.defaultCharset());	assertNotEquals(initialPid[0], newPid, "Process PID has not changed");	} catch (IOException e) {	Asserts.fail("Could not read PID file: " + e);	}	String targetStatus = monitNode.getAttribute(MonitNode.MONIT_TARGET_PROCESS_STATUS);	
monitnode target status 

========================= brooklyn sample_276 =========================

public LocationSpec<? extends Location> newLocationSpecFromString(String spec, Map<?, ?> locationFlags, LocationRegistry registry) {	String id = spec.substring(NAME.length()+1);	RegisteredType item = managementContext.getTypeRegistry().get(id);	if (item.isDisabled()) {	throw new IllegalStateException("Illegal use of disabled catalog item "+item.getSymbolicName()+":"+item.getVersion());	} else if (item.isDeprecated()) {	
use of deprecated catalog item 

========================= brooklyn sample_1311 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (v != null) {	String privateKeyFileName = v.toString();	String privateKey;	try {	privateKey = Files.toString(new File(Os.tidyPath(privateKeyFileName)), Charsets.UTF_8);	} catch (IOException e) {	
not found 

========================= brooklyn sample_2614 =========================

protected Optional<Task<?>> findTaskOrSubTask(Iterable<? extends Task<?>> tasks, Predicate<? super Task<?>> matcher) {	Optional<Task<?>> result = findTaskOrSubTaskImpl(tasks, matcher);	if (!result.isPresent() && LOG.isDebugEnabled()) {	
task not found matching 

========================= brooklyn sample_2244 =========================

throw new IllegalArgumentException("Invalid entity id '"+entityId.get()+"'");	}	}	try {	T entity = entityFactory.createEntity(spec, entityId);	Entity proxy = ((AbstractEntity)entity).getProxy();	checkNotNull(proxy, "proxy for entity %s, spec %s", entity, spec);	manage(entity);	return (T) proxy;	} catch (Throwable e) {	
failed to create entity using spec rethrowing 

public <T extends Policy> T createPolicy(PolicySpec<T> spec) {	try {	return policyFactory.createPolicy(spec);	} catch (Throwable e) {	
failed to create policy using spec rethrowing 

public <T extends Enricher> T createEnricher(EnricherSpec<T> spec) {	try {	return policyFactory.createEnricher(spec);	} catch (Throwable e) {	
failed to create enricher using spec rethrowing 

public void manage(Entity e) {	if (isManaged(e)) {	
redundant call to start management of entity and descendants of skipping source of duplicate management of 

checkManagementAllowed(e);	final List<EntityInternal> allEntities = Lists.newArrayList();	Predicate<EntityInternal> manageEntity = new Predicate<EntityInternal>() { @Override public boolean apply(EntityInternal it) {	ManagementTransitionMode mode = getLastManagementTransitionMode(it.getId());	if (mode==null) {	setManagementTransitionMode(it, mode = initialMode);	}	Boolean isReadOnlyFromEntity = it.getManagementSupport().isReadOnlyRaw();	if (isReadOnlyFromEntity==null) {	if (mode.isReadOnly()) {	
read only entity not marked as such on call to manage marking and continuing 

if (mode==null) {	setManagementTransitionMode(it, mode = initialMode);	}	Boolean isReadOnlyFromEntity = it.getManagementSupport().isReadOnlyRaw();	if (isReadOnlyFromEntity==null) {	if (mode.isReadOnly()) {	}	it.getManagementSupport().setReadOnly(mode.isReadOnly());	} else {	if (!isReadOnlyFromEntity.equals(mode.isReadOnly())) {	
read only status at entity not consistent with management mode 

if (!isReadOnlyFromEntity.equals(mode.isReadOnly())) {	}	}	if (it.getManagementSupport().isDeployed()) {	if (mode.wasNotLoaded()) {	return false;	} else {	if (mode.wasPrimary() && mode.isPrimary()) {	} else if (mode.wasReadOnly() && mode.isReadOnly()) {	} else {	
already deployed when managing ignoring this and all descendants 

}	allEntities.add(it);	preManageNonRecursive(it, mode);	it.getManagementSupport().onManagementStarting( new ManagementTransitionInfo(managementContext, mode) );	return manageNonRecursive(it, mode);	} };	boolean isRecursive = true;	if (initialMode.wasPrimary() && initialMode.isPrimary()) {	Entity aChild = Iterables.getFirst(e.getChildren(), null);	if (aChild!=null && isPreRegistered(aChild)) {	
managing in mode doing this recursively because a child is preregistered 

allEntities.add(it);	preManageNonRecursive(it, mode);	it.getManagementSupport().onManagementStarting( new ManagementTransitionInfo(managementContext, mode) );	return manageNonRecursive(it, mode);	} };	boolean isRecursive = true;	if (initialMode.wasPrimary() && initialMode.isPrimary()) {	Entity aChild = Iterables.getFirst(e.getChildren(), null);	if (aChild!=null && isPreRegistered(aChild)) {	} else {	
managing but skipping recursion as mode is 

private void unmanage(final Entity e, ManagementTransitionMode mode, boolean hasBeenReplaced) {	if (shouldSkipUnmanagement(e)) return;	final ManagementTransitionInfo info = new ManagementTransitionInfo(managementContext, mode);	if (hasBeenReplaced) {	if (mode.wasReadOnly()) {	} else {	if (!mode.wasPrimary()) {	
unexpected mode for unmanage replace applying anyway 

if (shouldSkipUnmanagement(it)) continue;	unmanageNonRecursive(it);	stopTasks(it);	}	for (EntityInternal it : allEntities) {	it.getManagementSupport().onManagementStopped(info);	managementContext.getRebindManager().getChangeListener().onUnmanaged(it);	if (managementContext.getGarbageCollector() != null) managementContext.getGarbageCollector().onUnmanaged(e);	}	} else {	
invalid mode for unmanage on ignoring 

CountdownTimer timeleft = timeout==null ? null : timeout.countdownTimer();	Collection<Exception> exceptions = MutableSet.of();	try {	Set<Task<?>> tasksCancelled = MutableSet.of();	for (Task<?> t: managementContext.getExecutionContext(entity).getTasks()) {	if (entity.equals(BrooklynTaskTags.getContextEntity(Tasks.current())) && hasTaskAsAncestor(t, Tasks.current())) {	continue;	}	if (!t.isDone()) {	try {	
cancelling on 

for (Task<?> t: managementContext.getExecutionContext(entity).getTasks()) {	if (entity.equals(BrooklynTaskTags.getContextEntity(Tasks.current())) && hasTaskAsAncestor(t, Tasks.current())) {	continue;	}	if (!t.isDone()) {	try {	tasksCancelled.add(t);	t.cancel(true);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error cancelling on will warn when all tasks are cancelled 

}	if (timeleft!=null) {	Set<Task<?>> tasksIncomplete = MutableSet.of();	for (Task<?> t: managementContext.getExecutionContext(entity).getTasks()) {	if (hasTaskAsAncestor(t, Tasks.current())) continue;	if (!Tasks.blockUntilInternalTasksEnded(t, timeleft.getDurationRemaining())) {	tasksIncomplete.add(t);	}	}	if (!tasksIncomplete.isEmpty()) {	
incomplete tasks when stopping 

if (timeleft!=null) {	Set<Task<?>> tasksIncomplete = MutableSet.of();	for (Task<?> t: managementContext.getExecutionContext(entity).getTasks()) {	if (hasTaskAsAncestor(t, Tasks.current())) continue;	if (!Tasks.blockUntilInternalTasksEnded(t, timeleft.getDurationRemaining())) {	tasksIncomplete.add(t);	}	}	if (!tasksIncomplete.isEmpty()) {	}	
cancelled tasks for with remaining of 

Set<Task<?>> tasksIncomplete = MutableSet.of();	for (Task<?> t: managementContext.getExecutionContext(entity).getTasks()) {	if (hasTaskAsAncestor(t, Tasks.current())) continue;	if (!Tasks.blockUntilInternalTasksEnded(t, timeleft.getDurationRemaining())) {	tasksIncomplete.add(t);	}	}	if (!tasksIncomplete.isEmpty()) {	}	} else {	
cancelled tasks for 

if (!Tasks.blockUntilInternalTasksEnded(t, timeleft.getDurationRemaining())) {	tasksIncomplete.add(t);	}	}	if (!tasksIncomplete.isEmpty()) {	}	} else {	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error inspecting tasks to cancel on unmanagement 

tasksIncomplete.add(t);	}	}	if (!tasksIncomplete.isEmpty()) {	}	} else {	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	}	
error when cancelling tasks for on unmanagement 

private synchronized boolean preManageNonRecursive(Entity e, ManagementTransitionMode mode) {	Entity realE = toRealEntity(e);	Object old = preManagedEntitiesById.put(e.getId(), realE);	preRegisteredEntitiesById.remove(e.getId());	if (old!=null && mode.wasNotLoaded()) {	if (old.equals(e)) {	
redundant call to pre start management of entity mode ignoring 

Entity realE = toRealEntity(e);	Object old = preManagedEntitiesById.put(e.getId(), realE);	preRegisteredEntitiesById.remove(e.getId());	if (old!=null && mode.wasNotLoaded()) {	if (old.equals(e)) {	} else {	throw new IllegalStateException("call to pre-manage entity "+e+" ("+mode+") but different entity "+old+" already known under that id at "+this);	}	return false;	} else {	
pre start management of entity mode 

private synchronized boolean manageNonRecursive(Entity e, ManagementTransitionMode mode) {	Entity old = entitiesById.get(e.getId());	if (old!=null && mode.wasNotLoaded()) {	if (old == deproxyIfNecessary(e)) {	
redundant call to start management of entity ignoring 

for (Group group : e.groups()) {	if (!Entities.isNoLongerManaged(group)) group.removeMember(e);	}	if (e instanceof Group) {	Collection<Entity> members = ((Group)e).getMembers();	for (Entity member : members) {	if (!Entities.isNoLongerManaged(member)) ((EntityInternal)member).groups().remove((Group)e);	}	}	} else {	
no relations being updated on unmanage of read only 

if (e instanceof Application) {	applications.remove(proxyE);	applicationIds.remove(e.getId());	}	entities.remove(proxyE);	entityProxiesById.remove(e.getId());	entityModesById.remove(e.getId());	Object old = entitiesById.remove(e.getId());	entityTypes.remove(e.getId());	if (old==null) {	
call to stop management of unknown entity already unmanaged ignoring 

applicationIds.remove(e.getId());	}	entities.remove(proxyE);	entityProxiesById.remove(e.getId());	entityModesById.remove(e.getId());	Object old = entitiesById.remove(e.getId());	entityTypes.remove(e.getId());	if (old==null) {	return false;	} else if (!old.equals(e)) {	
call to stop management of entity removed different entity 

entities.remove(proxyE);	entityProxiesById.remove(e.getId());	entityModesById.remove(e.getId());	Object old = entitiesById.remove(e.getId());	entityTypes.remove(e.getId());	if (old==null) {	return false;	} else if (!old.equals(e)) {	return true;	} else {	
stopped management of entity 

private void unmanageOwnedLocations(Entity e) {	for (Location loc : e.getLocations()) {	NamedStringTag ownerEntityTag = BrooklynTags.findFirst(BrooklynTags.OWNER_ENTITY_ID, loc.tags().getTags());	if (ownerEntityTag != null) {	if (e.getId().equals(ownerEntityTag.getContents())) {	managementContext.getLocationManager().unmanage(loc);	} else {	
unmanaging entity which contains a location owned by another entity not automatically unmanaging the location it will be unmanaged when its owning entity is unmanaged 

private boolean shouldSkipUnmanagement(Entity e) {	if (e==null) {	
call to unmanage null entity skipping source of null unmanagement call to 

private boolean shouldSkipUnmanagement(Entity e) {	if (e==null) {	return true;	}	if (!isManaged(e)) {	
call to stop management of unknown entity already unmanaged skipping and all descendants 

========================= brooklyn sample_1038 =========================

private Iterable<ConfigKey<?>> validateAll() {	List<ConfigKey<?>> violating = Lists.newLinkedList();	Iterable<ConfigKey<?>> configKeys = getBrooklynObjectTypeConfigKeys();	
checking config keys on 

========================= brooklyn sample_1192 =========================

public void testScheduledTask() throws Exception {	int PERIOD = 20;	BasicExecutionManager m = new BasicExecutionManager("mycontextid");	final AtomicInteger i = new AtomicInteger(0);	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", 2*PERIOD, "period", PERIOD, "maxIterations", 5), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	
task running 

int PERIOD = 20;	BasicExecutionManager m = new BasicExecutionManager("mycontextid");	final AtomicInteger i = new AtomicInteger(0);	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", 2*PERIOD, "period", PERIOD, "maxIterations", 5), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	return i.incrementAndGet();	}});	}});	
submitting 

BasicExecutionManager m = new BasicExecutionManager("mycontextid");	final AtomicInteger i = new AtomicInteger(0);	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", 2*PERIOD, "period", PERIOD, "maxIterations", 5), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	return i.incrementAndGet();	}});	}});	m.submit(t);	
submitted 

final AtomicInteger i = new AtomicInteger(0);	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", 2*PERIOD, "period", PERIOD, "maxIterations", 5), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	return i.incrementAndGet();	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	
done one 

return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	return i.incrementAndGet();	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	assertTrue(i.get() > 0, "i="+i);	t.blockUntilEnded();	Integer finalResult = (Integer) t.get();	
ended 

public void testScheduledTaskSelfEnding() throws Exception {	int PERIOD = 20;	BasicExecutionManager m = new BasicExecutionManager("mycontextid");	final AtomicInteger i = new AtomicInteger(0);	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", 2*PERIOD, "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	if (i.get() >= 4) submitter.period = null;	
task running 

final AtomicInteger i = new AtomicInteger(0);	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", 2*PERIOD, "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	if (i.get() >= 4) submitter.period = null;	return i.incrementAndGet();	}});	}});	
submitting 

ScheduledTask t = new ScheduledTask(MutableMap.of("delay", 2*PERIOD, "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	if (i.get() >= 4) submitter.period = null;	return i.incrementAndGet();	}});	}});	m.submit(t);	
submitted 

public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	if (i.get() >= 4) submitter.period = null;	return i.incrementAndGet();	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	
done one 

ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	if (i.get() >= 4) submitter.period = null;	return i.incrementAndGet();	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	assertTrue(i.get() > 0);	t.blockUntilEnded();	Integer finalResult = (Integer) t.get();	
ended 

public void testScheduledTaskCancelEnding() throws Exception {	Duration PERIOD = Duration.millis(20);	BasicExecutionManager m = new BasicExecutionManager("mycontextid");	final AtomicInteger i = new AtomicInteger();	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", PERIOD.times(2), "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	
task running 

ScheduledTask t = new ScheduledTask(MutableMap.of("delay", PERIOD.times(2), "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	i.incrementAndGet();	if (i.get() >= 5) submitter.cancel();	return i.get();	}});	}});	
submitting 

public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	i.incrementAndGet();	if (i.get() >= 5) submitter.cancel();	return i.get();	}});	}});	m.submit(t);	
submitted 

return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	i.incrementAndGet();	if (i.get() >= 5) submitter.cancel();	return i.get();	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	
done one 

ScheduledTask submitter = (ScheduledTask) ((BasicTask)Tasks.current()).getSubmittedByTask();	i.incrementAndGet();	if (i.get() >= 5) submitter.cancel();	return i.get();	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	assertTrue(i.get() > 0);	t.blockUntilEnded();	
ended 

public void testScheduledTaskCancelOuter() throws Exception {	final Duration PERIOD = Duration.millis(20);	final Duration CYCLE_DELAY = Duration.ONE_SECOND;	final Duration SMALL_FRACTION_OF_CYCLE_DELAY = PERIOD.add(CYCLE_DELAY.multiply(0.1));	BasicExecutionManager m = new BasicExecutionManager("mycontextid");	final AtomicInteger i = new AtomicInteger();	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", PERIOD.times(2), "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	
task running 

final AtomicInteger i = new AtomicInteger();	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", PERIOD.times(2), "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	Time.sleep(CYCLE_DELAY);	i.incrementAndGet();	return i.get();	}});	}});	
submitting 

ScheduledTask t = new ScheduledTask(MutableMap.of("delay", PERIOD.times(2), "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	Time.sleep(CYCLE_DELAY);	i.incrementAndGet();	return i.get();	}});	}});	m.submit(t);	
submitted 

public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	Time.sleep(CYCLE_DELAY);	i.incrementAndGet();	return i.get();	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	
done one 

}});	m.submit(t);	Integer interimResult = (Integer) t.get();	assertEquals(i.get(), 1);	Time.sleep(SMALL_FRACTION_OF_CYCLE_DELAY);	assertEquals(t.get(), 2);	Time.sleep(SMALL_FRACTION_OF_CYCLE_DELAY);	Stopwatch timer = Stopwatch.createUnstarted();	t.cancel(true);	t.blockUntilEnded();	
blocked until ended in 

Time.sleep(SMALL_FRACTION_OF_CYCLE_DELAY);	Stopwatch timer = Stopwatch.createUnstarted();	t.cancel(true);	t.blockUntilEnded();	try {	t.get();	Assert.fail("Should have failed getting result of cancelled "+t);	} catch (Exception e) {	}	assertEquals(i.get(), 2);	
ended in 

final Duration CYCLE_DELAY = Duration.ONE_SECOND;	final Duration SMALL_FRACTION_OF_CYCLE_DELAY = PERIOD.add(CYCLE_DELAY.multiply(0.1));	BasicExecutionManager m = new BasicExecutionManager("mycontextid");	final Semaphore interruptedSemaphore = new Semaphore(0);	final AtomicInteger i = new AtomicInteger();	ScheduledTask t = new ScheduledTask(MutableMap.of("delay", PERIOD.times(2), "period", PERIOD), new Callable<Task<?>>() {	public Task<?> call() throws Exception {	return new BasicTask<Integer>(new Callable<Integer>() {	public Integer call() {	try {	
task running 

try {	Time.sleep(CYCLE_DELAY);	i.incrementAndGet();	return i.get();	} catch (RuntimeInterruptedException e) {	interruptedSemaphore.release();	throw Exceptions.propagate(e);	}	}});	}});	
submitting 

Time.sleep(CYCLE_DELAY);	i.incrementAndGet();	return i.get();	} catch (RuntimeInterruptedException e) {	interruptedSemaphore.release();	throw Exceptions.propagate(e);	}	}});	}});	m.submit(t);	
submitted 

i.incrementAndGet();	return i.get();	} catch (RuntimeInterruptedException e) {	interruptedSemaphore.release();	throw Exceptions.propagate(e);	}	}});	}});	m.submit(t);	Integer interimResult = (Integer) t.get();	
done one 

}});	m.submit(t);	Integer interimResult = (Integer) t.get();	assertEquals(i.get(), 1);	Time.sleep(SMALL_FRACTION_OF_CYCLE_DELAY);	assertEquals(t.get(), 2);	Time.sleep(SMALL_FRACTION_OF_CYCLE_DELAY);	Stopwatch timer = Stopwatch.createUnstarted();	t.cancel(true);	t.blockUntilEnded();	
blocked until ended in 

Stopwatch timer = Stopwatch.createUnstarted();	t.cancel(true);	t.blockUntilEnded();	try {	t.get();	Assert.fail("Should have failed getting result of cancelled "+t);	} catch (Exception e) {	}	assertEquals(i.get(), 2);	Assert.assertTrue(interruptedSemaphore.tryAcquire(1, SMALL_FRACTION_OF_CYCLE_DELAY.toMilliseconds(), TimeUnit.MILLISECONDS), "child thread was not interrupted");	
ended in 

========================= brooklyn sample_919 =========================

public void customize(JcloudsLocation location, ComputeService computeService, JcloudsMachineLocation machine) {	Object callerContext = machine.getConfig(CloudLocationConfig.CALLER_CONTEXT);	Entity entity;	if (callerContext instanceof Entity) {	entity = (Entity)callerContext;	} else {	throw new IllegalArgumentException("customizer should be called on against a jcloudsLocation which has callerContext of type Entity. Location " + location);	}	TaskAdaptable<Iterable<IpPermission>> taskAdaptable = Effectors.invocation(entity, NetworkingEffectors.OPEN_INBOUND_PORTS_IN_SECURITY_GROUP_EFFECTOR, MutableMap.<Object, Object>of(INBOUND_PORTS_LIST, inboundPortsList, INBOUND_PORTS_LIST_PROTOCOL, inboundPortsListProtocol, JCLOUDS_MACHINE_LOCATIN, machine));	Iterable<IpPermission> result = DynamicTasks.submit(taskAdaptable.asTask(), entity).getUnchecked();	
opened ports for 

========================= brooklyn sample_2585 =========================

private static <T> T _register(T element, Hint<?> hintForThatElement) {	if (element==null) {	
invalid null target for renderer hint trace for invalid null target for renderer hint 

private static Object _applyDisplayValueHint(Object target, Object initialValue, boolean includeClass) {	Iterable<RendererHints.DisplayValue> hints = RendererHints._getHintsFor(target, RendererHints.DisplayValue.class);	if (Iterables.size(hints) > 1) {	
multiple display value hints set for only one will be applied using first 

========================= brooklyn sample_1203 =========================

public void testAddLegacyLocationDefinition() {	Map<String, String> expectedConfig = ImmutableMap.of( "identity", "bob", "credential", "CR3dential");	Response response = client().path("/locations") .type(MediaType.APPLICATION_JSON_TYPE) .post(new org.apache.brooklyn.rest.domain.LocationSpec(legacyLocationName, "aws-ec2:us-east-1", expectedConfig));	URI addedLegacyLocationUri = response.getLocation();	
added legacy at 

public void testAddLegacyLocationDefinition() {	Map<String, String> expectedConfig = ImmutableMap.of( "identity", "bob", "credential", "CR3dential");	Response response = client().path("/locations") .type(MediaType.APPLICATION_JSON_TYPE) .post(new org.apache.brooklyn.rest.domain.LocationSpec(legacyLocationName, "aws-ec2:us-east-1", expectedConfig));	URI addedLegacyLocationUri = response.getLocation();	LocationSummary location = client().path(response.getLocation()).get(LocationSummary.class);	
contents 

public void testAddNewLocationDefinition() {	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  symbolicName: "+locationName, "  version: " + locationVersion, "  itemType: location", "  item:", "    type: "+"aws-ec2:us-east-1", "    brooklyn.config:", "      identity: bob", "      credential: CR3dential"));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	
added at 

public void testAddNewLocationDefinition() {	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  symbolicName: "+locationName, "  version: " + locationVersion, "  itemType: location", "  item:", "    type: "+"aws-ec2:us-east-1", "    brooklyn.config:", "      identity: bob", "      credential: CR3dential"));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+locationName + "/" + locationVersion) .get(CatalogLocationSummary.class);	
item 

public void testAddNewLocationDefinition() {	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  symbolicName: "+locationName, "  version: " + locationVersion, "  itemType: location", "  item:", "    type: "+"aws-ec2:us-east-1", "    brooklyn.config:", "      identity: bob", "      credential: CR3dential"));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+locationName + "/" + locationVersion) .get(CatalogLocationSummary.class);	LocationSummary locationSummary = client().path(URI.create("/locations/"+locationName+"/")).get(LocationSummary.class);	
summary 

public void testDisplayNameInConfig() {	String symbolicName = "test_config_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")", "      brooklyn.config:", "        displayName: " + configDisplayName));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	
added at 

public void testDisplayNameInConfig() {	String symbolicName = "test_config_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")", "      brooklyn.config:", "        displayName: " + configDisplayName));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+symbolicName + "/" + locationVersion) .get(CatalogLocationSummary.class);	
item 

public void testDisplayNameInConfig() {	String symbolicName = "test_config_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")", "      brooklyn.config:", "        displayName: " + configDisplayName));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+symbolicName + "/" + locationVersion) .get(CatalogLocationSummary.class);	LocationSummary locationSummary = client().path(URI.create("/locations/"+symbolicName+"/")).get(LocationSummary.class);	
summary 

public void testDisplayNameInItems() {	String symbolicName = "test_items_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    displayName: " + testsDisplayName, "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")"));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	
added at 

public void testDisplayNameInItems() {	String symbolicName = "test_items_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    displayName: " + testsDisplayName, "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")"));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+symbolicName + "/" + locationVersion) .get(CatalogLocationSummary.class);	
item 

public void testDisplayNameInItems() {	String symbolicName = "test_items_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    displayName: " + testsDisplayName, "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")"));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+symbolicName + "/" + locationVersion) .get(CatalogLocationSummary.class);	LocationSummary locationSummary = client().path(URI.create("/locations/"+symbolicName+"/")).get(LocationSummary.class);	
summary 

public void testDisplayNameInConfigOverridesItems() {	String symbolicName = "test_config_overrides_items_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    displayName: " + testsDisplayName, "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")", "      brooklyn.config:", "        displayName: " + configDisplayName));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	
added at 

public void testDisplayNameInConfigOverridesItems() {	String symbolicName = "test_config_overrides_items_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    displayName: " + testsDisplayName, "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")", "      brooklyn.config:", "        displayName: " + configDisplayName));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+symbolicName + "/" + locationVersion) .get(CatalogLocationSummary.class);	
item 

public void testDisplayNameInConfigOverridesItems() {	String symbolicName = "test_config_overrides_items_displayName_id";	String yaml = Joiner.on("\n").join(ImmutableList.of( "brooklyn.catalog:", "  version: " + locationVersion, "  items:", "  - id: " + symbolicName, "    itemType: location", "    displayName: " + testsDisplayName, "    item:", "      type: byon:(hosts=\"" + byonHostname + "\")", "      brooklyn.config:", "        displayName: " + configDisplayName));	Response response = client().path("/catalog") .post(yaml);	assertEquals(response.getStatus(), Response.Status.CREATED.getStatusCode());	URI addedCatalogItemUri = response.getLocation();	CatalogLocationSummary locationItem = client().path("/catalog/locations/"+symbolicName + "/" + locationVersion) .get(CatalogLocationSummary.class);	LocationSummary locationSummary = client().path(URI.create("/locations/"+symbolicName+"/")).get(LocationSummary.class);	
summary 

========================= brooklyn sample_2839 =========================

public void connectSensors() {	super.connectSensors();	if (getDriver().isJmxEnabled()) {	String requestProcessorMbeanName = "Catalina:type=GlobalRequestProcessor,name=\"http-*\"";	Integer port = isHttpsEnabled() ? getAttribute(HTTPS_PORT) : getAttribute(HTTP_PORT);	String connectorMbeanName = format("Catalina:type=Connector,port=%s", port);	boolean retrieveUsageMetrics = getConfig(RETRIEVE_USAGE_METRICS);	jmxWebFeed = JmxFeed.builder() .entity(this) .period(3000, TimeUnit.MILLISECONDS) .pollAttribute(new JmxAttributePollConfig<Boolean>(SERVICE_PROCESS_IS_RUNNING) .objectName(connectorMbeanName) .attributeName("stateName") .onSuccess(Functions.forPredicate(Predicates.<Object>equalTo("STARTED"))) .setOnFailureOrException(false) .suppressDuplicates(true)) .pollAttribute(new JmxAttributePollConfig<String>(CONNECTOR_STATUS) .objectName(connectorMbeanName) .attributeName("stateName") .suppressDuplicates(true)) .pollAttribute(new JmxAttributePollConfig<Integer>(ERROR_COUNT) .objectName(requestProcessorMbeanName) .attributeName("errorCount") .enabled(retrieveUsageMetrics)) .pollAttribute(new JmxAttributePollConfig<Integer>(REQUEST_COUNT) .objectName(requestProcessorMbeanName) .attributeName("requestCount") .enabled(retrieveUsageMetrics) .onFailureOrException(EntityFunctions.attribute(this, REQUEST_COUNT))) .pollAttribute(new JmxAttributePollConfig<Integer>(TOTAL_PROCESSING_TIME) .objectName(requestProcessorMbeanName) .attributeName("processingTime") .enabled(retrieveUsageMetrics)) .build();	jmxAppFeed = JavaAppUtils.connectMXBeanSensors(this);	} else {	
tomcat running without jmx monitoring limited visibility of service available 

========================= brooklyn sample_221 =========================

public void onEvent(SensorEvent<Object> event) {	
received event 

========================= brooklyn sample_3052 =========================

public void testVanillaSoftwareYaml() {	SimpleYamlLauncher l = new SimpleYamlLauncherForTests();	try {	Application app = l.launchAppYaml("vanilla-software-blueprint.yaml");	
started 

app.invoke(Startable.STOP, null).getUnchecked();	Asserts.succeedsEventually(new Runnable() {	public void run() {	String fileContents = new ResourceUtils(this).getResourceAsString(filePath);	Assert.assertTrue(fileContents.contains("stop"));	}	});	} finally {	l.destroyAll();	}	
DONE 

public void testVanillaSoftwareYamlWithChildStartedAfter() {	SimpleYamlLauncher l = new SimpleYamlLauncherForTests();	try {	Application app = l.launchAppYaml("vanilla-software-with-child-blueprint.yaml");	
started 

try {	Application app = l.launchAppYaml("vanilla-software-with-child-blueprint.yaml");	Entity p1 = Iterables.getOnlyElement( app.getChildren() );	Long d1 = Long.parseLong( Strings.getFirstWordAfter(new ResourceUtils(this).getResourceAsString(Os.mergePaths(p1.getAttribute(SoftwareProcess.RUN_DIR), "DATE")), "utc") );	Entity p2 = Iterables.getOnlyElement( p1.getChildren() );	Long d2 = Long.parseLong( Strings.getFirstWordAfter(new ResourceUtils(this).getResourceAsString(Os.mergePaths(p2.getAttribute(SoftwareProcess.RUN_DIR), "DATE")), "utc") );	Assert.assertTrue( d2-d1 > 2 && d2-d1 < 10, "p2 should have started 3s after parent, but it did not ("+(d2-d1)+"s difference" );	} finally {	l.destroyAll();	}	
DONE 

========================= brooklyn sample_558 =========================

public void customize(JcloudsLocation location, ComputeService computeService, JcloudsMachineLocation machine) {	EntitySpec<?> spec = config().get(CHILD_ENTITY_SPEC);	Boolean create = config().get(CREATE_CHILD_ENTITY);	Duration timeout = config().get(BrooklynConfigKeys.START_TIMEOUT);	Entity parent = getCallerContext(machine);	if (Boolean.TRUE.equals(create) && spec != null) {	
creating child entity for in 

========================= brooklyn sample_2643 =========================

public void testNonRunningPidRequired() {	ProcessTaskWrapper<?> t = submit(SshEffectorTasks.requirePidRunning(99999));	setExpectingFailure();	try {	t.getTask().getUnchecked();	} catch (Exception e) {	
the error if required pid is not found is 

public void testRequirePidFromFileOnFailure() throws IOException {	File f = File.createTempFile("testBrooklynPid", ".pid");	Files.write( "99999".getBytes(), f );	ProcessTaskWrapper<?> t = submit(SshEffectorTasks.requirePidFromFileRunning(f.getPath()));	setExpectingFailure();	try {	t.getTask().getUnchecked();	} catch (Exception e) {	
the error if required pid is not found is 

public void testRequirePidFromFileOnFailureNoSuchFile() throws IOException {	ProcessTaskWrapper<?> t = submit(SshEffectorTasks.requirePidFromFileRunning("/path/does/not/exist/SADVQW"));	setExpectingFailure();	try {	t.getTask().getUnchecked();	} catch (Exception e) {	
the error if required pid is not found is 

public void testRequirePidFromFileOnFailureTooManyFiles() throws IOException {	ProcessTaskWrapper<?> t = submit(SshEffectorTasks.requirePidFromFileRunning("/*"));	setExpectingFailure();	try {	t.getTask().getUnchecked();	} catch (Exception e) {	
the error if required pid is not found is 

========================= brooklyn sample_695 =========================

public <T> T setAttribute(AttributeSensor<T> attribute, T val) {	
mocks container setting to 

public void addItem(Entity item) {	
mocks adding item to container 

public void removeItem(Entity item) {	
mocks removing item from container 

public void start(Collection<? extends Location> locs) {	
mocks starting container 

public void stop() {	
mocks stopping container 

public void offloadAndStop(final MockContainerEntity otherContainer) {	
mocks offloading container to items 

public void offloadAndStop(final MockContainerEntity otherContainer) {	runWithLock(ImmutableList.of(this, otherContainer), new Runnable() {	public void run() {	offloading = false;	for (Movable item : getBalanceableItems()) {	((MockItemEntity)item).moveNonEffector(otherContainer);	}	
mocks stopping offloaded container 

public void restart() {	
mocks restarting 

========================= brooklyn sample_2998 =========================

String port = matcher.group(4).trim();	assertEquals(newUsername, username);	assertEquals(hostname, machine.getAddress().getHostName());	assertEquals(port, ""+machine.getPort());	SshMachineLocation machine2 = mgmt.getLocationManager().createLocation(LocationSpec.create(SshMachineLocation.class) .configure(SshTool.PROP_USER, newUsername) .configure(SshMachineLocation.PASSWORD, password) .configure("address", hostname) .configure(SshMachineLocation.SSH_PORT, Integer.parseInt(port)));	LOG.info("Checking ssh'able for auto-generated user: machine="+machine+"; creds="+creds);	assertTrue(machine2.isSshable(), "machine="+machine+"; creds="+creds);	} catch (Exception e) {	throw e;	} finally {	
deleting auto generated user 

========================= brooklyn sample_2561 =========================

} finally {	call.cancel(true);	}	boolean done = false;	try {	lastError = null;	done = exitCondition.call();	hasLoggedTransientException = false;	} catch (Throwable e) {	if (hasLoggedTransientException) {	
repeated failure excluding stacktrace 

} catch (Throwable e) {	if (hasLoggedTransientException) {	} else {	log.debug(description, e);	hasLoggedTransientException = true;	}	lastError = e;	if (rethrowImmediatelyCondition.apply(e)) throw Exceptions.propagate(e);	}	if (done) {	
condition satisfied 

if (log.isDebugEnabled()) {	String msg = String.format("%s: unsatisfied during iteration %s %s", description, iterations, (iterationLimit > 0 ? "(max "+iterationLimit+" attempts)" : "") + (timer.isNotPaused() ? "("+Time.makeTimeStringRounded(timer.getDurationRemaining())+" remaining)" : ""));	if (iterations == 1) {	log.debug(msg);	} else {	log.trace(msg);	}	}	}	if (iterationLimit > 0 && iterations >= iterationLimit) {	
condition not satisfied and exceeded iteration limit 

String msg = String.format("%s: unsatisfied during iteration %s %s", description, iterations, (iterationLimit > 0 ? "(max "+iterationLimit+" attempts)" : "") + (timer.isNotPaused() ? "("+Time.makeTimeStringRounded(timer.getDurationRemaining())+" remaining)" : ""));	if (iterations == 1) {	log.debug(msg);	} else {	log.trace(msg);	}	}	}	if (iterationLimit > 0 && iterations >= iterationLimit) {	if (rethrowException && lastError != null) {	
error caught checking condition rethrowing 

}	}	if (iterationLimit > 0 && iterations >= iterationLimit) {	if (rethrowException && lastError != null) {	throw Exceptions.propagate(lastError);	}	if (warnOnUnRethrownException && lastError != null) log.warn("{}: error caught checking condition: {}", description, lastError.getMessage());	return ReferenceWithError.newInstanceMaskingError(false, lastError);	}	if (timer.isExpired()) {	
condition not satisfied with elapsed limit 

}	if (iterationLimit > 0 && iterations >= iterationLimit) {	if (rethrowException && lastError != null) {	throw Exceptions.propagate(lastError);	}	if (warnOnUnRethrownException && lastError != null) log.warn("{}: error caught checking condition: {}", description, lastError.getMessage());	return ReferenceWithError.newInstanceMaskingError(false, lastError);	}	if (timer.isExpired()) {	if (rethrowException && lastError != null) {	
error caught checking condition 

========================= brooklyn sample_1967 =========================

protected Entity createMysql() {	Entity mysql = app.createAndManageChild(DynamicToyMySqlEntityBuilder.spec());	
created 

========================= brooklyn sample_2218 =========================

public static CompoundTransformer load(String contents) {	CompoundTransformer.Builder builder = CompoundTransformer.builder();	Iterable<Object> toplevel = Yamls.parseAll(contents);	Collection<?> rules = (Collection<?>)Iterables.getOnlyElement(toplevel);	for (Object obj : rules) {	Map<?, ?> map = (Map<?, ?>)obj;	Entry<?, ?> entry = Iterables.getOnlyElement(map.entrySet());	addRule(builder, (String)entry.getKey(), (Map<?, ?>)entry.getValue());	}	
loaded transforms 

========================= brooklyn sample_1121 =========================

public void stop() {	
invoking stop method on 

public void restart() {	
invoking restart method on 

========================= brooklyn sample_1571 =========================

break;	}	}	if (differingKeys.isEmpty()) same = true;	}	if (cmd.commands.containsAll(expectedCmds) && same) {	return;	}	}	for (ExecCmd cmd : RecordingSshTool.execScriptCmds) {	
command 

break;	}	}	if (differingKeys.isEmpty()) same = true;	}	if (cmd.commands.containsAll(expectedCmds) && same) {	return;	}	}	for (ExecCmd cmd : RecordingSshTool.execScriptCmds) {	
tenv 

if (differingKeys.isEmpty()) same = true;	}	if (cmd.commands.containsAll(expectedCmds) && same) {	return;	}	}	for (ExecCmd cmd : RecordingSshTool.execScriptCmds) {	for (Map.Entry<?,?> entry : cmd.env.entrySet()) {	log.info("\t\t"+entry.getKey()+" = "+entry.getValue());	}	
tcmds 

}	if (cmd.commands.containsAll(expectedCmds) && same) {	return;	}	}	for (ExecCmd cmd : RecordingSshTool.execScriptCmds) {	for (Map.Entry<?,?> entry : cmd.env.entrySet()) {	log.info("\t\t"+entry.getKey()+" = "+entry.getValue());	}	for (String c : cmd.commands) {	
t t 

for (ExecCmd cmd : RecordingSshTool.execScriptCmds) {	String biggun = ""+cmd.env+" "+cmd.commands;	Iterator<String> pi = phrases.iterator();	while (pi.hasNext()) {	String phrase = pi.next();	if (biggun.contains(phrase)) pi.remove();	}	if (forbiddenPhrases!=null) for (String p: forbiddenPhrases) if (biggun.contains(p)) forbiddenPhrasesFound.add(p);	}	if (!phrases.isEmpty()) {	
missing phrases in commands commands 

while (pi.hasNext()) {	String phrase = pi.next();	if (biggun.contains(phrase)) pi.remove();	}	if (forbiddenPhrases!=null) for (String p: forbiddenPhrases) if (biggun.contains(p)) forbiddenPhrasesFound.add(p);	}	if (!phrases.isEmpty()) {	fail("Missing phrases in commands: "+phrases);	}	if (!forbiddenPhrasesFound.isEmpty()) {	
forbidden phrases found in commands commands 

========================= brooklyn sample_2189 =========================

public void install() {	
installing 

public void customize() {	
customizing cluster 

public void launch() {	
launching 

========================= brooklyn sample_338 =========================

public void testInheritsGeo() throws Exception {	ConfigBag allConfig = ConfigBag.newInstance() .configure(IMAGE_ID, "bogus") .configure(CLOUD_PROVIDER, "aws-ec2") .configure(CLOUD_REGION_ID, "bogus") .configure(ACCESS_IDENTITY, "bogus") .configure(ACCESS_CREDENTIAL, "bogus") .configure(LocationConfigKeys.LATITUDE, 42d) .configure(LocationConfigKeys.LONGITUDE, -20d) .configure(MACHINE_CREATE_ATTEMPTS, 1);	FakeLocalhostWithParentJcloudsLocation ll = managementContext.getLocationManager().createLocation(LocationSpec.create(FakeLocalhostWithParentJcloudsLocation.class).configure(allConfig.getAllConfig()));	MachineLocation l = ll.obtain();	
loc 

public void testInheritsGeo() throws Exception {	ConfigBag allConfig = ConfigBag.newInstance() .configure(IMAGE_ID, "bogus") .configure(CLOUD_PROVIDER, "aws-ec2") .configure(CLOUD_REGION_ID, "bogus") .configure(ACCESS_IDENTITY, "bogus") .configure(ACCESS_CREDENTIAL, "bogus") .configure(LocationConfigKeys.LATITUDE, 42d) .configure(LocationConfigKeys.LONGITUDE, -20d) .configure(MACHINE_CREATE_ATTEMPTS, 1);	FakeLocalhostWithParentJcloudsLocation ll = managementContext.getLocationManager().createLocation(LocationSpec.create(FakeLocalhostWithParentJcloudsLocation.class).configure(allConfig.getAllConfig()));	MachineLocation l = ll.obtain();	HostGeoInfo geo = HostGeoInfo.fromLocation(l);	
geo 

public void testInheritsGeoFromLocationMetadataProperties() throws Exception {	ConfigBag allConfig = ConfigBag.newInstance() .configure(IMAGE_ID, "bogus") .configure(CLOUD_PROVIDER, "softlayer") .configure(CLOUD_REGION_ID, "wdc01") .configure(ACCESS_IDENTITY, "bogus") .configure(ACCESS_CREDENTIAL, "bogus") .configure(MACHINE_CREATE_ATTEMPTS, 1);	Map<String, Object> brooklynProperties = managementContext.getBrooklynProperties().asMapWithStringKeys();	FakeLocalhostWithParentJcloudsLocation ll = managementContext.getLocationManager().createLocation(LocationSpec.create(FakeLocalhostWithParentJcloudsLocation.class) .configure(new JcloudsPropertiesFromBrooklynProperties().getJcloudsProperties("softlayer", "wdc01", null, brooklynProperties)) .configure(allConfig.getAllConfig()));	MachineLocation l = ll.obtain();	
loc 

public void testInheritsGeoFromLocationMetadataProperties() throws Exception {	ConfigBag allConfig = ConfigBag.newInstance() .configure(IMAGE_ID, "bogus") .configure(CLOUD_PROVIDER, "softlayer") .configure(CLOUD_REGION_ID, "wdc01") .configure(ACCESS_IDENTITY, "bogus") .configure(ACCESS_CREDENTIAL, "bogus") .configure(MACHINE_CREATE_ATTEMPTS, 1);	Map<String, Object> brooklynProperties = managementContext.getBrooklynProperties().asMapWithStringKeys();	FakeLocalhostWithParentJcloudsLocation ll = managementContext.getLocationManager().createLocation(LocationSpec.create(FakeLocalhostWithParentJcloudsLocation.class) .configure(new JcloudsPropertiesFromBrooklynProperties().getJcloudsProperties("softlayer", "wdc01", null, brooklynProperties)) .configure(allConfig.getAllConfig()));	MachineLocation l = ll.obtain();	HostGeoInfo geo = HostGeoInfo.fromLocation(l);	
geo 

========================= brooklyn sample_2536 =========================

private FindItemAndClass inferFrom(String type) {	RegisteredType item = mgmt.getTypeRegistry().get(type);	if (item != null) {	return setAs( mgmt.getTypeRegistry().createSpec(item, null, org.apache.brooklyn.api.entity.EntitySpec.class).getType(), item.getId());	} else {	try {	setAs( (Class<? extends Entity>) getCatalog().getRootClassLoader().loadClass(type), null);	
catalog does not contain item for type loaded class directly instead 

private FindItemAndClass inferFrom(String type) {	RegisteredType item = mgmt.getTypeRegistry().get(type);	if (item != null) {	return setAs( mgmt.getTypeRegistry().createSpec(item, null, org.apache.brooklyn.api.entity.EntitySpec.class).getType(), item.getId());	} else {	try {	setAs( (Class<? extends Entity>) getCatalog().getRootClassLoader().loadClass(type), null);	return this;	} catch (ClassNotFoundException e2) {	
no catalog item for type and could not load class directly rethrowing 

public Application create(ApplicationSpec spec) {	
using deprecated functionality as of applicationspec style pre camp plans transition to actively supported spec plans 

public Application create(ApplicationSpec spec) {	
rest creating application instance for 

itemAndClass = new FindItemAndClass().inferFrom(type);	}	if (!Entitlements.isEntitled(mgmt.getEntitlementManager(), Entitlements.INVOKE_EFFECTOR, null)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to create application from applicationSpec %s", Entitlements.getEntitlementContext().user(), spec);	}	try {	if (Application.class.isAssignableFrom(itemAndClass.clazz)) {	org.apache.brooklyn.api.entity.EntitySpec<?> coreSpec = toCoreEntitySpec(itemAndClass.clazz, name, configO, itemAndClass.catalogItemId);	configureRenderingMetadata(spec, coreSpec);	for (EntitySpec entitySpec : entities) {	
rest creating instance for entity 

try {	if (Application.class.isAssignableFrom(itemAndClass.clazz)) {	org.apache.brooklyn.api.entity.EntitySpec<?> coreSpec = toCoreEntitySpec(itemAndClass.clazz, name, configO, itemAndClass.catalogItemId);	configureRenderingMetadata(spec, coreSpec);	for (EntitySpec entitySpec : entities) {	coreSpec.child(toCoreEntitySpec(entitySpec));	}	log.info("REST placing '{}' under management", spec.getName() != null ? spec.getName() : spec);	instance = (Application) mgmt.getEntityManager().createEntity(coreSpec);	} else if (Entity.class.isAssignableFrom(itemAndClass.clazz)) {	
cannot supply additional entities when using a non application entity ignoring in spec 

for (EntitySpec entitySpec : entities) {	coreSpec.child(toCoreEntitySpec(entitySpec));	}	log.info("REST placing '{}' under management", spec.getName() != null ? spec.getName() : spec);	instance = (Application) mgmt.getEntityManager().createEntity(coreSpec);	} else if (Entity.class.isAssignableFrom(itemAndClass.clazz)) {	org.apache.brooklyn.api.entity.EntitySpec<?> coreSpec = toCoreEntitySpec(BasicApplication.class, name, configO, itemAndClass.catalogItemId);	configureRenderingMetadata(spec, coreSpec);	coreSpec.child(toCoreEntitySpec(itemAndClass.clazz, name, configO, itemAndClass.catalogItemId) .configure(BrooklynCampConstants.PLAN_ID, "soleChildId"));	coreSpec.enricher(Enrichers.builder() .propagatingAllBut(Attributes.SERVICE_UP, Attributes.SERVICE_NOT_UP_INDICATORS, Attributes.SERVICE_STATE_ACTUAL, Attributes.SERVICE_STATE_EXPECTED, Attributes.SERVICE_PROBLEMS) .from(new DslComponent(Scope.CHILD, "soleChildId").newTask()) .build());	
rest placing under management 

org.apache.brooklyn.api.entity.EntitySpec<?> coreSpec = toCoreEntitySpec(BasicApplication.class, name, configO, itemAndClass.catalogItemId);	configureRenderingMetadata(spec, coreSpec);	coreSpec.child(toCoreEntitySpec(itemAndClass.clazz, name, configO, itemAndClass.catalogItemId) .configure(BrooklynCampConstants.PLAN_ID, "soleChildId"));	coreSpec.enricher(Enrichers.builder() .propagatingAllBut(Attributes.SERVICE_UP, Attributes.SERVICE_NOT_UP_INDICATORS, Attributes.SERVICE_STATE_ACTUAL, Attributes.SERVICE_STATE_EXPECTED, Attributes.SERVICE_PROBLEMS) .from(new DslComponent(Scope.CHILD, "soleChildId").newTask()) .build());	instance = (Application) mgmt.getEntityManager().createEntity(coreSpec);	} else {	throw new IllegalArgumentException("Class " + itemAndClass.clazz + " must extend one of ApplicationBuilder, Application or Entity");	}	return instance;	} catch (Exception e) {	
rest failed to create application 

private Map<?,?> convertFlagsToKeys(Class<? extends Entity> javaType, Map<?, ?> config) {	if (config==null || config.isEmpty() || javaType==null) return config;	Map<String, ConfigKey<?>> configKeys = BrooklynTypes.getDefinedConfigKeys(javaType);	Map<Object,Object> result = new LinkedHashMap<Object,Object>();	for (Map.Entry<?,?> entry: config.entrySet()) {	
setting key to for rest creation of 

private Map<?,?> convertFlagsToKeys(Class<? extends Entity> javaType, Map<?, ?> config) {	if (config==null || config.isEmpty() || javaType==null) return config;	Map<String, ConfigKey<?>> configKeys = BrooklynTypes.getDefinedConfigKeys(javaType);	Map<Object,Object> result = new LinkedHashMap<Object,Object>();	for (Map.Entry<?,?> entry: config.entrySet()) {	Object key = configKeys.get(entry.getKey());	if (key==null) {	
unrecognised config key passed to will be treated as flag and likely ignored 

public static String fixLocation(String locationId) {	if (locationId.startsWith("/locations/") || locationId.startsWith("/v1/locations/")) {	
rest api using legacy uri syntax for location 

========================= brooklyn sample_2865 =========================

public String getNimbusHostname() {	String result = entity.getConfig(Storm.NIMBUS_HOSTNAME);	if (result != null) return result;	Entity nimbus = entity.getConfig(Storm.NIMBUS_ENTITY);	if (nimbus == null) {	
no nimbus hostname available using localhost 

public void launch() {	boolean needsSleep = false;	if (getRoleName().equals("supervisor")) {	Entity nimbus = entity.getConfig(Storm.NIMBUS_ENTITY);	if (nimbus == null) {	
no nimbus entity available not blocking before starting supervisors 

boolean needsSleep = false;	if (getRoleName().equals("supervisor")) {	Entity nimbus = entity.getConfig(Storm.NIMBUS_ENTITY);	if (nimbus == null) {	} else {	Entities.waitForServiceUp(nimbus, entity.getConfig(SoftwareProcess.START_TIMEOUT));	needsSleep = true;	}	}	String subnetHostname = Machines.findSubnetOrPublicHostname(entity).get();	
launching with role and hostname public hostname subnet 

public void customize() {	
customizing 

========================= brooklyn sample_504 =========================

return new String(out.toByteArray());	} catch (IOException e) {	throw Exceptions.propagate(e);	}	}	}).build();	String responseBody = (String) queue(t).getUnchecked();	if (jsonPath != null) {	String extractedValue = JsonPath.parse(responseBody).read(jsonPath, String.class);	if (publishSensor != null) {	
publishsensor configuration key is deprecated please prefer pathsandsensors instead 

private HttpRequest buildHttpRequest(String httpVerb, URI uri, Map<String, String> headers, String httpUsername, String httpPassword, Object payload) {	HttpRequest.Builder httpRequestBuilder = new HttpRequest.Builder() .uri(uri) .method(httpVerb) .config(HttpConfig.builder() .trustSelfSigned(true) .trustAll(true) .laxRedirect(true) .build());	if (headers != null) {	httpRequestBuilder.headers(headers);	}	if (payload != null) {	String body = "";	String contentType = headers.get(HttpHeaders.CONTENT_TYPE);	if (contentType == null || contentType.equalsIgnoreCase(APPLICATION_JSON)) {	
content type not specified using as default continuing 

========================= brooklyn sample_1176 =========================

private void closeSafely(final Channel channel, int timeoutMs) throws InterruptedException {	if (channel == null) return;	Thread t = new Thread(new Runnable() {	try {	channel.close();	} catch (IOException e) {	
error closing rabbitmq channel continuing 

private Channel getAmqpChannel(RabbitBroker rabbit) throws Exception {	String uri = rabbit.getAttribute(MessageBroker.BROKER_URL);	
connecting to rabbit 

========================= brooklyn sample_441 =========================

Object result = t.create(type, constraint);	if (result==null) {	transformersWhoDontSupport.add(t.getFormatCode() + " (returned null)");	continue;	}	return Maybe.of(result);	} catch (@SuppressWarnings("deprecation") org.apache.brooklyn.core.plan.PlanNotRecognizedException | UnsupportedTypePlanException e) {	transformersWhoDontSupport.add(t.getFormatCode() + (Strings.isNonBlank(e.getMessage()) ? " ("+e.getMessage()+")" : ""));	} catch (Throwable e) {	Exceptions.propagateIfFatal(e);	
transformer for gave an error creating this plan retrying with others 

} catch (@SuppressWarnings("deprecation") org.apache.brooklyn.core.plan.PlanNotRecognizedException | UnsupportedTypePlanException e) {	transformersWhoDontSupport.add(t.getFormatCode() + (Strings.isNonBlank(e.getMessage()) ? " ("+e.getMessage()+")" : ""));	} catch (Throwable e) {	Exceptions.propagateIfFatal(e);	failuresFromTransformers.add(new PropagatedRuntimeException( (type.getSymbolicName()!=null ? "Error in definition of "+type.getId() : "Transformer for "+t.getFormatCode()+" gave an error creating this plan") + ": "+ Exceptions.collapseText(e), e));	}	}	Exception result;	if (!failuresFromTransformers.isEmpty()) {	if (log.isDebugEnabled()) {	
failure transforming plan returning summary failure but for reference potentially application transformers were available ones are failures 

========================= brooklyn sample_1025 =========================

final EntityInternal entity = (EntityInternal) BrooklynTaskTags.getTargetOrContextEntity(Tasks.current());	final ExecutionContext exec = (null != entity ? entity.getExecutionContext() : BasicExecutionContext.getCurrentExecutionContext());	if (exec != null) {	optionValue = Tasks.resolveDeepValue(optionValue, Object.class, exec);	}	} catch (ExecutionException | InterruptedException e) {	Exceptions.propagate(e);	}	Maybe<?> result = MethodCoercions.tryFindAndInvokeBestMatchingMethod(options, option.getKey(), optionValue);	if (result.isAbsent()) {	
ignoring request to set template option because this is not supported by 

if (exec != null) {	optionValue = Tasks.resolveDeepValue(optionValue, Object.class, exec);	}	} catch (ExecutionException | InterruptedException e) {	Exceptions.propagate(e);	}	Maybe<?> result = MethodCoercions.tryFindAndInvokeBestMatchingMethod(options, option.getKey(), optionValue);	if (result.isAbsent()) {	}	} else {	
ignoring request to set template option because value is null 

========================= brooklyn sample_2609 =========================

public void testSoftUsageAndClearance() {	MemoryUsageSummary initialMemory = new MemoryUsageSummary();	
memory usage at start of test 

MemoryUsageSummary initialMemory = new MemoryUsageSummary();	MemoryUsageSummary beforeCollectedMemory = null;	List<Maybe<?>> dump = MutableList.of();	for (int i=0; i<1000*1000; i++) {	beforeCollectedMemory = new MemoryUsageSummary();	dump.add(Maybe.soft(new byte[1000*1000]));	if (containsAbsent(dump)) break;	}	int cleared = countAbsents(dump);	assertTrue(cleared > 0, "No soft references cleared after trying to allocate all available memory");	
first soft reference cleared after blocks created of them cleared memory just before collected is 

List<Maybe<?>> dump = MutableList.of();	for (int i=0; i<1000*1000; i++) {	beforeCollectedMemory = new MemoryUsageSummary();	dump.add(Maybe.soft(new byte[1000*1000]));	if (containsAbsent(dump)) break;	}	int cleared = countAbsents(dump);	assertTrue(cleared > 0, "No soft references cleared after trying to allocate all available memory");	assertUsedMemoryFractionWithinRange(beforeCollectedMemory, Range.closed(0.7, 1.0));	String clearanceResult = MemoryUsageTracker.forceClearSoftReferences(100*1000, 10*1000*1000);	
forcing memory eviction 

dump.add(Maybe.soft(new byte[1000*1000]));	if (containsAbsent(dump)) break;	}	int cleared = countAbsents(dump);	assertTrue(cleared > 0, "No soft references cleared after trying to allocate all available memory");	assertUsedMemoryFractionWithinRange(beforeCollectedMemory, Range.closed(0.7, 1.0));	String clearanceResult = MemoryUsageTracker.forceClearSoftReferences(100*1000, 10*1000*1000);	System.gc(); System.gc();	MemoryUsageSummary afterClearedMemory = new MemoryUsageSummary();	double initialUsedFraction = 1.0*initialMemory.used assertUsedMemoryFractionWithinRange(afterClearedMemory, Range.closed(0.0, initialUsedFraction + 0.1));	
final memory usage after forcing clear and gc 

========================= brooklyn sample_1926 =========================

public void testSimple() throws Exception {	Callable<String> mainJob = new Callable<String>() {	public String call() {	
main job 

public Callable<String> sayCallable(final String message, final Duration duration, final String message2) {	return new Callable<String>() {	public String call() {	try {	if (message != null) {	
saying 

return new Callable<String>() {	public String call() {	try {	if (message != null) {	synchronized (messages) {	messages.add(message);	messages.notifyAll();	}	}	if (message2 != null) {	
will say after 

messages.add(message);	messages.notifyAll();	}	}	if (message2 != null) {	}	if (duration != null && duration.toMilliseconds() > 0) {	Thread.sleep(duration.toMillisecondsRoundingUp());	}	} catch (InterruptedException e) {	
releasing semaphore on interruption after saying 

if (message2 != null) {	}	if (duration != null && duration.toMilliseconds() > 0) {	Thread.sleep(duration.toMillisecondsRoundingUp());	}	} catch (InterruptedException e) {	cancellations.release();	throw Exceptions.propagate(e);	}	if (message2 != null) {	
saying 

public void testCancelled() throws Exception {	Task<List<?>> t = Tasks.sequential( sayTask("1"), sayTask("2a", Duration.THIRTY_SECONDS, "2b"), sayTask("3"));	ec.submit(t);	waitForMessages(Predicates.compose(MathPredicates.greaterThanOrEqual(2), CollectionFunctionals.sizeFunction()), TIMEOUT);	Assert.assertEquals(messages, Arrays.asList("1", "2a"));	t.cancel(true);	Assert.assertTrue(t.isDone());	Assert.assertEquals(messages, Arrays.asList("1", "2a"));	
testcancelled waiting on semaphore permits left is 

public void testCancelled() throws Exception {	Task<List<?>> t = Tasks.sequential( sayTask("1"), sayTask("2a", Duration.THIRTY_SECONDS, "2b"), sayTask("3"));	ec.submit(t);	waitForMessages(Predicates.compose(MathPredicates.greaterThanOrEqual(2), CollectionFunctionals.sizeFunction()), TIMEOUT);	Assert.assertEquals(messages, Arrays.asList("1", "2a"));	t.cancel(true);	Assert.assertTrue(t.isDone());	Assert.assertEquals(messages, Arrays.asList("1", "2a"));	Assert.assertTrue(cancellations.tryAcquire(10, TimeUnit.SECONDS));	
testcancelled acquired semaphore permits left is 

========================= brooklyn sample_904 =========================

public void delete() {	if (!file.delete()) {	if (!file.exists()) {	
unable to delete probably did not exist 

public void delete() {	if (!file.delete()) {	if (!file.exists()) {	} else {	
unable to delete probably still locked 

public void delete() {	if (!file.delete()) {	if (!file.exists()) {	} else {	}	}	if (tmpFile.exists() && !tmpFile.delete()) {	
unable to delete probably still locked 

========================= brooklyn sample_1160 =========================

String keyName = Strings.removeFromStart((String)entry.getKey(), HTTP_EXECUTOR_CLASS_CONFIG_PREFIX);	httpExecutorProps.put(keyName, entry.getValue());	}	}	try {	httpExecutor = (HttpExecutor) new ClassLoaderUtils(getClass()).loadClass(httpExecutorClass).getConstructor(Map.class).newInstance(httpExecutorProps);	} catch (Exception e) {	throw Exceptions.propagate(e);	}	} else {	
parameter not provided using the default implementation 

========================= brooklyn sample_1530 =========================

private void serverAdded(MongoDBServer server) {	try {	
server added service up 

private void serverAdded(MongoDBServer server) {	try {	if (mustInitialise.compareAndSet(true, false)) {	
first server up in is 

if (mustInitialise.compareAndSet(true, false)) {	boolean replicaSetInitialised = server.initializeReplicaSet(getName(), nextMemberId.getAndIncrement());	if (replicaSetInitialised) {	sensors().set(PRIMARY_ENTITY, server);	sensors().set(Startable.SERVICE_UP, true);	} else {	ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator(this, "initialization", "replicaset failed to initialize");	ServiceStateLogic.setExpectedState(this, Lifecycle.ON_FIRE);	}	} else {	
scheduling addition of member to 

private void addSecondaryWhenPrimaryIsNonNull(final MongoDBServer secondary) {	executor.submit(new Runnable() {	public void run() {	Boolean isAvailable = secondary.sensors().get(MongoDBServer.SERVICE_UP);	MongoDBServer primary = getPrimary();	boolean reschedule;	if (Boolean.TRUE.equals(isAvailable) && primary != null) {	boolean added = primary.addMemberToReplicaSet(secondary, nextMemberId.incrementAndGet());	if (added) {	
added to replica set 

public void run() {	Boolean isAvailable = secondary.sensors().get(MongoDBServer.SERVICE_UP);	MongoDBServer primary = getPrimary();	boolean reschedule;	if (Boolean.TRUE.equals(isAvailable) && primary != null) {	boolean added = primary.addMemberToReplicaSet(secondary, nextMemberId.incrementAndGet());	if (added) {	reschedule = false;	} else {	if (LOG.isDebugEnabled()) {	
could not be added to replica set via rescheduling 

private void serverRemoved(final MongoDBServer member) {	try {	
scheduling removal of member from 

try {	if (member.equals(sensors().get(PRIMARY_ENTITY))) sensors().set(PRIMARY_ENTITY, null);	executor.submit(new Runnable() {	public void run() {	Boolean isAvailable = member.sensors().get(MongoDBServer.SERVICE_UP);	MongoDBServer primary = getPrimary();	boolean reschedule;	if (primary != null && !isAvailable) {	boolean removed = primary.removeMemberFromReplicaSet(member);	if (removed) {	
removed from replica set 

public void run() {	Boolean isAvailable = member.sensors().get(MongoDBServer.SERVICE_UP);	MongoDBServer primary = getPrimary();	boolean reschedule;	if (primary != null && !isAvailable) {	boolean removed = primary.removeMemberFromReplicaSet(member);	if (removed) {	reschedule = false;	} else {	if (LOG.isDebugEnabled()) {	
could not be removed from replica set via rescheduling 

public void start(Collection<? extends Location> locations) {	super.start(locations);	policy = policies().add(PolicySpec.create(MemberTrackingPolicy.class) .displayName(getName() + " membership tracker") .configure("group", this));	for (AttributeSensor<Long> sensor: SENSORS_TO_SUM) enrichers().add(Enrichers.builder() .aggregating(sensor) .publishing(sensor) .fromMembers() .computingSum() .valueToReportIfNoSensors(null) .defaultValueForUnreportedSensors(null) .build());	enrichers().add(Enrichers.builder() .aggregating(MongoDBServer.REPLICA_SET_PRIMARY_ENDPOINT) .publishing(MongoDBServer.REPLICA_SET_PRIMARY_ENDPOINT) .fromMembers() .valueToReportIfNoSensors(null) .computing(new Function<Collection<String>, String>() {	public String apply(Collection<String> input) {	if (input==null || input.isEmpty()) return null;	Set<String> distinct = MutableSet.of();	for (String endpoint: input) if (!Strings.isBlank(endpoint)) distinct.add(endpoint);	
mongo replica set detetcted multiple masters transitioning 

========================= brooklyn sample_379 =========================

public static void dumpReflectiveEquals(Object o1, Object o2) {	
comparing 

public static void dumpReflectiveEquals(Object o1, Object o2) {	Class<?> clazz = o1.getClass();	while (!(clazz.equals(Object.class))) {	
fields in 

public static void dumpReflectiveEquals(Object o1, Object o2) {	Class<?> clazz = o1.getClass();	while (!(clazz.equals(Object.class))) {	for (Field f: clazz.getDeclaredFields()) {	f.setAccessible(true);	try {	log.info( "    "+(Objects.equal(f.get(o1), f.get(o2)) ? "==" : "!=" ) + " "+ f.getName()+ " "+ f.get(o1) +" "+ f.get(o2) + " ("+ classOf(f.get(o1)) +" "+ classOf(f.get(o2)+")") );	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error 

========================= brooklyn sample_2062 =========================

public static void createDefaultNetworkAndAddToTemplateOptionsIfRequired(ComputeService computeService, ConfigBag config) {	if (!config.get(AZURE_ARM_DEFAULT_NETWORK_ENABLED)) {	
azure arm default network enabled is disabled not creating default network 

public static void createDefaultNetworkAndAddToTemplateOptionsIfRequired(ComputeService computeService, ConfigBag config) {	if (!config.get(AZURE_ARM_DEFAULT_NETWORK_ENABLED)) {	return;	}	String location = config.get(CLOUD_REGION_ID);	if(StringUtils.isEmpty(location)) {	
no region information so cannot create a default network 

public static void createDefaultNetworkAndAddToTemplateOptionsIfRequired(ComputeService computeService, ConfigBag config) {	if (!config.get(AZURE_ARM_DEFAULT_NETWORK_ENABLED)) {	return;	}	String location = config.get(CLOUD_REGION_ID);	if(StringUtils.isEmpty(location)) {	return;	}	Map<String, Object> templateOptions = config.get(TEMPLATE_OPTIONS);	if (config.containsKey(NETWORK_NAME)) {	
network config specified when provisioning azure machine not creating default network 

}	String location = config.get(CLOUD_REGION_ID);	if(StringUtils.isEmpty(location)) {	return;	}	Map<String, Object> templateOptions = config.get(TEMPLATE_OPTIONS);	if (config.containsKey(NETWORK_NAME)) {	return;	}	if (templateOptions != null && (templateOptions.containsKey("networks") || templateOptions.containsKey("ipOptions"))) {	
network config specified when provisioning azure machine not creating default network 

return;	}	AzureComputeApi api = computeService.getContext().unwrapApi(AzureComputeApi.class);	String resourceGroupName = DEFAULT_RESOURCE_GROUP_PREFIX  + "-" + location;	String vnetName = DEFAULT_NETWORK_NAME_PREFIX + "-" + location;	String subnetName = DEFAULT_SUBNET_NAME_PREFIX + "-" + location;	SubnetApi subnetApi = api.getSubnetApi(resourceGroupName, vnetName);	VirtualNetworkApi virtualNetworkApi = api.getVirtualNetworkApi(resourceGroupName);	Subnet preexistingSubnet = subnetApi.get(subnetName);	if(preexistingSubnet != null){	
using pre existing default azure network and subnet when provisioning machine 

SubnetApi subnetApi = api.getSubnetApi(resourceGroupName, vnetName);	VirtualNetworkApi virtualNetworkApi = api.getVirtualNetworkApi(resourceGroupName);	Subnet preexistingSubnet = subnetApi.get(subnetName);	if(preexistingSubnet != null){	updateTemplateOptions(config, preexistingSubnet);	return;	}	createResourceGroupIfNeeded(api, resourceGroupName, location);	Subnet.SubnetProperties subnetProperties = Subnet.SubnetProperties.builder().addressPrefix(DEFAULT_SUBNET_ADDRESS_PREFIX).build();	if(virtualNetworkApi.get(vnetName) == null) {	
network config not specified when provisioning azure machine and default network subnet does not exists creating network and subnet and updating template options 

updateTemplateOptions(config, preexistingSubnet);	return;	}	createResourceGroupIfNeeded(api, resourceGroupName, location);	Subnet.SubnetProperties subnetProperties = Subnet.SubnetProperties.builder().addressPrefix(DEFAULT_SUBNET_ADDRESS_PREFIX).build();	if(virtualNetworkApi.get(vnetName) == null) {	Subnet subnet = Subnet.create(subnetName, null, null, subnetProperties);	VirtualNetwork.VirtualNetworkProperties virtualNetworkProperties = VirtualNetwork.VirtualNetworkProperties .builder().addressSpace(VirtualNetwork.AddressSpace.create(Arrays.asList(DEFAULT_VNET_ADDRESS_PREFIX))) .subnets(Arrays.asList(subnet)).build();	virtualNetworkApi.createOrUpdate(vnetName, location, virtualNetworkProperties);	} else {	
network config not specified when provisioning azure machine and default subnet does not exists creating subnet on network and updating template options 

virtualNetworkApi.createOrUpdate(vnetName, location, virtualNetworkProperties);	} else {	subnetApi.createOrUpdate(subnetName, subnetProperties);	}	Subnet createdSubnet = api.getSubnetApi(resourceGroupName, vnetName).get(subnetName);	CountdownTimer timeout = CountdownTimer.newInstanceStarted(Duration.minutes(new Integer(20)));	while (createdSubnet == null || createdSubnet.properties()  == null || PROVISIONING_STATE_UPDATING.equals(createdSubnet.properties().provisioningState())) {	if (timeout.isExpired()) {	throw new IllegalStateException("Creating subnet " + subnetName + " stuck in the updating state, aborting.");	}	
created subnet is still in updating state waiting for it to complete 

CountdownTimer timeout = CountdownTimer.newInstanceStarted(Duration.minutes(new Integer(20)));	while (createdSubnet == null || createdSubnet.properties()  == null || PROVISIONING_STATE_UPDATING.equals(createdSubnet.properties().provisioningState())) {	if (timeout.isExpired()) {	throw new IllegalStateException("Creating subnet " + subnetName + " stuck in the updating state, aborting.");	}	Duration.sleep(Duration.ONE_SECOND);	createdSubnet = api.getSubnetApi(resourceGroupName, vnetName).get(subnetName);	}	String lastProvisioningState = createdSubnet.properties().provisioningState();	if (!lastProvisioningState.equals(PROVISIONING_STATE_SUCCEEDED)) {	
created subnet in wrong state expected state but found 

private static void createResourceGroupIfNeeded(AzureComputeApi api, String resourceGroup, String location) {	ResourceGroup rg = api.getResourceGroupApi().get(resourceGroup);	if (rg == null) {	
default azure resource group does not exist in creating 

private static void createResourceGroupIfNeeded(AzureComputeApi api, String resourceGroup, String location) {	ResourceGroup rg = api.getResourceGroupApi().get(resourceGroup);	if (rg == null) {	api.getResourceGroupApi().create(resourceGroup, location, ImmutableMap.of("description", "brooklyn default resource group"));	} else {	
using existing default azure resource group in 

========================= brooklyn sample_2577 =========================

if (provider.contains("rackspace") || provider.contains("cloudservers") || provider.contains("softlayer")) {	if (getConfig(LISTEN_ADDRESS_SENSOR)==null) config().set(LISTEN_ADDRESS_SENSOR, CassandraNode.ADDRESS.getName());	if (getConfig(BROADCAST_ADDRESS_SENSOR)==null) config().set(BROADCAST_ADDRESS_SENSOR, CassandraNode.ADDRESS.getName());	result = "public IP for both listen and broadcast";	} else if (provider.contains("google-compute")) {	if (getConfig(LISTEN_ADDRESS_SENSOR)==null) config().set(LISTEN_ADDRESS_SENSOR, CassandraNode.SUBNET_HOSTNAME.getName());	if (getConfig(BROADCAST_ADDRESS_SENSOR)==null) config().set(BROADCAST_ADDRESS_SENSOR, CassandraNode.SUBNET_HOSTNAME.getName());	result = "private IP for both listen and broadcast";	}	}	
cassandra nics inferred for using location based on provider 

if (getConfig(LISTEN_ADDRESS_SENSOR)==null) config().set(LISTEN_ADDRESS_SENSOR, CassandraNode.ADDRESS.getName());	if (getConfig(BROADCAST_ADDRESS_SENSOR)==null) config().set(BROADCAST_ADDRESS_SENSOR, CassandraNode.ADDRESS.getName());	result = "public IP for both listen and broadcast";	} else if (provider.contains("google-compute")) {	if (getConfig(LISTEN_ADDRESS_SENSOR)==null) config().set(LISTEN_ADDRESS_SENSOR, CassandraNode.SUBNET_HOSTNAME.getName());	if (getConfig(BROADCAST_ADDRESS_SENSOR)==null) config().set(BROADCAST_ADDRESS_SENSOR, CassandraNode.SUBNET_HOSTNAME.getName());	result = "private IP for both listen and broadcast";	}	}	} catch (Exception e) {	
cassandra nics auto detection failed for in location 

public void setToken(String token) {	try {	if (!jmxHelper.isConnected()) jmxHelper.connect();;	jmxHelper.operation(storageServiceMBean, "move", token);	
moved server to token 

if (privatePort == null) return -1L;	HostAndPort hp = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, privatePort);	try {	long start = System.currentTimeMillis();	Socket s = new Socket(hp.getHostText(), hp.getPort());	s.close();	long latency = System.currentTimeMillis() - start;	return latency;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
cassandra thrift port poll failure 

========================= brooklyn sample_396 =========================

public void testRootSerializesSensibly() throws Exception {	String data = client().path("/apidoc/swagger.json").get(String.class);	
apidoc gives 

========================= brooklyn sample_2824 =========================

super.connectSensors();	sensors().set(JMX_CONTEXT, String.format("karaf-%s", getConfig(KARAF_NAME.getConfigKey())));	ConfigToAttributes.apply(this);	ObjectName karafAdminObjectName = JmxHelper.createObjectName(String.format(KARAF_ADMIN, getConfig(KARAF_NAME.getConfigKey())));	jmxFeed = JmxFeed.builder() .entity(this) .helper(jmxHelper) .period(500, TimeUnit.MILLISECONDS) .pollAttribute(new JmxAttributePollConfig<Map>(KARAF_INSTANCES) .objectName(karafAdminObjectName) .attributeName("Instances") .onSuccess(new Function<Object, Map>() {	public Map apply(Object input) {	return JmxValueFunctions.tabularDataToMap((TabularData)input);	}	}) .onException(new Function<Exception,Map>() {	if (Boolean.TRUE.equals(getAttribute(SERVICE_UP))) {	
entity is not reachable on jmx 

for (Map.Entry<String, String> entry: additionalVals.entrySet()) {	String key = entry.getKey();	String value = entry.getValue();	CompositeData data = new CompositeDataSupport( JmxConstants.PROPERTY_TYPE, MutableMap.of(JmxConstants.KEY, key, JmxConstants.TYPE, "String", JmxConstants.VALUE, value));	table.remove(data.getAll(new String[] {JmxConstants.KEY}));	table.put(data);	}	} catch (OpenDataException e) {	throw Exceptions.propagate(e);	}	
updating monterey service configuration with changes 

for (Map.Entry<String, String> entry: additionalVals.entrySet()) {	String key = entry.getKey();	String value = entry.getValue();	CompositeData data = new CompositeDataSupport( JmxConstants.PROPERTY_TYPE, MutableMap.of(JmxConstants.KEY, key, JmxConstants.TYPE, "String", JmxConstants.VALUE, value));	table.remove(data.getAll(new String[] {JmxConstants.KEY}));	table.put(data);	}	} catch (OpenDataException e) {	throw Exceptions.propagate(e);	}	
updating monterey service configuration with new configuration 


installing feature via jmx 

========================= brooklyn sample_115 =========================

public static boolean isCertificateAuthorizedBy(X509Certificate candidate, X509Certificate authority, boolean quiet) {	try {	candidate = getCanonicalImpl(candidate);	getTrustManager(authority).checkClientTrusted(new X509Certificate[] { candidate }, "RSA");	return true;	} catch (CertificateException e) {	if (!quiet) {	
certificate not trusted with authority 

========================= brooklyn sample_1971 =========================

for (MachineLocation machine : initialMachines) {	T castMachine = (T) machine;	machines.add(castMachine);	}	}	}	config().set(INITIAL_MACHINES_FACTORY, (Supplier<List<? extends MachineLocation>>) null);	Set<T> machinesCopy = MutableSet.of();	for (T location : machines) {	if (location==null) {	
initialized with null location removing may be due to rebind with reference to an unmanaged location 

========================= brooklyn sample_1588 =========================

public static void invokeStopOnShutdown(Entity entity) {	if (!(entity instanceof Startable)) {	
not adding entity for stop on shutdown as not an instance of 

public static void invokeStopOnShutdown(Entity entity) {	if (!(entity instanceof Startable)) {	return;	}	try {	semaphore.acquire();	if (isShutDown.get()) {	semaphore.release();	try {	
call to invokestoponshutdown for while system already shutting down invoking stop now and throwing exception 

public static void invokeStopAppsOnShutdown(ManagementContext managementContext) {	try {	semaphore.acquire();	if (isShutDown.get()) {	semaphore.release();	try {	
call to invokestopappsonshutdown for while system already shutting down invoking stop now and throwing exception 

public static void invokeTerminateOnShutdown(ManagementContext managementContext) {	try {	semaphore.acquire();	if (isShutDown.get()) {	semaphore.release();	try {	
call to invokestoponshutdown for while system already shutting down invoking stop now and throwing exception 

} catch (Exception e) {	throw Exceptions.propagate(e);	}	entitiesToStop.addAll(entitiesToStopOnShutdown);	for (ManagementContext mgmt: managementContextsToStopAppsOnShutdown) {	if (mgmt.isRunning()) {	entitiesToStop.addAll(mgmt.getApplications());	}	}	if (entitiesToStop.isEmpty()) {	
brooklyn shutdown no entities to stop 

throw Exceptions.propagate(e);	}	entitiesToStop.addAll(entitiesToStopOnShutdown);	for (ManagementContext mgmt: managementContextsToStopAppsOnShutdown) {	if (mgmt.isRunning()) {	entitiesToStop.addAll(mgmt.getApplications());	}	}	if (entitiesToStop.isEmpty()) {	} else {	
brooklyn shutdown stopping entities 

entitiesToStop.addAll(entitiesToStopOnShutdown);	for (ManagementContext mgmt: managementContextsToStopAppsOnShutdown) {	if (mgmt.isRunning()) {	entitiesToStop.addAll(mgmt.getApplications());	}	}	if (entitiesToStop.isEmpty()) {	} else {	destroyAndWait(entitiesToStop, shutdownTimeout);	}	
brooklyn terminateonshutdown shutdown hook invoked terminating management contexts 

}	if (entitiesToStop.isEmpty()) {	} else {	destroyAndWait(entitiesToStop, shutdownTimeout);	}	for (ManagementContext managementContext: managementContextsToTerminateOnShutdown) {	try {	if (!managementContext.isRunning()) continue;	((ManagementContextInternal)managementContext).terminate();	} catch (RuntimeException e) {	
terminateonshutdown of returned error continuing 

if (!Entities.isManaged(entity)) continue;	Task<Object> t = Tasks.builder().dynamic(false).displayName("destroying "+entity).body(new Runnable() {	}).build();	stops.add( ((EntityInternal)entity).getExecutionContext().submit(t) );	}	CountdownTimer timer = CountdownTimer.newInstanceStarted(timeout);	for (Task<?> t: stops) {	try {	Duration durationRemaining = timer.getDurationRemaining();	Object result = t.getUnchecked(durationRemaining.isPositive() ? durationRemaining : Duration.ONE_MILLISECOND);	
stoponshutdown of completed 

}).build();	stops.add( ((EntityInternal)entity).getExecutionContext().submit(t) );	}	CountdownTimer timer = CountdownTimer.newInstanceStarted(timeout);	for (Task<?> t: stops) {	try {	Duration durationRemaining = timer.getDurationRemaining();	Object result = t.getUnchecked(durationRemaining.isPositive() ? durationRemaining : Duration.ONE_MILLISECOND);	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	
stoponshutdown of interrupted 

CountdownTimer timer = CountdownTimer.newInstanceStarted(timeout);	for (Task<?> t: stops) {	try {	Duration durationRemaining = timer.getDurationRemaining();	Object result = t.getUnchecked(durationRemaining.isPositive() ? durationRemaining : Duration.ONE_MILLISECOND);	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	break;	} catch (RuntimeException e) {	Exceptions.propagateIfFatal(e);	
shutdown hook returned error continuing 

CountdownTimer timer = CountdownTimer.newInstanceStarted(timeout);	for (Task<?> t: stops) {	try {	Duration durationRemaining = timer.getDurationRemaining();	Object result = t.getUnchecked(durationRemaining.isPositive() ? durationRemaining : Duration.ONE_MILLISECOND);	} catch (RuntimeInterruptedException e) {	Thread.currentThread().interrupt();	break;	} catch (RuntimeException e) {	Exceptions.propagateIfFatal(e);	
stoponshutdown of returned error continuing to stop others 

========================= brooklyn sample_1072 =========================

public void start(Collection<? extends Location> locations) {	try {	ServiceStateLogic.setExpectedState(this, Lifecycle.STARTING);	sensors().set(Attributes.SERVICE_UP, false);	Object val = config().get(START_LATCH);	if (val != null) {	
finished waiting for start latch in 

Object val = config().get(START_LATCH);	if (val != null) {	}	Entity child = sensors().get(LOCATION_ENTITY);	Map<String,EntitySpec<?>> specMap = MutableMap.copyOf(config().get(LOCATION_ENTITY_SPEC_MAP));	Boolean propagate = config().get(PROPAGATE_LOCATION_ENTITY_SENSORS);	Set<AttributeSensor<?>> sensors = MutableSet.copyOf(config().get(LOCATION_ENTITY_SENSOR_LIST));	Duration timeout = config().get(BrooklynConfigKeys.START_TIMEOUT);	addLocations(locations);	locations = Locations.getLocationsCheckingAncestors(locations, this);	
starting entity 

throw new IllegalStateException("Cannot determine provisioning location for entity: " + this);	}	String locationType = provisioner.getClass().getSimpleName();	String provider = provisioner.config().get(LocationConfigKeys.CLOUD_PROVIDER);	Set<String> countryCodes = MutableSet.copyOf(provisioner.config().get(LocationConfigKeys.ISO_3166));	sensors().set(LOCATION_TYPE, locationType);	sensors().set(LOCATION_PROVIDER, provider);	sensors().set(LOCATION_COUNTRY_CODES, countryCodes);	EntitySpec<?> spec = specMap.get(DEFAULT);	if (specMap.containsKey(locationType)) {	
matched location type for entity 

String locationType = provisioner.getClass().getSimpleName();	String provider = provisioner.config().get(LocationConfigKeys.CLOUD_PROVIDER);	Set<String> countryCodes = MutableSet.copyOf(provisioner.config().get(LocationConfigKeys.ISO_3166));	sensors().set(LOCATION_TYPE, locationType);	sensors().set(LOCATION_PROVIDER, provider);	sensors().set(LOCATION_COUNTRY_CODES, countryCodes);	EntitySpec<?> spec = specMap.get(DEFAULT);	if (specMap.containsKey(locationType)) {	spec = specMap.get(locationType);	} else if (specMap.containsKey(provider)) {	
matched provider for entity 

sensors().set(LOCATION_TYPE, locationType);	sensors().set(LOCATION_PROVIDER, provider);	sensors().set(LOCATION_COUNTRY_CODES, countryCodes);	EntitySpec<?> spec = specMap.get(DEFAULT);	if (specMap.containsKey(locationType)) {	spec = specMap.get(locationType);	} else if (specMap.containsKey(provider)) {	spec = specMap.get(provider);	} else for (String country : countryCodes) {	if (specMap.containsKey(country)) {	
matched country code for entity 

if (Boolean.TRUE.equals(propagate)) {	if (sensors.isEmpty()) {	enrichers().add(Enrichers.builder().propagatingAllButUsualAnd().from(child).build());	} else {	enrichers().add(Enrichers.builder().propagating(sensors).from(child).build());	}	}	}	}	if (child != null) {	
starting child 

if (sensors.isEmpty()) {	enrichers().add(Enrichers.builder().propagatingAllButUsualAnd().from(child).build());	} else {	enrichers().add(Enrichers.builder().propagating(sensors).from(child).build());	}	}	}	}	if (child != null) {	if (Entities.invokeEffectorWithArgs(this, child, Startable.START, locations).blockUntilEnded(timeout)) {	
successfully started by 

}	}	}	}	if (child != null) {	if (Entities.invokeEffectorWithArgs(this, child, Startable.START, locations).blockUntilEnded(timeout)) {	} else {	throw new IllegalStateException(String.format("Timed out while %s was starting %s", this, child));	}	} else {	
no child created setting service up to true 

========================= brooklyn sample_1567 =========================

public String findArchiveNameFromUrl(String url, boolean verbose) {	String name = url.substring(url.lastIndexOf('/') + 1);	if (name.indexOf("?")>0) {	Pattern p = Pattern.compile("[A-Za-z0-9_\\-]+\\..(ar|AR)($|(?=[^A-Za-z0-9_\\-]))");	Matcher wars = p.matcher(name);	if (wars.find()) {	name = wars.group();	if (wars.find()) {	
not clear which archive to deploy for using 

public String findArchiveNameFromUrl(String url, boolean verbose) {	String name = url.substring(url.lastIndexOf('/') + 1);	if (name.indexOf("?")>0) {	Pattern p = Pattern.compile("[A-Za-z0-9_\\-]+\\..(ar|AR)($|(?=[^A-Za-z0-9_\\-]))");	Matcher wars = p.matcher(name);	if (wars.find()) {	name = wars.group();	if (wars.find()) {	} else {	
inferred archive to deploy for using 

String name = url.substring(url.lastIndexOf('/') + 1);	if (name.indexOf("?")>0) {	Pattern p = Pattern.compile("[A-Za-z0-9_\\-]+\\..(ar|AR)($|(?=[^A-Za-z0-9_\\-]))");	Matcher wars = p.matcher(name);	if (wars.find()) {	name = wars.group();	if (wars.find()) {	} else {	}	} else {	
not clear which archive to deploy for using 

========================= brooklyn sample_247 =========================

public static void testReplication(DatastoreCommon db1, String dbName1, DatastoreCommon db2, String dbName2) throws Exception {	String db1Url = db1.getAttribute(DatastoreCommon.DATASTORE_URL);	String db2Url = db2.getAttribute(DatastoreCommon.DATASTORE_URL);	
testing replication between and 

String db2Url = db2.getAttribute(DatastoreCommon.DATASTORE_URL);	VogellaExampleAccess vea1 = new VogellaExampleAccess(db1 instanceof MySqlNode ? "com.mysql.jdbc.Driver" : "org.postgresql.Driver", db1Url, dbName1);	VogellaExampleAccess vea2 = new VogellaExampleAccess(db2 instanceof MySqlNode ? "com.mysql.jdbc.Driver" : "org.postgresql.Driver", db2Url, dbName2);	try {	vea1.connect();	List<List<String>> rs = vea1.readDataBase();	assertEquals(rs.size(), 1);	vea2.connect();	rs = vea2.readDataBase();	assertEquals(rs.size(), 1);	
modifying left database 

VogellaExampleAccess vea1 = new VogellaExampleAccess(db1 instanceof MySqlNode ? "com.mysql.jdbc.Driver" : "org.postgresql.Driver", db1Url, dbName1);	VogellaExampleAccess vea2 = new VogellaExampleAccess(db2 instanceof MySqlNode ? "com.mysql.jdbc.Driver" : "org.postgresql.Driver", db2Url, dbName2);	try {	vea1.connect();	List<List<String>> rs = vea1.readDataBase();	assertEquals(rs.size(), 1);	vea2.connect();	rs = vea2.readDataBase();	assertEquals(rs.size(), 1);	vea1.modifyDataBase();	
reading left database 

try {	vea1.connect();	List<List<String>> rs = vea1.readDataBase();	assertEquals(rs.size(), 1);	vea2.connect();	rs = vea2.readDataBase();	assertEquals(rs.size(), 1);	vea1.modifyDataBase();	rs = vea1.readDataBase();	assertEquals(rs.size(), 2);	
reading right database 

List<List<String>> rs = vea1.readDataBase();	assertEquals(rs.size(), 1);	vea2.connect();	rs = vea2.readDataBase();	assertEquals(rs.size(), 1);	vea1.modifyDataBase();	rs = vea1.readDataBase();	assertEquals(rs.size(), 2);	rs = vea2.readDataBase();	for (int i = 0; i < 60 && rs.size() != 2; i++) {	
sleeping for a second 

========================= brooklyn sample_67 =========================

defaultValue = specialFlagTransformer.apply(defaultValue);	}	boolean hasConstraints = inputDef.containsKey("constraints");	Predicate<?> constraint = parseConstraints(inputDef.get("constraints"), loader);	ConfigInheritance runtimeInheritance;	boolean hasRuntimeInheritance;	if (inputDef.containsKey("inheritance.runtime")) {	hasRuntimeInheritance = true;	runtimeInheritance = parseInheritance(inputDef.get("inheritance.runtime"), loader);	} else if (inputDef.containsKey("inheritance.parent")) {	
using deprecated key inheritance parent for replace with inheritance runtime 

if (Set.class.isAssignableFrom(type.getRawType()) && val instanceof Iterable) {	result = Collections.unmodifiableSet(MutableSet.copyOf((Iterable<?>)val));	} else if (val instanceof Iterable) {	result = Collections.unmodifiableList(MutableList.copyOf((Iterable<?>)val));	} else if (val instanceof Map) {	result = Collections.unmodifiableMap(MutableMap.copyOf((Map<?, ?>)val));	} else {	return val;	}	if (type != null && !type.isAssignableFrom(result.getClass())) {	
unable to convert parameter default value type to immutable 

}	}	}	List<SpecParameter<?>> result = MutableList.<SpecParameter<?>>of();	if (newParams!=null) {	for (SpecParameter<?> p: newParams) {	final SpecParameter<?> existingP = existingToKeep.remove(p.getConfigKey().getName());	if (p instanceof SpecParameterIncludingDefinitionForInheritance) {	p = ((SpecParameterIncludingDefinitionForInheritance<?>)p).resolveWithAncestor(existingP);	} else {	
found non definitional spec parameter adding to 

========================= brooklyn sample_1320 =========================

protected LocalManagementContext newTestManagementContext() {	if (mementoDir!=null) throw new IllegalStateException("already created mgmt context");	mementoDir = Files.createTempDir();	
test persisting to 

========================= brooklyn sample_1635 =========================

super.connectSensors();	sensors().set(DATASTORE_URL, String.format("mysql: Maybe<SshMachineLocation> machine = Locations.findUniqueSshMachineLocation(getLocations());	if (machine.isPresent()) {	String cmd = getDriver().getStatusCmd();	feed = SshFeed.builder() .entity(this) .period(config().get(SERVICE_PROCESS_IS_RUNNING_POLL_PERIOD)) .machine(machine.get()) .poll(new SshPollConfig<Boolean>(SERVICE_UP) .command(cmd) .setOnSuccess(true) .setOnFailureOrException(false)) .poll(new SshPollConfig<Double>(QUERIES_PER_SECOND_FROM_MARIADB) .command(cmd) .onSuccess(new Function<SshPollValue, Double>() {	public Double apply(SshPollValue input) {	String q = Strings.getFirstWordAfter(input.getStdout(), "Queries per second avg:");	return (q == null) ? null : Double.parseDouble(q);	}}) .setOnFailureOrException(null) ) .build();	} else {	
location s not an ssh machine location so not polling for status setting serviceup immediately 

========================= brooklyn sample_88 =========================

public void restart() {	DynamicTasks.queue("stop (best effort)", new Runnable() {	public void run() {	DynamicTasks.markInessential();	boolean previouslyRunning = isRunning();	try {	ServiceStateLogic.setExpectedState(getEntity(), Lifecycle.STOPPING);	stop();	} catch (Exception e) {	if (previouslyRunning) {	
restart stop failed when was previously running ignoring 

public void run() {	DynamicTasks.markInessential();	boolean previouslyRunning = isRunning();	try {	ServiceStateLogic.setExpectedState(getEntity(), Lifecycle.STOPPING);	stop();	} catch (Exception e) {	if (previouslyRunning) {	DynamicTasks.queue(Tasks.fail("Primary job failure (when previously running)", e));	} else {	
restart stop failed but was not previously running so not a surprise 

public void copyRuntimeResources() {	try {	copyResources(getRunDir(), entity.getConfig(SoftwareProcess.RUNTIME_FILES), entity.getConfig(SoftwareProcess.RUNTIME_TEMPLATES));	} catch (Exception e) {	
error copying runtime resources 

========================= brooklyn sample_2330 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	try {	t.authorizePublicKey(v.toString());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error trying jclouds authorizepublickey will run later 

========================= brooklyn sample_2625 =========================

} else {	LOG.trace(message, args);	}	}	Stopwatch timer = Stopwatch.createStarted();	try {	chain.doFilter(request, response);	} catch (Throwable e) {	requestErrored = true;	isInteresting = true;	
request from failed 

========================= brooklyn sample_2808 =========================

private static void addPropertiesFromUrl(BrooklynPropertiesImpl p, String url, boolean warnIfNotFound) {	if (url==null) return;	try {	p.addFrom(ResourceUtils.create(BrooklynPropertiesImpl.class).getResourceFromUrl(url));	} catch (Exception e) {	
could not load continuing 

private static void addPropertiesFromUrl(BrooklynPropertiesImpl p, String url, boolean warnIfNotFound) {	if (url==null) return;	try {	p.addFrom(ResourceUtils.create(BrooklynPropertiesImpl.class).getResourceFromUrl(url));	} catch (Exception e) {	
could not load continuing 

public BrooklynPropertiesImpl addFrom(File f) {	if (!f.exists()) {	
unable to find file when loading properties ignoring 

public String get(Map flags, String key) {	
discouraged use of brooklynproperties get map string ambiguous use getfirst map string or get string assuming the former 

public String get(Map flags, String key) {	
trace for discouraged use of brooklynproperties get map string arguments 

public String getFirst(Map flags, String ...keys) {	for (String k: keys) {	if (k!=null && containsKey(k)) return (String) get(k);	}	if (flags.get("warnIfNone")!=null && !Boolean.FALSE.equals(flags.get("warnIfNone"))) {	
warnIfNone unable to find brooklyn property 

public String getFirst(Map flags, String ...keys) {	for (String k: keys) {	if (k!=null && containsKey(k)) return (String) get(k);	}	if (flags.get("warnIfNone")!=null && !Boolean.FALSE.equals(flags.get("warnIfNone"))) {	
warnIfNone 

public String getFirst(Map flags, String ...keys) {	for (String k: keys) {	if (k!=null && containsKey(k)) return (String) get(k);	}	if (flags.get("warnIfNone")!=null && !Boolean.FALSE.equals(flags.get("warnIfNone"))) {	}	if (flags.get("failIfNone")!=null && !Boolean.FALSE.equals(flags.get("failIfNone"))) {	Object f = flags.get("failIfNone");	if (f instanceof Closure) {	
use of groovy lang closure is deprecated as value for failifnone in brooklynproperties getfirst 

========================= brooklyn sample_1377 =========================

public void testWithAppEnricher() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-app-with-enrichers-slightly-simpler.yaml"));	waitForApplicationTasks(app);	
started 

public void testWebappWithAveragingEnricher() throws Exception {	Entity app = createAndStartApplication(loadYaml("test-webapp-with-averaging-enricher.yaml"));	waitForApplicationTasks(app);	
started 

========================= brooklyn sample_30 =========================

public void install() {	
installing node js 

========================= brooklyn sample_210 =========================

public static String getRootPassword(Entity entity) {	String password = entity.config().get(MongoDBAuthenticationMixins.ROOT_PASSWORD);	if (Strings.isEmpty(password)) {	
has no password specified for using a random string 

========================= brooklyn sample_355 =========================

public synchronized void add(T item) {	if (items.containsKey(item.getId())) {	throw new IllegalStateException("Already contains item for "+item.getId()+" (adding "+item+")");	}	if (!items.isEmpty() && items.size()%100==0) {	
creating new camp item in had 

========================= brooklyn sample_1818 =========================

public void setEntity(final EntityLocal entity) {	checkArgument(entity instanceof MemberReplaceable, "ServiceReplacer must take a MemberReplaceable, not %s", entity);	Sensor<?> failureSensorToMonitor = checkNotNull(getConfig(FAILURE_SENSOR_TO_MONITOR), "failureSensorToMonitor");	super.setEntity(entity);	subscriptions().subscribeToMembers((Group)entity, failureSensorToMonitor, new SensorEventListener<Object>() {	if (isRunning()) {	highlightViolation("Failure detected");	
servicereplacer notified dispatching job for 

checkArgument(entity instanceof MemberReplaceable, "ServiceReplacer must take a MemberReplaceable, not %s", entity);	Sensor<?> failureSensorToMonitor = checkNotNull(getConfig(FAILURE_SENSOR_TO_MONITOR), "failureSensorToMonitor");	super.setEntity(entity);	subscriptions().subscribeToMembers((Group)entity, failureSensorToMonitor, new SensorEventListener<Object>() {	if (isRunning()) {	highlightViolation("Failure detected");	((EntityInternal)entity).getExecutionContext().submit(MutableMap.of(), new Runnable() {	onDetectedFailure(event);	}});	} else {	
servicereplacer not running so not acting on failure detected at child of 

protected synchronized void onDetectedFailure(SensorEvent<Object> event) {	final Entity failedEntity = event.getSource();	final Object reason = event.getValue();	String violationText = "Failure detected at "+failedEntity+(reason!=null ? " ("+reason+")" : "");	if (isSuspended()) {	highlightViolation(violationText+" but policy is suspended");	
servicereplacer suspended so not acting on failure detected at child of 

for (Iterator<Long> iter = consecutiveReplacementFailureTimes.iterator(); iter.hasNext();) {	Long timestamp = iter.next();	if (timestamp < oldestPermitted) {	iter.remove();	} else {	break;	}	}	if (consecutiveReplacementFailureTimes.size() >= failOnNumRecurringFailures) {	highlightViolation(violationText+" but too many recent failures detected: " + consecutiveReplacementFailureTimes.size()+" in "+failOnRecurringFailuresInThisDuration+" exceeds limit of "+failOnNumRecurringFailures);	
servicereplacer not acting on failure detected at child of because too many recent replacement failures 

iter.remove();	} else {	break;	}	}	if (consecutiveReplacementFailureTimes.size() >= failOnNumRecurringFailures) {	highlightViolation(violationText+" but too many recent failures detected: " + consecutiveReplacementFailureTimes.size()+" in "+failOnRecurringFailuresInThisDuration+" exceeds limit of "+failOnNumRecurringFailures);	return;	}	highlightViolation(violationText+", triggering restart");	
servicereplacer acting on failure detected at child of 

return;	}	highlightViolation(violationText+", triggering restart");	Task<?> t = ((EntityInternal)entity).getExecutionContext().submit(MutableMap.of(), new Runnable() {	public void run() {	try {	Entities.invokeEffectorWithArgs(entity, entity, MemberReplaceable.REPLACE_MEMBER, failedEntity.getId()).get();	consecutiveReplacementFailureTimes.clear();	} catch (Exception e) {	if (Exceptions.getFirstThrowableOfType(e, StopFailedRuntimeException.class) != null) {	
servicereplacer ignoring error reported from stopping failed node 

protected void onReplacementFailed(String msg) {	
servicereplacer failed for 

========================= brooklyn sample_3063 =========================

for (Entity member : serverPool.getMembers()) {	assertHttpStatusCodeEquals(member.getAttribute(WebAppService.ROOT_URL), 200);	}	assertHttpStatusCodeEquals(nginx.getAttribute(WebAppService.ROOT_URL), 200);	}});	WebAppMonitor monitor = new WebAppMonitor(nginx.getAttribute(WebAppService.ROOT_URL)) .logFailures(log) .delayMillis(0);	Thread t = new Thread(monitor);	t.start();	try {	Thread.sleep(1*1000);	
service continuity test startup requests made 

}});	WebAppMonitor monitor = new WebAppMonitor(nginx.getAttribute(WebAppService.ROOT_URL)) .logFailures(log) .delayMillis(0);	Thread t = new Thread(monitor);	t.start();	try {	Thread.sleep(1*1000);	monitor.assertAttemptsMade(10, "startup").assertNoFailures("startup").resetCounts();	for (int i=0; i<20; i++) {	nginx.reload();	Thread.sleep(500);	
service continuity test iteration requests made 

final String jbossUrl = Iterables.get(serverPool.getMembers(), 0).getAttribute(WebAppService.ROOT_URL);	Thread t = new Thread(new Runnable() {	public void run() {	long lastReportTime = System.currentTimeMillis();	int num = 0;	while (true) {	try {	num++;	int code = HttpTestUtils.getHttpStatusCode(nginxUrl);	if (code!=200) log.info("NGINX GOT: "+code);	
nginx got 

Thread t = new Thread(new Runnable() {	public void run() {	long lastReportTime = System.currentTimeMillis();	int num = 0;	while (true) {	try {	num++;	int code = HttpTestUtils.getHttpStatusCode(nginxUrl);	if (code!=200) log.info("NGINX GOT: "+code);	if (System.currentTimeMillis()>=lastReportTime+1000) {	
nginx did requests in last ms 

while (true) {	try {	num++;	int code = HttpTestUtils.getHttpStatusCode(nginxUrl);	if (code!=200) log.info("NGINX GOT: "+code);	if (System.currentTimeMillis()>=lastReportTime+1000) {	num=0;	lastReportTime = System.currentTimeMillis();	}	} catch (Exception e) {	
nginx got 

t.start();	Thread t2 = new Thread(new Runnable() {	public void run() {	long lastReportTime = System.currentTimeMillis();	int num = 0;	while (true) {	try {	num++;	int code = HttpTestUtils.getHttpStatusCode(jbossUrl);	if (code!=200) log.info("JBOSS GOT: "+code);	
jboss got 

Thread t2 = new Thread(new Runnable() {	public void run() {	long lastReportTime = System.currentTimeMillis();	int num = 0;	while (true) {	try {	num++;	int code = HttpTestUtils.getHttpStatusCode(jbossUrl);	if (code!=200) log.info("JBOSS GOT: "+code);	if (System.currentTimeMillis()>=1000+lastReportTime) {	
jboss did requests in last ms 

while (true) {	try {	num++;	int code = HttpTestUtils.getHttpStatusCode(jbossUrl);	if (code!=200) log.info("JBOSS GOT: "+code);	if (System.currentTimeMillis()>=1000+lastReportTime) {	num=0;	lastReportTime = System.currentTimeMillis();	}	} catch (Exception e) {	
jboss got 

public void testCanRestart() {	nginx = app.createAndManageChild(EntitySpec.create(NginxController.class) .configure("serverPool", serverPool) .configure("domain", "localhost") .configure("portNumberSensor", WebAppService.HTTP_PORT));	app.start(ImmutableList.of(localLoc));	Asserts.succeedsEventually(new Runnable() {	public void run() {	assertTrue(nginx.getAttribute(SoftwareProcess.SERVICE_UP));	}});	
started will restart soon 

public void run() {	assertTrue(nginx.getAttribute(SoftwareProcess.SERVICE_UP));	}});	Time.sleep(Duration.ONE_SECOND);	nginx.restart();	Time.sleep(Duration.ONE_SECOND);	Asserts.succeedsEventually(new Runnable() {	public void run() {	assertTrue(nginx.getAttribute(SoftwareProcess.SERVICE_UP));	}});	
restarted and got service up 

========================= brooklyn sample_139 =========================

protected abstract String inferProtocol();	protected abstract String inferUrl();	protected void addServerPoolMemberTrackingPolicy() {	Group serverPool = getServerPool();	if (serverPool == null) {	return;	}	if (serverPoolMemberTrackerPolicy != null) {	
call to addserverpoolmembertrackingpolicy when serverpoolmembertrackingpolicy already exists removing and re adding in 

protected void addServerPoolMemberTrackingPolicy() {	Group serverPool = getServerPool();	if (serverPool == null) {	return;	}	if (serverPoolMemberTrackerPolicy != null) {	removeServerPoolMemberTrackingPolicy();	}	for (Policy p: policies()) {	if (p instanceof ServerPoolMemberTrackerPolicy) {	
picking up as the tracker already set often due to rebind 

AttributeSensor<?> hostAndPortSensor = getConfig(HOST_AND_PORT_SENSOR);	AttributeSensor<?> hostnameSensor = getConfig(HOSTNAME_SENSOR);	AttributeSensor<?> portSensor = getConfig(PORT_NUMBER_SENSOR);	Set<AttributeSensor<?>> sensorsToTrack;	if (hostAndPortSensor != null) {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostAndPortSensor);	} else {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostnameSensor, portSensor);	}	serverPoolMemberTrackerPolicy = policies().add(PolicySpec.create(ServerPoolMemberTrackerPolicy.class) .displayName("Controller targets tracker") .configure("group", serverPool) .configure("sensorsToTrack", sensorsToTrack));	
added policy to 

Set<AttributeSensor<?>> sensorsToTrack;	if (hostAndPortSensor != null) {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostAndPortSensor);	} else {	sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostnameSensor, portSensor);	}	serverPoolMemberTrackerPolicy = policies().add(PolicySpec.create(ServerPoolMemberTrackerPolicy.class) .displayName("Controller targets tracker") .configure("group", serverPool) .configure("sensorsToTrack", sensorsToTrack));	Map<Entity,String> serverPoolTargets = Maps.newLinkedHashMap();	for (Entity member : serverPool.getMembers()) {	if (belongsInServerPool(member)) {	
done checkentity 

sensorsToTrack = ImmutableSet.<AttributeSensor<?>>of(hostnameSensor, portSensor);	}	serverPoolMemberTrackerPolicy = policies().add(PolicySpec.create(ServerPoolMemberTrackerPolicy.class) .displayName("Controller targets tracker") .configure("group", serverPool) .configure("sensorsToTrack", sensorsToTrack));	Map<Entity,String> serverPoolTargets = Maps.newLinkedHashMap();	for (Entity member : serverPool.getMembers()) {	if (belongsInServerPool(member)) {	String address = getAddressOfEntity(member);	serverPoolTargets.put(member, address);	}	}	
resetting server pool targets 

protected abstract void reconfigureService();	public void updateNeeded() {	synchronized (mutex) {	if (updateNeeded) return;	updateNeeded = true;	
queueing an update needed task for update will occur shortly 

public Task<?> updateAsync() {	synchronized (mutex) {	Task<?> result = null;	if (!isActive()) updateNeeded = true;	else {	updateNeeded = false;	
updating in response to changes 

public Task<?> updateAsync() {	synchronized (mutex) {	Task<?> result = null;	if (!isActive()) updateNeeded = true;	else {	updateNeeded = false;	
updating server pool targets 

public Task<?> updateAsync() {	synchronized (mutex) {	Task<?> result = null;	if (!isActive()) updateNeeded = true;	else {	updateNeeded = false;	reconfigureService();	
reloading in response to changes 

protected void onServerPoolMemberChanged(Entity member) {	synchronized (mutex) {	
for considering membership of which is in locations 

protected void onServerPoolMemberChanged(Entity member) {	synchronized (mutex) {	if (belongsInServerPool(member)) {	addServerPoolMember(member);	} else {	removeServerPoolMember(member);	}	
done checkentity 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	
members of checking eliminating because not up 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getServerPool().getMembers().contains(member)) {	
members of checking eliminating because not member 

protected boolean belongsInServerPool(Entity member) {	if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {	return false;	}	if (!getServerPool().getMembers().contains(member)) {	return false;	}	
members of checking approving 

protected void addServerPoolMember(Entity member) {	synchronized (mutex) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	
ignoring unchanged address 

protected void addServerPoolMember(Entity member) {	synchronized (mutex) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	
removing from member with old address because inferred address is now null 

protected void addServerPoolMember(Entity member) {	synchronized (mutex) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	} else {	if (oldAddress != null) {	
replacing in member with old address new address 

protected void addServerPoolMember(Entity member) {	synchronized (mutex) {	String oldAddress = getAttribute(SERVER_POOL_TARGETS).get(member);	String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	} else {	if (oldAddress != null) {	} else {	
adding to new member with address 

String newAddress = getAddressOfEntity(member);	if (Objects.equal(newAddress, oldAddress)) {	return;	} else if (newAddress == null) {	} else {	if (oldAddress != null) {	} else {	}	}	if (Objects.equal(oldAddress, newAddress)) {	
for ignoring change in member because address still 

protected void removeServerPoolMember(Entity member) {	synchronized (mutex) {	if (!getAttribute(SERVER_POOL_TARGETS).containsKey(member)) {	
for not removing as don t have member 

protected void removeServerPoolMember(Entity member) {	synchronized (mutex) {	if (!getAttribute(SERVER_POOL_TARGETS).containsKey(member)) {	return;	}	String address = MapAttribute.remove(this, SERVER_POOL_TARGETS, member);	
removing from member with address 

protected String getAddressOfEntity(Entity member) {	AttributeSensor<String> hostAndPortSensor = getHostAndPortSensor();	if (hostAndPortSensor != null) {	String result = member.getAttribute(hostAndPortSensor);	if (result != null) {	return result;	} else {	
no host port set for using attribute skipping in 

return result;	} else {	return null;	}	} else {	String ip = member.getAttribute(getHostnameSensor());	Integer port = member.getAttribute(getPortNumberSensor());	if (ip!=null && port!=null) {	return ip+":"+port;	}	
unable to construct hostname port representation for skipping in 

========================= brooklyn sample_206 =========================

public void testMachineUsableAfterRebindRepeatedly() throws Exception {	try {	testMachineUsableAfterRebind();	} catch (Exception e) {	
test failed 

========================= brooklyn sample_656 =========================

public void setEntity(final EntityLocal entity) {	super.setEntity(entity);	executor.scheduleAtFixedRate(new Runnable() {	try {	long time = System.currentTimeMillis();	double val = getRequiredConfig(SIN_AMPLITUDE) * (1 + Math.sin( (1.0*time) / getRequiredConfig(SIN_PERIOD_MS) * Math.PI * 2  - Math.PI/2 )) / 2;	entity.sensors().set(getRequiredConfig(TARGET), val);	} catch (Throwable t) {	
error generating sinusoidal load metric 

========================= brooklyn sample_26 =========================

String message = "Populating catalog for "+nodeState+", needsInitial="+needsInitialItemsLoaded+", needsAdditional="+needsAdditionsLoaded+", explicitItems="+(optionalExplicitItemsForResettingCatalog==null ? "null" : optionalExplicitItemsForResettingCatalog.size())+"; from "+JavaClassNames.callerNiceClassAndMethod(1);	if (!ManagementNodeState.isHotProxy(nodeState)) {	log.debug(message);	} else {	log.trace(message);	}	}	synchronized (populatingCatalogMutex) {	try {	if (hasRunFinalInitialization() && (needsInitialItemsLoaded || needsAdditionsLoaded)) {	
catalog initialization called to populate initial even though it has already run the final official initialization 

try {	if (hasRunFinalInitialization() && (needsInitialItemsLoaded || needsAdditionsLoaded)) {	}	isPopulating = true;	BasicBrooklynCatalog catalog = (BasicBrooklynCatalog) managementContext.getCatalog();	if (!catalog.getCatalog().isLoaded()) {	catalog.load();	} else {	if (needsInitialItemsLoaded && hasRunAnyInitialization()) {	if (hasRunTransientOfficialInitialization) {	
catalog initialization now populating but has noted a previous official run which was not final probalby loaded while in a standby mode or a previous run failed overwriting any items installed earlier 

if (hasRunFinalInitialization() && (needsInitialItemsLoaded || needsAdditionsLoaded)) {	}	isPopulating = true;	BasicBrooklynCatalog catalog = (BasicBrooklynCatalog) managementContext.getCatalog();	if (!catalog.getCatalog().isLoaded()) {	catalog.load();	} else {	if (needsInitialItemsLoaded && hasRunAnyInitialization()) {	if (hasRunTransientOfficialInitialization) {	} else {	
catalog initialization now populating but has noted a previous unofficial run it may have been an early web request overwriting any items installed earlier 

} else {	}	catalog.reset(ImmutableList.<CatalogItem<?,?>>of());	}	}	populateCatalogImpl(catalog, needsInitialItemsLoaded, needsAdditionsLoaded, optionalExplicitItemsForResettingCatalog);	if (nodeState == ManagementNodeState.MASTER) {	hasRunFinalInitialization = true;	}	} catch (Throwable e) {	
error populating catalog rethrowing 

public void handleException(Throwable throwable, Object details) {	if (throwable instanceof InterruptedException) throw new RuntimeInterruptedException((InterruptedException) throwable);	if (throwable instanceof RuntimeInterruptedException) throw (RuntimeInterruptedException) throwable;	if (details instanceof CatalogItem) {	if (((CatalogItem<?,?>)details).getCatalogItemId() != null) {	details = ((CatalogItem<?,?>)details).getCatalogItemId();	}	}	PropagatedRuntimeException wrap = new PropagatedRuntimeException("Error loading catalog item "+details, throwable);	log.warn(Exceptions.collapseText(wrap));	
trace for 

========================= brooklyn sample_1361 =========================

public void testConfigParameterInSubInheritsDefaultFromYaml() throws Exception {	addCatalogItems( "brooklyn.catalog:", "  itemType: entity", "  items:", "  - id: entity-with-keys", "    item:", "      type: "+TestEntity.class.getName(), "      brooklyn.parameters:", "      - name: my.param.key", "        type: string", "        description: description one", "        default: myDefaultVal", "      brooklyn.config:", "        key2: $brooklyn:config(\"my.param.key\")");	addCatalogItems( "brooklyn.catalog:", "  itemType: entity", "  items:", "  - id: wrapper-entity", "    item:", "      brooklyn.parameters:", "      - name: my.param.key", "        description: description two", "      type: entity-with-keys", "      brooklyn.config:", "        key3: $brooklyn:config(\"my.param.key\")", "        key3.from.root: $brooklyn:scopeRoot().config(\"my.param.key\")");	String yaml = Joiner.on("\n").join( "services:", "- type: wrapper-entity", "  brooklyn.config:", "    key4: $brooklyn:config(\"my.param.key\")", "    key4.from.root: $brooklyn:scopeRoot().config(\"my.param.key\")");	Entity app = createStartWaitAndLogApplication(yaml);	final TestEntity entity = (TestEntity) Iterables.getOnlyElement(app.getChildren());	
config keys declared on 

public void testManuallyAdd() throws Exception {	String yaml = Joiner.on("\n").join( "services:", "- type: "+TestEntity.class.getName());	Entity app = createStartWaitAndLogApplication(yaml);	TestEntity entity1 = (TestEntity) Iterables.getOnlyElement(app.getChildren());	TestEntity entity2 = entity1.addChild(EntitySpec.create(TestEntity.class));	entity2.start(Collections.<Location>emptyList());	Entities.dumpInfo(app);	
keys 

public void testManuallyAdd() throws Exception {	String yaml = Joiner.on("\n").join( "services:", "- type: "+TestEntity.class.getName());	Entity app = createStartWaitAndLogApplication(yaml);	TestEntity entity1 = (TestEntity) Iterables.getOnlyElement(app.getChildren());	TestEntity entity2 = entity1.addChild(EntitySpec.create(TestEntity.class));	entity2.start(Collections.<Location>emptyList());	Entities.dumpInfo(app);	
keys 

Entity app = createStartWaitAndLogApplication(yaml);	final TestEntity entity1 = (TestEntity) Iterables.getOnlyElement(app.getChildren());	TestEntity entity2 = entity1.getExecutionContext().submit(new Callable<TestEntity>() {	public TestEntity call() {	TestEntity entity2 = entity1.addChild(EntitySpec.create(TestEntity.class));	entity2.start(Collections.<Location>emptyList());	return entity2;	}	}).get();	Entities.dumpInfo(app);	
keys 

Entity app = createStartWaitAndLogApplication(yaml);	final TestEntity entity1 = (TestEntity) Iterables.getOnlyElement(app.getChildren());	TestEntity entity2 = entity1.getExecutionContext().submit(new Callable<TestEntity>() {	public TestEntity call() {	TestEntity entity2 = entity1.addChild(EntitySpec.create(TestEntity.class));	entity2.start(Collections.<Location>emptyList());	return entity2;	}	}).get();	Entities.dumpInfo(app);	
keys 

========================= brooklyn sample_1674 =========================

for (CreationResult<? extends Application, Void> t : tests) {	t.blockUntilComplete();	}	boolean isInteractive = Boolean.getBoolean("test.framework.interactive");	if (isInteractive) {	boolean hasFailed = false;	for (CreationResult<? extends Application, Void> t : tests) {	hasFailed = hasFailed || t.task().isError();	}	if (hasFailed) {	
the test failed blocking until user unmanages all entities 

========================= brooklyn sample_2408 =========================

public void testFailOnNonZero() {	ScriptHelper h = new ScriptHelper(newMockRunner(106), "mock");	boolean succeededWhenShouldntHave = false;	try {	h.body.append("ignored"). failOnNonZeroResultCode(). execute();	succeededWhenShouldntHave = true;	} catch (Exception e) {	
scripthelper non zero causes return code 

========================= brooklyn sample_2234 =========================

public void testFeedDeDupe() throws Exception {	testPollsAndParsesHttpGetResponse();	entity.addFeed(feed);	
feed is 

public void testFeedDeDupe() throws Exception {	testPollsAndParsesHttpGetResponse();	entity.addFeed(feed);	testPollsAndParsesHttpGetResponse();	
feed is 

public void testStartSuspended() throws Exception {	feed = HttpFeed.builder() .entity(entity) .baseUrl(baseUrl) .poll(HttpPollConfig.forSensor(SENSOR_INT) .period(100) .onSuccess(HttpValueFunctions.responseCode())) .poll(HttpPollConfig.forSensor(SENSOR_STRING) .period(100) .onSuccess(HttpValueFunctions.stringContentsFunction())) .suspended() .build();	Asserts.continually(MutableMap.of("timeout", 500), Entities.attributeSupplier(entity, SENSOR_INT), Predicates.<Integer>equalTo(null));	int countWhenSuspended = server.getRequestCount();	feed.resume();	Asserts.eventually(Entities.attributeSupplier(entity, SENSOR_INT), Predicates.<Integer>equalTo(200));	if (server.getRequestCount() <= countWhenSuspended) Assert.fail("Request count failed to increment when feed was resumed, from "+countWhenSuspended+", still at "+server.getRequestCount());	
run 

========================= brooklyn sample_986 =========================

public static SensorEventListener listenerFromValueClosure(final Closure code) {	
use of groovy lang closure is deprecated in policies listenerfromvalueclosure 

public static <T> Policy newSingleSensorValuePolicy(final Sensor<T> sensor, final Closure code) {	
use of groovy lang closure is deprecated in policies newsinglesensorvaluepolicy 

public static <S,T> Policy newSingleSensorValuePolicy(final Entity remoteEntity, final Sensor<T> remoteSensor, final Closure code) {	
use of groovy lang closure is deprecated in policies newsinglesensorvaluepolicy 

========================= brooklyn sample_1418 =========================

private static void checkCallAllowed(Method m) {	DslAccessible dslAccessible = m.getAnnotation(DslAccessible.class);	boolean isAnnotationAllowed = dslAccessible != null;	if (isAnnotationAllowed) return;	Class<?> clazz = m.getDeclaringClass();	Package whiteListPackage = BrooklynDslCommon.class.getPackage();	boolean isPackageAllowed = (clazz.getPackage() != null && clazz.getPackage().getName().startsWith(whiteListPackage.getName()));	if (isPackageAllowed) {	if (DEPRECATED_ACCESS_WARNINGS.add(m)) {	
deprecated since the method called by dsl should be white listed using the annotation support for dsl callable methods under the will be fremoved in a future release 

========================= brooklyn sample_1766 =========================

protected HttpResponse sendRequest(HttpUriRequest request, boolean consumeResponse) throws ClientProtocolException, IOException {	
geoscaling request 

protected HttpResponse sendRequest(HttpUriRequest request, boolean consumeResponse) throws ClientProtocolException, IOException {	HttpResponse response = httpClient.execute(request);	
geoscaling response 

========================= brooklyn sample_251 =========================

public void writeData(String keyspaceName) throws ConnectionException {	AstyanaxContext<Keyspace> context = newAstyanaxContextForKeyspace(keyspaceName);	try {	Keyspace keyspace = context.getEntity();	try {	checkNull(keyspace.describeKeyspace().getColumnFamily(columnFamilyName), "key space for column family "+columnFamilyName);	} catch (Exception ek) {	
repairing cassandra error by re creating keyspace 

public void writeData(String keyspaceName) throws ConnectionException {	AstyanaxContext<Keyspace> context = newAstyanaxContextForKeyspace(keyspaceName);	try {	Keyspace keyspace = context.getEntity();	try {	checkNull(keyspace.describeKeyspace().getColumnFamily(columnFamilyName), "key space for column family "+columnFamilyName);	} catch (Exception ek) {	try {	
dropping cassandra keyspace 

public void writeData(String keyspaceName) throws ConnectionException {	AstyanaxContext<Keyspace> context = newAstyanaxContextForKeyspace(keyspaceName);	try {	Keyspace keyspace = context.getEntity();	try {	checkNull(keyspace.describeKeyspace().getColumnFamily(columnFamilyName), "key space for column family "+columnFamilyName);	} catch (Exception ek) {	try {	keyspace.dropKeyspace();	} catch (Exception e) {	
cassandra keyspace could not be dropped probably did not exist 

try {	checkNull(keyspace.describeKeyspace().getColumnFamily(columnFamilyName), "key space for column family "+columnFamilyName);	} catch (Exception ek) {	try {	keyspace.dropKeyspace();	} catch (Exception e) {	}	try {	keyspace.createKeyspace(ImmutableMap.<String, Object>builder() .put("strategy_options", ImmutableMap.<String, Object>of("replication_factor", "1")) .put("strategy_class", "SimpleStrategy") .build());	} catch (SchemaDisagreementException e) {	
error creating cassandra keyspace retrying 

public String writeData(String keyspacePrefix, int numRetries) throws ConnectionException {	int retryCount = 0;	while (true) {	try {	String keyspaceName = keyspacePrefix + (retryCount > 0 ? "" : "_"+retryCount);	writeData(keyspaceName);	return keyspaceName;	} catch (Exception e) {	
error writing data attempt of 

public void readData(String keyspaceName, int numRetries) throws ConnectionException {	int retryCount = 0;	while (true) {	try {	readData(keyspaceName);	return;	} catch (Exception e) {	
error reading data attempt of 

========================= brooklyn sample_314 =========================

else if (os.getFamily().equals(OsFamily.RHEL)) score += 1;	else if (os.getFamily().equals(OsFamily.AMZN_LINUX)) score += 1;	else if (os.getFamily().equals(OsFamily.DEBIAN)) score += 1;	else if (os.getFamily().equals(OsFamily.WINDOWS)) score -= 1;	if ("softlayer".equals(cloudProviderName)) {	if (img.getId().toLowerCase().contains(os.getFamily().toString().toLowerCase())) score += 0.5;	}	}	if (os.is64Bit()) score += 0.5;	}	
initial score for 

protected double punishmentForDeprecation(Image img) {	String deprecated = img.getUserMetadata().get("deprecatedState");	if (deprecated!=null) {	if ("deprecated".equalsIgnoreCase(deprecated)) return -30;	if ("obsolete".equalsIgnoreCase(deprecated)) return -40;	
unrecognised deprecatedstate value when scoring ignoring that metadata 

========================= brooklyn sample_2633 =========================

server.registerMBean(new NamingService(jmxPort), naming);	Object proxy = MBeanServerInvocationHandler.newProxyInstance(server, naming, NamingServiceMBean.class, false);	namingServiceMBean = (NamingServiceMBean) proxy;	for (int i=0; ; i++) {	try {	namingServiceMBean.start();	break;	} catch (Exception e) {	if (i==0) logger.warn("JmxService couldn't start test mbean ("+e+"); will delay and retry");	else if (i>=180) {	
jmxservice couldn t start test mbean definitive throwing 

namingServiceMBean = (NamingServiceMBean) proxy;	for (int i=0; ; i++) {	try {	namingServiceMBean.start();	break;	} catch (Exception e) {	if (i==0) logger.warn("JmxService couldn't start test mbean ("+e+"); will delay and retry");	else if (i>=180) {	throw e;	} else {	
jmxservice couldn t start test mbean on retry attempt will continue retrying 

} catch (Exception e) {	if (i==0) logger.warn("JmxService couldn't start test mbean ("+e+"); will delay and retry");	else if (i>=180) {	throw e;	} else {	}	Thread.sleep(1000);	}	}	connectorServer.start();	
jmx tester service started at url 

} else {	}	Thread.sleep(1000);	}	}	connectorServer.start();	} catch (Exception e) {	try {	shutdown();	} catch (Exception e2) {	
error shutting down jmxservice after error during startup rethrowing original error 

public void shutdown() throws IOException {	if (connectorServer != null) connectorServer.stop();	if (namingServiceMBean != null) namingServiceMBean.stop();	if (server != null) MBeanServerFactory.releaseMBeanServer(server);	connectorServer = null;	namingServiceMBean = null;	server = null;	
jmx tester service stopped 

========================= brooklyn sample_2214 =========================

protected void addUser(Entity entity, SshMachineLocation machine) {	boolean grantSudo = getRequiredConfig(GRANT_SUDO);	boolean resetPassword = getRequiredConfig(RESET_LOGIN_USER);	String user = getRequiredConfig(VM_USERNAME);	String password = Identifiers.makeRandomId(12);	String hostname = machine.getAddress().getHostName();	int port = machine.getPort();	String creds = user + " : " + password + " @ " +hostname + ":" + port;	
adding auto generated user 

========================= brooklyn sample_2644 =========================

reuseFramework = true;	synchronized (OSGI_FRAMEWORK_CONTAINERS_FOR_REUSE) {	if (!OSGI_FRAMEWORK_CONTAINERS_FOR_REUSE.isEmpty()) {	framework = OSGI_FRAMEWORK_CONTAINERS_FOR_REUSE.remove(0);	}	}	if (framework!=null) {	if (!REUSED_FRAMEWORKS_ARE_KEPT_RUNNING) {	framework.start();	}	
reusing osgi framework container from for mgmt node 

}	if (framework!=null) {	if (!REUSED_FRAMEWORKS_ARE_KEPT_RUNNING) {	framework.start();	}	return;	}	osgiFrameworkCacheDir = Os.newTempDir("brooklyn-osgi-reusable-container");	Os.deleteOnExitRecursively(osgiFrameworkCacheDir);	if (numberOfReusableFrameworksCreated.incrementAndGet()%10==0) {	
possible leak of reusable osgi containers total 

return;	}	osgiFrameworkCacheDir = Os.newTempDir("brooklyn-osgi-reusable-container");	Os.deleteOnExitRecursively(osgiFrameworkCacheDir);	if (numberOfReusableFrameworksCreated.incrementAndGet()%10==0) {	}	} else {	osgiFrameworkCacheDir = BrooklynServerPaths.getOsgiCacheDirCleanedIfNeeded(mgmt);	}	framework = Osgis.getFramework(osgiFrameworkCacheDir.getAbsolutePath(), false);	
osgi framework container created in mgmt node reusable total 

public void stop() {	if (reuseFramework) {	for (Bundle b: framework.getBundleContext().getBundles()) {	if (!bundlesAtStartup.contains(b)) {	try {	
uninstalling from osgi container in 

public void stop() {	if (reuseFramework) {	for (Bundle b: framework.getBundleContext().getBundles()) {	if (!bundlesAtStartup.contains(b)) {	try {	b.uninstall();	} catch (BundleException e) {	Exceptions.propagateIfFatal(e);	
unable to uninstall container in will not be reused 

OSGI_FRAMEWORK_CONTAINERS_FOR_REUSE.add(framework);	}	} else if (BrooklynServerPaths.isOsgiCacheForCleaning(mgmt, osgiFrameworkCacheDir)) {	final AtomicReference<DeletionResult> deletionResult = new AtomicReference<DeletionResult>();	Repeater.create("Delete OSGi cache dir") .until(new Callable<Boolean>() {	public Boolean call() {	deletionResult.set(Os.deleteRecursively(osgiFrameworkCacheDir));	return deletionResult.get().wasSuccessful();	}}) .limitTimeTo(Duration.ONE_SECOND) .backoffTo(Duration.millis(50)) .run();	if (deletionResult.get().getThrowable()!=null) {	
unable to delete possibly being modified concurrently 

public ReferenceWithError<OsgiBundleInstallationResult> install(@Nullable ManagedBundle knownBundleMetadata, @Nullable InputStream zipIn, boolean start, boolean loadCatalogBom, boolean forceUpdateOfNonSnapshots) {	
installing bundle from stream known details 

private Bundle checkBundleInstalledThrowIfInconsistent(OsgiBundleWithUrl bundleMetadata, boolean requireUrlIfNotAlreadyPresent) {	String bundleUrl = bundleMetadata.getUrl();	if (bundleUrl != null) {	Maybe<Bundle> installedBundle = Osgis.bundleFinder(framework).requiringFromUrl(bundleUrl).find();	if (installedBundle.isPresent()) {	Bundle b = installedBundle.get();	String nv = b.getSymbolicName()+":"+b.getVersion().toString();	if (!isBundleNameEqualOrAbsent(bundleMetadata, b)) {	throw new IllegalStateException("User requested bundle " + bundleMetadata + " but already installed as "+nv);	} else {	
bundle from already installed as not re registering 

return b;	}	} else {	Maybe<Bundle> installedBundle;	if (bundleMetadata.isNameResolved()) {	installedBundle = Osgis.bundleFinder(framework).symbolicName(bundleMetadata.getSymbolicName()).version(bundleMetadata.getSuppliedVersionString()).find();	} else {	installedBundle = Maybe.absent("Bundle metadata does not have URL nor does it have both name and version");	}	if (installedBundle.isPresent()) {	
bundle installed from 

bundleProblems.put(osgiBundle, e);	Throwable cause = e.getCause();	if (cause != null && cause.getMessage().contains("Unresolved constraint in bundle")) {	if (BrooklynVersion.INSTANCE.getVersionFromOsgiManifest()==null) {	extraMessages.add("No brooklyn-core OSGi manifest available. OSGi will not work.");	}	if (BrooklynVersion.isDevelopmentEnvironment()) {	extraMessages.add("Your development environment may not have created necessary files. Doing a maven build then retrying may fix the issue.");	}	if (!extraMessages.isEmpty()) log.warn(Strings.join(extraMessages, " "));	
unresolved constraint resolving osgi bundle to load 

bundleProblems.put(osgiBundle, e);	Throwable cause = e.getCause();	if (cause != null && cause.getMessage().contains("Unresolved constraint in bundle")) {	if (BrooklynVersion.INSTANCE.getVersionFromOsgiManifest()==null) {	extraMessages.add("No brooklyn-core OSGi manifest available. OSGi will not work.");	}	if (BrooklynVersion.isDevelopmentEnvironment()) {	extraMessages.add("Your development environment may not have created necessary files. Doing a maven build then retrying may fix the issue.");	}	if (!extraMessages.isEmpty()) log.warn(Strings.join(extraMessages, " "));	
trace for osgi resolution failure 

========================= brooklyn sample_1087 =========================

public boolean isValueValid(T value) {	try {	return getConstraint().apply(value);	} catch (Exception e) {	
suppressing exception when testing validity of 

========================= brooklyn sample_1204 =========================

boolean continueOnFailure = Boolean.TRUE.equals(config().get(CONTINUE_ON_FAILURE));	List<Throwable> childErrors = Lists.newArrayList();	for (Entity child : getChildren()) {	Boolean serviceUp = child.sensors().get(Attributes.SERVICE_UP);	if (child instanceof Startable && !Boolean.TRUE.equals(serviceUp)){	try {	((Startable) child).start(locations);	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	if (continueOnFailure) {	
problem starting child continuing and will throw at end 

if (childErrors.size() > 0) {	throw Exceptions.propagate(childErrors);	}	sensors().set(Attributes.SERVICE_UP, true);	ServiceStateLogic.setExpectedState(this, Lifecycle.RUNNING);	} catch (Throwable t) {	Exceptions.propagateIfInterrupt(t);	try {	execOnErrorSpec();	} catch (Throwable t2) {	
problem executing on error for 

sensors().set(Attributes.SERVICE_UP, false);	try {	boolean continueOnFailure = Boolean.TRUE.equals(config().get(CONTINUE_ON_FAILURE));	List<Throwable> childErrors = Lists.newArrayList();	for (Entity child : getChildren()) {	try {	if (child instanceof Startable) ((Startable) child).stop();	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	if (continueOnFailure) {	
problem stopping child continuing and will throw at end 

protected void execOnErrorSpec() {	EntitySpec<?> onErrorSpec = config().get(ON_ERROR_SPEC);	if (onErrorSpec != null) {	
creating and starting on error child entity for 

protected void execOnErrorSpec() {	EntitySpec<?> onErrorSpec = config().get(ON_ERROR_SPEC);	if (onErrorSpec != null) {	Entity onErrorEntity = addChild(onErrorSpec);	if (onErrorEntity instanceof Startable){	((Startable) onErrorEntity).start(getLocations());	}	} else {	
no on error spec for 

========================= brooklyn sample_2428 =========================

return true;	}	});	URLConnection connection = url.openConnection();	TrustingSslSocketFactory.configure(connection);	connection.connect();	connection.getContentLength();	return connection;	} catch (Exception e) {	exception.set(e);	
error connecting to url propagating 

return null;	}	});	try {	URLConnection result = null;	try {	result = f.get(60, TimeUnit.SECONDS);	} catch (InterruptedException e) {	throw e;	} catch (Exception e) {	
error connecting to url probably timed out rethrowing 

try {	URLConnection result = null;	try {	result = f.get(60, TimeUnit.SECONDS);	} catch (InterruptedException e) {	throw e;	} catch (Exception e) {	throw new IllegalStateException("Connect to URL not complete within 60 seconds, for url "+url+": "+e);	}	if (exception.get() != null) {	
error connecting to url thread caller of source of rethrown error 

public static int getHttpStatusCode(String url) throws Exception {	URLConnection connection = connectToUrl(url);	long startTime = System.currentTimeMillis();	int status = ((HttpURLConnection) connection).getResponseCode();	consumeAndCloseQuietly((HttpURLConnection) connection);	
connection to ms gives 

long startTime = System.currentTimeMillis();	String err;	int status;	try {	InputStream errStream = connection.getErrorStream();	err = Streams.readFullyStringAndClose(errStream);	status = connection.getResponseCode();	} finally {	closeQuietly(connection);	}	
read of err ms complete http code 

X509HostnameVerifier hostnameVerifier = SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;	socketFactory = new SSLSocketFactory(trustStrategy, hostnameVerifier);	} else {	}	}	if (socketFactory != null) {	Scheme sch = new Scheme("https", port, socketFactory);	httpClient.getConnectionManager().getSchemeRegistry().register(sch);	}	} catch (Exception e) {	
error setting trust for uri 

} catch (Exception e) {	throw Exceptions.propagate(e);	}	}	if (uri != null && credentials != null) {	String hostname = uri.getHost();	int port = uri.getPort();	httpClient.getCredentialsProvider().setCredentials(new AuthScope(hostname, port), credentials);	}	if (uri==null && credentials!=null) {	
credentials have no effect in builder unless uri for host is specified 

if (request instanceof HttpPost) {	((HttpPost) request).setEntity(this.body);	} else if (request instanceof HttpPut) {	((HttpPut) request).setEntity(this.body);	} else {	throw new Exception(this.requestClass.getSimpleName() + " does not support a request body");	}	}	return request;	} catch (Exception e) {	
cannot create the http request for uri 

========================= brooklyn sample_2078 =========================

public static <T> ConfigKey<T> unprefixedKey(String prefix, ConfigKey<T> key) {	String newName = key.getName();	if (newName.startsWith(prefix)) newName = newName.substring(prefix.length());	
cannot remove prefix from key ignoring 

public static Set<HasConfigKey<?>> getStaticKeysOnClass(Class<?> type) {	Set<HasConfigKey<?>> result = new LinkedHashSet<ConfigKey.HasConfigKey<?>>();	for (Field f: type.getFields()) {	try {	if ((f.getModifiers() & Modifier.STATIC)==0) continue;	if (ConfigKey.class.isAssignableFrom(f.getType())) result.add(new WrappedConfigKey((ConfigKey<?>) f.get(null)));	else if (HasConfigKey.class.isAssignableFrom(f.getType())) result.add((HasConfigKey<?>) f.get(null));	} catch (Exception e) {	
error retrieving config key for field on class rethrowing 

========================= brooklyn sample_1195 =========================

}	((EC2TemplateOptions) t).userData(data.getBytes());	} else if (t instanceof SoftLayerTemplateOptions) {	((SoftLayerTemplateOptions) t).userData(Strings.toString(v));	} else {	Class<? extends TemplateOptions> clazz = t.getClass();	Method userDataMethod = null;	try {	userDataMethod = clazz.getMethod("userData", String.class);	} catch (SecurityException e) {	
problem reflectively inspecting methods of for setting userdata 

} catch (NoSuchMethodException e) {	try {	userDataMethod = clazz.getMethod("guestCustomizationScript", String.class);	} catch (NoSuchMethodException e2) {	}	}	if (userDataMethod != null) {	try {	userDataMethod.invoke(t, Strings.toString(v));	} catch (InvocationTargetException e) {	
problem invoking of for setting userdata rethrowing 

userDataMethod = clazz.getMethod("guestCustomizationScript", String.class);	} catch (NoSuchMethodException e2) {	}	}	if (userDataMethod != null) {	try {	userDataMethod.invoke(t, Strings.toString(v));	} catch (InvocationTargetException e) {	throw Exceptions.propagate(e);	} catch (IllegalAccessException e) {	
unable to reflectively invoke of for setting userdata rethrowing 

}	if (userDataMethod != null) {	try {	userDataMethod.invoke(t, Strings.toString(v));	} catch (InvocationTargetException e) {	throw Exceptions.propagate(e);	} catch (IllegalAccessException e) {	throw Exceptions.propagate(e);	}	} else {	
ignoring userdatastring in vm creation because not supported for cloud type 

========================= brooklyn sample_2613 =========================

public void testSshDateEffector1() {	Task<String> call = Entities.invokeEffector(app, app, GET_REMOTE_DATE_1);	
ssh date gives 

public void testSshDateEffector2() {	Task<String> call = Entities.invokeEffector(app, app, GET_REMOTE_DATE_2);	
ssh date gives 

public void testBadExitCodeCaughtAndStdErrAvailable() {	final ProcessTaskWrapper<?>[] sshTasks = new ProcessTaskWrapper[1];	Task<Void> call = Entities.invokeEffector(app, app, Effectors.effector(Void.class, "badExitCode") .impl(new SshEffectorBody<Void>() {	public Void call(ConfigBag parameters) {	sshTasks[0] = queue( ssh(COMMAND_THAT_DOES_NOT_EXIST).requiringExitCodeZero() );	return null;	}	}).build() );	call.blockUntilEnded();	Assert.assertTrue(call.isError());	
stderr gives 

========================= brooklyn sample_2243 =========================

protected void connectSensors() {	super.connectSensors();	Time.sleep(Duration.TEN_SECONDS);	if (getRole() == Role.UI) {	sensors().set(STORM_UI_URL, "http: }	if (((JavaSoftwareProcessDriver)getDriver()).isJmxEnabled()) {	jmxHelper = new JmxHelper(this);	jmxFeed = JavaAppUtils.connectMXBeanSensors(this);	connectServiceUpIsRunning();	} else {	
storm running without jmx monitoring limited visibility of service available 

========================= brooklyn sample_508 =========================

jmxAgentMode = entity.getConfig(JMX_AGENT_MODE);	if (jmxAgentMode==null) jmxAgentMode = JmxAgentModes.AUTODETECT;	isSecure = entity.getConfig(JMX_SSL_ENABLED);	if (isSecure==null) isSecure = false;	if (jmxAgentMode==JmxAgentModes.AUTODETECT) {	if (isSecure()) {	jmxAgentMode = JmxAgentModes.JMXMP;	} else {	jmxAgentMode = JmxAgentModes.JMXMP_AND_RMI;	if (!ResourceUtils.create(this).doesUrlExist(getJmxAgentJarUrl())) {	
jmx agent jar not found when auto detecting jmx settings for likely cause is an incomplete build e g from eclipse run a maven build then retry in the ide reverting to none use built in java jmx support which will not go through firewalls 

protected int fixPortsForModeNone() {	assert getJmxAgentMode()==JmxAgentModes.NONE;	Integer jmxRemotePort = getEntity().getAttribute(JMX_PORT);	Integer rmiRegistryPort = getEntity().getAttribute(RMI_REGISTRY_PORT);	if (rmiRegistryPort!=null && rmiRegistryPort>0) {	if (jmxRemotePort==null || jmxRemotePort!=rmiRegistryPort) {	if (jmxRemotePort!=null && jmxRemotePort>0) {	
ignoring jmx port when configuring agentless jmx on will use rmi registry port 

public String getJmxAgentJarUrl() {	MavenArtifact artifact = getJmxAgentJarMavenArtifact();	if (artifact==null) throw new IllegalStateException("Either JMX is not enabled or there is an error in the configuration (JMX mode "+getJmxAgentMode()+" does not support agent JAR)");	String jar = "classpath: if (ResourceUtils.create(this).doesUrlExist(jar)) return jar;	String result = MavenRetriever.localUrl(artifact);	if (warnedAboutNotOnClasspath) {	
jmx jar for is not on the classpath taking from 

public String getJmxAgentJarUrl() {	MavenArtifact artifact = getJmxAgentJarMavenArtifact();	if (artifact==null) throw new IllegalStateException("Either JMX is not enabled or there is an error in the configuration (JMX mode "+getJmxAgentMode()+" does not support agent JAR)");	String jar = "classpath: if (ResourceUtils.create(this).doesUrlExist(jar)) return jar;	String result = MavenRetriever.localUrl(artifact);	if (warnedAboutNotOnClasspath) {	} else {	
jmx jar for is not on the classpath taking from subsequent similar messages will be logged at debug 

public void recommendJmxRmiCustomAgent() {	Maybe<Object> jmx = ((EntityInternal)entity).config().getRaw(UsesJmx.JMX_AGENT_MODE);	if (!jmx.isPresentAndNonNull()) {	setConfig(UsesJmx.JMX_AGENT_MODE, JmxAgentModes.JMX_RMI_CUSTOM_AGENT);	} else if (jmx.get()!=JmxAgentModes.JMX_RMI_CUSTOM_AGENT) {	
entity may not function unless running jmx rmi custom agent mode asked to use 

========================= brooklyn sample_2306 =========================

public void addListener(Runnable listener, Executor executor) {	if (!warned) {	
use of deprecated listenableforwardingfuture addlistener at future calls will not be logged stack trace 

========================= brooklyn sample_1480 =========================

protected SshPollValue exec(String command, Map<String,String> env) throws IOException {	SshMachineLocation machine = (SshMachineLocation)getMachine();	Boolean execAsCommand = config().get(EXEC_AS_COMMAND);	
ssh polling for executing with env 

========================= brooklyn sample_1603 =========================

public boolean apply(Object deploymentPlanItem, AssemblyTemplateConstructor atc) {	if (!(deploymentPlanItem instanceof Service)) return false;	String type = lookupType(deploymentPlanItem);	if (type==null) return false;	
item being instantiated with 

public boolean apply(Object deploymentPlanItem, AssemblyTemplateConstructor atc) {	if (!(deploymentPlanItem instanceof Service)) return false;	String type = lookupType(deploymentPlanItem);	if (type==null) return false;	Object old = atc.getInstantiator();	if (old!=null && !old.equals(BrooklynAssemblyTemplateInstantiator.class)) {	
can t mix brooklyn entities with non brooklyn entities at present 

========================= brooklyn sample_1746 =========================

public ObjectMapper locateMapper(Class<?> type, MediaType mediaType) {	if (ourMapper != null) return ourMapper;	findSharedMapper();	if (ourMapper != null) return ourMapper;	if (!notFound) {	
management context not available using default objectmapper in 

protected synchronized ObjectMapper findSharedMapper() {	if (ourMapper != null || notFound) return ourMapper;	ourMapper = findSharedObjectMapper(mgmt());	if (ourMapper == null) return null;	if (notFound) {	notFound = false;	}	
found mapper for creating custom brooklyn mapper 

public static ObjectMapper findSharedObjectMapper(ManagementContext mgmt) {	checkNotNull(mgmt, "mgmt");	synchronized (mgmt) {	ConfigKey<ObjectMapper> key = ConfigKeys.newConfigKey(ObjectMapper.class, BROOKLYN_REST_OBJECT_MAPPER);	ObjectMapper mapper = (ObjectMapper) mgmt.getScratchpad().get(key);	if (mapper != null) return mapper;	mapper = newPrivateObjectMapper(mgmt);	
storing new objectmapper against because no servletcontext available 

========================= brooklyn sample_2869 =========================

}	if (hostname == null && where instanceof MachineLocation) {	Maybe<String> subnetIp = getSubnetIp(where);	if (subnetIp.isPresent()) {	hostname = subnetIp.get();	} else {	InetAddress addr = ((MachineLocation) where).getAddress();	if (addr != null) hostname = addr.getHostAddress();	}	}	
computed subnet hostname for 

if (where instanceof HasNetworkAddresses) {	Set<String> privateAddrs = ((HasNetworkAddresses) where).getPrivateAddresses();	if (privateAddrs.size() > 0) {	result = Iterables.get(privateAddrs, 0);	}	}	if (result == null && where instanceof MachineLocation) {	InetAddress addr = ((MachineLocation) where).getAddress();	if (addr != null) result = addr.getHostAddress();	}	
computed subnet host ip for 

if (items == null) {	return Maybe.absent(new NullPointerException("Null iterable"));	}	Iterator<?> i = items.iterator();	T result = null;	while (i.hasNext()) {	Object candidate = i.next();	if (type.isInstance(candidate)) {	if (result==null) result = (T)candidate;	else {	
multiple instances of in ignoring 

========================= brooklyn sample_1316 =========================

public void testPutAfterUnclosedGet() {	put(OBJECT_NAME_PUT, getContent());	put(OBJECT_NAME_GET, getContent());	for (int i = 1; i <= 50; i++) {	long start = System.currentTimeMillis();	get(OBJECT_NAME_GET);	long afterGet = System.currentTimeMillis();	
get 

long start = System.currentTimeMillis();	get(OBJECT_NAME_GET);	long afterGet = System.currentTimeMillis();	System.gc();	System.gc();	System.gc();	sleep(1000);	long beforePut = System.currentTimeMillis();	put(OBJECT_NAME_PUT, getContent());	long end = System.currentTimeMillis();	
put 

private void put(String name, String content) {	BlobStore blobStore = context.getBlobStore();	byte[] bytes = content.getBytes(Charsets.UTF_8);	Blob blob = blobStore.blobBuilder(name) .payload(ByteSource.wrap(bytes)) .contentLength(bytes.length) .build();	try {	blobStore.putBlob(containerName, blob);	} catch (Exception e) {	
put failed 

private Blob get(String name) {	try {	BlobStore blobStore = context.getBlobStore();	return blobStore.getBlob(containerName, name);	} catch (Exception e) {	
get failed 

========================= brooklyn sample_2490 =========================

private void checkUsable(RegisteredType item) {	if (item.isDisabled()) {	throw new IllegalStateException("Illegal use of disabled catalog item "+item.getSymbolicName()+":"+item.getVersion());	} else if (item.isDeprecated()) {	
use of deprecated catalog item 

========================= brooklyn sample_1183 =========================

protected void doTestRecursiveConfigFailsGracefully(boolean immediate) throws Exception {	String yaml = Joiner.on("\n").join( "services:", "- type: org.apache.brooklyn.core.test.entity.TestEntity", "  brooklyn.config:", "    infinite_loop: $brooklyn:config(\"infinite_loop\")");	final Entity app = createStartWaitAndLogApplication(yaml);	TestEntity entity = (TestEntity) Iterables.getOnlyElement(app.getChildren());	Thread t = new Thread(new Runnable() {	public void run() {	try {	Time.sleep(Duration.FIVE_SECONDS);	
timeout elapsed destroying items usage 

========================= brooklyn sample_1615 =========================

return true;	}	try {	switch (resourceType) {	case OpenShiftResource.DEPLOYMENT_CONFIG: return client.deploymentConfigs().inNamespace(namespace).withName(resourceName).delete();	case OpenShiftResource.PROJECT: return client.projects().withName(resourceName).delete();	case OpenShiftResource.TEMPLATE: return client.templates().inNamespace(namespace).withName(resourceName).delete();	case OpenShiftResource.BUILD_CONFIG: return client.buildConfigs().inNamespace(namespace).withName(resourceName).delete();	}	} catch (KubernetesClientException kce) {	
error deleting resource 

public Boolean call() {	Project actualProject = client.projects().withName(name).get();	return actualProject != null && actualProject.getStatus().getPhase().equals(PHASE_ACTIVE);	}	public String getFailureMessage() {	Project actualProject = client.projects().withName(name).get();	return "Project for " + name + " " + (actualProject == null ? "absent" : " status " + actualProject.getStatus());	}	};	if (project != null) {	
found project returning it 

return actualProject != null && actualProject.getStatus().getPhase().equals(PHASE_ACTIVE);	}	public String getFailureMessage() {	Project actualProject = client.projects().withName(name).get();	return "Project for " + name + " " + (actualProject == null ? "absent" : " status " + actualProject.getStatus());	}	};	if (project != null) {	} else if (create) {	project = client.projects().create(new ProjectBuilder().withNewMetadata().withName(name).endMetadata().build());	
created project 

Integer replicas = (status == null) ? null : status.getAvailableReplicas();	return replicas != null && replicas.intValue() == replicas;	}	public String getFailureMessage() {	DeploymentConfig dc = client.deploymentConfigs().inNamespace(namespace).withName(deploymentName).get();	DeploymentConfigStatus status = (dc == null) ? null : dc.getStatus();	return "Namespace=" + namespace + "; deploymentName= " + deploymentName + "; Deployment=" + dc + "; status=" + status;	}	};	waitForExitCondition(exitCondition);	
deployed to namespace 

========================= brooklyn sample_2469 =========================

public void testEnrichersOnRebindJavaApp() throws Exception {	VanillaJavaApp javaProcess = app.addChild(EntitySpec.create(VanillaJavaApp.class, EnrichedVanillaJavaAppImpl.class) .configure("main", MAIN_CLASS.getCanonicalName()).configure("classpath", ImmutableList.of(BROOKLYN_THIS_CLASSPATH)));	app.start(ImmutableList.of(loc));	EntityAsserts.assertAttributeEventuallyNonNull(javaProcess, EnrichedVanillaJavaAppImpl.AVG1);	EntityAsserts.assertAttributeEventuallyNonNull(javaProcess, EnrichedVanillaJavaAppImpl.AVG2);	
got avg 

public void testEnrichersOnRebindJavaApp() throws Exception {	VanillaJavaApp javaProcess = app.addChild(EntitySpec.create(VanillaJavaApp.class, EnrichedVanillaJavaAppImpl.class) .configure("main", MAIN_CLASS.getCanonicalName()).configure("classpath", ImmutableList.of(BROOKLYN_THIS_CLASSPATH)));	app.start(ImmutableList.of(loc));	EntityAsserts.assertAttributeEventuallyNonNull(javaProcess, EnrichedVanillaJavaAppImpl.AVG1);	EntityAsserts.assertAttributeEventuallyNonNull(javaProcess, EnrichedVanillaJavaAppImpl.AVG2);	rebind();	VanillaJavaApp javaProcess2 = (VanillaJavaApp) Iterables.find(app.getChildren(), Predicates.instanceOf(VanillaJavaApp.class));	EntityAsserts.assertAttributeChangesEventually(javaProcess2, EnrichedVanillaJavaAppImpl.PROCESS_CPU_TIME);	
avg now 

public void testEnrichersOnRebindJavaApp() throws Exception {	VanillaJavaApp javaProcess = app.addChild(EntitySpec.create(VanillaJavaApp.class, EnrichedVanillaJavaAppImpl.class) .configure("main", MAIN_CLASS.getCanonicalName()).configure("classpath", ImmutableList.of(BROOKLYN_THIS_CLASSPATH)));	app.start(ImmutableList.of(loc));	EntityAsserts.assertAttributeEventuallyNonNull(javaProcess, EnrichedVanillaJavaAppImpl.AVG1);	EntityAsserts.assertAttributeEventuallyNonNull(javaProcess, EnrichedVanillaJavaAppImpl.AVG2);	rebind();	VanillaJavaApp javaProcess2 = (VanillaJavaApp) Iterables.find(app.getChildren(), Predicates.instanceOf(VanillaJavaApp.class));	EntityAsserts.assertAttributeChangesEventually(javaProcess2, EnrichedVanillaJavaAppImpl.PROCESS_CPU_TIME);	EntityAsserts.assertAttributeChangesEventually(javaProcess2, EnrichedVanillaJavaAppImpl.AVG1);	EntityAsserts.assertAttributeChangesEventually(javaProcess2, EnrichedVanillaJavaAppImpl.AVG2);	
avg now 

public void onManagementStarted() {	super.onManagementStarted();	
mgmt started for 

protected void connectSensors() {	super.connectSensors();	
connecting sensors for 

========================= brooklyn sample_2193 =========================

public HazelcastInstance getClient() {	HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);	
hazelcast client 

========================= brooklyn sample_322 =========================

public void init() {	super.init();	final Set<? extends String> runList = getConfig(SaltConfig.START_STATES);	if (0 == runList.size()) {	throw new IllegalArgumentException("Must have configuration values for 'start_states' (" + SaltConfig.START_STATES + ")");	}	
run list size is 

public void init() {	super.init();	final Set<? extends String> runList = getConfig(SaltConfig.START_STATES);	if (0 == runList.size()) {	throw new IllegalArgumentException("Must have configuration values for 'start_states' (" + SaltConfig.START_STATES + ")");	}	for (String state : runList) {	
runlist state 

public void init() {	super.init();	final Set<? extends String> runList = getConfig(SaltConfig.START_STATES);	if (0 == runList.size()) {	throw new IllegalArgumentException("Must have configuration values for 'start_states' (" + SaltConfig.START_STATES + ")");	}	for (String state : runList) {	}	final Set<? extends String> formulas = getConfig(SaltConfig.SALT_FORMULAS);	
formulas size 

public void init() {	super.init();	final Set<? extends String> runList = getConfig(SaltConfig.START_STATES);	if (0 == runList.size()) {	throw new IllegalArgumentException("Must have configuration values for 'start_states' (" + SaltConfig.START_STATES + ")");	}	for (String state : runList) {	}	final Set<? extends String> formulas = getConfig(SaltConfig.SALT_FORMULAS);	for (String formula : formulas) {	
formula configured 

final Set<? extends String> runList = getConfig(SaltConfig.START_STATES);	if (0 == runList.size()) {	throw new IllegalArgumentException("Must have configuration values for 'start_states' (" + SaltConfig.START_STATES + ")");	}	for (String state : runList) {	}	final Set<? extends String> formulas = getConfig(SaltConfig.SALT_FORMULAS);	for (String formula : formulas) {	}	SaltConfig.SaltMode mode = getConfig(SaltConfig.SALT_MODE);	
initialize saltstack mode 

========================= brooklyn sample_267 =========================

String path1 = BlobStoreTest.CONTAINER_PREFIX+"-"+Identifiers.makeRandomId(4);	String path2 = BlobStoreTest.CONTAINER_PREFIX+"-"+Identifiers.makeRandomId(4);	String path3 = BlobStoreTest.CONTAINER_PREFIX+"-"+Identifiers.makeRandomId(4);	JcloudsBlobStoreBasedObjectStore store0 = null;	try {	store0 = new JcloudsBlobStoreBasedObjectStore(BlobStoreTest.PERSIST_TO_OBJECT_STORE_FOR_TEST_SPEC, Urls.mergePaths(path1, path2));	store0.injectManagementContext(mgmt);	store0.prepareForSharedUse(PersistMode.CLEAN, HighAvailabilityMode.DISABLED);	newPersistenceStoreObjectAccessor(store0, path3+"/").put("hello world");	} catch (Exception e) {	
failed with 

========================= brooklyn sample_2486 =========================

public void setContainers(Group containerGroup) {	this.containerGroup = containerGroup;	subscriptions().subscribe(containerGroup, AbstractGroup.MEMBER_ADDED, eventHandler);	subscriptions().subscribe(containerGroup, AbstractGroup.MEMBER_REMOVED, eventHandler);	subscriptions().subscribe(null, Movable.CONTAINER, eventHandler);	
scanning entities on container group set 

private void onContainerAdded(Entity newContainer) {	
rescanning entities on container added 

private void onContainerRemoved(Entity oldContainer) {	
rescanning entities on container removed 

protected void onEntityAdded(Entity item) {	if (acceptsEntity(item)) {	
adding new item 

protected void onEntityRemoved(Entity item) {	if (removeMember(item)) {	
removing deleted item 

private void onItemMoved(Movable item, BalanceableContainer container) {	
processing moved item to container 

private void onItemMoved(Movable item, BalanceableContainer container) {	if (hasMember(item)) {	if (!acceptsItem(item, container)) {	
removing moved item from group as new container is not a member 

private void onItemMoved(Movable item, BalanceableContainer container) {	if (hasMember(item)) {	if (!acceptsItem(item, container)) {	removeMember(item);	}	} else {	if (acceptsItem(item, container)) {	
adding moved item to group as new container is a member 

========================= brooklyn sample_3043 =========================

private BrooklynApiUtil() {}	public static TaskSummary deployBlueprint(BrooklynApi api, String blueprint) throws Exception {	Response r = api.getApplicationApi().createFromYaml(blueprint);	if (isUnhealthyResponse(r)) {	throw new Exception("Unexpected response deploying blueprint to server: " + r.getStatus());	} else {	
server response to deploy blueprint 

public static void waitForRunningAndThrowOtherwise(BrooklynApi api, String applicationId, String taskId, Duration timeout) throws IllegalStateException {	Status finalStatus = waitForAppStatus(api, applicationId, Status.RUNNING, timeout, DEFAULT_POLL_PERIOD);	if (!Status.RUNNING.equals(finalStatus)) {	
application is not running is 

public static Status waitForAppStatus(final BrooklynApi api, final String application, final Status desiredStatus, Duration timeout, Duration pollPeriod) {	final AtomicReference<Status> appStatus = new AtomicReference<>(Status.UNKNOWN);	final boolean shortcutOnError = !Status.ERROR.equals(desiredStatus) && !Status.UNKNOWN.equals(desiredStatus);	
waiting from for application to be 

public static Status waitForAppStatus(final BrooklynApi api, final String application, final Status desiredStatus, Duration timeout, Duration pollPeriod) {	final AtomicReference<Status> appStatus = new AtomicReference<>(Status.UNKNOWN);	final boolean shortcutOnError = !Status.ERROR.equals(desiredStatus) && !Status.UNKNOWN.equals(desiredStatus);	Repeater.create("Waiting for application " + application + " status to be " + desiredStatus) .every(pollPeriod) .limitTimeTo(timeout) .rethrowExceptionImmediately() .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	Status status = api.getApplicationApi().get(application).getStatus();	
application status is 

final AtomicReference<Status> appStatus = new AtomicReference<>(Status.UNKNOWN);	final boolean shortcutOnError = !Status.ERROR.equals(desiredStatus) && !Status.UNKNOWN.equals(desiredStatus);	Repeater.create("Waiting for application " + application + " status to be " + desiredStatus) .every(pollPeriod) .limitTimeTo(timeout) .rethrowExceptionImmediately() .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	Status status = api.getApplicationApi().get(application).getStatus();	appStatus.set(status);	return desiredStatus.equals(status) || (shortcutOnError && (Status.ERROR.equals(status) || Status.UNKNOWN.equals(status)));	}	}) .run();	if (appStatus.get().equals(desiredStatus)) {	
application is 

final boolean shortcutOnError = !Status.ERROR.equals(desiredStatus) && !Status.UNKNOWN.equals(desiredStatus);	Repeater.create("Waiting for application " + application + " status to be " + desiredStatus) .every(pollPeriod) .limitTimeTo(timeout) .rethrowExceptionImmediately() .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	Status status = api.getApplicationApi().get(application).getStatus();	appStatus.set(status);	return desiredStatus.equals(status) || (shortcutOnError && (Status.ERROR.equals(status) || Status.UNKNOWN.equals(status)));	}	}) .run();	if (appStatus.get().equals(desiredStatus)) {	} else {	
application is not within status is 

========================= brooklyn sample_6 =========================

protected Collection<Integer> getRequiredOpenPorts() {	Set<Integer> result = Sets.newLinkedHashSet();	result.addAll(getRequiredOpenPorts(entity()));	
getrequiredopenports detected aggregated default for 

private void addRequiredOpenPortsRecursively(Entity entity, Set<Integer> ports) {	ports.addAll(entity.getConfig(SameServerEntity.REQUIRED_OPEN_LOGIN_PORTS));	Boolean portsAutoInfer = entity.getConfig(SameServerEntity.INBOUND_PORTS_AUTO_INFER);	String portsRegex = entity.getConfig(SameServerEntity.INBOUND_PORTS_CONFIG_REGEX);	ports.addAll(InboundPortsUtils.getRequiredOpenPorts(entity, portsAutoInfer, portsRegex));	
getrequiredopenports detected default for 

Exception childException = null;	try {	DynamicTasks.waitForLast();	} catch (Exception e) {	childException = e;	}	try {	children.asTask().get();	} catch (Exception e) {	childException = e;	
error stopping children continuing and will rethrow if no other errors 

========================= brooklyn sample_2347 =========================

public BlobStoreContext newBlobStoreContext(Location location) {	String rawProvider = checkNotNull(location.getConfig(LocationConfigKeys.CLOUD_PROVIDER), "provider must not be null");	String provider = DeserializingJcloudsRenamesProvider.INSTANCE.applyJcloudsRenames(rawProvider);	String identity = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_IDENTITY), "identity must not be null");	String credential = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_CREDENTIAL), "credential must not be null");	String endpoint = location.getConfig(CloudLocationConfig.CLOUD_ENDPOINT);	Properties overrides = new Properties();	overrides.setProperty(Constants.PROPERTY_STRIP_EXPECT_HEADER, "true");	Map<String, Object> extra = Maps.filterKeys(location.getAllConfig(true), Predicates.containsPattern("^jclouds\\."));	if (extra.size() > 0) {	
configuring custom jclouds property overrides for 

========================= brooklyn sample_2594 =========================

Entity b = launchEntity("B");	Assert.assertTrue(BasicEntity.class.isInstance(b), "Wrong type: "+b);	Assert.assertEquals(b.config().get(ConfigKeys.newIntegerConfigKey("a")), (Integer)1);	Assert.assertEquals(b.config().get(ConfigKeys.newIntegerConfigKey("b")), (Integer)1);	deleteCatalogEntity("A");	try {	launchEntity("B");	Assert.fail("B should not be launchable");	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
got expected error 

========================= brooklyn sample_1642 =========================

Thread shutdownThread = new Thread() {	public void run() {	try {	MultivaluedMap<String, String> formData = new MultivaluedHashMap<>();	formData.add("stopAppsFirst", "true");	formData.add("shutdownTimeout", "0");	formData.add("requestTimeout", "0");	formData.add("delayForHttpReturn", "0");	client().path("/server/shutdown").type(MediaType.APPLICATION_FORM_URLENCODED).post(formData);	} catch (Exception e) {	
shutdown request error 

========================= brooklyn sample_2828 =========================

public void load() {	
loading catalog for 

public void load() {	getCatalog().load(mgmt, null);	if (log.isDebugEnabled()) {	
loaded catalog for search classpath is 

private void updateResultNewFormat(Map<RegisteredType, RegisteredType> resultNewFormat, RegisteredType replacedInstance, RegisteredType newInstance) {	if (resultNewFormat!=null) {	if (resultNewFormat.containsKey(newInstance)) {	
multiple definitions for in bom only recording one 

public void addTypesFromBundleBom(String yaml, ManagedBundle bundle, boolean forceUpdate, Map<RegisteredType, RegisteredType> result) {	
catalog load adding catalog item to 

public Map<RegisteredType,Collection<Throwable>> validateTypes(Iterable<RegisteredType> typesToValidate) {	List<RegisteredType> typesRemainingToValidate = MutableList.copyOf(typesToValidate);	while (true) {	
catalog load starting validation cycle to validate 

public Map<RegisteredType,Collection<Throwable>> validateTypes(Iterable<RegisteredType> typesToValidate) {	List<RegisteredType> typesRemainingToValidate = MutableList.copyOf(typesToValidate);	while (true) {	Map<RegisteredType,Collection<Throwable>> result = MutableMap.of();	for (RegisteredType t: typesRemainingToValidate) {	Collection<Throwable> tr = validateType(t, null);	if (!tr.isEmpty()) {	result.put(t, tr);	}	}	
catalog load finished validation cycle unvalidated 

public void uninstallEmptyWrapperBundles() {	
uninstalling empty wrapper bundles 

public void uninstallEmptyWrapperBundles() {	synchronized (uninstallingEmptyLock) {	Maybe<OsgiManager> osgi = ((ManagementContextInternal)mgmt).getOsgiManager();	if (osgi.isAbsent()) return;	for (ManagedBundle b: osgi.get().getInstalledWrapperBundles()) {	if (isNoBundleOrSimpleWrappingBundle(mgmt, b)) {	Iterable<RegisteredType> typesInBundle = osgi.get().getTypesFromBundle(b.getVersionedName());	if (Iterables.isEmpty(typesInBundle)) {	
uninstalling now empty bom wrapper bundle 

========================= brooklyn sample_1357 =========================

public void testMementoNotTooBig() throws Exception {	origApp.addChild(EntitySpec.create(TestEntity.class));	origApp.config().set(TestEntity.CONF_NAME, "slim");	origApp.sensors().set(TestApplication.MY_ATTRIBUTE, "foo");	origApp.sensors().set(TestEntity.SEQUENCE, 98765);	origApp.getMutableEntityType().addEffector(SayHiBody.EFFECTOR);	RebindTestUtils.stopPersistence(origApp);	File mementoFile = new File(new File(mementoDir, "entities"), origApp.getId());	String memento = Streams.readFullyAndClose(new FileReader(mementoFile));	
memento is 

private void checkEffectorWithRebind() throws InterruptedException, ExecutionException, Exception {	Effector<?> eff = origApp.getEntityType().getEffectorByName("say_hi").get();	assertEquals(origApp.invoke(eff, ConfigBag.newInstance().configure(SayHiBody.NAME_KEY, "bob").getAllConfig()).get(), "hello bob");	newApp = rebind();	
effectors on new app 

========================= brooklyn sample_660 =========================

public Maybe<String> get() {	
tmpdirfinder using fallback tmp directory caller using fallback tmp dir 

public boolean useWithWarning(String dir) {	if (tmpdir==null) {	tmpdir = dir;	isFallback = true;	
unable to find a valid tmp dir will use but with caution see debug messages marked tmpdirfinder for more information 

protected synchronized boolean find() {	if (isFound()) return true;	String customtmp = System.getProperty(BROOKLYN_OS_TMPDIR_PROPERTY);	if (customtmp!=null) {	if (checkAndSet(customtmp)) return true;	
tmpdirfinder custom tmp directory in is not a valid tmp dir ignoring 

boolean systmpWeird = (systmp.contains("/var/") || systmp.startsWith("/private"));	if (!systmpWeird) if (checkAndSet(systmp)) return true;	if (checkAndSet(File.separator+"tmp")) return true;	if (systmpWeird) if (checkAndSet(systmp)) return true;	try {	String hometmp = mergePaths(home(), ".tmp");	File hometmpF = new File(hometmp);	hometmpF.mkdirs();	if (checkAndSet(hometmp)) return true;	} catch (Exception e) {	
tmpdirfinder cannot create tmp dir in user s home dir 

protected boolean checkAndSet(String candidate) {	if (!check(candidate)) return false;	tmpdir = candidate;	
tmpdirfinder selected tmp dir as the best tmp working space 

protected boolean check(String candidate) {	try {	File f = new File(candidate);	if (!f.exists()) {	
tmpdirfinder candidate tmp dir does not exist 

protected boolean check(String candidate) {	try {	File f = new File(candidate);	if (!f.exists()) {	return false;	}	if (!f.isDirectory()) {	
tmpdirfinder candidate tmp dir is not a directory 

try {	File f = new File(candidate);	if (!f.exists()) {	return false;	}	if (!f.isDirectory()) {	return false;	}	File f2 = new File(f, "brooklyn-tmp-check-"+Strings.makeRandomId(4));	if (!f2.createNewFile()) {	
tmpdirfinder candidate tmp dir cannot have files created inside it 

return false;	}	if (!f.isDirectory()) {	return false;	}	File f2 = new File(f, "brooklyn-tmp-check-"+Strings.makeRandomId(4));	if (!f2.createNewFile()) {	return false;	}	if (!f2.delete()) {	
tmpdirfinder candidate tmp dir cannot have files deleted inside it 

}	File f2 = new File(f, "brooklyn-tmp-check-"+Strings.makeRandomId(4));	if (!f2.createNewFile()) {	return false;	}	if (!f2.delete()) {	return false;	}	return true;	} catch (Exception e) {	
tmpdirfinder candidate tmp dir is not valid 

private static void addShutdownFileDeletionHook(String path, FileDeletionHook hook) {	Ordering.<Integer>natural();	synchronized (deletions) {	if (deletions.isEmpty()) {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down deleting 

Thread shutdownHook = new Thread() {	public void run() {	try {	synchronized (deletions) {	List<String> pathsToDelete = new ArrayList<String>(deletions.keySet());	Collections.sort(pathsToDelete, Strings.lengthComparator().reverse());	for (String path: pathsToDelete) {	try {	deletions.remove(path).run();	} catch (Exception e) {	
unable to delete on shutdown 

Thread shutdownHook = new Thread() {	public void run() {	try {	synchronized (deletions) {	List<String> pathsToDelete = new ArrayList<String>(deletions.keySet());	Collections.sort(pathsToDelete, Strings.lengthComparator().reverse());	for (String path: pathsToDelete) {	try {	deletions.remove(path).run();	} catch (Exception e) {	
trace for shutdown deletion problem 

List<String> pathsToDelete = new ArrayList<String>(deletions.keySet());	Collections.sort(pathsToDelete, Strings.lengthComparator().reverse());	for (String path: pathsToDelete) {	try {	deletions.remove(path).run();	} catch (Exception e) {	}	}	}	} catch (Exception e) {	
unable to delete one or more paths on shutdown 

List<String> pathsToDelete = new ArrayList<String>(deletions.keySet());	Collections.sort(pathsToDelete, Strings.lengthComparator().reverse());	for (String path: pathsToDelete) {	try {	deletions.remove(path).run();	} catch (Exception e) {	}	}	}	} catch (Exception e) {	
trace for shutdown deletion problem 

public static int deleteOnExitEmptyParentsUpTo(File subsubDirOrFile, File dir) {	if (subsubDirOrFile==null || dir==null) return 0;	List<File> dirsToDelete = new ArrayList<File>();	File d = subsubDirOrFile;	do {	dirsToDelete.add(d);	if (d.equals(dir)) break;	d = d.getParentFile();	} while (d!=null);	if (d==null) {	
file has no ancestor will not attempt to clean up with ancestors on exit 

public static String tidyPath(String path) {	Preconditions.checkNotNull(path, "path");	Iterable<String> segments = Splitter.on("/").split(Files.simplifyPath(path));	if (Iterables.get(segments, 0).equals("~")) {	segments = Iterables.concat(ImmutableSet.of(Os.home()), Iterables.skip(segments, 1));	}	String result = Joiner.on("/").join(segments);	
quietly changing to 

String sanitizedPrefix = (prefix==null ? "" : Strings.makeValidFilename(prefix) + "-");	String tmpParent = tmp();	for (int i = 0; i < TEMP_DIR_ATTEMPTS; i++) {	String baseName = sanitizedPrefix + Identifiers.makeRandomId(4);	File tempDir = new File(tmpParent, baseName);	if (!tempDir.exists()) {	if (tempDir.mkdir()) {	Os.deleteOnExitRecursively(tempDir);	return tempDir;	} else {	
attempt to create temp dir failed either an io error disk full no rights or someone else created the folder after the exists check 

for (int i = 0; i < TEMP_DIR_ATTEMPTS; i++) {	String baseName = sanitizedPrefix + Identifiers.makeRandomId(4);	File tempDir = new File(tmpParent, baseName);	if (!tempDir.exists()) {	if (tempDir.mkdir()) {	Os.deleteOnExitRecursively(tempDir);	return tempDir;	} else {	}	} else {	
attempt to create temp dir failed already exists with id of length it is not unusual chance to have duplicate names at the samples mark 

========================= brooklyn sample_2081 =========================

public void testClassLoaderDir() throws Exception {	String d = utils.getClassLoaderDir();	
found resource in 

public void testClassLoaderDirFromJar() throws Exception {	String d = utils.getClassLoaderDir("java/lang/Object.class");	
found object in 

public void testClassLoaderDirFromJarWithSlash() throws Exception {	String d = utils.getClassLoaderDir("/java/lang/Object.class");	
found object in 

public void testClassLoaderDirNotFound() throws Exception {	String d = utils.getClassLoaderDir("/somewhere/not/found/XXX.xxx");	
uh oh found imaginary resource in 

========================= brooklyn sample_924 =========================

public void acquireMutex(String mutexId, String description) throws InterruptedException {	SemaphoreWithOwners s = getSemaphore(mutexId, true);	if (description!=null) Tasks.setBlockingDetails(description+" - waiting for "+mutexId);	
acquiring mutex 

public void acquireMutex(String mutexId, String description) throws InterruptedException {	SemaphoreWithOwners s = getSemaphore(mutexId, true);	if (description!=null) Tasks.setBlockingDetails(description+" - waiting for "+mutexId);	s.acquire();	if (description!=null) Tasks.setBlockingDetails(null);	s.setDescription(description);	
acquired mutex 

public boolean tryAcquireMutex(String mutexId, String description) {	SemaphoreWithOwners s = getSemaphore(mutexId, true);	if (s.tryAcquire()) {	
acquired mutex opportunistic 

public synchronized void releaseMutex(String mutexId) {	SemaphoreWithOwners s;	
releasing mutex 

========================= brooklyn sample_1510 =========================

protected <T> List<Class<? extends T>> forNames(Set<String> classNames, final String context) {	List<Class<? extends T>> result = new ArrayList<Class<? extends T>>();	for (String className : classNames) {	try {	Class<? extends T> clazz = (Class<? extends T>) loadClass(className);	if (clazz != null) {	result.add(clazz);	} else {	
unable to instantiate 

protected <T> List<Class<? extends T>> forNames(Set<String> classNames, final String context) {	List<Class<? extends T>> result = new ArrayList<Class<? extends T>>();	for (String className : classNames) {	try {	Class<? extends T> clazz = (Class<? extends T>) loadClass(className);	if (clazz != null) {	result.add(clazz);	} else {	}	} catch (Throwable e) {	
unable to instantiate 

========================= brooklyn sample_1455 =========================

protected String getProviderName(String providerOrApi, String namedLocationName, Map<String, ?> properties) {	String provider = providerOrApi;	if (!Strings.isNullOrEmpty(namedLocationName)) {	String providerDefinition = (String) properties.get(String.format("brooklyn.location.named.%s", namedLocationName));	if (providerDefinition!=null) {	String provider2 = getProviderFromDefinition(providerDefinition);	if (provider==null) {	
not set with provider inferring from locationname as 

protected String getProviderName(String providerOrApi, String namedLocationName, Map<String, ?> properties) {	String provider = providerOrApi;	if (!Strings.isNullOrEmpty(namedLocationName)) {	String providerDefinition = (String) properties.get(String.format("brooklyn.location.named.%s", namedLocationName));	if (providerDefinition!=null) {	String provider2 = getProviderFromDefinition(providerDefinition);	if (provider==null) {	provider = provider2;	} else if (!provider.equals(provider2)) {	
not changing provider from to candidate 

========================= brooklyn sample_2629 =========================

private Collection<Application> rebind(TestApplication app) throws Exception {	
rebind start 

private Collection<Application> rebind(TestApplication app) throws Exception {	RebindTestUtils.waitForPersisted(app);	((LocalManagementContext) app.getManagementContext()).terminate();	Collection<Application> r = RebindTestUtils.rebindAll(RebindOptions.create().mementoDir(mementoDir).classLoader(classLoader));	
rebind complete 

========================= brooklyn sample_2279 =========================

public static HostGeoInfo fromIpAddress(InetAddress address) {	try {	HostGeoLookup lookup = getDefaultLookup();	if (lookup!=null) return lookup.getHostGeoInfo(address);	} catch (Exception e) {	
unable to look up geo dns info for 

private static HostGeoLookup findHostGeoLookupImpl() throws InstantiationException, IllegalAccessException, ClassNotFoundException {	String type = BrooklynSystemProperties.HOST_GEO_LOOKUP_IMPL.getValue();	if (type==null) {	type = BrooklynSystemProperties.HOST_GEO_LOOKUP_IMPL_LEGACY.getValue();	if (type!=null && !warnedLegacy) {	warnedLegacy = true;	
using deprecated host geo lookup property set instead 

private static HostGeoLookup findHostGeoLookupImpl() throws InstantiationException, IllegalAccessException, ClassNotFoundException {	String type = BrooklynSystemProperties.HOST_GEO_LOOKUP_IMPL.getValue();	if (type==null) {	type = BrooklynSystemProperties.HOST_GEO_LOOKUP_IMPL_LEGACY.getValue();	if (type!=null && !warnedLegacy) {	warnedLegacy = true;	}	}	if (type==null) {	if (MaxMind2HostGeoLookup.getDatabaseReader()!=null) return new MaxMind2HostGeoLookup();	
using utrace remote for geo lookup because is not available 

========================= brooklyn sample_1286 =========================

public void stop() {	
stopping simple command 

public void restart() {	
restarting simple command 

protected void handle(WinRmToolResponse result) {	
result is with output and error 

private WinRmToolResponse execute(TaskBuilder<WinRmToolResponse> tb, String cmdIn) {	try {	ByteArrayOutputStream stdin = new ByteArrayOutputStream();	if (cmdIn != null) {	stdin.write(cmdIn.getBytes());	}	tb.tag(BrooklynTaskTags.tagForStreamSoft(BrooklynTaskTags.STREAM_STDIN, stdin));	} catch (IOException e) {	
error registering stream on 

========================= brooklyn sample_2445 =========================

ReferencedState.warnOfDifferences(stateToKeepFromXpath, stateToKeepFromGrep);	ReferencedState stateToKeep = ReferencedState.union(stateToKeepFromXpath, stateToKeepFromGrep);	Map<String, String> locationsToKeep = copyRetainingKeys(input.getLocations(), stateToKeep.locations);	Map<String, String> enrichersToKeep = copyRetainingKeys(input.getEnrichers(), stateToKeep.enrichers);	Map<String, String> policiesToKeep = copyRetainingKeys(input.getPolicies(), stateToKeep.policies);	Map<String, String> feedsToKeep = copyRetainingKeys(input.getFeeds(), stateToKeep.feeds);	Set<String> locsToDelete = Sets.difference(input.getLocations().keySet(), locationsToKeep.keySet());	Set<String> enrichersToDelete = Sets.difference(input.getEnrichers().keySet(), enrichersToKeep.keySet());	Set<String> policiesToDelete = Sets.difference(input.getPolicies().keySet(), policiesToKeep.keySet());	Set<String> feedsToDelete = Sets.difference(input.getFeeds().keySet(), feedsToKeep.keySet());	
deleting orphaned location of 

ReferencedState.warnOfDifferences(stateToKeepFromXpath, stateToKeepFromGrep);	ReferencedState stateToKeep = ReferencedState.union(stateToKeepFromXpath, stateToKeepFromGrep);	Map<String, String> locationsToKeep = copyRetainingKeys(input.getLocations(), stateToKeep.locations);	Map<String, String> enrichersToKeep = copyRetainingKeys(input.getEnrichers(), stateToKeep.enrichers);	Map<String, String> policiesToKeep = copyRetainingKeys(input.getPolicies(), stateToKeep.policies);	Map<String, String> feedsToKeep = copyRetainingKeys(input.getFeeds(), stateToKeep.feeds);	Set<String> locsToDelete = Sets.difference(input.getLocations().keySet(), locationsToKeep.keySet());	Set<String> enrichersToDelete = Sets.difference(input.getEnrichers().keySet(), enrichersToKeep.keySet());	Set<String> policiesToDelete = Sets.difference(input.getPolicies().keySet(), policiesToKeep.keySet());	Set<String> feedsToDelete = Sets.difference(input.getFeeds().keySet(), feedsToKeep.keySet());	
deleting orphaned enricher of 

ReferencedState stateToKeep = ReferencedState.union(stateToKeepFromXpath, stateToKeepFromGrep);	Map<String, String> locationsToKeep = copyRetainingKeys(input.getLocations(), stateToKeep.locations);	Map<String, String> enrichersToKeep = copyRetainingKeys(input.getEnrichers(), stateToKeep.enrichers);	Map<String, String> policiesToKeep = copyRetainingKeys(input.getPolicies(), stateToKeep.policies);	Map<String, String> feedsToKeep = copyRetainingKeys(input.getFeeds(), stateToKeep.feeds);	Set<String> locsToDelete = Sets.difference(input.getLocations().keySet(), locationsToKeep.keySet());	Set<String> enrichersToDelete = Sets.difference(input.getEnrichers().keySet(), enrichersToKeep.keySet());	Set<String> policiesToDelete = Sets.difference(input.getPolicies().keySet(), policiesToKeep.keySet());	Set<String> feedsToDelete = Sets.difference(input.getFeeds().keySet(), feedsToKeep.keySet());	LOG.info("Deleting {} orphaned polic{} (of {}): {}", new Object[] {policiesToDelete.size(), (policiesToDelete.size() == 1 ? "y" : "ies"), input.getPolicies().size(), policiesToDelete});	
deleting orphaned feed of 

public static void warnOfDifferences(ReferencedState s1, ReferencedState s2) {	Set<String> locDiffs = Sets.symmetricDifference(s1.locations, s2.locations);	Set<String> enricherDiffs = Sets.symmetricDifference(s1.enrichers, s2.enrichers);	Set<String> policyDiffs = Sets.symmetricDifference(s1.policies, s2.policies);	Set<String> feedDiffs = Sets.symmetricDifference(s1.feeds, s2.feeds);	if (locDiffs.size() > 0) {	
deletion of orphan state found unusually referenced locations keeping 

public static void warnOfDifferences(ReferencedState s1, ReferencedState s2) {	Set<String> locDiffs = Sets.symmetricDifference(s1.locations, s2.locations);	Set<String> enricherDiffs = Sets.symmetricDifference(s1.enrichers, s2.enrichers);	Set<String> policyDiffs = Sets.symmetricDifference(s1.policies, s2.policies);	Set<String> feedDiffs = Sets.symmetricDifference(s1.feeds, s2.feeds);	if (locDiffs.size() > 0) {	}	if (enricherDiffs.size() > 0) {	
deletion of orphan state found unusually referenced enrichers keeping 

public static void warnOfDifferences(ReferencedState s1, ReferencedState s2) {	Set<String> locDiffs = Sets.symmetricDifference(s1.locations, s2.locations);	Set<String> enricherDiffs = Sets.symmetricDifference(s1.enrichers, s2.enrichers);	Set<String> policyDiffs = Sets.symmetricDifference(s1.policies, s2.policies);	Set<String> feedDiffs = Sets.symmetricDifference(s1.feeds, s2.feeds);	if (locDiffs.size() > 0) {	}	if (enricherDiffs.size() > 0) {	}	if (policyDiffs.size() > 0) {	
deletion of orphan state found unusually referenced policies keeping 

Set<String> enricherDiffs = Sets.symmetricDifference(s1.enrichers, s2.enrichers);	Set<String> policyDiffs = Sets.symmetricDifference(s1.policies, s2.policies);	Set<String> feedDiffs = Sets.symmetricDifference(s1.feeds, s2.feeds);	if (locDiffs.size() > 0) {	}	if (enricherDiffs.size() > 0) {	}	if (policyDiffs.size() > 0) {	}	if (feedDiffs.size() > 0) {	
deletion of orphan state found unusually referenced feeds keeping 

========================= brooklyn sample_1117 =========================

public void testToyInterpreter() {	Map y1 = Yamls.getAs( Yamls.parseAll( Streams.reader(getClass().getResourceAsStream("yaml-sample-toy-interpreter.yaml"))), Map.class );	
pre interpreter have 

public void testToyInterpreter() {	Map y1 = Yamls.getAs( Yamls.parseAll( Streams.reader(getClass().getResourceAsStream("yaml-sample-toy-interpreter.yaml"))), Map.class );	BasicCampPlatform p = new BasicCampPlatform();	p.pdp().addInterpreter(new ToyInterpreter());	Map<String, Object> y2 = p.pdp().applyInterpreters(y1);	
interpreter gives 

========================= brooklyn sample_1814 =========================

public boolean isEnabled() {	boolean enabled = computeEnabled();	if (!loggedMode.getAndSet(true)) {	String reason = (this.enabled==null ? "autodetected" : "forced");	if (enabled) {	
brooklyn running in development mode 

public boolean isEnabled() {	boolean enabled = computeEnabled();	if (!loggedMode.getAndSet(true)) {	String reason = (this.enabled==null ? "autodetected" : "forced");	if (enabled) {	} else {	
brooklyn not running in development mode 

private static boolean computeAutodectectedDevelopmentMode() {	String cp = System.getProperty("java.class.path");	String platformSegment = Os.nativePath(segment);	if (cp==null) return false;	if (cp.endsWith(platformSegment) || cp.contains(platformSegment+File.pathSeparator)) {	
brooklyn developmentmode autodetected based on presence of in classpath 

========================= brooklyn sample_565 =========================

public ServerPoolLocation createLocation(Map<String, ?> flags) {	String locationName = getConfig(LOCATION_NAME);	if (locationName == null) {	String prefix = getConfig(LOCATION_NAME_PREFIX);	String suffix = getConfig(LOCATION_NAME_SUFFIX);	locationName = Joiner.on("-").skipNulls().join(prefix, getId(), suffix);	}	ServerPoolLocation location = getManagementContext().getLocationManager().createLocation(LocationSpec.create(ServerPoolLocation.class) .displayName("Server Pool(" + getId() + ")") .configure(flags) .configure("owner", getProxy()) .configure("locationName", locationName));	LocationDefinition definition = location.register();	
resolved and registered dynamic location for server pool 

public void deleteLocation() {	LocationManager mgr = getManagementContext().getLocationManager();	ServerPoolLocation location = getDynamicLocation();	if (location != null && mgr.isManaged(location)) {	
deleting and unmanaging location 

public MachineLocation claimMachine(Map<?, ?> flags) throws NoMachinesAvailableException {	LOG.info("Obtaining machine with flags: {}", Joiner.on(", ").withKeyValueSeparator("=").join(flags));	synchronized (mutex) {	Optional<Entity> claimed = getMemberWithStatus(MachinePoolMemberStatus.AVAILABLE);	if (claimed.isPresent()) {	setEntityStatus(claimed.get(), MachinePoolMemberStatus.CLAIMED);	updateCountSensors();	
has been claimed in 

public void releaseMachine(MachineLocation machine) {	synchronized (mutex) {	Entity entity = getMachineEntityMap().get(machine);	if (entity == null) {	
releasing machine but its owning entity is not known 

public void releaseMachine(MachineLocation machine) {	synchronized (mutex) {	Entity entity = getMachineEntityMap().get(machine);	if (entity == null) {	} else {	setEntityStatus(entity, MachinePoolMemberStatus.AVAILABLE);	updateCountSensors();	
has been released in 

public Entity addExistingMachine(MachineLocation machine) {	
adding additional machine to 

public Collection<Entity> addExistingMachinesFromSpec(String spec) {	Location location = getManagementContext().getLocationManager().createLocation( getManagementContext().getLocationRegistry().getLocationSpec(spec).get() .configure(LocalLocationManager.CREATE_UNMANAGED, true) );	List<Entity> additions = Lists.newLinkedList();	if (location == null) {	
spec was unresolvable 

public Collection<Entity> addExistingMachinesFromSpec(String spec) {	Location location = getManagementContext().getLocationManager().createLocation( getManagementContext().getLocationRegistry().getLocationSpec(spec).get() .configure(LocalLocationManager.CREATE_UNMANAGED, true) );	List<Entity> additions = Lists.newLinkedList();	if (location == null) {	} else {	Iterable<MachineLocation> machines = FluentIterable.from(location.getChildren()) .filter(MachineLocation.class);	
adding additional machines 

public Collection<Entity> addExistingMachinesFromSpec(String spec) {	Location location = getManagementContext().getLocationManager().createLocation( getManagementContext().getLocationRegistry().getLocationSpec(spec).get() .configure(LocalLocationManager.CREATE_UNMANAGED, true) );	List<Entity> additions = Lists.newLinkedList();	if (location == null) {	} else {	Iterable<MachineLocation> machines = FluentIterable.from(location.getChildren()) .filter(MachineLocation.class);	for (MachineLocation machine : machines) {	additions.add(addExistingMachine(machine));	}	
added additional machines 

return super.shrink(delta);	}	synchronized (mutex) {	int removable = 0;	for (Entity entity : getMembers()) {	if (!Boolean.FALSE.equals(entity.getConfig(REMOVABLE)) && !MachinePoolMemberStatus.CLAIMED.equals(entity.getAttribute(SERVER_STATUS))) {	removable -= 1;	}	}	if (delta < removable) {	
too few removable machines in to shrink by delta altered delta to 

public Entity apply(Collection<Entity> members) {	synchronized (mutex) {	Optional<Entity> choice;	if (Lifecycle.STOPPING.equals(getAttribute(Attributes.SERVICE_STATE_ACTUAL))) {	choice = Optional.of(members.iterator().next());	} else {	choice = getMemberWithStatusExcludingUnremovable(members, MachinePoolMemberStatus.UNUSABLE) .or(getMemberWithStatusExcludingUnremovable(members, MachinePoolMemberStatus.AVAILABLE));	}	if (!choice.isPresent()) {	
has no machines available to remove 

synchronized (mutex) {	Optional<Entity> choice;	if (Lifecycle.STOPPING.equals(getAttribute(Attributes.SERVICE_STATE_ACTUAL))) {	choice = Optional.of(members.iterator().next());	} else {	choice = getMemberWithStatusExcludingUnremovable(members, MachinePoolMemberStatus.UNUSABLE) .or(getMemberWithStatusExcludingUnremovable(members, MachinePoolMemberStatus.AVAILABLE));	}	if (!choice.isPresent()) {	return null;	} else {	
selected entity to remove from pool 

private void serverAdded(Entity member) {	Maybe<MachineLocation> machine = Machines.findUniqueMachineLocation(member.getLocations());	if (member.getAttribute(SERVER_STATUS) != null) {	
skipped addition of machine already in the pool 

private void serverAdded(Entity member) {	Maybe<MachineLocation> machine = Machines.findUniqueMachineLocation(member.getLocations());	if (member.getAttribute(SERVER_STATUS) != null) {	} else if (machine.isPresentAndNonNull()) {	MachineLocation m = machine.get();	
new machine in 

if (member.getAttribute(SERVER_STATUS) != null) {	} else if (machine.isPresentAndNonNull()) {	MachineLocation m = machine.get();	setEntityStatus(member, MachinePoolMemberStatus.AVAILABLE);	synchronized (mutex) {	getEntityMachineMap().put(member, m);	getMachineEntityMap().put(m, member);	updateCountSensors();	}	} else {	
member added to that does not have a machine location it will not be used by the pool 

protected void onEntityEvent(EventType type, Entity member) {	Boolean isUp = member.getAttribute(Attributes.SERVICE_UP);	
in service up is 

protected void onEntityEvent(EventType type, Entity member) {	Boolean isUp = member.getAttribute(Attributes.SERVICE_UP);	defaultHighlightAction(type, entity, "Update on %s %s (service "+(isUp==Boolean.TRUE ? "up" : isUp==Boolean.FALSE ? "not up" : "up value not known")+")");	if (type.equals(EventType.ENTITY_ADDED) || type.equals(EventType.ENTITY_CHANGE)) {	if (Boolean.TRUE.equals(isUp)) {	((ServerPoolImpl) entity).serverAdded(member);	} else if (LOG.isDebugEnabled()) {	
observed event but is not up yet and will not be used by the pool 

========================= brooklyn sample_2384 =========================

public void setUp() throws Exception {	super.setUp();	EntitySpec<StubAppServer> serverSpec = EntitySpec.create(StubAppServer.class);	cluster = app().createAndManageChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.INITIAL_SIZE, initialClusterSize) .configure(DynamicCluster.MEMBER_SPEC, serverSpec));	urlMapping = app().createAndManageChild(EntitySpec.create(UrlMapping.class) .configure("domain", "localhost") .configure("target", cluster));	app().start( ImmutableList.of( mgmt().getLocationManager().createLocation( LocationSpec.create(LocalhostMachineProvisioningLocation.class)) ));	
app s location managed 

public void setUp() throws Exception {	super.setUp();	EntitySpec<StubAppServer> serverSpec = EntitySpec.create(StubAppServer.class);	cluster = app().createAndManageChild(EntitySpec.create(DynamicCluster.class) .configure(DynamicCluster.INITIAL_SIZE, initialClusterSize) .configure(DynamicCluster.MEMBER_SPEC, serverSpec));	urlMapping = app().createAndManageChild(EntitySpec.create(UrlMapping.class) .configure("domain", "localhost") .configure("target", cluster));	app().start( ImmutableList.of( mgmt().getLocationManager().createLocation( LocationSpec.create(LocalhostMachineProvisioningLocation.class)) ));	
clusters s location managed 

public void testTargetMappingUpdatesAfterRebind() throws Exception {	
starting testtargetmappingupdatesafterrebind 

public void testTargetMappingUpdatesAfterRebind() throws Exception {	Iterable<StubAppServer> members = Iterables.filter(cluster.getChildren(), StubAppServer.class);	assertExpectedTargetsEventually(members);	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())));	rebind();	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())), "location not managed after rebind");	Iterable<StubAppServer> members2 = Iterables.filter(cluster.getChildren(), StubAppServer.class);	StubAppServer target1 = Iterables.get(members2, 0);	StubAppServer target2 = Iterables.get(members2, 1);	assertExpectedTargetsEventually(ImmutableSet.of(target1, target2));	
resizing 

assertExpectedTargetsEventually(members);	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())));	rebind();	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())), "location not managed after rebind");	Iterable<StubAppServer> members2 = Iterables.filter(cluster.getChildren(), StubAppServer.class);	StubAppServer target1 = Iterables.get(members2, 0);	StubAppServer target2 = Iterables.get(members2, 1);	assertExpectedTargetsEventually(ImmutableSet.of(target1, target2));	Integer result = cluster.resize(3);	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())));	
resized 

Iterable<StubAppServer> members2 = Iterables.filter(cluster.getChildren(), StubAppServer.class);	StubAppServer target1 = Iterables.get(members2, 0);	StubAppServer target2 = Iterables.get(members2, 1);	assertExpectedTargetsEventually(ImmutableSet.of(target1, target2));	Integer result = cluster.resize(3);	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())));	HashSet<StubAppServer> newEntities = Sets.newHashSet(Iterables.filter(cluster.getChildren(), StubAppServer.class));	newEntities.remove(target1);	newEntities.remove(target2);	StubAppServer target3 = Iterables.getOnlyElement(newEntities);	
expecting 

StubAppServer target1 = Iterables.get(members2, 0);	StubAppServer target2 = Iterables.get(members2, 1);	assertExpectedTargetsEventually(ImmutableSet.of(target1, target2));	Integer result = cluster.resize(3);	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())));	HashSet<StubAppServer> newEntities = Sets.newHashSet(Iterables.filter(cluster.getChildren(), StubAppServer.class));	newEntities.remove(target1);	newEntities.remove(target2);	StubAppServer target3 = Iterables.getOnlyElement(newEntities);	assertExpectedTargetsEventually(ImmutableSet.of(target1, target2, target3));	
pretending one node down 

assertExpectedTargetsEventually(ImmutableSet.of(target1, target2));	Integer result = cluster.resize(3);	Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())));	HashSet<StubAppServer> newEntities = Sets.newHashSet(Iterables.filter(cluster.getChildren(), StubAppServer.class));	newEntities.remove(target1);	newEntities.remove(target2);	StubAppServer target3 = Iterables.getOnlyElement(newEntities);	assertExpectedTargetsEventually(ImmutableSet.of(target1, target2, target3));	target1.sensors().set(StubAppServer.SERVICE_UP, false);	assertExpectedTargetsEventually(ImmutableSet.of(target2, target3));	
unmanaging another node 

Assert.assertTrue(mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())));	HashSet<StubAppServer> newEntities = Sets.newHashSet(Iterables.filter(cluster.getChildren(), StubAppServer.class));	newEntities.remove(target1);	newEntities.remove(target2);	StubAppServer target3 = Iterables.getOnlyElement(newEntities);	assertExpectedTargetsEventually(ImmutableSet.of(target1, target2, target3));	target1.sensors().set(StubAppServer.SERVICE_UP, false);	assertExpectedTargetsEventually(ImmutableSet.of(target2, target3));	Entities.unmanage(target2);	assertExpectedTargetsEventually(ImmutableSet.of(target3));	
success testtargetmappingupdatesafterrebind 

========================= brooklyn sample_135 =========================

public void addProvider(String name, ExternalConfigSupplier supplier) {	synchronized (providersMapMutex) {	if (providersByName.containsKey(name) && !DEMO_SAMPLE_PROVIDER.equals(name)) {	throw new IllegalArgumentException("Provider already registered with name '" + name + "'");	}	providersByName.put(name, supplier);	}	
added external config supplier named 

public void removeProvider(String name) {	synchronized (providersMapMutex) {	ExternalConfigSupplier supplier = providersByName.remove(name);	
removed external config supplier named 

configSupplier = Reflections.invokeConstructorFromArgs(supplierClass, mgmt, name, config.asMapWithStringKeys());	}	if (!configSupplier.isPresent()) {	configSupplier = Reflections.invokeConstructorFromArgs(supplierClass, mgmt, name);	}	if (!configSupplier.isPresent()) {	throw new IllegalStateException("No matching constructor found in "+providerClassname);	}	addProvider(name, configSupplier.get());	} catch (Exception e) {	
failed to instantiate external config supplier named 

========================= brooklyn sample_1052 =========================

public void testProvisioningProperties() throws Exception {	Entity app = createAndStartApplication( "location: localhost", "services:", "- type: "+EmptySoftwareProcess.class.getName(), "  provisioning.properties:", "    minRam: 16384");	waitForApplicationTasks(app);	
app started 

public void testProvisioningPropertiesViaJsonya() throws Exception {	Entity app = createAndStartApplication( Jsonya.newInstance() .put("location", "localhost") .at("services").list() .put("type", EmptySoftwareProcess.class.getName()) .at("provisioning.properties").put("minRam", 16384) .root().toString());	waitForApplicationTasks(app);	
app started 

========================= brooklyn sample_1681 =========================

public void rebind() {	super.rebind();	if (rescan == null) {	getExecutionContext().execute(new Runnable() {	
deferring scanner for until management context initialisation complete 

public void rebind() {	super.rebind();	if (rescan == null) {	getExecutionContext().execute(new Runnable() {	while (!isRebindComplete()) {	Time.sleep(100);	}	
connecting scanner for 

throw e;	}	ServiceProblemsLogic.clearProblemsIndicator(this, "children");	buckets.put(name, bucket);	}	bucket.setMembers(entityMapping.get(name));	}	Set<String> empty = ImmutableSet.copyOf(Sets.difference(buckets.keySet(), entityMapping.keySet()));	for (String name : empty) {	Group removed = buckets.remove(name);	
removing empty child bucket 

========================= brooklyn sample_1551 =========================

assertDnsEntityEventuallyHasActiveMembers(1);	logDnsMappings();	EntityAsserts.assertAttributeEqualsEventually(cluster, DynamicCluster.GROUP_SIZE, 1);	assertMapSizes(1, 1, 0, 1);	cluster.resize(5);	assertDnsEntityEventuallyHasActiveMembers(5);	logDnsMappings();	EntityAsserts.assertAttributeEqualsEventually(cluster, DynamicCluster.GROUP_SIZE, 5);	assertMapSizes(5, 1, 4, 1);	} catch (Throwable t) {	
test failed dumping out contents of original persistence dir used for rebind 

========================= brooklyn sample_123 =========================

public static String toRmiJmxUrl(String host, Integer jmxRmiServerPort, Integer rmiRegistryPort, String context) {	if (rmiRegistryPort != null && rmiRegistryPort > 0) {	if (jmxRmiServerPort!=null && jmxRmiServerPort > 0 && jmxRmiServerPort!=rmiRegistryPort) {	return String.format(RMI_JMX_URL_FORMAT, host, jmxRmiServerPort, host, rmiRegistryPort, context);	}	return String.format(JMX_URL_FORMAT, host, rmiRegistryPort, context);	} else if (jmxRmiServerPort!=null && jmxRmiServerPort > 0) {	
no rmi registry port set for attempting to use jmx port for rmi lookup 

public static String toRmiJmxUrl(String host, Integer jmxRmiServerPort, Integer rmiRegistryPort, String context) {	if (rmiRegistryPort != null && rmiRegistryPort > 0) {	if (jmxRmiServerPort!=null && jmxRmiServerPort > 0 && jmxRmiServerPort!=rmiRegistryPort) {	return String.format(RMI_JMX_URL_FORMAT, host, jmxRmiServerPort, host, rmiRegistryPort, context);	}	return String.format(JMX_URL_FORMAT, host, rmiRegistryPort, context);	} else if (jmxRmiServerPort!=null && jmxRmiServerPort > 0) {	return String.format(JMX_URL_FORMAT, host, jmxRmiServerPort, context);	} else {	
no rmi jmx details set for returning null 

public synchronized void reconnect() throws IOException {	disconnect();	try {	connect();	failedReconnecting = false;	} catch (Exception e) {	if (failedReconnecting) {	
unable to re connect to jmx url repeated failure 

public synchronized void reconnect() throws IOException {	disconnect();	try {	connect();	failedReconnecting = false;	} catch (Exception e) {	if (failedReconnecting) {	} else {	
unable to re connect to jmx url rethrowing 

if (key!=null) {	ks.setKeyEntry("brooklyn-jmx-access", key, "".toCharArray(), new Certificate[] { cert });	}	kmf.init(ks, "".toCharArray());	TrustManager tms = SslTrustUtils.TRUST_ALL;	SSLContext ctx = SSLContext.getInstance("TLSv1");	ctx.init(kmf.getKeyManagers(), new TrustManager[] { tms }, null);	SSLSocketFactory ssf = ctx.getSocketFactory();	env.put(JmxmpAgent.TLS_SOCKET_FACTORY_PROPERTY, ssf);	} catch (Exception e) {	
error setting key for 

public boolean connect(long timeoutMs) {	if (LOG.isDebugEnabled()) LOG.debug("Connecting to JMX URL: {} ({})", url, ((timeoutMs == -1) ? "indefinitely" : timeoutMs+"ms timeout"));	long startMs = System.currentTimeMillis();	long endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);	long currentTime = startMs;	Throwable lastError = null;	int attempt = 0;	while (currentTime <= endMs) {	currentTime = System.currentTimeMillis();	if (attempt != 0) sleep(100);	
trying connection to at time 

int attempt = 0;	while (currentTime <= endMs) {	currentTime = System.currentTimeMillis();	if (attempt != 0) sleep(100);	try {	connect();	return true;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (!terminated.get() && shouldRetryOn(e)) {	
attempt failed connecting to 

} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (!terminated.get() && shouldRetryOn(e)) {	lastError = e;	} else {	throw Exceptions.propagate(e);	}	}	attempt++;	}	
unable to connect to jmx url 

protected void disconnectNow() {	triedConnecting = false;	if (connector != null) {	
disconnecting from jmx url 

protected void disconnectNow() {	triedConnecting = false;	if (connector != null) {	try {	connector.close();	} catch (Exception e) {	
caught exception disconnecting from jmx at 

protected void disconnectNow() {	triedConnecting = false;	if (connector != null) {	try {	connector.close();	} catch (Exception e) {	
details for exception disconnecting jmx 

public ObjectInstance findMBean(ObjectName objectName) {	Set<ObjectInstance> beans = findMBeans(objectName);	if (beans.size() == 1) {	notFoundMBeans.remove(objectName);	return Iterables.getOnlyElement(beans);	} else {	boolean changed = notFoundMBeans.add(objectName);	if (beans.size() > 1) {	if (changed) {	
jmx object name query returned values for at ignoring all 

public ObjectInstance findMBean(ObjectName objectName) {	Set<ObjectInstance> beans = findMBeans(objectName);	if (beans.size() == 1) {	notFoundMBeans.remove(objectName);	return Iterables.getOnlyElement(beans);	} else {	boolean changed = notFoundMBeans.add(objectName);	if (beans.size() > 1) {	if (changed) {	} else {	
jmx object name query returned values for at repeating ignoring all 

notFoundMBeans.remove(objectName);	return Iterables.getOnlyElement(beans);	} else {	boolean changed = notFoundMBeans.add(objectName);	if (beans.size() > 1) {	if (changed) {	} else {	}	} else {	if (changed) {	
jmx object not found at 

return Iterables.getOnlyElement(beans);	} else {	boolean changed = notFoundMBeans.add(objectName);	if (beans.size() > 1) {	if (changed) {	} else {	}	} else {	if (changed) {	} else {	
jmx object not found at repeating 

public Object getAttribute(ObjectName objectName, final String attribute) {	final ObjectName realObjectName = toLiteralObjectName(objectName);	if (realObjectName != null) {	Object result = invokeWithReconnect(new Callable<Object>() {	public Object call() throws Exception {	return getConnectionOrFail().getAttribute(realObjectName, attribute);	}});	
from for jmx attribute got value 

public void setAttribute(ObjectName objectName, final String attribute, final Object val) {	final ObjectName realObjectName = toLiteralObjectName(objectName);	if (realObjectName != null) {	invokeWithReconnect(new Callable<Void>() {	public Void call() throws Exception {	getConnectionOrFail().setAttribute(realObjectName, new javax.management.Attribute(attribute, val));	return null;	}});	
from for jmx attribute set value 

public void setAttribute(ObjectName objectName, final String attribute, final Object val) {	final ObjectName realObjectName = toLiteralObjectName(objectName);	if (realObjectName != null) {	invokeWithReconnect(new Callable<Void>() {	public Void call() throws Exception {	getConnectionOrFail().setAttribute(realObjectName, new javax.management.Attribute(attribute, val));	return null;	}});	} else {	
from cannot set attribute because mbean not found 

final ObjectName realObjectName = toLiteralObjectName(objectName);	final String[] signature = new String[arguments.length];	for (int i = 0; i < arguments.length; i++) {	Class<?> clazz = arguments[i].getClass();	signature[i] = (CLASSES.containsKey(clazz.getSimpleName()) ? CLASSES.get(clazz.getSimpleName()) : clazz.getName());	}	Object result = invokeWithReconnect(new Callable<Object>() {	public Object call() throws Exception {	return getConnectionOrFail().invoke(realObjectName, method, arguments, signature);	}});	
from for jmx operation got value 

========================= brooklyn sample_2392 =========================

protected void assertNotSshable(Map<?,?> machineConfig) {	try {	assertSshable(machineConfig);	Assert.fail("ssh should not have succeeded "+machineConfig);	} catch (Exception e) {	
exception as expected when testing sshable 

protected List<Exception> releaseMachineSafely(Iterable<? extends JcloudsMachineLocation> machines) {	List<Exception> exceptions = Lists.newArrayList();	List<JcloudsMachineLocation> machinesCopy = ImmutableList.copyOf(machines);	for (JcloudsMachineLocation machine : machinesCopy) {	try {	releaseMachine(machine);	} catch (Exception e) {	
error releasing machine continuing 

========================= brooklyn sample_2541 =========================

protected boolean cancel(TaskCancellationMode mode, Boolean interruptPrimaryThreadOverride) {	if (isDone()) return false;	
cancelling dst 

protected boolean cancel(TaskCancellationMode mode, Boolean interruptPrimaryThreadOverride) {	if (isDone()) return false;	boolean result = super.cancel(mode);	if (interruptPrimaryThreadOverride==null) interruptPrimaryThreadOverride = mode.isAllowedToInterruptTask();	if (log.isTraceEnabled()) {	
dst cancelling mode interruptprimary 

protected boolean cancel(TaskCancellationMode mode, Boolean interruptPrimaryThreadOverride) {	if (isDone()) return false;	boolean result = super.cancel(mode);	if (interruptPrimaryThreadOverride==null) interruptPrimaryThreadOverride = mode.isAllowedToInterruptTask();	if (log.isTraceEnabled()) {	}	synchronized (jobTransitionLock) {	if (primaryThread!=null) {	if (interruptPrimaryThreadOverride) {	
cancelling interrupting 

protected void submitBackgroundInheritingContext(Task<?> task) {	BasicExecutionContext ec = BasicExecutionContext.getCurrentExecutionContext();	if (log.isTraceEnabled()) {	
task submitting background task 

protected void submitBackgroundInheritingContext(Task<?> task) {	BasicExecutionContext ec = BasicExecutionContext.getCurrentExecutionContext();	if (log.isTraceEnabled()) {	}	if (ec==null) {	String message = Tasks.current()!=null ? "Task "+this+" submitting background task requires an ExecutionContext (an ExecutionManager is not enough): submitting "+task+" in "+Tasks.current() : "Cannot submit tasks inside DST when not in a task : submitting "+task+" in "+this;	
rethrowing 

BasicExecutionContext ec = BasicExecutionContext.getCurrentExecutionContext();	if (log.isTraceEnabled()) {	}	if (ec==null) {	String message = Tasks.current()!=null ? "Task "+this+" submitting background task requires an ExecutionContext (an ExecutionManager is not enough): submitting "+task+" in "+Tasks.current() : "Cannot submit tasks inside DST when not in a task : submitting "+task+" in "+this;	throw new IllegalStateException(message);	}	synchronized (task) {	if (task.isSubmitted()) {	if (log.isTraceEnabled()) {	
dst skipping submission of child because it is already submitted 

synchronized (jobTransitionLock) {	currentSecondary = secondaryJob;	submitBackgroundInheritingContext(secondaryJob);	jobTransitionLock.notifyAll();	}	try {	result.add(secondaryJob.get());	} catch (Exception e) {	if (TaskTags.isInessential(secondaryJob)) {	result.add(Tasks.getError(secondaryJob));	
secondary job queue for ignoring error in inessential task 

submitBackgroundInheritingContext(secondaryJob);	jobTransitionLock.notifyAll();	}	try {	result.add(secondaryJob.get());	} catch (Exception e) {	if (TaskTags.isInessential(secondaryJob)) {	result.add(Tasks.getError(secondaryJob));	} else {	if (failureHandlingConfig.cancelSecondariesOnSecondaryFailure) {	
secondary job queue for cancelling remaining due to error in task 

if (TaskTags.isInessential(secondaryJob)) {	result.add(Tasks.getError(secondaryJob));	} else {	if (failureHandlingConfig.cancelSecondariesOnSecondaryFailure) {	synchronized (jobTransitionLock) {	for (Task<?> t: secondaryJobsRemaining) t.cancel(true);	jobTransitionLock.notifyAll();	}	}	if (failureHandlingConfig.abortSecondaryQueueOnSecondaryFailure) {	
aborting secondary job queue for due to error in child task being rethrown 

}	}	if (failureHandlingConfig.abortSecondaryQueueOnSecondaryFailure) {	secondaryQueueAborted = true;	throw e;	}	if (!primaryFinished && failureHandlingConfig.cancelPrimaryOnSecondaryFailure) {	cancel(TaskCancellationMode.INTERRUPT_TASK_BUT_NOT_SUBMITTED_TASKS, false);	}	result.add(Tasks.getError(secondaryJob));	
secondary job queue for continuing in presence of error in child task being remembered 

return result;	}	}).build();	((BasicTask<?>)secondaryJobMaster).proxyTargetTask = DynamicSequentialTask.this;	submitBackgroundInheritingContext(secondaryJobMaster);	T result = null;	Throwable error = null;	Throwable uninterestingSelfError = null;	boolean errorIsFromChild = false;	try {	
calling primary job for 

if (primaryJob!=null) result = primaryJob.call();	} catch (Throwable selfException) {	Exceptions.propagateIfFatal(selfException);	if (Exceptions.getFirstThrowableOfType(selfException, QueueAbortedException.class) != null) {	uninterestingSelfError = selfException;	} else {	error = selfException;	errorIsFromChild = false;	}	if (failureHandlingConfig.abortSecondaryQueueOnPrimaryFailure) {	
secondary job queue for aborting with remaining due to error in primary task 

if (Exceptions.getFirstThrowableOfType(selfException, QueueAbortedException.class) != null) {	uninterestingSelfError = selfException;	} else {	error = selfException;	errorIsFromChild = false;	}	if (failureHandlingConfig.abortSecondaryQueueOnPrimaryFailure) {	secondaryQueueAborted = true;	}	if (failureHandlingConfig.cancelSecondariesOnPrimaryFailure) {	
cancelling remaining due to error in primary task 

}	if (failureHandlingConfig.cancelSecondariesOnPrimaryFailure) {	synchronized (jobTransitionLock) {	for (Task<?> t: secondaryJobsRemaining) t.cancel(true);	primaryThread = null;	primaryFinished = true;	}	}	} finally {	try {	
cleaning up for 

}	}	} finally {	try {	synchronized (jobTransitionLock) {	primaryThread = null;	primaryFinished = true;	jobTransitionLock.notifyAll();	}	if (!isCancelled() && !Thread.currentThread().isInterrupted()) {	
waiting for secondaries for 

try {	if (primaryJob==null) result = (T)result2;	} catch (ClassCastException e) { /* ignore class cast exception; leave the result as null */ }	}	} catch (Throwable childException) {	Exceptions.propagateIfFatal(childException);	if (error==null) {	error = childException;	errorIsFromChild = true;	} else {	
parent task ignoring child error in presence of our own error 

public void handleException(Throwable throwable, boolean fromChild) throws Exception {	Exceptions.propagateIfFatal(throwable);	if (fromChild && !failureHandlingConfig.failParentOnSecondaryFailure) {	
parent task swallowing child error 

========================= brooklyn sample_1506 =========================

FrameworkFactory factory = newFrameworkFactory();	Stopwatch timer = Stopwatch.createStarted();	Framework framework = factory.newFramework(cfg);	try {	framework.init();	installBootBundles(framework);	framework.start();	} catch (Exception e) {	throw Exceptions.propagate(e);	}	
system bundles are 

FrameworkFactory factory = newFrameworkFactory();	Stopwatch timer = Stopwatch.createStarted();	Framework framework = factory.newFramework(cfg);	try {	framework.init();	installBootBundles(framework);	framework.start();	} catch (Exception e) {	throw Exceptions.propagate(e);	}	
osgi framework started in 

private static void installBootBundles(Framework framework) {	Stopwatch timer = Stopwatch.createStarted();	
installing osgi boot bundles from 

resources = EmbeddedFelixFramework.class.getClassLoader().getResources(MANIFEST_PATH);	} catch (IOException e) {	throw Exceptions.propagate(e);	}	BundleContext bundleContext = framework.getBundleContext();	Map<String, Bundle> installedBundles = getInstalledBundlesById(bundleContext);	while(resources.hasMoreElements()) {	URL url = resources.nextElement();	ReferenceWithError<?> installResult = installExtensionBundle(bundleContext, url, installedBundles, OsgiUtils.getVersionedId(framework));	if (installResult.hasError() && !installResult.masksErrorIfPresent()) {	
unable to install manifest from 

ReferenceWithError<?> installResult = installExtensionBundle(bundleContext, url, installedBundles, OsgiUtils.getVersionedId(framework));	if (installResult.hasError() && !installResult.masksErrorIfPresent()) {	} else {	Object result = installResult.getWithoutError();	if (result instanceof Bundle) {	String v = OsgiUtils.getVersionedId( (Bundle)result );	SYSTEM_BUNDLES.add(v);	if (installResult.hasError()) {	LOG.debug(installResult.getError().getMessage()+(result!=null ? " ("+result+"/"+v+")" : ""));	} else {	
installed from 

SYSTEM_BUNDLES.add(v);	if (installResult.hasError()) {	LOG.debug(installResult.getError().getMessage()+(result!=null ? " ("+result+"/"+v+")" : ""));	} else {	}	} else if (installResult.hasError()) {	LOG.debug(installResult.getError().getMessage());	}	}	}	
installed osgi boot bundles in 

String versionedId = OsgiUtils.getVersionedId(manifest);	URL bundleUrl = OsgiUtils.getContainerUrl(manifestUrl, MANIFEST_PATH);	Bundle existingBundle = installedBundles.get(versionedId);	if (existingBundle != null) {	if (!bundleUrl.equals(existingBundle.getLocation()) && !versionedId.equals(frameworkVersionedId)) {	return ReferenceWithError.newInstanceMaskingError(null, new IllegalArgumentException("Bundle "+versionedId+" (from manifest " + manifestUrl + ") is already installed, from " + existingBundle.getLocation()));	}	return ReferenceWithError.newInstanceMaskingError(existingBundle, new IllegalArgumentException("Bundle "+versionedId+" from manifest " + manifestUrl + " is already installed"));	}	byte[] jar = buildExtensionBundle(manifest);	
installing boot bundle 

========================= brooklyn sample_1855 =========================

public Server start() {	if (this.mgmt == null) {	mgmt = new LocalManagementContext();	}	BrooklynCampPlatformLauncherAbstract platform = new BrooklynCampPlatformLauncherNoServer() .useManagementContext(mgmt) .launch();	((LocalManagementContext)mgmt).noteStartupComplete();	
started 

private static Server startServer(ManagementContext mgmt, ContextHandler context, String summary, boolean disableHighAvailability) {	boolean secure = mgmt != null && !BrooklynWebConfig.hasNoSecurityOptions(mgmt.getConfig());	if (secure) {	
detected security configured launching server on all network interfaces 

private static Server startServer(ManagementContext mgmt, ContextHandler context, String summary, boolean disableHighAvailability) {	boolean secure = mgmt != null && !BrooklynWebConfig.hasNoSecurityOptions(mgmt.getConfig());	if (secure) {	} else {	
detected no security configured launching server on loopback localhost network interface only 

private static Server startServer(ManagementContext mgmt, ContextHandler context, String summary, boolean disableHighAvailability) {	boolean secure = mgmt != null && !BrooklynWebConfig.hasNoSecurityOptions(mgmt.getConfig());	if (secure) {	} else {	if (mgmt!=null) {	
detected no security configured running on loopback disabling authentication 

private static Server startServer(ManagementContext mgmt, ContextHandler context, String summary, InetSocketAddress bindLocation) {	Server server = new Server(bindLocation);	initJaas(mgmt, server);	server.setHandler(context);	try {	server.start();	} catch (Exception e) {	throw Exceptions.propagate(e);	}	
brooklyn rest server started on 

private static Server startServer(ManagementContext mgmt, ContextHandler context, String summary, InetSocketAddress bindLocation) {	Server server = new Server(bindLocation);	initJaas(mgmt, server);	server.setHandler(context);	try {	server.start();	} catch (Exception e) {	throw Exceptions.propagate(e);	}	
http return server 

public static void main(String[] args) throws Exception {	startRestResourcesViaServlet();	
press ctrl c to quit 

========================= brooklyn sample_2795 =========================

static Integer checkInt(String context, long value, Integer ifTooLarge) {	if (value > Integer.MAX_VALUE) {	
value for too large in sshjclientconnection using 

public void clear() {	if (ssh != null && ssh.isConnected()) {	try {	
disconnecting sshjclientconnection 

public void clear() {	if (ssh != null && ssh.isConnected()) {	try {	ssh.disconnect();	} catch (IOException e) {	
exception disconnecting from 

public SSHClient create() throws Exception {	
connecting sshjclientconnection 

========================= brooklyn sample_1443 =========================

public HostGeoInfo getHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	String url = getPropertiesLookupUrlFor(address);	
geo info lookup for at 

public HostGeoInfo getHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	String url = getPropertiesLookupUrlFor(address);	Properties props = new Properties();	try {	props.load( new URL(url).openStream() );	HostGeoInfo geo = new HostGeoInfo(address.getHostName(), props.getProperty("city")+" ("+props.getProperty("iso2")+")", Double.parseDouble(props.getProperty("latitude")), Double.parseDouble(props.getProperty("longitude")));	
geo info lookup for returned 

public HostGeoInfo getHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	String url = getPropertiesLookupUrlFor(address);	Properties props = new Properties();	try {	props.load( new URL(url).openStream() );	HostGeoInfo geo = new HostGeoInfo(address.getHostName(), props.getProperty("city")+" ("+props.getProperty("iso2")+")", Double.parseDouble(props.getProperty("latitude")), Double.parseDouble(props.getProperty("longitude")));	return geo;	} catch (Exception e) {	
geo info lookup for failed 

public HostGeoInfo getHostGeoInfo(InetAddress address) throws MalformedURLException, IOException {	String url = getPropertiesLookupUrlFor(address);	Properties props = new Properties();	try {	props.load( new URL(url).openStream() );	HostGeoInfo geo = new HostGeoInfo(address.getHostName(), props.getProperty("city")+" ("+props.getProperty("iso2")+")", Double.parseDouble(props.getProperty("latitude")), Double.parseDouble(props.getProperty("longitude")));	return geo;	} catch (Exception e) {	if (!LOGGED_GEO_LOOKUP_UNAVAILABLE) {	LOGGED_GEO_LOOKUP_UNAVAILABLE = true;	
geo info lookup unavailable for cause 

========================= brooklyn sample_1290 =========================

public ScriptExecutionSummary groovy(HttpServletRequest request, String script) {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user());	}	
web rest executing user supplied script 

public ScriptExecutionSummary groovy(HttpServletRequest request, String script) {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user());	}	if (log.isDebugEnabled()) {	
web rest user supplied script contents 

}	GroovyShell shell = new GroovyShell(binding);	OutputCapturingContext stdout = ThreadLocalPrintStream.stdout().captureTee();	OutputCapturingContext stderr = ThreadLocalPrintStream.stderr().captureTee();	Object value = null;	Throwable problem = null;	try {	value = shell.evaluate(script);	if (session!=null) session.setAttribute(USER_LAST_VALUE_SESSION_ATTRIBUTE, value);	} catch (Throwable t) {	
problem in user supplied script 

========================= brooklyn sample_2900 =========================

protected void doTest(Location loc) throws Exception {	
testing cassandra on 

========================= brooklyn sample_318 =========================

public static void closeQuietly(Closeable x) {	try {	if (x!=null) x.close();	} catch (Exception e) {	
error closing ignored 

========================= brooklyn sample_2003 =========================

public void setUp() throws Exception {	mementoDir = Os.newTempDir(getClass());	File mementoDirParent = mementoDir.getParentFile();	mementoDirBackup = new File(mementoDirParent, mementoDir.getName()+"."+Identifiers.makeRandomId(4)+".bak");	origManagementContext = createOrigManagementContext();	origApp = origManagementContext.getEntityManager().createEntity(EntitySpec.create(BasicApplication.class));	
test persisting to 

========================= brooklyn sample_2517 =========================

public List<EntityConfigSummary> list(final String application, final String entityToken) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to see entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	List<EntityConfigSummary> result = Lists.newArrayList();	for (ConfigKey<?> key : entity.getEntityType().getConfigKeys()) {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_CONFIG, new EntityAndItem<String>(entity, key.getName()))) {	
user not authorized to see config of entity excluding from configkey list results 

public Map<String, Object> call() throws Exception {	Map<ConfigKey<?>, Object> source = ( (EntityConfigMap)((EntityInternal) entity).config().getInternalConfigMap() ).getAllConfigInheritedRawValuesIgnoringErrors();	Map<String, Object> result = Maps.newLinkedHashMap();	for (Map.Entry<ConfigKey<?>, Object> ek : source.entrySet()) {	ConfigKey<?> key = ek.getKey();	Object value = ek.getValue();	if (!Entitlements.isEntitled(mgmt.getEntitlementManager(), Entitlements.SEE_CONFIG, new EntityAndItem<String>(entity, ek.getKey().getName()))) {	
user not authorized to see sensor of entity excluding from current state results 

public void setFromMap(String application, String entityToken, Boolean recurse, Map newValues) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to modify entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	
rest user setting configs 

public void set(String application, String entityToken, String configName, Boolean recurse, Object newValue) {	final Entity entity = brooklyn().getEntity(application, entityToken);	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to modify entity '%s'", Entitlements.getEntitlementContext().user(), entity);	}	ConfigKey ck = findConfig(entity, configName);	
rest setting config on to 

========================= brooklyn sample_2901 =========================

} else {	out = in;	}	URL urlOut;	try {	urlOut = out.toURL();	} catch (MalformedURLException e) {	throw Exceptions.propagate(e);	}	if (!urlOut.equals(url) && log.isDebugEnabled()) {	
quietly changing to 

========================= brooklyn sample_1507 =========================

public String toString(T memento) {	RuntimeException lastException = null;	int attempt = 0;	do {	attempt++;	try {	String result = delegate.toString(memento);	
success following previous serialization error 

public String toString(T memento) {	RuntimeException lastException = null;	int attempt = 0;	do {	attempt++;	try {	String result = delegate.toString(memento);	return result;	} catch (RuntimeException e) {	
error serializing memento attempt of for expected sometimes if attribute value modified 

public T fromString(String string) {	if (string==null) return null;	RuntimeException lastException = null;	int attempt = 0;	do {	attempt++;	try {	T result = delegate.fromString(string);	
success following previous deserialization error got 

public T fromString(String string) {	if (string==null) return null;	RuntimeException lastException = null;	int attempt = 0;	do {	attempt++;	try {	T result = delegate.fromString(string);	return result;	} catch (RuntimeException e) {	
error deserializing memento attempt of 

========================= brooklyn sample_1157 =========================

public void testResizeDownDoesNotReleaseClaimedMachines() {	TestApplication app = createAppWithChildren(getInitialPoolSize() - 1);	app.start(ImmutableList.of(pool.getDynamicLocation()));	assertAvailableCountEventuallyEquals(1);	assertClaimedCountEventuallyEquals(getInitialPoolSize() - 1);	
test attempting to resize to members should only drop the one available machine 

========================= brooklyn sample_2281 =========================

protected static void warnOnDeprecated(Map<String, ?> props, String deprecatedKey, String correctKey) {	if (props.containsKey(deprecatedKey)) {	if (correctKey != null && props.containsKey(correctKey)) {	Object dv = props.get(deprecatedKey);	Object cv = props.get(correctKey);	if (!Objects.equal(cv, dv)) {	
sshtool detected deprecated key with different value than new key ambiguous which will be used 

protected static void warnOnDeprecated(Map<String, ?> props, String deprecatedKey, String correctKey) {	if (props.containsKey(deprecatedKey)) {	if (correctKey != null && props.containsKey(correctKey)) {	Object dv = props.get(deprecatedKey);	Object cv = props.get(correctKey);	if (!Objects.equal(cv, dv)) {	} else {	}	} else {	Object dv = props.get(deprecatedKey);	
sshtool detected deprecated key used with value 

========================= brooklyn sample_1442 =========================

public void testStartsAppViaEffector() throws Exception {	URI webConsoleUri = URI.create(ENDPOINT_ADDRESS_HTTP);	EntitySpec<BrooklynNode> spec = EntitySpec.create(BrooklynNode.class);	EntityManager mgr = getManagementContext().getEntityManager();	BrooklynNode node = mgr.createEntity(spec);	node.sensors().set(BrooklynNode.WEB_CONSOLE_URI, webConsoleUri);	mgr.manage(node);	Map<String, String> params = ImmutableMap.of(DeployBlueprintEffector.BLUEPRINT_CAMP_PLAN.getName(), "{ services: [ serviceType: \"java:"+BasicApplication.class.getName()+"\" ] }");	String id = node.invoke(BrooklynNode.DEPLOY_BLUEPRINT, params).getUnchecked();	
got 

EntityManager mgr = getManagementContext().getEntityManager();	BrooklynNode node = mgr.createEntity(spec);	node.sensors().set(BrooklynNode.WEB_CONSOLE_URI, webConsoleUri);	mgr.manage(node);	Map<String, String> params = ImmutableMap.of(DeployBlueprintEffector.BLUEPRINT_CAMP_PLAN.getName(), "{ services: [ serviceType: \"java:"+BasicApplication.class.getName()+"\" ] }");	String id = node.invoke(BrooklynNode.DEPLOY_BLUEPRINT, params).getUnchecked();	String apps = HttpTool.getContent(getEndpointAddress() + "/applications");	List<String> appType = parseJsonList(apps, ImmutableList.of("spec", "type"), String.class);	assertEquals(appType, ImmutableList.of(BasicApplication.class.getName()));	String status = HttpTool.getContent(getEndpointAddress()+"/applications/"+id+"/entities/"+id+"/sensors/service.status");	
status 

========================= brooklyn sample_2813 =========================

public void tearDown() throws Exception {	try {	if (serverSocket != null) serverSocket.close();	} catch (IOException e) {	
error closing server socket continuing 

public void testExplicitAssertionForNotReachableWhenReachable() throws Exception {	TestEndpointReachable test = app.createAndManageChild(EntitySpec.create(TestEndpointReachable.class) .configure(TestEndpointReachable.TARGET_ENTITY, app) .configure(TestEndpointReachable.ENDPOINT, serverSocketHostAndPort.toString()) .configure(TestEndpointReachable.TIMEOUT, Duration.millis(100)) .configure(TestEndpointReachable.ASSERTIONS, ImmutableMap.of(TestEndpointReachable.REACHABLE_KEY, "false")));	try {	app.start(ImmutableList.of(loc));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
as desired failed to start app with testendpointreachable 

public void testHardcodedEndpointNotReachable() throws Exception {	HostAndPort unusedPort = findUnusedPort();	TestEndpointReachable test = app.createAndManageChild(EntitySpec.create(TestEndpointReachable.class) .configure(TestEndpointReachable.TARGET_ENTITY, app) .configure(TestEndpointReachable.ENDPOINT, unusedPort.toString()) .configure(TestEndpointReachable.TIMEOUT, Duration.millis(100)));	try {	app.start(ImmutableList.of(loc));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
as desired failed to start app with testendpointreachable 

public void testSensorEndpointNotReachable() throws Exception {	AttributeSensor<String> sensor = Sensors.newStringSensor("test.reachable.endpoint");	HostAndPort unusedPort = findUnusedPort();	TestEndpointReachable test = app.createAndManageChild(EntitySpec.create(TestEndpointReachable.class) .configure(TestEndpointReachable.TARGET_ENTITY, app) .configure(TestEndpointReachable.ENDPOINT, unusedPort.toString()) .configure(TestEndpointReachable.TIMEOUT, Duration.millis(100)));	app.sensors().set(sensor, unusedPort.toString());	try {	app.start(ImmutableList.of(loc));	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
as desired failed to start app with testendpointreachable 

========================= brooklyn sample_2405 =========================

public static File getBrooklynWebTmpDir(ManagementContext mgmt) {	String brooklynMgmtBaseDir = getMgmtBaseDir(mgmt);	File webappTempDir = new File(Os.mergePaths(brooklynMgmtBaseDir, "planes", mgmt.getManagementNodeId(), "jetty"));	try {	FileUtils.forceMkdir(webappTempDir);	Os.deleteOnExitRecursivelyAndEmptyParentsUpTo(webappTempDir, new File(brooklynMgmtBaseDir));	return webappTempDir;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	IllegalStateException e2 = new IllegalStateException("Cannot create working directory "+webappTempDir+" for embedded jetty server: "+e, e);	
rethrowing 

public static File getOsgiCacheDirCleanedIfNeeded(ManagementContext mgmt) {	File cacheDirF = getOsgiCacheDir(mgmt);	boolean clean = isOsgiCacheForCleaning(mgmt, cacheDirF);	
osgi cache dir computed as already exists does not exist cleaning now and on exit cleaning not requested 

========================= brooklyn sample_1383 =========================

public void start(Collection<? extends Location> locations) {	
starting 

public void stop() {	
stopping 

public void restart() {	
restarting 

========================= brooklyn sample_1679 =========================

protected void onEntityAdded(Entity item) {	synchronized (memberChangeMutex) {	if (acceptsEntity(item)) {	
detected item add 

protected void onEntityRemoved(Entity item) {	synchronized (memberChangeMutex) {	
detected item removal 

protected void onEntityChanged(Entity item) {	synchronized (memberChangeMutex) {	boolean accepts = acceptsEntity(item);	boolean has = hasMember(item);	if (has && !accepts) {	removeMember(item);	
detected item removal on change of 

protected void onEntityChanged(Entity item) {	synchronized (memberChangeMutex) {	boolean accepts = acceptsEntity(item);	boolean has = hasMember(item);	if (has && !accepts) {	removeMember(item);	} else if (!has && accepts) {	
detected item add on change of 

public void onManagementBecomingMaster() {	if (setChangeListener != null) {	
becoming master twice 

if (setChangeListener != null) {	return;	}	setChangeListener = new MyEntitySetChangeListener();	((ManagementContextInternal) getManagementContext()).addEntitySetListener(setChangeListener);	Task<Object> rescan = Tasks.builder().displayName("rescan entities").body( new Runnable() {	public void run() {	try {	rescanEntities();	} catch (Exception e) {	
error rescanning entities on management of may be a group set against an unknown entity 

if (setChangeListener != null) {	return;	}	setChangeListener = new MyEntitySetChangeListener();	((ManagementContextInternal) getManagementContext()).addEntitySetListener(setChangeListener);	Task<Object> rescan = Tasks.builder().displayName("rescan entities").body( new Runnable() {	public void run() {	try {	rescanEntities();	} catch (Exception e) {	
trace for rescan entities error 

public void onManagementNoLongerMaster() {	if (setChangeListener == null) {	
no longer master twice 

public void rescanEntities() {	synchronized (memberChangeMutex) {	if (!isRunning() || !getManagementSupport().isDeployed()) {	
not scanning for children stopped 

public void rescanEntities() {	synchronized (memberChangeMutex) {	if (!isRunning() || !getManagementSupport().isDeployed()) {	return;	}	if (getApplication() == null) {	
not yet scanning for children no application defined 

if (!isRunning() || !getManagementSupport().isDeployed()) {	return;	}	if (getApplication() == null) {	return;	}	boolean changed = false;	Collection<Entity> currentMembers = getMembers();	Collection<Entity> toRemove = Sets.newLinkedHashSet(currentMembers);	final Iterable<Entity> unfiltered = Entities.descendantsAndSelf(getApplication());	
filtering with 

if (getApplication() == null) {	return;	}	boolean changed = false;	Collection<Entity> currentMembers = getMembers();	Collection<Entity> toRemove = Sets.newLinkedHashSet(currentMembers);	final Iterable<Entity> unfiltered = Entities.descendantsAndSelf(getApplication());	for (Entity it : Iterables.filter(unfiltered, entityFilter())) {	toRemove.remove(it);	if (!currentMembers.contains(it)) {	
rescan detected new item 

Collection<Entity> toRemove = Sets.newLinkedHashSet(currentMembers);	final Iterable<Entity> unfiltered = Entities.descendantsAndSelf(getApplication());	for (Entity it : Iterables.filter(unfiltered, entityFilter())) {	toRemove.remove(it);	if (!currentMembers.contains(it)) {	addMember(it);	changed = true;	}	}	for (Entity it : toRemove) {	
rescan detected vanished item 

toRemove.remove(it);	if (!currentMembers.contains(it)) {	addMember(it);	changed = true;	}	}	for (Entity it : toRemove) {	removeMember(it);	changed = true;	}	
rescan complete members now 

========================= brooklyn sample_1550 =========================

public void gcIteration() {	try {	logUsage("brooklyn gc (before)");	gcTasks();	logUsage("brooklyn gc (after)");	double memUsage = 1.0 - 1.0*Runtime.getRuntime().freeMemory() / Runtime.getRuntime().maxMemory();	if (memUsage > brooklynProperties.getConfig(FORCE_CLEAR_SOFT_REFERENCES_ON_MEMORY_USAGE_LEVEL)) {	
forcing brooklyn gc including soft reference cleansing due to memory usage 

public void gcIteration() {	try {	logUsage("brooklyn gc (before)");	gcTasks();	logUsage("brooklyn gc (after)");	double memUsage = 1.0 - 1.0*Runtime.getRuntime().freeMemory() / Runtime.getRuntime().maxMemory();	if (memUsage > brooklynProperties.getConfig(FORCE_CLEAR_SOFT_REFERENCES_ON_MEMORY_USAGE_LEVEL)) {	MemoryUsageTracker.forceClearSoftReferences();	System.gc(); System.gc();	
forced cleansing brooklyn gc usage now 

double memUsage = 1.0 - 1.0*Runtime.getRuntime().freeMemory() / Runtime.getRuntime().maxMemory();	if (memUsage > brooklynProperties.getConfig(FORCE_CLEAR_SOFT_REFERENCES_ON_MEMORY_USAGE_LEVEL)) {	MemoryUsageTracker.forceClearSoftReferences();	System.gc(); System.gc();	} else if (brooklynProperties.getConfig(DO_SYSTEM_GC)) {	System.gc(); System.gc();	logUsage("brooklyn gc (after system gc)");	}	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	
error during management context gc 

Duration maxTaskAge = brooklynProperties.getConfig(MAX_TASK_AGE);	Collection<Task<?>> allTasks = executionManager.allTasksLive();	Collection<Task<?>> tasksToDelete = MutableList.of();	try {	for (Task<?> task: allTasks) {	if (!task.isDone()) continue;	if (BrooklynTaskTags.isSubTask(task)) continue;	if (maxTaskAge.isShorterThan(Duration.sinceUtc(task.getEndTimeUtc()))) tasksToDelete.add(task);	}	} catch (ConcurrentModificationException e) {	
got cme inspecting aged tasks with found for deletion 

Collection<Task<?>> tasksToDelete = MutableList.of();	try {	for (Task<?> task: allTasks) {	if (!task.isDone()) continue;	Task<?> submitter = task.getSubmittedByTask();	if (submitter!=null && submitter.isDone() && executionManager.getTask(submitter.getId())==null) {	tasksToDelete.add(task);	}	}	} catch (ConcurrentModificationException e) {	
got cme inspecting aged tasks with found for deletion 

taskTagsInCategoryOverCapacity.remove(tag);	if (taskTagsInCategoryOverCapacity.isEmpty()) return 0;	}	}	}	}	}	}	}	} catch (ConcurrentModificationException e) {	
got cme inspecting tasks with found for deletion 

if (taskTagsInCategoryOverCapacity.isEmpty()) return 0;	}	}	}	}	}	}	}	} catch (ConcurrentModificationException e) {	}	
brooklyn gc detected tags over capacity expiring old tasks tasks under consideration categories are 

break;	}	}	if (delete) {	deleted++;	executionManager.deleteTask(task);	for (Object tag: task.getTags()) {	AtomicInteger counter = taskAllTagsOverCapacity.get(tag);	if (counter!=null && counter.decrementAndGet()<=0) taskTagsInCategoryOverCapacity.remove(tag);	}	
brooklyn gc deleted buckets now 

if (delete) {	deleted++;	executionManager.deleteTask(task);	for (Object tag: task.getTags()) {	AtomicInteger counter = taskAllTagsOverCapacity.get(tag);	if (counter!=null && counter.decrementAndGet()<=0) taskTagsInCategoryOverCapacity.remove(tag);	}	if (taskTagsInCategoryOverCapacity.isEmpty()) break;	}	}	
brooklyn gc deleted tasks in over capacity tag categories capacities now 

protected int expireIfOverCapacityGlobally() {	Collection<Task<?>> tasksLive = executionManager.allTasksLive();	if (tasksLive.size() <= brooklynProperties.getConfig(MAX_TASKS_GLOBAL)) return 0;	
brooklyn gc detected tasks in memory over global limit looking at deleting some 

tasksLive = executionManager.getTasksWithAllTags(MutableList.of());	}	MutableList<Task<?>> tasks = MutableList.of();	for (Task<?> task: tasksLive) {	if (task.isDone()) {	tasks.add(task);	}	}	int numToDelete = tasks.size() - brooklynProperties.getConfig(MAX_TASKS_GLOBAL);	if (numToDelete <= 0) {	
brooklyn gc detected only completed tasks in memory not over global limit so not deleting any 

}	int numToDelete = tasks.size() - brooklynProperties.getConfig(MAX_TASKS_GLOBAL);	if (numToDelete <= 0) {	return 0;	}	Collections.sort(tasks, TASKS_OLDEST_FIRST_COMPARATOR);	int numDeleted = 0;	while (numDeleted < numToDelete && tasks.size()>numDeleted) {	executionManager.deleteTask( tasks.get(numDeleted++) );	}	
brooklyn gc deleted tasks as was over global limit now have 

========================= brooklyn sample_1045 =========================

private void readPropertiesFromMavenResource(ClassLoader resourceLoader) {	InputStream versionStream = null;	try {	versionStream = resourceLoader.getResourceAsStream(MVN_VERSION_RESOURCE_FILE);	if (versionStream == null) {	if (isDevelopmentEnvironment()) {	
no maven resource file available 

private void readPropertiesFromMavenResource(ClassLoader resourceLoader) {	InputStream versionStream = null;	try {	versionStream = resourceLoader.getResourceAsStream(MVN_VERSION_RESOURCE_FILE);	if (versionStream == null) {	if (isDevelopmentEnvironment()) {	} else {	
no maven resource file available 

try {	versionStream = resourceLoader.getResourceAsStream(MVN_VERSION_RESOURCE_FILE);	if (versionStream == null) {	if (isDevelopmentEnvironment()) {	} else {	}	return;	}	versionProperties.load(checkNotNull(versionStream));	} catch (IOException e) {	
error reading maven resource file 

ManifestHelper mh = ManifestHelper.forManifest(us);	if (BROOKLYN_CORE_SYMBOLIC_NAME.equals(mh.getSymbolicName())) {	Attributes attrs = mh.getManifest().getMainAttributes();	for (Object key : attrs.keySet()) {	versionProperties.put(key.toString(), attrs.getValue(key.toString()));	}	return;	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error reading osgi manifest from when determining version properties 

}	return;	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	} finally {	Streams.closeQuietly(us);	}	}	if (isDevelopmentEnvironment()) {	
no osgi manifest available to determine version properties 

return;	}	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	} finally {	Streams.closeQuietly(us);	}	}	if (isDevelopmentEnvironment()) {	} else {	
no osgi manifest available to determine version properties 

Enumeration<URL> paths;	try {	paths = BrooklynVersion.class.getClassLoader().getResources("org/apache/brooklyn/core/BrooklynVersion.class");	} catch (IOException e) {	throw Exceptions.propagate(e);	}	while (paths.hasMoreElements()) {	URL u = paths.nextElement();	if (u.getPath().endsWith("org/apache/brooklyn/core/BrooklynVersion.class")) {	try {	
brooklyn dev src environment detected brooklynversion class is at 

} catch (IOException e) {	throw Exceptions.propagate(e);	}	while (paths.hasMoreElements()) {	URL u = paths.nextElement();	if (u.getPath().endsWith("org/apache/brooklyn/core/BrooklynVersion.class")) {	try {	return true;	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error reading manifest to determine whether this is a development environment 

OsgiBrooklynClassLoadingContext osgiContext = new OsgiBrooklynClassLoadingContext(mgmt, t.getId(), t.getLibraries());	Iterables.addAll(manifests, osgiContext.getResources(MANIFEST_PATH));	}	ImmutableSet.Builder<BrooklynFeature> features = ImmutableSet.builder();	for (URL manifest : manifests) {	ManifestHelper mh = null;	try {	mh = ManifestHelper.forManifest(manifest);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
error reading osgi manifest from when determining version properties 

========================= brooklyn sample_1415 =========================

public void testFromHash() {	String id1 = Identifiers.makeIdFromHash("Hello".hashCode());	Assert.assertTrue(!Strings.isBlank(id1));	String id2 = Identifiers.makeIdFromHash("hello".hashCode());	String id3 = Identifiers.makeIdFromHash("hello".hashCode());	Assert.assertEquals(id2, id3);	Assert.assertNotEquals(id1, id2);	Assert.assertEquals(Identifiers.makeIdFromHash(0), "A");	String idLong = Identifiers.makeIdFromHash(Long.MAX_VALUE);	
id s made from hash of hello is and of long max value is 

public void testFromNegativeHash() {	String id1 = Identifiers.makeIdFromHash(-1);	Assert.assertTrue(!Strings.isBlank(id1));	
id s made from hash of is and of long min value is 

========================= brooklyn sample_1946 =========================

public void updateBindConfiguration() {	
skipped copy of bind configuration files to server 

public void updateBindConfiguration() {	
configuration 

public void updateBindConfiguration() {	
domain zone 

public void updateBindConfiguration() {	
reverse zone 

protected void configureResolver(Entity entity) {	
skipped configuration of resolver on 

protected void appendTemplate(String template, String destination, SshMachineLocation machine) {	
skipped append of template to 

========================= brooklyn sample_122 =========================

public void testCheckRunningForcesInessential() {	MyService entity = app.createAndManageChild(EntitySpec.create(MyService.class, MyServiceInessentialDriverImpl.class));	entity.start(ImmutableList.of(loc));	SimulatedInessentialIsRunningDriver driver = (SimulatedInessentialIsRunningDriver) entity.getDriver();	Assert.assertTrue(driver.isRunning());	EntityAsserts.assertAttributeEqualsEventually(entity, SoftwareProcess.SERVICE_PROCESS_IS_RUNNING, true);	EntityAsserts.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, true);	
up now cause failure 

public void testCheckRunningForcesInessential() {	MyService entity = app.createAndManageChild(EntitySpec.create(MyService.class, MyServiceInessentialDriverImpl.class));	entity.start(ImmutableList.of(loc));	SimulatedInessentialIsRunningDriver driver = (SimulatedInessentialIsRunningDriver) entity.getDriver();	Assert.assertTrue(driver.isRunning());	EntityAsserts.assertAttributeEqualsEventually(entity, SoftwareProcess.SERVICE_PROCESS_IS_RUNNING, true);	EntityAsserts.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, true);	driver.setFailExecution(true);	EntityAsserts.assertAttributeEqualsEventually(entity, SoftwareProcess.SERVICE_PROCESS_IS_RUNNING, false);	
caught failure now clear 

========================= brooklyn sample_2239 =========================

public BrooklynWebServer(Map<?,?> flags, ManagementContext managementContext) {	this.managementContext = managementContext;	Map<?,?> leftovers = FlagUtils.setFieldsFromFlags(flags, this);	
ignoring unknown flags 

WebAppContext webapp = deploy(contextProvider);	webapp.setTempDirectory(Os.mkdirs(new File(webappTempDir, newTimestampedDirName("war", 8))));	}	rootContext = deploy(rootWar);	deployRestApi(rootContext);	rootContext.setTempDirectory(Os.mkdirs(new File(webappTempDir, "war-root")));	server.setHandler(handlers);	try {	server.start();	} catch (BindException e) {	
initial server start up failed binding retrying after a delay 

String ksPassword = getConfig(keystorePassword, BrooklynWebConfig.KEYSTORE_PASSWORD);	String ksCertAlias = getConfig(keystoreCertAlias, BrooklynWebConfig.KEYSTORE_CERTIFICATE_ALIAS);	String trProtos = getConfig(transportProtocols, BrooklynWebConfig.TRANSPORT_PROTOCOLS);	String trCiphers = getConfig(transportCiphers, BrooklynWebConfig.TRANSPORT_CIPHERS);	if (ksUrl!=null) {	sslContextFactory.setKeyStorePath(getLocalKeyStorePath(ksUrl));	if (Strings.isEmpty(ksPassword)) throw new IllegalArgumentException("Keystore password is required and non-empty if keystore is specified.");	sslContextFactory.setKeyStorePassword(ksPassword);	if (Strings.isNonEmpty(ksCertAlias)) sslContextFactory.setCertAlias(ksCertAlias);	} else {	
no keystore specified but https enabled creating a default keystore 

String trCiphers = getConfig(transportCiphers, BrooklynWebConfig.TRANSPORT_CIPHERS);	if (ksUrl!=null) {	sslContextFactory.setKeyStorePath(getLocalKeyStorePath(ksUrl));	if (Strings.isEmpty(ksPassword)) throw new IllegalArgumentException("Keystore password is required and non-empty if keystore is specified.");	sslContextFactory.setKeyStorePassword(ksPassword);	if (Strings.isNonEmpty(ksCertAlias)) sslContextFactory.setCertAlias(ksCertAlias);	} else {	if (Strings.isEmpty(ksCertAlias)) ksCertAlias = "web-console";	if (Strings.isEmpty(ksPassword)) {	ksPassword = Identifiers.makeRandomId(8);	
created random password for ad hoc internal keystore 

private String getKeystoreUrl() {	if (keystoreUrl != null) {	if (Strings.isNonBlank(keystorePath) && !keystoreUrl.equals(keystorePath)) {	
deprecated keystorepath supplied with different value than keystoreurl preferring the latter 

private String getKeystoreUrl() {	if (keystoreUrl != null) {	if (Strings.isNonBlank(keystorePath) && !keystoreUrl.equals(keystorePath)) {	}	return keystoreUrl;	} else if (Strings.isNonBlank(keystorePath)) {	
deprecated keystorepath used callers should use keystoreurl 

if (shutdownHook != null) Threads.removeShutdownHook(shutdownHook);	if (log.isDebugEnabled()) log.debug("Stopping Brooklyn web console at "+root+ " (" + war + (wars != null ? " and " + wars.values() : "") + ")");	server.stop();	try {	server.join();	} catch (Exception e) {	}	server = null;	LocalhostMachineProvisioningLocation.releasePort(getAddress(), actualPort);	actualPort = -1;	
stopped brooklyn web console at 

protected synchronized void addShutdownHook() {	if (shutdownHook!=null) return;	shutdownHook = Threads.addShutdownHook(new Runnable() {	public void run() {	
brooklynwebserver detected shutdown stopping web console 

protected synchronized void addShutdownHook() {	if (shutdownHook!=null) return;	shutdownHook = Threads.addShutdownHook(new Runnable() {	public void run() {	try {	stop();	} catch (Exception e) {	
failure shutting down web console 

========================= brooklyn sample_572 =========================

protected void waitForApplicationTasks(Entity app) {	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(mgmt().getExecutionManager(), app);	
waiting on task s 

protected Entity createAndStartApplication(String input, Map<String,?> startParameters) throws Exception {	EntitySpec<?> spec = mgmt().getTypeRegistry().createSpecFromPlan(CampTypePlanTransformer.FORMAT, input, RegisteredTypeLoadingContexts.spec(Application.class), EntitySpec.class);	final Entity app = mgmt().getEntityManager().createEntity(spec);	
test created app and will now start 

========================= brooklyn sample_1680 =========================

public void testInteractionOfSecurityFilterAndFormMapProvider() throws Exception {	Stopwatch stopwatch = Stopwatch.createStarted();	try {	Server server = useServerForTest(baseLauncher() .forceUseOfDefaultCatalogWithJavaClassPath(true) .withoutJsgui() .start());	String appId = startAppAtNode(server);	String entityId = getTestEntityInApp(server, appId);	HttpClient client = HttpTool.httpClientBuilder() .uri(getBaseUriRest()) .build();	List<? extends NameValuePair> nvps = Lists.newArrayList( new BasicNameValuePair("arg", "bar"));	String effector = String.format("/applications/%s/entities/%s/effectors/identityEffector", appId, entityId);	HttpToolResponse response = HttpTool.httpPost(client, URI.create(getBaseUriRest() + effector), ImmutableMap.of(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_FORM_URLENCODED.getMimeType()), URLEncodedUtils.format(nvps, Charsets.UTF_8).getBytes());	
effector response 

try {	Server server = useServerForTest(baseLauncher() .forceUseOfDefaultCatalogWithJavaClassPath(true) .withoutJsgui() .start());	String appId = startAppAtNode(server);	String entityId = getTestEntityInApp(server, appId);	HttpClient client = HttpTool.httpClientBuilder() .uri(getBaseUriRest()) .build();	List<? extends NameValuePair> nvps = Lists.newArrayList( new BasicNameValuePair("arg", "bar"));	String effector = String.format("/applications/%s/entities/%s/effectors/identityEffector", appId, entityId);	HttpToolResponse response = HttpTool.httpPost(client, URI.create(getBaseUriRest() + effector), ImmutableMap.of(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_FORM_URLENCODED.getMimeType()), URLEncodedUtils.format(nvps, Charsets.UTF_8).getBytes());	assertTrue(HttpTool.isStatusCodeHealthy(response.getResponseCode()), "response code=" + response.getResponseCode());	} finally {	
testinteractionofsecurityfilterandformmapprovider complete in 

private String getTestEntityInApp(Server server, String appId) throws Exception {	HttpClient client = HttpTool.httpClientBuilder() .uri(getBaseUriRest(server)) .build();	List entities = new ObjectMapper().readValue( HttpTool.httpGet(client, URI.create(getBaseUriRest(server) + "applications/" + appId + "/entities"), MutableMap.<String, String>of()).getContent(), List.class);	
id 

========================= brooklyn sample_2805 =========================

static boolean trySetAccessible(Method method) {	try {	method.setAccessible(true);	if (SET_ACCESSIBLE_SUCCEEDED_LOGGED_METHODS.add(method.toString())) {	
discouraged use of setaccessible called for method 

static boolean trySetAccessible(Method method) {	try {	method.setAccessible(true);	if (SET_ACCESSIBLE_SUCCEEDED_LOGGED_METHODS.add(method.toString())) {	} else {	
discouraged use of setaccessible called for method 

static boolean trySetAccessible(Method method) {	try {	method.setAccessible(true);	if (SET_ACCESSIBLE_SUCCEEDED_LOGGED_METHODS.add(method.toString())) {	} else {	}	return true;	} catch (SecurityException e) {	boolean added = SET_ACCESSIBLE_FAILED_LOGGED_METHODS.add(method.toString());	if (added) {	
problem setting accessible for method 

try {	method.setAccessible(true);	if (SET_ACCESSIBLE_SUCCEEDED_LOGGED_METHODS.add(method.toString())) {	} else {	}	return true;	} catch (SecurityException e) {	boolean added = SET_ACCESSIBLE_FAILED_LOGGED_METHODS.add(method.toString());	if (added) {	} else {	
problem setting accessible for method 

static Maybe<Method> findAccessibleMethod(Method method) {	if (!isAccessible(method)) {	String err = "Method is not public, so not normally accessible for "+method;	if (FIND_ACCESSIBLE_FAILED_LOGGED_METHODS.add(method.toString())) {	
usage may subsequently fail 

}	return Maybe.absent(err);	}	boolean declaringClassAccessible = isAccessible(method.getDeclaringClass());	if (declaringClassAccessible) {	return Maybe.of(method);	}	if (Modifier.isStatic(method.getModifiers())) {	String err = "Static method not declared on a public class, so not normally accessible for "+method;	if (FIND_ACCESSIBLE_FAILED_LOGGED_METHODS.add(method.toString())) {	
usage may subsequently fail 

========================= brooklyn sample_2043 =========================

public InputStream getResourceFromUrl(String url) {	try {	return r.getResourceFromUrl(url);	} catch (Exception e) {	ResourceLocator locator = getLocatorFor(url, config);	if (locator!=null) {	
unable to load resource from attempting with locator 

try {	return r.getResourceFromUrl(url);	} catch (Exception e) {	ResourceLocator locator = getLocatorFor(url, config);	if (locator!=null) {	try {	InputStream result = locator.locate(url, config, r);	if (result!=null) return result;	if (result==null) log.warn("Unable to load resource from "+url+", even with custom locator; rethrowing original exception");	} catch (Exception e2) {	
unable to load resource from even with custom locator rethrowing original exception new exception is 

public InputStream locate(String url, ConfigMap config, ResourceUtils r) {	String cp = System.getProperty("java.class.path");	int cpi = cp.indexOf(classpathSuffixToSearchFor);	if (cpi==-1) return null;	String path = cp.substring(0, cpi);	int lps = path.lastIndexOf(File.pathSeparatorChar);	if (lps>=0) path = path.substring(lps+1);	path = path + classpathSuffixToUse;	
looking for in revised location 

public InputStream locate(String url, ConfigMap config, ResourceUtils r) {	String cp = System.getProperty("java.class.path");	int cpi = cp.indexOf(classpathSuffixToSearchFor);	if (cpi==-1) return null;	String path = cp.substring(0, cpi);	int lps = path.lastIndexOf(File.pathSeparatorChar);	if (lps>=0) path = path.substring(lps+1);	path = path + classpathSuffixToUse;	InputStream result = r.getResourceFromUrl(path);	
using from revised location 

========================= brooklyn sample_564 =========================

public void init() {	super.init();	
initialising owner is 

========================= brooklyn sample_2385 =========================

protected void advertiseUserAsync(final Entity entity, final WinRmMachineLocation machine) {	String user = machine.getUser();	String hostname = machine.getHostname();	int port = machine.getPort();	String password = machine.config().get(WinRmMachineLocation.PASSWORD);	String creds = user + " : " + password + " @ " +hostname + ":" + port;	
advertising user 

========================= brooklyn sample_2151 =========================

protected Entity createAndStartApplication(Reader input) throws Exception {	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	Assembly assembly;	try {	assembly = at.getInstantiator().newInstance().instantiate(at, platform);	} catch (Exception e) {	
unable to instantiate rethrowing 

protected Entity createAndStartApplication(Reader input) throws Exception {	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	Assembly assembly;	try {	assembly = at.getInstantiator().newInstance().instantiate(at, platform);	} catch (Exception e) {	throw e;	}	
test created 

protected Entity createAndStartApplication(Reader input) throws Exception {	AssemblyTemplate at = platform.pdp().registerDeploymentPlan(input);	Assembly assembly;	try {	assembly = at.getInstantiator().newInstance().instantiate(at, platform);	} catch (Exception e) {	throw e;	}	final Entity app = mgmt().getEntityManager().getEntity(assembly.getId());	
app 

========================= brooklyn sample_1638 =========================

public <T> boolean isEntitled(EntitlementContext context, EntitlementClass<T> entitlementClass, T entitlementClassArgument) {	if (log.isTraceEnabled()) {	
checking entitlement of to 

========================= brooklyn sample_1141 =========================

return new Function<SensorEvent<T>, Double>() {	public Double apply(SensorEvent<T> event) {	synchronized (lock) {	Double current = TypeCoercions.coerce(event.getValue(), Double.class);	if (current == null) return null;	long eventTime = event.getTimestamp();	long unitMillis = getConfig(DELTA_PERIOD).toMilliseconds();	Double result = null;	if (eventTime > 0 && eventTime > lastTime) {	if (lastValue == null || lastTime < 0) {	
received event but no last value so will not emit null at 

========================= brooklyn sample_1004 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	
using deprecated use instead 

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof NovaTemplateOptions) {	((NovaTemplateOptions) t).autoAssignFloatingIp((Boolean) v);	} else {	
ignoring auto generate floating ips in vm creation because not supported for cloud type 

========================= brooklyn sample_2628 =========================

public void setUp() throws Exception {	final ApplicationSpec simpleSpec = ApplicationSpec.builder().name("simple-app"). entities(ImmutableSet.of(new EntitySpec("simple-ent", RestMockSimpleEntity.class.getName(), ImmutableMap.of("install.version", "1.0.0")))). locations(ImmutableSet.of("localhost")). build();	startServer();	Response response = clientDeploy(simpleSpec);	int status = response.getStatus();	assertTrue(status >= 200 && status <= 299, "expected HTTP Response of 2xx but got " + status);	applicationUri = response.getLocation();	
built app application 

========================= brooklyn sample_2829 =========================

public static Object removeMultinameAttribute(Map<String,Object> obj, String ...equivalentNames) {	Object result = null;	for (String name: equivalentNames) {	Object candidate = obj.remove(name);	if (candidate!=null) {	if (result==null) result = candidate;	else if (!result.equals(candidate)) {	
different values for attributes preferring to 

public static Object getMultinameAttribute(Map<String,Object> obj, String ...equivalentNames) {	Object result = null;	for (String name: equivalentNames) {	Object candidate = obj.get(name);	if (candidate!=null) {	if (result==null) result = candidate;	else if (!result.equals(candidate)) {	
different values for attributes preferring to 

try {	return mark.getIndex();	} catch (NoSuchMethodError e) {	try {	getClass().getClassLoader().loadClass("org.testng.TestNG");	} catch (ClassNotFoundException e1) {	Exceptions.propagateIfFatal(e1);	throw e;	}	if (!LOGGED_TESTNG_WARNING.getAndSet(true)) {	
detected testng snakeyaml version incompatibilities some yaml source reconstruction will be unavailable this can happen with testng plugins which force an older version of snakeyaml which does not support mark getindex it should not occur from maven cli runs subsequent occurrences will be silently dropped and source code reconstructed from yaml 

public String getMatchedYamlTextOrWarn() {	try {	return getMatchedYamlText();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (e instanceof KnownClassVersionException) {	
known class version exception no yaml text being matched for 

public String getMatchedYamlTextOrWarn() {	try {	return getMatchedYamlText();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (e instanceof KnownClassVersionException) {	} else {	if (e instanceof UserFacingException) {	
unable to match yaml text in 

public String getMatchedYamlTextOrWarn() {	try {	return getMatchedYamlText();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	if (e instanceof KnownClassVersionException) {	} else {	if (e instanceof UserFacingException) {	} else {	
unable to match yaml text in 

try {	int pathIndex = 0;	result.yaml = yaml;	result.focus = newYaml().compose(new StringReader(yaml));	findTextOfYamlAtPath(result, pathIndex, path);	return result;	} catch (NoSuchMethodError e) {	throw new IllegalStateException("Class version error. This can happen if using a TestNG plugin in your IDE " + "which is an older version, dragging in an older version of SnakeYAML which does not support Mark.getIndex.", e);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
unable to find element in yaml setting in result 

========================= brooklyn sample_2080 =========================

protected boolean balanceItemsOnNodesInQuestion(NodeType questionedNode, boolean gonnaGrow) {	double questionedNodeTotalWorkrate = getDataProvider().getTotalWorkrate(questionedNode);	boolean balanced = balanceItemsOnHotNode(questionedNode, questionedNodeTotalWorkrate, gonnaGrow);	if (!balanced || BALANCE_COLD_PULLS_IN_SAME_RUN_AS_HOT_PUSHES) {	balanced |= balanceItemsOnColdNode(questionedNode, questionedNodeTotalWorkrate, gonnaGrow);	}	if (balanced) return true;	if (LOG.isDebugEnabled()) {	
policy not balancing its workrate number is acceptable or cannot be balanced 

int iterationCount = 0;	Set<ItemType> itemsMoved = new LinkedHashSet<ItemType>();	Set<NodeType> nodesChecked = new LinkedHashSet<NodeType>();	Double highThreshold = model.getHighThreshold(node);	if (highThreshold == -1) {	return false;	}	while (nodeWorkrate > highThreshold && migrationCount < getMaxMigrationsPerBalancingNode()) {	iterationCount++;	if (LOG.isDebugEnabled()) {	
policy considering balancing hot node workrate number iteration 

if (highThreshold == -1) {	return false;	}	while (nodeWorkrate > highThreshold && migrationCount < getMaxMigrationsPerBalancingNode()) {	iterationCount++;	if (LOG.isDebugEnabled()) {	}	NodeType coldNode = helper.findColdestContainer(nodesChecked);	if (coldNode == null) {	if (LOG.isDebugEnabled()) {	
policy not balancing hot node workrate number no coldest node available 

if (LOG.isDebugEnabled()) {	}	NodeType coldNode = helper.findColdestContainer(nodesChecked);	if (coldNode == null) {	if (LOG.isDebugEnabled()) {	}	break;	}	if (coldNode.equals(node)) {	if (LOG.isDebugEnabled()) {	
policy not balancing hot node workrate number it is also the coldest modifiable node 

break;	}	double poolLowWatermark = Double.MAX_VALUE;	if (gonnaGrow && (coldNodeWorkrate >= poolLowWatermark && !emergencyLoadBalancing)) {	break;	}	String questionedNodeName = getDataProvider().getName(node);	String coldNodeName = getDataProvider().getName(coldNode);	Location coldNodeLocation = getDataProvider().getLocation(coldNode);	if (LOG.isDebugEnabled()) {	
policy balancing hot node workrate number considering target workrate number 

String coldNodeName = getDataProvider().getName(coldNode);	Location coldNodeLocation = getDataProvider().getLocation(coldNode);	if (LOG.isDebugEnabled()) {	}	double idealSizeToMove = (nodeWorkrate - coldNodeWorkrate) / 2;	if (idealSizeToMove + coldNodeWorkrate > coldNodeHighThreshold) idealSizeToMove = coldNodeHighThreshold - coldNodeWorkrate;	double maxSizeToMoveIdeally = Math.min( nodeWorkrate/2 + 0.00001, (nodeWorkrate - coldNodeWorkrate)*0.9);	double maxSizeToMoveIfNoSmallButLarger = nodeWorkrate*3/4;	Map<ItemType, Double> questionedNodeItems = getDataProvider().getItemWorkrates(node);	if (questionedNodeItems == null) {	
policy balancing hot node workrate number abandoned item report for unavailable 

double idealSizeToMove = (nodeWorkrate - coldNodeWorkrate) / 2;	if (idealSizeToMove + coldNodeWorkrate > coldNodeHighThreshold) idealSizeToMove = coldNodeHighThreshold - coldNodeWorkrate;	double maxSizeToMoveIdeally = Math.min( nodeWorkrate/2 + 0.00001, (nodeWorkrate - coldNodeWorkrate)*0.9);	double maxSizeToMoveIfNoSmallButLarger = nodeWorkrate*3/4;	Map<ItemType, Double> questionedNodeItems = getDataProvider().getItemWorkrates(node);	if (questionedNodeItems == null) {	break;	}	ItemType itemToMove = findBestItemToMove(questionedNodeItems, idealSizeToMove, maxSizeToMoveIdeally, maxSizeToMoveIfNoSmallButLarger, itemsMoved, coldNodeLocation);	if (itemToMove == null) {	
policy balancing hot node workrate number ending no suitable segment found ideal transition item size number max number moving to coldest node workrate number available items 

}	itemsMoved.add(itemToMove);	double itemWorkrate = questionedNodeItems.get(itemToMove);	nodeWorkrate -= itemWorkrate;	coldNodeWorkrate += itemWorkrate;	moveItem(itemToMove, node, coldNode);	++migrationCount;	}	if (LOG.isDebugEnabled()) {	if (iterationCount == 0) {	
policy balancing if hot finished at node workrate number not hot 

double itemWorkrate = questionedNodeItems.get(itemToMove);	nodeWorkrate -= itemWorkrate;	coldNodeWorkrate += itemWorkrate;	moveItem(itemToMove, node, coldNode);	++migrationCount;	}	if (LOG.isDebugEnabled()) {	if (iterationCount == 0) {	}	else if (itemsMoved.isEmpty()) {	
policy balancing finished at hot node workrate number no way to improve it 

nodeWorkrate -= itemWorkrate;	coldNodeWorkrate += itemWorkrate;	moveItem(itemToMove, node, coldNode);	++migrationCount;	}	if (LOG.isDebugEnabled()) {	if (iterationCount == 0) {	}	else if (itemsMoved.isEmpty()) {	} else {	
policy balancing finished at hot node workrate from number to number report now says number by moving off 

protected boolean balanceItemsOnColdNode(NodeType questionedNode, double questionedNodeTotalWorkrate, boolean gonnaGrow) {	Map<ItemType, Double> items = getDataProvider().getItemWorkrates(questionedNode);	if (items == null) {	if (LOG.isDebugEnabled()) {	
policy not balancing cold node workrate number workrate breakdown unavailable probably reverting 

protected boolean balanceItemsOnColdNode(NodeType questionedNode, double questionedNodeTotalWorkrate, boolean gonnaGrow) {	Map<ItemType, Double> items = getDataProvider().getItemWorkrates(questionedNode);	if (items == null) {	if (LOG.isDebugEnabled()) {	}	return false;	}	for (ItemType item : items.keySet()) {	if (!model.isItemMoveable(item)) {	if (LOG.isDebugEnabled()) {	
policy not balancing cold node workrate number at least one item is in flux 

double originalQuestionedNodeTotalWorkrate = questionedNodeTotalWorkrate;	int numMigrations = 0;	Set<ItemType> itemsMoved = new LinkedHashSet<ItemType>();	Set<NodeType> nodesChecked = new LinkedHashSet<NodeType>();	int iters = 0;	Location questionedLocation = getDataProvider().getLocation(questionedNode);	double lowThreshold = model.getLowThreshold(questionedNode);	while (questionedNodeTotalWorkrate < lowThreshold) {	iters++;	if (LOG.isDebugEnabled()) {	
policy considering balancing cold node workrate number iteration 

int iters = 0;	Location questionedLocation = getDataProvider().getLocation(questionedNode);	double lowThreshold = model.getLowThreshold(questionedNode);	while (questionedNodeTotalWorkrate < lowThreshold) {	iters++;	if (LOG.isDebugEnabled()) {	}	NodeType hotNode = helper.findHottestContainer(nodesChecked);	if (hotNode == null) {	if (LOG.isDebugEnabled()) {	
policy not balancing cold node workrate number no hottest node available 

if (LOG.isDebugEnabled()) {	}	NodeType hotNode = helper.findHottestContainer(nodesChecked);	if (hotNode == null) {	if (LOG.isDebugEnabled()) {	}	break;	}	if (hotNode.equals(questionedNode)) {	if (LOG.isDebugEnabled()) {	
policy not balancing cold node workrate number it is also the hottest modfiable node 

}	if (hotNodeWorkrate <= hotNodeLowThreshold && !emergencyLoadBalancing) {	break;	}	if (gonnaGrow && (hotNodeWorkrate <= hotNodeHighThreshold && !emergencyLoadBalancing)) {	break;	}	String questionedNodeName = getDataProvider().getName(questionedNode);	String hotNodeName = getDataProvider().getName(hotNode);	if (LOG.isDebugEnabled()) {	
policy balancing cold node workrate number considering source workrate number 

String hotNodeName = getDataProvider().getName(hotNode);	if (LOG.isDebugEnabled()) {	}	double idealSizeToMove = (hotNodeWorkrate - questionedNodeTotalWorkrate) / 2;	double targetNodeHighThreshold = model.getHighThreshold(questionedNode);	if (idealSizeToMove + questionedNodeTotalWorkrate > targetNodeHighThreshold) idealSizeToMove = targetNodeHighThreshold - questionedNodeTotalWorkrate;	double maxSizeToMoveIdeally = Math.min( hotNodeWorkrate/2, (hotNodeWorkrate - questionedNodeTotalWorkrate)*0.6);	double maxSizeToMoveIfNoSmallButLarger = questionedNodeTotalWorkrate*3/4;	Map<ItemType, Double> hotNodeItems = getDataProvider().getItemWorkrates(hotNode);	if (hotNodeItems == null) {	
policy balancing cold node workrate number excluding hot node because its item report unavailable 

if (idealSizeToMove + questionedNodeTotalWorkrate > targetNodeHighThreshold) idealSizeToMove = targetNodeHighThreshold - questionedNodeTotalWorkrate;	double maxSizeToMoveIdeally = Math.min( hotNodeWorkrate/2, (hotNodeWorkrate - questionedNodeTotalWorkrate)*0.6);	double maxSizeToMoveIfNoSmallButLarger = questionedNodeTotalWorkrate*3/4;	Map<ItemType, Double> hotNodeItems = getDataProvider().getItemWorkrates(hotNode);	if (hotNodeItems == null) {	nodesChecked.add(hotNode);	continue;	}	ItemType itemToMove = findBestItemToMove(hotNodeItems, idealSizeToMove, maxSizeToMoveIdeally, maxSizeToMoveIfNoSmallButLarger, itemsMoved, questionedLocation);	if (itemToMove == null) {	
policy balancing cold node workrate number excluding hot node because it has no appilcable items ideal transition item size number max number moving from hot node workrate number available items 

double segmentRate = hotNodeItems.get(itemToMove);	questionedNodeTotalWorkrate += segmentRate;	hotNodeWorkrate -= segmentRate;	moveItem(itemToMove, hotNode, questionedNode);	if (++numMigrations >= getMaxMigrationsPerBalancingNode()) {	break;	}	}	if (LOG.isDebugEnabled()) {	if (iters == 0) {	
policy balancing if cold finished at node workrate number not cold 

hotNodeWorkrate -= segmentRate;	moveItem(itemToMove, hotNode, questionedNode);	if (++numMigrations >= getMaxMigrationsPerBalancingNode()) {	break;	}	}	if (LOG.isDebugEnabled()) {	if (iters == 0) {	}	else if (itemsMoved.isEmpty()) {	
policy balancing finished at cold node workrate number no way to improve it 

moveItem(itemToMove, hotNode, questionedNode);	if (++numMigrations >= getMaxMigrationsPerBalancingNode()) {	break;	}	}	if (LOG.isDebugEnabled()) {	if (iters == 0) {	}	else if (itemsMoved.isEmpty()) {	} else {	
policy balancing finished at cold node workrate from number to number report now says number by moving in 

protected ItemType findBestItemToMove(Map<ItemType, Double> costsPerItem, double targetCost, double maxCost, double maxCostIfNothingSmallerButLarger, Set<ItemType> excludedItems, Location locationIfKnown) {	ItemType closestMatch = null;	ItemType smallestMoveable = null, largest = null;	double minDiff = Double.MAX_VALUE, smallestC = Double.MAX_VALUE, largestC = Double.MIN_VALUE;	boolean exclusions = false;	for (Entry<ItemType, Double> entry : costsPerItem.entrySet()) {	ItemType item = entry.getKey();	Double cost = entry.getValue();	if (cost == null) {	
item has null workrate skipping 

ItemType smallestMoveable = null, largest = null;	double minDiff = Double.MAX_VALUE, smallestC = Double.MAX_VALUE, largestC = Double.MIN_VALUE;	boolean exclusions = false;	for (Entry<ItemType, Double> entry : costsPerItem.entrySet()) {	ItemType item = entry.getKey();	Double cost = entry.getValue();	if (cost == null) {	continue;	}	if (!model.isItemMoveable(item)) {	
item cannot be moved skipping 

for (Entry<ItemType, Double> entry : costsPerItem.entrySet()) {	ItemType item = entry.getKey();	Double cost = entry.getValue();	if (cost == null) {	continue;	}	if (!model.isItemMoveable(item)) {	continue;	}	if (cost < 0) {	
item subject to recent adjustment skipping 

========================= brooklyn sample_3042 =========================

public void test_Debian_6() throws Exception {	
skipped debian test 

public void test_Ubuntu_10_0() throws Exception {	
skipped ubuntu test 

public void test_CentOS_5() throws Exception {	
skipped centos test 

========================= brooklyn sample_118 =========================

throw Exceptions.propagate(e);	}	}	private boolean isStatusCodeHealthy(int code) { return (code>=200 && code<=299); }	private Class<?> getClassFromMethodAnnotationOrDefault(Method method, Class<?> def){	Class<?> type;	try{	type = method.getAnnotation(ApiOperation.class).response();	} catch (Exception e) {	type = def;	
unable to get class from annotation defaulting to 

========================= brooklyn sample_7 =========================

public Response createFromArchive(byte[] zipInput, boolean detail, boolean forceUpdate) {	if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.ROOT, null)) {	throw WebResourceUtils.forbidden("User '%s' is not authorized to add catalog item", Entitlements.getEntitlementContext().user());	}	ReferenceWithError<OsgiBundleInstallationResult> result = ((ManagementContextInternal)mgmt()).getOsgiManager().get() .install(null, new ByteArrayInputStream(zipInput), true, true, forceUpdate);	if (OsgiBundleInstallationResult.ResultCode.IGNORING_BUNDLE_AREADY_INSTALLED.equals(result.getWithoutError().getCode())) {	result = ReferenceWithError.newInstanceThrowingError(result.getWithoutError(), new IllegalStateException( "Cannot add bundle" + result.getWithoutError().getMetadata().getVersionedName() + "; different bundle with same name already installed"));	}	if (result.hasError()) {	if (log.isTraceEnabled()) {	
unable to create from archive returning 

List<T> result = Lists.newArrayList();	Iterator<? super T> li = list.iterator();	while (li.hasNext()) {	try {	result.add((T) li.next());	} catch (Throwable throwable) {	if (throwable instanceof NoClassDefFoundError) {	} else {	Exceptions.propagateIfFatal(throwable);	}	
ignoring invalid catalog item 

========================= brooklyn sample_2891 =========================

public void testHttpFeedRegisteredInInitIsPersistedAndFeedsStop() throws Exception {	TestEntity origEntity = origApp.createAndManageChild(EntitySpec.create(TestEntity.class).impl(MyEntityWithHttpFeedImpl.class) .configure(MyEntityWithHttpFeedImpl.BASE_URL, baseUrl));	EntityAsserts.assertAttributeEqualsEventually(origEntity, SENSOR_INT, 200);	EntityAsserts.assertAttributeEqualsEventually(origEntity, SENSOR_STRING, "{\"foo\":\"myfoo\"}");	assertEquals(origEntity.feeds().getFeeds().size(), 1);	final long taskCountBefore = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getNumIncompleteTasks();	
count of incomplete tasks before 

public void testHttpFeedRegisteredInInitIsPersistedAndFeedsStop() throws Exception {	TestEntity origEntity = origApp.createAndManageChild(EntitySpec.create(TestEntity.class).impl(MyEntityWithHttpFeedImpl.class) .configure(MyEntityWithHttpFeedImpl.BASE_URL, baseUrl));	EntityAsserts.assertAttributeEqualsEventually(origEntity, SENSOR_INT, 200);	EntityAsserts.assertAttributeEqualsEventually(origEntity, SENSOR_STRING, "{\"foo\":\"myfoo\"}");	assertEquals(origEntity.feeds().getFeeds().size(), 1);	final long taskCountBefore = ((BasicExecutionManager)origManagementContext.getExecutionManager()).getNumIncompleteTasks();	
tasks before rebind 

List<Feed> knownFeeds = MutableList.of();	TestEntity currentEntity = origEntity;	Collection<Feed> currentFeeds = currentEntity.feeds().getFeeds();	int expectedCount = 4;	assertEquals(currentFeeds.size(), expectedCount);	knownFeeds.addAll(currentFeeds);	assertActiveFeedsEventually(knownFeeds, expectedCount);	origEntity.config().set(MyEntityWithNewFeedsEachTimeImpl.MAKE_NEW, !soakTest);	long usedOriginally = -1;	for (int i=0; i<iterations; i++) {	
rebinding iteration 

switchOriginalToNewManagementContext();	waitForTaskCountToBecome(origManagementContext, expectedCount + SYSTEM_TASK_COUNT);	assertActiveFeedsEventually(knownFeeds, expectedCount);	knownFeeds.clear();	knownFeeds.addAll(currentFeeds);	if (soakTest) {	System.gc(); System.gc();	if (usedOriginally<0) {	Time.sleep(Duration.millis(200));	usedOriginally = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	
usage after first rebind 

assertActiveFeedsEventually(knownFeeds, expectedCount);	knownFeeds.clear();	knownFeeds.addAll(currentFeeds);	if (soakTest) {	System.gc(); System.gc();	if (usedOriginally<0) {	Time.sleep(Duration.millis(200));	usedOriginally = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	} else {	long usedNow = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	
usage 

========================= brooklyn sample_636 =========================

protected void doTestWithStore(PersistenceObjectStore objectStore) {	
testing against 

protected void doTestWithStore(PersistenceObjectStore objectStore) {	objectStore.createSubPath("foo");	StoreObjectAccessor f = objectStore.newAccessor("foo/file1.txt");	Assert.assertFalse(f.exists());	Stopwatch timer = Stopwatch.createStarted();	f.append("Hello world");	
created in 

protected void doTestWithStore(PersistenceObjectStore objectStore) {	objectStore.createSubPath("foo");	StoreObjectAccessor f = objectStore.newAccessor("foo/file1.txt");	Assert.assertFalse(f.exists());	Stopwatch timer = Stopwatch.createStarted();	f.append("Hello world");	timer.reset();	Assert.assertEquals(f.get(), "Hello world");	
retrieved in 

objectStore.createSubPath("foo");	StoreObjectAccessor f = objectStore.newAccessor("foo/file1.txt");	Assert.assertFalse(f.exists());	Stopwatch timer = Stopwatch.createStarted();	f.append("Hello world");	timer.reset();	Assert.assertEquals(f.get(), "Hello world");	Assert.assertTrue(f.exists());	timer.reset();	List<String> files = objectStore.listContentsWithSubPath("foo");	
list retrieved in is 

========================= brooklyn sample_2487 =========================

public EntitySpec<?> resolve(String type, BrooklynClassLoadingContext loader, Set<String> encounteredTypes) {	String yaml;	try {	yaml = ResourceUtils.create(loader).getResourceAsString(type);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
assemblytemplate type looks like a url that can t be fetched 

========================= brooklyn sample_1751 =========================

else kind=RegisteredTypeKind.BEAN;	}	return new RegisteredTypeKindVisitor<Maybe<T>>() {	protected Maybe<T> visitSpec() {	return tryValidateSpec(object, type, context);	}	protected Maybe<T> visitBean() {	return tryValidateBean(object, type, context);	}	protected Maybe<T> visitUnresolved() {	
request for to validate unresolved kind trying as spec 

return new RegisteredTypeKindVisitor<Maybe<T>>() {	protected Maybe<T> visitSpec() {	return tryValidateSpec(object, type, context);	}	protected Maybe<T> visitBean() {	return tryValidateBean(object, type, context);	}	protected Maybe<T> visitUnresolved() {	Maybe<T> result = visitSpec();	if (result.isPresent()) {	
request to use from unresolved state succeeded treating is as a spec 

return new RegisteredTypeKindVisitor<Maybe<T>>() {	protected Maybe<T> visitSpec() {	return tryValidateSpec(object, type, context);	}	protected Maybe<T> visitBean() {	return tryValidateBean(object, type, context);	}	protected Maybe<T> visitUnresolved() {	Maybe<T> result = visitSpec();	if (result.isPresent()) {	
trace for request to use in unresolved state succeeding location of request to use in unresolved state 

========================= brooklyn sample_1028 =========================

public static void init(ManagementContext mgmt) {	ManagementContextHolder.setManagementContextStatic(mgmt);	String config = System.getProperty(JAAS_CONFIG);	if (config == null) {	URL configUrl = JaasUtils.class.getResource("/jaas.conf");	if (configUrl != null) {	
using classpath jaas config from 

public static void init(ManagementContext mgmt) {	ManagementContextHolder.setManagementContextStatic(mgmt);	String config = System.getProperty(JAAS_CONFIG);	if (config == null) {	URL configUrl = JaasUtils.class.getResource("/jaas.conf");	if (configUrl != null) {	System.setProperty(JAAS_CONFIG, configUrl.toExternalForm());	} else {	
can t find on classpath web server authentication will fail 

public static void init(ManagementContext mgmt) {	ManagementContextHolder.setManagementContextStatic(mgmt);	String config = System.getProperty(JAAS_CONFIG);	if (config == null) {	URL configUrl = JaasUtils.class.getResource("/jaas.conf");	if (configUrl != null) {	System.setProperty(JAAS_CONFIG, configUrl.toExternalForm());	} else {	}	} else {	
using externally configured jaas at 

========================= brooklyn sample_2887 =========================

private EntityDynamicType(Class<? extends Entity> clazz, AbstractEntity entity) {	super(clazz, entity);	String id = entity==null ? clazz.getName() : entity.getId();	effectors.putAll(findEffectors(clazz, null));	
entity effectors 

private EntityDynamicType(Class<? extends Entity> clazz, AbstractEntity entity) {	super(clazz, entity);	String id = entity==null ? clazz.getName() : entity.getId();	effectors.putAll(findEffectors(clazz, null));	sensors.putAll(findSensors(clazz, null));	
entity sensors 

Map<String,Field> fieldSources = Maps.newLinkedHashMap();	Map<String,Method> methodSources = Maps.newLinkedHashMap();	for (Field f : Reflections.findPublicFieldsOrderedBySuper(clazz)) {	if (Effector.class.isAssignableFrom(f.getType())) {	if (!Modifier.isStatic(f.getModifiers())) {	LOG.warn("Discouraged/deprecated use of non-static effector field "+f+" defined in " + (optionalEntity!=null ? optionalEntity : clazz));	if (optionalEntity==null) continue;	}	Effector<?> eff = (Effector<?>) f.get(optionalEntity);	if (eff==null) {	
effector undefined for 

LOG.warn("Discouraged/deprecated use of non-static effector field "+f+" defined in " + (optionalEntity!=null ? optionalEntity : clazz));	if (optionalEntity==null) continue;	}	Effector<?> eff = (Effector<?>) f.get(optionalEntity);	if (eff==null) {	continue;	}	Effector<?> overwritten = result.put(eff.getName(), eff);	Field overwrittenFieldSource = fieldSources.put(eff.getName(), f);	if (overwritten!=null && !Effectors.sameInstance(overwritten, eff)) {	
multiple definitions for effector on preferring from to from 

LOG.warn("Discouraged/deprecated use of static annotated effector method "+m+" defined in " + (optionalEntity!=null ? optionalEntity : clazz));	if (optionalEntity==null) continue;	}	Effector<?> eff = MethodEffector.create(m);	Effector<?> overwritten = result.get(eff.getName());	if ((overwritten instanceof EffectorWithBody) && !(overwritten instanceof MethodEffector<?>)) {	} else {	result.put(eff.getName(), eff);	Method overwrittenMethodSource = methodSources.put(eff.getName(), m);	Field overwrittenFieldSource = fieldSources.remove(eff.getName());	
multiple definitions for effector on preferring from to from 

if (Sensor.class.isAssignableFrom(f.getType())) {	if (!Modifier.isStatic(f.getModifiers())) {	LOG.warn("Discouraged use of non-static sensor "+f+" defined in " + (optionalEntity!=null ? optionalEntity : clazz));	if (optionalEntity==null) continue;	}	Sensor<?> sens = (Sensor<?>) f.get(optionalEntity);	Sensor<?> overwritten = result.put(sens.getName(), sens);	Field source = sources.put(sens.getName(), f);	if (overwritten!=null && overwritten != sens) {	if (sens instanceof HasConfigKey) {	
multiple definitions for config sensor on preferring from to from 

LOG.warn("Discouraged use of non-static sensor "+f+" defined in " + (optionalEntity!=null ? optionalEntity : clazz));	if (optionalEntity==null) continue;	}	Sensor<?> sens = (Sensor<?>) f.get(optionalEntity);	Sensor<?> overwritten = result.put(sens.getName(), sens);	Field source = sources.put(sens.getName(), f);	if (overwritten!=null && overwritten != sens) {	if (sens instanceof HasConfigKey) {	sens.getName(), optionalEntity!=null ? optionalEntity : clazz, sens, f, overwritten, source});	} else {	
multiple definitions for sensor on preferring from to from 

========================= brooklyn sample_1252 =========================

ha.start(HighAvailabilityMode.MASTER);	TestApplication app = TestApplication.Factory.newManagedInstanceForTests(managementContext);	LocalhostMachineProvisioningLocation l = app.newLocalhostProvisioningLocation();	l.config().set(TestEntity.CONF_NAME, "sample1");	Assert.assertEquals(l.getConfig(TestEntity.CONF_NAME), "sample1");	SshMachineLocation l2 = l.obtain();	Assert.assertEquals(l2.getConfig(TestEntity.CONF_NAME), "sample1");	Assert.assertNotNull(l2.getParent(), "Parent not set after dodgy promoteToMaster");	Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	
entities managed are 

TestApplication app = TestApplication.Factory.newManagedInstanceForTests(managementContext);	LocalhostMachineProvisioningLocation l = app.newLocalhostProvisioningLocation();	l.config().set(TestEntity.CONF_NAME, "sample1");	Assert.assertEquals(l.getConfig(TestEntity.CONF_NAME), "sample1");	SshMachineLocation l2 = l.obtain();	Assert.assertEquals(l2.getConfig(TestEntity.CONF_NAME), "sample1");	Assert.assertNotNull(l2.getParent(), "Parent not set after dodgy promoteToMaster");	Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	Collection<Location> le = entity.getLocations();	
locs at entity are 

LocalhostMachineProvisioningLocation l = app.newLocalhostProvisioningLocation();	l.config().set(TestEntity.CONF_NAME, "sample1");	Assert.assertEquals(l.getConfig(TestEntity.CONF_NAME), "sample1");	SshMachineLocation l2 = l.obtain();	Assert.assertEquals(l2.getConfig(TestEntity.CONF_NAME), "sample1");	Assert.assertNotNull(l2.getParent(), "Parent not set after dodgy promoteToMaster");	Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	Collection<Location> le = entity.getLocations();	Collection<Location> lm = managementContext.getLocationManager().getLocations();	
locs managed are 

LocalhostMachineProvisioningLocation l = app.newLocalhostProvisioningLocation();	l.config().set(TestEntity.CONF_NAME, "sample1");	Assert.assertEquals(l.getConfig(TestEntity.CONF_NAME), "sample1");	SshMachineLocation l2 = l.obtain();	Assert.assertEquals(l2.getConfig(TestEntity.CONF_NAME), "sample1");	Assert.assertNotNull(l2.getParent(), "Parent not set after dodgy promoteToMaster");	Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	Collection<Location> le = entity.getLocations();	Collection<Location> lm = managementContext.getLocationManager().getLocations();	
objs 

Assert.assertNotNull(l2.getParent(), "Parent not set after dodgy promoteToMaster");	Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	Collection<Location> le = entity.getLocations();	Collection<Location> lm = managementContext.getLocationManager().getLocations();	Assert.assertNotNull(entity.getManagementContext());	Assert.assertNotNull( ((EntityInternal)app.getChildren().iterator().next()).getManagementContext());	Assert.assertTrue( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().isDeployed());	checkEntitiesHealthy(app, entity);	managementContext.getRebindManager().forcePersistNow(true, null);	
test deliberately doing unnecessary extra promotetomaster 

Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	Collection<Location> le = entity.getLocations();	Collection<Location> lm = managementContext.getLocationManager().getLocations();	Assert.assertNotNull(entity.getManagementContext());	Assert.assertNotNull( ((EntityInternal)app.getChildren().iterator().next()).getManagementContext());	Assert.assertTrue( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().isDeployed());	checkEntitiesHealthy(app, entity);	managementContext.getRebindManager().forcePersistNow(true, null);	ha.promoteToMaster();	
entities managed are 

TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	Collection<Location> le = entity.getLocations();	Collection<Location> lm = managementContext.getLocationManager().getLocations();	Assert.assertNotNull(entity.getManagementContext());	Assert.assertNotNull( ((EntityInternal)app.getChildren().iterator().next()).getManagementContext());	Assert.assertTrue( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().isDeployed());	checkEntitiesHealthy(app, entity);	managementContext.getRebindManager().forcePersistNow(true, null);	ha.promoteToMaster();	Collection<Location> lle = entity.getLocations();	
locs at entity old are 

TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));	Collection<Location> le = entity.getLocations();	Collection<Location> lm = managementContext.getLocationManager().getLocations();	Assert.assertNotNull(entity.getManagementContext());	Assert.assertNotNull( ((EntityInternal)app.getChildren().iterator().next()).getManagementContext());	Assert.assertTrue( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().isDeployed());	checkEntitiesHealthy(app, entity);	managementContext.getRebindManager().forcePersistNow(true, null);	ha.promoteToMaster();	Collection<Location> lle = entity.getLocations();	
objs 

Collection<Location> lm = managementContext.getLocationManager().getLocations();	Assert.assertNotNull(entity.getManagementContext());	Assert.assertNotNull( ((EntityInternal)app.getChildren().iterator().next()).getManagementContext());	Assert.assertTrue( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().isDeployed());	checkEntitiesHealthy(app, entity);	managementContext.getRebindManager().forcePersistNow(true, null);	ha.promoteToMaster();	Collection<Location> lle = entity.getLocations();	checkEntitiesHealthy(app, entity);	Collection<Location> llmm = managementContext.getLocationManager().getLocations();	
locs managed are 

Collection<Location> lm = managementContext.getLocationManager().getLocations();	Assert.assertNotNull(entity.getManagementContext());	Assert.assertNotNull( ((EntityInternal)app.getChildren().iterator().next()).getManagementContext());	Assert.assertTrue( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().isDeployed());	checkEntitiesHealthy(app, entity);	managementContext.getRebindManager().forcePersistNow(true, null);	ha.promoteToMaster();	Collection<Location> lle = entity.getLocations();	checkEntitiesHealthy(app, entity);	Collection<Location> llmm = managementContext.getLocationManager().getLocations();	
objs 

Collection<Location> lle = entity.getLocations();	checkEntitiesHealthy(app, entity);	Collection<Location> llmm = managementContext.getLocationManager().getLocations();	Assert.assertEquals(llmm, lm);	SshMachineLocation ll2a = Iterables.getOnlyElement(Iterables.filter(llmm, SshMachineLocation.class));	Assert.assertEquals(ll2a.getConfig(TestEntity.CONF_NAME), "sample1");	Assert.assertNotNull(ll2a.getParent(), "Parent not set after dodgy promoteToMaster");	Assert.assertEquals(ll2a.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	Entity ee = (Entity)managementContext.lookup(entity.getId());	Collection<Location> llee = ee.getLocations();	
locs at entity lookup are 

Collection<Location> lle = entity.getLocations();	checkEntitiesHealthy(app, entity);	Collection<Location> llmm = managementContext.getLocationManager().getLocations();	Assert.assertEquals(llmm, lm);	SshMachineLocation ll2a = Iterables.getOnlyElement(Iterables.filter(llmm, SshMachineLocation.class));	Assert.assertEquals(ll2a.getConfig(TestEntity.CONF_NAME), "sample1");	Assert.assertNotNull(ll2a.getParent(), "Parent not set after dodgy promoteToMaster");	Assert.assertEquals(ll2a.getParent().getConfig(TestEntity.CONF_NAME), "sample1");	Entity ee = (Entity)managementContext.lookup(entity.getId());	Collection<Location> llee = ee.getLocations();	
objs 

========================= brooklyn sample_620 =========================

protected Map<String, Object> extractValueMatchingThisKey(Object potentialBase, ExecutionContext exec, boolean coerce) throws InterruptedException, ExecutionException {	if (coerce) {	potentialBase = resolveValue(potentialBase, exec);	}	if (potentialBase==null) return null;	if (potentialBase instanceof Map<?,?>) {	return Maps.<String,Object>newLinkedHashMap( (Map<String,Object>) potentialBase);	}	
unable to extract as map it is 

public Object applyValueToMap(Object value, Map target) {	if (value == null) return null;	if (value instanceof StructuredModification) return ((StructuredModification)value).applyToKeyInMap(this, target);	if (value instanceof Map.Entry) return applyEntryValueToMap((Map.Entry)value, target);	if (!(value instanceof Map)) {	Maybe<Map> coercedValue = TypeCoercions.tryCoerce(value, Map.class);	if (coercedValue.isPresent()) {	
coerced value for from type to map 

if (mapAtRoot instanceof Map) {	if (mapAtRoot instanceof ConcurrentMap) {	return ((Map)mapAtRoot).put(k, value.getValue());	} else {	synchronized (mapAtRoot) {	return ((Map)mapAtRoot).put(k, value.getValue());	}	}	}	}	
unexpected subkey being inserted into ignoring 

========================= brooklyn sample_1194 =========================

public void testIsPortAvailableReportsFalseWhenPortIsInUse() throws Exception {	int port = findPort();	try (ServerSocket ss = new ServerSocket(port)) {	
acquired port on for test 

public void testPortNotAvailableOnAnyNicWithReuseAddressWhenBoundToAnyNic() throws Exception {	int port = findPort();	try (ServerSocket ss = new ServerSocket()) {	ss.setReuseAddress(true);	ss.bind(new InetSocketAddress(Networking.ANY_NIC, port));	
acquired port on for test 

public void testPortNotAvailableOnAnyNicOrLoopbackWithReuseAddressWhenBoundToLoopback() throws Exception {	int port = findPort();	try (ServerSocket ss = new ServerSocket()) {	ss.setReuseAddress(true);	ss.bind(new InetSocketAddress(Networking.LOOPBACK, port));	
acquired port on for test 

========================= brooklyn sample_1897 =========================

public void apply(final EntityLocal entity) {	super.apply(entity);	final Boolean suppressDuplicates = EntityInitializers.resolve(params, SUPPRESS_DUPLICATES);	if (entity instanceof UsesJmx) {	if (LOG.isDebugEnabled()) {	
submitting task to add jmx sensor to 

========================= brooklyn sample_2307 =========================

public static ConfigKey<?> newInstance(ConfigBag keyDefs) {	String typeName = Strings.toString(keyDefs.getStringKey("type"));	if (Strings.isNonBlank(typeName)) {	
setting type is not currently supported for dynamic config keys ignoring in definition of 

========================= brooklyn sample_1205 =========================

nowWaitingLatch.countDown();	if (!continueFromWaitingLatch.await(TIMEOUT, TimeUnit.MILLISECONDS)) {	fail("took too long to be told to continue");	}	return null;	}});	}	public void spawnchild() throws Exception {	BasicExecutionContext.getCurrentExecutionContext().submit( MutableMap.of("displayName", "SpawnedChildName"), new Callable<Void>() {	public Void call() throws Exception {	
beginning spawned child response with tags 

Thread bg = new Thread(new Runnable() {	public void run() {	try {	if (!entity.getNowWaitingLatch().await(TIMEOUT, TimeUnit.MILLISECONDS)) {	result.set("took too long for waitabit to be waiting");	return;	}	try {	Task<?> t = entity.getWaitingTask().get();	String status = t.getStatusDetail(true);	
waitabit task says 

return;	}	if (!status.startsWith("waitabit.blocking")) {	result.set("Status not in expected format: doesn't start with blocking details 'waitabit.blocking'\n"+status);	return;	}	} finally {	entity.getContinueFromWaitingLatch().countDown();	}	} catch (Throwable t) {	
failure 

return;	}	ExecutionManager em = entity.getManagementContext().getExecutionManager();	Task<?> subtask = Iterables.find(BrooklynTaskTags.getTasksInEntityContext(em, entity), new Predicate<Task<?>>() {	public boolean apply(Task<?> input) {	return "SpawnedChildName".equals(input.getDisplayName());	}	});	try {	String status = subtask.getStatusDetail(true);	
subtask task says 

try {	String status = subtask.getStatusDetail(true);	if (!status.contains("spawned child blocking details")) {	result.set("Status not in expected format: doesn't contain blocking details phrase 'spawned child blocking details'\n"+status);	return;	}	} finally {	entity.getContinueFromWaitingLatch().countDown();	}	} catch (Throwable t) {	
failure 

========================= brooklyn sample_698 =========================

public void connectSensors() {	super.connectSensors();	String requestProcessorMbeanName = "jboss.web:type=GlobalRequestProcessor,name=http-*";	String serverMbeanName = "jboss.system:type=Server";	boolean retrieveUsageMetrics = getConfig(RETRIEVE_USAGE_METRICS);	if (isJmxEnabled()) {	jmxFeed = JmxFeed.builder() .entity(this) .period(500, TimeUnit.MILLISECONDS) .pollAttribute(new JmxAttributePollConfig<Boolean>(SERVICE_UP) .objectName(serverMbeanName) .attributeName("Started") .onException(Functions.constant(false)) .suppressDuplicates(true)) .pollAttribute(new JmxAttributePollConfig<Integer>(ERROR_COUNT) .objectName(requestProcessorMbeanName) .attributeName("errorCount") .enabled(retrieveUsageMetrics)) .pollAttribute(new JmxAttributePollConfig<Integer>(REQUEST_COUNT) .objectName(requestProcessorMbeanName) .attributeName("requestCount") .onFailureOrException(EntityFunctions.attribute(this, REQUEST_COUNT)) .enabled(retrieveUsageMetrics)) .pollAttribute(new JmxAttributePollConfig<Integer>(TOTAL_PROCESSING_TIME) .objectName(requestProcessorMbeanName) .attributeName("processingTime") .enabled(retrieveUsageMetrics)) .build();	} else {	
running without jmx monitoring limited visibility of service available 

========================= brooklyn sample_227 =========================

protected void doTestPersistenceVolume(boolean forceDelay, boolean canTrigger) throws Exception {	if (forceDelay) Time.sleep(Duration.FIVE_SECONDS);	else recorder.blockUntilDataWrittenExceeds(512, Duration.FIVE_SECONDS);	localManagementContext.getRebindManager().waitForPendingComplete(Duration.FIVE_SECONDS, canTrigger);	long out1 = recorder.getBytesOut();	int filesOut1 = recorder.getCountDataOut();	
phase one recorded bytes files 

int filesOut1 = recorder.getCountDataOut();	Assert.assertTrue(out1>512, "should have written at least 0.5k, only wrote "+out1);	Assert.assertTrue(out1<pass1MaxKb*1000, "should have written less than " + pass1MaxKb + "k, wrote "+out1);	Assert.assertTrue(filesOut1<pass1MaxFiles, "should have written fewer than " + pass1MaxFiles + " files, wrote "+filesOut1);	((EntityInternal)app).sensors().set(TestEntity.NAME, "hello world");	if (forceDelay) Time.sleep(Duration.FIVE_SECONDS);	else recorder.blockUntilDataWrittenExceeds(out1+10, Duration.FIVE_SECONDS);	localManagementContext.getRebindManager().waitForPendingComplete(Duration.FIVE_SECONDS, canTrigger);	long out2 = recorder.getBytesOut();	int filesOut2 = recorder.getCountDataOut();	
phase two recorded bytes files 

Assert.assertTrue(out2-out1>10, "should have written more data");	Assert.assertTrue(filesOut2>filesOut1, "should have written more files");	Assert.assertTrue(out2<pass2MaxKb*1000, "should have written less than " + pass2MaxKb + "k, wrote "+out2);	Assert.assertTrue(filesOut2<pass2MaxFiles, "should have written fewer than " + pass2MaxFiles + " files, wrote "+filesOut2);	((EntityInternal)entity).sensors().set(TestEntity.NAME, Identifiers.makeRandomId(pass3MaxKb));	if (forceDelay) Time.sleep(Duration.FIVE_SECONDS);	else recorder.blockUntilDataWrittenExceeds(out2+pass3MaxKb, Duration.FIVE_SECONDS);	localManagementContext.getRebindManager().waitForPendingComplete(Duration.FIVE_SECONDS, canTrigger);	long out3 = recorder.getBytesOut();	int filesOut3 = recorder.getCountDataOut();	
phase three recorded bytes files 

========================= brooklyn sample_677 =========================

public <T extends Entity> EntityTypeRegistry registerImplementation(Class<T> type, Class<? extends T> implClazz) {	checkNotNull(type, "type");	checkNotNull(implClazz, "implClazz");	checkIsImplementation(type, implClazz);	checkIsNewStyleImplementation(implClazz);	synchronized (mutex) {	Class<?> existingType = registry.inverse().get(implClazz);	if (existingType != null && !type.equals(existingType)) {	throw new IllegalArgumentException("Implementation "+implClazz+" already registered against type "+existingType+"; cannot also register against "+type);	}	
implementation registered against type 

public <T extends Entity> Class<? extends T> getImplementedBy(Class<T> type) {	synchronized (mutex) {	Class<?> result = cache.get(type);	if (result != null) {	
implementation returned for type 

return (Class<? extends T>) result;	}	result = getFromAnnotation(type);	if (result == null) {	if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT)==0)) {	result = type;	} else {	throw new IllegalArgumentException("Interface "+type+" is not annotated with @"+ImplementedBy.class.getSimpleName()+", and no implementation is registered");	}	}	
implementation returned for type 

========================= brooklyn sample_1340 =========================

private void destroyApps(Iterable<? extends Application> apps) {	final int MAX_THREADS = 100;	ListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_THREADS));	List<ListenableFuture<?>> futures = Lists.newArrayList();	final AtomicReference<Exception> error = Atomics.newReference();	try {	for (final Application app: apps) {	futures.add(executor.submit(new Runnable() {	public void run() {	ManagementContext mgmt = app.getManagementContext();	
destroying app managed mgmt is 

ListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_THREADS));	List<ListenableFuture<?>> futures = Lists.newArrayList();	final AtomicReference<Exception> error = Atomics.newReference();	try {	for (final Application app: apps) {	futures.add(executor.submit(new Runnable() {	public void run() {	ManagementContext mgmt = app.getManagementContext();	try {	Entities.destroy(app);	
destroyed app mgmt now 

List<ListenableFuture<?>> futures = Lists.newArrayList();	final AtomicReference<Exception> error = Atomics.newReference();	try {	for (final Application app: apps) {	futures.add(executor.submit(new Runnable() {	public void run() {	ManagementContext mgmt = app.getManagementContext();	try {	Entities.destroy(app);	} catch (Exception e) {	
problems destroying app mgmt now will rethrow at least one exception 

Entities.destroy(app);	} catch (Exception e) {	error.compareAndSet(null, e);	}	}}));	}	Futures.allAsList(futures).get();	if (error.get() != null) throw Exceptions.propagate(error.get());	} catch (Exception e) {	if (!mgmt.isRunning()) {	
destroying apps gave an error but mgmt context was concurrently stopped so not really a problem swallowing unless fatal 

========================= brooklyn sample_2215 =========================

if (vRange != null) {	if (!vRange.includes(bv)) {	continue;	}	} else {	String bvString = bv.toString();	if (!v.equals(bvString)) {	if (!vDep.equals(bvString)) {	continue;	}	
legacy inferred osgi version string found to match switch to format to avoid issues with deprecated version syntax 

boolean isLocal = isLocalUrl(url);	String localUrl = url;	if (!isLocal) {	localUrl = cacheFile(url);	}	try {	Bundle bundle = getInstalledBundle(framework, localUrl);	if (bundle != null) {	return bundle;	}	
installing bundle into from url 

}	Manifest manifest = stream.getManifest();	Streams.closeQuietly(stream);	if (manifest == null) {	throw new IllegalStateException("Missing manifest file in bundle or not a jar file.");	}	String versionedId = OsgiUtils.getVersionedId(manifest);	for (Bundle installedBundle : framework.getBundleContext().getBundles()) {	if (versionedId.equals(OsgiUtils.getVersionedId(installedBundle))) {	if (SystemFrameworkLoader.get().isSystemBundle(installedBundle)) {	
already have system bundle from when requested not installing 

Streams.closeQuietly(stream);	if (manifest == null) {	throw new IllegalStateException("Missing manifest file in bundle or not a jar file.");	}	String versionedId = OsgiUtils.getVersionedId(manifest);	for (Bundle installedBundle : framework.getBundleContext().getBundles()) {	if (versionedId.equals(OsgiUtils.getVersionedId(installedBundle))) {	if (SystemFrameworkLoader.get().isSystemBundle(installedBundle)) {	return installedBundle;	} else {	
already have bundle from when requested but it is not a system bundle so proceeding 

========================= brooklyn sample_1439 =========================

public void restart(ConfigBag parameters) {	RestartMachineMode isRestartMachine = parameters.get(RestartSoftwareParameters.RESTART_MACHINE_TYPED);	if (isRestartMachine==null) isRestartMachine=RestartMachineMode.AUTO;	if (isRestartMachine==RestartMachineMode.AUTO) isRestartMachine = getDefaultRestartStopsMachine() ? RestartMachineMode.TRUE : RestartMachineMode.FALSE;	if (isRestartMachine==RestartMachineMode.TRUE) {	
restart of requested be applied at machine level 

public void restart(ConfigBag parameters) {	RestartMachineMode isRestartMachine = parameters.get(RestartSoftwareParameters.RESTART_MACHINE_TYPED);	if (isRestartMachine==null) isRestartMachine=RestartMachineMode.AUTO;	if (isRestartMachine==RestartMachineMode.AUTO) isRestartMachine = getDefaultRestartStopsMachine() ? RestartMachineMode.TRUE : RestartMachineMode.FALSE;	if (isRestartMachine==RestartMachineMode.TRUE) {	super.restart(parameters);	return;	}	DynamicTasks.queue("pre-restart", new PreRestartTask());	
restart of appears to have driver and hostname doing driver level restart 

protected boolean getDefaultRestartStopsMachine() {	if (entity().getDriver() == null) {	
restart of has no driver doing machine level restart 

protected boolean getDefaultRestartStopsMachine() {	if (entity().getDriver() == null) {	return true;	}	if (Strings.isEmpty(entity().getAttribute(Attributes.HOSTNAME))) {	
restart of has no hostname doing machine level restart 

protected void postStartCustom() {	entity().postDriverStart();	if (entity().connectedSensors) {	
skipping connecting sensors for in driver tasks poststartcustom because already connected e g restarting 

protected void postStartCustom() {	entity().postDriverStart();	if (entity().connectedSensors) {	} else {	
connecting sensors for in driver tasks poststartcustom because already connected e g restarting 

entity().getDriver().stop();	result = "Driver stop completed";	} else {	result = "No driver (nothing to do here)";	}	if (!mode.isDisabled && !mode.isBackground) {	try {	children.asTask().get();	} catch (Exception e) {	childException = e;	
error stopping children continuing and will rethrow if no other errors 

========================= brooklyn sample_2350 =========================

private static <T> ServiceLoader<T> lookupAllViaServiceLoader(Class<T> clazz, ClassLoader loader) {	
looking up all via serviceloader 

private static <T> Iterable<T> lookupAllInOsgi(Class<T> clazz) {	final List<T> result = new ArrayList<>();	final Bundle bundle = FrameworkUtil.getBundle(FrameworkLookup.class);	if (bundle != null) {	
looking up all in osgi 

private static <T> Maybe<T> lookupViaServiceLoader(Class<T> clazz, ClassLoader loader) {	
looking up via serviceloader 

private static <T> Maybe<T> lookupInOsgi(Class<T> clazz) {	Maybe<T> result = Maybe.absent("No class " + clazz.getSimpleName() + " found with OSGI");	final Bundle bundle = FrameworkUtil.getBundle(FrameworkLookup.class);	if (bundle != null) {	
looking up in osgi 

========================= brooklyn sample_2700 =========================

private void reloadImpl() {	Lifecycle lifecycle = entity.getAttribute(NginxController.SERVICE_STATE_ACTUAL);	if (lifecycle==Lifecycle.STOPPING || lifecycle==Lifecycle.STOPPED || !isRunning()) {	
ignoring reload of nginx because service is not running state 

private void doReloadNow() {	
reloading nginx by simularing restart kill hup 

========================= brooklyn sample_196 =========================

public void customize(JcloudsLocation location, ComputeService computeService, TemplateBuilder templateBuilder) {	if (computeService instanceof AWSEC2ComputeService) {	templateBuilder.locationId(availabilityZone);	} else {	
skipping configuration of non computeservice 

========================= brooklyn sample_2632 =========================

public void test_localhost() throws Exception {	File dataDir = Files.createTempDir();	try {	MySqlNode mysql = app.createAndManageChild(EntitySpec.create(MySqlNode.class) .configure("mysql.server.conf", MutableMap.of("skip-name-resolve","")) .configure("creationScriptContents", CREATION_SCRIPT) .configure("dataDir", dataDir.getAbsolutePath()) .configure("test.table.name", "COMMENTS"));	LocalhostMachineProvisioningLocation location = new LocalhostMachineProvisioningLocation();	app.start(ImmutableList.of(location));;	
mysql started 

public void test_localhost() throws Exception {	File dataDir = Files.createTempDir();	try {	MySqlNode mysql = app.createAndManageChild(EntitySpec.create(MySqlNode.class) .configure("mysql.server.conf", MutableMap.of("skip-name-resolve","")) .configure("creationScriptContents", CREATION_SCRIPT) .configure("dataDir", dataDir.getAbsolutePath()) .configure("test.table.name", "COMMENTS"));	LocalhostMachineProvisioningLocation location = new LocalhostMachineProvisioningLocation();	app.start(ImmutableList.of(location));;	new VogellaExampleAccess("com.mysql.jdbc.Driver", mysql.getAttribute(MySqlNode.DATASTORE_URL)).readModifyAndRevertDataBase();	
ran vogella mysql example success 

========================= brooklyn sample_70 =========================

public void testQuickFutureResolved() {	try {	EntityRequiringConfigKeyInRange child = app.createAndManageChild(EntitySpec.create(EntityRequiringConfigKeyInRange.class) .configure(EntityRequiringConfigKeyInRange.RANGE, sleepingTask(Duration.ZERO, -1)));	Object value = child.getConfig(EntityRequiringConfigKeyInRange.RANGE);	
got for now explicitly validating 

========================= brooklyn sample_745 =========================

public static void assertCassandraPortsAvailableEventually() {	Map<String, Integer> ports = getCassandraDefaultPorts();	NetworkingTestUtils.assertPortsAvailableEventually(ports);	
confirmed cassandra ports are available 

========================= brooklyn sample_315 =========================

public <D extends EntityDriver> String inferDriverClassName(DriverDependentEntity<D> entity, Class<D> driverInterface, Location location) {	if (driverInterface.getSimpleName().equals(expectedPattern)) {	
using discouraged driver simple class rename to find for it is recommended to set getdriverinterface or newdriver appropriately 

public DriverInferenceRule addRule(String identifier, DriverInferenceRule rule) {	DriverInferenceRule oldRule = rules.remove(identifier);	rules.put(identifier, rule);	
added driver mapping rule 

break;	}	} else {	exceptions.add(clazzR.getError());	}	}	}	} else {	driverClass = driverInterface;	}	
driver for in is 

}	if (driverClass==null) {	if (exceptions.isEmpty()) throw new RuntimeException("No drivers could be found for "+driverInterface.getName()+"; " + "currently only SshMachineLocation is supported for autodetection (location "+location+")");	else throw Exceptions.create("No drivers could be loaded for "+driverInterface.getName()+" in "+location, exceptions);	}	try {	Constructor<? extends D> constructor = getConstructor(driverClass);	constructor.setAccessible(true);	return constructor.newInstance(entity, location);	} catch (Exception e) {	
unable to instantiate rethrowing 

========================= brooklyn sample_1225 =========================

MutableList<URL> resources = MutableList.of();	for (String location : locations) {	File locationBom = new File(testFrameworkSuiteBuilder.locationsFolder, location + ".bom");	if (locationBom.exists()) {	try {	resources.add(locationBom.toURI().toURL());	} catch (MalformedURLException e) {	throw new IllegalStateException("Could not conert the path " + locationBom.getAbsolutePath() + " to URL", e);	}	} else {	
locationn file not found in assuming it s a location provided by the environment 

========================= brooklyn sample_2409 =========================

public static Thread addShutdownHook(final Runnable task) {	Thread t = new Thread("shutdownHookThread") {	public void run() {	try {	task.run();	} catch (Exception e) {	
failed to execute shutdown hook 

Collection<Thread> localHooks;	synchronized (Threads.hooks) {	localHooks = ImmutableList.copyOf(hooks);	hooks.clear();	}	for (Thread t : localHooks) {	try {	t.start();	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
failed to execute shutdown hook for thread 

========================= brooklyn sample_2059 =========================

public void run() {	if (latchTask != null) {	latchTask.blockUntilEnded();	} else {	
no latch task provided for unmanagetask falling back to fixed wait 

private void shutdownGracefully() {	if (Boolean.TRUE.equals(getAttribute(BrooklynNode.WEB_CONSOLE_ACCESSIBLE))) {	queueShutdownTask();	queueWaitExitTask();	} else {	
skipping graceful shutdown call because web console not up for 

private void queueWaitExitTask() {	DynamicTasks.queue(Tasks.builder().displayName("wait for graceful stop").body(new Runnable() {	public void run() {	DynamicTasks.markInessential();	boolean cleanExit = Repeater.create() .until(new Callable<Boolean>() {	public Boolean call() throws Exception {	return !getDriver().isRunning();	}	}) .backoffTo(Duration.ONE_SECOND) .limitTimeTo(Duration.ONE_MINUTE) .run();	if (!cleanExit) {	
tenant didn t stop cleanly after shutdown timeout waiting for process exit 

public String call(ConfigBag parameters) {	
deploying blueprint to 

public String submitPlan(final String plan) {	final MutableMap<String, String> headers = MutableMap.of(com.google.common.net.HttpHeaders.CONTENT_TYPE, "application/yaml");	final AtomicReference<byte[]> response = new AtomicReference<byte[]>();	Repeater.create() .every(Duration.ONE_SECOND) .backoffTo(Duration.FIVE_SECONDS) .limitTimeTo(Duration.minutes(5)) .repeat(Runnables.doNothing()) .rethrowExceptionImmediately() .until(new Callable<Boolean>() {	public Boolean call() {	HttpToolResponse result = ((BrooklynNode)entity()).http() .responseSuccess(Predicates.<Integer>or(ResponseCodePredicates.success(), Predicates.equalTo(HttpStatus.SC_FORBIDDEN))) .post("/v1/applications", headers, plan.getBytes());	if (result.getResponseCode() == HttpStatus.SC_FORBIDDEN) {	
remote is not ready to accept requests response is 

public Void call(ConfigBag parameters) {	MutableMap<String, String> formParams = MutableMap.of();	Lifecycle initialState = entity().getAttribute(Attributes.SERVICE_STATE_ACTUAL);	ServiceStateLogic.setExpectedState(entity(), Lifecycle.STOPPING);	for (ConfigKey<?> k: new ConfigKey<?>[] { STOP_APPS_FIRST, FORCE_SHUTDOWN_ON_ERROR, SHUTDOWN_TIMEOUT, REQUEST_TIMEOUT, DELAY_FOR_HTTP_RETURN }) formParams.addIfNotNull(k.getName(), toNullableString(parameters.get(k)));	try {	
shutting down with 

========================= brooklyn sample_2366 =========================

try {	Duration timeout = config().get(CONNECT_TIMEOUT);	Map<String, ?> flags = ImmutableMap.of( SshTool.PROP_CONNECT_TIMEOUT.getName(), timeout.toMilliseconds(), SshTool.PROP_SESSION_TIMEOUT.getName(), timeout.toMilliseconds(), SshTool.PROP_SSH_TRIES.getName(), 1);	int exitCode = sshMachine.execCommands(flags, SshMachineFailureDetector.class.getName(), ImmutableList.of("exit"));	return new BasicCalculatedStatus(exitCode == 0, sshMachine.toString());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	boolean isFirstFailure = lastPublished != LastPublished.FAILED && currentFailureStartTime == null;	if (isFirstFailure) {	if (LOG.isDebugEnabled()) {	
failed connecting to machine 

int exitCode = sshMachine.execCommands(flags, SshMachineFailureDetector.class.getName(), ImmutableList.of("exit"));	return new BasicCalculatedStatus(exitCode == 0, sshMachine.toString());	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	boolean isFirstFailure = lastPublished != LastPublished.FAILED && currentFailureStartTime == null;	if (isFirstFailure) {	if (LOG.isDebugEnabled()) {	}	} else {	if (LOG.isTraceEnabled()) {	
failed connecting to machine 

========================= brooklyn sample_3062 =========================

protected void finalize() {	
jmxfeed builder created but build never called 

final ObjectName objectName = Iterables.get(configs, 0).getObjectName();	final String operationName = Iterables.get(configs, 0).getOperationName();	final List<String> signature = Iterables.get(configs, 0).getSignature();	final List<?> params = Iterables.get(configs, 0).getParams();	for (JmxOperationPollConfig<?> config : configs) {	handlers.add(new AttributePollHandler<Object>(config, getEntity(), this));	if (config.getPeriod() > 0) minPeriod = Math.min(minPeriod, config.getPeriod());	}	getPoller().scheduleAtFixedRate( new Callable<Object>() {	public Object call() throws Exception {	
jmx operation polling for sensors at 

Set<AttributePollHandler<? super Object>> handlers = Sets.newLinkedHashSet();	long minPeriod = Integer.MAX_VALUE;	final ObjectName objectName = Iterables.get(configs, 0).getObjectName();	final String jmxAttributeName = Iterables.get(configs, 0).getAttributeName();	for (JmxAttributePollConfig<?> config : configs) {	handlers.add(new AttributePollHandler<Object>(config, getEntity(), this));	if (config.getPeriod() > 0) minPeriod = Math.min(minPeriod, config.getPeriod());	}	getPoller().scheduleAtFixedRate( new Callable<Object>() {	public Object call() throws Exception {	
jmx attribute polling for sensors at 

private void unregisterNotificationListener(ObjectName objectName, NotificationListener listener) {	try {	getHelper().removeNotificationListener(objectName, listener);	} catch (RuntimeException e) {	
failed to unregister listener continuing 

========================= brooklyn sample_2389 =========================

public void tearDownClass() throws Exception {	try {	try {	if (location != null) location.release(machine);	} finally {	if (mgmt != null) Entities.destroyAll(mgmt);	}	} catch (Throwable t) {	
caught exception in teardownclass method 

public void tearDown() throws Exception {	try {	try {	if (app != null) Entities.destroy(app);	} catch (Throwable t) {	
caught exception in teardown method 

public void testExecWithZeroExitCodes() {	VanillaWindowsProcess entity = app.createAndManageChild(EntitySpec.create(VanillaWindowsProcess.class) .configure(VanillaWindowsProcess.PRE_INSTALL_COMMAND, "echo preinstall") .configure(VanillaWindowsProcess.INSTALL_COMMAND, "echo install") .configure(VanillaWindowsProcess.POST_INSTALL_COMMAND, "echo postinstall") .configure(VanillaWindowsProcess.CUSTOMIZE_COMMAND, "echo customize") .configure(VanillaWindowsProcess.PRE_LAUNCH_COMMAND, "echo prelaunch") .configure(VanillaWindowsProcess.LAUNCH_COMMAND, "echo launch") .configure(VanillaWindowsProcess.POST_LAUNCH_COMMAND, "echo postlaunch") .configure(VanillaWindowsProcess.CHECK_RUNNING_COMMAND, "echo checkrunning") .configure(VanillaWindowsProcess.STOP_COMMAND, "echo stop"));	app.start(ImmutableList.of(machine));	
app started asserting up 

public void testExecWithZeroExitCodes() {	VanillaWindowsProcess entity = app.createAndManageChild(EntitySpec.create(VanillaWindowsProcess.class) .configure(VanillaWindowsProcess.PRE_INSTALL_COMMAND, "echo preinstall") .configure(VanillaWindowsProcess.INSTALL_COMMAND, "echo install") .configure(VanillaWindowsProcess.POST_INSTALL_COMMAND, "echo postinstall") .configure(VanillaWindowsProcess.CUSTOMIZE_COMMAND, "echo customize") .configure(VanillaWindowsProcess.PRE_LAUNCH_COMMAND, "echo prelaunch") .configure(VanillaWindowsProcess.LAUNCH_COMMAND, "echo launch") .configure(VanillaWindowsProcess.POST_LAUNCH_COMMAND, "echo postlaunch") .configure(VanillaWindowsProcess.CHECK_RUNNING_COMMAND, "echo checkrunning") .configure(VanillaWindowsProcess.STOP_COMMAND, "echo stop"));	app.start(ImmutableList.of(machine));	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_UP, true);	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.RUNNING);	entity.stop();	
stopping entity 

public void testExecPsWithZeroExitCodes() {	VanillaWindowsProcess entity = app.createAndManageChild(EntitySpec.create(VanillaWindowsProcess.class) .configure(VanillaWindowsProcess.PRE_INSTALL_POWERSHELL_COMMAND, "Write-Host preinstall") .configure(VanillaWindowsProcess.INSTALL_POWERSHELL_COMMAND, "Write-Host install") .configure(VanillaWindowsProcess.POST_INSTALL_POWERSHELL_COMMAND, "Write-Host postinstall") .configure(VanillaWindowsProcess.CUSTOMIZE_POWERSHELL_COMMAND, "Write-Host customize") .configure(VanillaWindowsProcess.PRE_LAUNCH_POWERSHELL_COMMAND, "Write-Host prelaunch") .configure(VanillaWindowsProcess.LAUNCH_POWERSHELL_COMMAND, "Write-Host launch") .configure(VanillaWindowsProcess.POST_LAUNCH_POWERSHELL_COMMAND, "Write-Host postlaunch") .configure(VanillaWindowsProcess.CHECK_RUNNING_POWERSHELL_COMMAND, "Write-Host checkrunning") .configure(VanillaWindowsProcess.STOP_POWERSHELL_COMMAND, "Write-Host stop"));	app.start(ImmutableList.of(machine));	
app started asserting up 

public void testExecPsWithZeroExitCodes() {	VanillaWindowsProcess entity = app.createAndManageChild(EntitySpec.create(VanillaWindowsProcess.class) .configure(VanillaWindowsProcess.PRE_INSTALL_POWERSHELL_COMMAND, "Write-Host preinstall") .configure(VanillaWindowsProcess.INSTALL_POWERSHELL_COMMAND, "Write-Host install") .configure(VanillaWindowsProcess.POST_INSTALL_POWERSHELL_COMMAND, "Write-Host postinstall") .configure(VanillaWindowsProcess.CUSTOMIZE_POWERSHELL_COMMAND, "Write-Host customize") .configure(VanillaWindowsProcess.PRE_LAUNCH_POWERSHELL_COMMAND, "Write-Host prelaunch") .configure(VanillaWindowsProcess.LAUNCH_POWERSHELL_COMMAND, "Write-Host launch") .configure(VanillaWindowsProcess.POST_LAUNCH_POWERSHELL_COMMAND, "Write-Host postlaunch") .configure(VanillaWindowsProcess.CHECK_RUNNING_POWERSHELL_COMMAND, "Write-Host checkrunning") .configure(VanillaWindowsProcess.STOP_POWERSHELL_COMMAND, "Write-Host stop"));	app.start(ImmutableList.of(machine));	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_UP, true);	EntityAsserts.assertAttributeEqualsEventually(entity, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.RUNNING);	entity.stop();	
stopping entity 

========================= brooklyn sample_2223 =========================

public void testSimpleYamlParse() throws IOException {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("java-web-app-simple.yaml"));	DeploymentPlan plan = platform.pdp().parseDeploymentPlan(input);	
dp is 

public void testExampleFunctionsYamlMatch() throws IOException {	Reader input = Streams.reader(new ResourceUtils(this).getResourceFromUrl("example-with-function.yaml"));	DeploymentPlan plan = platform.pdp().parseDeploymentPlan(input);	
dp is 

protected void assertWebDbWithFunctionValid(Reader input) {	DeploymentPlan plan = platform.pdp().parseDeploymentPlan(input);	
dp is 

========================= brooklyn sample_31 =========================

public AttributeSensorAndConfigKey(TypeToken<ConfigType> configType, TypeToken<SensorType> sensorType, String name, String description, Object defaultValue) {	super(sensorType, name, description);	ConfigType defaultValueTyped;	try {	defaultValueTyped = TypeCoercions.coerce(defaultValue, configType);	} catch (Exception e) {	
invalid default value for rethrowing 

========================= brooklyn sample_1399 =========================

public void testGetAllFields() {	
types 

public void testGetAllFields() {	assertEquals(FlagUtils.getAllAssignableTypes(Baz.class), ImmutableList.of(Baz.class, Foo.class, Bar.class));	List<Field> fs = FlagUtils.getAllFields(Baz.class);	for (Field f : fs) {	
field 

========================= brooklyn sample_883 =========================

public void testReportsServiceDownWhenKilled(final SoftwareProcess entity) throws Exception {	this.entity = entity;	log.info("test=testReportsServiceDownWithKilled; entity="+entity+"; app="+entity.getApplication());	Entities.start(entity.getApplication(), ImmutableList.of(loc));	EntityAsserts.assertAttributeEqualsEventually(MutableMap.of("timeout", 120*1000), entity, Startable.SERVICE_UP, true);	killEntityBehindBack(entity);	
killed behind mgmt s back waiting for service up false in mgmt context 

public void testReportsServiceDownWhenKilled(final SoftwareProcess entity) throws Exception {	this.entity = entity;	log.info("test=testReportsServiceDownWithKilled; entity="+entity+"; app="+entity.getApplication());	Entities.start(entity.getApplication(), ImmutableList.of(loc));	EntityAsserts.assertAttributeEqualsEventually(MutableMap.of("timeout", 120*1000), entity, Startable.SERVICE_UP, true);	killEntityBehindBack(entity);	EntityAsserts.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, false);	
success getting service up false in primary mgmt universe 

public void publishesRequestAndErrorCountMetrics(final SoftwareProcess entity) throws Exception {	this.entity = entity;	log.info("test=publishesRequestAndErrorCountMetrics; entity="+entity+"; app="+entity.getApplication());	Entities.start(entity.getApplication(), ImmutableList.of(loc));	EntityAsserts.assertAttributeEqualsEventually( MutableMap.of("timeout", 120 * 1000), entity, Startable.SERVICE_UP, Boolean.TRUE);	String url = entity.getAttribute(WebAppService.ROOT_URL) + "does_not_exist";	final int n = 10;	for (int i = 0; i < n; i++) {	URLConnection connection = HttpTestUtils.connectToUrl(url);	int status = ((HttpURLConnection) connection).getResponseCode();	
connection to gives 

public void publishesRequestsPerSecondMetric(final SoftwareProcess entity) throws Exception {	this.entity = entity;	log.info("test=publishesRequestsPerSecondMetric; entity="+entity+"; app="+entity.getApplication());	Entities.start(entity.getApplication(), ImmutableList.of(loc));	
entity started 

public void publishesRequestsPerSecondMetric(final SoftwareProcess entity) throws Exception {	this.entity = entity;	log.info("test=publishesRequestsPerSecondMetric; entity="+entity+"; app="+entity.getApplication());	Entities.start(entity.getApplication(), ImmutableList.of(loc));	try {	
waiting for initial avg requests to be zero 

assertNotNull(activityValue, "activity not set yet "+activityValue+")");	assertEquals(activityValue.doubleValue(), 0.0d, 0.000001d);	}});	Asserts.succeedsEventually(MutableMap.of("timeout", 30*1000), new Callable<Void>() {	public Void call() throws Exception {	String url = entity.getAttribute(WebAppService.ROOT_URL) + "does_not_exist";	final int desiredMsgsPerSec = 10;	Stopwatch stopwatch = Stopwatch.createStarted();	final AtomicInteger reqsSent = new AtomicInteger();	final Integer preRequestCount = entity.getAttribute(WebAppService.REQUEST_COUNT);	
applying load for 

Asserts.succeedsEventually(MutableMap.of("timeout", 4000), new Runnable() {	public void run() {	Double avgReqs = entity.getAttribute(WebAppService.REQUESTS_PER_SECOND_IN_WINDOW);	Integer requestCount = entity.getAttribute(WebAppService.REQUEST_COUNT);	log.info("avg-requests="+avgReqs+"; total-requests="+requestCount);	assertEquals(avgReqs.doubleValue(), desiredMsgsPerSec, 3.0d);	assertEquals(requestCount.intValue(), preRequestCount+reqsSent.get());	}});	return null;	}});	
waiting for avg requests to drop to zero for 

protected <T> SubscriptionHandle recordEvents(Entity entity, AttributeSensor<T> sensor, final List<SensorEvent<T>> events) {	SensorEventListener<T> listener = new SensorEventListener<T>() {	
onevent 

========================= brooklyn sample_180 =========================

});	try {	ByteArrayOutputStream stdin = new ByteArrayOutputStream();	if (command != null) {	stdin.write(command.getBytes());	} else if (psCommand != null) {	stdin.write(psCommand.getBytes());	}	tb.tag(BrooklynTaskTags.tagForStreamSoft(BrooklynTaskTags.STREAM_STDIN, stdin));	} catch (IOException e) {	
error registering stream on 

gatherOutput();	resultCodeCheck = new Predicate<Integer>() {	public boolean apply(@Nullable Integer input) {	if (input==0) return true;	try {	String notes = "";	if (!getResultStderr().isEmpty()) notes += "STDERR\n" + getResultStderr()+"\n";	if (!getResultStdout().isEmpty()) notes += "\n" + "STDOUT\n" + getResultStdout()+"\n";	Tasks.setExtraStatusDetails(notes.trim());	} catch (Exception e) {	
unable to collect additional metadata on failure of 

========================= brooklyn sample_2331 =========================

public void apply(TemplateOptions t, ConfigBag props, Object v) {	if (t instanceof NovaTemplateOptions) {	((NovaTemplateOptions) t).autoAssignFloatingIp((Boolean) v);	} else if (t instanceof CloudStackTemplateOptions) {	((CloudStackTemplateOptions) t).setupStaticNat((Boolean) v);	} else {	
ignoring auto assign floating ip in vm creation because not supported for cloud type 

========================= brooklyn sample_2624 =========================

public void onEvent(SensorEvent<T> event, long eventTimestamp) {	Number current = event.getValue();	if (current == null) {	
ignoring null value in at 

public void onEvent(SensorEvent<T> event, long eventTimestamp) {	Number current = event.getValue();	if (current == null) {	return;	}	if (eventTimestamp > lastTimestamp) {	if (lastValue == null) {	
received event but no last value so will not emit null at 

public void onEvent(SensorEvent<T> event, long eventTimestamp) {	Number current = event.getValue();	if (current == null) {	return;	}	if (eventTimestamp > lastTimestamp) {	if (lastValue == null) {	} else if (lastTimestamp < 0) {	
has lastvalue but last timestamp new value is at not publishing 

if (current == null) {	return;	}	if (eventTimestamp > lastTimestamp) {	if (lastValue == null) {	} else if (lastTimestamp < 0) {	} else {	long duration = eventTimestamp - lastTimestamp;	double fraction = toNanos(current.doubleValue() - lastValue.doubleValue(), durationPerOrigUnit.nanos()) / TimeUnit.MILLISECONDS.toNanos(duration);	entity.sensors().set((AttributeSensor<Double>)target, fraction);	
set to at previous at 

========================= brooklyn sample_3035 =========================

public void onEvent(SensorEvent<Number> event) {	Number current = producer.sensors().get(sourceCurrentSensor);	if (current == null) {	
can t calculate percentage value for entity as current from producer is null 

public void onEvent(SensorEvent<Number> event) {	Number current = producer.sensors().get(sourceCurrentSensor);	if (current == null) {	return;	}	Number total = producer.sensors().get(sourceTotalSensor);	if (total == null) {	
can t calculate percentage value for entity as total from producer is null 

if (current == null) {	return;	}	Number total = producer.sensors().get(sourceTotalSensor);	if (total == null) {	return;	}	Double currentDouble = current.doubleValue();	Double totalDouble = total.doubleValue();	if (DoubleMath.fuzzyEquals(totalDouble, 0d, EPSILON)) {	
can t calculate percentage value for entity as total from producer is zero 

Number total = producer.sensors().get(sourceTotalSensor);	if (total == null) {	return;	}	Double currentDouble = current.doubleValue();	Double totalDouble = total.doubleValue();	if (DoubleMath.fuzzyEquals(totalDouble, 0d, EPSILON)) {	return;	}	if (currentDouble < 0d || totalDouble < 0d) {	
can t calculate percentage value for entity as current or total from producer is negative 

========================= brooklyn sample_1008 =========================

public void testIfNodeStopsBeingAbleToWrite() throws Exception {	useSharedTime();	
time at start 

public void testIfNodeStopsBeingAbleToWrite() throws Exception {	useSharedTime();	HaMgmtNode n1 = newNode();	HaMgmtNode n2 = newNode();	n1.ha.start(HighAvailabilityMode.AUTO);	ManagementPlaneSyncRecord memento1 = n1.ha.loadManagementPlaneSyncRecord(true);	
ha 

HaMgmtNode n1 = newNode();	HaMgmtNode n2 = newNode();	n1.ha.start(HighAvailabilityMode.AUTO);	ManagementPlaneSyncRecord memento1 = n1.ha.loadManagementPlaneSyncRecord(true);	assertEquals(memento1.getMasterNodeId(), n1.ownNodeId);	Long time0 = sharedTickerCurrentMillis();	assertEquals(memento1.getManagementNodes().get(n1.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(memento1.getManagementNodes().get(n1.ownNodeId).getStatus(), ManagementNodeState.MASTER);	n2.ha.start(HighAvailabilityMode.HOT_STANDBY);	ManagementPlaneSyncRecord memento2 = n2.ha.loadManagementPlaneSyncRecord(true);	
ha 

assertEquals(memento2.getManagementNodes().get(n2.ownNodeId).getStatus(), ManagementNodeState.HOT_STANDBY);	assertEquals(memento2.getManagementNodes().get(n1.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(memento2.getManagementNodes().get(n2.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(n1.mgmt.getApplications().size(), 0);	assertEquals(n2.mgmt.getApplications().size(), 0);	TestApplication app = n1.mgmt.getEntityManager().createEntity(EntitySpec.create(TestApplication.class));	app.start(ImmutableList.<Location>of());	app.sensors().set(TestApplication.MY_ATTRIBUTE, "hello");	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 0);	
persisting 

assertEquals(memento2.getManagementNodes().get(n2.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(n1.mgmt.getApplications().size(), 0);	assertEquals(n2.mgmt.getApplications().size(), 0);	TestApplication app = n1.mgmt.getEntityManager().createEntity(EntitySpec.create(TestApplication.class));	app.start(ImmutableList.<Location>of());	app.sensors().set(TestApplication.MY_ATTRIBUTE, "hello");	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 0);	n1.mgmt.getRebindManager().forcePersistNow(false, null);	n1.objectStore.setWritesFailSilently(true);	
writes off 

assertEquals(n1.mgmt.getApplications().size(), 0);	assertEquals(n2.mgmt.getApplications().size(), 0);	TestApplication app = n1.mgmt.getEntityManager().createEntity(EntitySpec.create(TestApplication.class));	app.start(ImmutableList.<Location>of());	app.sensors().set(TestApplication.MY_ATTRIBUTE, "hello");	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 0);	n1.mgmt.getRebindManager().forcePersistNow(false, null);	n1.objectStore.setWritesFailSilently(true);	sharedTickerAdvance(Duration.ONE_MINUTE);	
time now 

assertEquals(n2.mgmt.getApplications().size(), 0);	TestApplication app = n1.mgmt.getEntityManager().createEntity(EntitySpec.create(TestApplication.class));	app.start(ImmutableList.<Location>of());	app.sensors().set(TestApplication.MY_ATTRIBUTE, "hello");	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 0);	n1.mgmt.getRebindManager().forcePersistNow(false, null);	n1.objectStore.setWritesFailSilently(true);	sharedTickerAdvance(Duration.ONE_MINUTE);	Long time1 = sharedTickerCurrentMillis();	
publish 

app.start(ImmutableList.<Location>of());	app.sensors().set(TestApplication.MY_ATTRIBUTE, "hello");	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 0);	n1.mgmt.getRebindManager().forcePersistNow(false, null);	n1.objectStore.setWritesFailSilently(true);	sharedTickerAdvance(Duration.ONE_MINUTE);	Long time1 = sharedTickerCurrentMillis();	n2.ha.publishAndCheck(false);	ManagementPlaneSyncRecord memento2b = n2.ha.loadManagementPlaneSyncRecord(true);	
ha now 

ManagementPlaneSyncRecord memento2b = n2.ha.loadManagementPlaneSyncRecord(true);	assertEquals(memento2b.getManagementNodes().get(n1.ownNodeId).getStatus(), ManagementNodeState.FAILED);	assertEquals(memento2b.getManagementNodes().get(n2.ownNodeId).getStatus(), ManagementNodeState.MASTER);	assertEquals(memento2b.getMasterNodeId(), n2.ownNodeId);	assertEquals(memento2b.getManagementNodes().get(n1.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(memento2b.getManagementNodes().get(n2.ownNodeId).getRemoteTimestamp(), time1);	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 1);	assertEquals(n1.mgmt.getApplications().iterator().next().getAttribute(TestApplication.MY_ATTRIBUTE), "hello");	n1.objectStore.setWritesFailSilently(false);	
writes on 

assertEquals(memento2b.getManagementNodes().get(n1.ownNodeId).getStatus(), ManagementNodeState.FAILED);	assertEquals(memento2b.getManagementNodes().get(n2.ownNodeId).getStatus(), ManagementNodeState.MASTER);	assertEquals(memento2b.getMasterNodeId(), n2.ownNodeId);	assertEquals(memento2b.getManagementNodes().get(n1.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(memento2b.getManagementNodes().get(n2.ownNodeId).getRemoteTimestamp(), time1);	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 1);	assertEquals(n1.mgmt.getApplications().iterator().next().getAttribute(TestApplication.MY_ATTRIBUTE), "hello");	n1.objectStore.setWritesFailSilently(false);	sharedTickerAdvance(Duration.ONE_SECOND);	
time now 

assertEquals(memento2b.getManagementNodes().get(n2.ownNodeId).getStatus(), ManagementNodeState.MASTER);	assertEquals(memento2b.getMasterNodeId(), n2.ownNodeId);	assertEquals(memento2b.getManagementNodes().get(n1.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(memento2b.getManagementNodes().get(n2.ownNodeId).getRemoteTimestamp(), time1);	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 1);	assertEquals(n1.mgmt.getApplications().iterator().next().getAttribute(TestApplication.MY_ATTRIBUTE), "hello");	n1.objectStore.setWritesFailSilently(false);	sharedTickerAdvance(Duration.ONE_SECOND);	Long time2 = sharedTickerCurrentMillis();	
publish 

assertEquals(memento2b.getManagementNodes().get(n1.ownNodeId).getRemoteTimestamp(), time0);	assertEquals(memento2b.getManagementNodes().get(n2.ownNodeId).getRemoteTimestamp(), time1);	assertEquals(n1.mgmt.getApplications().size(), 1);	assertEquals(n2.mgmt.getApplications().size(), 1);	assertEquals(n1.mgmt.getApplications().iterator().next().getAttribute(TestApplication.MY_ATTRIBUTE), "hello");	n1.objectStore.setWritesFailSilently(false);	sharedTickerAdvance(Duration.ONE_SECOND);	Long time2 = sharedTickerCurrentMillis();	n1.ha.publishAndCheck(false);	ManagementPlaneSyncRecord memento1b = n1.ha.loadManagementPlaneSyncRecord(true);	
ha now 

Long time2 = sharedTickerCurrentMillis();	n1.ha.publishAndCheck(false);	ManagementPlaneSyncRecord memento1b = n1.ha.loadManagementPlaneSyncRecord(true);	ManagementNodeState expectedStateAfterDemotion = BrooklynFeatureEnablement.isEnabled(BrooklynFeatureEnablement.FEATURE_DEFAULT_STANDBY_IS_HOT_PROPERTY) ? ManagementNodeState.HOT_STANDBY : ManagementNodeState.STANDBY;	assertEquals(memento1b.getManagementNodes().get(n1.ownNodeId).getStatus(), expectedStateAfterDemotion);	assertEquals(memento1b.getManagementNodes().get(n2.ownNodeId).getStatus(), ManagementNodeState.MASTER);	assertEquals(memento1b.getMasterNodeId(), n2.ownNodeId);	assertEquals(memento1b.getManagementNodes().get(n1.ownNodeId).getRemoteTimestamp(), time2);	assertEquals(memento1b.getManagementNodes().get(n2.ownNodeId).getRemoteTimestamp(), time1);	ManagementPlaneSyncRecord memento2c = n2.ha.loadManagementPlaneSyncRecord(true);	
ha now 

Asserts.succeedsEventually(new Runnable() {	ManagementPlaneSyncRecord memento = nodes.get(0).ha.loadManagementPlaneSyncRecord(true);	List<ManagementNodeState> counts = MutableList.of(), savedCounts = MutableList.of();	for (HaMgmtNode n: nodes) {	counts.add(n.ha.getNodeState());	ManagementNodeSyncRecord m = memento.getManagementNodes().get(n.ownNodeId);	if (m!=null) {	savedCounts.add(m.getStatus());	}	}	
while starting nodes m hot warm init saved m hot warm init 

ManagementPlaneSyncRecord memento = nodes.get(0).ha.loadManagementPlaneSyncRecord(true);	List<ManagementNodeState> counts = MutableList.of(), savedCounts = MutableList.of();	for (HaMgmtNode n: nodes) {	counts.add(n.ha.getNodeState());	ManagementNodeSyncRecord m = memento.getManagementNodes().get(n.ownNodeId);	if (m!=null) {	savedCounts.add(m.getStatus());	}	}	if (timer.isRunning() && Duration.of(timer).compareTo(Duration.TEN_SECONDS)>0) {	
we seem to have a problem stabilizing 

}	if (timer.isRunning() && Duration.of(timer).compareTo(Duration.TEN_SECONDS)>0) {	timer.stop();	}	assertEquals(Collections.frequency(counts, ManagementNodeState.MASTER), 1);	assertEquals(Collections.frequency(counts, ManagementNodeState.HOT_STANDBY)+Collections.frequency(counts, ManagementNodeState.STANDBY), nodes.size()-1);	assertEquals(Collections.frequency(savedCounts, ManagementNodeState.MASTER), 1);	assertEquals(Collections.frequency(savedCounts, ManagementNodeState.HOT_STANDBY)+Collections.frequency(savedCounts, ManagementNodeState.STANDBY), nodes.size()-1);	}});	} catch (Throwable t) {	
failed to stabilize rethrowing 

========================= brooklyn sample_616 =========================

protected void waitForApplicationTasks(Entity app) {	Set<Task<?>> tasks = BrooklynTaskTags.getTasksInEntityContext(brooklynMgmt.getExecutionManager(), app);	
waiting on task s 

========================= brooklyn sample_1634 =========================

private LocationSpec<?> getLocationSpec(String spec) {	
obtaining location spec 

private OpenShiftLocation resolve(String spec) {	
resolving location spec 

========================= brooklyn sample_2448 =========================

String publicAddress = "5.6.7.8";	TestEntity origEntity = origApp.createAndManageChild(EntitySpec.create(TestEntity.class).impl(MyEntity.class));	PortForwardManager origPortForwardManager = origEntity.getConfig(MyEntity.PORT_FORWARD_MANAGER);	origPortForwardManager.associate(publicIpId, HostAndPort.fromParts(publicAddress, 40080), origSimulatedMachine, 80);	String label = origManagementContext.getManagementNodeId()+"-"+Time.makeDateSimpleStampString();	PersistenceObjectStore targetStore = BrooklynPersistenceUtils.newPersistenceObjectStore(origManagementContext, null, "tmp/web-persistence-"+label+"-"+Identifiers.makeRandomId(4));	File dir = ((FileBasedObjectStore)targetStore).getBaseDir();	Os.deleteOnExitEmptyParentsUpTo(dir.getParentFile(), dir.getParentFile());	BrooklynPersistenceUtils.writeMemento(origManagementContext, targetStore, MementoCopyMode.LOCAL);	RebindTestUtils.waitForPersisted(origApp);	
using manual export dir for rebind instead of 

========================= brooklyn sample_817 =========================

} else {	Set<?> keys = ((Map<?,?>)targetSpec).keySet();	if (keys.size()!=1) throw new IllegalArgumentException("targets supplied to MultiLocation must be a list of single-entry maps (got map of size "+keys.size()+": "+targetSpec+")");	Object key = keys.iterator().next();	Object flagsS = ((Map<?,?>)targetSpec).get(key);	targets.add(managementContext.getLocationRegistry().getLocationSpec((String)key, (Map<?,?>)flagsS).get());	}	}	} else throw new IllegalArgumentException("targets must be supplied to MultiLocation, either as string spec or list of single-entry maps each being a location spec");	if (LOG.isDebugEnabled()) {	
creating multi location spec for sub locations 

========================= brooklyn sample_1589 =========================

public void customize() {	if (LOG.isInfoEnabled()) {	
customizing 

public void launch() {	entity.sensors().set(HazelcastNode.PID_FILE, Os.mergePathsUnix(getRunDir(), PID_FILENAME));	String maxHeapMemorySize = getHeapMemorySize();	if (LOG.isInfoEnabled()) {	
launching with heap memory of 

List<String> result = Lists.newArrayList();	if (Strings.isBlank(entity.getAttribute(HazelcastNode.NODE_CLUSTER_NAME))) {	result.add(String.format("%s:%d", entity.getAttribute(HazelcastNode.SUBNET_ADDRESS), entity.getAttribute(HazelcastNode.NODE_PORT)));	} else {	HazelcastCluster cluster = (HazelcastCluster) entity.getParent();	for (Entity member : cluster.getMembers()) {	String address = Entities.attributeSupplierWhenReady(member, HazelcastNode.SUBNET_ADDRESS).get();	Integer port = Entities.attributeSupplierWhenReady(member, HazelcastNode.NODE_PORT).get();	String addressAndPort = String.format("%s:%d", address, port);	if (LOG.isInfoEnabled()) {	
adding to the members list of 

========================= brooklyn sample_401 =========================

protected void onEntityChange(Entity member) {	
location updated in fabric 

protected void onEntityAdded(Entity member) {	
location added to fabric 

protected void onEntityRemoved(Entity member) {	
location removed from fabric 

========================= brooklyn sample_397 =========================

public void testGetHighAvailability() throws Exception {	HighAvailabilitySummary summary = client().path("/server/ha/states").get(HighAvailabilitySummary.class);	
ha summary is 

========================= brooklyn sample_2825 =========================

public void testFailuresThenUpDownResetsStabilisationCount() throws Exception {	
running testfailuresthenupdownresetsstabilisationcount 

========================= brooklyn sample_3019 =========================

public <T> T create(RegisteredType type, @Nullable RegisteredTypeLoadingContext constraint, @Nullable Class<T> optionalResultSuperType) {	Preconditions.checkNotNull(type, "type");	return new RegisteredTypeKindVisitor<T>() {	try {	
request for to create unresolved kind trying as spec 

public <T> T create(RegisteredType type, @Nullable RegisteredTypeLoadingContext constraint, @Nullable Class<T> optionalResultSuperType) {	Preconditions.checkNotNull(type, "type");	return new RegisteredTypeKindVisitor<T>() {	try {	T result = visitSpec();	
request to use from unresolved state succeeded treating is as a spec 

public <T> T create(RegisteredType type, @Nullable RegisteredTypeLoadingContext constraint, @Nullable Class<T> optionalResultSuperType) {	Preconditions.checkNotNull(type, "type");	return new RegisteredTypeKindVisitor<T>() {	try {	T result = visitSpec();	
trace for request to use in unresolved state succeeding location of request to use in unresolved state 

public void addToLocalUnpersistedTypeRegistry(RegisteredType type, boolean canForce) {	Preconditions.checkNotNull(type);	Preconditions.checkNotNull(type.getSymbolicName());	Preconditions.checkNotNull(type.getVersion());	Preconditions.checkNotNull(type.getId());	if (!type.getId().equals(type.getSymbolicName()+":"+type.getVersion())) Asserts.fail("Registered type "+type+" has ID / symname mismatch");	RegisteredType oldType = mgmt.getTypeRegistry().get(type.getId());	if (oldType==null || canForce || BrooklynVersionSyntax.isSnapshot(oldType.getVersion())) {	
inserting into 

private boolean assertSameEnoughToAllowReplacing(RegisteredType oldType, RegisteredType type) {	if (!oldType.getVersionedName().equals(type.getVersionedName())) {	throw new IllegalStateException("Cannot add "+type+" to catalog; different "+oldType+" is already present");	}	if (Objects.equals(oldType.getContainingBundle(), type.getContainingBundle())) {	if (!samePlan(oldType, type)) {	String msg = "Cannot add "+type+" to catalog; different plan in "+oldType+" from same bundle "+ type.getContainingBundle()+" is already present";	
plan being added is plan already present is 

String msg = "Cannot add "+type+" to catalog; different plan in "+oldType+" from same bundle "+ type.getContainingBundle()+" is already present";	throw new IllegalStateException(msg);	}	if (oldType.getKind()!=RegisteredTypeKind.UNRESOLVED && type.getKind()!=RegisteredTypeKind.UNRESOLVED && !Objects.equals(oldType.getKind(), type.getKind())) {	throw new IllegalStateException("Cannot add "+type+" to catalog; different kind in "+oldType+" from same bundle is already present");	}	return true;	}	if (!samePlan(oldType, type)) {	String msg = "Cannot add "+type+" in "+type.getContainingBundle()+" to catalog; different plan in "+oldType+" from bundle "+ oldType.getContainingBundle()+" is already present (throwing)";	
plan being added from is plan already present from is 

========================= brooklyn sample_1024 =========================

synchronized (x) {	x.release();	}	}	});	t = null;	Stopwatch watch = Stopwatch.createStarted();	for (int i=0; i<30; i++) {	System.gc(); System.gc();	if (x.tryAcquire(1, TimeUnit.SECONDS)) {	
finalizer ran after 

========================= brooklyn sample_905 =========================

public void start(final Collection<? extends Location> locs) {	
starting 

public void stop() {	
stopping 

========================= brooklyn sample_2521 =========================

protected RawT extractValueMatchingThisKey(Object potentialBase, ExecutionContext exec, boolean coerce) throws InterruptedException, ExecutionException {	if (coerce) {	potentialBase = resolveValue(potentialBase, exec);	}	if (potentialBase==null) return null;	if (potentialBase instanceof Map<?,?>) {	return merge(false, ((Map<?,?>) potentialBase).values() );	} else if (potentialBase instanceof Collection<?>) {	return merge(false, (Collection<?>) potentialBase );	}	
unable to extract as collection it is 

protected Object applyValueToMap(Object value, Map target, boolean isInCollection) {	if (value instanceof StructuredModification) {	return ((StructuredModification)value).applyToKeyInMap(this, target);	} else if ((value instanceof Iterable) && (!isInCollection)) {	boolean isSet = isSet(target);	if (isSet) {	String warning = "Discouraged undecorated setting of a collection to in-use StructuredConfigKey "+this+": use SetModification.{set,add}. " + "Defaulting to 'add'. Look at debug logging for call stack.";	log.warn(warning);	
trace for trace for 

}	if (Iterables.isEmpty(valueI) && !isSet) {	target.put(this, MutableSet.of());	}	return null;	} else if (value instanceof TaskAdaptable) {	boolean isSet = isSet(target);	if (isSet) {	String warning = "Discouraged undecorated setting of a task to in-use StructuredConfigKey "+this+": use SetModification.{set,add}. " + "Defaulting to 'add'. Look at debug logging for call stack.";	log.warn(warning);	
trace for trace for 

========================= brooklyn sample_1198 =========================

public Class<?> realClass(String elementName) {	String elementNamOrig = elementName;	Maybe<String> elementNameOpt = Reflections.findMappedNameMaybe(nameToType, elementName);	if (elementNameOpt.isPresent()) {	
mapping class to 

String elementNamOrig = elementName;	Maybe<String> elementNameOpt = Reflections.findMappedNameMaybe(nameToType, elementName);	if (elementNameOpt.isPresent()) {	elementName = elementNameOpt.get();	}	Exception tothrow;	try {	return super.realClass(elementName);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	
failed to load class using super realclass for orig class attempting fallbacks 

try {	return super.realClass(elementName);	} catch (Exception e) {	Exceptions.propagateIfFatal(e);	tothrow = e;	}	if (elementNameOpt.isPresent() && hasBundlePrefix(elementName)) {	try {	return classLoaderSupplier.get().loadClass(elementName);	} catch (ClassNotFoundException e) {	
fallback loadclass attempt failed orig class 

}	if (hasBundlePrefix(elementNamOrig)) {	PrefixAndClass prefixAndClass = splitBundlePrefix(elementNamOrig);	Maybe<String> classNameOpt = Reflections.findMappedNameMaybe(nameToType, prefixAndClass.clazz);	if (classNameOpt.isPresent()) {	if (hasBundlePrefix(classNameOpt.get())) {	elementName = classNameOpt.get();	} else {	elementName = joinBundlePrefix(prefixAndClass.prefix, classNameOpt.get());	}	
mapping class to 

Maybe<String> classNameOpt = Reflections.findMappedNameMaybe(nameToType, prefixAndClass.clazz);	if (classNameOpt.isPresent()) {	if (hasBundlePrefix(classNameOpt.get())) {	elementName = classNameOpt.get();	} else {	elementName = joinBundlePrefix(prefixAndClass.prefix, classNameOpt.get());	}	try {	return super.realClass(elementName);	} catch (CannotResolveClassException e) {	
fallback super realclass attempt failed orig class 

} else {	elementName = joinBundlePrefix(prefixAndClass.prefix, classNameOpt.get());	}	try {	return super.realClass(elementName);	} catch (CannotResolveClassException e) {	}	try {	return classLoaderSupplier.get().loadClass(elementName);	} catch (ClassNotFoundException e) {	
fallback loadclass attempt failed orig class 

========================= brooklyn sample_1527 =========================

public abstract T invokeEffector(I trait, Map<String,?> parameters);	public static <I,T> ExplicitEffector<I,T> create(String name, Class<T> type, List<ParameterType<?>> parameters, String description, Closure body) {	
use of groovy lang closure is deprecated in expliciteffector create 

========================= brooklyn sample_1177 =========================

public void testCopyToFailBadSubdir() throws IOException {	String fn = Urls.mergePaths(tempDir.getPath(), "non-existent-subdir/file");	SshPutTaskWrapper t = submit(SshTasks.newSshPutTaskFactory(host, fn).contents("hello world"));	t.block();	Assert.assertTrue(t.isDone());	setExpectingFailure();	try {	t.get();	} catch (Exception e) {	
the error if file cannot be written is 

========================= brooklyn sample_913 =========================

private Channel getAmqpChannel(RabbitBroker rabbit) throws Exception {	String uri = rabbit.getAttribute(MessageBroker.BROKER_URL);	
connecting to rabbit 

========================= brooklyn sample_440 =========================

protected void deleteKubernetesResourceLocation(Entity entity) {	final String namespace = entity.sensors().get(KubernetesPod.KUBERNETES_NAMESPACE);	final String resourceType = entity.sensors().get(KubernetesResource.RESOURCE_TYPE);	final String resourceName = entity.sensors().get(KubernetesResource.RESOURCE_NAME);	if (!handleResourceDelete(resourceType, resourceName, namespace)) {	
resource not deleted 

case KubernetesResource.DEPLOYMENT: return client.extensions().deployments().inNamespace(namespace).withName(resourceName).delete();	case KubernetesResource.REPLICA_SET: return client.extensions().replicaSets().inNamespace(namespace).withName(resourceName).delete();	case KubernetesResource.CONFIG_MAP: return client.configMaps().inNamespace(namespace).withName(resourceName).delete();	case KubernetesResource.PERSISTENT_VOLUME: return client.persistentVolumes().withName(resourceName).delete();	case KubernetesResource.SECRET: return client.secrets().inNamespace(namespace).withName(resourceName).delete();	case KubernetesResource.SERVICE: return client.services().inNamespace(namespace).withName(resourceName).delete();	case KubernetesResource.REPLICATION_CONTROLLER: return client.replicationControllers().inNamespace(namespace).withName(resourceName).delete();	case KubernetesResource.NAMESPACE: return client.namespaces().withName(resourceName).delete();	}	} catch (KubernetesClientException kce) {	
error deleting resource 

}	public String getFailureMessage() {	return "Cannot find created resources";	}	};	waitForExitCondition(exitCondition);	HasMetadata metadata = result.get(0);	String resourceType = metadata.getKind();	String resourceName = metadata.getMetadata().getName();	String namespace = metadata.getMetadata().getNamespace();	
resource type deployed to 

waitForExitCondition(exitCondition);	HasMetadata metadata = result.get(0);	String resourceType = metadata.getKind();	String resourceName = metadata.getMetadata().getName();	String namespace = metadata.getMetadata().getNamespace();	entity.sensors().set(KubernetesPod.KUBERNETES_NAMESPACE, namespace);	entity.sensors().set(KubernetesResource.RESOURCE_NAME, resourceName);	entity.sensors().set(KubernetesResource.RESOURCE_TYPE, resourceType);	LocationSpec<? extends KubernetesMachineLocation> locationSpec = LocationSpec.create(KubernetesSshMachineLocation.class);	if (!findResourceAddress(locationSpec, entity, metadata, resourceType, resourceName, namespace)) {	
resource with type has no associated address 

String podName = address.getTargetRef().getName();	podNames.add(podName);	String privateIp = address.getIp();	privateIps.add(privateIp);	}	}	locationSpec.configure(SshMachineLocation.PRIVATE_ADDRESSES, ImmutableSet.copyOf(privateIps));	if (podNames.size() > 0) {	String podName = Iterables.get(podNames, 0);	if (podNames.size() > 1) {	
multiple pods referenced by service in namespace using 

if (podNames.size() > 0) {	String podName = Iterables.get(podNames, 0);	if (podNames.size() > 1) {	}	try {	Pod pod = getPod(namespace, podName);	entity.sensors().set(KubernetesPod.KUBERNETES_POD, podName);	InetAddress node = Networking.getInetAddressWithFixedName(pod.getSpec().getNodeName());	locationSpec.configure("address", node);	} catch (KubernetesClientException kce) {	
cannot find pod in namespace for service 

int exitstatus = machine.execScript( ImmutableMap.of( SshTool.PROP_CONNECT_TIMEOUT.getName(), Duration.TEN_SECONDS.toMilliseconds(), SshTool.PROP_SESSION_TIMEOUT.getName(), Duration.TEN_SECONDS.toMilliseconds(), SshTool.PROP_SSH_TRIES_TIMEOUT.getName(), Duration.TEN_SECONDS.toMilliseconds(), SshTool.PROP_SSH_TRIES.getName(), 1), "check-sshable", ImmutableList.of("true"));	boolean success = (exitstatus == 0);	return success;	}	};	Stopwatch stopwatch = Stopwatch.createStarted();	ReferenceWithError<Boolean> reachable = Repeater.create("reachable") .threaded() .backoff(Duration.FIVE_SECONDS, 2, Duration.TEN_SECONDS) .until(checker) .limitTimeTo(timeout) .runKeepingError();	if (!reachable.getWithoutError()) {	throw new IllegalStateException("Connection failed for " + machine.getSshHostAndPort() + " after waiting " + stopwatch.elapsed(TimeUnit.SECONDS), reachable.getError());	} else {	
connection succeeded for after 

protected void registerPortMappings(KubernetesSshMachineLocation machine, Entity entity, Service service) {	PortForwardManager portForwardManager = (PortForwardManager) getManagementContext().getLocationRegistry() .getLocationManaged(PortForwardManagerLocationResolver.PFM_GLOBAL_SPEC);	List<ServicePort> ports = service.getSpec().getPorts();	String publicHostText = ((SshMachineLocation) machine).getSshHostAndPort().getHostText();	
recording port mappings for container of 

protected void registerPortMappings(KubernetesSshMachineLocation machine, Entity entity, Service service) {	PortForwardManager portForwardManager = (PortForwardManager) getManagementContext().getLocationRegistry() .getLocationManaged(PortForwardManagerLocationResolver.PFM_GLOBAL_SPEC);	List<ServicePort> ports = service.getSpec().getPorts();	String publicHostText = ((SshMachineLocation) machine).getSshHostAndPort().getHostText();	for (ServicePort port : ports) {	String protocol = port.getProtocol();	Integer targetPort = port.getTargetPort().getIntVal();	if (!"TCP".equalsIgnoreCase(protocol)) {	
ignoring port mapping for because only tcp is currently supported 

protected void registerPortMappings(KubernetesSshMachineLocation machine, Entity entity, Service service) {	PortForwardManager portForwardManager = (PortForwardManager) getManagementContext().getLocationRegistry() .getLocationManaged(PortForwardManagerLocationResolver.PFM_GLOBAL_SPEC);	List<ServicePort> ports = service.getSpec().getPorts();	String publicHostText = ((SshMachineLocation) machine).getSshHostAndPort().getHostText();	for (ServicePort port : ports) {	String protocol = port.getProtocol();	Integer targetPort = port.getTargetPort().getIntVal();	if (!"TCP".equalsIgnoreCase(protocol)) {	} else if (targetPort == null) {	
ignoring port mapping for because targetport intvalue is null 

protected void registerPortMappings(KubernetesSshMachineLocation machine, Entity entity, Service service) {	PortForwardManager portForwardManager = (PortForwardManager) getManagementContext().getLocationRegistry() .getLocationManaged(PortForwardManagerLocationResolver.PFM_GLOBAL_SPEC);	List<ServicePort> ports = service.getSpec().getPorts();	String publicHostText = ((SshMachineLocation) machine).getSshHostAndPort().getHostText();	for (ServicePort port : ports) {	String protocol = port.getProtocol();	Integer targetPort = port.getTargetPort().getIntVal();	if (!"TCP".equalsIgnoreCase(protocol)) {	} else if (targetPort == null) {	} else if (port.getNodePort() == null) {	
ignoring port mapping to because port getnodeport is null 

public Boolean call() {	Namespace actualNamespace = client.namespaces().withName(name).get();	return actualNamespace != null && actualNamespace.getStatus().getPhase().equals(PHASE_ACTIVE);	}	public String getFailureMessage() {	Namespace actualNamespace = client.namespaces().withName(name).get();	return "Namespace for " + name + " " + (actualNamespace == null ? "absent" : " status " + actualNamespace.getStatus());	}	};	if (namespace != null) {	
found namespace returning it 

return actualNamespace != null && actualNamespace.getStatus().getPhase().equals(PHASE_ACTIVE);	}	public String getFailureMessage() {	Namespace actualNamespace = client.namespaces().withName(name).get();	return "Namespace for " + name + " " + (actualNamespace == null ? "absent" : " status " + actualNamespace.getStatus());	}	};	if (namespace != null) {	} else if (create) {	namespace = client.namespaces().create(new NamespaceBuilder().withNewMetadata().withName(name).endMetadata().build());	
created namespace 

for (Map.Entry<String, ?> envVarEntry : env.entrySet()) {	envVars.add(new EnvVarBuilder().withName(envVarEntry.getKey()).withValue(envVarEntry.getValue().toString()).build());	}	ContainerBuilder containerBuilder = new ContainerBuilder() .withName(deploymentName) .withImage(imageName) .addToPorts(Iterables.toArray(containerPorts, ContainerPort.class)) .addToEnv(Iterables.toArray(envVars, EnvVar.class)) .withNewSecurityContext() .withPrivileged(privileged) .endSecurityContext();	if (limits != null) {	for (Map.Entry<String, String> nameValueEntry : limits.entrySet()) {	ResourceRequirements resourceRequirements = new ResourceRequirementsBuilder().addToLimits(nameValueEntry.getKey(), new QuantityBuilder().withAmount(nameValueEntry.getValue()).build()).build();	containerBuilder.withResources(resourceRequirements);	}	}	
built container to be deployed in namespace with metadata 

Integer replicas = (status == null) ? null : status.getAvailableReplicas();	return replicas != null && replicas.intValue() == replicas;	}	public String getFailureMessage() {	Deployment dep = client.extensions().deployments().inNamespace(namespace).withName(deploymentName).get();	DeploymentStatus status = (dep == null) ? null : dep.getStatus();	return "Namespace=" + namespace + "; deploymentName= " + deploymentName + "; Deployment=" + dep + "; status=" + status + "; availableReplicas=" + (status == null ? "null" : status.getAvailableReplicas());	}	};	waitForExitCondition(exitCondition);	
deployed deployment in namespace 

waitForExitCondition(exitCondition);	}	protected Service exposeService(String namespace, Map<String, String> metadata, String serviceName, Iterable<Integer> inboundPorts) {	List<ServicePort> servicePorts = Lists.newArrayList();	for (Integer inboundPort : inboundPorts) {	servicePorts.add(new ServicePortBuilder().withName(Integer.toString(inboundPort)).withPort(inboundPort).build());	}	Service service = new ServiceBuilder().withNewMetadata().withName(serviceName).endMetadata() .withNewSpec() .addToSelector(metadata) .addToPorts(Iterables.toArray(servicePorts, ServicePort.class)) .withType(NODE_PORT) .endSpec() .build();	client.services().inNamespace(namespace).create(service);	service = getService(namespace, serviceName);	
exposed service in namespace 

if (!isDockerContainer(entity)) {	Optional<ServicePort> sshPort = Iterables.tryFind(service.getSpec().getPorts(), new Predicate<ServicePort>() {	public boolean apply(ServicePort input) {	return input.getProtocol().equalsIgnoreCase("TCP") && input.getPort().intValue() == 22;	}	});	Optional<Integer> sshPortNumber;	if (sshPort.isPresent()) {	sshPortNumber = Optional.of(sshPort.get().getNodePort());	} else {	
no port mapping found to ssh port for container 

}	return defaultValue;	}	public void waitForExitCondition(ExitCondition exitCondition) {	waitForExitCondition(exitCondition, Duration.ONE_SECOND, Duration.FIVE_MINUTES);	}	public void waitForExitCondition(ExitCondition exitCondition, Duration initial, Duration duration) {	ReferenceWithError<Boolean> result = Repeater.create() .backoff(initial, 1.2, duration) .limitTimeTo(duration) .until(exitCondition) .runKeepingError();	if (!result.get()) {	String err = "Exit condition unsatisfied after " + duration + ": " + exitCondition.getFailureMessage();	
rethrowing 

========================= brooklyn sample_2472 =========================

public void deleteLocation() {	StubContainerLocation location = getDynamicLocation();	if (location != null) {	try {	location.close();	} catch (IOException ioe) {	
error closing container location 

========================= brooklyn sample_2167 =========================

public static WebApplicationException throwWebApplicationException(Response.Status status, Throwable exception, String format, Object... args) {	String suppliedMsg = format==null ? null : String.format(format, args);	String fullMsg = suppliedMsg;	if (exception!=null) {	if (fullMsg==null) fullMsg = Exceptions.collapseText(exception);	else fullMsg = suppliedMsg + ": "+Exceptions.collapseText(exception);	}	if (log.isDebugEnabled()) {	
responding 

public static MediaType getImageMediaTypeFromExtension(String extension) {	com.google.common.net.MediaType mime = IMAGE_FORMAT_MIME_TYPES.get(extension.toLowerCase());	if (mime==null) return null;	try {	return MediaType.valueOf(mime.toString());	} catch (Exception e) {	
unparseable mime type ignoring 

========================= brooklyn sample_2864 =========================

public AbstractScheduledEffectorPolicy() {	
created new scheduled effector policy 

Calendar now = Calendar.getInstance();	Calendar when = Calendar.getInstance();	Date parsed = parseTime(time);	when.setTime(parsed);	when.set(now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DATE));	if (when.before(now)) {	when.add(Calendar.DATE, 1);	}	return Duration.millis(Math.max(0, when.getTimeInMillis() - now.getTimeInMillis()));	} catch (ParseException | NumberFormatException e) {	
time should be formatted as 

public synchronized void run() {	if (effector == null) return;	if (!(isRunning() && getManagementContext().isRunning())) return;	try {	ConfigBag bag = ResolvingConfigBag.newInstanceExtending(getManagementContext(), config().getBag());	Map<String, Object> args = EntityInitializers.resolve(bag, EFFECTOR_ARGUMENTS);	
resolving arguments for 

public synchronized void run() {	if (effector == null) return;	if (!(isRunning() && getManagementContext().isRunning())) return;	try {	ConfigBag bag = ResolvingConfigBag.newInstanceExtending(getManagementContext(), config().getBag());	Map<String, Object> args = EntityInitializers.resolve(bag, EFFECTOR_ARGUMENTS);	Map<String, Object> resolved = (Map) Tasks.resolving(args, Object.class) .deep(true) .context(entity) .get();	
invoking effector on 

public synchronized void run() {	if (effector == null) return;	if (!(isRunning() && getManagementContext().isRunning())) return;	try {	ConfigBag bag = ResolvingConfigBag.newInstanceExtending(getManagementContext(), config().getBag());	Map<String, Object> args = EntityInitializers.resolve(bag, EFFECTOR_ARGUMENTS);	Map<String, Object> resolved = (Map) Tasks.resolving(args, Object.class) .deep(true) .context(entity) .get();	Object result = entity.invoke(effector, resolved).getUnchecked();	
effector returned 

if (effector == null) return;	if (!(isRunning() && getManagementContext().isRunning())) return;	try {	ConfigBag bag = ResolvingConfigBag.newInstanceExtending(getManagementContext(), config().getBag());	Map<String, Object> args = EntityInitializers.resolve(bag, EFFECTOR_ARGUMENTS);	Map<String, Object> resolved = (Map) Tasks.resolving(args, Object.class) .deep(true) .context(entity) .get();	Object result = entity.invoke(effector, resolved).getUnchecked();	} catch (RuntimeInterruptedException rie) {	Thread.currentThread().interrupt();	} catch (Throwable t) {	
exception running 

public void onEvent(SensorEvent<Object> event) {	
got event 

========================= brooklyn sample_3058 =========================

Throwable lastException = null;	T result = null;	long lastAttemptTime = 0;	long expireTime = startTime+duration.toMilliseconds();	long sleepTimeBetweenAttempts = minPeriod.toMilliseconds();	while (attempt < maxAttempts && lastAttemptTime < expireTime) {	try {	attempt++;	lastAttemptTime = System.currentTimeMillis();	result = c.call();	
attempt after ms 

long expireTime = startTime+duration.toMilliseconds();	long sleepTimeBetweenAttempts = minPeriod.toMilliseconds();	while (attempt < maxAttempts && lastAttemptTime < expireTime) {	try {	attempt++;	lastAttemptTime = System.currentTimeMillis();	result = c.call();	if (useGroovyTruth) {	if (groovyTruth(result)) return result;	} else if (Boolean.FALSE.equals(result)) {	
test returned an instance of booleanwithmessage but usegroovytruth is not set the result of this probably isn t what you intended 

if (groovyTruth(result)) return result;	} else if (Boolean.FALSE.equals(result)) {	return result;	} else {	return result;	}	lastException = null;	} catch(Throwable e) {	Exceptions.propagateIfInterrupt(e);	lastException = e;	
attempt after ms 

} catch(Throwable e) {	Exceptions.propagateIfInterrupt(e);	lastException = e;	if (abortOnException) throw e;	if (abortOnError && e instanceof Error) throw e;	}	long sleepTime = Math.min(sleepTimeBetweenAttempts, expireTime-System.currentTimeMillis());	if (sleepTime > 0) Thread.sleep(sleepTime);	sleepTimeBetweenAttempts = Math.min( sleepTimeBetweenAttempts + Math.max(1, sleepTimeBetweenAttempts/2), maxPeriod.toMilliseconds());	}	
succeedseventually exceeded max attempts or timeout attempts lasting ms for 

if (abortOnError && e instanceof Error) throw e;	}	long sleepTime = Math.min(sleepTimeBetweenAttempts, expireTime-System.currentTimeMillis());	if (sleepTime > 0) Thread.sleep(sleepTime);	sleepTimeBetweenAttempts = Math.min( sleepTimeBetweenAttempts + Math.max(1, sleepTimeBetweenAttempts/2), maxPeriod.toMilliseconds());	}	if (lastException != null) throw lastException;	throw fail("invalid results; last was: "+result);	} catch (Throwable t) {	Exceptions.propagateIfInterrupt(t);	
failed succeeds eventually attempts ms elapsed rethrowing 

long startTime = System.currentTimeMillis();	long expireTime = startTime+duration.toMilliseconds();	int attempt = 0;	boolean first = true;	T result = null;	while (first || System.currentTimeMillis() <= expireTime) {	attempt++;	try {	result = job.call();	} catch (Exception e) {	
succeedscontinually failed attempts lasting ms for rethrowing 

public static void assertFailsWith(Callable<?> c, Predicate<? super Throwable> exceptionChecker) {	boolean failed = false;	try {	c.call();	} catch (Throwable e) {	failed = true;	if (!exceptionChecker.apply(e)) {	
test threw invalid exception failing 

public static void assertFailsWith(Callable<?> c, Predicate<? super Throwable> exceptionChecker) {	boolean failed = false;	try {	c.call();	} catch (Throwable e) {	failed = true;	if (!exceptionChecker.apply(e)) {	fail("Test threw invalid exception: "+e);	}	
test for exception successful 

========================= brooklyn sample_1966 =========================

protected void checkIsRunningAndStops(Entity mysql, SshMachineLocation lh) {	Integer pid = getPid(mysql);	Assert.assertNotNull(pid, "PID should be set as an attribute (or getPid() overridden to supply)");	Entities.submit(app, SshEffectorTasks.requirePidRunning(pid).machine(lh).newTask() ).get();	app.stop();	Time.sleep(Duration.ONE_SECOND);	
mysql in pid should be dead now 

========================= brooklyn sample_2219 =========================

public void start(Collection<? extends Location> locations) {	try {	ServiceStateLogic.setExpectedState(this, Lifecycle.STARTING);	sensors().set(Attributes.SERVICE_UP, false);	Object val = config().get(START_LATCH);	if (val != null) {	
finished waiting for start latch in 

if (val != null) {	}	Entity child = sensors().get(CONDITIONAL_ENTITY);	EntitySpec<?> spec = config().get(CONDITIONAL_ENTITY_SPEC);	Boolean create = config().get(CREATE_CONDITIONAL_ENTITY);	Boolean propagate = config().get(PROPAGATE_CONDITIONAL_ENTITY_SENSORS);	Set<AttributeSensor<?>> sensors = MutableSet.copyOf(config().get(CONDITIONAL_ENTITY_SENSOR_LIST));	Duration timeout = config().get(BrooklynConfigKeys.START_TIMEOUT);	addLocations(locations);	locations = Locations.getLocationsCheckingAncestors(locations, this);	
starting entity 

enrichers().add(ServiceStateLogic.newEnricherFromChildrenState() .suppressDuplicates(true) .configure(ComputeServiceIndicatorsFromChildrenAndMembers.RUNNING_QUORUM_CHECK, QuorumCheck.QuorumChecks.all()));	if (Boolean.TRUE.equals(propagate)) {	if (sensors.isEmpty()) {	enrichers().add(Enrichers.builder().propagatingAllButUsualAnd().from(child).build());	} else {	enrichers().add(Enrichers.builder().propagating(sensors).from(child).build());	}	}	}	if (Boolean.TRUE.equals(create)) {	
starting child 

if (Boolean.TRUE.equals(propagate)) {	if (sensors.isEmpty()) {	enrichers().add(Enrichers.builder().propagatingAllButUsualAnd().from(child).build());	} else {	enrichers().add(Enrichers.builder().propagating(sensors).from(child).build());	}	}	}	if (Boolean.TRUE.equals(create)) {	if (Entities.invokeEffectorWithArgs(this, child, Startable.START, locations).blockUntilEnded(timeout)) {	
successfully started by 

enrichers().add(Enrichers.builder().propagating(sensors).from(child).build());	}	}	}	if (Boolean.TRUE.equals(create)) {	if (Entities.invokeEffectorWithArgs(this, child, Startable.START, locations).blockUntilEnded(timeout)) {	} else {	throw new IllegalStateException(String.format("Timed out while %s was starting %s", this, child));	}	} else {	
no child created setting service up to true 

========================= brooklyn sample_1570 =========================

public void start(Collection<? extends Location> locations) {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STARTING);	Entity target = resolveTarget();	if (target == null) {	
tasks not successfully run relativeentitytestcaseimpl target unset 

return;	}	config().set(BaseTest.TARGET_ENTITY, target);	boolean success = true;	try {	for (Entity child : getChildren()) {	if (child instanceof Startable) {	Startable test = Startable.class.cast(child);	test.start(locations);	if (Lifecycle.RUNNING.equals(child.sensors().get(Attributes.SERVICE_STATE_ACTUAL))) {	
task of successfully run targeting 

}	config().set(BaseTest.TARGET_ENTITY, target);	boolean success = true;	try {	for (Entity child : getChildren()) {	if (child instanceof Startable) {	Startable test = Startable.class.cast(child);	test.start(locations);	if (Lifecycle.RUNNING.equals(child.sensors().get(Attributes.SERVICE_STATE_ACTUAL))) {	} else {	
problem in child test case of targeting 

try {	for (Entity child : getChildren()) {	if (child instanceof Startable) {	Startable test = Startable.class.cast(child);	test.start(locations);	if (Lifecycle.RUNNING.equals(child.sensors().get(Attributes.SERVICE_STATE_ACTUAL))) {	} else {	success = false;	}	} else {	
ignored child of that is not startable 

success = false;	}	} else {	}	if (!success) {	break;	}	}	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	
problem in child test case of targeting 

}	if (!success) {	break;	}	}	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	success = false;	}	if (success) {	
tasks successfully run update state of to running 

break;	}	}	} catch (Throwable t) {	Exceptions.propagateIfFatal(t);	success = false;	}	if (success) {	setServiceState(true, Lifecycle.RUNNING);	} else {	
tasks not successfully run update state of to on fire 

public void stop() {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STOPPING);	try {	for (Entity child : this.getChildren()) {	if (child instanceof Startable) ((Startable) child).stop();	}	
tasks successfully run update state of to stopped 

public void stop() {	sensors().set(Attributes.SERVICE_STATE_ACTUAL, Lifecycle.STOPPING);	try {	for (Entity child : this.getChildren()) {	if (child instanceof Startable) ((Startable) child).stop();	}	setServiceState(false, Lifecycle.STOPPED);	} catch (Throwable t) {	
tasks not successfully run update state of to on fire 

========================= brooklyn sample_2425 =========================

connectServiceUpIsRunning();	int port = sensors().get(MongoDBServer.PORT);	HostAndPort accessibleAddress = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, port);	sensors().set(MONGO_SERVER_ENDPOINT, String.format("%s:%d", accessibleAddress.getHostText(), accessibleAddress.getPort()));	int httpConsolePort = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, sensors().get(HTTP_PORT)).getPort();	sensors().set(HTTP_INTERFACE_URL, String.format("http: accessibleAddress.getHostText(), httpConsolePort));	if (clientAccessEnabled()) {	try {	client = MongoDBClientSupport.forServer(this);	} catch (UnknownHostException e) {	
unable to create client connection to not connecting sensors 

BasicBSONObject serverStatus = client.getReplicaSetStatus();	int state = serverStatus.getInt("myState", -1);	return ReplicaSetMemberStatus.fromCode(state);	}	}) .onException(Functions.constant(ReplicaSetMemberStatus.UNKNOWN)) .suppressDuplicates(true)) .build();	} else {	sensors().set(IS_PRIMARY_FOR_REPLICA_SET, false);	sensors().set(IS_SECONDARY_FOR_REPLICA_SET, false);	}	} else {	
not monitoring to retrieve state via client api 

public boolean addMemberToReplicaSet(MongoDBServer secondary, Integer id) {	if (!sensors().get(IS_PRIMARY_FOR_REPLICA_SET)) {	
attempted to add to replica set at server that is not primary 

public boolean removeMemberFromReplicaSet(MongoDBServer server) {	if (!sensors().get(IS_PRIMARY_FOR_REPLICA_SET)) {	
attempted to remove from replica set at server that is not primary 

========================= brooklyn sample_381 =========================

