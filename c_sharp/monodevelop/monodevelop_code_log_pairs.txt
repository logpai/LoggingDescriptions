static compilererror getresourceid (filepath outputfile, executionenvironment env, projectfile finfo, ref string fname, string resgen, out string resourceid, progressmonitor monitor) {	resourceid = finfo.resourceid;	if (resourceid == null) {	
error unable to build resourceid for 

static compilererror getresourceid (filepath outputfile, executionenvironment env, projectfile finfo, ref string fname, string resgen, out string resourceid, progressmonitor monitor) {	resourceid = finfo.resourceid;	if (resourceid == null) {	
error unable to build resourceid for 

if (!isresgenrequired (fname, outputfile)) {	fname = file.exists (outputfile) ? (string)outputfile : path.changeextension (fname, ".resources");	return null;	}	if (resgen == null) {	string msg = gettextcatalog.getstring ("unable to find 'resgen' tool.");	monitor.reporterror (msg, null);	return new compilererror (fname, 0, 0, string.empty, msg);	}	using (stringwriter sw = new stringwriter ()) {	
compiling resources compile 

if (!isresgenrequired (fname, outputfile)) {	fname = file.exists (outputfile) ? (string)outputfile : path.changeextension (fname, ".resources");	return null;	}	if (resgen == null) {	string msg = gettextcatalog.getstring ("unable to find 'resgen' tool.");	monitor.reporterror (msg, null);	return new compilererror (fname, 0, 0, string.empty, msg);	}	using (stringwriter sw = new stringwriter ()) {	
compiling resource with 

return new compilererror (fname, 0, 0, string.empty, msg);	}	using (stringwriter sw = new stringwriter ()) {	processwrapper pw = null;	try {	processstartinfo info = runtime.processservice.createprocessstartinfo ( resgen, string.format ("/compile \"{0}\"", fname), path.getdirectoryname (fname), false);	env.mergeto (info);	if (platformid.unix == environment.osversion.platform) info.environmentvariables ["mono_iomap"] = "drive";	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	
error while trying to invoke to compile resource 

return new compilererror (fname, 0, 0, string.empty, msg);	}	using (stringwriter sw = new stringwriter ()) {	processwrapper pw = null;	try {	processstartinfo info = runtime.processservice.createprocessstartinfo ( resgen, string.format ("/compile \"{0}\"", fname), path.getdirectoryname (fname), false);	env.mergeto (info);	if (platformid.unix == environment.osversion.platform) info.environmentvariables ["mono_iomap"] = "drive";	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	
error while trying to invoke to compile resource 

if (platformid.unix == environment.osversion.platform) info.environmentvariables ["mono_iomap"] = "drive";	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	return new compilererror (fname, 0, 0, string.empty, ex.message);	}	pw.waitforoutput ();	if (pw.exitcode == 0) {	fname = path.changeextension (fname, ".resources");	} else {	string output = sw.tostring ();	
unable to compile to resources reason 

if (platformid.unix == environment.osversion.platform) info.environmentvariables ["mono_iomap"] = "drive";	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	return new compilererror (fname, 0, 0, string.empty, ex.message);	}	pw.waitforoutput ();	if (pw.exitcode == 0) {	fname = path.changeextension (fname, ".resources");	} else {	string output = sw.tostring ();	
unable to compile to resources reason 

static compilererror generatesatelliteassemblies (dictionary<string, string> resourcesbyculture, string outputdir, string al, string defaultns, progressmonitor monitor) {	foreach (keyvaluepair<string, string> pair in resourcesbyculture) {	string culture = pair.key;	string satdir = path.combine (outputdir, culture);	string outputfile = defaultns + ".resources.dll";	directory.createdirectory (satdir);	using (stringwriter sw = new stringwriter ()) {	string args = string.format ("/t:lib {0} \"/out:{1}\" /culture:{2}", pair.value, outputfile, culture);	
generating satellite assembly for culture 

static compilererror generatesatelliteassemblies (dictionary<string, string> resourcesbyculture, string outputdir, string al, string defaultns, progressmonitor monitor) {	foreach (keyvaluepair<string, string> pair in resourcesbyculture) {	string culture = pair.key;	string satdir = path.combine (outputdir, culture);	string outputfile = defaultns + ".resources.dll";	directory.createdirectory (satdir);	using (stringwriter sw = new stringwriter ()) {	string args = string.format ("/t:lib {0} \"/out:{1}\" /culture:{2}", pair.value, outputfile, culture);	
generating satellite assembly for culture with 

string satdir = path.combine (outputdir, culture);	string outputfile = defaultns + ".resources.dll";	directory.createdirectory (satdir);	using (stringwriter sw = new stringwriter ()) {	string args = string.format ("/t:lib {0} \"/out:{1}\" /culture:{2}", pair.value, outputfile, culture);	processwrapper pw = null;	try {	processstartinfo info = runtime.processservice.createprocessstartinfo ( al, args, satdir, false);	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	
error while trying to invoke to generate satellite assembly for culture 

string satdir = path.combine (outputdir, culture);	string outputfile = defaultns + ".resources.dll";	directory.createdirectory (satdir);	using (stringwriter sw = new stringwriter ()) {	string args = string.format ("/t:lib {0} \"/out:{1}\" /culture:{2}", pair.value, outputfile, culture);	processwrapper pw = null;	try {	processstartinfo info = runtime.processservice.createprocessstartinfo ( al, args, satdir, false);	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	
error while trying to invoke to generate satellite assembly for culture 

processwrapper pw = null;	try {	processstartinfo info = runtime.processservice.createprocessstartinfo ( al, args, satdir, false);	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	return new compilererror ("", 0, 0, string.empty, ex.message);	}	pw.waitforoutput ();	if (pw.exitcode != 0) {	string output = sw.tostring ();	
unable to generate satellite assemblies for culture with reason 

processwrapper pw = null;	try {	processstartinfo info = runtime.processservice.createprocessstartinfo ( al, args, satdir, false);	pw = runtime.processservice.startprocess (info, sw, sw, null);	} catch (system.componentmodel.win32exception ex) {	return new compilererror ("", 0, 0, string.empty, ex.message);	}	pw.waitforoutput ();	if (pw.exitcode != 0) {	string output = sw.tostring ();	
unable to generate satellite assemblies for culture with reason 

========================= monodevelop sample_2300 =========================

static longstaticconstructorwithfields () {	foo = 5;	bar = "mystring";	baz = new object ();	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

static longstaticconstructorwithoutfields () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public longconstructorwithreadonlyfields () {	foo = 5;	bar = "mystring";	baz = new object ();	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public longconstructorwithfields () {	foo = 5;	bar = "mystring";	baz = new object ();	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public longconstructorwithoutfields () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

protected virtual void build () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public void initializecomponent () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

protected virtual void build () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public void initializecomponent () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

protected virtual void build () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public void initializecomponent () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public void initializecomponent () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

protected virtual void build () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public void longmethod () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public void build () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

public void initializecomponent () {	
i m writting a test and i will fill a screen with some useless code 

foreach (object value in list) {	console.write (value);	console.write (environment.newline);	}	int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	
other useless string 

int x = 0;	for (int i = 0; i < 100; i++) x++;	console.writeline (x);	string useless = "useless string";	if (useless.equals ("other useless")) {	useless = string.empty;	}	useless = string.concat (useless," 1");	for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	
i have detected an useless char 

for (int j = 0; j < useless.length; j++) {	if (useless[j] == 'u') console.writeline ("i have detected an u char");	}	try {	foreach (string environmentvariable in environment.getenvironmentvariables ().keys) console.writeline (environmentvariable);	}	catch (system.security.securityexception exception) {	console.writeline (exception.message);	console.writeline (exception);	}	
i will add more useless code 

========================= monodevelop sample_10624 =========================

static customtoolservice () {	addinmanager.addextensionnodehandler ("/monodevelop/ide/customtools", delegate(object sender, extensionnodeeventargs args) {	var node = (customtoolextensionnode)args.extensionnode;	switch (args.change) {	
duplicate custom tool name 

if (name.startswith ("msbuild:", stringcomparison.ordinalignorecase)) {	string target = name.substring ("msbuild:".length).trim ();	if (string.isnullorempty (target)) return null;	return new msbuildcustomtool (target);	}	customtoolextensionnode node;	if (nodes.trygetvalue (name, out node)) {	try {	return node.tool;	} catch (exception ex) {	
error loading generator 

if (!shouldrun) {	writesummaryresults (monitor, succeeded, warnings, errors);	return;	}	taskservice.errors.clearbyowner (file);	var result = new singlefilecustomtoolresult ();	monitor.begintask (gettextcatalog.getstring ("running generator '{0}' on file '{1}'...", file.generator, file.name), 1);	try {	await tool.generate (monitor, file.project, file, result);	if (!monitor.haserrors && !monitor.haswarnings) {	
file was generated successfully 

return;	}	taskservice.errors.clearbyowner (file);	var result = new singlefilecustomtoolresult ();	monitor.begintask (gettextcatalog.getstring ("running generator '{0}' on file '{1}'...", file.generator, file.name), 1);	try {	await tool.generate (monitor, file.project, file, result);	if (!monitor.haserrors && !monitor.haswarnings) {	succeeded++;	} else if (!monitor.haserrors) {	
file was generated with warnings 

taskservice.errors.clearbyowner (file);	var result = new singlefilecustomtoolresult ();	monitor.begintask (gettextcatalog.getstring ("running generator '{0}' on file '{1}'...", file.generator, file.name), 1);	try {	await tool.generate (monitor, file.project, file, result);	if (!monitor.haserrors && !monitor.haswarnings) {	succeeded++;	} else if (!monitor.haserrors) {	warnings++;	} else {	
errors in file generation 

static void writesummaryresults (progressmonitor monitor, int succeeded, int warnings, int errors) {	monitor.log.writeline ();	int total = succeeded + warnings + errors;	
file processed total generated successfully with warnings with errors files processed total generated successfully with warnings with errors 

========================= monodevelop sample_1138 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_83 =========================

public override void setframeorigin (pointf neworigin) {	
setting new origin 

========================= monodevelop sample_10976 =========================

spid = spid.substring (0, i);	int pid;	if (int.tryparse (path.getfilename (spid), out pid)) {	try {	if (process.getprocessbyid (pid) != null) continue;	} catch {	}	try {	directory.delete (dir, true);	} catch (exception ex) {	
could not delete msbuild cache folder 

========================= monodevelop sample_2211 =========================

static string constructexpression(string expr) {	return @" using system;	using system.linq;	class bar {	public void foo (string[] args) {	
expr 

========================= monodevelop sample_8468 =========================

public void printsummaryreport() {	
tests run passed errors failures inconclusive 

public void printsummaryreport() {	
not run invalid ignored skipped 

public void printsummaryreport() {	
elapsed time 

public void printerrorreport() {	reportcount = 0;	writer.writeline();	
errors and failures 

public void printnotrunreport() {	reportcount = 0;	writer.writeline();	
tests not run 

public void printfullreport() {	writer.writeline();	
all test results 

========================= monodevelop sample_5593 =========================

if (!method.hasbody) return ruleresult.doesnotapply;	if (!mask.intersect (opcodeengine.getbitmask (method))) return ruleresult.doesnotapply;	log.writeline (this);	log.writeline (this, "---------------------------------------");	log.writeline (this, method);	foreach (instruction ins in method.body.instructions) {	switch (ins.opcode.code) {	case code.call: case code.callvirt: methodreference target = ins.operand as methodreference;	string define = avoidmethodswithsideeffectsinconditionalcoderule.conditionalon (target);	if (define != null) {	
call to method at 

private string mutates (methoddefinition method, instruction end) {	string name = null;	instruction ins = avoidmethodswithsideeffectsinconditionalcoderule.fulltraceback (method, end);	if (ins != null) {	
checking args for call at starting at 

========================= monodevelop sample_10406 =========================

public void smallswitch (string s) {	switch (s) {	
empty 

public void largeswitch (string s) {	switch (s) {	
unknown 

public void largeswitch (string s) {	switch (s) {	break;	
zero 

public void largeswitch (string s) {	switch (s) {	break;	break;	
one 

public void largeswitch (string s) {	switch (s) {	break;	break;	break;	
two 

public void largeswitch (string s) {	switch (s) {	break;	break;	break;	break;	
three 

public void largeswitch (string s) {	switch (s) {	break;	break;	break;	break;	break;	
four 

public void largeswitch (string s) {	switch (s) {	break;	break;	break;	break;	break;	break;	
large value 

========================= monodevelop sample_10546 =========================

}	break;	case 't': add (types, current_rule, getstring (buffer, length));	break;	case 'm': add (methods, current_rule, getstring (buffer, length));	break;	case 'n': base.add (current_rule, namespacedefinition.getdefinition (getstring (buffer, length)));	break;	case '@': files.push (getstring (buffer, length));	break;	
bad ignore entry 

========================= monodevelop sample_10641 =========================

public static async task<bool> addpackagedependency (this dotnetproject project, ipackagedependency dependency) {	if (project == null) throw new argumentnullexception (nameof (project));	
adding package dependency to project 

public static async task<bool> addpackagedependency (this dotnetproject project, ipackagedependency dependency) {	if (project == null) throw new argumentnullexception (nameof (project));	if (dependency.status == status.added) {	
skipped the package dependency is already added to the project 

}	try {	var references = new list<packagemanagementpackagereference> ();	references.add (new packagemanagementpackagereference (dependency.packageid, dependency.packageversion));	var task = packagemanagementservices.projectoperations.installpackagesasync (project, references);	await task.configureawait (false);	return true;	} catch (invalidoperationexception) {	throw;	} catch (exception ex) {	
could not queue package for installation 

public static async task<bool> addpackagedependencies (this dotnetproject project, ilist<ipackagedependency> dependencies) {	if (project == null) throw new argumentnullexception (nameof (project));	foreach (var dependency in dependencies) {	
adding package dependency to project 

public static async task<bool> addpackagedependencies (this dotnetproject project, ilist<ipackagedependency> dependencies) {	if (project == null) throw new argumentnullexception (nameof (project));	foreach (var dependency in dependencies) {	if (dependency.status == status.added) {	
skipped the package dependency is already added to the project 

var references = new list<packagemanagementpackagereference> ();	foreach (var dependency in dependenciestoadd) {	references.add (new packagemanagementpackagereference (dependency.packageid, dependency.packageversion));	}	var task = packagemanagementservices.projectoperations.installpackagesasync (project, references);	await task.configureawait (false);	return true;	} catch (invalidoperationexception) {	throw;	} catch (exception ex) {	
could not queue packages for installation 

public static async task removepackagedependency(this dotnetproject project, ipackagedependency dependency) {	if (project == null) throw new argumentnullexception (nameof (project));	
removing package dependency from project 

public static async task removepackagedependency(this dotnetproject project, ipackagedependency dependency) {	if (project == null) throw new argumentnullexception (nameof (project));	if (dependency.status == status.notadded || !project.packageadded (dependency)) {	
skipped the package dependency is not added to the project 

if (dependency.status == status.notadded || !project.packageadded (dependency)) {	return;	}	try {	var references = new list<string> ();	references.add (dependency.packageid);	var task = packagemanagementservices.projectoperations.uninstallpackagesasync (project, references, true);	await task.configureawait (false);	} catch (invalidoperationexception) {	} catch (exception ex) {	
could not queue package for uninstallation 

public static async task removepackagedependencies (this dotnetproject project, ilist<ipackagedependency> dependencies) {	if (project == null) throw new argumentnullexception (nameof (project));	foreach (var dependency in dependencies) {	
removing package dependency from project 

public static async task removepackagedependencies (this dotnetproject project, ilist<ipackagedependency> dependencies) {	if (project == null) throw new argumentnullexception (nameof (project));	foreach (var dependency in dependencies) {	if (dependency.status == status.notadded || !project.packageadded (dependency)) {	
skipped the package dependency is not added to the project 

var dependenciestoremove = dependencies.where (x => x.status != status.notadded && project.packageadded (x)).tolist ();	try {	var references = new list<string> ();	foreach (var dependency in dependencies) {	references.add (dependency.packageid);	}	var task = packagemanagementservices.projectoperations.uninstallpackagesasync (project, references, true);	await task.configureawait (false);	} catch (invalidoperationexception) {	} catch (exception ex) {	
could not queue packages for uninstallation 

========================= monodevelop sample_4669 =========================

});	if (currentsession != null && currentsession != sessions [session]) {	stopsqueue.enqueue (action);	notifypaused ();	} else {	action ();	}	break;	}	} catch (exception ex) {	
error handling debugger target event 

========================= monodevelop sample_4778 =========================

}	}	for (int i = actions.count - 1; i > 0; i--) {	int j = rnd.next(0, i);	var tmp = actions[i];	actions[i] = actions[j];	actions[j] = tmp;	}	foreach (var action in actions) {	if (!action()) {	
seed for this file was 

========================= monodevelop sample_7983 =========================

public targetframework gettargetframework (targetframeworkmoniker id) {	targetframework fx;	if (frameworks.trygetvalue (id, out fx)) return fx;	
unknown targetframework is being requested from systemassemblyservice ensuring runtimes initialized and trying again 

public targetframework gettargetframework (targetframeworkmoniker id) {	targetframework fx;	if (frameworks.trygetvalue (id, out fx)) return fx;	foreach (var r in runtimes) r.ensureinitialized ();	if (frameworks.trygetvalue (id, out fx)) return fx;	
unknown targetframework is being requested from systemassemblyservice returning empty targetframework 

static void buildframeworkrelations (targetframework fx, dictionary<targetframeworkmoniker, targetframework> frameworks) {	if (fx.relationsbuilt) return;	var includesframework = fx.getincludesframework ();	if (includesframework != null) {	fx.includedframeworks.add (includesframework);	targetframework compatfx;	if (frameworks.trygetvalue (includesframework, out compatfx)) {	buildframeworkrelations (compatfx, frameworks);	fx.includedframeworks.addrange (compatfx.includedframeworks);	} else {	
targetframework imports unknown framework 

assembly = assemblydefinition.readassembly (file);	var att = assembly.customattributes.firstordefault (a => a.attributetype.fullname == "system.runtime.versioning.targetframeworkattribute" );	if (att != null) {	if (att.constructorarguments.count == 1) {	var v = att.constructorarguments[0].value as string;	targetframeworkmoniker m;	if (v != null && targetframeworkmoniker.tryparse (v, out m)) {	return m;	}	}	
invalid targetframeworkattribute in assembly 

compatibleframework = tf;	if (tr.isinstalled (tf)) return tf.id;	}	}	if (compatibleframework != null) return compatibleframework.id;	break;	}	}	}	} catch (exception ex) {	
error determining target framework for assembly 

if (compatibleframework != null) return compatibleframework.id;	break;	}	}	}	} catch (exception ex) {	return targetframeworkmoniker.unknown;	} finally {	assembly?.dispose ();	}	
failed to determine target framework for assembly 

========================= monodevelop sample_2287 =========================

case "op_increment": sb.append ("operator ++"); break;	case "op_bitwiseand": sb.append ("operator &"); break;	case "op_bitwiseor": sb.append ("operator |"); break;	case "op_exclusiveor": sb.append ("operator ^"); break;	case "op_logicalnot": sb.append ("operator !"); break;	case "op_onescomplement": sb.append ("operator ~"); break;	case "op_true": sb.append ("operator true"); break;	case "op_false": sb.append ("operator false"); break;	case "op_leftshift": sb.append ("operator <<"); break;	case "op_rightshift": sb.append ("operator >>"); break;	
unhandled operator named 

========================= monodevelop sample_9862 =========================

public override void startblock (ulong startcounter, datetime starttime, ulong threadid) {	
startblock startcounter starttime threadid 

public override void endblock (ulong endcounter, datetime endtime, ulong threadid) {	
startblock endcounter endtime threadid 

public override void moduleloaded (ulong threadid, uint id, ulong startcounter, ulong endcounter, string name, bool success) {	
moduleloaded 

public override void moduleunloaded (ulong threadid, uint id, ulong startcounter, ulong endcounter, string name) {	
moduleunloaded 

public override void assemblyloaded (ulong threadid, uint id, ulong startcounter, ulong endcounter, string name, bool success) {	
assemblyloaded 

public override void assemblyunloaded (ulong threadid, uint id, ulong startcounter, ulong endcounter, string name) {	
assemblyunloaded 

public override void applicationdomainloaded (ulong threadid, uint id, ulong startcounter, ulong endcounter, string name, bool success) {	
applicationdomainloaded 

public override void applicationdomainunloaded (ulong threadid,uint id,  ulong startcounter, ulong endcounter, string name) {	
applicationdomainunloaded 

public override void setcurrentthread (ulong threadid) {	
setcurrentthread 

public override void classstartload (lc c, ulong counter) {	
classstartload 

public override void classendload (lc c, ulong counter, bool success) {	
classendload 

public override void classstartunload (lc c, ulong counter) {	
classstartunload 

public override void classendunload (lc c, ulong counter) {	
classendunload 

public override void exception (lc c, ulong counter) {	
exception 

public override void methodenter (lm m, ulong counter) {	
methodenter 

public override void methodexit (lm m, ulong counter) {	
methodexit 

public override void methodjitstart (lm m, ulong counter) {	
methodjitstart 

public override void methodjitend (lm m, ulong counter, bool success) {	
methodjitend 

public override void methodfreed (lm m, ulong counter) {	
methodfreed 

public override void adjuststack (uint lastvalidframe, uint topsectionsize, stacksectionelement<lc,lm>[] topsection) {	
adjuststack 

public override void methodstatisticalhit (lm m) {	
methodstatisticalhit 

public override void unknownmethodstatisticalhit () {	
unknownmethodstatisticalhit 

public override void unmanagedfunctionstatisticalhit (ufr f) {	
unmanagedfunctionstatisticalhit 

public override void unmanagedfunctionstatisticalhit (ufi f) {	
unmanagedfunctionstatisticalhit 

public override void unknownunmanagedfunctionstatisticalhit (mr region, uint offset) {	
unknownunmanagedfunctionstatisticalhit 

public override void unknownunmanagedfunctionstatisticalhit (ulong address) {	
unknownunmanagedfunctionstatisticalhit 

public override void statisticalcallchainstart (uint chaindepth) {	
statisticalcallchainstart 

public override void threadstart (ulong threadid, ulong counter) {	
threadstart 

public override void threadend (ulong threadid, ulong counter) {	
threadend 

public override void garbagecollectionstart (uint collection, uint generation, ulong counter) {	
garbagecollectionstart 

public override void garbagecollectionend (uint collection, uint generation, ulong counter) {	
garbagecollectionend 

public override void garbagecollectionmarkstart (uint collection, uint generation, ulong counter) {	
garbagecollectionmarkstart 

public override void garbagecollectionmarkend (uint collection, uint generation, ulong counter) {	
garbagecollectionmarkend 

public override void garbagecollectionsweepstart (uint collection, uint generation, ulong counter) {	
garbagecollectionsweepstart 

public override void garbagecollectionsweepend (uint collection, uint generation, ulong counter) {	
garbagecollectionsweepend 

public override void garbagecollectionresize (uint collection, ulong newsize) {	
garbagecollectionresize 

public override void garbagecollectionstopworldstart (uint collection, uint generation, ulong counter) {	
garbagecollectionstopworldstart 

public override void garbagecollectionstopworldend (uint collection, uint generation, ulong counter) {	
garbagecollectionstopworldend 

public override void garbagecollectionstartworldstart (uint collection, uint generation, ulong counter) {	
garbagecollectionstartworldstart 

public override void garbagecollectionstartworldend (uint collection, uint generation, ulong counter) {	
garbagecollectionstartworldend 

public override void heapreportstart (hs snapshot) {	
heapreportstart 

public override void heapobjectunreachable (lc c, uint size) {	
heapobjectunreachable 

public override void heapobjectreachable (ho o) {	
heapobjectreachable 

public override void heapreportend (hs snapshot) {	
heapreportend 

public override void allocationsummarystart (uint collection, ulong startcounter, datetime starttime) {	
allocationsummarystart 

public override void classallocationsummary (lc c, uint reachableinstances, uint reachablebytes, uint unreachableinstances, uint unreachablebytes) {	
classallocationsummary 

public override void allocationsummaryend (uint collection, ulong endcounter, datetime endtime) {	
allocationsummaryend 

========================= monodevelop sample_9922 =========================

private static opcodebitmask comparisonsbitmask () {	opcodebitmask mask = new opcodebitmask ();	mask.set (code.cgt);	mask.set (code.ceq);	mask.set (code.clt);	mask.set (code.ble);	mask.set (code.ble_s);	mask.set (code.bge);	mask.set (code.bge_s);	
comparisonsbitmask 

private static opcodebitmask conditionsbitmask () {	opcodebitmask mask = new opcodebitmask ();	mask.set (code.brtrue);	mask.set (code.brtrue_s);	mask.set (code.brfalse);	mask.set (code.brfalse_s);	
conditionsbitmask 

========================= monodevelop sample_10523 =========================

public void print (string html) {	#if !macos if (html == null) {	
empty print 

========================= monodevelop sample_9833 =========================

stringbuilder psb;	if (properties.trygetvalue (name, out psb)) {	rsb.appendformat ("## configuration{0}{0}", environment.newline);	rsb.appendformat ("some elements of this rule can be customized to better fit your needs.{0}{0}", environment.newline);	rsb.append (psb);	rsb.appendline ();	}	writer.writeline (rsb);	if (version == "git") {	writer.writeline ();	
source code you can browse the latest source code https 

rsb.appendline ();	}	writer.writeline (rsb);	if (version == "git") {	writer.writeline ();	}	}	var ruleslist = from rule in rulesindex orderby rule select rule;	string assembly_index = string.format ("{0}{1}{2}{1}{3}({2}).md", outputdir, path.directoryseparatorchar, version, assembly);	using (textwriter writer = file.createtext (assembly_index)) {	
rules 

}	writer.writeline (rsb);	if (version == "git") {	writer.writeline ();	}	}	var ruleslist = from rule in rulesindex orderby rule select rule;	string assembly_index = string.format ("{0}{1}{2}{1}{3}({2}).md", outputdir, path.directoryseparatorchar, version, assembly);	using (textwriter writer = file.createtext (assembly_index)) {	writer.writeline ();	
the following rules are available in version gendarme rules of 

var ruleslist = from rule in rulesindex orderby rule select rule;	string assembly_index = string.format ("{0}{1}{2}{1}{3}({2}).md", outputdir, path.directoryseparatorchar, version, assembly);	using (textwriter writer = file.createtext (assembly_index)) {	writer.writeline ();	writer.writeline ();	foreach (var rule in ruleslist) {	writer.writeline ("* [[{0}|{1}.{0}({2})]]  ", rule, assembly, version);	}	if (version == "git") {	writer.writeline ();	
source code you can browse the latest source code https 

static void main (string [] args) {	string [] files;	if (args.length < 1) {	
usage filepattern out outputdir version version 

files = directory.getfiles (dir, pattern);	foreach (string file in files) {	filenames.add (file);	}	break;	}	}	string subdir = path.combine (outputdir, version);	if (!directory.exists (subdir)) directory.createdirectory (subdir);	foreach (string file in filenames) {	
processing 

static void createversionindex () {	string rules_index = string.format ("{0}{1}{2}{1}gendarme.rules({2}).md", outputdir, path.directoryseparatorchar, version);	using (textwriter writer = file.createtext (rules_index)) {	
gendarme rules documentation index 

static void createversionindex () {	string rules_index = string.format ("{0}{1}{2}{1}gendarme.rules({2}).md", outputdir, path.directoryseparatorchar, version);	using (textwriter writer = file.createtext (rules_index)) {	writer.writeline ();	var assemblies = from assembly in assembliesindex orderby assembly select assembly;	
the following assemblies are available in version 

string rules_index = string.format ("{0}{1}{2}{1}gendarme.rules({2}).md", outputdir, path.directoryseparatorchar, version);	using (textwriter writer = file.createtext (rules_index)) {	writer.writeline ();	var assemblies = from assembly in assembliesindex orderby assembly select assembly;	writer.writeline ();	foreach (var assembly in assemblies) {	writer.writeline ("* [[{0}|{0}({1})]]  ", assembly, version);	}	if (version == "git") {	writer.writeline ();	
source code 

static void createfooterfile () {	string footer = string.format ("{0}{1}{2}{1}_footer.md", outputdir, path.directoryseparatorchar, version);	using (textwriter writer = file.createtext (footer)) {	
feedback note that this page was autogenerated based on the xmldoc comments inside the rules source code and cannot be edited from this wiki please report any documentation errors typos or suggestions to the gendarme google group http 

========================= monodevelop sample_9973 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_44 =========================

static void initializehelptree () {	lock (helptreelock) {	if (helptreeinitialized) return;	if (platform.iswindows && !file.exists ("monodoc.xml")) {	
monodoc documentation tree could not be loaded because monodoc xml was not found 

try {	helptree = roottree.loadtree ();	foreach (var node in addinmanager.getextensionnodes ("/monodevelop/projectmodel/monodocsources")) sources.add (((monodocsourcenode)node).directory);	if (platform.iswindows) {	var commonappdata = environment.getfolderpath (environment.specialfolder.commonapplicationdata);	sources.add (path.combine (commonappdata, "monodoc"));	}	foreach (var s in sources.tolist ().where (d => !directory.exists (d))) sources.remove (s);	foreach (var s in sources) helptree.addsource (s);	} catch (exception ex) {	
monodoc documentation tree could not be loaded 

========================= monodevelop sample_2007 =========================

}	}	foreach (regexinfo ri in regexes) {	int linenumber = 1;	int oldindex  = 0;	foreach (match match in ri.regex.matches (text)) {	bool ignore = false;	foreach (match em in excludematches) {	if (match.index >= em.index && match.index < em.index + em.length) {	ignore = true;	
excluded gettext string in file 

========================= monodevelop sample_2598 =========================

static librarycache load () {	string index_path = path.combine (dir, "index.xml");	if (file.exists (index_path)) {	try {	librarycache result;	xmlserializer serializer = new xmlserializer (typeof (librarycache));	using (xmltextreader rdr = new xmltextreader (index_path)) result = (librarycache) serializer.deserialize (rdr);	return result;	} catch (exception e) {	
cache index serialization failed 

========================= monodevelop sample_3565 =========================

public static void foo () {	
foo 

========================= monodevelop sample_153 =========================

public versioninfo getversioninfo (repository repo, filepath localpath, bool getremotestatus) {	var isdir = directory.exists (localpath);	try {	if (isdir) return getdirstatus (repo, localpath, getremotestatus);	return getfilestatus (repo, localpath, getremotestatus);	} catch (exception e) {	
failed to query subversion status 

public versioninfo[] getdirectoryversioninfo (repository repo, filepath sourcepath, bool getremotestatus, bool recursive) {	try {	return status (repo, sourcepath, svnrevision.head, recursive, true, getremotestatus).toarray ();	} catch (exception e) {	
failed to get subversion directory status 

========================= monodevelop sample_4214 =========================

public static void main (string [] args) {	
hello world 

========================= monodevelop sample_102 =========================

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	
project export tool 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	
usage mdtool project export source project file d dest path f format name 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	
options 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	
d dest path directory where the project will be exported 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	
f format to which export the project or solution 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	
l show a list of all allowed target formats 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	
p project name when exporting a solution name of a project to be 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	
included in the export it can be specified multiple 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	
times 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	console.writeline ("");	
the format name is optional a list of allowed file formats will be 

public async task<int> run (string[] arguments) {	if (arguments.length == 0 || arguments [0] == "--help") {	console.writeline ("");	console.writeline ("");	console.writeline ("");	
shown if none is provided 

string formatname = null;	bool formatlist = false;	list<string> projects = new list<string> ();	string[] itemstoexport = null;	foreach (string s in arguments) {	if (s.startswith ("-d:")) destpath = s.substring (3);	else if (s.startswith ("-f:")) formatname = s.substring (3);	else if (s.startswith ("-p:")) projects.add (s.substring (3));	else if (s == "-l") formatlist = true;	else if (projectfile != null) {	
only one project can be converted at a time 

if (s.startswith ("-d:")) destpath = s.substring (3);	else if (s.startswith ("-f:")) formatname = s.substring (3);	else if (s.startswith ("-p:")) projects.add (s.substring (3));	else if (s == "-l") formatlist = true;	else if (projectfile != null) {	return 1;	}	else projectfile = s;	}	if (projectfile == null) {	
project or solution file name not provided 

else if (projectfile != null) {	return 1;	}	else projectfile = s;	}	if (projectfile == null) {	return 1;	}	projectfile = fileservice.getfullpath (projectfile);	if (!file.exists (projectfile)) {	
file not found 

return 1;	}	consoleprogressmonitor monitor = new consoleprogressmonitor ();	monitor.ignorelogmessages = true;	object item;	if (services.projectservice.isworkspaceitemfile (projectfile)) {	item = await services.projectservice.readworkspaceitem (monitor, projectfile);	if (projects.count > 0) {	solution sol = item as solution;	if (sol == null) {	
the p option can only be used when exporting a solution 

if (services.projectservice.isworkspaceitemfile (projectfile)) {	item = await services.projectservice.readworkspaceitem (monitor, projectfile);	if (projects.count > 0) {	solution sol = item as solution;	if (sol == null) {	return 1;	}	for (int n=0; n<projects.count; n++) {	string pname = projects [n];	if (pname.length == 0) {	
project name not specified in p option 

if (sol == null) {	return 1;	}	for (int n=0; n<projects.count; n++) {	string pname = projects [n];	if (pname.length == 0) {	return 1;	}	project p = sol.findprojectbyname (pname);	if (p == null) {	
project not found in solution 

if (p == null) {	return 1;	}	projects[n] = p.itemid;	}	itemstoexport = projects.toarray ();	}	}	else {	if (projects.count > 0) {	
the p option can t be used when exporting a single project 

}	}	else {	if (projects.count > 0) {	return 1;	}	item = await services.projectservice.readsolutionitem (monitor, projectfile);	}	var formats = msbuildfileformat.getsupportedformats ().toarray ();	if (formats.length == 0) {	
can t convert file to any format 

}	item = await services.projectservice.readsolutionitem (monitor, projectfile);	}	var formats = msbuildfileformat.getsupportedformats ().toarray ();	if (formats.length == 0) {	return 1;	}	msbuildfileformat format = null;	if (formatname == null || formatlist) {	console.writeline ();	
target formats 

if (op > 0 && op <= formats.length) break;	}	} while (true);	format = formats [op - 1];	}	else {	foreach (var f in formats) {	if (f.name == formatname) format = f;	}	if (format == null) {	
unknown file format 

if (f.name == formatname) format = f;	}	if (format == null) {	return 1;	}	}	if (destpath == null) destpath = path.getdirectoryname (projectfile);	destpath = fileservice.getfullpath (destpath);	string ofile = await services.projectservice.export (monitor, projectfile, itemstoexport, destpath, format);	if (ofile != null) {	
saved file 

return 1;	}	}	if (destpath == null) destpath = path.getdirectoryname (projectfile);	destpath = fileservice.getfullpath (destpath);	string ofile = await services.projectservice.export (monitor, projectfile, itemstoexport, destpath, format);	if (ofile != null) {	return 0;	}	else {	
project export failed 

========================= monodevelop sample_1910 =========================

sb.append (".");	}	sb.append (customevent.identifier.tostring ());	} else if (e is enumdeclarationsyntax) {	var enumdecl = (enumdeclarationsyntax)e;	sb.append (enumdecl.identifier.tostring ());	} else if (e is enummemberdeclarationsyntax) {	var enummemberdecl = (enummemberdeclarationsyntax)e;	sb.append (enummemberdecl.identifier.tostring ());	} /*else if (e is memberdeclarationsyntax) {	
can t display 

========================= monodevelop sample_3904 =========================

public static void initialize () {	if (platformservice != null) return;	object[] platforms = addinmanager.getextensionobjects ("/monodevelop/core/platformservice");	if (platforms.length > 0) platformservice = (platformservice) platforms [0];	else {	platformservice = new defaultplatformservice ();	
a platform service implementation has not been found 

========================= monodevelop sample_1642 =========================

public void void () {	
foo 

========================= monodevelop sample_10199 =========================

public void write () {	
hey 

========================= monodevelop sample_10088 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_167 =========================

public void onassembly (object sender, runnereventargs e) {	foreach (moduledefinition module in e.currentassembly.modules) {	if (lookforthreadmodelattribute (module.getalltypes ())) {	
assembly defines threadmodelattribute 

public void onassembly (object sender, runnereventargs e) {	foreach (moduledefinition module in e.currentassembly.modules) {	if (lookforthreadmodelattribute (module.getalltypes ())) {	active = true;	return;	} else if (lookforthreadmodelattribute (module.gettypereferences ())) {	
assembly references threadmodelattribute 

public override void teardown () {	foreach (methoddefinition caller in anonymous_entry_points) {	foreach (instruction ins in caller.body.instructions) {	switch (ins.opcode.code) {	case code.call: case code.callvirt: methoddefinition target = ((methodreference) ins.operand).resolve ();	if (target != null) {	threadmodel targetmodel = target.threadingmodel ();	if (targetmodel == threadmodel.mainthread) {	string mesg = string.format (cultureinfo.invariantculture, "an anonymous thread entry point cannot call mainthread {0}.", target.name);	++defectcount;	
defect 

}	} else if (!threadrocks.threadednamespace (nspace)) {	methoddefinition target = ((methodreference) ins.previous.operand).resolve ();	if (target != null) {	threadmodel callermodel = type.threadingmodel ();	if (!target.isgeneratedcode () || target.isproperty ()) {	threadmodel targetmodel = target.threadingmodel ();	if (!isvalidcall (callermodel, targetmodel)) {	string mesg = string.format (cultureinfo.invariantculture, "{0} delegate cannot be bound to {1} {2} method.", callermodel, targetmodel, target.name);	++defectcount;	
defect 

}	}	} else if (setsynchronizingobject.matches (call)) {	if (ins.previous.opcode.code == code.ldarg_0) {	thissynchronized.add (call_type);	}	}	break;	}	if (candidate != null) {	
is a thread entry point 

if (target != null) {	threadmodel targetmodel = target.threadingmodel ();	if (!isvalidcall (method_model.value, targetmodel)) {	string mesg = string.format (cultureinfo.invariantculture, "{0} {1} cannot be bound to {2} {3} method.", method_model, entry.key, targetmodel, target.name);	reportdefect (method, severity.high, confidence.high, mesg);	}	}	}	} else {	foreach (methodreference mr in entry.value) {	
is a thread entry point 

private void checkforlegalcall (methoddefinition caller, instruction ins) {	methoddefinition target = ((methodreference) ins.operand).resolve ();	if (target != null) {	threadmodel callermodel = caller.threadingmodel ();	threadmodel targetmodel = target.threadingmodel ();	if (!isvalidcall (callermodel, targetmodel)) {	string mesg = string.format (cultureinfo.invariantculture, "{0} {1} cannot call {2} {3}.", callermodel, caller.name, targetmodel, target.name);	++defectcount;	
defect 

private void reportdefect (imetadatatokenprovider metadata, severity severity, confidence confidence, string mesg) {	++defectcount;	
defect 

========================= monodevelop sample_10259 =========================

protected override bool onbuild (progressmonitor monitor, deploycontext ctx) {	string consmsg;	operationconsole cons;	if (externalconsole) {	cons = externalconsolefactory.instance.createconsole (closeconsolewhendone, monitor.cancellationtoken);	consmsg = gettextcatalog.getstring ("(in external terminal)");	} else {	cons = new monitorconsole (monitor);	consmsg = "";	}	
executing 

========================= monodevelop sample_4331 =========================

public async task<int> run (string[] arguments) {	
monodevelop build tool 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	
build options build file 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	
p project project name of the project to build 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	
t target target name of the target build or clean 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	
c configuration configuration name of the solution configuration to build 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	
r runtime prefix prefix of the mono runtime to build against 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	console.writeline ();	
supported targets 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	console.writeline ();	
build the project the default target 

public async task<int> run (string[] arguments) {	foreach (string s in arguments) readargument (s);	if (help) {	console.writeline ();	
clean the project 

string itemfile = null;	if (file == null) {	var files = directory.enumeratefiles (".");	foreach (string f in files) {	if (services.projectservice.isworkspaceitemfile (f)) {	solfile = f;	break;	} else if (itemfile == null && services.projectservice.issolutionitemfile (f)) itemfile = f;	}	if (solfile == null && itemfile == null) {	
project file not found 

break;	} else if (itemfile == null && services.projectservice.issolutionitemfile (f)) itemfile = f;	}	if (solfile == null && itemfile == null) {	return 1;	}	} else {	if (services.projectservice.isworkspaceitemfile (file)) solfile = file;	else if (services.projectservice.issolutionitemfile (file)) itemfile = file;	else {	
file is not a project or solution 

targetruntime targetruntime = null;	targetruntime defaultruntime = runtime.systemassemblyservice.defaultruntime;	if (runtime != null) {	targetruntime = monotargetruntimefactory.registerruntime(new monoruntimeinfo(runtime));	if (targetruntime != null) runtime.systemassemblyservice.defaultruntime = targetruntime;	}	ibuildtarget item;	if (solfile != null) item = await services.projectservice.readworkspaceitem (monitor, solfile) as ibuildtarget;	else item = await services.projectservice.readsolutionitem (monitor, itemfile);	if (item == null) {	
the file can t be built 

return 1;	}	using (var readitem = (workspaceobject)item) {	if (project != null) {	solution solution = item as solution;	item = null;	if (solution != null) {	item = solution.findprojectbyname (project);	}	if (item == null) {	
the project could not be found in 

else if (command == projectservice.cleantarget) res = await item.clean (monitor, configuration);	} else {	configurationselector configuration = new solutionconfigurationselector (config);	if (command == projectservice.buildtarget) res = await item.build (monitor, configuration, true);	else if (command == projectservice.cleantarget) res = await item.clean (monitor, configuration);	else {	var p = item as project;	if (p != null) {	res = (await p.runtarget (monitor, command, configuration)).buildresult;	} else {	
target not supported 

========================= monodevelop sample_1975 =========================

}	if (doc.editor.gettextat (extractionresult.methoddeclarationnode.spanstart, "private ".length) == "private ") {	doc.editor.removetext (extractionresult.methoddeclarationnode.spanstart, "private ".length);	}	}	await doc.updateparsedocument ();	var info = refactoringsymbolinfo.getsymbolinfoasync (doc, extractionresult.invocationnametoken.span.start).result;	var sym = info.declaredsymbol ?? info.symbol;	if (sym != null) await new monodevelop.refactoring.rename.renamerefactoring ().rename (sym);	} catch (exception e) {	
error while extracting method 

========================= monodevelop sample_3821 =========================

animationfactory.trygetvalue (id, out animatedicon);	} else if (!string.isnullorempty (animation)) {	string id = getstockidforimagespec (addin, "animation:" + animation, iconsize);	img = geticon (id, iconsize);	animationfactory.trygetvalue (id, out animatedicon);	}	if (animatedicon != null) addtoanimatediconfactory (stockid, animatedicon);	if (imageloader != null) img.setstreamsource (imageloader);	return img;	} catch (exception ex) {	
error loading icon 

public static xwt.drawing.image geticon (string name, bool generatedefaulticon) {	name = name ?? "";	xwt.drawing.image img;	if (icons.trygetvalue (name, out img)) return img;	if (string.isnullorempty (name)) {	
empty icon requested stack trace 

icons [name] = img = getmissingicon ();	return img;	}	if (name[0] == '#') {	icons [name] = img = createcolorblock (name, gtk.iconsize.dialog).toxwtimage ();	return img;	}	ensurestockiconisloaded (name);	if (icons.trygetvalue (name, out img)) return img;	if (generatedefaulticon) {	
unknown icon 

static xwt.drawing.image getmissingicon () {	xwt.drawing.image img;	if (icons.trygetvalue ("gtk-missing-image", out img)) return img;	ensurestockiconisloaded ("gtk-missing-image");	if (icons.trygetvalue ("gtk-missing-image", out img)) return img;	if (gtk.icontheme.default.hasicon ("gtk-missing-image")) return icons ["gtk-missing-image"] = img = gtkutil.gtktoolkit.wrapimage ("gtk-missing-image");	
loading gtk missing image icon failed stack trace 

if (composedicons.trygetvalue (id, out cid)) return cid;	system.collections.icollection col = size == gtk.iconsize.invalid ? enum.getvalues (typeof(gtk.iconsize)) : new object [] { size };	var frames = new list<xwt.drawing.image> ();	foreach (gtk.iconsize sz in col) {	if (sz == gtk.iconsize.invalid) continue;	xwt.drawing.imagebuilder ib = null;	xwt.drawing.image icon = null;	for (int n = 0; n < ids.length; n++) {	var px = geticon (ids[n], sz);	if (px == null) {	
error creating composed icon at size icon is missing 

========================= monodevelop sample_1637 =========================

public stockiconsnodebuilder () {	try {	iconsicon = xwt.drawing.image.fromresource ("image-x-generic.png");	} catch (exception e) {	
error while loading pixbuf image x generic png 

========================= monodevelop sample_3623 =========================

public override bool shouldenablefor (project proj, string projectpath) {	if (proj.getprojectcapabilities ().contains ("aspnetcore")) {	if (minversion == null) return true;	var dpn = (dotnetproject)proj;	if (version.tryparse (dpn.targetframework.id.version, out var version)) return version >= minversion;	else {	
failed to parse framework version dpn targetframework id version of project 

========================= monodevelop sample_4261 =========================

private byte callbackok_nonvoid () {	try {	
try 

private void checkmethod_anonymousok2 () {	callbackdelegate a = delegate () { };	callbackdelegate b = delegate () {	try {	
try 

========================= monodevelop sample_10218 =========================

public void conditionaldebug () {	
debug 

public void conditionaltrace () {	
debug 

public void conditionalmultiple () {	
debug 

public void conditionalother () {	
debug 

public void usingtrace () {	
debug 

public void usingdebug () {	
debug 

public void usingconsole () {	
debug 

========================= monodevelop sample_10189 =========================

protected virtual void onrunactivated(object sender, system.eventargs e) {	
run 

========================= monodevelop sample_126 =========================

static actionmenuitem () {	try {	addmenuimage = gdk.pixbuf.loadfromresource ("add-menu.png");	removemenuimage = gdk.pixbuf.loadfromresource ("remove-menu.png");	} catch (exception e) {	
error while loading pixbuf 

========================= monodevelop sample_3757 =========================

protected async override task onexecute (progressmonitor monitor, executioncontext context, configurationselector configuration, solutionitemrunconfiguration runconfiguration) {	dotnetprojectconfiguration dotnetprojectconfig = getconfiguration (configuration) as dotnetprojectconfiguration;	if (dotnetprojectconfig == null) {	monitor.reporterror (gettextcatalog.getstring ("configuration '{0}' not found in project '{1}'", configuration, name), null);	return;	}	
running 

}	executioncommand executioncommand = createexecutioncommand (configuration, dotnetprojectconfig, runconfiguration as projectrunconfiguration);	if (context.executiontarget != null) executioncommand.target = context.executiontarget;	if (!context.executionhandler.canexecute (executioncommand)) {	monitor.reporterror (gettextcatalog.getstring ("can not execute \"{0}\". the selected execution mode is not supported for .net projects.", dotnetprojectconfig.compiledoutputname), null);	return;	}	try {	await projectextension.onexecutecommand (monitor, context, configuration, executioncommand);	} catch (exception ex) {	
cannot execute 

var dotnetexecutioncommand = executioncommand as dotnetexecutioncommand;	if (dotnetexecutioncommand != null) {	dotnetexecutioncommand.userassemblypaths = getuserassemblypaths (configuration);	externalconsole = dotnetexecutioncommand.externalconsole;	pauseconsole = dotnetexecutioncommand.pauseconsoleoutput;	}	var console = externalconsole ? context.externalconsolefactory.createconsole (!pauseconsole, monitor.cancellationtoken) : context.consolefactory.createconsole (operationconsolefactory.createconsoleoptions.default.withtitle (name), monitor.cancellationtoken);	using (console) {	processasyncoperation asyncop = context.executionhandler.execute (executioncommand, console);	using (var stopper = monitor.cancellationtoken.register (asyncop.cancel)) await asyncop.task;	
the application exited with code 

========================= monodevelop sample_1900 =========================

case doctype: string doctypestr = "octype";	if (c == doctypestr [context.keywordbuilder.length]) {	context.keywordbuilder.append (c);	if (context.keywordbuilder.length < doctypestr.length) return null;	return doctypestate;	} else {	context.keywordbuilder.length = 0;	}	break;	}	
incomplete tag opening encountered unexpected character 

========================= monodevelop sample_3497 =========================

public void generate (string extraattribute) {	var copy = decls;	var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	
abstract 

public void generate (string extraattribute) {	var copy = decls;	var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	
static 

public void generate (string extraattribute) {	var copy = decls;	var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	
appearance 

public void generate (string extraattribute) {	var copy = decls;	var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	
export 

public void generate (string extraattribute) {	var copy = decls;	var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	gencs.writeline ("\t\t{0} {1} ({2});", d.retval, trivialparser.asmethod (trivialparser.cleanselector (d.selector)), d.parameters);	gencs.writeline ();	}	
foreach var d in properties 

var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	gencs.writeline ("\t\t{0} {1} ({2});", d.retval, trivialparser.asmethod (trivialparser.cleanselector (d.selector)), d.parameters);	gencs.writeline ();	}	var decl = (from x in decls where x.selector == d select x).firstordefault ();	var sel = decl.selector;	if (sel.startswith ("is")) sel = char.tolower (sel [2]) + sel.substring (3);	
abstract 

var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	gencs.writeline ("\t\t{0} {1} ({2});", d.retval, trivialparser.asmethod (trivialparser.cleanselector (d.selector)), d.parameters);	gencs.writeline ();	}	var decl = (from x in decls where x.selector == d select x).firstordefault ();	var sel = decl.selector;	if (sel.startswith ("is")) sel = char.tolower (sel [2]) + sel.substring (3);	
static 

var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	gencs.writeline ("\t\t{0} {1} ({2});", d.retval, trivialparser.asmethod (trivialparser.cleanselector (d.selector)), d.parameters);	gencs.writeline ();	}	var decl = (from x in decls where x.selector == d select x).firstordefault ();	var sel = decl.selector;	if (sel.startswith ("is")) sel = char.tolower (sel [2]) + sel.substring (3);	
export 

var properties = (from d in copy let sel = d.selector where sel.startswith ("set") && sel.endswith (":") && count (sel, ':') == 1 let getter1 = char.tolower (sel [3]) + sel.substring (4).trim (':') let getter2 = "is" + sel.substring (3).trim (':') let getter = hasgetter (getter1, getter2) where getter != null let r = remove (sel) select getter).tolist ();	foreach (var d in decls){	if (ignore.contains (d.selector) || properties.contains (d.selector)) continue;	if (extraattribute != null) gencs.writeline ("\t\t[{0}]", extraattribute);	gencs.writeline ("\t\t{0} {1} ({2});", d.retval, trivialparser.asmethod (trivialparser.cleanselector (d.selector)), d.parameters);	gencs.writeline ();	}	var decl = (from x in decls where x.selector == d select x).firstordefault ();	var sel = decl.selector;	if (sel.startswith ("is")) sel = char.tolower (sel [2]) + sel.substring (3);	
get set is bind d 

========================= monodevelop sample_11222 =========================

public void start () {	validatemonodevelopbinpath ();	setupidelogfolder ();	string profilepath = util.createtmpdir ();	folderstoclean.add (profilepath);	if (profileroptions.type != stresstestoptions.profileroptions.profilertype.disabled) {	if (profileroptions.mlpdoutputpath == null) profileroptions.mlpdoutputpath = path.combine (profilepath, "profiler.mlpd");	profilerprocessor = new profilerprocessor (profileroptions);	string monopath = environment.getenvironmentvariable ("path") .split (path.pathseparator) .select (p => path.combine (p, "mono")) .firstordefault (s => file.exists (s));	testservice.startsession (monopath, profilepath, $"{profilerprocessor.getmonoarguments ()} \"{monodevelopbinpath}\"");	
profler is logging into profileroptions mlpdoutputpath 

========================= monodevelop sample_330 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_112 =========================

protected internal void log (string message, params object[] args) {	
testsuite 

========================= monodevelop sample_11140 =========================

protected void treenodepopulate (object sender, treenodeeventargs e) {	string val = e.node.value;	comparisonnode cn = db.getnodebyname (val);	if (cn == null){	
error did not find the node 

========================= monodevelop sample_10651 =========================

public void transfer([nonnull] node node, [nonnull] object infact, [nonnull] object outfact, bool warn) {	basicblock bb = (basicblock)node;	if(bb.isexit || bb.isexception) return;	nullderefframe outframe = (nullderefframe)outfact;	variabledefinitioncollection vars = method.body.variables;	if (verbose) {	trace.writeline (string.empty);	
basic block 

public void transfer([nonnull] node node, [nonnull] object infact, [nonnull] object outfact, bool warn) {	basicblock bb = (basicblock)node;	if(bb.isexit || bb.isexception) return;	nullderefframe outframe = (nullderefframe)outfact;	variabledefinitioncollection vars = method.body.variables;	if (verbose) {	trace.writeline (string.empty);	
input frame 

else outframe.pushstack(nullity.unknown);	break;	}	case code.ldsflda: outframe.pushstack (nullity.nonnull);	break;	case code.stfld: {	nullity n = outframe.popstack ();	check (insn, warn, outframe.popstack(), "field");	fieldreference field = (fieldreference)insn.operand;	if (warn && nnacollector.hasnonnullattribute (field)) {	
null deref at 

if (warn && nnacollector.hasnonnullattribute (field)) {	if (n == nullity.unknown) runner.report (method, insn, severity.high, confidence.low, "storing possibly null value in field declared non-null");	else if (n == nullity.null) runner.report (method, insn, severity.high, confidence.low, "storing null value in field declared non-null");	}	break;	}	case code.stsfld: {	nullity n = outframe.popstack ();	fieldreference field = (fieldreference)insn.operand;	if (warn && nnacollector.hasnonnullattribute (field)) {	
null deref at 

break;	case code.pop: outframe.popstack ();	break;	case code.calli: processcall (insn, warn, true, outframe);	break;	case code.call: case code.callvirt: processcall (insn, warn, false, outframe);	break;	case code.ret: if(!isvoid(method.returntype)) {	nullity n = outframe.popstack();	if(nnacollector.hasnonnullattribute(method) && warn) {	
null deref at 

break;	case code.conv_i1: case code.conv_i2: case code.conv_i4: case code.conv_i8: case code.conv_r4: case code.conv_r8: case code.conv_u4: case code.conv_u8: case code.conv_u: case code.conv_r_un: case code.conv_ovf_i1_un: case code.conv_ovf_i2_un: case code.conv_ovf_i4_un: case code.conv_ovf_i8_un: case code.conv_ovf_u1_un: case code.conv_ovf_u2_un: case code.conv_ovf_u4_un: case code.conv_ovf_u8_un: case code.conv_ovf_i_un: case code.conv_ovf_u_un: case code.conv_ovf_i1: case code.conv_ovf_u1: case code.conv_ovf_i2: case code.conv_ovf_u2: case code.conv_ovf_i4: case code.conv_ovf_u4: case code.conv_ovf_i8: case code.conv_ovf_u8: case code.conv_u2: case code.conv_u1: case code.conv_i: case code.conv_ovf_i: case code.conv_ovf_u: case code.ckfinite: break;	case code.jmp: break;	case code.cpblk: outframe.popstack (3);	break;	case code.initblk: outframe.popstack (3);	break;	case code.localloc: outframe.popstack();	outframe.pushstack(nullity.nonnull);	break;	
unknown instruction 

case code.jmp: break;	case code.cpblk: outframe.popstack (3);	break;	case code.initblk: outframe.popstack (3);	break;	case code.localloc: outframe.popstack();	outframe.pushstack(nullity.nonnull);	break;	break;	} /* switch */ } /* for */ if (verbose) {	
output frame 

int nameoffset = name.lastindexof("::");	if(nameoffset != -1) name = name.substring(nameoffset + 2);	if(type.equals("method")) {	string prefix = name.substring(0, 4);	if(prefix.equals("get_") || prefix.equals("set_")) {	name = name.substring(4);	type = "property";	}	}	if(n == nullity.null) {	
null deref at 

private void processcall ([nonnull] instruction insn, bool warn, bool indirect, [nonnull] nullderefframe frame) {	imethodsignature csig = (imethodsignature)insn.operand;	if(indirect) frame.popstack(); /* function pointer */ foreach(parameterdefinition param in csig.parameters) {	nullity n = frame.popstack();	if(warn && nnacollector.hasnonnullattribute(method, param)) {	
null deref at 

========================= monodevelop sample_10416 =========================

protected void runaction (action<texteditordata> action) {	hidemousecursor ();	try {	action (this.texteditordata);	} catch (exception e) {	
error while executing action 

========================= monodevelop sample_668 =========================

list = new hashset<astnode>();	referencedict.add(entity, list);	}	list.add(node);	}	}	);	file.createresolver().applynavigator(navigator);	}	}	
for each entity find all references 

foreach (var project in solution.projects) {	foreach (var type in project.compilation.mainassembly.getalltypedefinitions()) {	testfindreferences(type);	foreach (imember m in type.members) {	testfindreferences(m);	}	console.write('.');	}	}	w.stop();	
findreferencesconsistencycheck is done 

========================= monodevelop sample_7987 =========================

public void insertafterstatementindentslikestatement() {	var input =@" public class test {	void doublyindented() {	
hello 

public void insertafterstatementindentslikestatement() {	var input =@" public class test {	void doublyindented() {	}	}";	var expected = @" public class test {	void doublyindented() {	
hello 

========================= monodevelop sample_8868 =========================

using (xmltextreader xmlreader = new xmltextreader(fs)) {	xmlreader.xmlresolver = null;	xmlreader.movetocontent();	if (string.isnullorempty(xmlreader.getattribute("redirect"))) {	this.filename = filename;	this.encoding = xmlreader.encoding;	readxmldoc(xmlreader);	} else {	string redirectiontarget = getredirectiontarget(filename, xmlreader.getattribute("redirect"));	if (redirectiontarget != null) {	
xmldoc is redirecting to 

public static string lookuplocalizedxmldoc(string filename) {	string xmlfilename = path.changeextension(filename, ".xml");	string currentculture = system.threading.thread.currentthread.currentuiculture.twoletterisolanguagename;	string localizedxmldocfile = getlocalizedname(xmlfilename, currentculture);	
try find xmldoc 

public static string lookuplocalizedxmldoc(string filename) {	string xmlfilename = path.changeextension(filename, ".xml");	string currentculture = system.threading.thread.currentthread.currentuiculture.twoletterisolanguagename;	string localizedxmldocfile = getlocalizedname(xmlfilename, currentculture);	if (file.exists(localizedxmldocfile)) {	return localizedxmldocfile;	}	
try find xmldoc 

string currentculture = system.threading.thread.currentthread.currentuiculture.twoletterisolanguagename;	string localizedxmldocfile = getlocalizedname(xmlfilename, currentculture);	if (file.exists(localizedxmldocfile)) {	return localizedxmldocfile;	}	if (file.exists(xmlfilename)) {	return xmlfilename;	}	if (currentculture != "en") {	string englishxmldocfile = getlocalizedname(xmlfilename, "en");	
try find xmldoc 

========================= monodevelop sample_8928 =========================

static void setlocale (string locale) {	string culturelang;	if (!localetoculture.trygetvalue (locale, out culturelang)) culturelang = locale.replace ("_", "-");	cultureinfo ci;	try {	ci = cultureinfo.getcultureinfo (culturelang);	} catch (exception e) {	
failed to grab culture culturelang using default 

static string getstringinternal (string phrase) {	if (platform.iswindows && thread.currentthread.currentuiculture != uiculture) {	thread.currentthread.currentuiculture = uiculture;	setthreaduilanguage (uiculture.lcid);	}	try {	return catalog.getstring (phrase);	} catch (exception e) {	
failed to localize string 

static string getpluralstringinternal (string singular, string plural, int number) {	if (platform.iswindows && thread.currentthread.currentuiculture != uiculture) {	thread.currentthread.currentuiculture = uiculture;	setthreaduilanguage (uiculture.lcid);	}	try {	return catalog.getpluralstring (singular, plural, number);	} catch (exception e) {	
failed to localize string 

========================= monodevelop sample_2330 =========================

public override void finishedlaunching (nsobject notification) {	var args = environment.getcommandlineargs ();	nserror error;	var searchargidx = array.indexof<string> (args, "--search");	if (searchargidx != -1 && args.length > searchargidx + 1 && !string.isnullorempty (args [searchargidx + 1])) {	var document = controller.openuntitleddocument (true, out error);	if (document != null) ((mydocument)document).loadwithsearch (args[searchargidx + 1]);	}	var indexmanager = indexupdatemanager;	indexmanager.checkindexisfresh ().continuewith (t => {	
error while checking indexes 

========================= monodevelop sample_10705 =========================

public void testmethodsynchronized () {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (methodimploptions.synchronized)]	void testmethod () {	
foo 

class testclass {	[methodimpl (methodimploptions.synchronized)]	void testmethod () {	}	}";	var output = @" using system.runtime.compilerservices;	class testclass {	object locker = new object ();	void testmethod () {	lock (locker) {	
foo 

public void testmethodwithsynchronizedvalue () {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (value = methodimploptions.synchronized)]	void testmethod () {	
foo 

class testclass {	[methodimpl (value = methodimploptions.synchronized)]	void testmethod () {	}	}";	var output = @" using system.runtime.compilerservices;	class testclass {	object locker = new object ();	void testmethod () {	lock (locker) {	
foo 

public void testmethodhassynchronized () {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (methodimploptions.synchronized | methodimploptions.noinlining)]	void testmethod () {	
foo 

[methodimpl (methodimploptions.synchronized | methodimploptions.noinlining)]	void testmethod () {	}	}";	var output = @" using system.runtime.compilerservices;	class testclass {	object locker = new object ();	[methodimpl (methodimploptions.noinlining)]	void testmethod () {	lock (locker) {	
foo 

public void testmethodnotsynchronized () {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (methodimploptions.noinlining)]	void testmethod () {	
foo 

========================= monodevelop sample_8458 =========================

public void trycatchfinally() {	try {	
try 

public void trycatchfinally() {	try {	}	catch (exception ex) {	console.writeline(ex.message);	}	finally {	
finally 

public void trycatchmultiplehandlers() {	try {	
try 

public void trycatchmultiplehandlers() {	try {	}	catch (invalidoperationexception ex) {	console.writeline(ex.message);	}	catch (exception ex2) {	console.writeline(ex2.message);	}	catch {	
other 

========================= monodevelop sample_499 =========================

protected static void checkbatchfix (testrefactoringcontext ctx, ienumerable<codeissue> issues, object siblingkey, string expectedoutput) {	using (var script = ctx.startscript ()) {	foreach (var issue in issues) {	var actions = issue.actions.where (a => a.siblingkey == siblingkey).tolist ();	assert.istrue(actions.count <= 1, "at most a single action expected per sibling key and issue.");	actions.first (a => a.siblingkey == siblingkey).run (script);	}	}	bool pass = expectedoutput == ctx.text;	if (!pass) {	
expected 

using (var script = ctx.startscript ()) {	foreach (var issue in issues) {	var actions = issue.actions.where (a => a.siblingkey == siblingkey).tolist ();	assert.istrue(actions.count <= 1, "at most a single action expected per sibling key and issue.");	actions.first (a => a.siblingkey == siblingkey).run (script);	}	}	bool pass = expectedoutput == ctx.text;	if (!pass) {	console.writeline (expectedoutput);	
got 

========================= monodevelop sample_8549 =========================

public void performsearchindexcreation () {	firesearchindexcreationevent (true);	try {	roottree.makesearchindex ();	} catch (exception e) {	
error making search index 

public void performsearchindexcreation () {	firesearchindexcreationevent (true);	try {	roottree.makesearchindex ();	} catch (exception e) {	}	try {	roottree.makeindex ();	} catch (exception e) {	
error making normal index 

========================= monodevelop sample_9926 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_87 =========================

private sizef drawerwillresizecontents (nsdrawer sender, sizef contentsize) {	
drawer resize 

========================= monodevelop sample_10731 =========================

if (args.length != 2) return 1;	if (!int.tryparse (args [0], out tcpport)) return 2;	if (!int.tryparse (args [1], out processid)) return 3;	var thread = new thread (new parameterizedthreadstart (loop));	thread.start (tcpport);	var sw = stopwatch.startnew ();	while (!disonnected) {	sentevent.waitone ();	sw.restart ();	if (!responseevent.waitone (100)) {	
timeout seq 

if (!int.tryparse (args [0], out tcpport)) return 2;	if (!int.tryparse (args [1], out processid)) return 3;	var thread = new thread (new parameterizedthreadstart (loop));	thread.start (tcpport);	var sw = stopwatch.startnew ();	while (!disonnected) {	sentevent.waitone ();	sw.restart ();	if (!responseevent.waitone (100)) {	startcollectingstacks ();	
no response seq in 

if (!int.tryparse (args [0], out tcpport)) return 2;	if (!int.tryparse (args [1], out processid)) return 3;	var thread = new thread (new parameterizedthreadstart (loop));	thread.start (tcpport);	var sw = stopwatch.startnew ();	while (!disonnected) {	sentevent.waitone ();	sw.restart ();	if (!responseevent.waitone (100)) {	startcollectingstacks ();	
response seq in sw elapsed 

var thread = new thread (new parameterizedthreadstart (loop));	thread.start (tcpport);	var sw = stopwatch.startnew ();	while (!disonnected) {	sentevent.waitone ();	sw.restart ();	if (!responseevent.waitone (100)) {	startcollectingstacks ();	stopcollectingstacks ();	} else {	
in time seq 

static void startcollectingstacks () {	var startinfo = new processstartinfo ("sample");	startinfo.useshellexecute = false;	outputfilepath = path.gettempfilename ();	
storing in 

static void stopcollectingstacks () {	if (!sampleprocess.hasexited) mono.unix.native.syscall.kill (sampleprocess.id, mono.unix.native.signum.sigint);	
waiting for sample close 

static void stopcollectingstacks () {	if (!sampleprocess.hasexited) mono.unix.native.syscall.kill (sampleprocess.id, mono.unix.native.signum.sigint);	sampleprocess.waitforexit ();	
sample closed 

========================= monodevelop sample_4719 =========================

public void showbannerandadd () {	
banner 

public void showbannerandadd () {	
print 

public void addandshowbanner () {	mylist.add ("morefoo");	
banner 

public void addandshowbanner () {	mylist.add ("morefoo");	
print 

public void writethesame () {	
foo 

========================= monodevelop sample_10620 =========================

public static void main (string[] args) {	
hello world 

========================= monodevelop sample_25 =========================

public void small () {	assertrulesuccess<avoidlargenumberoflocalvariablestest> ("smallmethod");	
writeline 

========================= monodevelop sample_10542 =========================

public void end () {	if (!stopwatch.isrunning) {	
timer already finished 

========================= monodevelop sample_2037 =========================

if (p.reference.indexof ("nunit.framework", stringcomparison.ordinalignorecase) != -1) {	var selector = p.project?.defaultconfiguration.selector;	if (selector == null) return nunitversion.unknown;	var f = p.getreferencedfilenames (selector).firstordefault ();	if (f != null && file.exists (f)) {	try {	var aname = new assemblyname (systemassemblyservice.getassemblyname (f));	if (aname.version.major == 2) return nunitversion.nunit2;	else return nunitversion.nunit3;	} catch (exception ex) {	
could not get assembly version 

========================= monodevelop sample_2639 =========================

}	if (!pathalreadyset) data.selectedfiles = macselectfiledialoghandler.getselectedfiles (panel);	if (state.encodingselector != null) data.encoding = state.encodingselector.selectedencodingid > 0 ? encoding.getencoding (state.encodingselector.selectedencodingid) : null;	if (state.viewerselector != null) {	if (state.closesolutionbutton != null) data.closecurrentworkspace = state.closesolutionbutton.state != nscellstatevalue.off;	data.selectedviewer = state.viewerselector.indexofselecteditem >= 0 ? state.currentviewers [(int)state.viewerselector.indexofselecteditem] : null;	}	gtkquartz.focuswindow (data.transientfor ?? messageservice.rootwindow);	}	} catch (exception ex) {	
error in open file dialog 

========================= monodevelop sample_5008 =========================

public override appresult text (string text, bool exact) {	if (resultobject is nstableview) {	var control = (nstableview)resultobject;	for (int i = 0; i < control.columncount;i ++) {	var cell = control.getcell (i, index);	var possvalues = getpossiblenscellvalues (cell);	
possible values for nstableview with column i and row index 

public override bool select () {	if (resultobject is nstableview) {	var control = (nstableview)resultobject;	
found nstableview with index index 

public override bool select () {	if (resultobject is nstableview) {	var control = (nstableview)resultobject;	if (index >= 0) {	
selecting row index of 

========================= monodevelop sample_1401 =========================

#endregion x-ram function pointer definitions #region x-ram tokens private int al_eax_ram_size, al_eax_ram_free, al_storage_automatic, al_storage_hardware, al_storage_accessible;	#endregion x-ram tokens #region constructor / extension loading public xramextension() {	_valid = false;	if (al.isextensionpresent("eax-ram") == false) return;	al_eax_ram_size = al.getenumvalue("al_eax_ram_size");	al_eax_ram_free = al.getenumvalue("al_eax_ram_free");	al_storage_automatic = al.getenumvalue("al_storage_automatic");	al_storage_hardware = al.getenumvalue("al_storage_hardware");	al_storage_accessible = al.getenumvalue("al_storage_accessible");	if (al_eax_ram_size == 0 || al_eax_ram_free == 0 || al_storage_automatic == 0 || al_storage_hardware == 0 || al_storage_accessible == 0) {	
x ram token values could not be retrieved 

al_storage_hardware = al.getenumvalue("al_storage_hardware");	al_storage_accessible = al.getenumvalue("al_storage_accessible");	if (al_eax_ram_size == 0 || al_eax_ram_free == 0 || al_storage_automatic == 0 || al_storage_hardware == 0 || al_storage_accessible == 0) {	return;	}	try {	imported_getbuffermode = (delegate_getbuffermode)marshal.getdelegateforfunctionpointer(al.getprocaddress("eaxgetbuffermode"), typeof(delegate_getbuffermode));	imported_setbuffermode = (delegate_setbuffermode)marshal.getdelegateforfunctionpointer(al.getprocaddress("eaxsetbuffermode"), typeof(delegate_setbuffermode));	}	catch (exception e) {	
x ram attempt to marshal function pointers with al getprocaddress failed 

========================= monodevelop sample_11342 =========================

collectors.add (col);	col.task = cat.getresults (col, pattern, token);	}	task.whenall (collectors.select (c => c.task)).continuewith (t => {	if (token.iscancellationrequested) return;	var newresults = new list<tuple<searchcategory, ireadonlylist<searchresult>>> (collectors.count);	foreach (var col in collectors) {	if (col.task.iscanceled) {	continue;	} else if (col.task.isfaulted) {	
error getting search results for col category 

}	}	list<tuple<searchcategory, ireadonlylist<searchresult>>> failedresults = null;	itemidentifier topresult = null;	for (int i = 0; i < newresults.count; i++) {	var tuple = newresults [i];	try {	if (tuple.item2.count == 0) continue;	if (topresult == null || topresult.datasource [topresult.item].weight < tuple.item2 [0].weight) topresult = new itemidentifier (tuple.item1, tuple.item2, 0);	} catch (exception e) {	
error while showing result 

========================= monodevelop sample_1763 =========================

public static void main (string[] args) {	
hello world 

========================= monodevelop sample_201 =========================

openfiledialog dlg = new openfiledialog ("export rules", monodevelop.components.filechooseraction.save);	dlg.initialfilename = "rules.html";	if (!dlg.run ()) return;	dictionary<codediagnosticdescriptor, diagnosticseverity?> severities = new dictionary<codediagnosticdescriptor, diagnosticseverity?> ();	var language = coderefactoringservice.mimetypetolanguage (lang);	foreach (var node in options.alldiagnostics.where (x => x.languages.contains (language))) {	severities [node] = node.diagnosticseverity;	}	var grouped = severities.keys.oftype<codediagnosticdescriptor> () .groupby (node => node.getprovider ().supporteddiagnostics.first ().category) .orderby (g => g.key, stringcomparer.ordinal);	using (var sw = new streamwriter (dlg.selectedfile)) {	
code rules 

severities [node] = node.diagnosticseverity;	}	var grouped = severities.keys.oftype<codediagnosticdescriptor> () .groupby (node => node.getprovider ().supporteddiagnostics.first ().category) .orderby (g => g.key, stringcomparer.ordinal);	using (var sw = new streamwriter (dlg.selectedfile)) {	foreach (var g in grouped) {	sw.writeline ("<h2>" + g.key + "</h2>");	sw.writeline ("<table border='1'>");	foreach (var node in g.select (n => new { descriptor = n, provider = n.getprovider ()}).orderby (n => n.provider.getanalyzerid(), stringcomparer.ordinal)) {	var title = node.provider.getanalyzerid ();	var desc = node.provider.supporteddiagnostics.first ().description.tostring () != title ? node.provider.supporteddiagnostics.first ().description : "";	
tr td td td td td td tr 

foreach (var g in grouped) {	sw.writeline ("<h2>" + g.key + "</h2>");	sw.writeline ("<table border='1'>");	foreach (var node in g.select (n => new { descriptor = n, provider = n.getprovider ()}).orderby (n => n.provider.getanalyzerid(), stringcomparer.ordinal)) {	var title = node.provider.getanalyzerid ();	var desc = node.provider.supporteddiagnostics.first ().description.tostring () != title ? node.provider.supporteddiagnostics.first ().description : "";	if (node.provider.supporteddiagnostics.length > 1) {	foreach (var subissue in node.provider.supporteddiagnostics) {	title = subissue.description.tostring ();	desc = subissue.description.tostring () != title ? subissue.description : "";	
tr td td td td td td tr 

foreach (var node in g.select (n => new { descriptor = n, provider = n.getprovider ()}).orderby (n => n.provider.getanalyzerid(), stringcomparer.ordinal)) {	var title = node.provider.getanalyzerid ();	var desc = node.provider.supporteddiagnostics.first ().description.tostring () != title ? node.provider.supporteddiagnostics.first ().description : "";	if (node.provider.supporteddiagnostics.length > 1) {	foreach (var subissue in node.provider.supporteddiagnostics) {	title = subissue.description.tostring ();	desc = subissue.description.tostring () != title ? subissue.description : "";	}	}	}	
table 

title = subissue.description.tostring ();	desc = subissue.description.tostring () != title ? subissue.description : "";	}	}	}	}	var providerstates = new dictionary<coderefactoringdescriptor, bool> ();	foreach (var node in options.allrefactorings.where (x => x.language.contains (language))) {	providerstates [node] = node.isenabled;	}	
code actions 

}	}	}	var providerstates = new dictionary<coderefactoringdescriptor, bool> ();	foreach (var node in options.allrefactorings.where (x => x.language.contains (language))) {	providerstates [node] = node.isenabled;	}	sw.writeline ("<table border='1'>");	var sortedandfiltered = providerstates.keys.orderby (n => n.name, stringcomparer.ordinal);	foreach (var node in sortedandfiltered) {	
tr td td td td tr 

}	}	var providerstates = new dictionary<coderefactoringdescriptor, bool> ();	foreach (var node in options.allrefactorings.where (x => x.language.contains (language))) {	providerstates [node] = node.isenabled;	}	sw.writeline ("<table border='1'>");	var sortedandfiltered = providerstates.keys.orderby (n => n.name, stringcomparer.ordinal);	foreach (var node in sortedandfiltered) {	}	
table 

========================= monodevelop sample_4057 =========================

public override control createpanelwidget () {	
configurationoptionspanel createpanelwidget 

public override void loadconfigdata () {	
configurationoptionspanel loadconfigdata 

public override void applychanges () {	
configurationoptionspanel applychanges 

========================= monodevelop sample_4090 =========================

public void testaddbracestoif() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestoif() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	}	}", @"class testclass {	void test() {	if (true) {	
hello 

public void testaddbracestoifwithcomment() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestoifwithcomment() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	}	}", @"class testclass {	void test() {	if (true) {	
hello 

public void testaddbracestoifwithcommentinblock() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestoifwithcommentinblock() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	}	}", @"class testclass {	void test() {	if (true) {	
hello 

public void testaddbracestoelse() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	
hello 

public void testaddbracestoelse() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	
world 

public void testaddbracestoelse() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	}	}", @"class testclass {	void test() {	if (true) {	
hello 

public void testaddbracestoelse() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	}	}", @"class testclass {	void test() {	if (true) {	} else {	
world 

public void testaddbracestodowhile() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestodowhile() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	while (true);	}	}", @"class testclass {	void test() {	do {	
hello 

public void testaddbracestoforeach() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestoforeach() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	}	}", @"class testclass {	void test() {	foreach (var a in b) {	
hello 

public void testaddbracestofor() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestofor() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	}	}", @"class testclass {	void test() {	for (;;) {	
hello 

public void testaddbracestolock() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestolock() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	}	}", @"class testclass {	void test() {	lock (this) {	
hello 

public void testaddbracestousing() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	$using (var a = new a ()) console.writeline(""hello"");	}	}", @"class testclass {	void test() {	using (var a = new a ()) {	
hello 

public void testaddbracestowhile() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	
hello 

public void testaddbracestowhile() {	test<addbracescoderefactoringprovider>(@"class testclass {	void test() {	}	}", @"class testclass {	void test() {	while (true) {	
hello 

public void testblockalreadyinserted() {	testwrongcontext<addbracescoderefactoringprovider>(@"class testclass {	void test() {	$if (true) {	
hello 

public void testnullnode() {	testwrongcontext<addbracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	
hello 

========================= monodevelop sample_7028 =========================

stream stream = null;	try {	stream = getkeybindingsschemestream ();	if (stream != null) {	reader = new xmltextreader (stream);	cachedset = new keybindingset (keybindingservice.defaultkeybindingset);	cachedset.loadscheme (reader, id);	return cachedset;	}	} catch (exception e) {	
error reading keybindings definition in addin 

========================= monodevelop sample_1497 =========================

static actioncomponent () {	try {	defaultactionicon = gdk.pixbuf.loadfromresource ("action.png");	} catch (exception e) {	
error while loading pixbuf action png 

========================= monodevelop sample_3603 =========================

upgradedfromrevision = lastrevision;	propertyservice.set ("monodevelop.core.lastrunversion", buildinfo.version);	propertyservice.set ("monodevelop.core.lastrunrevision", currentrevision);	propertyservice.saveproperties ();	}	isinitialized = true;	if (isinitialrun) {	try {	oninitialrun ();	} catch (exception e) {	
error found while initializing the ide 

if (isinitialrun) {	try {	oninitialrun ();	} catch (exception e) {	}	}	if (isinitialrunafterupgrade) {	try {	onupgraded (upgradedfromrevision);	} catch (exception e) {	
error found while initializing the ide 

static void onextensionchanged (object s, extensionnodeeventargs args) {	if (args.change == extensionchange.add) {	try {	if (typeof(commandhandler).isinstanceoftype (args.extensionobject)) typeof(commandhandler).getmethod ("run", system.reflection.bindingflags.nonpublic|system.reflection.bindingflags.instance, null, type.emptytypes, null).invoke (args.extensionobject, null);	
type must be a subclass of monodevelop components commands commandhandler 

public static void enableidleactions () {	runtime.assertmainthread ();	if (idleactionsdisabled == 0) {	
enableidleactions call without corresponding disableidleactions call 

========================= monodevelop sample_1646 =========================

private void processqueue () {	while (true) {	try {	using (var slice = getslice ()) {	if (slice == null) return;	analyzefile (slice, slice.getjobs ().selectmany (job => job.getissueproviders (slice.file)));	}	} catch (exception e) {	
unhandled exception 

========================= monodevelop sample_4022 =========================

if (file.exists (filetoload)) {	xmldataserializer serializer = new xmldataserializer (new datacontext ());	list<tasklistentry> ts = (list<tasklistentry>) serializer.deserialize (filetoload, typeof(list<tasklistentry>));	foreach (tasklistentry t in ts) {	t.workspaceobject = e.item;	usertasks.add (t);	}	}	}	catch (exception ex) {	
could not load user tasks 

========================= monodevelop sample_1815 =========================

public static void foo () {	
foo 

========================= monodevelop sample_147 =========================

public static void start (commandmanager commandmanager, bool publishserver) {	autotestservice.commandmanager = commandmanager;	string sref = environment.getenvironmentvariable ("mono_autotest_client");	if (!string.isnullorempty (sref)) {	
autotest service starting 

public void notifyevent (string eventname) {	try {	client.notifyevent (eventname);	}	catch (exception ex) {	
dropping autotest client 

public void resume () {	if (state == state.idle) {	commandmanager.keypressed += handlecommandmanagerkeypressed;	commandmanager.commandactivated += handlecommandmanagercommandactivated;	state = state.recording;	
starting up session recording 

========================= monodevelop sample_1534 =========================

}	ctorparametertypes = interningprovider.internlist(ctorparametertypes);	}	byte[] blob;	try {	blob = attribute.__getblob ();	} catch (ikvm.reflection.missingmemberexception) {	blob = new byte[0];	} catch (exception e) {	blob = new byte[0];	
ikvm error while getting blob 

========================= monodevelop sample_8357 =========================

try {	bool haveanycancelled = false;	itemunloadingeventargs args = new itemunloadingeventargs (item);	foreach (eventhandler<itemunloadingeventargs> handler in itemunloading.getinvocationlist ()) {	handler (this, args);	haveanycancelled |= args.cancel;	}	return !haveanycancelled;	}	catch (exception ex) {	
exception in itemunloading 

public task savepreferences (workspaceitem item) {	workspaceuserdata data = new workspaceuserdata ();	data.activeconfiguration = activeconfigurationid;	data.activeruntime = usedefaultruntime ? null : activeruntime.id;	item.userproperties.setvalue ("monodevelop.ide.workspace", data);	if (storinguserpreferences != null) {	userpreferenceseventargs args = new userpreferenceseventargs (item, item.userproperties);	try {	storinguserpreferences (this, args);	} catch (exception ex) {	
exception in userpreferencesrequested 

========================= monodevelop sample_1633 =========================

var latestmodel = await latestdocument.getsemanticmodelasync (cancellationtoken).configureawait (false);	var latestroot = await latestdocument.getsyntaxrootasync (cancellationtoken).configureawait (false);	await runtime.runinmainthread (async delegate {	try {	var node = latestroot.findnode (token.value.parent.span, false, false);	if (node == null) return;	var info = latestmodel.getsymbolinfo (node);	var sym = info.symbol ?? latestmodel.getdeclaredsymbol (node);	if (sym != null) await new monodevelop.refactoring.rename.renamerefactoring ().rename (sym);	} catch (exception ex) {	
error while renaming 

========================= monodevelop sample_3897 =========================

foreach(int target in targets) {	addedge(new cfgedge((basicblock)insnbb[insn.offset], (basicblock)insnbb[target], cfgedgetype.branch));	}	}	entrypoint = (basicblock)insnbb[0];	}	public void printdot() {	string name = method.declaringtype.name + "." + method.name + ".dot";	filemode mode = filemode.create;	streamwriter writer = new streamwriter(new filestream(name, mode));	
digraph 

========================= monodevelop sample_10443 =========================

public bool loadprofile (string path) {	this.path = path;	synclogfilereader rdr = new synclogfilereader (path);	profilereventhandler data = new profilereventhandler ();	data.loadedelements.recordheapsnapshots = false;	for (blockdata current = rdr.readblock (); current != null; current = rdr.readblock ()) {	try {	current.decode (data, rdr);	} catch (decodingexception e) {	
stopping decoding after a decodingexception in block of code length file offset block offset 

========================= monodevelop sample_9902 =========================

public void pushstack (nullity n) {	if(stackdepth == stack.length) {	throw new exception("nullity stack overflow");	}	
push 

public nullity popstack () {	if (stackdepth == 0) {	throw new exception("nullity stack underflow");	}	
pop 

public void setlocnullity(int index, nullity n) {	
setloc 

public nullity getlocnullity(int index) {	
getloc 

public void setargnullity(int index, nullity n) {	if (runner.verbositylevel > 1) {	
setarg 

public nullity getargnullity(int index) {	if (runner.verbositylevel > 1) {	
getarg 

========================= monodevelop sample_10426 =========================

public void testsimplestring() {	string result = runcontextaction( new splitstringcoderefactoringprovider(), "class testclass" + environment.newline + "{" + environment.newline + "	void test ()" + environment.newline + "	{" + environment.newline + "		system.console.writeline (\"hello$world\");" + environment.newline + "	}" + environment.newline + "}" );	
class testclass void test system console writeline 

public void testverbatimstring() {	string result = runcontextaction( new splitstringcoderefactoringprovider(), "class testclass" + environment.newline + "{" + environment.newline + "	void test ()" + environment.newline + "	{" + environment.newline + "		system.console.writeline (@\"hello$world\");" + environment.newline + "	}" + environment.newline + "}" );	
class testclass void test system console writeline 

========================= monodevelop sample_6999 =========================

protected safehandlebase() : base(intptr.zero, true) {	nativemethods.addhandle();	registered = 1;	#if leaks_tracking id = guid.newguid();	
allocating handle 

protected override void dispose(bool disposing) {	bool leaked = !disposing && !isinvalid;	#if leaks_identifying if (leaked) {	leakscontainer.add(gettype().name);	}	#endif base.dispose(disposing);	#if leaks_tracking if (!leaked) {	
disposing handle 

protected override void dispose(bool disposing) {	bool leaked = !disposing && !isinvalid;	#if leaks_identifying if (leaked) {	leakscontainer.add(gettype().name);	}	#endif base.dispose(disposing);	#if leaks_tracking if (!leaked) {	}	else {	
unexpected finalization of handle 

========================= monodevelop sample_9775 =========================

public static void readlist (xmlreader reader, icollection<string> endnodes, readercallbackwithdata callback) {	if (reader.isemptyelement) return;	readcallbackdata data = new readcallbackdata ();	bool didreadstartnode = false;	while (reader.read()) {	skip: data.skipnextread = false;	switch (reader.nodetype) {	case xmlnodetype.endelement: if (endnodes.contains (reader.localname)) return;	
unknown end node valid end nodes are 

bool didreadstartnode = false;	while (reader.read()) {	skip: data.skipnextread = false;	switch (reader.nodetype) {	case xmlnodetype.endelement: if (endnodes.contains (reader.localname)) return;	break;	case xmlnodetype.element: if (!didreadstartnode && endnodes.contains (reader.localname)) {	didreadstartnode = true;	}	bool validnode = callback (data);	
unknown node 

========================= monodevelop sample_718 =========================

pi++;	switch (arg) {	case "-v": case "/v": case "--verbose": case "/verbose": verbosity = (enabledlogginglevel)((int)verbosity << 1) | enabledlogginglevel.fatal;	continue;	case "-q": case "/q": listtools = true;	continue;	case "--no-reg-update": case "/no-reg-update": case "-nru": case "/nru": regupdate = false;	continue;	case "-h": case "/h": case "--help": case "/help": showhelp = true;	continue;	
unknown argument 

string toolname = null;	string[] toolargs = null;	if (!showhelp && !listtools && !badinput) {	if (pi < args.length) {	toolname = args[pi];	toolargs = new string [args.length - 1 - pi];	array.copy (args, pi + 1, toolargs, 0, args.length - 1 - pi);	} else if (args.length == 0) {	showhelp = true;	} else {	
no tool specified 

}	var logger = (consolelogger)loggingservice.getlogger ("consolelogger");	logger.enabledlevel = verbosity;	runtime.initialize (regupdate);	if (showhelp || badinput) {	showhelp (badinput, exename);	return badinput? 1 : 0;	}	var tool = runtime.applicationservice.getapplication (toolname);	if (tool == null) {	
tool not found 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	
run help to show usage information 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	
monodevelop tool runner 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	console.writeline ();	
usage options tool runs a tool 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	console.writeline ();	
setup runs the setup utility 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	console.writeline ();	
q lists available tools 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	console.writeline ();	console.writeline ();	
options 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	console.writeline ();	console.writeline ();	
verbose v increases log verbosity can be used multiple times 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	console.writeline ();	console.writeline ();	
no reg update skip updating extension registry faster but results in 

static void showhelp (bool shorthelp, string exename) {	if (shorthelp) {	console.writeline ();	console.writeline ();	return;	}	console.writeline ();	console.writeline ();	console.writeline ();	
random errors if registry is not up to date 

static int runsetup (string[] args) {	
monodevelop extension setup utility 

static void showavailabletools () {	console.writeline ();	
available tools 

========================= monodevelop sample_609 =========================

public void selftest() {	foreach (var file in filenames) {	
processing 

========================= monodevelop sample_8448 =========================

static void help () {	
compares masterinfos to mono assemblies and stores the data in a db 

static void help () {	
the masterinfos are expected to be in masterinfos and the assemblies 

static void help () {	
in binary 

static void help () {	console.writeline ();	
when invoked with no arguments it is equivalent to 

static void help () {	console.writeline ();	console.writeline ();	
webcompare db exe 

static void help () {	console.writeline ();	console.writeline ();	console.writeline ();	
the first argument of each pair is a directory in masterinfos 

static void help () {	console.writeline ();	console.writeline ();	console.writeline ();	
the second argument of each pair is a directory in binary 

static void help () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
help displays this help 

static void help () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
delete tables delete all the data in all the tables and exits 

static void help () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
assemblies comma separated list of assemblies to compare 

static void help () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
all other assemblies are ignored 

foreach (string s in strs) include_list.add (s);	got_assemblies = false;	continue;	}	if (arg == "--help") {	help ();	return 0;	}	if (arg == "--delete-tables") {	deletetables ();	
tables deleted 

if (arg == "--delete-tables") {	deletetables ();	return 0;	}	if (arg == "--assemblies") {	got_assemblies = true;	continue;	}	string [] compare = arg.split ();	if (compare.length != 2) {	
invalid argument 

got_assemblies = true;	continue;	}	string [] compare = arg.split ();	if (compare.length != 2) {	return 1;	}	compares.add (arg);	}	if (got_assemblies) {	
assembly list not provided for assemblies 

static void performcomparison () {	int end = work_items.count;	for (int i = 0; i < end; i++) {	state state = work_items [i];	if (interlocked.compareexchange (ref state.alreadycomparing, 1, 0) == 1) continue;	
comparing 

static void updatedb () {	dataaccess da = getdataaccess ();	int end = work_items.count;	for (int i = 0; i < end; i++) {	state state = work_items [i];	if (interlocked.compareexchange (ref state.lockinuse, 1, 0) == 1) continue;	state.updatelock.waitone ();	if (state.root != null) {	
inserting 

state.updatelock.waitone ();	if (state.root != null) {	state.detaillevel = "detailed";	da.insertroot (state);	state.root.resetcounts ();	filterroot (state.root);	state.root.propagatecounts ();	state.detaillevel = "normal";	da.insertroot (state);	} else {	
no insertions for 

static comparisonnode makecomparisonnode (string info_file, string dll_file) {	if (!file.exists (info_file)) {	
does not exist 

static comparisonnode makecomparisonnode (string info_file, string dll_file) {	if (!file.exists (info_file)) {	return null;	}	if (!file.exists (dll_file)) {	
does not exist 

}	if (!file.exists (dll_file)) {	return null;	}	comparecontext cc = new comparecontext ( () => new masterassembly (info_file), () => new cecilassembly (dll_file));	cc.progresschanged += delegate (object sender, compareprogresschangedeventargs a){	};	bool have_error = false;	cc.error += delegate (object sender, compareerroreventargs args) {	have_error = true;	
error loading 

========================= monodevelop sample_10655 =========================

public void setmessage (string msg) {	
process ps msg 

public void setprogress (double progress) {	
process ps progress 

public void log (string msg) {	
plog process ps plog 

public void log (string msg) {	
process ps log 

public void reportwarning (string message) {	
process ps warning 

public void reporterror (string message, exception exception) {	if (message == null) message = string.empty;	string et;	if (loglevel > 1) et = exception != null ? exception.tostring () : string.empty;	else et = exception != null ? exception.message : string.empty;	
process ps exception 

public void reporterror (string message, exception exception) {	if (message == null) message = string.empty;	string et;	if (loglevel > 1) et = exception != null ? exception.tostring () : string.empty;	else et = exception != null ? exception.message : string.empty;	
process ps error 

public void cancel () {	canceled = true;	
process ps cancel 

========================= monodevelop sample_11568 =========================

do {	string cf = path.combine (dir, "changelog");	if (file.exists (cf)) return cf;	dir = path.getdirectoryname (dir);	} while (dir.length >= basecommitpath.length);	return null;	}	case changelogupdatemode.projectroot: return path.combine (parententry.basedirectory, "changelog");	case changelogupdatemode.directory: string filedir = path.getdirectoryname (file);	return path.combine (filedir, "changelog");	
could not handle changelogupdatemode 

========================= monodevelop sample_2360 =========================

static targetframework readtargetframework (targetframeworkmoniker moniker, filepath directory) {	try {	return targetframework.fromframeworkdirectory (moniker, directory);	} catch (exception ex) {	
error reading framework definition 

========================= monodevelop sample_2282 =========================

if (line == null || line.length == 0 || column < 0) return 0;	var wrapper = getlayout (line);	uint curindex = 0;	uint byteindex = 0;	int index;	pango.rectangle pos;	try {	index = (int)translatetoutf8index (wrapper.text, (uint)system.math.min (system.math.max (0, column), wrapper.text.length), ref curindex, ref byteindex);	pos = wrapper.indextopos (index);	} catch (exception ex) {	
error calculating x position for line column 

========================= monodevelop sample_4489 =========================

public override control createpanelwidget() {	try {	return createpackagesourceswidget ();	} catch (exception ex) {	
unable to show package sources in nuget config file 

public override bool validatechanges () {	if (platform.iswindows || loaderror) {	return true;	}	try {	if (anypasswordstobeencrypted ()) {	checkpasswordencryptionisworking ();	}	} catch (cryptographicexception ex) {	
unable to encrypt nuget package source passwords 

public override void applychanges() {	if (loaderror) return;	try {	if (packagesourceswidget.haspackagesourcesorderchanged) {	viewmodel.save ( packagesourceswidget.getorderedpackagesources ());	} else {	viewmodel.save ();	}	packagemanagementservices.workspace.reloadsettings ();	} catch (exception ex) {	
unable to save nuget config changes 

========================= monodevelop sample_3129 =========================

private void usercontrol_loaded(object sender, routedeventargs e) {	textui.writeheader(this.writer);	textui.writeruntimeenvironment(this.writer);	
no tests found in assembly 

========================= monodevelop sample_5596 =========================

static void concludedragoperation (intptr sender, intptr sel, intptr draginfo) {	
concludedragoperation 

========================= monodevelop sample_7582 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_162 =========================

for (int n=0; n<ents.length; n++) epaths [n] = ents [n].itemid;	var r = services.projectservice.export (mon, sourcefile, epaths, folder, fileformat).result;	if (string.isnullorempty (r)) return false;	string td = path.getdirectoryname (targetfile);	if (!directory.exists (td)) directory.createdirectory (td);	deployservice.createarchive (mon, tmpfolder, targetfile);	}	finally {	directory.delete (tmpfolder, true);	}	
created file 

========================= monodevelop sample_4334 =========================

public static string formatxml (textstylepolicy textpolicy, xmlformattingpolicy formattingpolicy, string input) {	xmldocument doc;	try {	doc = new xmldocument ();	doc.xmlresolver = null;	doc.loadxml (input);	} catch (xmlexception ex) {	if (ex.message == "root element is missing.") return input;	
error formatting xml file 

xmldocument doc;	try {	doc = new xmldocument ();	doc.xmlresolver = null;	doc.loadxml (input);	} catch (xmlexception ex) {	if (ex.message == "root element is missing.") return input;	ideapp.workbench.statusbar.showerror ("error formatting file: " + ex.message);	return input;	} catch (exception ex) {	
error formatting xml file 

========================= monodevelop sample_3505 =========================

ontheflyformatter.format (ext.editor, ext.documentcontext);	var newoffset = ext.editor.caretoffset;	assert.areequal (oldoffset, newoffset);	});	}	[test]	public async task testbug51549 () {	await simulate (@" using system;	class mycontext {	public static void main() {	
hello 

========================= monodevelop sample_311 =========================

public static void main (string[] args) {	
hello world 

========================= monodevelop sample_191 =========================

public void nocheckload (eventargs e) {	loading (this, e);	
load 

public void nonullcheckload (eventargs e) {	eventhandler handler = loading;	handler (this, e);	
load 

public void ongoodload (eventargs e) {	eventhandler handler = loading;	if (handler != null) {	handler (this, e);	}	
load 

public void ongoodloadinverted (eventargs e) {	eventhandler handler = loading;	if (null == handler) {	handler (this, e);	}	
load 

public void nochecktest (eventargs e) {	testing (this, e);	
test 

public void nonullchecktest (eventargs e) {	eventhandler<eventargs> handler = testing;	handler (this, e);	
test 

public void ongoodtest (eventargs e) {	eventhandler<eventargs> handler = testing;	if (handler != null) {	handler (this, e);	}	
test 

public void ongoodtestinverted (eventargs e) {	eventhandler<eventargs> handler = testing;	if (null != handler) {	handler (this, e);	}	
test 

========================= monodevelop sample_10268 =========================

public void showstats () {	if (timers == null) return;	dictionary<timertype, string> timer_names = new dictionary<timertype,string> {	{ timertype.parsetotal, "parsing source files" }, { timertype.assemblybuildersetup, "assembly builder setup" }, { timertype.createtypetotal, "compiled types created" }, { timertype.referencesloading, "referenced assemblies loading" }, { timertype.referencesimporting, "referenced assemblies importing" }, { timertype.predefinedtypesinit, "predefined types initialization" }, { timertype.moduledefinitiontotal, "module definition" }, { timertype.emittotal, "resolving and emitting members blocks" }, { timertype.closetypes, "module types closed" }, { timertype.resouces, "embedding resources" }, { timertype.outputsave, "writing output file" }, { timertype.debugsave, "writing debug symbols file" }, };	int counter = 0;	double percentage = (double) total.elapsedmilliseconds / 100;	long subtotal = total.elapsedmilliseconds;	foreach (var timer in timers) {	string msg = timer_names[(timertype) counter++];	var ms = timer == null ? 0 : timer.elapsedmilliseconds;	
ms 

dictionary<timertype, string> timer_names = new dictionary<timertype,string> {	{ timertype.parsetotal, "parsing source files" }, { timertype.assemblybuildersetup, "assembly builder setup" }, { timertype.createtypetotal, "compiled types created" }, { timertype.referencesloading, "referenced assemblies loading" }, { timertype.referencesimporting, "referenced assemblies importing" }, { timertype.predefinedtypesinit, "predefined types initialization" }, { timertype.moduledefinitiontotal, "module definition" }, { timertype.emittotal, "resolving and emitting members blocks" }, { timertype.closetypes, "module types closed" }, { timertype.resouces, "embedding resources" }, { timertype.outputsave, "writing output file" }, { timertype.debugsave, "writing debug symbols file" }, };	int counter = 0;	double percentage = (double) total.elapsedmilliseconds / 100;	long subtotal = total.elapsedmilliseconds;	foreach (var timer in timers) {	string msg = timer_names[(timertype) counter++];	var ms = timer == null ? 0 : timer.elapsedmilliseconds;	subtotal -= ms;	}	
ms other tasks 

{ timertype.parsetotal, "parsing source files" }, { timertype.assemblybuildersetup, "assembly builder setup" }, { timertype.createtypetotal, "compiled types created" }, { timertype.referencesloading, "referenced assemblies loading" }, { timertype.referencesimporting, "referenced assemblies importing" }, { timertype.predefinedtypesinit, "predefined types initialization" }, { timertype.moduledefinitiontotal, "module definition" }, { timertype.emittotal, "resolving and emitting members blocks" }, { timertype.closetypes, "module types closed" }, { timertype.resouces, "embedding resources" }, { timertype.outputsave, "writing output file" }, { timertype.debugsave, "writing debug symbols file" }, };	int counter = 0;	double percentage = (double) total.elapsedmilliseconds / 100;	long subtotal = total.elapsedmilliseconds;	foreach (var timer in timers) {	string msg = timer_names[(timertype) counter++];	var ms = timer == null ? 0 : timer.elapsedmilliseconds;	subtotal -= ms;	}	console.writeline ();	
total elapsed time 

========================= monodevelop sample_9208 =========================

input = compile (input, out compiled);	if (input != null) return input;	if (compiled == null) return null;	object retval = typeof (quitvalue);	try {	invoke_thread = system.threading.thread.currentthread;	invoking = true;	compiled (ref retval);	} catch (threadabortexception e){	thread.resetabort ();	
interrupted 

output.write (evaluator.getusing ());	output.flush ();	}	static public timespan time (action a) {	datetime start = datetime.now;	a ();	return datetime.now - start;	}	static public void loadpackage (string pkg) {	if (pkg == null){	
invalid package specified 

public void addtypecontainer (typecontainer current_container, typedefinition tc) {	if (current_container == tc){	
internal error inserting container into itself 

========================= monodevelop sample_9199 =========================

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	
dict 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	
key name key 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	
string string 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	
key settings key 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	
array 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	
dict 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	
key name key 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	
string string 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	
key scope key 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	
string string 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	
key settings key 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	
dict 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	
key key 

public static void save (textwriter writer, editortheme theme) {	writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	
string string 

writer.writeline ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");	writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	}	
dict 

writer.writeline ("<!doctype plist public \"- writer.writeline ("<plist version=\"1.0\">");	foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	}	}	
dict 

foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	}	}	}	
array 

foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	}	}	}	
key uuid key 

foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	}	}	}	
string string 

foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	}	}	}	
dict 

foreach (var setting in theme.settings) {	if (setting.name != null) {	}	if (setting.scopes.count > 0) {	}	if (setting.settings.count > 0) {	foreach (var kv in setting.settings) {	}	}	}	
plist 

case "array": return new parray (new list<pobject> (f.elements ().select (convert)));	case "object": var val = new pdictionary ();	foreach (var subelement in f.elements ()) {	var name = subelement.name.localname;	if (string.isnullorempty (name)) continue;	if (name == "item") name = subelement.attribute ("item").value;	if (!val.containskey (name)) {	var converted = convert (subelement);	if (converted != null) val.add (name, converted);	} else {	
warning while converting json highlighting to textmate key is duplicated in 

if (string.isnullorempty (name)) continue;	if (name == "item") name = subelement.attribute ("item").value;	if (!val.containskey (name)) {	var converted = convert (subelement);	if (converted != null) val.add (name, converted);	} else {	}	}	return val;	case "number": return new pnumber (int.parse (f.value));	
can t convert element of type 

========================= monodevelop sample_1616 =========================

private void backtrack() {	int newpos = runtrack[runtrackpos++];	#if dbg if (runmatch.debug) {	
backtracking to code position 

private void backtrack() {	int newpos = runtrack[runtrackpos++];	#if dbg if (runmatch.debug) {	
backtracking to code position 

========================= monodevelop sample_1606 =========================

public void buildstartedhandler (object sender, buildstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	writeline (string.empty);	
build started 

public void projectstartedhandler (object sender, projectstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	setcolor (eventcolor);	
project target s default 

public void projectfinishedhandler (object sender, projectfinishedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	if (indent == 1) indent --;	setcolor (eventcolor);	
done building project failed 

public void targetstartedhandler (object sender, targetstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	indent++;	setcolor (eventcolor);	writeline (string.empty);	
target 

public void targetfinishedhandler (object sender, targetfinishedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.detailed) || (!args.succeeded && isverbositygreaterorequal (loggerverbosity.normal))) {	setcolor (eventcolor);	
done building target in project failed 

public void taskstartedhandler (object sender, taskstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.detailed)) {	setcolor (eventcolor);	
task 

public void taskfinishedhandler (object sender, taskfinishedeventargs args) {	indent--;	if (isverbositygreaterorequal (loggerverbosity.detailed) || (!args.succeeded && isverbositygreaterorequal (loggerverbosity.normal))) {	setcolor (eventcolor);	
done executing task 

public void taskfinishedhandler (object sender, taskfinishedeventargs args) {	indent--;	if (isverbositygreaterorequal (loggerverbosity.detailed) || (!args.succeeded && isverbositygreaterorequal (loggerverbosity.normal))) {	setcolor (eventcolor);	
task execution failed 

========================= monodevelop sample_1845 =========================

}	}	readonly static immutablearray<string> tags = immutablearray<string>.empty.add ("snippet");	internal static completionitem createcompletionitem (string completiontext, string description, object example) {	var pdict = immutabledictionary<string, string>.empty;	if (description != null) pdict = pdict.add ("descriptionmarkup", "- <span foreground=\"darkgray\" size='small'>" + description + "</span>");	if (example != null) {	try {	pdict = pdict.add ("rightsidemarkup", "<span size='small'>" + string.format ("{0:" + completiontext + "}", example) + "</span>");	} catch (exception e) {	
format error 

========================= monodevelop sample_3851 =========================

return;	}	filepath oldfile = item.filename;	string oldname = item.name;	filepath newfile = oldfile.parentdirectory.combine (newname + oldfile.extension);	if (!renameitemfile (oldfile, newfile)) return;	try {	item.name = newname;	item.needsreload = false;	if (item.filename != newfile) {	
file was renamed to instead of 

========================= monodevelop sample_1657 =========================

public changesignatureoptionsresult getchangesignatureoptions (isymbol symbol, parameterconfiguration parameters, inotificationservice notificationservice) {	var dialog = new signaturechangedialog ();	try {	dialog.init (symbol, parameters);	bool performchange = dialog.run () == (int)gtk.responsetype.ok;	if (!performchange) return cancelled;	return new changesignatureoptionsresult {	iscancelled = false, updatedsignature = new microsoft.codeanalysis.changesignature.signaturechange (parameters, parameterconfiguration.create (dialog.parameterlist, parameters.thisparameter != null)) };	} catch (exception ex) {	
error while signature changing 

========================= monodevelop sample_4072 =========================

if (gtknotebookvalue != null) result = new gtknotebookresult (gtknotebookvalue);	var gtktreeviewvalue = value as gtk.treeview;	if (gtktreeviewvalue != null && result == null) result = new gtktreemodelresult (gtktreeviewvalue, gtktreeviewvalue.model, 0);	var gtkwidgetvalue = value as gtk.widget;	if (gtkwidgetvalue != null && result == null) result = new gtkwidgetresult (gtkwidgetvalue);	#if mac var nsobjectvalue = value as foundation.nsobject;	if (nsobjectvalue != null && result == null) result = new nsobjectresult (nsobjectvalue);	#endif if (result == null) result = new objectresult (value);	propertiesobject.add (property.name, result, property);	} catch (exception e) {	
failed to fetch property on with exception 

========================= monodevelop sample_1535 =========================

public void stopbuffering () {	if (version.atleast (2, 34)) vm_stopbuffering ();	buffer_packets = false;	writepackets (buffered_packets);	if (enableconnectionlogging) {	
sent packets 

========================= monodevelop sample_6184 =========================

static void main(string[] args) {	
hello world 

========================= monodevelop sample_117 =========================

public async task projectserializationroundtrip () {	string solfile = util.getsampleproject ("msbuild-glob-tests", "glob-test.csproj");	foreach (var f in directory.getfiles (path.getdirectoryname (solfile), "*.csproj")) {	var p = await services.projectservice.readsolutionitem (util.getmonitor (), f);	var refxml = file.readalltext (p.filename);	await p.saveasync (util.getmonitor ());	await p.saveasync (util.getmonitor ());	var savedxml = file.readalltext (p.filename);	p.dispose ();	
serialization roundtrip test 

========================= monodevelop sample_350 =========================

public static void main (string[] args) {	for (int i = 0; i < 10; i++) {	
test 

========================= monodevelop sample_3974 =========================

protected override string ongetvalue () {	var style = base.ongetvalue ();	if (syntaxhighlightingservice.containsstyle (style)) return style;	var defaultstyle = syntaxhighlightingservice.getdefaultcolorstylename ();	
highlighting theme not found using default instead 

========================= monodevelop sample_1632 =========================

public static async task<bool> rename (isymbol symbol, string newname) {	if (symbol == null) throw new argumentnullexception ("symbol");	if (newname == null) throw new argumentnullexception ("newname");	try {	await new renamerefactoring ().performchangesasync (symbol, new renameproperties () { newname = newname });	return true;	} catch (aggregateexception ae) {	
exception while rename 

public static async task<bool> rename (isymbol symbol, string newname) {	if (symbol == null) throw new argumentnullexception ("symbol");	if (newname == null) throw new argumentnullexception ("newname");	try {	await new renamerefactoring ().performchangesasync (symbol, new renameproperties () { newname = newname });	return true;	} catch (aggregateexception ae) {	return false;	} catch (exception e) {	
exception while rename 

========================= monodevelop sample_3987 =========================

static void report (config cfg, string name, string[] args, int start, int count) {	list<string> instances = new list<string> ();	for (; start < args.length; ++start) instances.add (args [start]);	if (instances.count == 0) {	
need to provide instance names 

static void report (config cfg, string name, string[] args, int start, int count) {	list<string> instances = new list<string> ();	for (; start < args.length; ++start) instances.add (args [start]);	if (instances.count == 0) {	return;	}	counterset cset = cfg [name];	if (cset == null) {	
unknown counter set 

static void report (list<performancecounter> counters) {	string last_instance = null;	foreach (performancecounter c in counters) {	string instance = c.instancename;	if (last_instance != instance) {	
report for 

========================= monodevelop sample_9952 =========================

public void savesettings () {	if (settings == null) return;	try {	var doc = new xdocument ( new xelement ("root", shell.savehistory (), new xelement ("width", allocation.width), new xelement ("height", allocation.height), new xelement ("panevisible", panevisible ? 1 : 0), new xelement ("paneposition", hpaned.position)));	doc.save (settings, saveoptions.disableformatting);	} catch (exception e ) {	
oops 

protected override bool ondeleteevent (gdk.event args) {	if (!mainclass.attached){	
quitting 

========================= monodevelop sample_9843 =========================

public override nsdragoperation draggingentered (nsdragginginfo sender) {	
drag delegate received draggingentered 

public override bool performdragoperation (nsdragginginfo sender) {	
drag delegate received performdragoperation sender 

public override bool performdragoperation (nsdragginginfo sender) {	nsobject obj = sender.draggingsource;	if (obj != null && obj.equals (browserview)) {	
let the image browser handle it 

public override bool preparefordragoperation (nsdragginginfo sender) {	
drag delegate received preparefordragoperation 

public override void concludedragoperation (nsdragginginfo sender) {	
drag delegate received concludedragoperation 

public override void draggingexited (nsdragginginfo sender) {	
drag delegate received draggingexited 

public override void draggingended (nsdragginginfo sender) {	
drag delegate received draggingended 

========================= monodevelop sample_10881 =========================

private void conditionisok (object value) {	if (value is useisoperatortest) {	
ok 

private void conditionsplitbad (object value) {	useisoperatortest test = (value as useisoperatortest);	if (test != null) {	
bad 

private void conditionequalitybad (object value) {	if ((value as useisoperatortest) == null) {	
bad 

private void conditioninequalitybad (object value) {	if ((value as useisoperatortest) != null) {	
bad 

========================= monodevelop sample_10567 =========================

static void loadruntimes () {	if (!file.exists (configfile)) return;	try {	xmldataserializer ser = new xmldataserializer (new datacontext ());	using (streamreader sr = new streamreader (configfile)) {	customruntimes = (runtimecollection) ser.deserialize (sr, typeof(runtimecollection));	}	} catch (exception ex) {	
error while loading mono runtimes xml 

========================= monodevelop sample_2292 =========================

public static void main (string[] args) {	if (args.length != 1) {	
please specify one input file 

public static void main (string[] args) {	if (args.length != 1) {	return;	}	seekablelogfilereader reader = null;	try {	reader = new seekablelogfilereader (args [0]);	} catch (ioexception){	
it was not possible to open the file 

========================= monodevelop sample_9877 =========================

public static void main (string[] args) {	new myclass ();	
hello world 

========================= monodevelop sample_51 =========================

public void testsimplestring () {	string result = runcontextaction ( new splitstringaction (), "class testclass" + environment.newline + "{" + environment.newline + "	void test ()" + environment.newline + "	{" + environment.newline + "		system.console.writeline (\"hello$world\");" + environment.newline + "	}" + environment.newline + "}" );	
class testclass void test system console writeline 

public void testverbatimstring () {	string result = runcontextaction ( new splitstringaction (), "class testclass" + environment.newline + "{" + environment.newline + "	void test ()" + environment.newline + "	{" + environment.newline + "		system.console.writeline (@\"hello$world\");" + environment.newline + "	}" + environment.newline + "}" );	
class testclass void test system console writeline 

========================= monodevelop sample_8698 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_8449 =========================

try {	filetemplate t = loadfiletemplate (codon.addin, codon);	t.id = codon.id;	return t;	} catch (exception e) {	string extid = null, addinid = null;	if (codon != null) {	if (codon.hasid) extid = codon.id;	if (codon.addin != null) addinid = codon.addin.id;	}	
error loading template id in addin null null 

========================= monodevelop sample_1059 =========================

if (lastcat != cmd.category) {	console.writeline ();	console.writeline (cmd.category + ":");	lastcat = cmd.category;	}	string cc = cmd.commanddesc;	if (cc.length < 16) cc += new string (' ', 16 - cc.length);	console.writeline ("  " + cc + " " + cmd.description);	}	console.writeline ();	
run help command to get help about a specific command 

console.writeline ();	console.writeline ();	return;	}	else {	console.writeline ();	setupcommand cmd = findcommand (parms [0]);	if (cmd != null) {	console.writeline ("{0}: {1}", cmd.commanddesc, cmd.description);	console.writeline ();	
usage 

setupcommand cmd = findcommand (parms [0]);	if (cmd != null) {	console.writeline ("{0}: {1}", cmd.commanddesc, cmd.description);	console.writeline ();	console.writeline ();	textformatter fm = new textformatter ();	fm.wrap = wrappingtype.word;	fm.append (cmd.longdescription);	console.writeline (fm.tostring ());	}	
unknown command 

========================= monodevelop sample_11549 =========================

static int indexofversion (userdatamigrationnode node, string version) {	for (int i=0; i < userprofile.profileversions.length; i++) {	if (string.equals (userprofile.profileversions[i], version)) {	return i;	}	}	if (node != null) {	
migration in addin refers to unknown version 

filepath target = filepath.null;	try {	source = profile.getlocation (node.sourcekind).combine (node.sourcepath);	target = userprofile.current.getlocation (node.targetkind).combine (node.targetpath);	bool sourceisdirectory = directory.exists (source);	if (sourceisdirectory) {	if (directory.exists (target)) return;	} else {	if (file.exists (target) || directory.exists (target) || !file.exists (source)) return;	}	
migrating to 

========================= monodevelop sample_2350 =========================

public void logcommentfromtext (msbuildcontext buildeventcontext, messageimportance messageimportance, string message) {	
msbuild 

public void logfatalbuilderror (msbuildcontext buildeventcontext, exception e, string projectfile) {	
msbuild 

public void logwarning (string message) {	
msbuild 

public void logwarningfromtext (msbuildcontext bec, object p1, object p2, object p3, string projectfile, string warning) {	
msbuild 

========================= monodevelop sample_2172 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_20 =========================

public void testdisable() {	var input = baseinput + @" try {	f ();	} catch {	throw;	} finally {	
inside finally 

public void testonlyredundantcatches() {	var input = baseinput + @" try {	f ();	
inside try 

public void addsblockifneccessary() {	var input = baseinput + @" if (true) try {	f ();	
inside try 

public void testemptycatchwithfinally() {	var input = baseinput + @" try {	f ();	} catch {	throw;	} finally {	
inside finally 

public void testbug12273case2() {	var input = baseinput + @" try {	f ();	} catch (argumentoutofrangeexception) {	throw;	} catch {	
hello world 

========================= monodevelop sample_8578 =========================

notebook1.page = 0;	context = new comparecontext (reference_loader, target_loader);	context.progresschanged += delegate (object sender, compareprogresschangedeventargs e) {	application.invoke (delegate {	status = e.message;	progress = e.progress;	});	};	context.error += delegate (object sender, compareerroreventargs e) {	application.invoke (delegate {	
error 

========================= monodevelop sample_9857 =========================

private void addmethod () {	foreach (var method in class.methods) {	if(method.name==".ctor") continue;	try {	string key = method.fullname + " " + serializeparameters(method);	if(methods.containskey(key)) continue;	methods.add(key, new methodproperties(method));	methods[key].parentclass = this;	} catch (exception ex) {	
error 

private void addfield () {	if(fields==null) fields = new dictionary<string, fieldproperties>();	foreach (ifield field in class.fields) {	try {	fields.add(field.name, new fieldproperties(field));	} catch (exception ex) {	
error 

========================= monodevelop sample_4728 =========================

public void performsearchindexcreation () {	firesearchindexcreationevent (true);	try {	roottree.makesearchindex ();	} catch (exception e) {	
error making search index 

public void performsearchindexcreation () {	firesearchindexcreationevent (true);	try {	roottree.makesearchindex ();	} catch (exception e) {	}	try {	roottree.makeindex ();	} catch (exception e) {	
error making normal index 

========================= monodevelop sample_10700 =========================

public virtual void resolved(astnode node, resolveresult result) {	if (resolvednodes.containskey(node)) throw new invalidoperationexception("duplicate resolved() call");	resolvednodes.add(node, result);	if (csharpastresolver.isunresolvablenode(node)) throw new invalidoperationexception("resolved unresolvable node");	if (!parenthesizedexpression.actsasparenthesizedexpression(node)) if (!resolveresults.add(result) && result != errorresolveresult.unknownerror) throw new invalidoperationexception("duplicate resolve result");	if (result.iserror && !allowerrors) {	
compiler error at 

public virtual void processconversion(expression expression, resolveresult result, conversion conversion, itype targettype) {	if (!nodeswithconversions.add(expression)) throw new invalidoperationexception("duplicate processconversion() call");	if (!conversion.isvalid && !allowerrors) {	
compiler error at cannot convert from to 

public virtual void validate(csharpastresolver resolver, syntaxtree syntaxtree) {	foreach (astnode node in syntaxtree.descendantsandself.except(resolvednodes.keys)) {	if (!csharpastresolver.isunresolvablenode(node)) {	if (!node.ancestors.any(a => a is preprocessordirective)) {	
forgot to resolve 

public static void runtestwithoutunresolvedfile(csharpfile file) {	csharpastresolver resolver = new csharpastresolver(file.project.compilation, file.syntaxtree);	var navigator = new validatingresolveallnavigator(file.filename);	resolver.applynavigator(navigator, cancellationtoken.none);	navigator.validate(resolver, file.syntaxtree);	csharpastresolver originalresolver = new csharpastresolver(file.project.compilation, file.syntaxtree, file.unresolvedtypesystemforfile);	foreach (var node in file.syntaxtree.descendantsandself) {	var originalresult = originalresolver.resolve(node);	var result = resolver.resolve(node);	if (!randomizedorderresolvertest.isequalresolveresult(result, originalresult)) {	
got different without iunresolvedfile at 

========================= monodevelop sample_7982 =========================

settag (context, attstate.percent);	return null;	}	rollback = "<";	return parent;	case attstate.percent: if (c == '-') {	settag (context, attstate.percentdash);	return null;	}	if (c == '@') {	
invalid directive location 

return parent;	}	webformsexpressionstate.addexpressionnode (c, context);	settag (context, attstate.expression);	return null;	case attstate.percentdash: if (c == '-') {	context.nodes.push (new webformsservercomment (context.locationminus (4)));	settag (context, attstate.comment);	return null;	}	
malformed server comment 

========================= monodevelop sample_4889 =========================

public static void registerremotingchannel () {	if (!channelregistered) {	channelregistered = true;	idictionary formatterprops = new hashtable ();	formatterprops ["includeversions"] = false;	formatterprops ["strictbinding"] = false;	ichannel ch = channelservices.getchannel ("ipc");	if (ch != null) {	
ipc channel already registered an add in may have registered it 

binaryserverformattersinkprovider serverprovider = new binaryserverformattersinkprovider(formatterprops, null);	serverprovider.typefilterlevel = system.runtime.serialization.formatters.typefilterlevel.full;	disposerformattersinkprovider clientprovider = new disposerformattersinkprovider();	clientprovider.next = new binaryclientformattersinkprovider(formatterprops, null);	unixremotingfile = path.gettempfilename ();	idictionary dict = new hashtable ();	dict ["portname"] = path.getfilename (unixremotingfile);	channelservices.registerchannel (new ipcchannel (dict, clientprovider, serverprovider), false);	ch = channelservices.getchannel ("tcp");	if (ch != null) {	
tcp channel already registered an add in may have registered it 

========================= monodevelop sample_2057 =========================

show_gui = false;	if (v != null) mergeconfigfile = v;	else {	error ("missing config file for --merge-changes.");	r = 1;	}	} }, { "remote-mode", "accept crefs from stdin to display in the browser.\n" + "for monodevelop integration.", v => remote_mode = v != null }, { "about|version", "write version information and exit.", v => show_version = v != null }, { "h|?|help", "show this message and exit.", v => show_help = v != null }, };	list<string> topics = p.parse (args);	if (basedir == null) basedir = directory.getparent (system.reflection.assembly.getexecutingassembly ().location).fullname;	if (show_version) {	
mono documentation browser 

}	} }, { "remote-mode", "accept crefs from stdin to display in the browser.\n" + "for monodevelop integration.", v => remote_mode = v != null }, { "about|version", "write version information and exit.", v => show_version = v != null }, { "h|?|help", "show this message and exit.", v => show_help = v != null }, };	list<string> topics = p.parse (args);	if (basedir == null) basedir = directory.getparent (system.reflection.assembly.getexecutingassembly ().location).fullname;	if (show_version) {	version ver = assembly.getexecutingassembly ().getname ().version;	if (ver != null) console.writeline (ver.tostring ());	return r;	}	if (show_help) {	
usage monodoc html topic make index make search index merge changes change file target dir about edit path remote mode engine engine topic 

public browser (string basedir, ienumerable<string> sources, string engine) {	#if macos try {	initmacapphandlers();	} catch (exception ex) {	
installing mac appleevent handlers failed skipping 

} else {	createsearchpanel ();	}	booklist = new arraylist ();	index_browser = indexbrowser.makeindexbrowser (this);	mainwindow.showall();	#if macos try {	installmacmainmenu ();	((menubar)ui["menubar1"]).hide ();	} catch (exception ex) {	
installing mac ige main menu failed skipping 

public void loadurl (string url) {	if (url.startswith("#")) {	currenttab.html.jumptoanchor(url.substring(1));	return;	}	if (url.startswith ("edit:")) {	
node is 

if (url.startswith ("edit:")) {	currenttab.edit_node = editingutils.getnodefromurl (url, help_tree);	currenttab.edit_url = url;	currenttab.setmode (mode.editor);	currenttab.text_editor.buffer.text = currenttab.edit_node.innerxml;	return;	}	node node;	string[] urlparts = url.split (':');	if (urlparts [0].length == 1) url = urlparts [0].toupper () + url.substring (1);	
trying 

if (urlparts [0].length == 1) url = urlparts [0].toupper () + url.substring (1);	try {	string res = browser.gethtml (url, null, help_tree, out node);	if (res != null){	render (res, node, url);	currenttab.history.appendhistory (new linkpagevisit (this, url));	return;	}	} catch (exception e){	console.writeline("#########");	
error loading url excpetion below 

render (res, node, url);	currenttab.history.appendhistory (new linkpagevisit (this, url));	return;	}	} catch (exception e){	console.writeline("#########");	console.writeline("#########");	console.writeline(e);	}	console.error.writeline ("+----------------------------------------------+");	
here we should locate the provider for the 

render (res, node, url);	currenttab.history.appendhistory (new linkpagevisit (this, url));	return;	}	} catch (exception e){	console.writeline("#########");	console.writeline("#########");	console.writeline(e);	}	console.error.writeline ("+----------------------------------------------+");	
link maybe using this document as a base 

render (res, node, url);	currenttab.history.appendhistory (new linkpagevisit (this, url));	return;	}	} catch (exception e){	console.writeline("#########");	console.writeline("#########");	console.writeline(e);	}	console.error.writeline ("+----------------------------------------------+");	
maybe having a locator interface the short 

render (res, node, url);	currenttab.history.appendhistory (new linkpagevisit (this, url));	return;	}	} catch (exception e){	console.writeline("#########");	console.writeline("#########");	console.writeline(e);	}	console.error.writeline ("+----------------------------------------------+");	
urls are not very useful to locate types 

public void shownode (node n) {	if (node_to_iter [n] == null){	opentree (n);	if (node_to_iter [n] == null){	
internal error no node to iter mapping 

public static ihtmlrender getrenderer (string engine, browser browser) {	ihtmlrender renderer = loadrenderer (system.io.path.combine (appdomain.currentdomain.basedirectory, engine + "htmlrender.dll"), browser);	if (renderer != null) {	try {	if (renderer.initialize ()) {	
using 

} catch (exception ex) {	console.error.writeline (ex);	}	}	foreach (string backend in driver.engines) {	if (backend != engine) {	renderer = loadrenderer (system.io.path.combine (appdomain.currentdomain.basedirectory, backend + "htmlrender.dll"), browser);	if (renderer != null) {	try {	if (renderer.initialize ()) {	
using 

========================= monodevelop sample_9832 =========================

if (!file.exists (preferencesfilename)) return;	using (var streamreader = new streamreader (preferencesfilename)) {	xmltextreader reader = new xmltextreader (streamreader);	try {	reader.movetocontent ();	if (reader.localname != "properties") return;	xmldataserializer ser = new xmldataserializer (new datacontext ());	ser.serializationcontext.basefile = preferencesfilename;	userproperties = (propertybag)ser.deserialize (reader, typeof(propertybag));	} catch (exception e) {	
exception while loading user solution preferences 

}	xmltextwriter writer = null;	try {	directory.createdirectory (file.parentdirectory);	writer = new xmltextwriter (file, system.text.encoding.utf8);	writer.formatting = formatting.indented;	xmldataserializer ser = new xmldataserializer (new datacontext ());	ser.serializationcontext.basefile = file;	ser.serialize (writer, userprops, typeof(propertybag));	} catch (exception e) {	
could not save solution preferences 

========================= monodevelop sample_2006 =========================

gendarmefile = args [3];	include = (args [4] == "/i");	}	catch (indexoutofrangeexception e) {	}	string ext = (xmloutput) ? "xml" : "md";	fxcopfile = path.changeextension (fxcopfile, ext);	gendarmefile = path.changeextension (gendarmefile, ext);	if (!directory.exists (dirname)) error = true;	if (error) {	
usage fxcopmapbuilder dirname target wiki fxcopmapfile gendarmemapfile i 

include = (args [4] == "/i");	}	catch (indexoutofrangeexception e) {	}	string ext = (xmloutput) ? "xml" : "md";	fxcopfile = path.changeextension (fxcopfile, ext);	gendarmefile = path.changeextension (gendarmefile, ext);	if (!directory.exists (dirname)) error = true;	if (error) {	console.writeline ();	
i includes gendarme rules which were not mapped to any of fxcop rules to the output 

========================= monodevelop sample_9972 =========================

static string geticon (string filename) {	try {	icon = ideapp.services.projectservice.fileformats.getfileformats (filename, typeof(solution)).length > 0 ? "md-solution" : "md-workspace"; */ return system.io.path.getextension (filename) != ".mdw" ? "md-solution" : "md-workspace";	} catch (system.io.ioexception ex) {	
error building recent solutions list 

========================= monodevelop sample_1521 =========================

public void save (string file) {	foreach (dictionaryentry e in lists) {	stringcollection col = (stringcollection) e.value;	string s = "";	foreach (string v in col) s += v.replace (";", "\\;") + ";";	if (s.length > 0) entries [e.key] = s;	else entries.remove (e.key);	}	using (streamwriter sw = new streamwriter (file)) {	if (!isloadedfile) {	
desktop entry 

========================= monodevelop sample_4355 =========================

if (!exists) order.add (key);	dict [key] = value;	if (exists) onchildreplaced (key, existing, value);	else onchildadded (key, value);	}	}	public void add (string key, pobject value) {	try {	dict.add (key, value);	} catch (exception e) {	
error while adding 

public override readwritecontext startreading (stream input) {	var settings = new xmlreadersettings () {	closeinput = true, dtdprocessing = dtdprocessing.ignore, xmlresolver = null, };	xmlreader reader = null;	input.seek (0, seekorigin.begin);	try {	reader = xmlreader.create (input, settings);	reader.readtodescendant ("plist");	while (reader.read () && reader.nodetype != xmlnodetype.element) ;	} catch (exception ex) {	
exception 

protected override void write (pboolean boolean) {	
true false 

protected override void write (pnumber number) {	
integer integer 

protected override void write (preal real) {	
real real 

protected override void write (pdate date) {	
date date 

protected override void write (pdata data) {	
data data 

protected override void write (pstring str) {	
string string 

protected override void write (parray array) {	if (array.count == 0) {	
array 

protected override void write (parray array) {	if (array.count == 0) {	return;	}	
array 

protected override void write (parray array) {	if (array.count == 0) {	return;	}	increaseindent ();	foreach (var item in array) writeobject (item);	decreaseindent ();	
array 

protected override void write (pdictionary dict) {	if (dict.count == 0) {	
dict 

protected override void write (pdictionary dict) {	if (dict.count == 0) {	return;	}	
dict 

protected override void write (pdictionary dict) {	if (dict.count == 0) {	return;	}	increaseindent ();	foreach (var kv in dict) {	
key key 

protected override void write (pdictionary dict) {	if (dict.count == 0) {	return;	}	increaseindent ();	foreach (var kv in dict) {	writeobject (kv.value);	}	decreaseindent ();	
dict 

========================= monodevelop sample_1570 =========================

public static void ignore (this task task) {	task.continuewith (t => {	
async operation failed 

========================= monodevelop sample_1851 =========================

public override xmlparserstate pushchar (char c, ixmlparsercontext context, ref string rollback) {	var namedobject = context.nodes.peek () as inamedxobject;	if (namedobject == null || namedobject.name.prefix != null) throw new invalidoperationexception ("invalid state");	debug.assert (context.currentstatelength > 1 || isvalidnamestart (c), "first character pushed to a xmltagnamestate must be a letter.");	debug.assert (context.currentstatelength > 1 || context.keywordbuilder.length == 0, "keyword builder must be empty when state begins.");	if (xmlchar.iswhitespace (c) || c == '<' || c == '>' || c == '/' || c == '=') {	rollback = string.empty;	if (context.keywordbuilder.length == 0) {	
zero length name 

int i = s.indexof (':');	if (i < 0) {	namedobject.name = new xname (s);	} else {	namedobject.name = new xname (s.substring (0, i), s.substring (i + 1));	}	}	return parent;	}	if (c == ':') {	
unexpected in name 

}	if (c == ':') {	context.keywordbuilder.append (c);	return null;	}	if (xmlchar.isnamechar (c)) {	context.keywordbuilder.append (c);	return null;	}	rollback = string.empty;	
unexpected character in name 

========================= monodevelop sample_3486 =========================

return;	} else if (result == certificatecheckresult.error) {	return;	}	if (confirmtrustcertificate (result)) {	await dotnetcoredevcertstool.trustcertificate (monitor.cancellationtoken);	}	} catch (operationcanceledexception) {	throw;	} catch (exception ex) {	
error trusting development certificate 

========================= monodevelop sample_4270 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_166 =========================

public void testcreateindexer(string input, string output) {	string result = runcontextaction(new createindexeraction(), homogenizeeol(input));	output = homogenizeeol(output);	bool passed = result == output;	if (!passed) {	
expected 

public void testcreateindexer(string input, string output) {	string result = runcontextaction(new createindexeraction(), homogenizeeol(input));	output = homogenizeeol(output);	bool passed = result == output;	if (!passed) {	console.writeline(output);	
got 

========================= monodevelop sample_7019 =========================

svnadmin.start ();	svnadmin.waitforexit ();	if (svnserve != null) {	info = new processstartinfo ();	info.filename = "svnserve";	info.arguments = "-dr " + remotepath;	info.windowstyle = processwindowstyle.hidden;	svnserve.startinfo = info;	svnserve.start ();	using (var perm = file. createtext (remotepath.combine("repo", "conf", "svnserve.conf"))) {	
general 

svnadmin.waitforexit ();	if (svnserve != null) {	info = new processstartinfo ();	info.filename = "svnserve";	info.arguments = "-dr " + remotepath;	info.windowstyle = processwindowstyle.hidden;	svnserve.startinfo = info;	svnserve.start ();	using (var perm = file. createtext (remotepath.combine("repo", "conf", "svnserve.conf"))) {	perm.writeline ("anon-access = write");	
sasl 

========================= monodevelop sample_4112 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_204 =========================

var diagnostic = await data.todiagnosticasync (analysisdocument, cancellationtoken, desc);	resultlist.add (new diagnosticresult (diagnostic));	}	return resultlist;	} catch (operationcanceledexception) {	return enumerable.empty<result> ();	} catch (aggregateexception ae) {	ae.flatten ().handle (ix => ix is operationcanceledexception);	return enumerable.empty<result> ();	} catch (exception e) {	
error while running diagnostics 

========================= monodevelop sample_4003 =========================

}");	addoption (indentationoptions, "indentswitchcasesection", gettextcatalog.getstring ("indent case sections"), @"class aclass {	void method(int x) {	switch (x) {	case 1: break;	}	}	}");	addoption (indentationoptions, "labelpositioning", gettextcatalog.getstring ("label indentation"), @"class test {	void method() {	
hello world 

========================= monodevelop sample_3970 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_185 =========================

intptr localpool = intptr.zero;	try {	localpool = trystartoperation (monitor);	intptr array = normalizepaths (localpool, paths);	intptr commit_info = intptr.zero;	commitmessage = message;	checkerror (svn.client_commit (ref commit_info, array, false, ctx, localpool));	unsafe {	if (commit_info != intptr.zero) {	monitor.log.writeline ();	
revision 

========================= monodevelop sample_4102 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_176 =========================

public void ifelsecase() {	test<useasandnullcheckcoderefactoringprovider>(@" class bar {	public bar baz (object foo) {	if (foo $is bar) {	baz ((bar)foo);	return (bar)foo;	} else {	
hello 

return null;	}	}	", @" class bar {	public bar baz (object foo) {	var bar = foo as bar;	if (bar != null) {	baz (bar);	return bar;	} else {	
hello 

========================= monodevelop sample_7009 =========================

static void main (string[] args) {	nsapplication.init();	using(new nsautoreleasepool()) {	string[] interfaces = cwinterface.supportedinterfaces;	if(interfaces.length<1){	
no supported interface is available in this computer 

static void main (string[] args) {	nsapplication.init();	using(new nsautoreleasepool()) {	string[] interfaces = cwinterface.supportedinterfaces;	if(interfaces.length<1){	return;	}	cwinterface selectedintface = cwinterface.fromname (interfaces[0]);	
interface information name active ssid active bssid 

nsapplication.init();	using(new nsautoreleasepool()) {	string[] interfaces = cwinterface.supportedinterfaces;	if(interfaces.length<1){	return;	}	cwinterface selectedintface = cwinterface.fromname (interfaces[0]);	nserror error;	cwnetwork[] data = selectedintface.scanfornetworkswithparameters(null, out error);	if(error!=null){	
an error occurred while scanning for available networks 

========================= monodevelop sample_11064 =========================

generatecomment (new codecomment (" <autogenerated>"));	generatecomment (new codecomment ("     this code was generated by a tool."));	generatecomment (new codecomment ("     mono runtime version: " + system.environment.version));	generatecomment (new codecomment (""));	generatecomment (new codecomment ("     changes to this file may cause incorrect behavior and will be lost if "));	generatecomment (new codecomment ("     the code is regenerated."));	generatecomment (new codecomment (" </autogenerated>"));	generatecomment (new codecomment ("------------------------------------------------------------------------------"));	output.writeline ();	if (asbool(compileunit.userdata["allowlatebound"])) {	
option explicit requirevariabledeclaration 

generatecomment (new codecomment (" <autogenerated>"));	generatecomment (new codecomment ("     this code was generated by a tool."));	generatecomment (new codecomment ("     mono runtime version: " + system.environment.version));	generatecomment (new codecomment (""));	generatecomment (new codecomment ("     changes to this file may cause incorrect behavior and will be lost if "));	generatecomment (new codecomment ("     the code is regenerated."));	generatecomment (new codecomment (" </autogenerated>"));	generatecomment (new codecomment ("------------------------------------------------------------------------------"));	output.writeline ();	if (asbool(compileunit.userdata["allowlatebound"])) {	
option strict off 

generatecomment (new codecomment ("     this code was generated by a tool."));	generatecomment (new codecomment ("     mono runtime version: " + system.environment.version));	generatecomment (new codecomment (""));	generatecomment (new codecomment ("     changes to this file may cause incorrect behavior and will be lost if "));	generatecomment (new codecomment ("     the code is regenerated."));	generatecomment (new codecomment (" </autogenerated>"));	generatecomment (new codecomment ("------------------------------------------------------------------------------"));	output.writeline ();	if (asbool(compileunit.userdata["allowlatebound"])) {	} else {	
option explicit on 

generatecomment (new codecomment ("     this code was generated by a tool."));	generatecomment (new codecomment ("     mono runtime version: " + system.environment.version));	generatecomment (new codecomment (""));	generatecomment (new codecomment ("     changes to this file may cause incorrect behavior and will be lost if "));	generatecomment (new codecomment ("     the code is regenerated."));	generatecomment (new codecomment (" </autogenerated>"));	generatecomment (new codecomment ("------------------------------------------------------------------------------"));	output.writeline ();	if (asbool(compileunit.userdata["allowlatebound"])) {	} else {	
option strict on 

protected override void generateiterationstatement (codeiterationstatement statement) {	textwriter output = output;	generatestatement (statement.initstatement);	output.write ("do while ");	generateexpression (statement.testexpression);	output.writeline ();	indent++;	generatestatements (statement.statements);	generatestatement (statement.incrementstatement);	indent--;	
loop 

protected override void generatemethodreturnstatement (codemethodreturnstatement statement) {	textwriter output = output;	if (statement.expression != null) {	output.write ("return ");	generateexpression (statement.expression);	output.writeline ();	} else {	
return 

protected override void generateconditionstatement (codeconditionstatement statement) {	textwriter output = output;	output.write ("if ");	generateexpression (statement.condition);	
then 

protected override void generateconditionstatement (codeconditionstatement statement) {	textwriter output = output;	output.write ("if ");	generateexpression (statement.condition);	++indent;	generatestatements (statement.truestatements);	--indent;	codestatementcollection falses = statement.falsestatements;	if (falses.count > 0) {	
else 

++indent;	generatestatements (statement.truestatements);	--indent;	codestatementcollection falses = statement.falsestatements;	if (falses.count > 0) {	++indent;	generatestatements (falses);	--indent;	}	else {	
else 

generatestatements (statement.truestatements);	--indent;	codestatementcollection falses = statement.falsestatements;	if (falses.count > 0) {	++indent;	generatestatements (falses);	--indent;	}	else {	}	
end if 

protected override void generatetrycatchfinallystatement (codetrycatchfinallystatement statement) {	textwriter output = output;	
try 

foreach (codecatchclause clause in statement.catchclauses) {	output.write ("catch ");	outputtypenamepair (clause.catchexceptiontype, clause.localname);	output.writeline ();	++indent;	generatestatements (clause.statements);	--indent;	}	codestatementcollection finallies = statement.finallystatements;	if (finallies.count > 0) {	
finally 

++indent;	generatestatements (clause.statements);	--indent;	}	codestatementcollection finallies = statement.finallystatements;	if (finallies.count > 0) {	++indent;	generatestatements (finallies);	--indent;	}	
end try 

protected override void generatelinepragmaend (codelinepragma linepragma) {	
end externalsource 

protected override void generateentrypointmethod (codeentrypointmethod method, codetypedeclaration declaration) {	#if net_2_0 outputattributes (method.customattributes, null, linehandling.continueline);	
public shared sub main 

protected override void generateentrypointmethod (codeentrypointmethod method, codetypedeclaration declaration) {	#if net_2_0 outputattributes (method.customattributes, null, linehandling.continueline);	indent++;	generatestatements (method.statements);	indent--;	
end sub 

outputtype (method.privateimplementationtype);	output.write ('.');	output.write (method.name);	}	output.writeline ();	if (!iscurrentinterface) {	if ((attributes & memberattributes.scopemask) != memberattributes.abstract) {	++indent;	generatestatements (method.statements);	--indent;	
end sub 

outputtype (method.privateimplementationtype);	output.write ('.');	output.write (method.name);	}	output.writeline ();	if (!iscurrentinterface) {	if ((attributes & memberattributes.scopemask) != memberattributes.abstract) {	++indent;	generatestatements (method.statements);	--indent;	
end function 

} else if (property.privateimplementationtype != null) {	output.write (" implements ");	outputtype (property.privateimplementationtype);	output.write ('.');	output.write (property.name);	}	output.writeline ();	if (!iscurrentinterface) {	++indent;	if (property.hasget) {	
get 

output.write ('.');	output.write (property.name);	}	output.writeline ();	if (!iscurrentinterface) {	++indent;	if (property.hasget) {	++indent;	generatestatements (property.getstatements);	--indent;	
end get 

}	output.writeline ();	if (!iscurrentinterface) {	++indent;	if (property.hasget) {	++indent;	generatestatements (property.getstatements);	--indent;	}	if (property.hasset) {	
set 

++indent;	if (property.hasget) {	++indent;	generatestatements (property.getstatements);	--indent;	}	if (property.hasset) {	++indent;	generatestatements (property.setstatements);	--indent;	
end set 

++indent;	generatestatements (property.getstatements);	--indent;	}	if (property.hasset) {	++indent;	generatestatements (property.setstatements);	--indent;	}	--indent;	
end property 

outputexpressionlist (ctorargs);	output.writeline (")");	} else {	ctorargs = constructor.baseconstructorargs;	if (ctorargs.count > 0) {	output.write ("mybase.new(");	outputexpressionlist (ctorargs);	output.writeline (")");	#if net_2_0 } else if (iscurrentclass) {	#else } else {	
mybase new 

if (ctorargs.count > 0) {	output.write ("mybase.new(");	outputexpressionlist (ctorargs);	output.writeline (")");	#if net_2_0 } else if (iscurrentclass) {	#else } else {	}	}	generatestatements (constructor.statements);	indent--;	
end sub 

protected override void generatetypeconstructor (codetypeconstructor constructor) {	if (iscurrentdelegate || iscurrentenum || iscurrentinterface) {	return;	}	#if net_2_0 outputattributes (constructor.customattributes, null, linehandling.continueline);	
shared sub new 

protected override void generatetypeconstructor (codetypeconstructor constructor) {	if (iscurrentdelegate || iscurrentenum || iscurrentinterface) {	return;	}	#if net_2_0 outputattributes (constructor.customattributes, null, linehandling.continueline);	indent++;	generatestatements (constructor.statements);	indent--;	
end sub 

protected override void generatenamespaceend (codenamespace ns) {	string name = ns.name;	if (name != null && name != string.empty) {	--indent;	
end namespace 

========================= monodevelop sample_4076 =========================

rollback = string.empty;	return parent;	}	context.statetag = gettingeq;	}	else if (context.previousstate is xmlattributevaluestate) {	context.nodes.pop ();	att.end (context.locationminus (1));	iattributedxobject element = (iattributedxobject) context.nodes.peek ();	if (element.attributes.get (att.name, false) != null) {	
is a duplicate attribute name 

return null;	}	context.logerror ("expecting = in attribute, got '" + c + "'.");	} else if (context.statetag == gettingval) {	if (char.iswhitespace (c)) {	return null;	}	rollback = string.empty;	return attributevaluestate;	} else if (c != '<') {	
unexpected character in attribute 

========================= monodevelop sample_3496 =========================

}	#if dbg public bool debug {	get {	if (_regex == null) return false;	return _regex.debug;	}	}	internal virtual void dump() {	int i,j;	for (i = 0; i < _matchcount.length; i++) {	
capnum 

========================= monodevelop sample_1602 =========================

protected override void onreadsolution (progressmonitor monitor, monodevelop.projects.msbuild.slnfile file) {	base.onreadsolution (monitor, file);	try {	makefiledata.resolveprojectreferences (solution.rootfolder, monitor);	} catch (exception e) {	
error resolving makefile based project references for solution 

protected override void onwriteproject (progressmonitor monitor, monodevelop.projects.msbuild.msbuildproject msproject) {	base.onwriteproject (monitor, msproject);	if (data == null) return;	msproject.setmonodevelopprojectextension ("monodevelop.autotools.makefileinfo", data.write ());	if (!data.supportsintegration) return;	try {	data.updatemakefile (monitor);	} catch (exception e) {	
error saving to makefile for project 

protected async override task onexecute (progressmonitor monitor, executioncontext context, configurationselector configuration, solutionitemrunconfiguration runconfiguration) {	if (data == null || !data.supportsintegration || string.isnullorempty (data.executetargetname)) {	await base.onexecute (monitor, context, configuration, runconfiguration);	return;	}	operationconsole console = context.consolefactory.createconsole ( operationconsolefactory.createconsoleoptions.default.withtitle (project.name));	monitor.begintask (gettextcatalog.getstring ("executing {0}", project.name), 1);	try {	processwrapper process = runtime.processservice.startprocess ("make", data.executetargetname, project.basedirectory, console.out, console.error, null);	await process.task;	
the application exited with code 

========================= monodevelop sample_2387 =========================

if (reader.movetoattribute ("ingac") && reader.readattributevalue ()) ainfo.ingac = reader.readcontentasboolean ();	} while (reader.readtofollowing ("file"));	} else if (directory.exists (dir)) {	foreach (var f in directory.enumeratefiles (dir, "*.dll")) {	try {	var an = systemassemblyservice.getassemblynameobj (dir.combine (f));	var ainfo = new assemblyinfo ();	ainfo.update (an);	assemblies.add (ainfo);	} catch (badimageformatexception ex) {	
invalid assembly in framework 

} while (reader.readtofollowing ("file"));	} else if (directory.exists (dir)) {	foreach (var f in directory.enumeratefiles (dir, "*.dll")) {	try {	var an = systemassemblyservice.getassemblynameobj (dir.combine (f));	var ainfo = new assemblyinfo ();	ainfo.update (an);	assemblies.add (ainfo);	} catch (badimageformatexception ex) {	} catch (exception ex) {	
error reading assembly in framework 

========================= monodevelop sample_2296 =========================

}	foreach (code code in casts) {	casts.set (code);	throwers.set (code);	}	throwers.set (code.throw);	foreach (code code in overflow) {	throwers.set (code);	overflow.set (code);	}	
throwers 

}	foreach (code code in casts) {	casts.set (code);	throwers.set (code);	}	throwers.set (code.throw);	foreach (code code in overflow) {	throwers.set (code);	overflow.set (code);	}	
alwaysbad 

}	foreach (code code in casts) {	casts.set (code);	throwers.set (code);	}	throwers.set (code.throw);	foreach (code code in overflow) {	throwers.set (code);	overflow.set (code);	}	
overflow 

}	foreach (code code in casts) {	casts.set (code);	throwers.set (code);	}	throwers.set (code.throw);	foreach (code code in overflow) {	throwers.set (code);	overflow.set (code);	}	
casts 

========================= monodevelop sample_10590 =========================

public abstract control getsectionwidget ();	public async task<bool> addtoproject (cancellationtoken token) {	this.notifyaddingtoproject ();	var result = false;	try {	result = await this.onaddtoproject (token).configureawait (false);	} catch (exception ex) {	
could not add configuration 

========================= monodevelop sample_4678 =========================

public static void showhelp (optionset p) {	
usage it gsharp agent filen 

interactivegraphicsbase.mainwindow = m;	interactivegraphicsbase.panecontainer = m.panecontainer;	m.title = title;	m.loadstartupfiles ();	if (files != null) m.loadfiles (files, false);	m.showall ();	if (!hosthasgtkrunning){	try {	glib.exceptionmanager.unhandledexception += delegate (glib.unhandledexceptionargs a) {	resetoutput ();	
application terminating 

========================= monodevelop sample_9847 =========================

public static bool logonuser (string lpszusername, string lpszdomain, string lpszpassword, int dwlogontype, int dwlogonprovider, out intptr phtoken) {	
logonuser called 

public static bool duplicatetoken (intptr existingtokenhandle, int security_impersonation_level, out intptr duplicatetokenhandle) {	
duplicatetoken called 

public static intptr sendmessage(intptr hwnd, int msg, intptr wparam, string lparam) {	
sendmessage called 

public static short getkeystate (int nvirtkey) {	
getkeystate called 

public static long getvolumeinformation (string pathname, stringbuilder volumenamebuffer, int volumenamesize, out uint volumeserialnumber, out uint maximumcomponentlength, out uint filesystemflags, stringbuilder filesystemnamebuffer, uint filesystemnamesize) {	
getvolumeinformation called 

public static bool closehandle (intptr hobject) {	
closehandle called 

public static bool queryperformancecounter (out long performancecount) {	
queryperformancecounter called 

public static execution_state setthreadexecutionstate (execution_state esflags) {	
setthreadexecutionstate called 

public static bool setlocaltime (ref systemtime lpsystemtime) {	
setlocaltime called 

public static intptr createfile (string lpfilename, uint dwdesiredaccess, uint dwsharemode, intptr securityattributes, uint dwcreationdisposition, uint dwflagsandattributes, intptr htemplatefile) {	
createfile called 

public static bool readfile (intptr hfile, byte[] lpbuffer, uint nnumberofbytestoread, out uint lpnumberofbytesread, intptr lpoverlapped) {	
readfile called 

public static bool writefile(intptr hfile, byte [] lpbuffer, uint nnumberofbytestowrite, out uint lpnumberofbyteswritten, intptr lpoverlapped) {	
writefile called 

public static bool flushfilebuffers (intptr hfile) {	
flushfilebuffers called 

public static bool setcommtimeouts (intptr hfile, ref commtimeouts lpcommtimeouts) {	
setcommtimeouts called 

public static bool setupcomm (intptr hfile, uint dwinqueue, uint dwoutqueue) {	
setupcomm called 

public static bool purgecomm (intptr hfile, uint dwflags) {	
purgecomm called 

public static bool getcommstate (intptr hfile, ref dcb lpdcb) {	
getcommstate called 

public static bool setcommstate(intptr hfile, ref dcb lpdcb) {	
setcommstate called 

========================= monodevelop sample_9816 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_61 =========================

public void invocationscountduringexpandingtest () {	var mutablefieldclass = new mutablefieldclass ();	
invocationscountduringexpandingtest breakpoint 

public void methodwithtypegenericargseval () {	var a = new a("just a");	var wrappeda = new wrapper<a>(new a("wrappeda"));	var genericclass = new genericclass<a>(new a("constructor arg a"));	
break for methodwithtypegenericargseval 

========================= monodevelop sample_6028 =========================

xmldocument doc = loadfeedbackdoc ();	if (doc.documentelement == null) doc.appendchild (doc.createelement ("feedbacks"));	var f = doc.createelement ("feedback");	f.setattribute ("email", email);	f.innertext = body;	doc.documentelement.appendchild (f);	try {	if (!directory.exists (feedbackfile.parentdirectory)) directory.createdirectory (feedbackfile.parentdirectory);	doc.save (feedbackfile);	} catch (exception ex) {	
could not save feedback file 

static xmldocument loadfeedbackdoc () {	xmldocument doc = new xmldocument ();	try {	if (file.exists (feedbackfile)) doc.load (feedbackfile);	} catch (exception ex) {	
could not load feedback file 

static void handleresponse (task<httpwebresponse> t) {	try {	webresponse resp = t.result;	string result;	using (var sr = new streamreader (resp.getresponsestream ())) result = sr.readtoend ();	if (result != "ok") throw new exception (result);	}	catch (exception ex) {	
feedback submission failed 

string result;	using (var sr = new streamreader (resp.getresponsestream ())) result = sr.readtoend ();	if (result != "ok") throw new exception (result);	}	catch (exception ex) {	lock (sendinglock) {	sending = false;	}	return;	}	
feedback successfully sent 

========================= monodevelop sample_1648 =========================

public override void visit(membercore member) {	
unknown member 

public override void visit(membercore member) {	
member 

newtype.addchild(identifier.create(e.membername.name, convert(e.membername.location)), roles.identifier);	if (e.basetypeexpression != null) {	if (location != null && curloc < location.count) newtype.addchild(new csharptokennode(convert(location [curloc++]), roles.colon), roles.colon);	newtype.addchild(converttotype(e.basetypeexpression), roles.basetype);	}	if (location != null && curloc < location.count) newtype.addchild(new csharptokennode(convert(location [curloc++]), roles.lbrace), roles.lbrace);	typestack.push(newtype);	foreach (var m in e.members) {	var member = m as enummember;	if (member == null) {	
warning enum member 

static void addmodifiers(entitydeclaration parent, locationsbag.memberlocations location) {	if (location == null || location.modifiers == null) return;	foreach (var modifier in location.modifiers) {	modifiers mod;	if (!modifiertable.trygetvalue(modifier.item1, out mod)) {	
modifier can t be converted 

public override object visit(icsharpcode.nrefactory.monocsharp.statement stmt) {	
unknown statement 

public override object visit(icsharpcode.nrefactory.monocsharp.expression expression) {	
visit unknown expression 

========================= monodevelop sample_9165 =========================

public void refresh () {	try {	cancelcurrentrefresh ();	getpackagedependencies ();	} catch (exception ex) {	
refresh packages folder error 

========================= monodevelop sample_2555 =========================

data.counters = counters;	data.categories = categories;	filepath path = file + ".tmp";	using (stream fs = file.openwrite (path)) {	binaryformatter f = new binaryformatter ();	f.serialize (fs, data);	}	fileservice.systemrename (path, file);	}	} catch (exception ex) {	
instrumentation service data could not be saved 

========================= monodevelop sample_2039 =========================

public void runaction (action<texteditordata> action) {	try {	action (gettexteditordata ());	} catch (exception e) {	if (debugger.isattached) debugger.break ();	
error while executing 

========================= monodevelop sample_4475 =========================

public void testnullcoalescing() {	
class foo sub bar i as object j as object console writeline if i j end sub end class 

public void testunaryexpression() {	
class foo sub bar a as boolean b as boolean console writeline not a and b end sub end class class foo sub bar a as boolean b as boolean console writeline not a or not b end sub end class 

========================= monodevelop sample_6800 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_89 =========================

public void run () {	
hello world 

========================= monodevelop sample_11453 =========================

public static int main (string [] args) {	filegenerator[] generators = new filegenerator[]{	new headerfilegenerator (), new sourcefilegenerator (), new convertfilegenerator (), new convertdocfilegenerator (), };	configuration config = new configuration ();	bool exit = false;	try {	exit = !config.parse (args);	}	catch (exception e) {	
error 

protected static void writeheader (streamwriter s, string assembly, bool noconfig) {	
this file was automatically generated by create native map from do not modify 

protected static void writeheader (streamwriter s, string assembly, bool noconfig) {	if (!noconfig) {	
ifdef have config h 

protected static void writeheader (streamwriter s, string assembly, bool noconfig) {	if (!noconfig) {	
include config h 

protected static void writeheader (streamwriter s, string assembly, bool noconfig) {	if (!noconfig) {	
endif ndef have config h 

protected static void writemacrodefinition (textwriter writer, string macro) {	if (macro == null || macro.length == 0) return;	string[] val = macro.split ('=');	
ifndef 

protected static void writemacrodefinition (textwriter writer, string macro) {	if (macro == null || macro.length == 0) return;	string[] val = macro.split ('=');	
define 

protected static void writemacrodefinition (textwriter writer, string macro) {	if (macro == null || macro.length == 0) return;	string[] val = macro.split ('=');	
endif ndef 

protected static void writeincludedeclaration (textwriter writer, string inc) {	if (inc == null || inc.length == 0) return;	match m = includeregex.match (inc);	if (!m.groups ["include"].success) {	
warning invalid publicincludefile 

protected static void writeincludedeclaration (textwriter writer, string inc) {	if (inc == null || inc.length == 0) return;	match m = includeregex.match (inc);	if (!m.groups ["include"].success) {	return;	}	if (m.success && m.groups ["autoheader"].success) {	string i = m.groups ["includefile"].value;	string def = "have_" + i.toupper ().replace ("/", "_").replace (".", "_");	
ifdef 

protected static void writeincludedeclaration (textwriter writer, string inc) {	if (inc == null || inc.length == 0) return;	match m = includeregex.match (inc);	if (!m.groups ["include"].success) {	return;	}	if (m.success && m.groups ["autoheader"].success) {	string i = m.groups ["includefile"].value;	string def = "have_" + i.toupper ().replace ("/", "_").replace (".", "_");	
include include 

protected static void writeincludedeclaration (textwriter writer, string inc) {	if (inc == null || inc.length == 0) return;	match m = includeregex.match (inc);	if (!m.groups ["include"].success) {	return;	}	if (m.success && m.groups ["autoheader"].success) {	string i = m.groups ["includefile"].value;	string def = "have_" + i.toupper ().replace ("/", "_").replace (".", "_");	
endif ndef 

protected static void writeincludedeclaration (textwriter writer, string inc) {	if (inc == null || inc.length == 0) return;	match m = includeregex.match (inc);	if (!m.groups ["include"].success) {	return;	}	if (m.success && m.groups ["autoheader"].success) {	string i = m.groups ["includefile"].value;	string def = "have_" + i.toupper ().replace ("/", "_").replace (".", "_");	}	
include include 

public override void createfile (string assembly_name, string file_prefix) {	sh = file.createtext (file_prefix + ".h");	file_prefix = file_prefix.replace ("../", "").replace ("/", "_");	this.assembly_file = assembly_name = path.getfilename (assembly_name);	writeheader (sh, assembly_name, true);	assembly_name = assembly_name.replace (".dll", "").replace (".", "_");	
ifndef inc h 

public override void createfile (string assembly_name, string file_prefix) {	sh = file.createtext (file_prefix + ".h");	file_prefix = file_prefix.replace ("../", "").replace ("/", "_");	this.assembly_file = assembly_name = path.getfilename (assembly_name);	writeheader (sh, assembly_name, true);	assembly_name = assembly_name.replace (".dll", "").replace (".", "_");	
define inc h 

public override void createfile (string assembly_name, string file_prefix) {	sh = file.createtext (file_prefix + ".h");	file_prefix = file_prefix.replace ("../", "").replace ("/", "_");	this.assembly_file = assembly_name = path.getfilename (assembly_name);	writeheader (sh, assembly_name, true);	assembly_name = assembly_name.replace (".dll", "").replace (".", "_");	
include glib h 

public override void createfile (string assembly_name, string file_prefix) {	sh = file.createtext (file_prefix + ".h");	file_prefix = file_prefix.replace ("../", "").replace ("/", "_");	this.assembly_file = assembly_name = path.getfilename (assembly_name);	writeheader (sh, assembly_name, true);	assembly_name = assembly_name.replace (".dll", "").replace (".", "_");	
g begin decls 

public override void writeassemblyattributes (assembly assembly) {	
public macros 

public override void writeassemblyattributes (assembly assembly) {	foreach (string def in configuration.publicmacros) {	writemacrodefinition (sh, def);	}	sh.writeline ();	
public includes 

public override void writeassemblyattributes (assembly assembly) {	foreach (string def in configuration.publicmacros) {	writemacrodefinition (sh, def);	}	sh.writeline ();	foreach (string inc in configuration.publicheaders) {	writeincludedeclaration (sh, inc);	}	sh.writeline ();	
enumerations 

private void writeenum (type t, string ns, string fn) {	if (!canmaptype (t) || !t.isenum) return;	string etype = maputils.getnativetype (t);	writeliteralvalues (sh, t, fn);	
int from x r 

private void writeenum (type t, string ns, string fn) {	if (!canmaptype (t) || !t.isenum) return;	string etype = maputils.getnativetype (t);	writeliteralvalues (sh, t, fn);	
int to x r 

========================= monodevelop sample_9839 =========================

public void reportwarning (string message) {	
warning 

========================= monodevelop sample_11645 =========================

public void preservesbody() {	test<removeredundantcatchtypeaction>(@" class testclass {	public void f() {	try {	}	catch $(system.exception e) {	
hi 

public void f() {	try {	}	catch $(system.exception e) {	}	}	}", @" class testclass {	public void f() {	try {	} catch {	
hi 

========================= monodevelop sample_8765 =========================

public void addmethodlists(ilist<methodlistwithdeclaringtype> methodlists) {	if (methodlists == null) throw new argumentnullexception("methodlists");	bool[] ishiddenbyderivedtype;	if (methodlists.count > 1) ishiddenbyderivedtype = new bool[methodlists.count];	else ishiddenbyderivedtype = null;	for (int i = methodlists.count - 1; i >= 0; i--) {	if (ishiddenbyderivedtype != null && ishiddenbyderivedtype[i]) {	
skipping methods in because they are hidden by an applicable method in a derived type 

========================= monodevelop sample_9409 =========================

var alloc = allocation;	using (var cr = cairohelper.create (evnt.window)) {	cr.translate (alloc.x, alloc.y);	cr.translate (xexpandedoffset * (1 - scale), yexpandedoffset * (1 - scale));	var scalex = (alloc.width / userspacearea.width - 1) * scale + 1;	var scaley = (alloc.height / userspacearea.height - 1) * scale + 1;	cr.scale (scalex, scaley);	draw (cr, userspacearea);	}	} catch (exception e) {	
exception in animation 

========================= monodevelop sample_4632 =========================

protected string runcontextaction (codeactionprovider action, string input, int actionindex = 0, bool expecterrors = false) {	var context = testrefactoringcontext.create (input, expecterrors);	context.formattingoptions = formattingoptions;	bool isvalid = action.getactions (context).any ();	
invalid node is 

protected void testwrongcontext (codeactionprovider action, string input) {	var context = testrefactoringcontext.create (input);	context.formattingoptions = formattingoptions;	bool isvalid = action.getactions (context).any ();	
valid node is 

========================= monodevelop sample_8775 =========================

public async task<bool> addtoproject () {	if (this.getisaddedtoproject()) {	
skipping adding of the service it has already been added 

return true;	}	this.changestatus (status.adding);	try {	await this.adddependencies (cancellationtoken.none).configureawait (false);	await this.onaddtoproject ().configureawait (false);	await this.storeaddedstate ().configureawait (false);	this.changestatus (this.getisaddedtoproject() ? status.added : status.notadded);	return true;	} catch (exception ex) {	
an error occurred while adding the service to the project 

public async task<bool> removefromproject () {	if (!this.getisaddedtoproject()) {	
skipping removing of the service it is not added to the project 

public async task<bool> removefromproject () {	if (!this.getisaddedtoproject()) {	return true;	}	this.changestatus (status.removing);	var dependenciesfailed = false;	try {	await this.removedependencies (cancellationtoken.none).configureawait (false);	} catch (exception) {	
an error occurred while removing the service dependencies from the project 

dependenciesfailed = true;	}	try {	await this.onremovefromproject ().configureawait (false);	await this.removeaddedstate ().configureawait (false);	this.changestatus (status.notadded);	if (dependenciesfailed) {	}	return true;	} catch (exception ex) {	
an error occurred while removing the service from the project 

try {	var packages = this.dependencies.reverse ().oftype<packagedependency> ().cast<ipackagedependency> ().tolist ();	foreach (var dependency in this.dependencies.reverse ()) {	if (packages.contains (dependency)) {	continue;	}	await dependency.removefromproject (token).configureawait (false);	}	await this.project.removepackagedependencies (packages).configureawait (false);	} catch (exception ex) {	
could not remove dependency 

========================= monodevelop sample_4673 =========================

private sourceeditorprintsettings () {	try {	font = pango.fontdescription.fromstring (defaultsourceeditoroptions.instance.fontname);	} catch {	
could not load font 

========================= monodevelop sample_4540 =========================

private void checkself () {	
of course 

private void returnvalue () {	
of course 

========================= monodevelop sample_10568 =========================

public override void writecomment(commenttype commenttype, string content) {	switch (commenttype) {	
output writeline content 

========================= monodevelop sample_551 =========================

_currentparsetree = args.generatorresults.document;	_lastchangeowner = null;	}	debug.assert(args != null, "event arguments cannot be null");	eventhandler<documentparsecompleteeventargs> handler = documentparsecomplete;	if (handler != null) {	try {	handler(this, args);	}	catch (exception ex) {	
rzed document parse complete handler threw 

========================= monodevelop sample_4855 =========================

public void ifelsecase() {	testissue<canbereplacedwithtrycastandcheckfornullissue>(@" class bar {	public bar baz (object foo) {	if (foo is bar) {	baz ((bar)foo);	return (bar)foo;	} else {	
hello 

public void invalidifnotypecast() {	testwrongcontext<canbereplacedwithtrycastandcheckfornullissue>(@" class bar {	public bar baz (object foo) {	if (foo is bar) {	
hello 

========================= monodevelop sample_8601 =========================

private string getsource (string objectname) {	
getsource 

========================= monodevelop sample_5107 =========================

public void trackprocesstask (task<int> task) {	task.continuewith (t => {	var faulted = t.isfaulted;	
merger exception 

========================= monodevelop sample_7113 =========================

public bool updategtkfolder () {	if (!supportsdesigner (project)) return false;	fileservice.createdirectory (gtkguifolder);	bool projectmodified = false;	bool initialgeneration = false;	if (!file.exists (steticfile)) {	initialgeneration = true;	streamwriter sw = new streamwriter (steticfile);	
stetic interface 

========================= monodevelop sample_3629 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_118 =========================

public override int compareobjects (itreenavigator thisnode, itreenavigator othernode) {	try {	if (thisnode == null || othernode == null) return -1;	var e1 = thisnode.dataitem as namespace;	var e2 = othernode.dataitem as namespace;	if (e1 == null && e2 == null) return 0;	if (e1 == null) return 1;	if (e2 == null) return -1;	return e1.name.compareto (e2.name);	} catch (exception e) {	
exception in assembly browser sort function 

========================= monodevelop sample_2431 =========================

static dbfactoryservice () {	factories = new dictionary<string, idbfactory> ();	foreach (dbfactorycodon codon in addinmanager.getextensionnodes ("/monodevelop/database/sql")) {	idbfactory fac = codon.dbfactory;	if (fac != null) {	factories.add (fac.identifier, fac);	
db factory 

========================= monodevelop sample_5251 =========================

protected virtual void onconnectionerror (exception ex) {	if (hasexited) return;	if (!handleexception (new connectionexception (ex))) {	
unhandled error launching soft debugger 

if (!hasexited) endlaunch ();	symbolfilestimestamps.clear ();	sourcefilesdebuginfo.clear ();	if (!hasexited) {	if (vm != null) {	threadpool.queueuserworkitem (delegate {	try {	vm.exit (0);	} catch (vmdisconnectedexception) {	} catch (exception ex) {	
error exiting sdb vm 

protected override void onexit () {	hasexited = true;	endlaunch ();	if (vm != null) {	try {	vm.exit (0);	} catch (vmdisconnectedexception) {	} catch (socketexception se) {	
error closing debugger session 

protected override void onexit () {	hasexited = true;	endlaunch ();	if (vm != null) {	try {	vm.exit (0);	} catch (vmdisconnectedexception) {	} catch (socketexception se) {	} catch (ioexception ex) {	
error closing debugger session 

protected virtual void ensureexited () {	try {	if (vm != null && vm.targetprocess != null && !vm.targetprocess.hasexited) vm.targetprocess.kill ();	} catch (exception ex) {	
error force terminating soft debugger process 

if (procs == null) {	if (vm == null) return new processinfo [0];	if (vm.targetprocess == null) {	procs = new [] { new processinfo (0, remoteprocessname ?? "mono") };	} else {	try {	procs = new [] { new processinfo (vm.targetprocess.id, remoteprocessname ?? vm.targetprocess.processname) };	} catch (exception ex) {	if (!loggedsymlinkedruntimesbug) {	loggedsymlinkedruntimesbug = true;	
error getting debugger process info known mono bug with symlinked runtimes 

========================= monodevelop sample_6049 =========================

}	else return str;	}	public gdbcommandresult runcommand (string command, params string[] args) {	lock (gdblock) {	lock (synclock) {	lastresult = null;	lock (eventlock) {	running = true;	}	
gdb 

string line;	while ((line = sout.readline ()) != null) {	try {	processoutput (line);	} catch (exception ex) {	console.writeline (ex);	}	}	}	void processoutput (string line) {	
dbg 

handleevent (ev);	} catch (exception ex) {	console.writeline (ex);	}	});	break;	}	}	void handleevent (gdbevent ev) {	if (ev.name != "stopped") {	
unknown event 

========================= monodevelop sample_2500 =========================

public ruleresult checktype (typedefinition type) {	if (!type.hasmethods || type.isenum || type.isdelegate ()) return ruleresult.doesnotapply;	log.writeline (this);	log.writeline (this, "----------------------------------");	log.writeline (this, type);	if (!type.implements ("system", "idisposable")) {	
type does not implement idisposable 

public ruleresult checktype (typedefinition type) {	if (!type.hasmethods || type.isenum || type.isdelegate ()) return ruleresult.doesnotapply;	log.writeline (this);	log.writeline (this, "----------------------------------");	log.writeline (this, type);	if (!type.implements ("system", "idisposable")) {	foreach (methoddefinition method in type.methods.where (m => m.name == "dispose")) {	
found 

========================= monodevelop sample_10164 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_169 =========================

private void oncreatetablethreaded (object state) {	object[] objs = state as object[];	ischemaprovider provider = objs[0] as ischemaprovider;	tableschema table = objs[1] as tableschema;	basenode node = objs[2] as basenode;	
add table 

========================= monodevelop sample_5142 =========================

public override int compareobjects (itreenavigator thisnode, itreenavigator othernode) {	try {	if (thisnode == null || othernode == null) return -1;	var e1 = thisnode.dataitem as project;	var e2 = othernode.dataitem as project;	if (e1 == null && e2 == null) return 0;	if (e1 == null) return -1;	if (e2 == null) return 1;	return e1.name.compareto (e2.name);	} catch (exception e) {	
exception in assembly browser sort function 

========================= monodevelop sample_2425 =========================

public override xmlparserstate pushchar (char c, ixmlparsercontext context, ref string rollback) {	xelement element = context.nodes.peek () as xelement;	if (element == null || element.iscomplete) {	var parent = element;	element = new xelement (context.locationminus (2));	element.parent = parent;	context.nodes.push (element);	}	if (c == '<') {	if (element.isnamed) {	
unexpected in tag 

if (element == null || element.iscomplete) {	var parent = element;	element = new xelement (context.locationminus (2));	element.parent = parent;	context.nodes.push (element);	}	if (c == '<') {	if (element.isnamed) {	close (element, context, context.locationminus (1));	} else {	
unexpected in unnamed tag 

}	rollback = string.empty;	return parent;	}	debug.assert (!element.iscomplete);	if (element.isclosed && c != '>') {	if (char.iswhitespace (c)) {	context.logwarning ("unexpected whitespace after '/' in self-closing tag.");	return null;	}	
unexpected character after in self closing tag 

return null;	}	context.nodes.pop ();	return parent;	}	if (c == '>') {	if (context.statetag == maybe_self_closing) {	element.close (element);	}	if (!element.isnamed) {	
tag closed prematurely 

context.statetag = ok;	if (!element.isnamed && xmlchar.isfirstnamechar (c)) {	rollback = string.empty;	return namestate;	}	if (context.currentstatelength > 0 && xmlchar.isfirstnamechar (c)) {	rollback = string.empty;	return attributestate;	}	if (xmlchar.iswhitespace (c)) return null;	
unexpected character in tag 

========================= monodevelop sample_3489 =========================

public bool success3 () {	bool ret = false;	object o = new object ();	lock (o) {	object o2 = new object ();	lock (locker) {	
foo 

public bool success3 () {	bool ret = false;	object o = new object ();	lock (o) {	object o2 = new object ();	lock (locker) {	x++;	}	lock (locker) {	ret = true;	
foo 

public void failure5 () {	object o = new object ();	lock (locker) {	lock (locker2) {	
foo 

public void failure5 () {	object o = new object ();	lock (locker) {	lock (locker2) {	lock (o) {	y--;	}	}	lock (locker2) {	
foo 

public void failure5b () {	object o = new object ();	lock (locker) {	lock (locker2) {	
foo 

public void failure6 (int j) {	lock (locker) {	lock (locker2) {	
foo 

public void failure6 (int j) {	lock (locker) {	lock (locker2) {	}	lock (locker2) {	
foo 

public void failure8 (int i, int j) {	bool ret = false;	lock (locker) {	lock (locker2) {	ret = true;	}	lock (locker2) {	object o = new object ();	object o2 = new object ();	lock (o) {	
foo 

========================= monodevelop sample_10263 =========================

public async task<int> run (string[] arguments) {	desktopservice.initialize ();	
monodevelop gettext update tool 

public async task<int> run (string[] arguments) {	desktopservice.initialize ();	foreach (string s in arguments) readargument (s);	if (help) {	
gettext update options project file 

public async task<int> run (string[] arguments) {	desktopservice.initialize ();	foreach (string s in arguments) readargument (s);	if (help) {	
f file file project or solution file to build 

public async task<int> run (string[] arguments) {	desktopservice.initialize ();	foreach (string s in arguments) readargument (s);	if (help) {	
p project project name of the project to build 

public async task<int> run (string[] arguments) {	desktopservice.initialize ();	foreach (string s in arguments) readargument (s);	if (help) {	
sort sorts the output po file 

}	if (file == null) {	var files = directory.enumeratefiles (".");	foreach (string f in files) {	if (services.projectservice.isworkspaceitemfile (f)) {	file = f;	break;	}	}	if (file == null) {	
solution file not found 

foreach (string f in files) {	if (services.projectservice.isworkspaceitemfile (f)) {	file = f;	break;	}	}	if (file == null) {	return 1;	}	} else if (!services.projectservice.isworkspaceitemfile (file)) {	
file is not a project or solution 

}	} else if (!services.projectservice.isworkspaceitemfile (file)) {	return 1;	}	consoleprogressmonitor monitor = new consoleprogressmonitor ();	monitor.ignorelogmessages = true;	workspaceitem centry = await services.projectservice.readworkspaceitem (monitor, file);	monitor.ignorelogmessages = false;	solution solution = centry as solution;	if (solution == null) {	
file is not a solution 

monitor.ignorelogmessages = true;	workspaceitem centry = await services.projectservice.readworkspaceitem (monitor, file);	monitor.ignorelogmessages = false;	solution solution = centry as solution;	if (solution == null) {	return 1;	}	if (project != null) {	solutionitem item = solution.findprojectbyname (project);	if (item == null) {	
the project could not be found in 

if (solution == null) {	return 1;	}	if (project != null) {	solutionitem item = solution.findprojectbyname (project);	if (item == null) {	return 1;	}	translationproject tp = item as translationproject;	if (tp == null) {	
the project is not a translation project 

========================= monodevelop sample_2607 =========================

int filecounter = 0;	string tempfilename = "";	try {	do  {	filecounter++;	tempfilename = pofile + filecounter.tostring();	} while (file.exists(tempfilename));	sw = new streamwriter(tempfilename,false,encoding);	}	catch (exception ex) {	
unhandled error creating temp file while saving gettext catalog 

tempfilename = pofile + filecounter.tostring();	} while (file.exists(tempfilename));	sw = new streamwriter(tempfilename,false,encoding);	}	catch (exception ex) {	return false;	}	using (sw) {	sw.newline = originalnewline;	if (!string.isnullorempty (comment)) catalog.savemultilines (sw, comment);	
msgid 

tempfilename = pofile + filecounter.tostring();	} while (file.exists(tempfilename));	sw = new streamwriter(tempfilename,false,encoding);	}	catch (exception ex) {	return false;	}	using (sw) {	sw.newline = originalnewline;	if (!string.isnullorempty (comment)) catalog.savemultilines (sw, comment);	
msgstr 

}	sw.writeline ();	}	}	bool saved = false;	try {	file.copy(tempfilename, pofile, true);	saved = true;	}	catch (exception ex){	
unhandled error saving gettext catalog to 

public void additem (catalogentry data) {	if (this.entriesdict.containskey (data.string)) {	
duplicate message id in po file ignoring it to achieve validity 

========================= monodevelop sample_2596 =========================

public abstract string getdescription (filteroptions filteroptions, string pattern, string replacepattern);	}	public class documentscope : scope {	public override pathmode pathmode {	get { return pathmode.hidden; }	}	public override int gettotalwork (filteroptions filteroptions) {	return 1;	}	public override ienumerable<fileprovider> getfiles (progressmonitor monitor, filteroptions filteroptions) {	
looking in 

public override ienumerable<fileprovider> getfiles (progressmonitor monitor, filteroptions filteroptions) {	if (ideapp.workspace.isopen) {	
looking in project 

public override ienumerable<fileprovider> getfiles (progressmonitor monitor, filteroptions filteroptions) {	foreach (document document in ideapp.workbench.documents) {	
looking in 

public override ienumerable<fileprovider> getfiles (progressmonitor monitor, filteroptions filteroptions) {	
looking in 

========================= monodevelop sample_850 =========================

public void testlocalconstant () {	test<introduceconstantaction> (@"class testclass {	public void hello () {	
hello world 

public void testfieldconstant () {	test<introduceconstantaction> (@"class testclass {	public void hello () {	
hello world 

public void testlocalconstantreplaceall () {	test<introduceconstantaction> (@"class testclass {	public void hello () {	
hello world 

public void testlocalconstantreplaceall () {	test<introduceconstantaction> (@"class testclass {	public void hello () {	
hello world 

public void testlocalconstantreplaceall () {	test<introduceconstantaction> (@"class testclass {	public void hello () {	
hello world 

========================= monodevelop sample_8683 =========================

protected resolveresult resolve(string code) {	var prep = prepareresolver(code);	debug.writeline(new string('=', 70));	
starting new resolver for 

protected resolveresult resolve(string code) {	var prep = prepareresolver(code);	debug.writeline(new string('=', 70));	resolveresult rr = prep.item1.resolve(prep.item2);	assert.isnotnull(rr, "resolveresult is null - did something go wrong while navigating to the target node?");	
resolveresult is 

========================= monodevelop sample_8891 =========================

public static void check (texteditordata data, string content) {	var checkdocument = create (content);	if (checkdocument.text != data.text) {	
was 

public static void check (texteditordata data, string content) {	var checkdocument = create (content);	if (checkdocument.text != data.text) {	console.writeline (data.text);	
expected 

========================= monodevelop sample_642 =========================

static task<objectvalue[]> getchildrenasync (objectvalue value, cancellationtoken cancellationtoken) {	return task.factory.startnew<objectvalue[]> (delegate (object arg) {	try {	return ((objectvalue) arg).getallchildren ();	} catch (exception ex) {	
failed to get objectvalue children 

========================= monodevelop sample_4776 =========================

var lang = projectoptions.getattribute ("language");	var splittype = !string.isnullorempty (type) ? type.split (new char [] {','}, stringsplitoptions.removeemptyentries).select (t => t.trim()).toarray() : null;	var projecttypes = splittype != null ? splittype : new string[] {lang};	var projecttype = projecttypes [0];	string[] flavors;	if (!services.projectservice.cancreatesolutionitem (projecttype, projectcreateinformation, projectoptions) && projecttype != lang && !string.isnullorempty (lang)) {	projecttype = lang;	flavors = splittype ?? new string[0];	} else flavors = projecttypes.skip (1).toarray ();	if (!services.projectservice.cancreatesolutionitem (projecttype, projectcreateinformation, projectoptions)) {	
could not create project of type project skipped 

========================= monodevelop sample_1013 =========================

foreach (string id in pd.xdocument.getallplaceholderids ()) {	sb.append ("<asp:content contentplaceholderid=\"");	sb.append (id);	sb.append ("\" id=\"");	sb.append (id);	sb.append ("content\" runat=\"server\">\n</asp:content>\n");	}	tags["aspnetmastercontent"] = sb.tostring ();	}	catch (exception ex) {	
error generating aspnetmastercontent for template 

========================= monodevelop sample_4875 =========================

public void dispose () {	foreach (assemblydefinition asm in cachedassemblies.values) asm.dispose ();	
total assemblies 

public void dispose () {	foreach (assemblydefinition asm in cachedassemblies.values) asm.dispose ();	
assembly cache size 

public void dispose () {	foreach (assemblydefinition asm in cachedassemblies.values) asm.dispose ();	
total assembly loads 

public void dispose () {	foreach (assemblydefinition asm in cachedassemblies.values) asm.dispose ();	var redundant = loadcounter.where (c => c.value > 1).select (c => c.value - 1).sum ();	
redundant loads 

========================= monodevelop sample_11432 =========================

comment.region = new monodevelop.ide.editor.documentregion ( context.document.offsettolocation (span.start.absoluteindex - comment.opentag.length), context.document.offsettolocation (span.start.absoluteindex + span.length + comment.closingtag.length));	context.comments.add (comment);	}	}	};	context.editorparser.currentparsetree.accept (new callbackvisitor (action));	var parser = new monodevelop.xml.parser.xmlparser (new webformsrootstate (), true);	try {	parser.parse (new stringreader (sb.tostring ()));	} catch (exception ex) {	
unhandled error parsing html in razor document 

========================= monodevelop sample_4824 =========================

static tablabel () {	try {	closeimage = xwt.drawing.image.fromresource ("popup-close-16.png");	} catch (exception e) {	
can t create pixbuf from resource popup close png 

========================= monodevelop sample_736 =========================

public void conditionalcode () {	
writeline 

========================= monodevelop sample_10459 =========================

public void querynotification (nsnotification note) {	if (note.name == nsmetadataquery.didstartgatheringnotification) {	
search started gathering 

public void querynotification (nsnotification note) {	if (note.name == nsmetadataquery.didstartgatheringnotification) {	progresssearch.hidden = false;	progresssearch.startanimation (this);	progresssearchlabel.stringvalue = "searching....";	}	if (note.name == nsmetadataquery.didfinishgatheringnotification) {	
search finished gathering 

progresssearch.hidden = false;	progresssearch.startanimation (this);	progresssearchlabel.stringvalue = "searching....";	}	if (note.name == nsmetadataquery.didfinishgatheringnotification) {	progresssearch.hidden = true;	progresssearch.stopanimation (this);	loadresultsfromquery (note);	}	if (note.name == nsmetadataquery.gatheringprogressnotification){	
search progressing 

public nsobject metadataqueryreplacementobjectforresultobject (nsmetadataquery query, nsmetadataitem result) {	
delegate object 

public nsobject metadataqueryreplacementvalueforattributevalue (nsmetadataquery query, string attrname, nsobject attrvalue) {	
delegate value 

========================= monodevelop sample_10688 =========================

static void onloaderror (object s, addinerroreventargs args) {	
add in error 

static void onload (object s, addineventargs args) {	
add in loaded 

static void onunload (object s, addineventargs args) {	
add in unloaded 

static void onextensionchange (object s, extensioneventargs args) {	
extension changed 

========================= monodevelop sample_11457 =========================

protected override void run () {	try {	ideapp.workbench.activedocument.getcontent<iprintable> ().printpreviewdocument (printingsettings.instance);	} catch (exception e) {	
error while generating the print preview 

protected override void run () {	try {	string title = gettextcatalog.getstring ("clear recent files");	string question = gettextcatalog.getstring ("are you sure you want to clear recent files list?");	if (messageservice.genericalert ( monodevelop.ide.gui.stock.question, title, question, alertbutton.no, alertbutton.yes) == alertbutton.yes) {	desktopservice.recentfiles.clearfiles ();	}	} catch (exception ex) {	
error clearing recent files list 

int i = 0;	var solutionformat = gettextcatalog.getstring ("load solution {0}");	var ctrlmodtext = gettextcatalog.getstring ("hold control to open in current workspace.");	foreach (var ri in projects) {	iconid icon;	try {	if (!file.exists (ri.filename)) continue;	icon = ideapp.services.projectservice.fileisobjectoftype (ri.filename, typeof(solution)) ? "md-solution": "md-workspace";	}	catch (unauthorizedaccessexception exaccess) {	
error building recent solutions list permissions 

foreach (var ri in projects) {	iconid icon;	try {	if (!file.exists (ri.filename)) continue;	icon = ideapp.services.projectservice.fileisobjectoftype (ri.filename, typeof(solution)) ? "md-solution": "md-workspace";	}	catch (unauthorizedaccessexception exaccess) {	continue;	}	catch (ioexception ex) {	
error building recent solutions list 

protected override void run () {	try {	string title = gettextcatalog.getstring ("clear recent projects");	string question = gettextcatalog.getstring ("are you sure you want to clear recent projects list?");	if (messageservice.genericalert ( monodevelop.ide.gui.stock.question, title, question, alertbutton.no, alertbutton.yes) == alertbutton.yes) {	desktopservice.recentfiles.clearprojects ();	}	} catch (exception ex) {	
error clearing recent projects list 

========================= monodevelop sample_1076 =========================

public explicitlytypedlambda(ilist<iparameter> parameters, bool isanonymousmethod, bool isasync, csharpresolver storedcontext, resolvevisitor visitor, astnode body) {	this.parameters = parameters;	this.isanonymousmethod = isanonymousmethod;	this.isasync = isasync;	this.storedcontext = storedcontext;	this.visitor = visitor;	this.body = body;	if (visitor.undecidedlambdas == null) visitor.undecidedlambdas = new list<lambdabase>();	visitor.undecidedlambdas.add(this);	
added undecided explicitly typed lambda 

public override conversion isvalid(itype[] parametertypes, itype returntype, csharpconversions conversions) {	
testing validity of for return type 

public override conversion isvalid(itype[] parametertypes, itype returntype, csharpconversions conversions) {	log.indent();	bool valid = analyze() && isvalidlambda(isvalidasvoidmethod, isendpointunreachable, isasync, returnvalues, returntype, conversions);	log.unindent();	
is for return type valid invalid 

throw new invalidoperationexception();	}	if (actualreturntype != null) {	if (actualreturntype.equals(returntype)) return;	throw new invalidoperationexception("inconsistent return types for explicitly-typed lambda");	}	actualreturntype = returntype;	visitor.undecidedlambdas.remove(this);	analyze();	itype unpackedreturntype = isasync ? visitor.unpacktask(returntype) : returntype;	
applying return type to explicitly typed lambda 

public override conversion isvalid(itype[] parametertypes, itype returntype, csharpconversions conversions) {	
testing validity of for parameters and return type 

public override conversion isvalid(itype[] parametertypes, itype returntype, csharpconversions conversions) {	log.indent();	var hypothesis = gethypothesis(parametertypes);	conversion c = hypothesis.isvalid(returntype, conversions);	log.unindent();	
is for return type valid invalid 

public lambdatypehypothesis(implicitlytypedlambda lambda, itype[] parametertypes, resolvevisitor visitor, icollection<parameterdeclaration> parameterdeclarations, csharpresolver storedcontext) {	debug.assert(parametertypes.length == lambda.parameters.count);	this.lambda = lambda;	this.parametertypes = parametertypes;	this.visitor = visitor;	this.storedcontext = storedcontext;	visitor.setnavigator(this);	
analyzing 

for (int i = 0; i < parametertypes.length; i++) {	var p = lambda.parameters[i];	lambdaparameters[i] = new defaultparameter(parametertypes[i], p.name, region: p.region);	visitor.resolver = visitor.resolver.addvariable(lambdaparameters[i]);	}	}	success = true;	visitor.analyzelambda(lambda.bodyexpression, lambda.isasync, out isvalidasvoidmethod, out isendpointunreachable, out inferredreturntype, out returnexpressions, out returnvalues);	visitor.resolver = oldresolver;	log.unindent();	
finished analyzing 

if (lambda.isasync) returntype = parentvisitor.unpacktask(returntype);	lambda.winninghypothesis = this;	lambda.parameters = lambdaparameters;	if (lambda.bodyexpression is expression && returnvalues.count == 1) {	lambda.bodyresult = returnvalues[0];	if (returntype.kind != typekind.void) {	var conv = storedcontext.conversions.implicitconversion(lambda.bodyresult, returntype);	if (!conv.isidentityconversion) lambda.bodyresult = new conversionresolveresult(returntype, lambda.bodyresult, conv, storedcontext.checkforoverflow);	}	}	
applying return type to implicitly typed lambda 

var conv = storedcontext.conversions.implicitconversion(lambda.bodyresult, returntype);	if (!conv.isidentityconversion) lambda.bodyresult = new conversionresolveresult(returntype, lambda.bodyresult, conv, storedcontext.checkforoverflow);	}	}	if (returntype.kind != typekind.void || lambda.bodyexpression is statement) {	for (int i = 0; i < returnexpressions.count; i++) {	visitor.processconversion(returnexpressions[i], returnvalues[i], returntype);	}	}	visitor.mergeundecidedlambdas();	
merging 

========================= monodevelop sample_9429 =========================

public void testbasiccase() {	analyze<basemethodcallwithdefaultparameteranalyzer>(@" public class mybase {	public virtual void foobar(int x = 12) {	
foo bar 

public void testdonotwarncase() {	analyze<basemethodcallwithdefaultparameteranalyzer>(@" public class mybase {	public virtual void foobar(int x = 12) {	
foo bar 

public void testdonotwarninparamscase() {	analyze<basemethodcallwithdefaultparameteranalyzer>(@" public class mybase {	public virtual void foobar(params int[] x) {	
foo bar 

public void testdisable() {	analyze<basemethodcallwithdefaultparameteranalyzer>(@" public class mybase {	public virtual void foobar(int x = 12) {	
foo bar 

========================= monodevelop sample_6814 =========================

public void testbug3292case2 () {	
class testclass int field public int field get return field set console writeline field 

========================= monodevelop sample_8714 =========================

var doc = new monodevelop.xml.editor.xmlparseddocument (parseoptions.filename);	doc.flags = parseddocumentflags.nonserializable;	try {	var xmlparser = new xmlparser ( new xmlrootstate (new htmltagstate (), new htmlclosingtagstate (true)), true);	xmlparser.parse (parseoptions.content.createreader ());	doc.xdocument = xmlparser.nodes.getroot ();	doc.addrange (xmlparser.errors);	if (doc.xdocument != null) doc.addrange (validate (doc.xdocument));	}	catch (exception ex) {	
unhandled error parsing html document 

========================= monodevelop sample_4940 =========================

dllimports imports = new dllimports ();	foreach (typedefinition t in assembly.mainmodule.getalltypes ()) {	if (t.name == "<module>") continue;	if (t.isspecialname || t.isruntimespecialname) continue;	foreach (methoddefinition md in t.methods) {	if (md.isspecialname) continue;	if (isfinalizer (md)) continue;	pinvokeinfo pinfo = md.pinvokeinfo;	if (pinfo == null) continue;	importkey key = new importkey (pinfo.module.name, pinfo.entrypoint);	
warning pinvoke shows up more than once in input assembly 

for (int i = 0; i < md.body.instructions.count; i ++) {	instruction ins = md.body.instructions[i];	if (ins.opcode == opcodes.call) {	methoddefinition method_operand = ins.operand as methoddefinition;	if (method_operand == null) continue;	pinvokeinfo pinfo = method_operand.pinvokeinfo;	if (pinfo == null) continue;	importkey key = new importkey (pinfo.module.name, pinfo.entrypoint);	if (imports.containskey (key)) {	if (map.containskey (key)) {	
retargeting reference to method method 

if (imports.containskey (key)) {	if (map.containskey (key)) {	var il = md.body.getilprocessor ();	methoddefinition mapped_method = map[key];	methodreference mapped_ref;	mapped_ref = type.module.import(mapped_method);	instruction callmethod = il.create(opcodes.call, mapped_ref);	il.replace (ins, callmethod);	}	else {	
warning no map entry for method 

public static void main (string[] args) {	if (args.length != 3) {	
usage minvoke exe mapassemblyname inputassemblyname outputassemblyname 

public static void main (string[] args) {	if (args.length != 3) {	environment.exit (1);	}	string map_assembly_name = args[0];	string input_assembly_name = args[1];	string output_assembly_name = args[2];	
building list of mapdllimports from map assembly 

public static void main (string[] args) {	if (args.length != 3) {	environment.exit (1);	}	string map_assembly_name = args[0];	string input_assembly_name = args[1];	string output_assembly_name = args[2];	dllimportmap map = buildmap (map_assembly_name);	
building list of dllimports in input assembly 

public static void main (string[] args) {	if (args.length != 3) {	environment.exit (1);	}	string map_assembly_name = args[0];	string input_assembly_name = args[1];	string output_assembly_name = args[2];	dllimportmap map = buildmap (map_assembly_name);	var input_assembly = assemblydefinition.readassembly (input_assembly_name);	dllimports imports = collectdllimports (input_assembly);	
retargeting assembly 

========================= monodevelop sample_9819 =========================

static xmlassembly createxmlassembly (string file) {	xmldocument doc = new xmldocument ();	doc.load (file.openread (file));	xmlnode node = doc.selectsinglenode ("/assemblies/assembly");	xmlassembly result = new xmlassembly ();	try {	result.loaddata (node);	} catch (exception e) {	
error loading 

public override string tostring () {	stringwriter sw = new stringwriter ();	
present 

public override string tostring () {	stringwriter sw = new stringwriter ();	
presenttotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
missing 

public override string tostring () {	stringwriter sw = new stringwriter ();	
missingtotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
todo 

public override string tostring () {	stringwriter sw = new stringwriter ();	
todototal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
extra 

public override string tostring () {	stringwriter sw = new stringwriter ();	
extratotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
warning 

public override string tostring () {	stringwriter sw = new stringwriter ();	
warningtotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
errortotal 

if (node == null) throw new argumentnullexception ("node");	name = node.attributes ["name"].value;	version = node.attributes  ["version"].value;	xmlnode atts = node.firstchild;	attributes = new xmlattributes ();	if (atts.name == "attributes") {	attributes.loaddata (atts);	atts = atts.nextsibling;	}	if (atts == null || atts.name != "namespaces") {	
warning no namespaces found 

public override void loaddata (xmlnode node) {	if (node == null) throw new argumentnullexception ("node");	if (node.name != "namespace") throw new formatexception ("expecting <namespace>");	name = node.attributes  ["name"].value;	xmlnode classes = node.firstchild;	if (classes == null) {	
warning no classes for name 

events.loaddata (child);	child = child.nextsibling;	}	if (child != null && child.name == "methods") {	methods = new xmlmethods ();	methods.loaddata (child);	child = child.nextsibling;	}	if (child == null) return;	if (child.name != "classes") {	
name type 

========================= monodevelop sample_9959 =========================

protected void onshowtest () {	unittest test = getselectedtest ();	if (test == null) return;	sourcecodelocation loc = null;	unittestresult res = test.getlastresult ();	if (res != null && res.isfailure) loc = res.getfailurelocation ();	if (loc == null) loc = test.sourcecodelocation;	if (loc != null) {	ideapp.workbench.opendocument (loc.filename, null, loc.line, loc.column);	} else {	
can t get source code location for test 

protected void onshowtestcode () {	unittest test = getselectedtest ();	if (test == null) return;	sourcecodelocation loc = test.sourcecodelocation;	if (loc != null) {	ideapp.workbench.opendocument (loc.filename, null, loc.line, loc.column);	}  else {	
can t get source code location for test 

========================= monodevelop sample_4430 =========================

static void fixuppcltypeinfo (codecompileunit ccu) {	try {	codeobjectcreateexpression initexpr = getinitexpr (ccu);	var typeofexpr = (codepropertyreferenceexpression)initexpr.parameters [1];	typeofexpr.targetobject = new codemethodinvokeexpression (typeofexpr.targetobject, "gettypeinfo");	} catch (exception ex) {	
failed to fixup stronglytypedresourcebuilder output for pcl 

static void fixupembeddedresourceid (codecompileunit ccu, string id) {	try {	codeobjectcreateexpression initexpr = getinitexpr (ccu);	initexpr.parameters [0] = new codeprimitiveexpression (id);	} catch (exception ex) {	
failed to fixup stronglytypedresourcebuilder resource id 

========================= monodevelop sample_1143 =========================

public void testmethodsynchronized() {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (methodimploptions.synchronized)]	void testmethod () {	
foo 

class testclass {	[methodimpl (methodimploptions.synchronized)]	void testmethod () {	}	}";	var output = @" using system.runtime.compilerservices;	class testclass {	object locker = new object ();	void testmethod () {	lock (locker) {	
foo 

public void testmethodwithsynchronizedvalue() {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (value = methodimploptions.synchronized)]	void testmethod () {	
foo 

class testclass {	[methodimpl (value = methodimploptions.synchronized)]	void testmethod () {	}	}";	var output = @" using system.runtime.compilerservices;	class testclass {	object locker = new object ();	void testmethod () {	lock (locker) {	
foo 

public void testmethodhassynchronized() {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (methodimploptions.synchronized | methodimploptions.noinlining)]	void testmethod () {	
foo 

[methodimpl (methodimploptions.synchronized | methodimploptions.noinlining)]	void testmethod () {	}	}";	var output = @" using system.runtime.compilerservices;	class testclass {	object locker = new object ();	[methodimpl (methodimploptions.noinlining)]	void testmethod () {	lock (locker) {	
foo 

public void testmethodnotsynchronized() {	var input = @" using system.runtime.compilerservices;	class testclass {	[methodimpl (methodimploptions.noinlining)]	void testmethod () {	
foo 

========================= monodevelop sample_6820 =========================

public override bool execute () {	string cachedirectory = getcachedirectory ("mdbuild");	foreach (var taskitem in downloads) {	string url = taskitem.itemspec;	uri uriobj;	if (!uri.trycreate (url, urikind.absolute, out uriobj)) {	
download has invalid url 

uri uriobj;	if (!uri.trycreate (url, urikind.absolute, out uriobj)) {	return false;	}	bool usesha256 = false;	string sha = taskitem.getmetadata ("sha1");	if (string.isnullorempty (sha)) {	sha = taskitem.getmetadata ("sha2");	usesha256 = true;	if (string.isnullorempty (sha)) {	
item has no sha metadata 

========================= monodevelop sample_2 =========================

public override async void deleteitem () {	var service = this.currentnode.dataitem as connectedservicenode;	try {	await connectedservices.removeservicefromproject (this.project, service.id);	} catch (exception ex) {	
error during service removal 

========================= monodevelop sample_4684 =========================

public object visitcommandtargets (icommandtargetvisitor visitor, object initialtarget) {	commandtargetroute targetroute = new commandtargetroute (initialtarget);	object cmdtarget = getfirstcommandtarget (targetroute);	visitor.start ();	try {	while (cmdtarget != null) {	if (visitor.visit (cmdtarget)) return cmdtarget;	cmdtarget = getnextcommandtarget (targetroute, cmdtarget);	}	} catch (exception ex) {	
error while visiting command targets 

public void run (object cmdtarget, commandinfo info) {	if (customhandlerchain != null) {	info.updatehandlerdata = method;	var sw = stopwatch.startnew ();	customhandlerchain.commandupdate (cmdtarget, info);	sw.stop ();	
slow command update ms command customupdater commandtargettype 

} else {	if (method == null) throw new invalidoperationexception ("invalid custom update handler. an implementation of icommandupdatehandler was expected.");	if (isarray) throw new invalidoperationexception ("invalid signature for command update handler: " + method.declaringtype + "." + method.name + "()");	var sw = stopwatch.startnew ();	if (method.returntype == typeof (task)) {	var t = (task) method.invoke (cmdtarget, new object [] { info, info.asyncupdatecancellationtoken });	info.setupdatetask (t);	}	else method.invoke (cmdtarget, new object [] { info });	sw.stop ();	
slow command update ms command method commandtargettype 

public void run (object cmdtarget, commandarrayinfo info) {	if (customarrayhandlerchain != null) {	info.updatehandlerdata = method;	var sw = stopwatch.startnew ();	customarrayhandlerchain.commandupdate (cmdtarget, info);	sw.stop ();	
slow command update ms command method commandtargettype 

sw.stop ();	} else {	if (method == null) throw new invalidoperationexception ("invalid custom update handler. an implementation of icommandarrayupdatehandler was expected.");	if (!isarray) throw new invalidoperationexception ("invalid signature for command update handler: " + method.declaringtype + "." + method.name + "()");	var sw = stopwatch.startnew ();	if (method.returntype == typeof (task)) {	var t = (task)method.invoke (cmdtarget, new object [] { info, info.asyncupdatecancellationtoken });	info.setupdatetask (t);	} else method.invoke (cmdtarget, new object [] { info });	sw.stop ();	
slow command update ms command method commandtargettype 

========================= monodevelop sample_900 =========================

return;	}	var list = await getreferencesasync (result, token);	if (!token.iscancellationrequested) {	gtk.application.invoke ((o, args) => {	if (!token.iscancellationrequested) showreferences (list);	});	}	} catch (operationcanceledexception) {	} catch (exception e) {	
unhandled exception in highlightingusagesextension 

========================= monodevelop sample_840 =========================

treeviewcolumn colfile = new treeviewcolumn (gettextcatalog.getstring ("file"), new cellrenderertext(), "text", 2);	filelist.appendcolumn(colcommit);	filelist.appendcolumn(colstatus);	filelist.appendcolumn(colfile);	colcommit.visible = false;	object[] exts = addinmanager.getextensionobjects ("/monodevelop/versioncontrol/commitdialogextensions", false);	bool separatorrequired = false;	foreach (object ob in exts) {	commitdialogextension ext = ob as commitdialogextension;	if (ext == null) {	
commit extension type must be a subclass of commitdialogextension 

========================= monodevelop sample_4139 =========================

public override void writecomment(commenttype commenttype, string content) {	writeindentation();	switch (commenttype) {	
textwriter writeline content 

isatstartofline = true;	break;	case commenttype.multiline: textwriter.write("/*");	textwriter.write(content);	textwriter.write("*/");	column += 2;	updateendlocation(content, ref line, ref column);	column += 2;	isatstartofline = false;	break;	
textwriter writeline content 

========================= monodevelop sample_9145 =========================

static void createfirefoxprofileifnecessary (string profilename) {	filepath profilepath = filepath.null;	try {	profilepath = getfirefoxprofilepath (profilename);	} catch (exception ex) {	
error reading firefox profile list 

static filepath getfirefoxprofilepath (string profilename) {	filepath profiledir = environment.getfolderpath (environment.specialfolder.personal);	profiledir = profiledir.combine (".mozilla", "firefox");	filepath inifile = profiledir.combine ("profiles.ini");	if (!file.exists (inifile)) {	
firefox profile list does not exist 

========================= monodevelop sample_2763 =========================

}	registerproperty (prop, type, handle);	}	nsobject.overrideretainandrelease (handle);	foreach (methodinfo minfo in type.getmethods (bindingflags.declaredonly | bindingflags.public | bindingflags.nonpublic | bindingflags.instance | bindingflags.static)) registermethod (minfo, type, handle);	constructorinfo default_ctor = type.getconstructor (type.emptytypes);	if (default_ctor != null) {	nativeconstructorbuilder builder = new nativeconstructorbuilder (default_ctor);	class_addmethod (handle, builder.selector, builder.delegate, builder.signature);	method_wrappers.add (builder.delegate);	
ctor registering x on init 

nativeconstructorbuilder builder = new nativeconstructorbuilder (default_ctor);	class_addmethod (handle, builder.selector, builder.delegate, builder.signature);	method_wrappers.add (builder.delegate);	#endif }	foreach (constructorinfo cinfo in type.getconstructors (bindingflags.nonpublic | bindingflags.public | bindingflags.instance | bindingflags.static)) {	exportattribute ea = (exportattribute)attribute.getcustomattribute (cinfo, typeof(exportattribute));	if (ea == null) continue;	nativeconstructorbuilder builder = new nativeconstructorbuilder (cinfo);	class_addmethod (handle, builder.selector, builder.delegate, builder.signature);	method_wrappers.add (builder.delegate);	
ctor registering x on 

========================= monodevelop sample_11249 =========================

static string getbasedirectory (dotnetproject project) {	if (project.parentsolution != null) return project.parentsolution.basedirectory;	
project has no solution using project directory as base directory for nuget project 

========================= monodevelop sample_2893 =========================

public static void printlogfunction (string domain, loglevelflags level, string message) {	
domain level 

public static void printlogfunction (string domain, loglevelflags level, string message) {	
message 

public static void printtracelogfunction (string domain, loglevelflags level, string message) {	printlogfunction (domain, level, message);	
trace follows 

case loglevelflags.debug: loggingservice.logdebug (msg);	break;	case loglevelflags.info: loggingservice.loginfo (msg);	break;	case loglevelflags.warning: loggingservice.logwarning (msg);	break;	case loglevelflags.error: case loglevelflags.critical: default: loggingservice.logerror (msg);	break;	}	remainingbytes -= msg.length;	
disabling glib logging for the rest of the session 

========================= monodevelop sample_1628 =========================

public void staticfieldisnullorempty () {	
empty 

public static void staticlocalisnullorempty () {	string s = string.format ("{0}", 1);	
empty 

========================= monodevelop sample_10087 =========================

public override void buildchildnodes (itreebuilder builder, object dataobject) {	databaseconnectioncontextcollection collection = (databaseconnectioncontextcollection) dataobject;	
buildchildnodes context 

public override bool haschildnodes (itreebuilder builder, object dataobject) {	
haschildnodes context 

========================= monodevelop sample_5143 =========================

case 2: if (c == '>') {	context.statetag = 1;	}	return null;	default: throw new invalidoperationexception ();	}	}	doc = (xdoctype)context.nodes.pop ();	if (c == '<') {	rollback = string.empty;	
doctype ended prematurely 

context.statetag = 1;	}	return null;	default: throw new invalidoperationexception ();	}	}	doc = (xdoctype)context.nodes.pop ();	if (c == '<') {	rollback = string.empty;	} else if (c != '>') {	
unexpected character in doctype 

========================= monodevelop sample_3488 =========================

static void show () {	
hello 

static void show () {	
hello 

static void show () {	
hello 

========================= monodevelop sample_10373 =========================

try {	process = runtime.processservice.startprocess (gettool ("msgfmt"), pb.tostring (), parentproject.basedirectory, monitor.log, monitor.log, null);	} catch (system.componentmodel.win32exception) {	var msg = gettextcatalog.getstring ("did not find msgfmt. please ensure that gettext tools are installed.");	monitor.reporterror (msg, null);	results.adderror (msg);	return results;	}	process.waitforoutput ();	if (process.exitcode == 0) {	
translation compilation succeeded 

========================= monodevelop sample_2606 =========================

public static void notifyfilechange (string filename, string text) {	try {	foreach (var ws in workspaces) ws.updatefilecontent (filename, text);	} catch (exception e) {	
error while notify file change 

public static documentid getdocumentid (microsoft.codeanalysis.workspace workspace, monodevelop.projects.project project, string filename) {	if (project == null) throw new argumentnullexception (nameof(project));	if (filename == null) throw new argumentnullexception (nameof(filename));	filename = fileservice.getfullpath (filename);	var projectid = ((monodevelopworkspace)workspace).getprojectid (project);	if (projectid != null) {	return ((monodevelopworkspace)workspace).getdocumentid (projectid, filename);	} else {	
warning can t find in project 

var ws = getworkspace (args.solution);	var projectinfo = await ws.loadproject (project, cancellationtoken.none, args.replaceditem as monodevelop.projects.project);	if (args.reloading) {	ws.onprojectreloaded (projectinfo);	}	else {	ws.onprojectadded (projectinfo);	}	}	} catch (exception ex) {	
onsolutionitemadded failed 

========================= monodevelop sample_1370 =========================

case classificationtypenames.modulename: return editorthemecolors.usertypes;	case classificationtypenames.structname: return editorthemecolors.usertypesvaluetypes;	case classificationtypenames.typeparametername: return editorthemecolors.usertypestypeparameters;	case classificationtypenames.identifier: return "source.cs";	case classificationtypenames.numericliteral: return "constant.numeric";	case classificationtypenames.stringliteral: return "string.quoted";	case classificationtypenames.whitespace: return "source.cs";	case classificationtypenames.operator: return "keyword.source";	case classificationtypenames.punctuation: return "punctuation";	case classificationtypenames.text: return "source.cs";	
warning unexpected classification type 

========================= monodevelop sample_4555 =========================

typeid = "t:" + idstring.substring (2, idx - 2);	doc = helptree.gethelpxml (typeid);	if (doc == null) return null;	membername = idstring.substring (idx + 1);	var membernode = doc.selectsinglenode ("/type/members/member[@membername='" + membername + "']/docs");	return membernode?.outerxml;	}	return null;	} catch (exception e) {	haderror = true;	
error while reading monodoc file 

if (containingtype == null) return null;	var parentid = containingtype.getdocumentationcommentid ();	doc = helptree.gethelpxml (parentid);	if (doc == null) return null;	xmlnode node = selectnode (doc, entity);	if (node != null) return commentcache [idstring] = node.outerxml;	return null;	}	} catch (exception e) {	haderror = true;	
error while reading monodoc file 

========================= monodevelop sample_1383 =========================

public override system.threading.tasks.task<parseddocument> parse (parseoptions parseoptions, system.threading.cancellationtoken cancellationtoken) {	var info = new webformspageinfo ();	var errors = new list<error> ();	var parser = new xmlparser ( new webformsrootstate (), true );	try {	parser.parse (parseoptions.content.createreader ());	} catch (exception ex) {	
unhandled error parsing asp net document 

========================= monodevelop sample_4874 =========================

public recentfilestorage (string filepath) {	this.filepath = filepath;	acquirefileexclusive (filepath).continuewith (t => {	if (t.isfaulted) {	exception ex = t.exception;	while (ex is aggregateexception && ex.innerexception != null) {	ex = ex.innerexception;	}	
failed to acquire recent items lock 

}	try {	using (var reader = xmlreader.create (file, new xmlreadersettings { closeinput = false })) {	while (reader.read ()) {	if (reader.isstartelement () && reader.localname == recentitem.node) {	result.add (recentitem.read (reader));	}	}	}	} catch (exception e) {	
error while reading recent file store 

========================= monodevelop sample_1204 =========================

static int getitemtype (completionitem completionitem) {	foreach (var tag in completionitem.tags) {	if (roslyncompletiontypetable.trygetvalue (tag, out int result)) return result;	}	
roslyncompletiondata can t find item type 

========================= monodevelop sample_974 =========================

if (!method.hasbody) return ruleresult.doesnotapply;	if (!opcodebitmask.calls.intersect (opcodeengine.getbitmask (method))) return ruleresult.success;	log.writeline (this);	log.writeline (this, "---------------------------------------");	log.writeline (this, method);	foreach (instruction ins in method.body.instructions) {	switch (ins.opcode.code) {	case code.call: case code.callvirt: methodreference target = ins.operand as methodreference;	string define = conditionalon (target);	if (define != null) {	
call to method at 

private methodreference findimpurity (imethodsignature method, instruction end) {	methodreference impure = null;	instruction ins = fulltraceback (method, end);	if (ins != null) {	
checking args for call at starting at 

}	}	}	if (method.hascustomattributes) {	if (haspureattribute (method.customattributes)) {	return true;	}	}	return false;	}	
couldn t resolve call assuming it is pure 

========================= monodevelop sample_10409 =========================

directory.createdirectory (config_dir);	} catch {}	try {	file.delete (settings_file);	} catch {}	try {	using (filestream fs = file.create (settings_file)){	serializer.serialize (fs, this);	}	} catch  (exception e){	
saving 

========================= monodevelop sample_9859 =========================

static void testoutput (string input, string expectedmarkup, string syntaxmode) {	string markup = getmarkup (input, syntaxmode);	if (markup != expectedmarkup){	
expected 

static void testoutput (string input, string expectedmarkup, string syntaxmode) {	string markup = getmarkup (input, syntaxmode);	if (markup != expectedmarkup){	console.writeline (expectedmarkup);	
got 

========================= monodevelop sample_626 =========================

public void run () {	
hello world 

========================= monodevelop sample_11456 =========================

if (configuration.targetruntime is msnettargetruntime) res.adderror (gettextcatalog.getstring ("you may need to install the .net sdk."));	return res;	}	string outstr = ilasm + " " + sb;	monitor.log.writeline (outstr);	string workingdir = ".";	if (configuration.parentitem != null) {	workingdir = configuration.parentitem.basedirectory;	if (workingdir == null) workingdir = ".";	}	
ilasm 

========================= monodevelop sample_4811 =========================

public void runaction (action<texteditordata> action) {	try {	action (gettexteditordata ());	} catch (exception e) {	
error while executing 

public new void queuedrawarea (int x, int y, int w, int h) {	if (gdkwindow != null) {	gdkwindow.invalidaterect (new rectangle (x, y, w, h), false);	
invalidated x 

public new void queuedraw () {	base.queuedraw ();	
invalidated entire widget 

if (index >= 0) {	linelayout.indextolinex (index, true, out l, out x1);	} else {	l = x1 = 0;	}	index = result.offset - line.offset - 1 + result.length;	if (index >= 0) {	linelayout.indextolinex (index, true, out l, out x2);	} else {	x2 = 0;	
invalid end index 

========================= monodevelop sample_4483 =========================

systemassembly = metadatareference.createfromfile(typeof(system.componentmodel.browsableattribute).assembly.location);	systemxmllinq = metadatareference.createfromfile(typeof(system.xml.linq.xelement).assembly.location);	systemcore = metadatareference.createfromfile(typeof(enumerable).assembly.location);	visualbasic = metadatareference.createfromfile(typeof(microsoft.visualbasic.constants).assembly.location);	defaultmetadatareferences = new[] {	mscorlib, systemassembly, systemcore, systemxmllinq, visualbasic };	foreach (var provider in typeof(diagnosticanalyzercategories).assembly.gettypes().where(t => t.getcustomattributes(typeof(exportcodefixproviderattribute), false).length > 0)) {	var codefixprovider = (codefixprovider)activator.createinstance(provider);	foreach (var id in codefixprovider.fixablediagnosticids) {	if (providers.containskey(id)) {	
provider already added 

========================= monodevelop sample_6805 =========================

public void testcase1() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase1() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalidcase1() {	testwrongcontext<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase2() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase2() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalidcase2() {	testwrongcontext<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase3() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase3() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testcase4() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase4() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalidcase4() {	testwrongcontext<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase5() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase5() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testcase6() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	
foo bar 

public void testcase6() {	test<stringcompareisculturespecificissue>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalid() {	testwrongcontext<stringcompareisculturespecificissue>(@" class test {	void foo () {	
a b 

public void testcomplex() {	test<stringcompareisculturespecificissue>(@" class test {	void foo (bool b) {	
foo bar 

public void testcomplex() {	test<stringcompareisculturespecificissue>(@" class test {	void foo (bool b) {	}	}", @" class test {	void foo (bool b) {	
foo bar 

public void testdisable() {	testwrongcontext<stringcompareisculturespecificissue>(@" class test {	void foo() {	
foo bar 

========================= monodevelop sample_8614 =========================

public void buildrepository (iprogressstatus statusmonitor, string path) {	string mainpath = path.combine (path, "main.mrep");	arraylist alladdins = new arraylist ();	repository rootrep = (repository) addinstore.readobject (mainpath, typeof(repository));	if (rootrep == null) rootrep = new repository ();	iprogressmonitor monitor = progressstatusmonitor.getprogressmonitor (statusmonitor);	buildrepository (monitor, rootrep, path, "root.mrep", alladdins);	addinstore.writeobject (mainpath, rootrep);	generateindexpage (rootrep, alladdins, path);	
updated main mrep 

========================= monodevelop sample_11547 =========================

public void invalidnestedinvocationexpressiontest() {	invocationexpression expr = parseutilcsharp.parseexpression<invocationexpression>("writeline(mymethod(,))", true);	assert.istrue(expr.target is identifierexpression);	
writeline 

========================= monodevelop sample_8857 =========================

public void testparamsinvalidcontext() {	testwrongcontext<addargumentnameaction>(@" class testclass {	public void f() {	
foo 

========================= monodevelop sample_8744 =========================

}	} catch (exception e) {	errors.add (new compilererror (fullpath, 1, 1, null, e.tostring ()));	return null;	}	foreach (razorerror error in results.parsererrors) {	errors.add (new compilererror (fullpath, error.location.lineindex + 1, error.location.characterindex + 1, null, error.message));	}	try {	using (var writer = new stringwriter ()) {	
pragma warning disable 

} catch (exception e) {	errors.add (new compilererror (fullpath, 1, 1, null, e.tostring ()));	return null;	}	foreach (razorerror error in results.parsererrors) {	errors.add (new compilererror (fullpath, error.location.lineindex + 1, error.location.characterindex + 1, null, error.message));	}	try {	using (var writer = new stringwriter ()) {	_codedomprovider.generatecodefromcompileunit (results.generatedcode, writer, codegeneratoroptions);	
pragma warning restore 

========================= monodevelop sample_4850 =========================

private void displaycontent(isignature sigtorender) {	_signaturetextbuffer.properties[signaturehelpparameterboldingclassfier.useprettyprintedcontentkey] = false;	_signaturetextbuffer.replace(new span(0, _signaturetextbuffer.currentsnapshot.length), sigtorender.content);	var classifierspans = platformcatalog.instance.classifieraggregatorservice.getclassifier(_signaturetextbuffer)?.getclassificationspans(new snapshotspan(_signaturetextbuffer.currentsnapshot, 0, _signaturetextbuffer.currentsnapshot.length));	if (classifierspans != null && classifierspans.count > 0) _signaturewpftextview.markup = mdutils.classificationstomarkup(_signaturetextbuffer.currentsnapshot, classifierspans, sigtorender.currentparameter);	else {	_signaturewpftextview.markup = monodevelop.ide.typesystem.ambience.escapetext(_signaturetextbuffer.currentsnapshot.gettext());	
no classification spans found for signature helper 

private void displayprettyprintedcontent(isignature sigtorender) {	debug.assert(sigtorender.prettyprintedcontent != null, "we shouldn't try to display null prettyprintedcontent.");	_signaturetextbuffer.properties[signaturehelpparameterboldingclassfier.useprettyprintedcontentkey] = true;	_signaturetextbuffer.replace(new span(0, _signaturetextbuffer.currentsnapshot.length), sigtorender.prettyprintedcontent);	var classifierspans = platformcatalog.instance.classifieraggregatorservice.getclassifier(_signaturetextbuffer)?.getclassificationspans(new snapshotspan(_signaturetextbuffer.currentsnapshot, 0, _signaturetextbuffer.currentsnapshot.length));	if (classifierspans != null && classifierspans.count > 0) _signaturewpftextview.markup = mdutils.classificationstomarkup(_signaturetextbuffer.currentsnapshot, classifierspans, sigtorender.currentparameter);	else {	_signaturewpftextview.markup = monodevelop.ide.typesystem.ambience.escapetext(_signaturetextbuffer.currentsnapshot.gettext());	
no classification spans found for signature helper 

========================= monodevelop sample_4582 =========================

public void invalidmethodtest() {	var actions = getactions<abstractandvirtualconversionaction>( abstract class test {	public virtual string $tostring() {	
hello world 

========================= monodevelop sample_8715 =========================

assert.areequal (maintoolkit, toolkit.currentengine);	noxwtcallback = true;	return false;	}, timespan.frommilliseconds (50));	var t = sectoolkit.invoke (async delegate {	assert.aresame (sectoolkit, toolkit.currentengine);	assert.isfalse (noxwtcallback);	await task.delay (200);	assert.istrue (noxwtcallback);	assert.aresame (sectoolkit, toolkit.currentengine);	
done 

eventqueue.maineventqueue.enqueue (delegate {	assert.areequal (maintoolkit, toolkit.currentengine);	noxwtcallback = true;	});	sectoolkit.invoke (delegate {	assert.aresame (sectoolkit, toolkit.currentengine);	assert.isfalse (noxwtcallback);	application.mainloop.dispatchpendingevents ();	assert.istrue (noxwtcallback);	assert.aresame (sectoolkit, toolkit.currentengine);	
done 

========================= monodevelop sample_7658 =========================

public void runaction (action<texteditordata> action) {	try {	action (gettexteditordata ());	} catch (exception e) {	
error while executing 

public new void queuedrawarea (int x, int y, int w, int h) {	if (gdkwindow != null) {	gdkwindow.invalidaterect (new rectangle (x, y, w, h), false);	
invalidated x 

public new void queuedraw () {	base.queuedraw ();	
invalidated entire widget 

if (!options.useantialiasing) {	textviewcr.antialias = cairo.antialias.none;	cr.antialias = cairo.antialias.none;	}	updatemarginxoffsets ();	cr.linewidth = options.zoom;	textviewcr.linewidth = options.zoom;	textviewcr.rectangle (textviewmargin.xoffset, 0, allocation.width - textviewmargin.xoffset, allocation.height);	textviewcr.clip ();	rendermargins (cr, textviewcr, cairoarea);	
expose x 

if (index >= 0) {	linelayout.layout.indextolinex (index, true, out l, out x1);	} else {	l = x1 = 0;	}	index = result.offset - line.offset - 1 + result.length;	if (index >= 0) {	linelayout.layout.indextolinex (index, true, out l, out x2);	} else {	x2 = 0;	
invalid end index 

========================= monodevelop sample_8412 =========================

public static bool runmodalwin32dialog (commonfiledialog dialog, gtk.window parent) {	while (gtk.application.eventspending ()) gtk.application.runiteration ();	intptr ph = hgdiobjget (parent.gdkwindow);	intptr hdlg = intptr.zero;	dialog.dialogopening += delegate {	try {	hdlg = getdialoghandle (dialog);	setgtkdialoghook (hdlg);	} catch (exception ex) {	
failed to hook dialog messages 

public static bool runmodalwpfdialog (window dialog, gtk.window parent) {	while (gtk.application.eventspending ()) gtk.application.runiteration ();	intptr ph = hgdiobjget (parent.gdkwindow);	intptr hdlg = intptr.zero;	dialog.loaded += delegate {	try {	hdlg = new windowinterophelper (dialog).handle;	setgtkdialoghook (hdlg);	} catch (exception ex) {	
failed to hook dialog messages 

========================= monodevelop sample_3374 =========================

public ruleresult checktype (typedefinition type) {	if (!type.isenum) return ruleresult.doesnotapply;	if (type.isflags ()) return ruleresult.doesnotapply;	getvalues (type);	if (values.count < 3) return ruleresult.success;	#if debug log.writeline (this);	log.writeline (this, "------------------------------------");	log.writeline (this, type);	
values 

if (values.count < 3) return ruleresult.success;	#if debug log.writeline (this);	log.writeline (this, "------------------------------------");	log.writeline (this, type);	#endif int numflags = 0;	int nummasks = 0;	foreach (ulong value in values) {	if (ispoweroftwo (value)) ++numflags;	else if (isbitmask (value)) ++nummasks;	}	
numflags 

if (values.count < 3) return ruleresult.success;	#if debug log.writeline (this);	log.writeline (this, "------------------------------------");	log.writeline (this, type);	#endif int numflags = 0;	int nummasks = 0;	foreach (ulong value in values) {	if (ispoweroftwo (value)) ++numflags;	else if (isbitmask (value)) ++nummasks;	}	
nummasks 

log.writeline (this, type);	#endif int numflags = 0;	int nummasks = 0;	foreach (ulong value in values) {	if (ispoweroftwo (value)) ++numflags;	else if (isbitmask (value)) ++nummasks;	}	if (numflags + nummasks == values.count) {	values.sort ();	int numsequential = countsequential ();	
numsequential 

========================= monodevelop sample_10332 =========================

public void stop () {	stopping = true;	try {	if (communicationmanager != null) {	communicationmanager.stopserver ();	communicationmanager = null;	}	} catch (exception ex) {	
testplatformcommunicationmanager stop error 

} catch (exception ex) {	}	try {	if (dotnetprocess != null) {	if (!dotnetprocess.hasexited) {	dotnetprocess.dispose ();	}	dotnetprocess = null;	}	} catch (exception ex) {	
vstest process dispose error 

public void canceltestrun () {	if (isrunningtests) {	try {	communicationmanager.sendmessage (messagetype.canceltestrun);	} catch (exception ex) {	
canceltestrun error 

try {	communicationmanager.sendmessage (messagetype.canceltestrun);	} catch (exception ex) {	}	try {	if (debugoperation != null) {	if (!debugoperation.iscompleted) debugoperation.cancel ();	debugoperation = null;	}	} catch (exception ex) {	
canceltestrun error 

========================= monodevelop sample_2587 =========================

static void main(string[] args) {	const string basepath = @"..\..\refactoringessentials";	using (var missingmdwriter = new streamwriter(path.combine(basepath, "missing.md"), false, encoding.utf8)) {	
things not ported yet 

static void main(string[] args) {	const string basepath = @"..\..\refactoringessentials";	using (var missingmdwriter = new streamwriter(path.combine(basepath, "missing.md"), false, encoding.utf8)) {	missingmdwriter.writeline("=====================");	missingmdwriter.writeline("");	var coderefactorings = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcoderefactoringproviderattribute).fullname)) .orderby(t => t.name);	var codeanalyzers = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(diagnosticanalyzerattribute).fullname)) .orderby(t => t.name);	var codefixes = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcodefixproviderattribute).fullname) && codefixunrelatedtonranalyzer(t)) .orderby(t => t.name);	
refactorings 

static void main(string[] args) {	const string basepath = @"..\..\refactoringessentials";	using (var missingmdwriter = new streamwriter(path.combine(basepath, "missing.md"), false, encoding.utf8)) {	missingmdwriter.writeline("=====================");	missingmdwriter.writeline("");	var coderefactorings = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcoderefactoringproviderattribute).fullname)) .orderby(t => t.name);	var codeanalyzers = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(diagnosticanalyzerattribute).fullname)) .orderby(t => t.name);	var codefixes = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcodefixproviderattribute).fullname) && codefixunrelatedtonranalyzer(t)) .orderby(t => t.name);	missingmdwriter.writeline("");	
c 

missingmdwriter.writeline("=====================");	missingmdwriter.writeline("");	var coderefactorings = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcoderefactoringproviderattribute).fullname)) .orderby(t => t.name);	var codeanalyzers = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(diagnosticanalyzerattribute).fullname)) .orderby(t => t.name);	var codefixes = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcodefixproviderattribute).fullname) && codefixunrelatedtonranalyzer(t)) .orderby(t => t.name);	missingmdwriter.writeline("");	missingmdwriter.writeline("");	writetypelist(basepath, "coderefactorings.html.template", "coderefactorings.csharp.html", "{0} code refactorings for c#", coderefactorings.where(t => iscsharprelatedelement(t)), getrefactoringdescription, missingmdwriter);	missingmdwriter.writeline("");	writetypelist(basepath, "coderefactorings.html.template", "coderefactorings.vb.html", "{0} code refactorings for visual basic", coderefactorings.where(t => isvbrelatedelement(t)), getrefactoringdescription, null);	
analyzers 

missingmdwriter.writeline("");	var coderefactorings = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcoderefactoringproviderattribute).fullname)) .orderby(t => t.name);	var codeanalyzers = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(diagnosticanalyzerattribute).fullname)) .orderby(t => t.name);	var codefixes = typeof(notportedyetattribute).assembly.gettypes() .where(t => !t.fullname.startswith("refactoringessentials.samples.") && t.customattributes.any(a => a.attributetype.fullname == typeof(exportcodefixproviderattribute).fullname) && codefixunrelatedtonranalyzer(t)) .orderby(t => t.name);	missingmdwriter.writeline("");	missingmdwriter.writeline("");	writetypelist(basepath, "coderefactorings.html.template", "coderefactorings.csharp.html", "{0} code refactorings for c#", coderefactorings.where(t => iscsharprelatedelement(t)), getrefactoringdescription, missingmdwriter);	missingmdwriter.writeline("");	writetypelist(basepath, "coderefactorings.html.template", "coderefactorings.vb.html", "{0} code refactorings for visual basic", coderefactorings.where(t => isvbrelatedelement(t)), getrefactoringdescription, null);	missingmdwriter.writeline("");	
c 

========================= monodevelop sample_7091 =========================

public void method_with_underscore (string param_with_underscore) {	event_with_underscore += delegate {	
hello 

public void methodwithoutunderscore (string paramwithoutunderscore) {	eventwithoutunderscore += delegate {	
hello 

========================= monodevelop sample_10110 =========================

public void testusageinifcondition() {	test<addnullcheckcoderefactoringprovider>(@" using system;	using system.collections.generic;	class testclass {	public void testmethod(ienumerable<string> list) {	if ($list.contains(""bla"")) {	
contains 

class testclass {	public void testmethod(ienumerable<string> list) {	if ($list.contains(""bla"")) {	}	}	}", @" using system;	using system.collections.generic;	class testclass {	public void testmethod(ienumerable<string> list) {	if ((list != null) && list.contains(""bla"")) {	
contains 

========================= monodevelop sample_7007 =========================

public void oninstallingselectedpackages () {	try {	updaterecentpackages ();	} catch (exception ex) {	
unable to update recent packages 

========================= monodevelop sample_2791 =========================

private void initializegui () {	notebook.sensitive = true;	waitdialog.hidedialog ();	
tableeditordialog entering initializegui 

private void initializegui () {	notebook.sensitive = true;	waitdialog.hidedialog ();	columneditor.initialize (table, columns, constraints, datatypes);	if (constrainteditor != null) constrainteditor.initialize (tables, table, columns, constraints, datatypes);	if (triggereditor != null) triggereditor.initialize (table, triggers);	
tableeditordialog leaving initializegui 

========================= monodevelop sample_5231 =========================

static string getmonoversionnumber () {	var t = type.gettype ("mono.runtime");	if (t == null) return "unknown";	var mi = t.getmethod ("getdisplayname", bindingflags.nonpublic | bindingflags.static);	if (mi == null) {	
no mono runtime getdisplayname method found 

========================= monodevelop sample_1638 =========================

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
regex match timeout occurred 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
specified timeout 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
timeout check frequency 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
search pattern 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
input 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
about to throw regexmatchtimeoutexception 

========================= monodevelop sample_1589 =========================

assemblyloadertask = task.run ( () => {	try {	var assemblydefinition = assemblydefinition.readassembly (filename, new readerparameters {	assemblyresolver = this });	assemblydefinitiontasksource.setresult(assemblydefinition);	decompilertypesystem = new decompilertypesystem(assemblydefinition.mainmodule);	var loadedassembly = decompilertypesystem.mainassembly.unresolvedassembly;	return tuple.create(assemblydefinition, loadedassembly);	}	catch (exception e) {	
error while reading assembly 

========================= monodevelop sample_2420 =========================

public void greeting () {	
hello 

========================= monodevelop sample_10266 =========================

public void updatetranslations (progressmonitor monitor, bool sort, params translation[] translations) {	monitor.begintask (null, translations.count + 1);	try {	list<project> projects = new list<project> ();	foreach (project p in parentsolution.getallprojects ()) {	if (isincluded (p)) projects.add (p);	}	monitor.begintask (gettextcatalog.getstring ("updating message catalog"), projects.count);	createdefaultcatalog (monitor);	
done 

foreach (project p in parentsolution.getallprojects ()) {	if (isincluded (p)) projects.add (p);	}	monitor.begintask (gettextcatalog.getstring ("updating message catalog"), projects.count);	createdefaultcatalog (monitor);	} finally {	monitor.endtask ();	monitor.step (1);	}	if (monitor.cancellationtoken.iscancellationrequested) {	
operation cancelled 

monitor.reporterror (msg, null);	}	catch (exception ex) {	monitor.reporterror (gettextcatalog.getstring ("could not update file {0}", translation.pofile), ex);	}	finally {	monitor.endtask ();	monitor.step (1);	}	if (monitor.cancellationtoken.iscancellationrequested) {	
operation cancelled 

protected async override task<buildresult> onclean (progressmonitor monitor, configurationselector configuration, operationcontext operationcontext) {	isdirty = true;	
removing all mo files 

========================= monodevelop sample_2593 =========================

public void setdatabaseoptions (npgsqldatabaseschema schema) {	treeiter iter;	if (comboowner.getactiveiter (out iter)) schema.owner = (userschema)ownersstore.getvalue (iter,1);	else if (comboowner.activetext != string.empty) {	
elegido 

========================= monodevelop sample_5173 =========================

if (analyzerattr != null) {	try {	var analyzer = (diagnosticanalyzer)activator.createinstance (type);	var descriptor = new codediagnosticdescriptor (analyzerattr.languages, type);	foreach (var diag in analyzer.supporteddiagnostics) {	if (!isdiagnosticsupported (diag)) continue;	diagnostictable[diag.id] = descriptor;	}	diagnostics.add (descriptor);	} catch (exception e) {	
error while adding diagnostic analyzer type from assembly asm fullname 

} catch (exception e) {	}	}	var exportattr = type.getcustomattributes (typeof (exportcoderefactoringproviderattribute), false).firstordefault () as exportcoderefactoringproviderattribute;	if (exportattr != null) {	refactoringtable[type] = new coderefactoringdescriptor (type, exportattr);	}	}	} catch (reflectiontypeloadexception ex) {	foreach (var subexception in ex.loaderexceptions) {	
error while loading diagnostics in 

========================= monodevelop sample_4058 =========================

public void testparamsinvalidcontext() {	testwrongcontext<addnametoargumentcoderefactoringprovider>(@" class testclass {	public void f() {	
foo 

========================= monodevelop sample_7042 =========================

}));	result.add (new inspectorresults ( provider, r.region, r.description, severity, r.issuemarker, fixes.toarray () ));	}	}	#if profile clock.stop ();	lock (runlist) {	runlist.add (tuple.create (clock.elapsedmilliseconds, parentprovider.title));	}	#endif } catch (operationcanceledexception) {	} catch (exception e) {	
codeanalysis got exception in inspector 

#if profile clock.stop ();	lock (runlist) {	runlist.add (tuple.create (clock.elapsedmilliseconds, parentprovider.title));	}	#endif } catch (operationcanceledexception) {	} catch (exception e) {	}	});	#if profile runlist.sort ();	foreach (var item in runlist) {	
ms 

========================= monodevelop sample_3999 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_88 =========================

public static string getxspname (aspnetexecutioncommand cmd) {	switch (cmd.clrversion) {	case clrversion.net_1_1: return "xsp1";	case clrversion.net_2_0: return "xsp2";	case clrversion.net_4_0: return "xsp4";	case clrversion.net_4_5: return "xsp4";	
asp net is not supported for unknown runtime version 

filepath xsppath = cmd.targetruntime.gettoolpath (cmd.targetframework, xspname);	if (xsppath.isnullorempty && cmd.clrversion == clrversion.net_1_1) xsppath = cmd.targetruntime.gettoolpath (cmd.targetframework, "xsp");	if (xsppath.isnullorempty) {	filepath addinpath = typeof (aspnetexecutionhandler).assembly.location;	xsppath = addinpath.parentdirectory.combine (xspname + ".exe");	}	if (file.exists (xsppath)) return xsppath;	filepath rootexe = system.reflection.assembly.getentryassembly ().location;	xsppath = rootexe.parentdirectory.combine (xspname + ".exe");	if (file.exists (xsppath)) return xsppath;	
did not find web server 

========================= monodevelop sample_4955 =========================

public void testdefaultparameter () {	var input = @" using system;	namespace testprojectforbug {	class mainclass {	public static void condmethod (bool cond = false) {	
true false 

========================= monodevelop sample_8490 =========================

p.waitforexit ();	application.invoke (delegate {	main.progress = 0;	main.status = "download complete";	if (done != null) done (masterinfo);	});	}	}	catch (system.net.webexception wex) {	if (wex != null && wex.response != null && ((httpwebresponse)wex.response).statuscode == httpstatuscode.notmodified) {	
remote file not modified since we downloaded it 

main.progress = 0;	fileinfo masterinfoinfo = new fileinfo (masterinfo);	if (masterinfoinfo.exists) {	main.status = "download failed, reusing cached (possibly out of date) masterinfo";	if (done != null) done (masterinfo);	}	else main.status = "download failed";	});	}	});	
downloading to 

menu sub = null;	foreach (menuitem mi in main.menubar.allchildren){	accellabel a = mi.child as accellabel;	if (a == null || a.labelprop != "_compare") continue;	if (a.labelprop == "recent comparisons"){	}	sub = (menu) mi.submenu;	break;	}	if (sub == null){	
unable to found compare submenu 

========================= monodevelop sample_9869 =========================

static void printnode (astnode node) {	
parent 

static void printnode (astnode node) {	
children 

static void printnode (astnode node) {	
at role 

========================= monodevelop sample_8797 =========================

public void reportresult (searchresult result) {	runtime.runinmainthread (delegate {	try {	outputpad.reportresult (result);	} catch (exception ex) {	
error adding search result for file to result pad 

public void reportresults (ienumerable<searchresult> results) {	runtime.runinmainthread (delegate {	try {	outputpad.reportresults (results);	} catch (exception ex) {	
error adding search results 

========================= monodevelop sample_855 =========================

public unittestresult getlastresult (datetime date) {	try {	if (store != null) return store.getlastresult (test.activeconfiguration, test, date);	} catch (exception ex) {	
test store query failed test history data may be corrupt 

public unittestresult getnextresult (datetime date) {	try {	if (store != null) return store.getnextresult (test.activeconfiguration, test, date);	} catch (exception ex) {	
test store query failed test history data may be corrupt 

public unittestresult getpreviousresult (datetime date) {	try {	if (store != null) return store.getpreviousresult (test.activeconfiguration, test, date);	} catch (exception ex) {	
test store query failed test history data may be corrupt 

public unittestresult [] getresults (datetime startdate, datetime enddate) {	try {	if (store != null) return store.getresults (test.activeconfiguration, test, startdate, enddate);	} catch (exception ex) {	
test store query failed test history data may be corrupt 

public unittestresult [] getresultstodate (datetime enddate, int count) {	try {	if (store != null) return store.getresultstodate (test.activeconfiguration, test, enddate, count);	} catch (exception ex) {	
test store query failed test history data may be corrupt 

========================= monodevelop sample_4440 =========================

public static string run (string scriptsource) {	aedesc sourcedata = new aedesc ();	try {	appleevent.aecreatedescutf8 (scriptsource, out sourcedata);	return run (true, ref sourcedata);	} catch (applescriptexception ex) {	
applescript failure 

========================= monodevelop sample_4992 =========================

}	image = getimagefile (template);	if (image == null) {	image = getimagefromid (template.imageid);	}	if (image == null) {	image = defaultimage;	}	return image;	} catch (exception ex) {	
unable to load image for project template 

========================= monodevelop sample_1047 =========================

razordocument = cu as razorcsharpparseddocument;	if (razordocument == null || razordocument.pageinfo.csharpsyntaxtree == null) return;	createdoctype ();	var state = tracker.engine.currentstate;	if (state is razorstate && completionwindowmanager.isvisible || (!updateneeded && (state is razorspeculativestate || state is razorexpressionstate))) updatehiddendocument (false);	else {	updatehiddendocument ();	updateneeded = false;	}	} catch (exception e) {	
error while updating razor completion 

========================= monodevelop sample_4821 =========================

protected override void forall (bool includeinternals, gtk.callback callback) {	base.forall (includeinternals, callback);	foreach (var c in children.keys.toarray ()) {	if (c.parent == null) {	
error found unparented child in property grid 

========================= monodevelop sample_1387 =========================

static customexecutionmodes getglobalcustomexecutionmodes () {	if (globalmodes == null) {	try {	xmldataserializer ser = new xmldataserializer (getdatacontext ());	filepath file = userprofile.current.configdir.combine ("custom-command-modes.xml");	if (file.exists (file)) globalmodes = (customexecutionmodes) ser.deserialize (file, typeof(customexecutionmodes));	} catch (exception ex) {	
could not load global custom execution modes 

static void saveglobalcustomexecutionmodes () {	if (globalmodes == null) return;	try {	xmldataserializer ser = new xmldataserializer (getdatacontext ());	filepath file = userprofile.current.configdir.combine ("custom-command-modes.xml");	ser.serialize (file, globalmodes, typeof(customexecutionmodes));	} catch (exception ex) {	
could not save global custom execution modes 

========================= monodevelop sample_1156 =========================

unit.acceptvisitor (visitor);	foreach (var loc in visitor.output) {	var provider = createprovider (cnt.item2, cnt.item1, loc.item1);	if (provider.find (loc.item2) != null) {	found++;	} else {	missing++;	}	}	} catch (exception e) {	
exception in 

if (provider.find (loc.item2) != null) {	found++;	} else {	missing++;	}	}	} catch (exception e) {	exceptions++;	}	}	
found 

if (provider.find (loc.item2) != null) {	found++;	} else {	missing++;	}	}	} catch (exception e) {	exceptions++;	}	}	
missing 

if (provider.find (loc.item2) != null) {	found++;	} else {	missing++;	}	}	} catch (exception e) {	exceptions++;	}	}	
exceptions 

public void testbug568204 () {	completiondatalist provider = createprovider ( public class style {	public static style testme () {	return new style ();	}	public void print () {	
hello 

assert.areequal(2, provider.data.count(d => d.displaytext == "method"));	}	[test]	public void testbug3973 () {	var provider = createprovider ( using system;	class a {	public static void main (string[] args) {	console.$w$ }	}	");	
writeline writeline not found 

public int requestid { get; set; }	public bool requirelogin { get; set; }	public requestattribute (int requestid, bool requirelogin = false) {	requestid = requestid;	requirelogin = requirelogin;	}	}	class mainclass {	[requestattribute(5$, r$)]	public static void main (string[] args) {	
hello 

========================= monodevelop sample_8877 =========================

public void testbug3292case2() {	
class testclass int field public int field get return field set console writeline field 

========================= monodevelop sample_6965 =========================

public static ienumerable<templateparameter> createparameters (string condition) {	string[] parts = condition.split (new [] {';', ','}, stringsplitoptions.removeemptyentries);	foreach (string part in parts) {	var parameter = new templateparameter (part);	if (!parameter.isvalid) {	
invalid template condition 

========================= monodevelop sample_1006 =========================

public void addvariable (codetemplatevariable var) {	if (variabledecarations.containskey (var.name)) {	
code template duplicate 

========================= monodevelop sample_1117 =========================

static void main(string[] args) {	comparefloats();	bool fiveisfive = (5 == 5);	bool hasargs = false;	hasargs |= (args.length > 0);	var commandlineswitchparser = new commandlineswitchparser();	commandlineswitchparser.parameters = args;	commandlineswitchparser.parse();	
selected switches 

========================= monodevelop sample_6777 =========================

protected sealed override async task<bool> onaddtoproject (cancellationtoken token) {	int trycount = 1;	bool keeptrying = true;	while (keeptrying) {	try {	if (trycount > 1) {	
retrying to add code dependency 

protected sealed override async task<bool> onaddtoproject (cancellationtoken token) {	int trycount = 1;	bool keeptrying = true;	while (keeptrying) {	try {	if (trycount > 1) {	} else {	
adding code dependency to 

protected sealed override async task<bool> onaddtoproject (cancellationtoken token) {	int trycount = 1;	bool keeptrying = true;	while (keeptrying) {	try {	if (trycount > 1) {	} else {	}	this.compilation = await typesystemservice.getcompilationasync (this.service.project).configureawait (false);	if (this.compilation == null) {	
could not get compilation object 

try {	if (trycount > 1) {	} else {	}	this.compilation = await typesystemservice.getcompilationasync (this.service.project).configureawait (false);	if (this.compilation == null) {	return false;	}	this.initlookuptypes (token, this.lookuptypes.keys.toarray ());	var result = await runtime.runinmainthread<bool> ( () => this.addcodetoproject (token) );	
code dependency added code dependency was not added 

protected sealed override async task<bool> onremovefromproject (cancellationtoken token) {	int trycount = 1;	bool keeptrying = true;	while (keeptrying) {	try {	if (trycount > 1) {	
retrying to remove code dependency 

protected sealed override async task<bool> onremovefromproject (cancellationtoken token) {	int trycount = 1;	bool keeptrying = true;	while (keeptrying) {	try {	if (trycount > 1) {	} else {	
removing code dependency from 

protected sealed override async task<bool> onremovefromproject (cancellationtoken token) {	int trycount = 1;	bool keeptrying = true;	while (keeptrying) {	try {	if (trycount > 1) {	} else {	}	this.compilation = await typesystemservice.getcompilationasync (this.service.project).configureawait (false);	if (this.compilation == null) {	
could not get compilation object 

try {	if (trycount > 1) {	} else {	}	this.compilation = await typesystemservice.getcompilationasync (this.service.project).configureawait (false);	if (this.compilation == null) {	return false;	}	this.initlookuptypes (token, this.lookuptypes.keys.toarray ());	var result = await this.removecodefromproject (token).configureawait (false);	
code dependency removed code dependency was not removed 

protected virtual void updatemethodwithcodedependency (location methodregion) {	if (methodregion == null) return;	var sourcetree = methodregion.sourcetree;	if (sourcetree == null) return;	var proj = this.service.project.getcodeanalysisproject ();	if (proj == null) {	
could not get codeanalysisproject for the given project cannot modify code 

var codestatements = this.createcodedependencystatements ();	for (int i = 0; i < codestatements.count; i++) {	newmethodstatements = newmethodstatements.insert (i, codestatements [i]);	}	newmethodnode = newmethodnode.withbody (newmethodnode.body.withstatements (newmethodstatements));	if (newmethodnode != methodnode) {	var newroot = root.replacenode<syntaxnode> (methodnode, newmethodnode);	newroot = formatter.format (newroot, proj.solution.workspace);	var newsolution = proj.solution.withdocumentsyntaxroot (docid, newroot);	if (!proj.solution.workspace.tryapplychanges (newsolution)) {	
failed to add code dependency changes to the workspace 

for (int i = 0; i < codestatements.count; i++) {	newmethodstatements = newmethodstatements.insert (i, codestatements [i]);	}	newmethodnode = newmethodnode.withbody (newmethodnode.body.withstatements (newmethodstatements));	if (newmethodnode != methodnode) {	var newroot = root.replacenode<syntaxnode> (methodnode, newmethodnode);	newroot = formatter.format (newroot, proj.solution.workspace);	var newsolution = proj.solution.withdocumentsyntaxroot (docid, newroot);	if (!proj.solution.workspace.tryapplychanges (newsolution)) {	if (proj.solution.workspace.currentsolution.version != newsolution.version) {	
solution version is different 

var root = sourcetree.getroot ();	var classnode = root.findnode (classregion.sourcespan) as classdeclarationsyntax;	if (classnode == null) return;	var newclassnode = classnode;	newclassnode = newclassnode.withmembers (newclassnode.members.add (newmethod ()));	if (newclassnode != classnode) {	var newroot = root.replacenode<syntaxnode> (classnode, newclassnode);	newroot = formatter.format (newroot, proj.solution.workspace);	var newsolution = proj.solution.withdocumentsyntaxroot (docid, newroot);	if (!proj.solution.workspace.tryapplychanges (newsolution)) {	
failed to add code dependency changes to the workspace 

var classnode = root.findnode (classregion.sourcespan) as classdeclarationsyntax;	if (classnode == null) return;	var newclassnode = classnode;	newclassnode = newclassnode.withmembers (newclassnode.members.add (newmethod ()));	if (newclassnode != classnode) {	var newroot = root.replacenode<syntaxnode> (classnode, newclassnode);	newroot = formatter.format (newroot, proj.solution.workspace);	var newsolution = proj.solution.withdocumentsyntaxroot (docid, newroot);	if (!proj.solution.workspace.tryapplychanges (newsolution)) {	if (proj.solution.workspace.currentsolution.version != newsolution.version) {	
solution version is different 

========================= monodevelop sample_4672 =========================

public void testuppercase1 () {	string output = runsimulation ("", "wr\t", true, true, false, "writeline");	
writeline 

========================= monodevelop sample_424 =========================

public static void endcodefragment<t> (ixmlparsercontext context, documentlocation loc) where t : xnode {	var top = context.nodes.pop ();	var node = top as t;	if (node == null) {	if (top.isended) node = context.nodes.pop () as t;	if (node == null) {	debug.fail ("unexpected node at the top of the stack");	
error in razor stateengine parser unexpected node at the top of the stack expected 

========================= monodevelop sample_4831 =========================

public void testbug() {	analyze<stringlastindexofisculturespecificanalyzer>(@" class program {	public int foobar { get; }	static void main(string [] args, string foobar) {	
aeia 

public void testbug() {	analyze<stringlastindexofisculturespecificanalyzer>(@" class program {	public int foobar { get; }	static void main(string [] args, string foobar) {	}	}	", @" class program {	public int foobar { get; }	static void main(string [] args, string foobar) {	
aeia system stringcomparison ordinal 

========================= monodevelop sample_6934 =========================

public void saveviews () {	try {	xmldataserializer ser = new xmldataserializer (new datacontext ());	ser.serialize (configfile, views);	} catch (exception ex) {	
error while saving monitor views xml 

========================= monodevelop sample_597 =========================

static void show () {	
hello 

========================= monodevelop sample_10478 =========================

using (streamreader sr = new streamreader(filename)) {	prettyprinteroptions options;	xmlserializer xs = new xmlserializer (typeof (prettyprinteroptions));	options = (prettyprinteroptions) xs.deserialize (sr);	sr.close ();	return options;	}	}	}	catch (exception exception1) {	
couldn t load configuration file cause 

directory.createdirectory (path);	}	}	using (streamwriter sw = new streamwriter (filename)) {	xmlserializer xs = new xmlserializer (typeof (prettyprinteroptions));	xs.serialize (sw, options);	sw.close();	}	}	catch (exception e) {	
couldn t save configuration file cause 

========================= monodevelop sample_9968 =========================

public void methodparameternamedvalue() {	
void m string value system console writeline value void m string value console writeline value 

public void valueinproperty() {	
string p set system console writeline value string p set console writeline value 

========================= monodevelop sample_8447 =========================

static filepath resolvesymboliclink (filepath filename) {	if (filename.isempty) return filename;	try {	var alreadyvisted = new hashset<filepath> ();	while (true) {	if (alreadyvisted.contains (filename)) {	
cyclic links detected 

========================= monodevelop sample_1335 =========================

public override xmlparserstate pushchar (char c, ixmlparsercontext context, ref string rollback) {	var directive = context.nodes.peek () as webformsdirective;	if (directive == null || directive.iscomplete) {	directive = new webformsdirective (context.locationminus (4));	context.nodes.push (directive);	}	if (c == '<') {	
unexpected in directive 

}	debug.assert (!directive.iscomplete);	if (context.statetag != ending && c == '%') {	context.statetag = ending;	return null;	}	if (context.statetag == ending) {	if (c == '>') {	context.nodes.pop ();	if (!directive.isnamed) {	
directive closed prematurely 

}	} else if (char.isletter (c)) {	rollback = string.empty;	if (!directive.isnamed) {	return namestate;	} else {	return attributestate;	}	} else if (char.iswhitespace (c)) return null;	rollback = string.empty;	
unexpected character in tag 

========================= monodevelop sample_4893 =========================

static string constructexpression(string expr) {	return @" using system;	using system.linq;	class bar {	public void foo (string[] args) {	
expr 

========================= monodevelop sample_6900 =========================

public void testsimplecase() {	test<stringcomparetoisculturespecificissue>(@" public class test {	void foo (string b) {	
foo compareto b 

public void testsimplecase() {	test<stringcomparetoisculturespecificissue>(@" public class test {	void foo (string b) {	}	}	", @" public class test {	void foo (string b) {	
foo b system stringcomparison ordinal 

public void testinvalidcase() {	testwrongcontext<stringcomparetoisculturespecificissue>(@" public class test {	void foo (object b) {	
foo compareto b 

public void testdisable() {	testwrongcontext<stringcomparetoisculturespecificissue>(@" public class test {	void foo (string b) {	
foo compareto b 

========================= monodevelop sample_8651 =========================

public void save(textwriter writer) {	if (writer == null) throw new argumentnullexception("writer");	
digraph g 

========================= monodevelop sample_8952 =========================

public void testwrongcontext2 () {	
using system class testclass void test console writeline foo 

public void testsimplemethodcall () {	string result = runcontextaction ( new createfieldaction (), "using system;" + environment.newline + "class testclass" + environment.newline + "{" + environment.newline + "	void test ()" + environment.newline + "	{" + environment.newline + "		console.writeline ($foo);" + environment.newline + "	}" + environment.newline + "}" );	console.writeline (result);	
using system class testclass object foo void test console writeline foo 

========================= monodevelop sample_8740 =========================

while (!shuttingdown) {	binarymessage msg;	int type;	try {	type = instream.readbyte ();	if (type == -1) break;	msg = binarymessage.read (instream);	msg = loadmessagedata (msg);	if (debugmode) {	string mtype = type == message_queue_end ? "[m] " : "[q] ";	
server xs rp 

public void writemessage (byte type, binarymessage msg) {	msg.readcustomdata ();	lock (listeners) {	
server xs rp ms 

========================= monodevelop sample_2079 =========================

borderwidth = 6;	setlabel (gettextcatalog.getstring ("loading..."));	new system.threading.thread (() => {	try {	var info = systeminformation.getdescription ().toarray ();	gtk.application.invoke ((o, args) => {	if (destroyed) return;	settext (info);	});	} catch (exception ex) {	
failed to load version information 

========================= monodevelop sample_960 =========================

public extractinterfaceoptionsresult getextractinterfaceoptions (isyntaxfactsservice syntaxfactsservice, inotificationservice notificationservice, list<isymbol> extractablemembers, string defaultinterfacename, list<string> conflictingtypenames, string defaultnamespace, string generatednametypeparametersuffix, string languagename) {	var dialog = new extractinterfacedialog ();	try {	dialog.init (syntaxfactsservice, notificationservice, extractablemembers, defaultinterfacename, conflictingtypenames, defaultnamespace, generatednametypeparametersuffix, languagename);	bool performchange = dialog.run () == xwt.command.ok;	if (!performchange) return extractinterfaceoptionsresult.cancelled;	return new extractinterfaceoptionsresult (false, dialog.includedmembers, dialog.interfacename, dialog.filename);	} catch (exception ex) {	
error while signature changing 

========================= monodevelop sample_3989 =========================

public packagemanagementworkspace () {	if (ideapp.workspace != null) {	ideapp.workspace.solutionloaded += solutionloaded;	ideapp.workspace.solutionunloaded += solutionunloaded;	ideapp.workspace.itemaddedtosolution += solutionitemaddedorremoved;	ideapp.workspace.itemremovedfromsolution += solutionitemaddedorremoved;	} else {	
ideapp workspace is not available when creating packagemanagementworkspace 

========================= monodevelop sample_2896 =========================

public virtual void setup () {	var vcs = repo.versioncontrolsystem;	
running tests for v 

========================= monodevelop sample_4108 =========================

static void main(string[] args) {	
hello world 

========================= monodevelop sample_119 =========================

var indent = createengine(@" namespace foobar {	class foo {	void bar () {	system.console.writeline ();	}	$ }	}	", out sourcetext);	itextpastehandler handler = createtextpasteindentengine(indent, formattingoptionsfactory.createmono());	var text = handler.formatplaintext(sourcetext, indent.offset, "void bar ()\n{\nsystem.console.writeline ();\n}", null);	
void bar system console writeline 

sourcetext sourcetext;	var indent = createengine(@" class foo {	void bar () {	system.console.writeline ();	}	$ }	", out sourcetext);	itextpastehandler handler = createtextpasteindentengine(indent, formattingoptionsfactory.createmono());	for (int i = 0; i < 2; i++) {	var text = handler.formatplaintext(sourcetext, indent.offset, "void bar ()\n{\nsystem.console.writeline ();\n}", null);	
void bar system console writeline 

public void pasteverbatimstringbug1() {	var texteditoroptions = formattingoptionsfactory.createmono();	texteditoroptions = texteditoroptions.withchangedoption(formattingoptions.newline, languagenames.csharp, "\r\n");	sourcetext sourcetext;	var indent = createengine("\r\nclass foo\r\n{\r\n\tvoid bar ()\r\n\t{\r\n\t\t$\r\n\t}\r\n}", out sourcetext, texteditoroptions);	itextpastehandler handler = createtextpasteindentengine(indent, texteditoroptions);	var text = handler.formatplaintext(sourcetext, indent.offset, "console.writeline (@\"hello world!\", out sourcetext);\n", null);	
console writeline out sourcetext 

public void pasteverbatimstringbug2() {	sourcetext sourcetext;	var indent = createengine("\nclass foo\n{\n\tvoid bar ()\n\t{\n\t\t$\n\t}\n}", out sourcetext);	itextpastehandler handler = createtextpasteindentengine(indent, formattingoptionsfactory.createmono());	var text = handler.formatplaintext(sourcetext, indent.offset, "if (true)\nconsole.writeline (@\"hello\n world!\", out sourcetext);\n", null);	
if true console writeline out sourcetext 

public void pasteverbatimstringbug3() {	sourcetext sourcetext;	var indent = createengine("\nclass foo\n{\n\tvoid bar ()\n\t{\n$\n\t}\n}", out sourcetext);	itextpastehandler handler = createtextpasteindentengine(indent, formattingoptionsfactory.createmono());	var text = handler.formatplaintext(sourcetext, indent.offset, "\t\tsystem.console.writeline(@\"<evlevlle>\", out sourcetext);\n", null);	
system console writeline out sourcetext 

public void pastemultilineatfirstcolumncorrection() {	sourcetext sourcetext;	var indent = createengine("class foo\n{\n$\n}", out sourcetext);	itextpastehandler handler = createtextpasteindentengine(indent, formattingoptionsfactory.createmono());	var text = handler.formatplaintext(sourcetext, indent.offset, "void bar ()\n{\n\tsystem.console.writeline ();\n}", null);	
void bar system console writeline 

========================= monodevelop sample_288 =========================

} else action = backgroundqueue.dequeue ();	}	if (wait) {	backgroundthreadwait.waitone ();	continue;	}	if (action != null) {	try {	action ();	} catch (exception ex) {	
backgrounddispatcher error 

========================= monodevelop sample_2800 =========================

public override void didfinishlaunching (nsnotification notification) {	var args = environment.getcommandlineargs ();	nserror error;	var searchargidx = array.indexof<string> (args, "--search");	if (searchargidx != -1 && args.length > searchargidx + 1 && !string.isnullorempty (args [searchargidx + 1])) {	var document = controller.openuntitleddocument (true, out error);	if (document != null) ((mydocument)document).loadwithsearch (args[searchargidx + 1]);	}	var indexmanager = indexupdatemanager;	indexmanager.checkindexisfresh ().continuewith (t => {	
error while checking indexes 

========================= monodevelop sample_7105 =========================

public static int getoperandtype (instruction self, methoddefinition method) {	int i = 0;	switch (self.opcode.code) {	case code.ldarg_0: case code.ldarg_1: case code.ldarg_2: case code.ldarg_3: case code.ldarg: case code.ldarg_s: case code.ldarga: case code.ldarga_s: case code.starg: case code.starg_s: i = 1;	
arguments 

public static int getoperandtype (instruction self, methoddefinition method) {	int i = 0;	switch (self.opcode.code) {	case code.ldarg_0: case code.ldarg_1: case code.ldarg_2: case code.ldarg_3: case code.ldarg: case code.ldarg_s: case code.ldarga: case code.ldarga_s: case code.starg: case code.starg_s: i = 1;	break;	case code.conv_r4: case code.ldc_r4: case code.ldelem_r4: case code.ldind_r4: case code.stelem_r4: case code.stind_r4: i = 2;	
singles 

public static int getoperandtype (instruction self, methoddefinition method) {	int i = 0;	switch (self.opcode.code) {	case code.ldarg_0: case code.ldarg_1: case code.ldarg_2: case code.ldarg_3: case code.ldarg: case code.ldarg_s: case code.ldarga: case code.ldarga_s: case code.starg: case code.starg_s: i = 1;	break;	case code.conv_r4: case code.ldc_r4: case code.ldelem_r4: case code.ldind_r4: case code.stelem_r4: case code.stind_r4: i = 2;	break;	case code.conv_r8: case code.ldc_r8: case code.ldelem_r8: case code.ldind_r8: case code.stelem_r8: i = 3;	
doubles 

public static int getoperandtype (instruction self, methoddefinition method) {	int i = 0;	switch (self.opcode.code) {	case code.ldarg_0: case code.ldarg_1: case code.ldarg_2: case code.ldarg_3: case code.ldarg: case code.ldarg_s: case code.ldarga: case code.ldarga_s: case code.starg: case code.starg_s: i = 1;	break;	case code.conv_r4: case code.ldc_r4: case code.ldelem_r4: case code.ldind_r4: case code.stelem_r4: case code.stind_r4: i = 2;	break;	case code.conv_r8: case code.ldc_r8: case code.ldelem_r8: case code.ldind_r8: case code.stelem_r8: i = 3;	break;	case code.ldloc_0: case code.ldloc_1: case code.ldloc_2: case code.ldloc_3: case code.ldloc: case code.ldloc_s: case code.ldloca: case code.ldloca_s: case code.stloc_0: case code.stloc_1: case code.stloc_2: case code.stloc_3: case code.stloc: case code.stloc_s: i = 4;	
locals 

switch (self.opcode.code) {	case code.ldarg_0: case code.ldarg_1: case code.ldarg_2: case code.ldarg_3: case code.ldarg: case code.ldarg_s: case code.ldarga: case code.ldarga_s: case code.starg: case code.starg_s: i = 1;	break;	case code.conv_r4: case code.ldc_r4: case code.ldelem_r4: case code.ldind_r4: case code.stelem_r4: case code.stind_r4: i = 2;	break;	case code.conv_r8: case code.ldc_r8: case code.ldelem_r8: case code.ldind_r8: case code.stelem_r8: i = 3;	break;	case code.ldloc_0: case code.ldloc_1: case code.ldloc_2: case code.ldloc_3: case code.ldloc: case code.ldloc_s: case code.ldloca: case code.ldloca_s: case code.stloc_0: case code.stloc_1: case code.stloc_2: case code.stloc_3: case code.stloc: case code.stloc_s: i = 4;	break;	case code.ldfld: case code.ldflda: case code.ldsfld: case code.ldsflda: case code.stfld: case code.stsfld: i = 5;	
fields 

break;	case code.conv_r4: case code.ldc_r4: case code.ldelem_r4: case code.ldind_r4: case code.stelem_r4: case code.stind_r4: i = 2;	break;	case code.conv_r8: case code.ldc_r8: case code.ldelem_r8: case code.ldind_r8: case code.stelem_r8: i = 3;	break;	case code.ldloc_0: case code.ldloc_1: case code.ldloc_2: case code.ldloc_3: case code.ldloc: case code.ldloc_s: case code.ldloca: case code.ldloca_s: case code.stloc_0: case code.stloc_1: case code.stloc_2: case code.stloc_3: case code.stloc: case code.stloc_s: i = 4;	break;	case code.ldfld: case code.ldflda: case code.ldsfld: case code.ldsflda: case code.stfld: case code.stsfld: i = 5;	break;	case code.call: case code.callvirt: case code.newobj: i = 6;	
calls 

break;	case code.conv_r8: case code.ldc_r8: case code.ldelem_r8: case code.ldind_r8: case code.stelem_r8: i = 3;	break;	case code.ldloc_0: case code.ldloc_1: case code.ldloc_2: case code.ldloc_3: case code.ldloc: case code.ldloc_s: case code.ldloca: case code.ldloca_s: case code.stloc_0: case code.stloc_1: case code.stloc_2: case code.stloc_3: case code.stloc: case code.stloc_s: i = 4;	break;	case code.ldfld: case code.ldflda: case code.ldsfld: case code.ldsflda: case code.stfld: case code.stsfld: i = 5;	break;	case code.call: case code.callvirt: case code.newobj: i = 6;	break;	default: i = 7;	
default 

break;	case code.ldloc_0: case code.ldloc_1: case code.ldloc_2: case code.ldloc_3: case code.ldloc: case code.ldloc_s: case code.ldloca: case code.ldloca_s: case code.stloc_0: case code.stloc_1: case code.stloc_2: case code.stloc_3: case code.stloc: case code.stloc_s: i = 4;	break;	case code.ldfld: case code.ldflda: case code.ldsfld: case code.ldsflda: case code.stfld: case code.stsfld: i = 5;	break;	case code.call: case code.callvirt: case code.newobj: i = 6;	break;	default: i = 7;	break;	}	
end 

========================= monodevelop sample_10084 =========================

public static void main (string[] args) {	
hello world 

========================= monodevelop sample_198 =========================

public bool isreleaseversion () {	nugetversion nugetversion = null;	if (nugetversion.tryparse (version, out nugetversion)) {	return !nugetversion.isprerelease;	}	
unable to parse nuget package version assuming release version 

========================= monodevelop sample_2553 =========================

}	else if (catalogparser.readparam (line, "msgid \"", out dummy) || catalogparser.readparam (line, "msgid\t\"", out dummy)) {	mstr = parsemessage (ref line, ref dummy, sr);	}	else if (catalogparser.readparam (line, "msgid_plural \"", out dummy) || catalogparser.readparam (line, "msgid_plural\t\"", out dummy)) {	msgidplural = parsemessage (ref line, ref dummy, sr);	hasplural = true;	}	else if (catalogparser.readparam (line, "msgstr \"", out dummy) || catalogparser.readparam (line, "msgstr\t\"", out dummy)) {	if (hasplural) {	
broken catalog file singular form msgstr used together with msgid plural 

if (! onentry (mstr, string.empty, false, mtranslations.toarray (), mflags, mrefs.toarray (), mcomment, mautocomments.toarray ())) {	return false;	}	mcomment = mstr = msgidplural = mflags = string.empty;	hasplural = false;	mrefs.clear ();	mautocomments.clear ();	mtranslations.clear ();	} else if (catalogparser.readparam (line, "msgstr[", out dummy)) {	if (!hasplural){	
broken catalog file plural form msgstr used without msgid plural 

========================= monodevelop sample_2605 =========================

static bool ontransferprogress (transferprogress tp, progressmonitor monitor, ref int progress) {	if (progress == 0 && tp.receivedobjects == 0) {	progress = 1;	
receiving and indexing objects 

static void oncheckoutprogress (int completedsteps, int totalsteps, progressmonitor monitor, ref int progress) {	if (progress == 0 && completedsteps == 0) {	progress = 1;	
checking out files 

protected override ienumerable<versioninfo> ongetversioninfo (ienumerable<filepath> paths, bool getremotestatus) {	try {	return getdirectoryversioninfo (filepath.null, paths, getremotestatus, false);	} catch (exception e) {	
failed to query git status 

protected override versioninfo[] ongetdirectoryversioninfo (filepath localdirectory, bool getremotestatus, bool recursive) {	try {	return getdirectoryversioninfo (localdirectory, null, getremotestatus, recursive);	} catch (exception e) {	
failed to get git directory status 

public void fetch (progressmonitor monitor, string remote) {	monitor.begintask (gettextcatalog.getstring ("fetching"), 1);	
fetching from 

try {	monitor.begintask (gettextcatalog.getstring ("rebasing"), 5);	if (!commonpremergerebase (options, monitor, out stashindex)) return;	var divergence = rootrepository.objectdatabase.calculatehistorydivergence (rootrepository.head.tip, rootrepository.branches [branch].tip);	var toapply = rootrepository.commits.queryby (new commitfilter {	includereachablefrom = rootrepository.head.tip, excludereachablefrom = divergence.commonancestor, sortby = commitsortstrategies.topological | commitsortstrategies.reverse }).toarray ();	rootrepository.reset (resetmode.hard, divergence.another);	int count = toapply.length;	int i = 1;	foreach (var com in toapply) {	
cherry picking 

int checkoutprogress = 0;	try {	monitor.begintask ("cloning...", 2);	retryuntilsuccess (monitor, credtype => {	rootpath = libgit2sharp.repository.clone (url, targetlocalpath, new cloneoptions {	credentialsprovider = (url, userfromurl, types) => {	transferprogress = checkoutprogress = 0;	return gitcredentials.tryget (url, userfromurl, types, credtype);	}, repositoryoperationstarting = ctx => {	runtime.runinmainthread (() => {	
checking out repository at 

credentialsprovider = (url, userfromurl, types) => {	transferprogress = checkoutprogress = 0;	return gitcredentials.tryget (url, userfromurl, types, credtype);	}, repositoryoperationstarting = ctx => {	runtime.runinmainthread (() => {	});	return true;	}, ontransferprogress = (tp) => ontransferprogress (tp, monitor, ref transferprogress), oncheckoutprogress = (path, completedsteps, totalsteps) => {	oncheckoutprogress (completedsteps, totalsteps, monitor, ref checkoutprogress);	runtime.runinmainthread (() => {	
checking out file 

using (var repo = new libgit2sharp.repository (path)) {	retryuntilsuccess (monitor, credtype => {	int transferprogress = 0, checkoutprogress = 0;	submoduleupdateoptions updateoptions = new submoduleupdateoptions () {	init = true, credentialsprovider = (url, userfromurl, types) => {	transferprogress = checkoutprogress = 0;	return gitcredentials.tryget (url, userfromurl, types, credtype);	}, ontransferprogress = (tp) => ontransferprogress (tp, monitor, ref transferprogress), oncheckoutprogress = (file, completedsteps, totalsteps) => {	oncheckoutprogress (completedsteps, totalsteps, monitor, ref checkoutprogress);	runtime.runinmainthread (() => {	
checking out file 

runtime.runinmainthread (() => {	});	}, };	var submodulearray = repo.submodules.where (sm => sm.retrievestatus ().hasflag (submodulestatus.inindex)).toarray ();	monitor.begintask (submodulearray.length);	foreach (var sm in submodulearray) {	if (monitor.cancellationtoken.iscancellationrequested) {	throw new usercancelledexception ("recursive clone of submodules was cancelled.");	}	runtime.runinmainthread (() => {	
checking out submodule at 

public override diffinfo generatediff (filepath baselocalpath, versioninfo versioninfo) {	try {	var repository = getrepository (versioninfo.localpath);	var patch = repository.diff.compare<patch> (new [] { repository.togitpath (versioninfo.localpath) });	int diffstart = patch.content.indexof ('\n', patch.content.indexof ('\n') + 1);	return new diffinfo (baselocalpath, versioninfo.localpath, patch.content.substring (diffstart + 1));	} catch (exception ex) {	
could not get diff for file 

========================= monodevelop sample_4249 =========================

public void initialize () {	try {	initializedefaultcredentialprovider ();	} catch (exception ex) {	
failed to initialize packagemanagementcredentialservice 

public static void reset () {	try {	var credentialservice = httphandlerresourcev3.credentialservice as credentialservice;	if (credentialservice != null) credentialservice.reset ();	} catch (exception ex) {	
failed to reset packagemanagementcredentialservice 

========================= monodevelop sample_2957 =========================

public xmlschemaelement findelement (qualifiedname name) {	ensureloaded();	foreach (xmlschemaelement element in schema.elements.values) {	if (name.equals (element.qualifiedname)) {	return element;	}	}	
xmlschemadataobject did not find element in the schema 

public xmlschemaelement findelement (string name) {	ensureloaded();	foreach (xmlschemaelement element in schema.elements.values) if (element.qualifiedname.name == name) return element;	
xmlschemadataobject did not find element in the schema 

========================= monodevelop sample_3478 =========================

overlay_protected = xwt.drawing.image.fromresource("lock-required-overlay-16.png");	overlay_unlocked = xwt.drawing.image.fromresource("unlocked-overlay-16.png");	overlay_locked = xwt.drawing.image.fromresource("locked-overlay-16.png");	overlay_ignored = xwt.drawing.image.fromresource("ignored-overlay-16.png");	icon_modified = imageservice.geticon ("vc-file-modified", gtk.iconsize.menu);	icon_removed = imageservice.geticon ("vc-file-removed", gtk.iconsize.menu);	icon_conflicted = imageservice.geticon ("vc-file-conflicted", gtk.iconsize.menu);	icon_added = imageservice.geticon ("vc-file-added", gtk.iconsize.menu);	icon_controled = xwt.drawing.image.fromresource("versioned-overlay-16.png");	} catch (exception e) {	
error while loading icons 

static void onextensionchanged (object s, extensionnodeeventargs args) {	versioncontrolsystem vcs;	try {	vcs = (versioncontrolsystem) args.extensionobject;	} catch (exception e) {	
failed to initialize versioncontrolsystem type 

return;	}	if (args.change == extensionchange.add) {	handlers.add (vcs);	try {	repository r = vcs.createrepositoryinstance ();	r.addref ();	datacontext.includetype (r.gettype ());	r.unref ();	} catch (exception e) {	
error while adding version control system 

========================= monodevelop sample_4189 =========================

}	}	}	break;	default: if (alreadyaddedreference.add (filename)) appendquoted (sb, "/r:", refprefix + filename);	break;	}	}	}	if (alreadyaddedreference.any (reference => systemassemblyservice.containsreferencetosystemruntime (reference))) {	
found assembly 

} else {	appendquoted (sb, "/win32icon:", projectparameters.win32icon);	}	}	if (projectparameters.codepage != 0) sb.append ("/codepage:").appendline (projectparameters.codepage.tostring ());	else if (runtime is monotargetruntime) sb.appendline ("/codepage:utf8");	if (compilerparameters.unsafecode) sb.appendline ("-unsafe");	if (compilerparameters.nostdlib) sb.appendline ("-nostdlib");	if (!string.isnullorempty (compilerparameters.platformtarget) && !string.equals (compilerparameters.platformtarget, "anycpu", stringcomparison.ordinalignorecase)) {	if (runtime.runtimeid == "mono" && runtime.assemblycontext.getassemblylocation ("mono.debugger.soft", null) == null) {	
mono runtime appears to be too old to support the platform c compiler flag 

}	if (!compilerparameters.documentationfile.isnullorempty) appendquoted (sb, "/doc:", compilerparameters.documentationfile);	if (!string.isnullorempty (compilerparameters.nowarnings)) appendquoted (sb, "/nowarn:", compilerparameters.nowarnings);	if (runtime.runtimeid == "ms.net") {	sb.appendline("/fullpaths");	sb.appendline("/utf8output");	}	string output = "";	string error  = "";	file.writealltext (responsefilename, sb.tostring ());	
noconfig 

string cargs = "/noconfig @\"" + responsefilename + "\"";	int exitcode = docompilation (monitor, compilername, cargs, workingdir, envvars, gacroots, ref output, ref error);	buildresult result = parseoutput (workingdir, output, error);	if (result.compileroutput.trim ().length != 0) monitor.log.writeline (result.compileroutput);	if (result.errorcount == 0 && exitcode != 0) {	try {	monitor.log.write (file.readalltext (error));	} catch (ioexception) {	}	result.adderror ("the compiler appears to have crashed. check the build output pad for details.");	
c compiler crashed response file stdout file stderr file 

========================= monodevelop sample_3908 =========================

public delegate void databaseconnectioncontextcallback (databaseconnectioncontext context, bool connected, object state);	public static class queryservice {	public static void raiseexception (exception exception) {	messageservice.showexception (exception);	
database exception 

public delegate void databaseconnectioncontextcallback (databaseconnectioncontext context, bool connected, object state);	public static class queryservice {	public static void raiseexception (exception exception) {	messageservice.showexception (exception);	}	public static void raiseexception (string message, exception exception) {	messageservice.showexception (exception, message);	
database exception 

========================= monodevelop sample_5247 =========================

protected override string generateinfo (string filename) {	try {	var doc = typesystemservice.parsefile (null, filename, desktopservice.getmimetypeforuri (filename), stringtextsource.readfrom (filename)).result as webformsparseddocument;	if (doc != null && !string.isnullorempty (doc.info.inheritedclass)) return doc.info.inheritedclass;	} catch (exception ex) {	
error reading codebehind name for file 

========================= monodevelop sample_4877 =========================

static extern bool setdlldirectory (string lppathname);	static void initwindowsnativelibs () {	string location = null;	using (var key = microsoft.win32.registry.localmachine.opensubkey(@"software\xamarin\gtksharp\installfolder")) {	if (key != null) {	location = key.getvalue (null) as string;	}	}	if (location == null || !file.exists (path.combine (location, "bin", "libgtk-win32-2.0-0.dll"))) {	
did not find registered gtk installation 

if (location == null || !file.exists (path.combine (location, "bin", "libgtk-win32-2.0-0.dll"))) {	return;	}	var path = path.combine (location, @"bin");	try {	if (setdlldirectory (path)) {	return;	}	} catch (entrypointnotfoundexception) {	}	
unable to set gtk dll directory 

========================= monodevelop sample_2338 =========================

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	
mono addins setup utility 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	
usage mautil options command arguments 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
options 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
path p specify the startup path of the application 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
registry reg specify the add in registry path 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
addinspath ap specify the default add ins path of the application 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
the path can be absolute or relative to the registry path 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
cachepath cp specify add in cache path for the application 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
the path can be absolute or relative to the registry path 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
package pkg specify the package name of the application 

public static int main(string[] args) {	if (args.length == 0 || args [0] == "--help" || args [0] == "help") {	console.writeline ();	
v verbose output use multiple times to increase log level 

int verbose = 1;	string path = null;	string startuppath = null;	string addinspath = null;	string databasepath = null;	string package = null;	bool toolparam = true;	while (toolparam && ppos < args.length) {	if (args [ppos] == "-reg" || args [ppos] == "--registry") {	if (ppos + 1 >= args.length) {	
registry path not provided 

while (toolparam && ppos < args.length) {	if (args [ppos] == "-reg" || args [ppos] == "--registry") {	if (ppos + 1 >= args.length) {	return 1;	}	path = args [ppos + 1];	ppos += 2;	}	else if (args [ppos] == "-p" || args [ppos] == "--path") {	if (ppos + 1 >= args.length) {	
startup path not provided 

}	else if (args [ppos] == "-p" || args [ppos] == "--path") {	if (ppos + 1 >= args.length) {	return 1;	}	startuppath = args [ppos + 1];	ppos += 2;	}	else if (args [ppos] == "-ap" || args [ppos] == "--addinspath") {	if (ppos + 1 >= args.length) {	
add ins path not provided 

}	else if (args [ppos] == "-ap" || args [ppos] == "--addinspath") {	if (ppos + 1 >= args.length) {	return 1;	}	addinspath = args [ppos + 1];	ppos += 2;	}	else if (args [ppos] == "-cp" || args [ppos] == "--cachepath") {	if (ppos + 1 >= args.length) {	
add ins cache path not provided 

}	else if (args [ppos] == "-cp" || args [ppos] == "--cachepath") {	if (ppos + 1 >= args.length) {	return 1;	}	databasepath = args [ppos + 1];	ppos += 2;	}	else if (args [ppos] == "-pkg" || args [ppos] == "--package") {	if (ppos + 1 >= args.length) {	
package name not provided 

ppos += 2;	}	else if (args [ppos] == "-v") {	verbose++;	ppos++;	} else toolparam = false;	}	addinregistry reg;	if (package != null) {	if (startuppath != null || path != null || addinspath != null || databasepath != null) {	
the registry path cachepath and addinspath options can t be used when package is specified 

ppos++;	} else toolparam = false;	}	addinregistry reg;	if (package != null) {	if (startuppath != null || path != null || addinspath != null || databasepath != null) {	return 1;	}	application app = setupservice.getextensibleapplication (package);	if (app == null) {	
the package could not be found or does not provide add in registry information 

========================= monodevelop sample_11430 =========================

status = teststatus.loading;	var discoveredtests = await vstestdiscoveryadapter.instance.discovertestsasync (project);	var tests = discoveredtests.buildtestinfo (this);	status = teststatus.ready;	tests.clear ();	foreach (unittest test in tests) {	tests.add (test);	}	ontestchanged ();	} catch (exception e) {	
failed to discover unit tests 

========================= monodevelop sample_4416 =========================

public async void simplevoidmethod() {	
before 

public async void simplevoidmethod() {	await task.delay(timespan.fromseconds(1.0));	
after 

public async void voidmethodwithoutawait() {	
no await 

public async task simplevoidtaskmethod() {	
before 

public async task simplevoidtaskmethod() {	await task.delay(timespan.fromseconds(1.0));	
after 

public async task taskmethodwithoutawait() {	
no await 

public async task<bool> simplebooltaskmethod() {	
before 

public async task<bool> simplebooltaskmethod() {	await task.delay(timespan.fromseconds(1.0));	
after 

public async void twoawaitswithdifferentawaitertypes() {	
before 

public async void twoawaitswithdifferentawaitertypes() {	if (await this.simplebooltaskmethod()) {	await task.delay(timespan.fromseconds(1.0));	}	
after 

public async void awaitinloopcondition() {	while (await this.simplebooltaskmethod()) {	
body 

public async task taskmethodwithoutawaitbutwithexceptionhandling() {	try {	using (new stringwriter()) {	
no await 

public async task taskmethodwithoutawaitbutwithexceptionhandling() {	try {	using (new stringwriter()) {	}	}	catch (exception) {	
crash 

public async task awaitwithstack(task<int> task) {	
a 

public async task awaitwithstack2(task<int> task) {	if (await this.simplebooltaskmethod()) {	
a 

public async task awaitwithstack2(task<int> task) {	if (await this.simplebooltaskmethod()) {	}	else {	int num = 1;	
a 

========================= monodevelop sample_491 =========================

protected override registrationinfo generateinfo (string filename) {	try {	using (var reader = new xmltextreader (filename) { whitespacehandling = whitespacehandling.none }) {	var doc = xdocument.load (reader);	return readfrom (filename, doc);	}	} catch (exception ex) {	
error reading registration info from file 

========================= monodevelop sample_4884 =========================

public void testaddbracestoif() {	test<addbracesaction>(@"class testclass {	void test () {	
hello 

public void testaddbracestoif() {	test<addbracesaction>(@"class testclass {	void test () {	}	}",@"class testclass {	void test () {	if (true) {	
hello 

public void testaddbracestoelse() {	test<addbracesaction>(@"class testclass {	void test () {	if (true) {	
hello 

public void testaddbracestoelse() {	test<addbracesaction>(@"class testclass {	void test () {	if (true) {	
world 

public void testaddbracestoelse() {	test<addbracesaction>(@"class testclass {	void test () {	if (true) {	}	}", @"class testclass {	void test () {	if (true) {	
hello 

public void testaddbracestoelse() {	test<addbracesaction>(@"class testclass {	void test () {	if (true) {	}	}", @"class testclass {	void test () {	if (true) {	} else {	
world 

public void testaddbracestodowhile() {	test<addbracesaction>(@"class testclass {	void test () {	
hello 

public void testaddbracestodowhile() {	test<addbracesaction>(@"class testclass {	void test () {	while (true);	}	}", @"class testclass {	void test () {	do {	
hello 

public void testaddbracestoforeach() {	test<addbracesaction>(@"class testclass {	void test () {	
hello 

public void testaddbracestoforeach() {	test<addbracesaction>(@"class testclass {	void test () {	}	}", @"class testclass {	void test () {	foreach (var a in b) {	
hello 

public void testaddbracestofor() {	test<addbracesaction>(@"class testclass {	void test () {	
hello 

public void testaddbracestofor() {	test<addbracesaction>(@"class testclass {	void test () {	}	}", @"class testclass {	void test () {	for (;;) {	
hello 

public void testaddbracestolock() {	test<addbracesaction>(@"class testclass {	void test () {	
hello 

public void testaddbracestolock() {	test<addbracesaction>(@"class testclass {	void test () {	}	}", @"class testclass {	void test () {	lock (this) {	
hello 

public void testaddbracestousing() {	test<addbracesaction>(@"class testclass {	void test () {	$using (var a = new a ()) console.writeline (""hello"");	}	}", @"class testclass {	void test () {	using (var a = new a ()) {	
hello 

public void testaddbracestowhile() {	test<addbracesaction>(@"class testclass {	void test () {	
hello 

public void testaddbracestowhile() {	test<addbracesaction>(@"class testclass {	void test () {	}	}", @"class testclass {	void test () {	while (true) {	
hello 

public void testblockalreadyinserted() {	testwrongcontext<addbracesaction>(@"class testclass {	void test () {	$if (true) {	
hello 

public void testnullnode() {	testwrongcontext<addbracesaction>(@"class testclass {	void test () {	if (true) {	
hello 

========================= monodevelop sample_8681 =========================

if (buildexpressions) {	writeclassdeclaration (info, document);	document.appendline ("{");	document.appendline ("void generated ()");	document.appendline ("{");	foreach (var node in info.xexpressions) {	bool isblock = node is webformsrenderblock;	var start = data.locationtooffset (node.region.begin.line, node.region.begin.column) + 2;	var end = data.locationtooffset (node.region.end.line, node.region.end.column) - 2;	if (!isblock) {	
writeline 

========================= monodevelop sample_4903 =========================

public void disassemble(methodbody body, methoddebugsymbols debugsymbols) {	methoddefinition method = body.method;	
output writeline maxstack 

========================= monodevelop sample_547 =========================

public void testcase1() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase1() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalidcase1() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase2() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase2() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalidcase2() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase3() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase3() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testcase4() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase4() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalidcase4() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase5() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase5() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testcase6() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
foo bar 

public void testcase6() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	}	}", @" class test {	void foo () {	
foo bar 

public void testinvalid() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo () {	
a b 

public void testcomplex() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo (bool b) {	
foo bar 

public void testcomplex() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo (bool b) {	}	}", @" class test {	void foo (bool b) {	
foo bar 

public void testdisable() {	analyze<stringcompareisculturespecificanalyzer>(@" class test {	void foo() {	
csharpdiagnosticids stringcompareisculturespecificanalyzerid foo bar 

========================= monodevelop sample_6857 =========================

static gtk.menuitem createmenuitem (commandmanager manager, command cmd, object cmdid, bool isarraymaster, string overridelabel, bool disabledvisible) {	cmdid = commandmanager.tocommandid (cmdid);	if (cmdid == commandmanager.tocommandid (command.separator)) return new gtk.separatormenuitem ();	if (cmd == null) cmd = manager.getcommand (cmdid);	if (cmd == null) {	
unknown command 

========================= monodevelop sample_895 =========================

public override bool execute () {	if (string.isnullorempty (extensiondomain)) {	
extensiondomain item not found 

public override bool execute () {	if (string.isnullorempty (extensiondomain)) {	return false;	}	if (addinreferences == null) {	return true;	}	application app = setupservice.getextensibleapplication (extensiondomain);	if (app == null) {	
extension domain not found 

return true;	}	application app = setupservice.getextensibleapplication (extensiondomain);	if (app == null) {	return false;	}	foreach (itaskitem item in addinreferences) {	string addinid = item.itemspec.replace (':',',');	addin addin = app.registry.getaddin (addinid);	if (addin == null) {	
add in not found 

if (app == null) {	return false;	}	foreach (itaskitem item in addinreferences) {	string addinid = item.itemspec.replace (':',',');	addin addin = app.registry.getaddin (addinid);	if (addin == null) {	return false;	}	if (addin.description == null) {	
add in could not be loaded 

========================= monodevelop sample_11677 =========================

public int pastetext (int offset, string text, byte[] copydata, ref idisposable undogroup) {	if (textpastehandler != null) {	string newtext;	try {	newtext = textpastehandler.formatplaintext (offset, text, copydata);	} catch (exception e) {	
text paste handler exception 

========================= monodevelop sample_674 =========================

long memorywithfullpc = gc.gettotalmemory(true) - startmemory;	interningprovider p = new interningprovider();	cecilloader loader = new cecilloader();	loader.interningprovider = p;	pc = loadprojects(loader);	printstatistics(p);	loader = null;	p = null;	long memorywithinternedpc = gc.gettotalmemory(true) - startmemory;	gc.keepalive(pc);	
kb kb 

========================= monodevelop sample_8435 =========================

col++;	}	if (i == currentparameter) markup.append ("</b>");	}	markup.appendtaggedtext (theme, item.suffixdisplayparts);	list<taggedtext> documentation;	try {	documentation = item.documentationfactory (canceltoken).tolist ();	} catch (exception e) {	documentation = emptytaggedtextlist;	
error while getting parameter documentation 

markup.appendtaggedtext (theme, documentation, 0, maxparamcolumncount);	markup.append ("</span>");	}	if (currentparameter >= 0 && currentparameter < item.parameters.length) {	var p = item.parameters [currentparameter];	if (p.documentationfactory != null) {	try {	documentation = p.documentationfactory (canceltoken).tolist ();	} catch (exception e) {	documentation = emptytaggedtextlist;	
error while getting parameter documentation 

========================= monodevelop sample_967 =========================

protected virtual void onbuttonokclicked (object sender, system.eventargs e) {	if (!validatechanges ()) return;	try {	applychanges ();	} catch (exception ex) {	
error saving options changes 

========================= monodevelop sample_936 =========================

public void testnonredundantfloatcast () {	testwrongcontext<redundantcastissue> (@" class foo {	void bar () {	float f = 5.6f;	
foo 

public void testnonredundantfloatcastcase2 () {	testwrongcontext<redundantcastissue> (@" using system;	class foo {	void bar () {	float f = 5.6f;	
foo 

========================= monodevelop sample_8487 =========================

protected override string processcontent (string content, istringtagmodel tags) {	using (var host = new filetemplatehost (tags)) {	string s = srcfile;	string output;	host.processtemplate (s, content, ref s, out output);	if (host.errors.haserrors) {	
error in template generator 

========================= monodevelop sample_4641 =========================

public static void initialise () {	if (schemas != null) return;	schemas = new dictionary<string, htmlschema> ();	foreach (doctypeextensionnode node in mono.addins.addinmanager.getextensionnodes ("/monodevelop/html/doctypes")) {	
htmlschemaservice cannot register duplicate doctype with the name 

public static void initialise () {	if (schemas != null) return;	schemas = new dictionary<string, htmlschema> ();	foreach (doctypeextensionnode node in mono.addins.addinmanager.getextensionnodes ("/monodevelop/html/doctypes")) {	if (!string.isnullorempty (node.xsdfile)) {	string path = node.addin.getfilepath (node.xsdfile);	try {	ixmlcompletionprovider provider = new xmlschemacompletiondata (path);	schemas.add (node.name, new htmlschema (node.name, node.fullname, provider));	} catch (exception ex) {	
htmlschemaservice encountered an error registering the schema 

schemas.add (node.name, new htmlschema (node.name, node.fullname, node.completiondoctypename));	}	}	if (!schemas.containskey (defaultdoctypename)) {	htmlschema defaultsubstprovider = schemas["xhtml 1.0 transitional"];	ixmlcompletionprovider provider;	if (defaultsubstprovider != null) {	loadschema (defaultsubstprovider, true);	provider = defaultsubstprovider.completionprovider;	} else {	
completion schema for default html doctype not found 

htmlschema defaultsubstprovider = schemas["xhtml 1.0 transitional"];	ixmlcompletionprovider provider;	if (defaultsubstprovider != null) {	loadschema (defaultsubstprovider, true);	provider = defaultsubstprovider.completionprovider;	} else {	provider = new emptyxmlcompletionprovider ();	}	schemas[defaultdoctypename] = new htmlschema ("html 4.01 transitional", "<!doctype html public \"- + "\"http: provider);	}	
htmlschemaservice initialised 

========================= monodevelop sample_4942 =========================

public void testunsafeclass () {	test<redundantunsafecontextissue>(@" unsafe class foo {	public static void main (string[] args) {	
hello 

public void testunsafeclass () {	test<redundantunsafecontextissue>(@" unsafe class foo {	public static void main (string[] args) {	}	}	", @" class foo {	public static void main (string[] args) {	
hello 

public void testunsafestatement () {	test<redundantunsafecontextissue>(@" class foo {	public static void main (string[] args) {	unsafe {	
hello 

public void testunsafestatement () {	test<redundantunsafecontextissue>(@" class foo {	public static void main (string[] args) {	unsafe {	
hello 

public void testunsafestatement () {	test<redundantunsafecontextissue>(@" class foo {	public static void main (string[] args) {	unsafe {	}	}	}	", @" class foo {	public static void main (string[] args) {	
hello 

public void testunsafestatement () {	test<redundantunsafecontextissue>(@" class foo {	public static void main (string[] args) {	unsafe {	}	}	}	", @" class foo {	public static void main (string[] args) {	
hello 

public void testdisable () {	testwrongcontext<redundantunsafecontextissue>(@" unsafe class foo {	public static void main (string[] args) {	
hello 

========================= monodevelop sample_8607 =========================

return;	}	this.updatetimer = new timer (1000);	this.updatetimer.elapsed += this.onupdatetimerellapsed;	this.updatetimer.autoreset = false;	this.recentfiles = desktopservice.recentfiles;	this.recentfiles.changed += this.onrecentfileschanged;	try {	updatejumplist();	} catch (exception ex) {	
could not update jumplists 

private void onupdatetimerellapsed (object sender, eventargs args) {	try {	updatejumplist();	} catch (exception ex) {	
could not update jumplists 

========================= monodevelop sample_3377 =========================

});	if(base.cancellationpending) return;	lock(lockcounter) {	counter++;	dispatchservice.guisyncdispatch (delegate {	ideapp.workbench.statusbar.setprogressfraction (counter / (double)totalprojects);	});	}	}	} catch (exception ex) {	
error 

========================= monodevelop sample_4735 =========================

if (parseddocument == null) return task.fromresult (emptylist);	var semanticmodel = parseddocument.getast<semanticmodel> ();	if (semanticmodel == null) return task.fromresult (emptylist);	if (!hasmethodmarkerattribute (semanticmodel, unittestmarkers)) return task.fromresult (emptylist);	var visitor = new nunitvisitor (semanticmodel, unittestmarkers, token);	try {	visitor.visit (semanticmodel.syntaxtree.getroot (token));	} catch (operationcanceledexception) {	throw;	}catch (exception ex) {	
exception while analyzing ast for unit tests 

========================= monodevelop sample_3858 =========================

public override int compareobjects (itreenavigator thisnode, itreenavigator othernode) {	try {	if (thisnode == null || othernode == null) return -1;	var e1 = thisnode.dataitem as assemblyloader;	var e2 = othernode.dataitem as assemblyloader;	if (e1 == null && e2 == null) return 0;	if (e1 == null || e1.assembly == null) return 1;	if (e2 == null || e2.assembly == null) return -1;	return string.compare (e1.assembly.name.name, e2.assembly.name.name, stringcomparison.ordinal);	} catch (exception e) {	
exception in assembly browser sort function 

public list<referencesegment> disassemble (texteditor data, itreenavigator navigator) {	var assemblyloader = (assemblyloader)navigator.dataitem;	var assembly = assemblyloader.unresolvedassembly;	var compilationunit = assemblyloader.assembly;	if (compilationunit == null) {	
can t get cecil object for assembly 

========================= monodevelop sample_2437 =========================

static bool canreferencenetstandardproject (dotnetproject project, dotnetproject targetproject) {	try {	return dotnetcoreframeworkcompatibility.canreferencenetstandardproject (project, targetproject);	} catch (exception ex) {	
error checking target framework compatibility 

========================= monodevelop sample_2526 =========================

case "suite-finished": if (testname == roottestname) {	finishsuites (0);	listener.suitefinished ("<root>", createresult (element));	rootsuitestarted = false;	}	break;	}	}	}	} catch (exception ex) {	
exception in test listener 

========================= monodevelop sample_2644 =========================

public void openstylesheetcommand () {	if (!string.isnullorempty (stylesheetfilename)) {	try {	ideapp.workbench.opendocument (stylesheetfilename, documentcontext.project);	} catch (exception ex) {	
could not open document 

public void gotoschemadefinitioncommand () {	try {	xmlschemacompletiondata currentschemacompletiondata = findschemafromfilename (filename);	xmlschemaobject schemaobject = getschemaobjectselected (currentschemacompletiondata);	if (schemaobject != null && schemaobject.sourceuri != null && schemaobject.sourceuri.length > 0) {	string schemafilename = schemaobject.sourceuri.replace ("file:/", string.empty);	ideapp.workbench.opendocument ( schemafilename, documentcontext.project, math.max (1, schemaobject.linenumber), math.max (1, schemaobject.lineposition));	}	} catch (exception ex) {	
could not open document 

========================= monodevelop sample_3528 =========================

public packagemanagementprojectservice () {	if (ideapp.workspace != null) {	ideapp.workspace.solutionloaded += (sender, e) => onsolutionloaded (e.solution);	ideapp.workspace.solutionunloaded += (sender, e) => onsolutionunloaded (e.solution);	} else {	
ideapp workspace is not available when creating packagemanagementprojectservice 

========================= monodevelop sample_2856 =========================

protected virtual void oncmdremoveclicked (object sender, system.eventargs e) {	bool removed = false;	
oncmdremoveclicked 

========================= monodevelop sample_4088 =========================

if (cls != null) {	typeclassdescriptor = findtype (cls);	tname = cls.name;	if (typeclassdescriptor != null) {	element.setattribute ("baseclasstype", typeclassdescriptor.name);	objects_dirty = true;	}	}	}	if (typeclassdescriptor == null) {	
descriptor not found 

========================= monodevelop sample_3579 =========================

public static dotnetcoreversion getdotnetcoreversionfromdirectory (string directory) {	string directoryname = path.getfilename (directory);	dotnetcoreversion version = null;	if (tryparse (directoryname, out version)) return version;	
unable to parse version from directory 

========================= monodevelop sample_2512 =========================

public static void main (string[] args) {	
hello world 

========================= monodevelop sample_188 =========================

public void callpinvoke_geterror_invalid () {	messagebeep (5);	
fail 

========================= monodevelop sample_10214 =========================

public void implemented2 () {	
foo 

========================= monodevelop sample_10185 =========================

public static void main (string[] args) {	
hello world 

========================= monodevelop sample_328 =========================

using (var sw = new streamwriter (temppath)) {	write (sw);	}	fileservice.systemrename (temppath, path);	gtk.application.invoke ((o, args) => {	fileservice.notifyfilechanged (path);	});	writtencount++;	} catch (ioexception ex) {	if (monitor != null) monitor.reporterror (gettextcatalog.getstring ("failed to write file '{0}'.", path), ex);	
codebehindwriter failed 

}	fileservice.systemrename (temppath, path);	gtk.application.invoke ((o, args) => {	fileservice.notifyfilechanged (path);	});	writtencount++;	} catch (ioexception ex) {	if (monitor != null) monitor.reporterror (gettextcatalog.getstring ("failed to write file '{0}'.", path), ex);	} catch (exception ex) {	if (monitor != null) monitor.reporterror (gettextcatalog.getstring ("failed to generate code for file '{0}'.", path), ex);	
codebehindwriter failed 

try {	var temppath = path.parentdirectory.combine (".#" + path.filename);	file.writealltext (temppath, contents);	fileservice.systemrename (temppath, path);	gtk.application.invoke ((o, args) => {	fileservice.notifyfilechanged (path);	});	writtencount++;	} catch (ioexception ex) {	if (monitor != null) monitor.reporterror (gettextcatalog.getstring ("failed to write file '{0}'.", path), ex);	
codebehindwriter failed 

file.writealltext (temppath, contents);	fileservice.systemrename (temppath, path);	gtk.application.invoke ((o, args) => {	fileservice.notifyfilechanged (path);	});	writtencount++;	} catch (ioexception ex) {	if (monitor != null) monitor.reporterror (gettextcatalog.getstring ("failed to write file '{0}'.", path), ex);	} catch (exception ex) {	if (monitor != null) monitor.reporterror (gettextcatalog.getstring ("failed to generate code for file '{0}'.", path), ex);	
codebehindwriter failed 

}	}	if (!updated) {	var textfile = monodevelop.projects.text.textfile.readfile (item.key);	textfile.text = item.value;	textfile.save ();	}	writtencount++;	} catch (ioexception ex) {	if (monitor != null) monitor.reporterror (gettextcatalog.getstring ("failed to write file '{0}'.", item.key), ex);	
codebehindwriter failed 

========================= monodevelop sample_2446 =========================

class bar {	override foo }	public foo () {	}	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var constructor = type.members.skip(1).first() as constructordeclaration;	var passed = !constructor.hasmodifier(modifiers.override);	if (!passed) {	
expected 

class bar {	override foo }	public foo () {	}	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var constructor = type.members.skip(1).first() as constructordeclaration;	var passed = !constructor.hasmodifier(modifiers.override);	if (!passed) {	
was 

public void testbug4059() {	string code = @" class stub {	test a () {	return new test () }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = method.body.statements.firstordefault() is returnstatement;	if (!passed) {	
expected 

public void testbug4059() {	string code = @" class stub {	test a () {	return new test () }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = method.body.statements.firstordefault() is returnstatement;	if (!passed) {	
was 

public void testbug4058() {	string code = @" class testclass {	testclass([attr]) {	}	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var constructor = type.members.first() as constructordeclaration;	bool passed = constructor.getnodeat<attributesection>(constructor.lpartoken.startlocation.line, constructor.lpartoken.startlocation.column + 1) != null;	if (!passed) {	
expected 

public void testbug4058() {	string code = @" class testclass {	testclass([attr]) {	}	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var constructor = type.members.first() as constructordeclaration;	bool passed = constructor.getnodeat<attributesection>(constructor.lpartoken.startlocation.line, constructor.lpartoken.startlocation.column + 1) != null;	if (!passed) {	
was 

public void testbug3952() {	string code = @" class foo {	void bar() {	test(new foo ( }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = !method.body.isnull;	if (!passed) {	
expected 

public void testbug3952() {	string code = @" class foo {	void bar() {	test(new foo ( }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = !method.body.isnull;	if (!passed) {	
was 

string code = {	void bar () {	for (int i = 0; i < foo.bar) }	}";	var unit = syntaxtree.parse(code);	bool passed = @"class foo {	void bar () {	for (int i = 0; i < foo.bar;) }	}" == unit.tostring().trim ();	if (!passed) {	
expected 

string code = {	void bar () {	for (int i = 0; i < foo.bar) }	}";	var unit = syntaxtree.parse(code);	bool passed = @"class foo {	void bar () {	for (int i = 0; i < foo.bar;) }	}" == unit.tostring().trim ();	if (!passed) {	
was 

void foo () {	a = cond ? expr }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	var exprstmt = method.body.statements.firstordefault() as expressionstatement;	var expr = exprstmt.expression as assignmentexpression;	bool passed = expr != null && expr.right is conditionalexpression;	if (!passed) {	
expected 

void foo () {	a = cond ? expr }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	var exprstmt = method.body.statements.firstordefault() as expressionstatement;	var expr = exprstmt.expression as assignmentexpression;	bool passed = expr != null && expr.right is conditionalexpression;	if (!passed) {	
was 

void foo () {	a = cond ? expr : }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	var exprstmt = method.body.statements.firstordefault() as expressionstatement;	var expr = exprstmt.expression as assignmentexpression;	bool passed = expr != null && expr.right is conditionalexpression;	if (!passed) {	
expected 

void foo () {	a = cond ? expr : }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	var exprstmt = method.body.statements.firstordefault() as expressionstatement;	var expr = exprstmt.expression as assignmentexpression;	bool passed = expr != null && expr.right is conditionalexpression;	if (!passed) {	
was 

public void testbug3468() {	string code = {	public static void main (string[] args) {	string str = }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = !method.body.isnull;	if (!passed) {	
expected 

public void testbug3468() {	string code = {	public static void main (string[] args) {	string str = }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = !method.body.isnull;	if (!passed) {	
was 

string code = {	public void main(string[] args) {	try {	} catch (exception name) }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = method.body.statements.firstordefault() is trycatchstatement;	if (!passed) {	
expected 

string code = {	public void main(string[] args) {	try {	} catch (exception name) }	}";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = method.body.statements.firstordefault() is trycatchstatement;	if (!passed) {	
was 

";	var unit = syntaxtree.parse(code);	bool passed = unit.tostring().trim() == @"using system;	class test {	void foo () {	action<int> act = delegate (int testme) {	};	}	}";	if (!passed) {	
expected 

";	var unit = syntaxtree.parse(code);	bool passed = unit.tostring().trim() == @"using system;	class test {	void foo () {	action<int> act = delegate (int testme) {	};	}	}";	if (!passed) {	
was 

public void testbug4556() {	string code = class foo {	public static void main (string[] args) {	
foo 

public void testbug4556() {	string code = class foo {	public static void main (string[] args) {	}	";	var unit = syntaxtree.parse(code);	var type = unit.members.first(m => m is typedeclaration) as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = !method.body.isnull;	if (!passed) {	
expected 

public void testbug4556() {	string code = class foo {	public static void main (string[] args) {	}	";	var unit = syntaxtree.parse(code);	var type = unit.members.first(m => m is typedeclaration) as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = !method.body.isnull;	if (!passed) {	
was 

j++;	continue;	}	if (text [i] != expected [j]) {	break;	}	i++;j++;	}	bool passed = i == text.length && j == expected.length;	if (!passed) {	
expected 

j++;	continue;	}	if (text [i] != expected [j]) {	break;	}	i++;j++;	}	bool passed = i == text.length && j == expected.length;	if (!passed) {	
was 

}	}	}	";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	var stmt = method.body.statements.first () as returnstatement;	bool passed = stmt.expression is objectcreateexpression;	if (!passed) {	
expected 

}	}	}	";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	var stmt = method.body.statements.first () as returnstatement;	bool passed = stmt.expression is objectcreateexpression;	if (!passed) {	
was 

public void testincompleteparameter() {	string code = {	void bar (params system.a) {}	}	";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = method.parameters.count == 1;	if (!passed) {	
expected 

public void testincompleteparameter() {	string code = {	void bar (params system.a) {}	}	";	var unit = syntaxtree.parse(code);	var type = unit.members.first() as typedeclaration;	var method = type.members.first() as methoddeclaration;	bool passed = method.parameters.count == 1;	if (!passed) {	
was 

========================= monodevelop sample_8801 =========================

throw;	}	}	console = context.consolefactory.createconsole (monitor.cancellationtoken);	string url = string.format ("http: if (isxsp) {	console = new xspbrowserlauncherconsole (console, delegate (string port) {	if (browserexctarget != null) browserexctarget.desktopapp.launch (string.format("{0}:{1}", url, port));	else browserlauncher.launchdefaultbrowser (string.format("{0}:{1}", url, port));	});	}	
running web server 

if (browserexctarget != null) browserexctarget.desktopapp.launch (string.format("{0}:{1}", url, port));	else browserlauncher.launchdefaultbrowser (string.format("{0}:{1}", url, port));	});	}	var op = context.executionhandler.execute (cmd, console);	if (!isxsp) {	if (browserexctarget != null) browserexctarget.desktopapp.launch (url);	else browserlauncher.launchdefaultbrowser (url);	}	using (monitor.cancellationtoken.register (op.cancel)) await op.task;	
the web server exited with code 

});	}	var op = context.executionhandler.execute (cmd, console);	if (!isxsp) {	if (browserexctarget != null) browserexctarget.desktopapp.launch (url);	else browserlauncher.launchdefaultbrowser (url);	}	using (monitor.cancellationtoken.register (op.cancel)) await op.task;	} catch (exception ex) {	if (!(ex is userexception)) {	
could not launch asp net web server 

========================= monodevelop sample_4907 =========================

private static void accepttypedref(typedreference tr) {	
value is 

private static void accepttypedref(typedreference tr) {	
type is 

========================= monodevelop sample_512 =========================

protected override ilist<recentfile> ongetprojects () {	try {	return get (projgroup);	} catch (exception e) {	
can t get recent projects list 

protected override ilist<recentfile> ongetfiles () {	try {	return get (filegroup);	} catch (exception e) {	
can t get recent files list 

public override void clearprojects () {	try {	recentfiles.cleargroup (projgroup);	} catch (exception e) {	
can t clear recent projects list 

public override void clearfiles () {	try {	recentfiles.cleargroup (filegroup);	} catch (exception e) {	
can t get recent files list 

public override void notifyfileremoved (string filename) {	try {	setfavoritefile (filename, false);	recentfiles.removeitem (recentfilestorage.touri (filename));	} catch (exception e) {	
can t remove from recent files list 

public override void notifyfilerenamed (string oldname, string newname) {	try {	recentfiles.renameitem (recentfilestorage.touri (oldname), recentfilestorage.touri (newname));	} catch (exception e) {	
can t rename file in recent files list 

========================= monodevelop sample_1203 =========================

public void writelog (string message) {	
starting logging 

public void writelog (string message) {	
logging for 

public void printbanner () {	
this is a simple banner 

public void printbanner () {	
for the incredible foo bar program 

public void printbanner () {	
send your suggestions to foo domain com 

========================= monodevelop sample_10618 =========================

public void testlocalconstant() {	test<introduceconstantaction>(@"class testclass {	public void hello () {	
hello world 

public void testfieldconstant() {	test<introduceconstantaction>(@"class testclass {	public void hello () {	
hello world 

public void testlocalconstantreplaceall() {	test<introduceconstantaction>(@"class testclass {	public void hello () {	
hello world 

public void testlocalconstantreplaceall() {	test<introduceconstantaction>(@"class testclass {	public void hello () {	
hello world 

public void testlocalconstantreplaceall() {	test<introduceconstantaction>(@"class testclass {	public void hello () {	
hello world 

========================= monodevelop sample_6976 =========================

} else {	filename = file.filepath.fullpath;	}	if (!hashset.add (filename)) continue;	var metadatareference = metadatareferencecache.loadreference (projectid, filename);	if (metadatareference == null) continue;	metadatareference = metadatareference.withaliases (file.enumeratealiases ());	result.add (metadatareference);	}	} catch (exception e) {	
error while getting referenced assemblies 

var referencedproject = pr as monodevelop.projects.dotnetproject;	if (referencedproject == null) continue;	if (typesystemservice.isoutputtrackedproject (referencedproject)) {	var filename = referencedproject.getoutputfilename (configurationselector);	if (!hashset.add (filename)) continue;	var metadatareference = metadatareferencecache.loadreference (projectid, filename);	if (metadatareference != null) result.add (metadatareference);	}	}	} catch (exception e) {	
error while getting referenced projects 

var formatter = codeformatterservice.getformatter (desktopservice.getmimetypeforuri (path));	if (formatter != null && mdproject != null) {	formattedtext = formatter.formattext (mdproject.policies, text.tostring ());	} else {	formattedtext = text.tostring ();	}	var textsource = new stringtextsource (formattedtext, text.encoding ?? system.text.encoding.utf8);	try {	textsource.writetextto (path);	} catch (exception e) {	
exception while saving file to 

protected override void applymetadatareferenceadded (projectid projectid, metadatareference metadatareference) {	var mdproject = getmonoproject (projectid) as monodevelop.projects.dotnetproject;	var path = getmetadatapath (metadatareference);	if (mdproject == null || path == null) return;	foreach (var r in mdproject.references) {	if (r.referencetype == monodevelop.projects.referencetype.assembly && r.reference == path) {	
warning duplicate reference is added 

var mdproject = getmonoproject (projectid) as monodevelop.projects.dotnetproject;	var path = getmetadatapath (metadatareference);	if (mdproject == null || path == null) return;	foreach (var r in mdproject.references) {	if (r.referencetype == monodevelop.projects.referencetype.assembly && r.reference == path) {	return;	}	if (r.referencetype == monodevelop.projects.referencetype.project) {	foreach (var fn in r.getreferencedfilenames (monodevelop.projects.configurationselector.default)) {	if (fn == path) {	
warning duplicate reference is added for project 

========================= monodevelop sample_1384 =========================

if (!string.isnullorempty (document.info.masterpagetypename)) {	mastertypename = document.info.masterpagetypename;	} else if (!string.isnullorempty (document.info.masterpagetypevpath)) {	try {	var ext = project.getservice<aspnetappprojectflavor> ();	projectfile resolvedmaster = ext.resolvevirtualpath (document.info.masterpagetypevpath, document.filename);	webformsparseddocument masterparseddocument = null;	if (resolvedmaster != null) masterparseddocument = typesystemservice.parsefile (project, resolvedmaster.filepath).result as webformsparseddocument;	if (masterparseddocument != null && !string.isnullorempty (masterparseddocument.info.inheritedclass)) mastertypename = masterparseddocument.info.inheritedclass;	} catch (exception ex) {	
error resolving master page type 

========================= monodevelop sample_4873 =========================

private static void setapplicabilityscope (irule rule, string applicabilityscope) {	switch (applicabilityscope) {	case "visible": rule.applicabilityscope = applicabilityscope.visible;	break;	case "nonvisible": rule.applicabilityscope = applicabilityscope.nonvisible;	break;	case "all": rule.applicabilityscope = applicabilityscope.all;	break;	
unknown scope value defaulting to all 

private int loadrulesfromassembly (string assembly, string includemask, string excludemask, string applicabilityscope) {	assembly a = null;	try {	assemblyname aname = assemblyname.getassemblyname (path.getfullpath (assembly));	a = assembly.load (aname);	}	catch (filenotfoundexception) {	
could not load rules from assembly 

========================= monodevelop sample_10649 =========================

public static void write(pofile po, string outpath) {	using (var stream = file.open(outpath, filemode.create)) using (var writer = new streamwriter(stream)) {	foreach (var line in po.copyrightheader) writer.writeline(line);	
msgid 

public static void write(pofile po, string outpath) {	using (var stream = file.open(outpath, filemode.create)) using (var writer = new streamwriter(stream)) {	foreach (var line in po.copyrightheader) writer.writeline(line);	
msgstr 

static void writeblock(poblock block, streamwriter writer, pofile po, bool ismessages) {	foreach (var item in block.metadata) writer.writeline(item);	
msgid 

static void writeblock(poblock block, streamwriter writer, pofile po, bool ismessages) {	foreach (var item in block.metadata) writer.writeline(item);	if (block.idplural != null) {	
msgid plural 

static void writeblock(poblock block, streamwriter writer, pofile po, bool ismessages) {	foreach (var item in block.metadata) writer.writeline(item);	if (block.idplural != null) {	for (int i = 0; i < po.nplurals; ++i) {	var translatedplural = block.gettranslatedplural(i);	if (translatedplural == null) continue;	string value = ismessages ? "" : translatedplural.replace("\r\n", "\n");	
msgstr i 

foreach (var item in block.metadata) writer.writeline(item);	if (block.idplural != null) {	for (int i = 0; i < po.nplurals; ++i) {	var translatedplural = block.gettranslatedplural(i);	if (translatedplural == null) continue;	string value = ismessages ? "" : translatedplural.replace("\r\n", "\n");	}	}	else {	string value = ismessages ? "" : block.translatedstring.replace("\r\n", "\n");	
msgstr 

========================= monodevelop sample_577 =========================

public void testsingleexpression() {	
imports system class testclass public sub testmethod str as string console writeline str end sub end class imports system class testclass public sub testmethod str as string if str isnot nothing then console writeline str end if end sub end class 

public void testvaluetype() {	
imports system class testclass public sub testmethod datetime as datetime console writeline datetime end sub end class 

public void testnullabletype() {	
imports system class testclass public sub testmethod datetime as datetime console writeline datetime end sub end class imports system class testclass public sub testmethod datetime as datetime if datetime isnot nothing then console writeline datetime end if end sub end class 

public void testmemberaccessexpression1() {	
imports system class somedata public property name as string end class class testclass public sub testmethod dim data as new somedata console writeline data name end sub end class imports system class somedata public property name as string end class class testclass public sub testmethod dim data as new somedata if data name isnot nothing then console writeline data name end if end sub end class 

public void testmemberaccessexpression2() {	
imports system class somedata public property name as string end class class testclass public sub testmethod dim data as new somedata console writeline data name end sub end class imports system class somedata public property name as string end class class testclass public sub testmethod dim data as new somedata if data isnot nothing then console writeline data name end if end sub end class 

public void testmemberaccessexpression3() {	
imports system class somedata public property subdata as somesubdata end class class somesubdata public property name as string end class class testclass public sub testmethod dim data as new somedata console writeline data subdata name end sub end class imports system class somedata public property subdata as somesubdata end class class somesubdata public property name as string end class class testclass public sub testmethod dim data as new somedata if data subdata isnot nothing then console writeline data subdata name end if end sub end class 

public void teststaticmemberaccessexpression() {	
imports system class somedata public shared property name as string end class class testclass public sub testmethod console writeline somedata name end sub end class 

public void testindexeraccess() {	
imports system class testclass public sub testmethod str as string console writeline str end sub end class imports system class testclass public sub testmethod str as string if str isnot nothing then console writeline str end if end sub end class 

public void testusageinifcondition() {	
imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string if list contains bla contains class bla then console writeline contains bla end if end sub end class 

public void testusageinifblock() {	
imports system class testclass public sub testmethod i as integer str as string if i then console writeline str end if end sub end class imports system class testclass public sub testmethod i as integer str as string if str isnot nothing andalso i then console writeline str end if end sub end class 

public void testusageinforeachloop() {	
imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string for each item in list console writeline item next end sub end class imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string if list isnot nothing then for each item in list console writeline item next end if end sub end class 

public void testusageinwhileloop() {	
imports system imports system collections generic class testclass public sub testmethod list as ilist of string while list count console writeline item list removeat end while end sub end class imports system imports system collections generic class testclass public sub testmethod list as ilist of string if list isnot nothing then while list count console writeline item list removeat end while end if end sub end class 

public void testalreadypresentifnotnullcheck1() {	
imports system class testclass public sub testmethod str as string if str isnot nothing then console writeline str end if end sub end class 

public void testalreadypresentifnotnullcheck2() {	
imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string if list isnot nothing andalso list contains bla class 

public void testalreadypresentifnotnullcheck3() {	
imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string if list isnot nothing andalso list contains bla class 

public void testalreadypresentifnotnullcheck4() {	
imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string if list isnot nothing andalso list contains bla class 

public void testalreadypresentifnotnullcheck5() {	
imports system class testclass public sub testmethod str as string if str isnot nothing then console writeline str end sub end class 

public void testalreadypresentnotnullcheckinwhileloop() {	
imports system class testclass public sub testmethod str as string yes this is an infinite loop while str isnot nothing console writeline str end while end sub end class 

public void testalreadypresentnullcheckinconditionalternaryexpression1() {	
imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string console writeline if list isnot nothing list first end sub end class 

public void testalreadypresentnullcheckinconditionalternaryexpression2() {	
imports system imports system collections generic class testclass public sub testmethod list as ienumerable of string console writeline if list isnot nothing list first end sub end class 

========================= monodevelop sample_6797 =========================

public void preservesbody() {	test<removecatchexceptioncoderefactoringprovider>(@" class testclass {	public void f() {	try {	} $catch (system.exception e) {	
hi 

test<removecatchexceptioncoderefactoringprovider>(@" class testclass {	public void f() {	try {	} $catch (system.exception e) {	}	}	}", @" class testclass {	public void f() {	try {	} catch {	
hi 

========================= monodevelop sample_6985 =========================

private void openfindsourcefiledialog (object sender, eventargs e) {	var sf = debuggingservice.currentframe;	if (sf == null) {	
currentframe was null in nameof openfindsourcefiledialog 

========================= monodevelop sample_4783 =========================

match match = projectlinepattern.match(line);	if (match.success) {	string typeguid = match.groups["typeguid"].value;	string title    = match.groups["title"].value;	string location = match.groups["location"].value;	string guid     = match.groups["guid"].value;	switch (typeguid.toupperinvariant()) {	case "{2150e333-8fdc-42a3-9474-1a3956d46de8}": break;	case "{fae04ec0-301f-11d3-bf4b-00c04f79efbc}": projects.add(new csharpproject(this, title, path.combine(directory, location)));	break;	
project has unsupported type 

========================= monodevelop sample_7978 =========================

public override void visit(membercore member) {	
unknown member 

public override void visit(membercore member) {	
member 

newtype.addchild(identifier.create(e.membername.name, convert(e.membername.location)), roles.identifier);	if (e.basetypeexpression != null) {	if (location != null && curloc < location.count) newtype.addchild(new csharptokennode(convert(location [curloc++]), roles.colon), roles.colon);	newtype.addchild(converttotype(e.basetypeexpression), roles.basetype);	}	if (location != null && curloc < location.count) newtype.addchild(new csharptokennode(convert(location [curloc++]), roles.lbrace), roles.lbrace);	typestack.push(newtype);	foreach (var m in e.members) {	var member = m as enummember;	if (member == null) {	
warning enum member 

static void addmodifiers(entitydeclaration parent, locationsbag.memberlocations location) {	if (location == null || location.modifiers == null) return;	foreach (var modifier in location.modifiers) {	modifiers mod;	if (!modifiertable.trygetvalue(modifier.item1, out mod)) {	
modifier can t be converted 

public override object visit(icsharpcode.nrefactory.monocsharp.statement stmt) {	
unknown statement 

public override object visit(icsharpcode.nrefactory.monocsharp.expression expression) {	
visit unknown expression 

========================= monodevelop sample_8415 =========================

e.handled = true;	};	applicationevents.reopen += delegate (object sender, applicationeventargs e) {	if (win != null) {	win.deiconify ();	win.visible = true;	e.handled = true;	}	};	} catch (exception ex) {	
installing mac appleevent handlers failed skipping 

win.deiconify ();	win.visible = true;	e.handled = true;	}	};	} catch (exception ex) {	}	try {	win.installmacglobalmenu ();	} catch (exception ex) {	
installing mac ige main menu failed skipping 

static void showhelp () {	
usage 

static void showhelp () {	
mdmonitor log file open log file 

static void showhelp () {	
mdmonitor c host port connect to running service 

========================= monodevelop sample_594 =========================

public bool doinserttemplate () {	string shortcut = codetemplate.gettemplateshortcutbeforecaret (editorextension.editor);	foreach (codetemplate template in codetemplateservice.getcodetemplatesasync (editorextension.editor).waitandgetresult (cancellationtoken.none)) {	if (template.shortcut == shortcut) {	var doc = view.workbenchwindow?.document ?? ideapp.workbench.activedocument;	if (doc != null) {	inserttemplate (template, doc.editor, doc);	} else {	
doinserttemplate can t find valid document 

========================= monodevelop sample_4513 =========================

public void testremovebracesfromif() {	test<removebracesaction>(@"class testclass {	void test () {	$if (true) {	
hello 

public void testremovebracesfromif() {	test<removebracesaction>(@"class testclass {	void test () {	$if (true) {	}	}	}", @"class testclass {	void test () {	
hello 

public void testremovebracesfromelse() {	test<removebracesaction>(@"class testclass {	void test () {	if (true) {	
hello 

public void testremovebracesfromelse() {	test<removebracesaction>(@"class testclass {	void test () {	if (true) {	} $else {	
world 

public void testremovebracesfromelse() {	test<removebracesaction>(@"class testclass {	void test () {	if (true) {	} $else {	}	}	}", @"class testclass {	void test () {	if (true) {	
hello 

public void testremovebracesfromelse() {	test<removebracesaction>(@"class testclass {	void test () {	if (true) {	} $else {	}	}	}", @"class testclass {	void test () {	if (true) {	
world 

public void testremovebracesfromdowhile() {	test<removebracesaction>(@"class testclass {	void test () {	$do {	
hello 

public void testremovebracesfromdowhile() {	test<removebracesaction>(@"class testclass {	void test () {	$do {	} while (true);	}	}", @"class testclass {	void test () {	
hello 

public void testremovebracesfromforeach() {	test<removebracesaction>(@"class testclass {	void test () {	$foreach (var a in b) {	
hello 

public void testremovebracesfromforeach() {	test<removebracesaction>(@"class testclass {	void test () {	$foreach (var a in b) {	}	}	}", @"class testclass {	void test () {	
hello 

public void testremovebracesfromfor() {	test<removebracesaction>(@"class testclass {	void test () {	$for (;;) {	
hello 

public void testremovebracesfromfor() {	test<removebracesaction>(@"class testclass {	void test () {	$for (;;) {	}	}	}", @"class testclass {	void test () {	
hello 

public void testremovebracesfromlock() {	test<removebracesaction>(@"class testclass {	void test () {	$lock (this) {	
hello 

public void testremovebracesfromlock() {	test<removebracesaction>(@"class testclass {	void test () {	$lock (this) {	}	}	}", @"class testclass {	void test () {	
hello 

public void testremovebracesfromusing() {	test<removebracesaction>(@"class testclass {	void test () {	$using (var a = new a ()) {	
hello 

public void testremovebracesfromwhile() {	test<removebracesaction>(@"class testclass {	void test () {	$while (true) {	
hello 

public void testremovebracesfromwhile() {	test<removebracesaction>(@"class testclass {	void test () {	$while (true) {	}	}	}", @"class testclass {	void test () {	
hello 

public void testnullnode() {	testwrongcontext<removebracesaction>(@"class testclass {	void test () {	if (true) {	
hello 

========================= monodevelop sample_8726 =========================

public override void writeto(itextoutput output) {	
try 

public override void writeto(itextoutput output) {	output.indent();	tryblock.writeto(output);	output.unindent();	output.writeline("}");	foreach (catchblock block in catchblocks) {	block.writeto(output);	}	if (faultblock != null) {	
fault 

foreach (catchblock block in catchblocks) {	block.writeto(output);	}	if (faultblock != null) {	output.indent();	faultblock.writeto(output);	output.unindent();	output.writeline("}");	}	if (finallyblock != null) {	
finally 

public override void writeto(itextoutput output) {	output.write("if (");	condition.writeto(output);	output.writeline(") {");	output.indent();	trueblock.writeto(output);	output.unindent();	output.write("}");	if (falseblock != null) {	
else 

public override void writeto(itextoutput output) {	if (this.values != null) {	foreach (int i in this.values) {	
case 

public override void writeto(itextoutput output) {	if (this.values != null) {	foreach (int i in this.values) {	}	} else {	
default 

========================= monodevelop sample_536 =========================

public void writea (string message) {	
fee fie fum 

========================= monodevelop sample_10599 =========================

public void clear () {	try {	recenttemplates.cleargroup (templategroup);	} catch (exception e) {	
can t clear recent templates list 

public void addtemplate (solutiontemplate template) {	try {	if (template.hasgroupid) removetemplatefromsamegroup (template);	var recentitem = createrecentitem (template);	recenttemplates.addwithlimit (recentitem, templategroup, itemlimit);	} catch (exception e) {	
failed to add item to recent templates list 

========================= monodevelop sample_1005 =========================

public xwt.drawing.image geticon () {	using (var stream = gettype ().assembly.getmanifestresourcestream (gettype ().fullname + ".bmp")) {	if (stream != null) {	try {	return new gdk.pixbuf (stream).toxwtimage ();	} catch (exception e) {	
can t create pixbuf from resource bmp 

========================= monodevelop sample_1394 =========================

public void testrequiredthistoavoidcs0135withforeach () {	testwithsubissue<redundantthisqualifierissue>(@"class foo {	int a;	void bar () {	this.a = 2;	
abc system console writeline a 

========================= monodevelop sample_8530 =========================

layout.setmarkup (tooltipinformation.signaturemarkup);	int w, h;	layout.getpixelsize (out w, out h);	if (w >= size.width - 10) {	tooltipinformation = await data.createtooltipinformation (true, canceltoken);	}	}	if (canceltoken.iscancellationrequested) return;	addoverload (tooltipinformation);	} catch (exception e) {	
error while adding overload 

========================= monodevelop sample_990 =========================

public static void userefboolincondition(ref bool x) {	if (x) {	
true 

public static void comparenotequal0isreallynotequal(icomparable<int> a) {	if (a.compareto(0) != 0) {	
true 

public static void compareequal0isreallyequal(icomparable<int> a) {	if (a.compareto(0) == 0) {	
true 

========================= monodevelop sample_502 =========================

public void methodinvocation() {	var rr = resolveatlocation<csharpinvocationresolveresult>(@"using system;	class a { void m() {	console.w$riteline(1);	}}");	
system console writeline 

========================= monodevelop sample_8900 =========================

addinmanager.addextensionnodehandler ("/monodevelop/ide/codetemplates", delegate (object sender, extensionnodeeventargs args) {	var codon = (codetemplatecodon)args.extensionnode;	switch (args.change) {	case extensionchange.add: using (xmlreader reader = codon.open ()) {	loadtemplates (reader).foreach (t => templates.add (t));	}	break;	}	});	} catch (exception e) {	
codetemplateservice exception while loading templates 

public static void deletetemplate (codetemplate template) {	try {	var filename = path.combine (templatepath, template.shortcut + ".template.xml");	if (file.exists (filename)) file.delete (filename);	} catch (exception e) {	
error while removing template file 

public static void savetemplates () {	if (!directory.exists (templatepath)) directory.createdirectory (templatepath);	foreach (string templatefile in directory.getfiles (templatepath, "*.xml")) {	file.delete (templatefile);	}	foreach (codetemplate template in templates) {	if (string.isnullorempty (template.shortcut)) {	
codetemplateservice can t save unnamed template 

switch (reader.localname) {	case node: string fileversion = reader.getattribute (versionattribute);	if (fileversion != version) return null;	break;	case codetemplate.node: result.add (codetemplate.read (reader));	break;	}	}	}	} catch (exception e) {	
codetemplateservice exception while loading template 

var result = new list<codetemplate> ();	foreach (string templatefile in directory.getfiles (templatepath, "*.xml")) {	result.addrange (loadtemplates (xmlreader.create (templatefile)));	}	for (int i = 0; i < builtintemplates.count; i++) {	var curtemplate = builtintemplates[i];	if (!result.any (t => t.shortcut == curtemplate.shortcut)) result.add (curtemplate);	}	return result;	}	
codetemplateservice no user templates reading default templates 

========================= monodevelop sample_1120 =========================

}	}	}	applicationname = getstring ("applicationname");	applicationlongname = getstring ("applicationlongname") ?? applicationname;	suitename = getstring ("suitename");	profiledirectoryname = getstring ("profiledirectoryname");	statussteadyiconid = getstring ("statusareasteadyicon");	helpabouticonid = getstring ("helpabouticon");	} catch (exception ex) {	
could not read branding document 

========================= monodevelop sample_2349 =========================

public void invalidmethodtest() {	var actions = getactions<toabstractvirtualnonvirtualconversioncoderefactoringprovider>( abstract class test {	public virtual string $tostring() {	
hello world 

========================= monodevelop sample_7051 =========================

public void processingtime3 () {	datetime start = datetime.now;	
started at 

public void processingtime3 () {	datetime start = datetime.now;	datetime end = datetime.now;	
ended at 

public void processingtime3 () {	datetime start = datetime.now;	datetime end = datetime.now;	
duration 

========================= monodevelop sample_10090 =========================

protected virtual void handleerror (exception e) {	
an exception occurred in the designer gui thread 

private plug attachchildviaplug (uint socket, gtk.widget child) {	
attaching plug to socket 

private void removeplugchildwhenunrealised (object sender, eventargs e) {	plug plug = (gtk.plug) sender;	
plug unrealised removing child before it gets destroyed 

public override void dispose () {	if (disposed) return;	disposed = true;	
trying to close designer gui thread 

========================= monodevelop sample_2462 =========================

try {	if (thisnode == null || othernode == null) return -1;	var e1 = thisnode.dataitem as iunresolvedentity;	var e2 = othernode.dataitem as iunresolvedentity;	if (e1 == null && e2 == null) return 0;	if (e1 == null) return -1;	if (e2 == null) return 1;	if (e1.symbolkind != e2.symbolkind) return e2.symbolkind.compareto (e1.symbolkind);	return e1.name.compareto (e2.name);	} catch (exception e) {	
exception in assembly browser sort function 

========================= monodevelop sample_2433 =========================

public void testremovebracesfromif() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$if (true) {	
hello 

public void testremovebracesfromif() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$if (true) {	}	}	}", @"class testclass {	void test() {	
hello 

public void testremovebracesfromelse() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	
hello 

public void testremovebracesfromelse() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	} $else {	
world 

public void testremovebracesfromelse() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	} $else {	}	}	}", @"class testclass {	void test() {	if (true) {	
hello 

test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	} $else {	}	}	}", @"class testclass {	void test() {	if (true) {	}	
world 

public void testremovebracesfromdowhile() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$do {	
hello 

public void testremovebracesfromdowhile() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$do {	} while (true);	}	}", @"class testclass {	void test() {	
hello 

public void testremovebracesfromforeach() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$foreach (var a in b) {	
hello 

public void testremovebracesfromforeach() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$foreach (var a in b) {	}	}	}", @"class testclass {	void test() {	
hello 

public void testremovebracesfromfor() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$for (; ; ) {	
hello 

public void testremovebracesfromfor() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$for (; ; ) {	}	}	}", @"class testclass {	void test() {	
hello 

public void testremovebracesfromlock() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$lock (this) {	
hello 

public void testremovebracesfromlock() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$lock (this) {	}	}	}", @"class testclass {	void test() {	
hello 

public void testremovebracesfromusing() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$using (var a = new a()) {	
hello 

public void testremovebracesfromwhile() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$while (true) {	
hello 

public void testremovebracesfromwhile() {	test<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$while (true) {	}	}	}", @"class testclass {	void test() {	
hello 

public void testdonotremovebracesfromblockwithlabel() {	testwrongcontext<removebracescoderefactoringprovider>(@"class testclass {	void test() {	$if (true) {	
hello 

public void testnullnode() {	testwrongcontext<removebracescoderefactoringprovider>(@"class testclass {	void test() {	if (true) {	
hello 

========================= monodevelop sample_7025 =========================

public void correctindenting (policycontainer policyparent, texteditor editor, idocumentline line) {	try {	if (line == null) throw new argumentnullexception (nameof (line));	formatter.correctindenting (policyparent, editor, line.linenumber);	} catch (exception e) {	
error while indenting 

========================= monodevelop sample_1808 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_238 =========================

public static languagebinding getbindingperfilename (string filename) {	if (string.isnullorempty (filename)) {	
cannot get binding for null filename at 

public static languagebinding getbindingperlanguagename (string language) {	if (string.isnullorempty (language)) {	
cannot get binding for null language at 

========================= monodevelop sample_1948 =========================

public static int main (string[] args) {	location.inemacs = environment.getenvironmentvariable ("emacs") == "t";	commandlineparser cmd = new commandlineparser (console.out);	var settings = cmd.parsearguments (args);	if (settings == null) return 1;	if (cmd.hasbeenstopped) return 0;	driver d = new driver (new compilercontext (settings, new consolereportprinter ()));	if (d.compile () && d.report.errors == 0) {	if (d.report.warnings > 0) {	
compilation succeeded warning s 

var settings = cmd.parsearguments (args);	if (settings == null) return 1;	if (cmd.hasbeenstopped) return 0;	driver d = new driver (new compilercontext (settings, new consolereportprinter ()));	if (d.compile () && d.report.errors == 0) {	if (d.report.warnings > 0) {	}	environment.exit (0);	return 0;	}	
compilation failed error s warnings 

========================= monodevelop sample_9204 =========================

private void checkmethod (methoddefinition method) {	log.writeline (this, method);	fielddefinition field;	if (method.hasbody && opcodeengine.getbitmask (method).intersect (loadstorefields)) {	foreach (instruction ins in method.body.instructions) {	switch (ins.opcode.code) {	case code.stfld: case code.stsfld: field = ins.getfield ();	if (field == null) continue;	if (checkfornullassignment (ins)) {	setfields.add (field);	
is set to null at 

fielddefinition field;	if (method.hasbody && opcodeengine.getbitmask (method).intersect (loadstorefields)) {	foreach (instruction ins in method.body.instructions) {	switch (ins.opcode.code) {	case code.stfld: case code.stsfld: field = ins.getfield ();	if (field == null) continue;	if (checkfornullassignment (ins)) {	setfields.add (field);	} else {	nullfields.remove (field);	
is set at 

if (field == null) continue;	if (checkfornullassignment (ins)) {	setfields.add (field);	} else {	nullfields.remove (field);	}	break;	case code.ldflda: case code.ldsflda: field = ins.getfield ();	if (field == null) continue;	nullfields.remove (field);	
is set at 

nullfields.remove (field);	}	break;	case code.ldflda: case code.ldsflda: field = ins.getfield ();	if (field == null) continue;	nullfields.remove (field);	break;	case code.ldfld: case code.ldsfld: field = ins.getfield ();	if (field == null) continue;	usedfields.add (field);	
is used at 

if (field.isprivate && !field.fieldtype.isvaluetype) if (!iswinformcontrol || field.name != "components") nullfields.add (field);	}	checkmethods (type);	if (type.hasnestedtypes) {	foreach (typedefinition nested in type.nestedtypes) checkmethods (nested);	}	setfields.intersectwith (nullfields);	setfields.exceptwith (usedfields);	if (setfields.count > 0) {	foreach (fielddefinition field in setfields) {	
is always null 

setfields.intersectwith (nullfields);	setfields.exceptwith (usedfields);	if (setfields.count > 0) {	foreach (fielddefinition field in setfields) {	runner.report (field, severity.medium, confidence.high);	}	}	nullfields.intersectwith (usedfields);	if (nullfields.count > 0) {	foreach (fielddefinition field in nullfields) {	
is always null 

========================= monodevelop sample_10081 =========================

protected virtual task readversions (cancellationtoken cancellationtoken) {	try {	packagedetailmodel = new packagedetailcontrolmodel (parent.nugetproject);	packagedetailmodel.selectedversion = new displayversion (selectedversion, null);	return readversionsfrompackagedetailcontrolmodel (cancellationtoken).continuewith ( task => onversionsread (task), taskscheduler.fromcurrentsynchronizationcontext ());	} catch (exception ex) {	
readversions error 

========================= monodevelop sample_2826 =========================

public void performsearchindexcreation () {	firesearchindexcreationevent (true);	try {	roottree.makesearchindex ();	} catch (exception e) {	
error making search index 

public void performsearchindexcreation () {	firesearchindexcreationevent (true);	try {	roottree.makesearchindex ();	} catch (exception e) {	}	try {	roottree.makeindex ();	} catch (exception e) {	
error making normal index 

========================= monodevelop sample_7100 =========================

var packages = this.service.dependencies.oftype<packagedependency> ().cast<ipackagedependency>().tolist();	await this.service.project.addpackagedependencies (packages).configureawait (false);	try {	foreach (var dependency in service.dependencies) {	if (packages.contains (dependency)) {	continue;	}	await dependency.addtoproject (token).configureawait (false);	}	} catch (exception ex) {	
could not add dependency 

========================= monodevelop sample_4654 =========================

public void testdisable() {	var input = baseinput + @" try {	f ();	} catch {	throw;	} finally {	
inside finally 

public void testonlyredundantcatches() {	test<redundantcatchclauseanalyzer>(baseinput + @" try {	f ();	
inside try 

public void addsblockifneccessary() {	test<redundantcatchclauseanalyzer>(baseinput + @" if (true) try {	f ();	
inside try 

public void testemptycatchwithfinally() {	test<redundantcatchclauseanalyzer>(baseinput + @" try {	f ();	} catch {	throw;	} finally {	
inside finally 

public void testbug12273case2() {	test<redundantcatchclauseanalyzer>(baseinput + @" try {	f ();	} catch (argumentoutofrangeexception) {	throw;	} catch {	
hello world 

========================= monodevelop sample_6852 =========================

protected override void run () {	try {	var profile = monodevelop.core.userprofile.current;	if (profile != null && system.io.directory.exists (profile.logdir)) system.diagnostics.process.start (profile.logdir);	} catch (exception ex) {	
could not open the log directory 

protected override void run () {	var windows = gtk.window.listtoplevels ();	
number of windows windows 

protected override void run () {	var windows = gtk.window.listtoplevels ();	foreach (var window in windows) {	
window window title window gettype 

protected override void run () {	
mark 

========================= monodevelop sample_1071 =========================

protected override void run () {	if (!options.hasmemoryleakfeature) return;	var type = typeof (glib.object).assembly.gettype ("glib.pointerwrapper");	if (type == null) {	return;	}	
gtk mac leak tracking enabled 

protected override void run () {	if (!options.hasmemoryleakfeature) return;	var type = typeof (glib.object).assembly.gettype ("glib.pointerwrapper");	if (type == null) {	return;	}	
gtk mac leak tracking pad enabled may cause performance issues 

========================= monodevelop sample_4714 =========================

resettooltipinformation ();	if (ext == null) {	lastparam = -2;	return;	}	var ct = new cancellationtokensource ();	try {	cancellationtokensource = ct;	currenttooltipinformation = await parameterhintingdata.createtooltipinformation (ext.editor, ext.documentcontext, currentparam, false, ct.token);	} catch (exception ex) {	
error while getting tooltip information 

========================= monodevelop sample_972 =========================

messagebar.setmessagelabel (brandingservice.brandapplicationname (gettextcatalog.getstring ( "<b>an autosave file has been found for this file.</b>\n" + "this could mean that another instance of monodevelop is editing this " + "file, or that monodevelop crashed with unsaved changes.\n\n" + "do you want to use the original file, or load from the autosave file?")));	button b1 = new button (gettextcatalog.getstring("_use original file"));	b1.image = new imageview (gtk.stock.refresh, iconsize.button);	b1.clicked += delegate {	try {	autosave.removeautosavefile (filename);	texteditor.grabfocus ();	view.load (filename);	view.workbenchwindow.document.reparsedocument ();	} catch (exception ex) {	
could not remove the autosave file 

b2.image = new imageview (gtk.stock.reverttosaved, iconsize.button);	b2.clicked += delegate {	try {	var content = autosave.loadandremoveautosave (filename);	texteditor.grabfocus ();	view.load (filename);	view.replacecontent (filename, content.text, view.sourceencoding);	view.workbenchwindow.document.reparsedocument ();	view.isdirty = true;	} catch (exception ex) {	
could not remove the autosave file 

========================= monodevelop sample_4536 =========================

var document = ideapp.workbench?.documents.firstordefault (doc => doc.isfile && doc.filename != null && filepath.pathcomparer.compare (path.getfullpath (doc.filename), filename) == 0 && doc.editor != null);	text = monodevelopsourcetext.create (document.editor);	} else {	try {	if (file.exists (filename)) {	text = sourcetext.from (textfileutility.gettext (filename));	} else {	text = sourcetext.from ("");	}	} catch (exception e) {	
failed to get file text for filename 

========================= monodevelop sample_1385 =========================

foreach (instruction ins in method.body.instructions) {	switch (ins.opcode.code) {	case code.call: case code.callvirt: methodreference target = (methodreference) ins.operand;	if (!call_using_this) {	methoddefinition callee = target.resolve ();	if (callee != null) {	if (!callee.ispublic && !callee.isstatic) {	if (callee.declaringtype.isnamed (nspace, name)) {	instruction instance = ins.traceback (method);	if (instance != null && instance.opcode.code == code.ldarg_0) {	
found non public this call at 

if (instance != null && instance.opcode.code == code.ldarg_0) {	call_using_this = true;	}	}	}	}	}	if (!has_dispose_check) {	string tname = target.name;	if (tname.contains ("check") && tname.contains ("dispose")) {	
found dispose check at 

if (tname.contains ("check") && tname.contains ("dispose")) {	has_dispose_check = true;	}	}	break;	case code.ldfld: case code.stfld: case code.ldflda: if (!field_access_using_this) {	fieldreference field = (fieldreference) ins.operand;	if (field.declaringtype.isnamed (nspace, name)) {	instruction instance = ins.traceback (method);	if (instance != null && instance.opcode.code == code.ldarg_0) {	
found field access at 

instruction instance = ins.traceback (method);	if (instance != null && instance.opcode.code == code.ldarg_0) {	field_access_using_this = true;	}	}	}	break;	case code.newobj: if (!creates_exception) {	methodreference ctor = (methodreference) ins.operand;	if (ctor.declaringtype.isnamed ("system", "objectdisposedexception")) {	
creates exception at 

========================= monodevelop sample_10588 =========================

public void nochainwithtemporaryvariables () {	int x;	char c;	
more tests 

========================= monodevelop sample_10619 =========================

public static void cascadingifelse(bool condition, string input, int index) {	if (condition) {	
condition 

========================= monodevelop sample_494 =========================

public void testanonymousmethodsubscription() {	testissue<staticeventsubscriptionissue>(@" using system;	class foo {	public static event eventhandler foobar;	public void test () {	foobar += delegate {	
hello 

public void testanonymousmethodsubscription_validcase() {	testwrongcontext<staticeventsubscriptionissue>(@" using system;	class foo {	public static event eventhandler foobar;	public static void test () {	foobar += delegate {	
hello 

========================= monodevelop sample_8505 =========================

public static imagesource getimagesource (this iconid stockid, xwt.iconsize size) {	if (stockid.isnull) return null;	try {	return stockid.getstockicon ().withsize (size).getimagesource ();	} catch (exception ex) {	
failed loading icon 

========================= monodevelop sample_3372 =========================

public void test() {	
imports system class testclass sub test param as string console writeline param end sub end class imports system class testclass sub test param as string if param is nothing then throw new system argumentnullexception nameof param end if console writeline param end sub end class 

public void testwithcomment() {	
imports system class testclass sub test param as string some comment console writeline param end sub end class imports system class testclass sub test param as string if param is nothing then throw new system argumentnullexception nameof param end if some comment console writeline param end sub end class 

========================= monodevelop sample_6786 =========================

public defaultworkbench() {	title = brandingservice.applicationlongname;	
creating defaultworkbench 

private xwt.drawing.image prepareshowview (viewcontent content) {	viewcontentcollection.add (content);	if (ideapp.preferences.loaddocumentuserproperties && content is imementocapable) {	try {	properties memento = getstoredmemento(content);	if (memento != null) {	((imementocapable)content).memento = memento;	}	} catch (exception e) {	
can t get set memento 

protected void onclosed(eventargs e) {	foreach (var fv in dock.layouts) if (fv.endswith (fullviewmodetag)) dock.deletelayout (fv);	try {	dock.savelayouts (configfile);	} catch (exception ex) {	
error while saving layout 

========================= monodevelop sample_1337 =========================

protected projecttemplate (runtimeaddin addin, string id, projecttemplatecodon codon, string overridelanguage) {	xmldocument xmldocument = codon.gettemplate ();	xmlelement xmlconfiguration = xmldocument.documentelement ["templateconfiguration"];	if (xmlconfiguration ["_category"] != null) {	category = xmlconfiguration ["_category"].innertext;	}	if (xmlconfiguration ["category"] != null) {	category = xmlconfiguration ["category"].innertext;	} else if (category == null) {	
category missing in project template 

list<string> listlanguages = new list<string> ();	foreach (string item in xmlconfiguration ["languagename"].innertext.split (',')) listlanguages.add (item.trim ());	expandlanguagewildcards (listlanguages);	this.languagename = listlanguages [0];	if (listlanguages.count > 1 && !string.isnullorempty (languagename) && !category.startswith (languagename + "/")) category = languagename + "/" + category;	for (int i = 1; i < listlanguages.count; i++) {	string language = listlanguages[i];	try {	projecttemplates.add (new projecttemplate (addin, id, codon, language));	} catch (exception e) {	
error loading template for language 

projecttemplatecodon codon = (projecttemplatecodon) args.extensionnode;	try {	projecttemplates.add (new projecttemplate (codon.addin, codon.id, codon, null));	}	catch (exception e) {	string extid = null, addinid = null;	if (codon != null) {	if (codon.hasid) extid = codon.id;	if (codon.addin != null) addinid = codon.addin.id;	}	
error loading template id in addin null null 

========================= monodevelop sample_1055 =========================

public void testabstractoverridemethodcase1() {	test<implementabstractmembersaction>(@"class a {	public virtual void foo() {	
a 

}	}	abstract class b : a {	public abstract override void foo();	public abstract void foobar();	}	class c : $b {	}	", @"class a {	public virtual void foo() {	
a 

========================= monodevelop sample_8776 =========================

settingsloader.usertemplatecache.scan (scanpath);	}	}	settingsloader.save ();	paths.writealltext (paths.user.firstruncookie, "");	var templateinfos = settingsloader.usertemplatecache.list (false, t => new matchinfo ()).todictionary (m => m.info.identity, m => m.info);	var newprojecttemplates = new list<microsofttemplateenginesolutiontemplate> ();	foreach (var template in projecttemplatenodes) {	itemplateinfo templateinfo;	if (!templateinfos.trygetvalue (template.templateid, out templateinfo)) {	
template not found 

if (!templateinfos.trygetvalue (template.templateid, out templateinfo)) {	continue;	}	newprojecttemplates.add (new microsofttemplateenginesolutiontemplate (template, templateinfo));	}	projecttemplates = newprojecttemplates;	var newitemtemplates = new list<microsofttemplateengineitemtemplate> ();	foreach (var template in itemtemplatenodes) {	itemplateinfo templateinfo;	if (!templateinfos.trygetvalue (template.templateid, out templateinfo)) {	
template not found 

public static async task formatfile (policycontainer policies, filepath file) {	string mime = desktopservice.getmimetypeforuri (file);	if (mime == null) return;	var formatter = codeformatterservice.getformatter (mime);	if (formatter != null) {	try {	var content = await textfileutility.readalltextasync (file);	var formatted = formatter.formattext (policies, content.text);	if (formatted != null) textfileutility.writetext (file, formatted, content.encoding);	} catch (exception ex) {	
file formatting failed 

========================= monodevelop sample_1004 =========================

build ();	this.project = project;	targetframework = project.targetframework;	string netstandardversion = null;	try {	netstandardversion = getprojectjsonframeworks (project)?.firstordefault ();	if (netstandardversion != null && !netstandardversion.startswith ("netstandard", stringcomparison.ordinal)) {	netstandardversion = null;	}	} catch (exception ex) {	
error reading project json file 

========================= monodevelop sample_873 =========================

string str;	if (string.isnullorempty (shortcut)) return null;	while (i < shortcut.length) {	if ((j = shortcut.indexof ('|', i + 1)) == -1) {	j = shortcut.length;	}	str = shortcut.substring (i, j - i);	if ((mod = modifiermask (str)) == gdk.modifiertype.none) {	if (str.length > 1) {	if (!gdk.key.tryparse (str, out key)) {	
warning invalid gdk key portion of shortcut 

}	str = shortcut.substring (i, j - i);	if ((mod = modifiermask (str)) == gdk.modifiertype.none) {	if (str.length > 1) {	if (!gdk.key.tryparse (str, out key)) {	return null;	}	}	else if (str[0] >= 'a' && str[0] <= 'z') key = (gdk.key) str[0] - 32;	else key = (gdk.key) str[0];	
warning trailing data after gdk key portion of shortcut 

return null;	}	}	else if (str[0] >= 'a' && str[0] <= 'z') key = (gdk.key) str[0] - 32;	else key = (gdk.key) str[0];	return accellabelfromkey (key, mask);	}	mask |= mod;	i = j + 1;	}	
warning incomplete shortcut 

public static string canonicalizebinding (string binding) {	gdk.modifiertype chordmod, mod;	string accel, chord = null;	uint chordkey, key;	if (string.isnullorempty (binding)) return null;	if (isshortcutformat (binding)) return shortcuttobinding (binding);	if (!bindingtokeys (binding, out chordkey, out chordmod, out key, out mod)) {	
warning failed to canonicalize binding 

public void registercommand (command command) {	if (commands.contains (command)) {	
warning trying to re register command 

public void unregistercommand (command command) {	if (!commands.contains (command)) {	
warning trying to unregister unknown command 

========================= monodevelop sample_933 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_69 =========================

public void show () {	visible = true;	}	public void hide () {	visible = false;	}	internal void click () {	try {	doclick ();	} catch (exception ex) {	
exception in context menu 

========================= monodevelop sample_721 =========================

vbox vbox = new vbox ();	vbox.accessible.setshouldignore (true);	switchercombolist = new liststore (typeof (string), typeof (itasklistview), typeof (string));	try {	extensionnodelist viewcodons = addinmanager.getextensionnodes ("/monodevelop/ide/tasklist/view", typeof (tasklistviewcodon));	foreach (tasklistviewcodon codon in viewcodons) {	switchercombolist.appendvalues (codon.label, codon.view, codon.class);	}	}	catch (exception e) {	
loading of tasks views failed 

========================= monodevelop sample_1352 =========================

public bool movetofirstpage (solutiontemplate template, projectcreateparameters parameters) {	reset ();	if (!template.haswizard) {	return false;	}	currentwizard = getwizard (template.wizard);	if (currentwizard == null) {	
unable to find project template wizard 

========================= monodevelop sample_1030 =========================

static void setupinstrumentation () {	instrumentationservice.enabled = runtime.preferences.enableinstrumentation;	if (instrumentationservice.enabled) {	
instrumentation service started 

static void setupinstrumentation () {	instrumentationservice.enabled = runtime.preferences.enableinstrumentation;	if (instrumentationservice.enabled) {	try {	int port = instrumentationservice.publishservice ();	
instrumentation available at port 

static void setupinstrumentation () {	instrumentationservice.enabled = runtime.preferences.enableinstrumentation;	if (instrumentationservice.enabled) {	try {	int port = instrumentationservice.publishservice ();	} catch (exception ex) {	
instrumentation service could not be published 

public static void checkmainthread () {	if (ismainthread) {	return;	}	if (system.diagnostics.debugger.isattached) {	system.diagnostics.debugger.break ();	}	
operation not supported in background thread location 

public static void setprocessname (string name) {	if (!platform.ismac && !platform.iswindows) {	try {	unixsetprocessname (name);	} catch (exception e) {	
error setting process name 

========================= monodevelop sample_2319 =========================

public static void printnumberofunhandledopcodes() {	#if debug foreach (var pair in unhandledopcodes) {	
addmethodbodybuilder unhandled opcode x 

========================= monodevelop sample_552 =========================

string migrateversion = null;	userprofile migratableprofile = null;	var prefspath = userprofile.current.configdir.combine (filename);	if (!file.exists (prefspath)) {	if (getmigratableprofile (out migratableprofile, out migrateversion)) {	filepath migrateprefspath = migratableprofile.configdir.combine (filename);	try {	var parentdir = prefspath.parentdirectory;	if (!directory.exists (parentdir)) directory.createdirectory (parentdir);	file.copy (migrateprefspath, prefspath);	
migrated core properties from 

filepath migrateprefspath = migratableprofile.configdir.combine (filename);	try {	var parentdir = prefspath.parentdirectory;	if (!directory.exists (parentdir)) directory.createdirectory (parentdir);	file.copy (migrateprefspath, prefspath);	} catch (ioexception ex) {	string message = string.format ("failed to migrate core properties from {0}", migrateprefspath);	loggingservice.logerror (message, ex);	}	} else {	
did not find previous version from which to migrate data 

static bool loadproperties (string filename) {	properties = null;	if (file.exists (filename)) {	try {	properties = properties.load (filename);	} catch (exception ex) {	
error loading properties from file 

try {	properties = properties.load (filename);	} catch (exception ex) {	}	}	string backupfile = filename + ".previous";	if (properties == null && file.exists (backupfile)) {	try {	properties = properties.load (backupfile);	} catch (exception ex) {	
error loading properties from backup file 

========================= monodevelop sample_2348 =========================

public void reloadsettings () {	try {	loadsettings ();	} catch (exception ex) {	
failed to reload settings 

========================= monodevelop sample_2894 =========================

if (!type.hasfields || type.isenum) return ruleresult.doesnotapply;	log.writeline (this);	log.writeline (this, "----------------------------------");	log.writeline (this, type);	fielddefinition field = findintptr (type);	if (field != null) {	confidence confidence = confidence.low;	methoddefinition finalizer = type.getmethod (methodsignatures.finalize);	if (finalizer != null) confidence = (confidence) ((int) confidence - 1);	if (type.implements ("system", "idisposable")) confidence = (confidence) ((int) confidence - 1);	
is an intptr 

========================= monodevelop sample_10173 =========================

configuration.loadeddefaultproviders.add (pname);	initializing++;	ontoolboxcontentschanged ();	system.threading.threadpool.queueuserworkitem (delegate {	if (!runtime.initialized) return;	list<itemtoolboxnode> nodes = new list<itemtoolboxnode> ();	try {	ienumerable<itemtoolboxnode> newitems = provider.getdefaultitems ();	if (newitems != null) nodes.addrange (newitems);	} catch (exception ex) {	
error getting default items from a itoolboxdefaultprovider 

public void dragselecteditem (gtk.widget source, gdk.dragcontext ctx) {	if ((currentconsumer == null) || (selecteditem == null)) return;	try {	currentconsumer.dragitem (selecteditem, source, ctx);	ontoolboxused (currentconsumer, selecteditem);	} catch (exception ex) {	
error dragging toolbox item 

========================= monodevelop sample_2457 =========================

public void methodwiththreadsuspendcall () {	thread thread = new thread (delegate () {	
stupid code 

public void methodwiththreadresumecall () {	thread thread = new thread (delegate () {	
useless code 

========================= monodevelop sample_10180 =========================

}	}	if (ref_changed) break;	}*/ if (!ref_changed && last_gen_time >= file.getlastwritetime (info.steticfile)) return null;	if (info.guibuilderproject.haserror) {	var error = gettextcatalog.getstring ("gui code generation failed for project '{0}'. the file '{1}' could not be loaded.", project.name, info.steticfile);	monitor.reporterror (error, null);	throw new userexception (error);	}	if (info.guibuilderproject.isempty) return null;	
generating gui code for project 

options.generatemodifiedonly = true;	generationresult = steticapp.generateprojectcode (options, info.guibuilderproject.steticproject);	info.guibuilderproject.steticproject.resetmodifiedwidgetflags ();	} catch (exception ex) {	generatedexception = ex;	}	generating = false;	}	timer.trace ("writing code units");	if (generatedexception != null) {	
gui code generation failed 

========================= monodevelop sample_3548 =========================

static int main (string[] args) {	if (args.length == 1 && directory.exists (args[0])) parse (new directoryinfo (args[0]));	else if (args.length == 1 && file.exists (args[0])) parse (new fileinfo (args[0]));	else return printusage ();	
out of failed to parse correctly 

static int printusage () {	
usage parse exe dir 

static void parse (fileinfo file) {	if (file.exists) {	lexer = new lexer (new filereader (file.fullname));	p.parse (lexer);	csharpvisitor v = new csharpvisitor ();	v.visit (p.compilationunit, null);	v.cu.errorsduringcompile = p.errors.count > 0;	if (v.cu.errorsduringcompile) {	
errors in parsing 

========================= monodevelop sample_3799 =========================

using (var progressmonitor = createprogressmonitor ()) {	try {	string arguments = "install tool dotnet-dev-certs -g --version " + getdevcertsversion ();	progressmonitor.log.writeline ("{0} {1}", dotnetcoreruntime.filename, arguments);	var process = runtime.processservice.startconsoleprocess ( dotnetcoreruntime.filename, arguments, null, progressmonitor.console );	using (var customcanceltoken = cancellationtoken.register (process.cancel)) {	await process.task;	if (process.exitcode == 0) {	return true;	} else {	
install failed dotnet install returned 

if (process.exitcode == 0) {	return true;	} else {	return false;	}	}	} catch (operationcanceledexception) {	throw;	} catch (exception ex) {	progressmonitor.log.writeline (ex.message);	
failed to install dotnet dev certs 

public static async task<certificatecheckresult> checkcertificate (cancellationtoken cancellationtoken) {	int exitcode = await rundotnetcommand ( "dev-certs https --trust --check", cancellationtoken );	var result = (certificatecheckresult)exitcode;	if (enum.isdefined (typeof (certificatecheckresult), result)) {	return result;	}	
unknown exit code returned from dotnet dev certs https trust check exitcode 

var monoruntime = runtime.systemassemblyservice.defaultruntime as monotargetruntime;	string monopath = monoruntime.getmonoexecutableforassembly (installerpath);	var process = runtime.processservice.startconsoleprocess ( monopath, $"\"{installerpath}\" \"{dotnetcoreruntime.filename}\" \"{monopath}\"", null, progressmonitor.console );	using (var customcanceltoken = cancellationtoken.register (process.cancel)) {	await process.task;	}	} catch (operationcanceledexception) {	throw;	} catch (exception ex) {	progressmonitor.log.writeline (ex.message);	
failed to trust https certificate 

========================= monodevelop sample_4268 =========================

public override int compareobjects (itreenavigator thisnode, itreenavigator othernode) {	try {	if (thisnode == null || othernode == null) return -1;	var e1 = thisnode.dataitem as modulereference;	var e2 = othernode.dataitem as modulereference;	if (e1 == null && e2 == null) return 0;	if (e1 == null) return -1;	if (e2 == null) return 1;	return e1.name.compareto (e2.name);	} catch (exception e) {	
exception in assembly browser sort function 

========================= monodevelop sample_2432 =========================

break;	} else {	string typename = (string)o;	toolboxitem = null;	try {	resolver.resolve (typereferencefromstring (module, typename));	} catch (exception ex) {	system.diagnostics.debug.writeline (ex);	}	if (toolboxitem == null) {	
ceciltoolboxitemscanner error resolving type 

========================= monodevelop sample_2490 =========================

public static void generatebitmasks () {	opcodebitmask bitmask;	bitmask = new opcodebitmask ();	bitmask.set (code.stfld);	bitmask.set (code.stsfld);	bitmask.set (code.call);	bitmask.set (code.callvirt);	applicable_method_bitmask = bitmask;	
applicable method bitmask 

bitmask.set (code.pop);	bitmask.set (code.stind_i);	bitmask.set (code.stind_i1);	bitmask.set (code.stind_i2);	bitmask.set (code.stind_i4);	bitmask.set (code.stind_i8);	bitmask.set (code.stind_r4);	bitmask.set (code.stind_r8);	bitmask.set (code.stind_ref);	safe_instructions = bitmask;	
safe instructions 

private ruleresult checkmethodunsafe (methoddefinition method) {	locals.clear ();	stack.clear ();	
checking method on type 

private ruleresult checkmethodunsafe (methoddefinition method) {	locals.clear ();	stack.clear ();	log.writeline (this, method);	methodbody body = method.body;	
handlertype trystart x tryend x handlerstart x handlerend x filterstart x catchtype 

if ((stack_count == 0) && body.hasexceptionhandlers) {	foreach (exceptionhandler eh in body.exceptionhandlers) {	if (eh.handlerstart != null && eh.handlerstart.offset == ins.offset) {	stack_count = 1;	stack.add (null);	break;	}	}	}	int push = ins.getpushcount ();	
x prev stack pop push post stack 

} else if (ins.opcode.code == code.stfld || ins.opcode.code == code.stsfld) {	verifystorefieldinstruction (ins, stack_count);	} else if (ins.isstorelocal ()) {	verifystorelocalinstruction (ins, stack_count);	}	stack_count += push - pop;	while (stack_count > stack.count) stack.add (new ilrange (ins));	while (stack_count < stack.count) stack.removeat (stack.count - 1);	if (stack_count > 0 && stack [stack_count - 1] != null) stack [stack_count - 1].last = ins;	}	
checking method done result 

private void verifycallinstruction (instruction ins) {	methoddefinition called_method;	ilist<parameterdefinition> parameters;	called_method = (ins.operand as methodreference).resolve ();	if (called_method != null && called_method.ispinvokeimpl && called_method.hasparameters) {	
reached a call instruction to a pinvoke method 

private void verifycallinstruction (instruction ins) {	methoddefinition called_method;	ilist<parameterdefinition> parameters;	called_method = (ins.operand as methodreference).resolve ();	if (called_method != null && called_method.ispinvokeimpl && called_method.hasparameters) {	parameters = called_method.parameters;	for (int i = 0; i < parameters.count; i++) {	if (stack [i] == null) continue;	if (!parameters [i].parametertype.isdelegate ()) continue;	
parameter takes a delegate stack expression 

private bool verifycallbacksafety (methoddefinition callback) {	bool result;	bool valid_ex_handler;	methodbody body;	ilist<instruction> instructions;	if (callback == null) return true;	
verifying with code size instruction count 

is_safe.add (safe);	}	if (body.hasexceptionhandlers) {	foreach (exceptionhandler eh in body.exceptionhandlers) {	if (eh.handlertype != exceptionhandlertype.catch) continue;	if (eh.filterstart != null) continue;	typereference ctype = eh.catchtype;	if (!(ctype == null || ctype.isnamed ("system", "object") || ctype.isnamed ("system", "exception"))) continue;	int start_index = instructions.indexof (eh.trystart);	int end_index = instructions.indexof (eh.tryend);	
catch all block found marking instruction at index to index included as safe 

if (eh.handlertype != exceptionhandlertype.catch) continue;	if (eh.filterstart != null) continue;	typereference ctype = eh.catchtype;	if (!(ctype == null || ctype.isnamed ("system", "object") || ctype.isnamed ("system", "exception"))) continue;	int start_index = instructions.indexof (eh.trystart);	int end_index = instructions.indexof (eh.tryend);	for (int j = start_index; j < end_index; j++) is_safe [j] = true;	}	}	valid_ex_handler = !is_safe.contains (false);	
method verified 

if (eh.filterstart != null) continue;	typereference ctype = eh.catchtype;	if (!(ctype == null || ctype.isnamed ("system", "object") || ctype.isnamed ("system", "exception"))) continue;	int start_index = instructions.indexof (eh.trystart);	int end_index = instructions.indexof (eh.tryend);	for (int j = start_index; j < end_index; j++) is_safe [j] = true;	}	}	valid_ex_handler = !is_safe.contains (false);	for (int i = 0; i < is_safe.count; i++) {	
y n 

typereference ctype = eh.catchtype;	if (!(ctype == null || ctype.isnamed ("system", "object") || ctype.isnamed ("system", "exception"))) continue;	int start_index = instructions.indexof (eh.trystart);	int end_index = instructions.indexof (eh.tryend);	for (int j = start_index; j < end_index; j++) is_safe [j] = true;	}	}	valid_ex_handler = !is_safe.contains (false);	for (int i = 0; i < is_safe.count; i++) {	}	
handlertype trystart tryend handlerstart handlerend filterstart catchtype 

private void reportverifiedmethod (methoddefinition pointer, bool safe) {	if (!safe) {	if (reported_methods.contains (pointer)) return;	reported_methods.add (pointer);	
reporting 

private void reportverifiedmethod (methoddefinition pointer, bool safe) {	if (!safe) {	if (reported_methods.contains (pointer)) return;	reported_methods.add (pointer);	runner.report (pointer, severity.high, confidence.high);	} else {	
safe 

========================= monodevelop sample_10205 =========================

private void addcontentrenderer (idatagridcontentrenderer renderer) {	foreach (type type in renderer.datatypes) {	
duplicate idatagridcontentrenderer for type 

========================= monodevelop sample_5064 =========================

if (language == null || language == "") throw new invalidoperationexception (gettextcatalog.getstring ("language not defined in codedom based template."));	codedomprovider provider = getcodedomprovider (language);	if (tempsubstitutedcontent == null) throw new exception (gettextcatalog.getstring ("expected modifytags to be called before createcontent"));	codecompileunit ccu;	using (stringreader sr = new stringreader (tempsubstitutedcontent)) {	try {	ccu = parserprovider.parse (sr);	} catch (notimplementedexception) {	throw new invalidoperationexception (gettextcatalog.getstring ("invalid code translation template: the codedomprovider of the source language '{0}' has not implemented the parse method.", language));	} catch (exception ex) {	
unparseable template 

========================= monodevelop sample_1041 =========================

public void ifelsecase() {	test<useasandnullcheckaction>(@" class bar {	public bar baz (object foo) {	if (foo $is bar) {	baz ((bar)foo);	return (bar)foo;	} else {	
hello 

return null;	}	}	", @" class bar {	public bar baz (object foo) {	var bar = foo as bar;	if (bar != null) {	baz (bar);	return bar;	} else {	
hello 

========================= monodevelop sample_8673 =========================

var pd = await typesystemservice.parsefile (project, realpath) as webformsparseddocument;	if (pd != null) {	try {	contentplaceholders.addrange (pd.xdocument.getallplaceholderids ());	for (int i = 0; i < contentplaceholders.count; i++) {	string placeholder = contentplaceholders[i];	primaryplaceholderstore.appendvalues (placeholder);	if (placeholder.contains ("main") || placeholder.contains ("main") || placeholder.contains ("content") || placeholder.contains ("content")) placeholdercombo.active = i;	}	} catch (exception ex) {	
unhandled exception getting master regions for 

========================= monodevelop sample_4967 =========================

public void noargument() {	test<extractmethodaction>(@"class testclass {	void testmethod () {	int i = 5;	
hello world 

public void noargument() {	test<extractmethodaction>(@"class testclass {	void testmethod () {	int i = 5;	}	", @"class testclass {	static void newmethod () {	
hello world 

========================= monodevelop sample_8762 =========================

static system.web.ui.persistencemode getpersistencemode (ipropertysymbol prop) {	foreach (var att in prop.getattributes ()) {	if (att.attributeclass.getfullname () == "system.web.ui.persistencemodeattribute") {	var expr = att.constructorarguments.firstordefault ();	if (expr.isnull) {	
unknown expression type in attribute parameter 

static bool arechildrenasproperties (inamedtypesymbol type, out string defaultproperty) {	bool childrenasproperties = false;	defaultproperty = "";	attributedata att = getattributes (type, "system.web.ui.parsechildrenattribute").firstordefault ();	if (att == null) return childrenasproperties;	var posargs = att.constructorarguments;	if (posargs.length == 0) return childrenasproperties;	if (posargs.length > 0) {	var expr = posargs [0];	if (expr.isnull) {	
unknown expression type in attribute parameter 

var posargs = att.constructorarguments;	if (posargs.length == 0) return childrenasproperties;	if (posargs.length > 0) {	var expr = posargs [0];	if (expr.isnull) {	return false;	}	if (expr.value is bool) {	childrenasproperties = (bool)expr.value;	} else {	
asp net completion does not yet handle parsechildrenattribute type 

}	if (expr.value is bool) {	childrenasproperties = (bool)expr.value;	} else {	return false;	}	}	if (posargs.length > 1) {	var expr = posargs [1];	if (expr.isnull || !(expr.value is string)) {	
unknown expression in iattribute parameter 

if (expr.isnull || !(expr.value is string)) {	return false;	}	defaultproperty = (string)expr.value;	}	var namedargs = att.namedarguments;	if (namedargs.length > 0) {	if (namedargs.any (p => p.key == "childrenasproperties")) {	var expr = namedargs.first (p => p.key == "childrenasproperties").value;	if (expr.isnull) {	
unknown expression type in iattribute parameter 

if (namedargs.any (p => p.key == "childrenasproperties")) {	var expr = namedargs.first (p => p.key == "childrenasproperties").value;	if (expr.isnull) {	return false;	}	childrenasproperties = (bool)expr.value;	}	if (namedargs.any (p => p.key == "defaultproperty")) {	var expr = namedargs.first (p => p.key == "defaultproperty").value;	if (expr.isnull) {	
unknown expression type in iattribute parameter 

childrenasproperties = (bool)expr.value;	}	if (namedargs.any (p => p.key == "defaultproperty")) {	var expr = namedargs.first (p => p.key == "defaultproperty").value;	if (expr.isnull) {	return false;	}	defaultproperty = (string)expr.value;	}	if (namedargs.any (p => p.key == "childcontroltype")) {	
asp net completion does not yet handle parsechildrenattribute type 

========================= monodevelop sample_4876 =========================

public void refreshpackages () {	try {	cancelcurrentrefresh ();	getinstalledpackages ();	} catch (exception ex) {	
refresh packages folder error 

protected virtual void oninstalledpackagesread (task<ienumerable<packagereference>> task, cancellationtokensource tokensource) {	try {	if (task.isfaulted) {	
oninstalledpackagesread error 

protected virtual void oninstalledpackagesread (task<ienumerable<packagereference>> task, cancellationtokensource tokensource) {	try {	if (task.isfaulted) {	} else if (!tokensource.iscancellationrequested) {	packagereferencesrefreshed = true;	packagereferences = task.result.tolist ();	onpackagereferenceschanged ();	}	} catch (exception ex) {	
oninstalledpackagesread error 

========================= monodevelop sample_3115 =========================

cleanupcache ();	parsers = addinmanager.getextensionnodes<typesystemparsernode> ("/monodevelop/typesystem/parser");	bool initialload = true;	addinmanager.addextensionnodehandler ("/monodevelop/typesystem/parser", delegate (object sender, extensionnodeeventargs args) {	if (!initialload) parsers = addinmanager.getextensionnodes<typesystemparsernode> ("/monodevelop/typesystem/parser");	});	initialload = false;	try {	emptyworkspace = new monodevelopworkspace (null);	} catch (exception e) {	
can t create roslyn workspace 

if (char.isletterordigit (ch)) {	name.append (ch);	} else {	name.append ('_');	}	}	string result = deriveddatapath.combine (stringbuildercache.returnandfree (name));	try {	if (!directory.exists (result)) directory.createdirectory (result);	} catch (exception e) {	
error while creating derived data directories 

static string internalgetcachedirectory (filepath filename) {	canonicalizepath (ref filename);	var assemblycacheroot = getassemblycacheroot (filename);	try {	if (!directory.exists (assemblycacheroot)) return null;	foreach (var dir in directory.enumeratedirectories (assemblycacheroot)) {	string result;	if (checkcachedirectoryiscorrect (filename, dir, out result)) return result;	}	} catch (exception e) {	
error while getting derived data directories 

using (var reader = xmlreader.create (datapath)) {	while (reader.read ()) {	if (reader.nodetype == xmlnodetype.element && reader.localname == "file") {	info.version = reader.getattribute ("version");	info.filename = reader.getattribute ("name");	}	}	}	cachedirectorycache [candidate] = info;	} catch (exception e) {	
error while reading derived data file 

static string createcachedirectory (filepath filename) {	canonicalizepath (ref filename);	try {	string cacheroot = getassemblycacheroot (filename);	string cachedir = getpossiblecachedirnames (cacheroot).first (d => !directory.exists (d));	directory.createdirectory (cachedir);	file.writealltext ( path.combine (cachedir, "data.xml"), string.format ("<deriveddata><file name=\"{0}\" version =\"{1}\"/></deriveddata>", escapetoxml (filename), currentversion) );	return cachedir;	} catch (exception e) {	
error creating cache for 

var t = counters.parserservice.objectdeserialized.begintiming (path);	try {	using (var fs = new filestream (path, system.io.filemode.open, fileaccess.read, fileshare.read, 4096, fileoptions.sequentialscan)) {	using (var reader = new binaryreaderwith7bitencodedints (fs)) {	lock (sharedserializer) {	return (t)sharedserializer.deserialize (reader);	}	}	}	} catch (exception e) {	
error while trying to deserialize stack trace 

var t = counters.parserservice.objectserialized.begintiming (path);	try {	using (var fs = new filestream (path, system.io.filemode.create, fileaccess.write)) {	using (var writer = new binarywriterwith7bitencodedints (fs)) {	lock (sharedserializer) {	sharedserializer.serialize (writer, obj);	}	}	}	} catch (exception e) {	
serialize stack trace 

try {	using (var fs = new filestream (path, system.io.filemode.create, fileaccess.write)) {	using (var writer = new binarywriterwith7bitencodedints (fs)) {	lock (sharedserializer) {	sharedserializer.serialize (writer, obj);	}	}	}	} catch (exception e) {	console.writeline (environment.stacktrace);	
error while writing type system cache object 

static void cleanupcache () {	string deriveddatapath = userprofile.current.cachedir.combine ("deriveddata");	ienumerable<string> cachedirectories;	try {	if (!directory.exists (deriveddatapath)) return;	cachedirectories = directory.enumeratedirectories (deriveddatapath);	} catch (exception e) {	
error while getting derived data directories 

return;	}	var now = datetime.now;	foreach (var cachedirectory in cachedirectories) {	try {	foreach (var subdir in directory.enumeratedirectories (cachedirectory)) {	try {	var days = math.abs ((now - directory.getlastwritetime (subdir)).totaldays);	if (days > 30) directory.delete (subdir, true);	} catch (exception e) {	
error while removing outdated cache 

foreach (var cachedirectory in cachedirectories) {	try {	foreach (var subdir in directory.enumeratedirectories (cachedirectory)) {	try {	var days = math.abs ((now - directory.getlastwritetime (subdir)).totaldays);	if (days > 30) directory.delete (subdir, true);	} catch (exception e) {	}	}	} catch (exception e) {	
error while getting cache directories 

static void removecache (string cachedir) {	try {	directory.delete (cachedir, true);	} catch (exception e) {	
error while removing cache 

static void touchcache (string cachedir) {	try {	directory.setlastwritetime (cachedir, datetime.now);	} catch (exception e) {	
error while touching cache directory 

static void storeextensionobject (string cachedir, object extensionobject) {	if (cachedir == null) throw new argumentnullexception (nameof(cachedir));	if (extensionobject == null) throw new argumentnullexception (nameof(extensionobject));	var filename = path.gettempfilename ();	serializeobject (filename, extensionobject);	var cachefile = path.combine (cachedir, extensionobject.gettype ().fullname + ".cache");	try {	if (file.exists (cachefile)) file.delete (cachefile);	file.move (filename, cachefile);	} catch (exception e) {	
error whil saving cache for extension object 

========================= monodevelop sample_1372 =========================

public void build () {	try {	foreach (xelement el in xdocument.nodes.oftype<xelement> ()) addmember (el);	} catch (exception ex) {	
unknown parser error 

========================= monodevelop sample_4885 =========================

public void ignoreslinespreceedinginitialization() {	
system console writeline one 

public void ignoreslinespreceedinginitialization() {	for(;;) {	
two 

public void ignoreslinespreceedinginitialization() {	for(;;) {	}	
three 

========================= monodevelop sample_8791 =========================

static void main (string[] args) {	if (args.length != 1|| !file.exists (args[0])) {	
usage assemblyinfowriter inputfile 

static void main (string[] args) {	if (args.length != 1|| !file.exists (args[0])) {	environment.exit (1);	}	string outfile = path.combine (path.getdirectoryname (args[0]), "assemblyinfo.cs");	xelement el = xdocument.load (args[0]).element ("addin");	if (el == null) {	
error missing addin element in addin file 

}	string outfile = path.combine (path.getdirectoryname (args[0]), "assemblyinfo.cs");	xelement el = xdocument.load (args[0]).element ("addin");	if (el == null) {	environment.exit (1);	}	var maps = new dictionary<string,string> () {	{"name", "assemblytitle"}, {"description", "assemblydescription"}, {"version", "assemblyversion"}, {"copyright", "assemblycopyright"}	};	using (textwriter writer = new streamwriter (outfile)) {	
writer writeline 

}	string outfile = path.combine (path.getdirectoryname (args[0]), "assemblyinfo.cs");	xelement el = xdocument.load (args[0]).element ("addin");	if (el == null) {	environment.exit (1);	}	var maps = new dictionary<string,string> () {	{"name", "assemblytitle"}, {"description", "assemblydescription"}, {"version", "assemblyversion"}, {"copyright", "assemblycopyright"}	};	using (textwriter writer = new streamwriter (outfile)) {	
using system reflection 

string outfile = path.combine (path.getdirectoryname (args[0]), "assemblyinfo.cs");	xelement el = xdocument.load (args[0]).element ("addin");	if (el == null) {	environment.exit (1);	}	var maps = new dictionary<string,string> () {	{"name", "assemblytitle"}, {"description", "assemblydescription"}, {"version", "assemblyversion"}, {"copyright", "assemblycopyright"}	};	using (textwriter writer = new streamwriter (outfile)) {	writer.writeline ();	
assembly assemblyproduct 

environment.exit (1);	}	var maps = new dictionary<string,string> () {	{"name", "assemblytitle"}, {"description", "assemblydescription"}, {"version", "assemblyversion"}, {"copyright", "assemblycopyright"}	};	using (textwriter writer = new streamwriter (outfile)) {	writer.writeline ();	foreach (keyvaluepair<string, string> map in maps) {	xattribute att = el.attribute (map.key);	if (att == null || string.isnullorempty (att.value)) console.writeline ("warning: missing {0} in addin file '{1}'.", map.key, args[0]);	
assembly 

========================= monodevelop sample_610 =========================

public void testdefaultwithcode() {	analyze<redundantemptydefaultswitchbranchanalyzer>(@" class test {	void testmethod (int i = 0) {	switch (i) {	case 0: system.console.writeline();	break;	
default 

========================= monodevelop sample_6891 =========================

public static async task dump (textwriter log) {	var (summary, delta) = await leakhelpers.getsummary (steady: true);	
summary 

public static async task dump (textwriter log) {	var (summary, delta) = await leakhelpers.getsummary (steady: true);	log.writeline (summary);	log.writeline ();	
delta 

========================= monodevelop sample_4710 =========================

using (var stream = assembly.getmanifestresourcestream (resource)) {	buffer = new byte [stream.length];	stream.read (buffer, 0, (int)stream.length);	}	using (var px = new gdk.pixbuf (buffer)) return new imagesurface (px.pixels, format.argb32, px.width, px.height, px.rowstride);*/ var tmp = system.io.path.gettempfilename ();	system.io.file.writeallbytes (tmp, buffer);	var img = new imagesurface (tmp);	try {	system.io.file.delete (tmp);	} catch (exception e) {	
unable to delete tmp due to exception e 

========================= monodevelop sample_764 =========================

public static void deletedirectory(string directorypath) {	if (!directory.exists(directorypath)) {	
directory is missing and can t be removed 

}	catch (exception ex) {	var caughtexceptiontype = ex.gettype();	if (!whitelist.any(knownexceptiontype => knownexceptiontype.isassignablefrom(caughtexceptiontype))) {	throw;	}	if (attempt < maxattempts) {	thread.sleep(initialtimeout * (int)math.pow(timeoutfactor, attempt - 1));	continue;	}	
the directory could not be deleted attempts were made due to a most of the time this is due to an external process accessing the files in the temporary repositories created during the test runs and keeping a handle on the directory thus preventing the deletion of those files known and common causes include windows search indexer go to the indexing options in the windows control panel and exclude the bin folder of tests antivirus exclude the bin folder of tests from the paths scanned by your real time antivirus tortoisegit change the icon overlays settings e g adding the bin folder of tests to exclude paths and appending an to exclude all subfolders as well 

========================= monodevelop sample_9498 =========================

static async task checkupdates (progressmonitor monitor, object[] handlers, bool automatic) {	using (monitor) {	if (handlers.length == 0) return;	try {	iupdatehandler uh = (iupdatehandler) handlers [handlers.length - 1];	await uh.checkupdates (monitor, automatic);	} catch (exception ex) {	
updates check failed for handler of type 

========================= monodevelop sample_1197 =========================

public void testbasiccase () {	testrefactoringcontext ctx;	var issues = getissues(new basemethodcallwithdefaultparameterissue(), @" public class mybase {	public virtual void foobar(int x = 12) {	
foo bar 

public void testdonotwarncase () {	testwrongcontext<basemethodcallwithdefaultparameterissue>(@" public class mybase {	public virtual void foobar(int x = 12) {	
foo bar 

public void testdonotwarninparamscase () {	testwrongcontext<basemethodcallwithdefaultparameterissue>(@" public class mybase {	public virtual void foobar(params int[] x) {	
foo bar 

public void testdisable () {	testwrongcontext<basemethodcallwithdefaultparameterissue> (@" public class mybase {	public virtual void foobar(int x = 12) {	
foo bar 

========================= monodevelop sample_8486 =========================

public void addwebusernameandpassword (uri url, string username, string password) {	var didwrite = writecredential (url.host, username, password);	if (didwrite) return;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	
tried saving credentials but the logon session does not exist 

public void addwebusernameandpassword (uri url, string username, string password) {	var didwrite = writecredential (url.host, username, password);	if (didwrite) return;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	break;	
tried saving credentials but got invalid flags set on credential 

public void addwebusernameandpassword (uri url, string username, string password) {	var didwrite = writecredential (url.host, username, password);	if (didwrite) return;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	break;	break;	
tried saving credentials but got unknown error code x 

public tuple<string, string> getwebusernameandpassword (uri url) {	var read = readcredential (url.host);	if (read != null) return read;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	case errorcode.notfound: return null;	
tried to retrieve credential but got no logon session 

public tuple<string, string> getwebusernameandpassword (uri url) {	var read = readcredential (url.host);	if (read != null) return read;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	case errorcode.notfound: return null;	return null;	
tried to retrieve credential but got invalid flags 

public tuple<string, string> getwebusernameandpassword (uri url) {	var read = readcredential (url.host);	if (read != null) return read;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	case errorcode.notfound: return null;	return null;	return null;	
tried to retrieve credentials but got unknown error code x 

public void removewebusernameandpassword (uri uri) {	var diddelete = removecredential (uri.host);	if (diddelete) return;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	
tried saving credentials but the logon session does not exist 

public void removewebusernameandpassword (uri uri) {	var diddelete = removecredential (uri.host);	if (diddelete) return;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	break;	
tried saving credentials but got invalid flags set on credential 

public void removewebusernameandpassword (uri uri) {	var diddelete = removecredential (uri.host);	if (diddelete) return;	var lasterror = (errorcode)marshal.getlastwin32error ();	switch (lasterror) {	break;	break;	
tried saving credentials but got unknown error code x 

========================= monodevelop sample_3376 =========================

var indent = createengine(@" namespace foobar {	class foo {	void bar () {	system.console.writeline ();	}	$ }	}	");	itextpastehandler handler = new textpasteindentengine(indent, new texteditoroptions { eolmarker = "\n" }, formattingoptionsfactory.createmono());	var text = handler.formatplaintext(indent.offset, "void bar ()\n{\nsystem.console.writeline ();\n}", null);	
void bar system console writeline 

public void testmultiplepastes() {	var indent = createengine(@" class foo {	void bar () {	system.console.writeline ();	}	$ }	");	itextpastehandler handler = new textpasteindentengine(indent, new texteditoroptions { eolmarker = "\n" }, formattingoptionsfactory.createmono());	for (int i = 0; i < 2; i++) {	var text = handler.formatplaintext(indent.offset, "void bar ()\n{\nsystem.console.writeline ();\n}", null);	
void bar system console writeline 

public void pasteverbatimstringbug1() {	var texteditoroptions = createinvariantoptions ();	texteditoroptions.eolmarker = "\r\n";	var indent = createengine("\r\nclass foo\r\n{\r\n\tvoid bar ()\r\n\t{\r\n\t\t$\r\n\t}\r\n}", formattingoptionsfactory.createmono(), texteditoroptions);	itextpastehandler handler = new textpasteindentengine(indent, texteditoroptions, formattingoptionsfactory.createmono());	var text = handler.formatplaintext(indent.offset, "console.writeline (@\"hello world!\");\n", null);	
console writeline 

public void pasteverbatimstringbug2() {	var indent = createengine("\nclass foo\n{\n\tvoid bar ()\n\t{\n\t\t$\n\t}\n}");	itextpastehandler handler = new textpasteindentengine(indent, createinvariantoptions (), formattingoptionsfactory.createmono());	var text = handler.formatplaintext(indent.offset, "if (true)\nconsole.writeline (@\"hello\n world!\");\n", null);	
if true console writeline 

public void pasteverbatimstringbug3() {	var indent = createengine("\nclass foo\n{\n\tvoid bar ()\n\t{\n$\n\t}\n}");	itextpastehandler handler = new textpasteindentengine(indent, createinvariantoptions (), formattingoptionsfactory.createmono());	var text = handler.formatplaintext(indent.offset, "\t\tsystem.console.writeline(@\"<evlevlle>\");\n", null);	
system console writeline 

public void pastemultilineatfirstcolumncorrection() {	var indent = createengine("class foo\n{\n$\n}");	itextpastehandler handler = new textpasteindentengine(indent, createinvariantoptions (), formattingoptionsfactory.createmono());	var text = handler.formatplaintext(indent.offset, "void bar ()\n{\n\tsystem.console.writeline ();\n}", null);	
void bar system console writeline 

========================= monodevelop sample_8410 =========================

public static void readlist (xmlreader reader, icollection<string> endnodes, readercallbackwithdata callback) {	if (reader.isemptyelement) return;	readcallbackdata data = new readcallbackdata ();	bool didreadstartnode = endnodes.contains (reader.localname);	while (data.skipnextread || reader.read()) {	data.skipnextread = false;	switch (reader.nodetype) {	case xmlnodetype.endelement: if (endnodes.contains (reader.localname)) return;	ixmllineinfo xmlinfo = (ixmllineinfo)reader;	
encountered end node when expecting one of location ln col stack trace 

data.skipnextread = false;	switch (reader.nodetype) {	case xmlnodetype.endelement: if (endnodes.contains (reader.localname)) return;	ixmllineinfo xmlinfo = (ixmllineinfo)reader;	break;	case xmlnodetype.element: if (!didreadstartnode && endnodes.contains (reader.localname)) {	didreadstartnode = true;	break;	}	bool validnode = callback (data);	
unknown node 

========================= monodevelop sample_2329 =========================

case "get-version": getversion(args);	break;	case "get-releaseid": getreleaseid(args);	break;	case "gen-updateinfo": generateupdateinfo(args);	break;	case "gen-buildinfo": generatebuildinfo(args);	break;	case "is-preview": getispreview(args);	break;	
unknown command 

static void printhelp() {	
monodevelop configuration script 

static void printhelp() {	console.writeline();	
commands 

static void printhelp() {	console.writeline();	
get version prints the version of this release 

static void printhelp() {	console.writeline();	
get releaseid prints the release id 

static void printhelp() {	console.writeline();	
is preview prints true if this is a preview or false otherwise 

static void printhelp() {	console.writeline();	
gen updateinfo config file path generates the updateinfo file 

static void printhelp() {	console.writeline();	
in the provided path 

static void printhelp() {	console.writeline();	
gen buildinfo path generates the buildinfo file in the provided path 

public static void reporterror(string msg) {	if (logfile != null) {	lock (locallock) file.appendalltext(logfile, "[error] " + msg + environment.newline);	}	
error 

========================= monodevelop sample_1 =========================

timer.begintiming ();	var dir = path.getdirectoryname (typeof(macplatformservice).assembly.location);	if (objcruntime.dlfcn.dlopen (path.combine (dir, "libxammac.dylib"), 0) == intptr.zero) loggingservice.logfatalerror ("unable to load libxammac");	mimemap = new lazy<dictionary<string, string>> (loadmimemapasync);	carbon.setprocessname (brandingservice.applicationname);	checkgtkversion (2, 24, 14);	xwt.toolkit.currentengine.registerbackend<iextendedtitlebarwindowbackend,extendedtitlebarwindowbackend> ();	xwt.toolkit.currentengine.registerbackend<iextendedtitlebardialogbackend,extendedtitlebardialogbackend> ();	var description = xammacbuildinfo.value;	if (string.isnullorempty (description)) {	
failed to parse version of xamarin mac used at runtime 

var dir = path.getdirectoryname (typeof(macplatformservice).assembly.location);	if (objcruntime.dlfcn.dlopen (path.combine (dir, "libxammac.dylib"), 0) == intptr.zero) loggingservice.logfatalerror ("unable to load libxammac");	mimemap = new lazy<dictionary<string, string>> (loadmimemapasync);	carbon.setprocessname (brandingservice.applicationname);	checkgtkversion (2, 24, 14);	xwt.toolkit.currentengine.registerbackend<iextendedtitlebarwindowbackend,extendedtitlebarwindowbackend> ();	xwt.toolkit.currentengine.registerbackend<iextendedtitlebardialogbackend,extendedtitlebardialogbackend> ();	var description = xammacbuildinfo.value;	if (string.isnullorempty (description)) {	} else {	
using 

static void checkgtkversion (uint major, uint minor, uint micro) {	if (gtk.global.checkversion (major, minor, micro) != null) {	
gtk version is incompatible with required version 

e.reply = nsapplicationterminatereply.cancel;	gtk.main.quit ();	} else {	e.reply = nsapplicationterminatereply.now;	}	};	}	swizzlensapplication ();	var nc = nsnotificationcenter.defaultcenter;	nc.addobserver ((nsstring)"atkcocoaaccessibilityenabled", (nsnotification) => {	
voiceover on idetheme accessibilityenabled 

gtk.main.quit ();	} else {	e.reply = nsapplicationterminatereply.now;	}	};	}	swizzlensapplication ();	var nc = nsnotificationcenter.defaultcenter;	nc.addobserver ((nsstring)"atkcocoaaccessibilityenabled", (nsnotification) => {	if (!idetheme.accessibilityenabled) {	
showing notice 

rootmenu.additem (new mdsubmenuitem (commandmanager, (commandentryset)ce));	}	} catch (exception ex) {	try {	var m = nsapplication.sharedapplication.mainmenu;	if (m != null) {	m.dispose ();	}	nsapplication.sharedapplication.mainmenu = null;	} catch {}	
could not install global menu 

========================= monodevelop sample_4977 =========================

if (string.isnullorempty (solution_version)) solution_version = "0.1";	makefile makefile = handler.deploy ( context, solution.rootfolder, monitor );	string path = path.combine (solution_dir, "makefile");	if (generateautotools) {	context.addautoconffile (path);	createautogendotsh (context, monitor);	createconfiguredotac (solution, defaultconf, monitor, context);	createmacros ();	} else {	createconfigurescript (solution, defaultconf, context, monitor);	
creating rules make 

if (generateautotools) path = path + ".am";	streamwriter writer = new streamwriter (path);	makefile.write ( writer );	writer.close ();	context.addgeneratedfile (path);	monitor.reportsuccess ( gettextcatalog.getstring ("{0} were successfully generated.", filesstring ) );	monitor.step (1);	}	catch ( exception e ) {	monitor.reporterror ( gettextcatalog.getstring ("{0} could not be generated: ", filesstring ), e );	
could not be generated 

========================= monodevelop sample_2378 =========================

static dotnetcoreruntime () {	init (getdotnetcorepath ());	
net core runtime not found 

========================= monodevelop sample_2527 =========================

public void test () {	
a b 

public void testbase () {	
a b 

public void testinherited () {	
a b 

public void test () {	
a b 

public void test () {	
a b 

public void test () {	
a b 

public void test () {	
a b 

public void testextrafirst () {	
a b 

public void testextramid () {	
a b 

public void testextraend () {	
a b 

========================= monodevelop sample_10143 =========================

public static int main (string[] args) {	try {	if (args.length < 2) {	
arguments missing 

static int run (string dotnetcorepath, string monopath) {	var filename = typeof (mainclass).assembly.location;	var args = new [] { filename, "--setuid", dotnetcorepath };	var flags = authorizationflags.extendrights | authorizationflags.interactionallowed | authorizationflags.preauthorize;	using (var auth = authorization.create (null, null, flags)) {	int result = auth.executewithprivileges ( monopath, authorizationflags.defaults, args);	if (result != 0) {	if (enum.tryparse (result.tostring (), out authorizationstatus authstatus)) {	if (authstatus == authorizationstatus.canceled) {	
authorization canceled 

}	int status;	if (syscall.wait (out status) == -1) {	throw new invalidoperationexception ("failed to start child process.");	}	if (!syscall.wifexited (status)) {	throw new invalidoperationexception ("child process terminated abnormally.");	}	int exitcode = syscall.wexitstatus (status);	if (exitcode != 0) {	
exit code from dotnet dev certs exitcode 

static int rundotnetdevcerts (string dotnetcorepath) {	int result = syscall.setuid (0);	if (result != 0) {	
unable to set user id to root 

========================= monodevelop sample_4258 =========================

public void testbug325187() {	csharpformattingoptions policy = formattingoptionsfactory.createmono();	policy.elsenewlineplacement = newlineplacement.newline;	teststatementformatting (policy, if (i == 6) console.writeline (""yeah"");	else console.writeline (""bad indent"");", if (i == 6) console.writeline (""yeah"");	
bad indent 

========================= monodevelop sample_8399 =========================

}	try {	using (var asm = mono.cecil.assemblydefinition.readassembly (file)) {	if (string.isnullorempty (asm.name.name)) throw new invalidoperationexception ("assembly has no assembly name");	assemblyname name = new assemblyname (asm.name.fullname);	if (!pathmap.containskey (asm.name.fullname)) pathmap.add (asm.name.fullname, file);	names.add (name);	}	} catch (exception ex) {	dsi.logmessage = gettextcatalog.getstring ("could not get assembly name for user assembly '{0}'. " + "debugger will now debug all code, not just user code.", file);	
error getting assembly name for user assembly 

========================= monodevelop sample_2760 =========================

}	else {	foreach (string a in args) {	string ext = path.getextension (a);	if (!(ext == ".dll" || ext == ".exe") || !file.exists (a)) continue;	comparewindow mw = new comparewindow ();	mw.setassemblypath (a);	mw.showall();	}	}	
calling application run 

========================= monodevelop sample_9864 =========================

static void main(string[] args) {	tcplistener listener = new tcplistener(port);	listener.start();	
waiting for test to begin 

static void main(string[] args) {	tcplistener listener = new tcplistener(port);	listener.start();	tcpclient client = listener.accepttcpclient();	
connected to test runner 

========================= monodevelop sample_5933 =========================

private static void save () {	using (filestream file = new filestream (bookmark_file,filemode.create)) {	serializer.serialize (file,root_group);	}	
bookmarks saved 

private static void load () {	using (filestream file = new filestream (bookmark_file,filemode.open)) {	root_group = (bookmarkgroup)serializer.deserialize (file);	}	
bookmarks loaded 

public bookmarkmanager (browser browser){	_browser = browser;	
bookmark manager init 

menuitem item = new menuitem (((bookmarkgroup)i).name);	item.activated += on_bookmarkgroup_activated;	menu_to_id[item] = ((bookmarkgroup)i).id;	menu.append (item);	menu m = new menu ();	item.submenu = m;	buildmenuhelper (m, ((bookmarkgroup)i));	}	foreach (object i in group.members) {	if (i is bookmark) {	
appending bookmark 

static void on_bookmark_activated (object sender, eventargs e) {	bookmarkbase bk = null;	getbookmarkbase (root_group, menu_to_id[ (menuitem)sender] as string,ref  bk);	if (bk != null) {	if (bk is  bookmark) _browser.loadurl (((bookmark)bk).url);	} else {	
bookmark error could not load bookmark 

========================= monodevelop sample_9835 =========================

public static void main(string[] args) {	addinmanager.initialize (".");	addinmanager.registry.update (null);	
normal writers 

public static void main(string[] args) {	addinmanager.initialize (".");	addinmanager.registry.update (null);	writermanager manager = new writermanager (new string[0]);	foreach (iwriter w in manager.getwriters ()) console.writeline (w.write ());	
including debug writers 

========================= monodevelop sample_11498 =========================

private void writeunhandledexceptionmessage (exception e) {	console.writeline ();	console.writeline ("an uncaught exception occured. please fill a bug report at https: if (currentrule != null) console.writeline ("rule:\t{0}", currentrule);	if (currenttarget != null) console.writeline ("target:\t{0}", currenttarget);	
stack trace 

public override void run () {	if (assemblies.count == 0) {	
no assemblies were specified to be analyzed 

public override void teardown () {	if (!quiet) {	console.writeline (": {0}", timetostring (local.elapsed));	local.start ();	local.reset ();	}	base.teardown ();	if (!quiet) {	local.stop ();	total.stop ();	
teardown 

console.writeline (": {0}", timetostring (local.elapsed));	local.start ();	local.reset ();	}	base.teardown ();	if (!quiet) {	local.stop ();	total.stop ();	console.writeline ();	if (assemblies.count == 1) console.writeline ("one assembly processed in {0}.", timetostring (total.elapsed));	
assemblies processed in 

console.writeline ();	if (assemblies.count == 1) console.writeline ("one assembly processed in {0}.", timetostring (total.elapsed));	string hint = string.empty;	if (null != log_file || null != xml_file || null != html_file) {	list<string> files = new list<string> (new string [] { log_file, xml_file, html_file });	files.removeall (string.isnullorempty);	hint = string.format (cultureinfo.currentculture, "report{0} written to: {1}.", (files.count > 1) ? "s" : string.empty, string.join (",", files.select (file => string.format (cultureinfo.currentculture, "`{0}'", file)).toarray ()));	}	if (defects.count == 0) console.writeline ("no defect found. {0}", hint);	else if (defects.count == 1) console.writeline ("one defect found. {0}", hint);	
defects found 

static void help () {	
usage gendarme config file set ruleset log xml html file assemblies 

static void help () {	
where 

static void help () {	
config file specify the rule sets and rule settings default is rules xml 

static void help () {	
set ruleset specify a rule set from configfile default is default 

static void help () {	
log file save the report to the specified file 

static void help () {	
xml file save the report as xml to the specified file 

static void help () {	
html file save the report as html to the specified file 

static void help () {	
ignore file do not report defects listed in the specified file 

static void help () {	
limit n stop reporting after n defects are found 

static void help () {	
severity all audit low medium high critical 

static void help () {	
filter defects for the specified severity levels 

static void help () {	
default is medium 

static void help () {	
confidence all low normal high total 

static void help () {	
filter defects for the specified confidence levels 

static void help () {	
default is normal 

static void help () {	
console show defects on the console even if log xml or html are specified 

static void help () {	
quiet used to disable progress and other information which is normally written to stdout 

static void help () {	
v when present additional progress information is written to stdout can be used multiple times 

static void help () {	
assemblies specify the assemblies to verify 

========================= monodevelop sample_10647 =========================

public static void main(string[] args) {	if (args.length != 1) {	
usage stripmnemonics exe po dir 

========================= monodevelop sample_579 =========================

if (!calls.get (ins.opcode.code)) continue;	methodreference mr = (ins.operand as methodreference);	if (mr.name.startswith ("op_", stringcomparison.ordinal)) continue;	int counter = 1;	instruction caller = ins.traceback (method);	while ((caller != null) && validlink (caller)) {	counter++;	i = ic.indexof (caller);	caller = caller.traceback (method);	}	
chain of length at 

========================= monodevelop sample_10616 =========================

public void save (string filename) {	string backupfilename = filename + ".previous";	string tempfilename = path.getdirectoryname (filename) + path.directoryseparatorchar + ".#" + path.getfilename (filename);	try {	if (file.exists (filename)) {	file.copy (filename, backupfilename, true);	}	} catch (exception ex) {	
error copying properties file to backup 

writer.formatting = formatting.indented;	writer.writestartelement (propertiesrootnode);	writer.writeattributestring (propertiesversionattribute, propertiesversion);	write (writer, false);	writer.writeendelement ();	}	fileservice.systemrename (tempfilename, filename);	return;	}	catch (exception ex) {	
error writing properties file 

if (typeof(icustomxmlserializer).isassignablefrom (typeof(t))) {	using (xmlreader reader = new xmltextreader (new memorystream (system.text.encoding.utf8.getbytes ("<" + properties.serializednode + ">" + xml + "</" + properties.serializednode + ">" )))) {	return (t)((icustomxmlserializer)typeof(t).assembly.createinstance (typeof(t).fullname)).readfrom (reader);	}	}	xmlserializer serializer = new xmlserializer (typeof(t));	using (streamreader sr = new streamreader (new memorystream (system.text.encoding.utf8.getbytes (xml)))) {	return (t)serializer.deserialize (sr);	}	} catch (exception e) {	
caught exception while deserializing 

========================= monodevelop sample_2332 =========================

public void testsimplecase() {	analyze<stringcomparetoisculturespecificanalyzer>(@" public class test {	void foo (string b) {	
foo compareto b 

public void testsimplecase() {	analyze<stringcomparetoisculturespecificanalyzer>(@" public class test {	void foo (string b) {	}	}	", @" public class test {	void foo (string b) {	
foo b system stringcomparison ordinal 

public void testinvalidcase() {	analyze<stringcomparetoisculturespecificanalyzer>(@" public class test {	void foo (object b) {	
foo compareto b 

public void testdisable() {	analyze<stringcomparetoisculturespecificanalyzer>(@" public class test {	void foo (string b) {	
csharpdiagnosticids stringcomparetoisculturespecificanalyzerid foo compareto b 

========================= monodevelop sample_6838 =========================

public void outlinetype () {	bool first, ns = !string.isnullorempty (t.namespace);	if (ns){	
namespace 

========================= monodevelop sample_9850 =========================

public override sizef drawerwillresizecontents (nsdrawer sender, sizef contentsize) {	
drawer resize from mydrawerdelegate 

========================= monodevelop sample_10733 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_85 =========================

checktype (prop);	this.prop = prop;	mainhbox = new gtk.hbox (false, 6);	packstart (mainhbox, false, false, 0);	if (!prop.translatable) return;	button = new gtk.button ();	try {	globe = gdk.pixbuf.loadfromresource ("globe.png");	globe_not = gdk.pixbuf.loadfromresource ("globe-not.png");	} catch (exception e) {	
error while loading pixbuf 

========================= monodevelop sample_3786 =========================

break;	case "file_extensions": foreach (var nn in entry.value.allnodes.oftype<yamlscalarnode> ()) {	extensions.add ("." + nn.value);	}	break;	case "scope": scope = ((yamlscalarnode)entry.value).value;	break;	case "hidden": try {	hidden = bool.parse (((yamlscalarnode)entry.value).value);	} catch (exception e) {	
error while parsing hidden flag of 

recordword = true;	continue;	}	if (ch == '}' && next == '}' && recordword) {	i++;	recordword = false;	string replacement;	if (variables.trygetvalue (wordbuilder.tostring (), out replacement)) {	result.append (replacevariables (replacement, variables));	} else {	
can t find variable 

========================= monodevelop sample_1615 =========================

}	if (possiblematch.success) {	if (match == null || possiblematch.index < match.index) {	match = possiblematch;	curmatch = m;	} else {	}	} else {	}	} catch (regexmatchtimeoutexception) {	
warning regex timed out on line 

========================= monodevelop sample_1584 =========================

}	laststoppedposition = frame.sourcelocation;	targetstoppedevent.set ();	};	session.targetstopped += (sender, e) => {	if (e.backtrace != null) {	frame = e.backtrace.getframe (0);	laststoppedposition = frame.sourcelocation;	targetstoppedevent.set ();	} else {	
e backtrace is null 

targetstoppedevent.set ();	} else {	}	};	var targetexited = new manualresetevent (false);	session.targetexited += delegate {	targetexited.set ();	};	session.run (dsi, ops);	session.exceptionhandler = (ex) => {	
session exceptionhandler 

session.exceptionhandler = (ex) => {	handleanyexception(ex);	return true;	};	switch (waithandle.waitany (new waithandle[]{ done, targetexited }, 30000)) {	case 0: break;	case 1: throw new exception ("test application exited before hitting breakpoint");	default: throw new exception ("timeout while waiting for initial breakpoint");	}	if (session is softdebuggersession) {	
sdb protocol version 

========================= monodevelop sample_6024 =========================

public async task<bool> execute (progressmonitor monitor, workspaceobject entry, executioncontext context, configurationselector configuration) {	processexecutioncommand cmd = createexecutioncommand (entry, configuration);	
executing 

var stopper = monitor.cancellationtoken.register (oper.cancel);	await oper.task;	stopper.dispose ();	if (oper.exitcode != 0) {	monitor.reporterror (gettextcatalog.getstring ("custom command failed (exit code: {0})", oper.exitcode), null);	}	} catch (win32exception w32ex) {	monitor.reporterror (gettextcatalog.getstring ("failed to execute custom command '{0}': {1}", cmd.command, w32ex.message), null);	return false;	} catch (exception ex) {	
command execution failed 

========================= monodevelop sample_1947 =========================

public static void main(string[] args) {	lib.class1.run(args);	
hello world 

========================= monodevelop sample_155 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_104 =========================

if (obj is objectmirror) handle = ((objectmirror)obj).begininvokemethod (ctx.thread, function, args, options, null, null);	else if (obj is typemirror) handle = ((typemirror)obj).begininvokemethod (ctx.thread, function, args, options, null, null);	else if (obj is structmirror) handle = ((structmirror)obj).begininvokemethod (ctx.thread, function, args, options | invokeoptions.returnoutthis, null, null);	else if (obj is primitivevalue) handle = ((primitivevalue)obj).begininvokemethod (ctx.thread, function, args, options, null, null);	else throw new argumentexception ("soft debugger method calls cannot be invoked on objects of type " + obj.gettype ().name);	} catch (invocationexception ex) {	ctx.session.stackversion++;	exception = ex;	} catch (exception ex) {	ctx.session.stackversion++;	
error in soft debugger method call thread on 

public override void abort () {	if (handle is iinvokeasyncresult) {	var info = getinfo ();	
aborting invocation of 

========================= monodevelop sample_6034 =========================

static dnd () {	try {	widgeticon = gdk.pixbuf.loadfromresource ("widget.png");	} catch (exception e) {	
error while loading pixbuf widget png 

========================= monodevelop sample_3640 =========================

public async task takeheapshotandmakereport () {	var newheapshot = await takeheapshot ();	if (options.printreporttypes.hasflag (stresstestoptions.profileroptions.printreport.objectstotal)) {	
total objects per type newheapshot objectsperclasscounter count 

public async task takeheapshotandmakereport () {	var newheapshot = await takeheapshot ();	if (options.printreporttypes.hasflag (stresstestoptions.profileroptions.printreport.objectstotal)) {	foreach (var typewithcount in newheapshot.objectsperclasscounter.where (p => p.value > 0).orderbydescending (p => p.value)) {	
newheapshot classinfos typewithcount key name typewithcount value 

public async task takeheapshotandmakereport () {	var newheapshot = await takeheapshot ();	if (options.printreporttypes.hasflag (stresstestoptions.profileroptions.printreport.objectstotal)) {	foreach (var typewithcount in newheapshot.objectsperclasscounter.where (p => p.value > 0).orderbydescending (p => p.value)) {	}	}	if (options.printreporttypes.hasflag (stresstestoptions.profileroptions.printreport.objectsdiff)) {	heapshots.add (newheapshot);	if (heapshots.count == 1) {	
no objects diff report on heapshot 

if (heapshots.count == 1) {	return;	}	var oldheapshot = heapshots[heapshots.count - 2];	var diffcounter = new list<tuple<long, int>> ();	foreach (var classinfoid in newheapshot.classinfos.keys) {	if (!oldheapshot.objectsperclasscounter.trygetvalue (classinfoid, out int oldcount)) oldcount = 0;	if (!newheapshot.objectsperclasscounter.trygetvalue (classinfoid, out int newcount)) newcount = 0;	if (newcount - oldcount != 0) diffcounter.add (tuple.create (classinfoid, newcount - oldcount));	}	
heapshot diff has diffcounter count entries 

return;	}	var oldheapshot = heapshots[heapshots.count - 2];	var diffcounter = new list<tuple<long, int>> ();	foreach (var classinfoid in newheapshot.classinfos.keys) {	if (!oldheapshot.objectsperclasscounter.trygetvalue (classinfoid, out int oldcount)) oldcount = 0;	if (!newheapshot.objectsperclasscounter.trygetvalue (classinfoid, out int newcount)) newcount = 0;	if (newcount - oldcount != 0) diffcounter.add (tuple.create (classinfoid, newcount - oldcount));	}	foreach (var diff in diffcounter.orderbydescending (d => d.item2)) {	
newheapshot classinfos diff name diff 

========================= monodevelop sample_336 =========================

static void main () {	nsapplication.init ();	var locationmanager = new cllocationmanager ();	locationmanager.updatedlocation += (sender, args) => {	var coord = args.newlocation.coordinate;	
at 

========================= monodevelop sample_11063 =========================

public gtk.image getimage () {	if (icon == null || icon.length == 0) return null;	if (icon.startswith ("res:")) {	system.io.stream s = this.classdescriptor.library.getresource (icon.substring (4));	if (s == null) return null;	using (s) {	gdk.pixbuf pixbuf;	try {	pixbuf = new gdk.pixbuf (s);	} catch (exception e) {	
error while loading pixbuf 

========================= monodevelop sample_3674 =========================

static void start() {	registerremotingchannel ();	watchprocess (console.readline ());	var builderengine = new buildengine ();	var bf = new binaryformatter ();	objref oref = remotingservices.marshal (builderengine);	var ms = new memorystream ();	bf.serialize (ms, oref);	
monodevelop 

========================= monodevelop sample_1823 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_182 =========================

public void initializetoolkit () {	var dylibpath = path.combine (path.getdirectoryname (application.assembly.location), "libxammac.dylib");	if (dlopen (dylibpath, 0) == intptr.zero) {	var errptr = dlerror ();	var errstr = (errptr == intptr.zero)? "<unknown error>" : marshal.ptrtostringansi (errptr);	
warning cannot load 

========================= monodevelop sample_5467 =========================

public void testunsafeclass() {	analyze<redundantunsafecontextanalyzer>(@"$unsafe$ class foo {	public static void main(string[] args) {	
hello 

public void testunsafeclass() {	analyze<redundantunsafecontextanalyzer>(@"$unsafe$ class foo {	public static void main(string[] args) {	}	}	", @"class foo {	public static void main(string[] args) {	
hello 

public void testunsafestatement() {	analyze<redundantunsafecontextanalyzer>(@" class foo {	public static void main(string[] args) {	$unsafe$ {	
hello 

public void testunsafestatement() {	analyze<redundantunsafecontextanalyzer>(@" class foo {	public static void main(string[] args) {	$unsafe$ {	
hello 

public void testunsafestatement() {	analyze<redundantunsafecontextanalyzer>(@" class foo {	public static void main(string[] args) {	$unsafe$ {	}	}	}	", @" class foo {	public static void main(string[] args) {	
hello 

public void testunsafestatement() {	analyze<redundantunsafecontextanalyzer>(@" class foo {	public static void main(string[] args) {	$unsafe$ {	}	}	}	", @" class foo {	public static void main(string[] args) {	
hello 

public void testdisable() {	analyze<redundantunsafecontextanalyzer>(@" #pragma warning disable " + csharpdiagnosticids.redundantunsafecontextanalyzerid + @" unsafe class foo {	public static void main(string[] args) {	
hello 

========================= monodevelop sample_6828 =========================

public void testsimplemethodcall () {	string result = runcontextaction ( new createlocalvariableaction (), "using system;" + environment.newline + "class testclass" + environment.newline + "{" + environment.newline + "	void test ()" + environment.newline + "	{" + environment.newline + "		console.writeline ($foo);" + environment.newline + "	}" + environment.newline + "}" );	
using system class testclass void test object foo console writeline foo 

========================= monodevelop sample_8779 =========================

stringbuilder varname = new stringbuilder();	for( ; i < input.length-1; ++i) {	if(input[i] == '%' && input[i+1] == '%') {	i += 1;	break;	}	varname.append(input[i]);	}	string val;	if (variables.trygetvalue (varname.tostring (), out val)) result.append (val);	
no replacement for variable defined 

========================= monodevelop sample_2373 =========================

public void testdisable() {	analyze<possiblemistakencalltogettypeanalyzer>(@" public class bar {	public void foobar(type a) {	
csharpdiagnosticids possiblemistakencalltogettypeanalyzerid 

========================= monodevelop sample_6939 =========================

e.add (xelement.parse ("<para>this method is called by both the dispose() method and the object finalizer (finalize).    when invoked by the dispose method, the parameter disposting <paramref name=\"disposing\"/> is set to <see langword=\"true\"/> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword=\"false\"/>. </para>"));	e.add (xelement.parse ("<para>calling the dispose method when you are finished using the " +t.name + " ensures that all external resources used by this managed object are released as soon as possible.  once you have invoked the dispose method, the object is no longer useful and you should no longer make any calls to it.</para>"));	e.add (xelement.parse ("<para>  for more information on how to override this method and on the dispose }	save (xmldoc, t);	}	public static int main (string [] args) {	assembly monotouch = typeof (monomac.foundation.nsobject).assembly;	bool update_events = false;	var dir = args [0];	if (file.exists (path.combine (dir, "en"))){	
the directory does not seem to be the root for documentation missing en directory 

========================= monodevelop sample_10657 =========================

if ((desc != null) && (desc.length > 0)) {	sw.writeline (de.key);	sw.writeline (de.value);	}	}	sw.close ();	}	_modified = false;	}	catch (exception e) {	
oid cache couldn t be saved cause 

========================= monodevelop sample_9965 =========================

content.encoding = content.provider.currentencoding;	content.reader = new stringreader (content.text);	}	content.results.addrange(findall (monitor, content.provider, content.reader, pattern, replacepattern, filter));	lock (results) {	results.addrange (content.results);	}	foundmatchescount += content.results.count;	if (searchedfilescount % step == 0) monitor.step (1);	} catch (exception e) {	
exception during search 

});	if (replacepattern != null) {	foreach (var content in contents) {	if (token.iscancellationrequested) return enumerable.empty<searchresult> ();	if (content.results.count == 0) continue;	try {	content.provider.beginreplace (content.text, content.encoding);	replace (content.provider, content.results, replacepattern);	content.provider.endreplace ();	} catch (exception e) {	
exception during replace 

========================= monodevelop sample_848 =========================

additem (new mdsubmenuitem (manager, subset, commandsource, initialcommandtarget));	continue;	}	var lce = ce as linkcommandentry;	if (lce != null) {	additem (new mdlinkmenuitem (lce));	continue;	}	command cmd = ce.getcommand (manager);	if (cmd == null) {	
macmenu maps to null command 

var lce = ce as linkcommandentry;	if (lce != null) {	additem (new mdlinkmenuitem (lce));	continue;	}	command cmd = ce.getcommand (manager);	if (cmd == null) {	continue;	}	if (cmd is customcommand) {	
macmenu is unsupported custom rendered command 

}	command cmd = ce.getcommand (manager);	if (cmd == null) {	continue;	}	if (cmd is customcommand) {	continue;	}	var acmd = cmd as actioncommand;	if (acmd == null) {	
macmenu has unknown command type 

========================= monodevelop sample_819 =========================

mousebtnbox.packstart (new label("mouse butons:"));	mousebtnbox.packstart (laleft);	mousebtnbox.packstart (lamiddle);	mousebtnbox.packstart (laright);	packstart (mousebtnbox);	packstart (la);	packstart (resla);	la.mouseentered += (sender, e) => {	insidelabel = true;	application.timeoutinvoke (100, checkmouseoverlabel);	
mouse entered 

mousebtnbox.packstart (laright);	packstart (mousebtnbox);	packstart (la);	packstart (resla);	la.mouseentered += (sender, e) => {	insidelabel = true;	application.timeoutinvoke (100, checkmouseoverlabel);	};	la.mouseexited += (sender, e) => {	insidelabel = false;	
mouse exited 

};	la.mousemoved += (sender, e) => movedoverlabel = true;	la.buttonpressed += handlebuttonpressed;	la.buttonreleased += handlebuttonreleased;	la.mousescrolled += handlemousescrolled;	packstart (te);	packstart (reste);	te.mouseentered += (sender, e) => {	insidete = true;	application.timeoutinvoke (100, checkmouseoverte);	
mouse entered 

la.mousescrolled += handlemousescrolled;	packstart (te);	packstart (reste);	te.mouseentered += (sender, e) => {	insidete = true;	application.timeoutinvoke (100, checkmouseoverte);	reste.text = "mouse has entered text entry";	};	te.mouseexited += (sender, e) => {	insidete = false;	
mouse exited 

};	te.mousemoved += (sender, e) => movedoverte = true;	te.buttonpressed += handlebuttonpressed;	te.buttonreleased += handlebuttonreleased;	te.mousescrolled += handlemousescrolled;	packstart (spn);	packstart (resspn);	spn.mouseentered += (sender, e) => {	insidespn = true;	application.timeoutinvoke (100, checkmouseoverspn);	
mouse entered 

te.buttonreleased += handlebuttonreleased;	te.mousescrolled += handlemousescrolled;	packstart (spn);	packstart (resspn);	spn.mouseentered += (sender, e) => {	insidespn = true;	application.timeoutinvoke (100, checkmouseoverspn);	};	spn.mouseexited += (sender, e) => {	insidespn = false;	
mouse exited 

};	spn.mousemoved += (sender, e) => movedoverspn = true;	spn.buttonpressed += handlebuttonpressed;	spn.buttonreleased += handlebuttonreleased;	spn.mousescrolled += handlemousescrolled;	packstart (btn);	packstart (resbtn);	btn.mouseentered += (sender, e) =>  {	insidebutton = true;	application.timeoutinvoke (100, checkmouseoverbutton);	
mouse entered 

spn.buttonreleased += handlebuttonreleased;	spn.mousescrolled += handlemousescrolled;	packstart (btn);	packstart (resbtn);	btn.mouseentered += (sender, e) =>  {	insidebutton = true;	application.timeoutinvoke (100, checkmouseoverbutton);	};	btn.mouseexited += (sender, e) => {	insidebutton = false;	
mouse exited 

application.timeoutinvoke (100, checkmouseoverbutton);	};	btn.mouseexited += (sender, e) => {	insidebutton = false;	};	btn.mousemoved += (sender, e) => movedoverbutton = true;	btn.buttonpressed += handlebuttonpressed;	btn.buttonreleased += handlebuttonreleased;	btn.clicked += (sender, e) => {	resbtn.text = "button clicked";	
clicked 

btn.buttonpressed += handlebuttonpressed;	btn.buttonreleased += handlebuttonreleased;	btn.clicked += (sender, e) => {	resbtn.text = "button clicked";	};	packstart (canvas);	packstart (rescanvas);	canvas.mouseentered += (sender, e) =>  {	insidecanvas = true;	application.timeoutinvoke (100, checkmouseovercanvas);	
mouse entered 

resbtn.text = "button clicked";	};	packstart (canvas);	packstart (rescanvas);	canvas.mouseentered += (sender, e) =>  {	insidecanvas = true;	application.timeoutinvoke (100, checkmouseovercanvas);	};	canvas.mouseexited += (sender, e) => {	insidecanvas = false;	
mouse exited 

========================= monodevelop sample_7494 =========================

static void runexternaltool (externaltools.externaltool tool, string argumentstool) {	string commandtool = stringparserservice.parse (tool.command, ideapp.workbench.getstringtagmodel ());	string initialdirectorytool = stringparserservice.parse (tool.initialdirectory, ideapp.workbench.getstringtagmodel ());	progressmonitor progressmonitor = ideapp.workbench.progressmonitors.getrunprogressmonitor ();	try {	
running 

processwrapper processwrapper;	if (tool.useoutputpad) processwrapper = runtime.processservice.startprocess (commandtool, argumentstool, initialdirectorytool, progressmonitor.log, progressmonitor.log, null);	else processwrapper = runtime.processservice.startprocess (commandtool, argumentstool, initialdirectorytool, null);	string processname = system.io.path.getfilename (commandtool);	try {	processname = processwrapper.processname;	} catch (systemexception) {	}	processwrapper.waitforoutput ();	if (processwrapper.exitcode == 0) {	
process has completed succesfully 

if (tool.useoutputpad) processwrapper = runtime.processservice.startprocess (commandtool, argumentstool, initialdirectorytool, progressmonitor.log, progressmonitor.log, null);	else processwrapper = runtime.processservice.startprocess (commandtool, argumentstool, initialdirectorytool, null);	string processname = system.io.path.getfilename (commandtool);	try {	processname = processwrapper.processname;	} catch (systemexception) {	}	processwrapper.waitforoutput ();	if (processwrapper.exitcode == 0) {	} else {	
process has exited with error code 

========================= monodevelop sample_1349 =========================

protected override void performwork() {	result.setresult(resultstate.success);	performonetimesetup();	if (result.resultstate.status == teststatus.passed && _suite.haschildren) {	foreach (test test in _suite.tests) if (_childfilter.pass(test)) _children.enqueue(createworkitem(test, this.context, _childfilter));	if (_children.count > 0) {	runchildren();	return;	}	else {	
no tests found that match filter 

========================= monodevelop sample_5651 =========================

engine = info.engine;	projectinstance = engine.createprojectinstance (info.project);	try {	foreach (var gpp in msbuildprojectservice.globalpropertyproviders) {	foreach (var prop in gpp.getglobalproperties ()) engine.setglobalproperty (projectinstance, prop.key, prop.value);	}	foreach (var prop in globalproperties) engine.setglobalproperty (projectinstance, prop.key, prop.value);	engine.evaluate (projectinstance, onlyevaluateproperties);	syncbuildproject (info.itemmap, info.engine, projectinstance);	} catch (exception ex) {	
msbuild project could not be evaluated 

========================= monodevelop sample_2171 =========================

public void testsimplemethodcall () {	string result = runcontextaction ( new createpropertyaction (), "using system;" + environment.newline + "class testclass" + environment.newline + "{" + environment.newline + "	void test ()" + environment.newline + "	{" + environment.newline + "		console.writeline ($foo);" + environment.newline + "	}" + environment.newline + "}" );	
using system class testclass object foo get set void test console writeline foo 

public void testcreateproperty (string input, string output) {	string result = runcontextaction (new createpropertyaction (), createmethoddeclarationtests.homogenizeeol (input));	bool passed = result == output;	if (!passed) {	
expected 

public void testcreateproperty (string input, string output) {	string result = runcontextaction (new createpropertyaction (), createmethoddeclarationtests.homogenizeeol (input));	bool passed = result == output;	if (!passed) {	console.writeline (output);	
got 

========================= monodevelop sample_8759 =========================

public void addmap (runtimeaddin addin, string xmlmap, string fileid) {	xmldocument doc = new xmldocument ();	doc.loadxml (xmlmap);	foreach (xmlelement elem in doc.documentelement.selectnodes ("dataitem")) {	string tname = elem.getattribute ("class");	type type = addin.gettype (tname);	if (type == null) {	
serializationmap type not found 

mem.declaringtype = map.type;	map.extendedmembers.add (mem);	lastmember = mem;	continue;	}	else {	membername = att.getattribute ("member");	type mt;	object mi;	if (!findmember (map, membername, out mi, out mt)) {	
serializationmap member not found in type 

========================= monodevelop sample_2145 =========================

public void canlistavailableframeworks() {	runtimeframework[] available = runtimeframework.availableframeworks;	assert.that(available, has.length.greaterthan(0) );	bool foundcurrent = false;	foreach (runtimeframework framework in available) {	
available 

========================= monodevelop sample_5826 =========================

public void updatecontent(string serviceid) {	var binding = ((dotnetproject)this.project).getconnectedservicesbinding ();	if (!string.isnullorempty (serviceid)) {	var service = binding.supportedservices.firstordefault (x => x.id == serviceid);	if (service != null) {	this.widget.showservicedetails (service);	return;	}	
showing service details failed service id not found 

========================= monodevelop sample_4698 =========================

if (ce is solutionfolder) makefile.append ("dist-local: dist-local-recursive\n");	else makefile.append ("include $(top_srcdir)/rules.make\n");	}	ctx.addgeneratedfile (outpath);	}	streamwriter writer = new streamwriter (outpath);	makefile.write ( writer );	writer.close ();	}	else {	
project skipped 

========================= monodevelop sample_2394 =========================

public override string tostring () {	stringwriter sw = new stringwriter ();	
present 

public override string tostring () {	stringwriter sw = new stringwriter ();	
presenttotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
missing 

public override string tostring () {	stringwriter sw = new stringwriter ();	
missingtotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
todo 

public override string tostring () {	stringwriter sw = new stringwriter ();	
todototal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
extra 

public override string tostring () {	stringwriter sw = new stringwriter ();	
extratotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
warning 

public override string tostring () {	stringwriter sw = new stringwriter ();	
warningtotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
errortotal 

public static xmlassembly createfromfile (string file) {	xmldocument doc = new xmldocument ();	doc.load (file.openread (file));	xmlnode node = doc.selectsinglenode ("/assemblies/assembly");	if (node != null) {	xmlassembly result = new xmlassembly ();	try {	result.loaddata (node);	} catch (exception e) {	
error loading 

if (node == null) throw new argumentnullexception ("node");	name = node.attributes ["name"].value;	version = node.attributes  ["version"].value;	xmlnode atts = node.firstchild;	attributes = new xmlattributes ();	if (atts.name == "attributes") {	attributes.loaddata (atts);	atts = atts.nextsibling;	}	if (atts == null || atts.name != "namespaces") {	
warning no namespaces found 

public override void loaddata (xmlnode node) {	if (node == null) throw new argumentnullexception ("node");	if (node.name != "namespace") throw new formatexception ("expecting <namespace>");	name = node.attributes  ["name"].value;	xmlnode classes = node.firstchild;	if (classes == null) {	
warning no classes for name 

events.loaddata (child);	child = child.nextsibling;	}	if (child != null && child.name == "methods") {	methods = new xmlmethods ();	methods.loaddata (child);	child = child.nextsibling;	}	if (child == null) return;	if (child.name != "classes") {	
name type 

========================= monodevelop sample_9860 =========================

if ((symboltype == "t") || (symboltype == "t")) {	lastfunction = region.newfunction (symbolname, (uint) symboloffset);	}	}	}	}	if (lastfunction != null) {	lastfunction.endoffset = (uint) (region.endaddress - region.startaddress);	}	} catch (exception e) {	
exception 

========================= monodevelop sample_9920 =========================

public csharpfile(csharpproject project, string filename) {	this.project = project;	this.filename = filename;	csharpparser p = new csharpparser(project.compilersettings);	this.originaltext = file.readalltext(filename);	this.syntaxtree = p.parse(this.originaltext, filename);	this.syntaxtree.freeze();	if (p.haserrors) {	
error parsing 

========================= monodevelop sample_7981 =========================

protected abstract itextsource formatimplementation (policycontainer policyparent, string mimetype, itextsource input, int startoffset, int length);	public itextsource format (policycontainer policyparent, string mimetype, itextsource input, int startoffset, int length) {	if (startoffset < 0 || startoffset > input.length) throw new argumentoutofrangeexception (nameof (startoffset), "should be >= 0 && < " + input.length + " was:" + startoffset);	if (length < 0 || startoffset + length > input.length) throw new argumentoutofrangeexception (nameof (length), "should be >= 0 && < " + (input.length - startoffset) + " was:" + length);	try {	return formatimplementation (policyparent ?? policyservice.defaultpolicies, mimetype, input, startoffset, length);	} catch (exception e) {	
error while formatting text 

========================= monodevelop sample_1803 =========================

static void releasetrampoline (intptr @this, intptr sel) {	int ref_count = messaging.int_objc_msgsend (@this, selector.retaincount);	nsobject obj = null;	#if debug_ref_counting console.writeline ("releasetrampoline ({0} handle=0x{1}) retaincount={2}; hasmanagedref={3} gchandle={4}", getclassname (@this), @this.tostring ("x"), ref_count, hasmanagedref (@this), getgchandle (@this));	#endif if (ref_count == 1) {	obj = runtime.trygetnsobject (@this);	if (obj != null) {	obj.unregisterobject ();	obj.freegchandle ();	} else {	
could not find managed object 

========================= monodevelop sample_11261 =========================

public void markfiledirty (string filename) {	try {	var fi = new fileinfo (filename);	if (fi.exists) fi.lastwritetime = datetime.now;	} catch (exception e) {	
error while marking file as dirty 

public bool editfile (filepath filepath, action<itextdocument> operation) {	if (operation == null) throw new argumentnullexception ("operation");	bool isopen;	var data = gettexteditordata (filepath, out isopen);	operation (data);	if (!isopen) {	try {	data.save ();	} catch (exception e) {	
error while saving changes to 

========================= monodevelop sample_1640 =========================

public override int compareobjects (itreenavigator thisnode, itreenavigator othernode) {	try {	if (thisnode == null || othernode == null) return -1;	var e1 = thisnode.dataitem as assemblynamereference;	var e2 = othernode.dataitem as assemblynamereference;	if (e1 == null && e2 == null) return 0;	if (e1 == null) return 1;	if (e2 == null) return -1;	return e1.name.compareto (e2.name);	} catch (exception e) {	
exception in assembly browser sort function 

========================= monodevelop sample_2429 =========================

public void add (filepath[] localpaths, bool recurse, progressmonitor monitor) {	try {	onadd (localpaths, recurse, monitor);	} catch (exception e) {	
failed to add file 

public void movefile (filepath localsrcpath, filepath localdestpath, bool force, progressmonitor monitor) {	clearcachedversioninfo (localsrcpath, localdestpath);	try {	onmovefile (localsrcpath, localdestpath, force, monitor);	} catch (exception e) {	
failed to move file 

public void movedirectory (filepath localsrcpath, filepath localdestpath, bool force, progressmonitor monitor) {	clearcachedversioninfo (localsrcpath, localdestpath);	try {	onmovedirectory (localsrcpath, localdestpath, force, monitor);	} catch (exception e) {	
failed to move directory 

========================= monodevelop sample_4174 =========================

public static void main(string[] args) {	var x = new class1().x;	
hello world 

========================= monodevelop sample_100 =========================

public bool trygetcolor (string key, out hslcolor color) {	pobject value;	if (!settings.trygetvalue (key, out value)) {	color = new hslcolor (0, 0, 0);	return false;	}	try {	color = hslcolor.parse (((pstring)value).value);	} catch (exception e) {	
error while parsing color 

========================= monodevelop sample_1573 =========================

imported_aldeleteeffects = (delegate_aldeleteeffects)marshal.getdelegateforfunctionpointer(al.getprocaddress("aldeleteeffects"), typeof(delegate_aldeleteeffects));	imported_aliseffect = (delegate_aliseffect)marshal.getdelegateforfunctionpointer(al.getprocaddress("aliseffect"), typeof(delegate_aliseffect));	imported_aleffecti = (delegate_aleffecti)marshal.getdelegateforfunctionpointer(al.getprocaddress("aleffecti"), typeof(delegate_aleffecti));	imported_aleffectf = (delegate_aleffectf)marshal.getdelegateforfunctionpointer(al.getprocaddress("aleffectf"), typeof(delegate_aleffectf));	imported_aleffectfv = (delegate_aleffectfv)marshal.getdelegateforfunctionpointer(al.getprocaddress("aleffectfv"), typeof(delegate_aleffectfv));	imported_algeteffecti = (delegate_algeteffecti)marshal.getdelegateforfunctionpointer(al.getprocaddress("algeteffecti"), typeof(delegate_algeteffecti));	imported_algeteffectf = (delegate_algeteffectf)marshal.getdelegateforfunctionpointer(al.getprocaddress("algeteffectf"), typeof(delegate_algeteffectf));	imported_algeteffectfv = (delegate_algeteffectfv)marshal.getdelegateforfunctionpointer(al.getprocaddress("algeteffectfv"), typeof(delegate_algeteffectfv));	}	catch (exception e) {	
failed to marshal effect functions 

try {	imported_algenfilters = (delegate_algenfilters)marshal.getdelegateforfunctionpointer(al.getprocaddress("algenfilters"), typeof(delegate_algenfilters));	imported_aldeletefilters = (delegate_aldeletefilters)marshal.getdelegateforfunctionpointer(al.getprocaddress("aldeletefilters"), typeof(delegate_aldeletefilters));	imported_alisfilter = (delegate_alisfilter)marshal.getdelegateforfunctionpointer(al.getprocaddress("alisfilter"), typeof(delegate_alisfilter));	imported_alfilteri = (delegate_alfilteri)marshal.getdelegateforfunctionpointer(al.getprocaddress("alfilteri"), typeof(delegate_alfilteri));	imported_alfilterf = (delegate_alfilterf)marshal.getdelegateforfunctionpointer(al.getprocaddress("alfilterf"), typeof(delegate_alfilterf));	imported_algetfilteri = (delegate_algetfilteri)marshal.getdelegateforfunctionpointer(al.getprocaddress("algetfilteri"), typeof(delegate_algetfilteri));	imported_algetfilterf = (delegate_algetfilterf)marshal.getdelegateforfunctionpointer(al.getprocaddress("algetfilterf"), typeof(delegate_algetfilterf));	}	catch (exception e) {	
failed to marshal filter functions 

try {	imported_algenauxiliaryeffectslots = (delegate_algenauxiliaryeffectslots)marshal.getdelegateforfunctionpointer(al.getprocaddress("algenauxiliaryeffectslots"), typeof(delegate_algenauxiliaryeffectslots));	imported_aldeleteauxiliaryeffectslots = (delegate_aldeleteauxiliaryeffectslots)marshal.getdelegateforfunctionpointer(al.getprocaddress("aldeleteauxiliaryeffectslots"), typeof(delegate_aldeleteauxiliaryeffectslots));	imported_alisauxiliaryeffectslot = (delegate_alisauxiliaryeffectslot)marshal.getdelegateforfunctionpointer(al.getprocaddress("alisauxiliaryeffectslot"), typeof(delegate_alisauxiliaryeffectslot));	imported_alauxiliaryeffectsloti = (delegate_alauxiliaryeffectsloti)marshal.getdelegateforfunctionpointer(al.getprocaddress("alauxiliaryeffectsloti"), typeof(delegate_alauxiliaryeffectsloti));	imported_alauxiliaryeffectslotf = (delegate_alauxiliaryeffectslotf)marshal.getdelegateforfunctionpointer(al.getprocaddress("alauxiliaryeffectslotf"), typeof(delegate_alauxiliaryeffectslotf));	imported_algetauxiliaryeffectsloti = (delegate_algetauxiliaryeffectsloti)marshal.getdelegateforfunctionpointer(al.getprocaddress("algetauxiliaryeffectsloti"), typeof(delegate_algetauxiliaryeffectsloti));	imported_algetauxiliaryeffectslotf = (delegate_algetauxiliaryeffectslotf)marshal.getdelegateforfunctionpointer(al.getprocaddress("algetauxiliaryeffectslotf"), typeof(delegate_algetauxiliaryeffectslotf));	}	catch (exception e) {	
failed to marshal auxiliaryeffectslot functions 

========================= monodevelop sample_11344 =========================

public void breakpointinsideonelinedelegatenodisplayclass () {	initializetest ();	addbreakpoint ("e0a96c37-577f-43e3-9a20-2cdd8bf7824e");	
console writeline 

public void breakpointinsideonelinedelegatenodisplayclass () {	initializetest ();	addbreakpoint ("e0a96c37-577f-43e3-9a20-2cdd8bf7824e");	starttest ("breakpointinsideonelinedelegatenodisplayclass");	checkposition ("e0a96c37-577f-43e3-9a20-2cdd8bf7824e");	
console writeline 

========================= monodevelop sample_6014 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_196 =========================

foreach (var renamechange in changes.oftype<renamefilechange> ()) {	if (filenames.contains (renamechange.oldname)) {	filenames.remove (renamechange.oldname);	filenames.add (renamechange.newname);	}	}	foreach (var doc in ideapp.workbench.documents) {	filenames.remove (doc.filename);	}	} catch (exception e) {	
error while applying refactoring changes 

========================= monodevelop sample_4051 =========================

string tdir = fileservice.getfullpath (path.getdirectoryname (tfile));	if (!directory.exists (tdir)) directory.createdirectory (tdir);	file.copy (file.sourcepath, tfile, true);	}	string td = path.getdirectoryname (targetfile);	if (!directory.exists (td)) directory.createdirectory (td);	deployservice.createarchive (monitor, tmpfolder, targetfile);	}	catch (exception ex) {	monitor.reporterror ("package creation failed", ex);	
package creation failed 

if (!directory.exists (td)) directory.createdirectory (td);	deployservice.createarchive (monitor, tmpfolder, targetfile);	}	catch (exception ex) {	monitor.reporterror ("package creation failed", ex);	return false;	}	finally {	if (tmpfolder != null) directory.delete (tmpfolder, true);	}	
created file 

========================= monodevelop sample_4333 =========================

static metadataset resolvewithwsmex (string url) {	metadataset metadata = null;	try {	var client = new metadataexchangeclient (new endpointaddress (url));	
attempting to download metadata from using ws metadataexchange 

static metadataset resolvewithwsmex (string url) {	metadataset metadata = null;	try {	var client = new metadataexchangeclient (new endpointaddress (url));	metadata = client.getmetadata ();	} catch (invalidoperationexception e) {	string msg;	msg = e.innerexception == null ? e.message : e.innerexception.tostring ();	
ws metadataexchange query failed for the url with exception 

========================= monodevelop sample_4372 =========================

public static void main (string [] args) {	
hello world 

========================= monodevelop sample_124 =========================

public static async task launchbrowser (string appurl, string launchurl, task processtask) {	launchurl = launchurl ?? "";	uri launchuri;	if (!uri.trycreate (launchurl, urikind.absolute, out launchuri)) {	uri appuri;	if (!uri.trycreate (appurl, urikind.absolute, out appuri)) {	
failed to launch browser because invalid launch and app urls 

public static async task launchbrowser (string appurl, string launchurl, task processtask) {	launchurl = launchurl ?? "";	uri launchuri;	if (!uri.trycreate (launchurl, urikind.absolute, out launchuri)) {	uri appuri;	if (!uri.trycreate (appurl, urikind.absolute, out appuri)) {	return;	}	if (!uri.trycreate (launchurl, urikind.relative, out launchuri)) {	
failed to launch browser because invalid launch url 

using (var tcpclient = new tcpclient ()) {	try {	tcpclient.connect (launchuri.host, launchuri.port);	await task.delay (timespan.fromseconds (1));	break;	} catch {	}	}	}	if (processtask.iscompleted) {	
failed to launch browser because process exited before server started listening 

========================= monodevelop sample_4263 =========================

static autosave () {	try {	if (!directory.exists (autosavepath)) directory.createdirectory (autosavepath);	} catch (exception e) {	
can t create auto save path auto save is disabled 

var autosavefilename = getautosavefilename (filename);	bool autosaveexists = file.exists (autosavefilename);	if (autosaveexists) {	if (file.getlastwritetimeutc (autosavefilename) < file.getlastwritetimeutc (filename)) {	file.delete (autosavefilename);	return false;	}	}	return autosaveexists;	} catch (exception e) {	
error in auto save disableing 

static void createautosave (string filename, itextsource content) {	if (!autosaveenabled) return;	try {	var autosavefilename = getautosavefilename (filename);	if (file.exists (autosavefilename)) file.delete (autosavefilename);	content.writetextto (autosavefilename);	counters.autosavedfiles++;	} catch (exception e) {	
error in auto save while creating disableing auto save 

public static void removeautosavefile (string filename) {	if (!autosaveenabled) return;	if (autosaveexists (filename)) {	string autosavefilename = getautosavefilename (filename);	try {	file.delete (autosavefilename);	} catch (exception e) {	
can t delete auto save file disableing auto save 

========================= monodevelop sample_1697 =========================

public static void main (string[] args) {	
hello world 

========================= monodevelop sample_186 =========================

for (int i = linesegment.offset; i < linesegment.offset + linesegment.length; i++) {	tracker.push (editor.getcharat (i));	}	string curindent = linesegment.getindentation (editor);	int nlwsp = curindent.length;	if (!tracker.linebeganinsidemultilinecomment || (nlwsp < linesegment.lengthincludingdelimiter && editor.getcharat (linesegment.offset + nlwsp) == '*')) {	string newindent = tracker.thislineindent;	if (newindent != curindent) editor.replacetext (linesegment.offset, nlwsp, newindent);	}	} catch (exception e) {	
error while indenting 

========================= monodevelop sample_3973 =========================

public static void print (textwriter writer, testresultcollection result) {	writer.writeline ();	
total tests passed errors 

========================= monodevelop sample_11185 =========================

int caretpositon = input.indexof('$');	if (caretpositon > 0) input = input.substring(0, caretpositon) + input.substring(caretpositon + 1);	var document1 = new stringbuilderdocument(input);	int expectedcaretposition = expectedoutput.indexof('$');	if (expectedcaretposition > 0) expectedoutput = expectedoutput.substring(0, expectedcaretposition) + expectedoutput.substring(expectedcaretposition + 1);	var fixer = new constructfixer(formattingoptionsfactory.createmono (), new texteditoroptions { eolmarker = "\n" });	int newcaretposition;	assert.istrue(fixer.tryfix(document1, caretpositon, out newcaretposition));	var isequal = expectedoutput == document1.text.replace("\r\n", "\n");	if (!isequal) {	
expected 

if (caretpositon > 0) input = input.substring(0, caretpositon) + input.substring(caretpositon + 1);	var document1 = new stringbuilderdocument(input);	int expectedcaretposition = expectedoutput.indexof('$');	if (expectedcaretposition > 0) expectedoutput = expectedoutput.substring(0, expectedcaretposition) + expectedoutput.substring(expectedcaretposition + 1);	var fixer = new constructfixer(formattingoptionsfactory.createmono (), new texteditoroptions { eolmarker = "\n" });	int newcaretposition;	assert.istrue(fixer.tryfix(document1, caretpositon, out newcaretposition));	var isequal = expectedoutput == document1.text.replace("\r\n", "\n");	if (!isequal) {	system.console.writeline(expectedoutput);	
was 

========================= monodevelop sample_8396 =========================

static testbase () {	var toppath = locatetoplevel ();	
testresult loggingservice log 

========================= monodevelop sample_246 =========================

public void stop () {	if (service != null) service.detachclient (this);	else try {	process.kill ();	} catch (invalidoperationexception) {	
process has already exited 

========================= monodevelop sample_1532 =========================

onstatechanged (true);	onoperationstartedevent (this);	onmessageevent ("loading {0}", uri);	var result = await run (uri, cts.token);	if (result != null) onmessageevent (result);	else onmessageevent ("loaded {0}.", uri);	} catch (taskcanceledexception) {	onmessageevent ("cancelled!");	} catch (exception ex) {	onmessageevent ("error: {0}", ex.message);	
error 

========================= monodevelop sample_11113 =========================

if (!found) popcount = 0;	while (popcount > 1) {	xelement el = context.nodes.pop () as xelement;	if (el != null) context.logerror (string.format ( "unclosed tag '{0}' at line {1}, column {2}.", el.name.fullname, el.region.beginline, el.region.begincolumn), ct.region);	popcount--;	}	if (popcount > 0) {	if (context.buildtree) ((xelement) context.nodes.pop ()).close (ct);	else context.nodes.pop ();	} else {	
closing tag does not match any currently open tag 

xelement el = context.nodes.pop () as xelement;	if (el != null) context.logerror (string.format ( "unclosed tag '{0}' at line {1}, column {2}.", el.name.fullname, el.region.beginline, el.region.begincolumn), ct.region);	popcount--;	}	if (popcount > 0) {	if (context.buildtree) ((xelement) context.nodes.pop ()).close (ct);	else context.nodes.pop ();	} else {	}	} else {	
closing tag ended prematurely 

if (popcount > 0) {	if (context.buildtree) ((xelement) context.nodes.pop ()).close (ct);	else context.nodes.pop ();	} else {	}	} else {	}	return parent;	}	if (c == '<') {	
unexpected in tag 

return parent;	}	if (xmlchar.iswhitespace (c)) {	return null;	}	if (!ct.isnamed && (char.isletter (c) || c == '_')) {	rollback = string.empty;	return namestate;	}	rollback = string.empty;	
unexpected character in closing tag 

========================= monodevelop sample_3495 =========================

public void showhelp () {	
usage stresstest options 

public void showhelp () {	console.writeline ();	
options 

public void showhelp () {	console.writeline ();	
iterations number number of times the stress test will be run 

public void showhelp () {	console.writeline ();	
mdbinpath path path to monodevelop exe or visualstudio exe 

public void showhelp () {	console.writeline ();	
useinstalledapp use installed visual studio app 

public void showhelp () {	console.writeline ();	
profiler use profiler to make more detailed leak reporting 

========================= monodevelop sample_332 =========================

canwrite = pinfo.setmethod != null;	}	else {	name = elem.getattribute ("name");	tname = elem.getattribute ("type");	canwrite = elem.attributes ["canwrite"] == null;	}	load (elem);	type = stetic.registry.gettype (tname, false);	if (type == null) {	
could not find type 

========================= monodevelop sample_3584 =========================

public void trackprocesstask (task<int> task) {	task.continuewith (t => {	var faulted = t.isfaulted;	
merger exception 

========================= monodevelop sample_10713 =========================

if (finfo.lastwritetime > configuredpackages.lastwritetime) configuredpackages = null;	}	}	if (configuredpackages == null) {	configuredpackages = new configuredpackagesmanager (path);	pkgmanagertable [path] = new weakreference (configuredpackages);	ownerproject.extendedproperties ["monodevelop.autotools.configuredpackagesmanager"] = configuredpackages;	}	}	} catch (exception e) {	
error trying to read configure in for project 

public list<packagecontent> getpackagecontentfromvarname (string varname) {	if (!pkgvarnametopkgname.containskey (varname)) {	
pkg config variable not found in pkgvarnametopkgname 

public string getvarnamefromname (string name) {	if (!pkgnametopkgvarname.containskey (name)) {	
package named not specified in configure in 

========================= monodevelop sample_2377 =========================

public static bool isfoldercasesensitive (filepath path) {	var testfile = path.combine (guid.newguid ().tostring ().tolower ());	try {	file.writealltext (testfile, "");	return !file.exists (testfile.tostring ().toupper ());	} catch (exception ex) {	
isfoldercasesensitive failed 

public static filewriteablestate getwriteablestate (filepath filename) {	debug.assert (!string.isnullorempty (filename));	try {	return getfilesystemforpath (filename, false).getwriteablestate (filename);	} catch (exception ex) {	
file can t be written 

public static void notifyfileschanged (ienumerable<filepath> files, bool autoreload) {	try {	foreach (var fsfiles in files.groupby (f => getfilesystemforpath (f, false))) fsfiles.key.notifyfileschanged (fsfiles);	onfilechanged (new fileeventargs (files, false, autoreload));	} catch (exception ex) {	
file change notification failed 

public static void notifyfilesremoved (ienumerable<filepath> files) {	try {	onfileremoved (new fileeventargs (files, false));	} catch (exception ex) {	
file remove notification failed 

}	ct.throwifcancellationrequested ();	systemrename (tempfile, cachefile);	deletetempfile = false;	return true;	} finally {	if (deletetempfile) {	try {	file.delete (tempfile);	} catch (exception ex) {	
failed to delete temp download file 

========================= monodevelop sample_2326 =========================

public void swallowerrorscatchingtypeexceptionnoemptycatchblock () {	try {	file.open ("foo.txt", filemode.open);	}	catch (exception) {	
has happened an exception 

public void swallowerrorscatchingallnoemptycatchblock () {	try {	file.open ("foo.txt", filemode.open);	}	catch {	
has happened an exception 

public void skipusinggoto () {	try {	file.open ("foo.txt", filemode.open);	}	catch (exception exception) {	retry: if (exception == null) throw new exception (exception.tostring ());	
skipped 

========================= monodevelop sample_10602 =========================

static type getregisteredtype (string name) {	type t;	if (!policynames.trygetvalue (name, out t)) {	
cannot deserialise unregistered policy name 

userdefaultpolicies = null;	try {	if (directory.exists (policiesfolder)) {	foreach (var file in directory.getfiles (policiesfolder, "*.mdpolicy.mdpolicy.xml")) file.delete (file);	foreach (var file in directory.getfiles (policiesfolder, "*.mdpolicy.mdpolicy.xml.previous")) file.delete (file);	if (file.exists (policiesfolder.combine ("default.mdpolicy.xml")) && file.exists (policiesfolder.combine ("userdefault.mdpolicy.xml"))) file.delete (policiesfolder.combine ("default.mdpolicy.xml"));	foreach (var file in directory.getfiles (policiesfolder, "*.mdpolicy.xml")) {	try {	loadpolicy (file);	} catch (exception ex) {	
failed to load policy file 

foreach (var file in directory.getfiles (policiesfolder, "*.mdpolicy.mdpolicy.xml.previous")) file.delete (file);	if (file.exists (policiesfolder.combine ("default.mdpolicy.xml")) && file.exists (policiesfolder.combine ("userdefault.mdpolicy.xml"))) file.delete (policiesfolder.combine ("default.mdpolicy.xml"));	foreach (var file in directory.getfiles (policiesfolder, "*.mdpolicy.xml")) {	try {	loadpolicy (file);	} catch (exception ex) {	}	}	}	} catch (exception ex) {	
policy load failed 

static bool paranoidload (string filename, string friendlyname, action<streamreader> read) {	streamreader reader = null;	try {	if (file.exists (filename)) {	reader = new streamreader (filename, system.text.encoding.utf8);	read (reader);	return true;	}	} catch (exception ex) {	
error loading file 

}	}	string backupfile = filename + ".previous";	try {	if (file.exists (backupfile)) {	reader = new streamreader (backupfile, system.text.encoding.utf8);	read (reader);	return true;	}	} catch (exception ex) {	
error loading backup file 

static bool paranoidsave (string filename, string friendlyname, action<streamwriter> write) {	string backupfilename = filename + ".previous";	string dir = path.getdirectoryname (filename);	string tempfilename = path.combine (dir, ".#" + path.getfilename (filename));	try {	if (!directory.exists (dir)) {	directory.createdirectory (dir);	}	} catch (ioexception ex) {	
error creating directory for file 

directory.createdirectory (dir);	}	} catch (ioexception ex) {	return false;	}	try {	if (file.exists (filename)) {	file.copy (filename, backupfilename, true);	}	} catch (ioexception ex) {	
error copying file to backup 

streamwriter writer = null;	try {	writer = new streamwriter (tempfilename, false, system.text.encoding.utf8);	write (writer);	writer.close ();	writer = null;	fileservice.systemrename (tempfilename, filename);	return true;	}	catch (exception ex) {	
error writing file 

========================= monodevelop sample_2266 =========================

protected virtual void onfilechooserbutton2focused (object o, gtk.focusedargs args) {	
got focus 

========================= monodevelop sample_9870 =========================

public async task<int> run (string [] arguments) {	
monodevelop makefile generator 

if (arguments.length == 0) {	showusage ();	return 0;	}	foreach (string s in arguments) {	if (s == "--simple-makefiles" || s == "-s") {	generateautotools = false;	} else if (s.startswith ("-d:")) {	if (s.length > 3) defaultconfig = s.substring (3);	} else if (s [0] == '-') {	
error unknown option 

}	foreach (string s in arguments) {	if (s == "--simple-makefiles" || s == "-s") {	generateautotools = false;	} else if (s.startswith ("-d:")) {	if (s.length > 3) defaultconfig = s.substring (3);	} else if (s [0] == '-') {	return 1;	} else {	if (filename != null) {	
error filename already specified another filename cannot be specified 

} else if (s [0] == '-') {	return 1;	} else {	if (filename != null) {	return 1;	}	filename = s;	}	}	if (filename == null) {	
error solution file not specified 

if (filename != null) {	return 1;	}	filename = s;	}	}	if (filename == null) {	showusage ();	return 1;	}	
loading solution file 

filename = s;	}	}	if (filename == null) {	showusage ();	return 1;	}	consoleprogressmonitor monitor = new consoleprogressmonitor ();	solution solution = await services.projectservice.readworkspaceitem (monitor, filename) as solution;	if (solution == null) {	
error makefile generation supported only for solutions 

if (filename == null) {	showusage ();	return 1;	}	consoleprogressmonitor monitor = new consoleprogressmonitor ();	solution solution = await services.projectservice.readworkspaceitem (monitor, filename) as solution;	if (solution == null) {	return 1;	}	if (defaultconfig == null || !checkvalidconfig (solution, defaultconfig)) {	
invalid configuration valid configurations 

========================= monodevelop sample_2384 =========================

public void autoincrement () {	
a 

========================= monodevelop sample_10471 =========================

if ((console == null || externalconsole != null) && externalconsolehandler != null) {	var dict = new dictionary<string,string> ();	if (environmentvariables != null) foreach (var kvp in environmentvariables) dict[kvp.key] = kvp.value;	if (environmentvariableoverrides != null) foreach (var kvp in environmentvariableoverrides) dict[kvp.key] = kvp.value;	var p = externalconsolehandler (command, arguments, workingdirectory, dict, externalconsole?.title ?? gettextcatalog.getstring ("{0} external console", brandingservice.applicationname), externalconsole != null ? !externalconsole.closeondispose : false);	if (p != null) {	if (exited != null) p.task.continuewith (t => exited (p, eventargs.empty), runtime.maintaskscheduler);	counters.processesstarted++;	return p;	} else {	
could not create external console for command 

} else {	}	}	processstartinfo psi = createprocessstartinfo (command, arguments, workingdirectory, false);	if (environmentvariables != null) foreach (keyvaluepair<string, string> kvp in environmentvariables) psi.environmentvariables [kvp.key] = kvp.value;	try {	processwrapper pw = startprocess (psi, console.out, console.error, null);	new processmonitor (console, pw.processasyncoperation, exited);	return pw.processasyncoperation;	} catch (exception ex) {	
the application could not be started 

} else {	}	}	processstartinfo psi = createprocessstartinfo (command, arguments, workingdirectory, false);	if (environmentvariables != null) foreach (keyvaluepair<string, string> kvp in environmentvariables) psi.environmentvariables [kvp.key] = kvp.value;	try {	processwrapper pw = startprocess (psi, console.out, console.error, null);	new processmonitor (console, pw.processasyncoperation, exited);	return pw.processasyncoperation;	} catch (exception ex) {	
could not start process for command 

public void onoperationcompleted () {	cancelregistration.dispose ();	try {	if (exited != null) runtime.runinmainthread (() => {	exited (operation, eventargs.empty);	});	
the application was terminated by a signal 

public void onoperationcompleted () {	cancelregistration.dispose ();	try {	if (exited != null) runtime.runinmainthread (() => {	exited (operation, eventargs.empty);	});	else if (operation.exitcode != 0) console.log.writeline (gettextcatalog.getstring ("the application exited with code: {0}"), operation.exitcode);	} catch (argumentexception ex) {	
the application was terminated by an unknown signal 

========================= monodevelop sample_2083 =========================

openstepwork = -1;	var t = currenttask;	currenttask = t.parenttask;	if (currenttask == null) roottask = null;	t.setcomplete ();	if (context != null) context.post ((o) => {	var (mon, task) = (valuetuple<progressmonitor, progresstask>)o;	mon.onendtask (task.name, task.totalwork, task.stepwork);	}, (this, t));	else onendtask (t.name, t.totalwork, t.stepwork);	
task not started 

========================= monodevelop sample_2312 =========================

public task writefile (string file, object obj, bool saveprojects, progressmonitor monitor) {	return task.run (async delegate {	solution sol = (solution)obj;	try {	monitor.begintask (gettextcatalog.getstring ("saving solution: {0}", file), 1);	await writefileinternal (file, file, sol, saveprojects, monitor).configureawait (false);	} catch (exception ex) {	monitor.reporterror (gettextcatalog.getstring ("could not save solution: {0}", file), ex);	
could not save solution 

========================= monodevelop sample_2203 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_91 =========================

case texttags.module: return editorthemecolors.usertypes;	case texttags.struct: return editorthemecolors.usertypesvaluetypes;	case texttags.typeparameter: return editorthemecolors.usertypestypeparameters;	case texttags.alias: case texttags.assembly: case texttags.field: case texttags.errortype: case texttags.event: case texttags.label: case texttags.local: case texttags.method: case texttags.namespace: case texttags.parameter: case texttags.property: case texttags.rangevariable: return "source.cs";	case texttags.numericliteral: return "constant.numeric";	case texttags.stringliteral: return "string.quoted";	case texttags.space: case texttags.linebreak: return "source.cs";	case texttags.operator: return "keyword.source";	case texttags.punctuation: return "punctuation";	case texttags.anonymoustypeindicator: case texttags.text: return "source.cs";	
warning unexpected text tag 

========================= monodevelop sample_978 =========================

static externaltoolservice () {	try {	tools = loadtools ();	} catch (exception e) {	
externaltoolservice exception while loading tools 

static list<externaltool> loadtools () {	list<externaltool> result = loadtools (userprofile.current.configdir.combine (filename));	if (result == null) {	
externaltoolservice no user templates reading default templates 

========================= monodevelop sample_1348 =========================

case "createdtime": {	if (!file.exists (itemfile)) return "";	return file.getcreationtime (itemfile).tostring ("yyyy-mm-dd hh:mm:ss");	}	case "accessedtime": {	if (!file.exists (itemfile)) return "";	return file.getlastaccesstime (itemfile).tostring ("yyyy-mm-dd hh:mm:ss");	}	}	} catch (exception ex) {	
failure in msbuild file 

========================= monodevelop sample_2170 =========================

output.writeline();	output.unindent();	}	output.writeline("{");	output.indent();	bool oldisintype = isintype;	isintype = true;	writeattributes(type.customattributes);	writesecuritydeclarations(type);	if (type.haslayoutinfo) {	
pack 

output.writeline();	output.unindent();	}	output.writeline("{");	output.indent();	bool oldisintype = isintype;	isintype = true;	writeattributes(type.customattributes);	writesecuritydeclarations(type);	if (type.haslayoutinfo) {	
size 

output.writeline("{");	output.indent();	bool oldisintype = isintype;	isintype = true;	writeattributes(type.customattributes);	writesecuritydeclarations(type);	if (type.haslayoutinfo) {	output.writeline();	}	if (type.hasnestedtypes) {	
foreach var nestedtype in type nestedtypes 

output.writeline();	}	if (type.hasnestedtypes) {	cancellationtoken.throwifcancellationrequested();	disassembletype(nestedtype);	output.writeline();	}	output.writeline();	}	if (type.hasfields) {	
foreach var field in type fields 

}	output.writeline();	}	if (type.hasfields) {	cancellationtoken.throwifcancellationrequested();	disassemblefield(field);	}	output.writeline();	}	if (type.hasmethods) {	
foreach var m in type methods 

}	output.writeline();	}	if (type.hasmethods) {	cancellationtoken.throwifcancellationrequested();	disassemblemethod(m);	output.writeline();	}	}	if (type.hasevents) {	
foreach var ev in type events 

}	}	if (type.hasevents) {	cancellationtoken.throwifcancellationrequested();	disassembleevent(ev);	output.writeline();	}	output.writeline();	}	if (type.hasproperties) {	
foreach var prop in type properties 

output.write(".publickey = ");	writeblob(asm.name.publickey);	output.writeline();	}	if (asm.name.hashalgorithm != assemblyhashalgorithm.none) {	output.write(".hash algorithm 0x{0:x8}", (int)asm.name.hashalgorithm);	if (asm.name.hashalgorithm == assemblyhashalgorithm.sha1) output.write(" output.writeline();	}	version v = asm.name.version;	if (v != null) {	
ver 

output.write(".hash algorithm 0x{0:x8}", (int)asm.name.hashalgorithm);	if (asm.name.hashalgorithm == assemblyhashalgorithm.sha1) output.write(" output.writeline();	}	version v = asm.name.version;	if (v != null) {	}	closeblock();	}	public void writeassemblyreferences(moduledefinition module) {	foreach (var mref in module.modulereferences) {	
module extern 

output.write(".assembly extern ");	if (aref.iswindowsruntime) output.write("windowsruntime ");	output.write(disassemblerhelpers.escape(aref.name));	openblock(false);	if (aref.publickeytoken != null) {	output.write(".publickeytoken = ");	writeblob(aref.publickeytoken);	output.writeline();	}	if (aref.version != null) {	
ver 

}	}	public void writemoduleheader(moduledefinition module) {	if (module.hasexportedtypes) {	foreach (exportedtype exportedtype in module.exportedtypes) {	output.write(".class extern ");	if (exportedtype.isforwarder) output.write("forwarder ");	output.write(exportedtype.declaringtype != null ? exportedtype.name : exportedtype.fullname);	openblock(false);	if (exportedtype.declaringtype != null) output.writeline(".class extern {0}", disassemblerhelpers.escape(exportedtype.declaringtype.fullname));	
assembly extern 

if (module.hasexportedtypes) {	foreach (exportedtype exportedtype in module.exportedtypes) {	output.write(".class extern ");	if (exportedtype.isforwarder) output.write("forwarder ");	output.write(exportedtype.declaringtype != null ? exportedtype.name : exportedtype.fullname);	openblock(false);	if (exportedtype.declaringtype != null) output.writeline(".class extern {0}", disassemblerhelpers.escape(exportedtype.declaringtype.fullname));	closeblock();	}	}	
module 

if (module.hasexportedtypes) {	foreach (exportedtype exportedtype in module.exportedtypes) {	output.write(".class extern ");	if (exportedtype.isforwarder) output.write("forwarder ");	output.write(exportedtype.declaringtype != null ? exportedtype.name : exportedtype.fullname);	openblock(false);	if (exportedtype.declaringtype != null) output.writeline(".class extern {0}", disassemblerhelpers.escape(exportedtype.declaringtype.fullname));	closeblock();	}	}	
output writeline 

========================= monodevelop sample_548 =========================

public void write (textwriter writer) {	writer.newline = format.newline;	for (int n=0; n<prefixblanklines; n++) writer.writeline ();	
microsoft visual studio solution file format version 

public void write (textwriter writer) {	writer.newline = format.newline;	for (int n=0; n<prefixblanklines; n++) writer.writeline ();	writer.writeline ("# " + productdescription);	metadata.write (writer);	foreach (var p in projects) p.write (writer);	
global 

public void write (textwriter writer) {	writer.newline = format.newline;	for (int n=0; n<prefixblanklines; n++) writer.writeline ();	writer.writeline ("# " + productdescription);	metadata.write (writer);	foreach (var p in projects) p.write (writer);	foreach (slnsection s in sections) s.write (writer, "globalsection");	
endglobal 

writer.write ("\") = \"");	writer.write (name);	writer.write ("\", \"");	writer.write (filepath);	writer.write ("\", \"");	writer.write (id);	writer.writeline ("\"");	if (sections != null) {	foreach (slnsection s in sections) s.write (writer, "projectsection");	}	
endproject 

========================= monodevelop sample_2183 =========================

public void testanonymousmethodsubscription() {	testissue<staticeventsubscriptionanalyzer>(@" using system;	class foo {	public static event eventhandler foobar;	public void test () {	foobar += delegate {	
hello 

public void testanonymousmethodsubscription_validcase() {	analyze<staticeventsubscriptionanalyzer>(@" using system;	class foo {	public static event eventhandler foobar;	public static void test () {	foobar += delegate {	
hello 

========================= monodevelop sample_6809 =========================

public static void main (string[] args) {	if (args.length == 0) {	
usage astverifier v verbose directory 

public static void main (string[] args) {	if (args.length == 0) {	return;	}	string directory = args[args.length - 1];	bool verboseoutput =  args.length > 1 && (args[0] == "-v" || args[0] == "-verbose");	try {	if (!directory.exists (directory)) {	
directory not found 

if (args.length == 0) {	return;	}	string directory = args[args.length - 1];	bool verboseoutput =  args.length > 1 && (args[0] == "-v" || args[0] == "-verbose");	try {	if (!directory.exists (directory)) {	return;	}	} catch (ioexception) {	
exception while trying to access the directory 

string directory = args[args.length - 1];	bool verboseoutput =  args.length > 1 && (args[0] == "-v" || args[0] == "-verbose");	try {	if (!directory.exists (directory)) {	return;	}	} catch (ioexception) {	return;	}	int failed = 0, passed = 0;	
search in 

int failed = 0, passed = 0;	foreach (var file in directory.getfilesystementries (directory, "*", searchoption.alldirectories)) {	if (!file.endswith (".cs", stringcomparison.ordinal)) continue;	string text = file.readalltext (file);	var unit = syntaxtree.parse (text, file);	if (unit == null) continue;	string generated = unit.tostring ();	int i, j;	if (!ismatch (text, generated, out i, out j)) {	if (i > 0 && j > 0 && verboseoutput) {	
fail original 

foreach (var file in directory.getfilesystementries (directory, "*", searchoption.alldirectories)) {	if (!file.endswith (".cs", stringcomparison.ordinal)) continue;	string text = file.readalltext (file);	var unit = syntaxtree.parse (text, file);	if (unit == null) continue;	string generated = unit.tostring ();	int i, j;	if (!ismatch (text, generated, out i, out j)) {	if (i > 0 && j > 0 && verboseoutput) {	console.writeline (text.substring (0, math.min (text.length, i + 1)));	
generated 

if (!ismatch (text, generated, out i, out j)) {	if (i > 0 && j > 0 && verboseoutput) {	console.writeline (text.substring (0, math.min (text.length, i + 1)));	console.writeline (generated.substring (0, math.min (generated.length, j + 1)));	}	failed++;	} else {	passed++;	}	}	
passed failed 

========================= monodevelop sample_9434 =========================

if (newcache == null) {	newcache = typesystemservice.getcachedirectory (basedirectory, true);	var olddirectory = path.combine (basedirectory, "test-results");	var newdirectory = path.combine (newcache, "test-results");	try {	directory.createdirectory (newdirectory);	if (directory.exists (olddirectory)) {	foreach (string file in directory.getfiles(olddirectory, "*.*")) file.copy (file, file.replace (olddirectory, newdirectory));	}	} catch (exception e) {	
error while copying old test results 

========================= monodevelop sample_4448 =========================

static void main (string [] args) {	typenames.addrange (args [0].split (','));	for (int i = 1; i < args.length; i++) {	assemblies.add (assemblydefinition.readassembly (args [i]));	}	if (typenames.count == 1) {	
looking for type 

static void main (string [] args) {	typenames.addrange (args [0].split (','));	for (int i = 1; i < args.length; i++) {	assemblies.add (assemblydefinition.readassembly (args [i]));	}	if (typenames.count == 1) {	} else {	
looking for types 

foreach (string name in typenames) console.writeline ("\t{0}", name);	}	console.writeline ();	int inside = 0;	int total = 0;	foreach (assemblydefinition assembly in assemblies) {	foreach (moduledefinition module in assembly.modules) {	bool all = typenames.all (name => (module.hastypereference (name)));	if (all) inside++;	total++;	
yes no 

console.writeline ();	int inside = 0;	int total = 0;	foreach (assemblydefinition assembly in assemblies) {	foreach (moduledefinition module in assembly.modules) {	bool all = typenames.all (name => (module.hastypereference (name)));	if (all) inside++;	total++;	}	}	
total out of assemblies 

========================= monodevelop sample_9970 =========================

public void typoextrasemicolumn (int x) {	if (x == 1);	
of course 

public void emptycondition (int x) {	if (x == 0) {	}	
of course 

public void condition (int x) {	if (x == 0) {	
zero 

public void condition (int x) {	if (x == 0) {	}	
of course 

========================= monodevelop sample_10460 =========================

public override monodevelop.projects.extensions.migrationtype shouldmigrateproject () {	
warning one or more projects in this solution cannot be 

public override monodevelop.projects.extensions.migrationtype shouldmigrateproject () {	
compiled unless they are migrated to a newer format please 

public override monodevelop.projects.extensions.migrationtype shouldmigrateproject () {	
open the solution in an ide and migrate the project so that 

public override monodevelop.projects.extensions.migrationtype shouldmigrateproject () {	
the solution can be compiled 

========================= monodevelop sample_2115 =========================

public ienumerable<string> getallpkgconfigfiles () {	var packagenames = new hashset<string> ();	foreach (string pcdir in pkgconfigdirs) {	ienumerable<string> files;	if (!directory.exists (pcdir)) continue;	try {	files = directory.enumeratefiles (pcdir, "*.pc");	} catch (exception ex) {	
runtime error in pc file scan of directory 

protected override void oninitialize () {	if (!monoruntimeinfo.isvalidruntime) return;	foreach (string pcfile in getallpkgconfigfiles ()) {	try {	var pc = new filepath (pcfile).resolvelinks ();	if (!string.isnullorempty (pc)) parsepcfile (pc);	if (shuttingdown) return;	}	catch (exception ex) {	
could not parse file 

else if (targetframework != null) {	targetframework newfx = runtime.systemassemblyservice.gettargetframework (targetframework);	if (newfx == null) inconsistentframeworks = true;	else {	if (newfx.canreferenceassembliestargetingframework (commonframework)) commonframework = newfx;	else if (!commonframework.canreferenceassembliestargetingframework (newfx)) inconsistentframeworks = true;	}	}	if (inconsistentframeworks) break;	}	
inconsistent target frameworks found in 

========================= monodevelop sample_2284 =========================

protected virtual void processmessage (message message) {	switch (message.messagetype) {	case messagetype.sessionconnected: onsessionconnected ();	break;	
unprocessed vstest message message 

========================= monodevelop sample_4419 =========================

public static heapitemset<hi1> performintersection<hi1,hi2> (heapitemset<hi1> firstset, heapitemset<hi2> secondset) where hi1 : iheapitem where hi2 : iheapitem {	list<hi1> result = new list<hi1> ();	int firstindex = 0;	int secondindex = 0;	hi1[] firstobjects = firstset.elements;	hi2[] secondobjects = secondset.elements;	
inside performintersection 

public override void writefullstatistics (textwriter writer, monitoraggregateddatahandler owner, profilereventhandler processor, int depth) {	writeindividualstatistics (writer, owner, processor, depth);	writeindentation (writer, depth + 1);	
statistics by caller 

public override void writefullstatistics (textwriter writer, monitoraggregateddatahandler owner, profilereventhandler processor, int depth) {	writeindividualstatistics (writer, owner, processor, depth);	writeindentation (writer, depth + 1);	writecomponentstatistics (writer, this, componentdatabycaller, processor, depth + 1);	writeindentation (writer, depth + 1);	
statistics by monitor 

========================= monodevelop sample_9921 =========================

protected override void onbuttonpressed (buttoneventargs args) {	
press 

protected override void onbuttonreleased (buttoneventargs args) {	
release 

========================= monodevelop sample_7512 =========================

private void writeheader () {	
produced on for 

irule rule = defect.rule;	begincolor ( (severity.critical == defect.severity || severity.high == defect.severity) ? consolecolor.darkred : consolecolor.darkyellow);	writer.writeline ("{0}. {1}", index, rule.name);	writer.writeline ();	endcolor ();	begincolor (consolecolor.darkred);	writer.write ("problem: ");	endcolor ();	writer.write (rule.problem);	writer.writeline ();	
severity confidence 

irule rule = defect.rule;	begincolor ( (severity.critical == defect.severity || severity.high == defect.severity) ? consolecolor.darkred : consolecolor.darkyellow);	writer.writeline ("{0}. {1}", index, rule.name);	writer.writeline ();	endcolor ();	begincolor (consolecolor.darkred);	writer.write ("problem: ");	endcolor ();	writer.write (rule.problem);	writer.writeline ();	
target 

writer.writeline ("{0}. {1}", index, rule.name);	writer.writeline ();	endcolor ();	begincolor (consolecolor.darkred);	writer.write ("problem: ");	endcolor ();	writer.write (rule.problem);	writer.writeline ();	if (defect.location != defect.target) writer.writeline ("* location: {0}", defect.location);	string source = defect.source;	
source 

writer.writeline ("{0}. {1}", index, rule.name);	writer.writeline ();	endcolor ();	begincolor (consolecolor.darkred);	writer.write ("problem: ");	endcolor ();	writer.write (rule.problem);	writer.writeline ();	if (defect.location != defect.target) writer.writeline ("* location: {0}", defect.location);	string source = defect.source;	
details 

writer.write (rule.problem);	writer.writeline ();	if (defect.location != defect.target) writer.writeline ("* location: {0}", defect.location);	string source = defect.source;	writer.writeline ();	begincolor (consolecolor.darkgreen);	writer.write ("solution: ");	endcolor ();	writer.write (rule.solution);	writer.writeline ();	
more info available at 

========================= monodevelop sample_10642 =========================

case microsoft.codeanalysis.symbolkind.namespace: result = getnamespacemarkup ((inamespacesymbol)entity);	break;	case microsoft.codeanalysis.symbolkind.local: result = getlocalvariablemarkup ((ilocalsymbol)entity);	break;	case microsoft.codeanalysis.symbolkind.parameter: result = getparametervariablemarkup ((iparametersymbol)entity);	break;	default: console.writeline (entity.kind);	return null;	}	} catch (exception e) {	
error while getting markup for 

result.summarymarkup = gettextcatalog.getstring ("the {0} keyword on a method declaration allows for the implementation of a method to be defined in another part of the partial class.", highlight ("partial", getthemecolor (keywordother)));	}	} else result.addcategory (gettextcatalog.getstring ("form"), gettextcatalog.getstring ("[modifiers] {0} type-declaration\n\nor\n\n{0} method-declaration", highlight ("partial", getthemecolor (keywordother))));	break;	case syntaxkind.privatekeyword: result.signaturemarkup = highlight ("private", getthemecolor (modifiercolor)) + keywordsign;	result.summarymarkup = gettextcatalog.getstring ("the {0} keyword is a member access modifier. private access is the least permissive access level. private members are accessible only within the body of the class or the struct in which they are declared.", highlight ("private", getthemecolor (modifiercolor)));	break;	case syntaxkind.protectedkeyword: result.signaturemarkup = highlight ("protected", getthemecolor (modifiercolor)) + keywordsign;	result.summarymarkup = gettextcatalog.getstring ("the {0} keyword is a member access modifier. a protected member is accessible from within the class in which it is declared, and from within any class derived from the class that declared this member.", highlight ("protected", getthemecolor (modifiercolor)));	break;	
modifier color 

static ulong getulong (string str) {	try {	if (str [0] == '-') return (ulong)long.parse (str);	return ulong.parse (str);	} catch (exception e) {	
error while converting to a number 

========================= monodevelop sample_3907 =========================

static void main(string[] args) {	
hello world 

========================= monodevelop sample_232 =========================

string location = null;	version version = null;	version minversion = new version (2, 12, 22);	using (var key = microsoft.win32.registry.localmachine.opensubkey(@"software\xamarin\gtksharp\installfolder")) {	if (key != null) location = key.getvalue (null) as string;	}	using (var key = microsoft.win32.registry.localmachine.opensubkey (@"software\xamarin\gtksharp\version")) {	if (key != null) version.tryparse (key.getvalue (null) as string, out version);	}	if (version == null || version < minversion || location == null || !file.exists (path.combine (location, "bin", "libgtk-win32-2.0-0.dll"))) {	
did not find required gtk installation 

if (key != null) version.tryparse (key.getvalue (null) as string, out version);	}	if (version == null || version < minversion || location == null || !file.exists (path.combine (location, "bin", "libgtk-win32-2.0-0.dll"))) {	string url = "http: string caption = "fatal error";	string message = "{0} did not find the required version of gtk#. please click ok to open the download page, where " + "you can download and install the latest version.";	if (displaywindowsokcancelmessage ( string.format (message, brandingservice.applicationname, url), caption) ) {	process.start (url);	}	return false;	}	
found gtk version 

}	return false;	}	var path = path.combine (location, @"bin");	try {	if (setdlldirectory (path)) {	return true;	}	} catch (entrypointnotfoundexception) {	}	
unable to set gtk dll directory 

static void onextensionchanged (object s, extensionnodeeventargs args) {	if (args.change == extensionchange.add) {	try {	if (typeof(commandhandler).isinstanceoftype (args.extensionobject)) typeof(commandhandler).getmethod ("run", system.reflection.bindingflags.nonpublic|system.reflection.bindingflags.instance, null, type.emptytypes, null).invoke (args.extensionobject, null);	
type must be a subclass of monodevelop components commands commandhandler 

public static monodevelopoptions parse (string[] args) {	var opt = new monodevelopoptions ();	var optset = opt.getoptionset ();	try {	opt.remainingargs = optset.parse (args);	} catch (mono.options.optionexception ex) {	opt.error = ex.tostring ();	}	if (opt.error != null) {	
error 

public static monodevelopoptions parse (string[] args) {	var opt = new monodevelopoptions ();	var optset = opt.getoptionset ();	try {	opt.remainingargs = optset.parse (args);	} catch (mono.options.optionexception ex) {	opt.error = ex.tostring ();	}	if (opt.error != null) {	
pass help for usage information 

var optset = opt.getoptionset ();	try {	opt.remainingargs = optset.parse (args);	} catch (mono.options.optionexception ex) {	opt.error = ex.tostring ();	}	if (opt.error != null) {	}	if (opt.showhelp) {	console.writeline (brandingservice.applicationname + " " + buildinfo.versionlabel);	
options 

opt.error = ex.tostring ();	}	if (opt.error != null) {	}	if (opt.showhelp) {	console.writeline (brandingservice.applicationname + " " + buildinfo.versionlabel);	optset.writeoptiondescriptions (console.out);	const string openfiletext = "      file.ext;line;column";	console.write (openfiletext);	console.write (new string (' ', 29 - openfiletext.length));	
opens a file at specified integer line and column 

========================= monodevelop sample_1641 =========================

public async static task run (monodevelop.ide.gui.document doc) {	var ad = doc.analysisdocument;	if (ad == null) return;	try {	var service = ad.getlanguageservice<iremoveunnecessaryimportsservice> ();	var newdocument = await service.removeunnecessaryimportsasync (ad, default (cancellationtoken));	ad.project.solution.workspace.applydocumentchanges (newdocument, cancellationtoken.none);	} catch (exception e) {	
error while removing unused usings 

public async static task run (monodevelop.ide.gui.document doc) {	var ad = doc.analysisdocument;	if (ad == null) return;	try {	document newdocument = await sortusingsasync (ad, default (cancellationtoken));	ad.project.solution.workspace.applydocumentchanges (newdocument, cancellationtoken.none);	} catch (exception e) {	
error while sorting usings 

public async static task run (monodevelop.ide.gui.document doc) {	var ad = doc.analysisdocument;	if (ad == null) return;	try {	document newdocument = await sortandremoveasync (ad, default (cancellationtoken));	ad.project.solution.workspace.applydocumentchanges (newdocument, cancellationtoken.none);	} catch (exception e) {	
error while removing unused usings 

========================= monodevelop sample_3816 =========================

string value;	if (colorcache.trygetvalue (key, out color)) return true;	if (!settings.trygetvalue (key, out value)) {	color = new hslcolor (0, 0, 0);	return false;	}	try {	color = hslcolor.parse (value);	colorcache = colorcache.setitem (key, color);	} catch (exception e) {	
error while parsing color 

========================= monodevelop sample_1581 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_206 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_164 =========================

string cmd, args;	if (platform.ismac) {	cmd = "umount";	args = string.format ("\"{0}\"", escapeddir);	} else {	cmd = "fusermount";	args = string.format ("-u \"{0}\"", escapeddir);	}	runfusecommand (monitor, cmd, args);	} catch (exception e) {	
could not unmount fuse filesystem 

public abstract void mounttempdirectory (progressmonitor monitor, filecopyconfiguration copyconfig, string temppath);	protected void runfusecommand (progressmonitor monitor, string command, string args) {	
running fuse command 

========================= monodevelop sample_4332 =========================

protected virtual void onunamsactivated(object sender, system.eventargs e) {	
opcionat 

========================= monodevelop sample_135 =========================

p.parse (args);	var asm = typeof(asynctests.httpclienttests.simple).assembly;	if (server) {	server.start (asm, prefix).wait ();	thread.sleep (timeout.infinite);	return;	}	try {	run (asm).wait ();	} catch (exception ex) {	
error 

========================= monodevelop sample_11184 =========================

public void formatbuffer () {	
format buffer 

========================= monodevelop sample_3972 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_111 =========================

public override void visit (membercore member) {	
unknown member 

public override void visit (membercore member) {	
member 

========================= monodevelop sample_3946 =========================

public static async task launchbrowser (string appurl, string launchurl, task processtask) {	launchurl = launchurl ?? "";	uri launchuri;	if (!uri.trycreate (launchurl, urikind.absolute, out launchuri)) {	uri appuri;	if (!uri.trycreate (appurl, urikind.absolute, out appuri)) {	
failed to launch browser because invalid launch and app urls 

public static async task launchbrowser (string appurl, string launchurl, task processtask) {	launchurl = launchurl ?? "";	uri launchuri;	if (!uri.trycreate (launchurl, urikind.absolute, out launchuri)) {	uri appuri;	if (!uri.trycreate (appurl, urikind.absolute, out appuri)) {	return;	}	if (!uri.trycreate (launchurl, urikind.relative, out launchuri)) {	
failed to launch browser because invalid launch url 

using (var tcpclient = new tcpclient ()) {	try {	tcpclient.connect (launchuri.host, launchuri.port);	await task.delay (timespan.fromseconds (1));	break;	} catch {	}	}	}	if (processtask.iscompleted) {	
failed to launch browser because process exited before server started listening 

========================= monodevelop sample_2529 =========================

public void callmethodwithpropertyasargument () {	
hello 

========================= monodevelop sample_6031 =========================

foreach (projectreference lib in items.getall<projectreference> ()) {	foreach (string filename in lib.getreferencedfilenames (configselector)) {	writer.write ("\"-r:");	writer.write (filename);	writer.writeline ("\"");	}	}	foreach (projectfile finfo in items.getall<projectfile> ()) {	if (finfo.subtype != subtype.directory) {	switch (finfo.buildaction) {	
compile finfo name 

break;	case "embeddedresource": string fname = finfo.name;	if (string.compare (path.getextension (fname), ".resx", true) == 0) fname = path.changeextension (fname, ".resources");	writer.writeline("\"-resource:{0},{1}\"", fname, finfo.resourceid);	break;	default: continue;	}	}	}	foreach (import import in items.getall<import> ()) {	
imports 

========================= monodevelop sample_4074 =========================

static void printmethodallocationsperclass (textwriter writer, loadedclass.allocationspermethod allocationspermethod, bool jittime, bool printstacktraces, double stacktracetreshold) {	if (! jittime) {	
bytes instances from 

static void printmethodallocationsperclass (textwriter writer, loadedclass.allocationspermethod allocationspermethod, bool jittime, bool printstacktraces, double stacktracetreshold) {	if (! jittime) {	} else {	
bytes instances at jit time in 

if (! jittime) {	} else {	}	if (printstacktraces) {	loadedclass.allocationsperstacktrace [] stacktraces = allocationspermethod.stacktraces;	array.sort (stacktraces, loadedclass.allocationsperstacktrace.comparebyallocatedbytes);	array.reverse (stacktraces);	double cumulativeallocatedbytesperstacktrace = 0;	foreach (loadedclass.allocationsperstacktrace trace in stacktraces) {	if (cumulativeallocatedbytesperstacktrace / allocationspermethod.allocatedbytes < stacktracetreshold) {	
bytes instances inside 

static void printclassallocationdata (textwriter writer, profilereventhandler data, loadedclass c, ulong totalallocatedbytes) {	double allocatedbytesperclass = (double)c.allocatedbytes;	
bytes 

static void printexecutiontimebycallstack (textwriter writer, profilereventhandler data, stacktrace stackframe, double callerseconds, int indentationlevel) {	for (int i = 0; i < indentationlevel; i++) {	writer.write ("    ");	}	loadedmethod currentmethod = stackframe.topmethod;	double currentseconds = data.clickstoseconds (stackframe.clicks);	
s calls 

istatisticalhititem[] statisticalhititems = data.statisticalhititems;	if ((data.flags & profilerflags.class_events) != 0) {	array.sort (classes, loadedclass.comparebyallocatedbytes);	array.reverse (classes);	ulong totalallocatedbytes = 0;	foreach (loadedclass c in classes) {	totalallocatedbytes += c.allocatedbytes;	}	if (totalallocatedbytes > 0) {	printseparator (writer);	
reporting allocations on classes 

totalallocatedbytes += c.allocatedbytes;	}	if (totalallocatedbytes > 0) {	printseparator (writer);	foreach (loadedclass c in classes) {	if (c.allocatedbytes > 0) {	printclassallocationdata (writer, data, c, totalallocatedbytes);	}	}	} else {	
no allocations reported on classes 

}	if ((data.flags & profilerflags.method_events) != 0) {	array.sort (methods, loadedmethod.comparebytotalclicks);	array.reverse (methods);	ulong totalexecutionclicks = 0;	foreach (loadedmethod m in methods) {	totalexecutionclicks += m.clicks;	}	if (totalexecutionclicks > 0) {	printseparator (writer);	
reporting execution time on methods 

array.sort (methods, loadedmethod.comparebytotalclicks);	array.reverse (methods);	ulong totalexecutionclicks = 0;	foreach (loadedmethod m in methods) {	totalexecutionclicks += m.clicks;	}	if (totalexecutionclicks > 0) {	printseparator (writer);	foreach (loadedmethod m in methods) {	if (m.clicks > 0) {	
s 

}	if (totalexecutionclicks > 0) {	printseparator (writer);	foreach (loadedmethod m in methods) {	if (m.clicks > 0) {	loadedmethod.callspercallermethod[] callspercallermethodarray = m.callers;	if (callspercallermethodarray.length > 0) {	array.sort (callspercallermethodarray, loadedmethod.callspercallermethod.comparebycalls);	array.reverse (callspercallermethodarray);	foreach (loadedmethod.callspercallermethod callspercallermethod in callspercallermethodarray) {	
calls from 

loadedmethod.callspercallermethod[] callspercallermethodarray = m.callers;	if (callspercallermethodarray.length > 0) {	array.sort (callspercallermethodarray, loadedmethod.callspercallermethod.comparebycalls);	array.reverse (callspercallermethodarray);	foreach (loadedmethod.callspercallermethod callspercallermethod in callspercallermethodarray) {	}	}	}	}	printseparator (writer);	
reporting execution time by stack frame 

foreach (loadedmethod.callspercallermethod callspercallermethod in callspercallermethodarray) {	}	}	}	}	printseparator (writer);	foreach (stacktrace rootframe in data.rootframes) {	printexecutiontimebycallstack (writer, data, rootframe, data.clickstoseconds (totalexecutionclicks), 0);	}	} else {	
no execution time reported on methods 

}	if ((data.flags & profilerflags.jit_compilation) != 0) {	array.sort (methods, loadedmethod.comparebyjitclicks);	array.reverse (methods);	ulong totaljitclicks = 0;	foreach (loadedmethod m in methods) {	totaljitclicks += m.jitclicks;	}	if (totaljitclicks > 0) {	printseparator (writer);	
reporting jit time on methods 

array.sort (methods, loadedmethod.comparebyjitclicks);	array.reverse (methods);	ulong totaljitclicks = 0;	foreach (loadedmethod m in methods) {	totaljitclicks += m.jitclicks;	}	if (totaljitclicks > 0) {	printseparator (writer);	foreach (loadedmethod m in methods) {	if (m.jitclicks > 0) {	
ms 

foreach (loadedmethod m in methods) {	totaljitclicks += m.jitclicks;	}	if (totaljitclicks > 0) {	printseparator (writer);	foreach (loadedmethod m in methods) {	if (m.jitclicks > 0) {	}	}	} else {	
no jit time reported on methods 

}	if ((data.flags & profilerflags.statistical) != 0) {	array.sort (statisticalhititems, statisticalhititemcallcounts.comparebystatisticalhits);	array.reverse (statisticalhititems);	ulong totalhits = 0;	foreach (istatisticalhititem s in statisticalhititems) {	totalhits += s.statisticalhits;	}	if (totalhits > 0) {	printseparator (writer);	
reporting statistical hits hits recorded 

if (totalhits > 0) {	printseparator (writer);	foreach (istatisticalhititem s in statisticalhititems) {	if ((s.statisticalhits > 0) || s.hascallcounts) {	writer.writeline ("{0,5:f2}% ({1}) {2}", ((((double)s.statisticalhits) / totalhits) * 100), s.statisticalhits, s.name);	if (s.hascallcounts) {	statisticalhititemcallcounts callcounts = s.callcounts;	if (callcounts.callerscount > 0) {	statisticalhititemcallinformation[] calls = callcounts.callers;	foreach (statisticalhititemcallinformation call in calls) {	
calls from 

if (s.hascallcounts) {	statisticalhititemcallcounts callcounts = s.callcounts;	if (callcounts.callerscount > 0) {	statisticalhititemcallinformation[] calls = callcounts.callers;	foreach (statisticalhititemcallinformation call in calls) {	}	}	if (callcounts.calleescount > 0) {	statisticalhititemcallinformation[] calls = callcounts.callees;	foreach (statisticalhititemcallinformation call in calls) {	
calls to 

}	if (callcounts.calleescount > 0) {	statisticalhititemcallinformation[] calls = callcounts.callees;	foreach (statisticalhititemcallinformation call in calls) {	}	}	}	}	}	} else {	
no statistical hits reported on items 

}	}	}	}	}	} else {	}	}	if (data.globalmonitorstatistics.containsdata) {	printseparator (writer);	
reporting monitor statistics 

int collections = 0;	foreach (profilereventhandler.gcstatistics gcs in gcstatistics) {	if (gcs.newheapsize == null) {	collections ++;	gctime += gcs.duration;	gcmarktime += gcs.markduration;	gcsweeptime += gcs.sweepduration;	}	}	printseparator (writer);	
reporting gc statistics for collections total ms of total time mark sweep 

collections ++;	gctime += gcs.duration;	gcmarktime += gcs.markduration;	gcsweeptime += gcs.sweepduration;	}	}	printseparator (writer);	foreach (profilereventhandler.gcstatistics gcs in gcstatistics) {	if (gcs.newheapsize == null) {	ulong gcstartclicks = gcs.startcounter - data.startcounter;	
collection starting at s generation duration ms mark ms sweep ms 

gctime += gcs.duration;	gcmarktime += gcs.markduration;	gcsweeptime += gcs.sweepduration;	}	}	printseparator (writer);	foreach (profilereventhandler.gcstatistics gcs in gcstatistics) {	if (gcs.newheapsize == null) {	ulong gcstartclicks = gcs.startcounter - data.startcounter;	} else {	
heap resized to bytes 

foreach (profilereventhandler.gcstatistics gcs in gcstatistics) {	if (gcs.newheapsize == null) {	ulong gcstartclicks = gcs.startcounter - data.startcounter;	} else {	}	}	}	allocationsummary [] allocationsummaries = data.allocationsummaries;	if (allocationsummaries.length > 0) {	printseparator (writer);	
reporting allocation summaries for collections 

if (gcs.newheapsize == null) {	ulong gcstartclicks = gcs.startcounter - data.startcounter;	} else {	}	}	}	allocationsummary [] allocationsummaries = data.allocationsummaries;	if (allocationsummaries.length > 0) {	printseparator (writer);	foreach (allocationsummary allocationsummary in allocationsummaries) {	
data for collection written s since the application started 

} else {	}	}	}	allocationsummary [] allocationsummaries = data.allocationsummaries;	if (allocationsummaries.length > 0) {	printseparator (writer);	foreach (allocationsummary allocationsummary in allocationsummaries) {	allocationclassdata<loadedclass>[] classdata = allocationsummary.data;	foreach (allocationclassdata<loadedclass> cdata in classdata) {	
class bytes in instances freed bytes in instances 

printseparator (writer);	foreach (allocationsummary allocationsummary in allocationsummaries) {	allocationclassdata<loadedclass>[] classdata = allocationsummary.data;	foreach (allocationclassdata<loadedclass> cdata in classdata) {	}	}	}	heapsnapshot[] heapsnapshots = data.loadedelements.heapsnapshots;	if (heapsnapshots.length > 0) {	printseparator (writer);	
reporting heap data for collections 

allocationclassdata<loadedclass>[] classdata = allocationsummary.data;	foreach (allocationclassdata<loadedclass> cdata in classdata) {	}	}	}	heapsnapshot[] heapsnapshots = data.loadedelements.heapsnapshots;	if (heapsnapshots.length > 0) {	printseparator (writer);	foreach (heapsnapshot heapsnapshot in heapsnapshots) {	heapsnapshot.allocationstatisticsperclass [] allocationstatistics = heapsnapshot.allocationstatistics;	
heap data collection started at duration ms 

heapsnapshot.allocationstatisticsperclass [] allocationstatistics = heapsnapshot.allocationstatistics;	if (allocationstatistics.length > 0) {	array.sort (allocationstatistics, heapsnapshot.allocationstatisticsperclass.comparebyallocatedbytes);	array.reverse (allocationstatistics);	uint totalallocatedbytes = 0;	foreach (heapsnapshot.allocationstatisticsperclass s in allocationstatistics) {	totalallocatedbytes += s.allocatedbytes;	}	foreach (heapsnapshot.allocationstatisticsperclass s in allocationstatistics) {	if (s.allocatedbytes > 0) {	
bytes freed 

array.reverse (allocationstatistics);	uint totalallocatedbytes = 0;	foreach (heapsnapshot.allocationstatisticsperclass s in allocationstatistics) {	totalallocatedbytes += s.allocatedbytes;	}	foreach (heapsnapshot.allocationstatisticsperclass s in allocationstatistics) {	if (s.allocatedbytes > 0) {	}	}	} else {	
no allocation statistics for this collection 

static void main (string[] argv) {	blockdata.debuglog = console.out;	if (argv.length != 1) {	
please specify one input file 

}	synclogfilereader reader = new synclogfilereader (argv [0]);	profilereventhandler data = new profilereventhandler ();	data.loadedelements.recordheapsnapshots = false;	while (! reader.hasended) {	blockdata currentblock = null;	try {	currentblock = reader.readblock ();	currentblock.decode (data, reader);	} catch (decodingexception e) {	
stopping decoding after a decodingexception in block of code length file offset block offset 

========================= monodevelop sample_9882 =========================

break;	}	string removedtext = b.tostring(offset, removallength);	b.remove(offset, removallength);	string insertedtext = originalxmlfile.gettext(originaloffset, insertionlength);	b.insert(offset, insertedtext);	versionprovider.appendchange(new textchangeeventargs(offset, removedtext, insertedtext));	totalcharacterschanged += insertionlength;	}	}	
incremental parse time for characters changed 

break;	}	string removedtext = b.tostring(offset, removallength);	b.remove(offset, removallength);	string insertedtext = originalxmlfile.gettext(originaloffset, insertionlength);	b.insert(offset, insertedtext);	versionprovider.appendchange(new textchangeeventargs(offset, removedtext, insertedtext));	totalcharacterschanged += insertionlength;	}	}	
non incremental parse time for characters 

========================= monodevelop sample_7990 =========================

} else {	var text = document.editor.text;	var policies = document.project != null ? document.project.policies : policyservice.defaultpolicies;	string formattedtext = formatter.formattext (policies, text);	if (formattedtext != null && formattedtext != text) {	document.editor.replacetext (0, text.length, formattedtext);	}	}	}	} catch (exception e) {	
error while formatting on save 

file.setattributes (filename, fileattributes & ~fileattributes.readonly);	} catch (exception) {	messageservice.showerror (gettextcatalog.getstring ("error"), gettextcatalog.getstring ("operation failed."));	return;	}	} else {	return;	}	}	} catch (exception e) {	
can t get file attributes 

this.document.vstextdocument.encoding = encoding.utf8;	monodevelop.core.text.textfileutility.writetext (filename, document);	}	else {	return;	}	}	try {	if (attributes != null) desktopservice.setfileattributes (filename, attributes);	} catch (exception e) {	
can t set file attributes 

}	else {	return;	}	}	try {	if (attributes != null) desktopservice.setfileattributes (filename, attributes);	} catch (exception e) {	}	} catch (unauthorizedaccessexception e) {	
error while saving file 

========================= monodevelop sample_4518 =========================

public void print (string html) {	if (html == null) {	
empty print 

public void print (string html) {	if (html == null) {	return;	}	
xxxx 

========================= monodevelop sample_9820 =========================

view.getdroptargetrow (e.position.x, e.position.y, out pos, out node);	if (pos == rowdropposition.into) e.allowedaction = dragdropaction.none;	else e.allowedaction = e.action;	};	view.dragstarted += delegate(object sender, dragstartedeventargs e) {	var val = store.getnavigatorat (view.selectedrow).getvalue (text);	e.dragoperation.data.addvalue (val);	var img = image.fromresource(gettype(), "class.png");	e.dragoperation.setdragimage(img, (int)img.size.width, (int)img.size.height);	e.dragoperation.finished += delegate(object s, dragfinishedeventargs args) {	
d 

view.dragstarted += delegate(object sender, dragstartedeventargs e) {	var val = store.getnavigatorat (view.selectedrow).getvalue (text);	e.dragoperation.data.addvalue (val);	var img = image.fromresource(gettype(), "class.png");	e.dragoperation.setdragimage(img, (int)img.size.width, (int)img.size.height);	e.dragoperation.finished += delegate(object s, dragfinishedeventargs args) {	};	};	view.rowexpanding += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	
expanding 

var img = image.fromresource(gettype(), "class.png");	e.dragoperation.setdragimage(img, (int)img.size.width, (int)img.size.height);	e.dragoperation.finished += delegate(object s, dragfinishedeventargs args) {	};	};	view.rowexpanding += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	};	view.rowexpanded += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	
expanded 

};	};	view.rowexpanding += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	};	view.rowexpanded += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	};	view.rowcollapsing += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	
collapsing 

var val = store.getnavigatorat (e.position).getvalue (text);	};	view.rowexpanded += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	};	view.rowcollapsing += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	};	view.rowcollapsed += delegate(object sender, treeviewroweventargs e) {	var val = store.getnavigatorat (e.position).getvalue (text);	
collapsed 

========================= monodevelop sample_7536 =========================

public static ienumerable<int> yieldreturnwithtryfinally() {	yield return 0;	try {	yield return 1;	} finally {	
finally 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	
start of method 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	
start of method 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	
within outer try 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	yield return "within outer try";	
within outer try 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	yield return "within outer try";	try {	
within inner try 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	yield return "within outer try";	try {	yield return "within inner try";	
within inner try 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	yield return "within outer try";	try {	yield return "within inner try";	if (breakinmiddle) yield break;	
end of inner try 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	yield return "within outer try";	try {	yield return "within inner try";	if (breakinmiddle) yield break;	yield return "end of inner try";	
end of inner try 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	yield return "within outer try";	try {	yield return "within inner try";	if (breakinmiddle) yield break;	yield return "end of inner try";	} finally {	
inner finally 

public static ienumerable<string> yieldreturnwithnestedtryfinally(bool breakinmiddle) {	yield return "start of method";	try {	yield return "within outer try";	try {	yield return "within inner try";	if (breakinmiddle) yield break;	yield return "end of inner try";	} finally {	}	
end of outer try 

yield return "start of method";	try {	yield return "within outer try";	try {	yield return "within inner try";	if (breakinmiddle) yield break;	yield return "end of inner try";	} finally {	}	yield return "end of outer try";	
end of outer try 

try {	yield return "within outer try";	try {	yield return "within inner try";	if (breakinmiddle) yield break;	yield return "end of inner try";	} finally {	}	yield return "end of outer try";	} finally {	
outer finally 

yield return "within outer try";	try {	yield return "within inner try";	if (breakinmiddle) yield break;	yield return "end of inner try";	} finally {	}	yield return "end of outer try";	} finally {	}	
end of method 

try {	yield return "within inner try";	if (breakinmiddle) yield break;	yield return "end of inner try";	} finally {	}	yield return "end of outer try";	} finally {	}	yield return "end of method";	
end of method 

public static ienumerable<string> yieldreturnwithtwononnestedfinallyblocks(ienumerable<string> input) {	foreach (string line in input) {	try {	yield return line;	} finally {	
processed 

========================= monodevelop sample_509 =========================

public mainwindow () {	title = "xwt demo application";	width = 500;	height = 400;	try {	statusicon = application.createstatusicon ();	statusicon.menu = new menu ();	statusicon.menu.items.add (new menuitem ("test"));	statusicon.image = image.fromresource (gettype (), "package.png");	} catch {	
status icon could not be shown 

========================= monodevelop sample_7476 =========================

public void testcreateindexer (string input, string output) {	string result = runcontextaction (new createindexeraction (), createmethoddeclarationtests.homogenizeeol (input));	bool passed = result == output;	if (!passed) {	
expected 

public void testcreateindexer (string input, string output) {	string result = runcontextaction (new createindexeraction (), createmethoddeclarationtests.homogenizeeol (input));	bool passed = result == output;	if (!passed) {	console.writeline (output);	
got 

========================= monodevelop sample_8719 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_90 =========================

public override bool execute() {	using (filestream fs = new filestream(this.outputfile, filemode.create, fileaccess.write, fileshare.none)) using (streamwriter sw = new streamwriter(fs, encoding.utf8)) {	
using system 

public override bool execute() {	using (filestream fs = new filestream(this.outputfile, filemode.create, fileaccess.write, fileshare.none)) using (streamwriter sw = new streamwriter(fs, encoding.utf8)) {	sw.writeline();	
namespace core 

public override bool execute() {	using (filestream fs = new filestream(this.outputfile, filemode.create, fileaccess.write, fileshare.none)) using (streamwriter sw = new streamwriter(fs, encoding.utf8)) {	sw.writeline();	sw.writeline("{");	
internal static class uniqueid 

========================= monodevelop sample_9814 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_63 =========================

infact[node] = analysis.newtop();	} else {	infact[node] = analysis.newentry();	}	}	dfs dfs = new dfs(cfg, cfg.entrypoint);	dfs.traverse();	bool changed;	int iteration = 0;	do {	
iteration 

node node = (node)o;	foreach(object pred in cfg.predecessors(node)) analysis.meetinto(infact[node], outfact[pred], false);	object temp = ((icloneable)infact[node]).clone();	analysis.transfer(node, infact[node], temp, false);	if(!temp.equals(outfact[node])) {	changed = true;	outfact[node] = temp;	}	}	} while(changed);	
final iteration 

========================= monodevelop sample_10444 =========================

if (cref == null) return "";	if (cref.length < 2) return cref;	try {	var entity = new icsharpcode.nrefactory.documentation.documentationcomment ("", ctx).resolvecref (cref.replace("<", "{").replace(">", "}"));	if (entity != null) {	var ambience = new icsharpcode.nrefactory.csharp.csharpambience ();	ambience.conversionflags = icsharpcode.nrefactory.typesystem.conversionflags.showparameterlist | icsharpcode.nrefactory.typesystem.conversionflags.showparameternames | icsharpcode.nrefactory.typesystem.conversionflags.showtypeparameterlist;	return ambience.convertsymbol (entity);	}	} catch (exception e) {	
invalid cref 

========================= monodevelop sample_1358 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_32 =========================

public static void dumpfile (string file) {	
file 

========================= monodevelop sample_11588 =========================

public void conditionalcode () {	
writeline 

========================= monodevelop sample_10575 =========================

public void loadproviders () {	string config_dir = environment.getfolderpath (environment.specialfolder.applicationdata);	string monodoc_dir = system.io.path.combine (config_dir, "monodoc");	string settings_file = system.io.path.combine (monodoc_dir, "providers.xml");	xmlserializer ser = new xmlserializer (typeof (providers));	providers p;	if (file.exists (settings_file)) p = (providers) ser.deserialize (new xmltextreader (settings_file));	else {	
file does not exist 

public void loadproviders () {	string config_dir = environment.getfolderpath (environment.specialfolder.applicationdata);	string monodoc_dir = system.io.path.combine (config_dir, "monodoc");	string settings_file = system.io.path.combine (monodoc_dir, "providers.xml");	xmlserializer ser = new xmlserializer (typeof (providers));	providers p;	if (file.exists (settings_file)) p = (providers) ser.deserialize (new xmltextreader (settings_file));	else {	
format is 

========================= monodevelop sample_9834 =========================

static void header () {	assembly a = assembly.getexecutingassembly ();	version v = a.getname ().version;	if (v.tostring () != "0.0.0.0") {	
v 

static void header () {	assembly a = assembly.getexecutingassembly ();	version v = a.getname ().version;	if (v.tostring () != "0.0.0.0") {	} else {	
development snapshot 

static void help () {	
usage defects xml list ignore extra defects warnings syntax check quiet version help 

static void help () {	
where 

static void help () {	
defects xml the list of defects xml produced by gendarme on your project 

static void help () {	
list ignore the file listing ignored defects entries for your project 

static void help () {	
extra check optional report ignore entries not in the defect list 

static void help () {	
syntax check optional report syntax error found in list ignore file 

static void help () {	
quiet optional minimize output tro stdout 

static void help () {	
version display the tool s version number 

static void help () {	
help show help about the command line options 

========================= monodevelop sample_9974 =========================

beginoperation ();	var res = await sendrun (configurations, loggerid, logger.enabledevents, verbosity, runtargets, evaluateitems, evaluateproperties, globalproperties, taskid).configureawait (false);	if (res == null && cancellationtoken.iscancellationrequested) {	msbuildtargetresult err = new msbuildtargetresult (file, false, "", "", file, 1, 1, 1, 1, "build cancelled", "");	return new msbuildresult (new [] { err });	}	if (res == null) throw new exception ("unknown failure");	return res;	} catch (exception ex) {	await checkdisconnected ().configureawait (false);	
runtarget failed 

public async task refresh () {	try {	beginoperation ();	await sendrefresh ().configureawait (false);	} catch (exception ex) {	
msbuild refresh failed 

public async task refreshwithcontent (string projectcontent) {	try {	beginoperation ();	await sendrefreshwithcontent (projectcontent).configureawait (false);	} catch (exception ex) {	
msbuild refresh failed 

========================= monodevelop sample_2222 =========================

public void testmethodinframeworkclass () {	testwrongcontext<createmethoddeclarationaction> ( {	void testmethod () {	
think it 

========================= monodevelop sample_8679 =========================

var token = tooltipcancelsrc.token;	task.run (delegate {	var list = getreferences (result, token).tolist ();	if (!token.iscancellationrequested) {	gtk.application.invoke (delegate {	if (!token.iscancellationrequested) showreferences (list);	});	}	});	} catch (exception e) {	
unhandled exception in highlightingusagesextension 

========================= monodevelop sample_4538 =========================

notrun = xwt.drawing.image.fromresource ("unit-skipped-16.png");	success = xwt.drawing.image.fromresource ("unit-success-16.png");	successandfailure = xwt.drawing.image.fromresource ("unit-mixed-results-16.png");	loading = xwt.drawing.image.fromresource ("unit-loading-16.png");	inconclusive = xwt.drawing.image.fromresource ("unit-inconclusive-16.png");	oldfailure = failure.withalpha (0.4);	oldsuccess = success.withalpha (0.4);	oldsuccessandfailure = successandfailure.withalpha (0.4);	oldinconclusive = inconclusive.withalpha (0.4);	} catch (exception e) {	
error while loading icons 

========================= monodevelop sample_4429 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_193 =========================

info.clear ();	foreach (var item in menu.items) {	additem (info, item);	}	if (menu.items.count == 0) {	info.add (new commandinfo (gettextcatalog.getstring ("no code fixes available"), false, false), null);	}	info.notifychanged ();	} catch (operationcanceledexception) {	} catch (exception e) {	
error while creating quick fix menu 

========================= monodevelop sample_4054 =========================

if (wrapper == null) throw new argumentexception (string.format ("no wrapper type for class {0}", wrapped.fullname));	}	gtype = (glib.gtype)wrapped;	cname = gtype.tostring ();	string iconname = elem.getattribute ("icon");	if (iconname.length > 0) {	try {	gdk.pixbufloader loader = new gdk.pixbufloader (assembly, iconname);	icon = loader.pixbuf;	} catch {	
could not load icon 

========================= monodevelop sample_3665 =========================

public void instrumentpackageaction (ipackageaction action) {	try {	var provider = action as inugetprojectactionsprovider;	if (provider != null) {	instrumentpackageactions (provider.getnugetprojectactions ());	}	} catch (exception ex) {	
instrumentation failure in packagemanagement 

========================= monodevelop sample_2828 =========================

protected async override task onexecute (progressmonitor monitor, executioncontext context, configurationselector configuration, solutionitemrunconfiguration runconfiguration) {	projectconfiguration conf = (projectconfiguration) getconfiguration (configuration);	
running 

try {	executioncommand executioncommand = createexecutioncommand (configuration, conf);	if (!context.executionhandler.canexecute (executioncommand)) {	monitor.reporterror (gettextcatalog.getstring ("can not execute \"{0}\". the selected execution mode is not supported for .net projects.", filename), null);	return;	}	processasyncoperation asyncop = context.executionhandler.execute (executioncommand, console);	var stopper = monitor.cancellationtoken.register (asyncop.cancel);	await asyncop.task;	stopper.dispose ();	
the application exited with code 

return;	}	processasyncoperation asyncop = context.executionhandler.execute (executioncommand, console);	var stopper = monitor.cancellationtoken.register (asyncop.cancel);	await asyncop.task;	stopper.dispose ();	} finally {	console.dispose ();	}	} catch (exception ex) {	
cannot execute 

========================= monodevelop sample_1890 =========================

var solutionmanager = getsolutionmanager (dotnetproject);	var nugetproject = createnugetproject (solutionmanager, dotnetproject);	var pathresolver = createpathresolver (solutionmanager);	var packagesbeinginstalled = getpackagesbeinginstalled (dotnetproject).tolist ();	var packages = await task.run (() => nugetproject.getinstalledpackagesasync (cancellationtoken.none)).configureawait (false);	var packagereferences = packages .select (package => createpackagereference (package.packageidentity, nugetproject, pathresolver)) .tolist ();	packagereferences.addrange (getmissingpackagesbeinginstalled (packagereferences, packagesbeinginstalled));	return packagereferences;	}).result;	} catch (exception ex) {	
getinstalledpackages error 

========================= monodevelop sample_2939 =========================

public bool trygetdocumentoption (document document, optionkey option, optionset underlyingoptions, out object value) {	if (codingconventionssnapshot != null) {	var editorconfigpersistence = option.option.storagelocations.oftype<ieditorconfigstoragelocation> ().singleordefault ();	if (editorconfigpersistence != null) {	var allrawconventions = codingconventionssnapshot.allrawconventions;	try {	var underlyingoption = underlyingoptions.getoption (option);	if (editorconfigpersistence.trygetoption (underlyingoption, allrawconventions, option.option.type, out value)) return true;	} catch (exception ex) {	
error while getting editor config preferences 

========================= monodevelop sample_3952 =========================

break;	case loglevel.warn: header = "warning";	break;	case loglevel.info: header = "info";	break;	case loglevel.debug: header = "debug";	break;	default: header = "log";	break;	}	
u 

========================= monodevelop sample_1857 =========================

byte [] bytes;	using (var sr = textfileutility.openstream (stream)) {	bytes = system.text.encoding.utf8.getbytes (sr.readtoend ());	}	var reader = system.runtime.serialization.json.jsonreaderwriterfactory.createjsonreader (bytes, new system.xml.xmldictionaryreaderquotas ());	var root = xelement.load (reader);	result.name = root.xpathselectelement ("name").value;	if (result.name != "") result.copyvalues (loadfrom (assembly.getcallingassembly ().getmanifestresourcestream ("fallbackstyle.json")));	var version = version.parse (root.xpathselectelement ("version").value);	if (version.major != 1) {	
can t load scheme unsupported version 

if (el != null) result.basescheme = el.value;	var palette = new dictionary<string, hslcolor> ();	foreach (var color in root.xpathselectelements ("palette/*")) {	var name = color.xpathselectelement ("name").value;	if (palette.containskey (name)) throw new invaliddataexception ("duplicate palette color definition for: " + name);	palette.add ( name, parsecolor (color.xpathselectelement ("value").value) );	}	foreach (var colorelement in root.xpathselectelements (" var color = ambientcolor.create (colorelement, palette);	propertydescription info;	if (!ambientcolors.trygetvalue (color.name, out info)) {	
ambient color not found 

var result = new colorscheme ();	result.name = path.getfilenamewithoutextension (filename);	result.description = "imported color scheme";	result.originator = "imported from " + filename;	var colors = new dictionary<string, vssettingcolor> ();	using (var reader = xmlreader.create (stream)) {	while (reader.read ()) {	if (reader.localname == "item") {	var color = vssettingcolor.create (reader);	if (colors.containskey (color.name)) {	
warning is defined twice in vssettings 

found = true;	continue;	}*/ var textcolor = importchunkstyle (color.value.attribute.name, vsc);	if (textcolor != null) {	color.value.info.setvalue (result, textcolor, null);	found = true;	}	}	}	}	
not imported 

========================= monodevelop sample_1614 =========================

formatter.ontheflyformat (doc.editor, doc, selection);	} else {	var pol = doc.project != null ? doc.project.policies : null;	try {	var editortext = editor.text;	string text = formatter.formattext (pol, editortext, selection);	if (text != null && editortext.substring (selection.offset, selection.length) != text) {	editor.replacetext (selection.offset, selection.length, text);	}	} catch (exception e) {	
error during format 

========================= monodevelop sample_1806 =========================

public void log (functionid functionid, logmessage logmessage) {	
roslyn error 

public void logblockend (functionid functionid, logmessage logmessage, int uniquepairid, int delta, cancellationtoken cancellationtoken) {	
roslyn error 

public void logblockstart (functionid functionid, logmessage logmessage, int uniquepairid, cancellationtoken cancellationtoken) {	
roslyn error 

========================= monodevelop sample_1645 =========================

corevaluationcontext cctx = (corevaluationcontext) ctx;	type t;	if (metadatahelperfunctionsextensions.coretypes.trygetvalue (type.type, out t)) return t.fullname;	try {	if (type.type == corelementtype.element_type_array || type.type == corelementtype.element_type_szarray) return gettypename (ctx, type.firsttypeparameter) + "[" + new string (',', type.rank - 1) + "]";	if (type.type == corelementtype.element_type_byref) return gettypename (ctx, type.firsttypeparameter) + "&";	if (type.type == corelementtype.element_type_ptr) return gettypename (ctx, type.firsttypeparameter) + "*";	return type.gettypeinfo (cctx.session).fullname;	}	catch (exception ex) {	
exception in gettypename 

mems.addrange (t.getproperties (bindingflags.public | bindingflags.nonpublic | bindingflags.static | bindingflags.instance));	foreach (memberinfo m in mems) {	object[] atts = m.getcustomattributes (typeof (debuggerbrowsableattribute), false);	if (atts.length > 0) {	hastypedata = true;	if (memberdata == null) memberdata = new dictionary<string, debuggerbrowsablestate> ();	memberdata[m.name] = ((debuggerbrowsableattribute)atts[0]).state;	}	}	} catch (exception ex) {	
exception in ongettypedisplaydata 

========================= monodevelop sample_6207 =========================

xmldocument doc = null;	try {	doc = new xmldocument ();	doc.loadxml (xml);	} catch (xmlexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	error = true;	}	if (error) {	
validation failed 

doc = new xmldocument ();	doc.loadxml (xml);	} catch (xmlexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	error = true;	}	if (error) {	taskservice.showerrors ();	} else {	
xml is valid 

catch (xmlexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	error = true;	}	finally {	if (stringreader != null) stringreader.dispose ();	settings.validationeventhandler -= validationhandler;	}	if (error) {	
validation failed 

addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	error = true;	}	finally {	if (stringreader != null) stringreader.dispose ();	settings.validationeventhandler -= validationhandler;	}	if (error) {	taskservice.showerrors ();	} else {	
xml is valid 

monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	error = true;	}	catch (xmlexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	error = true;	}	if (error) {	
validation failed 

error = true;	}	catch (xmlexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	error = true;	}	if (error) {	taskservice.showerrors ();	} else {	
schema is valid 

}	catch (xsltexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	}	catch (xmlexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	}	if (error) {	
validation failed 

monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	}	catch (xmlexception ex) {	monitor.reporterror (ex.message, ex);	addtask (filename, ex.message, ex.lineposition, ex.linenumber, taskseverity.error, workspaceobject);	}	if (error) {	taskservice.showerrors ();	} else {	
stylesheet is valid 

========================= monodevelop sample_3533 =========================

public preferences (nscoder coder) : base (coder) {	
preferences ctor 

========================= monodevelop sample_11157 =========================

public static editortheme geteditortheme (string name) {	foreach (var bundle in languagebundles) {	for (int i = 0; i < bundle.editorthemes.count; ++i) {	var style = bundle.editorthemes[i];	if (style.name == name) return style;	}	}	
color style not found switching to default 

}	}	} else if (file.endswith (".tmtheme", stringcomparison.ordinalignorecase)) {	using (var stream = openstream ()) {	string stylename = scantextmatestyle (stream);	if (!string.isnullorempty (stylename)) {	var theme = textmateformat.loadeditortheme (getstreamprovider ().open ());	if (theme != null) bundle.add (theme);	return theme;	} else {	
invalid tmtheme theme file 

}	}	} else if (file.endswith (".vssettings", stringcomparison.ordinalignorecase)) {	using (var stream = openstream ()) {	string stylename = path.getfilenamewithoutextension (file);	editortheme theme;	try {	theme = oldformat.importvssetting (stylename, getstreamprovider ().open ());	} catch (styleimportexception e) {	switch (e.reason) {	
unknown error in theme file 

}	} else if (file.endswith (".vssettings", stringcomparison.ordinalignorecase)) {	using (var stream = openstream ()) {	string stylename = path.getfilenamewithoutextension (file);	editortheme theme;	try {	theme = oldformat.importvssetting (stylename, getstreamprovider ().open ());	} catch (styleimportexception e) {	switch (e.reason) {	break;	
no colors defined in vssettings 

editortheme theme;	try {	theme = oldformat.importvssetting (stylename, getstreamprovider ().open ());	} catch (styleimportexception e) {	switch (e.reason) {	break;	break;	}	return null;	} catch (exception e) {	
invalid theme 

stream.read (data, 0, (int)entry.size);	loadfile (newbundle, entry.name, () => new memorystream (data), () => new memorystreamprovider (data, entry.name));	}	}	entry = stream.getnextentry ();	}	languagebundles.add (newbundle);	return newbundle;	}	} catch (exception e) {	
error while reading 

if (match.success) {	if (jsonversionregex.match (versionline).success) {	name = match.groups [1].value;	format = jsonformat.oldsyntaxtheme;	return true;	}	}	format = jsonformat.textmatejsonsyntax;	return true;	} catch (exception e) {	
error while scanning json 

var line = file.readline ();	if (line == null) return "";	if (line.contains (keystring)) break;	}	var nameline = file.readline ();	file.close ();	var match = textmatenameregex.match (nameline);	if (!match.success) return null;	return match.groups[1].value;	} catch (exception e) {	
error while scanning json 

static syntaxhighlightingservice () {	languagebundles.add (builtinbundle);	loadstylesandmodes (typeof (syntaxhighlightingservice).assembly);	var texteditorassembly = appdomain.currentdomain.getassemblies ().firstordefault (a => a.getname ().name.startswith ("monodevelop.sourceeditor", stringcomparison.ordinal));	if (texteditorassembly != null) {	loadstylesandmodes (texteditorassembly);	} else {	
can t lookup mono texteditor assembly default styles won t be loaded 

if (texteditorassembly != null) {	loadstylesandmodes (texteditorassembly);	} else {	}	bool success = true;	if (!directory.exists (languagebundlepath)) {	try {	directory.createdirectory (languagebundlepath);	} catch (exception e) {	success = false;	
can t create syntax mode directory 

var codon = (templatecodon)args.extensionnode;	if (args.change == extensionchange.add) {	try {	var o = loadfile (builtinbundle, codon.name, () => codon.open (), () => codon);	if (o is syntaxhighlightingdefinition) ((syntaxhighlightingdefinition)o).preparematches ();	var bundle = o as languagebundle;	if (bundle != null) {	foreach (var h in bundle.highlightings) h.preparematches ();	}	} catch (exception e) {	
error while loading custom editor extension file 

========================= monodevelop sample_1576 =========================

} else if (evnt.type == gdk.eventtype.twobuttonpress) {	var cursorpos = buffer.getiteratoffset (buffer.cursorposition);	textiter iterstart;	textiter iterend;	string linetext;	try {	iterstart = buffer.getiteratline (cursorpos.line);	iterend = buffer.getiteratoffset (iterstart.offset + iterstart.charsinline);	linetext = buffer.gettext (iterstart, iterend, true);	} catch (exception e) {	
error in getting text of the current line 

public texttag indent () {	texttag tag;	indent++;	if (indent >= tags.count) {	tag = new texttag ($"{trackerid}-{indent}");	
tag name 

========================= monodevelop sample_1566 =========================

if (!directory.exists(userschemafolder)) {	directory.createdirectory (userschemafolder);	}	string filename = path.getfilename (schemadata.filename);	string destinationfilename = path.combine (userschemafolder, filename);	file.copy (schemadata.filename, destinationfilename);	schemadata.filename = destinationfilename;	userschemas.add (schemadata);	onuserschemaadded ();	} else {	
xmlschemamanager cannot register two schemas with the same namespace 

static void loadschemas (list<xmlschemacompletiondata> list, string folder, bool readonly) {	
reading schemas from 

static void loadschemas (list<xmlschemacompletiondata> list, string folder, bool readonly) {	if (directory.exists(folder)) {	int count = 0;	foreach (string filename in directory.getfiles(folder, "*.xsd")) {	loadschema (list, filename, readonly);	++count;	}	
xmlschemamanager found schemas 

static void loadschema (list<xmlschemacompletiondata> list, string filename, bool readonly) {	try {	string baseuri = xmlschemacompletiondata.geturi (filename);	xmlschemacompletiondata data = new xmlschemacompletiondata (baseuri, filename);	if (data.namespaceuri == null) {	
xmlschemamanager is ignoring schema with no namespace from file 

static void loadschema (list<xmlschemacompletiondata> list, string filename, bool readonly) {	try {	string baseuri = xmlschemacompletiondata.geturi (filename);	xmlschemacompletiondata data = new xmlschemacompletiondata (baseuri, filename);	if (data.namespaceuri == null) {	return;	}	foreach (xmlschemacompletiondata d in list) {	if (d.namespaceuri == data.namespaceuri) {	
xmlschemamanager is ignoring schema with duplicate namespace 

return;	}	foreach (xmlschemacompletiondata d in list) {	if (d.namespaceuri == data.namespaceuri) {	return;	}	}	data.readonly = readonly;	list.add (data);	} catch (exception ex) {	
xmlschemamanager is unable to read schema because of the following error 

static xmlschemacompletiondata readlocalschema (uri uri) {	try {	return new xmlschemacompletiondata (uri.tostring (), uri.localpath);	} catch (exception ex) {	
xmlschemamanager is unable to read schema because of the following error 

========================= monodevelop sample_3523 =========================

public void checkwegotdefaultloggers () {	
consolelogger 

public void checkwegotdefaultloggers () {	
instrumentation logger 

========================= monodevelop sample_395 =========================

objectadapter.busystatechanged += (sender, e) => setbusystate (e);	var cancellationtoken = helperoperationscancellationtokensource.token;	new thread (() => {	try {	while (!cancellationtoken.iscancellationrequested) {	var action = helperoperationsqueue.take(cancellationtoken);	try {	action ();	}	catch (exception e) {	
exception on processing helper thread action 

var action = helperoperationsqueue.take(cancellationtoken);	try {	action ();	}	catch (exception e) {	}	}	}	catch (exception e) {	if (e is operationcanceledexception || e is objectdisposedexception) {	
helper thread was gracefully interrupted 

action ();	}	catch (exception e) {	}	}	}	catch (exception e) {	if (e is operationcanceledexception || e is objectdisposedexception) {	}	else {	
unhandled exception in helper thread helper thread is terminated 

private void onappdomainexit (object sender, corappdomaineventargs e) {	var appdomainid = e.appdomain.id;	lock (appdomainslock) {	if (!appdomains.remove (appdomainid)) {	
failed to unload app domain id because it s not found in map possibly already unloaded 

case hresult.cordbg_e_process_terminated: binfo.setstatus (breakeventstatus.binderror, "process terminated");	break;	case hresult.cordbg_e_code_not_available: binfo.setstatus (breakeventstatus.binderror, "module is not loaded");	break;	default: binfo.setstatus (breakeventstatus.binderror, e.message);	break;	}	}	else {	binfo.setstatus (breakeventstatus.binderror, e.message);	
unknown exception when setting breakpoint 

========================= monodevelop sample_6217 =========================

static list<commenttag> createcommenttags (string tagliststring) {	var list = new list<commenttag> ();	if (string.isnullorempty (tagliststring)) return list;	string[] tags = tagliststring.split (';');	for (int n=0; n<tags.length; n++) {	string[] split = tags [n].split (':');	int priority;	if (split.length == 2 && int.tryparse (split [1], out priority)) list.add (new commenttag (split [0], priority));	
invalid tag list in commenttagset 

========================= monodevelop sample_1816 =========================

zs.putnextentry (infoentry);	using (stream s = file.openread (f)) {	int nr;	while ((nr = s.read (buffer, 0, buffer.length)) > 0) zs.write (buffer, 0, nr);	}	zs.closeentry ();	}	zs.finish ();	zs.close ();	break;	
unsupported file format 

========================= monodevelop sample_4326 =========================

var monoproject = ((monodevelopworkspace)workspace).getmonoproject (documentid.projectid);	if (!packageservices.ispackageinstalled (monoproject, packagename)) {	if (versionopt == null) {	packageservices.installlatestpackage ( source, monoproject, packagename, includeprerelease, ignoredependencies: false);	} else {	packageservices.installpackage ( source, monoproject, packagename, versionopt, ignoredependencies: false);	}	return true;	}	} catch (exception e) {	
error while installing nuget package 

========================= monodevelop sample_3985 =========================

public override string getindentationstring (int linenumber) {	var line = data.getline (linenumber);	if (line == null) return "";	var offset = line.offset;	string curindent = line.getindentation (data);	try {	statetracker.update (data, math.min (data.length, offset + line.length));	int nlwsp = curindent.length;	if (!statetracker.linebeganinsidemultilinecomment || (nlwsp < line.lengthincludingdelimiter && data.getcharat (offset + nlwsp) == '*')) return statetracker.thislineindent;	} catch (exception e) {	
error while indenting at line 

========================= monodevelop sample_3976 =========================

public static void loadcustomstylesandmodes () {	bool success = true;	if (!directory.exists (syntaxmodepath)) {	try {	directory.createdirectory (syntaxmodepath);	} catch (exception e) {	success = false;	
can t create syntax mode directory 

========================= monodevelop sample_1721 =========================

weakreference reference;	if (object_map.trygetvalue (ptr, out reference)) {	nsobject target = (nsobject) reference.target;	if (target != null) return target;	}	}	type = class.lookup (messaging.intptr_objc_msgsend (ptr, selclass));	if (type != null) {	return (nsobject) activator.createinstance (type, new object[] { ptr });	} else {	
warning cannot find type for using nsobject 

========================= monodevelop sample_11240 =========================

static void main (string[] args) {	
hello world 

========================= monodevelop sample_183 =========================

public static void main(string[] args) {	
hello world 

========================= monodevelop sample_212 =========================

static object checkinstalled () {	try {	return new svnclient ();	} catch (exception ex) {	
svn client could not be initialized 

if (data.remainder >= 1024) {	data.savedprogress += data.remainder / 1024;	data.remainder = data.remainder % 1024;	}	data.kbytes = data.savedprogress + currentprogress / 1024;	if (data.logtimer.enabled) return;	data.logtimer.interval = 1000;	data.logtimer.elapsed += delegate {	data.seconds += 1;	runtime.runinmainthread (() => {	
transferred in seconds 

========================= monodevelop sample_4104 =========================

static void shutdown () {	var helper = new invokerhelper {	func = () => {	try {	if (beforeshutdown != null) beforeshutdown (null, eventargs.empty);	} catch (exception ex) {	
unexpected error during beforeshutdown 

public static void writeruntimeenvironment(textwriter writer) {	string clrplatform = type.gettype("mono.runtime", false) == null ? ".net" : "mono";	
runtime environment 

public static void writeruntimeenvironment(textwriter writer) {	string clrplatform = type.gettype("mono.runtime", false) == null ? ".net" : "mono";	
os version 

public static void writeruntimeenvironment(textwriter writer) {	string clrplatform = type.gettype("mono.runtime", false) == null ? ".net" : "mono";	
version 

private void runtests(itestfilter filter) {	itestresult result = runner.run(this, filter);	exitcode = result.failcount > 0 ? 1 : 0;	new resultreporter(result, writer).reportresults();	if (commandlineoptions.resultfile != null) {	new nunit2xmloutputwriter().writeresultfile (result, commandlineoptions.resultfile);	console.writeline();	
results saved as 

textwriter textwriter = listfile != null && listfile.length > 0 ? new streamwriter(listfile) : console.out;	#if clr_2_0 || clr_4_0 system.xml.xmlwritersettings settings = new system.xml.xmlwritersettings();	settings.indent = true;	settings.encoding = system.text.encoding.utf8;	system.xml.xmlwriter testwriter = system.xml.xmlwriter.create(textwriter, settings);	#else system.xml.xmltextwriter testwriter = new system.xml.xmltextwriter(textwriter);	testwriter.formatting = system.xml.formatting.indented;	#endif testnode.writeto(testwriter);	testwriter.close();	console.writeline();	
test info saved as 

========================= monodevelop sample_5466 =========================

}	else {	razoreditortrace.traceline(razorresources.trace_nochangesarrived, filenameonly, parcel.changes.count);	thread.yield();	}	}	}	catch (operationcanceledexception) {	}	catch (exception ex) {	
internal error in razor parser 

========================= monodevelop sample_4858 =========================

public void printbannerusingparameter (version version) {	
welcome to the foo program 

public void printbannerusingassembly (version version) {	
welcome to the foo program 

public void printbannerwithoutparameters () {	
welcome to the foo program 

public void methodwithunusedparameters (ienumerable enumerable, int x) {	
method with unused parameters 

public void buttonclick_noparameterunused (object o, eventargs e) {	
uho 

public void conditionalcode () {	
writeline 

========================= monodevelop sample_10551 =========================

static string convertfromencoding (byte[] content, long nread, string fromencoding) {	try {	return encoding.utf8.getstring (converttobytes (content, nread, "utf-8", fromencoding));	} catch (exception e) {	
fail to use encoding 

========================= monodevelop sample_2164 =========================

if (!opcodebitmask.calls.intersect (opcodeengine.getbitmask (method))) return ruleresult.doesnotapply;	log.writeline (this);	log.writeline (this, "---------------------------------------");	log.writeline (this, method);	foreach (instruction ins in method.body.instructions) {	switch (ins.opcode.code) {	case code.call: case code.callvirt: methodreference callee = (ins.operand as methodreference).resolve();	if (callee != null) {	if (callee.metadatatoken == method.metadatatoken) {	if (callee.tostring () == method.tostring ()) {	
recursive call at 

========================= monodevelop sample_10440 =========================

captureview.willdisplayimage = (view, image) => {	if (videopreviewfilterdescription == null) return image;	var selectedfilter = (nsstring) videopreviewfilterdescription [filternamekey];	var filter = cifilter.fromname (selectedfilter);	filter.setdefaults ();	filter.setvalueforkey (image, cifilterinputkey.image);	return (ciimage) filter.valueforkey (cifilteroutputkey.image);	};	moviefileoutput = new qtcapturemoviefileoutput ();	moviefileoutput.willstartrecording += delegate {	
will start recording 

var selectedfilter = (nsstring) videopreviewfilterdescription [filternamekey];	var filter = cifilter.fromname (selectedfilter);	filter.setdefaults ();	filter.setvalueforkey (image, cifilterinputkey.image);	return (ciimage) filter.valueforkey (cifilteroutputkey.image);	};	moviefileoutput = new qtcapturemoviefileoutput ();	moviefileoutput.willstartrecording += delegate {	};	moviefileoutput.didstartrecording += delegate {	
started recording 

moviefileoutput = new qtcapturemoviefileoutput ();	moviefileoutput.willstartrecording += delegate {	};	moviefileoutput.didstartrecording += delegate {	};	moviefileoutput.shouldchangeoutputfile = (output, url, connections, reason) => {	console.writeline (reason.localizeddescription);	return false;	};	moviefileoutput.mustchangeoutputfile += delegate(object sender, qtcapturefileerroreventargs e) {	
must change file due to error 

};	moviefileoutput.didstartrecording += delegate {	};	moviefileoutput.shouldchangeoutputfile = (output, url, connections, reason) => {	console.writeline (reason.localizeddescription);	return false;	};	moviefileoutput.mustchangeoutputfile += delegate(object sender, qtcapturefileerroreventargs e) {	};	moviefileoutput.willfinishrecording += delegate(object sender, qtcapturefileerroreventargs e) {	
will finish recording 

return false;	};	moviefileoutput.mustchangeoutputfile += delegate(object sender, qtcapturefileerroreventargs e) {	};	moviefileoutput.willfinishrecording += delegate(object sender, qtcapturefileerroreventargs e) {	invokeonmainthread (delegate {	willchangevalue ("recording");	});	};	moviefileoutput.didfinishrecording += delegate(object sender, qtcapturefileerroreventargs e) {	
recorded bytes duration 

========================= monodevelop sample_10747 =========================

public void test( [values("a", "b", "c")] string a, [values("+", "-")] string b, [values("x", "y")] string c) {	
pairwise 

========================= monodevelop sample_5891 =========================

public void testfieldaccess() {	
using system class class int bar void foo console writeline bar 

public void testpropertyaccess() {	
using system class class int bar get set void foo console writeline bar 

public void teststringformatiteminverbatimstringcolor() {	
using system class myclass public static void main console writeline 

========================= monodevelop sample_8669 =========================

public void testsimplecase() {	
class test public shared sub main args as system collections generic idictionary of integer integer console writeline args end sub end class class test public shared sub main args as system collections generic idictionary of integer integer dim val as integer if args trygetvalue val then console writeline val end if end sub end class 

public void testnestedcase1() {	
class test public shared sub main args as system collections generic idictionary of integer integer if true then if true then console writeline args end if end if end sub end class class test public shared sub main args as system collections generic idictionary of integer integer if true then if true then dim val as integer if args trygetvalue val then console writeline val end if end if end if end sub end class 

public void testnestedcase2() {	
class test public shared sub main args as system collections generic idictionary of integer integer dim val as integer if args trygetvalue val then console writeline val end if end sub end class 

public void testnameclash() {	
class test private shared val as integer public shared sub main args as system collections generic idictionary of integer integer console writeline args end sub end class class test private shared val as integer public shared sub main args as system collections generic idictionary of integer integer dim as integer if args trygetvalue then console writeline end if end sub end class 

========================= monodevelop sample_6788 =========================

public static xmlnode getnodefromurl (string url, roottree tree) {	
url is 

public static xmlnode getnodefromurl (string url, roottree tree) {	string [] usplit = parseediturl (url);	
results are 

public void save () {	settingshandler.ensuresettingsdirectory ();	try {	if (file.exists(changeset_file)) file.copy (changeset_file, changeset_backup_file, true);	using (filestream fs = file.create (changeset_file)){	serializer.serialize (fs, this);	}	} catch (exception e) {	
error while saving changes 

public void merge () {	foreach (docsetchangeset dsc in changeset.docsetchangesets) {	bool merged = false;	foreach (string path in targetdirs) {	if (file.exists (path.combine (path, dsc.docset + ".source"))) {	merge (dsc, path);	merged = true;	break;	}	}	
could not merge docset 

========================= monodevelop sample_9824 =========================

static void printoptionkey (optionkey optionkey) {	
name optionkey option name language optionkey language languagespecific optionkey option isperlanguage 

static void printoptionkey (optionkey optionkey) {	var locations = optionkey.option.storagelocations;	if(locations.isdefault) {	return;	}	foreach (var loc in locations) {	switch (loc) {	
roaming roaming getkeynameforlanguage optionkey language 

static void printoptionkey (optionkey optionkey) {	var locations = optionkey.option.storagelocations;	if(locations.isdefault) {	return;	}	foreach (var loc in locations) {	switch (loc) {	break;	
local local keyname 

static void printoptionkey (optionkey optionkey) {	var locations = optionkey.option.storagelocations;	if(locations.isdefault) {	return;	}	foreach (var loc in locations) {	switch (loc) {	break;	break;	
editorconfig edconf keyname 

static void printoptionkey (optionkey optionkey) {	var locations = optionkey.option.storagelocations;	if(locations.isdefault) {	return;	}	foreach (var loc in locations) {	switch (loc) {	break;	break;	break;	
editorconfig edconf keyname 

var locations = optionkey.option.storagelocations;	if(locations.isdefault) {	return;	}	foreach (var loc in locations) {	switch (loc) {	break;	break;	break;	break;	
editorconfig edconf keyname 

if(locations.isdefault) {	return;	}	foreach (var loc in locations) {	switch (loc) {	break;	break;	break;	break;	break;	
editorconfig edconf keyname 

return;	}	foreach (var loc in locations) {	switch (loc) {	break;	break;	break;	break;	break;	break;	
unknown loc gettype 

========================= monodevelop sample_1368 =========================

uint modekey;	gdk.modifiertype modemod;	uint key;	gdk.modifiertype mod;	if (!keybindingmanager.bindingtokeys (accelkey, out modekey, out modemod, out key, out mod)) {	item.keyequivalent = "";	item.keyequivalentmodifiermask = (nseventmodifiermask) 0;	return;	}	if (modekey != 0) {	
mac menu cannot display accelerators with mode keys 

}	if ((mod & gdk.modifiertype.controlmask) != 0) {	outmod |= nseventmodifiermask.controlkeymask;	mod ^= gdk.modifiertype.controlmask;	}	if ((mod & gdk.modifiertype.metamask) != 0) {	outmod |= nseventmodifiermask.commandkeymask;	mod ^= gdk.modifiertype.metamask;	}	if (mod != 0) {	
mac menu cannot display accelerators with modifiers 

static string getkeyequivalent (gdk.key key) {	if (key == gdk.key.tab) return "\t";	char c = (char) gdk.keyval.tounicode ((uint) key);	if (c != 0) return c.tostring ();	var fk = getfunctionkey (key);	if (fk != 0) return ((char) fk).tostring ();	
mac menu cannot display key 

========================= monodevelop sample_818 =========================

