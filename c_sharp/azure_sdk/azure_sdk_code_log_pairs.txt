public void testomjobspecandrelease() {	action test = () => {	stagingstorageaccount stagingcreds = testutilities.getstoragecredentialsfromenvironment();	using (batchclient client = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jsid = "jobprepandrelease-" + /* "om-static-c" */ "dynamic-" + crafttimestring() + "-" + testutilities.getmyname();	try {	protocol.requestinterceptor increasetimeoutinterceptor = new protocol.requestinterceptor((x) => {	
testomjobspecandrelease setting request timeout request type clientrequestid 

if (jpstatus == null) {	thread.sleep(2000);	}	else {	if (jobpreparationtaskstate.completed == jpstatus.jobpreparationtaskexecutioninformation.state) {	prepnotcompleted = false;	assert.notnull(jpstatus.jobpreparationtaskexecutioninformation.failureinformation);	assert.equal(taskexecutionresult.failure, jpstatus.jobpreparationtaskexecutioninformation.result);	this.outputfailureinfo(jpstatus.jobpreparationtaskexecutioninformation.failureinformation);	}	
job prep is running waiting for blob dl to timeout 

resourcefile[] badresfiles = {new resourcefile("https: reltask.resourcefiles = badresfiles;	reltask.id = "jobrelease";	}	unboundjob.commit();	}	client.joboperations.addtask(jobid, new cloudtask("forcejobprep", "cmd /c echo testomjobreleaseschedulingerror"));	taskstatemonitor tsm = client.utilities.createtaskstatemonitor();	tsm.waitall( client.joboperations.listtasks(jobid), taskstate.completed, timespan.fromminutes(10), additionalbehaviors: new[]	{	new protocol.requestinterceptor((x) => {	
issuing request type 

reltask.id = "jobrelease";	}	unboundjob.commit();	}	client.joboperations.addtask(jobid, new cloudtask("forcejobprep", "cmd /c echo testomjobreleaseschedulingerror"));	taskstatemonitor tsm = client.utilities.createtaskstatemonitor();	tsm.waitall( client.joboperations.listtasks(jobid), taskstate.completed, timespan.fromminutes(10), additionalbehaviors: new[]	{	new protocol.requestinterceptor((x) => {	list<computenode> allcomputenodes = client.pooloperations.listcomputenodes(this.poolfixture.poolid).tolist();	
compute nodes 

}	unboundjob.commit();	}	client.joboperations.addtask(jobid, new cloudtask("forcejobprep", "cmd /c echo testomjobreleaseschedulingerror"));	taskstatemonitor tsm = client.utilities.createtaskstatemonitor();	tsm.waitall( client.joboperations.listtasks(jobid), taskstate.completed, timespan.fromminutes(10), additionalbehaviors: new[]	{	new protocol.requestinterceptor((x) => {	list<computenode> allcomputenodes = client.pooloperations.listcomputenodes(this.poolfixture.poolid).tolist();	allcomputenodes.foreach((icn) => {	
computenode id state 

if (prepandreleasestatus != null && null != prepandreleasestatus.jobreleasetaskexecutioninformation) {	if (jobreleasetaskstate.completed == prepandreleasestatus.jobreleasetaskexecutioninformation.state) {	releasenotcompleted = false;	assert.notnull(prepandreleasestatus);	assert.notnull(prepandreleasestatus.jobreleasetaskexecutioninformation.failureinformation);	assert.equal(taskexecutionresult.failure, prepandreleasestatus.jobreleasetaskexecutioninformation.result);	this.outputfailureinfo(prepandreleasestatus.jobreleasetaskexecutioninformation.failureinformation);	}	}	thread.sleep(2000);	
job release tasks still running waiting for blob dl to timeout 

#region private helpers private void testgetprepreleasestatuscalls(batchclient batchcli, cloudjobschedule boundjobschedule, string sharedpool, ienumerable<resourcefile> correctresfiles) {	string jobid = boundjobschedule.executioninformation.recentjob.id;	pooloperations poolops = batchcli.pooloperations;	jobscheduleoperations jobscheduleoperations = batchcli.jobscheduleoperations;	{	datetime beforejobprepruns = datetime.utcnow;	cloudtask sillytask = new cloudtask("forcejobprep", "cmd /c hostname");	batchcli.joboperations.addtask(jobid, sillytask);	bool keeplooking = true;	while (keeplooking) {	
waiting for task to be scheduled 

jobprepstatuslist = batchcli.joboperations.listjobpreparationandreleasetaskstatus(jobid).tolist();	}	jobpreparationandreleasetaskexecutioninformation jptei = jobprepstatuslist.first();	computenode victimcomputenoderunningprepandrelease = poolops.getcomputenode(sharedpool, jptei.computenodeid);	{	assert.notnull(jptei);	assert.equal(0, jptei.jobpreparationtaskexecutioninformation.retrycount);	assert.true(beforejobprepruns < jptei.jobpreparationtaskexecutioninformation.starttime + timespan.fromseconds(10));	assert.null(jptei.jobpreparationtaskexecutioninformation.failureinformation);	this.testoutputhelper.writeline("");	
listing files for compute node 

computenode victimcomputenoderunningprepandrelease = poolops.getcomputenode(sharedpool, jptei.computenodeid);	{	assert.notnull(jptei);	assert.equal(0, jptei.jobpreparationtaskexecutioninformation.retrycount);	assert.true(beforejobprepruns < jptei.jobpreparationtaskexecutioninformation.starttime + timespan.fromseconds(10));	assert.null(jptei.jobpreparationtaskexecutioninformation.failureinformation);	this.testoutputhelper.writeline("");	list<nodefile> filteredlistjobprep = new list<nodefile>();	foreach (nodefile curtf in victimcomputenoderunningprepandrelease.listnodefiles(recursive: true)) {	if (curtf.path.indexof(boundjobschedule.id, stringcomparison.invariantcultureignorecase) >= 0) {	
name size dir 

}	}	foreach (resourcefile curcorrectrf in correctresfiles) {	bool found = false;	foreach (nodefile curtf in filteredlistjobprep) {	found |= curtf.path.indexof(curcorrectrf.filepath, stringcomparison.invariantcultureignorecase) >= 0;	}	assert.true(found, "looking for resourcefile: " + curcorrectrf.filepath);	}	while (jobpreparationtaskstate.completed != jptei.jobpreparationtaskexecutioninformation.state) {	
waiting for jopprep to complete 

}	catch (exception) {	}	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	assert.true(!string.isnullorwhitespace(stdout));	assert.contains("jobpreparation", stdout.tolower());	}	taskstatemonitor tsm = batchcli.utilities.createtaskstatemonitor();	protocol.requestinterceptor consolespammer = new protocol.requestinterceptor((x) => {	
testgetprepreleasestatuscalls waiting for jobprep and task to complete 

this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	assert.true(!string.isnullorwhitespace(stdout));	assert.contains("jobpreparation", stdout.tolower());	}	taskstatemonitor tsm = batchcli.utilities.createtaskstatemonitor();	protocol.requestinterceptor consolespammer = new protocol.requestinterceptor((x) => {	odatadetaillevel detaillevel = new odatadetaillevel() { filterclause = string.format("nodeid eq '{0}'", victimcomputenoderunningprepandrelease.id) };	jobprepstatuslist = batchcli.joboperations.listjobpreparationandreleasetaskstatus(jobid, detaillevel: detaillevel).tolist();	jobpreparationandreleasetaskexecutioninformation jpteiinterceptor = jobprepstatuslist.first();	
jobprep state 

while (true) {	odatadetaillevel detaillevel = new odatadetaillevel() { filterclause = string.format("nodeid eq '{0}'", victimcomputenoderunningprepandrelease.id) };	jobprepstatuslist = batchcli.joboperations.listjobpreparationandreleasetaskstatus(jobid, detaillevel: detaillevel).tolist();	jobpreparationandreleasetaskexecutioninformation jrtei = jobprepstatuslist.firstordefault();	if ((jrtei == null) || (null == jrtei.jobreleasetaskexecutioninformation)) {	thread.sleep(2000);	}	else {	assert.notnull(jrtei);	if (jrtei.jobreleasetaskexecutioninformation.state != jobreleasetaskstate.completed) {	
jobreleasetask state is 

jobpreparationandreleasetaskexecutioninformation jrtei = jobprepstatuslist.firstordefault();	if ((jrtei == null) || (null == jrtei.jobreleasetaskexecutioninformation)) {	thread.sleep(2000);	}	else {	assert.notnull(jrtei);	if (jrtei.jobreleasetaskexecutioninformation.state != jobreleasetaskstate.completed) {	thread.sleep(5000);	}	else {	
jobrelease commpleted 

}	private static ilist<resourcefile> uploadfilesmakeresfiles(stagingstorageaccount stagingcreds) {	cloudtask mytask = new cloudtask(id: "countwordstask", commandline: @"cmd /c dir /s .. & dir & type localwords.txt");	filetostage wordsdottext = new filetostage(resources.localwordsdottext, stagingcreds);	mytask.filestostage = new list<ifilestagingprovider>();	mytask.filestostage.add(wordsdottext);	mytask.stagefiles();	return mytask.resourcefiles;	}	private void outputfailureinfo(taskfailureinformation failureinfo) {	
jp failure info 

}	private static ilist<resourcefile> uploadfilesmakeresfiles(stagingstorageaccount stagingcreds) {	cloudtask mytask = new cloudtask(id: "countwordstask", commandline: @"cmd /c dir /s .. & dir & type localwords.txt");	filetostage wordsdottext = new filetostage(resources.localwordsdottext, stagingcreds);	mytask.filestostage = new list<ifilestagingprovider>();	mytask.filestostage.add(wordsdottext);	mytask.stagefiles();	return mytask.resourcefiles;	}	private void outputfailureinfo(taskfailureinformation failureinfo) {	
category 

}	private static ilist<resourcefile> uploadfilesmakeresfiles(stagingstorageaccount stagingcreds) {	cloudtask mytask = new cloudtask(id: "countwordstask", commandline: @"cmd /c dir /s .. & dir & type localwords.txt");	filetostage wordsdottext = new filetostage(resources.localwordsdottext, stagingcreds);	mytask.filestostage = new list<ifilestagingprovider>();	mytask.filestostage.add(wordsdottext);	mytask.stagefiles();	return mytask.resourcefiles;	}	private void outputfailureinfo(taskfailureinformation failureinfo) {	
code 

filetostage wordsdottext = new filetostage(resources.localwordsdottext, stagingcreds);	mytask.filestostage = new list<ifilestagingprovider>();	mytask.filestostage.add(wordsdottext);	mytask.stagefiles();	return mytask.resourcefiles;	}	private void outputfailureinfo(taskfailureinformation failureinfo) {	this.testoutputhelper.writeline("    details:" + (null == failureinfo.details ? " <null>" : string.empty));	if (null != failureinfo.details) {	foreach (namevaluepair curdetail in failureinfo.details) {	
name value 

mytask.filestostage.add(wordsdottext);	mytask.stagefiles();	return mytask.resourcefiles;	}	private void outputfailureinfo(taskfailureinformation failureinfo) {	this.testoutputhelper.writeline("    details:" + (null == failureinfo.details ? " <null>" : string.empty));	if (null != failureinfo.details) {	foreach (namevaluepair curdetail in failureinfo.details) {	}	}	
message 

========================= azure_sdk sample_5810 =========================

private void keymustthrowargumentexception( string paramname, jsonwebkey key ) {	var serialized = key.tostring();	try {	var deserialized = jsonconvert.deserializeobject<jsonwebkey>( serialized );	assert.equal( key, deserialized );	}	catch ( targetinvocationexception ex ) {	
warning key with bad value on can be serialized but not deserialized 

public static void emitvariable( string collectionname, int keysize, jsonwebkey key ) {	var text = key.tostring();	text = text.replace( "\"", "\\\"" );	text = text.replace( "\r\n", "\\r\\n" );	
add 

========================= azure_sdk sample_2122 =========================

public async task bug1360227_addtasksbatchfailure(bool usejoboperations) {	const string testname = "bug1360227_addtasksbatchfailure";	int count = 0;	const int counttofailat = 102;	const int taskcount = 407;	hashset<string> taskidsexpectedtofail = new hashset<string>();	func<addtaskresult, cancellationtoken, addtaskresultstatus> resulthandlerfunc = (result, token) => {	
task got status code 

const int taskcount = 407;	hashset<string> taskidsexpectedtofail = new hashset<string>();	func<addtaskresult, cancellationtoken, addtaskresultstatus> resulthandlerfunc = (result, token) => {	++count;	if (taskidsexpectedtofail.contains(result.taskid)) {	return addtaskresultstatus.retry;	}	else {	if (count >= counttofailat) {	taskidsexpectedtofail.add(result.taskid);	
forcing a failure 

public async task bug1360227_addtasksbatchretry(bool usejoboperations) {	const string testname = "bug1360227_addtasksbatchretry";	random rand = new random();	object randlock = new object();	int numberoftaskswhichhitclienterror = 0;	int numberoftaskswhichwereforcedtoretry = 0;	func<addtaskresult, cancellationtoken, addtaskresultstatus> resulthandlerfunc = (result, token) => {	
task got status code 

int numberoftaskswhichwereforcedtoretry = 0;	func<addtaskresult, cancellationtoken, addtaskresultstatus> resulthandlerfunc = (result, token) => {	addtaskresultstatus resultaction;	if (result.status == addtaskstatus.clienterror) {	++numberoftaskswhichhitclienterror;	return addtaskresultstatus.success;	}	lock (randlock) {	double d = rand.nextdouble();	if (d > 0.8) {	
forcing retry for task 

return resultaction;	};	await synchronizationcontexthelper.runtestasync(async () => {	stagingstorageaccount storagecredentials = testutilities.getstoragecredentialsfromenvironment();	using (batchclient batchcli = await testutilities.openbatchclientfromenvironmentasync()) {	batchclientparalleloptions paralleloptions = new batchclientparalleloptions() {	maxdegreeofparallelism = 2 };	await this.addtaskssimpletestasync( batchcli, testname, 1281, paralleloptions, resulthandlerfunc, storagecredentials, new list<string> { "testresources\\data.txt" }, usejoboperations: usejoboperations).configureawait(false);	}	}, longtesttimeout);	
forced a total of tasks to retry 

public async task bug1360227_addtasksbatchcancelation(bool usejoboperations) {	const string testname = "bug1360227_addtasksbatchcancelation";	const int taskcount = 322;	await synchronizationcontexthelper.runtestasync(async () => {	using (batchclient batchcli = await testutilities.openbatchclientfromenvironmentasync()) {	using (cancellationtokensource source = new cancellationtokensource()) {	batchclientparalleloptions paralleloptions = new batchclientparalleloptions() {	maxdegreeofparallelism = 2, cancellationtoken = source.token };	system.threading.tasks.task t = this.addtaskssimpletestasync( batchcli, testname, taskcount, paralleloptions, usejoboperations: usejoboperations);	thread.sleep(timespan.fromseconds(.3));	
canceling the work flow 

legartifactscountlist.add(artifacts.count);	thread.sleep(timespan.fromseconds(1));	}	});	await synchronizationcontexthelper.runtestasync(async () => {	stagingstorageaccount storagecredentials = testutilities.getstoragecredentialsfromenvironment();	using (batchclient batchcli = await testutilities.openbatchclientfromenvironmentasync()) {	await this.addtaskssimpletestasync( batchcli, testname, taskcount, paralleloptions: new batchclientparalleloptions() { maxdegreeofparallelism = 2 }, storagecredentials: storagecredentials, localfilestostage: localfilestostage, filestagingartifacts: artifacts, usejoboperations: usejoboperations).configureawait(false);	cts.cancel();	await t.configureawait(false);	
file staging leg count 

private async system.threading.tasks.task addtaskssimpletestasync( batchclient batchcli, string testname, int taskcount, batchclientparalleloptions paralleloptions = null, func<addtaskresult, cancellationtoken, addtaskresultstatus> resulthandlerfunc = null, stagingstorageaccount storagecredentials = null, ienumerable<string> localfilestostage = null, concurrentbag<concurrentdictionary<type, ifilestagingartifact>> filestagingartifacts = null, timespan? timeout = null, bool usejoboperations = true) {	joboperations joboperations = batchcli.joboperations;	string jobid = "bulk-" + testutilities.getmyname() + "-" + testname + "-" + usejoboperations;	try {	cloudjob unboundjob = joboperations.createjob();	
initial job commit for job 

}	}	taskstoadd.add(mytask);	taskstovalidatewith.add(duplicatereadabletask);	}	list<batchclientbehavior> behaviors = new list<batchclientbehavior>();	if (resulthandlerfunc != null) {	behaviors.add(new addtaskcollectionresulthandler(resulthandlerfunc));	}	stopwatch stopwatch = new stopwatch();	
starting task add 

}	stopwatch stopwatch = new stopwatch();	stopwatch.start();	if (usejoboperations) {	await joboperations.addtaskasync( jobid, taskstoadd, paralleloptions: paralleloptions, filestagingartifacts: filestagingartifacts, timeout: timeout, additionalbehaviors: behaviors).configureawait(continueoncapturedcontext: false);	}	else {	await boundjob.addtaskasync( taskstoadd, paralleloptions: paralleloptions, filestagingartifacts: filestagingartifacts, timeout: timeout, additionalbehaviors: behaviors).configureawait(continueoncapturedcontext: false);	}	stopwatch.stop();	
task add finished took 

await boundjob.addtaskasync( taskstoadd, paralleloptions: paralleloptions, filestagingartifacts: filestagingartifacts, timeout: timeout, additionalbehaviors: behaviors).configureawait(continueoncapturedcontext: false);	}	stopwatch.stop();	if (lastfilestostagelist != null) {	testutilities.assertthrows<invalidoperationexception>(() => lastfilestostagelist.add(new filetostage("test", null)));	}	list<cloudtask> tasksfromservice = await joboperations.listtasks(jobid).tolistasync().configureawait(false);	ensuretaskslistsmatch(taskstovalidatewith, tasksfromservice);	}	catch (exception e) {	
exception 

========================= azure_sdk sample_5795 =========================

protected task removenode(servermanagementclient client, string nodename) {	try {	
removing node 

protected async task removegateway(servermanagementclient client, string gatewayname) {	try {	
removing gateway 

========================= azure_sdk sample_7882 =========================

assert.true(boundpool.autoscaleenabled.hasvalue);	assert.true(boundpool.autoscaleenabled.value);	assert.equal(poolasformulaorig, boundpool.autoscaleformula);	autoscalerun eval = boundpool.evaluateautoscale(poolasformula2);	assert.contains(poolasformula2, eval.results);	boundpool.disableautoscale();	boundpool.refresh();	assert.true(boundpool.autoscaleenabled.hasvalue);	assert.false(boundpool.autoscaleenabled.value);	while (allocationstate.steady != boundpool.allocationstate) {	
waiting for pool to be steady before enableautoscale call 

public void testpoolobjectresizestopresize() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string poolid = "testpoolobjectresizestopresize" + testutilities.getmyname();	const int targetdedicated = 0;	const int newtargetdedicated = 1;	try {	cloudpool pool = batchcli.pooloperations.createpool(poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetdedicatedcomputenodes: targetdedicated);	pool.commit();	
created pool 

cloudpool boundpool = batchcli.pooloperations.getpool(poolid);	boundpool.enableautoscale(autoscaleformula1);	datetime utcearliestcancallenableasagain = datetime.utcnow + enableautoscaleminimumdelay;	boundpool.refresh();	assert.true(boundpool.autoscaleenabled);	assert.equal(autoscaleformula1, boundpool.autoscaleformula);	assert.notnull(boundpool.autoscalerun);	assert.notnull(boundpool.autoscalerun.results);	assert.contains(autoscaleformula1, boundpool.autoscalerun.results);	autoscalerun evaluation = boundpool.evaluateautoscale(evaluateautoscaleformula);	
autoscale evaluate results 

thread.sleep(delaybeforenextenableascall);	}	batchcli.pooloperations.enableautoscale(poolid, autoscaleformula2);	boundpool.refresh();	assert.true(boundpool.autoscaleenabled);	assert.equal(autoscaleformula2, boundpool.autoscaleformula);	assert.notnull(boundpool.autoscalerun);	assert.notnull(boundpool.autoscalerun.results);	assert.contains(autoscaleformula2, boundpool.autoscalerun.results);	evaluation = batchcli.pooloperations.evaluateautoscale(poolid, evaluateautoscaleformula);	
autoscale evaluate results 

public void longrunning_removepoolcomputenodesresizetimeout_resizeerrorspopulated() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string poolid = "bug2251050_testremovecomputenodesresizetimeout_lr" + testutilities.getmyname();	string jobid = "bug2251050job-" + testutilities.getmyname();	const int targetdedicated = 2;	try {	cloudpool pool = batchcli.pooloperations.createpool(poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetdedicatedcomputenodes: targetdedicated);	pool.commit();	
created pool 

taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( batchcli.joboperations.listtasks(jobid), microsoft.azure.batch.common.taskstate.running, timespan.fromminutes(20));	timespan resizetimeout = timespan.fromminutes(5);	batchcli.pooloperations.removefrompool(poolid, computenodes, computenodedeallocationoption.taskcompletion, resizetimeout);	testutilities.waitforpooltoreachstateasync(batchcli, poolid, allocationstate.steady, timespan.fromminutes(6)).wait();	refreshablepool.refresh();	assert.notnull(refreshablepool.resizeerrors);	assert.equal(1, refreshablepool.resizeerrors.count);	var resizeerror = refreshablepool.resizeerrors.single();	assert.equal(poolresizeerrorcodes.allocationtimedout, resizeerror.code);	
resize error 

public void longrunning_testremovepoolcomputenodes() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string poolid = "testremovepoolcomputenodes_longrunning" + testutilities.getmyname();	const int targetdedicated = 3;	try {	cloudpool pool = batchcli.pooloperations.createpool(poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetdedicatedcomputenodes: targetdedicated);	pool.commit();	
created pool 

cloudpool pool = batchcli.pooloperations.createpool(poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetdedicatedcomputenodes: targetdedicated);	pool.commit();	cloudpool refreshablepool = batchcli.pooloperations.getpool(poolid);	testutilities.waitforpooltoreachstateasync(batchcli, poolid, allocationstate.steady, timespan.fromminutes(10)).wait();	refreshablepool.refresh();	assert.equal(targetdedicated, refreshablepool.currentdedicatedcomputenodes);	ienumerable<computenode> computenodes = refreshablepool.listcomputenodes();	assert.equal(targetdedicated, computenodes.count());	computenode computenodetoremove = computenodes.first();	assert.null(computenodetoremove.starttask);	
will remove compute node 

assert.null(computenodetoremove.starttask);	refreshablepool.removefrompool(computenodetoremove);	testutilities.waitforpooltoreachstateasync(batchcli, poolid, allocationstate.steady, timespan.fromminutes(10)).wait();	refreshablepool.refresh();	list<computenode> computenodesafterremove = refreshablepool.listcomputenodes().tolist();	assert.equal(targetdedicated - 1, computenodesafterremove.count);	list<string> remainingcomputenodeids = computenodesafterremove.select(computenode => computenode.id).tolist();	foreach (computenode originalcomputenode in computenodes) {	assert.contains(originalcomputenode.id, remainingcomputenodeids);	}	
verified that the compute node was removed correctly 

foreach (computenode originalcomputenode in computenodes) {	assert.contains(originalcomputenode.id, remainingcomputenodeids);	}	computenode secondcomputenodetoremove = computenodesafterremove.first();	string secondcomputenodetoremoveid = secondcomputenodetoremove.id;	refreshablepool.removefrompool(secondcomputenodetoremoveid);	testutilities.waitforpooltoreachstateasync(batchcli, poolid, allocationstate.steady, timespan.fromminutes(10)).wait();	refreshablepool.refresh();	computenodesafterremove = refreshablepool.listcomputenodes().tolist();	assert.equal(targetdedicated - 2, computenodesafterremove.count);	
verified that the compute node was removed correctly 

}	computenode secondcomputenodetoremove = computenodesafterremove.first();	string secondcomputenodetoremoveid = secondcomputenodetoremove.id;	refreshablepool.removefrompool(secondcomputenodetoremoveid);	testutilities.waitforpooltoreachstateasync(batchcli, poolid, allocationstate.steady, timespan.fromminutes(10)).wait();	refreshablepool.refresh();	computenodesafterremove = refreshablepool.listcomputenodes().tolist();	assert.equal(targetdedicated - 2, computenodesafterremove.count);	computenode thirdcomputenodetoremove = computenodesafterremove.first();	string thirdcomputenodetoremoveid = thirdcomputenodetoremove.id;	
will remove compute node 

testutilities.waitforpooltoreachstateasync(batchcli, poolid, allocationstate.steady, timespan.fromminutes(10)).wait();	refreshablepool.refresh();	computenodesafterremove = refreshablepool.listcomputenodes().tolist();	assert.equal(targetdedicated - 2, computenodesafterremove.count);	computenode thirdcomputenodetoremove = computenodesafterremove.first();	string thirdcomputenodetoremoveid = thirdcomputenodetoremove.id;	thirdcomputenodetoremove.removefrompool();	testutilities.waitforpooltoreachstateasync(batchcli, poolid, allocationstate.steady, timespan.fromminutes(10)).wait();	computenodesafterremove = refreshablepool.listcomputenodes().tolist();	assert.equal(targetdedicated - 3, computenodesafterremove.count);	
verified that the computenode was removed correctly 

public async task longrunning_lowprioritycomputenodeallocated_isdedicatedfalse() {	func<task> test = async () => {	using (batchclient batchcli = await testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment())) {	string poolid = "testlowpri_longrunning" + testutilities.getmyname();	const int targetlowpriority = 1;	try {	cloudpool pool = batchcli.pooloperations.createpool( poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetlowprioritycomputenodes: targetlowpriority);	await pool.commitasync().configureawait(false);	
created pool 

public void listnodeagentskus() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	var nas = batchcli.pooloperations.listnodeagentskus().tolist();	assert.true(nas.count > 0);	foreach (nodeagentsku curnas in nas) {	
nas 

public void listnodeagentskus() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	var nas = batchcli.pooloperations.listnodeagentskus().tolist();	assert.true(nas.count > 0);	foreach (nodeagentsku curnas in nas) {	
skuid 

public void listnodeagentskus() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	var nas = batchcli.pooloperations.listnodeagentskus().tolist();	assert.true(nas.count > 0);	foreach (nodeagentsku curnas in nas) {	
ostype 

public void listnodeagentskus() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	var nas = batchcli.pooloperations.listnodeagentskus().tolist();	assert.true(nas.count > 0);	foreach (nodeagentsku curnas in nas) {	foreach (imagereference verifiedimagereference in curnas.verifiedimagereferences) {	
verifiedimagerefs publisher 

public void listnodeagentskus() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	var nas = batchcli.pooloperations.listnodeagentskus().tolist();	assert.true(nas.count > 0);	foreach (nodeagentsku curnas in nas) {	foreach (imagereference verifiedimagereference in curnas.verifiedimagereferences) {	
verifiedimagerefs offer 

public void listnodeagentskus() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	var nas = batchcli.pooloperations.listnodeagentskus().tolist();	assert.true(nas.count > 0);	foreach (nodeagentsku curnas in nas) {	foreach (imagereference verifiedimagereference in curnas.verifiedimagereferences) {	
verifiedimagerefs sku 

public void listnodeagentskus() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	var nas = batchcli.pooloperations.listnodeagentskus().tolist();	assert.true(nas.count > 0);	foreach (nodeagentsku curnas in nas) {	foreach (imagereference verifiedimagereference in curnas.verifiedimagereferences) {	
verifiedimagerefs version 

========================= azure_sdk sample_5804 =========================

public static void deletejobifexistsnothrow(batchserviceclient client, string jobid, itestoutputhelper output) {	try {	client.job.delete(jobid);	}	catch (batcherrorexception e) {	
job failed to delete 

public static void deletepoolifexistsnothrow(batchserviceclient client, string poolid, itestoutputhelper output) {	try {	client.pool.delete(poolid);	}	catch (batcherrorexception e) {	
pool failed to delete 

========================= azure_sdk sample_5791 =========================

public override bool execute() {	try {	strongnameutility utility = new strongnameutility();	if (!utility.validatestrongnametoolexistance(windowssdkpath)) {	
the strong name tool sn exe could not be located within the windows sdk directory structure 

try {	strongnameutility utility = new strongnameutility();	if (!utility.validatestrongnametoolexistance(windowssdkpath)) {	return false;	}	string path = assembly.itemspec;	string output;	string arguments = "-q -t \"" + path + "\"";	bool success = utility.execute(arguments, out output);	if (!success) {	
the assembly path has not been strong named signed 

bool success = utility.execute(arguments, out output);	if (!success) {	log.logerror(output);	return false;	}	int lastspace = output.lastindexof(' ');	if (lastspace >= 0) {	output = output.substring(lastspace + 1).trim();	}	if (output != expectedtokensignature) {	
the assembly had the strong name token of but was expected to have the token 

========================= azure_sdk sample_10 =========================

new filetostage(resources.localwordsdottext, storagecreds) };	var artifacts = boundjob.addtask(mytask);	var specificartifact = artifacts[typeof(filetostage)];	sequentialfilestagingartifact sfsa = specificartifact as sequentialfilestagingartifact;	assert.notnull(sfsa);	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	taskstatemonitor taskstatemonitor = batchcli.utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(10), controlparams: null, additionalbehaviors: new[]	{	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	
issuing request type 

var specificartifact = artifacts[typeof(filetostage)];	sequentialfilestagingartifact sfsa = specificartifact as sequentialfilestagingartifact;	assert.notnull(sfsa);	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	taskstatemonitor taskstatemonitor = batchcli.utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(10), controlparams: null, additionalbehaviors: new[]	{	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	try {	list<computenode> allcomputenodes = boundpool.listcomputenodes().tolist();	
compute nodes 

sequentialfilestagingartifact sfsa = specificartifact as sequentialfilestagingartifact;	assert.notnull(sfsa);	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	taskstatemonitor taskstatemonitor = batchcli.utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(10), controlparams: null, additionalbehaviors: new[]	{	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	try {	list<computenode> allcomputenodes = boundpool.listcomputenodes().tolist();	allcomputenodes.foreach( (icn) => {	
computenode id state 

allcomputenodes.foreach( (icn) => {	});	}	catch (exception ex) {	assert.true(false, "samplewithfilesandpool probably can ignore this if its pool not found: " + ex.tostring());	}	}) });	list<cloudtask> tasks = boundjob.listtasks().tolist();	cloudtask mycompletedtask = tasks.single();	foreach (cloudtask curtask in tasks) {	
task id state 

}	catch (exception ex) {	assert.true(false, "samplewithfilesandpool probably can ignore this if its pool not found: " + ex.tostring());	}	}) });	list<cloudtask> tasks = boundjob.listtasks().tolist();	cloudtask mycompletedtask = tasks.single();	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	
pool id state 

assert.true(false, "samplewithfilesandpool probably can ignore this if its pool not found: " + ex.tostring());	}	}) });	list<cloudtask> tasks = boundjob.listtasks().tolist();	cloudtask mycompletedtask = tasks.single();	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
stdout 

}	}) });	list<cloudtask> tasks = boundjob.listtasks().tolist();	cloudtask mycompletedtask = tasks.single();	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	
stderr 

}) });	list<cloudtask> tasks = boundjob.listtasks().tolist();	cloudtask mycompletedtask = tasks.single();	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	
task files 

list<cloudtask> tasks = boundjob.listtasks().tolist();	cloudtask mycompletedtask = tasks.single();	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	foreach (nodefile curfile in mycompletedtask.listnodefiles(recursive: true)) {	
file path 

while (!cts.token.iscancellationrequested) {	legartifactscountlist.add(artifacts.count);	thread.sleep(timespan.fromseconds(1));	}	});	stagingstorageaccount storagecredentials = testutilities.getstoragecredentialsfromenvironment();	using (batchclient batchcli = await testutilities.openbatchclientfromenvironmentasync()) {	await this.addtaskssimpletestasync( batchcli, testname, taskcount, paralleloptions: new batchclientparalleloptions() { maxdegreeofparallelism = 2 }, resulthandlerfunc: null, storagecredentials: storagecredentials, localfilestostage: localfilestostage, filestagingartifacts: artifacts, usejoboperations: usejoboperations).configureawait(false);	cts.cancel();	await t.configureawait(false);	
file staging leg count 

private async system.threading.tasks.task addtaskssimpletestasync( batchclient batchcli, string testname, int taskcount, batchclientparalleloptions paralleloptions, func<addtaskresult, cancellationtoken, addtaskresultstatus> resulthandlerfunc, stagingstorageaccount storagecredentials, ienumerable<string> localfilestostage, concurrentbag<concurrentdictionary<type, ifilestagingartifact>> filestagingartifacts = null, timespan? timeout = null, bool usejoboperations = true) {	joboperations joboperations = batchcli.joboperations;	string jobid = "bulk-" + testutilities.getmyname() + "-" + testname + "-" + usejoboperations;	try {	cloudjob unboundjob = joboperations.createjob();	
initial job commit for job 

}	}	taskstoadd.add(mytask);	taskstovalidatewith.add(duplicatereadabletask);	}	list<batchclientbehavior> behaviors = new list<batchclientbehavior>();	if (resulthandlerfunc != null) {	behaviors.add(new addtaskcollectionresulthandler(resulthandlerfunc));	}	stopwatch stopwatch = new stopwatch();	
starting task add 

}	stopwatch stopwatch = new stopwatch();	stopwatch.start();	if (usejoboperations) {	await joboperations.addtaskasync( jobid, taskstoadd, paralleloptions: paralleloptions, filestagingartifacts: filestagingartifacts, timeout: timeout, additionalbehaviors: behaviors).configureawait(continueoncapturedcontext: false);	}	else {	await boundjob.addtaskasync( taskstoadd, paralleloptions: paralleloptions, filestagingartifacts: filestagingartifacts, timeout: timeout, additionalbehaviors: behaviors).configureawait(continueoncapturedcontext: false);	}	stopwatch.stop();	
task add finished took 

await boundjob.addtaskasync( taskstoadd, paralleloptions: paralleloptions, filestagingartifacts: filestagingartifacts, timeout: timeout, additionalbehaviors: behaviors).configureawait(continueoncapturedcontext: false);	}	stopwatch.stop();	if (lastfilestostagelist != null) {	assert.throws<invalidoperationexception>(() => lastfilestostagelist.add(new filetostage("test", null)));	}	list<cloudtask> tasksfromservice = await joboperations.listtasks(jobid).tolistasync().configureawait(false);	ensuretaskslistsmatch(taskstovalidatewith, tasksfromservice);	}	catch (exception e) {	
exception 

========================= azure_sdk sample_5706 =========================

public async task testcertificateverbs() {	func<task> test = async () => {	using (batchclient batchcli = await testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment())) {	const string certificateprefix = "testcertificatecrud";	string cerfilepath = integrationtestcommon.gettemporarycertificatefilepath(string.format("{0}.cer", certificateprefix));	string pfxfilepath = integrationtestcommon.gettemporarycertificatefilepath(string.format("{0}.pfx", certificateprefix));	ienumerable<certificate> certificates = generatecertificates(batchcli, cerfilepath, pfxfilepath);	try {	foreach (certificate certificate in certificates) {	
adding certificate with thumbprint 

public async task testpoolcertificatereferenceswithupdate() {	func<task> test = async () => {	using (batchclient batchcli = await testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment())) {	const string certificateprefix = "poolwithcertificatereferences";	string cerfilepath = integrationtestcommon.gettemporarycertificatefilepath(string.format("{0}.cer", certificateprefix));	string pfxfilepath = integrationtestcommon.gettemporarycertificatefilepath(string.format("{0}.pfx", certificateprefix));	ienumerable<certificate> certificates = generatecertificates(batchcli, cerfilepath, pfxfilepath);	try {	foreach (certificate certificate in certificates) {	
adding certificate with thumbprint 

========================= azure_sdk sample_5801 =========================

else {	sdkprojects = projutil.getscopedsdkprojects(buildscope);	testprojects = projutil.getscopedtestprojects(buildscope);	}	allprojects.addrange(sdkprojects);	allprojects.addrange(testprojects);	concurrentbag<sdkprojectmetadata> projwithmetadata = new concurrentbag<sdkprojectmetadata>();	var projtimebefore = datetime.now;	projwithmetadata = getprojectdata(allprojects, projwithmetadata);	var projtimeafter = datetime.now;	
parsing projects took 

========================= azure_sdk sample_6 =========================

public void testhandcodedenumsmatchswaggergeneratedenums() {	typeinfo arbitraryhandcraftedenum = typeof(jobstate).gettypeinfo();	string handcraftedenumnamespace = arbitraryhandcraftedenum.namespace;	list<type> enumtypes = arbitraryhandcraftedenum.assembly.gettypes().where(t => t.gettypeinfo().isenum && t.namespace == handcraftedenumnamespace).tolist();	typeinfo arbitrarygeneratedenum = typeof(protocol.models.jobstate).gettypeinfo();	string generatedenumnamespace = arbitrarygeneratedenum.namespace;	list<type> generatedenumtypes = arbitrarygeneratedenum.assembly.gettypes().where(t => t.gettypeinfo().isenum && t.namespace == generatedenumnamespace).tolist();	
generated types 

typeinfo arbitraryhandcraftedenum = typeof(jobstate).gettypeinfo();	string handcraftedenumnamespace = arbitraryhandcraftedenum.namespace;	list<type> enumtypes = arbitraryhandcraftedenum.assembly.gettypes().where(t => t.gettypeinfo().isenum && t.namespace == handcraftedenumnamespace).tolist();	typeinfo arbitrarygeneratedenum = typeof(protocol.models.jobstate).gettypeinfo();	string generatedenumnamespace = arbitrarygeneratedenum.namespace;	list<type> generatedenumtypes = arbitrarygeneratedenum.assembly.gettypes().where(t => t.gettypeinfo().isenum && t.namespace == generatedenumnamespace).tolist();	foreach (type generatedenumtype in generatedenumtypes) {	this.testoutputhelper.writeline(generatedenumtype.tostring());	}	this.testoutputhelper.writeline("");	
handcrafted types 

========================= azure_sdk sample_6441 =========================

using (mockcontext context = mockcontext.start(this.gettype().fullname)) {	var resourcesclient = resourcesmanagementtestutilities.getresourcemanagementclientwithhandler(context, handler1);	var networkmanagementclient = networkmanagementtestutilities.getnetworkmanagementclientwithhandler(context, handler2);	var location = networkmanagementtestutilities.getresourcelocation(resourcesclient, "microsoft.network/virtualnetworkgateways");	string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

"192.168.0.0/16", }	}, bgpsettings = new bgpsettings() {	asn = 1234, bgppeeringaddress = "192.168.0.1", peerweight = 3 }	};	var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

name = ipconfigname, privateipallocationmethod = ipallocationmethod.dynamic, publicipaddress = new subresource() {	id = nic1publicip.id }, subnet = new subresource() {	id = getsubnetresponse.id }	}	}, sku = new virtualnetworkgatewaysku() {	name = "standard", tier = "standard" }, bgpsettings = new bgpsettings() {	asn = 1337, bgppeeringaddress = null, peerweight = 5 }	};	var putvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.createorupdate(resourcegroupname, virtualnetworkgatewayname, virtualnetworkgateway);	assert.equal("succeeded", putvirtualnetworkgatewayresponse.provisioningstate);	
virtual network gateway is deployed successfully 

addressprefixes = new list<string>() {	"192.168.0.0/16", }	}	};	var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

new virtualnetworkgatewayipconfiguration() {	name = ipconfigname, privateipallocationmethod = ipallocationmethod.dynamic, publicipaddress = new subresource() {	id = nic1publicip.id }, subnet = new subresource() {	id = getsubnetresponse.id }	}	}, sku = new virtualnetworkgatewaysku() {	name = virtualnetworkgatewayskuname.standard, tier = virtualnetworkgatewayskutier.standard }	};	var putvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.createorupdate(resourcegroupname, virtualnetworkgatewayname, virtualnetworkgateway);	assert.equal("succeeded", putvirtualnetworkgatewayresponse.provisioningstate);	
virtual network gateway is deployed successfully 

addressprefixes = new list<string>() {	"192.168.0.0/16", }	}	};	var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

id = getlocalnetworkgatewayresponse.id }, gatewaytype = virtualnetworkgatewaytype.vpn, vpntype = vpntype.routebased, ipconfigurations = new list<virtualnetworkgatewayipconfiguration>() {	new virtualnetworkgatewayipconfiguration() {	name = ipconfigname, privateipallocationmethod = ipallocationmethod.dynamic, publicipaddress = new subresource() {	id = nic1publicip.id }, subnet = new subresource() {	id = getsubnetresponse.id }	}	}	};	var putvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.createorupdate(resourcegroupname, virtualnetworkgatewayname, virtualnetworkgateway);	assert.equal("succeeded", putvirtualnetworkgatewayresponse.provisioningstate);	
virtual network gateway is deployed successfully 

name = ipconfigname, privateipallocationmethod = ipallocationmethod.dynamic, publicipaddress = new subresource() {	id = nic1publicip.id }, subnet = new subresource() {	id = getsubnetresponse.id }	}	}	};	var putvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.createorupdate(resourcegroupname, virtualnetworkgatewayname, virtualnetworkgateway);	assert.equal("succeeded", putvirtualnetworkgatewayresponse.provisioningstate);	var getvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.get(resourcegroupname, virtualnetworkgatewayname);	assert.notnull(getvirtualnetworkgatewayresponse.gatewaydefaultsite);	
default site set at virtual network gateway 

var getvirtualnetworkgatewayconnectionresponse = networkmanagementclient.virtualnetworkgatewayconnections.get(resourcegroupname, virtualnetworkgatewayconnectionname);	console.writeline("gatewayconnection details:- gatewaylocation: {0}, gatewayconnectionid:{1}, virtualnetworkgateway1 name={2} & id={3}, localnetworkgateway2 name={4} & id={5}, connectiontype={6} routingweight={7} sharedkey={8}" + "connectionstatus={9}, egressbytestransferred={10}, ingressbytestransferred={11}", getvirtualnetworkgatewayconnectionresponse.location, getvirtualnetworkgatewayconnectionresponse.id, getvirtualnetworkgatewayconnectionresponse.name, getvirtualnetworkgatewayconnectionresponse.virtualnetworkgateway1.name, getvirtualnetworkgatewayconnectionresponse.virtualnetworkgateway1.id, getvirtualnetworkgatewayconnectionresponse.localnetworkgateway2.name, getvirtualnetworkgatewayconnectionresponse.localnetworkgateway2.id, getvirtualnetworkgatewayconnectionresponse.connectiontype, getvirtualnetworkgatewayconnectionresponse.routingweight, getvirtualnetworkgatewayconnectionresponse.sharedkey, getvirtualnetworkgatewayconnectionresponse.connectionstatus, getvirtualnetworkgatewayconnectionresponse.egressbytestransferred, getvirtualnetworkgatewayconnectionresponse.ingressbytestransferred);	assert.equal(virtualnetworkgatewayconnectiontype.ipsec, getvirtualnetworkgatewayconnectionresponse.connectiontype);	assert.equal(3, getvirtualnetworkgatewayconnectionresponse.routingweight);	assert.equal("abc", getvirtualnetworkgatewayconnectionresponse.sharedkey);	getvirtualnetworkgatewayresponse.gatewaydefaultsite = null;	putvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.createorupdate(resourcegroupname, virtualnetworkgatewayname, getvirtualnetworkgatewayresponse);	assert.equal("succeeded", putvirtualnetworkgatewayresponse.provisioningstate);	getvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.get(resourcegroupname, virtualnetworkgatewayname);	assert.null(getvirtualnetworkgatewayresponse.gatewaydefaultsite);	
default site removal from virtual network gateway is successful 

using (mockcontext context = mockcontext.start(this.gettype().fullname)) {	var resourcesclient = resourcesmanagementtestutilities.getresourcemanagementclientwithhandler(context, handler1);	var networkmanagementclient = networkmanagementtestutilities.getnetworkmanagementclientwithhandler(context, handler2);	var location = networkmanagementtestutilities.getresourcelocation(resourcesclient, "microsoft.network/connections");	string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

var putvirtualnetworkgatewayconnectionresponse = networkmanagementclient.virtualnetworkgatewayconnections.createorupdate(resourcegroupname, virtualnetworkgatewayconnectionname, virtualnetworkgatewayconneciton);	assert.equal("succeeded", putvirtualnetworkgatewayconnectionresponse.provisioningstate);	var getvirtualnetworkgatewayconnectionresponse = networkmanagementclient.virtualnetworkgatewayconnections.get(resourcegroupname, virtualnetworkgatewayconnectionname);	assert.equal("succeeded", getvirtualnetworkgatewayconnectionresponse.provisioningstate);	assert.equal("abc", getvirtualnetworkgatewayconnectionresponse.sharedkey);	string connectionsharedkeyname = virtualnetworkgatewayconnectionname;	var connectionresetsharedkey = new connectionresetsharedkey() {	keylength = 50 };	var resetconnectionresetsharedkeyresponse = networkmanagementclient.virtualnetworkgatewayconnections.resetsharedkey(resourcegroupname, connectionsharedkeyname, connectionresetsharedkey);	var getconnectionsharedkeyresponse = networkmanagementclient.virtualnetworkgatewayconnections.getsharedkey(resourcegroupname, connectionsharedkeyname);	
connectionsharedkey details value 

string connectionsharedkeyname = virtualnetworkgatewayconnectionname;	var connectionresetsharedkey = new connectionresetsharedkey() {	keylength = 50 };	var resetconnectionresetsharedkeyresponse = networkmanagementclient.virtualnetworkgatewayconnections.resetsharedkey(resourcegroupname, connectionsharedkeyname, connectionresetsharedkey);	var getconnectionsharedkeyresponse = networkmanagementclient.virtualnetworkgatewayconnections.getsharedkey(resourcegroupname, connectionsharedkeyname);	assert.notequal("abc", getconnectionsharedkeyresponse.value);	var connectionsharedkey = new connectionsharedkey() {	value = "testsharedkeyvalue" };	var putconnectionsharedkeyresponse = networkmanagementclient.virtualnetworkgatewayconnections.setsharedkey(resourcegroupname, connectionsharedkeyname, connectionsharedkey);	getconnectionsharedkeyresponse = networkmanagementclient.virtualnetworkgatewayconnections.getsharedkey(resourcegroupname, connectionsharedkeyname);	
connectionsharedkey details value 

addressprefixes = new list<string>() {	"192.168.0.0/16", }	}	};	var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

using (mockcontext context = mockcontext.start(this.gettype().fullname)) {	var resourcesclient = resourcesmanagementtestutilities.getresourcemanagementclientwithhandler(context, handler1);	var networkmanagementclient = networkmanagementtestutilities.getnetworkmanagementclientwithhandler(context, handler2);	var location = networkmanagementtestutilities.getresourcelocation(resourcesclient, "microsoft.network/virtualnetworkgateways");	string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname1 = testutilities.generatename();	string domainnamelabel1 = testutilities.generatename();	var nic1publicip1 = testhelper.createdefaultpublicipaddress(publicipname1, resourcegroupname, domainnamelabel1, location, networkmanagementclient);	
publicipaddress gateway ip 

var location = networkmanagementtestutilities.getresourcelocation(resourcesclient, "microsoft.network/virtualnetworkgateways");	string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname1 = testutilities.generatename();	string domainnamelabel1 = testutilities.generatename();	var nic1publicip1 = testhelper.createdefaultpublicipaddress(publicipname1, resourcegroupname, domainnamelabel1, location, networkmanagementclient);	string publicipname2 = testutilities.generatename();	string domainnamelabel2 = testutilities.generatename();	var nic1publicip2 = testhelper.createdefaultpublicipaddress(publicipname2, resourcegroupname, domainnamelabel2, location, networkmanagementclient);	
publicipaddress gateway ip 

string publicipname1 = testutilities.generatename();	string domainnamelabel1 = testutilities.generatename();	var nic1publicip1 = testhelper.createdefaultpublicipaddress(publicipname1, resourcegroupname, domainnamelabel1, location, networkmanagementclient);	string publicipname2 = testutilities.generatename();	string domainnamelabel2 = testutilities.generatename();	var nic1publicip2 = testhelper.createdefaultpublicipaddress(publicipname2, resourcegroupname, domainnamelabel2, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

using (mockcontext context = mockcontext.start(this.gettype().fullname)) {	var resourcesclient = resourcesmanagementtestutilities.getresourcemanagementclientwithhandler(context, handler1);	var networkmanagementclient = networkmanagementtestutilities.getnetworkmanagementclientwithhandler(context, handler2);	var location = networkmanagementtestutilities.getresourcelocation(resourcesclient, "microsoft.network/virtualnetworkgateways");	string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

string resourcegroupname = testutilities.generatename("csmrg");	resourcesclient.resourcegroups.createorupdate(resourcegroupname, new resourcegroup {	location = location });	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

addressprefixes = new list<string>() {	"192.168.0.0/16", }	}	};	var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	
publicipaddress gateway ip 

var putlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.createorupdate(resourcegroupname, localnetworkgatewayname, localnetworkgateway);	assert.equal("succeeded", putlocalnetworkgatewayresponse.provisioningstate);	var getlocalnetworkgatewayresponse = networkmanagementclient.localnetworkgateways.get(resourcegroupname, localnetworkgatewayname);	string publicipname = testutilities.generatename();	string domainnamelabel = testutilities.generatename();	var nic1publicip = testhelper.createdefaultpublicipaddress(publicipname, resourcegroupname, domainnamelabel, location, networkmanagementclient);	string vnetname = testutilities.generatename();	string subnetname = "gatewaysubnet";	var virtualnetwork = testhelper.createvirtualnetwork(vnetname, subnetname, resourcegroupname, location, networkmanagementclient);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, subnetname);	
virtual network gatewaysubnet id 

new virtualnetworkgatewayipconfiguration() {	name = ipconfigname, privateipallocationmethod = ipallocationmethod.dynamic, publicipaddress = new subresource() {	id = nic1publicip.id }, subnet = new subresource() {	id = getsubnetresponse.id }	}	}, sku = new virtualnetworkgatewaysku() {	name = virtualnetworkgatewayskuname.standard, tier = virtualnetworkgatewayskutier.standard }	};	var putvirtualnetworkgatewayresponse = networkmanagementclient.virtualnetworkgateways.createorupdate(resourcegroupname, virtualnetworkgatewayname, virtualnetworkgateway);	assert.equal("succeeded", putvirtualnetworkgatewayresponse.provisioningstate);	
virtual network gateway is deployed successfully 

========================= azure_sdk sample_3235 =========================

public override bool execute() {	if (timeoutmiliseconds == 0) timeoutmiliseconds = default_task_timeout;	threadtask.task waitingtask = threadtask.task.run(() => {	
press any key to continue or it will continue in seconds 

========================= azure_sdk sample_7 =========================

timespan duration = endtime.subtract(starttime);	taskcompletionsource.setresult(duration);	});	cancellationduration = await taskcompletionsource.task;	token.throwifcancellationrequested();	return new azureoperationresponse<protocol.models.cloudjob, protocol.models.jobgetheaders>() { body = new protocol.models.cloudjob() };	};	});	await assert.throwsasync<operationcanceledexception>(async () => await client.joboperations.getjobasync("dummy", additionalbehaviors: new list<batchclientbehavior> { requestinterceptor }));	}	
there were requests executed 

timespan duration = endtime.subtract(starttime);	taskcompletionsource.setresult(duration);	});	cancellationduration = await taskcompletionsource.task;	token.throwifcancellationrequested();	return new azureoperationresponse<protocol.models.cloudjob, protocol.models.jobgetheaders>() { body = new protocol.models.cloudjob() };	};	});	await assert.throwsasync<operationcanceledexception>(async () => await client.joboperations.getjobasync("dummy", additionalbehaviors: new list<batchclientbehavior> { requestinterceptor }));	}	
took to cancel task 

});	cancellationduration = await taskcompletionsource.task;	token.throwifcancellationrequested();	return new azureoperationresponse<protocol.models.cloudjob, protocol.models.jobgetheaders>() { body = new protocol.models.cloudjob() };	};	});	await assert.throwsasync<operationcanceledexception>(async () => await client.joboperations.getjobasync("dummy", additionalbehaviors: new list<batchclientbehavior> { requestinterceptor }));	}	assert.notnull(cancellationduration);	if (expectedcustomtokentimeouttohitfirst) {	
expected custom token timeout to hit first 

return new azureoperationresponse<protocol.models.cloudjob, protocol.models.jobgetheaders>() { body = new protocol.models.cloudjob() };	};	});	await assert.throwsasync<operationcanceledexception>(async () => await client.joboperations.getjobasync("dummy", additionalbehaviors: new list<batchclientbehavior> { requestinterceptor }));	}	assert.notnull(cancellationduration);	if (expectedcustomtokentimeouttohitfirst) {	assert.true(math.abs(clientrequesttimeoutviacustomtoken.value.totalseconds - cancellationduration.value.totalseconds) < timetolerance, string.format("expected timeout: {0}, observed timeout: {1}", clientrequesttimeoutviacustomtoken, cancellationduration));	}	else {	
expected client side timeout to hit first 

private async task batchrequestcancellationviaparametertestasync(methodinfo method, object o, timespan? clientrequesttimeoutviacustomtoken) {	assert.notnull(clientrequesttimeoutviacustomtoken);	using (cancellationtokensource cancellationtokensource = new cancellationtokensource(clientrequesttimeoutviacustomtoken.value)) {	
invoking 

private async task batchrequestcancellationviaparametertestasync(methodinfo method, object o, timespan? clientrequesttimeoutviacustomtoken) {	assert.notnull(clientrequesttimeoutviacustomtoken);	using (cancellationtokensource cancellationtokensource = new cancellationtokensource(clientrequesttimeoutviacustomtoken.value)) {	batchunittestcancellationexception e = await assert.throwsasync<batchunittestcancellationexception>( async () => await invokecancellationtokenmethodasync(method, o, cancellationtokensource.token));	
there were requests executed 

private async task batchrequestcancellationviaparametertestasync(methodinfo method, object o, timespan? clientrequesttimeoutviacustomtoken) {	assert.notnull(clientrequesttimeoutviacustomtoken);	using (cancellationtokensource cancellationtokensource = new cancellationtokensource(clientrequesttimeoutviacustomtoken.value)) {	batchunittestcancellationexception e = await assert.throwsasync<batchunittestcancellationexception>( async () => await invokecancellationtokenmethodasync(method, o, cancellationtokensource.token));	
took to cancel task 

========================= azure_sdk sample_6443 =========================

unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(id: "bug1480489task", commandline: @"md bug1480489directory");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
taskid 

unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(id: "bug1480489task", commandline: @"md bug1480489directory");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
stdout 

cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(id: "bug1480489task", commandline: @"md bug1480489directory");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	
stderr 

cloudtask mytask = new cloudtask(id: "bug1480489task", commandline: @"md bug1480489directory");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	
task files 

utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	bool foundatleastonedir = false;	foreach (nodefile curfile in mycompletedtask.listnodefiles()) {	
filepath 

utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	bool foundatleastonedir = false;	foreach (nodefile curfile in mycompletedtask.listnodefiles()) {	
isdirectory 

cloudjob unboundjob = batchcli.joboperations.createjob(jobid, new poolinformation());	unboundjob.poolinformation.poolid = this.poolfixture.poolid;	unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	cloudtask directorycreationtask1 = new cloudtask(directorycreationtaskid1, string.format("cmd /c mkdir {0} && echo test > {0}/testfile.txt", directorynameone));	cloudtask directorycreationtask2 = new cloudtask(directorycreationtaskid2, string.format("cmd /c mkdir {0} && echo test > {0}/testfile.txt", directorynametwo));	boundjob.addtask(mytask);	boundjob.addtask(directorycreationtask1);	boundjob.addtask(directorycreationtask2);	
initial job commit 

cloudjob unboundjob = batchcli.joboperations.createjob(jobid, new poolinformation());	unboundjob.poolinformation.poolid = this.poolfixture.poolid;	unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	cloudtask directorycreationtask1 = new cloudtask(directorycreationtaskid1, string.format("cmd /c mkdir {0} && echo test > {0}/testfile.txt", directorynameone));	cloudtask directorycreationtask2 = new cloudtask(directorycreationtaskid2, string.format("cmd /c mkdir {0} && echo test > {0}/testfile.txt", directorynametwo));	boundjob.addtask(mytask);	boundjob.addtask(directorycreationtask1);	boundjob.addtask(directorycreationtask2);	
initial job commit 

cloudtask directorycreationtask2 = new cloudtask(directorycreationtaskid2, string.format("cmd /c mkdir {0} && echo test > {0}/testfile.txt", directorynametwo));	boundjob.addtask(mytask);	boundjob.addtask(directorycreationtask1);	boundjob.addtask(directorycreationtask2);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	
task ran on compute node 

list<nodefile> filesbycomputenoderecursivefalse = batchcli.pooloperations.listnodefiles( this.poolfixture.poolid, computenodeid, recursive: false).tolist();	assertfilelistsmatch(filesbycomputenoderecursiveomitted, filesbycomputenoderecursivefalse);	}	{	list<nodefile> filesbytaskrecursiveomitted = batchcli.joboperations.listnodefiles( jobid, taskid).tolist();	list<nodefile> filesbytaskrecursivefalse = batchcli.joboperations.listnodefiles( jobid, taskid, recursive: false).tolist();	assertfilelistsmatch(filesbytaskrecursiveomitted, filesbytaskrecursivefalse);	}	list<nodefile> filelistfromcomputenodeoperations = batchcli.pooloperations.listnodefiles(this.poolfixture.poolid, computenodeid, recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	
found file 

list<nodefile> filesbytaskrecursiveomitted = batchcli.joboperations.listnodefiles( jobid, taskid).tolist();	list<nodefile> filesbytaskrecursivefalse = batchcli.joboperations.listnodefiles( jobid, taskid, recursive: false).tolist();	assertfilelistsmatch(filesbytaskrecursiveomitted, filesbytaskrecursivefalse);	}	list<nodefile> filelistfromcomputenodeoperations = batchcli.pooloperations.listnodefiles(this.poolfixture.poolid, computenodeid, recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenodeoperations.select(f => f.path));	list<nodefile> filelistfromcomputenode = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	
found file 

}	list<nodefile> filelistfromcomputenodeoperations = batchcli.pooloperations.listnodefiles(this.poolfixture.poolid, computenodeid, recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenodeoperations.select(f => f.path));	list<nodefile> filelistfromcomputenode = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenode.select(f => f.path));	string filepathtoget = filelistfromcomputenode.first(f => !f.isdirectory.value).path;	
getting file 

list<nodefile> filelistfromcomputenodeoperations = batchcli.pooloperations.listnodefiles(this.poolfixture.poolid, computenodeid, recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenodeoperations.select(f => f.path));	list<nodefile> filelistfromcomputenode = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenode.select(f => f.path));	string filepathtoget = filelistfromcomputenode.first(f => !f.isdirectory.value).path;	nodefile computenodefilefrommanager = batchcli.pooloperations.getnodefile(this.poolfixture.poolid, computenodeid, filepathtoget);	
successfully retrieved file 

list<nodefile> filelistfromcomputenodeoperations = batchcli.pooloperations.listnodefiles(this.poolfixture.poolid, computenodeid, recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenodeoperations.select(f => f.path));	list<nodefile> filelistfromcomputenode = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenode.select(f => f.path));	string filepathtoget = filelistfromcomputenode.first(f => !f.isdirectory.value).path;	nodefile computenodefilefrommanager = batchcli.pooloperations.getnodefile(this.poolfixture.poolid, computenodeid, filepathtoget);	
file data 

foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenodeoperations.select(f => f.path));	list<nodefile> filelistfromcomputenode = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenode.select(f => f.path));	string filepathtoget = filelistfromcomputenode.first(f => !f.isdirectory.value).path;	nodefile computenodefilefrommanager = batchcli.pooloperations.getnodefile(this.poolfixture.poolid, computenodeid, filepathtoget);	this.testoutputhelper.writeline(computenodefilefrommanager.readasstring());	
getting file 

}	assert.contains("shared", filelistfromcomputenodeoperations.select(f => f.path));	list<nodefile> filelistfromcomputenode = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenode.select(f => f.path));	string filepathtoget = filelistfromcomputenode.first(f => !f.isdirectory.value).path;	nodefile computenodefilefrommanager = batchcli.pooloperations.getnodefile(this.poolfixture.poolid, computenodeid, filepathtoget);	this.testoutputhelper.writeline(computenodefilefrommanager.readasstring());	nodefile filefromcomputenode = computenode.getnodefile(filepathtoget);	
successfully retrieved file 

}	assert.contains("shared", filelistfromcomputenodeoperations.select(f => f.path));	list<nodefile> filelistfromcomputenode = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile f in filelistfromcomputenodeoperations) {	}	assert.contains("shared", filelistfromcomputenode.select(f => f.path));	string filepathtoget = filelistfromcomputenode.first(f => !f.isdirectory.value).path;	nodefile computenodefilefrommanager = batchcli.pooloperations.getnodefile(this.poolfixture.poolid, computenodeid, filepathtoget);	this.testoutputhelper.writeline(computenodefilefrommanager.readasstring());	nodefile filefromcomputenode = computenode.getnodefile(filepathtoget);	
file data 

joboperations joboperations = batchcli.joboperations;	{	string jobid = "bug2338301job-" + testutilities.getmyname();	try {	const string taskid = "hiworld";	cloudjob unboundjob = joboperations.createjob(jobid, new poolinformation() { poolid = this.poolfixture.poolid });	unboundjob.commit();	cloudjob boundjob = joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	
initial job commit 

using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = "bug1480491job-" + testutilities.getmyname();	try {	const string taskid = "hiworld";	cloudjob unboundjob = batchcli.joboperations.createjob(jobid, new poolinformation());	unboundjob.poolinformation.poolid = this.poolfixture.poolid;	unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	
initial job commit 

unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	const int expectedfilesize = 13;	const string stdoutfilename = "stdout.txt";	nodefile file = batchcli.joboperations.getnodefile(jobid, taskid, stdoutfilename);	
file has content length 

unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	const int expectedfilesize = 13;	const string stdoutfilename = "stdout.txt";	nodefile file = batchcli.joboperations.getnodefile(jobid, taskid, stdoutfilename);	
file has content type 

unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	const int expectedfilesize = 13;	const string stdoutfilename = "stdout.txt";	nodefile file = batchcli.joboperations.getnodefile(jobid, taskid, stdoutfilename);	
file has creation time 

unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	const int expectedfilesize = 13;	const string stdoutfilename = "stdout.txt";	nodefile file = batchcli.joboperations.getnodefile(jobid, taskid, stdoutfilename);	
file has last modified time 

taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	const int expectedfilesize = 13;	const string stdoutfilename = "stdout.txt";	nodefile file = batchcli.joboperations.getnodefile(jobid, taskid, stdoutfilename);	assert.equal(expectedfilesize, file.properties.contentlength);	assert.equal("application/octet-stream", file.properties.contenttype);	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	
task ran on compute node 

const int expectedfilesize = 13;	const string stdoutfilename = "stdout.txt";	nodefile file = batchcli.joboperations.getnodefile(jobid, taskid, stdoutfilename);	assert.equal(expectedfilesize, file.properties.contentlength);	assert.equal("application/octet-stream", file.properties.contenttype);	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	list<nodefile> files = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile nodefile in files) {	
found file 

assert.equal(expectedfilesize, file.properties.contentlength);	assert.equal("application/octet-stream", file.properties.contenttype);	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	list<nodefile> files = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile nodefile in files) {	}	string filepathtoget = string.format("workitems/{0}/{1}/{2}/{3}", jobid, "job-1", taskid, stdoutfilename);	file = computenode.getnodefile(filepathtoget);	
file has content length 

assert.equal(expectedfilesize, file.properties.contentlength);	assert.equal("application/octet-stream", file.properties.contenttype);	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	list<nodefile> files = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile nodefile in files) {	}	string filepathtoget = string.format("workitems/{0}/{1}/{2}/{3}", jobid, "job-1", taskid, stdoutfilename);	file = computenode.getnodefile(filepathtoget);	
file has content type 

assert.equal(expectedfilesize, file.properties.contentlength);	assert.equal("application/octet-stream", file.properties.contenttype);	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	list<nodefile> files = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile nodefile in files) {	}	string filepathtoget = string.format("workitems/{0}/{1}/{2}/{3}", jobid, "job-1", taskid, stdoutfilename);	file = computenode.getnodefile(filepathtoget);	
file has creation time 

assert.equal(expectedfilesize, file.properties.contentlength);	assert.equal("application/octet-stream", file.properties.contenttype);	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	list<nodefile> files = computenode.listnodefiles(recursive: true).tolist();	foreach (nodefile nodefile in files) {	}	string filepathtoget = string.format("workitems/{0}/{1}/{2}/{3}", jobid, "job-1", taskid, stdoutfilename);	file = computenode.getnodefile(filepathtoget);	
file has last modified time 

public void bug1501413testgetnodefilebytask() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	joboperations joboperations = batchcli.joboperations;	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-bug1501413testgetnodefilebytask";	try {	cloudjob job = joboperations.createjob(jobid, new poolinformation());	job.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	
initial job schedule commit 

public void bug1501413testgetnodefilebytask() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	joboperations joboperations = batchcli.joboperations;	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-bug1501413testgetnodefilebytask";	try {	cloudjob job = joboperations.createjob(jobid, new poolinformation());	job.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	job.commit();	
waiting for job 

joboperations joboperations = batchcli.joboperations;	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-bug1501413testgetnodefilebytask";	try {	cloudjob job = joboperations.createjob(jobid, new poolinformation());	job.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	job.commit();	cloudjob boundjob = joboperations.getjob(jobid);	const string taskid = "t1";	const string taskmessage = "this is a test";	
adding task 

try {	cloudjob job = joboperations.createjob(jobid, new poolinformation());	job.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	job.commit();	cloudjob boundjob = joboperations.getjob(jobid);	const string taskid = "t1";	const string taskmessage = "this is a test";	cloudtask task = new cloudtask(taskid, string.format("cmd /c echo {0}", taskmessage));	boundjob.addtask(task);	
waiting for the task to complete 

poolid = this.poolfixture.poolid };	job.commit();	cloudjob boundjob = joboperations.getjob(jobid);	const string taskid = "t1";	const string taskmessage = "this is a test";	cloudtask task = new cloudtask(taskid, string.format("cmd /c echo {0}", taskmessage));	boundjob.addtask(task);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( joboperations.listtasks(jobid), taskstate.completed, timespan.fromseconds(30));	
downloading the stdout for the file 

cloudjob boundjob = joboperations.getjob(jobid);	const string taskid = "t1";	const string taskmessage = "this is a test";	cloudtask task = new cloudtask(taskid, string.format("cmd /c echo {0}", taskmessage));	boundjob.addtask(task);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( joboperations.listtasks(jobid), taskstate.completed, timespan.fromseconds(30));	nodefile file = joboperations.getnodefile(jobid, taskid, "stdout.txt");	string data = file.readasstring(encoding: encoding.utf8);	
data 

========================= azure_sdk sample_5799 =========================

public void exceptionsthrowndirectlybyrestproxydontchange() {	const string exceptionnamecapturegroup = "exceptionname";	string pattern = getexceptioncaptureregex(exceptionnamecapturegroup);	sourceparser sourceparser = new sourceparser(this.proxysourcelocation, sourcefiletype, null, pattern);	list<sourceparserresult> results = sourceparser.parse().tolist();	const int expectedexceptioncount = 100;	
found strings 

string pattern = getexceptioncaptureregex(exceptionnamecapturegroup);	sourceparser sourceparser = new sourceparser(this.proxysourcelocation, sourcefiletype, null, pattern);	list<sourceparserresult> results = sourceparser.parse().tolist();	const int expectedexceptioncount = 100;	assert.true(results.count > expectedexceptioncount);	hashset<string> exceptionset = new hashset<string>();	foreach (sourceparserresult parserresult in results) {	string exceptionname = parserresult.match.groups[exceptionnamecapturegroup].value;	exceptionset.add(exceptionname);	}	
found types of exception thrown by rest proxy 

string pattern = getexceptioncaptureregex(exceptionnamecapturegroup);	sourceparser sourceparser = new sourceparser(this.proxysourcelocation, sourcefiletype, null, pattern);	list<sourceparserresult> results = sourceparser.parse().tolist();	const int expectedexceptioncount = 100;	assert.true(results.count > expectedexceptioncount);	hashset<string> exceptionset = new hashset<string>();	foreach (sourceparserresult parserresult in results) {	string exceptionname = parserresult.match.groups[exceptionnamecapturegroup].value;	exceptionset.add(exceptionname);	}	
exceptions 

public void exceptionsthrowndirectlybyobjectmodeldontchange() {	const string exceptionnamecapturegroup = "exceptionname";	string pattern = getexceptioncaptureregex(exceptionnamecapturegroup);	sourceparser sourceparser = new sourceparser(this.sourcelocation, sourcefiletype, generatedprotocolfolder, pattern);	list<sourceparserresult> results = sourceparser.parse().tolist();	const int expectedexceptioncount = 50;	
found strings 

string pattern = getexceptioncaptureregex(exceptionnamecapturegroup);	sourceparser sourceparser = new sourceparser(this.sourcelocation, sourcefiletype, generatedprotocolfolder, pattern);	list<sourceparserresult> results = sourceparser.parse().tolist();	const int expectedexceptioncount = 50;	assert.true(results.count > expectedexceptioncount);	hashset<string> exceptionset = new hashset<string>();	foreach (sourceparserresult parserresult in results) {	string exceptionname = parserresult.match.groups[exceptionnamecapturegroup].value;	exceptionset.add(exceptionname);	}	
found types of exception thrown by object model 

string pattern = getexceptioncaptureregex(exceptionnamecapturegroup);	sourceparser sourceparser = new sourceparser(this.sourcelocation, sourcefiletype, generatedprotocolfolder, pattern);	list<sourceparserresult> results = sourceparser.parse().tolist();	const int expectedexceptioncount = 50;	assert.true(results.count > expectedexceptioncount);	hashset<string> exceptionset = new hashset<string>();	foreach (sourceparserresult parserresult in results) {	string exceptionname = parserresult.match.groups[exceptionnamecapturegroup].value;	exceptionset.add(exceptionname);	}	
exceptions 

public void dotwaitanddotresultareneverused() {	const string pattern = "(?<! sourceparser sourceparser = new sourceparser(this.sourcelocation, sourcefiletype, null, pattern);	list<sourceparserresult> results = sourceparser.parse().tolist();	results.remove(results.first(r => r.file.contains("utilitiesinternal.cs")));	results.remove(results.first(r => r.file.contains("synchronousmethodexceptionbehavior.cs")));	foreach (sourceparserresult parserresult in results) {	
found wait or result in at 

========================= azure_sdk sample_6447 =========================

for (int i = 0; i < 50; i++) {	cloudtask curtask = new cloudtask("bug957878-task-" + i.tostring(), "hostname");	thejob.addtask(curtask);	numtaskscreated++;	}	int numtasksseen = 0;	bug957878replacementinterceptorbox box0 = new bug957878replacementinterceptorbox(this.testoutputhelper);	foreach (cloudtask curtask in thejob.listtasks(additionalbehaviors: new[] {	new microsoft.azure.batch.protocol.requestreplacementinterceptor(box0.bug957878requestreplacementinterceptoropcontextfactory)})) {	numtasksseen++;	
task id 

numtaskscreated++;	}	int numtasksseen = 0;	bug957878replacementinterceptorbox box0 = new bug957878replacementinterceptorbox(this.testoutputhelper);	foreach (cloudtask curtask in thejob.listtasks(additionalbehaviors: new[] {	new microsoft.azure.batch.protocol.requestreplacementinterceptor(box0.bug957878requestreplacementinterceptoropcontextfactory)})) {	numtasksseen++;	}	assert.equal(numtaskscreated, numtasksseen);	assert.true(box0.numtimescalled >= 10);	
total tasks created 

numtaskscreated++;	}	int numtasksseen = 0;	bug957878replacementinterceptorbox box0 = new bug957878replacementinterceptorbox(this.testoutputhelper);	foreach (cloudtask curtask in thejob.listtasks(additionalbehaviors: new[] {	new microsoft.azure.batch.protocol.requestreplacementinterceptor(box0.bug957878requestreplacementinterceptoropcontextfactory)})) {	numtasksseen++;	}	assert.equal(numtaskscreated, numtasksseen);	assert.true(box0.numtimescalled >= 10);	
total tasks enumerated 

public void bug1719609odatadetaillevel() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	
job schedule tests 

}	finally {	list<task> jobscheduledeletions = new list<task>();	foreach (string id in jobscheduleids) {	task t = testutilities.deletejobscheduleifexistsasync(batchcli, id);	jobscheduledeletions.add(t);	}	task.whenall(jobscheduledeletions).wait();	}	}	
job tests 

cloudjob lowdetaillevel = listfewerprops.single();	assert.equal(listallprops[0].id, lowdetaillevel.id);	assert.notequal(listallprops[0].creationtime, lowdetaillevel.creationtime);	lowdetaillevel.refresh();	assert.equal(listallprops[0].creationtime, lowdetaillevel.creationtime);	lowdetaillevel = batchcli.joboperations.getjob(lowdetaillevel.id);	assert.equal(listallprops[0].creationtime, lowdetaillevel.creationtime);	lowdetaillevel.refresh(detaillevel: new odatadetaillevel() { selectclause = "id,state" });	assert.notequal(listallprops[0].creationtime, lowdetaillevel.creationtime);	}	
task tests 

matchingallpropstask = curallpropstask;	}	}	assert.notnull(matchingallpropstask);	assert.notequal(matchingallpropstask.creationtime, lowerdetailtask.creationtime);	lowerdetailtask.refresh();	assert.equal(matchingallpropstask.creationtime, lowerdetailtask.creationtime);	matchingallpropstask.refresh(detaillevel: new odatadetaillevel() { selectclause = "id,state" });	assert.notequal(lowerdetailtask.creationtime, matchingallpropstask.creationtime);	}	
task file tests 

action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	const string testname = "bug1996130_resourcedoublerefreshdoesntwork";	const string taskid = "bug1996130_resourcedoublerefreshdoesntwork_task1";	string jobscheduleid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-" + testname;	try {	cloudjobschedule jobschedule = batchcli.jobscheduleoperations.createjobschedule(jobscheduleid, null, null);	jobschedule.jobspecification = new jobspecification(new poolinformation() {	poolid = this.poolfixture.poolid });	jobschedule.schedule = new schedule() { recurrenceinterval = timespan.fromminutes(1) };	
initial job schedule commit 

try {	cloudjobschedule jobschedule = batchcli.jobscheduleoperations.createjobschedule(jobscheduleid, null, null);	jobschedule.jobspecification = new jobspecification(new poolinformation() {	poolid = this.poolfixture.poolid });	jobschedule.schedule = new schedule() { recurrenceinterval = timespan.fromminutes(1) };	jobschedule.commit();	cloudjobschedule boundjobschedule = testutilities.waitforjobonjobschedule(batchcli.jobscheduleoperations, jobscheduleid);	cloudjob boundjob = batchcli.joboperations.getjob(boundjobschedule.executioninformation.recentjob.id);	string jobid = boundjob.id;	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	
adding task 

jobschedule.schedule = new schedule() { recurrenceinterval = timespan.fromminutes(1) };	jobschedule.commit();	cloudjobschedule boundjobschedule = testutilities.waitforjobonjobschedule(batchcli.jobscheduleoperations, jobscheduleid);	cloudjob boundjob = batchcli.joboperations.getjob(boundjobschedule.executioninformation.recentjob.id);	string jobid = boundjob.id;	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	
refreshing job schedule 

jobschedule.commit();	cloudjobschedule boundjobschedule = testutilities.waitforjobonjobschedule(batchcli.jobscheduleoperations, jobscheduleid);	cloudjob boundjob = batchcli.joboperations.getjob(boundjobschedule.executioninformation.recentjob.id);	string jobid = boundjob.id;	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	boundjobschedule.refresh();	
refreshing job schedule 

cloudjobschedule boundjobschedule = testutilities.waitforjobonjobschedule(batchcli.jobscheduleoperations, jobscheduleid);	cloudjob boundjob = batchcli.joboperations.getjob(boundjobschedule.executioninformation.recentjob.id);	string jobid = boundjob.id;	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	boundjobschedule.refresh();	boundjobschedule.refresh();	
refreshing job 

cloudjob boundjob = batchcli.joboperations.getjob(boundjobschedule.executioninformation.recentjob.id);	string jobid = boundjob.id;	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	boundjobschedule.refresh();	boundjobschedule.refresh();	boundjob.refresh();	
refreshing job 

string jobid = boundjob.id;	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	boundjobschedule.refresh();	boundjobschedule.refresh();	boundjob.refresh();	boundjob.refresh();	
refreshing task 

cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	boundjobschedule.refresh();	boundjobschedule.refresh();	boundjob.refresh();	boundjob.refresh();	boundtask.refresh();	
refreshing task 

cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	boundjobschedule.refresh();	boundjobschedule.refresh();	boundjob.refresh();	boundjob.refresh();	boundtask.refresh();	boundtask.refresh();	nodefile nodefile = boundtask.getnodefile("stdout.txt");	
refreshing task file 

taskstatemonitor statemonitor = batchcli.utilities.createtaskstatemonitor();	statemonitor.waitall(new list<cloudtask> { boundtask }, taskstate.completed, timespan.fromminutes(2));	boundjobschedule.refresh();	boundjobschedule.refresh();	boundjob.refresh();	boundjob.refresh();	boundtask.refresh();	boundtask.refresh();	nodefile nodefile = boundtask.getnodefile("stdout.txt");	nodefile.refresh();	
refreshing task file 

boundjobschedule.refresh();	boundjobschedule.refresh();	boundjob.refresh();	boundjob.refresh();	boundtask.refresh();	boundtask.refresh();	nodefile nodefile = boundtask.getnodefile("stdout.txt");	nodefile.refresh();	nodefile.refresh();	cloudpool boundpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	
refreshing pool 

boundjobschedule.refresh();	boundjob.refresh();	boundjob.refresh();	boundtask.refresh();	boundtask.refresh();	nodefile nodefile = boundtask.getnodefile("stdout.txt");	nodefile.refresh();	nodefile.refresh();	cloudpool boundpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	boundpool.refresh();	
refreshing pool 

boundjob.refresh();	boundtask.refresh();	boundtask.refresh();	nodefile nodefile = boundtask.getnodefile("stdout.txt");	nodefile.refresh();	nodefile.refresh();	cloudpool boundpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	boundpool.refresh();	boundpool.refresh();	computenode computenode = boundpool.listcomputenodes().first();	
refreshing compute node 

boundtask.refresh();	boundtask.refresh();	nodefile nodefile = boundtask.getnodefile("stdout.txt");	nodefile.refresh();	nodefile.refresh();	cloudpool boundpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	boundpool.refresh();	boundpool.refresh();	computenode computenode = boundpool.listcomputenodes().first();	computenode.refresh();	
refreshing compute node 

try {	int interceptorcount = 0;	batchcli.custombehaviors.add(new protocol.requestinterceptor((o) => { interceptorcount++; this.testoutputhelper.writeline("test: random interceptor"); }));	string taskidhello;	{	int presetupcount = interceptorcount;	cloudpool sharedpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	testutilities.helloworld(batchcli, this.testoutputhelper, sharedpool, out bug1959324jobid, out taskidhello, deletejob: false);	assert.true(interceptorcount > presetupcount);	}	
listnodefiles 

string taskidhello;	{	int presetupcount = interceptorcount;	cloudpool sharedpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	testutilities.helloworld(batchcli, this.testoutputhelper, sharedpool, out bug1959324jobid, out taskidhello, deletejob: false);	assert.true(interceptorcount > presetupcount);	}	int prelistnodefilescount = interceptorcount;	var files = batchcli.joboperations.listnodefiles(bug1959324jobid, taskidhello, recursive: true).tolist();	assert.true(interceptorcount > prelistnodefilescount);	
listjobs 

cloudpool sharedpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	testutilities.helloworld(batchcli, this.testoutputhelper, sharedpool, out bug1959324jobid, out taskidhello, deletejob: false);	assert.true(interceptorcount > presetupcount);	}	int prelistnodefilescount = interceptorcount;	var files = batchcli.joboperations.listnodefiles(bug1959324jobid, taskidhello, recursive: true).tolist();	assert.true(interceptorcount > prelistnodefilescount);	int prelistjobscount = interceptorcount;	var jobs = batchcli.joboperations.listjobs().tolist();	assert.true(interceptorcount > prelistjobscount);	
listpools 

}	int prelistnodefilescount = interceptorcount;	var files = batchcli.joboperations.listnodefiles(bug1959324jobid, taskidhello, recursive: true).tolist();	assert.true(interceptorcount > prelistnodefilescount);	int prelistjobscount = interceptorcount;	var jobs = batchcli.joboperations.listjobs().tolist();	assert.true(interceptorcount > prelistjobscount);	int prelistpoolscount = interceptorcount;	var pools = batchcli.pooloperations.listpools().tolist();	assert.true(interceptorcount > prelistpoolscount);	
getjob yield injector test 

int prelistnodefilescount = interceptorcount;	var files = batchcli.joboperations.listnodefiles(bug1959324jobid, taskidhello, recursive: true).tolist();	assert.true(interceptorcount > prelistnodefilescount);	int prelistjobscount = interceptorcount;	var jobs = batchcli.joboperations.listjobs().tolist();	assert.true(interceptorcount > prelistjobscount);	int prelistpoolscount = interceptorcount;	var pools = batchcli.pooloperations.listpools().tolist();	assert.true(interceptorcount > prelistpoolscount);	protocol.batchrequestmodificationintercepthandler yieldinjectioninterceptor = baserequest => {	
yield injector 

assert.true(interceptorcount > prelistnodefilescount);	int prelistjobscount = interceptorcount;	var jobs = batchcli.joboperations.listjobs().tolist();	assert.true(interceptorcount > prelistjobscount);	int prelistpoolscount = interceptorcount;	var pools = batchcli.pooloperations.listpools().tolist();	assert.true(interceptorcount > prelistpoolscount);	protocol.batchrequestmodificationintercepthandler yieldinjectioninterceptor = baserequest => {	var request = (jobgetbatchrequest)baserequest;	request.servicerequestfunc = (token) => { return request.restclient.job.getwithhttpmessagesasync(bug1959324jobid, request.options, cancellationtoken: token); };	
leaving yield injector 

var jobs = batchcli.joboperations.listjobs().tolist();	assert.true(interceptorcount > prelistjobscount);	int prelistpoolscount = interceptorcount;	var pools = batchcli.pooloperations.listpools().tolist();	assert.true(interceptorcount > prelistpoolscount);	protocol.batchrequestmodificationintercepthandler yieldinjectioninterceptor = baserequest => {	var request = (jobgetbatchrequest)baserequest;	request.servicerequestfunc = (token) => { return request.restclient.job.getwithhttpmessagesasync(bug1959324jobid, request.options, cancellationtoken: token); };	};	cloudjob boundjob = batchcli.joboperations.getjob( "test value that can't possibly be found as a job id", additionalbehaviors: new[] { new protocol.requestinterceptor(yieldinjectioninterceptor) });	
done got job 

cloudjobschedule boundjobschedule = null;	{	string jobscheduleid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-" + testname;	try {	cloudpool pool = pooloperations.getpool(this.poolfixture.poolid);	pool.metadata = new list<metadataitem>();	pool.metadata.add(new metadataitem("test", "test"));	pool.commit();	pool = pooloperations.getpool(this.poolfixture.poolid);	assert.equal(1, pool.metadata.count);	
creating job schedule 

assert.null(poolspecification.metadata);	poolspecification.metadata = new list<metadataitem>() { new metadataitem("test", "test") };	poolinformation poolinformation = new poolinformation() {	autopoolspecification = new autopoolspecification() {	keepalive = false, poolspecification = poolspecification, poollifetimeoption = poollifetimeoption.jobschedule }	};	unboundjobschedule.jobspecification = new jobspecification(poolinformation) {	jobmanagertask = jm, };	unboundjobschedule.schedule = new schedule() { recurrenceinterval = timespan.fromminutes(6) };	unboundjobschedule.commit();	
getting job schedule to ensure that ilist properties were set correctly on server 

assert.equal(1, boundjobschedule.metadata.count);	assert.equal(1, boundjobschedule.jobspecification.jobmanagertask.environmentsettings.count);	assert.equal(1, boundjobschedule.jobspecification.jobmanagertask.resourcefiles.count);	assert.equal(1, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.count);	assert.equal(1, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.count);	assert.equal(1, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.resourcefiles.count);	boundjobschedule.metadata.add(new metadataitem("abc", "abc"));	boundjobschedule.jobspecification.jobmanagertask.resourcefiles.add(new resourcefile("http: boundjobschedule.jobspecification.jobmanagertask.environmentsettings.add(new environmentsetting("abc", "abc"));	boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.add(new metadataitem("abc", "abc"));	boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.add(new environmentsetting("abc", "abc"));	
http this testoutputhelper writeline added 

assert.equal(1, boundjobschedule.jobspecification.jobmanagertask.environmentsettings.count);	assert.equal(1, boundjobschedule.jobspecification.jobmanagertask.resourcefiles.count);	assert.equal(1, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.count);	assert.equal(1, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.count);	assert.equal(1, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.resourcefiles.count);	boundjobschedule.metadata.add(new metadataitem("abc", "abc"));	boundjobschedule.jobspecification.jobmanagertask.resourcefiles.add(new resourcefile("http: boundjobschedule.jobspecification.jobmanagertask.environmentsettings.add(new environmentsetting("abc", "abc"));	boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.add(new metadataitem("abc", "abc"));	boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.add(new environmentsetting("abc", "abc"));	boundjobschedule.commit();	
getting job schedule to ensure that ilist properties were set correctly on server 

boundjobschedule = jobscheduleoperations.getjobschedule(jobscheduleid);	assert.equal(2, boundjobschedule.metadata.count);	assert.equal(2, boundjobschedule.jobspecification.jobmanagertask.environmentsettings.count);	assert.equal(2, boundjobschedule.jobspecification.jobmanagertask.resourcefiles.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.resourcefiles.count);	boundjobschedule.metadata = null;	boundjobschedule.jobspecification.jobmanagertask.resourcefiles = null;	boundjobschedule.jobspecification.jobmanagertask.environmentsettings = null;	
commiting updated job schedule with some ilist stuff removed 

assert.equal(2, boundjobschedule.metadata.count);	assert.equal(2, boundjobschedule.jobspecification.jobmanagertask.environmentsettings.count);	assert.equal(2, boundjobschedule.jobspecification.jobmanagertask.resourcefiles.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.resourcefiles.count);	boundjobschedule.metadata = null;	boundjobschedule.jobspecification.jobmanagertask.resourcefiles = null;	boundjobschedule.jobspecification.jobmanagertask.environmentsettings = null;	boundjobschedule.commit();	
getting job schedule to ensure that ilist properties were removed correctly on server 

boundjobschedule = jobscheduleoperations.getjobschedule(jobscheduleid);	assert.null(boundjobschedule.metadata);	assert.null(boundjobschedule.jobspecification.jobmanagertask.environmentsettings);	assert.null(boundjobschedule.jobspecification.jobmanagertask.resourcefiles);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.count);	assert.equal(2, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.resourcefiles.count);	boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.metadata.removeat(0);	boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.starttask.environmentsettings.removeat(1);	boundjobschedule.commit();	
getting job schedule to ensure that ilist properties were removed correctly on server 

poolinformation poolinfo = new poolinformation();	poolinfo.autopoolspecification = autopoolspec;	jobspecification jobspec = new jobspecification(poolinfo);	jobspec.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundjobschedule.displayname);	jobspec.jobmanagertask = jobmanager;	unboundjobschedule.jobspecification = jobspec;	schedule schedule = new schedule();	schedule.donotrununtil = datetime.now.addyears(1);	unboundjobschedule.schedule = schedule;	
creating job schedule 

schedule schedule = new schedule();	schedule.donotrununtil = datetime.now.addyears(1);	unboundjobschedule.schedule = schedule;	unboundjobschedule.commit();	try {	cloudjobschedule boundjobschedule = batchcli.jobscheduleoperations.getjobschedule(jobscheduleid);	assert.equal(originaldisplayname, boundjobschedule.displayname);	assert.equal(originaldisplayname, boundjobschedule.jobspecification.displayname);	assert.equal(originaldisplayname, boundjobschedule.jobspecification.jobmanagertask.displayname);	assert.equal(originaldisplayname, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.displayname);	
attempting to set display names on job schedule job specification pool specification and job manager task 

assert.equal(originaldisplayname, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.displayname);	testutilities.assertthrows<invalidoperationexception>(() => boundjobschedule.displayname = updateddisplayname);	boundjobschedule.jobspecification.displayname = updateddisplayname;	boundjobschedule.jobspecification.jobmanagertask.displayname = updateddisplayname;	boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.displayname = updateddisplayname;	assert.equal(updateddisplayname, boundjobschedule.jobspecification.displayname);	assert.equal(updateddisplayname, boundjobschedule.jobspecification.jobmanagertask.displayname);	assert.equal(updateddisplayname, boundjobschedule.jobspecification.poolinformation.autopoolspecification.poolspecification.displayname);	}	finally {	
deleting job schedule 

}	finally {	batchcli.jobscheduleoperations.deletejobschedule(jobscheduleid);	}	string jobid = testname + "_job_" + testutilities.getmyname();	cloudjob unboundjob = batchcli.joboperations.createjob();	unboundjob.id = jobid;	unboundjob.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundjob.displayname);	unboundjob.poolinformation = new poolinformation() { poolid = this.poolfixture.poolid };	
creating job 

string jobid = testname + "_job_" + testutilities.getmyname();	cloudjob unboundjob = batchcli.joboperations.createjob();	unboundjob.id = jobid;	unboundjob.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundjob.displayname);	unboundjob.poolinformation = new poolinformation() { poolid = this.poolfixture.poolid };	unboundjob.commit();	try {	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	assert.equal(originaldisplayname, boundjob.displayname);	
attempting to set display name on job 

unboundjob.poolinformation = new poolinformation() { poolid = this.poolfixture.poolid };	unboundjob.commit();	try {	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	assert.equal(originaldisplayname, boundjob.displayname);	testutilities.assertthrows<invalidoperationexception>(() => boundjob.displayname = updateddisplayname);	string taskid = testname + "_task_" + testutilities.getmyname();	cloudtask unboundtask = new cloudtask(taskid, "cmd /c echo hi");	unboundtask.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundtask.displayname);	
adding task to job 

assert.equal(originaldisplayname, boundjob.displayname);	testutilities.assertthrows<invalidoperationexception>(() => boundjob.displayname = updateddisplayname);	string taskid = testname + "_task_" + testutilities.getmyname();	cloudtask unboundtask = new cloudtask(taskid, "cmd /c echo hi");	unboundtask.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundtask.displayname);	boundjob.addtask(unboundtask);	try {	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	assert.equal(originaldisplayname, boundtask.displayname);	
attempting to set display name on task 

cloudtask unboundtask = new cloudtask(taskid, "cmd /c echo hi");	unboundtask.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundtask.displayname);	boundjob.addtask(unboundtask);	try {	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	assert.equal(originaldisplayname, boundtask.displayname);	testutilities.assertthrows<invalidoperationexception>(() => boundtask.displayname = updateddisplayname);	}	finally {	
deleting task 

try {	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	assert.equal(originaldisplayname, boundtask.displayname);	testutilities.assertthrows<invalidoperationexception>(() => boundtask.displayname = updateddisplayname);	}	finally {	batchcli.joboperations.deletetask(jobid, taskid);	}	}	finally {	
deleting job 

batchcli.joboperations.deletetask(jobid, taskid);	}	}	finally {	batchcli.joboperations.deletejob(jobid);	}	string poolid = testname + "_pool_" + testutilities.getmyname();	cloudpool unboundpool = batchcli.pooloperations.createpool(poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), 0);	unboundpool.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundpool.displayname);	
creating pool 

batchcli.joboperations.deletejob(jobid);	}	string poolid = testname + "_pool_" + testutilities.getmyname();	cloudpool unboundpool = batchcli.pooloperations.createpool(poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), 0);	unboundpool.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundpool.displayname);	unboundpool.commit();	try {	cloudpool boundpool = batchcli.pooloperations.getpool(poolid);	assert.equal(originaldisplayname, boundpool.displayname);	
attempting to set display name on pool 

cloudpool unboundpool = batchcli.pooloperations.createpool(poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), 0);	unboundpool.displayname = originaldisplayname;	assert.equal(originaldisplayname, unboundpool.displayname);	unboundpool.commit();	try {	cloudpool boundpool = batchcli.pooloperations.getpool(poolid);	assert.equal(originaldisplayname, boundpool.displayname);	testutilities.assertthrows<invalidoperationexception>(() => boundpool.displayname = updateddisplayname);	}	finally {	
deleting pool 

return false;	}	private class bug957878replacementinterceptorbox {	public int numtimescalled { get; private set; }	private readonly itestoutputhelper testoutputhelper;	public bug957878replacementinterceptorbox(itestoutputhelper testoutputhelper) {	this.testoutputhelper = testoutputhelper;	}	internal void bug957878requestreplacementinterceptoropcontextfactory(ref protocol.ibatchrequest batchrequest) {	this.numtimescalled++;	
movenextasync call to server 

cloudpool unboundpool = batchcli.pooloperations.createpool( poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetdedicatedcomputenodes: 0);	bug1770942retrypolicy retrypolicy = new bug1770942retrypolicy(this.testoutputhelper);	testutilities.assertthrows<batchexception>(() => unboundpool.commit(new[] { new retrypolicyprovider(retrypolicy) }));	assert.equal(3, retrypolicy.numtimescalled);	}	{	foreach (string poolid in poolidstocreate) {	cloudpool unboundpool = batchcli.pooloperations.createpool( poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetdedicatedcomputenodes: 0);	unboundpool.commit();	}	
all pools 

{	foreach (string poolid in poolidstocreate) {	cloudpool unboundpool = batchcli.pooloperations.createpool( poolid, poolfixture.vmsize, new cloudserviceconfiguration(poolfixture.osfamily), targetdedicatedcomputenodes: 0);	unboundpool.commit();	}	var allpools = batchcli.pooloperations.listpools();	testutilities.displaypools(this.testoutputhelper, allpools);	var oddienum = batchcli.pooloperations.listpools(new odatadetaillevel() {	filterclause = "startswith(id, 'odd')", selectclause = "id,state" });	list<cloudpool> oddlist = new list<cloudpool>(oddienum);	
odd pools 

}	var allpools = batchcli.pooloperations.listpools();	testutilities.displaypools(this.testoutputhelper, allpools);	var oddienum = batchcli.pooloperations.listpools(new odatadetaillevel() {	filterclause = "startswith(id, 'odd')", selectclause = "id,state" });	list<cloudpool> oddlist = new list<cloudpool>(oddienum);	testutilities.displaypools(this.testoutputhelper, oddienum);	var evenienum = batchcli.pooloperations.listpools(new odatadetaillevel() {	filterclause = "startswith(id, 'even')", selectclause = "id,state" });	list<cloudpool> evenlist = new list<cloudpool>(evenienum);	
even pools 

}	#region test helpers private class bug1770942retrypolicy : iretrypolicy {	public int numtimescalled { get; private set; }	private readonly itestoutputhelper testoutputhelper;	public bug1770942retrypolicy(itestoutputhelper testoutputhelper) {	this.testoutputhelper = testoutputhelper;	}	public task<retrydecision> shouldretryasync(exception exception, operationcontext operationcontext) {	timespan retryinterval = timespan.zero;	this.numtimescalled++;	
exception 

========================= azure_sdk sample_5808 =========================

var context = new authenticationcontext(authority, tokencache);	var result = await context.acquiretokenasync(resource, clientcredential).configureawait(false);	return result.accesstoken;	}	public async task<string> getuseraccesstoken(string authority, string resource, string scope) {	string clientid = testconfigurationmanager.trygetenvironmentorappsetting("nativeclientid");	var context = new authenticationcontext(authority, tokencache);	if (_devicecodeforstoragetests == null) {	_devicecodeforstoragetests = await context.acquiredevicecodeasync(resource, clientid).configureawait(false);	debug.writeline("############################################################################################");	
test won t run until you perform following steps 

var context = new authenticationcontext(authority, tokencache);	var result = await context.acquiretokenasync(resource, clientcredential).configureawait(false);	return result.accesstoken;	}	public async task<string> getuseraccesstoken(string authority, string resource, string scope) {	string clientid = testconfigurationmanager.trygetenvironmentorappsetting("nativeclientid");	var context = new authenticationcontext(authority, tokencache);	if (_devicecodeforstoragetests == null) {	_devicecodeforstoragetests = await context.acquiredevicecodeasync(resource, clientid).configureawait(false);	debug.writeline("############################################################################################");	
go to following url devicecodeforstoragetests verificationurl 

var context = new authenticationcontext(authority, tokencache);	var result = await context.acquiretokenasync(resource, clientcredential).configureawait(false);	return result.accesstoken;	}	public async task<string> getuseraccesstoken(string authority, string resource, string scope) {	string clientid = testconfigurationmanager.trygetenvironmentorappsetting("nativeclientid");	var context = new authenticationcontext(authority, tokencache);	if (_devicecodeforstoragetests == null) {	_devicecodeforstoragetests = await context.acquiredevicecodeasync(resource, clientid).configureawait(false);	debug.writeline("############################################################################################");	
insert following user code devicecodeforstoragetests usercode 

var context = new authenticationcontext(authority, tokencache);	var result = await context.acquiretokenasync(resource, clientcredential).configureawait(false);	return result.accesstoken;	}	public async task<string> getuseraccesstoken(string authority, string resource, string scope) {	string clientid = testconfigurationmanager.trygetenvironmentorappsetting("nativeclientid");	var context = new authenticationcontext(authority, tokencache);	if (_devicecodeforstoragetests == null) {	_devicecodeforstoragetests = await context.acquiredevicecodeasync(resource, clientid).configureawait(false);	debug.writeline("############################################################################################");	
login with your username and password credentials 

========================= azure_sdk sample_2249 =========================

public void testireadonlymakespropertiesreadonly() {	type ireadonlytype = typeof(ireadonly);	list<type> typeswithireadonlybase = gettypeswhichimplementinterface(ireadonlytype.gettypeinfo().assembly, ireadonlytype, requirepublicconstructor: false).tolist();	foreach (type type in typeswithireadonlybase) {	
reading setting properties of type 

public void testireadonlymakespropertiesreadonly() {	type ireadonlytype = typeof(ireadonly);	list<type> typeswithireadonlybase = gettypeswhichimplementinterface(ireadonlytype.gettypeinfo().assembly, ireadonlytype, requirepublicconstructor: false).tolist();	foreach (type type in typeswithireadonlybase) {	ireadonly objectundertest = this.customizedobjectfactory.createinstance<ireadonly>(type);	objectundertest.isreadonly = true;	ienumerable<propertyinfo> properties = type.getproperties(bindingflags.public | bindingflags.instance);	foreach (propertyinfo property in properties.where(p => p.name != "custombehaviors")) {	if (property.canwrite) {	
attempting to write property 

foreach (type type in typeswithireadonlybase) {	ireadonly objectundertest = this.customizedobjectfactory.createinstance<ireadonly>(type);	objectundertest.isreadonly = true;	ienumerable<propertyinfo> properties = type.getproperties(bindingflags.public | bindingflags.instance);	foreach (propertyinfo property in properties.where(p => p.name != "custombehaviors")) {	if (property.canwrite) {	targetinvocationexception e = assert.throws<targetinvocationexception>(() => property.setvalue(objectundertest, null));	assert.istype<invalidoperationexception>(e.innerexception);	}	if (property.canread) {	
attempting to read property 

public void testgettransportobjectdoesntmissproperties() {	const int objectstovalidate = 100;	type itransportobjectprovidertype = typeof(itransportobjectprovider<>);	ienumerable<type> types = gettypeswhichimplementinterface(itransportobjectprovidertype.gettypeinfo().assembly, itransportobjectprovidertype, requirepublicconstructor: false);	foreach (type type in types) {	
generating objects of type 

========================= azure_sdk sample_6462 =========================

public void bug1910530_concurrentchangetrackedlistthreadsafetest() {	const string testname = "bug1910530_concurrentchangetrackedlistthreadsafetest";	using(batchclient batchcli = batchclient.open(clientunittestcommon.createdummysharedkeycredential())) {	jobscheduleoperations jobscheduleoperations = batchcli.jobscheduleoperations;	string jobscheduleid = microsoft.azure.batch.constants.defaultconvenienceprefix + "-" + testname;	
creating job schedule 

public void bug1910530_concurrentchangetrackedlistthreadsafetest() {	const string testname = "bug1910530_concurrentchangetrackedlistthreadsafetest";	using(batchclient batchcli = batchclient.open(clientunittestcommon.createdummysharedkeycredential())) {	jobscheduleoperations jobscheduleoperations = batchcli.jobscheduleoperations;	string jobscheduleid = microsoft.azure.batch.constants.defaultconvenienceprefix + "-" + testname;	cloudjobschedule unboundjobschedule = jobscheduleoperations.createjobschedule(jobscheduleid, null, null);	unboundjobschedule.metadata = new list<metadataitem>();	action addaction = () => {	
adding an item 

const string testname = "bug1910530_concurrentchangetrackedlistthreadsafetest";	using(batchclient batchcli = batchclient.open(clientunittestcommon.createdummysharedkeycredential())) {	jobscheduleoperations jobscheduleoperations = batchcli.jobscheduleoperations;	string jobscheduleid = microsoft.azure.batch.constants.defaultconvenienceprefix + "-" + testname;	cloudjobschedule unboundjobschedule = jobscheduleoperations.createjobschedule(jobscheduleid, null, null);	unboundjobschedule.metadata = new list<metadataitem>();	action addaction = () => {	unboundjobschedule.metadata.add(new metadataitem("test", "test"));	};	action removeaction = () => {	
removing an item 

========================= azure_sdk sample_6446 =========================

topic topic = new topic() {	location = location, tags = originaltagsdictionary };	var createtopicresponse = this.eventgridmanagementclient.topics.createorupdate(resourcegroup, topicname, topic);	assert.notnull(createtopicresponse);	assert.equal(createtopicresponse.name, topicname);	testutilities.wait(timespan.fromseconds(60));	topicsharedaccesskeys keys = this.eventgridmanagementclient.topics.listsharedaccesskeys(resourcegroup, topicname);	string topichostname = new uri(createtopicresponse.endpoint).host;	topiccredentials topiccredentials = new topiccredentials(keys.key1);	eventgridclient client =  eventgridmanagementhelper.geteventgridclient( context, topiccredentials, new recordeddelegatinghandler { statuscodetoreturn = httpstatuscode.ok });	
publishing to azure event grid 

location = location, tags = originaltagsdictionary };	var createtopicresponse = this.eventgridmanagementclient.topics.createorupdate(resourcegroup, topicname, topic);	assert.notnull(createtopicresponse);	assert.equal(createtopicresponse.name, topicname);	testutilities.wait(timespan.fromseconds(60));	topicsharedaccesskeys keys = this.eventgridmanagementclient.topics.listsharedaccesskeys(resourcegroup, topicname);	string topichostname = new uri(createtopicresponse.endpoint).host;	topiccredentials topiccredentials = new topiccredentials(keys.key1);	eventgridclient client =  eventgridmanagementhelper.geteventgridclient( context, topiccredentials, new recordeddelegatinghandler { statuscodetoreturn = httpstatuscode.ok });	client.publisheventsasync(topichostname, geteventslist()).getawaiter().getresult();	
published successfully 

========================= azure_sdk sample_6650 =========================

var cerificatethumbprint = configurationmanager.appsettings["authcertthumbprint"];	var nativeclientid = "fc35ecf8-76f1-4e2c-a075-60d01dc4698f";	var certificate = findcertificatebythumbprint(cerificatethumbprint);	var assertioncert = new clientassertioncertificate(clientid, certificate);	keyvaultclient = new keyvaultclient(new keyvaultclient.authenticationcallback( (authority, resource, scope) => getaccesstoken(authority, resource, scope, assertioncert)), new injecthostheaderhttpmessagehandler());	userkeyvaultclient = new keyvaultclient(new keyvaultclient.authenticationcallback( (authority, resource, scope) => getuseraccesstoken(authority, resource, nativeclientid)), new injecthostheaderhttpmessagehandler());	list<keyoperationtype> successfuloperations = new list<keyoperationtype>();	list<keyoperationtype> failedoperations = new list<keyoperationtype>();	foreach (var operation in inputvalidator.getkeyoperations()) {	try {	
is in process 

case keyoperationtype.list_storage_sas_definition: listsasdefinitions(storageaccountname);	break;	case keyoperationtype.delete_storage_sas_definition: deletesasdefinition(storageaccountname, sasdefinitionname);	break;	case keyoperationtype.delete_storage_account: deletestorageaccount(storageaccountname);	break;	}	successfuloperations.add(operation);	}	catch (keyvaulterrorexception exception) {	
operation failed 

break;	case keyoperationtype.delete_storage_account: deletestorageaccount(storageaccountname);	break;	}	successfuloperations.add(operation);	}	catch (keyvaulterrorexception exception) {	failedoperations.add(operation);	}	}	
successful key vault operations 

break;	}	successfuloperations.add(operation);	}	catch (keyvaulterrorexception exception) {	failedoperations.add(operation);	}	}	foreach (keyoperationtype type in successfuloperations) console.out.writeline("\t{0}", type);	if (failedoperations.count > 0) {	
failed key vault operations 

private static keybundle updatekey(string keyname) {	var vaultaddress = inputvalidator.getvaultaddress();	keyname = (keyname == string.empty) ? inputvalidator.getkeyid() : keyname;	var keyattributes = inputvalidator.getupdatekeyattribute();	var updatedkey = task.run(() => keyvaultclient.updatekeyasync(vaultaddress, keyname, attributes: keyattributes)).configureawait(false).getawaiter().getresult();	
updated key 

private static keybundle importkey(out string keyname) {	var vaultaddress = inputvalidator.getvaultaddress();	keyname = inputvalidator.getkeyname();	var ishsm = inputvalidator.getkeytype() == jsonwebkeytype.rsahsm;	var keybundle = inputvalidator.getimportkeybundle();	var name = keyname;	var importedkey = task.run(() => keyvaultclient.importkeyasync(vaultaddress, name, keybundle, ishsm)).configureawait(false).getawaiter().getresult();	
imported key 

retrievedkey = task.run(() => keyvaultclient.getkeyasync(vaultaddress, keyname, keyversion)).configureawait(false).getawaiter().getresult();	}	else {	retrievedkey = task.run(() => keyvaultclient.getkeyasync(vaultaddress, keyname)).configureawait(false).getawaiter().getresult();	}	}	else {	var keyid = (key != null) ? key.key.kid : inputvalidator.getkeyid();	retrievedkey = task.run(() => keyvaultclient.getkeyasync(keyid)).configureawait(false).getawaiter().getresult();	}	
retrived key 

private static void listkeyversions(string keyname) {	var vaultaddress = inputvalidator.getvaultaddress();	keyname = (keyname == string.empty) ? inputvalidator.getkeyid() : keyname;	var numkeyversions = 0;	var maxresults = 1;	
list key versions 

numkeyversions += results.count();	foreach (var m in results) console.out.writeline("\t{0}-{1}", m.identifier.name, m.identifier.version);	}	while (results != null && !string.isnullorwhitespace(results.nextpagelink)) {	results = task.run(() => keyvaultclient.getkeyversionsnextasync(results.nextpagelink)).configureawait(false).getawaiter().getresult();	if (results != null) {	numkeyversions += results.count();	foreach (var m in results) console.out.writeline("\t{0}-{1}", m.identifier.name, m.identifier.version);	}	}	
number of versions of key in the vault 

private static keybundle createkey(keybundle keybundle, out string keyname) {	keybundle = keybundle ?? inputvalidator.getkeybundle();	var vaultaddress = inputvalidator.getvaultaddress();	keyname = inputvalidator.getkeyname();	var tags = inputvalidator.gettags();	var name = keyname;	var createdkey = task.run(() => keyvaultclient.createkeyasync(vaultaddress, name, keybundle.key.kty, keyattributes: keybundle.attributes, tags: tags)) .configureawait(false).getawaiter().getresult();	
created key 

private static secretbundle createsecret(out string secretname) {	secretname = inputvalidator.getsecretname();	string secretvalue = inputvalidator.getsecretvalue();	var tags = inputvalidator.gettags();	var contenttype = inputvalidator.getsecretcontenttype();	var name = secretname;	var secret = task.run(() => keyvaultclient.setsecretasync(inputvalidator.getvaultaddress(), name, secretvalue, tags, contenttype, inputvalidator.getsecretattributes())) .configureawait(false).getawaiter().getresult();	
created updated secret 

string secretversion = inputvalidator.getsecretversion();	if (secretversion != string.empty) {	var vaultaddress = inputvalidator.getvaultaddress();	string secretname = inputvalidator.getsecretname(true);	secret = task.run(() => keyvaultclient.getsecretasync(vaultaddress, secretname, secretversion)).configureawait(false).getawaiter().getresult();	}	else {	secretid = secretid ?? inputvalidator.getsecretid();	secret = task.run(() => keyvaultclient.getsecretasync(secretid)).configureawait(false).getawaiter().getresult();	}	
retrieved secret 

private static void listsecrets() {	var vaultaddress = inputvalidator.getvaultaddress();	var numsecretsinvault = 0;	var maxresults = 1;	
list secrets 

numsecretsinvault += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	while (results != null && !string.isnullorwhitespace(results.nextpagelink)) {	results = task.run(() => keyvaultclient.getsecretsnextasync(results.nextpagelink)).configureawait(false).getawaiter().getresult();	if (results != null) {	numsecretsinvault += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	}	
number of secrets in the vault 

private static secretbundle deletesecret(string secretname) {	var vaultaddress = inputvalidator.getvaultaddress();	secretname = (secretname == string.empty) ? inputvalidator.getsecretname() : secretname;	var secret = task.run(() => keyvaultclient.deletesecretasync(vaultaddress, secretname)).configureawait(false).getawaiter().getresult();	
deleted secret 

private static keybundle backuprestorekey(string keyname) {	var vaultaddress = inputvalidator.getvaultaddress();	keyname = inputvalidator.getkeyname();	var backupkeyresult = task.run(() => keyvaultclient.backupkeyasync(vaultaddress, keyname)).configureawait(false).getawaiter().getresult();	
the backup key value contains bytes to restore it into a key vault this value should be provided 

private static keybundle backuprestorekey(string keyname) {	var vaultaddress = inputvalidator.getvaultaddress();	keyname = inputvalidator.getkeyname();	var backupkeyresult = task.run(() => keyvaultclient.backupkeyasync(vaultaddress, keyname)).configureawait(false).getawaiter().getresult();	var newvaultaddress = inputvalidator.getvaultaddress();	task.run(() => keyvaultclient.deletekeyasync(vaultaddress, keyname)).configureawait(false).getawaiter().getresult();	var restoredkey = task.run(() => keyvaultclient.restorekeyasync(newvaultaddress, backupkeyresult.value)).configureawait(false).getawaiter().getresult();	
restored key 

private static void deletekey(string keyname) {	var vaultaddress = inputvalidator.getvaultaddress();	keyname = (keyname == string.empty) ? inputvalidator.getkeyname() : keyname;	var keybundle = task.run(() => keyvaultclient.deletekeyasync(vaultaddress, keyname)).configureawait(false).getawaiter().getresult();	
key is deleted successfully 

string keyversion = inputvalidator.getkeyversion();	if (keyversion != string.empty) {	var vaultaddress = inputvalidator.getvaultaddress();	string keyname = inputvalidator.getkeyname(true);	wrappedkey = task.run(() => keyvaultclient.wrapkeyasync(vaultaddress, keyname, keyversion, algorithm, symmetrickey)).configureawait(false).getawaiter().getresult();	}	else {	var keyid = (key != null) ? key.key.kid : inputvalidator.getkeyid();	wrappedkey = task.run(() => keyvaultclient.wrapkeyasync(keyid, algorithm, symmetrickey)).configureawait(false).getawaiter().getresult();	}	
the symmetric key is wrapped using key id and algorithm 

if (keyversion != string.empty) {	var vaultaddress = inputvalidator.getvaultaddress();	string keyname = inputvalidator.getkeyname(true);	wrappedkey = task.run(() => keyvaultclient.wrapkeyasync(vaultaddress, keyname, keyversion, algorithm, symmetrickey)).configureawait(false).getawaiter().getresult();	}	else {	var keyid = (key != null) ? key.key.kid : inputvalidator.getkeyid();	wrappedkey = task.run(() => keyvaultclient.wrapkeyasync(keyid, algorithm, symmetrickey)).configureawait(false).getawaiter().getresult();	}	var unwrappedkey = task.run(() => keyvaultclient.unwrapkeyasync(wrappedkey.kid, algorithm, wrappedkey.result)).configureawait(false).getawaiter().getresult();	
the unwrapped key is the same as the original key not 

private static void encryptdecrypt(keybundle key) {	keyoperationresult operationresult;	var algorithm = inputvalidator.getencryptionalgorithm();	var plaintext = inputvalidator.getplaintext();	string keyversion = inputvalidator.getkeyversion();	operationresult = _encrypt(key, keyversion, algorithm, plaintext);	
the text is encrypted using key id and algorithm 

private static void encryptdecrypt(keybundle key) {	keyoperationresult operationresult;	var algorithm = inputvalidator.getencryptionalgorithm();	var plaintext = inputvalidator.getplaintext();	string keyversion = inputvalidator.getkeyversion();	operationresult = _encrypt(key, keyversion, algorithm, plaintext);	var decryptedtext = task.run(() => keyvaultclient.decryptasync(operationresult.kid, algorithm, operationresult.result)).configureawait(false).getawaiter().getresult();	
the decrypted text is the same as the original key not 

private static void encryptdecrypt(keybundle key) {	keyoperationresult operationresult;	var algorithm = inputvalidator.getencryptionalgorithm();	var plaintext = inputvalidator.getplaintext();	string keyversion = inputvalidator.getkeyversion();	operationresult = _encrypt(key, keyversion, algorithm, plaintext);	var decryptedtext = task.run(() => keyvaultclient.decryptasync(operationresult.kid, algorithm, operationresult.result)).configureawait(false).getawaiter().getresult();	
the decrypted text is 

private static void encrypt(keybundle key) {	keyoperationresult  operationresult;	var algorithm = inputvalidator.getencryptionalgorithm();	var plaintext = inputvalidator.getplaintext();	string keyversion = inputvalidator.getkeyversion();	operationresult = _encrypt(key, keyversion, algorithm, plaintext);	file.writealltext("ciphertext.txt", convert.tobase64string(operationresult.result));	
the text is encrypted using key id and algorithm 

private static void encrypt(keybundle key) {	keyoperationresult  operationresult;	var algorithm = inputvalidator.getencryptionalgorithm();	var plaintext = inputvalidator.getplaintext();	string keyversion = inputvalidator.getkeyversion();	operationresult = _encrypt(key, keyversion, algorithm, plaintext);	file.writealltext("ciphertext.txt", convert.tobase64string(operationresult.result));	
encrypted text base encoded 

private static void decrypt(keybundle key) {	keyoperationresult operationresult;	var algorithm = inputvalidator.getencryptionalgorithm();	var ciphertext = inputvalidator.getciphertext();	keybundle   localkey;	localkey = (key ?? getkey(null));	operationresult = task.run(() => keyvaultclient.decryptasync(localkey.keyidentifier.tostring(), algorithm, ciphertext)).configureawait(false).getawaiter().getresult();	
the decrypted text is 

string keyversion = inputvalidator.getkeyversion();	if (keyversion != string.empty) {	var vaultaddress = inputvalidator.getvaultaddress();	string keyname = inputvalidator.getkeyname(true);	signature = task.run(() => keyvaultclient.signasync(vaultaddress, keyname, keyversion, algorithm, digest)).configureawait(false).getawaiter().getresult();	}	else {	var keyid = (key != null) ? key.key.kid : inputvalidator.getkeyid();	signature = task.run(() => keyvaultclient.signasync(keyid, algorithm, digest)).configureawait(false).getawaiter().getresult();	}	
the signature is created using key id and algorithm 

if (keyversion != string.empty) {	var vaultaddress = inputvalidator.getvaultaddress();	string keyname = inputvalidator.getkeyname(true);	signature = task.run(() => keyvaultclient.signasync(vaultaddress, keyname, keyversion, algorithm, digest)).configureawait(false).getawaiter().getresult();	}	else {	var keyid = (key != null) ? key.key.kid : inputvalidator.getkeyid();	signature = task.run(() => keyvaultclient.signasync(keyid, algorithm, digest)).configureawait(false).getawaiter().getresult();	}	bool isverified = task.run(() => keyvaultclient.verifyasync(signature.kid, algorithm, digest, signature.result)).configureawait(false).getawaiter().getresult();	
the signature is verified not 

subject = "cn=keyvaultdemo" }	};	var tags = inputvalidator.gettags();	var name = certificatename;	var pendingcertificate = task.run(() => keyvaultclient.createcertificateasync(vaultaddress, name, policy, new certificateattributes { enabled = true }, tags)).configureawait(false).getawaiter().getresult();	var pendingpollcount = 0;	while (pendingpollcount < 11) {	var pendingcertificateresponse = task.run(() => keyvaultclient.getcertificateoperationasync(vaultaddress, pendingcertificate.certificateoperationidentifier.name)) .configureawait(false).getawaiter().getresult();	printoutcertificateoperation(pendingcertificateresponse);	if (0 == string.compare(pendingcertificateresponse.status, "inprogress", true)) {	
waiting on the long running operation to complete creating the certificate 

while (pendingpollcount < 11) {	var pendingcertificateresponse = task.run(() => keyvaultclient.getcertificateoperationasync(vaultaddress, pendingcertificate.certificateoperationidentifier.name)) .configureawait(false).getawaiter().getresult();	printoutcertificateoperation(pendingcertificateresponse);	if (0 == string.compare(pendingcertificateresponse.status, "inprogress", true)) {	thread.sleep(timespan.fromseconds(5));	pendingpollcount++;	continue;	}	if (0 == string.compare(pendingcertificateresponse.status, "completed", true)) {	var certbundle = task.run(() => keyvaultclient.getcertificateasync(pendingcertificateresponse.target)).configureawait(false).getawaiter().getresult();	
created certificate 

if (file.exists(pfxpath)) {	var x509collection = new x509certificate2collection();	x509collection.import(pfxpath, pfxpassword, x509keystorageflags.exportable);	var x509bytes = x509collection.cast<x509certificate2>().single(s => s.hasprivatekey).export(x509contenttype.pfx, pfxpassword);	base64x509 = convert.tobase64string(x509bytes);	}	else {	base64x509 = "miijowibazcccpcgcsqgsib3dqehaacccogeggjkmiii4dccbgkgcsqgsib3dqehaaccbfoeggx2miif8jccbe4gcyqgsib3dqemcgecoiie }	var name = certificatename;	var certificate = task.run(() => keyvaultclient.importcertificateasync(vaultaddress, name, base64x509, pfxpassword, policy)).configureawait(false).getawaiter().getresult();	
created certificate 

private static void listcertificates() {	var vaultaddress = inputvalidator.getvaultaddress();	var numsecretsinvault = 0;	var maxresults = 1;	
list certificate 

numsecretsinvault += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	while (results != null && !string.isnullorwhitespace(results.nextpagelink)) {	results = task.run(() => keyvaultclient.getcertificatesnextasync(results.nextpagelink)).configureawait(false).getawaiter().getresult();	if (results != null && results != null) {	numsecretsinvault += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	}	
number of certificates in the vault 

private static void listcertificateversions(string certificatename) {	var vaultaddress = inputvalidator.getvaultaddress();	certificatename = (certificatename == string.empty) ? inputvalidator.getkeyid() : certificatename;	var numkeyversions = 0;	var maxresults = 1;	
list certificate versions 

numkeyversions += results.count();	foreach (var m in results) console.out.writeline("\t{0}-{1}", m.identifier.name, m.identifier.version);	}	while (results != null && !string.isnullorwhitespace(results.nextpagelink)) {	results = task.run(() => keyvaultclient.getcertificateversionsnextasync(results.nextpagelink)).configureawait(false).getawaiter().getresult();	if (results != null && results != null) {	numkeyversions += results.count();	foreach (var m in results) console.out.writeline("\t{0}-{1}", m.identifier.name, m.identifier.version);	}	}	
number of versions of certificate in the vault 

private static certificatebundle deletecertificate(string certificatename) {	var vaultaddress = inputvalidator.getvaultaddress();	certificatename = (certificatename == string.empty) ? inputvalidator.getcertificatename() : certificatename;	var certificate = task.run(() => keyvaultclient.deletecertificateasync(vaultaddress, certificatename)).configureawait(false).getawaiter().getresult();	
deleted certificate 

private static storagebundle createstorageaccount(out string storageaccountname) {	var vaultaddress = inputvalidator.getvaultaddress();	storageaccountname = inputvalidator.getstorageaccountname();	var name = storageaccountname;	var armstorageresourceid = configurationmanager.appsettings["armstorageaccountresourceid"];	var keyname = "key1";	var storageaccount = task.run( () => userkeyvaultclient.setstorageaccountasync(vaultaddress, name, armstorageresourceid, keyname, false)) .configureawait(false).getawaiter().getresult();	
created storage account 

private static storagebundle getstorageaccount(string storageaccountname) {	var vaultaddress = inputvalidator.getvaultaddress();	var storageaccount = task.run( () => userkeyvaultclient.getstorageaccountasync(vaultaddress, storageaccountname)) .configureawait(false).getawaiter().getresult();	
retrieved storage account 

private static storagebundle updatestorageaccount(string storageaccountname) {	var vaultaddress = inputvalidator.getvaultaddress();	var keyname = "key2";	var regenerationperiod = xmlconvert.tostring(timespan.fromdays(5));	var storageaccount = task.run( () => userkeyvaultclient.updatestorageaccountasync(vaultaddress, storageaccountname, keyname, false, regenerationperiod)) .configureawait(false).getawaiter().getresult();	
updated storage account 

private static storagebundle regeneratestorageaccountkey(string storageaccountname) {	var vaultaddress = inputvalidator.getvaultaddress();	var keyname = "key1";	var storageaccount = task.run( () => userkeyvaultclient.regeneratestorageaccountkeyasync(vaultaddress, storageaccountname, keyname)) .configureawait(false).getawaiter().getresult();	
updated storage account 

private static void liststorageaccounts() {	var vaultaddress = inputvalidator.getvaultaddress();	var numstorageaccounts = 0;	var maxresults = 1;	
list storage accounts 

numstorageaccounts += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	while (results != null && !string.isnullorwhitespace(results.nextpagelink)) {	results = task.run(() => userkeyvaultclient.getstorageaccountsnextasync(results.nextpagelink)).configureawait(false).getawaiter().getresult();	if (results != null && results != null) {	numstorageaccounts += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	}	
number of storage accounts in the vault 

private static storagebundle deletestorageaccount(string storageaccountname) {	var vaultaddress = inputvalidator.getvaultaddress();	var storageaccount = task.run( () => userkeyvaultclient.deletestorageaccountasync(vaultaddress, storageaccountname)) .configureawait(false).getawaiter().getresult();	
delted storage account 

private static sasdefinitionbundle createsasdefinition(string storageaccountname, out string sasdefinitionname) {	var vaultaddress = inputvalidator.getvaultaddress();	sasdefinitionname = inputvalidator.getsasdefinitionname();	var name = sasdefinitionname;	var fields = new dictionary<string, string>() {	{"sastype", "account"}, {"signedprotocols", "https"}, {"signedservices", "bq"}, {"signedresourcetypes", "sco"}, {"signedpermissions", "rw"}, {"signedversion", "2016-05-31"}, {"validityperiod", "pt10h"}	};	var sasdefinition = task.run( () => userkeyvaultclient.setsasdefinitionasync(vaultaddress, storageaccountname, name, fields)) .configureawait(false).getawaiter().getresult();	
created storage sas definition 

private static sasdefinitionbundle getsasdefinition(string storageaccountname, string sasdefinitionname) {	var vaultaddress = inputvalidator.getvaultaddress();	var sasdefinition = task.run( () => userkeyvaultclient.getsasdefinitionasync(vaultaddress, storageaccountname, sasdefinitionname)) .configureawait(false).getawaiter().getresult();	
retrieved storage sas definition 

private static sasdefinitionbundle updatesasdefinition(string storageaccountname, string sasdefinitionname) {	var vaultaddress = inputvalidator.getvaultaddress();	var fields = new dictionary<string, string>() {	{"sastype", "account"}, {"signedprotocols", "https"}, {"signedservices", "t"}, {"signedresourcetypes", "s"}, {"signedpermissions", "rl"}, {"signedversion", "2016-05-31"}, {"validityperiod", "p1d"}	};	var sasdefinition = task.run( () => userkeyvaultclient.updatesasdefinitionasync(vaultaddress, storageaccountname, sasdefinitionname, fields)) .configureawait(false).getawaiter().getresult();	
updated storage sas definition 

private static void listsasdefinitions(string storageaccountname) {	var vaultaddress = inputvalidator.getvaultaddress();	var numsasdefinitions = 0;	var maxresults = 1;	
list storage sas definitions 

numsasdefinitions += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	while (results != null && !string.isnullorwhitespace(results.nextpagelink)) {	results = task.run(() => userkeyvaultclient.getsasdefinitionsnextasync(results.nextpagelink)).configureawait(false).getawaiter().getresult();	if (results != null && results != null) {	numsasdefinitions += results.count();	foreach (var m in results) console.out.writeline("\t{0}", m.identifier.name);	}	}	
number of storage sas definitions in the vault 

private static sasdefinitionbundle deletesasdefinition(string storageaccountname, string sasdefinitionname) {	var vaultaddress = inputvalidator.getvaultaddress();	var sasdefinition = task.run( () => keyvaultclient.deletesasdefinitionasync(vaultaddress, storageaccountname, sasdefinitionname)) .configureawait(false).getawaiter().getresult();	
delted storage sas definition 

private static void printoutkey(keybundle keybundle) {	
key key id key type 

private static void printoutkey(keybundle keybundle) {	var expirydatestr = keybundle.attributes.expires.hasvalue ? keybundle.attributes.expires.tostring() : "never";	var notbeforestr = keybundle.attributes.notbefore.hasvalue ? keybundle.attributes.notbefore.tostring() : unixtimejsonconverter.epochdate.tostring();	
key attributes is the key enabled expiry date enable date 

private static void printoutsecret(secretbundle secret) {	
secret id secret value 

private static void printoutsecret(secretbundle secret) {	var expirydatestr = secret.attributes.expires.hasvalue ? secret.attributes.expires.tostring() : "never";	var notbeforestr = secret.attributes.notbefore.hasvalue ? secret.attributes.notbefore.tostring() : unixtimejsonconverter.epochdate.tostring();	
secret attributes is the key enabled expiry date enable date content type 

private static void printoutcertificate(certificatebundle certificatebundle) {	
certificate id 

private static void printoutcertificate(certificatebundle certificatebundle) {	var expirydatestr = certificatebundle.attributes.expires.hasvalue ? certificatebundle.attributes.expires.tostring() : "never";	var notbeforestr = certificatebundle.attributes.notbefore.hasvalue ? certificatebundle.attributes.notbefore.tostring() : unixtimejsonconverter.epochdate.tostring();	
certificate attributes is enabled expiry date enable date thumbprint 

private static void printoutstorageaccount(storagebundle storagebundle) {	
storage account id 

private static void printoutstorageaccount(storagebundle storagebundle) {	
arm storage account resource id 

private static void printoutstorageaccount(storagebundle storagebundle) {	
storage account active key name 

private static void printoutstorageaccount(storagebundle storagebundle) {	
storage account regeneration period days 

private static void printoutstorageaccount(storagebundle storagebundle) {	
storage account auto regeneration enabled 

private static void printoutstorageaccount(storagebundle storagebundle) {	
storage account attributes is enabled 

private static void printoutstoragesasdefinition(sasdefinitionbundle sasdefinitionbundle) {	
storage sas definition id 

private static void printoutstoragesasdefinition(sasdefinitionbundle sasdefinitionbundle) {	
storage sas token secret 

private static void printoutstoragesasdefinition(sasdefinitionbundle sasdefinitionbundle) {	console.out.writeline("storage sas definition parameters: {{ {0} }}", string.join(", ", sasdefinitionbundle.parameters.select(kvp => kvp.key + ":" + kvp.value.tostring())));	
storage sas definition attributes is enabled 

private static void printoutcertificateoperation(certificateoperation certificateoperation) {	
certificate id 

private static void printoutcertificateoperation(certificateoperation certificateoperation) {	
certificate opeation status status detail target issuer reference name 

========================= azure_sdk sample_2141 =========================

string jobid = "bug2329884job-" + testutilities.getmyname();	protocol.requestinterceptor interceptor = null;	try {	const string taskid = "hiworld";	cloudjob unboundjob = batchcli.joboperations.createjob(jobid, new poolinformation());	unboundjob.poolinformation.poolid = this.poolfixture.poolid;	unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	
initial job commit 

unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, new timespan(0, 3 /*min*/, 0));	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	
recent tasks 

cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, new timespan(0, 3 /*min*/, 0));	cloudtask boundtask = boundjob.gettask(taskid);	string computenodeid = boundtask.computenodeinformation.affinityid.split(':')[1];	computenode computenode = batchcli.pooloperations.getcomputenode(this.poolfixture.poolid, computenodeid);	foreach (taskinformation recenttask in computenode.recenttasks) {	
compute node has recent task job task state subtask 

public void bug2342986_starttaskmissingoncomputenode() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	cloudpool pool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	
getting pool 

public void bug2342986_starttaskmissingoncomputenode() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	cloudpool pool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	starttask poolstarttask = pool.starttask;	assert.notnull(poolstarttask);	assert.notnull(poolstarttask.environmentsettings);	ienumerable<computenode> computenodes = pool.listcomputenodes();	assert.true(computenodes.any());	
checking every compute nodes start task in the pool matches the pools start task 

public void bug2342986_starttaskmissingoncomputenode() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	cloudpool pool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	starttask poolstarttask = pool.starttask;	assert.notnull(poolstarttask);	assert.notnull(poolstarttask.environmentsettings);	ienumerable<computenode> computenodes = pool.listcomputenodes();	assert.true(computenodes.any());	foreach (computenode computenode in computenodes) {	
checking start task of compute node 

}	}	}	finally {	try {	if (null != victim) {	victim.enablescheduling();	}	}	catch (exception ex) {	
onlineofflinetest exception during exit trying to restore scheduling state 

bob.password = "password";	bob.sshpublickey = "base64==";	cnunamestodelete.add(bob.name);	bob.commit(computenodeusercommitsemantics.adduser);	bob.sshpublickey = "base65==";	bob.commit(computenodeusercommitsemantics.updateuser);	}	finally {	try {	foreach (string curcnuname in cnunamestodelete) {	
testcomputenodeuseriaas attempting to delete the following nodeid user 

bob.sshpublickey = "base65==";	bob.commit(computenodeusercommitsemantics.updateuser);	}	finally {	try {	foreach (string curcnuname in cnunamestodelete) {	cn.deletecomputenodeuser(curcnuname);	}	}	catch (exception ex) {	
testcomputenodeuseriaas exception deleting user account ex 

========================= azure_sdk sample_5793 =========================

public void testjsonsamples<tsample, tresource>(itestoutputhelper logger) {	int failurecount = 0;	int samplecount = 0;	ienumerable<jsonsampleinfo> samples = jsonsamplecommon.getjsonsamplesfromtype<tsample>();	foreach (jsonsampleinfo sampleinfo in samples) {	string samplename = sampleinfo.name;	string serializedjson = string.empty;	samplecount++;	
testing json sample 

public void testjsonsamples<tsample, tresource>(itestoutputhelper logger) {	int failurecount = 0;	int samplecount = 0;	ienumerable<jsonsampleinfo> samples = jsonsamplecommon.getjsonsamplesfromtype<tsample>();	foreach (jsonsampleinfo sampleinfo in samples) {	string samplename = sampleinfo.name;	string serializedjson = string.empty;	samplecount++;	try {	testjsonsample<tresource>(sampleinfo);	
passed 

int samplecount = 0;	ienumerable<jsonsampleinfo> samples = jsonsamplecommon.getjsonsamplesfromtype<tsample>();	foreach (jsonsampleinfo sampleinfo in samples) {	string samplename = sampleinfo.name;	string serializedjson = string.empty;	samplecount++;	try {	testjsonsample<tresource>(sampleinfo);	}	catch (exception ex) {	
failed exception json 

========================= azure_sdk sample_2373 =========================

"10.1.1.1", "10.1.2.4" }	}, subnets = new list<subnet>() {	new subnet() {	name = gwsubnetname, addressprefix = "10.0.0.0/24", }, new subnet() {	name = subnet2name, addressprefix = "10.0.1.0/24", }	}	};	var putvnetresponse = networkmanagementclient.virtualnetworks.createorupdate(resourcegroupname, vnetname, vnet);	var getvnetresponse = networkmanagementclient.virtualnetworks.get(resourcegroupname, vnetname);	var getsubnetresponse = networkmanagementclient.subnets.get(resourcegroupname, vnetname, gwsubnetname);	
virtual network gatewaysubnet id 

========================= azure_sdk sample_3229 =========================

system.threading.thread.sleep(5000);	{	bool repeat = true;	while (repeat) {	cloudpool boundpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	repeat = false;	foreach (cloudtask curtask in boundjob.listtasks()) {	if (curtask.state != microsoft.azure.batch.common.taskstate.completed) {	repeat = true;	this.testoutputhelper.writeline("manual wait task id: " + curtask.id + ", state = " + curtask.state);	
poolstate currentdedicated 

system.threading.thread.sleep(5000);	{	bool repeat = true;	while (repeat) {	cloudpool boundpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	repeat = false;	foreach (cloudtask curtask in boundjob.listtasks()) {	if (curtask.state != microsoft.azure.batch.common.taskstate.completed) {	repeat = true;	this.testoutputhelper.writeline("manual wait task id: " + curtask.id + ", state = " + curtask.state);	
compute nodes 

{	bool repeat = true;	while (repeat) {	cloudpool boundpool = batchcli.pooloperations.getpool(this.poolfixture.poolid);	repeat = false;	foreach (cloudtask curtask in boundjob.listtasks()) {	if (curtask.state != microsoft.azure.batch.common.taskstate.completed) {	repeat = true;	this.testoutputhelper.writeline("manual wait task id: " + curtask.id + ", state = " + curtask.state);	foreach (computenode curcomputenode in boundpool.listcomputenodes()) {	
computenode id state 

foreach (cloudtask curtask in boundjob.listtasks()) {	if (curtask.state != microsoft.azure.batch.common.taskstate.completed) {	repeat = true;	this.testoutputhelper.writeline("manual wait task id: " + curtask.id + ", state = " + curtask.state);	foreach (computenode curcomputenode in boundpool.listcomputenodes()) {	}	}	}	}	}	
adding longer running tasks 

for (int i = 0; i < 15; i++) {	cloudtask unboundtask = new cloudtask(i.tostring() + "_a234567890a234567890a234567890a234567890a234567890a234567890", "cmd /c ping 127.0.0.1 -n 4");	boundjob.addtask(unboundtask);	}	utilities utilities = batchcli.utilities;	taskstatemonitor tsm = utilities.createtaskstatemonitor();	ipagedenumerable<cloudtask> tasklist = boundjob.listtasks();	odatamonitorcontrol odmc = new odatamonitorcontrol();	odmc.delaybetweendatafetch = new timespan(0);	assert.equal(500, odmc.delaybetweendatafetch.milliseconds);	
calling taskstatemonitor waitall this will take a while 

using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-testboundjobverbs";	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	cloudjob.commit();	cloudjob job = batchcli.joboperations.getjob(jobid);	job.disable(disablejoboption.terminate);	cloudjob disabledjob = batchcli.joboperations.getjob(jobid);	
disabledjob state 

cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	cloudjob.commit();	cloudjob job = batchcli.joboperations.getjob(jobid);	job.disable(disablejoboption.terminate);	cloudjob disabledjob = batchcli.joboperations.getjob(jobid);	assert.true(disabledjob.state == jobstate.disabled || disabledjob.state == jobstate.disabling);	job.enable();	cloudjob enabledjob = batchcli.joboperations.getjob(jobid);	
enabledjob state 

cloudjob.commit();	cloudjob job = batchcli.joboperations.getjob(jobid);	job.disable(disablejoboption.terminate);	cloudjob disabledjob = batchcli.joboperations.getjob(jobid);	assert.true(disabledjob.state == jobstate.disabled || disabledjob.state == jobstate.disabling);	job.enable();	cloudjob enabledjob = batchcli.joboperations.getjob(jobid);	assert.equal(jobstate.active, jobstate.active);	batchcli.joboperations.disablejob(jobid, disablejoboption.terminate);	disabledjob = batchcli.joboperations.getjob(jobid);	
disabledjob state 

cloudjob disabledjob = batchcli.joboperations.getjob(jobid);	assert.true(disabledjob.state == jobstate.disabled || disabledjob.state == jobstate.disabling);	job.enable();	cloudjob enabledjob = batchcli.joboperations.getjob(jobid);	assert.equal(jobstate.active, jobstate.active);	batchcli.joboperations.disablejob(jobid, disablejoboption.terminate);	disabledjob = batchcli.joboperations.getjob(jobid);	assert.true(disabledjob.state == jobstate.disabled || disabledjob.state == jobstate.disabling);	batchcli.joboperations.enablejob(jobid);	enabledjob = batchcli.joboperations.getjob(jobid);	
enabledjob state 

cloudjob enabledjob = batchcli.joboperations.getjob(jobid);	assert.equal(jobstate.active, jobstate.active);	batchcli.joboperations.disablejob(jobid, disablejoboption.terminate);	disabledjob = batchcli.joboperations.getjob(jobid);	assert.true(disabledjob.state == jobstate.disabled || disabledjob.state == jobstate.disabling);	batchcli.joboperations.enablejob(jobid);	enabledjob = batchcli.joboperations.getjob(jobid);	assert.equal(jobstate.active, jobstate.active);	job.terminate("need some reason");	cloudjob terminatedjob = batchcli.joboperations.getjob(jobid);	
terminatedjob state 

enabledjob = batchcli.joboperations.getjob(jobid);	assert.equal(jobstate.active, jobstate.active);	job.terminate("need some reason");	cloudjob terminatedjob = batchcli.joboperations.getjob(jobid);	assert.true(terminatedjob.state == jobstate.terminating || terminatedjob.state == jobstate.completed);	if (terminatedjob.state == jobstate.terminating) {	thread.sleep(timespan.fromseconds(5));	}	job.delete();	try {	
expected exception testing that job does not exist 

try {	cloudjob deletedjob = batchcli.joboperations.getjob(jobid);	assert.equal(jobstate.deleting, deletedjob.state);	}	catch (exception e) {	assert.isassignablefrom<batchexception>(e);	batchexception be = e as batchexception;	assert.notnull(be.requestinformation);	assert.notnull(be.requestinformation.batcherror);	assert.equal(batcherrorcodestrings.jobnotfound, be.requestinformation.batcherror.code);	
job was deleted successfully 

public void bug1433069testboundjobcommit() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-testboundjobcommit";	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	
initial job schedule commit 

using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-testboundjobcommit";	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	cloudjob.commit();	cloudjob refreshablejob = batchcli.joboperations.getjob(jobid);	const int newjobpriority = 5;	onalltaskscomplete newonalltaskscomplete = onalltaskscomplete.noaction;	
job priority is 

autopoolspec.poolspecification = poolspec;	poolinformation poolinfo = new poolinformation();	poolinfo.autopoolspecification = autopoolspec;	unboundjob.poolinformation = poolinfo;	const int originalpriority = 0;	unboundjob.priority = originalpriority;	list<metadataitem> originalmetadata = new list<metadataitem>();	originalmetadata.add(new metadataitem("meta1", "value1"));	originalmetadata.add(new metadataitem("meta2", "value2"));	unboundjob.metadata = originalmetadata;	
creating job 

unboundjob.metadata = originalmetadata;	unboundjob.commit();	try {	cloudjob createdjob = batchcli.joboperations.getjob(jobid);	assert.notequal(jobstate.disabled, createdjob.state);	int updatedpriority = originalpriority + 1;	list<metadataitem> updatedmetadata = new list<metadataitem>();	updatedmetadata.add(new metadataitem("updatedmeta1", "value1"));	createdjob.priority = updatedpriority;	createdjob.metadata = updatedmetadata;	
updating job without altering poolinformation 

list<metadataitem> updatedmetadata = new list<metadataitem>();	updatedmetadata.add(new metadataitem("updatedmeta1", "value1"));	createdjob.priority = updatedpriority;	createdjob.metadata = updatedmetadata;	createdjob.commit();	cloudjob updatedjob = batchcli.joboperations.getjob(jobid);	assert.equal(updatedpriority, updatedjob.priority);	assert.equal(updatedjob.metadata.count, updatedjob.priority);	assert.equal(updatedjob.metadata[0].name, updatedmetadata[0].name);	assert.equal(updatedjob.metadata[0].value, updatedmetadata[0].value);	
disabling job 

updatedjob.disable(disablejoboption.terminate);	while (updatedjob.state != jobstate.disabled) {	thread.sleep(500);	updatedjob.refresh();	}	assert.equal(jobstate.disabled, updatedjob.state);	bool updatedkeepalive = !originalkeepalive;	updatedjob.poolinformation.autopoolspecification.keepalive = updatedkeepalive;	int updatedagainpriority = updatedpriority + 1;	updatedjob.priority = updatedagainpriority;	
updating job properties including poolinformation 

bool updatedkeepalive = !originalkeepalive;	updatedjob.poolinformation.autopoolspecification.keepalive = updatedkeepalive;	int updatedagainpriority = updatedpriority + 1;	updatedjob.priority = updatedagainpriority;	updatedjob.commit();	cloudjob updatedpoolinfojob = batchcli.joboperations.getjob(jobid);	assert.equal(updatedkeepalive, updatedpoolinfojob.poolinformation.autopoolspecification.keepalive);	assert.equal(updatedagainpriority, updatedpoolinfojob.priority);	}	finally {	
deleting job 

int updatedagainpriority = updatedpriority + 1;	updatedjob.priority = updatedagainpriority;	updatedjob.commit();	cloudjob updatedpoolinfojob = batchcli.joboperations.getjob(jobid);	assert.equal(updatedkeepalive, updatedpoolinfojob.poolinformation.autopoolspecification.keepalive);	assert.equal(updatedagainpriority, updatedpoolinfojob.priority);	}	finally {	testutilities.deletejobifexistsasync(batchcli, jobid).wait();	foreach (cloudpool pool in batchcli.pooloperations.listpools(new odatadetaillevel(filterclause: string.format("startswith(id,'{0}')", autopoolprefix)))) {	
deleting pool 

using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = "bug1965363job-" + testutilities.getmyname();	try {	poolinformation poolinfo = new poolinformation() {	autopoolspecification = new autopoolspecification() {	poollifetimeoption = poollifetimeoption.job, poolspecification = new poolspecification() {	cloudserviceconfiguration = new cloudserviceconfiguration(poolfixture.osfamily), virtualmachinesize = poolfixture.vmsize, targetdedicatedcomputenodes = 1 }	}	};	cloudjob unboundjob = batchcli.joboperations.createjob(jobid, poolinfo);	
commiting quickjob 

autopoolspecification = new autopoolspecification() {	poollifetimeoption = poollifetimeoption.job, poolspecification = new poolspecification() {	cloudserviceconfiguration = new cloudserviceconfiguration(poolfixture.osfamily), virtualmachinesize = poolfixture.vmsize, targetdedicatedcomputenodes = 1 }	}	};	cloudjob unboundjob = batchcli.joboperations.createjob(jobid, poolinfo);	unboundjob.commit();	cloudtask task = new cloudtask("bug1965363wat7osversionfeaturesquickjobwithautopooltask", "cmd /c echo bug1965363");	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	boundjob.addtask(task);	
getting pool name 

};	cloudjob unboundjob = batchcli.joboperations.createjob(jobid, poolinfo);	unboundjob.commit();	cloudtask task = new cloudtask("bug1965363wat7osversionfeaturesquickjobwithautopooltask", "cmd /c echo bug1965363");	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	boundjob.addtask(task);	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	taskstatemonitor tsm = batchcli.utilities.createtaskstatemonitor();	odatamonitorcontrol odcontrol = new odatamonitorcontrol();	odcontrol.delaybetweendatafetch = timespan.fromseconds(5);	
invoking taskstatemonitor 

unboundjob.commit();	cloudtask task = new cloudtask("bug1965363wat7osversionfeaturesquickjobwithautopooltask", "cmd /c echo bug1965363");	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	boundjob.addtask(task);	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	taskstatemonitor tsm = batchcli.utilities.createtaskstatemonitor();	odatamonitorcontrol odcontrol = new odatamonitorcontrol();	odcontrol.delaybetweendatafetch = timespan.fromseconds(5);	tsm.waitall( boundjob.listtasks(), taskstate.completed, timespan.fromminutes(15), odcontrol, new[] {	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	
issuing request type 

cloudtask task = new cloudtask("bug1965363wat7osversionfeaturesquickjobwithautopooltask", "cmd /c echo bug1965363");	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	boundjob.addtask(task);	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	taskstatemonitor tsm = batchcli.utilities.createtaskstatemonitor();	odatamonitorcontrol odcontrol = new odatamonitorcontrol();	odcontrol.delaybetweendatafetch = timespan.fromseconds(5);	tsm.waitall( boundjob.listtasks(), taskstate.completed, timespan.fromminutes(15), odcontrol, new[] {	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	list<computenode> allcomputenodes = boundpool.listcomputenodes().tolist();	
comnpute nodes 

action test = () => {	using (batchclient batchcli = testutilities.openbatchclientfromenvironmentasync().result) {	string jobid = "jobconditionalheaders-" + testutilities.getmyname();	try {	poolinformation poolinfo = new poolinformation() {	poolid = "fake" };	cloudjob unboundjob = batchcli.joboperations.createjob(jobid, poolinfo);	unboundjob.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	string capturedetag1 = boundjob.etag;	
etag is 

========================= azure_sdk sample_5797 =========================

private async task<ipage<noderesource>> listnodesinsubscription(servermanagementclient client) {	var nodes = await client.node.listasync();	assert.notnull(nodes);	var found = false;	foreach (var n in nodes) {	found = true;	
found node in subscription 

private async task<gatewayresource> createandconfiguregateway(servermanagementclient client, string gatewayname) {	gatewayresource gateway;	gateway = await client.gateway.createasync( resourcegroup, gatewayname, upgrademode: upgrademode.automatic, location: location );	assert.notnull(gateway);	
created gateway 

private async task<gatewayresource> createandconfiguregateway(servermanagementclient client, string gatewayname) {	gatewayresource gateway;	gateway = await client.gateway.createasync( resourcegroup, gatewayname, upgrademode: upgrademode.automatic, location: location );	assert.notnull(gateway);	var profile = await client.gateway.getprofileasync(resourcegroup, gatewayname);	if (testinginteractively) {	stopgateway();	
profile 

gateway = await client.gateway.getasync(resourcegroup, gatewayone, gatewayexpandoption.status);	assert.notnull(gateway);	assert.notnull(gateway.latestpublishedmsiversion);	assert.notnull(gateway.activemessagecount);	writeline(gateway.tojson());	var gateways = await client.gateway.listasync();	assert.notnull(gateways);	var found = false;	foreach (var g in gateways) {	found = true;	
found gateway in subscription 

startgateway();	}	catch {	}	}	try {	if (gateway == null) {	await createandconfiguregateway(client, gatewaytwo);	gateway = await client.gateway.getasync(resourcegroup, gatewaytwo, gatewayexpandoption.status);	}	
creating node 

catch {	}	}	try {	if (gateway == null) {	await createandconfiguregateway(client, gatewaytwo);	gateway = await client.gateway.getasync(resourcegroup, gatewaytwo, gatewayexpandoption.status);	}	var node = await createnode(client, gateway, string.empty, string.empty);	assert.notnull(node);	
getting node 

if (gateway == null) {	await createandconfiguregateway(client, gatewaytwo);	gateway = await client.gateway.getasync(resourcegroup, gatewaytwo, gatewayexpandoption.status);	}	var node = await createnode(client, gateway, string.empty, string.empty);	assert.notnull(node);	node = await client.node.getasync(resourcegroup, nodename);	assert.notnull(node);	assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	
listing nodes 

}	var node = await createnode(client, gateway, string.empty, string.empty);	assert.notnull(node);	node = await client.node.getasync(resourcegroup, nodename);	assert.notnull(node);	assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	var nodes = await listnodesinsubscription(client);	nodes = await client.node.listforresourcegroupasync(resourcegroup);	assert.equal(1, nodes.count());	
creating session 

node = await client.node.getasync(resourcegroup, nodename);	assert.notnull(node);	assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	var nodes = await listnodesinsubscription(client);	nodes = await client.node.listforresourcegroupasync(resourcegroup);	assert.equal(1, nodes.count());	var session = await client.session.createasync(resourcegroup, node.name, sessionid, nodeusername, nodepassword);	assert.notnull(session);	assert.equal(session.name, sessionid);	
getting session 

assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	var nodes = await listnodesinsubscription(client);	nodes = await client.node.listforresourcegroupasync(resourcegroup);	assert.equal(1, nodes.count());	var session = await client.session.createasync(resourcegroup, node.name, sessionid, nodeusername, nodepassword);	assert.notnull(session);	assert.equal(session.name, sessionid);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	
session get response 

assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	var nodes = await listnodesinsubscription(client);	nodes = await client.node.listforresourcegroupasync(resourcegroup);	assert.equal(1, nodes.count());	var session = await client.session.createasync(resourcegroup, node.name, sessionid, nodeusername, nodepassword);	assert.notnull(session);	assert.equal(session.name, sessionid);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	
creating powershell session 

var nodes = await listnodesinsubscription(client);	nodes = await client.node.listforresourcegroupasync(resourcegroup);	assert.equal(1, nodes.count());	var session = await client.session.createasync(resourcegroup, node.name, sessionid, nodeusername, nodepassword);	assert.notnull(session);	assert.equal(session.name, sessionid);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	var ps = await client.powershell.createsessionasync(resourcegroup, node.name, session.name, "00000000-0000-0000-0000-000000000000");	assert.notnull(ps);	
running powershell command 

nodes = await client.node.listforresourcegroupasync(resourcegroup);	assert.equal(1, nodes.count());	var session = await client.session.createasync(resourcegroup, node.name, sessionid, nodeusername, nodepassword);	assert.notnull(session);	assert.equal(session.name, sessionid);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	var ps = await client.powershell.createsessionasync(resourcegroup, node.name, session.name, "00000000-0000-0000-0000-000000000000");	assert.notnull(ps);	await runpowershellcommand(client, node, session, ps);	
try tab completion 

assert.equal(1, nodes.count());	var session = await client.session.createasync(resourcegroup, node.name, sessionid, nodeusername, nodepassword);	assert.notnull(session);	assert.equal(session.name, sessionid);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	var ps = await client.powershell.createsessionasync(resourcegroup, node.name, session.name, "00000000-0000-0000-0000-000000000000");	assert.notnull(ps);	await runpowershellcommand(client, node, session, ps);	await gettabcompletionresults(client, node, session, ps);	
list powershell sessions 

var session = await client.session.createasync(resourcegroup, node.name, sessionid, nodeusername, nodepassword);	assert.notnull(session);	assert.equal(session.name, sessionid);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	var ps = await client.powershell.createsessionasync(resourcegroup, node.name, session.name, "00000000-0000-0000-0000-000000000000");	assert.notnull(ps);	await runpowershellcommand(client, node, session, ps);	await gettabcompletionresults(client, node, session, ps);	await listpowershellsessions(client, node, session);	
try a long running command 

assert.notnull(session);	assert.equal(session.name, sessionid);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	var ps = await client.powershell.createsessionasync(resourcegroup, node.name, session.name, "00000000-0000-0000-0000-000000000000");	assert.notnull(ps);	await runpowershellcommand(client, node, session, ps);	await gettabcompletionresults(client, node, session, ps);	await listpowershellsessions(client, node, session);	await runlongpowershellcommand(client, node, session, ps);	
delete session 

startgateway();	}	catch {	}	}	try {	if (gateway == null) {	await createandconfiguregateway(client, gatewaytwo);	gateway = await client.gateway.getasync(resourcegroup, gatewaytwo, gatewayexpandoption.status);	}	
creating node 

catch {	}	}	try {	if (gateway == null) {	await createandconfiguregateway(client, gatewaytwo);	gateway = await client.gateway.getasync(resourcegroup, gatewaytwo, gatewayexpandoption.status);	}	var node = await createnode(client, gateway, string.empty, string.empty);	assert.notnull(node);	
getting node 

if (gateway == null) {	await createandconfiguregateway(client, gatewaytwo);	gateway = await client.gateway.getasync(resourcegroup, gatewaytwo, gatewayexpandoption.status);	}	var node = await createnode(client, gateway, string.empty, string.empty);	assert.notnull(node);	node = await client.node.getasync(resourcegroup, nodename);	assert.notnull(node);	assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	
creating session 

assert.notnull(node);	node = await client.node.getasync(resourcegroup, nodename);	assert.notnull(node);	assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	var username =  utility.encryptusinggatewaysettings(gateway.instances[0], nodeusername);	var password =  utility.encryptusinggatewaysettings(gateway.instances[0], nodepassword);	var session = await client.session.createasync(resourcegroup, node.name, sessionidtwo, username, password, retentionperiod.session, credentialdataformat.rsaencrypted);	assert.notnull(session);	assert.equal(session.name, sessionidtwo);	
getting session 

assert.notnull(node);	assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	var username =  utility.encryptusinggatewaysettings(gateway.instances[0], nodeusername);	var password =  utility.encryptusinggatewaysettings(gateway.instances[0], nodepassword);	var session = await client.session.createasync(resourcegroup, node.name, sessionidtwo, username, password, retentionperiod.session, credentialdataformat.rsaencrypted);	assert.notnull(session);	assert.equal(session.name, sessionidtwo);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	
session get response 

assert.notnull(node);	assert.equal(nodename, node.name);	assert.equal(nodename, node.connectionname);	var username =  utility.encryptusinggatewaysettings(gateway.instances[0], nodeusername);	var password =  utility.encryptusinggatewaysettings(gateway.instances[0], nodepassword);	var session = await client.session.createasync(resourcegroup, node.name, sessionidtwo, username, password, retentionperiod.session, credentialdataformat.rsaencrypted);	assert.notnull(session);	assert.equal(session.name, sessionidtwo);	session = await client.session.getasync(resourcegroup, node.name, session.name);	assert.notnull(session);	
delete session 

========================= azure_sdk sample_7881 =========================

utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks())[0];	assert.equal<taskstate?>(taskstate.completed, mycompletedtask.state);	assert.notnull(mycompletedtask.multiinstancesettings);	assert.equal(mycompletedtask.multiinstancesettings.numberofinstances, 3);	assert.equal(mycompletedtask.multiinstancesettings.coordinationcommandline, "cmd /c set");	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
stdout 

cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks())[0];	assert.equal<taskstate?>(taskstate.completed, mycompletedtask.state);	assert.notnull(mycompletedtask.multiinstancesettings);	assert.equal(mycompletedtask.multiinstancesettings.numberofinstances, 3);	assert.equal(mycompletedtask.multiinstancesettings.coordinationcommandline, "cmd /c set");	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	
stderr 

}	thread.sleep(500);	} while (sw.elapsed <= checksubtasksstatetimeout);	assert.true(sw.elapsed <= checksubtasksstatetimeout, string.format("the subtasks state is not set to complete after {0} seconds", checksubtasksstatetimeout.totalseconds));	assert.equal(2, subtasks.count);	assert.equal(0, subtasks[0].exitcode);	assert.null(subtasks[0].failureinformation);	assert.equal(0, subtasks[1].exitcode);	assert.null(subtasks[1].failureinformation);	assert.true((subtasks[0].id == 1 && subtasks[1].id == 2) || (subtasks[0].id == 2 && subtasks[1].id == 1));	
multi instance test complete 

hwtask.multiinstancesettings = new multiinstancesettings(@"cmd /c start cmd /c ""%msmpi_bin%\smpd.exe"" -d 3 -p 6050", 3);	hwtask.multiinstancesettings.commonresourcefiles = new list<resourcefile>();	hwtask.multiinstancesettings.commonresourcefiles.add(new resourcefile("https: boundjob.addtask(hwtask);	{	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks()).single();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
stdout 

{	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks()).single();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	
stderr 

sw.start();	do {	ipagedenumerable<subtaskinformation> results = batchcli.joboperations.listsubtasks(jobid, mycompletedtask.id);	subtasks = results.tolist();	if (subtasks.all(t => t.state == subtaskstate.completed)) {	break;	}	thread.sleep(500);	} while (sw.elapsed <= checksubtasksstatetimeout);	assert.true(sw.elapsed <= checksubtasksstatetimeout, string.format("the subtasks state is not set to complete after {0} seconds", checksubtasksstatetimeout.totalseconds));	
mpi test complete 

numenvsettings = newenvsettings.count;	hwtask.environmentsettings = newenvsettings;	boundjob.addtask(hwtask);	{	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks())[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
stdout 

{	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks())[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	
stderr 

string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	ienumerable<environmentsetting> boundsettings = mycompletedtask.environmentsettings;	assert.notnull(boundsettings);	list<environmentsetting> compenvsettings = new list<environmentsetting>(boundsettings);	assert.equal(numenvsettings, compenvsettings.count);	
environement settings 

this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	ienumerable<environmentsetting> boundsettings = mycompletedtask.environmentsettings;	assert.notnull(boundsettings);	list<environmentsetting> compenvsettings = new list<environmentsetting>(boundsettings);	assert.equal(numenvsettings, compenvsettings.count);	foreach (environmentsetting curenvsetting in boundsettings) {	
name value 

this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	ienumerable<environmentsetting> boundsettings = mycompletedtask.environmentsettings;	assert.notnull(boundsettings);	list<environmentsetting> compenvsettings = new list<environmentsetting>(boundsettings);	assert.equal(numenvsettings, compenvsettings.count);	foreach (environmentsetting curenvsetting in boundsettings) {	}	
env setting test complete 

cloudtask mytask = new cloudtask(id: "bug1447214task", commandline: @"hostname");	taskconstraints ts = new taskconstraints(maxwallclocktime: timespan.fromhours(1), retentiontime: timespan.fromhours(1), maxtaskretrycount: 99);	mytask.constraints = ts;	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
taskid 

cloudtask mytask = new cloudtask(id: "bug1447214task", commandline: @"hostname");	taskconstraints ts = new taskconstraints(maxwallclocktime: timespan.fromhours(1), retentiontime: timespan.fromhours(1), maxtaskretrycount: 99);	mytask.constraints = ts;	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
stdout 

mytask.constraints = ts;	boundjob.addtask(mytask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	
stderr 

utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	
taskconstraints 

cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	taskconstraints comptc = mycompletedtask.constraints;	assert.notnull(comptc);	if (null == comptc) {	
null 

this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	taskconstraints comptc = mycompletedtask.constraints;	assert.notnull(comptc);	if (null == comptc) {	}	else {	this.testoutputhelper.writeline("");	
maxwallclocktime null 

this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	taskconstraints comptc = mycompletedtask.constraints;	assert.notnull(comptc);	if (null == comptc) {	}	else {	this.testoutputhelper.writeline("");	
retentiontime null 

this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline("");	this.testoutputhelper.writeline(stderr);	this.testoutputhelper.writeline("");	taskconstraints comptc = mycompletedtask.constraints;	assert.notnull(comptc);	if (null == comptc) {	}	else {	this.testoutputhelper.writeline("");	
maxtaskretrycount null 

this.testoutputhelper.writeline("");	taskconstraints comptc = mycompletedtask.constraints;	assert.notnull(comptc);	if (null == comptc) {	}	else {	this.testoutputhelper.writeline("");	assert.true(comptc.maxtaskretrycount.hasvalue);	assert.equal(99, comptc.maxtaskretrycount.value);	}	
taskexecutioninfo 

if (null == comptc) {	}	else {	this.testoutputhelper.writeline("");	assert.true(comptc.maxtaskretrycount.hasvalue);	assert.equal(99, comptc.maxtaskretrycount.value);	}	taskexecutioninformation tei = mycompletedtask.executioninformation;	assert.notnull(tei);	if (null == tei) {	
null 

this.testoutputhelper.writeline("");	assert.true(comptc.maxtaskretrycount.hasvalue);	assert.equal(99, comptc.maxtaskretrycount.value);	}	taskexecutioninformation tei = mycompletedtask.executioninformation;	assert.notnull(tei);	if (null == tei) {	}	else {	this.testoutputhelper.writeline("");	
starttime null 

this.testoutputhelper.writeline("");	assert.true(comptc.maxtaskretrycount.hasvalue);	assert.equal(99, comptc.maxtaskretrycount.value);	}	taskexecutioninformation tei = mycompletedtask.executioninformation;	assert.notnull(tei);	if (null == tei) {	}	else {	this.testoutputhelper.writeline("");	
lastupdatetime null 

this.testoutputhelper.writeline("");	assert.true(comptc.maxtaskretrycount.hasvalue);	assert.equal(99, comptc.maxtaskretrycount.value);	}	taskexecutioninformation tei = mycompletedtask.executioninformation;	assert.notnull(tei);	if (null == tei) {	}	else {	this.testoutputhelper.writeline("");	
exitcode null 

assert.true(comptc.maxtaskretrycount.hasvalue);	assert.equal(99, comptc.maxtaskretrycount.value);	}	taskexecutioninformation tei = mycompletedtask.executioninformation;	assert.notnull(tei);	if (null == tei) {	}	else {	this.testoutputhelper.writeline("");	}	
stats 

}	taskexecutioninformation tei = mycompletedtask.executioninformation;	assert.notnull(tei);	if (null == tei) {	}	else {	this.testoutputhelper.writeline("");	}	taskstatistics compts = mycompletedtask.statistics;	if (null == compts) {	
null 

assert.notnull(tei);	if (null == tei) {	}	else {	this.testoutputhelper.writeline("");	}	taskstatistics compts = mycompletedtask.statistics;	if (null == compts) {	}	else {	
url 

cloudtask newtasktoadd = new cloudtask(id: "bug1535329newtask", commandline: "hostname");	filetostage wordsdottext = new filetostage(resources.localwordsdottext, stagingstorageaccount);	newtasktoadd.filestostage = new list<ifilestagingprovider>();	newtasktoadd.filestostage.add(wordsdottext);	batchcli.joboperations.addtask(jobid, newtasktoadd);	bool foundlocalwords = false;	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(5));	foreach (cloudtask curtask in boundjob.listtasks()) {	
taskid 

filetostage wordsdottext = new filetostage(resources.localwordsdottext, stagingstorageaccount);	newtasktoadd.filestostage = new list<ifilestagingprovider>();	newtasktoadd.filestostage.add(wordsdottext);	batchcli.joboperations.addtask(jobid, newtasktoadd);	bool foundlocalwords = false;	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(5));	foreach (cloudtask curtask in boundjob.listtasks()) {	foreach (nodefile curfile in curtask.listnodefiles(recursive: true)) {	
filename 

cloudtask untask = new cloudtask("bug1611592", "hostname");	testutilities.assertthrows<invalidoperationexception>(() => { var f = untask.computenodeinformation; });	cloudjob bndjob = batchcli.joboperations.getjob(jobid);	bndjob.addtask(untask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( bndjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(5));	foreach (cloudtask curtask in bndjob.listtasks()) {	computenodeinformation computenodeinfo = curtask.computenodeinformation;	assert.notnull(computenodeinfo);	
task 

cloudtask untask = new cloudtask("bug1611592", "hostname");	testutilities.assertthrows<invalidoperationexception>(() => { var f = untask.computenodeinformation; });	cloudjob bndjob = batchcli.joboperations.getjob(jobid);	bndjob.addtask(untask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( bndjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(5));	foreach (cloudtask curtask in bndjob.listtasks()) {	computenodeinformation computenodeinfo = curtask.computenodeinformation;	assert.notnull(computenodeinfo);	
computenodeinfo 

cloudtask untask = new cloudtask("bug1611592", "hostname");	testutilities.assertthrows<invalidoperationexception>(() => { var f = untask.computenodeinformation; });	cloudjob bndjob = batchcli.joboperations.getjob(jobid);	bndjob.addtask(untask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( bndjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(5));	foreach (cloudtask curtask in bndjob.listtasks()) {	computenodeinformation computenodeinfo = curtask.computenodeinformation;	assert.notnull(computenodeinfo);	
poolid 

cloudtask untask = new cloudtask("bug1611592", "hostname");	testutilities.assertthrows<invalidoperationexception>(() => { var f = untask.computenodeinformation; });	cloudjob bndjob = batchcli.joboperations.getjob(jobid);	bndjob.addtask(untask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( bndjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(5));	foreach (cloudtask curtask in bndjob.listtasks()) {	computenodeinformation computenodeinfo = curtask.computenodeinformation;	assert.notnull(computenodeinfo);	
computenodeid 

public void testboundtaskterminateanddelete() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-testboundtaskterminateanddelete";	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	
creating job 

using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = microsoft.azure.batch.constants.defaultconvenienceprefix + testutilities.getmyname() + "-testboundtaskterminateanddelete";	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() {	poolid = this.poolfixture.poolid };	cloudjob.commit();	{	const string taskid = "t1";	cloudtask tasktoadd = new cloudtask(taskid, "ping 127.0.0.1 -n 60");	
adding task 

poolid = this.poolfixture.poolid };	cloudjob.commit();	{	const string taskid = "t1";	cloudtask tasktoadd = new cloudtask(taskid, "ping 127.0.0.1 -n 60");	batchcli.joboperations.addtask(jobid, tasktoadd);	list<cloudtask> tasks = batchcli.joboperations.listtasks(jobid).tolist();	assert.equal(1, tasks.count);	taskstatemonitor taskstatemonitor = batchcli.utilities.createtaskstatemonitor();	taskstatemonitor.waitall( tasks, taskstate.running, timespan.fromseconds(30), new odatamonitorcontrol {delaybetweendatafetch = timespan.fromseconds(5)});	
terminating task 

batchcli.joboperations.addtask(jobid, tasktoadd);	list<cloudtask> tasks = batchcli.joboperations.listtasks(jobid).tolist();	assert.equal(1, tasks.count);	taskstatemonitor taskstatemonitor = batchcli.utilities.createtaskstatemonitor();	taskstatemonitor.waitall( tasks, taskstate.running, timespan.fromseconds(30), new odatamonitorcontrol {delaybetweendatafetch = timespan.fromseconds(5)});	cloudtask runningtask = batchcli.joboperations.gettask(jobid, taskid);	runningtask.terminate();	runningtask.refresh();	assert.equal(taskstate.completed, runningtask.state);	runningtask.refresh();	
deleting task 

runningtask.refresh();	assert.equal(taskstate.completed, runningtask.state);	runningtask.refresh();	runningtask.delete();	list<cloudtask> tasklistafterdelete = batchcli.joboperations.listtasks(jobid).tolist();	assert.equal(0, tasklistafterdelete.count);	}	{	const string taskid = "t2";	cloudtask tasktoadd = new cloudtask(taskid, "ping 127.0.0.1 -n 60");	
adding task 

assert.equal(0, tasklistafterdelete.count);	}	{	const string taskid = "t2";	cloudtask tasktoadd = new cloudtask(taskid, "ping 127.0.0.1 -n 60");	batchcli.joboperations.addtask(jobid, tasktoadd);	list<cloudtask> tasks = batchcli.joboperations.listtasks(jobid).tolist();	assert.equal(1, tasks.count);	taskstatemonitor taskstatemonitor = batchcli.utilities.createtaskstatemonitor();	taskstatemonitor.waitall( tasks, taskstate.running, timespan.fromseconds(30), new odatamonitorcontrol { delaybetweendatafetch = timespan.fromseconds(5) });	
terminating task 

batchcli.joboperations.addtask(jobid, tasktoadd);	list<cloudtask> tasks = batchcli.joboperations.listtasks(jobid).tolist();	assert.equal(1, tasks.count);	taskstatemonitor taskstatemonitor = batchcli.utilities.createtaskstatemonitor();	taskstatemonitor.waitall( tasks, taskstate.running, timespan.fromseconds(30), new odatamonitorcontrol { delaybetweendatafetch = timespan.fromseconds(5) });	cloudtask runningtask = batchcli.joboperations.gettask(jobid, taskid);	batchcli.joboperations.terminatetask(jobid, taskid);	runningtask.refresh();	assert.equal(taskstate.completed, runningtask.state);	runningtask.refresh();	
deleting task 

public void failedtaskcanbereactivated() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = constants.defaultconvenienceprefix + testutilities.getmyname() + guid.newguid();	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() { poolid = this.poolfixture.poolid };	
creating job 

public void failedtaskcanbereactivated() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = constants.defaultconvenienceprefix + testutilities.getmyname() + guid.newguid();	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation() { poolid = this.poolfixture.poolid };	cloudjob.commit();	const string taskid = "t1";	cloudtask tasktoadd = new cloudtask(taskid, "cmd /c \"ping 127.0.0.1 -n 20 > nul && exit /b 3\"");	
adding task 

action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = constants.defaultconvenienceprefix + testutilities.getmyname() + guid.newguid();	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation() { poolid = this.poolfixture.poolid });	cloudjob.ontaskfailure = ontaskfailure.performexitoptionsjobaction;	cloudjob.usestaskdependencies = true;	cloudjob.commit();	const string taskid = "t1";	cloudtask tasktoadd = new cloudtask(taskid, "cmd /c \"ping 127.0.0.1 \"");	
adding task 

public void accessscopecanberoundtripped() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	string jobid = constants.defaultconvenienceprefix + testutilities.getmyname() + guid.newguid();	try {	cloudjob cloudjob = batchcli.joboperations.createjob(jobid, new poolinformation());	cloudjob.poolinformation = new poolinformation { poolid = this.poolfixture.poolid };	
creating job 

action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	const string testname = "bug1770926_updatetask";	const string taskid = "bug1770926_updatetask_task1";	string jobid = constants.defaultconvenienceprefix + testutilities.getmyname() + "-" + testname;	taskconstraints defaultconstraints = new taskconstraints(timespan.maxvalue, timespan.maxvalue, 0);	try {	cloudjob jobschedule = batchcli.joboperations.createjob(jobid, new poolinformation());	jobschedule.poolinformation = new poolinformation() {	poolid = "poolwhodoesntexist" };	
initial job schedule commit 

const string taskid = "bug1770926_updatetask_task1";	string jobid = constants.defaultconvenienceprefix + testutilities.getmyname() + "-" + testname;	taskconstraints defaultconstraints = new taskconstraints(timespan.maxvalue, timespan.maxvalue, 0);	try {	cloudjob jobschedule = batchcli.joboperations.createjob(jobid, new poolinformation());	jobschedule.poolinformation = new poolinformation() {	poolid = "poolwhodoesntexist" };	jobschedule.commit();	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	
adding task 

cloudtask mytask = new cloudtask(taskid, "cmd /c echo hello world");	boundjob.addtask(mytask);	cloudtask boundtask = batchcli.joboperations.gettask(jobid, taskid);	assert.equal(defaultconstraints.maxtaskretrycount, boundtask.constraints.maxtaskretrycount);	assert.equal(defaultconstraints.maxwallclocktime, boundtask.constraints.maxwallclocktime);	assert.equal(defaultconstraints.retentiontime, boundtask.constraints.retentiontime);	timespan maxwallclocktime = timespan.fromhours(1);	timespan dataretentiontime = timespan.fromhours(2);	const int maxretrycount = 1;	boundtask.constraints = new taskconstraints(maxwallclocktime, dataretentiontime, maxretrycount);	
updating task constraints 

========================= azure_sdk sample_5796 =========================

public async task ifatrackedfileisisusewhenitisduetobeflushed_thennoerroroccursandchangesarepersisted() {	var file = path.gettempfilename();	try {	var taskoutputstorage = new taskoutputstorage(storageaccount, _jobid, _taskid);	using (await taskoutputstorage.savetrackedasync(taskoutputkind.tasklog, file, "tracked2.txt", timespan.frommilliseconds(5))) {	using (var writer = file.appendtext(file)) {	for (int i = 0; i < 100; ++i) {	await task.delay(timespan.frommilliseconds(3));	
line i 

var taskoutputstorage = new taskoutputstorage(storageaccount, _jobid, _taskid);	using (await taskoutputstorage.savetrackedasync(taskoutputkind.tasklog, file, "tracked2.txt", timespan.frommilliseconds(5))) {	using (var writer = file.appendtext(file)) {	for (int i = 0; i < 100; ++i) {	await task.delay(timespan.frommilliseconds(3));	await task.delay(timespan.frommilliseconds(3));	}	}	using (var writer = file.appendtext(file)) {	for (int i = 0; i < 100; ++i) {	
line i 

========================= azure_sdk sample_5734 =========================

const string jobmanagercommandline = "ping 127.0.0.1 -n 500";	ilist<metadataitem> metadata = new list<metadataitem> { new metadataitem("key1", "test1"), new metadataitem("key2", "test2") };	cloudjobschedule jobschedule = batchcli.jobscheduleoperations.createjobschedule(jobscheduleid, null, null);	timespan firstrecurrenceinterval = timespan.fromminutes(2);	jobschedule.schedule = new schedule() { recurrenceinterval = firstrecurrenceinterval };	poolinformation poolinfo = new poolinformation() {	poolid = this.poolfixture.poolid };	jobschedule.jobspecification = new jobspecification(poolinfo) {	priority = jobschedulepriority, jobmanagertask = new jobmanagertask(jobmanagerid, jobmanagercommandline) };	jobschedule.metadata = metadata;	
initial job schedule commit 

poolid = this.poolfixture.poolid };	jobschedule.jobspecification = new jobspecification(poolinfo) {	priority = jobschedulepriority, jobmanagertask = new jobmanagertask(jobmanagerid, jobmanagercommandline) };	jobschedule.metadata = metadata;	jobschedule.commit();	cloudjobschedule boundjobschedule = batchcli.jobscheduleoperations.getjobschedule(jobscheduleid);	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, jobschedulepriority, jobmanagerid, jobmanagercommandline, firstrecurrenceinterval, metadata);	timespan recurrenceinterval = timespan.fromminutes(5);	boundjobschedule.schedule = new schedule() {	recurrenceinterval = recurrenceinterval };	
updating jobschedule schedule 

jobschedule.commit();	cloudjobschedule boundjobschedule = batchcli.jobscheduleoperations.getjobschedule(jobscheduleid);	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, jobschedulepriority, jobmanagerid, jobmanagercommandline, firstrecurrenceinterval, metadata);	timespan recurrenceinterval = timespan.fromminutes(5);	boundjobschedule.schedule = new schedule() {	recurrenceinterval = recurrenceinterval };	boundjobschedule.commit();	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, jobschedulepriority, jobmanagerid, jobmanagercommandline, recurrenceinterval, metadata);	const int newjobschedulepriority = 1;	boundjobschedule.jobspecification.priority = newjobschedulepriority;	
updating jobspecification priority 

boundjobschedule.schedule = new schedule() {	recurrenceinterval = recurrenceinterval };	boundjobschedule.commit();	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, jobschedulepriority, jobmanagerid, jobmanagercommandline, recurrenceinterval, metadata);	const int newjobschedulepriority = 1;	boundjobschedule.jobspecification.priority = newjobschedulepriority;	boundjobschedule.commit();	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, newjobschedulepriority, jobmanagerid, jobmanagercommandline, recurrenceinterval, metadata);	const string newjobmanagercommandline = "ping 127.0.0.1 -n 150";	boundjobschedule.jobspecification.jobmanagertask.commandline = newjobmanagercommandline;	
updating jobspecification jobmanagertask commandline 

const int newjobschedulepriority = 1;	boundjobschedule.jobspecification.priority = newjobschedulepriority;	boundjobschedule.commit();	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, newjobschedulepriority, jobmanagerid, jobmanagercommandline, recurrenceinterval, metadata);	const string newjobmanagercommandline = "ping 127.0.0.1 -n 150";	boundjobschedule.jobspecification.jobmanagertask.commandline = newjobmanagercommandline;	boundjobschedule.commit();	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, newjobschedulepriority, jobmanagerid, newjobmanagercommandline, recurrenceinterval, metadata);	const string newpoolid = "testpool";	boundjobschedule.jobspecification.poolinformation = new poolinformation() { poolid = newpoolid };	
updating poolinformation 

const string newjobmanagercommandline = "ping 127.0.0.1 -n 150";	boundjobschedule.jobspecification.jobmanagertask.commandline = newjobmanagercommandline;	boundjobschedule.commit();	assertjobschedulecorrectness(batchcli.jobscheduleoperations, boundjobschedule, this.poolfixture.poolid, newjobschedulepriority, jobmanagerid, newjobmanagercommandline, recurrenceinterval, metadata);	const string newpoolid = "testpool";	boundjobschedule.jobspecification.poolinformation = new poolinformation() { poolid = newpoolid };	boundjobschedule.commit();	assertjobschedulecorrectness( batchcli.jobscheduleoperations, boundjobschedule, newpoolid, newjobschedulepriority, jobmanagerid, newjobmanagercommandline, recurrenceinterval, metadata);	ilist<metadataitem> newmetadata = new list<metadataitem> { new metadataitem("object", "model") };	boundjobschedule.metadata = newmetadata;	
updating metadata 

========================= azure_sdk sample_5803 =========================

public list<keyoperationtype> getkeyoperations() {	list<keyoperationtype> keyoperations = new list<keyoperationtype>();	foreach ( var arg in args ) {	var result = new keyoperationtype();	if ( enum.tryparse<keyoperationtype>( arg, true, out result ) ) {	keyoperations.add( result );	}	}	if ( keyoperations.count == 0 ) {	
no operation is provided executing all the key and secret operations 

public byte[] getplaintext() {	var tag = "-text";	var text = getargumentvalue( tag );	if ( text == string.empty ) {	
is not provided using default value 

public byte[] getciphertext() {	var tag = "-text";	var text = getargumentvalue( tag );	if ( text == string.empty ) {	
is not provided using default value 

public byte[] getdigesthash() {	var tag = "-digestfile";	var digestfile = getargumentvalue( tag );	var digest = randomhash<sha256cryptoserviceprovider>( 32 );	if ( digestfile != string.empty ) {	digest = file.readallbytes( digestfile );	}	else {	
is not provided using default value 

public string getsignalgorithm() {	var tag = "-algo";	var algorithm = getargumentvalue( tag );	if ( algorithm == string.empty ) {	algorithm = jsonwebkeysignaturealgorithm.rs256;	
is not provided using default value 

public string getencryptionalgorithm() {	var tag = "-algo";	var algorithm = getargumentvalue( tag );	if ( algorithm == string.empty ) {	algorithm = jsonwebkeyencryptionalgorithm.rsaoaep;	
is not provided using default value 

public byte[] getsymmetrickey() {	var tag = "-symkeyfile";	var symmetrickeyfile = getargumentvalue( tag );	var symmetrickey = symmetricalgorithm.create().key;	if ( symmetrickeyfile != string.empty ) {	symmetrickey = file.readallbytes( symmetrickeyfile );	}	else {	
is not provided using default value 

public string getvaultaddress() {	var tag = "-vault";	string keyvaultvaultaddress = getargumentvalue( tag );	if ( keyvaultvaultaddress == string.empty ) {	keyvaultvaultaddress = configurationmanager.appsettings["vaulturl"];	
is not provided using default value 

public string getsecretvalue() {	var tag = "-secretvalue";	string value = getargumentvalue( tag );	if ( value == string.empty ) {	value = "default secret value";	
is not provided using new guid 

public string getpfxpath() {	var tag = "-pfxfilepath";	var path = getargumentvalue( tag );	if ( path == string.empty ) {	
is not provided using default value 

public string getpfxpassword() {	var tag = "-pfxfilepassword";	var password = getargumentvalue( tag );	if (password == string.empty) {	
is not provided using default value 

public string getsecretcontenttype() {	var tag = "-secretcontenttype";	string value = getargumentvalue(tag);	if (value == string.empty) {	value = "plaintext";	
is not provided using default value 

public string getkeyversion() {	var tag = "-keyversion";	string version = getargumentvalue( tag );	if ( version == string.empty ) {	
is not provided 

public string getsecretversion() {	var tag = "-secretversion";	string version = getargumentvalue( tag );	if ( version == string.empty ) {	
is not provided 

========================= azure_sdk sample_2140 =========================

public static void assertisbatchexceptionandhascorrectazureerrorcode(exception ex, string correctcode, itestoutputhelper outputhelper) {	exception theoneinner = ex;	if (ex is aggregateexception) {	aggregateexception ae = (aggregateexception)ex;	assert.equal<int>(1, ae.innerexceptions.count);	theoneinner = ae.innerexceptions[0];	}	if (!(theoneinner is microsoft.azure.batch.common.batchexception)) {	
assertisbatchexceptionandhascorrectazureerrorcode incorrect exception 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	
pool count 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	
allocationstate 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	
state 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	
targetdedicated 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	
currentdedicated no value 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
avgcpu avgdisk avgmemory diskreadbytes 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
diskreadiops 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
diskwritebytes 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
diskwriteiops 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
networkreadbytes 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
networkwritebytes 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
peakdisk 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
peakmemory 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
starttime 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	
lastupdatetime 

public static void displaypools(itestoutputhelper testoutputhelper, ienumerable<cloudpool> poolsenumerable) {	list<cloudpool> pools = new list<cloudpool>(poolsenumerable);	int numpools = (null != pools) ? pools.count : 0;	testoutputhelper.writeline("");	testoutputhelper.writeline("");	foreach (cloudpool curpool in pools) {	testoutputhelper.writeline(curpool.id + ":");	if (curpool.statistics != null) {	}	else {	
no value 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	
id 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	
state 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	
url 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	
lastmodified null 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	
exeinfo 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	
lastupdatetime null 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	
nextruntime null 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	
recentjob 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	recentjob rj = wiexinfo.recentjob;	if (null == rj) {	
null 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	recentjob rj = wiexinfo.recentjob;	if (null == rj) {	}	else {	
id 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	recentjob rj = wiexinfo.recentjob;	if (null == rj) {	}	else {	
url 

public static void displayjobschedulelong(itestoutputhelper testoutputhelper, cloudjobschedule curwi) {	{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	recentjob rj = wiexinfo.recentjob;	if (null == rj) {	}	else {	}	}	jobspecification jobspec = curwi.jobspecification;	
jobspecification 

{	jobscheduleexecutioninformation wiexinfo = curwi.executioninformation;	recentjob rj = wiexinfo.recentjob;	if (null == rj) {	}	else {	}	}	jobspecification jobspec = curwi.jobspecification;	if (null == jobspec) {	
null 

if (null == rj) {	}	else {	}	}	jobspecification jobspec = curwi.jobspecification;	if (null == jobspec) {	}	else {	testoutputhelper.writeline("");	
priority null 

}	else {	}	}	jobspecification jobspec = curwi.jobspecification;	if (null == jobspec) {	}	else {	testoutputhelper.writeline("");	jobconstraints jobcon = jobspec.constraints;	
constraints 

else {	}	}	jobspecification jobspec = curwi.jobspecification;	if (null == jobspec) {	}	else {	testoutputhelper.writeline("");	jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	
null 

jobspecification jobspec = curwi.jobspecification;	if (null == jobspec) {	}	else {	testoutputhelper.writeline("");	jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	
maxtaskretrycount null 

jobspecification jobspec = curwi.jobspecification;	if (null == jobspec) {	}	else {	testoutputhelper.writeline("");	jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	
maxwallclocktime null 

else {	testoutputhelper.writeline("");	jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	
null 

jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	}	else {	
jobmanagertask 

jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	}	else {	
commandline 

jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	}	else {	
killjoboncompletion null 

jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	}	else {	
id 

jobconstraints jobcon = jobspec.constraints;	if (null == jobcon) {	}	else {	testoutputhelper.writeline("");	}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	}	else {	
runexclusive null 

else {	testoutputhelper.writeline("");	}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	}	else {	ienumerable<environmentsetting> envsettings = ijm.environmentsettings;	if (null != envsettings) {	list<environmentsetting> envsettingslist = new list<environmentsetting>(ijm.environmentsettings);	
environmentsettings count 

}	jobmanagertask ijm = jobspec.jobmanagertask;	if (null == ijm) {	}	else {	ienumerable<environmentsetting> envsettings = ijm.environmentsettings;	if (null != envsettings) {	list<environmentsetting> envsettingslist = new list<environmentsetting>(ijm.environmentsettings);	}	else {	
environmentsettings null 

else {	ienumerable<environmentsetting> envsettings = ijm.environmentsettings;	if (null != envsettings) {	list<environmentsetting> envsettingslist = new list<environmentsetting>(ijm.environmentsettings);	}	else {	}	ienumerable<resourcefile> resfilesprop = ijm.resourcefiles;	if (null != resfilesprop) {	list<resourcefile> resfiles = new list<resourcefile>();	
resourcefiles count 

if (null != envsettings) {	list<environmentsetting> envsettingslist = new list<environmentsetting>(ijm.environmentsettings);	}	else {	}	ienumerable<resourcefile> resfilesprop = ijm.resourcefiles;	if (null != resfilesprop) {	list<resourcefile> resfiles = new list<resourcefile>();	}	else {	
resourcefiles null 

else {	}	ienumerable<resourcefile> resfilesprop = ijm.resourcefiles;	if (null != resfilesprop) {	list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	
taskconstraints null 

ienumerable<resourcefile> resfilesprop = ijm.resourcefiles;	if (null != resfilesprop) {	list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	
taskconstraints 

ienumerable<resourcefile> resfilesprop = ijm.resourcefiles;	if (null != resfilesprop) {	list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	
maxtaskretrycount null 

ienumerable<resourcefile> resfilesprop = ijm.resourcefiles;	if (null != resfilesprop) {	list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	
maxwallclocktime null 

ienumerable<resourcefile> resfilesprop = ijm.resourcefiles;	if (null != resfilesprop) {	list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	
retentiontime null 

list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	}	if (ijm.useridentity != null) {	
useridentity 

list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	}	if (ijm.useridentity != null) {	
username 

list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	}	if (ijm.useridentity != null) {	
elevationlevel 

list<resourcefile> resfiles = new list<resourcefile>();	}	else {	}	taskconstraints tc = ijm.constraints;	if (null == tc) {	}	else {	}	if (ijm.useridentity != null) {	
scope 

if (null == tc) {	}	else {	}	if (ijm.useridentity != null) {	}	}	}	{	ienumerable<metadataitem> mdis = curwi.metadata;	
metadata 

}	else {	}	if (ijm.useridentity != null) {	}	}	}	{	ienumerable<metadataitem> mdis = curwi.metadata;	if (null == mdis) {	
null 

if (ijm.useridentity != null) {	}	}	}	{	ienumerable<metadataitem> mdis = curwi.metadata;	if (null == mdis) {	}	else {	list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	
count 

{	ienumerable<metadataitem> mdis = curwi.metadata;	if (null == mdis) {	}	else {	list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	}	}	schedule sched = curwi.schedule;	if (null == sched) {	
schedule null 

if (null == mdis) {	}	else {	list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	}	}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	
schedule 

if (null == mdis) {	}	else {	list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	}	}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	
donotrunafter null 

if (null == mdis) {	}	else {	list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	}	}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	
donotrununtil null 

if (null == mdis) {	}	else {	list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	}	}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	
recurrenceinterval null 

if (null == mdis) {	}	else {	list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	}	}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	
startwindow null 

list<metadataitem> meta = new list<metadataitem>(curwi.metadata);	}	}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	
stats null 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
stats 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
lastupdatetime 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
kernelcputime 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
numfailedtasks 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
numtimescalled 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
numsucceededtasks 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
readiogib 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
readiops 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
starttime 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
url 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
usercputime 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
waittime 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
wallclocktime 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
writeiogib 

}	schedule sched = curwi.schedule;	if (null == sched) {	}	else {	}	jobschedulestatistics stats = curwi.statistics;	if (null == stats) {	}	else {	
writeiops 

public static void deletecertmonitor(certificateoperations certops, itestoutputhelper testoutputhelper, string thumbalgo, string thumb) {	bool found;	
polling for deletion of thumbprint 

public static void deletecertmonitor(certificateoperations certops, itestoutputhelper testoutputhelper, string thumbalgo, string thumb) {	bool found;	do {	found = false;	foreach (certificate curcert in certops.listcertificates()) {	if (thumbalgo.equals(curcert.thumbprintalgorithm, stringcomparison.invariantcultureignorecase) && thumb.equals(curcert.thumbprint, stringcomparison.invariantcultureignorecase)) {	
deletecertmonitor thumb state 

cloudtask hwtask = new cloudtask(id: taskid, commandline: winnertaskcmdline);	cloudjob boundjob = batchcli.joboperations.getjob(jobid);	boundjob.addtask(hwtask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	assert.contains("hello world", stdout);	
stdout 

cloudjob boundjob = batchcli.joboperations.getjob(jobid);	boundjob.addtask(hwtask);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), taskstate.completed, timespan.fromminutes(3));	cloudtask mycompletedtask = new list<cloudtask>(boundjob.listtasks(null))[0];	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	assert.contains("hello world", stdout);	testoutputhelper.writeline(stdout);	
stderr 

========================= azure_sdk sample_5823 =========================

private static void generatemodelfiles() {	var inputfolder = path.combine(getsourcedirectory(), @"spec");	var inputpattern = "*.json";	var model = new filereader(inputfolder, inputpattern).readtypes();	var seen = new hashset<string>();	foreach (var type in model.types) {	if (seen.contains(type.name)) {	
duplicate type type name 

========================= azure_sdk sample_5782 =========================

var specificartifact = artifacts[typeof(filetostage)];	sequentialfilestagingartifact sfsa = specificartifact as sequentialfilestagingartifact;	assert.notnull(sfsa);	testutilities.assertthrows<invalidoperationexception>(() => mytask.filestostage = new list<ifilestagingprovider>());	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(10), controlparams: null, additionalbehaviors: new[]	{	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	
issuing request type 

assert.notnull(sfsa);	testutilities.assertthrows<invalidoperationexception>(() => mytask.filestostage = new list<ifilestagingprovider>());	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(10), controlparams: null, additionalbehaviors: new[]	{	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	try {	list<computenode> allcomputenodes = boundpool.listcomputenodes().tolist();	
compute nodes 

testutilities.assertthrows<invalidoperationexception>(() => mytask.filestostage = new list<ifilestagingprovider>());	cloudpool boundpool = batchcli.pooloperations.getpool(boundjob.executioninformation.poolid);	utilities utilities = batchcli.utilities;	taskstatemonitor taskstatemonitor = utilities.createtaskstatemonitor();	taskstatemonitor.waitall( boundjob.listtasks(), microsoft.azure.batch.common.taskstate.completed, timespan.fromminutes(10), controlparams: null, additionalbehaviors: new[]	{	new microsoft.azure.batch.protocol.requestinterceptor((x) => {	try {	list<computenode> allcomputenodes = boundpool.listcomputenodes().tolist();	allcomputenodes.foreach( (icn) => {	
computenode id state 

allcomputenodes.foreach( (icn) => {	});	}	catch (exception ex) {	assert.true(false, "samplewithfilesandpool probably can ignore this if its pool not found: " + ex.tostring());	}	}) });	list<cloudtask> tasks = boundjob.listtasks(null).tolist();	cloudtask mycompletedtask = tasks[0];	foreach (cloudtask curtask in tasks) {	
task id state 

}	catch (exception ex) {	assert.true(false, "samplewithfilesandpool probably can ignore this if its pool not found: " + ex.tostring());	}	}) });	list<cloudtask> tasks = boundjob.listtasks(null).tolist();	cloudtask mycompletedtask = tasks[0];	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	
pool id state 

assert.true(false, "samplewithfilesandpool probably can ignore this if its pool not found: " + ex.tostring());	}	}) });	list<cloudtask> tasks = boundjob.listtasks(null).tolist();	cloudtask mycompletedtask = tasks[0];	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	
stdout 

}	}) });	list<cloudtask> tasks = boundjob.listtasks(null).tolist();	cloudtask mycompletedtask = tasks[0];	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	
stderr 

}) });	list<cloudtask> tasks = boundjob.listtasks(null).tolist();	cloudtask mycompletedtask = tasks[0];	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	
task files 

list<cloudtask> tasks = boundjob.listtasks(null).tolist();	cloudtask mycompletedtask = tasks[0];	foreach (cloudtask curtask in tasks) {	}	boundpool.refresh();	string stdout = mycompletedtask.getnodefile(constants.standardoutfilename).readasstring();	string stderr = mycompletedtask.getnodefile(constants.standarderrorfilename).readasstring();	this.testoutputhelper.writeline(stdout);	this.testoutputhelper.writeline(stderr);	foreach (nodefile curfile in mycompletedtask.listnodefiles(recursive: true)) {	
filepath 

public void bug1965363_2384616_wat7osversionfeatures() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	pooloperations pooloperations = batchcli.pooloperations;	try {	
listing os versions 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
jobschedulestatistics starttime 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
jobschedulestatistics lastupdatetime 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
jobschedulestatistics numsucceededtasks 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
jobschedulestatistics usercputime 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
poolstatistics starttime 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
poolstatistics lastupdatetime 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
poolstatistics resourcestatistics avgmemory 

public void bug1771070_1771072_jobandpoollifetimestats() {	action test = () => {	using (batchclient batchcli = testutilities.openbatchclientasync(testutilities.getcredentialsfromenvironment()).result) {	jobstatistics jobstatistics = batchcli.joboperations.getalllifetimestatistics();	poolstatistics poolstatistics = batchcli.pooloperations.getalllifetimestatistics();	assert.notnull(jobstatistics);	assert.notnull(poolstatistics);	
poolstatistics usagestatistics dedicatedcoretime 

========================= azure_sdk sample_5807 =========================

