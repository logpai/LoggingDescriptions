public override object getentity(uri absoluteuri, string role, type ofobjecttoreturn) {	
getting 

public override object getentity(uri absoluteuri, string role, type ofobjecttoreturn) {	
getting 

public void consolewrite() {	
where did i see this 

========================= corefx sample_12630 =========================

private delegate void readmethoddelegate(serialport com, int buffersize);	#region test cases [conditionalfact(nameof(hasoneserialport))]	public void bytestoread_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default bytestoread 

public void bytestoread_rcvrndnumbytes() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying bytestoread after receiving a random number of bytes 

public void bytestoread_read_byte_int_int() {	
verifying bytestoread with read byte buffer int offset int count 

public void bytestoread_read_char_int_int() {	
verifying bytestoread with read char buffer int offset int count 

public void bytestoread_readbyte() {	
verifying bytestoread with readbyte 

public void bytestoread_readchar() {	
verifying bytestoread with readchar 

public void bytestoread_readline() {	
verifying bytestoread with readline 

public void bytestoread_readto() {	
verifying bytestoread with readto string value 

public void bytestoread_readexisting() {	
verifying bytestoread with readexisting 

========================= corefx sample_629 =========================

public static void createbytetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
x 

public static void createutf8encodedtestfile(string strfilename, encoding encode) {	stream strm = new memorystream();	textwriter tw = new streamwriter(strm, encode);	
root 

public static void createutf8encodedtestfile(string strfilename, encoding encode) {	stream strm = new memorystream();	textwriter tw = new streamwriter(strm, encode);	tw.write("\u00a9");	
root 

public static void createencodedtestfile(string strfilename, encoding encode) {	stream strm = new memorystream();	textwriter tw = new streamwriter(strm, encode);	
root 

public static void createencodedtestfile(string strfilename, encoding encode) {	stream strm = new memorystream();	textwriter tw = new streamwriter(strm, encode);	
root 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
doctype dt 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
element pcdata 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
element pcdata 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
element pcdata 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("]>");	
doc 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("]>");	
elem 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("]>");	
elem 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("]>");	
elem 

public static void createwhitespacehandlingtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("]>");	
doc 

public static void creategenerictestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	
first processing instruction 

public static void creategenerictestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
play 

public static void creategenerictestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	
text node two no text node three 

stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	
no 

stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	
cdata this section contains characters that should not be interpreted as markup for example characters 

stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	
and are all fine here 

textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	
a 

tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	
this is a 

tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	
a 

tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
b 

tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
this is b 

tw.writeline("<elem1 child1=\"\" child2=\"no_referencee2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
b 

tw.writeline("</elem1>");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	tw.writeline("elem2-text4");	
pi pi 

tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	tw.writeline("elem2-text4");	tw.writeline("elem2-text5");	tw.writeline("</elem2>");	tw.writeline("<elem2 att1=\"id2\"></elem2>");	
root 

tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	tw.writeline("elem2-text4");	tw.writeline("elem2-text5");	tw.writeline("</elem2>");	tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	
no 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
a b 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
comm ent 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
cdata cd ata 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
x x 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
x x 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
x x 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
elem 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
elem 

tw.writeline("<elem2 att1=\"id2\"></elem2>");	tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
elem 

tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	
xxx yyy 

tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	
xxx 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
xxx markup yyy 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx markup yyy chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars markup yyy chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx markup chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx cdata yyy zzz chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars cdata yyy zzz chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx cdata yyy chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx pi yyy zzz chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars pi zzz chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx pi yyy chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx zzz chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars zzz chars 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxno_referencee1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxxno_referencee1;xxx</entity4>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	
isdefault 

tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	
true 

tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	
false 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
true 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
datetime datetime 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
date date 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
time time 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
integer integer 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
float float 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
decimal decimal 

tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	
title this is a comment title 

tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	
pgroup 

tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	
persona dromio of ephesus persona 

tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	
abcde 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
grpdescr twin brothers and sons to aegeon and aemilia grpdescr 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
pgroup 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
pgroup 

tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color no_referencee1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	
noxmllang 

tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color no_referencee1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	
donexmllang 

tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color no_referencee1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	
nospace 

tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color no_referencee1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
grpdescr twin brothers and attendants on the two antipholuses grpdescr 

tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color no_referencee1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
docnamespace 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
docnamespace 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
pgroup 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
gotocontent some text cdata cdata info gotocontent 

tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	tw.writeline("<skipcontent att1=\"\">  <!-- comment1--> \n <?pi_skipcontent instruction?></skipcontent>");	
mixcontent some text pi skipcontent instruction cdata cdata info mixcontent 

tw.writeline("</j8>89</i8>88</h8>87</g8>86</f8>85</e8>84</d8>83</c8>82</b8>81</a8>");	tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	
complex text comment cdata cdata complex 

tw.writeline("</j8>89</i8>88</h8>87</g8>86</f8>85</e8>84</d8>83</c8>82</b8>81</a8>");	tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	
dummy 

tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	
cat ab cdata cd cat 

tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	
catmixed ab cdata cd catmixed 

public static void createnamespacetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
docnamespace 

tw.writeline("<namespace0 xmlns:bar=\"1\"><bar:check>namespace=1</bar:check></namespace0>");	tw.writeline("<namespace1 xmlns:bar=\"1\"><a><b><c><d><bar:check>namespace=1</bar:check></d></c></b></a></namespace1>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	
docnamespace 

public static void createxmllangtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
pgroup 

public static void createxmllangtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
persona dromio of ephesus persona 

public static void createxmllangtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
persona dromio of syracuse persona 

public static void createxmllangtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	
noxmllang 

public static void createxmllangtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	
donexmllang 

public static void createxmllangtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	
pgroup 

public static void createxmlspacetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
pgroup 

public static void createxmlspacetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
persona dromio of ephesus persona 

public static void createxmlspacetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	
persona dromio of syracuse persona 

public static void createxmlspacetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><b><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	
nospace 

public static void createxmlspacetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><b><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
grpdescr twin brothers and attendants on the two antipholuses grpdescr 

public static void createxmlspacetestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><b><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
pgroup 

public static void createbigelementtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	string str = new string('z', (1 << 20) - 1);	
root 

public static void createbigelementtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	
x 

public static void createbigelementtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	tw.flush();	tw.write("<");	tw.write(str);	
y 

public static void createbigelementtestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	tw.flush();	tw.write("<");	tw.write(str);	
root 

public static void createxsltstylesheetwcopytestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http: tw.writeline("<xsl:template match=\"/\">");	tw.writeline("<xsl:copy-of select=\"/\" />");	
xsl template 

public static void createxsltstylesheetwcopytestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http: tw.writeline("<xsl:template match=\"/\">");	tw.writeline("<xsl:copy-of select=\"/\" />");	
xsl stylesheet 

public static void createconstructortestfile(string strfilename) {	stream s = new memorystream();	textwriter tw = new streamwriter(s);	tw.writeline("<?xml version=\"1.0\"?>");	
root 

========================= corefx sample_12412 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	}	else if (args.severity == xmlseveritytype.error) {	
error 

xmlschemaset set1 = new xmlschemaset();	set1.xmlresolver = new xmlurlresolver();	set1.validationeventhandler += new validationeventhandler(validationcallback);	xmlschema includedschema = set1.add(null, include1);	set1.compile();	xmlschemaset set = new xmlschemaset();	set.xmlresolver = new xmlurlresolver();	set.validationeventhandler += new validationeventhandler(validationcallback);	xmlschema mainschema = set.add(null, mainfile);	set.compile();	
first validation 

set.compile();	xmlreadersettings settings = new xmlreadersettings();	settings.validationeventhandler += new validationeventhandler(validationcallback);	settings.validationtype = validationtype.schema;	settings.schemas = set;	xmlreader reader = xmlreader.create(xmlfile, settings);	while (reader.read()) { }	cerror.compare(bwarningcallback, false, "warning count mismatch");	cerror.compare(berrorcallback, true, "error count mismatch");	if (isimport == true) set.remove(((xmlschemaexternal)mainschema.includes[0]).schema);	
re setting include 

settings.validationeventhandler += new validationeventhandler(validationcallback);	settings.validationtype = validationtype.schema;	settings.schemas = set;	xmlreader reader = xmlreader.create(xmlfile, settings);	while (reader.read()) { }	cerror.compare(bwarningcallback, false, "warning count mismatch");	cerror.compare(berrorcallback, true, "error count mismatch");	if (isimport == true) set.remove(((xmlschemaexternal)mainschema.includes[0]).schema);	xmlschema reparsedinclude = loadschema(include2, include1);	((xmlschemaexternal)mainschema.includes[0]).schema = reparsedinclude;	
calling reprocess 

while (reader.read()) { }	cerror.compare(bwarningcallback, false, "warning count mismatch");	cerror.compare(berrorcallback, true, "error count mismatch");	if (isimport == true) set.remove(((xmlschemaexternal)mainschema.includes[0]).schema);	xmlschema reparsedinclude = loadschema(include2, include1);	((xmlschemaexternal)mainschema.includes[0]).schema = reparsedinclude;	set.reprocess(mainschema);	set.compile();	bwarningcallback = false;	berrorcallback = false;	
second validation 

((xmlschemaexternal)mainschema.includes[0]).schema = reparsedinclude;	set.reprocess(mainschema);	set.compile();	bwarningcallback = false;	berrorcallback = false;	settings.schemas = set;	reader = xmlreader.create(xmlfile, settings);	while (reader.read()) { }	cerror.compare(bwarningcallback, false, "warning count mismatch");	cerror.compare(berrorcallback, false, "error count mismatch");	
re adding include to 

xmlschema reparsedinclude2 = loadschema(include1, include1);	set1.remove(includedschema);	set1.add(reparsedinclude2);	set1.compile();	if (isimport == true) set.remove(((xmlschemaexternal)mainschema.includes[0]).schema);	((xmlschemaexternal)mainschema.includes[0]).schema = reparsedinclude2;	set.reprocess(mainschema);	set.compile();	bwarningcallback = false;	berrorcallback = false;	
third validation expecting errors 

public xmlschema loadschema(string path, string baseuri) {	string includeuri = path.getfullpath(baseuri);	string correcturi = path.getfullpath(path);	
include uri 

public xmlschema loadschema(string path, string baseuri) {	string includeuri = path.getfullpath(baseuri);	string correcturi = path.getfullpath(path);	
correct uri 

public xmlschema loadschema(string path, string baseuri) {	string includeuri = path.getfullpath(baseuri);	string correcturi = path.getfullpath(path);	using (stream s = new filestream(path.getfullpath(path), filemode.open, fileaccess.read, fileshare.read, 1)) {	xmlreader r = xmlreader.create(s, new xmlreadersettings(), includeuri);	
reader uri 

========================= corefx sample_12503 =========================

public void greedyread() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	random rndgen = new random();	byte[] bytexmitbuffer = new byte[1024];	byte[] expectedbytes = new byte[bytexmitbuffer.length + 4];	byte[] bytercvbuffer;	char utf32char = (char)8169;	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	int numbytesread;	
verifying that read byte int int will read everything from internal buffer and drivers buffer 

public void read_datareceivedbeforetimeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	byte[] bytexmitbuffer = tcsupport.getrandombytes(512);	byte[] bytercvbuffer = new byte[bytexmitbuffer.length];	asyncread asyncread = new asyncread(com1, bytercvbuffer, 0, bytercvbuffer.length);	var asyncreadtask = new task(asyncread.read);	
verifying that read byte int int will read characters that have been received after the call to read was made 

========================= corefx sample_678 =========================

break;	case "rawchars": w.writeraw(invalidxml, 6, 2);	break;	case "writevalue": w.writevalue(invalidxml[3].tostring());	break;	default: cerror.compare(false, "invalid param value");	break;	}	}	catch (xmlexception e1) {	
exception 

break;	default: cerror.compare(false, "invalid param value");	break;	}	}	catch (xmlexception e1) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	catch (argumentexception e2) {	
exception 

case "writevalue": w.writevalue(invalidxml[3].tostring());	w.writeendelement();	w.dispose();	assert.true(utils.comparereader("<root>&#xc;</root>"));	return;	default: cerror.compare(false, "invalid param value");	break;	}	}	catch (argumentexception e) {	
exception 

break;	case "nmtoken": w.writenmtoken(invalidxml[5].tostring());	break;	case "qname": w.writequalifiedname(invalidxml[3].tostring(), "");	break;	default: cerror.compare(false, "invalid param value");	break;	}	}	catch (argumentexception e) {	
exception 

try {	w = writerhelper.create("writer.out", wsettings, overrideasync: true, async: utils.async);	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	return;	}	finally {	if (w != null) w.dispose();	}	
did not throw exception 

try {	w = writerhelper.create("writer.out", wsettings, overrideasync: true, async: utils.async);	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	return;	}	finally {	if (w != null) w.dispose();	}	
did not throw exception 

========================= corefx sample_12443 =========================

public override int executevariation(cxmldriverparam param) {	
test parameters 

========================= corefx sample_12484 =========================

}	console.writeline("\";");	console.writeline();	string filename = ( args.length == 0 ) ? "xmlchartype.bin" : args[0];	console.write( "writing xmlchartype character properties to {0}...", filename );	filestream fs = new filestream( filename, filemode.create );	for ( int i = 0; i < charpropertiessize; i += 4096 ) {	fs.write( s_charproperties, i, 4096 );	}	fs.close();	
done 

string filename = ( args.length == 0 ) ? "xmlchartype.bin" : args[0];	console.write( "writing xmlchartype character properties to {0}...", filename );	filestream fs = new filestream( filename, filemode.create );	for ( int i = 0; i < charpropertiessize; i += 4096 ) {	fs.write( s_charproperties, i, 4096 );	}	fs.close();	}	catch ( exception e ) {	console.writeline();	
exception 

========================= corefx sample_12715 =========================

public override int init(object param) {	if (_exception != null) {	
xmldriver error 

public override int init(object param) {	
xmldriver 

========================= corefx sample_12477 =========================

private void multipleerrorhandling(dbconnection connection) {	try {	
multipleerrorhandling 

private void multipleerrorhandling(dbconnection connection) {	try {	type expectedexception = null;	if (connection is sqlconnection) {	((sqlconnection)connection).infomessage += delegate (object sender, sqlinfomessageeventargs args) {	
sql connection info message 

type expectedexception = null;	if (connection is sqlconnection) {	((sqlconnection)connection).infomessage += delegate (object sender, sqlinfomessageeventargs args) {	};	expectedexception = typeof(sqlexception);	}	connection.open();	using (dbcommand command = connection.createcommand()) {	command.commandtext = "print n'0';\n" + "select num = 1, str = 'abc';\n" + "print n'1';\n" + "raiserror('error 1', 15, 1);\n" + "print n'3';\n" + "select num = 2, str = 'abc';\n" + "print n'4';\n" + "raiserror('error 2', 15, 1);\n" + "print n'5';\n" + "select num = 3, str = 'abc';\n" + "print n'6';\n" + "raiserror('error 3', 15, 1);\n" + "print n'7';\n" + "select num = 4, str = 'abc';\n" + "print n'8';\n" + "raiserror('error 4', 15, 1);\n" + "print n'9';\n" + "select num = 5, str = 'abc';\n" + "print n'10';\n" + "raiserror('error 5', 15, 1);\n" + "print n'11';\n";	try {	
executenonquery 

connection.open();	using (dbcommand command = connection.createcommand()) {	command.commandtext = "print n'0';\n" + "select num = 1, str = 'abc';\n" + "print n'1';\n" + "raiserror('error 1', 15, 1);\n" + "print n'3';\n" + "select num = 2, str = 'abc';\n" + "print n'4';\n" + "raiserror('error 2', 15, 1);\n" + "print n'5';\n" + "select num = 3, str = 'abc';\n" + "print n'6';\n" + "raiserror('error 3', 15, 1);\n" + "print n'7';\n" + "select num = 4, str = 'abc';\n" + "print n'8';\n" + "raiserror('error 4', 15, 1);\n" + "print n'9';\n" + "select num = 5, str = 'abc';\n" + "print n'10';\n" + "raiserror('error 5', 15, 1);\n" + "print n'11';\n";	try {	command.executenonquery();	}	catch (exception e) {	printexception(expectedexception, e);	}	try {	
executescalar 

catch (exception e) {	printexception(expectedexception, e);	}	try {	command.executescalar();	}	catch (exception e) {	printexception(expectedexception, e);	}	try {	
executereader 

command.executescalar();	}	catch (exception e) {	printexception(expectedexception, e);	}	try {	using (dbdatareader reader = command.executereader()) {	bool moreresults = true;	do {	try {	
nextresult 

runtest();	console.out.flush();	console.out.dispose();	streamwriter standardoutput = new streamwriter(console.openstandardoutput());	standardoutput.autoflush = true;	console.setout(standardoutput);	var comparisonresult = finddifffrombaseline(baselinepath, outputpath);	if (string.isnullorempty(comparisonresult)) {	return true;	}	
test failed 

runtest();	console.out.flush();	console.out.dispose();	streamwriter standardoutput = new streamwriter(console.openstandardoutput());	standardoutput.autoflush = true;	console.setout(standardoutput);	var comparisonresult = finddifffrombaseline(baselinepath, outputpath);	if (string.isnullorempty(comparisonresult)) {	return true;	}	
please compare baseline with output 

runtest();	console.out.flush();	console.out.dispose();	streamwriter standardoutput = new streamwriter(console.openstandardoutput());	standardoutput.autoflush = true;	console.setout(standardoutput);	var comparisonresult = finddifffrombaseline(baselinepath, outputpath);	if (string.isnullorempty(comparisonresult)) {	return true;	}	
comparison results 

========================= corefx sample_11010 =========================

string dirnamereferedfrommounteddrive;	string dirname;	string[] expectedfiles;	string[] files;	string[] expecteddirs;	string[] dirs;	list<string> list;	watch = new stopwatch();	watch.start();	try {	
scenario vanilla different drive is mounted on the current drive 

string[] expecteddirs;	string[] dirs;	list<string> list;	watch = new stopwatch();	watch.start();	try {	string otherdriveinmachine = ioservices.getntfsdriveotherthancurrent();	if (filesystemdebuginfo.iscurrentdriventfs() && otherdriveinmachine != null) {	mounteddirname = path.getfullpath(managefilesystem.getnonexistingdir(path.directoryseparatorchar.tostring(), mountprefixname));	try {	
creating directory 

foreach (string value in list) console.writeline(value);	}	}	}	finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	
skipping since drive is not ntfs and there is no other drive on the machine 

finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	}	
scenario current drive is mounted on a different drive 

foreach (string value in list) console.writeline(value);	}	}	}	finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	
skipping since drive is not ntfs and there is no other drive on the machine 

finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	}	
scenario current drive is mounted on current drive 

foreach (string value in list) console.writeline(value);	}	}	}	finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	
drive is not ntfs skipping scenario 

finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	}	
scenario current drive is mounted on current directory 

foreach (string value in list) console.writeline(value);	}	}	}	finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	
drive is not ntfs skipping scenario 

finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	else {	}	}	catch (exception ex) {	s_pass = false;	}	
completed 

}	else {	}	}	catch (exception ex) {	s_pass = false;	}	}	catch (exception ex) {	s_pass = false;	
err uncaught exception in runtest 

========================= corefx sample_231 =========================

public void charencoding() {	string chars = "\u1234 \u4567 \uabcd \r \n \t \\ \" \' \0 \u2028 \u2029 \u0084 \u0085 \u00010f00";	var main = new codeentrypointmethod();	
writeline 

public void charencoding() {	string chars = "\u1234 \u4567 \uabcd \r \n \t \\ \" \' \0 \u2028 \u2029 \u0084 \u0085 \u00010f00";	var main = new codeentrypointmethod();	
public shared sub main system console writeline global microsoft visualbasic chrw global microsoft visualbasic chrw global microsoft visualbasic chrw global microsoft visualbasic chrw global microsoft visualbasic chrw global microsoft visualbasic chrw end sub 

public void defaultvalues() {	var main = new codeentrypointmethod();	foreach (type t in new[] { typeof(int), typeof(object), typeof(datetime), typeof(string) }) {	
writeline 

public void defaultvalues() {	var main = new codeentrypointmethod();	foreach (type t in new[] { typeof(int), typeof(object), typeof(datetime), typeof(string) }) {	}	
sub 

========================= corefx sample_9328 =========================

public static bool checkcontent(byte[] values, int offsinmodelcontents, int count) {	for (int i = 0; i < count; i++) {	if (!checkcontent(values[i], i + offsinmodelcontents)) {	
fail on 

========================= corefx sample_1627 =========================

public async task servernoencryption_clientallownoencryption_connectwithnoencryption() {	using (var servernoencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.noencryption)) using (var client = new tcpclient()) {	await client.connectasync(servernoencryption.remoteendpoint.address, servernoencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null, encryptionpolicy.allownoencryption)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

public async task servernoencryption_clientnoencryption_connectwithnoencryption() {	using (var servernoencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.noencryption)) using (var client = new tcpclient()) {	await client.connectasync(servernoencryption.remoteendpoint.address, servernoencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null, encryptionpolicy.noencryption)) {	if (supportsnullencryption) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

========================= corefx sample_8145 =========================

private static bool booltypewithidentityconversioninifstatement() {	int failcount = 0;	dynamic d = false;	if (d) {	failcount++;	
test failed at conversion result 

private static bool chartypewithidentityconversioninassignment() {	int failcount = 0;	dynamic d = 'a';	char result = d;	if (result != 'a') {	failcount++;	
test failed at conversion result 

private static bool sbytetypewithidentityconversioninassignment() {	int failcount = 0;	dynamic d = (sbyte)-128;	sbyte result = d;	if (result != -128) {	failcount++;	
test failed at conversion result 

private static bool bytetypewithidentityconversioninassignment() {	int failcount = 0;	dynamic d = (byte)0;	byte result = d;	if (result != 0) {	failcount++;	
test failed at conversion result 

private static bool nullablebooltypewithidentityconversioninassignment() {	int failcount = 0;	bool? origin = true;	dynamic d = origin;	bool? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullablechartypewithidentityconversioninassignment() {	int failcount = 0;	char? origin = '\0';	dynamic d = origin;	char? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullablesbytetypewithidentityconversioninassignment() {	int failcount = 0;	sbyte? origin = 127;	dynamic d = origin;	sbyte? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullablebytetypewithidentityconversioninassignment() {	int failcount = 0;	byte? origin = 255;	dynamic d = origin;	byte? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool shorttypewithnumbericconversionfromsbyteinassignment() {	int failcount = 0;	sbyte origin = sbyte.minvalue;	dynamic d = origin;	short result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool ushorttypewithnumbericconversionfromcharinassignment() {	int failcount = 0;	char origin = char.minvalue;	dynamic d = origin;	ushort result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool inttypewithnumbericconversionfromsbyteinassignment() {	int failcount = 0;	sbyte origin = sbyte.minvalue;	dynamic d = origin;	int result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool uinttypewithnumbericconversionfrombyteinassignment() {	int failcount = 0;	byte origin = byte.maxvalue;	dynamic d = origin;	uint result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool longtypewithnumbericconversionfromshortinassignment() {	int failcount = 0;	short origin = short.maxvalue;	dynamic d = origin;	long result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool ulongtypewithnumbericconversionfromushortinassignment() {	int failcount = 0;	ushort origin = ushort.maxvalue;	dynamic d = origin;	ulong result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullableshorttypewithnumbericconversionfrombyteinassignment() {	int failcount = 0;	byte? origin = byte.maxvalue;	dynamic d = origin;	short? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullableushorttypewithnumbericconversionfrombyteinassignment() {	int failcount = 0;	byte? origin = byte.minvalue;	dynamic d = origin;	short? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullableinttypewithnumbericconversionfromshortinassignment() {	int failcount = 0;	short? origin = short.maxvalue;	dynamic d = origin;	int? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullableuinttypewithnumbericconversionfromushortinassignment() {	int failcount = 0;	ushort? origin = ushort.maxvalue;	dynamic d = origin;	uint? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullablelongtypewithnumbericconversionfromintinassignment() {	int failcount = 0;	int? origin = int.minvalue;	dynamic d = origin;	long? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullableulongtypewithnullablenumbericconversionfromuintinassignment() {	int failcount = 0;	uint origin = uint.maxvalue;	dynamic d = origin;	ulong? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool floattypewithnumbericconversionfromintinassignment() {	int failcount = 0;	int origin = int.maxvalue;	dynamic d = origin;	float result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool doubletypewithnumbericconversionfromulonginassignment() {	int failcount = 0;	ulong origin = ulong.minvalue;	dynamic d = origin;	double result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool decimaltypewithnumbericconversionfromuintinassignment() {	int failcount = 0;	uint origin = uint.maxvalue;	dynamic d = origin;	decimal result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool guidtypewithidentityconversioninassignment() {	int failcount = 0;	guid origin = new guid("11111111-2222-3333-4444-555555555555");	dynamic d = origin;	guid result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool datetimetypewithidentityconversioninassignment() {	int failcount = 0;	datetime origin = datetime.now;	dynamic d = origin;	datetime result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullablefloattypewithnumbericconversionfromlonginassignment() {	int failcount = 0;	long? origin = long.maxvalue;	dynamic d = origin;	float? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullabledoubletypewithnumbericconversionfromfloatinassignment() {	int failcount = 0;	float? origin = +0.0f;	dynamic d = origin;	double? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullabledecimaltypewithnumbericconversionfromulonginassignment() {	int failcount = 0;	ulong? origin = ulong.maxvalue;	dynamic d = origin;	decimal? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullableguidtypewithidentityconversioninassignment() {	int failcount = 0;	guid? origin = new guid("11111111-2222-3333-4444-555555555555");	dynamic d = origin;	guid? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullabledatetimetypewithnullableidentityconversioninassignment() {	int failcount = 0;	datetime origin = datetime.now;	dynamic d = origin;	datetime? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool userdefinedstructwithidentityconversioninassignment() {	int failcount = 0;	s origin = new s(10);	dynamic d = origin;	s result = d;	if (result.f != origin.f) {	failcount++;	
test failed at conversion result 

private static bool userdefinedstructwithuserdefinedimplicitconversioninassignment() {	int failcount = 0;	s origin = new s(10);	dynamic d = origin;	s2 result = d;	if (result.f != origin.f) {	failcount++;	
test failed at conversion result 

private static bool userdefinedgenericstructwithidentityconversioninassignment() {	int failcount = 0;	gs<int> origin = new gs<int>(10);	dynamic d = origin;	gs<int> result = d;	if (result.f != origin.f) {	failcount++;	
test failed at conversion result 

private static bool userdefinedenumwithidentityconversioninassignment() {	int failcount = 0;	e origin = e.one;	dynamic d = origin;	e result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool nullableuserdefinedstructwithidentityconversioninassignment() {	int failcount = 0;	s? origin = new s(10);	dynamic d = origin;	s? result = d;	if (result.value.f != origin.value.f) {	failcount++;	
test failed at conversion result 

private static bool nullableuserdefinedstructwithnullableuserdefinedimplicitconversioninassignment() {	int failcount = 0;	s origin = new s(10);	dynamic d = origin;	s2? result = d;	if (result.value.f != origin.f) {	failcount++;	
test failed at conversion result 

private static bool nullableuserdefinedgenericstructwithnullableidentityconversioninassignment() {	int failcount = 0;	gs<int> origin = new gs<int>(10);	dynamic d = origin;	gs<int>? result = d;	if (result.value.f != origin.f) {	failcount++;	
test failed at conversion result 

private static bool nullableuserdefinedenumwithnullableidentityconversioninassignment() {	int failcount = 0;	e origin = e.one;	dynamic d = origin;	e? result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool stringwithidentityconversioninassignment() {	int failcount = 0;	string origin = "aabb";	dynamic d = origin;	string result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool objectwithreferenceconversionfromstringinassignment() {	int failcount = 0;	string origin = "aabb";	dynamic d = origin;	object result = d;	if ((string)result != origin) {	failcount++;	
test failed at conversion result 

private static bool objectwithboxingconversionfromintinassignment() {	int failcount = 0;	int origin = 10;	dynamic d = origin;	object result = d;	if ((int)result != origin) {	failcount++;	
test failed at conversion result 

private static bool valuetypewithboxingconversionfromuserdefinedstructinassignment() {	int failcount = 0;	s origin = new s(10);	dynamic d = origin;	valuetype result = d;	if (((s)result).f != origin.f) {	failcount++;	
test failed at conversion result 

private static bool enumwithboxingconversionfromuserdefinedenuminassignment() {	int failcount = 0;	e origin = e.two;	dynamic d = origin;	enum result = d;	if ((e)result != origin) {	failcount++;	
test failed at conversion result 

private static bool arraywithreferenceconversionfromuserdefinedarrayinassignment() {	int failcount = 0;	var origin = new[]	{	1, 2, 3 }	;	dynamic d = origin;	array result = d;	if (((int[])result)[1] != origin[1]) {	failcount++;	
test failed at conversion result 

private static bool delegatewithreferenceconversionfromuserdefineddelegateinassignment() {	int failcount = 0;	d origin = s.m;	dynamic d = origin;	delegate result = d;	if ((int)result.dynamicinvoke(null) != origin()) {	failcount++;	
test failed at conversion result 

private static bool exceptionwithreferenceconversionfromuserdefinedexceptioninassignment() {	int failcount = 0;	var origin = new myexception(0xe000);	dynamic d = origin;	exception result = d;	if (((myexception)result).code != origin.code) {	failcount++;	
test failed at conversion result 

private static bool arraywithidentityconversioninassignment() {	int failcount = 0;	var origin = new[]	{	1, 2, 3 }	;	dynamic d = origin;	int[] result = d;	if (result[1] != origin[1]) {	failcount++;	
test failed at conversion result 

private static bool arraywithreferenceconversioninassignment() {	int failcount = 0;	var origin = new[]	{	"aa", "bb", "cc" }	;	dynamic d = origin;	object[] result = d;	if ((string)(result[1]) != origin[1]) {	failcount++;	
test failed at conversion result 

private static bool delegatewithidentityconversioninassignment() {	int failcount = 0;	d origin = c.m1;	dynamic d = origin;	d result = d;	if (result() != origin()) {	failcount++;	
test failed at conversion result 

private static bool genericdelegatewithidentityconversioninassignment() {	int failcount = 0;	gd<int> origin = c.m1;	dynamic d = origin;	gd<int> result = d;	if (result() != origin()) {	failcount++;	
test failed at conversion result 

private static bool variantgenericdelegatewithidentityconversioninassignment() {	int failcount = 0;	vgd<int, int> origin = c.m2;	dynamic d = origin;	vgd<int, int> result = d;	if (result(11) != origin(11)) {	failcount++;	
test failed at conversion result 

private static bool userdefinedclasswithreferenceconversioninassignment() {	int failcount = 0;	var origin = new c();	dynamic d = origin;	b result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool userdefinedclasswithuserdefinedimplicitconversioninassignment() {	int failcount = 0;	var origin = new c(22);	dynamic d = origin;	c2 result = d;	if (result.f1 != origin.f1) {	failcount++;	
test failed at conversion result 

private static bool userdefinedgenericclasswithreferenceconversioninassignment() {	int failcount = 0;	var origin = new ggc<int>();	dynamic d = origin;	gb<int> result = d;	if (result != origin) {	failcount++;	
test failed at conversion result 

private static bool testmethodforreferenceconversionfromstringtoobjectinassignment<t>() where t : class {	int failcount = 0;	var origin = "aa";	dynamic d = origin;	t result = d;	if (result != (object)origin) {	failcount++;	
test failed at conversion result 

private static bool testmethodforreferenceconversiontobaseclassinassignment<t>() where t : b {	int failcount = 0;	var origin = new c();	dynamic d = origin;	t result = d;	if (result != (b)origin) {	failcount++;	
test failed at conversion result 

private static bool testmethodforreferenceconversiontobaseinterfaceinassignment<t>() where t : class, i {	int failcount = 0;	var origin = new c();	dynamic d = origin;	t result = d;	if (result != (i)origin) {	failcount++;	
test failed at conversion result 

private static bool nopredefinedimplicitconversionbutexistexplicitconversion() {	int failcount = 0;	ulong origin = 100;	dynamic d = origin;	try {	int result = (int)d;	if ((ulong)result != origin) {	failcount++;	
test failed at conversion result 

ulong origin = 100;	dynamic d = origin;	try {	int result = (int)d;	if ((ulong)result != origin) {	failcount++;	}	}	catch (exception e) {	failcount++;	
test failed catch an unknown exception 

private static bool nouserdefinedimplicitconversionbutexistexplicitconversion() {	int failcount = 0;	c origin = new c(22);	dynamic d = origin;	try {	c2 result = (c2)d;	if (result.f1 != origin.f1) {	failcount++;	
test failed at conversion result 

c origin = new c(22);	dynamic d = origin;	try {	c2 result = (c2)d;	if (result.f1 != origin.f1) {	failcount++;	}	}	catch (exception e) {	failcount++;	
test failed catch an unknown exception 

private static bool nopredefinedimplicitandexplicitconversion() {	int failcount = 0;	string origin = "aa";	dynamic d = origin;	try {	int result = d;	failcount++;	
test failed should throw exception 

dynamic d = origin;	try {	int result = d;	failcount++;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (!errorverifier.verify(errormessageid.noimplicitconv, e.message, "string", "int")) failcount++;	}	catch (exception e) {	failcount++;	
test failed catch an unknown exception 

private static bool nopredefinedimplicitandexplicitconversionforarray() {	int failcount = 0;	var origin = new int[]	{	1, 2, 3 }	;	dynamic d = origin;	try {	long[] result = d;	failcount++;	
test failed should throw exception 

dynamic d = origin;	try {	long[] result = d;	failcount++;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (!errorverifier.verify(errormessageid.noimplicitconv, e.message, "int[]", "long[]")) failcount++;	}	catch (exception e) {	failcount++;	
test failed catch an unknown exception 

private static bool nouserdefinedimplicitandexplicitconversion() {	int failcount = 0;	c origin = new c();	dynamic d = origin;	try {	c2 result = d;	failcount++;	
test failed should throw exception 

dynamic d = origin;	try {	c2 result = d;	failcount++;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (!errorverifier.verify(errormessageid.noimplicitconv, e.message, "c", "c2")) failcount++;	}	catch (exception e) {	failcount++;	
test failed catch an unknown exception 

private static bool leftislocalvariable() {	int failcount = 0;	sbyte origin = 10;	dynamic d = origin;	int result = d;	if (result != origin) {	failcount++;	
test failed conversion result is incorrect 

private static bool leftisinstancefield() {	int failcount = 0;	sbyte origin = 10;	dynamic d = origin;	var c = new c();	c.f1 = d;	if (c.f1 != origin) {	failcount++;	
test failed conversion result is incorrect 

private static bool leftisstaticfield() {	int failcount = 0;	byte origin = 10;	dynamic d = origin;	c.f2 = d;	if (c.f2 != origin) {	failcount++;	
test failed conversion result is incorrect 

private static bool leftisinstanceproperty() {	int failcount = 0;	sbyte origin = 10;	dynamic d = origin;	var c = new c();	c.p1 = d;	if (c.p1 != origin) {	failcount++;	
test failed conversion result is incorrect 

private static bool leftisstaticproperty() {	int failcount = 0;	byte origin = 10;	dynamic d = origin;	c.p2 = d;	if (c.p2 != (ulong)origin) {	failcount++;	
test failed conversion result is incorrect 

private static bool leftisinstancedelegatefield() {	int failcount = 0;	d origin = c.m;	dynamic d = origin;	var c = new c();	c.f3 = d;	if (c.f3(11) != origin(11)) {	failcount++;	
test failed conversion result is incorrect 

private static bool leftisstaticdelegatefield() {	int failcount = 0;	d origin = c.m;	dynamic d = origin;	c.f4 = d;	if (c.f4(22) != origin(22)) {	failcount++;	
test failed conversion result is incorrect 

private static bool leftisinstanceindexer() {	int failcount = 0;	sbyte origin = 10;	dynamic d = origin;	var c = new c();	c[1] = d;	if (c[1] != origin) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	sbyte origin = 10;	dynamic d = origin;	byte origin2 = 20;	dynamic d2 = origin2;	var c = new c() {	f1 = d, p1 = d2 }	;	if ((c.f1 != origin) || (c.p1 != origin2)) {	failcount++;	
test failed conversion result is incorrect 

private static bool inifstatement() {	int failcount = 0;	bool origin = false;	dynamic d = origin;	if (d) {	failcount++;	
test failed conversion result is incorrect 

private static bool inwhilestatement() {	int failcount = 0;	bool origin = false;	dynamic d = origin;	while (d) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	bool origin = false;	dynamic d = origin;	int count = 0;	do {	if (count == 0) {	count++;	}	else {	failcount++;	
test failed conversion result is incorrect 

private static bool inforstatement() {	int failcount = 0;	bool origin = false;	dynamic d = origin;	for (; d;) {	failcount++;	
test failed conversion result is incorrect 

private static bool inconditionaloperator() {	int failcount = 0;	bool origin = false;	dynamic d = origin;	if (d ? true : false) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	var a = new[]	{	1, 2, 3 }	;	bool origin = true;	dynamic d = origin;	var q = ( from m in a where d select m).toarray();	if (q[1] != a[1]) {	failcount++;	
test failed conversion result is incorrect 

private static bool inifstatement0() {	int failcount = 0;	c origin = new c(0);	dynamic d = origin;	if ((bool)d) {	}	else {	failcount++;	
test failed conversion result is incorrect 

private static bool inifstatement1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	if ((bool)d) {	failcount++;	
test failed conversion result is incorrect 

private static bool inwhilestatement1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	while ((bool)d) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	c origin = new c(1);	dynamic d = origin;	int count = 0;	do {	if (count == 0) {	count++;	}	else {	failcount++;	
test failed conversion result is incorrect 

int count = 0;	c origin = new c(0);	dynamic d = origin;	for (; (bool)d;) {	if (count == 0) {	count++;	break;	}	else {	failcount++;	
test failed conversion result is incorrect 

private static bool inforstatement1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	for (; (bool)d;) {	failcount++;	
test failed conversion result is incorrect 

private static bool inconditionaloperator0() {	int failcount = 0;	c origin = new c(0);	dynamic d = origin;	if (!((bool)d ? true : false)) {	failcount++;	
test failed conversion result is incorrect 

private static bool inconditionaloperator1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	if ((bool)d ? true : false) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	var a = new[]	{	1, 2, 3 }	;	c origin = new c(0);	dynamic d = origin;	var q = ( from m in a where (bool)d select m).toarray();	if (q[1] != a[1]) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	var a = new[]	{	1, 2, 3 }	;	c origin = new c(1);	dynamic d = origin;	var q = ( from m in a where (bool)d select m).toarray();	if (q.length != 0) {	failcount++;	
test failed conversion result is incorrect 

private static bool inifstatement0() {	int failcount = 0;	c origin = new c(0);	dynamic d = origin;	if (!d) {	failcount++;	
test failed conversion result is incorrect 

private static bool inifstatement1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	if (d) {	failcount++;	
test failed conversion result is incorrect 

private static bool inwhilestatement0() {	int failcount = 0;	c origin = new c(0);	dynamic d = origin;	while (!d) {	failcount++;	
test failed conversion result is incorrect 

private static bool inwhilestatement1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	while (d) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	c origin = new c(0);	dynamic d = origin;	int count = 0;	do {	if (count == 0) {	count++;	}	else {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	c origin = new c(1);	dynamic d = origin;	int count = 0;	do {	if (count == 0) {	count++;	}	else {	failcount++;	
test failed conversion result is incorrect 

private static bool inforstatement0() {	int failcount = 0;	c origin = new c(0);	dynamic d = origin;	for (; !d;) {	failcount++;	
test failed conversion result is incorrect 

private static bool inforstatement1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	for (; d;) {	failcount++;	
test failed conversion result is incorrect 

private static bool inconditionaloperator0() {	int failcount = 0;	c origin = new c(0);	dynamic d = origin;	if (!(d ? true : false)) {	failcount++;	
test failed conversion result is incorrect 

private static bool inconditionaloperator1() {	int failcount = 0;	c origin = new c(1);	dynamic d = origin;	if (d ? true : false) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	var a = new[]	{	1, 2, 3 }	;	c origin = new c(0);	dynamic d = origin;	var q = ( from m in a where d select m).toarray();	if (q[1] != a[1]) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	var a = new[]	{	1, 2, 3 }	;	c origin = new c(1);	dynamic d = origin;	var q = ( from m in a where !d select m).toarray();	if (q[1] != a[1]) {	failcount++;	
test failed conversion result is incorrect 

private static bool inifstatement0() {	int failcount = 0;	c origin = new c();	dynamic d = origin;	if (d) {	}	else {	failcount++;	
test failed conversion result is incorrect 

private static bool inifstatement1() {	int failcount = 0;	c1 origin = new c1();	dynamic d = origin;	if (d) {	failcount++;	
test failed conversion result is incorrect 

private static bool inwhilestatement1() {	int failcount = 0;	c1 origin = new c1();	dynamic d = origin;	while (d) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	c1 origin = new c1();	dynamic d = origin;	int count = 0;	do {	if (count == 0) {	count++;	}	else {	failcount++;	
test failed conversion result is incorrect 

int count = 0;	c origin = new c();	dynamic d = origin;	for (; d;) {	if (count == 0) {	count++;	break;	}	else {	failcount++;	
test failed conversion result is incorrect 

private static bool inforstatement1() {	int failcount = 0;	c1 origin = new c1();	dynamic d = origin;	for (; d;) {	failcount++;	
test failed conversion result is incorrect 

private static bool inconditionaloperator0() {	int failcount = 0;	c origin = new c();	dynamic d = origin;	if (!(d ? true : false)) {	failcount++;	
test failed conversion result is incorrect 

private static bool inconditionaloperator1() {	int failcount = 0;	c1 origin = new c1();	dynamic d = origin;	if (d ? true : false) {	failcount++;	
test failed conversion result is incorrect 

private static bool inmethod() {	int failcount = 0;	if (testingmethod(25) != 25) {	failcount++;	
test failed conversion result is incorrect 

private static bool inpropertyget() {	int failcount = 0;	testingproperty = 33;	if (testingproperty != 33) {	failcount++;	
test failed conversion result is incorrect 

private static bool inindexerget() {	int failcount = 0;	var t = new conversioninreturn();	if (t[33] != 33) {	failcount++;	
test failed conversion result is incorrect 

private static bool inoperator() {	int failcount = 0;	var t = new conversioninreturn();	if ((t + 44) != 44) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	bool ispass = false;	foreach (var v in testingreturnienumerable(25)) {	if ((byte)v == 25) {	ispass = true;	}	break;	}	if (!ispass) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	bool ispass = false;	foreach (var v in testingreturnienumerablet(33)) {	if (v == 33) {	ispass = true;	}	break;	}	if (!ispass) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	bool ispass = false;	foreach (var v in new nctestingreturnienumerator(25)) {	if ((byte)v == 25) {	ispass = true;	}	break;	}	if (!ispass) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	bool ispass = false;	foreach (var v in new nctestingreturnienumeratort(33)) {	if (v == 33) {	ispass = true;	}	break;	}	if (!ispass) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinsecondoperandandfirstisnull() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	long? first = null;	if ((long)(first ?? d) != 24) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinsecondoperand() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	long? first = 33;	if ((long)(first ?? d) != 33) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinfirstoperand() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	long? second = 2;	if ((long)(d ?? second) != 24) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinfirstoperandandfirstisnull() {	int failcount = 0;	dynamic d = null;	long? second = 2;	if ((long)(d ?? second) != 2) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinsecondandthirdoperandandconditionistrue() {	int failcount = 0;	byte origin = 24;	dynamic d1 = origin;	dynamic d2 = 33;	bool cond = true;	if ((int)(cond ? d1 : d2) != 24) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinsecondandthirdoperandandconditionisfalse() {	int failcount = 0;	byte origin = 24;	dynamic d1 = origin;	dynamic d2 = 33;	bool cond = false;	if ((int)(cond ? d1 : d2) != 33) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinsecondoperandandconditionistrue() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	long third = 33;	bool cond = true;	if ((long)(cond ? d : third) != 24) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinthirdoperandandconditionisfalse() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	ulong second = 33;	bool cond = false;	if ((ulong)(cond ? second : d) != 24) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinsecondoperandandthirdisnullableandconditionistrue() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	long? third = 33;	bool cond = true;	if ((long)(cond ? d : third) != 24) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectinthirdoperandandsecondisnullableandconditionisfalse() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	ulong? second = 33;	bool cond = false;	if ((ulong)(cond ? second : d) != 24) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectindimensionexpressionlist() {	int failcount = 0;	byte origin = 24;	dynamic d = origin;	var a = new int[(int)d];	a[0] = 10;	if ((a[0] != 10) || (a.length != 24)) {	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	byte origin = 24;	dynamic d = origin;	dynamic d2 = 33;	var a = new int[]	{	d, d2 }	;	if ((a[0] != 24) || (a[1] != 33)) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamiclocalvariabledefinitioninusing() {	int failcount = 0;	c.calleddisposeflag = false;	using (dynamic d = new c()) {	if (((int)d.m(10)) != 10) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamiclocalvariabledefinitioninusing() {	int failcount = 0;	c.calleddisposeflag = false;	using (dynamic d = new c()) {	if (((int)d.m(10)) != 10) {	failcount++;	}	}	if (!c.calleddisposeflag) {	failcount++;	
test failed didn t called the dispose 

private static bool runtimetypenotconvertibletoboolbutwithtrueoperator() {	int failcount = 1;	dynamic d = new c1();	if (d) {	failcount--;	}	else {	
test failed conversion result is incorrect 

private static bool runtimetypenotconvertibletobool() {	int failcount = 0;	dynamic d = new c2();	try {	if (d) {	failcount++;	
test failed conversion result is incorrect 

private static bool dynamicobjectdoesntimplementidisposable() {	int failcount = 0;	dynamic d = new c1();	try {	using (d) {	
test failed conversion result is incorrect 

private static bool inusing() {	int failcount = 0;	dynamic d = null;	try {	using (idisposable i = d) {	}	}	catch (exception e) {	failcount++;	
test failed caught an unexpected exception 

private static bool inassignment() {	int failcount = 0;	dynamic d = null;	try {	int result = d;	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	dynamic d = null;	try {	int result = d;	failcount++;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	}	catch (exception e) {	failcount++;	
test failed caught an unexpected exception 

private static bool inbooleanexpression() {	int failcount = 0;	dynamic d = null;	try {	if (d) {	failcount++;	
test failed conversion result is incorrect 

try {	if (d) {	failcount++;	}	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (!errorverifier.verify(errormessageid.valuecantbenull, e.message, "bool")) failcount++;	}	catch (exception e) {	failcount++;	
test failed caught an unexpected exception 

private static bool inreturn() {	int failcount = 0;	try {	testinginreturn();	failcount++;	
test failed conversion result is incorrect 

int failcount = 0;	try {	testinginreturn();	failcount++;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (!errorverifier.verify(errormessageid.valuecantbenull, e.message, "bool")) failcount++;	}	catch (exception e) {	failcount++;	
test failed caught an unexpected exception 

public void dispose() {	
s 

public void dispose() {	
c 

========================= corefx sample_112 =========================

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
supports 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
supports 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.notnull(ipproperties.anycastaddresses);	
anycast addresses 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.notnull(ipproperties.anycastaddresses);	foreach (ipaddressinformation anyaddr in ipproperties.anycastaddresses) {	_log.writeline("-- " + anyaddr.address.tostring());	
dns eligible 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.notnull(ipproperties.anycastaddresses);	foreach (ipaddressinformation anyaddr in ipproperties.anycastaddresses) {	_log.writeline("-- " + anyaddr.address.tostring());	
transient 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.notnull(ipproperties.anycastaddresses);	foreach (ipaddressinformation anyaddr in ipproperties.anycastaddresses) {	_log.writeline("-- " + anyaddr.address.tostring());	}	assert.notnull(ipproperties.dhcpserveraddresses);	
dhcp server addresses 

assert.notnull(ipproperties);	assert.notnull(ipproperties.anycastaddresses);	foreach (ipaddressinformation anyaddr in ipproperties.anycastaddresses) {	_log.writeline("-- " + anyaddr.address.tostring());	}	assert.notnull(ipproperties.dhcpserveraddresses);	foreach (ipaddress dhcp in ipproperties.dhcpserveraddresses) {	_log.writeline("-- " + dhcp.tostring());	}	assert.notnull(ipproperties.dnsaddresses);	
dns addresses 

}	assert.notnull(ipproperties.dhcpserveraddresses);	foreach (ipaddress dhcp in ipproperties.dhcpserveraddresses) {	_log.writeline("-- " + dhcp.tostring());	}	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	
dns suffix 

assert.notnull(ipproperties.dhcpserveraddresses);	foreach (ipaddress dhcp in ipproperties.dhcpserveraddresses) {	_log.writeline("-- " + dhcp.tostring());	}	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	
gateway addresses 

}	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	
dns enabled 

}	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	
dynamic dns enabled 

assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	
multicast addresses 

_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	
dns eligible 

_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	
transient 

assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	
unicast addresses 

foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	
preferred lifetime 

foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	
valid lifetime 

foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	
dhcp lease lifetime 

foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	
duplicate address detection state 

_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.notnull(uni.ipv4mask);	
mask 

_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.notnull(uni.ipv4mask);	
dns eligible 

_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.notnull(uni.ipv4mask);	
transient 

_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.notnull(uni.ipv4mask);	
prefix origin 

_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.notnull(uni.ipv4mask);	
suffix origin 

_log.writeline("-- " + gateway.address.tostring());	}	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.notnull(uni.ipv4mask);	
prefix length 

foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.notnull(uni.ipv4mask);	assert.notequal(0, uni.prefixlength);	}	assert.notnull(ipproperties.winsserversaddresses);	
wins addresses 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	
properties 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv4)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv4properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
index 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv4)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv4properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
isautomaticprivateaddressingactive 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv4)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv4properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
isautomaticprivateaddressingenabled 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv4)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv4properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
isdhcpenabled 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv4)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv4properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
isforwardingenabled 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv4)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv4properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
mtu 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv4)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv4properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
useswins 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	
properties 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv6)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv6properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	
is null 

ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv6)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv6properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	continue;	}	
index 

ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv6)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv6properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	continue;	}	
mtu 

ipinterfaceproperties ipproperties = nic.getipproperties();	if (!nic.supports(networkinterfacecomponent.ipv6)) {	var nie = assert.throws<networkinformationexception>(() => ipproperties.getipv6properties());	assert.equal(socketerror.protocolnotsupported, (socketerror)nie.errorcode);	continue;	}	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	continue;	}	
scopeid 

public void ipv6scopeid_accessallvalues_success() {	assert.true(capability.ipv6support());	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipv6scopeid_accessallvalues_success() {	assert.true(capability.ipv6support());	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	if (!nic.supports(networkinterfacecomponent.ipv6)) {	continue;	}	ipinterfaceproperties ipproperties = nic.getipproperties();	
scope levels 

public void ipv6scopeid_accessallvalues_success() {	assert.true(capability.ipv6support());	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	if (!nic.supports(networkinterfacecomponent.ipv6)) {	continue;	}	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	array values = enum.getvalues(typeof(scopelevel));	foreach (scopelevel level in values) {	
level 

========================= corefx sample_13385 =========================

exceptiondispatchinfo exceptioninfo = exceptiondispatchinfo.capture(item.exception);	exceptioninfo.throw();	}	}	else if (item.status == taskstatus.rantocompletion) {	if (item.result.equals(liveconnectioninternal)) {	if (!taskwithliveconnection) taskwithliveconnection = true;	}	else if (!item.result.equals(deadconnectioninternal) && !taskwithnewconnection) taskwithnewconnection = true;	}	
error task in unknown state 

========================= corefx sample_11111 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	
error 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	errorcount++;	errorinnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

========================= corefx sample_12527 =========================

private void verifyoutput(string expected) {	string actual = _strwriter.tostring();	if (actual != expected) {	
expected 

private void verifyoutput(string expected) {	string actual = _strwriter.tostring();	if (actual != expected) {	
actual 

========================= corefx sample_12467 =========================

threadlocal<string> tlocal = null;	int numofthreads = 10;	task[] threads = new task[numofthreads];	object alock = new object();	list<string> seenvaluesfromallthreads = new list<string>();	int counter = 0;	tlocal = new threadlocal<string>(() => (++counter).tostring());	for (int i = 0; i < threads.length; ++i) {	threads[i] = new task(() => {	string value = tlocal.value;	
val 

========================= corefx sample_9881 =========================

debug.assert(this.exceptionid != null, "exceptionid must be initialized to a valid fully qualified type name");	debug.assert(this.resourceid != null, "resourceid must be initialized to string.empty, in which case messagefragment is used, or a legal resource id");	debug.assert(this.messagefragment != null, "messagefragment must be initialized to string.empty, in which case resourceid is used, or a string that represents a specific exception message.");	if (!isxmlexception(this.exceptionid)) {	return objecttocompareto.exceptionid.equals(this.exceptionid);	}	else {	if (!objecttocompareto.resourceid.equals(string.empty) && !objecttocompareto.resourceid.equals(xmluserex) && objecttocompareto.resourceid.equals(this.resourceid)) {	if (objecttocompareto.exceptionid.equals(this.exceptionid)) return true;	else {	
match compare to pls investigate why this resource id is being thrown in differet exceptions 

if (!objecttocompareto.resourceid.equals(string.empty) && !objecttocompareto.resourceid.equals(xmluserex) && objecttocompareto.resourceid.equals(this.resourceid)) {	if (objecttocompareto.exceptionid.equals(this.exceptionid)) return true;	else {	return true;	}	}	else if (!this.messagefragment.equals(string.empty) && _examinemessages) {	if (objecttocompareto.resourceid.equals(this.resourceid) && objecttocompareto.messagefragment.contains(this.messagefragment)) {	if (objecttocompareto.exceptionid.equals(this.exceptionid)) return true;	else {	
match message matches but exact typename doesn t compare to 

}	else if (!this.messagefragment.equals(string.empty) && _examinemessages) {	if (objecttocompareto.resourceid.equals(this.resourceid) && objecttocompareto.messagefragment.contains(this.messagefragment)) {	if (objecttocompareto.exceptionid.equals(this.exceptionid)) return true;	else {	return false;	}	}	}	else {	
old comparison compare to 

========================= corefx sample_12614 =========================

public static exception fatalerror(string description) {	
fatal test error 

========================= corefx sample_10952 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	}	else if (args.severity == xmlseveritytype.error) {	
error 

========================= corefx sample_12513 =========================

public void openreceivedata() {	using (cancellationtokensource cts = new cancellationtokensource()) {	var workertask = new task(() => openreceivedata_workerthread(cts.token));	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
open and close port while the port is receiving data 

public void openreceivedataandrts() {	using (cancellationtokensource cts = new cancellationtokensource()) {	var workertask = new task(() => openreceivedataandrts_workerthread(cts.token));	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
open and close port while the port is recieving data and the rts pin is changing states 

try {	int iterationcount = tcsupport.runshortstresstests ? 10 : 1000;	for (int i = 0; i < iterationcount; ++i) {	com.open();	com.handshake = handshake.requesttosend;	com.write(xmitbytes, 0, xmitbytes.length);	com.close();	}	}	catch (exception e) {	
threw the following exception 

byte[] xmitbytes = new byte[16];	for (int i = 0; i < xmitbytes.length; ++i) xmitbytes[i] = (byte)i;	com.open();	while (!ct.iscancellationrequested) {	com.write(xmitbytes, 0, xmitbytes.length);	com.rtsenable = !com.rtsenable;	}	}	}	catch (exception e) {	
threw the following exception 

========================= corefx sample_639 =========================

protected override void test() {	
testing 

========================= corefx sample_12480 =========================

public static void runspinlocktests_negativetests() {	for (int i = 0; i < 2; i++) {	bool b;	if (i == 0) {	
no thread ids new spinlock true 

public static void runspinlocktests_negativetests() {	for (int i = 0; i < 2; i++) {	bool b;	if (i == 0) {	b = true;	}	else {	
with thread ids new spinlock false 

========================= corefx sample_9895 =========================

private void runbenchmark(int count, int bits, action<biginteger> operation) {	biginteger[] value = createintegerseed(count, bits);	long result = runbenchmark(count, i => operation(value[i]));	
ms ops 

private void runbenchmark(int count, int leftbits, int rightbits, action<biginteger, biginteger> operation) {	biginteger[] left = createintegerseed(count, leftbits);	biginteger[] right = createintegerseed(count, rightbits);	long result = runbenchmark(count, i => operation(left[i], right[i]));	
ms ops 

private void runbenchmark(int count, int leftbits, int rightbits, int otherbits, action<biginteger, biginteger, biginteger> operation) {	biginteger[] left = createintegerseed(count, leftbits);	biginteger[] right = createintegerseed(count, rightbits);	biginteger[] other = createintegerseed(count, otherbits);	long result = runbenchmark(count, i => operation(left[i], right[i], other[i]));	
ms ops 

========================= corefx sample_8928 =========================

public void verifynametableget(object objactual, string str, char[] ach, int offset, int length) {	object objexpected = null;	if (nametablever == enametable_ver.verify_with_getstr) {	objexpected = datareader.nametable.get(str);	
verifynametablewgetstr 

public void verifynametableget(object objactual, string str, char[] ach, int offset, int length) {	object objexpected = null;	if (nametablever == enametable_ver.verify_with_getstr) {	objexpected = datareader.nametable.get(str);	cerror.compare(objactual, objexpected, "verifynametablewgetstr");	}	else if (nametablever == enametable_ver.verify_with_getchar) {	objexpected = datareader.nametable.get(ach, offset, length);	
verifynametablewgetchar 

public void verifynametableadd(object objactual, string str, char[] ach, int offset, int length) {	object objexpected = null;	if (nametablever == enametable_ver.verify_with_addstr) {	objexpected = datareader.nametable.add(ach, offset, length);	
verifynametablewaddstr 

public void verifynametableadd(object objactual, string str, char[] ach, int offset, int length) {	object objexpected = null;	if (nametablever == enametable_ver.verify_with_addstr) {	objexpected = datareader.nametable.add(ach, offset, length);	cerror.compare(objactual, objexpected, "verifynametablewaddstr");	}	else if (nametablever == enametable_ver.verify_with_addchar) {	objexpected = datareader.nametable.add(str);	
verifynametablewaddchar 

string str = "";	char[] ach = str.tochararray();	bool fretry = false;	for (; ;) {	try {	str = new string('z', size);	ach = str.tochararray();	}	catch (outofmemoryexception exc) {	size >>= 1;	
retry with 

public int variation_17() {	object objactual = datareader.nametable.get(chval, 0, 0);	object objactual1 = datareader.nametable.get(chval, 0, 0);	
here 

public int variation_20() {	object objactual = datareader.nametable.get(chval, 0, -1);	
here 

public int variation_18() {	reloadsource();	string strempty = string.empty;	object objadded = datareader.nametable.add(strempty);	object objadded1 = datareader.nametable.add(strempty.tochararray(), 0, strempty.length);	object objactual1 = datareader.nametable.get(strempty.tochararray(), 0, strempty.length);	object objactual2 = datareader.nametable.get(strempty);	
string 

public int variation_18() {	reloadsource();	string strempty = string.empty;	object objadded = datareader.nametable.add(strempty);	object objadded1 = datareader.nametable.add(strempty.tochararray(), 0, strempty.length);	object objactual1 = datareader.nametable.get(strempty.tochararray(), 0, strempty.length);	object objactual2 = datareader.nametable.get(strempty);	
string 

========================= corefx sample_12600 =========================

private void dumpchars(string stractvalue) {	byte c;	int i;	for (i = 0; i < stractvalue.length; i++) {	c = convert.tobyte(stractvalue[i]);	
char 

public void positiononelement(string strelementname) {	
seeking element 

public void positiononnodetype(xmlnodetype nodetype) {	
seeking nodetype 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	
nodetype doesn t match 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	
expected nodetype 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	
actual nodetype 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	bpassed = false;	}	if (name != strexpname) {	
name doesn t match 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	bpassed = false;	}	if (name != strexpname) {	
expected name 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	bpassed = false;	}	if (name != strexpname) {	
actual name 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	bpassed = false;	}	if (name != strexpname) {	bpassed = false;	}	if (value != strexpvalue) {	
value doesn t match 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	bpassed = false;	}	if (name != strexpname) {	bpassed = false;	}	if (value != strexpvalue) {	
expected value 

public bool verifynode(xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (nodetype != eexpnodetype) {	bpassed = false;	}	if (name != strexpname) {	bpassed = false;	}	if (value != strexpvalue) {	
actual value 

if (nodetype != eexpnodetype) {	bpassed = false;	}	if (name != strexpname) {	bpassed = false;	}	if (value != strexpvalue) {	bpassed = false;	}	if (bpassed) {	
passed 

========================= corefx sample_12422 =========================

public void canread_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying canread property throws exception after open then close 

public void canread_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying canread property throws exception after open then basestream close 

public void canread_afteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying canread property returns true after a call to open 

========================= corefx sample_588 =========================

public static void printchars(char[] chars) {	foreach (char chr in chars) {	
char 

========================= corefx sample_619 =========================

private void openeveryportname() {	foreach (string portname in serialport.getportnames()) {	
opening port 

========================= corefx sample_648 =========================

using (rsa rsapublic = rsafactory.create()) using (rsa rsaprivate = rsafactory.create()) {	try {	rsapublic.importparameters(publicparameters);	}	catch (cryptographicexception) {	return;	}	rsaprivate.importparameters(keyparameters);	if (signature == null) {	signature = signdata(rsaprivate, data, hashalgorithm, padding);	
callername signature bytearraytohex 

========================= corefx sample_4488 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	
error 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	errorcount++;	errorinnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

public void callback1(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning recieved 

set.xmlresolver = new xmlurlresolver();	string path = path.combine(testdata.standardpath, "xsd10", "schema", "schn11_a.xsd");	set.add(null, path);	set.compile();	xmlreadersettings settings = new xmlreadersettings();	settings.validationtype = validationtype.schema;	settings.schemas = set;	using (xmlreader reader = xmlreader.create(new stringreader(xml), settings)) {	try {	while (reader.read()) ;	
xmlschemavalidationexception was not thrown 

private void validatexpathnavigator(xpathnavigator nav, xmlschemaset schemaset) {	
validation succeeded validation failed 

private void onvalidationevent(object sender, validationeventargs e) {	xmlschemavalidationexception exception = e.exception as xmlschemavalidationexception;	if (exception == null || exception.sourceobject == null) {	cerror.compare(exception != null, "exception == null");	cerror.compare(exception.sourceobject != null, "sourceobject == null");	return;	}	if (!platformdetection.isnetnative) {	cerror.compare(exception.sourceobject.gettype().tostring(), "ms.internal.xml.cache.xpathdocumentnavigator", "sourceobject.gettype");	}	
exc 

========================= corefx sample_12507 =========================

try {	w.writedoctype("doc1", null, null, "<!entity e 'abc'>");	w.writedoctype("doc2", null, null, "<!entity f 'abc'>");	}	catch (invalidoperationexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.start : writestate.error, "writestate should be error");	return;	}	catch (nullreferenceexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.start : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writedoctype("doc1", null, null, "test1");	w.writeendelement();	}	catch (invalidoperationexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writeendelement();	w.writedoctype("doc1", null, null, "test1");	}	catch (invalidoperationexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

========================= corefx sample_12447 =========================

public int initreaderpointer() {	int iretval = test_pass;	
initreaderpointer 

public int testmovetocontent() {	if (integrityver == eintegrity.before_read || integrityver == eintegrity.after_resetstate) {	return test_skipped;	}	else {	
nodetype 

public int lookupnamespace() {	reloadsource();	string[] astr = { "a", "foo", for (int i = 0; i < astr.length; i++) {	if (datareader.lookupnamespace(astr[i]) != null) {	
not null lookupnamespace 

========================= corefx sample_12416 =========================

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ((!(bool)(s.instancemethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ((!(bool)(s.instancemethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)(s.instancemethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)(s.instancemethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)(s.instancemethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)(s.instancemethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)(s.instancemethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)(s.instancemethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)(s.instancemethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)(s.instancemethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ( (!(bool)(s.instancemethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ((!(bool)(s.instanceproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ((!(bool)(s.instanceproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)(s.instanceproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)(s.instanceproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)(s.instanceproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)(s.instanceproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)(s.instanceproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)(s.instanceproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)(s.instanceproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)(s.instanceproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ( (!(bool)(s.instanceproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ((!(bool)((s + 1).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)((s + 1) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)((s + 1)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)((s + 1).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)((s + 1).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)((s + 1) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)((s + 1)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)((s + 1).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)((s + 1).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ( (!(bool)((s + 1)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ((!(bool)(s[1].instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ((!(bool)(s[1].instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)(s[1] + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass();	if ( (!(bool)(s[1][2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)(s[1].instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ((!(bool)(s[1].instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)(s[1] + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct();	if ( (!(bool)(s[1][2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)(s[1].instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ((!(bool)(s[1].instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface();	if ( (!(bool)(s[1][2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)(s.instancemethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)(s.instancemethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)(s.instancemethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)(s.instancemethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)(s.instancemethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)(s.instancemethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)(s.instancemethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)(s.instancemethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)(s.instancemethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)(s.instancemethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ( (!(bool)(s.instancemethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)(s.instanceproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)(s.instanceproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)(s.instanceproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)(s.instanceproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)(s.instanceproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)(s.instanceproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)(s.instanceproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)(s.instanceproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)(s.instanceproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)(s.instanceproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ( (!(bool)(s.instanceproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)((s + 1).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)((s + 1).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)((s + 1) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)((s + 1)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)((s + 1).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)((s + 1).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)((s + 1) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)((s + 1)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)((s + 1).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)((s + 1).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ( (!(bool)((s + 1)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)(s[1].instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ((!(bool)(s[1].instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)(s[1] + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicclass<int>();	if ( (!(bool)(s[1][2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)(s[1].instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ((!(bool)(s[1].instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)(s[1] + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicstruct<int>();	if ( (!(bool)(s[1][2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)(s[1].instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ((!(bool)(s[1].instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturndynamicinterface<int>();	if ( (!(bool)(s[1][2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass.staticmethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass.staticmethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass.staticmethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass.staticmethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct.staticmethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct.staticmethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct.staticmethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct.staticmethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface.staticmethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface.staticmethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicinterface.staticmethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass.staticproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass.staticproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass.staticproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass.staticproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct.staticproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct.staticproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct.staticproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct.staticproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface.staticproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface.staticproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicinterface.staticproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass<int>.staticmethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass<int>.staticmethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass<int>.staticmethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass<int>.staticmethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct<int>.staticmethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct<int>.staticmethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct<int>.staticmethod() + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct<int>.staticmethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface<int>.staticmethod().instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface<int>.staticmethod().instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicinterface<int>.staticmethod()[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass<int>.staticproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicclass<int>.staticproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass<int>.staticproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicclass<int>.staticproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct<int>.staticproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicstruct<int>.staticproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct<int>.staticproperty + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicstruct<int>.staticproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface<int>.staticproperty.instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(firstclassreturndynamicinterface<int>.staticproperty.instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(firstclassreturndynamicinterface<int>.staticproperty[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)s.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)s.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)s.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)s.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)s.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)s.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)s.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)s.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)s.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)s.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface();	if ( (!(bool)(((dynamic)s.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)s.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)s.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)s.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)s.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)s.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)s.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)s.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)s.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)s.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)s.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface();	if ( (!(bool)(((dynamic)s.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)(s + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)(s + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)(s + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)(s + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)(s + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)(s + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)(s + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)(s + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)(s + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)(s + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface();	if ( (!(bool)(((dynamic)(s + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)s[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass();	if ((!(bool)(((dynamic)s[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)s[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass();	if ( (!(bool)(((dynamic)s[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)s[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ((!(bool)(((dynamic)s[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)s[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct();	if ( (!(bool)(((dynamic)s[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)s[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface();	if ((!(bool)(((dynamic)s[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface();	if ( (!(bool)(((dynamic)s[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)s.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)s.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)s.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)s.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)s.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)s.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)s.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)s.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)s.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)s.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ( (!(bool)(((dynamic)s.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)s.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)s.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)s.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)s.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)s.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)s.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)s.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)s.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)s.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)s.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ( (!(bool)(((dynamic)s.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)(s + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)(s + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)(s + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)(s + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)(s + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)(s + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)(s + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)(s + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)(s + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)(s + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ( (!(bool)(((dynamic)(s + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)s[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ((!(bool)(((dynamic)s[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)s[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnclass<int>();	if ( (!(bool)(((dynamic)s[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)s[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ((!(bool)(((dynamic)s[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)s[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturnstruct<int>();	if ( (!(bool)(((dynamic)s[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)s[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ((!(bool)(((dynamic)s[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	var s = new firstclassreturninterface<int>();	if ( (!(bool)(((dynamic)s[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass.staticmethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass.staticmethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass.staticmethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass.staticmethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct.staticmethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct.staticmethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct.staticmethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct.staticmethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface.staticmethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface.staticmethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturninterface.staticmethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass.staticproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass.staticproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass.staticproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass.staticproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct.staticproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct.staticproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct.staticproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct.staticproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface.staticproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface.staticproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturninterface.staticproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass<int>.staticmethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass<int>.staticmethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass<int>.staticmethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass<int>.staticmethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct<int>.staticmethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct<int>.staticmethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct<int>.staticmethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct<int>.staticmethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface<int>.staticmethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface<int>.staticmethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturninterface<int>.staticmethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass<int>.staticproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnclass<int>.staticproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass<int>.staticproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondclassindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnclass<int>.staticproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct<int>.staticproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturnstruct<int>.staticproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructoperator() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct<int>.staticproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondstructindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturnstruct<int>.staticproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface<int>.staticproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	if ((!(bool)(((dynamic)firstclassreturninterface<int>.staticproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

static bool callsecondinterfaceindexer() {	int failcount = 0; verify.firstcalled = false;	if ( (!(bool)(((dynamic)firstclassreturninterface<int>.staticproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((secondinterface)d.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((secondinterface)d.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((secondinterface)d.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((secondclass)d.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)d.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((secondinterface)d.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((secondinterface)d.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((secondinterface)d.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((d + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((d + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((d + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	dynamic d = new firstclassreturnclass();	verify.firstcalled = false;	if ((!(((d + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((d + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((d + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((secondstruct)(d + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	dynamic d = new firstclassreturnstruct();	verify.firstcalled = false;	if ((!(((d + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((d + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((d + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	dynamic d = new firstclassreturninterface();	verify.firstcalled = false;	if ((!(((d + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass();	if ((!(((secondclass)d[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass();	if ((!(((secondclass)d[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass();	if ((!(((secondclass)d[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass();	if ((!(((secondclass)d[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct();	if ((!(((secondstruct)d[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct();	if ((!(((secondstruct)d[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct();	if ((!(((secondstruct)d[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct();	if ((!(((secondstruct)d[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface();	if ((!(((secondinterface)d[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface();	if ((!(((secondinterface)d[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface();	if ((!(((secondinterface)d[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instancemethod()) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d.instancemethod()).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d.instancemethod()).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d.instancemethod())[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instanceproperty) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d.instanceproperty).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d.instanceproperty).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d.instanceproperty)[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((d + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((d + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((d + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((d + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((d + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((d + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((d + 1)) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((d + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((d + 1)).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((d + 1)).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((d + 1))[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondclassindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnclass<int>();	if ((!(((secondclass<int>)d[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructoperator() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d[1]) + 2)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondstructindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturnstruct<int>();	if ((!(((secondstruct<int>)d[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstancemethod() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d[1]).instancemethod())) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceinstanceproperty() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d[1]).instanceproperty)) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

private static bool callsecondinterfaceindexer() {	int failcount = 0;	verify.firstcalled = false;	dynamic d = new firstclassreturninterface<int>();	if ((!(((secondinterface<int>)d[1])[2])) || (!verify.firstcalled)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new first();	if ((!(bool)(((second)d.m1()).m2().m3().m4())) || (testcount.callcount != 4)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new first();	if ((!(bool)(((dynamic)(((second)d.m1()).m2().m3())).m4())) || (testcount.callcount != 4)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new first();	if ((!(bool)((((second)d.p1) + 2).m3()[4])) || (testcount.callcount != 4)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new first();	if ((!(bool)(((dynamic)(((second)d.m1()).p2 + 3))[4])) || (testcount.callcount != 4)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new c1();	if ((!(bool)(((c5)(((c2)d.m1()).m2().m3().m4())).m5().m6().m7())) || (testcount.callcount != 7)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new c1();	if ((!(bool)(((c5)((dynamic)(((c2)d.m1()).m2().m3())).m4()).m5().m6().m7())) || (testcount.callcount != 7)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new c1();	if ((!(bool)((((c5)((((c2)d[1]) + 2).p3.m4()))[5] + 6).p7)) || (testcount.callcount != 7)) {	failcount++;	
test failed at call result 

public static int mainmethod() {	int failcount = 0;	dynamic d = new c1();	if ((!(bool)(((c5)((dynamic)(((c2)d.m1()).p2 + 3))[4]).p5[6] + 7)) || (testcount.callcount != 7)) {	failcount++;	
test failed at call result 

========================= corefx sample_132 =========================

public static void testintegration(string apitype, bool usereader) {	
running apitype usereader 

foreach (var scheduler in schedulers) {	action<int> recursivework = null;	recursivework = depth => {	if (depth > 0) {	action work = () => {	var sw = new spinwait();	while (!sw.nextspinwillyield) sw.spinonce();	recursivework(depth - 1);	};	taskfactory factory = new taskfactory(scheduler);	
start tasks in scheduler 

========================= corefx sample_3996 =========================

if (length == 0) {	handleerror();	continue;	}	module.filename = (length >= 4 && chars[0] == '\\' && chars[1] == '\\' && chars[2] == '?' && chars[3] == '\\') ? new string(chars, 4, length - 4) : new string(chars, 0, length);	modules.add(module);	}	return modules;	}	finally {	
process closehandle process 

========================= corefx sample_3965 =========================

bool usector = (i == 0);	for (int j = 0; j < 2; j++) {	bool useobj = (j == 0);	object refobj = new object();	for (int k = 0; k < 2; k++) {	bool precanceledtoken = (k == 0);	task<int> f1;	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken ct = cts.token;	if (precanceledtoken) {	
with cts cancelled 

for (int j = 0; j < 2; j++) {	bool useobj = (j == 0);	object refobj = new object();	for (int k = 0; k < 2; k++) {	bool precanceledtoken = (k == 0);	task<int> f1;	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken ct = cts.token;	if (precanceledtoken) {	cts.cancel();	
with cts cancelled worked 

public static void runlongrunningtasktests() {	taskscheduler tm = taskscheduler.default;	int ntasks = environment.processorcount * 2;	task[] tasks = new task[ntasks];	manualresetevent mre = new manualresetevent(false);	countdownevent cde = new countdownevent(ntasks);	for (int i = 0; i < ntasks; i++) {	tasks[i] = task.factory.startnew(delegate {	cde.signal();	
signalled 

manualresetevent mre = new manualresetevent(false);	countdownevent cde = new countdownevent(ntasks);	for (int i = 0; i < ntasks; i++) {	tasks[i] = task.factory.startnew(delegate {	cde.signal();	mre.waitone();	}, cancellationtoken.none, taskcreationoptions.longrunning, tm);	}	bool waitsucceeded = cde.wait(5000);	if (!waitsucceeded) {	
status 

for (int i = 0; i < ntasks; i++) {	tasks[i] = task.factory.startnew(delegate {	cde.signal();	mre.waitone();	}, cancellationtoken.none, taskcreationoptions.longrunning, tm);	}	bool waitsucceeded = cde.wait(5000);	if (!waitsucceeded) {	int count = cde.currentcount;	int initialcount = cde.initialcount;	
wait failed cde currentcount cde initial count 

========================= corefx sample_4022 =========================

ace1binaryform = new byte[ace1.binarylength];	ace2binaryform = new byte[ace2.binarylength];	ace1.getbinaryform(ace1binaryform, 0);	ace2.getbinaryform(ace2binaryform, 0);	if (!isbinaryformequal(ace1binaryform, ace2binaryform)) {	result = false;	}	}	}	else if (null == ace1 && null == ace2) {	
both aces are null 

public static void printbinaryform(byte[] binaryform) {	console.writeline();	if (binaryform != null) {	
binaryform 

public static void printbinaryform(byte[] binaryform) {	console.writeline();	if (binaryform != null) {	for (int i = 0; i < binaryform.length; i++) {	console.writeline("{0}", binaryform[i]);	}	console.writeline();	}	
binaryform null 

========================= corefx sample_4073 =========================

public static void dumptofile(byte[] buffer, int offset, int count) {	using (var testfile = tempfile.create()) {	try {	filestream fs = file.create(testfile.path);	fs.write(buffer, offset, count);	fs.close();	}	catch (exception e) {	
failed dumping to file 

========================= corefx sample_4296 =========================

private void confirmvalidcertificate(string expectedhostname) {	assert.equal(sslpolicyerrors.none, _validationcallbackhistory.sslpolicyerrors);	assert.true(_validationcallbackhistory.certificatechain.count > 0);	
certificate subject 

private void confirmvalidcertificate(string expectedhostname) {	assert.equal(sslpolicyerrors.none, _validationcallbackhistory.sslpolicyerrors);	assert.true(_validationcallbackhistory.certificatechain.count > 0);	
expected hostname 

========================= corefx sample_8390 =========================

public static void validate(x509certificate2collection expected, x509chain actual) {	itestoutputhelper log = testlogging.getinstance();	
certificatechainvalidation 

========================= corefx sample_8141 =========================

public void close() {	if (associated) {	if (_haveprocesshandle) {	lock (this) {	stopwatchingforexit();	}	
process closehandle process in close 

public static process[] getprocesses(string machinename) {	bool isremotemachine = processmanager.isremotemachine(machinename);	processinfo[] processinfos = processmanager.getprocessinfos(machinename);	process[] processes = new process[processinfos.length];	for (int i = 0; i < processinfos.length; i++) {	processinfo processinfo = processinfos[i];	processes[i] = new process(machinename, isremotemachine, processinfo.processid, processinfo);	}	
process getprocesses 

========================= corefx sample_3986 =========================

public void updateblobs() {	string testdatafilepath = gettestdatafilepath();	string[] coretypeblobs = serializableequalitycomparers_memberdata() .concat(serializableobjects_memberdata()) .select(record => binaryformatterhelpers.tobase64string(record[0])) .toarray();	var (numberofblobs, numberoffoundblobs, numberofupdatedblobs) = updatecoretypeblobs(testdatafilepath, coretypeblobs);	
numberofblobs existing blobs environment newline numberoffoundblobs found blobs with regex search environment newline numberofupdatedblobs updated blobs with regex replace 

========================= corefx sample_8223 =========================

public void bug601305(xmlwriterutils utils) {	
expected 

public void bug601305(xmlwriterutils utils) {	cerror.writeline("<p:root xmlns:p='uri' />");	
actual 

========================= corefx sample_12457 =========================

sc.xmlresolver = new xmlurlresolver();	sc.add(null, path.combine(testdata._root, "import_v16_b.xsd"));	xmlschema parent = sc.add(null, path.combine(testdata._root, "import_v16_a.xsd"));	sc.compile();	sc.remove(parent);	cerror.compare(sc.count, 1, "count");	cerror.compare(sc.contains("ns-b"), true, "contains");	return;	}	catch (xmlschemaexception e) {	
exception 

========================= corefx sample_12517 =========================

stoppos = runregex.righttoleft ? runtextbeg : runtextend;	runtextpos = textstart;	if (prevlen == 0) {	if (runtextpos == stoppos) return match.empty;	runtextpos += bump;	}	starttimeoutwatch();	for (; ;) {	#if debug if (runregex.debug) {	debug.writeline("");	
search range from to 

stoppos = runregex.righttoleft ? runtextbeg : runtextend;	runtextpos = textstart;	if (prevlen == 0) {	if (runtextpos == stoppos) return match.empty;	runtextpos += bump;	}	starttimeoutwatch();	for (; ;) {	#if debug if (runregex.debug) {	debug.writeline("");	
firstchar search starting at stopping at 

#if debug if (runregex.debug) {	debug.writeline("");	}	#endif if (findfirstchar()) {	checktimeout();	if (!initted) {	initmatch();	initted = true;	}	#if debug if (runregex.debug) {	
executing engine starting at 

private void dochecktimeout() {	if (--_timeoutcheckstoskip != 0) return;	_timeoutcheckstoskip = timeoutcheckfrequency;	int currentmillis = environment.tickcount;	if (currentmillis < _timeoutoccursat) return;	if (0 > _timeoutoccursat && 0 < currentmillis) return;	#if debug if (runregex.debug) {	debug.writeline("");	
regex match timeout occurred 

private void dochecktimeout() {	if (--_timeoutcheckstoskip != 0) return;	_timeoutcheckstoskip = timeoutcheckfrequency;	int currentmillis = environment.tickcount;	if (currentmillis < _timeoutoccursat) return;	if (0 > _timeoutoccursat && 0 < currentmillis) return;	#if debug if (runregex.debug) {	debug.writeline("");	
specified timeout 

private void dochecktimeout() {	if (--_timeoutcheckstoskip != 0) return;	_timeoutcheckstoskip = timeoutcheckfrequency;	int currentmillis = environment.tickcount;	if (currentmillis < _timeoutoccursat) return;	if (0 > _timeoutoccursat && 0 < currentmillis) return;	#if debug if (runregex.debug) {	debug.writeline("");	
timeout check frequency 

private void dochecktimeout() {	if (--_timeoutcheckstoskip != 0) return;	_timeoutcheckstoskip = timeoutcheckfrequency;	int currentmillis = environment.tickcount;	if (currentmillis < _timeoutoccursat) return;	if (0 > _timeoutoccursat && 0 < currentmillis) return;	#if debug if (runregex.debug) {	debug.writeline("");	
search pattern 

private void dochecktimeout() {	if (--_timeoutcheckstoskip != 0) return;	_timeoutcheckstoskip = timeoutcheckfrequency;	int currentmillis = environment.tickcount;	if (currentmillis < _timeoutoccursat) return;	if (0 > _timeoutoccursat && 0 < currentmillis) return;	#if debug if (runregex.debug) {	debug.writeline("");	
input 

private void dochecktimeout() {	if (--_timeoutcheckstoskip != 0) return;	_timeoutcheckstoskip = timeoutcheckfrequency;	int currentmillis = environment.tickcount;	if (currentmillis < _timeoutoccursat) return;	if (0 > _timeoutoccursat && 0 < currentmillis) return;	#if debug if (runregex.debug) {	debug.writeline("");	
about to throw regexmatchtimeoutexception 

========================= corefx sample_3138 =========================

public void test_eventsource_shutdownmanifest() {	testutilities.checknoeventsourcesrunning("start");	
logging more than of events 

public void test_eventsource_shutdownmanifest() {	testutilities.checknoeventsourcesrunning("start");	overflowcircularbuffertest();	
success 

public void overflowcircularbuffertest() {	string datafilename = "overflowdata.etl";	var sessionname = path.getfilenamewithoutextension(datafilename) + "session";	var logger = adshutdowneventsourcetester.adshutdowneventsource.log;	datafilename = path.getfullpath(datafilename);	
creating data file 

========================= corefx sample_3078 =========================

public void getparam1() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam2() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(null, szempty);	if (retobj != null) {	
did not return null for null param name 

public void getparam3() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(szempty, szempty);	if (retobj != null) {	
did not return null for empty string param name 

public void getparam4() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam("randomname", szempty);	if (retobj != null) {	
did not return null for non existent parameter name 

public void getparam5() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(szinvalid, szempty);	if (retobj != null) {	
did not return null for an invalid param name 

public void getparam6() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam(szlongstring, szempty, "test6");	retobj = m_xsltarg.getparam(szlongstring, szempty);	
added value retrieved value 

public void getparam7() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam("myarg1", null);	if (retobj != null) {	
did not return null for null namespace system xml tests 

public void getparam8() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test8");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam9() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test9");	retobj = m_xsltarg.getparam("myarg1", "http: if (retobj != null) {	
did not retrieve a null value for non existent uri 

public void getparam9() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test9");	retobj = m_xsltarg.getparam("myarg1", "http: if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", "http: retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
did not retrieve a null value for non existent uri 

m_xsltarg.addparam("myarg1", szempty, "test9");	retobj = m_xsltarg.getparam("myarg1", "http: if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", "http: retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
did not retrieve a null value for non existent uri 

public void getparam10() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szlongns, "test10");	retobj = m_xsltarg.getparam("myarg1", szlongns);	
added value retrieved value 

public void getparam12() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam12() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "0.00") {	
failed to add get a value for of type string 

public void getparam12() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "0.00") {	
retrieved 

string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int j = 8;	int i = 8;	m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int j = 8;	int i = 8;	m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!i.equals(retobj)) {	
failed to add get a value for of type int 

int i = 8;	m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!i.equals(retobj)) {	assert.true(false);	}	if (i.gettype() != j.gettype()) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	
added value retrieved value 

m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!i.equals(retobj)) {	assert.true(false);	}	if (i.gettype() != j.gettype()) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	
failed to add get a value for of type boolean 

m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!i.equals(retobj)) {	assert.true(false);	}	if (i.gettype() != j.gettype()) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	
retrieved 

if (i.gettype() != j.gettype()) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	
added value retrieved value 

boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	
failed to add get a value for of type boolean 

boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	
retrieved 

boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	assert.true(false);	}	xpathdocument xd = new xpathdocument(fullfilepath("fish.xml"));	m_xsltarg.addparam("myarg5", szempty, ((ixpathnavigable)xd).createnavigator());	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj == null) {	
failed to add get a value of type xpathnavigator 

boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	assert.true(false);	}	xpathdocument xd = new xpathdocument(fullfilepath("fish.xml"));	m_xsltarg.addparam("myarg5", szempty, ((ixpathnavigable)xd).createnavigator());	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj == null) {	
retrieved 

public void getparam14() {	int i = 1;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test" + str);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != "test" + str) {	
error processing test for whitespace arg in first set 

retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != "test" + str) {	assert.true(false);	}	i++;	}	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test");	retobj = m_xsltarg.getparam("myarg" + str, szempty);	if (retobj != null) {	
error processing test for whitespace arg in second set returned object is not null 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	
failed after retrieving times 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	
added value retrieved value 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	assert.true(false);	}	}	
retrievied times 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	assert.true(false);	}	}	
added value retrieved value 

public void getparam17() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test17");	retobj = m_xsltarg.getparam("myarg3", szdefaultns);	if (retobj != null) {	
return a non null value when retrieving param with namespace 

public void getparam18() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam18() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	m_xsltarg.addparam("myarg1", "http: retobj = m_xsltarg.getparam("myarg1", "http: _output.writeline("added value:{0}\nretrieved value: {1}", "test2", retobj);	if (retobj.tostring() != "test2") assert.true(false);	retobj = m_xsltarg.getparam("myarg1", szempty);	
retrieve original value actual retrieved value 

public void getparam19() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(null, null);	if (retobj != null) {	
did not return null for null parameter name 

double d1 = double.positiveinfinity;	double d2 = double.negativeinfinity;	double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

double d2 = double.negativeinfinity;	double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	
failed to add get a value for 

double d2 = double.negativeinfinity;	double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	
retrieved 

double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	
failed to add get a value for 

double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	
retrieved 

if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	
retrieved 

if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	
retrieved 

if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	
retrieved 

if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	
retrieved 

if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	retobj = m_xsltarg.getparam("myarg7", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (!d7.equals(retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (!d7.equals(retobj)) {	
retrieved 

public void addparam1(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam2() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam(null, szempty, "test1");	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for adding null param 

public void addparam3() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam(szempty, szempty, "test1");	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for param name empty string 

public void addparam4(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam(szlongstring, szempty, "test1");	retobj = m_xsltarg.getparam(szlongstring, szempty);	
added value retrieved value 

public void addparam5() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam(szinvalid, szempty, "test1");	}	catch (system.xml.xmlexception) {	return;	}	
system xml xmlexception not thrown for invalid param name 

public void addparam6() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam("myarg1", null, "test1");	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for null namespace system xml tests 

public void addparam7(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test7 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test7");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam8(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szlongns, "test8");	retobj = m_xsltarg.getparam("myarg1", szlongns);	
added value retrieved value 

public void addparam11() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	try {	m_xsltarg.addparam("myarg1", szempty, "test1");	}	catch (system.argumentexception) {	return;	}	
did not throw system argumentexception for adding a param that already exists 

public void addparam12(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam12(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", "http: retobj = m_xsltarg.getparam("myarg1", "http: _output.writeline("added value:{0}\nretrieved value: {1}", "test2", retobj);	if (retobj.tostring() != "test2") assert.true(false);	retobj = m_xsltarg.getparam("myarg1", szempty);	
retrieve original value actual retrieved value 

public void addparam13(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.test2 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam13(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.test2 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

public void addparam13(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.test2 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != "test2") assert.true(false);	retobj = m_xsltarg.getparam("myarg1", szempty);	
retrieve original value actual retrieved value 

public void addparam14(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.test2 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam14(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.test2 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", szempty, "test2");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.test2 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", szempty, "test2");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", szempty, "test2");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg3", szempty, "test3");	retobj = m_xsltarg.getparam("myarg3", szempty);	
added value retrieved value 

public void addparam15() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam("myarg1", szempty, null);	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for null object 

public void addparam16(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.test1 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	string obj = "test";	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg2", szempty, obj + i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != ("test" + i)) {	
failed to add remove iteration 

retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != ("test" + i)) {	assert.true(false);	}	m_xsltarg.removeparam("myarg2", szempty);	}	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg" + i, szempty, obj + i);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != (obj + i)) {	
failed in part to add remove iteration 

public void addparam17(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test 2.test 3.test 4.test 5.test 6.no value specified</result>";	int i = 1;	int errcount = 0;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	try {	m_xsltarg.addparam("myarg" + i, szempty, "test" + str);	}	catch (system.xml.xmlexception) {	
improperly reported an exception for a whitespace value 

m_xsltarg.addparam("myarg" + str, szempty, "test");	}	catch (system.xml.xmlexception) {	errcount++;	}	finally {	errcount--;	}	}	if (errcount != 0) {	
at least one whitespace test failed 

public void addparam19(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.test1 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	string obj = "test";	for (int i = 0; i < 300; i++) {	m_xsltarg.addparam("myarg" + i, szempty, obj + "1");	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != ("test" + "1")) {	
failed to add myarg 

public void addparam20(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result xmlns:myobj1=""urn:http: 1.test1 2.test2 3.test3 4.test4 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", "urn:" + szxslns, "test1");	retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	
added value retrieved value 

public void addparam20(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result xmlns:myobj1=""urn:http: 1.test1 2.test2 3.test3 4.test4 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", "urn:" + szxslns, "test1");	retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", "urn:tmp", "test2");	retobj = m_xsltarg.getparam("myarg2", "urn:tmp");	
added value retrieved value 

string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result xmlns:myobj1=""urn:http: 1.test1 2.test2 3.test3 4.test4 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", "urn:" + szxslns, "test1");	retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", "urn:tmp", "test2");	retobj = m_xsltarg.getparam("myarg2", "urn:tmp");	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg3", "urn:my-object", "test3");	retobj = m_xsltarg.getparam("myarg3", "urn:my-object");	
added value retrieved value 

retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", "urn:tmp", "test2");	retobj = m_xsltarg.getparam("myarg2", "urn:tmp");	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg3", "urn:my-object", "test3");	retobj = m_xsltarg.getparam("myarg3", "urn:my-object");	if (retobj.tostring() != "test3") assert.true(false);	m_xsltarg.addparam("myarg4", "urn:my-object", "test4");	retobj = m_xsltarg.getparam("myarg4", "urn:my-object");	
added value retrieved value 

public void addextobject2() {	myobject obj = new myobject(2, _output);	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addextensionobject(null, obj);	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not generated for null namespace system xml tests 

public void addextobject6(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> string  argument: system.string int32   argument: system.int32 boolean argument: system.boolean boolean argument: system.boolean double  argument: system.double string  argument: system.string</result>";	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	
added value retrieved value 

public void addextobject6(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> string  argument: system.string int32   argument: system.int32 boolean argument: system.boolean boolean argument: system.boolean double  argument: system.double string  argument: system.string</result>";	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	
failed to add get a value for of type string 

public void addextobject6(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> string  argument: system.string int32   argument: system.int32 boolean argument: system.boolean boolean argument: system.boolean double  argument: system.double string  argument: system.string</result>";	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	
retrieved 

m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	
added value retrieved value 

string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	
failed to add get a value for with conversion from int to double 

string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	
retrieved 

int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	assert.true(false);	}	if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	
added value retrieved value 

m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	assert.true(false);	}	if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	
failed to add get a value for of type boolean 

m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	assert.true(false);	}	if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	
retrieved 

if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	
added value retrieved value 

boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	if (!bt.equals(retobj)) {	
failed to add get a value for of type boolean 

boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	if (!bt.equals(retobj)) {	
retrieved 

}	boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	if (!bt.equals(retobj)) {	assert.true(false);	}	double d = 3.14;	m_xsltarg.addextensionobject("myarg5", d);	retobj = m_xsltarg.getextensionobject("myarg5");	
added value retrieved value 

boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	if (!bt.equals(retobj)) {	assert.true(false);	}	double d = 3.14;	m_xsltarg.addextensionobject("myarg5", d);	retobj = m_xsltarg.getextensionobject("myarg5");	if (!d.equals(retobj)) {	
failed to add get a value for of type boolean 

boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	if (!bt.equals(retobj)) {	assert.true(false);	}	double d = 3.14;	m_xsltarg.addextensionobject("myarg5", d);	retobj = m_xsltarg.getextensionobject("myarg5");	if (!d.equals(retobj)) {	
retrieved 

assert.true(false);	}	double d = 3.14;	m_xsltarg.addextensionobject("myarg5", d);	retobj = m_xsltarg.getextensionobject("myarg5");	if (!d.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addextensionobject("myarg6", "3");	retobj = m_xsltarg.getextensionobject("myarg6");	
added value retrieved value 

myobject obj1 = new myobject(1, _output);	myobject obj2 = new myobject(2, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj1);	try {	m_xsltarg.addextensionobject(szdefaultns, obj2);	}	catch (system.argumentexception) {	return;	}	
did not launch exception system argumentexception for an item already added 

public void addextobject8(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result xmlns:myobj=""urn:my-object""> 1.test1 2.test2 3.test3</result>";	myobject obj = new myobject(1, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject("urn:my-object", obj);	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (((myobject)retobj).myvalue() != obj.myvalue()) {	
set and retrieved value appear to be different 

public void addextobject9() {	myobject obj = new myobject(9, _output);	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addextensionobject(szdefaultns, null);	}	catch (system.argumentnullexception) {	return;	}	
did not launch exception system argumentnullexception for adding a null valued item 

myobject obj = new myobject(i, _output);	m_xsltarg.addextensionobject(szdefaultns + str, obj);	i++;	}	try {	if ((loadxsl("myobjectdef.xsl", inputtype, readertype) == 1)) transform_arglist("fruits.xml", true, transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

public void addextobject13() {	myobject obj = new myobject(13, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	try {	m_xsltarg.addextensionobject(szdefaultns, obj);	}	catch (system.argumentexception) {	return;	}	
did not exception for adding an extension object that already exists 

public void addextobject15(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	myobject obj = new myobject(15, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szsimple, obj);	try {	if ((loadxsl("myobjectdef.xsl", inputtype, readertype) == 1)) transform_arglist("fruits.xml", true, transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

m_xsltarg = new xsltargumentlist();	double d = 1;	int i = 1;	m_xsltarg.addextensionobject("urn:myspace", d);	try {	m_xsltarg.addextensionobject("urn:myspace", i);	}	catch (system.argumentexception) {	return;	}	
exception not thrown for uri namespace system xml tests in use 

m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	if ((loadxsl("myobject_notfoundns.xsl", inputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", true, transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for ns not found 

m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	if ((loadxsl("myobject_notfound.xsl", inputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", true, transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for method not found 

public void removeparam1(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	
value of removed object is not null 

string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test1 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") {	
value of removed object is not as expected 

public void removeparam2() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.removeparam(null, szempty);	if (retobj != null) {	
did not return null for null parameter name 

public void removeparam7() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.removeparam("myarg1", null);	if (retobj != null) {	
did not return null for null uri namespace 

double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg1", szempty, d1);	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, d2);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	m_xsltarg.removeparam("myarg3", szempty);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg3", szempty, d3);	m_xsltarg.removeparam("myarg3", szempty);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg4", szempty, d4);	m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg5", szempty, d5);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	m_xsltarg.removeparam("myarg6", szempty);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg6", szempty, d6);	m_xsltarg.removeparam("myarg6", szempty);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	m_xsltarg.removeparam("myarg7", szempty);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg7", szempty);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (retobj != null) {	assert.true(false);	}	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	int i = 2;	m_xsltarg.addparam("myarg2", szempty, i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg4", szempty, bf);	m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg5", szempty, bt);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg5", szempty, bt);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (int16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (int16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (uint16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (uint16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (int32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (int32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (uint32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (uint32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (int64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (int64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (uint64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (uint64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (single)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (single)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (decimal)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

public void removeparam13(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.test 2.test 3.test 4.test 5.test 6.no value specified</result>";	int i = 1;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test" + str);	m_xsltarg.removeparam("myarg" + i, szempty);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj != null) {	
error removing case from this test 

assert.true(false);	}	i++;	}	i = 1;	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test");	m_xsltarg.removeparam("myarg" + str, szempty);	retobj = m_xsltarg.getparam("myarg" + str, szempty);	if (retobj != null) {	
error removing case in the second batch from this test 

myobject obj = new myobject(1, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	m_xsltarg.removeextensionobject(szdefaultns);	try {	if ((loadxsl("myobjectdef.xsl", inputtype, readertype) == 1)) transform_arglist("fruits.xml", true, transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

public void removeextobj2() {	myobject obj = new myobject(2, _output);	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.removeextensionobject(null);	}	catch (system.argumentnullexception) {	return;	}	
exception not generated for null parameter name 

m_xsltarg = new xsltargumentlist();	myobject obj = new myobject(5, _output);	m_xsltarg.addextensionobject("urn:" + szlongns, obj);	m_xsltarg.removeextensionobject("urn:" + szlongns);	try {	if ((loadxsl("myobjectdef.xsl", inputtype, readertype) == 1)) transform_arglist("fruits.xml", true, transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

public void removeextobj8(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	int i = 1;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	myobject obj = new myobject(i, _output);	m_xsltarg.addextensionobject(szdefaultns + str, obj);	m_xsltarg.removeextensionobject(szdefaultns + str);	retobj = m_xsltarg.getextensionobject(szdefaultns + str);	if (retobj != null) {	
error deleting case for whitespace arg 

assert.true(false);	}	i++;	}	try {	if ((loadxsl("myobjectdef.xsl", inputtype, readertype) == 1)) transform_arglist("fruits.xml", true, transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not exception for object that could not be executed 

public void clear4(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	myobject obj = new myobject(26, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	m_xsltarg.clear();	retobj = m_xsltarg.getextensionobject(szdefaultns);	if (retobj != null) {	
did not appear to clear an extension object 

assert.true(false);	}	if ((loadxsl("myobjectdef.xsl", inputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for ns not found 

public void clear5(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	m_xsltarg = new xsltargumentlist();	string obj = "test";	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg2", szempty, obj + i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != (obj + i)) {	
failed to add remove iteration 

if (retobj.tostring() != (obj + i)) {	_output.writeline("{0} : {1}", retobj, obj + i);	assert.true(false);	}	m_xsltarg.clear();	}	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg" + i, szempty, obj + i);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != (obj + i)) {	
failed in part to add remove iteration 

m_xsltarg.removeextensionobject(szdefaultns);	m_xsltarg.clear();	if ((loadxsl("myobjectdef.xsl", inputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", transformtype, doctype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for ns not found 

========================= corefx sample_12624 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	}	else if (args.severity == xmlseveritytype.error) {	
error 

sc.removerecursive(parent);	cerror.compare(sc.count, 1, "count");	cerror.compare(sc.contains("ns-b"), true, "contains");	parent = sc.add(null, path.combine(testdata._root, "import_v16_a.xsd"));	sc.removerecursive(parent);	cerror.compare(sc.count, 1, "count");	cerror.compare(sc.contains("ns-b"), true, "contains");	return;	}	catch (xmlschemaexception e) {	
exception 

========================= corefx sample_12523 =========================

public void parity_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default parity 

public void parity_none_beforeopen() {	
verifying none parity before open 

public void parity_even_beforeopen() {	
verifying even parity before open 

public void parity_odd_beforeopen() {	
verifying odd parity before open 

public void parity_mark_beforeopen() {	
verifying mark parity before open 

public void parity_space_beforeopen() {	
verifying space before open 

public void parity_none_afteropen() {	
verifying none parity after open 

public void parity_even_afteropen() {	
verifying even parity after open 

public void parity_odd_afteropen() {	
verifying odd parity after open 

public void parity_mark_afteropen() {	
verifying mark parity after open 

public void parity_space_afteropen() {	
verifying space parity after open 

public void parity_int32minvalue() {	
verifying minvalue parity 

public void parity_neg1() {	
verifying parity 

public void parity_int32maxvalue() {	
verifying maxvalue parity 

public void parity_even_odd() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying parity even and then odd 

public void parity_odd_even() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying parity odd and then even 

public void parity_odd_mark() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying parity odd and then mark 

if (0 != com2.bytestoread) {	fail("error!!! bytestoread={0} expected 0", com2.bytestoread);	}	int expectedindex = 0, actualindex = 0;	for (; expectedindex < expectedbytes.length && actualindex < rcvbytes.length; ++expectedindex, ++actualindex) {	if (expectedbytes[expectedindex] != rcvbytes[actualindex]) {	if (actualindex != rcvbytes.length - 1 && expectedbytes[expectedindex] == rcvbytes[actualindex + 1]) {	actualindex++;	}	else {	
bytes sent 

fail("error!!! bytestoread={0} expected 0", com2.bytestoread);	}	int expectedindex = 0, actualindex = 0;	for (; expectedindex < expectedbytes.length && actualindex < rcvbytes.length; ++expectedindex, ++actualindex) {	if (expectedbytes[expectedindex] != rcvbytes[actualindex]) {	if (actualindex != rcvbytes.length - 1 && expectedbytes[expectedindex] == rcvbytes[actualindex + 1]) {	actualindex++;	}	else {	tcsupport.printbytes(xmitbytes);	
bytes recieved 

}	int expectedindex = 0, actualindex = 0;	for (; expectedindex < expectedbytes.length && actualindex < rcvbytes.length; ++expectedindex, ++actualindex) {	if (expectedbytes[expectedindex] != rcvbytes[actualindex]) {	if (actualindex != rcvbytes.length - 1 && expectedbytes[expectedindex] == rcvbytes[actualindex + 1]) {	actualindex++;	}	else {	tcsupport.printbytes(xmitbytes);	tcsupport.printbytes(rcvbytes);	
expected bytes 

========================= corefx sample_658 =========================

public void canwrite_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying canwrite property throws exception after open then close 

public void canwrite_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying canwrite property throws exception after open then basestream close 

public void canwrite_afteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying canwrite property returns true after a call to open 

========================= corefx sample_609 =========================

public void openclose_writemethods() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying calling write methods after calling open and basestream close 

com.write(new char[8], 0, 8);	}	catch (invalidoperationexception) {	}	try {	com.write("a");	}	catch (invalidoperationexception) {	}	try {	
a 

public void openclose_readmethods() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying calling read methods after calling open and basestream close 

public void openclose_discardmethods() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying calling discard methods after calling open and basestream close 

public void openclose_openclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying calling open close methods after calling open and basestream close 

public void openclose_properties() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying properites after calling open and basestream close 

public void openfillbuffersclose() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
calling open fill both trasmit and receive buffers call close 

serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	com1.handshake = handshake.requesttosend;	com1.open();	com2.open();	com1.basestream.beginwrite(new byte[numwritebytes], 0, numwritebytes, null, null);	com2.write(new byte[numreadbytes], 0, numreadbytes);	thread.sleep(500);	serportprop.setproperty("handshake", handshake.requesttosend);	serportprop.setproperty("bytestowrite", numwritebytes);	serportprop.setproperty("bytestoread", numreadbytes);	
verifying properties after port is open and bufferes have been filled 

com2.write(new byte[numreadbytes], 0, numreadbytes);	thread.sleep(500);	serportprop.setproperty("handshake", handshake.requesttosend);	serportprop.setproperty("bytestowrite", numwritebytes);	serportprop.setproperty("bytestoread", numreadbytes);	serportprop.verifypropertiesandprint(com1);	com1.handshake = handshake.none;	com1.basestream.close();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying properties after port has been closed 

serportprop.setproperty("bytestoread", numreadbytes);	serportprop.verifypropertiesandprint(com1);	com1.handshake = handshake.none;	com1.basestream.close();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	com1.open();	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying properties after port has been opened again 

public void openclosenewinstanceopen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
calling close after calling open then create a new instance of serialport and call open again 

public void open_basestreamclose_open() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying properites after calling open basestream close then open again 

public void open_basestreamclose_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying properites after calling open basestream close then close 

public void open_multiplebasestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying properites after calling open basestream close multiple times 

========================= corefx sample_598 =========================

public delegate void mydel(int x);	public class myclass {	public static void do(int x) {	
do 

public delegate void mydel(int x);	public class myclass {	public static void do(int x) {	
do 

public delegate int mydel(int x);	private class myclass {	public int do(int p) {	
doint 

public delegate int mydel(int x);	private class myclass {	public int do(int p) {	return 1;	}	public short do(short x) {	
doshort 

public delegate void mydel(int x);	private class myclass {	public void do(int x) {	test.s_status = true;	}	public void do(short x) {	test.s_status = false;	
do 

public void invoke() {	
a 

public delegate void mydel(int x);	private class myclass {	public static void do(int x) {	test.s_status = true;	
do 

public delegate void mydel(int x);	private class myclass {	public void do(int x) {	test.s_status = true;	
do 

========================= corefx sample_50 =========================

public int cauto() {	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.auto;	object[] xml = getallpri0conformancetestxmlstrings();	if (xml.length > s_pri0expectednone.length) {	
invalid compare attempted 

try {	while (reader.read()) ;	}	catch (xmlexception xe) {	cerror.write("case : " + (i + 1));	cerror.writeline(xe.message);	actual = true;	}	if (actual != s_pri0expectednone[i]) {	cerror.writeline("conformancelevel = auto");	
test failed for case 

public int cfragment() {	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.fragment;	object[] xml = getallpri0conformancetestxmlstrings();	if (xml.length > s_pri0expectedfragment.length) {	
invalid compare attempted 

try {	while (reader.read()) ;	}	catch (xmlexception xe) {	cerror.write("case : " + (i + 1));	cerror.writeline(xe.message);	actual = true;	}	if (actual != s_pri0expectedfragment[i]) {	cerror.writeline("conformancelevel = fragment");	
test failed for case 

public int cdocument() {	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.document;	object[] xml = getallpri0conformancetestxmlstrings();	if (xml.length > s_pri0expecteddocument.length) {	
invalid compare attempted 

try {	while (reader.read()) ;	}	catch (xmlexception xe) {	cerror.write("case : " + (i + 1));	cerror.writeline(xe.message);	actual = true;	}	if (actual != s_pri0expecteddocument[i]) {	cerror.writeline("conformancelevel = document");	
test failed for case 

========================= corefx sample_12581 =========================

string fragment = (string)options[readerfactory.ht_fragment];	stringreader sr = (stringreader)options[readerfactory.ht_stringreader];	if (rs == null) rs = new xmlreadersettings();	rs.dtdprocessing = dtdprocessing.ignore;	rs.checkcharacters = false;	xmlreadersettings wrs = new xmlreadersettings();	wrs.dtdprocessing = dtdprocessing.ignore;	wrs.checkcharacters = true;	wrs.conformancelevel = conformancelevel.auto;	if (sr != null) {	
charcheckingreader string 

xmlreadersettings wrs = new xmlreadersettings();	wrs.dtdprocessing = dtdprocessing.ignore;	wrs.checkcharacters = true;	wrs.conformancelevel = conformancelevel.auto;	if (sr != null) {	xmlreader r = readerhelper.create(sr, rs, string.empty);	xmlreader wr = readerhelper.create(r, wrs);	return wr;	}	if (stream != null) {	
charcheckingreader stream 

xmlreader r = readerhelper.create(sr, rs, string.empty);	xmlreader wr = readerhelper.create(r, wrs);	return wr;	}	if (stream != null) {	xmlreader r = readerhelper.create(stream, rs, filename);	xmlreader wr = readerhelper.create(r, wrs);	return wr;	}	if (fragment != null) {	
charcheckingreader fragment 

return wr;	}	if (fragment != null) {	rs.conformancelevel = conformancelevel.fragment;	stringreader tr = new stringreader(fragment);	xmlreader r = readerhelper.create(tr, rs, (string)null);	xmlreader wr = readerhelper.create(r, wrs);	return wr;	}	if (filename != null) {	
charcheckingreader filename 

========================= corefx sample_12610 =========================

private static void addlistenercomponent(eventloginternal component, string compmachinename, string complogname) {	lock (internalsyncobject) {	
eventlog addlistenercomponent 

private static void addlistenercomponent(eventloginternal component, string compmachinename, string complogname) {	lock (internalsyncobject) {	loglisteninginfo info = (loglisteninginfo)listenerinfos[complogname];	if (info != null) {	
eventlog addlistenercomponent listener already active 

private void close(string currentmachinename) {	
eventlog close 

private void close(string currentmachinename) {	if (readhandle != null) {	try {	readhandle.close();	}	catch (ioexception) {	throw sharedutils.createsafewin32exception();	}	readhandle = null;	
eventlog close closed read handle 

readhandle = null;	}	if (writehandle != null) {	try {	writehandle.close();	}	catch (ioexception) {	throw sharedutils.createsafewin32exception();	}	writehandle = null;	
eventlog close closed write handle 

private void completioncallback(object context) {	if (boolflags[flag_disposed]) {	return;	}	
eventlog completionstatuschanged starting at 

private void completioncallback(object context) {	if (boolflags[flag_disposed]) {	return;	}	lock (instancelockobject) {	if (boolflags[flag_notifying]) {	
eventlog completionstatuschanged aborting because we re already notifying 

boolflags[flag_notifying] = true;	}	int i = lastseencount;	try {	int oldest = oldestentrynumber;	int count = entrycount + oldest;	if (lastseencount < oldest || lastseencount > count) {	lastseencount = oldest;	i = lastseencount;	}	
eventlog completionstatuschanged oldestentrynumber is entrycount is 

eventlogentry entry = getentrywitholdest(i);	if (this.synchronizingobject != null && this.synchronizingobject.invokerequired) this.synchronizingobject.begininvoke(this.onentrywrittenhandler, new object[] { this, new entrywritteneventargs(entry) });	else onentrywrittenhandler(this, new entrywritteneventargs(entry));	i++;	}	oldest = oldestentrynumber;	count = entrycount + oldest;	}	}	catch (exception e) {	
eventlog completionstatuschanged caught exception notifying event handlers 

oldest = oldestentrynumber;	count = entrycount + oldest;	}	}	catch (exception e) {	}	try {	int newcount = entrycount + oldestentrynumber;	if (i > newcount) lastseencount = newcount;	else lastseencount = i;	
eventlog completionstatuschanged finishing at 

}	}	catch (exception e) {	}	try {	int newcount = entrycount + oldestentrynumber;	if (i > newcount) lastseencount = newcount;	else lastseencount = i;	}	catch (win32exception e) {	
eventlog completionstatuschanged caught exception updating last entry number 

else {	flags = nativemethods.backwards_read | nativemethods.seek_read;	boolflags[flag_forwards] = false;	}	cache = new byte[buf_size];	int bytesread;	int minbytesneeded;	bool success = unsafenativemethods.readeventlog(readhandle, flags, index, cache, cache.length, out bytesread, out minbytesneeded);	if (!success) {	int error = marshal.getlastwin32error();	
error from readeventlog is 

private void openforread(string currentmachinename) {	
eventlog openforread 

private void openforwrite(string currentmachinename) {	if (this.boolflags[flag_disposed]) throw new objectdisposedexception(gettype().name);	
eventlog openforwrite 

private void reset(string currentmachinename) {	
eventlog reset 

private static void removelistenercomponent(eventloginternal component, string complogname) {	lock (internalsyncobject) {	
eventlog removelistenercomponent 

private static void staticcompletioncallback(object context, bool wassignaled) {	loglisteninginfo info = (loglisteninginfo)context;	if (info == null) return;	eventloginternal[] interestedcomponents;	lock (internalsyncobject) {	interestedcomponents = (eventloginternal[])info.listeningcomponents.toarray(typeof(eventloginternal));	}	
eventlog staticcompletioncallback notifying components 

lock (internalsyncobject) {	interestedcomponents = (eventloginternal[])info.listeningcomponents.toarray(typeof(eventloginternal));	}	for (int i = 0; i < interestedcomponents.length; i++) {	try {	if (interestedcomponents[i] != null) {	interestedcomponents[i].completioncallback(null);	}	}	catch (objectdisposedexception) {	
eventlog staticcompletioncallback ignored an objectdisposedexception 

========================= corefx sample_11539 =========================

foreach (createcollectioninfo c in _createmethods.values) {	writecreatecollectionmethod(c);	}	writer.writeline();	foreach (string idname in _idnames.values) {	writer.write("string ");	writer.write(idname);	writer.writeline(";");	}	writer.writeline();	
protected override void initids 

private void writeisstarttag(string name, string ns) {	writer.write("if (reader.isstartelement(");	writeid(name);	writer.write(", ");	writeid(ns);	writer.writeline(")) {");	writer.indent++;	}	private void writeunknownnode(string func, string node, elementaccessor e, bool anyifs) {	if (anyifs) {	
else 

reflectionawarecodegen.writequotedcsharpstring(writer, expectedelement);	}	writer.writeline(");");	if (anyifs) {	writer.indent--;	writer.writeline("}");	}	}	private void generateinitcallbacksmethod() {	writer.writeline();	
protected override void initcallbacks 

}	}	writer.indent--;	writer.writeline("}");	if (needdummyarraymethod) {	writer.writeline();	writer.write("object ");	writer.write(dummyarraymethodname);	writer.writeline("() {");	writer.indent++;	
writer writeline 

}	}	writer.indent--;	writer.writeline("}");	if (needdummyarraymethod) {	writer.writeline();	writer.write("object ");	writer.write(dummyarraymethodname);	writer.writeline("() {");	writer.indent++;	
return null 

private string generateliteralmemberselement(xmlmembersmapping xmlmembersmapping) {	elementaccessor element = xmlmembersmapping.accessor;	membermapping[] mappings = ((membersmapping)element.mapping).members;	bool haswrapperelement = ((membersmapping)element.mapping).haswrapperelement;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public object[] ");	writer.write(methodname);	writer.writeline("() {");	writer.indent++;	
reader movetocontent 

}	member[] members = (member[])memberslist.toarray(typeof(member));	member[] textorarraymembers = (member[])textorarraymemberslist.toarray(typeof(member));	if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	writeparamsread(mappings.length);	if (attributememberslist.count > 0) {	member[] attributemembers = (member[])attributememberslist.toarray(typeof(member));	writememberbegin(attributemembers);	writeattributes(attributemembers, anyattribute, "unknownnode", "(object)p");	writememberend(attributemembers);	
reader movetoelement 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	writeparamsread(mappings.length);	if (attributememberslist.count > 0) {	member[] attributemembers = (member[])attributememberslist.toarray(typeof(member));	writememberbegin(attributemembers);	writeattributes(attributemembers, anyattribute, "unknownnode", "(object)p");	writememberend(attributemembers);	}	writememberbegin(textorarraymembers);	if (haswrapperelement) {	
if reader isemptyelement reader skip reader movetocontent continue 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	writeparamsread(mappings.length);	if (attributememberslist.count > 0) {	member[] attributemembers = (member[])attributememberslist.toarray(typeof(member));	writememberbegin(attributemembers);	writeattributes(attributemembers, anyattribute, "unknownnode", "(object)p");	writememberend(attributemembers);	}	writememberbegin(textorarraymembers);	if (haswrapperelement) {	
reader readstartelement 

writememberbegin(textorarraymembers);	if (haswrapperelement) {	}	if (issequence(members)) {	writer.writeline("int state = 0;");	}	int loopindex = writewhilenotloopstart();	writer.indent++;	string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	
reader movetocontent 

if (issequence(members)) {	writer.writeline("int state = 0;");	}	int loopindex = writewhilenotloopstart();	writer.indent++;	string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	writewhileloopend(loopindex);	writememberend(textorarraymembers);	if (haswrapperelement) {	
readendelement 

int loopindex = writewhilenotloopstart();	writer.indent++;	string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	writewhileloopend(loopindex);	writememberend(textorarraymembers);	if (haswrapperelement) {	writer.indent--;	writer.writeline("}");	writeunknownnode("unknownnode", "null", element, true);	
reader movetocontent 

string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	writewhileloopend(loopindex);	writememberend(textorarraymembers);	if (haswrapperelement) {	writer.indent--;	writer.writeline("}");	writeunknownnode("unknownnode", "null", element, true);	writewhileloopend(wrapperloopindex);	}	
return p 

membersmapping membersmapping = (membersmapping)element.mapping;	membermapping[] mappings = membersmapping.members;	bool haswrapperelement = membersmapping.haswrapperelement;	bool writeaccessors = membersmapping.writeaccessors;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public object[] ");	writer.write(methodname);	writer.writeline("() {");	writer.indent++;	
reader movetocontent 

writer.indent++;	writer.write("object[] p = new object[");	writer.write(mappings.length.tostring(cultureinfo.invariantculture));	writer.writeline("];");	initializevaluetypes("p", mappings);	if (haswrapperelement) {	writereadnonroots();	if (membersmapping.validaterpcwrapperelement) {	writer.write("if (!");	writexmlnodeequal("reader", element.name, element.form == xmlschemaform.qualified ? element.namespace : "");	
throw createunknownnodeexception 

writer.write(mappings.length.tostring(cultureinfo.invariantculture));	writer.writeline("];");	initializevaluetypes("p", mappings);	if (haswrapperelement) {	writereadnonroots();	if (membersmapping.validaterpcwrapperelement) {	writer.write("if (!");	writexmlnodeequal("reader", element.name, element.form == xmlschemaform.qualified ? element.namespace : "");	}	writer.writeline("bool isemptywrapper = reader.isemptyelement;");	
reader readstartelement 

string fixupmethodname = "fixup_" + methodname;	bool anyfixups = writememberfixupbegin(members, fixupmethodname, "p");	if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	
reader movetocontent 

bool anyfixups = writememberfixupbegin(members, fixupmethodname, "p");	if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	writewhileloopend(loopindex);	
if isemptywrapper readendelement 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	writewhileloopend(loopindex);	if (checktypehrefsource != null) writehandlehreflist(members, checktypehrefsource);	
readreferencedelements 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	writewhileloopend(loopindex);	if (checktypehrefsource != null) writehandlehreflist(members, checktypehrefsource);	
return p 

writer.writeline();	writer.write("public object ");	writer.write(methodname);	writer.writeline("() {");	writer.indent++;	writer.writeline("object o = null;");	membermapping member = new membermapping();	member.typedesc = mapping.typedesc;	member.elements = new elementaccessor[] { element };	member[] members = new member[] { new member(this, "o", "o", "a", 0, member) };	
reader movetocontent 

writer.writeline("() {");	writer.indent++;	writer.writeline("object o = null;");	membermapping member = new membermapping();	member.typedesc = mapping.typedesc;	member.elements = new elementaccessor[] { element };	member[] members = new member[] { new member(this, "o", "o", "a", 0, member) };	string unknownnode = "unknownnode(null, " + expectedelements(members) + ");";	writememberelements(members, "throw createunknownnodeexception();", unknownnode, element.any ? members[0] : null, null, null);	if (element.issoap) {	
referenced o 

writer.writeline("() {");	writer.indent++;	writer.writeline("object o = null;");	membermapping member = new membermapping();	member.typedesc = mapping.typedesc;	member.elements = new elementaccessor[] { element };	member[] members = new member[] { new member(this, "o", "o", "a", 0, member) };	string unknownnode = "unknownnode(null, " + expectedelements(members) + ");";	writememberelements(members, "throw createunknownnodeexception();", unknownnode, element.any ? members[0] : null, null, null);	if (element.issoap) {	
readreferencedelements 

writer.indent++;	writer.writeline("object o = null;");	membermapping member = new membermapping();	member.typedesc = mapping.typedesc;	member.elements = new elementaccessor[] { element };	member[] members = new member[] { new member(this, "o", "o", "a", 0, member) };	string unknownnode = "unknownnode(null, " + expectedelements(members) + ");";	writememberelements(members, "throw createunknownnodeexception();", unknownnode, element.any ? members[0] : null, null, null);	if (element.issoap) {	}	
return object o 

writer.write(" ");	writer.write(membername);	writer.writeline(";");	writer.writeline();	writer.write("internal ");	writer.write(typeof(hashtable).fullname);	writer.write(" ");	writer.write(propname);	writer.writeline(" {");	writer.indent++;	
get 

========================= corefx sample_12942 =========================

public void checkexpectederror(exception ex, string assembly) {	cexceptionhandler handler = new cexceptionhandler(path.combine(_strpath, "exceptions.xml"), assembly, _output);	bool result = handler.verifyexception(ex);	if (handler.res != _expectederrorcode) {	
expected exception 

public void checkexpectederror(exception ex, string assembly) {	cexceptionhandler handler = new cexceptionhandler(path.combine(_strpath, "exceptions.xml"), assembly, _output);	bool result = handler.verifyexception(ex);	if (handler.res != _expectederrorcode) {	
actual exception 

public int loadxsl(string _strxslfile, xslinputtype xslinputtype, readertype readertype, xmlresolver xr) {	_strxslfile = fullfilepath(_strxslfile);	xslt = new xslcompiledtransform();	xmlreadersettings xrs = null;	switch (xslinputtype) {	
loading style sheet as uri 

_strxslfile = fullfilepath(_strxslfile);	xslt = new xslcompiledtransform();	xmlreadersettings xrs = null;	switch (xslinputtype) {	xrs = new xmlreadersettings() { dtdprocessing = dtdprocessing.parse};	xslt.load(xmlreader.create(_strxslfile, xrs), xsltsettings.trustedxslt, xr);	break;	case xslinputtype.reader: switch (readertype) {	case readertype.xmltextreader: xmltextreader trtemp = new xmltextreader(_strxslfile);	try {	
loading style sheet as xmltextreader 

xslt.load(trtemp, xsltsettings.trustedxslt, xr);	}	finally {	if (trtemp != null) trtemp.dispose();	}	break;	case readertype.xmlnodereader: xmldocument doctemp = new xmldocument();	doctemp.load(_strxslfile);	xmlnodereader nrtemp = new xmlnodereader(doctemp);	try {	
loading style sheet as xmlnodereader 

xslt.load(nrtemp);	}	finally {	if (nrtemp != null) nrtemp.dispose();	}	break;	case readertype.xmlvalidatingreader: default: xrs = new xmlreadersettings();	#pragma warning disable 0618 xrs.prohibitdtd = false;	#pragma warning restore 0618 xmlreader xvr = xmlreader.create(_strxslfile, xrs);	try {	
loading style sheet as xmlvalidatingreader 

}	break;	}	break;	case xslinputtype.navigator: xrs = new xmlreadersettings();	xrs.validationtype = validationtype.none;	#pragma warning disable 0618 xrs.prohibitdtd = false;	#pragma warning restore 0618 xmlreader xrload = xmlreader.create(_strxslfile, xrs);	xpathdocument xdtemp = new xpathdocument(xrload, xmlspace.preserve);	xrload.dispose();	
loading style sheet as navigator 

public int loadxsl_resolver(string _strxslfile, xslinputtype xslinputtype, readertype readertype, xmlresolver xr) {	_strxslfile = fullfilepath(_strxslfile);	xslt = new xslcompiledtransform();	xmlreadersettings xrs = null;	switch (xslinputtype) {	
loading style sheet as uri 

public int loadxsl_resolver(string _strxslfile, xslinputtype xslinputtype, readertype readertype, xmlresolver xr) {	_strxslfile = fullfilepath(_strxslfile);	xslt = new xslcompiledtransform();	xmlreadersettings xrs = null;	switch (xslinputtype) {	xslt.load(_strxslfile, xsltsettings.trustedxslt, xr);	break;	case xslinputtype.reader: switch (readertype) {	case readertype.xmltextreader: xmltextreader trtemp = new xmltextreader(_strxslfile);	try {	
loading style sheet as xmltextreader 

xslt.load(trtemp, xsltsettings.trustedxslt, xr);	}	finally {	if (trtemp != null) trtemp.dispose();	}	break;	case readertype.xmlnodereader: xmldocument doctemp = new xmldocument();	doctemp.load(_strxslfile);	xmlnodereader nrtemp = new xmlnodereader(doctemp);	try {	
loading style sheet as xmlnodereader 

xslt.load(nrtemp, xsltsettings.trustedxslt, xr);	}	finally {	if (nrtemp != null) nrtemp.dispose();	}	break;	case readertype.xmlvalidatingreader: default: xrs = new xmlreadersettings();	#pragma warning disable 0618 xrs.prohibitdtd = false;	#pragma warning restore 0618 xmlreader vrtemp = xmlreader.create(_strxslfile, xrs);	try {	
loading style sheet as xmlvalidatingreader 

if (vrtemp != null) vrtemp.dispose();	}	break;	}	break;	case xslinputtype.navigator: xrs = new xmlreadersettings();	#pragma warning disable 0618 xrs.prohibitdtd = false;	#pragma warning restore 0618 xmlreader xrload = xmlreader.create(_strxslfile, xrs);	xpathdocument xdtemp = new xpathdocument(xrload, xmlspace.preserve);	xrload.dispose();	
loading style sheet as navigator 

public void verifyresult(string expectedvalue) {	xmldiff.xmldiff xmldiff = new xmldiff.xmldiff();	xmldiff.option = xmldiffoption.infosetcomparison | xmldiffoption.ignoreemptyelement | xmldiffoption.normalizenewline;	streamreader sr = new streamreader(new filestream("out.xml", filemode.open, fileaccess.read));	string actualvalue = sr.readtoend();	sr.dispose();	
expected 

public void verifyresult(string expectedvalue) {	xmldiff.xmldiff xmldiff = new xmldiff.xmldiff();	xmldiff.option = xmldiffoption.infosetcomparison | xmldiffoption.ignoreemptyelement | xmldiffoption.normalizenewline;	streamreader sr = new streamreader(new filestream("out.xml", filemode.open, fileaccess.read));	string actualvalue = sr.readtoend();	sr.dispose();	
actual 

public void verifyresult(string baseline, string outputfile) {	bool result = false;	filestream fsexpected;	baseline = fullfilepath(baseline);	xmldiff.xmldiff diff = new xmldiff.xmldiff();	diff.option = xmldiffoption.ignoreemptyelement | xmldiffoption.ignoreattributeorder | xmldiffoption.infosetcomparison | xmldiffoption.ignorewhitespace | xmldiffoption.normalizenewline;	xmlparsercontext context = new xmlparsercontext(new nametable(), null, "", xmlspace.none);	fsexpected = new filestream(baseline, filemode.open, fileaccess.read, fileshare.read);	filestream fsactual = new filestream(outputfile, filemode.open, fileaccess.read, fileshare.read);	
verifying o p with baseline result 

result = diff.compare(new xmltextreader(fsactual, xmlnodetype.element, context), new xmltextreader(fsexpected, xmlnodetype.element, context));	}	catch (exception e) {	_output.writeline(e.tostring());	}	finally {	fsexpected.dispose();	fsactual.dispose();	}	if (!result) {	
expected o p 

}	finally {	fsexpected.dispose();	fsactual.dispose();	}	if (!result) {	using (streamreader sr = new streamreader(new filestream(baseline, filemode.open, fileaccess.read))) {	string baseline = sr.readtoend();	_output.writeline(baseline);	}	
actual o p 

public int transform(string szxmlfile, outputtype outputtype, navtype navtype, bool errorcase) {	szxmlfile = fullfilepath(szxmlfile);	
loading xml 

public int transform(string szxmlfile, outputtype outputtype, navtype navtype, bool errorcase) {	szxmlfile = fullfilepath(szxmlfile);	ixpathnavigable xd = loadxml(szxmlfile, navtype);	
executing transform 

public int transform_arglist(string szxmlfile, outputtype outputtype, navtype navtype, bool errorcase) {	szxmlfile = fullfilepath(szxmlfile);	
loading xml 

public int transform_arglist(string szxmlfile, outputtype outputtype, navtype navtype, bool errorcase) {	szxmlfile = fullfilepath(szxmlfile);	ixpathnavigable xd = loadxml(szxmlfile, navtype);	
executing transform 

public int transformresolver(string szxmlfile, outputtype outputtype, navtype navtype, xmlresolver xr, bool errorcase) {	szxmlfile = fullfilepath(szxmlfile);	
loading xml 

public int transformresolver(string szxmlfile, outputtype outputtype, navtype navtype, xmlresolver xr, bool errorcase) {	szxmlfile = fullfilepath(szxmlfile);	ixpathnavigable xd = loadxml(szxmlfile, navtype);	
executing transform 

========================= corefx sample_12641 =========================

catch (notsupportedexception) {	return true;	}	}	try {	datareader.readvaluechunk(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
actual exception 

catch (notsupportedexception) {	return true;	}	}	try {	datareader.readvaluechunk(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
expected exception 

}	int nchars;	try {	nchars = datareader.readvaluechunk(buffer, strexpected.length, 3);	}	catch (argumentexception) {	testlog.compare(datareader.readvaluechunk(buffer, 0, buffer.length), strexpected.length, "readvalue count");	testlog.compare(new string(buffer), strexpected, "str");	return;	}	
couldn t read after argumentexception 

========================= corefx sample_11568 =========================

xmlreader datareader = getreader(pbinhexxml);	positiononelement(datareader, st_elem_name1);	datareader.read();	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
actual exception 

xmlreader datareader = getreader(pbinhexxml);	positiononelement(datareader, st_elem_name1);	datareader.read();	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
expected exception 

public void testtextreadbinhex_23() {	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('a', 5000);	try {	xmlreader datareader = getreaderstr(strxml);	positiononelement(datareader, "b");	datareader.read();	if (!datareader.canreadbinarycontent) return;	datareader.readcontentasbinhex(buffer, 0, 5000);	
accepted incomplete element 

byte[] buffer = new byte[ibuffersize];	xmlreader datareader = getreader(pbinhexxml);	positiononelement(datareader, st_elem_name1);	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readelementcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
actual exception 

byte[] buffer = new byte[ibuffersize];	xmlreader datareader = getreader(pbinhexxml);	positiononelement(datareader, st_elem_name1);	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readelementcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
expected exception 

public void testtextreadbinhex_23() {	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('a', 5000);	try {	xmlreader datareader = getreaderstr(strxml);	positiononelement(datareader, "b");	datareader.readelementcontentasbinhex(buffer, 0, 5000);	
accepted incomplete element 

========================= corefx sample_11579 =========================

protected void log(string text, params object[] args) {	if (eventlog != null) {	
tdsparser 

========================= corefx sample_10916 =========================

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	
first processing instruction 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
doctype root system 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
notation gif system 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element root any 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element any 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element isdefault any 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity e system 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
e 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist cdata implied cdata cdata required 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist root xmlns something cdata fixed xmlns my cdata fixed xmlns dt cdata fixed 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist isdefault cdata fixed 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist multispaces att idrefs implied 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element catmixed pcdata 

public static void creategenerictestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	
play 

memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"e1foo e3bzee  e2bar\" child3=\"something\">");	
text node two text node three 

tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"e1foo e3bzee  e2bar\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("e1foo e3bzee  e2bar");	
cdata this section contains characters that should not be interpreted as markup for example characters 

tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"e1foo e3bzee  e2bar\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("e1foo e3bzee  e2bar");	
and are all fine here 

tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"e1foo e3bzee  e2bar\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("e1foo e3bzee  e2bar");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	
a 

tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"e1foo e3bzee  e2bar\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("e1foo e3bzee  e2bar");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	
this is a 

tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"e1foo e3bzee  e2bar\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("e1foo e3bzee  e2bar");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	
a 

tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("e1foo e3bzee ");	tw.writeline("e1foo e3bzee  e4gee");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
b 

tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("e1foo e3bzee ");	tw.writeline("e1foo e3bzee  e4gee");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
this is b 

tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("e1foo e3bzee ");	tw.writeline("e1foo e3bzee  e4gee");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
b 

tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("e1foo e3bzee ");	tw.writeline("e1foo e3bzee  e4gee");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	tw.writeline("elem2-text4");	
pi pi 

tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("e1foo e3bzee ");	tw.writeline("e1foo e3bzee  e4gee");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	tw.writeline("elem2-text4");	tw.writeline("elem2-text5");	tw.writeline("</elem2>");	tw.writeline("<elem2 att1=\"id2\"></elem2>");	
root 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	
x x 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	
x x 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	
x x 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	
elem 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	
elem 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	
elem 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	
xxx yyy 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	
xxx 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
xxx markup yyy 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx markup yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars markup yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx markup chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx cdata yyy zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars cdata yyy zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx cdata yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx pi yyy zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars pi zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx pi yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxxe1fooxxx'>xxx&gt;xxx&#66;xxx&#x44;xxxe1fooxxx</entity4>");	tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx chars 

tw.writeline("<entity5>e1foo e3bzee </entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	
isdefault 

tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	
true 

tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	
false 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
true 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
datetime datetime 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
date date 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
time time 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
integer integer 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
float float 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
decimal decimal 

tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	
title this is a comment title 

tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	
pgroup 

tw.writeline(string.format("<attribute5 crlf='x{0}x' cr='x{0}x' lf='x\nx' ms='x     x' tab='x\tx' />", environment.newline));	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	
persona dromio of ephesus persona 

tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	
abcde 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
grpdescr twin brothers and sons to aegeon and aemilia grpdescr 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
pgroup 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
pgroup 

tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color e1foo is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	
noxmllang 

tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color e1foo is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	
donexmllang 

tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color e1foo is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	
nospace 

tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color e1foo is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
grpdescr twin brothers and attendants on the two antipholuses grpdescr 

tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color e1foo is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
docnamespace 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
docnamespace 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
pgroup 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
gotocontent some text cdata cdata info gotocontent 

tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	tw.writeline("<skipcontent att1=\"\">  <!-- comment1--> \n <?pi_skipcontent instruction?></skipcontent>");	
mixcontent some text pi skipcontent instruction cdata cdata info mixcontent 

tw.writeline("</j8>89</i8>88</h8>87</g8>86</f8>85</e8>84</d8>83</c8>82</b8>81</a8>");	tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	
complex text comment cdata cdata complex 

tw.writeline("</j8>89</i8>88</h8>87</g8>86</f8>85</e8>84</d8>83</c8>82</b8>81</a8>");	tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	
dummy 

tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline(string.format("<multispaces att=' {0} \t {0}{0}  n1  {0} \t {0}{0}  n2  {0} \t {0}{0} ' />", environment.newline));	
cat ab cdata cd cat 

tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline(string.format("<multispaces att=' {0} \t {0}{0}  n1  {0} \t {0}{0}  n2  {0} \t {0}{0} ' />", environment.newline));	
catmixed ab cdata cd catmixed 

public static void createbigelementtestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	string str = new string('z', (1 << 20) - 1);	
root 

public static void createbigelementtestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	
x 

public static void createbigelementtestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	tw.flush();	tw.write("<");	tw.write(str);	
y 

public static void createbigelementtestfile(string strfilename) {	memorystream ms = new memorystream();	textwriter tw = new streamwriter(ms);	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	tw.flush();	tw.write("<");	tw.write(str);	
root 

========================= corefx sample_12601 =========================

public int indexof(t value) {	if (value == null) throw new argumentnullexception("value");	int index = 0;	foreach (trackedcollection<t>.valueel el in _inner.combinedvalues) {	if (el.isinserted && el.insertedvalue.equals(value)) {	
principalvaluecollection indexof found on inserted at 

public int indexof(t value) {	if (value == null) throw new argumentnullexception("value");	int index = 0;	foreach (trackedcollection<t>.valueel el in _inner.combinedvalues) {	if (el.isinserted && el.insertedvalue.equals(value)) {	return index;	}	if (!el.isinserted && el.originalvalue.right.equals(value)) {	
principalvaluecollection indexof found on original at 

public void removeat(int index) {	_inner.markchange();	if ((index < 0) || (index >= _inner.combinedvalues.count)) {	globaldebug.writelineif(globaldebug.warn, "principalvaluecollection", "removeat({0}): out of range (count={1})", index, _inner.combinedvalues.count);	throw new argumentoutofrangeexception("index");	}	trackedcollection<t>.valueel el = _inner.combinedvalues[index];	if (el.isinserted) {	
principalvaluecollection removeat removing inserted 

_inner.markchange();	if ((index < 0) || (index >= _inner.combinedvalues.count)) {	globaldebug.writelineif(globaldebug.warn, "principalvaluecollection", "removeat({0}): out of range (count={1})", index, _inner.combinedvalues.count);	throw new argumentoutofrangeexception("index");	}	trackedcollection<t>.valueel el = _inner.combinedvalues[index];	if (el.isinserted) {	_inner.combinedvalues.removeat(index);	}	else {	
principalvaluecollection removeat removing original 

========================= corefx sample_8978 =========================

}	else {	throw new outofmemoryexception();	}	}	if (retval != null) {	var serialregex = new regex(@"^com\d{1,3}$");	foreach (string str in retval) {	if (serialregex.ismatch(str)) {	ports.add(str);	
installed serial ports 

========================= corefx sample_618 =========================

public void canseek_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying canseek property throws exception after open then close 

public void canseek_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying canseek property throws exception after open then basestream close 

public void canseek_afteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying canseek property returns true after a call to open 

========================= corefx sample_589 =========================

public void document_2(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartdocument();	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartdocument();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void document_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writeenddocument();	w.writeenddocument();	}	catch (invalidoperationexception e) {	
exception 

w.writestartelement("root");	w.writeendelement();	w.writeenddocument();	w.writeenddocument();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writeenddocument();	w.writestartdocument();	w.writeenddocument();	}	catch (invalidoperationexception e) {	
exception 

w.writeendelement();	w.writeenddocument();	w.writestartdocument();	w.writeenddocument();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void document_7(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writestartelement("root");	}	catch (invalidoperationexception e) {	
exception 

w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writestartelement("root");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void document_8(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeenddocument();	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeenddocument();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void document_9(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestring("top level text");	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestring("top level text");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void document_10(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writestring("top level text");	}	catch (invalidoperationexception e) {	
exception 

w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writestring("top level text");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void document_11(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	int i = 1;	w.writevalue(i);	}	catch (invalidoperationexception e) {	
exception 

public void document_12(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	int i = 1;	w.writevalue(i);	}	catch (invalidoperationexception e) {	
exception 

========================= corefx sample_12472 =========================

public void dsrholding_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default dsrholding before open 

public void dsrholding_default_afteropen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default dsrholding after open 

========================= corefx sample_649 =========================

private void verifyresult(object actual, object expected, string message) {	
expected 

private void verifyresult(object actual, object expected, string message) {	
actual 

public void os10(object param0, object param1) {	init(param0.tostring(), param1.tostring());	_xsl.load(_xslfile);	xmlwritersettings os = _xsl.outputsettings;	
omitxmldeclaration 

public void os10(object param0, object param1) {	init(param0.tostring(), param1.tostring());	_xsl.load(_xslfile);	xmlwritersettings os = _xsl.outputsettings;	assert.equal(os.omitxmldeclaration, true);	
indent 

public void os10(object param0, object param1) {	init(param0.tostring(), param1.tostring());	_xsl.load(_xslfile);	xmlwritersettings os = _xsl.outputsettings;	assert.equal(os.omitxmldeclaration, true);	assert.equal(os.indent, true);	
outputmethod 

public void os10(object param0, object param1) {	init(param0.tostring(), param1.tostring());	_xsl.load(_xslfile);	xmlwritersettings os = _xsl.outputsettings;	assert.equal(os.omitxmldeclaration, true);	assert.equal(os.indent, true);	assert.equal(os.outputmethod, xmloutputmethod.xml);	
encoding 

public void os11(object param0, object param1) {	init(param0.tostring(), param1.tostring());	_xsl.load(_xslfile);	stream stm1 = new filestream("out1.xml", filemode.create, fileaccess.readwrite);	
transforming to xml 

public void os11(object param0, object param1) {	init(param0.tostring(), param1.tostring());	_xsl.load(_xslfile);	stream stm1 = new filestream("out1.xml", filemode.create, fileaccess.readwrite);	_xsl.transform(_xmlfile, null, stm1);	stream stm2 = new filestream("out2.xml", filemode.create, fileaccess.readwrite);	xmlwritersettings os = _xsl.outputsettings;	xmlwriter xw = xmlwriter.create(stm2, os);	
transforming to xmlwriter over with xslt outputsettings xml 

_xsl.transform(_xmlfile, null, stm1);	stream stm2 = new filestream("out2.xml", filemode.create, fileaccess.readwrite);	xmlwritersettings os = _xsl.outputsettings;	xmlwriter xw = xmlwriter.create(stm2, os);	_xsl.transform(_xmlfile, null, xw);	stm1.dispose();	stm2.dispose();	xmldiff.xmldiff diff = new xmldiff.xmldiff();	xmlreader xr1 = xmlreader.create("out1.xml");	xmlreader xr2 = xmlreader.create("out2.xml");	
comparing the stream output and xmlwriter output 

========================= corefx sample_12635 =========================

private object activate(lifetimecontext context, compositionoperation operation) {	if (!_exportdescriptor.isvaluecreated) {	throw throwhelper.notimplemented_metadatacycles();	}	
system composition activating via cycle breaking proxy 

========================= corefx sample_3038 =========================

public override tagvariation_status execute() {	list<object> children = children;	if (children != null && children.count > 0) {	foreach (object child in children) {	ctestcase tc = child as ctestcase;	if (tc != null) {	if (cmodinfo.istestcaseselected(tc.name)) {	
testcase 

foreach (object child in children) {	ctestcase tc = child as ctestcase;	if (tc != null) {	if (cmodinfo.istestcaseselected(tc.name)) {	tc.init();	tc.execute();	}	}	}	}	
pass fail skip 

========================= corefx sample_4609 =========================

public static void eval(dynamic result, string comment) {	if ((int)result != 0) {	failcount++;	
test failed at 

========================= corefx sample_75 =========================

public stressengine(int threads, int duration, ienumerable<testbase> alltests, int seed) {	if (seed != 0) {	_rnd = new random(seed);	}	else {	random rndbootstrap = new random();	seed = rndbootstrap.next();	_rnd = new random(seed);	}	
seeding stress engine random number generator with 

list<stresstest> tmpweightedlookup = new list<stresstest>();	foreach (testbase t in alltests) {	if (t is stresstest) {	_alltests.add(t as stresstest);	}	}	try {	_perfcounters = new perfcounters();	}	catch (exception e) {	
warning an error occurred initializing performance counters performance counters can only be initialized when running with administrator privileges error message 

try {	deadlockdetection.addtestthread();	t.run();	if (_perfcounters != null) _perfcounters.incrementrequestscounter();	}	catch (exception e) {	if (_perfcounters != null) _perfcounters.incrementexceptionscounter();	t.handleexception(e);	bool thresholdexceeded = _exceptions.record(t.title, e);	if (thresholdexceeded) {	
exception threshold of has been exceeded on halting 

========================= corefx sample_10980 =========================

public static datatablemapping gettablemappingbyschemaaction(datatablemappingcollection tablemappings, string sourcetable, string datasettable, missingmappingaction mappingaction) {	if (null != tablemappings) {	int index = tablemappings.indexof(sourcetable);	if (-1 != index) {	#if debug if (adapterswitches.dataschema.tracewarning) {	
mapping match on sourcetable 

#if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return tablemappings._items[index];	}	}	if (string.isnullorempty(sourcetable)) {	throw adp.invalidsourcetable(nameof(sourcetable));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	
mapping passthrough of sourcetable 

}	}	if (string.isnullorempty(sourcetable)) {	throw adp.invalidsourcetable(nameof(sourcetable));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatablemapping(sourcetable, datasettable);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
mapping filter of sourcetable 

throw adp.invalidsourcetable(nameof(sourcetable));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatablemapping(sourcetable, datasettable);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingmappingaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
mapping error on sourcetable sourcetable 

========================= corefx sample_3554 =========================

private static void dumpdatatable(datatable datatable, int rowprintcount) {	
dumpdatatable 

private static void dumpdatatable(datatable datatable, int rowprintcount) {	console.writeline("");	if (datatable == null) {	
datatable object is null 

private static void dumpdatatable(datatable datatable, int rowprintcount) {	console.writeline("");	if (datatable == null) {	return;	}	int columncount = datatable.columns.count;	int currentcolumn;	int rowcount = datatable.rows.count;	int currentrow;	
table has columns 

private static void dumpdatatable(datatable datatable, int rowprintcount) {	console.writeline("");	if (datatable == null) {	return;	}	int columncount = datatable.columns.count;	int currentcolumn;	int rowcount = datatable.rows.count;	int currentrow;	
table has rows at most the first are dumped 

private static void dumpdatarow(datarow datarow, datatable datatable) {	console.writeline(" ");	
dumpdatarow 

========================= corefx sample_11021 =========================

}	[fact]	public static void dynamiccsharpruntest() {	assert.equal(0, mainmethod());	}	public static int mainmethod() {	test t = new test();	dynamic d0 = (mydel)method;	t.foo += d0;	if (t.flag != 1) {	
event add doesn t get called 

}	public static int mainmethod() {	test t = new test();	dynamic d0 = (mydel)method;	t.foo += d0;	if (t.flag != 1) {	return 1;	}	t.foo -= d0;	if (t.flag != 2) {	
event remove doesn t get called 

========================= corefx sample_133 =========================

_restrictionerrormsg = null;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	xmlschemaparticle derivedparticle = cannonicalizepointlessroot(complextype.contenttypeparticle);	xmlschemaparticle baseparticle = cannonicalizepointlessroot(basetype.contenttypeparticle);	if (!isvalidrestriction(derivedparticle, baseparticle)) {	#if debug if (complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
invalid complextype content restriction 

_restrictionerrormsg = null;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	xmlschemaparticle derivedparticle = cannonicalizepointlessroot(complextype.contenttypeparticle);	xmlschemaparticle baseparticle = cannonicalizepointlessroot(basetype.contenttypeparticle);	if (!isvalidrestriction(derivedparticle, baseparticle)) {	#if debug if (complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
base 

_restrictionerrormsg = null;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	xmlschemaparticle derivedparticle = cannonicalizepointlessroot(complextype.contenttypeparticle);	xmlschemaparticle baseparticle = cannonicalizepointlessroot(basetype.contenttypeparticle);	if (!isvalidrestriction(derivedparticle, baseparticle)) {	#if debug if (complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
derived 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

foreach (xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

foreach (xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

foreach (xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

if (!contentvalidator.addelement(localelement.qualifiedname, localelement, localelement.minoccurs == decimal.zero)) {	sendvalidationevent(sr.sch_dupelement, localelement.qualifiedname.tostring(), localelement);	}	}	return contentvalidator;	}	else {	particlecontentvalidator contentvalidator = new particlecontentvalidator(complextype.contenttype, compilationsettings.enableupacheck);	#if debug if (diagnosticsswitches.xmlschema.traceverbose) {	string name = complextype.name != null ? complextype.name : string.empty;	
compilecomplexcontent 

========================= corefx sample_13097 =========================

private void runtest() {	
starting test tvptest 

runtest();	console.out.flush();	console.out.dispose();	streamwriter standardoutput = new streamwriter(console.openstandardoutput());	standardoutput.autoflush = true;	console.setout(standardoutput);	var comparisonresult = finddifffrombaseline(baselinepath, outputpath);	if (string.isnullorempty(comparisonresult)) {	return true;	}	
test failed 

runtest();	console.out.flush();	console.out.dispose();	streamwriter standardoutput = new streamwriter(console.openstandardoutput());	standardoutput.autoflush = true;	console.setout(standardoutput);	var comparisonresult = finddifffrombaseline(baselinepath, outputpath);	if (string.isnullorempty(comparisonresult)) {	return true;	}	
please compare baseline with output 

runtest();	console.out.flush();	console.out.dispose();	streamwriter standardoutput = new streamwriter(console.openstandardoutput());	standardoutput.autoflush = true;	console.setout(standardoutput);	var comparisonresult = finddifffrombaseline(baselinepath, outputpath);	if (string.isnullorempty(comparisonresult)) {	return true;	}	
comparison results 

private void testtvppermutations(stestructuredtypeboundaries bounds, bool runonlydatarecordtest) {	ienumerator<stepermutation> boundsmd = bounds.getenumerator(boundariestestkeys);	object[][] basevalues = stestructuredtypeboundaries.getseparatevalues(boundsmd);	ilist<datatable> dtlist = generatedatatables(basevalues);	transactionoptions opts = new transactionoptions();	opts.isolationlevel = system.transactions.isolationlevel.readcommitted;	int iter = 0;	while (boundsmd.movenext()) {	
iteration 

sqlcommand cmd;	sqlparameter param;	cmd = new sqlcommand(getprocname(tvpperm));	cmd.commandtype = commandtype.storedprocedure;	param = cmd.parameters.add(tvpname, sqldbtype.structured);	param.typename = gettypename(tvpperm);	try {	createserverobjects(tvpperm);	}	catch (sqlexception se) {	
sqlexception creating objects 

param = cmd.parameters.add(tvpname, sqldbtype.structured);	param.typename = gettypename(tvpperm);	try {	createserverobjects(tvpperm);	}	catch (sqlexception se) {	dropserverobjects(tvpperm);	iter++;	continue;	}	
ienumerable sqldatarecord 

catch (sqlexception se) {	dropserverobjects(tvpperm);	iter++;	continue;	}	try {	param.value = createlistofrecords(tvpperm, basevalues);	executeandverify(cmd, tvpperm, basevalues, null);	}	catch (argumentexception ae) {	
argument exception in value setup 

iter++;	continue;	}	try {	param.value = createlistofrecords(tvpperm, basevalues);	executeandverify(cmd, tvpperm, basevalues, null);	}	catch (argumentexception ae) {	}	if (!runonlydatarecordtest) {	
dbdatareader 

executeandverify(cmd, tvpperm, basevalues, null);	}	catch (argumentexception ae) {	}	if (!runonlydatarecordtest) {	try {	param.value = new tvprestartablereader(createlistofrecords(tvpperm, basevalues));	executeandverify(cmd, tvpperm, basevalues, null);	}	catch (argumentexception ae) {	
argument exception in value setup 

}	catch (argumentexception ae) {	}	if (!runonlydatarecordtest) {	try {	param.value = new tvprestartablereader(createlistofrecords(tvpperm, basevalues));	executeandverify(cmd, tvpperm, basevalues, null);	}	catch (argumentexception ae) {	}	
datatables 

sqlcommand cmd = new sqlcommand(createtypesql, conn);	cmd.executenonquery();	cmd.commandtext = createprocsql;	cmd.executenonquery();	cmd.commandtext = procname;	cmd.commandtype = commandtype.storedprocedure;	sqlparameter param = cmd.parameters.add("@tvp", sqldbtype.structured);	sqlmetadata[] columnmetadata;	list<sqldatarecord> rows = new list<sqldatarecord>();	sqldatarecord record;	
sort order uniqueness simple 

record.setvalues(1, "x-value", datetime.parse("04/01/2000"), 8);	rows.add(record);	record = new sqldatarecord(columnmetadata);	record.setvalues(1, "x-value", datetime.parse("04/01/2000"), 4);	rows.add(record);	param.value = rows;	using (sqldatareader rdr = cmd.executereader()) {	writereader(rdr);	}	rows.clear();	
sort order uniqueness mixed order 

record.setvalues(5, "x-value", datetime.parse("03/01/2000"), 3);	rows.add(record);	record = new sqldatarecord(columnmetadata);	record.setvalues(4, "x-value", datetime.parse("01/01/2000"), 3);	rows.add(record);	param.value = rows;	using (sqldatareader rdr = cmd.executereader()) {	writereader(rdr);	}	rows.clear();	
default column outer subset 

record.setvalues(5, "x-value", datetime.parse("03/01/2000"), 3);	rows.add(record);	record = new sqldatarecord(columnmetadata);	record.setvalues(4, "x-value", datetime.parse("01/01/2000"), 3);	rows.add(record);	param.value = rows;	using (sqldatareader rdr = cmd.executereader()) {	writereader(rdr);	}	rows.clear();	
default column middle subset 

record.setvalues(5, "x-value", datetime.parse("03/01/2000"), 3);	rows.add(record);	record = new sqldatarecord(columnmetadata);	record.setvalues(4, "x-value", datetime.parse("01/01/2000"), 3);	rows.add(record);	param.value = rows;	using (sqldatareader rdr = cmd.executereader()) {	writereader(rdr);	}	rows.clear();	
default column all 

private void dropserverobjects(stepermutation tvpperm) {	string droptext = "drop proc " + getprocname(tvpperm) + "; drop type " + gettypename(tvpperm);	using (sqlconnection conn = new sqlconnection(_connstr)) {	conn.open();	sqlcommand cmd = new sqlcommand(droptext, conn);	try {	cmd.executenonquery();	}	catch (sqlexception e) {	
sqlexception dropping objects 

private void executeandverify(sqlcommand cmd, stepermutation tvpperm, object[][] objvalues, datatable dtvalues) {	using (sqlconnection conn = new sqlconnection(_connstr)) {	conn.open();	cmd.connection = conn;	try {	using (sqldatareader rdr = cmd.executereader()) {	verifycolumnboundaries(rdr, getfields(tvpperm), objvalues, dtvalues);	}	}	catch (sqlexception se) {	
sqlexception error code 

conn.open();	cmd.connection = conn;	try {	using (sqldatareader rdr = cmd.executereader()) {	verifycolumnboundaries(rdr, getfields(tvpperm), objvalues, dtvalues);	}	}	catch (sqlexception se) {	}	catch (invalidoperationexception ioe) {	
invalidop 

try {	using (sqldatareader rdr = cmd.executereader()) {	verifycolumnboundaries(rdr, getfields(tvpperm), objvalues, dtvalues);	}	}	catch (sqlexception se) {	}	catch (invalidoperationexception ioe) {	}	catch (argumentexception ae) {	
argumentexception 

private void dumpsqlparam(sqlparameter param) {	
parameter 

private void dumpsqlparam(sqlparameter param) {	
isnullable 

private void dumpsqlparam(sqlparameter param) {	
localeid 

private void dumpsqlparam(sqlparameter param) {	
offset 

private void dumpsqlparam(sqlparameter param) {	
compareinfo 

private void dumpsqlparam(sqlparameter param) {	
dbtype 

private void dumpsqlparam(sqlparameter param) {	
direction 

private void dumpsqlparam(sqlparameter param) {	
precision 

private void dumpsqlparam(sqlparameter param) {	
scale 

private void dumpsqlparam(sqlparameter param) {	
size 

private void dumpsqlparam(sqlparameter param) {	
sqldbtype 

private void dumpsqlparam(sqlparameter param) {	
typename 

private void dumpsqlparam(sqlparameter param) {	
xmlschemacollectiondatabase 

private void dumpsqlparam(sqlparameter param) {	
xmlschemacollectionname 

private void dumpsqlparam(sqlparameter param) {	
xmlschemacollectionschema 

========================= corefx sample_11083 =========================

public async task serverallownoencryption_clientrequireencryption_connectwithencryption() {	using (var serverallownoencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.allownoencryption)) using (var client = new tcpclient()) {	await client.connectasync(serverallownoencryption.remoteendpoint.address, serverallownoencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null, encryptionpolicy.requireencryption)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

public async task serverallownoencryption_clientallownoencryption_connectwithencryption() {	using (var serverallownoencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.allownoencryption)) using (var client = new tcpclient()) {	await client.connectasync(serverallownoencryption.remoteendpoint.address, serverallownoencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null, encryptionpolicy.allownoencryption)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

public async task serverallownoencryption_clientnoencryption_connectwithnoencryption() {	using (var serverallownoencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.allownoencryption)) using (var client = new tcpclient()) {	await client.connectasync(serverallownoencryption.remoteendpoint.address, serverallownoencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null, encryptionpolicy.noencryption)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

========================= corefx sample_8125 =========================

public void manual_sendclientcertificatewithclientauthekutoremoteserver_ok() {	if (!cantestclientcertificates) {	
skipping nameof manual sendclientcertificatewithclientauthekutoremoteserver ok 

public void manual_sendclientcertificatewithserverauthekutoremoteserver_forbidden() {	if (!cantestclientcertificates) {	
skipping nameof manual sendclientcertificatewithserverauthekutoremoteserver forbidden 

public void manual_sendclientcertificatewithnoekutoremoteserver_ok() {	if (!cantestclientcertificates) {	
skipping nameof manual sendclientcertificatewithnoekutoremoteserver ok 

public async task manual_certificatesentmatchescertificatereceived_success( int numberofrequests, bool reuseclient) {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof manual certificatesentmatchescertificatereceived success 

public async task automaticormanual_doesntfailregardlessofwhetherclientcertsareavailable(clientcertificateoption mode) {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof manual certificatesentmatchescertificatereceived success 

========================= corefx sample_364 =========================

private test(int i) {	this.x = i;	
test 

protected test(int i) {	this.x = i;	
test 

========================= corefx sample_117 =========================

_stateobj._longlen = _snapshotlonglen;	_stateobj._longlenleft = _snapshotlonglenleft;	_stateobj._snapshotreplay = true;	_stateobj.assertvalidstate();	}	internal void preparereplay() {	resetsnapshotstate();	}	}	private void dumpbuffer() {	
dumping buffer 

}	internal void preparereplay() {	resetsnapshotstate();	}	}	private void dumpbuffer() {	console.writeline("_inbytesread = {0}", _inbytesread);	console.writeline("_inbytesused = {0}", _inbytesused);	int cc = 0;	int i;	
used buffer 

console.writeline();	cc = 0;	}	console.write("{0,-2:x2} ", _inbuff[i]);	cc++;	}	if (cc>0) {	console.writeline();	}	cc = 0;	
unused buffer 

========================= corefx sample_11182 =========================

public void timesincludemillisecondpart_linux() {	t item = getexistingitem();	string driveformat = new driveinfo(getitempath(item)).driveformat;	assert.all(timefunctions(), (function) => {	var msec = 0;	for (int i = 0; i < 5; i++) {	datetime time = function.getter(item);	msec = time.millisecond;	if (msec != 0) break;	thread.sleep(1234);	
timesincludemillisecondpart got a file time of time tostring o on driveformat 

========================= corefx sample_301 =========================

private static bool test1() {	dynamic a = 10;	int b = -a;	if (b == -10) return true;	
failed int 

private static bool test2() {	dynamic a = 10l;	long b = -(-a);	if (b == 10) return true;	
failed long 

private static bool test3() {	dynamic a = 10.10f;	float b = -a;	if (b == -10.10f) return true;	
failed float 

private static bool test4() {	dynamic a = 10.10d;	double b = -a;	if (b == -10.10) return true;	
failed double 

private static bool test5() {	dynamic a = 10.001m;	decimal b = -a;	if (b == -10.001m) return true;	
failed decimal 

private static bool test1() {	dynamic a = -10;	int b = +a;	if (b == -10) return true;	
failed int 

private static bool test2() {	dynamic a = -10l;	long b = +(+a);	if (b == -10) return true;	
failed long 

private static bool test3() {	dynamic a = 10.10f;	float b = +a;	if (b == 10.10f) return true;	
failed float 

private static bool test4() {	dynamic a = 10.10d;	double b = +(-a);	if (b == -10.10) return true;	
failed double 

private static bool test5() {	dynamic a = -10.001m;	decimal b = +a;	if (b == -10.001m) return true;	
failed decimal 

private static bool test1() {	dynamic a = 10;	int b = ~a;	if (b == -11) return true;	
failed int 

private static bool test2() {	dynamic a = -10l;	long b = ~a;	if (b == 9) return true;	
failed long 

private static bool test3() {	dynamic a = uint.minvalue;	uint b = ~a;	if (b == uint.maxvalue) return true;	
failed uint 

private static bool test4() {	dynamic a = ulong.maxvalue;	ulong b = ~~a;	if (b == ulong.maxvalue) return true;	
failed ulong 

private static bool test5() {	dynamic a = myenum.second;	myenum b = ~a;	if (b == ~myenum.second) return true;	
failed enum 

private static bool test6() {	dynamic a = "10";	try {	int b = ~a;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (errorverifier.verify(errormessageid.badunaryop, e.message, "~", "string")) return true;	}	
failed string 

private static bool test1() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a in boolvalues) {	dynamic d = a;	if (!d != !a) {	
failed bool 

private static bool test2() {	bool?[] boolvalues = new bool?[]	{	true, false };	foreach (bool? a in boolvalues) {	dynamic d = a;	if (!d != !a) {	
failed nullable bool 

private static bool test1() {	sbyte a = 10;	dynamic b = a;	++b;	if (b == 11) return true;	
failed sbyte 

private static bool test2() {	byte a = 10;	dynamic b = a;	++b;	if (b == 11) return true;	
failed byte 

private static bool test3() {	short a = 1;	dynamic b = a;	++b;	if (b == 2) return true;	
failed short 

private static bool test4() {	ushort a = 1;	dynamic b = a;	++b;	if (b == 2) return true;	
failed ushort 

private static bool test5() {	int a = -1;	dynamic b = a;	++b;	if (b == 0) return true;	
failed int 

private static bool test6() {	uint a = 1;	dynamic b = a;	++b;	if (b == 2) return true;	
failed uint 

private static bool test7() {	long a = 1;	dynamic b = a;	++b;	if (b == 2) return true;	
failed long 

private static bool test8() {	ulong a = 1;	dynamic b = a;	++b;	if (b == 2) return true;	
failed ulong 

private static bool test9() {	char a = 'a';	dynamic b = a;	++b;	if (b == 'b') return true;	
failed char 

private static bool test10() {	float a = 1.10f;	dynamic b = a;	++b;	if (b == 2.10f) return true;	
failed float 

private static bool test11() {	double a = 1.10d;	dynamic b = a;	++b;	if (b == 2.10d) return true;	
failed double 

private static bool test12() {	decimal a = 1.10m;	dynamic b = a;	++b;	if (b == 2.10m) return true;	
failed decimal 

private static bool test13() {	myenum a = myenum.second;	dynamic b = a;	++b;	if (b == myenum.third) return true;	
failed enum 

private static bool test1() {	sbyte a = 10;	dynamic b = a;	b++;	if (b == 11) return true;	
failed sbyte 

private static bool test2() {	byte a = 10;	dynamic b = a;	b++;	if (b == 11) return true;	
failed b yte 

private static bool test3() {	short a = 1;	dynamic b = a;	b++;	if (b == 2) return true;	
failed short 

private static bool test4() {	ushort a = 1;	dynamic b = a;	b++;	if (b == 2) return true;	
failed ushort 

private static bool test5() {	int a = -1;	dynamic b = a;	b++;	if (b == 0) return true;	
failed int 

private static bool test6() {	uint a = 1;	dynamic b = a;	b++;	if (b == 2) return true;	
failed uint 

private static bool test7() {	long a = 1;	dynamic b = a;	b++;	if (b == 2) return true;	
failed long 

private static bool test8() {	ulong a = 1;	dynamic b = a;	b++;	if (b == 2) return true;	
failed ulong 

private static bool test9() {	char a = 'a';	dynamic b = a;	b++;	if (b == 'b') return true;	
failed char 

private static bool test10() {	float a = 1.10f;	dynamic b = a;	b++;	if (b == 2.10f) return true;	
failed float 

private static bool test11() {	double a = 1.10d;	dynamic b = a;	b++;	if (b == 2.10d) return true;	
failed double 

private static bool test12() {	decimal a = 1.10m;	dynamic b = a;	b++;	if (b == 2.10m) return true;	
failed decimal 

private static bool test13() {	myenum a = myenum.second;	dynamic b = a;	b++;	if (b == myenum.third) return true;	
failed enum 

private static bool test1() {	sbyte a = 10;	dynamic b = a;	--b;	if (b == 9) return true;	
failed sbyte 

private static bool test2() {	byte a = 10;	dynamic b = a;	--b;	if (b == 9) return true;	
failed byte 

private static bool test3() {	short a = 2;	dynamic b = a;	--b;	if (b == 1) return true;	
failed short 

private static bool test4() {	ushort a = 2;	dynamic b = a;	--b;	if (b == 1) return true;	
failed ushort 

private static bool test5() {	int a = -1;	dynamic b = a;	--b;	if (b == -2) return true;	
failed int 

private static bool test6() {	uint a = 1;	dynamic b = a;	--b;	if (b == 0) return true;	
failed uint 

private static bool test7() {	long a = 1;	dynamic b = a;	--b;	if (b == 0) return true;	
failed long 

private static bool test8() {	ulong a = 2;	dynamic b = a;	--b;	if (b == 1) return true;	
failed ulong 

private static bool test9() {	char a = 'b';	dynamic b = a;	--b;	if (b == 'a') return true;	
failed char 

private static bool test10() {	float a = 1.11f;	dynamic b = a;	--b;	a--;	if (b == a) return true;	
failed float 

private static bool test11() {	double a = 1.12d;	dynamic b = a;	--b;	a--;	if (b == a) return true;	
failed double 

private static bool test12() {	decimal a = 2.10m;	dynamic b = a;	--b;	if (b == 1.10m) return true;	
failed decimal 

private static bool test13() {	myenum a = myenum.third;	dynamic b = a;	--b;	if (b == myenum.second) return true;	
failed enum 

private static bool test1() {	sbyte a = 10;	dynamic b = a;	b--;	if (b == 9) return true;	
failed sbyte 

private static bool test2() {	byte a = 10;	dynamic b = a;	b--;	if (b == 9) return true;	
failed b yte 

private static bool test3() {	short a = 2;	dynamic b = a;	b--;	if (b == 1) return true;	
failed short 

private static bool test4() {	ushort a = 2;	dynamic b = a;	b--;	if (b == 1) return true;	
failed ushort 

private static bool test5() {	int a = -1;	dynamic b = a;	b--;	if (b == -2) return true;	
failed int 

private static bool test6() {	uint a = 2;	dynamic b = a;	b--;	if (b == 1) return true;	
failed uint 

private static bool test7() {	long a = 1;	dynamic b = a;	b--;	if (b == 0) return true;	
failed long 

private static bool test8() {	ulong a = 2;	dynamic b = a;	b--;	if (b == 1) return true;	
failed ulong 

private static bool test9() {	char a = 'b';	dynamic b = a;	b--;	if (b == 'a') return true;	
failed char 

private static bool test10() {	float a = 2.10f;	dynamic b = a;	b--;	--a;	if (b == a) return true;	
failed float 

private static bool test11() {	double a = 2.10d;	dynamic b = a;	b--;	if (b == 1.10d) return true;	
failed double 

private static bool test12() {	decimal a = 2.10m;	dynamic b = a;	b--;	if (b == 1.10m) return true;	
failed decimal 

private static bool test13() {	myenum a = myenum.third;	dynamic b = a;	b--;	if (b == myenum.second) return true;	
failed enum 

private static bool test1() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	foreach (bool a2 in boolvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 & d2) != (a1 & a2)) {	
failed bool bool 

bool?[] boolvalues = new bool?[]	{	true, false, null }	;	foreach (bool? a1 in boolvalues) {	foreach (bool? a2 in boolvalues) {	if (a1 == null && a2 == null) continue;	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 & d2) != (a1 & a2)) {	
failed bool bool 

private static bool test3() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	foreach (bool a2 in boolvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 | d2) != (a1 | a2)) {	
failed bool bool 

bool?[] boolvalues = new bool?[]	{	true, false, null }	;	foreach (bool? a1 in boolvalues) {	foreach (bool? a2 in boolvalues) {	if (a1 == null && a2 == null) continue;	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 | d2) != (a1 | a2)) {	
failed bool bool 

private static bool test5() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	foreach (bool a2 in boolvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 ^ d2) != (a1 ^ a2)) {	
failed bool bool 

bool?[] boolvalues = new bool?[]	{	true, false, null }	;	foreach (bool? a1 in boolvalues) {	foreach (bool? a2 in boolvalues) {	if (a1 == null && a2 == null) continue;	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 ^ d2) != (a1 ^ a2)) {	
failed bool bool 

private static bool test1() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	foreach (bool a2 in boolvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 || d2) != (a1 || a2)) {	
failed bool bool 

private static bool test2() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	foreach (bool a2 in boolvalues) {	dynamic d1 = a1;	bool d2 = a2;	if ((d1 || d2) != (a1 || a2)) {	
failed bool bool 

private static bool test3() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	foreach (bool a2 in boolvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 && d2) != (a1 && a2)) {	
failed bool bool 

private static bool test4() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	foreach (bool a2 in boolvalues) {	bool d1 = a1;	dynamic d2 = a2;	if ((d1 && d2) != (a1 && a2)) {	
failed bool bool 

private static bool test1() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	dynamic d1 = a1;	if ((d1 || true) != (a1 || true)) {	
failed bool bool 

private static bool test2() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	dynamic d1 = a1;	if ((false || d1) != (false || a1)) {	
failed bool bool 

private static bool test3() {	bool?[] boolvalues = new bool?[]	{	true, false }	;	foreach (bool? a1 in boolvalues) {	dynamic d1 = a1;	if ((false || d1) != (false || a1.value)) {	
failed bool bool 

private static bool test4a() {	bool?[] boolvalues = new bool?[]	{	true }	;	foreach (bool? a1 in boolvalues) {	dynamic d1 = a1;	if (!(d1 || null)) {	
failed bool null 

private static bool test5() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	dynamic d1 = a1;	if ((d1 && false) != (a1 && false)) {	
failed bool bool 

private static bool test6() {	bool[] boolvalues = new bool[]	{	true, false }	;	foreach (bool a1 in boolvalues) {	dynamic d1 = a1;	if ((true && a1) != (true && d1)) {	
failed bool bool 

private static bool test7() {	bool?[] boolvalues = new bool?[]	{	true, false }	;	foreach (bool? a1 in boolvalues) {	dynamic d1 = a1;	if ((d1 && true) != (a1.value && true)) {	
failed bool bool 

private static bool test7a() {	bool?[] boolvalues = new bool?[]	{	null }	;	foreach (bool? a1 in boolvalues) {	dynamic d1 = a1;	try {	dynamic d = d1 && true;	
failed bool bool neg 

private static bool test1() {	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a1 in stringvalues) {	foreach (string a2 in stringvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 ?? d2) != (a1 ?? a2)) {	
failed string string 

;	int[] intvalues = new int[]	{	int.maxvalue, int.minvalue, 0 }	;	foreach (int? a1 in intnvalues) {	foreach (int a2 in intvalues) {	dynamic d1 = a1;	int d2 = a2;	if ((d1 ?? d2) != (a1 ?? a2)) {	
failed int int 

;	myenum[] enumvalues = new myenum[]	{	myenum.first, myenum.second, myenum.third }	;	foreach (myenum? a1 in enumnvalues) {	foreach (myenum a2 in enumvalues) {	myenum? d1 = a1;	dynamic d2 = a2;	if ((d1 ?? d2) != (a1 ?? a2)) {	
failed enum enum 

private static bool test1() {	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a1 in stringvalues) {	dynamic d1 = a1;	if ((d1 ?? null) != (a1 ?? null)) {	
failed string null 

private static bool test1a() {	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a1 in stringvalues) {	dynamic d1 = a1;	if ((d1 ?? string.empty) != (a1 ?? string.empty)) {	
failed string string 

private static bool test2() {	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a1 in stringvalues) {	dynamic d1 = a1;	if ((string.empty ?? d1) != (string.empty ?? a1)) {	
failed string string 

private static bool test3() {	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a1 in stringvalues) {	dynamic d1 = 10;	if ((string.empty ?? d1) != (string.empty ?? a1)) {	
failed string string 

private static bool test4() {	int?[] intnvalues = new int?[]	{	int.maxvalue, int.minvalue, 0, null }	;	foreach (int? a1 in intnvalues) {	dynamic d1 = a1;	if ((d1 ?? 0) != (a1 ?? 0)) {	
failed int int 

{	myenum.first, myenum.second, myenum.third, null }	;	myenum[] enumvalues = new myenum[]	{	myenum.first, myenum.second, myenum.third }	;	foreach (myenum? a1 in enumnvalues) {	dynamic d1 = a1;	if ((d1 ?? myenum.third) != (a1 ?? myenum.third)) {	
failed enum enum 

{	string.empty, "abc", null }	;	foreach (bool a1 in boolvalues) {	foreach (string a2 in stringvalues) {	foreach (string a3 in stringvalues) {	dynamic d1 = a1;	string d2 = a2;	string d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool string string 

{	string.empty, "abc", null }	;	foreach (bool a1 in boolvalues) {	foreach (string a2 in stringvalues) {	foreach (string a3 in stringvalues) {	bool d1 = a1;	dynamic d2 = a2;	string d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool string string 

{	string.empty, "abc", null }	;	foreach (bool a1 in boolvalues) {	foreach (string a2 in stringvalues) {	foreach (string a3 in stringvalues) {	bool d1 = a1;	string d2 = a2;	dynamic d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool string string 

{	string.empty, "abc", null }	;	foreach (bool a1 in boolvalues) {	foreach (string a2 in stringvalues) {	foreach (string a3 in stringvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	dynamic d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool string string 

{	decimal.maxvalue, decimal.minvalue, 0m }	;	foreach (bool a1 in boolvalues) {	foreach (decimal a2 in longvalues) {	foreach (decimal a3 in longvalues) {	dynamic d1 = a1;	decimal d2 = a2;	decimal d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool decimal decimal 

{	long.maxvalue, long.minvalue, null }	;	foreach (bool a1 in boolvalues) {	foreach (long? a2 in longnvalues) {	foreach (long? a3 in longnvalues) {	bool d1 = a1;	dynamic d2 = a2;	long? d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool nullable long nullable long 

{	guid.newguid(), guid.newguid(), default (guid)}	;	foreach (bool a1 in boolvalues) {	foreach (guid a2 in guidvalues) {	foreach (guid a3 in guidvalues) {	bool d1 = a1;	guid d2 = a2;	dynamic d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool guid guid 

{	guid.newguid(), default (guid), null }	;	foreach (bool a1 in boolvalues) {	foreach (guid? a2 in guidnvalues) {	foreach (guid? a3 in guidnvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	dynamic d3 = a3;	if ((d1 ? d2 : d3) != (a1 ? a2 : a3)) {	
failed bool nullable guid nullable guid 

;	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (bool a1 in boolvalues) {	foreach (string a3 in stringvalues) {	dynamic d1 = a1;	string d3 = a3;	if ((d1 ? null : d3) != (a1 ? null : a3)) {	
failed bool string string 

;	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (bool a1 in boolvalues) {	foreach (string a2 in stringvalues) {	bool d1 = a1;	dynamic d2 = a2;	if ((d1 ? d2 : string.empty) != (a1 ? a2 : string.empty)) {	
failed bool string string 

;	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a2 in stringvalues) {	foreach (string a3 in stringvalues) {	string d2 = a2;	dynamic d3 = a3;	if ((false ? d2 : d3) != (false ? a2 : a3)) {	
failed bool string string 

string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a2 in stringvalues) {	foreach (string a3 in stringvalues) {	bool d1 = true;	string d2 = a2;	dynamic d3 = 100;	if ((d1 ? "abc" : d3) != (d1 ? "abc" : a3)) {	
failed bool string string 

;	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (bool a1 in boolvalues) {	foreach (string a3 in stringvalues) {	dynamic d1 = a1;	dynamic d3 = a3;	if ((d1 ? "abcd" : d3) != (a1 ? "abcd" : a3)) {	
failed bool string string 

;	decimal[] longvalues = new decimal[]	{	decimal.maxvalue, decimal.minvalue, 0m }	;	foreach (bool a1 in boolvalues) {	foreach (decimal a2 in longvalues) {	dynamic d1 = a1;	decimal d2 = a2;	if ((d1 ? d2 : 10.01m) != (a1 ? a2 : 10.01m)) {	
failed bool decimal decimal 

;	long?[] longnvalues = new long?[]	{	long.maxvalue, long.minvalue, null }	;	foreach (bool a1 in boolvalues) {	foreach (long? a2 in longnvalues) {	bool d1 = a1;	dynamic d2 = a2;	if ((d1 ? d2 : 10l) != (a1 ? a2 : 10l)) {	
failed bool nullable long nullable long 

;	guid[] guidvalues = new guid[]	{	guid.newguid(), guid.newguid(), default (guid)}	;	foreach (bool a1 in boolvalues) {	foreach (guid a3 in guidvalues) {	bool d1 = a1;	dynamic d3 = a3;	if ((d1 ? default(guid) : d3) != (a1 ? default(guid) : a3)) {	
failed bool guid guid 

;	guid?[] guidnvalues = new guid?[]	{	guid.newguid(), default (guid), null }	;	foreach (bool a1 in boolvalues) {	foreach (guid? a2 in guidnvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 ? d2 : null) != (a1 ? a2 : null)) {	
failed bool nullable guid nullable guid 

private static bool test1() {	string[] stringvalues = new string[]	{	string.empty, "abc", null }	;	foreach (string a1 in stringvalues) {	dynamic d1 = a1;	if (d1 != a1) {	
failed string 

private static bool test2() {	int?[] intnvalues = new int?[]	{	int.maxvalue, int.minvalue, 0, null }	;	foreach (int? a1 in intnvalues) {	dynamic d1 = a1;	dynamic d2 = a1;	if (d1 != d2) {	
failed nullable int 

private static bool test3() {	guid[] guidvalues = new guid[]	{	guid.newguid(), guid.newguid(), default (guid)}	;	for (int i = 0; i < guidvalues.length; i++) {	for (int j = 0; j < guidvalues.length; j++) {	if (i != j) {	dynamic d1 = guidvalues[i];	if (d1 == guidvalues[j]) {	
failed guid 

private static bool test4() {	decimal[] decimalvalues = new decimal[]	{	decimal.maxvalue, decimal.minusone, 0m }	;	for (int i = 0; i < decimalvalues.length; i++) {	for (int j = 0; j < decimalvalues.length; j++) {	if (i != j) {	dynamic d1 = decimalvalues[i];	if (decimalvalues[j] == d1) {	
failed decimal 

private static bool test5() {	datetime[] datetimevalues = new datetime[]	{	datetime.now.addhours(10.00), datetime.now.addhours(5.00), datetime.now }	;	foreach (datetime a1 in datetimevalues) {	dynamic d1 = a1;	if (d1 != a1) {	
failed datetime 

private static bool test6() {	long[] longvalues = new long[]	{	long.maxvalue, long.minvalue, 0 }	;	foreach (long a1 in longvalues) {	dynamic d1 = a1;	dynamic d2 = a1;	if (d1 != d2) {	
failed long 

private static bool test7() {	myenum[] enumvalues = new myenum[]	{	myenum.first, myenum.second, myenum.third }	;	for (int i = 0; i < enumvalues.length; i++) {	for (int j = 0; j < enumvalues.length; j++) {	if (i != j) {	dynamic d1 = enumvalues[i];	if (d1 == enumvalues[j]) {	
failed enum 

private static bool test8() {	myenum?[] enumvalues = new myenum?[]	{	myenum.first, myenum.second, myenum.third, null }	;	for (int i = 0; i < enumvalues.length; i++) {	for (int j = 0; j < enumvalues.length; j++) {	if (i != j) {	dynamic d1 = enumvalues[i];	if (enumvalues[j] == d1) {	
failed nullable enum 

private static bool test1() {	long[] longvalues = new long[]	{	long.minvalue, long.minvalue, 0 }	;	foreach (long a1 in longvalues) {	foreach (long a2 in longvalues) {	dynamic d1 = a1;	if ((d1 < a2) != (a1 < a2)) {	
failed long long 

private static bool test2() {	decimal?[] decimalnvalues = new decimal?[]	{	decimal.maxvalue, int.minvalue, default (decimal), null }	;	foreach (decimal? a1 in decimalnvalues) {	foreach (decimal? a2 in decimalnvalues) {	dynamic d2 = a2;	if ((a1 > d2) != (a1 > a2)) {	
failed decimal decimal 

private static bool test1() {	long[] longvalues = new long[]	{	long.minvalue, long.minvalue, 0 }	;	foreach (long a1 in longvalues) {	dynamic d1 = a1;	if ((d1 < 10) != (a1 < 10)) {	
failed long long 

private static bool test2() {	decimal?[] decimalnvalues = new decimal?[]	{	decimal.maxvalue, int.minvalue, default (decimal), null }	;	foreach (decimal? a2 in decimalnvalues) {	dynamic d2 = a2;	if ((10m > d2) != (10m > a2)) {	
failed decimal decimal 

private static bool test2a() {	decimal?[] decimalnvalues = new decimal?[]	{	decimal.maxvalue, int.minvalue, default (decimal), null }	;	foreach (decimal? a2 in decimalnvalues) {	dynamic d2 = a2;	if ((d2 > null) != (a2 > null)) {	
failed decimal decimal 

private static bool test1() {	long[] longvalues = new long[]	{	long.minvalue, long.minvalue, 0 }	;	foreach (long a1 in longvalues) {	dynamic d1 = a1;	if ((method(d1) < 10) != (a1 < 10)) {	
failed long long 

private static bool test2() {	decimal?[] decimalnvalues = new decimal?[]	{	decimal.maxvalue, int.minvalue, default (decimal), null }	;	foreach (decimal? a2 in decimalnvalues) {	dynamic d2 = a2;	dynamic t = new test();	t.dfield = d2;	if ((10m > t.dpro) != (10m > a2)) {	
failed decimal decimal 

private static bool test2a() {	decimal?[] decimalnvalues = new decimal?[]	{	decimal.maxvalue, int.minvalue, default (decimal), null }	;	foreach (decimal? a2 in decimalnvalues) {	dynamic d2 = a2;	dynamic t = new test();	if ((t.method(d2) > null) != (a2 > null)) {	
failed decimal decimal 

string.empty, "abc", null }	;	object[] objectvalues = new object[]	{	null, 10, 10l, "10", myenum.first }	;	foreach (string a1 in stringvalues) {	foreach (object a2 in objectvalues) {	dynamic d2 = a2;	if ((a1 + d2) != (a1 + a2)) {	
failed string object 

private static bool test2() {	long?[] longnvalues = new long?[]	{	10l, 30l, 0, null }	;	foreach (long? a1 in longnvalues) {	foreach (long? a2 in longnvalues) {	dynamic d1 = a1;	if ((d1 - a2) != (a1 - a2)) {	
failed long long 

private static bool test3() {	decimal[] decimalvalues = new decimal[]	{	1m, 10.10m, 100.01m, 0m }	;	foreach (decimal a1 in decimalvalues) {	foreach (decimal a2 in decimalvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 * d2) != (a1 * a2)) {	
failed decimal decimal 

private static bool test4() {	int[] intvalues = new int[]	{	1, 2, 4, 99 }	;	foreach (int a1 in intvalues) {	foreach (int a2 in intvalues) {	dynamic d1 = a1;	dynamic d2 = a2;	if ((d1 / d2) != (a1 / a2)) {	
failed int int 

private static bool test5() {	decimal?[] decimalnvalues = new decimal?[]	{	1m, 10.10m, 100.01m, null }	;	foreach (decimal? a1 in decimalnvalues) {	foreach (decimal? a2 in decimalnvalues) {	dynamic d1 = a1;	if ((d1 % a2) != (a1 % a2)) {	
failed decimal decimal 

private static bool test6() {	byte[] bytevalues = new byte[]	{	2, 30, 16, 9 }	;	foreach (byte a1 in bytevalues) {	foreach (byte a2 in bytevalues) {	dynamic d2 = a2;	if ((a1 << d2) != (a1 << a2)) {	
failed byte byte 

private static bool test7() {	int?[] intnvalues = new int?[]	{	null, 2, 4, 3 }	;	foreach (int? a1 in intnvalues) {	foreach (int? a2 in intnvalues) {	dynamic d1 = a1;	if ((d1 >> a2) != (a1 >> a2)) {	
failed nullable int nullable int 

private static bool test1() {	object[] objectvalues = new object[]	{	10, 10l, "10" }	;	foreach (object a2 in objectvalues) {	dynamic d2 = a2;	if (("abc" + d2) != ("abc" + 10)) {	
failed string object 

private static bool test1a() {	object[] objectvalues = new object[]	{	string.empty, new test(), null }	;	foreach (object a2 in objectvalues) {	dynamic d2 = a2;	if (("abc" + d2) != ("abc" + a2)) {	
failed string object 

private static bool test2() {	long?[] longnvalues = new long?[]	{	10l, 30l, 0, null }	;	foreach (long? a1 in longnvalues) {	dynamic d1 = a1;	if ((d1 - 10) != (a1 - 10)) {	
failed long long 

private static bool test3() {	decimal[] decimalvalues = new decimal[]	{	1m, 10.10m, 100.01m, 0m }	;	foreach (decimal a2 in decimalvalues) {	dynamic d2 = a2;	if ((2m * d2) != (2m * a2)) {	
failed decimal decimal 

private static bool test4() {	int[] intvalues = new int[]	{	1, 2, 4, 99 }	;	foreach (int a1 in intvalues) {	dynamic d1 = a1;	if ((d1 / 3) != (a1 / 3)) {	
failed int int 

private static bool test5() {	decimal?[] decimalnvalues = new decimal?[]	{	1m, 10.10m, 100.01m, null }	;	foreach (decimal? a1 in decimalnvalues) {	dynamic d1 = a1;	if ((d1 % null) != (a1 % null)) {	
failed decimal decimal 

private static bool test6() {	byte[] bytevalues = new byte[]	{	2, 30, 16, 9 }	;	foreach (byte a2 in bytevalues) {	dynamic d2 = a2;	if ((30 << d2) != (30 << a2)) {	
failed byte byte 

private static bool test7() {	int?[] intnvalues = new int?[]	{	null, 2, 4, 3 }	;	foreach (int? a1 in intnvalues) {	dynamic d1 = a1;	if ((d1 >> 2) != (a1 >> 2)) {	
failed nullable int nullable int 

private static bool test1() {	dynamic d1 = true;	ishit = false;	if (d1 || boolvalue) {	if (ishit) {	
failed bool bool as circuiting operators 

private static bool test1() {	dynamic d1 = true;	ishit = false;	if (d1 || boolvalue) {	if (ishit) {	return false;	}	}	else {	
failed bool bool as circuiting operators 

private static bool test2() {	dynamic d1 = false;	ishit = false;	if (d1 && boolvalue) {	
failed bool bool as circuiting operators 

private static bool test2() {	dynamic d1 = false;	ishit = false;	if (d1 && boolvalue) {	return false;	}	else {	if (ishit) {	
failed bool bool as circuiting operators 

private static bool test3() {	dynamic d1 = false;	ishit = false;	dynamic m = d1 ? stringvalue : "abc";	if (ishit || m != "abc") {	
failed operator 

private static bool test4() {	dynamic d1 = true;	ishit = false;	dynamic value = 20;	dynamic m = d1 ? value : intvalue;	if (ishit || m != 20) {	
failed operator 

private static bool testandopwithsametypeandreturntype() {	clearflags();	dynamic d1 = new myopclass();	dynamic d2 = new myopclass();	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclass)) {	
failed got wrong return type 

private static bool testandopwithsametypeandreturntype() {	clearflags();	dynamic d1 = new myopclass();	dynamic d2 = new myopclass();	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclass)) {	return false;	}	if (dr != d1) {	
failed got wrong result 

dynamic d1 = new myopclass();	dynamic d2 = new myopclass();	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclass)) {	return false;	}	if (dr != d1) {	return false;	}	if (!(iscallfalse && iscallopand && !iscalltrue && !iscallconvert && !iscallopor)) {	
failed executed error ops iscallconvert iscalltrue iscallfalse iscallopand iscallopor 

private static bool testandopwithdifftype() {	clearflags();	dynamic d1 = new myopclasswithdifftype();	dynamic d2 = 10;	try {	dynamic dr = d1 && d2;	
failed didn t get runtimebinderexception 

private static bool testandopwithdifftype2() {	clearflags();	dynamic d1 = new myopclasswithdifftype2();	dynamic d2 = 10;	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclasswithdifftype2)) {	
failed got wrong return type 

private static bool testandopwithdifftype2() {	clearflags();	dynamic d1 = new myopclasswithdifftype2();	dynamic d2 = 10;	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclasswithdifftype2)) {	return false;	}	if (dr != d1) {	
failed got wrong result 

dynamic d1 = new myopclasswithdifftype2();	dynamic d2 = 10;	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclasswithdifftype2)) {	return false;	}	if (dr != d1) {	return false;	}	if (!(iscallfalse && !iscallopand && !iscalltrue && !iscallconvert && !iscallopor)) {	
failed executed error ops iscallconvert iscalltrue iscallfalse iscallopand iscallopor 

private static bool testandopwithsametypebutwrongreturntype() {	clearflags();	dynamic d1 = new myopclasswitherrorreturntype();	dynamic d2 = new myopclasswitherrorreturntype();	try {	dynamic dr = d1 && d2;	
failed didn t get runtimebinderexception 

private static bool testandopwithsametypebutwrongreturntype2() {	clearflags();	dynamic d1 = new myopclasswitherrorreturntype2();	dynamic d2 = new myopclasswitherrorreturntype2();	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclasswitherrorreturntype2)) {	
failed got wrong return type 

private static bool testandopwithsametypebutwrongreturntype2() {	clearflags();	dynamic d1 = new myopclasswitherrorreturntype2();	dynamic d2 = new myopclasswitherrorreturntype2();	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclasswitherrorreturntype2)) {	return false;	}	if (dr != d1) {	
failed got wrong result 

dynamic d1 = new myopclasswitherrorreturntype2();	dynamic d2 = new myopclasswitherrorreturntype2();	dynamic dr = d1 && d2;	if (dr.gettype() != typeof(myopclasswitherrorreturntype2)) {	return false;	}	if (dr != d1) {	return false;	}	if (!(iscallfalse && !iscallopand && !iscalltrue && !iscallconvert && !iscallopor)) {	
failed executed error ops iscallconvert iscalltrue iscallfalse iscallopand iscallopor 

private static bool testoropwithsametypeandreturntype() {	clearflags();	dynamic d1 = new myopclass();	dynamic d2 = new myopclass();	dynamic dr = d1 || d2;	if (dr.gettype() != typeof(myopclass)) {	
failed got wrong return type 

private static bool testoropwithsametypeandreturntype() {	clearflags();	dynamic d1 = new myopclass();	dynamic d2 = new myopclass();	dynamic dr = d1 || d2;	if (dr.gettype() != typeof(myopclass)) {	return false;	}	if (dr != d2) {	
failed got wrong result 

dynamic d1 = new myopclass();	dynamic d2 = new myopclass();	dynamic dr = d1 || d2;	if (dr.gettype() != typeof(myopclass)) {	return false;	}	if (dr != d2) {	return false;	}	if (!(iscalltrue && iscallopor && !iscallfalse && !iscallconvert && !iscallopand)) {	
failed executed error ops iscallconvert iscalltrue iscallfalse iscallopand iscallopor 

private static bool testoropwithdifftype() {	clearflags();	dynamic d1 = 10;	dynamic d2 = new myopclasswithdifftype();	try {	dynamic dr = d1 || d2;	
failed didn t get runtimebinderexception 

private static bool testoropwithdifftype2() {	clearflags();	dynamic d1 = 10;	dynamic d2 = new myopclasswithdifftype2();	try {	dynamic dr = d1 || d2;	
failed didn t get runtimebinderexception 

private static bool testoropwithsametypebutwrongreturntype() {	clearflags();	dynamic d1 = new myopclasswitherrorreturntype();	dynamic d2 = new myopclasswitherrorreturntype();	dynamic dr = d1 || d2;	if (dr.gettype() != typeof(myopclasswitherrorreturntype)) {	
failed got wrong return type 

private static bool testoropwithsametypebutwrongreturntype() {	clearflags();	dynamic d1 = new myopclasswitherrorreturntype();	dynamic d2 = new myopclasswitherrorreturntype();	dynamic dr = d1 || d2;	if (dr.gettype() != typeof(myopclasswitherrorreturntype)) {	return false;	}	if (dr != d1) {	
failed got wrong result 

dynamic d1 = new myopclasswitherrorreturntype();	dynamic d2 = new myopclasswitherrorreturntype();	dynamic dr = d1 || d2;	if (dr.gettype() != typeof(myopclasswitherrorreturntype)) {	return false;	}	if (dr != d1) {	return false;	}	if (!(iscalltrue && !iscallopor && !iscallfalse && !iscallconvert && !iscallopand)) {	
failed executed error ops iscallconvert iscalltrue iscallfalse iscallopand iscallopor 

private static bool testoropwithsametypebutwrongreturntype2() {	clearflags();	dynamic d1 = new myopclasswitherrorreturntype2();	dynamic d2 = new myopclasswitherrorreturntype2();	try {	dynamic dr = d1 || d2;	
failed didn t get runtimebinderexception 

========================= corefx sample_123 =========================

public void newlinechars_6(xmlwriterutils utils, string newlinechars) {	xmlwritersettings wsettings = new xmlwritersettings();	wsettings.closeoutput = true;	wsettings.newlinechars = newlinechars;	xmlwriter w = null;	try {	w = utils.createwriter(wsettings);	}	catch (argumentexception e) {	
exception 

xmlwritersettings wsettings = new xmlwritersettings();	wsettings.closeoutput = true;	wsettings.newlinechars = newlinechars;	xmlwriter w = null;	try {	w = utils.createwriter(wsettings);	}	catch (argumentexception e) {	return;	}	
did not throw argumentexception 

========================= corefx sample_12456 =========================

protected void logtestfailure(string exceptiondata) {	
failed 

========================= corefx sample_10963 =========================

var etest = e as oledb.test.modulecore.ctestexception;	if (etest != null) {	actual = etest.actual;	expected = etest.expected;	eresult = etest.result;	switch (eresult) {	case 1: _output.writeline(etest.message);	return eresult;	};	}	
actual 

var etest = e as oledb.test.modulecore.ctestexception;	if (etest != null) {	actual = etest.actual;	expected = etest.expected;	eresult = etest.result;	switch (eresult) {	case 1: _output.writeline(etest.message);	return eresult;	};	}	
expected 

========================= corefx sample_12625 =========================

public bufferedgraphics allocate(graphics targetgraphics, rectangle targetrectangle) {	if (shouldusetempmanager(targetrectangle)) {	
too big of buffer requested x allocating temp buffer manager 

public bufferedgraphics allocate(intptr targetdc, rectangle targetrectangle) {	if (shouldusetempmanager(targetrectangle)) {	
too big of buffer requested x allocating temp buffer manager 

private bufferedgraphics allocbuffer(graphics targetgraphics, intptr targetdc, rectangle targetrectangle) {	int oldbusy = interlocked.compareexchange(ref _busy, bufferbusypainting, bufferfree);	if (oldbusy != bufferfree) {	
attempt to have two buffers for a buffer manager allocating temp buffer manager 

private unsafe bool fillcolortable(intptr hdc, intptr hpal, ref nativemethods.bitmapinfo_flat pbmi) {	byte[] aj = new byte[sizeof(nativemethods.paletteentry) * 256];	fixed (byte* pcolors = pbmi.bmicolors) {	fixed (byte* ppal = aj) {	nativemethods.rgbquad* prgb = (nativemethods.rgbquad*)pcolors;	nativemethods.paletteentry* lppe = (nativemethods.paletteentry*)ppal;	int ccolors = 1 << pbmi.bmiheader_bibitcount;	if (ccolors <= 256) {	
bit or less 

byte[] aj = new byte[sizeof(nativemethods.paletteentry) * 256];	fixed (byte* pcolors = pbmi.bmicolors) {	fixed (byte* ppal = aj) {	nativemethods.rgbquad* prgb = (nativemethods.rgbquad*)pcolors;	nativemethods.paletteentry* lppe = (nativemethods.paletteentry*)ppal;	int ccolors = 1 << pbmi.bmiheader_bibitcount;	if (ccolors <= 256) {	uint palret;	intptr palhalftone = intptr.zero;	if (hpal == intptr.zero) {	
using halftone palette 

nativemethods.paletteentry* lppe = (nativemethods.paletteentry*)ppal;	int ccolors = 1 << pbmi.bmiheader_bibitcount;	if (ccolors <= 256) {	uint palret;	intptr palhalftone = intptr.zero;	if (hpal == intptr.zero) {	palhalftone = graphics.gethalftonepalette();	palret = safenativemethods.getpaletteentries(new handleref(null, palhalftone), 0, ccolors, aj);	}	else {	
using custom palette 

if (palret != 0) {	for (int i = 0; i < ccolors; i++) {	prgb[i].rgbred = lppe[i].pered;	prgb[i].rgbgreen = lppe[i].pegreen;	prgb[i].rgbblue = lppe[i].peblue;	prgb[i].rgbreserved = 0;	}	return true;	}	else {	
fillcolortable mygetsystempaletteentries failed 

private graphics createbuffer(intptr src, int offsetx, int offsety, int width, int height) {	_busy = bufferbusydisposing;	disposedc();	_busy = bufferbusypainting;	_compatdc = unsafenativemethods.createcompatibledc(new handleref(null, src));	if (width > _buffersize.width || height > _buffersize.height) {	
allocating new bitmap x 

_busy = bufferbusydisposing;	disposedc();	_busy = bufferbusypainting;	_compatdc = unsafenativemethods.createcompatibledc(new handleref(null, src));	if (width > _buffersize.width || height > _buffersize.height) {	int optwidth = math.max(width, _buffersize.width);	int optheight = math.max(height, _buffersize.height);	_busy = bufferbusydisposing;	disposebitmap();	_busy = bufferbusypainting;	
new size x 

int optwidth = math.max(width, _buffersize.width);	int optheight = math.max(height, _buffersize.height);	_busy = bufferbusydisposing;	disposebitmap();	_busy = bufferbusypainting;	intptr pvbits = intptr.zero;	_dib = createcompatibledib(src, intptr.zero, optwidth, optheight, ref pvbits);	_buffersize = new size(optwidth, optheight);	}	_oldbitmap = safenativemethods.selectobject(new handleref(this, _compatdc), new handleref(this, _dib));	
create compatgraphics 

private void disposedc() {	if (_oldbitmap != intptr.zero && _compatdc != intptr.zero) {	
restoring bitmap to dc 

private void disposedc() {	if (_oldbitmap != intptr.zero && _compatdc != intptr.zero) {	safenativemethods.selectobject(new handleref(this, _compatdc), new handleref(this, _oldbitmap));	_oldbitmap = intptr.zero;	}	if (_compatdc != intptr.zero) {	
delete compat dc 

private void disposebitmap() {	if (_dib != intptr.zero) {	debug.assert(_oldbitmap == intptr.zero);	
delete dib 

private void dispose(bool disposing) {	
dispose 

private void dispose(bool disposing) {	debug.indent();	int oldbusy = interlocked.compareexchange(ref _busy, bufferbusydisposing, bufferfree);	if (disposing) {	if (oldbusy == bufferbusypainting) {	
stack at busy buffer 

private void dispose(bool disposing) {	debug.indent();	int oldbusy = interlocked.compareexchange(ref _busy, bufferbusydisposing, bufferfree);	if (disposing) {	if (oldbusy == bufferbusypainting) {	#endif throw new invalidoperationexception(sr.format(sr.graphicsbuffercurrentlybusy));	}	if (_compatgraphics != null) {	
disposing compatgraphics 

#endif throw new invalidoperationexception(sr.format(sr.graphicsbuffercurrentlybusy));	}	if (_compatgraphics != null) {	_compatgraphics.dispose();	_compatgraphics = null;	}	}	disposedc();	disposebitmap();	if (_buffer != null) {	
disposing buffer 

private void dumpbitmapinfo(ref nativemethods.bitmapinfo_flat pbmi) {	
biwidth 

private void dumpbitmapinfo(ref nativemethods.bitmapinfo_flat pbmi) {	
biheight 

private void dumpbitmapinfo(ref nativemethods.bitmapinfo_flat pbmi) {	
biplanes 

private void dumpbitmapinfo(ref nativemethods.bitmapinfo_flat pbmi) {	
bibitcount 

========================= corefx sample_10427 =========================

public void discardwithoutopen() {	using (serialport com = new serialport()) {	
verifying discard method throws exception without a call to open 

public void discardafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read discard throws exception with a failed call to open 

public void discardafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying discard method throws exception after a call to cloes 

public void discardafteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying discard method does not throw an exception after a call to open 

========================= corefx sample_659 =========================

wsettings.omitxmldeclaration = true;	xmlwriter w = utils.createwriter(wsettings);	cerror.compare(w.settings.conformancelevel, conformancelevel.document, "mismatch in cl");	cerror.compare(w.settings.omitxmldeclaration, true, "mismatch in omitxmldecl");	w.writestartelement("root");	w.writeendelement();	w.dispose();	xmlreader xr = utils.getreader();	while (xr.read()) {	if (xr.nodetype == xmlnodetype.xmldeclaration) {	
wrote xmldecl when omitxmldecl was true 

wsettings.omitxmldeclaration = true;	xmlwriter w = utils.createwriter(wsettings);	w.writestartdocument(true);	w.writestartelement("root");	w.writeendelement();	w.writeenddocument();	w.dispose();	xmlreader xr = utils.getreader();	while (xr.read()) {	if (xr.nodetype == xmlnodetype.xmldeclaration) {	
wrote xmldecl when omitxmldecl was true 

========================= corefx sample_12462 =========================

if (d0.field != 14) ispass &= false;	d1[0] = 0;	if (d1.field != 14) ispass &= false;	try {	d0.myproperty2 = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "myclass.myproperty2");	if (!ret) {	
error message is wrong 

if (d0.myproperty2 != 14) ispass &= false;	else ispass &= true;	}	try {	d1.myproperty2 = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "mystruct.myproperty2");	if (!ret) {	
error message is wrong 

if (d1.myproperty2 != 14) ispass &= false;	else ispass &= true;	}	try {	d0['a'] = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "myclass.this[char]");	if (!ret) {	
error message is wrong 

if (d0['a'] != 14) ispass &= false;	else ispass &= true;	}	try {	d1['a'] = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "mystruct.this[char]");	if (!ret) {	
error message is wrong 

if (d1.mc.field != 12) ispass &= false;	d1.mc[0] = 0;	if (d1.mc.field != 14) ispass &= false;	try {	d1.mc.myproperty2 = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "myclass.myproperty2");	if (!ret) {	
error message is wrong 

if (d1.mc.myproperty2 != 14) ispass &= false;	else ispass &= true;	}	try {	d1.mc['a'] = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "myclass.this[char]");	if (!ret) {	
error message is wrong 

if (d1.ms.field != 9) ispass &= false;	d1.ms[0] = 0;	if (d1.ms.field != 9) ispass &= false;	try {	d1.ms.myproperty2 = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "mystruct2.myproperty2");	if (!ret) {	
error message is wrong 

if (d1.ms.myproperty2 != 9) ispass &= false;	else ispass &= true;	}	try {	d1.ms['a'] = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "mystruct2.this[char]");	if (!ret) {	
error message is wrong 

if (d1.ms.field != 9) ispass &= false;	d1.ms[0] = 0;	if (d1.ms.field != 9) ispass &= false;	try {	d1.ms.myproperty2 = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "mystruct.myproperty2");	if (!ret) {	
error message is wrong 

if (d1.ms.myproperty2 != 9) ispass &= false;	else ispass &= true;	}	try {	d1.ms['a'] = 0;	ispass &= false;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.inaccessiblesetter, ex.message, "mystruct.this[char]");	if (!ret) {	
error message is wrong 

========================= corefx sample_51 =========================

public void endwriteafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying endwrite method throws exception after a call to close 

public void endwriteafterserialstreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying endwrite method throws exception after a call to basestream close 

public void asyncresult_null() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying endwrite with null asyncresult 

public void asyncresult_readresult() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying endwrite with asyncresult returned from read 

public void asyncresult_multiplesameresult() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	var numbytestowrite = 8;	
verifying calling endwrite twice with the same asyncresult 

public void asyncresult_multipleinorder() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	int numbytestowrite1 = 8, numbytestowrite2 = 16, numbytestowrite3 = 10;	
verifying endwrite with multiple calls to beginread 

public void asyncresult_multipleoutoforder() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	int numbytestowrite1 = 8, numbytestowrite2 = 16, numbytestowrite3 = 10;	
verifying calling endwrite with different asyncresults out of order returned from beginread 

public void inbreak() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying endwrite throws invalidoperationexception while in a break 

========================= corefx sample_599 =========================

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void readafterbasestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to basestream close 

public void parityerroronlastbyte() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var rndgen = new random(15);	var bytestowrite = new byte[numrndbyte];	var expectedbytes = new byte[numrndbyte];	var actualbytes = new byte[numrndbyte + 1];	var actualbyteindex = 0;	
verifying default parityreplace byte with a parity error on the last byte 

========================= corefx sample_608 =========================

bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.binhex_test);	datareader.positiononelement(st_elem_name1);	datareader.read();	if (checkcanreadbinarycontent()) return true;	try {	datareader.readcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	
actual exception 

bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.binhex_test);	datareader.positiononelement(st_elem_name1);	datareader.read();	if (checkcanreadbinarycontent()) return true;	try {	datareader.readcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	
expected exception 

public void dump(byte[] bytes) {	for (int i = 0; i < bytes.length; i++) {	
byte 

int binhexlen = 10;	byte[] binhex = new byte[binhexlen];	reloadsource(ereader_type.binhex_test);	datareader.positiononelement(st_elem_name4);	datareader.read();	if (checkcanreadbinarycontent()) return test_pass;	string stractbinhex = "";	for (int i = 0; i < binhexlen; i = i + 2) {	datareader.readcontentasbinhex(binhex, i, 2);	stractbinhex = (system.bitconverter.tochar(binhex, i)).tostring();	
actual exp 

public int testtextreadbinhex_23() {	if (isroundtrippedreader()) return test_skipped;	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('a', 5000);	reloadsource(new stringreader(strxml));	datareader.positiononelement("b");	datareader.read();	if (checkcanreadbinarycontent()) return test_pass;	try {	datareader.readcontentasbinhex(buffer, 0, 5000);	
accepted incomplete element 

stringbuilder output = new stringbuilder();	while (bytes != 0) {	byte[] bbb = new byte[1024];	bytes = datareader.readcontentasbinhex(bbb, 0, bbb.length);	for (int i = 0; i < bytes; i++) {	cerror.write(bbb[i].tostring());	output.appendformat(bbb[i].tostring());	}	}	cerror.writeline();	
length of the output 

private bool verifyinvalidreadbinhex(int ibuffersize, int iindex, int icount, type exceptiontype) {	bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.binhex_test);	datareader.positiononelement(st_elem_name1);	if (checkcanreadbinarycontent()) return true;	try {	datareader.readelementcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	
actual exception 

private bool verifyinvalidreadbinhex(int ibuffersize, int iindex, int icount, type exceptiontype) {	bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.binhex_test);	datareader.positiononelement(st_elem_name1);	if (checkcanreadbinarycontent()) return true;	try {	datareader.readelementcontentasbinhex(buffer, iindex, icount);	}	catch (exception e) {	
expected exception 

public int testreadbinhex_13() {	int binhexlen = 10;	byte[] binhex = new byte[binhexlen];	reloadsource(ereader_type.binhex_test);	datareader.positiononelement(st_elem_name4);	if (checkcanreadbinarycontent()) return test_pass;	string stractbinhex = "";	for (int i = 0; i < binhexlen; i = i + 2) {	datareader.readelementcontentasbinhex(binhex, i, 2);	stractbinhex = (system.bitconverter.tochar(binhex, i)).tostring();	
actual exp 

public int testtextreadbinhex_23() {	if (isroundtrippedreader()) return test_skipped;	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('a', 5000);	reloadsource(new stringreader(strxml));	datareader.positiononelement("b");	if (checkcanreadbinarycontent()) return test_pass;	try {	datareader.readelementcontentasbinhex(buffer, 0, 5000);	
accepted incomplete element 

stringbuilder output = new stringbuilder();	while (bytes != 0) {	byte[] bbb = new byte[1024];	bytes = datareader.readelementcontentasbinhex(bbb, 0, bbb.length);	for (int i = 0; i < bytes; i++) {	cerror.write(bbb[i].tostring());	output.appendformat(bbb[i].tostring());	}	}	cerror.writeline();	
length of the output 

reloadsource(new stringreader(strxml));	datareader.read();	datareader.read();	using (xmlreader sr = datareader.readsubtree()) {	sr.read();	sr.movetofirstattribute();	sr.movetofirstattribute();	byte[] bytes = new byte[4];	while ((sr.readcontentasbinhex(bytes, 0, bytes.length)) > 0) {	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
linenumber 

reloadsource(new stringreader(strxml));	datareader.read();	datareader.read();	using (xmlreader sr = datareader.readsubtree()) {	sr.read();	sr.movetofirstattribute();	sr.movetofirstattribute();	byte[] bytes = new byte[4];	while ((sr.readcontentasbinhex(bytes, 0, bytes.length)) > 0) {	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
lineposition 

byte[] buffer = new byte[3];	int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbinhex(buffer, startpos, readsize);	cerror.equals(currentsize, 1, "size");	cerror.equals(buffer[0], (byte)17, "buffer");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
linenumber 

byte[] buffer = new byte[3];	int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbinhex(buffer, startpos, readsize);	cerror.equals(currentsize, 1, "size");	cerror.equals(buffer[0], (byte)17, "buffer");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
lineposition 

byte[] buffer = new byte[3];	int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbinhex(buffer, startpos, readsize);	cerror.equals(currentsize, 1, "size");	cerror.equals(buffer[0], (byte)18, "buffer");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
linenumber 

byte[] buffer = new byte[3];	int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbinhex(buffer, startpos, readsize);	cerror.equals(currentsize, 1, "size");	cerror.equals(buffer[0], (byte)18, "buffer");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
lineposition 

int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	cerror.equals(datareader.value.contains("123"), "value");	currentsize = datareader.readcontentasbinhex(buffer, startpos, readsize);	cerror.equals(currentsize, 1, "size");	cerror.equals(buffer[0], (byte)18, "buffer");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
linenumber 

int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	cerror.equals(datareader.value.contains("123"), "value");	currentsize = datareader.readcontentasbinhex(buffer, startpos, readsize);	cerror.equals(currentsize, 1, "size");	cerror.equals(buffer[0], (byte)18, "buffer");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
lineposition 

========================= corefx sample_12433 =========================

private void verifyresult(object actual, object expected, string message) {	
expected 

private void verifyresult(object actual, object expected, string message) {	
actual 

public void xsltsettings2(object param0, object param1, object param2, object param3) {	init(param0.tostring(), param1.tostring());	xsltsettings xs = new xsltsettings((bool)param2, (bool)param3);	xpathdocument doc = new xpathdocument(_xslfile);	_xsl.load(doc, xs, new xmlurlresolver());	try {	stringwriter sw = transform();	
execution of the scripts was allowed even when xsltsettings enablescript is false 

========================= corefx sample_12640 =========================

private static int verify() {	lock (test.locker) {	if (test.s_field == null) {	
failed the finalizer hasn t executed 

private static int verify() {	lock (test.locker) {	if ((object)(test.s_field) == null) {	
failed the finalizer hasn t executed 

========================= corefx sample_9 =========================

public int getparam1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	
getparam thread iteration added value retrieved value 

public int getparam1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	if (retobj.tostring() != "test1") {	
error 

public int getparam2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	string expected = "test" + ((object[])args)[0];	
getparam thread iteration added value retrieved value 

public int getparam2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	string expected = "test" + ((object[])args)[0];	if (retobj.tostring() != expected) {	
error 

public int getextnobject1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	
getextensionobject thread iteration value returned 

public int getextnobject1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	if (((myobject)retobj).myvalue() != 1) {	
error set and retrieved value appear to be different 

public int getextnobject2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	
getextensionobject thread iteration value returned 

public int getextnobject2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	if (((myobject)retobj).myvalue() != (int)((object[])args)[0]) {	
error set and retrieved value appear to be different 

xpathdocument xd = new xpathdocument(xrdata, xmlspace.preserve);	xrdata.dispose();	xsltransform xslt = new xsltransform();	xmlvalidatingreader xrtemp = new xmlvalidatingreader(new xmltextreader(_strxslfile));	#pragma warning restore 0618 xrtemp.validationtype = validationtype.none;	xrtemp.entityhandling = entityhandling.expandcharentities;	xslt.load(xrtemp);	xmlreader xrxslt = null;	for (int i = 1; i <= 100; i++) {	xrxslt = xslt.transform(xd, xsltarg1);	
sharedargumentlist thread iteration done with transform 

========================= corefx sample_12631 =========================

public void eventhandlers_calledserially() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler pinchangedeventhandler = new pinchangedeventhandler(com1, false, true);	receivedeventhandler receivedeventhandler = new receivedeventhandler(com1, false, true);	erroreventhandler erroreventhandler = new erroreventhandler(com1, false, true);	int numpinchangedevents = 0, numerrorevents = 0, numreceivedevents = 0;	int iterationwaittime = 100;	
verifying that event handlers are called serially 

thread.sleep(trigering_events_wait_time);	com1.pinchanged += pinchangedeventhandler.handleevent;	com1.datareceived += receivedeventhandler.handleevent;	com1.errorreceived += erroreventhandler.handleevent;	com1.databits = 7;	com1.parity = parity.mark;	com2.basestream.write(new byte[1], 0, 1);	debug.print("errorevent triggered");	thread.sleep(trigering_events_wait_time);	com2.dtrenable = true;	
pinchange triggered 

com1.databits = 7;	com1.parity = parity.mark;	com2.basestream.write(new byte[1], 0, 1);	debug.print("errorevent triggered");	thread.sleep(trigering_events_wait_time);	com2.dtrenable = true;	thread.sleep(trigering_events_wait_time);	com1.databits = 8;	com1.parity = parity.none;	com2.basestream.write(new byte[] { 40 }, 0, 1);	
rxevent triggered 

thread.sleep(trigering_events_wait_time);	com2.dtrenable = true;	thread.sleep(trigering_events_wait_time);	com1.databits = 8;	com1.parity = parity.none;	com2.basestream.write(new byte[] { 40 }, 0, 1);	thread.sleep(trigering_events_wait_time);	com1.databits = 7;	com1.parity = parity.none;	com2.basestream.write(new byte[] { 0x01 }, 0, 1);	
frameerror triggered 

thread.sleep(trigering_events_wait_time);	com1.databits = 8;	com1.parity = parity.none;	com2.basestream.write(new byte[] { 40 }, 0, 1);	thread.sleep(trigering_events_wait_time);	com1.databits = 7;	com1.parity = parity.none;	com2.basestream.write(new byte[] { 0x01 }, 0, 1);	thread.sleep(trigering_events_wait_time);	com2.rtsenable = true;	
pinchange triggered 

thread.sleep(trigering_events_wait_time);	com1.databits = 7;	com1.parity = parity.none;	com2.basestream.write(new byte[] { 0x01 }, 0, 1);	thread.sleep(trigering_events_wait_time);	com2.rtsenable = true;	thread.sleep(trigering_events_wait_time);	com1.databits = 8;	com1.parity = parity.none;	com2.basestream.write(new byte[] { 26 }, 0, 1);	
rxeof triggered 

com1.parity = parity.none;	com2.basestream.write(new byte[] { 26 }, 0, 1);	thread.sleep(trigering_events_wait_time);	com2.breakstate = true;	thread.sleep(trigering_events_wait_time);	bool threadfound = true;	stopwatch sw = stopwatch.startnew();	while (threadfound && sw.elapsedmilliseconds < max_time_wait) {	threadfound = false;	for (int i = 0; i < max_time_wait / iterationwaittime; ++i) {	
event counts pinchange rx error 

com1.parity = parity.none;	com2.basestream.write(new byte[] { 26 }, 0, 1);	thread.sleep(trigering_events_wait_time);	com2.breakstate = true;	thread.sleep(trigering_events_wait_time);	bool threadfound = true;	stopwatch sw = stopwatch.startnew();	while (threadfound && sw.elapsedmilliseconds < max_time_wait) {	threadfound = false;	for (int i = 0; i < max_time_wait / iterationwaittime; ++i) {	
waiting for pinchange event ms 

fail("err_191818ahied a thread is in pinchangedevent and receivedevent");	}	if (erroreventhandler.numeventshandled != numerrorevents) {	fail("err_198119hjaheid a thread is in pinchangedevent and errorevent");	}	++numpinchangedevents;	pinchangedeventhandler.resumehandleevent();	threadfound = true;	break;	}	
waiting for rx event ms 

fail("err_2288ajed a thread is in receivedevent and pinchangedevent");	}	if (erroreventhandler.numeventshandled != numerrorevents) {	fail("err_25158ajeiod a thread is in receivedevent and errorevent");	}	++numreceivedevents;	receivedeventhandler.resumehandleevent();	threadfound = true;	break;	}	
waiting for error event ms 

public void thread_in_pinchangedevent() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler pinchangedeventhandler = new pinchangedeventhandler(com1, false, true);	
verifying that if a thread is blocked in a pinchangedevent handler the port can still be closed 

public void thread_in_receivedevent() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	receivedeventhandler receivedeventhandler = new receivedeventhandler(com1, false, true);	
verifying that if a thread is blocked in a recevedevent handler the port can still be closed 

public void thread_in_errorevent() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	erroreventhandler erroreventhandler = new erroreventhandler(com1, false, true);	
verifying that if a thread is blocked in a errorevent handler the port can still be closed 

========================= corefx sample_628 =========================

string str = datareader.getattribute(-1);	}	catch (argumentoutofrangeexception exc) {	cerror.writeline(exc + " : " + exc.message);	return test_pass;	}	catch (exception e) {	cerror.writeline(e + " : " + e.message);	throw new ctestexception(ctestbase.test_fail, wrong_exception);	}	
no exception thrown 

string str = datareader.getattribute(datareader.attributecount + 1);	}	catch (argumentoutofrangeexception exc) {	cerror.writeline(exc + " : " + exc.message);	return test_pass;	}	catch (exception e) {	cerror.writeline(e + " : " + e.message);	throw new ctestexception(ctestbase.test_fail, wrong_exception);	}	
no exception thrown 

string str = datareader[-1];	}	catch (argumentoutofrangeexception exc) {	cerror.writeline(exc + " : " + exc.message);	return test_pass;	}	catch (exception e) {	cerror.writeline(e + " : " + e.message);	throw new ctestexception(ctestbase.test_fail, wrong_exception);	}	
no exception thrown 

string str = datareader[datareader.attributecount + 1];	}	catch (argumentoutofrangeexception exc) {	cerror.writeline(exc + " : " + exc.message);	return test_pass;	}	catch (exception e) {	cerror.writeline(e + " : " + e.message);	throw new ctestexception(ctestbase.test_fail, wrong_exception);	}	
no exception thrown 

public int movetonextattribute9() {	reloadsource(path.combine(testdata, "common", "bug424573.xml"));	datareader.read();	if (datareader.hasattributes) {	for (int i = 0; i < datareader.attributecount; i++) {	datareader.movetonextattribute();	if (datareader.nodetype == xmlnodetype.attribute && datareader.depth != 1) {	
unexpected attribute depth 

========================= corefx sample_12413 =========================

public void writetimeout_default_write_byte_int_int() {	
verifying default writetimeout with write byte buffer int offset int count 

public void writetimeout_default_write_char_int_int() {	
verifying default writetimeout with write char buffer int offset int count 

public void writetimeout_default_write_str() {	
verifying default writetimeout with write string 

public void writetimeout_infinite_write_byte_int_int() {	
verifying infinite writetimeout with write byte buffer int offset int count 

public void writetimeout_infinite_write_char_int_int() {	
verifying infinite writetimeout with write char buffer int offset int count 

public void writetimeout_infinite_write_str() {	
verifying infinite writetimeout with write string 

public void writetimeout_1_write_str_beforeopen() {	
verifying writetimeout before open with write string 

public void writetimeout_1_write_str_afteropen() {	
verifying writetimeout after open with write string 

public void writetimeout_int32minvalue() {	
verifying minvalue writetimeout 

public void writetimeout_neg2() {	
verifying writetimeout 

========================= corefx sample_679 =========================

private static int verify() {	lock (test.locker) {	if (test.s_field == null) {	
failed the finalizer hasn t executed 

========================= corefx sample_20 =========================

public void indent_28(xmlwriterutils utils) {	int i;	for (i = 0; i < 4; i++) {	xmlwritersettings wsettings = new xmlwritersettings();	wsettings.omitxmldeclaration = true;	wsettings.indent = true;	wsettings.conformancelevel = (i % 2) == 0 ? conformancelevel.auto : conformancelevel.document;	
conformancelevel 

public void indent_28(xmlwriterutils utils) {	int i;	for (i = 0; i < 4; i++) {	xmlwritersettings wsettings = new xmlwritersettings();	wsettings.omitxmldeclaration = true;	wsettings.indent = true;	wsettings.conformancelevel = (i % 2) == 0 ? conformancelevel.auto : conformancelevel.document;	using (xmlwriter w = utils.createwriter(wsettings)) {	if (i > 1) {	
writestartdocument called 

for (i = 0; i < 4; i++) {	xmlwritersettings wsettings = new xmlwritersettings();	wsettings.omitxmldeclaration = true;	wsettings.indent = true;	wsettings.conformancelevel = (i % 2) == 0 ? conformancelevel.auto : conformancelevel.document;	using (xmlwriter w = utils.createwriter(wsettings)) {	if (i > 1) {	w.writestartdocument();	}	else {	
writestartdocument not called 

public void indent_29(xmlwriterutils utils) {	int i;	for (i = 0; i < 2; i++) {	xmlwritersettings wsettings = new xmlwritersettings();	wsettings.omitxmldeclaration = false;	wsettings.indent = true;	wsettings.conformancelevel = (i % 2) == 0 ? conformancelevel.auto : conformancelevel.document;	
conformancelevel 

========================= corefx sample_12442 =========================

private exception throwunexpectedtoken(binxmltoken token) {	
unhandled token 

========================= corefx sample_12745 =========================

public int testnormalization11() {	reloadsource();	while (datareader.read()) {	if (datareader.hasvalue) {	if (datareader.value.indexof('\r') != -1) {	
xd found in node line col 

public int testnormalization14() {	string[] invalidxml = { "0", "8", "b", "c", "e", "1f", "fffe", "ffff" };	for (int i = 0; i < invalidxml.length; i++) {	string strxml = string.format("<root>&#x{0};</root>", invalidxml[i]);	reloadsourcestr(strxml);	try {	while (datareader.read()) ;	
accepted invalid character xml 

========================= corefx sample_12605 =========================

public int v1() {	string type = curvariation.params[0].tostring();	
test type 

public int v2() {	string type = curvariation.params[0].tostring();	
test type 

public int v15() {	reloadsource(new stringreader("<root><b/></root>"));	datareader.read();	if (isbinaryreader()) datareader.read();	try {	datareader.readtofollowing(null);	}	catch (argumentnullexception) {	
caught for single param 

if (isbinaryreader()) datareader.read();	try {	datareader.readtofollowing(null);	}	catch (argumentnullexception) {	}	try {	datareader.readtofollowing("b", null);	}	catch (argumentnullexception) {	
caught for single param 

========================= corefx sample_12427 =========================

private string geturistringandconfigurehandler(httpstestserver.options options, httpstestserver server, httpclienthandler handler) {	if (capability.arehostsfilenamesinstalled()) {	string hostname = (new uribuilder("https", options.servercertificate.getnameinfo(x509nametype.simplename, false), server.port)).tostring();	
testing using hostname 

========================= corefx sample_383 =========================

public static int mainmethod(string[] args) {	dynamic d = new derived();	int s = +d;	if (s == short.maxvalue) return 0;	
failed 

========================= corefx sample_103 =========================

private void checkparticlederivation(xmlschemacomplextype complextype) {	xmlschemacomplextype basetype = complextype.basexmlschematype as xmlschemacomplextype;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	if (!isvalidrestriction(complextype.contenttypeparticle, basetype.contenttypeparticle)) {	#if debug if (complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
invalid complextype content restriction 

private void checkparticlederivation(xmlschemacomplextype complextype) {	xmlschemacomplextype basetype = complextype.basexmlschematype as xmlschemacomplextype;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	if (!isvalidrestriction(complextype.contenttypeparticle, basetype.contenttypeparticle)) {	#if debug if (complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
base 

private void checkparticlederivation(xmlschemacomplextype complextype) {	xmlschemacomplextype basetype = complextype.basexmlschematype as xmlschemacomplextype;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	if (!isvalidrestriction(complextype.contenttypeparticle, basetype.contenttypeparticle)) {	#if debug if (complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
derived 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

foreach (xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

foreach (xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

foreach (xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

if (!contentvalidator.addelement(localelement.qualifiedname, localelement, localelement.minoccurs == decimal.zero)) {	sendvalidationevent(sr.sch_dupelement, localelement.qualifiedname.tostring(), localelement);	}	}	return contentvalidator;	}	else {	particlecontentvalidator contentvalidator = new particlecontentvalidator(complextype.contenttype);	#if debug if (diagnosticsswitches.xmlschema.traceverbose) {	string name = complextype.name != null ? complextype.name : string.empty;	
compilecomplexcontent 

========================= corefx sample_13060 =========================

schemaelementdecl currentelementdecl = _context.elementdecl;	string localname = _context.localname;	string namespaceuri = _context.namespace;	for (int i = _startidconstraint; i < _validationstack.length; i++) {	if (((validationstate)(_validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)_validationstack[i]).constr;	for (int j = 0; j < constraintstructures.length; ++j) {	if (constraintstructures[j].axisselector.movetostartelement(localname, namespaceuri)) {	
selector match 

schemaelementdecl currentelementdecl = _context.elementdecl;	string localname = _context.localname;	string namespaceuri = _context.namespace;	for (int i = _startidconstraint; i < _validationstack.length; i++) {	if (((validationstate)(_validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)_validationstack[i]).constr;	for (int j = 0; j < constraintstructures.length; ++j) {	if (constraintstructures[j].axisselector.movetostartelement(localname, namespaceuri)) {	
name uri 

continue;	}	constraintstruct[] constraintstructures = ((validationstate)_validationstack[i]).constr;	for (int j = 0; j < constraintstructures.length; ++j) {	if (constraintstructures[j].axisselector.movetostartelement(localname, namespaceuri)) {	constraintstructures[j].axisselector.pushks(_positioninfo.linenumber, _positioninfo.lineposition);	}	for (int k = 0; k < constraintstructures[j].axisfields.count; ++k) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[j].axisfields[k];	if (laxis.movetostartelement(localname, namespaceuri)) {	
element field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, xmlschemadatatype datatype) {	for (int ci = _startidconstraint; ci < _validationstack.length; ci++) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraintstructures.length; ++i) {	for (int j = 0; j < constraintstructures[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, xmlschemadatatype datatype) {	for (int ci = _startidconstraint; ci < _validationstack.length; ci++) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraintstructures.length; ++i) {	for (int j = 0; j < constraintstructures[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field filling value 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, xmlschemadatatype datatype) {	for (int ci = _startidconstraint; ci < _validationstack.length; ci++) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraintstructures.length; ++i) {	for (int j = 0; j < constraintstructures[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
name uri value 

string namespaceuri = _context.namespace;	for (int ci = _validationstack.length - 1; ci >= _startidconstraint; ci--) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
element field filling value 

string namespaceuri = _context.namespace;	for (int ci = _validationstack.length - 1; ci >= _startidconstraint; ci--) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
name uri value 

========================= corefx sample_13031 =========================

public async task proxy_connectthruproxy_success(uri server) {	string proxyserveruri = system.net.test.common.configuration.websockets.proxyserveruri;	if (string.isnullorempty(proxyserveruri)) {	
skipping test no proxy server defined 

public async task proxy_connectthruproxy_success(uri server) {	string proxyserveruri = system.net.test.common.configuration.websockets.proxyserveruri;	if (string.isnullorempty(proxyserveruri)) {	return;	}	
proxyserver proxyserveruri 

========================= corefx sample_3723 =========================

exception exception = null;	try {	c2.wait();	assert.true(false, string.format("runcontinuewithprecanceltests_state:  expected c2.wait to throw ae/tce"));	}	catch (exception ex) {	exception = ex;	}	ensureexceptionisaeoftce(exception, "runcontinuewithprecanceltests_state:  expected c2.wait to throw ae/tce");	mres.set();	
runcontinuewithprecanceltests state waiting for tasks to complete if we hang here something went wrong 

public static void runcontinuewithbase( taskcontinuationoptions options, action initran, func<task, task> continuationmaker, func<bool> ranvalue, bool taskisfuture) {	
continuewith after task finishes successfully 

public static void runcontinuewithbase( taskcontinuationoptions options, action initran, func<task, task> continuationmaker, func<bool> ranvalue, bool taskisfuture) {	{	bool expect = (options & taskcontinuationoptions.notonrantocompletion) == 0;	task task;	if (taskisfuture) task = task<string>.factory.startnew(() => "");	else task = task.factory.startnew(delegate { });	task.wait();	initran();	
init action ran 

bool expect = (options & taskcontinuationoptions.notonrantocompletion) == 0;	task task;	if (taskisfuture) task = task<string>.factory.startnew(() => "");	else task = task.factory.startnew(delegate { });	task.wait();	initran();	bool cancel = false;	task cont = continuationmaker(task);	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	
finished wait 

task.wait();	initran();	bool cancel = false;	task cont = continuationmaker(task);	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	if (expect != ranvalue() || expect == cancel) {	assert.true(false, string.format("runcontinuewithbase: >> failed: continuation didn't run or get canceled when expected: ran = {0}, cancel = {1}", ranvalue(), cancel));	}	}	
continuewith before task finishes successfully 

public static void runcontinuewithbase_exceptioncases( taskcontinuationoptions options, action initran, func<task, task> continuationmaker, func<bool> ranvalue, bool taskisfuture) {	
continuewith after task finishes exceptionally 

public static void runcontinuewithbase_exceptioncases( taskcontinuationoptions options, action initran, func<task, task> continuationmaker, func<bool> ranvalue, bool taskisfuture) {	{	bool expect = (options & taskcontinuationoptions.notonfaulted) == 0;	task task;	if (taskisfuture) task = task<string>.factory.startnew(delegate { throw new exception("boom"); });	else task = task.factory.startnew(delegate { throw new exception("boom"); });	try { task.wait(); }	catch (aggregateexception) { /*swallow(ouch)*/ }	
caught 

task task;	if (taskisfuture) task = task<string>.factory.startnew(delegate { throw new exception("boom"); });	else task = task.factory.startnew(delegate { throw new exception("boom"); });	try { task.wait(); }	catch (aggregateexception) { /*swallow(ouch)*/ }	initran();	bool cancel = false;	task cont = continuationmaker(task);	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	
finished wait 

catch (aggregateexception) { /*swallow(ouch)*/ }	initran();	bool cancel = false;	task cont = continuationmaker(task);	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	if (expect != ranvalue() || expect == cancel) {	assert.true(false, string.format("runcontinuewithbase: >> failed: continuation didn't run or get canceled when expected: ran = {0}, cancel = {1}", ranvalue(), cancel));	}	}	
continuewith before task finishes exceptionally 

task cont = continuationmaker(task);	mre.set();	try { task.wait(); }	catch (aggregateexception) { /*swallow(ouch)*/ }	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	if (expect != ranvalue() || expect == cancel) {	assert.true(false, string.format("runcontinuewithbase: >> failed: continuation didn't run or get canceled when expected: ran = {0}, cancel = {1}", ranvalue(), cancel));	}	}	
continuewith after task becomes aborted 

cancellationmre.set();	initran();	bool cancel = false;	task cont = continuationmaker(task);	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	if (expect != ranvalue() || expect == cancel) {	assert.true(false, string.format("runcontinuewithbase: >> failed: continuation didn't run or get canceled when expected: ran = {0}, cancel = {1}", ranvalue, cancel));	}	}	
continuewith before task becomes aborted 

========================= corefx sample_4013 =========================

if (_inprepare) {	_inprepare = false;	isdirty = true;	_exectype = exectype.preparepending;	}	if (null != ds) {	try {	ds.close();	}	catch (exception exclose) {	
received this exception from sqldatareader close while in another catch block 

if (adp.iscatchableexceptiontype(e)) {	if (_inprepare) {	_inprepare = false;	isdirty = true;	_exectype = exectype.preparepending;	}	try {	ds.close();	}	catch (exception exclose) {	
received this exception from sqldatareader close while in another catch block 

========================= corefx sample_11217 =========================

if (clienttotalbytesreceived == 1 && clientchunks == 0) {	clientauxrecorddetected = true;	}	if (client.stream.cipheralgorithm == cipheralgorithmtype.none || client.stream.cipheralgorithm == cipheralgorithmtype.null || client.stream.cipheralgorithm == cipheralgorithmtype.rc4) {	clientauxrecorddetectedinconclusive = true;	}	return task.fromresult<string>(null);	});	await task.whenall(tasks).timeoutafter(testconfiguration.passingtesttimeoutmilliseconds);	if (serverauxrecorddetectedinconclusive || clientauxrecorddetectedinconclusive) {	
test inconclusive the operating system preferred a non cbc or null cipher 

========================= corefx sample_8115 =========================

program = "uname";	workingdirectory = "/does-not-exist";	}	if (isprograminstalled(program)) {	var psi = new processstartinfo {	filename = program, useshellexecute = false, workingdirectory = workingdirectory };	win32exception e = assert.throws<win32exception>(() => process.start(psi));	assert.notequal(0, e.nativeerrorcode);	}	else {	
program program is not installed on this machine 

timespan allowedwindow = timespan.fromseconds(3);	for (int i = 0; i < 2; i++) {	process p = createprocessportable(remotelyinvokable.readline);	assert.throws<invalidoperationexception>(() => p.starttime);	datetime teststarttime = datetime.now;	p.startinfo.redirectstandardinput = true;	p.start();	assert.equal(p.starttime, p.starttime);	datetime processstarttime = p.starttime;	using (streamwriter writer = p.standardinput) {	
start 

assert.equal(expectedargv, handle.process.standardoutput.readtoend());	}	}	[fact]	public void standardinput_getnotredirected_throwsinvalidoperationexception() {	var process = new process();	assert.throws<invalidoperationexception>(() => process.standardinput);	}	public void testdiagnosticswithconsolewriteline() {	foreach (var p in process.getprocesses().orderby(p => p.id)) {	
threads 

========================= corefx sample_3915 =========================

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
networkinterface 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
name 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
description 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
id 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
isreceiveonly 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
type 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
status 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
speed 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	assert.inrange(nic.speed, -1, long.maxvalue);	
supportsmulticast 

public void basictest_accessinstanceproperties_noexceptions() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	assert.inrange(nic.speed, -1, long.maxvalue);	
getphysicaladdress 

public void basictest_accessinstanceproperties_noexceptions_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
networkinterface 

public void basictest_accessinstanceproperties_noexceptions_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
name 

public void basictest_accessinstanceproperties_noexceptions_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	
description 

public void basictest_accessinstanceproperties_noexceptions_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	
id 

public void basictest_accessinstanceproperties_noexceptions_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	
type 

public void basictest_accessinstanceproperties_noexceptions_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	
status 

public void basictest_accessinstanceproperties_noexceptions_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	try {	
speed 

assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	try {	assert.inrange(nic.speed, -1, long.maxvalue);	}	catch (platformnotsupportedexception pnse) {	_log.writeline(pnse.tostring());	}	
supportsmulticast 

assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	try {	assert.inrange(nic.speed, -1, long.maxvalue);	}	catch (platformnotsupportedexception pnse) {	_log.writeline(pnse.tostring());	}	
getphysicaladdress 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
networkinterface 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
name 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	
description 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	
id 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	
type 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	
status 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	
speed 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	assert.inrange(nic.speed, 0, long.maxvalue);	
supportsmulticast 

public void basictest_accessinstanceproperties_noexceptions_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	string description = nic.description;	assert.false(string.isnullorempty(description), "networkinterface.description should not be null or empty.");	string id = nic.id;	assert.false(string.isnullorempty(id), "networkinterface.id should not be null or empty.");	assert.throws<platformnotsupportedexception>(() => nic.isreceiveonly);	assert.inrange(nic.speed, 0, long.maxvalue);	
getphysicaladdress 

public void basictest_staticloopbackindex_matchesloopbacknetworkinterface() {	assert.true(capability.ipv4support());	
loopback index 

public void basictest_staticloopbackindex_exceptionifv4notsupported() {	assert.true(capability.ipv4support());	
loopback index 

public void basictest_staticipv6loopbackindex_matchesloopbacknetworkinterface() {	assert.true(capability.ipv6support());	
loopback index 

public void basictest_staticipv6loopbackindex_exceptionifv6notsupported() {	assert.true(capability.ipv6support());	
loopback index 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
stats for 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
bytesreceived 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
bytessent 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingpacketsdiscarded 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingpacketswitherrors 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingunknownprotocolpackets 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
nonunicastpacketsreceived 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
nonunicastpacketssent 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
outgoingpacketsdiscarded 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
outgoingpacketswitherrors 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
outputqueuelength 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
unicastpacketsreceived 

public void basictest_getipinterfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
unicastpacketssent 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
stats for 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
bytesreceived 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
bytessent 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingpacketsdiscarded 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingpacketswitherrors 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	
nonunicastpacketsreceived 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
outgoingpacketsdiscarded 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
outgoingpacketswitherrors 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
outputqueuelength 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
unicastpacketsreceived 

public void basictest_getipinterfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
unicastpacketssent 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
stats for 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
bytesreceived 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
bytessent 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingpacketsdiscarded 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingpacketswitherrors 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
incomingunknownprotocolpackets 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
nonunicastpacketsreceived 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	
nonunicastpacketssent 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
outgoingpacketswitherrors 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
outputqueuelength 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
unicastpacketsreceived 

public void basictest_getipinterfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfacestatistics stats = nic.getipstatistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
unicastpacketssent 

========================= corefx sample_13377 =========================

private static void appendil(methodinfo method, stringwriter sw, itypefactory typefactory) {	ilreader reader = ilreaderfactory.create(method);	exceptioninfo[] exceptions = reader.ilprovider.getexceptioninfos();	var writer = new richilstringtotextwriter(sw, exceptions);	
method 

private static void appendil(methodinfo method, stringwriter sw, itypefactory typefactory) {	ilreader reader = ilreaderfactory.create(method);	exceptioninfo[] exceptions = reader.ilprovider.getexceptioninfos();	var writer = new richilstringtotextwriter(sw, exceptions);	sw.writeline("{");	
maxstack 

private static void appendil(methodinfo method, stringwriter sw, itypefactory typefactory) {	ilreader reader = ilreaderfactory.create(method);	exceptioninfo[] exceptions = reader.ilprovider.getexceptioninfos();	var writer = new richilstringtotextwriter(sw, exceptions);	sw.writeline("{");	byte[] sig = reader.ilprovider.getlocalsignature();	var lsp = new localssignatureparser(reader.resolver, typefactory);	var locals = default(type[]);	if (lsp.parse(sig, out locals) && locals.length > 0) {	
locals init 

========================= corefx sample_2649 =========================

public static datacolumn getdatacolumn(datacolumnmappingcollection columnmappings, string sourcecolumn, type datatype, datatable datatable, missingmappingaction mappingaction, missingschemaaction schemaaction) {	if (null != columnmappings) {	int index = columnmappings.indexof(sourcecolumn);	if (-1 != index) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
mapping match on sourcecolumn 

#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return columnmappings._items[index].getdatacolumnbyschemaaction(datatable, datatype, schemaaction);	}	}	if (string.isnullorempty(sourcecolumn)) {	throw adp.invalidsourcecolumn(nameof(sourcecolumn));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	
mapping passthrough of sourcecolumn 

}	}	if (string.isnullorempty(sourcecolumn)) {	throw adp.invalidsourcecolumn(nameof(sourcecolumn));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return datacolumnmapping.getdatacolumnbyschemaaction(sourcecolumn, sourcecolumn, datatable, datatype, schemaaction);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
mapping filter of sourcecolumn 

throw adp.invalidsourcecolumn(nameof(sourcecolumn));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return datacolumnmapping.getdatacolumnbyschemaaction(sourcecolumn, sourcecolumn, datatable, datatype, schemaaction);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingmappingaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
mapping error on sourcecolumn 

public static datacolumnmapping getcolumnmappingbyschemaaction(datacolumnmappingcollection columnmappings, string sourcecolumn, missingmappingaction mappingaction) {	if (null != columnmappings) {	int index = columnmappings.indexof(sourcecolumn);	if (-1 != index) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
mapping match on sourcecolumn 

#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return columnmappings._items[index];	}	}	if (string.isnullorempty(sourcecolumn)) {	throw adp.invalidsourcecolumn(nameof(sourcecolumn));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	
mapping passthrough of sourcecolumn 

}	}	if (string.isnullorempty(sourcecolumn)) {	throw adp.invalidsourcecolumn(nameof(sourcecolumn));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datacolumnmapping(sourcecolumn, sourcecolumn);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
mapping filter of sourcecolumn 

throw adp.invalidsourcecolumn(nameof(sourcecolumn));	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datacolumnmapping(sourcecolumn, sourcecolumn);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingmappingaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
mapping error on sourcecolumn 

========================= corefx sample_3574 =========================

public int getparam1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	
getparam thread iteration added value retrieved value 

public int getparam1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	if (retobj.tostring() != "test1") {	
error 

public int getparam2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	string expected = "test" + ((object[])args)[0];	
getparam thread iteration added value retrieved value 

public int getparam2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getparam(((object[])args)[1].tostring(), szempty);	string expected = "test" + ((object[])args)[0];	if (retobj.tostring() != expected) {	
error 

public int getextnobject1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	
getextensionobject thread iteration value returned 

public int getextnobject1(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	if (((myobject)retobj).myvalue() != 1) {	
error set and retrieved value appear to be different 

public int getextnobject2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	
getextensionobject thread iteration value returned 

public int getextnobject2(object args) {	object retobj;	for (int i = 1; i <= 100; i++) {	retobj = xsltarg1.getextensionobject(((object[])args)[1].tostring());	if (((myobject)retobj).myvalue() != (int)((object[])args)[0]) {	
error set and retrieved value appear to be different 

xpathdocument xd = new xpathdocument(xrdata, xmlspace.preserve);	xrdata.dispose();	xslcompiledtransform xslt = new xslcompiledtransform();	xmlreadersettings xrs = new xmlreadersettings();	#pragma warning disable 0618 xrs.prohibitdtd = false;	#pragma warning restore 0618 xmlreader xrtemp = xmlreader.create(_strxslfile);	xslt.load(xrtemp);	stringwriter sw = new stringwriter();	for (int i = 1; i <= 100; i++) {	xslt.transform(xd, xsltarg1, sw);	
sharedargumentlist thread iteration done with transform 

========================= corefx sample_12644 =========================

private void generatelinepragmaend(codelinepragma e) {	output.writeline();	
line default 

private void generatelinepragmaend(codelinepragma e) {	output.writeline();	
line hidden 

outputparameters(e.parameters);	output.write(']');	}	else {	outputidentifier(e.name);	}	outputstartingbrace();	indent++;	if (e.hasget) {	if (iscurrentinterface || (e.attributes & memberattributes.scopemask) == memberattributes.abstract) {	
get 

private void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	
output write 

private void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	
output writeline sr autogen comment 

private void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.autogen_comment_line3);	output.writeline(environment.version.tostring());	
output write 

private void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.autogen_comment_line3);	output.writeline(environment.version.tostring());	
output writeline sr autogen comment 

private void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.autogen_comment_line3);	output.writeline(environment.version.tostring());	
output writeline sr autogen comment 

private void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.autogen_comment_line3);	output.writeline(environment.version.tostring());	
output writeline 

private void generatecoderegiondirective(coderegiondirective regiondirective) {	if (regiondirective.regionmode == coderegionmode.start) {	output.write("#region ");	output.writeline(regiondirective.regiontext);	}	else if (regiondirective.regionmode == coderegionmode.end) {	
endregion 

========================= corefx sample_9412 =========================

private void enabletimer(float pollingintervalinseconds) {	debug.assert(monitor.isentered(this));	if (pollingintervalinseconds <= 0) {	disposetimer();	_pollingintervalinmilliseconds = 0;	}	else if (_pollingintervalinmilliseconds == 0 || pollingintervalinseconds * 1000 < _pollingintervalinmilliseconds) {	
polling interval changed at mm ss ffffff 

private void ontimer(object state) {	
timer fired at mm ss ffffff 

========================= corefx sample_3109 =========================

public static void log(textwriter log, string prefix, object instance) {	if (log == null) {	return;	}	if (instance == null) {	
null 

if (objecttype.isenum || instance is bool || instance is string || instance is int || instance is uint || instance is byte || instance is sbyte || instance is short || instance is ushort || instance is long || instance is ulong || instance is double || instance is float || instance is version) {	serializedwritelinetolog(log, string.format("{0}: {1}", prefix, instance));	return;	}	if (objecttype.isgenerictype || (objecttype.basetype != null && objecttype.basetype.isgenerictype)) {	int index = 0;	foreach (object o in (instance as system.collections.ienumerable)) {	log(log, string.format("{0}[{1}]", prefix, index++), o);	}	if (index == 0) {	
empty 

========================= corefx sample_10813 =========================

int addmodcount = 0;	berval bervalueptr = null;	intptr searchattributes = intptr.zero;	int attributecount = 0;	int error = 0;	if (!_connected) {	connect();	_connected = true;	}	if (autobind && (!_bounded || _needrebind) && ((ldapdirectoryidentifier)directory).connectionless != true) {	
rebind occurs 

========================= corefx sample_10710 =========================

}	wsettings.closeoutput = closeoutput;	xmlwriter w = writerhelper.create("writer.out", wsettings, overrideasync: true, async: utils.async);	w.writestartelement("root");	w.writeendelement();	w.dispose();	stream fs = null;	try {	fs = filepathutil.getstream("writer.out");/*new filestream("writer.out", filemode.open, fileaccess.readwrite);*/ }	catch (exception e) {	
exception 

}	wsettings.closeoutput = closeoutput;	xmlwriter w = writerhelper.create("writer.out", wsettings, overrideasync: true, async: utils.async);	w.writestartelement("root");	w.writeendelement();	w.dispose();	stream fs = null;	try {	fs = filepathutil.getstream("writer.out");/*new filestream("writer.out", filemode.open, fileaccess.readwrite);*/ }	catch (exception e) {	
uri stream is not closed by writer 

case "textwriter": streamwriter tw = new streamwriter(writerstream, wsettings.encoding);	w = writerhelper.create(tw, wsettings, overrideasync: true, async: utils.async);	break;	}	bool bresult = false;	try {	w.writestartdocument();	w.writestartdocument();	}	catch (exception e) {	
exception 

========================= corefx sample_12452 =========================

public void readwithoutopen() {	using (serialport com = new serialport()) {	
verifying read method throws exception without a call to open 

public void readafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read method throws exception with a failed call to open 

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void parityerroronlastbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(15);	byte[] bytestowrite = new byte[numrndbytesparity];	char[] expectedchars = new char[numrndbytesparity];	
verifying default parityreplace byte with a parity errro on the last byte 

byte randbyte = (byte)rndgen.next(0, 256);	bytestowrite[i] = randbyte;	}	char[] expectedchars = encoding.getchars(bytestowrite, 0, bytestowrite.length);	for (int i = 0; i < numnewlines; i++) {	int newlineindex;	newlineindex = rndgen.next(0, numbytesread);	bytestowrite[newlineindex] = (byte)'\n';	expectedchars[newlineindex] = (char)'\n';	}	
verifying bytestoread with a buffer of 

========================= corefx sample_669 =========================

public bool errorevent_txfull() {	serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname);	serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname);	erroreventhandler erreventhandler = new erroreventhandler(com1);	int elapsedtime;	
verifying txfull event 

com2.open();	com1.errorevent += new serialerroreventhandler(erreventhandler.handleevent);	com1.basestream.beginwrite(new byte[32767], 0, 32767, null, null);	elapsedtime = 0;	while(1 > erreventhandler.numeventshandled && elapsedtime < max_time_wait) {	system.threading.thread.sleep(iteration_time_wait);	elapsedtime += iteration_time_wait;	}	retvalue &= erreventhandler.validate(serialerrors.txfull, com1.receivedbytesthreshold, 0);	if(!retvalue) {	
err verifying txfull event failed 

public void errorevent_rxover() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	erroreventhandler erreventhandler = new erroreventhandler(com1);	
verifying rxover event 

public bool errorevent_overrun() {	serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname);	serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname);	erroreventhandler erreventhandler = new erroreventhandler(com1);	int elapsedtime;	
verifying overrun event 

com2.open();	com1.errorevent += new serialerroreventhandler(erreventhandler.handleevent);	com2.basestream.write(new byte[32767], 0, 32767);	elapsedtime = 0;	while(1 > erreventhandler.numeventshandled && elapsedtime < max_time_wait) {	system.threading.thread.sleep(iteration_time_wait);	elapsedtime += iteration_time_wait;	}	retvalue &= erreventhandler.validate(serialerrors.overrun, com1.receivedbytesthreshold, 0);	if(!retvalue) {	
err verifying overrun event failed 

public void errorevent_rxparity() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	erroreventhandler erreventhandler = new erroreventhandler(com1);	
verifying rxparity event 

public void errorevent_rxparity() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	erroreventhandler erreventhandler = new erroreventhandler(com1);	com1.databits = 7;	com1.parity = parity.mark;	com1.open();	com2.open();	com1.errorreceived += erreventhandler.handleevent;	for (int i = 0; i < num_trys; i++) {	
verifying rxparity event try 

public void errorevent_frame() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	erroreventhandler erreventhandler = new erroreventhandler(com1);	
verifying frame event 

public void errorevent_frame() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	erroreventhandler erreventhandler = new erroreventhandler(com1);	com1.databits = 7;	com1.open();	com2.open();	com1.errorreceived += erreventhandler.handleevent;	var frameerrorbytes = new byte[] { 0x01 };	for (int i = 0; i < num_trys; i++) {	
verifying frame event try 

========================= corefx sample_638 =========================

public static unsafe void fillnativebytes() {	int length = 50;	byte* ptr = null;	try {	ptr = (byte*)marshal.allochglobal((intptr)50);	}	catch (outofmemoryexception) {	
span fill test nameof fillnativebytes skipped due to nameof outofmemoryexception 

========================= corefx sample_7565 =========================

public principalsearchresult<principal> findall() {	
principalsearcher entering findall 

public principal findone() {	
principalsearcher entering findone 

public principal findone() {	checkdisposed();	using (principalsearchresult<principal> fr = findall(true)) {	findresultenumerator<principal> fre = (findresultenumerator<principal>)fr.getenumerator();	if (fre.movenext()) {	
principalsearcher findone found a principal 

public principal findone() {	checkdisposed();	using (principalsearchresult<principal> fr = findall(true)) {	findresultenumerator<principal> fre = (findresultenumerator<principal>)fr.getenumerator();	if (fre.movenext()) {	return (principal)fre.current;	}	else {	
principalsearcher findone found no principal 

public object getunderlyingsearcher() {	
principalsearcher entering getunderlyingsearcher 

public type getunderlyingsearchertype() {	
principalsearcher entering getunderlyingsearchertype 

public virtual void dispose() {	if (!_disposed) {	
principalsearcher dispose disposing 

public virtual void dispose() {	if (!_disposed) {	if ((this.underlyingsearcher != null) && (this.underlyingsearcher is idisposable)) {	
principalsearcher dispose disposing underlying searcher of type 

private principalsearchresult<principal> findall(bool returnone) {	globaldebug.writelineif(globaldebug.info, "principalsearcher", "entering findall, returnone=" + returnone.tostring());	if (_qbefilter == null) throw new invalidoperationexception(sr.principalsearchermustsetfilter);	if (!_qbefilter.unpersisted) throw new invalidoperationexception(sr.principalsearcherpersistedprincipal);	if (hasreferentialpropertiesset()) throw new invalidoperationexception(sr.principalsearchernonreferentialprops);	
principalsearcher findall qbefilter is non null and passes 

private void setdefaultpagesizeforcontext() {	_pagesize = 0;	if (_qbefilter != null) {	
principalsearcher setdefaultpagesizeforcontext type is 

private bool hasreferentialpropertiesset() {	if (_qbefilter == null) return false;	debug.assert(_qbefilter.unpersisted == true);	type t = _qbefilter.gettype();	
principalsearcher hasreferentialpropertiesset using type 

private bool hasreferentialpropertiesset() {	if (_qbefilter == null) return false;	debug.assert(_qbefilter.unpersisted == true);	type t = _qbefilter.gettype();	arraylist referentialproperties = (arraylist)referentialproperties.properties[t];	if (referentialproperties != null) {	foreach (string propertyname in referentialproperties) {	if (_qbefilter.getchangestatusforproperty(propertyname) == true) {	
principalsearcher hasreferentialpropertiesset found ref property 

private void checkdisposed() {	if (_disposed) {	
principalsearcher checkdisposed accessing disposed object 

========================= corefx sample_9025 =========================

private static bool comparemessages(resourcemanager rm, string id, string actualerror, params string[] args) {	if (null == rm) return false;	if (string.isnullorempty(id) || string.isnullorempty(actualerror)) {	
empty error id or actual message 

========================= corefx sample_108 =========================

private void loadcertificatecollection(list<byte[]> certificatestoload) {	_certificates.clear();	debug.assert(_certificates.count == 0);	
authenticableprincipal loadcertificatecollection loading certs 

private void loadcertificatecollection(list<byte[]> certificatestoload) {	_certificates.clear();	debug.assert(_certificates.count == 0);	foreach (byte[] rawcert in certificatestoload) {	try {	_certificates.import(rawcert);	}	catch (system.security.cryptography.cryptographicexception) {	
authenticableprincipal loadcertificatecollection skipped bad cert 

private void refreshoriginalthumbprintlist() {	
authenticableprincipal refreshoriginalthumbprintlist resetting thumbprints 

private bool hascertificatecollectionchanged() {	if (_certificates.count != _certificateoriginalthumbprints.count) {	
authenticableprincipal hascertificatecollectionchanged original count current count 

private bool hascertificatecollectionchanged() {	if (_certificates.count != _certificateoriginalthumbprints.count) {	return true;	}	list<string> remainingoriginalthumbprints = new list<string>(_certificateoriginalthumbprints);	foreach (x509certificate2 certificate in _certificates) {	string thumbprint = certificate.thumbprint;	if (!remainingoriginalthumbprints.contains(thumbprint)) {	
authenticableprincipal refreshoriginalthumbprintlist found inserted cert 

========================= corefx sample_9011 =========================

public static string extensiontypeconverter(string attributename, type type, object value, matchtype mt) {	stringbuilder ldapfilter = new stringbuilder("(");	string ldapvalue;	if (typeof(boolean) == type) {	ldapvalue = ((bool)value ? "true" : "false");	}	else if (type is icollection) {	stringbuilder collectionfilter = new stringbuilder();	icollection collection = (icollection)value;	foreach (object o in collection) {	
adstorectx extensiontypeconverter collection filter type 

protected static string extensioncacheconverter(filterbase filter, string suggestedadproperty) {	
adstorectx extensioncacheconverter 

protected static string extensioncacheconverter(filterbase filter, string suggestedadproperty) {	stringbuilder query = new stringbuilder();	if (filter.value != null) {	extensioncache ec = (extensioncache)filter.value;	foreach (keyvaluepair<string, extensioncachevalue> kvp in ec.properties) {	type type = kvp.value.type == null ? kvp.value.value.gettype() : kvp.value.type;	
adstorectx extensioncacheconverter filter type 

protected static string extensioncacheconverter(filterbase filter, string suggestedadproperty) {	stringbuilder query = new stringbuilder();	if (filter.value != null) {	extensioncache ec = (extensioncache)filter.value;	foreach (keyvaluepair<string, extensioncachevalue> kvp in ec.properties) {	type type = kvp.value.type == null ? kvp.value.value.gettype() : kvp.value.type;	
adstorectx extensioncacheconverter match type 

protected static string extensioncacheconverter(filterbase filter, string suggestedadproperty) {	stringbuilder query = new stringbuilder();	if (filter.value != null) {	extensioncache ec = (extensioncache)filter.value;	foreach (keyvaluepair<string, extensioncachevalue> kvp in ec.properties) {	type type = kvp.value.type == null ? kvp.value.value.gettype() : kvp.value.type;	if (kvp.value.value is icollection) {	
adstorectx extensioncacheconverter encountered collection 

protected static string extensioncacheconverter(filterbase filter, string suggestedadproperty) {	stringbuilder query = new stringbuilder();	if (filter.value != null) {	extensioncache ec = (extensioncache)filter.value;	foreach (keyvaluepair<string, extensioncachevalue> kvp in ec.properties) {	type type = kvp.value.type == null ? kvp.value.value.gettype() : kvp.value.type;	if (kvp.value.value is icollection) {	icollection collection = (icollection)kvp.value.value;	foreach (object o in collection) {	
adstorectx extensioncacheconverter collection filter type 

icollection collection = (icollection)kvp.value.value;	foreach (object o in collection) {	query.append(extensiontypeconverter(kvp.key, o.gettype(), o, kvp.value.matchtype));	}	}	else {	query.append(extensiontypeconverter(kvp.key, type, kvp.value.value, kvp.value.matchtype));	}	}	}	
adstorectx extensioncacheconverter complete built filter 

========================= corefx sample_9040 =========================

public bool checkcanreadbinarycontent() {	byte[] buffer = new byte[1];	if (!datareader.canreadbinarycontent) {	try {	int nbytes = 0;	switch ((int)new random().next(4)) {	
selecting rcabh 

public bool checkcanreadbinarycontent() {	byte[] buffer = new byte[1];	if (!datareader.canreadbinarycontent) {	try {	int nbytes = 0;	switch ((int)new random().next(4)) {	nbytes = datareader.readcontentasbinhex(buffer, 0, 1);	break;	
selecting recabh 

public bool checkcanreadbinarycontent() {	byte[] buffer = new byte[1];	if (!datareader.canreadbinarycontent) {	try {	int nbytes = 0;	switch ((int)new random().next(4)) {	nbytes = datareader.readcontentasbinhex(buffer, 0, 1);	break;	nbytes = datareader.readelementcontentasbinhex(buffer, 0, 1);	break;	
selecting 

if (!datareader.canreadbinarycontent) {	try {	int nbytes = 0;	switch ((int)new random().next(4)) {	nbytes = datareader.readcontentasbinhex(buffer, 0, 1);	break;	nbytes = datareader.readelementcontentasbinhex(buffer, 0, 1);	break;	nbytes = datareader.readcontentasbase64(buffer, 0, 1);	break;	
selecting 

public void dumpstat() {	if (datareader == null) {	
reader not initialized 

public void dumpstat() {	if (datareader == null) {	return;	}	
dumping datareader status 

public void dumpstat() {	if (datareader == null) {	return;	}	
status 

datareader.positiononelement("entity5");	datareader.read();	strexpbaseuri = "environment.currentdirectory" + "\\" + gettestfilename(ereader_type.generic);	if (isbinaryreader()) strexpbaseuri = strexpbaseuri + ".bin";	uri expbaseuri = new uri("file: bpassed = cerror.equals(datareader.baseuri, expbaseuri.tostring(), "before resolveentity");	if (isxmltextreader() || isxmlnodereader() || isxmlvalidatingreader()) {	bpassed = datareader.verifynode(xmlnodetype.entityreference, st_gen_ent_name, string.empty);	if (datareader.canresolveentity) {	datareader.resolveentity();	datareader.read();	
here 

uri uri = new uri("file:" + filename);	reloadsource(filename);	datareader.positiononelement("root");	datareader.read();	bpassed = cerror.equals(datareader.baseuri.contains("common/bug_62426.xml"), true, "before resolveentity");	if (isxmltextreader() || isxmlnodereader() || isxmlvalidatingreader()) {	bpassed = datareader.verifynode(xmlnodetype.entityreference, "bug62426", string.empty);	if (datareader.canresolveentity) {	datareader.resolveentity();	datareader.read();	
here 

if (isxsltreader() || isxmlnodereader() || isxmlnodereaderdatadoc() || iscorereader() || isxpathnavigatorreader()) return test_skipped;	string filename = path.combine(testdata, "common", "bug94358.xml");	if (isbinaryreader()) filename = path.getfilename(filename) + ".bin";	uri urifile = new uri("file:" + filename);	reloadsource(filename);	while (datareader.read()) {	if (datareader.readstate == readstate.interactive && datareader.localname == "x") {	break;	}	}	
base uri of element x is 

========================= corefx sample_12418 =========================

public void writeattributes_3(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	xmlreader xr = null;	try {	w.writestartelement("root");	w.writeattributes(xr, false);	}	catch (argumentnullexception e) {	
exception 

xmlreader xr = null;	try {	w.writestartelement("root");	w.writeattributes(xr, false);	}	catch (argumentnullexception e) {	cerror.compare(w.writestate, writestate.element, "writestate should be element");	return;	}	}	
did not throw exception 

public void writeattributes_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	using (xmlreader xr = createreader("xmlreader.xml")) {	while (xr.read()) {	if (xr.localname == "attributesgeneric") {	do { xr.read(); } while (xr.localname != "node");	break;	}	}	if (xr.nodetype != xmlnodetype.element) {	
reader not positioned element 

using (xmlwriter w = utils.createwriter()) {	using (xmlreader xr = createreader("xmlreader.xml")) {	while (xr.read()) {	if (xr.localname == "attributesgeneric") {	do { xr.read(); } while (xr.localname != "node");	xr.movetoattribute(1);	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader not positioned on attribute 

while (xr.read()) {	if (xr.localname == "attributesgeneric") {	do { xr.read(); } while (xr.localname != "node");	xr.movetonextattribute();	xr.movetonextattribute();	xr.movetonextattribute();	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader not positioned on attribute 

public void writeattributes_8(xmlwriterutils utils) {	if (isxpathdatamodelreader()) {	
does not support xmldecl node 

public void writeattributes_8(xmlwriterutils utils) {	if (isxpathdatamodelreader()) {	return;	}	using (xmlwriter w = utils.createwriter()) {	using (xmlreader xr = createreader("simple.xml")) {	xr.read();	if (xr.nodetype != xmlnodetype.xmldeclaration) {	
reader not positioned on xmldeclaration 

public void writeattributes_9(xmlwriterutils utils, string tokentype) {	string strxml = "";	switch (tokentype) {	case "documenttype": if (isxpathdatamodelreader()) {	
does not support documenttype node 

public void writeattributes_9(xmlwriterutils utils, string tokentype) {	string strxml = "";	switch (tokentype) {	case "documenttype": if (isxpathdatamodelreader()) {	return;	}	strxml = "<!doctype root[]><root/>";	break;	case "cdata": if (isxpathdatamodelreader()) {	
does not support cdata node 

}	strxml = "<root><![cdata[test]]></root>";	break;	case "text": strxml = "<root>test</root>";	break;	case "processinginstruction": strxml = "<root><?pi test?></root>";	break;	case "comment": strxml = "<root><!-- comment --></root>";	break;	case "entityreference": if (!readersupportsentityref()) {	
does not support entityref node 

case "comment": strxml = "<root><!-- comment --></root>";	break;	case "entityreference": if (!readersupportsentityref()) {	return;	}	strxml = "<!doctype root[<!entity e \"test entity\"> ]><root>&e;</root>";	break;	case "significantwhitespace": strxml = "<root xml:space=\"preserve\">			 </root>";	break;	case "whitespace": if (readerstripswhitespace()) {	
strips whitespace nodes by default 

}	strxml = "<root>			 </root>";	break;	}	xmlreader xr;	xr = createreader(new stringreader(strxml));	do { xr.read(); }	while ((xr.nodetype.tostring() != tokentype) && (xr.readstate != readstate.endoffile));	if (xr.readstate == readstate.endoffile || xr.nodetype.tostring() != tokentype) {	xr.dispose();	
reader not positioned on correct node 

}	strxml = "<root>			 </root>";	break;	}	xmlreader xr;	xr = createreader(new stringreader(strxml));	do { xr.read(); }	while ((xr.nodetype.tostring() != tokentype) && (xr.readstate != readstate.endoffile));	if (xr.readstate == readstate.endoffile || xr.nodetype.tostring() != tokentype) {	xr.dispose();	
readstate 

}	strxml = "<root>			 </root>";	break;	}	xmlreader xr;	xr = createreader(new stringreader(strxml));	do { xr.read(); }	while ((xr.nodetype.tostring() != tokentype) && (xr.readstate != readstate.endoffile));	if (xr.readstate == readstate.endoffile || xr.nodetype.tostring() != tokentype) {	xr.dispose();	
nodetype 

}	catch (xmlexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, (tokentype == "documenttype") ? writestate.start : writestate.element, "writestate should be element");	return;	}	finally {	xr.dispose();	}	}	
did not throw exception 

public void writeattributes_12(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	using (xmlreader xr = createreader("xmlreader.xml")) {	while (xr.read()) {	if (xr.localname == "onehundredattributes") {	xr.movetofirstattribute();	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

public void writeattributes_13(xmlwriterutils utils) {	string strxml = "<e a=\"&gt;&lt;&quot;&apos;&amp;\" />";	using (xmlreader xr = createreader(new stringreader(strxml))) {	xr.read();	xr.movetofirstattribute();	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

public void writeattributes_14(xmlwriterutils utils) {	string strxml = "<root attr='test' />";	xmlreader xr = createreader(new stringreader(strxml));	xr.read();	xr.movetofirstattribute();	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

assert.true(false);	}	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute("attr");	w.writeattributes(xr, false);	w.writeendelement();	}	catch (exception e) {	
exception 

w.writeendelement();	}	catch (exception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	finally {	xr.dispose();	}	}	
did not throw exception 

========================= corefx sample_12449 =========================

public void rtsenable_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default rtsenable 

public void rtsenable_true_beforeopen() {	
verifying true rtsenable before open 

public void rtsenable_false_beforeopen() {	
verifying false rtsenable before open 

public void rtsenable_true_false_beforeopen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying seting rtsenable to true then false before open 

public void rtsenable_true_afteropen() {	
verifying true rtsenable after open 

public void rtsenable_false_afteropen() {	
verifying false rtsenable after open 

public void rtsenable_true_handshake_xonxoff() {	
verifying true rtsenable after setting handshake to xonxoff 

public void rtsenable_false_handshake_xonxoff() {	
verifying false rtsenable after setting handshake to xonxoff 

public void rtsenable_true_handshake_requesttosend() {	
verifying true rtsenable after setting handshake to requesttosend 

public void rtsenable_false_handshake_requesttosend() {	
verifying false rtsenable after setting handshake to requesttosend 

public void rtsenable_true_handshake_requesttosendxonxoff() {	
verifying true rtsenable after setting handshake to requesttosendxonxoff 

public void rtsenable_false_handshake_requesttosendxonxoff() {	
verifying false rtsenable after setting handshake to requesttosendxonxoff 

public void rtsenable_true_false_afteropen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying seting rtsenable to true then false after open 

public void rtsenable_get_handshake_none() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying getting rtsenable with handshake set to none 

public void rtsenable_get_handshake_requesttosend() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying getting rtsenable with handshake set to requesttosend 

public void rtsenable_get_handshake_requesttosendxonxoff() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying getting rtsenable with handshake set to requesttosendxonxoff 

public void rtsenable_get_handshake_xonxoff() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying getting rtsenable with handshake set to xonxoff 

========================= corefx sample_681 =========================

public void baudrate_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default baudrate 

public void baudrate_14400() {	
verifying baudrate 

public void baudrate_28800() {	
verifying baudrate 

public void baudrate_1200() {	
verifying baudrate 

public void baudrate_115200() {	
verifying baudrate 

public void baudrate_minvalue() {	
verifying minvalue baudrate 

public void baudrate_neg1() {	
verifying baudrate 

public void baudrate_zero() {	
verifying baudrate 

public void baudrate_maxvalue() {	
verifying maxvalue baudrate 

private void verifybaudrate(int baudrate) {	
verifying setting baudrate before a call to open has been made 

private void verifybaudrate(int baudrate) {	verifybaudrateatopen(baudrate);	
verifying setting baudrate after a call to open has been made 

========================= corefx sample_646 =========================

private void checkrowversion(datarow dr) {	
has 

private void checkrowversion(datarow dr) {	
has 

private void checkrowversion(datarow dr) {	
has 

private void checkrowversion(datarow dr) {	
has 

========================= corefx sample_3361 =========================

public static void createeventsource(eventsourcecreationdata sourcedata) {	if (sourcedata == null) throw new argumentnullexception(nameof(sourcedata));	string logname = sourcedata.logname;	string source = sourcedata.source;	string machinename = sourcedata.machinename;	
createeventsource checking arguments 

throw new argumentexception(sr.format(sr.invalidparameter, nameof(machinename), machinename));	}	if (logname == null || logname.length == 0) logname = "application";	if (!validlogname(logname, false)) throw new argumentexception(sr.badlogname);	if (source == null || source.length == 0) throw new argumentexception(sr.format(sr.missingparameter, nameof(source)));	if (source.length + eventlogkey.length > 254) throw new argumentexception(sr.format(sr.parametertoolong, nameof(source), 254 - eventlogkey.length));	mutex mutex = null;	runtimehelpers.prepareconstrainedregions();	try {	sharedutils.entermutex(eventlogmutexname, ref mutex);	
createeventsource calling sourceexists 

}	if (logname == null || logname.length == 0) logname = "application";	if (!validlogname(logname, false)) throw new argumentexception(sr.badlogname);	if (source == null || source.length == 0) throw new argumentexception(sr.format(sr.missingparameter, nameof(source)));	if (source.length + eventlogkey.length > 254) throw new argumentexception(sr.format(sr.parametertoolong, nameof(source), 254 - eventlogkey.length));	mutex mutex = null;	runtimehelpers.prepareconstrainedregions();	try {	sharedutils.entermutex(eventlogmutexname, ref mutex);	if (sourceexists(source, machinename, true)) {	
createeventsource sourceexists returned true 

if (source == null || source.length == 0) throw new argumentexception(sr.format(sr.missingparameter, nameof(source)));	if (source.length + eventlogkey.length > 254) throw new argumentexception(sr.format(sr.parametertoolong, nameof(source), 254 - eventlogkey.length));	mutex mutex = null;	runtimehelpers.prepareconstrainedregions();	try {	sharedutils.entermutex(eventlogmutexname, ref mutex);	if (sourceexists(source, machinename, true)) {	if (".".equals(machinename)) throw new argumentexception(sr.format(sr.localsourcealreadyexists, source));	else throw new argumentexception(sr.format(sr.sourcealreadyexists, source, machinename));	}	
createeventsource getting dllpath 

if (sourceexists(source, machinename, true)) {	if (".".equals(machinename)) throw new argumentexception(sr.format(sr.localsourcealreadyexists, source));	else throw new argumentexception(sr.format(sr.sourcealreadyexists, source, machinename));	}	registrykey basekey = null;	registrykey eventkey = null;	registrykey logkey = null;	registrykey sourcelogkey = null;	registrykey sourcekey = null;	try {	
createeventsource getting local machine regkey 

========================= corefx sample_11527 =========================

if (datareader.nodetype != xmlnodetype.element) {	string nodetype = datareader.nodetype.tostring();	bool flag = true;	try {	datareader.readsubtree();	}	catch (invalidoperationexception) {	flag = false;	}	if (flag) {	
readsubtree doesn t throw invalidop exception on nodetype 

catch (invalidoperationexception) {	flag = false;	}	if (flag) {	throw new testexception(testresult.failed, "");	}	try {	datareader.read();	}	catch (xmlexception) {	
cannot read after an invalid operation exception 

if (datareader.hasattributes) {	bool flag = true;	datareader.movetofirstattribute();	try {	datareader.readsubtree();	}	catch (invalidoperationexception) {	flag = false;	}	if (flag) {	
readsubtree doesn t throw invalidop exception on attribute node type 

catch (invalidoperationexception) {	flag = false;	}	if (flag) {	throw new testexception(testresult.failed, "");	}	try {	datareader.read();	}	catch (xmlexception) {	
cannot read after an invalid operation exception 

========================= corefx sample_11566 =========================

protected override void generateiterationstatement(codeiterationstatement e) {	generatestatement(e.initstatement);	output.write("do while ");	generateexpression(e.testexpression);	output.writeline();	indent++;	generatevbstatements(e.statements);	generatestatement(e.incrementstatement);	indent--;	
loop 

protected override void generatemethodreturnstatement(codemethodreturnstatement e) {	if (e.expression != null) {	output.write("return ");	generateexpression(e.expression);	output.writeline();	}	else {	
return 

protected override void generateconditionstatement(codeconditionstatement e) {	output.write("if ");	generateexpression(e.condition);	
then 

generatevbstatements(e.truestatements);	indent--;	codestatementcollection falsestatemetns = e.falsestatements;	if (falsestatemetns.count > 0) {	output.write("else");	output.writeline();	indent++;	generatevbstatements(e.falsestatements);	indent--;	}	
end if 

protected override void generatetrycatchfinallystatement(codetrycatchfinallystatement e) {	
try 

foreach (codecatchclause current in catches) {	output.write("catch ");	outputtypenamepair(current.catchexceptiontype, current.localname);	output.writeline();	indent++;	generatevbstatements(current.statements);	indent--;	}	codestatementcollection finallystatements = e.finallystatements;	if (finallystatements.count > 0) {	
finally 

indent++;	generatevbstatements(current.statements);	indent--;	}	codestatementcollection finallystatements = e.finallystatements;	if (finallystatements.count > 0) {	indent++;	generatevbstatements(finallystatements);	indent--;	}	
end try 

protected override void generatelinepragmaend(codelinepragma e) {	output.writeline();	
end externalsource 

outputtype(e.privateimplementationtype);	output.write('.');	outputidentifier(methodname);	}	output.writeline();	if (!iscurrentinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	generatevbstatements(e.statements);	indent--;	if (sub) {	
end sub 

outputidentifier(methodname);	}	output.writeline();	if (!iscurrentinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	generatevbstatements(e.statements);	indent--;	if (sub) {	}	else {	
end function 

protected override void generateentrypointmethod(codeentrypointmethod e, codetypedeclaration c) {	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	
public shared sub main 

protected override void generateentrypointmethod(codeentrypointmethod e, codetypedeclaration c) {	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	indent++;	generatevbstatements(e.statements);	indent--;	
end sub 

else if (e.privateimplementationtype != null) {	output.write(" implements ");	outputtype(e.privateimplementationtype);	output.write('.');	outputidentifier(propname);	}	output.writeline();	if (!c.isinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	if (e.hasget) {	
get 

}	output.writeline();	if (!c.isinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	if (e.hasget) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.getstatements);	e.name = propname;	indent--;	
end get 

indent++;	if (e.hasget) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.getstatements);	e.name = propname;	indent--;	}	}	if (e.hasset) {	
set 

generatevbstatements(e.getstatements);	e.name = propname;	indent--;	}	}	if (e.hasset) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.setstatements);	indent--;	
end set 

}	}	if (e.hasset) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.setstatements);	indent--;	}	}	indent--;	
end property 

output.write(')');	output.writeline();	}	else if (baseargs.count > 0) {	output.write("mybase.new(");	outputexpressionlist(baseargs);	output.write(')');	output.writeline();	}	else if (iscurrentclass) {	
mybase new 

else if (baseargs.count > 0) {	output.write("mybase.new(");	outputexpressionlist(baseargs);	output.write(')');	output.writeline();	}	else if (iscurrentclass) {	}	generatevbstatements(e.statements);	indent--;	
end sub 

protected override void generatetypeconstructor(codetypeconstructor e) {	if (!(iscurrentclass || iscurrentstruct)) return;	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	
shared sub new 

protected override void generatetypeconstructor(codetypeconstructor e) {	if (!(iscurrentclass || iscurrentstruct)) return;	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	indent++;	generatevbstatements(e.statements);	indent--;	
end sub 

output.writeline(environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.autogen_comment_line4);	output.write("'     ");	output.writeline(sr.autogen_comment_line5);	output.write("' </");	output.writeline(sr.autogen_comment_line1);	output.writeline("'------------------------------------------------------------------------------");	output.writeline();	
option strict off 

output.writeline(environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.autogen_comment_line4);	output.write("'     ");	output.writeline(sr.autogen_comment_line5);	output.write("' </");	output.writeline(sr.autogen_comment_line1);	output.writeline("'------------------------------------------------------------------------------");	output.writeline();	
option strict on 

output.writeline(environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.autogen_comment_line4);	output.write("'     ");	output.writeline(sr.autogen_comment_line5);	output.write("' </");	output.writeline(sr.autogen_comment_line1);	output.writeline("'------------------------------------------------------------------------------");	output.writeline();	
option explicit off 

output.writeline(environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.autogen_comment_line4);	output.write("'     ");	output.writeline(sr.autogen_comment_line5);	output.write("' </");	output.writeline(sr.autogen_comment_line1);	output.writeline("'------------------------------------------------------------------------------");	output.writeline();	
option explicit on 

private void generatecoderegiondirective(coderegiondirective regiondirective) {	if (isgeneratingstatements()) {	return;	}	if (regiondirective.regionmode == coderegionmode.start) {	output.write("#region \"");	output.write(regiondirective.regiontext);	output.writeline("\"");	}	else if (regiondirective.regionmode == coderegionmode.end) {	
end region 

protected override void generatenamespaceend(codenamespace e) {	if (!string.isnullorempty(e.name)) {	indent--;	
end namespace 

========================= corefx sample_9419 =========================

if (!nologo) {	writeheader();	}	if (errs.count > 0) {	foreach (string err in errs) {	console.error.writeline(formatmessage(parsableerrors, true, sr.format(sr.warning, err)));	}	}	if (args.length == 0 || assembly == null) {	if (assembly == null) {	
assembly 

console.error.writeline(formatmessage(parsableerrors, true, sr.format(sr.warning, err)));	}	}	if (args.length == 0 || assembly == null) {	if (assembly == null) {	}	writehelp();	return 0;	}	if(disablerun) {	
this tool is not intended to be used directly 

console.error.writeline(formatmessage(parsableerrors, true, sr.format(sr.warning, err)));	}	}	if (args.length == 0 || assembly == null) {	if (assembly == null) {	}	writehelp();	return 0;	}	if(disablerun) {	
please refer to https return 

private void writeheader() {	
microsoft r net core xml serialization generation utility version 

private void writeheader() {	
copyright c microsoft corporation all rights reserved 

private void writehelp() {	console.out.writeline(sr.format(sr.helpdescription));	
dotnet 

private void writehelp() {	console.out.writeline(sr.format(sr.helpdescription));	console.out.writeline(sr.format(sr.helpdevoptions));	
a assembly 

private void writehelp() {	console.out.writeline(sr.format(sr.helpdescription));	console.out.writeline(sr.format(sr.helpdevoptions));	
type 

private void writehelp() {	console.out.writeline(sr.format(sr.helpdescription));	console.out.writeline(sr.format(sr.helpdevoptions));	
proxytypes 

private void writehelp() {	console.out.writeline(sr.format(sr.helpdescription));	console.out.writeline(sr.format(sr.helpdevoptions));	
force 

private void writehelp() {	console.out.writeline(sr.format(sr.helpdescription));	console.out.writeline(sr.format(sr.helpdevoptions));	
o out 

private void writehelp() {	console.out.writeline(sr.format(sr.helpdescription));	console.out.writeline(sr.format(sr.helpdevoptions));	console.out.writeline(sr.format(sr.helpmiscoptions));	
h help 

========================= corefx sample_13572 =========================

public void initializeshareddata(datasource source) {	
creating shared objects 

public void initializeshareddata(datasource source) {	tablemetadatalist = new list<tablemetadata>();	buildusertables(tablemetadatalist);	_applicationnames = new list<string>();	for (int i = 0; i < getnumdifferentapplicationnames(); i++) {	_applicationnames.add(getrandomapplicationname());	}	currentpoolingstressmode = poolingstressmode.randomizeconnectionstrings;	
finished creating shared objects 

========================= corefx sample_10958 =========================

public void inbreak() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write throws invalidoperationexception while in a break 

========================= corefx sample_607 =========================

public void inbreak() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying writebyte throws invalidoperationexception while in a break 

========================= corefx sample_596 =========================

public void clear() {	
trackedcollection clear 

public void add(t o) {	
trackedcollection add 

public bool remove(t value) {	
trackedcollection remove 

public bool remove(t value) {	markchange();	foreach (valueel el in this.combinedvalues) {	if (el.isinserted && el.insertedvalue.equals(value)) {	
trackedcollection found value to remove on inserted 

public bool remove(t value) {	markchange();	foreach (valueel el in this.combinedvalues) {	if (el.isinserted && el.insertedvalue.equals(value)) {	this.combinedvalues.remove(el);	return true;	}	if (!el.isinserted && el.originalvalue.right.equals(value)) {	
trackedcollection found value to remove on original 

========================= corefx sample_8994 =========================

public static void error(testresult result, object actual, object expected, string source, string message, string stack, string filename, int lineno) {	if (internal != null) {	internal.error(result, testlogflags.text, stringex.format(actual), stringex.format(expected), source, message, stack, filename, lineno );	}	else {	
message 

public static void error(testresult result, object actual, object expected, string source, string message, string stack, string filename, int lineno) {	if (internal != null) {	internal.error(result, testlogflags.text, stringex.format(actual), stringex.format(expected), source, message, stack, filename, lineno );	}	else {	
source 

public static void error(testresult result, object actual, object expected, string source, string message, string stack, string filename, int lineno) {	if (internal != null) {	internal.error(result, testlogflags.text, stringex.format(actual), stringex.format(expected), source, message, stack, filename, lineno );	}	else {	
expected 

public static void error(testresult result, object actual, object expected, string source, string message, string stack, string filename, int lineno) {	if (internal != null) {	internal.error(result, testlogflags.text, stringex.format(actual), stringex.format(expected), source, message, stack, filename, lineno );	}	else {	
received 

public static void error(testresult result, object actual, object expected, string source, string message, string stack, string filename, int lineno) {	if (internal != null) {	internal.error(result, testlogflags.text, stringex.format(actual), stringex.format(expected), source, message, stack, filename, lineno );	}	else {	
details 

public static void error(testresult result, object actual, object expected, string source, string message, string stack, string filename, int lineno) {	if (internal != null) {	internal.error(result, testlogflags.text, stringex.format(actual), stringex.format(expected), source, message, stack, filename, lineno );	}	else {	
file 

public static void error(testresult result, object actual, object expected, string source, string message, string stack, string filename, int lineno) {	if (internal != null) {	internal.error(result, testlogflags.text, stringex.format(actual), stringex.format(expected), source, message, stack, filename, lineno );	}	else {	
line 

========================= corefx sample_11655 =========================

using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	stopwatch stopwatch = new stopwatch();	int datareceivedcount = 0;	int count = 0;	com1.datareceived += (sender, e) => { ++datareceivedcount; };	com2.open();	stopwatch.start();	while (count % 100 != 0 || stopwatch.elapsedmilliseconds < s_testduration.totalmilliseconds) {	com1.open();	for (int j = 0; j < 10; ++j) {	
foo 

========================= corefx sample_656 =========================

public void dtrenable_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default dtrenable 

public void dtrenable_true_beforeopen() {	
verifying true dtrenable before open 

public void dtrenable_false_beforeopen() {	
verifying false dtrenable before open 

public void dtrenable_true_false_beforeopen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying seting dtrenable to true then false before open 

public void dtrenable_true_afteropen() {	
verifying true dtrenable after open 

public void dtrenable_false_afteropen() {	
verifying false dtrenable after open 

public void dtrenable_true_false_afteropen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying seting dtrenable to true then false after open 

========================= corefx sample_691 =========================

public void attribute_8(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute("attr1");	w.writestartattribute("attr1");	}	catch (xmlexception e) {	
exception 

try {	w.writestartelement("root");	w.writestartattribute("attr1");	w.writestartattribute("attr1");	}	catch (xmlexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attribute_9(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute("ns1", "attr1", "http: w.writestartattribute("ns1", "attr1", "http: }	catch (xmlexception e) {	
exception 

public void attribute_9(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute("ns1", "attr1", "http: w.writestartattribute("ns1", "attr1", "http: }	catch (xmlexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attribute_10(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute(string.empty);	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute(string.empty);	}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attribute_11(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute(null);	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartattribute(null);	}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attribute_13(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xml", "space", "http: }	catch (argumentexception e) {	
exception 

public void attribute_13(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xml", "space", "http: }	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attribute_25(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("test");	w.writestartattribute(null, "attr", null);	w.writestartattribute("attr");	}	catch (xmlexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("test");	w.writestartattribute(null, "attr", null);	w.writestartattribute("attr");	}	catch (xmlexception e) {	return;	}	}	
did not throw error for duplicate attrs 

========================= corefx sample_12459 =========================

}	thread.sleep(500);	}	else {	interlocked.increment(ref _numconnectedsockets);	_log.writeline(this.gethashcode() + " processaccept(_numconnectedsockets={0})", _numconnectedsockets);	socketasynceventargs readeventargs = _readwritepool.pop();	((asyncusertoken)readeventargs.usertoken).socket = e.acceptsocket;	bool willraiseevent = e.acceptsocket.receiveasync(readeventargs);	if (!willraiseevent) {	
processaccept processreceive 

private bool processreceive(socketasynceventargs e) {	_log.writeline( this.gethashcode() + " processreceive(bytestransferred={0}, socketerror={1}, _numconnectedsockets={2})", e.bytestransferred, e.socketerror, _numconnectedsockets);	asyncusertoken token = (asyncusertoken)e.usertoken;	if (e.bytestransferred > 0 && e.socketerror == socketerror.success) {	interlocked.add(ref _totalbytesread, e.bytestransferred);	
the server has read a total of bytes 

private bool processsend(socketasynceventargs e) {	_log.writeline( this.gethashcode() + " processsend(socketerror={0}, _numconnectedsockets={1})", e.socketerror, _numconnectedsockets);	if (e.socketerror == socketerror.success) {	asyncusertoken token = (asyncusertoken)e.usertoken;	bool willraiseevent = token.socket.receiveasync(e);	if (!willraiseevent) {	
processsend processreceive 

private bool processsend(socketasynceventargs e) {	_log.writeline( this.gethashcode() + " processsend(socketerror={0}, _numconnectedsockets={1})", e.socketerror, _numconnectedsockets);	if (e.socketerror == socketerror.success) {	asyncusertoken token = (asyncusertoken)e.usertoken;	bool willraiseevent = token.socket.receiveasync(e);	if (!willraiseevent) {	}	return willraiseevent;	}	else {	
processsend closeclientsocket 

private void closeclientsocket(socketasynceventargs e) {	asyncusertoken token = e.usertoken as asyncusertoken;	_log.writeline( this.gethashcode() + " closeclientsocket(_numconnectedsockets={0}, socketerror={1})", _numconnectedsockets, e.socketerror);	try {	token.socket.shutdown(socketshutdown.send);	}	catch (exception ex) {	
closeclientsocket exception 

========================= corefx sample_4434 =========================

public void breakstate_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default breakstate 

public void breakstate_beforeopen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying setting breakstate before open 

public void breakstate_true() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying true breakstate 

public void breakstate_false() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying false breakstate 

public void breakstate_true_false() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying setting breakstate to true then false 

public void breakstate_true_false_true() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying setting breakstate to true then false then true again 

========================= corefx sample_662 =========================

public void validationcallback(object sender, validationeventargs args) {	switch (args.severity) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	switch (args.severity) {	bwarningcallback = true;	warningcount++;	break;	
error 

public void validationcallback(object sender, validationeventargs args) {	switch (args.severity) {	bwarningcallback = true;	warningcount++;	break;	berrorcallback = true;	errorcount++;	break;	}	
exception message 

public void validationcallback(object sender, validationeventargs args) {	switch (args.severity) {	bwarningcallback = true;	warningcount++;	break;	berrorcallback = true;	errorcount++;	break;	}	if (args.exception.innerexception != null) {	
innerexception message 

bwarningcallback = true;	warningcount++;	break;	berrorcallback = true;	errorcount++;	break;	}	if (args.exception.innerexception != null) {	}	else {	
inner exception is null 

xss.xmlresolver = new xmlurlresolver();	xss.validationeventhandler += validationcallback;	xmlreader r = createreader(path.combine(testdata._root, param0.tostring()), false);	xmlreader r2 = createreader(r, true);	try {	xss.add(null, r2);	}	catch (xmlexception) {	assert.true(false);	}	
count 

========================= corefx sample_12519 =========================

public void writewithoutopen() {	using (serialport com = new serialport()) {	
verifying write method throws exception without a call to open 

public void writeafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying write method throws exception with a failed call to open 

public void writeafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to cloes 

public void bytestowrite() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndstr asyncwriterndstr = new asyncwriterndstr(com, s_string_size_bytes_to_write);	var t = new task(asyncwriterndstr.writerndstr);	
verifying bytestowrite with one call to write 

public void bytestowritesuccessive() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndstr asyncwriterndstr = new asyncwriterndstr(com, s_string_size_bytes_to_write);	var t1 = new task(asyncwriterndstr.writerndstr);	var t2 = new task(asyncwriterndstr.writerndstr);	
verifying bytestowrite with successive calls to write 

========================= corefx sample_633 =========================

task c4 = c3.continuewith(_ => { mres.waitone(); donecount[4]++; }, cts.token, taskcontinuationoptions.lazycancellation, taskscheduler.default);	task c5 = c4.continuewith(_ => { mres.waitone(); donecount[5]++; });	ensurecompletionstatus(c2, true, "runcontinuewithprecanceltests: c2 should have completed (canceled) upon construction");	ensurecompletionstatus(c4, false, "runcontinuewithprecanceltests: c4 should not have completed (canceled) upon construction");	ensurecompletionstatus(t1, false, "runcontinuewithprecanceltests: t1 should not have completed before being started");	ensurecompletionstatus(c1, false, "runcontinuewithprecanceltests: c1 should not have completed before antecedent completed");	ensurecompletionstatus(c3, false, "runcontinuewithprecanceltests: c3 should not have completed before mres was set");	ensurecompletionstatus(c5, false, "runcontinuewithprecanceltests: c5 should not have completed before mres was set");	ensuretaskcanceledexceptionthrown(() => { c2.wait(); }, "runcontinuewithprecanceltests: expected c2.wait to throw ae/tce");	mres.set();	
runcontinuewithprecanceltests waiting for tasks to complete if we hang here something went wrong 

v7.start();	checkcompletionstate(c1, false, "task ==> task<t>, source task incomplete");	checkcompletionstate(c2, false, "task<t> ==> task<t>, source task incomplete");	checkcompletionstate(c3, false, "startnew ==> task<t>, source task incomplete");	checkcompletionstate(c4, false, "continuewhenall => task<t>, source task incomplete");	checkcompletionstate(c5, false, "task ==> task, source task incomplete");	checkcompletionstate(c6, false, "task<t> ==> task, source task incomplete");	checkcompletionstate(c7, false, "startnew ==> task, source task incomplete");	checkcompletionstate(c8, false, "continuewhenany => task, source task incomplete");	mres.set();	
rununwraptests waiting on unwrap products if we hang something is wrong 

ctsforc6.cancel();	try {	c6.wait();	assert.true(false, string.format("rununwraptests: > failed.  expected wait() to throw after cancellation of task<int>->task."));	}	catch { }	ts = c6.status;	if (ts != taskstatus.canceled) {	assert.true(false, string.format("rununwraptests: > failed.  direct cancellation of returned task<int>->task did not work -- status = {0}", ts));	}	
rununwraptests waiting for container if we deadlock cancellations are not being cleaned up properly 

public static void testnodeadlockoncontinuewith() {	
testnodeadlockoncontinuewith shouldn t deadlock if it passes 

public static void testnodeadlockoncontinuewith() {	const int iterations = 1000;	var tasks = new task<int>[iterations];	for (int i = 0; i < iterations; i++) {	tasks[i] = choose(cancellationtoken.none);	}	try { task.waitall(tasks); }	catch (aggregateexception ae) { ae.handle(e => e is taskcanceledexception); }	
success 

else if (usecontinuewhenany) {	c1 = task.factory.continuewhenany(new task[] { t1 }, _ => { mres1.set(); mres2.wait(); }, cts.token, options, taskscheduler.default);	}	else {	c1 = task.factory.continuewhenall(new task[] { t1 }, _ => { mres1.set(); mres2.wait(); }, cts.token, options, taskscheduler.default);	}	t1.start();	mres1.wait();	cts.cancel();	mres2.set();	
about to wait on 

mres1.wait();	cts.cancel();	mres2.set();	try {	c1.wait();	}	catch (exception e) {	assert.true(false, string.format("runlazycancellationtests: error. did not expect c1.wait() to throw an exception, got " + e.tostring()));	}	}	
finished successfully 

c1 = t1.continuewith(_ => { }, cts.token, options, taskscheduler.default);	}	else if (usecontinuewhenany) {	c1 = task.factory.continuewhenany(new task[] { t1 }, _ => { }, cts.token, options, taskscheduler.default);	}	else {	c1 = task.factory.continuewhenall(new task[] { t1 }, _ => { }, cts.token, options, taskscheduler.default);	}	assert.true(c1.iscompleted != uselazycancellation, "runlazycancellationtests: before t1.start(), c1.iscompleted = " + c1.iscompleted);	t1.start();	
about to wait on 

}	else if (usecontinuewhenany) {	c1 = task.factory.continuewhenany(new task[] { t1 }, _ => { }, cts.token, options, taskscheduler.default);	}	else {	c1 = task.factory.continuewhenall(new task[] { t1 }, _ => { }, cts.token, options, taskscheduler.default);	}	cts.cancel();	assert.true(c1.iscompleted != uselazycancellation, "runlazycancellationtests: before t1.start(), c1.iscompleted = " + c1.iscompleted);	t1.start();	
about to wait on 

========================= corefx sample_4018 =========================

public virtual void addservice(type servicetype, object serviceinstance, bool promote) {	
adding service instance servicetype name promoting promote tostring 

public virtual void addservice(type servicetype, object serviceinstance, bool promote) {	if (promote) {	iservicecontainer container = container;	if (container != null) {	
promoting to container 

public virtual void addservice(type servicetype, servicecreatorcallback callback, bool promote) {	
adding service callback servicetype name promoting promote tostring 

public virtual void addservice(type servicetype, servicecreatorcallback callback, bool promote) {	if (promote) {	iservicecontainer container = container;	if (container != null) {	
promoting to container 

public virtual object getservice(type servicetype) {	object service = null;	
searching for service servicetype name 

for (int idx = 0; idx < defaults.length; idx++) {	if (servicetype.isequivalentto(defaults[idx])) {	service = this;	break;	}	}	if (service == null) {	services.trygetvalue(servicetype, out service);	}	if (service is servicecreatorcallback) {	
encountered a callback invoking it 

}	}	if (service == null) {	services.trygetvalue(servicetype, out service);	}	if (service is servicecreatorcallback) {	service = ((servicecreatorcallback)service)(this, servicetype);	debug.writelineif(s_traceservice.traceverbose, $"callback return object: {(service == null ? "(null)" : service.tostring())}");	if (service != null && !service.gettype().iscomobject && !servicetype.isinstanceoftype(service)) {	debug.fail($"object {service.gettype().name} was returned from a service creator callback but it does not implement the registered type of {servicetype.name}");	
object does not implement service interface 

if (service is servicecreatorcallback) {	service = ((servicecreatorcallback)service)(this, servicetype);	debug.writelineif(s_traceservice.traceverbose, $"callback return object: {(service == null ? "(null)" : service.tostring())}");	if (service != null && !service.gettype().iscomobject && !servicetype.isinstanceoftype(service)) {	debug.fail($"object {service.gettype().name} was returned from a service creator callback but it does not implement the registered type of {servicetype.name}");	service = null;	}	services[servicetype] = service;	}	if (service == null && _parentprovider != null) {	
service unresolved trying parent 

debug.fail($"object {service.gettype().name} was returned from a service creator callback but it does not implement the registered type of {servicetype.name}");	service = null;	}	services[servicetype] = service;	}	if (service == null && _parentprovider != null) {	service = _parentprovider.getservice(servicetype);	}	#if debug if (s_traceservice.traceverbose && service == null) {	debug.writeline("******************************************");	
failed to resolve service 

debug.fail($"object {service.gettype().name} was returned from a service creator callback but it does not implement the registered type of {servicetype.name}");	service = null;	}	services[servicetype] = service;	}	if (service == null && _parentprovider != null) {	service = _parentprovider.getservice(servicetype);	}	#if debug if (s_traceservice.traceverbose && service == null) {	debug.writeline("******************************************");	
at 

public virtual void removeservice(type servicetype, bool promote) {	
removing service servicetype name promote promote tostring 

public virtual void removeservice(type servicetype, bool promote) {	if (promote) {	iservicecontainer container = container;	if (container != null) {	
invoking parent container 

========================= corefx sample_7220 =========================

perftrack.dumphistogram(_executedinstructions);	console.writeline("-- total executed: {0}", _executedinstructions.values.aggregate(0, (sum, value) => sum + value));	console.writeline("-----");	var referenced = new dictionary<string, int>();	int total = 0;	foreach (var entry in _instances) {	referenced[entry.key] = entry.value.count;	total += entry.value.count;	}	perftrack.dumphistogram(referenced);	
total referenced 

========================= corefx sample_2794 =========================

public static void assertiscoercion(unaryexpression u, string opname, type expected) {	
convert 

========================= corefx sample_2571 =========================

public void cleanup() {	string currentservice = "";	foreach (servicecontroller controller in servicecontroller.getservices()) {	try {	currentservice = controller.displayname;	if (controller.displayname.startswith("test service")) {	
trying to clean up 

public void cleanup() {	string currentservice = "";	foreach (servicecontroller controller in servicecontroller.getservices()) {	try {	currentservice = controller.displayname;	if (controller.displayname.startswith("test service")) {	testserviceinstaller deleteservice = new testserviceinstaller() {	servicename = controller.servicename };	deleteservice.removeservice();	
cleaned up 

foreach (servicecontroller controller in servicecontroller.getservices()) {	try {	currentservice = controller.displayname;	if (controller.displayname.startswith("test service")) {	testserviceinstaller deleteservice = new testserviceinstaller() {	servicename = controller.servicename };	deleteservice.removeservice();	}	}	catch (exception ex) {	
failed 

========================= corefx sample_2883 =========================

public void charencoding() {	string chars = "\u1234 \u4567 \uabcd \r \n \t \\ \" \' \0 \u2028 \u2029 \u0084 \u0085 \u00010f00";	var main = new codeentrypointmethod();	
writeline 

public void charencoding() {	string chars = "\u1234 \u4567 \uabcd \r \n \t \\ \" \' \0 \u2028 \u2029 \u0084 \u0085 \u00010f00";	var main = new codeentrypointmethod();	
public static void main system console writeline 

public void defaultvalues() {	var main = new codeentrypointmethod();	foreach (type t in new[] { typeof(int), typeof(object), typeof(datetime), typeof(string) }) {	
writeline 

public void defaultvalues() {	var main = new codeentrypointmethod();	foreach (type t in new[] { typeof(int), typeof(object), typeof(datetime), typeof(string) }) {	}	
public static void main system console writeline default int system console writeline default object system console writeline default system datetime system console writeline default string 

========================= corefx sample_9326 =========================

private object findnativebysididentref(type principaltype, byte[] sid) {	string samurnvalue;	string name;	string domainname;	int accountusage;	int err = utils.lookupsid(this.machineusersuppliedname, _credentials, sid, out name, out domainname, out accountusage);	if (err != 0) {	globaldebug.writelineif(globaldebug.error, "samstorectx", "findnativebysididentref:lookupsid on {0} failed, err={1}", this.machineusersuppliedname, err);	return null;	}	
samstorectx findnativebysididentref mapped to 

string name;	string domainname;	int accountusage;	int err = utils.lookupsid(this.machineusersuppliedname, _credentials, sid, out name, out domainname, out accountusage);	if (err != 0) {	globaldebug.writelineif(globaldebug.error, "samstorectx", "findnativebysididentref:lookupsid on {0} failed, err={1}", this.machineusersuppliedname, err);	return null;	}	if (utils.classifysid(sid) == sidtype.realobjectfakedomain) {	domainname = this.machineflatname;	
samstorectx findnativebysididentref using for domainname 

return null;	}	if (utils.classifysid(sid) == sidtype.realobjectfakedomain) {	domainname = this.machineflatname;	}	if (string.compare(domainname, this.machineflatname, stringcomparison.ordinalignorecase) != 0) {	globaldebug.writelineif(globaldebug.warn, "samstorectx", "findnativebysididentref: {0} != {1}, no match", domainname, this.machineflatname);	return null;	}	samurnvalue = domainname + "\\" + name;	
samstorectx findnativebysididentref searching for 

private object findnativebynt4identref(type principaltype, string urnvalue) {	int index = urnvalue.indexof('\\');	if (index == urnvalue.length - 1) throw new argumentexception(sr.storectxnt4identityclaimwrongform);	string samaccountname = (index != -1) ? urnvalue.substring(index + 1) : urnvalue;	
samstorectx searching for 

private static void samaccountnamefromwinntconverter(directoryentry de, string suggestedwinntproperty, principal p, string propertyname) {	debug.assert(de.properties["name"].count == 1);	string samaccountname = (string)de.properties["name"][0];	
samstorectx samaccountnamefromwinntconverter loading sam 

private static void updategroupmembership(principal group, directoryentry de, netcred credentials, authenticationtypes authtypes) {	debug.assert(group.fakeprincipal == false);	principalcollection members = (principalcollection)group.getvalueforproperty(propertynames.groupmembers);	unsafenativemethods.iadsgroup iadsgroup = (unsafenativemethods.iadsgroup)de.nativeobject;	try {	if (members.cleared) {	
samstorectx updategroupmembership clearing 

type membertype = member.gettype();	if ((membertype != typeof(userprincipal)) && (!membertype.issubclassof(typeof(userprincipal))) && (membertype != typeof(computerprincipal)) && (!membertype.issubclassof(typeof(computerprincipal))) && (membertype != typeof(groupprincipal)) && (!membertype.issubclassof(typeof(groupprincipal)))) {	throw new invalidoperationexception( string.format(cultureinfo.currentculture, sr.storectxunsupportedprincipaltypeforgroupinsert, membertype.tostring()));	}	if (member.unpersisted) throw new invalidoperationexception(sr.storectxgrouphasunpersistedinsertedprincipal);	debug.assert(member.context != null);	}	foreach (principal member in insertedmembers) {	string membersidpath = getsidadspathfromprincipal(member);	if (membersidpath == null) throw new invalidoperationexception(sr.samstorectxcouldntgetsidforgroupmember);	
samstorectx updategroupmembership inserting 

string membersidpath = getsidadspathfromprincipal(member);	if (membersidpath == null) throw new invalidoperationexception(sr.samstorectxcouldntgetsidforgroupmember);	iadsgroup.add(membersidpath);	}	list<principal> removedmembers = members.removed;	foreach (principal member in removedmembers) {	debug.assert(member.unpersisted == false);	debug.assert(members.cleared == false);	string membersidpath = getsidadspathfromprincipal(member);	if (membersidpath == null) throw new invalidoperationexception(sr.samstorectxcouldntgetsidforgroupmember);	
samstorectx updategroupmembership removing 

private static string getsidadspathfromprincipal(principal p) {	debug.assert(p.unpersisted == false);	securityidentifier sid = p.sid;	if (sid == null) {	
samstorectx getsidadspathfromprincipal no sid 

private static string getsidadspathfromprincipal(principal p) {	debug.assert(p.unpersisted == false);	securityidentifier sid = p.sid;	if (sid == null) {	return null;	}	string sddlsid = sid.tostring();	if (sddlsid == null) {	
samstorectx getsidadspathfromprincipal couldn t convert to sddl 

========================= corefx sample_9044 =========================

public static void checkleaks() {	lock (s_internalsyncobject) {	if (compmodswitches.handleleak.level >= tracelevel.warning) {	gc.collect();	gc.waitforpendingfinalizers();	handletype[] types = new handletype[s_handletypes.values.count];	s_handletypes.values.copyto(types, 0);	
begin checkleaks 

public static void checkleaks() {	lock (s_internalsyncobject) {	if (compmodswitches.handleleak.level >= tracelevel.warning) {	gc.collect();	gc.waitforpendingfinalizers();	handletype[] types = new handletype[s_handletypes.values.count];	s_handletypes.values.copyto(types, 0);	for (int i = 0; i < types.length; i++) {	types[i]?.checkleaks();	}	
end checkleaks 

private void onhandleremove(string handlename, intptr handle, int handlecount) {	handletype type = (handletype)s_handletypes[handlename];	bool removed = false;	if (type != null) {	removed = type.remove(handle);	}	if (!removed) {	if (compmodswitches.handleleak.level >= tracelevel.error) {	debug.writeline("*************************************************");	
while removing couldn t find handle 

private void onhandleremove(string handlename, intptr handle, int handlecount) {	handletype type = (handletype)s_handletypes[handlename];	bool removed = false;	if (type != null) {	removed = type.remove(handle);	}	if (!removed) {	if (compmodswitches.handleleak.level >= tracelevel.error) {	debug.writeline("*************************************************");	
handle type 

public void add(intptr handle) {	lock (this) {	int hash = computehash(handle);	if (compmodswitches.handleleak.level >= tracelevel.info) {	debug.writeline("-------------------------------------------------");	
handle allocating 

public void add(intptr handle) {	lock (this) {	int hash = computehash(handle);	if (compmodswitches.handleleak.level >= tracelevel.info) {	debug.writeline("-------------------------------------------------");	
handle type 

public void checkleaks() {	lock (this) {	bool reportedfirstleak = false;	if (_handlecount > 0) {	for (int i = 0; i < numberofbuckets; i++) {	handleentry e = _buckets[i];	while (e != null) {	if (!e.ignorableasleak) {	if (!reportedfirstleak) {	
handle leaks detected for handles of type 

public bool remove(intptr handle) {	lock (this) {	int hash = computehash(handle);	if (compmodswitches.handleleak.level >= tracelevel.info) {	debug.writeline("-------------------------------------------------");	
handle releaseing 

public bool remove(intptr handle) {	lock (this) {	int hash = computehash(handle);	if (compmodswitches.handleleak.level >= tracelevel.info) {	debug.writeline("-------------------------------------------------");	
handle type 

========================= corefx sample_10346 =========================

private static bool verifyreadwrite(serialport com1, serialport com2) {	try {	com1.readtimeout = 1000;	com2.readtimeout = 1000;	com1.writetimeout = 1000;	com2.writetimeout = 1000;	
ping 

private static bool verifyreadwrite(serialport com1, serialport com2) {	try {	com1.readtimeout = 1000;	com2.readtimeout = 1000;	com1.writetimeout = 1000;	com2.writetimeout = 1000;	if ("ping" != com2.readline()) {	return false;	}	
response 

public static flowcontrolcapabilities measureflowcontrolcapabilities(string portname) {	for (int probebase = 1; probebase <= 65536; probebase *= 2) {	int probelength;	probelength = probebase + 1;	int buffersize = measuretransmitbuffersize(portname, probelength);	if (buffersize < probelength) {	
found blocking packet of length hardware buffer 

public static flowcontrolcapabilities measureflowcontrolcapabilities(string portname) {	for (int probebase = 1; probebase <= 65536; probebase *= 2) {	int probelength;	probelength = probebase + 1;	int buffersize = measuretransmitbuffersize(portname, probelength);	if (buffersize < probelength) {	return new flowcontrolcapabilities(probelength, buffersize, true);	}	}	
failed to achieve write blocking on serial port no hardware flow control available 

========================= corefx sample_613 =========================

private static void onemovenext(int length, bool isorderable) {	
length isorderable 

========================= corefx sample_1260 =========================

public void handshake_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default handshake 

public void handshake_none_beforeopen() {	
verifying none handshake before open 

public void handshake_xonxoff_beforeopen() {	
verifying xonxoff handshake before open 

public void handshake_requesttosend_beforeopen() {	
verifying requesttosend handshake before open 

public void handshake_requesttosendxonxoff_beforeopen() {	
verifying requesttosendxonxoff handshake before open 

public void handshake_none_afteropen() {	
verifying none handshake after open 

public void handshake_xonxoff_afteropen() {	
verifying xonxoff handshake after open 

public void handshake_requesttosend_afteropen() {	
verifying requesttosend handshake after open 

public void handshake_requesttosendxonxoff_afteropen() {	
verifying requesttosendxonxoff handshake after open 

public void handshake_int32minvalue() {	
verifying minvalue handshake 

public void handshake_neg1() {	
verifying handshake 

public void handshake_4() {	
verifying handshake 

public void handshake_int32maxvalue() {	
verifying maxvalue handshake 

========================= corefx sample_642 =========================

public void setxmlnametabletonull() {	xmlschemavalidator val;	try {	val = new xmlschemavalidator(null, new xmlschemaset(), new xmlnamespacemanager(new nametable()), allflags);	}	catch (argumentnullexception) {	return;	}	
argumentnullexception was not thrown 

public void setschemasettonull() {	xmlschemavalidator val;	try {	val = new xmlschemavalidator(new nametable(), null, new xmlnamespacemanager(new nametable()), allflags);	}	catch (argumentnullexception) {	return;	}	
argumentnullexception was not thrown 

========================= corefx sample_12539 =========================

}	console.writeline("\";");	console.writeline();	string filename = (args.length == 0) ? "xmlchartype.bin" : args[0];	console.write("writing xmlchartype character properties to {0}...", filename);	filestream fs = new filestream(filename, filemode.create);	for (int i = 0; i < charpropertiessize; i += 4096) {	fs.write(s_charproperties, i, 4096);	}	fs.close();	
done 

string filename = (args.length == 0) ? "xmlchartype.bin" : args[0];	console.write("writing xmlchartype character properties to {0}...", filename);	filestream fs = new filestream(filename, filemode.create);	for (int i = 0; i < charpropertiessize; i += 4096) {	fs.write(s_charproperties, i, 4096);	}	fs.close();	}	catch (exception e) {	console.writeline();	
exception 

========================= corefx sample_5638 =========================

public void newline_crlf_crstr() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with newline and a string containing just 

public void newline_crlf_lfstr() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with newline and a string containing just 

public void greedyread() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(128, tcsupport.characteroptions.surrogates);	byte[] bytexmitbuffer = new byte[1024];	char utf32char = tcsupport.generaterandomcharnonsurrogate();	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	int numbytes;	
verifying that readto will read everything from internal buffer and drivers buffer 

public void nullnewline() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws argumentexcpetion with a null newline string 

public void emptynewline() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws argumentexcpetion with an empty newline string 

public void newlinesubstring() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with sub strings of the new line appearing in the string being read 

public void read_datareceivedbeforetimeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	string endstring = "end";	asyncread asyncread = new asyncread(com1, endstring);	var asyncreadtask = new task(asyncread.read);	char endchar = endstring[0];	char notendchar = tcsupport.getrandomotherchar(endchar, tcsupport.characteroptions.none);	
verifying that readto string will read characters that have been received after the call to read was made 

public void read_timeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	string endstring = "end";	char endchar = endstring[0];	char notendchar = tcsupport.getrandomotherchar(endchar, tcsupport.characteroptions.none);	
verifying that readto string works appropriately after timeoutexception has been thrown 

public void read_surrogatecharacter() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with surrogate pair in the input and a surrogate pair for the newline 

========================= corefx sample_676 =========================

else {	using (stream es = entry.open()) {	try {	assert.equal(0, es.length);	}	catch (notsupportedexception) {	try {	assert.equal(-1, es.readbyte());	}	catch (exception) {	
didn t return eof 

========================= corefx sample_4531 =========================

public void receivedevent_chars() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	receivedeventhandler rcveventhandler = new receivedeventhandler(com1);	
verifying receivedchars event 

public void receivedevent_eof() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	receivedeventhandler rcveventhandler = new receivedeventhandler(com1);	byte[] xmitbytes = new byte[1];	
verifying eofreceived event 

public void receivedevent_charseof() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	receivedeventhandler rcveventhandler = new receivedeventhandler(com1);	byte[] xmitbytes = new byte[3];	
verifying eofreceived event 

public void receivedevent_charseof_readallchars() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	readinreceivedeventhandler rcveventhandler = new readinreceivedeventhandler(com1);	byte[] xmitbytes = new byte[3];	
verifying eofreceived and receivedchars events where all chars are read in the receivedchars event 

========================= corefx sample_627 =========================

public void putendelement(string myname) {	
popping 

case 'c': putcomment();	break;	case 'r': putroot();	break;	case 'r': putendroot();	break;	case 'b': putendroot();	break;	case 'w': putwhitespace();	break;	
skipping character 

========================= corefx sample_4602 =========================

private void greedyread() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(128, true);	byte[] bytexmitbuffer = new byte[1024];	char utf32char = tcsupport.generaterandomcharnonsurrogate();	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	int numbytes;	
verifying that readexisting will read everything from internal buffer and drivers buffer 

========================= corefx sample_685 =========================

public void ctsholding_default() {	using (serialport com1 = new serialport()) {	serialportproperties serportprop = new serialportproperties();	
verifying default ctsholding before open 

public void ctsholding_default_afteropen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default ctsholding after open 

========================= corefx sample_666 =========================

public void v() {	string type = variation.params[0].tostring();	xmlreader datareader = getreader(new stringreader(_xmlstr));	positiononelement(datareader, "root");	switch (type) {	case "nns": datareader.readtodescendant("elem");	if (datareader.hasattributes) {	
positioned on wrong element 

if (datareader.hasattributes) {	testlog.writeignore(datareader.readinnerxml() + "\n");	throw new testexception(testresult.failed, "");	}	while (datareader.read()) ;	datareader.dispose();	return;	case "dns": datareader.readtodescendant("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns") == null) {	
positioned on wrong element not on dns 

if (datareader.getattribute("xmlns") == null) {	throw new testexception(testresult.failed, "");	}	}	while (datareader.read()) ;	datareader.dispose();	return;	case "ns": datareader.readtodescendant("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on ns 

public void v3() {	string type = variation.params[0].tostring();	xmlreader datareader = getreader(new stringreader(_xmlstr));	positiononelement(datareader, "root");	switch (type) {	case "nns": datareader.readtodescendant("elem");	int depth = datareader.depth;	if (datareader.hasattributes) {	
positioned on wrong element 

throw new testexception(testresult.failed, "");	}	testlog.compare(datareader.readtodescendant("elem"), false, "there are no more descendants");	testlog.compare(datareader.nodetype, xmlnodetype.endelement, "wrong node type");	while (datareader.read()) ;	datareader.dispose();	return;	case "dns": datareader.readtodescendant("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns") == null) {	
positioned on wrong element not on dns 

}	}	testlog.compare(datareader.readtodescendant("elem", "elem"), false, "there are no more descendants");	testlog.compare(datareader.nodetype, xmlnodetype.endelement, "wrong node type");	while (datareader.read()) ;	datareader.dispose();	return;	case "ns": datareader.readtodescendant("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on dns 

public void v18() {	string type = variation.params[0].tostring();	xmlreader datareader = getreader(new stringreader(_xmlstr));	switch (type) {	case "nns": datareader.readtodescendant("elem");	if (datareader.hasattributes) {	
positioned on wrong element 

if (datareader.hasattributes) {	testlog.writeignore(datareader.readinnerxml() + "\n");	throw new testexception(testresult.failed, "");	}	while (datareader.read()) ;	datareader.dispose();	return;	case "dns": datareader.readtodescendant("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns") == null) {	
positioned on wrong element not on dns 

if (datareader.getattribute("xmlns") == null) {	throw new testexception(testresult.failed, "");	}	}	while (datareader.read()) ;	datareader.dispose();	return;	case "ns": datareader.readtodescendant("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on ns 

========================= corefx sample_11562 =========================

assert.equal(ss.count, 1);	xmlreadersettings settings = new xmlreadersettings();	settings.schemas = ss;	settings.validationtype = validationtype.schema;	using (xmlreader xmlreader = xmlreader.create(new stringreader(instancexml), settings)) {	try {	while (xmlreader.read()) ;	assert.true(false); ;	}	catch (xmlschemavalidationexception e) {	
before remove 

========================= corefx sample_12529 =========================

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void readafterbasestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to basestream close 

public void parityerroronlastbyte() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var rndgen = new random(15);	var bytestowrite = new byte[numrndbytespairty];	var expectedbytes = new byte[numrndbytespairty];	var actualbytes = new byte[numrndbytespairty + 1];	
verifying default parityreplace byte with a parity errro on the last byte 

private void verifybytestoread(int numbytesread, encoding encoding) {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var rndgen = new random(-55);	var bytestowrite = new byte[numrndbytestoread];	for (var i = 0; i < bytestowrite.length; i++) {	var randbyte = (byte)rndgen.next(0, 256);	bytestowrite[i] = randbyte;	}	
verifying bytestoread with a buffer of 

========================= corefx sample_592 =========================

public void seek_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying seek property throws exception after open then close 

public void seek_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying seek property throws exception after open then basestream close 

public void seek_afteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying seek method throws exception after a call to open 

public void seek_badoffset() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying seek method throws exception with a bad offset after a call to open 

public void seek_badorigin() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying seek method throws exception with a bad origin after a call to open 

public void seek_badoffset_badorigin() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying seek method throws exception with a bad offset origin after a call to open 

========================= corefx sample_603 =========================

public void add(principal principal) {	checkdisposed();	if (principal == null) throw new argumentnullexception("principal");	if (contains(principal)) throw new principalexistsexception(sr.principalexistsexceptiontext);	markchange();	if (_removedvaluespending.contains(principal)) {	
principalcollection add removing from removedvaluespending 

public void add(principal principal) {	checkdisposed();	if (principal == null) throw new argumentnullexception("principal");	if (contains(principal)) throw new principalexistsexception(sr.principalexistsexceptiontext);	markchange();	if (_removedvaluespending.contains(principal)) {	_removedvaluespending.remove(principal);	if (!_insertedvaluescompleted.contains(principal)) {	
principalcollection add adding to insertedvaluescompleted 

if (principal == null) throw new argumentnullexception("principal");	if (contains(principal)) throw new principalexistsexception(sr.principalexistsexceptiontext);	markchange();	if (_removedvaluespending.contains(principal)) {	_removedvaluespending.remove(principal);	if (!_insertedvaluescompleted.contains(principal)) {	_insertedvaluescompleted.add(principal);	}	}	else {	
principalcollection add making it a pending insert 

public void add(principalcontext context, identitytype identitytype, string identityvalue) {	checkdisposed();	if (context == null) throw new argumentnullexception("context");	if (identityvalue == null) throw new argumentnullexception("identityvalue");	principal principal = principal.findbyidentity(context, identitytype, identityvalue);	if (principal != null) {	add(principal);	}	else {	
principalcollection add urn urn no match 

public void clear() {	
principalcollection clear 

public bool remove(principal principal) {	checkdisposed();	if (principal == null) throw new argumentnullexception("principal");	storectx storectxtouse = _owninggroup.getstorectxtouse();	string explanation;	debug.assert(storectxtouse != null || _owninggroup.unpersisted == true);	if ((storectxtouse != null) && (!storectxtouse.cangroupmemberberemoved(_owninggroup, principal, out explanation))) throw new invalidoperationexception(explanation);	bool removed = false;	if (_insertedvaluespending.contains(principal)) {	
principalcollection remove removing from insertedvaluespending 

storectx storectxtouse = _owninggroup.getstorectxtouse();	string explanation;	debug.assert(storectxtouse != null || _owninggroup.unpersisted == true);	if ((storectxtouse != null) && (!storectxtouse.cangroupmemberberemoved(_owninggroup, principal, out explanation))) throw new invalidoperationexception(explanation);	bool removed = false;	if (_insertedvaluespending.contains(principal)) {	markchange();	_insertedvaluespending.remove(principal);	removed = true;	if (!_removedvaluescompleted.contains(principal)) {	
principalcollection remove adding to removedvaluescompleted 

public bool remove(principalcontext context, identitytype identitytype, string identityvalue) {	checkdisposed();	if (context == null) throw new argumentnullexception("context");	if (identityvalue == null) throw new argumentnullexception("identityvalue");	principal principal = principal.findbyidentity(context, identitytype, identityvalue);	if (principal == null) {	
principalcollection remove urn urn no match 

private bool containsenumtest(principal principal) {	checkdisposed();	if (principal == null) throw new argumentnullexception("principal");	lock (_resultset) {	resultsetbookmark bookmark = null;	try {	
principalcollection containsenumtest bookmarking 

try {	bookmark = _resultset.bookmarkandreset();	principalcollectionenumerator containmentenumerator = new principalcollectionenumerator( _resultset, this, _removedvaluescompleted, _removedvaluespending, _insertedvaluescompleted, _insertedvaluespending);	while (containmentenumerator.movenext()) {	principal p = containmentenumerator.current;	if (p.equals(principal)) return true;	}	}	finally {	if (bookmark != null) {	
principalcollection containsenumtest restoring from bookmark 

private bool containsnativetest(principal principal) {	checkdisposed();	if (principal == null) throw new argumentnullexception("principal");	if (_insertedvaluescompleted.contains(principal) || _insertedvaluespending.contains(principal)) {	
principalcollection containsnativetest found insert 

private bool containsnativetest(principal principal) {	checkdisposed();	if (principal == null) throw new argumentnullexception("principal");	if (_insertedvaluescompleted.contains(principal) || _insertedvaluespending.contains(principal)) {	return true;	}	if (_removedvaluescompleted.contains(principal) || _removedvaluespending.contains(principal)) {	
principalcollection containsnativetest found remove 

private bool containsnativetest(principal principal) {	checkdisposed();	if (principal == null) throw new argumentnullexception("principal");	if (_insertedvaluescompleted.contains(principal) || _insertedvaluespending.contains(principal)) {	return true;	}	if (_removedvaluescompleted.contains(principal) || _removedvaluespending.contains(principal)) {	return false;	}	if (_clearpending || _clearcompleted) {	
principalcollection containsnativetest clear pending 

if (_insertedvaluescompleted.contains(principal) || _insertedvaluespending.contains(principal)) {	return true;	}	if (_removedvaluescompleted.contains(principal) || _removedvaluespending.contains(principal)) {	return false;	}	if (_clearpending || _clearcompleted) {	return false;	}	if (_owninggroup.unpersisted == false && principal.unpersisted == false) return _owninggroup.getstorectxtouse().ismemberofinstore(_owninggroup, principal);	
principalcollection containsnativetest no store to check 

public bool contains(principal principal) {	storectx storectxtouse = _owninggroup.getstorectxtouse();	if ((storectxtouse != null) && (storectxtouse.supportsnativemembershiptest)) {	globaldebug.writelineif(globaldebug.info, "principalcollection", "contains: using native test (store ctx is null = {0})", (storectxtouse == null));	return containsnativetest(principal);	}	else {	
principalcollection contains using enum test 

========================= corefx sample_8990 =========================

protected void translatesids(string target, intptr[] psids) {	
authzset sidlist processing sids 

pcurrentname = new intptr(pcurrentname.toint64() + marshal.sizeof(typeof(unsafenativemethods.lsa_translated_name)));	}	unsafenativemethods.lsa_referenced_domain_list referenceddomains = (unsafenativemethods.lsa_referenced_domain_list)marshal.ptrtostructure(pdomains, typeof(unsafenativemethods.lsa_referenced_domain_list));	int domaincount = referenceddomains.entries;	domains = new unsafenativemethods.lsa_trust_information[domaincount];	intptr pcurrentdomain = referenceddomains.domains;	for (int i = 0; i < domaincount; i++) {	domains[i] = (unsafenativemethods.lsa_trust_information)marshal.ptrtostructure(pcurrentdomain, typeof(unsafenativemethods.lsa_trust_information));	pcurrentdomain = new intptr(pcurrentdomain.toint64() + marshal.sizeof(typeof(unsafenativemethods.lsa_trust_information)));	}	
authzset sidlist got groups in domains 

========================= corefx sample_9031 =========================

private void tmexceptiontesthelper(taskscheduler tm, string tminvalidmessage) {	if (_tasktype != tasktype.promise) {	if (_tasktype != tasktype.future) {	try {	_task = createtaskhelper();	_task.start(tm);	assert.true(false, string.format("able to pass {0} taskmanager to start() on {1}, when expecting exception", tminvalidmessage, _tasktype));	}	catch (argumentnullexception) {	
null exception argumentnullexception throws as expected when trying to pass taskmanager to start on 

if (_tasktype != tasktype.future) {	try {	_task = createtaskhelper();	_task.start(tm);	assert.true(false, string.format("able to pass {0} taskmanager to start() on {1}, when expecting exception", tminvalidmessage, _tasktype));	}	catch (argumentnullexception) {	else throw;	}	catch (invalidoperationexception) {	
disposed exception invalidoperationexception throws as expected when trying to pass taskmanager to start on 

}	}	try {	cancellationtoken token = new cancellationtoken();	if (_tasktype == tasktype.task) _task = task.factory.startnew(work, token, taskcreationoptions.none, tm);	else if (_tasktype == tasktype.futuret) _task = task<double>.factory.startnew(futurework, token, taskcreationoptions.none, tm);	else if (_tasktype == tasktype.future) _task = task.factory.startnew<double>(futurework, token, taskcreationoptions.none, tm);	assert.true(false, string.format("able to pass {0} taskmanager to startnew() on {1}, when expecting exception", tminvalidmessage, _tasktype));	}	catch (argumentnullexception) {	
null exception argumentnullexception throws as expected when trying to pass taskmanager to startnew on 

cancellationtoken token = new cancellationtoken();	if (_tasktype == tasktype.task) _task = task.factory.startnew(work, token, taskcreationoptions.none, tm);	else if (_tasktype == tasktype.futuret) _task = task<double>.factory.startnew(futurework, token, taskcreationoptions.none, tm);	else if (_tasktype == tasktype.future) _task = task.factory.startnew<double>(futurework, token, taskcreationoptions.none, tm);	assert.true(false, string.format("able to pass {0} taskmanager to startnew() on {1}, when expecting exception", tminvalidmessage, _tasktype));	}	catch (argumentnullexception) {	else throw;	}	catch (invalidoperationexception) {	
disposed exception invalidoperationexception throws as expected when trying to pass taskmanager to startnew on 

double actualresult = 0;	switch (_tasktype) {	case tasktype.task: actualresult = _result;	break;	case tasktype.futuret: case tasktype.future: actualresult = ((task<double>)_task).result;	break;	default: throw new notsupportedexception("mismatch type, " + _tasktype + " doesn't have value that can be verified");	}	double minlimit = 1.63;	double maxlimit = 1.65;	
result matched 

========================= corefx sample_4028 =========================

public int v() {	string type = curvariation.params[0].tostring();	
test type 

string type = curvariation.params[0].tostring();	reloadsource(new stringreader(_xmlstr));	datareader.positiononelement("root");	switch (type) {	case "nns": datareader.readtodescendant("elem");	datareader.readtonextsibling("elem");	if (datareader.hasattributes) {	cerror.compare(datareader.getattribute("att"), "1", "not the expected attribute");	}	else {	
positioned on wrong element 

dumpstat();	return test_fail;	}	while (datareader.read()) ;	datareader.close();	return test_pass;	case "dns": datareader.readtodescendant("elem", "elem");	datareader.readtonextsibling("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("att") == null) {	
positioned on wrong element not on dns 

datareader.close();	return test_pass;	case "dns": datareader.readtodescendant("elem", "elem");	datareader.readtonextsibling("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("att") == null) {	return test_fail;	}	}	else {	
positioned on wrong element 

dumpstat();	return test_fail;	}	while (datareader.read()) ;	datareader.close();	return test_pass;	case "ns": datareader.readtodescendant("e:elem");	datareader.readtonextsibling("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on dns 

datareader.close();	return test_pass;	case "ns": datareader.readtodescendant("e:elem");	datareader.readtonextsibling("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	return test_fail;	}	}	else {	
positioned on wrong element 

public int v3() {	string type = curvariation.params[0].tostring();	string xml = curvariation.params[1].tostring();	
test type 

public int v16() {	reloadsource(new stringreader("<root><e/></root>"));	datareader.read();	try {	datareader.readtonextsibling(null);	}	catch (argumentnullexception) {	
caught for single param 

datareader.read();	try {	datareader.readtonextsibling(null);	}	catch (argumentnullexception) {	}	try {	datareader.readtonextsibling("e", null);	}	catch (argumentnullexception) {	
caught for single param 

========================= corefx sample_12385 =========================

private static void testxml2text(bool sync, bool oldtypes, int paramlen, bool nvarchar) {	testtextwrite(xmlstr, xmlreader.create(new stringreader(xmlstr)), sync, oldtypes, paramlen, nvarchar, false, false);	
sync paramlen nvarchar old is ok 

private static void immediatecancelbin() {	
test immediate cancel for binary stream 

rand.nextbytes(data);	memorystream ms = new memorystream(data, false);	cmd.commandtext = "insert into #blobs (id, blob) values (1, @blob)";	cmd.parameters.add("@blob", sqldbtype.varbinary, datasize);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = ms;	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	
fail expected aggregateexception on task wait for cancelled task 

rand.nextbytes(data);	memorystream ms = new memorystream(data, false);	cmd.commandtext = "insert into #blobs (id, blob) values (1, @blob)";	cmd.parameters.add("@blob", sqldbtype.varbinary, datasize);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = ms;	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	
t status 

cmd.parameters.add("@blob", sqldbtype.varbinary, datasize);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = ms;	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	}	catch (aggregateexception ae) {	if (ae.innerexception is invalidoperationexception) {	
pass task is cancelled 

private static void immediatecanceltext() {	
test immediate cancel for text stream 

stringbuilder sb = new stringbuilder();	for (int i = 0; i < 1000000; i++) sb.append(i);	cmd.commandtext = "insert into #blobs (id, blob) values (1, @blob)";	cmd.parameters.add("@blob", sqldbtype.varchar, -1);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = new stringreader(sb.tostring());	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	
fail expected aggregateexception on task wait for cancelled task 

stringbuilder sb = new stringbuilder();	for (int i = 0; i < 1000000; i++) sb.append(i);	cmd.commandtext = "insert into #blobs (id, blob) values (1, @blob)";	cmd.parameters.add("@blob", sqldbtype.varchar, -1);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = new stringreader(sb.tostring());	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	
t status 

cmd.parameters.add("@blob", sqldbtype.varchar, -1);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = new stringreader(sb.tostring());	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	}	catch (aggregateexception ae) {	if (ae.innerexception is invalidoperationexception) {	
pass task is cancelled 

private static void immediatecancelxml() {	
test immediate cancel for xml stream 

cmd.commandtext = "create table #blobs (id int, blob xml)";	cmd.executenonquery();	cmd.commandtext = "insert into #blobs (id, blob) values (1, @blob)";	cmd.parameters.add("@blob", sqldbtype.xml, -1);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = xmlreader.create(new stringreader(xmlstr));	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	
fail expected aggregateexception on task wait for cancelled task 

cmd.commandtext = "create table #blobs (id int, blob xml)";	cmd.executenonquery();	cmd.commandtext = "insert into #blobs (id, blob) values (1, @blob)";	cmd.parameters.add("@blob", sqldbtype.xml, -1);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = xmlreader.create(new stringreader(xmlstr));	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	
t status 

cmd.parameters.add("@blob", sqldbtype.xml, -1);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = xmlreader.create(new stringreader(xmlstr));	task t = cmd.executenonqueryasync(cts.token);	if (!t.iscompleted) cts.cancel();	try {	t.wait();	}	catch (aggregateexception ae) {	if (ae.innerexception is invalidoperationexception) {	
pass task is cancelled 

cmd.commandtext = "insert into #blobs (id, blob) values (1, @blob)";	cmd.parameters.add("@blob", sqldbtype.varbinary, datasize);	cmd.parameters["@blob"].direction = parameterdirection.input;	cmd.parameters["@blob"].value = ms;	cmd.prepare();	cmd.executenonquery();	conn.close();	ms.close();	}	}	
pass 

private static void commandreuse() {	foreach (var func in new func<sqlcommand, cancellationtoken, task>[] {	(cmd,token) => cmd.executenonqueryasync(token), (cmd,token) => cmd.executereaderasync(token), (cmd,token) => cmd.executexmlreaderasync(token) }) {	cancellationtokensource cts = new cancellationtokensource();	using (sqlconnection conn = new sqlconnection(s_connstr)) {	conn.openasync().wait();	
test reuse of command after cancel 

task t = func(cmd, cts.token);	if (!t.iscompleted) {	cts.cancel();	}	try {	t.wait();	throw new exception("expected aggregateexception on task wait for cancelled task!");	}	catch (aggregateexception ae) {	if(!ae.innerexception.message.contains("operation cancelled by user.")) {	
unexpected exception message 

========================= corefx sample_11089 =========================

return bpassed;	}	catch (notsupportedexception) {	return true;	}	}	try {	datareader.readvaluechunk(buffer, iindex, icount);	}	catch (exception e) {	
actual exception 

return bpassed;	}	catch (notsupportedexception) {	return true;	}	}	try {	datareader.readvaluechunk(buffer, iindex, icount);	}	catch (exception e) {	
expected exception 

}	int nchars;	try {	nchars = datareader.readvaluechunk(buffer, strexpected.length, 3);	}	catch (argumentexception) {	cerror.compare(datareader.readvaluechunk(buffer, 0, buffer.length), strexpected.length, "readvalue count");	cerror.compare(new string(buffer), strexpected, "str");	return test_pass;	}	
couldn t read after argumentexception 

if (!isfactoryreader()) return test_skipped;	string xml = @"<root a1='12345' a2='value'/>";	reloadsource(new stringreader(xml));	char[] buffer = new char[10];	cerror.compare(datareader.read(), "read");	cerror.compare(datareader.movetonextattribute(), "movetonextattribute");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), "2", "buffer1");	cerror.compare(buffer[2].tostring(), "3", "buffer1");	
linenumber 

if (!isfactoryreader()) return test_skipped;	string xml = @"<root a1='12345' a2='value'/>";	reloadsource(new stringreader(xml));	char[] buffer = new char[10];	cerror.compare(datareader.read(), "read");	cerror.compare(datareader.movetonextattribute(), "movetonextattribute");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), "2", "buffer1");	cerror.compare(buffer[2].tostring(), "3", "buffer1");	
lineposition 

cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), "2", "buffer1");	cerror.compare(buffer[2].tostring(), "3", "buffer1");	cerror.compare(datareader.movetonextattribute(), "movetonextattribute");	cerror.compare(datareader.movetofirstattribute(), "movetofirstattribute");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer2");	cerror.compare(buffer[1].tostring(), "2", "buffer2");	cerror.compare(buffer[2].tostring(), "3", "buffer2");	
linenumber 

cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), "2", "buffer1");	cerror.compare(buffer[2].tostring(), "3", "buffer1");	cerror.compare(datareader.movetonextattribute(), "movetonextattribute");	cerror.compare(datareader.movetofirstattribute(), "movetofirstattribute");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer2");	cerror.compare(buffer[1].tostring(), "2", "buffer2");	cerror.compare(buffer[2].tostring(), "3", "buffer2");	
lineposition 

string xml = @"<?xml version='1.0'?><root/>";	reloadsource(new stringreader(xml));	char[] buffer = new char[10];	cerror.compare(datareader.read(), "read");	cerror.compare(datareader.movetofirstattribute(), "movetofirstattribute");	cerror.compare(datareader.name, "version", "name");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), ".", "buffer1");	cerror.compare(buffer[2].tostring(), "0", "buffer1");	
linenumber 

string xml = @"<?xml version='1.0'?><root/>";	reloadsource(new stringreader(xml));	char[] buffer = new char[10];	cerror.compare(datareader.read(), "read");	cerror.compare(datareader.movetofirstattribute(), "movetofirstattribute");	cerror.compare(datareader.name, "version", "name");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), ".", "buffer1");	cerror.compare(buffer[2].tostring(), "0", "buffer1");	
lineposition 

cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), ".", "buffer1");	cerror.compare(buffer[2].tostring(), "0", "buffer1");	cerror.compare(datareader.movetoelement(), "movetoelement");	cerror.compare(datareader.movetofirstattribute(), "movetofirstattribute");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer2");	cerror.compare(buffer[1].tostring(), ".", "buffer2");	cerror.compare(buffer[2].tostring(), "0", "buffer2");	
linenumber 

cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer1");	cerror.compare(buffer[1].tostring(), ".", "buffer1");	cerror.compare(buffer[2].tostring(), "0", "buffer1");	cerror.compare(datareader.movetoelement(), "movetoelement");	cerror.compare(datareader.movetofirstattribute(), "movetofirstattribute");	cerror.compare(datareader.readvaluechunk(buffer, 0, 3), 3, "error");	cerror.compare(buffer[0].tostring(), "1", "buffer2");	cerror.compare(buffer[1].tostring(), ".", "buffer2");	cerror.compare(buffer[2].tostring(), "0", "buffer2");	
lineposition 

public int readvaluechunkworksproperlywithsubtreereaderinsertedattributes() {	if (!isfactoryreader()) return test_skipped;	string xml = "<root xmlns='foo'><bar/></root>";	reloadsource(new stringreader(xml));	datareader.read();	datareader.read();	using (xmlreader sr = datareader.readsubtree()) {	sr.read();	sr.movetofirstattribute();	
value 

========================= corefx sample_12394 =========================

public principalsearchresult<principal> getmembers(bool recursive) {	checkdisposedordeleted();	if (!this.unpersisted) {	globaldebug.writelineif(globaldebug.info, "group", "getmembers: persisted, querying for members (recursive={0}", recursive);	return new principalsearchresult<principal>(contextraw.queryctx.getgroupmembership(this, recursive));	}	else {	
group getmembers unpersisted creating empty principalsearchresult 

public override void dispose() {	try {	if (!_disposed) {	
group dispose disposing 

========================= corefx sample_9020 =========================

public virtual void process(ilinstruction ilinstruction, string operandstring) {	
il 

public override void process(ilinstruction ilinstruction, string operandstring) {	
il 

========================= corefx sample_2657 =========================

private void dispose(bool disposing) {	if (_handle != intptr.zero) {	#if finalization_watch if (!disposing) {	
disposed through finalization 

========================= corefx sample_10373 =========================

public void asciiencoding() {	
verifying read with bytes encoded with asciiencoding 

public void utf8encoding() {	
verifying read with bytes encoded with 

public void utf32encoding() {	
verifying read with bytes encoded with 

========================= corefx sample_612 =========================

w.writeentityref("ent");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writeentityref("ent");	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writeentityref("ent");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writeentityref("ent");	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writecharentity('\ud23e');	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writecharentity('\ud23e');	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writecharentity('\ud23e');	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writecharentity('\ud23e');	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writestartattribute("attr", "");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writestartattribute("attr", "");	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writestartattribute("attr", "");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writestartattribute("attr", "");	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writecdata("invalid");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writecdata("invalid");	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writecdata("invalid");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writecdata("invalid");	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writestartdocument();	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writestartdocument();	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

w.writedoctype("test", null, null, "");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "error");	try {	w.writedoctype("test", null, null, "");	}	catch (invalidoperationexception) { return; }	}	}	
did not throw exception 

========================= corefx sample_11580 =========================

public void newline_crlf_crstr() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with newline and a string containing just 

public void newline_crlf_lfstr() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with newline and a string containing just 

public void greedyread() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(128, tcsupport.characteroptions.surrogates);	var bytexmitbuffer = new byte[1024];	char[] expectedchars;	string rcvstring;	char[] actualchars;	char utf32char = tcsupport.generaterandomcharnonsurrogate();	byte[] utf32charbytes = encoding.utf32.getbytes(new char[] { utf32char });	int numbytes;	
verifying that readline will read everything from internal buffer and drivers buffer 

public void newlinesubstring() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with sub strings of the new line appearing in the string being read 

public void read_datareceivedbeforetimeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	var asyncread = new asyncread(com1);	var asyncreadtask = new task(asyncread.read);	char endlinechar = com1.newline[0];	char notendlinechar = tcsupport.getrandomotherchar(endlinechar, tcsupport.characteroptions.none);	
verifying that read char int int will read characters that have been received after the call to read was made 

public void read_timeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	char endchar = com1.newline[0];	char notendchar = tcsupport.getrandomotherchar(endchar, tcsupport.characteroptions.none);	
verifying that readline string works appropriately after timeoutexception has been thrown 

public void read_surrogatecharacter() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying read method with surrogate pair in the input and a surrogate pair for the newline 

========================= corefx sample_643 =========================

public ienumerator<t> getenumerator() {	
principalsearchresult entering getenumerator 

public void dispose() {	if (!_disposed) {	
principalsearchresult dispose disposing 

public void dispose() {	if (!_disposed) {	if (_resultset != null) {	
principalsearchresult dispose disposing resultset 

private void checkdisposed() {	if (_disposed) {	
principalsearchresult checkdisposed accessing disposed object 

========================= corefx sample_8972 =========================

public unsafe static void binarysearch_maxlength_nooverflow() {	if (sizeof(intptr) == sizeof(long)) {	var length = int.maxvalue;	if (!allocationhelper.tryallocnative(new intptr(length), out intptr memory)) {	
span binarysearch test nameof binarysearch maxlength nooverflow skipped could not alloc memory 

========================= corefx sample_7499 =========================

public void pinchangedevent_ctschanged() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler eventhandler = new pinchangedeventhandler(com1);	
verifying ctschanged event 

public void pinchangedevent_ctschanged() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler eventhandler = new pinchangedeventhandler(com1);	com1.pinchanged += eventhandler.handleevent;	com1.open();	com2.open();	for (int i = 0; i < num_trys; i++) {	
verifying when rtsenable set to true on remote port try 

public void pinchangedevent_dsrchanged() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler eventhandler = new pinchangedeventhandler(com1);	eventhandler.eventfilter = eventtype => eventtype != serialpinchange.cdchanged;	
verifying dsrchanged event 

public void pinchangedevent_dsrchanged() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler eventhandler = new pinchangedeventhandler(com1);	eventhandler.eventfilter = eventtype => eventtype != serialpinchange.cdchanged;	com1.pinchanged += eventhandler.handleevent;	com1.open();	com2.open();	for (int i = 0; i < num_trys; i++) {	
verifying when dtrenable set to true on remote port 

public void pinchangedevent_break() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler eventhandler = new pinchangedeventhandler(com1);	
verifying break event 

public void pinchangedevent_break() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler eventhandler = new pinchangedeventhandler(com1);	com1.pinchanged += eventhandler.handleevent;	com1.open();	com2.open();	for (int i = 0; i < num_trys; i++) {	
verifying when break set to true on remote port try 

public void pinchangedevent_multiple() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	pinchangedeventhandler eventhandler = new pinchangedeventhandler(com1);	eventhandler.eventfilter = eventtype => eventtype != serialpinchange.cdchanged;	serialpinchangedeventhandler pinchangedeventhandler = eventhandler.handleevent;	
verifying multiple pinchangedevents 

========================= corefx sample_677 =========================

private async task connecttohostasync(tcpclient tcp) {	string hostname = null;	if (_options.remoteendpoint is dnsendpoint) {	var dns = (dnsendpoint)_options.remoteendpoint;	hostname = dns.host;	
client connecting to 

private async task connecttohostasync(tcpclient tcp) {	string hostname = null;	if (_options.remoteendpoint is dnsendpoint) {	var dns = (dnsendpoint)_options.remoteendpoint;	hostname = dns.host;	await tcp.connectasync(hostname, dns.port).configureawait(false);	}	else {	var ip = (ipendpoint)_options.remoteendpoint;	hostname = ip.address.tostring();	
client connecting to 

========================= corefx sample_4421 =========================

public void readwithoutopen() {	using (serialport com = new serialport()) {	
verifying read method throws exception without a call to open 

public void readafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read method throws exception with a failed call to open 

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void parityerroronlastbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(15);	byte[] bytestowrite = new byte[numrndbytespairty];	char[] expectedchars = new char[numrndbytespairty];	
verifying default parityreplace byte with a parity errro on the last byte 

byte randbyte = (byte)rndgen.next(0, 256);	bytestowrite[i] = randbyte;	}	char[] expectedchars = encoding.getchars(bytestowrite, 0, bytestowrite.length);	for (int i = 0; i < numnewlines; i++) {	int newlineindex;	newlineindex = rndgen.next(0, numbytesread);	bytestowrite[newlineindex] = (byte)'\n';	expectedchars[newlineindex] = (char)'\n';	}	
verifying bytestoread with a buffer of 

========================= corefx sample_626 =========================

public bool comparereader(xdocument doc, string expectedxml) {	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.auto;	rs.dtdprocessing = dtdprocessing.ignore;	rs.closeinput = true;	_diff.option = xmldiffoption.ignoreattributeorder;	using (xmlreader r1 = doc.createreader()) using (xmlreader r2 = xmlreader.create(new stringreader(expectedxml), rs)) {	if (!_diff.compare(r1, r2)) {	
mismatch expected actual 

public bool comparereader(xmlreader r1, string expectedxml) {	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.auto;	rs.closeinput = true;	_diff.option = xmldiffoption.ignoreattributeorder;	using (xmlreader r2 = xmlreader.create(new stringreader(expectedxml), rs)) {	if (!_diff.compare(r1, r2)) {	
mismatch expected actual 

public bool comparebaseline(xdocument doc, string baselinefile) {	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.auto;	rs.dtdprocessing = dtdprocessing.ignore;	rs.closeinput = true;	_diff.option = xmldiffoption.ignoreattributeorder;	using (xmlreader r1 = xmlreader.create(filepathutil.getstream(fullpath(baselinefile)), rs)) using (xmlreader r2 = doc.createreader()) {	if (!_diff.compare(r1, r2)) {	
mismatch expected actual 

break;	default: testlog.compare(false, "unexpected method name " + methodname);	break;	}	}	catch (exception e) {	if (exceptiontype.equals(e.gettype())) {	return;	}	else {	
did not throw exception of type 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	
nodetype doesn t match 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	
expected nodetype 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	
actual nodetype 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	bpassed = false;	}	if (r.name != strexpname) {	
name doesn t match 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	bpassed = false;	}	if (r.name != strexpname) {	
expected name 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	bpassed = false;	}	if (r.name != strexpname) {	
actual name 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	bpassed = false;	}	if (r.name != strexpname) {	bpassed = false;	}	if (r.value != strexpvalue) {	
value doesn t match 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	bpassed = false;	}	if (r.name != strexpname) {	bpassed = false;	}	if (r.value != strexpvalue) {	
expected value 

public static bool verifynode(xmlreader r, xmlnodetype eexpnodetype, string strexpname, string strexpvalue) {	bool bpassed = true;	if (r.nodetype != eexpnodetype) {	bpassed = false;	}	if (r.name != strexpname) {	bpassed = false;	}	if (r.value != strexpvalue) {	
actual value 

public void difftwoxmlstrings(string source, string target) {	_diff.option = xmldiffoption.ignoreattributeorder;	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.fragment;	xmlreader src = xmlreader.create(new stringreader(source), rs);	xmlreader tgt = xmlreader.create(new stringreader(target), rs);	bool retval = _diff.compare(src, tgt);	if (!retval) {	
xmldif failed 

public void difftwoxmlstrings(string source, string target) {	_diff.option = xmldiffoption.ignoreattributeorder;	xmlreadersettings rs = new xmlreadersettings();	rs.conformancelevel = conformancelevel.fragment;	xmlreader src = xmlreader.create(new stringreader(source), rs);	xmlreader tgt = xmlreader.create(new stringreader(target), rs);	bool retval = _diff.compare(src, tgt);	if (!retval) {	
diff 

public static void createbytetestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
x 

public static void createutf8encodedtestfile(string strfilename, encoding encode) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename), encode);	
root 

public static void createutf8encodedtestfile(string strfilename, encoding encode) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename), encode);	tw.write("�");	
root 

public static void createencodedtestfile(string strfilename, encoding encode) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename), encode);	
root 

public static void createencodedtestfile(string strfilename, encoding encode) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename), encode);	
root 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
doctype dt 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
element pcdata 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
element pcdata 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
element pcdata 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("]>");	
doc 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("]>");	
elem 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("]>");	
elem 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("]>");	
elem 

public static void createwhitespacehandlingtestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("]>");	
doc 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	
first processing instruction 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
doctype root system 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
notation gif system 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element root any 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element any 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element isdefault any 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity e system 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
e 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
entity 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist cdata implied cdata cdata required 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist root xmlns something cdata fixed xmlns my cdata fixed xmlns dt cdata fixed 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist isdefault cdata fixed 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
attlist multispaces att idrefs implied 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	
element catmixed pcdata 

public static void creategenerictestfile(string strfilename) {	filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	
play 

filepathutil.addstream(strfilename, new memorystream());	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"&e2;\" child3=\"something\">");	
text node two text node three 

tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"&e2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("&e2;");	
cdata this section contains characters that should not be interpreted as markup for example characters 

tw.writeline("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>");	tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"&e2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("&e2;");	
and are all fine here 

tw.writeline("<!-- comment1 -->");	tw.writeline("<?pi1a?>");	tw.writeline("<?pi1b?>");	tw.writeline("<?pi1c?>");	tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"&e2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("&e2;");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	
a 

tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"&e2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("&e2;");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	
this is a 

tw.writeline("]>");	tw.writeline("<root xmlns:something=\"something\" xmlns:my=\"my\" xmlns:dt=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">");	tw.writeline("<elem1 child1=\"\" child2=\"&e2;\" child3=\"something\">");	tw.writeline("</elem1>");	tw.writeline("&e2;");	tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	
a 

tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("&e3;");	tw.writeline("&e4;");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
b 

tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("&e3;");	tw.writeline("&e4;");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
this is b 

tw.writeline("<elem2 att1=\"id1\" att2=\"up\" att3=\"attribute3\"> ");	tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("&e3;");	tw.writeline("&e4;");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	
b 

tw.writeline("</elem2>");	tw.writeline("<elem2> ");	tw.writeline("elem2-text1");	tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("&e3;");	tw.writeline("&e4;");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	tw.writeline("elem2-text4");	
pi pi 

tw.writeline("<a refs=\"id2\"> ");	tw.writeline("elem2-text2");	tw.writeline("&e3;");	tw.writeline("&e4;");	tw.writeline("<!-- elem2-comment1-->");	tw.writeline("elem2-text3");	tw.writeline("elem2-text4");	tw.writeline("elem2-text5");	tw.writeline("</elem2>");	tw.writeline("<elem2 att1=\"id2\"></elem2>");	
root 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
a b 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
comm ent 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
cdata cd ata 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
x x 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
x x 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
x x 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
elem 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
elem 

tw.write("<entity1 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity1>");	tw.writeline("<entity2 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity2>");	tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	
elem 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	
xxx yyy 

tw.writeline("<entity3 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity3>");	tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	
xxx 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
xxx markup yyy 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx markup yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars markup yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx markup chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx cdata yyy zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars cdata yyy zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx cdata yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx pi yyy zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars pi zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx pi yyy chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars zzz chars 

tw.writeline("<entity4 att1='xxx&lt;xxx&#65;xxx&#x43;xxx&e1;xxx'>xxx&gt;xxx&#66;xxx&#x44;xxx&e1;xxx</entity4>");	tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	
chars xxx chars 

tw.writeline("<entity5>&ext3;</entity5>");	tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	
isdefault 

tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	
true 

tw.writeline("<attribute1 />");	tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	
false 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
true 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
datetime datetime 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
date date 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
time time 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
integer integer 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
float float 

tw.writeline("<attribute2 a1='a1value' />");	tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	
decimal decimal 

tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	
title this is a comment title 

tw.writeline("<attribute3 a1='a1value' a2='a2value' a3='a3value' />");	tw.writeline("<attribute4 a1='' />");	tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	
pgroup 

tw.writeline("<attribute5 crlf='x\r\nx' cr='x\rx' lf='x\nx' ms='x     x' tab='x\tx' />");	tw.writeline("<skip1 /><afterskip1 />");	tw.writeline("<skip2></skip2><afterskip2 />");	tw.writeline("<chars1>0123456789</chars1>");	tw.flush();	tw.writeline("<isdefault a1='a1value' />");	tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	
persona dromio of ephesus persona 

tw.writeline("<boolean3>1</boolean3>");	tw.writeline("<content><e1 a1='a1value' a2='a2value'><e2 a1='a1value' a2='a2value'><e3 a1='a1value' a2='a2value'>leave</e3></e2></e1></content>");	tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	
abcde 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
grpdescr twin brothers and sons to aegeon and aemilia grpdescr 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
pgroup 

tw.writeline("<act0 xmlns:foo=\"http: tw.writeline("<act1 attr0=\'0\' attr1=\'1111111101\' attr2=\'222222202\' attr3=\'333333303\' attr4=\'444444404\' attr5=\'555555505\' attr6=\'666666606\' attr7=\'777777707\' attr8=\'888888808\' attr9=\'999999909\' />");	tw.writeline("<quote1 attr0=\"0\" attr1=\'1111111101\' attr2=\"222222202\" attr3=\'333333303\' />");	tw.writeline("<quote2 attr0=\"0\" attr1=\"1111111101\" attr2=\'222222202\' attr3=\'333333303\' />");	tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	
pgroup 

tw.writeline("<quote3 attr0=\'0\' attr1=\"1111111101\" attr2=\'222222202\' attr3=\"333333303\" />");	tw.writeline("<empty1 />");	tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color &e1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	
noxmllang 

tw.writeline("<empty2 val=\"abc\" />");	tw.writeline("<empty3></empty3>");	tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color &e1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	
donexmllang 

tw.writeline("<nonempty0></nonempty0>");	tw.writeline("<nonempty2 val=\"abc\">1234</nonempty2>");	tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color &e1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	
nospace 

tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color &e1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
grpdescr twin brothers and attendants on the two antipholuses grpdescr 

tw.writeline("<act2 attr0=\"10\" attr1=\"1111111011\" attr2=\"222222012\" attr3=\"333333013\" attr4=\"444444014\" attr5=\"555555015\" attr6=\"666666016\" attr7=\"777777017\" attr8=\"888888018\" attr9=\"999999019\" />");	tw.flush();	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color &e1; is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><!-- comment--><b><?pi1a?><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
docnamespace 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
docnamespace 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
pgroup 

tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	
gotocontent some text cdata cdata info gotocontent 

tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<empty_namespace2 attr0=\"0\" xmlns=\"14\"></empty_namespace2>");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><empty100 /><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<nonamespace1 attr1=\"one\" xmlns=\"1000\">namespace=\"\"</nonamespace1>");	tw.writeline("<skipcontent att1=\"\">  <!-- comment1--> \n <?pi_skipcontent instruction?></skipcontent>");	
mixcontent some text pi skipcontent instruction cdata cdata info mixcontent 

tw.writeline("</j8>89</i8>88</h8>87</g8>86</f8>85</e8>84</d8>83</c8>82</b8>81</a8>");	tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	
complex text comment cdata cdata complex 

tw.writeline("</j8>89</i8>88</h8>87</g8>86</f8>85</e8>84</d8>83</c8>82</b8>81</a8>");	tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	
dummy 

tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	
cat ab cdata cd cat 

tw.writeline("</j7>79</i7>78</h7>77</g7>76</f7>75</e7>74</d7>73</c7>72</b7>71</a7>");	tw.writeline("</j6>69</i6>68</h6>67</g6>66</f6>65</e6>64</d6>63</c6>62</b6>61</a6>");	tw.writeline("</j5>59</i5>58</h5>57</g5>56</f5>55</e5>54</d5>53</c5>52</b5>51</a5>");	tw.writeline("</j4>49</i4>48</h4>47</g4>46</f4>45</e4>44</d4>43</c4>42</b4>41</a4>");	tw.writeline("</j3>39</i3>38</h3>37</g3>36</f3>35</e3>34</d3>33</c3>32</b3>31</a3>");	tw.writeline("</j2>29</i2>28</h2>27</g2>26</f2>25</e2>24</d2>23</c2>22</b2>21</a2>");	tw.writeline("</j1>19</i1>18</h1>17</g1>16</f1>15</e1>14</d1>13</c1>12</b1>11</a1>");	tw.write("</j>9</i>8</h>7</g>6</f>5</e>4</d>3</c>2</b>1</a>");	tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	
catmixed ab cdata cd catmixed 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
element pcdata a b 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
element a any 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
element b any 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
element c any 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
attlist 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
id implied 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
cdata implied 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
cdata implied 

tw.writeline("<empty4 val=\"abc\"></empty4>");	tw.writeline("<multispaces att=' \r\n \t \r\r\n  n1  \r\n \t \r\r\n  n2  \r\n \t \r\r\n ' />");	tw.writeline("<validxmllang0 xml:lang=\"a\" />");	tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	
attlist a refs idrefs implied 

tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	twdtd.flush();	filepathutil.addstream("allnodetypes.ent", new memorystream());	textwriter twent = new streamwriter(filepathutil.getstream("allnodetypes.ent"));	
element foo any 

tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	twdtd.flush();	filepathutil.addstream("allnodetypes.ent", new memorystream());	textwriter twent = new streamwriter(filepathutil.getstream("allnodetypes.ent"));	
entity 

tw.writeline("<validxmllang1 xml:lang=\"\" />");	tw.writeline("<validxmllang2 xml:lang=\"ab-cd-\" />");	tw.writeline("<validxmllang3 xml:lang=\"a b-cd\" />");	tw.write("</play>");	tw.flush();	filepathutil.addstream("allnodetypes.dtd", new memorystream());	textwriter twdtd = new streamwriter(filepathutil.getstream("allnodetypes.dtd"));	twdtd.flush();	filepathutil.addstream("allnodetypes.ent", new memorystream());	textwriter twent = new streamwriter(filepathutil.getstream("allnodetypes.ent"));	
entity 

public static void createinvalidxmlxdrtestfile(string strfilename) {	createxdrtestfile(pvalidxdr);	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?><e:root xmlns:e=\"x-schema:xdrfile.xml\">");	
e element e e root 

public static void createxdrtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<schema xmlns=\"uuid:bdc6e3f0-6da3-11d1-a2a3-00aa00c14882\"><elementtype content=\"empty\" name=\"tt\"></elementtype>");	tw.writeline("<elementtype content=\"eltonly\" order=\"seq\" name=\"bar\" model=\"closed\"><element type=\"tt\" /><element type=\"tt\" /></elementtype>");	
schema 

public static void createnamespacetestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
docnamespace 

tw.writeline("<namespace0 xmlns:bar=\"1\"><bar:check>namespace=1</bar:check></namespace0>");	tw.writeline("<namespace1 xmlns:bar=\"1\"><a><b><c><d><bar:check>namespace=1</bar:check></d></c></b></a></namespace1>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	tw.writeline("<empty_namespace bar:attr0=\"0\" xmlns:bar=\"1\" />");	tw.writeline("<empty_namespace1 attr0=\"0\" xmlns=\"14\" />");	tw.writeline("<namespace2 xmlns:bar=\"1\"><a><b><c xmlns:bar=\"2\"><d><bar:check>namespace=2</bar:check></d></c></b></a></namespace2>");	tw.writeline("<namespace3 xmlns=\"1\"><a xmlns:a=\"2\" xmlns:b=\"3\" xmlns:c=\"4\"><b xmlns:d=\"5\" xmlns:e=\"6\" xmlns:f='7'><c xmlns:d=\"8\" xmlns:e=\"9\" xmlns:f=\"10\">");	tw.writeline("<d xmlns:g=\"11\" xmlns:h=\"12\"><check>namespace=1</check><testns xmlns=\"100\"><check100>namespace=100</check100></testns><check1>namespace=1</check1><d:check8>namespace=8</d:check8></d></c><d:check5>namespace=5</d:check5></b></a>");	tw.writeline("<a13 a:check=\"namespace=13\" xmlns:a=\"13\" /><check14 xmlns=\"14\">namespace=14</check14></namespace3>");	tw.writeline("<nonamespace>namespace=\"\"</nonamespace>");	
docnamespace 

public static void createxmllangtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
pgroup 

public static void createxmllangtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
persona dromio of ephesus persona 

public static void createxmllangtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
persona dromio of syracuse persona 

public static void createxmllangtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	
noxmllang 

public static void createxmllangtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	
donexmllang 

public static void createxmllangtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>");	tw.write("<xmllang1 xml:lang=\"en-gb\">what color is it?<a><b><c>language test</c><persona>dromio of ephesus</persona></b></a></xmllang1>");	tw.writeline("<empty_xmllang attr0=\"0\" xml:lang=\"en-us\" />");	tw.writeline("<xmllang2 xml:lang=\"en-us\">what color is it?<title><!-- this is a comment--></title><xmllang1 xml:lang=\"en-gb\">testing language<xmllang0 xml:lang=\"en-us\">what color is it?</xmllang0>haha </xmllang1>hihihi</xmllang2>");	
pgroup 

public static void createxmlspacetestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
pgroup 

public static void createxmlspacetestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
persona dromio of ephesus persona 

public static void createxmlspacetestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	
persona dromio of syracuse persona 

public static void createxmlspacetestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><b><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	
nospace 

public static void createxmlspacetestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><b><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
grpdescr twin brothers and attendants on the two antipholuses grpdescr 

public static void createxmlspacetestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xmlspace1 xml:space=\'default\'>&lt; &gt;</xmlspace1>");	tw.write("<xmlspace2 xml:space=\'preserve\'>&lt; &gt;<a><b><c>space test</c><persona>dromio of syracuse</persona></b></a></xmlspace2>");	tw.writeline("<empty_xmlspace attr0=\"0\" xml:space=\'default\' />");	tw.writeline("<xmlspace2a xml:space=\'default\'>&lt; <xmlspace3 xml:space=\'preserve\'>  &lt; &gt; <xmlspace4 xml:space=\'default\'>  &lt; &gt;  </xmlspace4> test </xmlspace3> &gt;</xmlspace2a>");	
pgroup 

public static void createbigelementtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	string str = new string('z', (1 << 20) - 1);	
root 

public static void createbigelementtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	
x 

public static void createbigelementtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	tw.flush();	tw.write("<");	tw.write(str);	
y 

public static void createbigelementtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	string str = new string('z', (1 << 20) - 1);	tw.write("<");	tw.write(str);	tw.flush();	tw.write("<");	tw.write(str);	
root 

public static void createxsltstylesheetwcopytestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http: tw.writeline("<xsl:template match=\"/\">");	tw.writeline("<xsl:copy-of select=\"/\" />");	
xsl template 

public static void createxsltstylesheetwcopytestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http: tw.writeline("<xsl:template match=\"/\">");	tw.writeline("<xsl:copy-of select=\"/\" />");	
xsl stylesheet 

public static void createconstructortestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\"?>");	
root 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	
doctype dt 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	
element root any 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	
entity ext system ext 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	
entity 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	
root 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	
cdata this section contains cdata 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	
charentity ab cd charentity 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	
comment comment node comment 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	
entityref a b c entityref 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	
skip 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
binhex binhex 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
boolxsd true boolxsd 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
boolxdr true boolxdr 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
date date 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
datetime datetime 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
decimal decimal 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
int int 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
time time 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
timespan timespan 

public static void createlinenumbertestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	
abc 

tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	tw.writeline("<sig_whitespace xml:space='preserve'>  </sig_whitespace>");	tw.write("</root>");	tw.flush();	tw.dispose();	filepathutil.addstream("linenumber.ent", new memorystream());	textwriter twent = new streamwriter(filepathutil.getstream("linenumber.ent"));	
entity 

tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	tw.writeline("<sig_whitespace xml:space='preserve'>  </sig_whitespace>");	tw.write("</root>");	tw.flush();	tw.dispose();	filepathutil.addstream("linenumber.ent", new memorystream());	textwriter twent = new streamwriter(filepathutil.getstream("linenumber.ent"));	
entity 

tw.writeline("<?xml version=\"1.0\" ?>");	tw.writeline(" <element a0='a0&e1;v' a1='a1value' a2='a2&e1;v'><embedded /></element>");	tw.writeline("<?pi1?>");	tw.writeline("<base64>9f6hju++</base64>");	tw.writeline("<sig_whitespace xml:space='preserve'>  </sig_whitespace>");	tw.write("</root>");	tw.flush();	tw.dispose();	filepathutil.addstream("linenumber.ent", new memorystream());	textwriter twent = new streamwriter(filepathutil.getstream("linenumber.ent"));	
entity zzz 

public static void createlbnormalizationtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" standalone=\"no\"?>");	
doctype root 

public static void createlbnormalizationtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" standalone=\"no\"?>");	tw.writeline("[");	
entity system 

public static void createlbnormalizationtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" standalone=\"no\"?>");	tw.writeline("[");	
entity pe system 

public static void createlbnormalizationtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" standalone=\"no\"?>");	tw.writeline("[");	
pe 

public static void createlbnormalizationtestfile(string strfilename) {	textwriter tw = new streamwriter(filepathutil.getstream(strfilename));	tw.writeline("<?xml version=\"1.0\" standalone=\"no\"?>");	tw.writeline("[");	tw.writeline("]>");	
root root 

filepathutil.addstream(plbnorment1, new memorystream());	textwriter twent = new streamwriter(filepathutil.getstream(plbnorment1));	twent.writeline("<?xml version=\"1.0\"?>");	twent.writeline("<e1 xml:space=\"preserve\">");	twent.writeline("</e1>");	twent.writeline();	twent.flush();	twent.dispose();	filepathutil.addstream(plbnorment2, new memorystream());	twent = new streamwriter(filepathutil.getstream(plbnorment2));	
entity 

========================= corefx sample_11674 =========================

eresult = etest.result;	switch (eresult) {	case test_pass: case test_skipped: return eresult;	case test_warning: eerrorlevel = tagerrorlevel.hr_warning;	break;	};	}	exception inner = e.innerexception;	cerror.log(actual, expected, e.source, message, e.stacktrace, eerrorlevel);	while (inner != null) {	
inner exception 

========================= corefx sample_4603 =========================

private delegate char[] readmethoddelegate(serialport com);	#region test cases [fact]	public void parityreplace_default_beforeopen() {	using (serialport com1 = new serialport()) {	serialportproperties serportprop = new serialportproperties();	
verifying default parityreplace before open 

public void parityreplace_default_afteropen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default parityreplace after open 

public void read_byte_int_int_rndparityreplace() {	
verifying random parityreplace with read byte int int 

public void read_char_int_int_rndparityreplace() {	
verifying random parityreplace with read char int int 

public void readbyte_rndparityreplace() {	
verifying random parityreplace with readbyte 

public void readchar_rndparityreplace() {	
verifying random parityreplace with readchar 

public void readline_rndparityreplace() {	
verifying random parityreplace with readline 

public void readto_str_rndparityreplace() {	
verifying random parityreplace with readto string 

public void parityreplace_after_parity() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying setting parityreplace after parity has been set 

public void parityreplace_after_parityreplace() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying setting parityreplace after parityreplace has aready been set 

public void parityreplace_after_parityreplaceandparity() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying setting parityreplace after parityreplace and parity have aready been set 

========================= corefx sample_636 =========================

protected abstract void handleerror(int errorcode);	private void cancel() {	safehandle handle = _threadpoolbinding.handle;	nativeoverlapped* overlapped = overlapped;	if (!handle.isinvalid && !interop.kernel32.cancelioex(handle, overlapped)) {	int errorcode = marshal.getlastwin32error();	
cancelioex finished with error code 

========================= corefx sample_3251 =========================

private delegate char[] readmethoddelegate(serialport com);	#region test cases [conditionalfact(nameof(hasnullmodem))]	public void discardnull_default_read_byte_int_int() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with read byte int int 

public void discardnull_default_read_char_int_int() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with read char int int 

public void discardnull_default_readbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with readbyte 

public void discardnull_default_readchar() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with readchar 

public void discardnull_default_readline() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with readline 

public void discardnull_default_readto() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with readto 

public void discardnull_true_read_byte_int_int_before() {	
verifying true discardnull with read byte int int before open 

public void discardnull_true_read_char_int_int_after() {	
verifying true discardnull with read char int int after open 

public void discardnull_true_readbyte_before() {	
verifying true discardnull with readbyte before open 

public void discardnull_true_readchar_after() {	
verifying true discardnull with readchar after open 

public void discardnull_true_readline_before() {	
verifying true discardnull with readline before open 

public void discardnull_true_readto_after() {	
verifying true discardnull with readto after open 

public void discardnull_true_false_read_byte_int_int_before() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with read byte int int 

public void discardnull_true_true_read_char_int_int_after() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with read char int int 

public void discardnull_false_flase_default_readbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default discardnull with readbyte 

========================= corefx sample_667 =========================

public void encoding_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default encoding 

public void encoding_asciiencoding_beforeopen() {	
verifying asciiencoding encoding before open 

public void encoding_utf8encoding_beforeopen() {	
verifying encoding before open 

public void encoding_utf32encoding_beforeopen() {	
verifying encoding before open 

public void encoding_unicodeencoding_beforeopen() {	
verifying unicodeencoding encoding before open 

public void encoding_asciiencoding_afteropen() {	
verifying asciiencoding encoding after open 

public void encoding_utf8encoding_afteropen() {	
verifying encoding after open 

public void encoding_utf32encoding_afteropen() {	
verifying encoding after open 

public void encoding_unicodeencoding_afteropen() {	
verifying unicodeencoding encoding after open 

public void encoding_isciiassemese() {	
verifying isciiassemese encoding 

public void encoding_utf7() {	
verifying encoding 

public void encoding_null() {	
verifying null encoding 

public void encoding_ibm_latin1() {	
verifying ibm latin encoding before open 

public void encoding_japanese_jis() {	
verifying japanese jis encoding before open 

public void encoding_chinesesimplified_gb18030() {	
verifying chinese simplified encoding before open 

========================= corefx sample_653 =========================

public void frag_7(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter(conformancelevel.fragment)) {	try {	w.writedoctype("root", "publicid", "sysid", "<!entity e 'abc'>");	}	catch (invalidoperationexception e) {	
exception 

public void frag_7(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter(conformancelevel.fragment)) {	try {	w.writedoctype("root", "publicid", "sysid", "<!entity e 'abc'>");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void frag_8(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter(conformancelevel.fragment)) {	try {	w.writestartdocument();	}	catch (invalidoperationexception e) {	
exception 

public void frag_8(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter(conformancelevel.fragment)) {	try {	w.writestartdocument();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

========================= corefx sample_12468 =========================

public void cantimeout_open() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying cantimeout property returns true after a call to open 

public void cantimeout_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying cantimeout property retunrs false after open then close 

public void cantimeout_open_close_open() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	com.close();	com.open();	stream serialstream = com.basestream;	
verifying cantimeout property returns false after open then close 

public void cantimeout_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying cantimeout property returns false after open then basestream close 

========================= corefx sample_602 =========================

public void callback() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var callbackhandler = new callbackhandler();	int elapsedtime;	
verifying beginread with a callback specified 

public void callback_endreadoncallback() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var callbackhandler = new callbackhandler(com1);	int elapsedtime;	
verifying beginread with a callback that calls endread 

public void callback_state() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var callbackhandler = new callbackhandler();	int elapsedtime;	
verifying beginread with a callback and state specified 

========================= corefx sample_593 =========================

private resultset getauthorizationgroupshelper() {	checkdisposedordeleted();	if (this.unpersisted) {	
user getauthorizationgroupshelper unpersisted using emptyset 

========================= corefx sample_8991 =========================

private static void assertequalfloatarray(float[] expected, float[] actual) {	assert.equal(expected.length, actual.length);	for (int i = 0; i < expected.length; i++) {	try {	assert.equal(expected[i], actual[i], 3);	}	catch {	console.writeline(i);	
expected string join expected 

private static void assertequalfloatarray(float[] expected, float[] actual) {	assert.equal(expected.length, actual.length);	for (int i = 0; i < expected.length; i++) {	try {	assert.equal(expected[i], actual[i], 3);	}	catch {	console.writeline(i);	
actual string join actual 

========================= corefx sample_10332 =========================

protected void checkxmlexception(string expectedcode, xmlexception e, int expectedline, int expectedposition) {	string actualcode = expectedcode;	
exception 

========================= corefx sample_12377 =========================

case '=': sb.append(@"\=");	break;	default: sb.append(c.tostring());	break;	}	}	if (sb[sb.length - 1] == ' ') {	sb.remove(sb.length - 1, 1);	sb.append(@"\ ");	}	
adutils escapedncomponent mapped to 

case ')': sb.append(@"\29");	break;	case '*': sb.append(@"\2a");	break;	case '\\': sb.append(@"\5c");	break;	default: sb.append(c.tostring());	break;	}	}	
adutils mapped to 

break;	case '*': sb.append(@"\2a");	break;	case '\\': sb.append(@"\5c");	break;	default: sb.append(c.tostring());	break;	}	}	}	
adutils papiquerytoldapquerystring mapped to 

static internal string hexstringtoldaphexstring(string s) {	debug.assert(s != null);	if (s.length % 2 != 0) {	
adutils hexstringtoldaphexstring string has bad length 

stringbuilder sb = new stringbuilder();	for (int i = 0; i < (s.length) / 2; i++) {	char firstchar = s[i * 2];	char secondchar = s[(i * 2) + 1];	if (((firstchar >= '0' && firstchar <= '9') || (firstchar >= 'a' && firstchar <= 'f') || (firstchar >= 'a' && firstchar <= 'f')) && ((secondchar >= '0' && secondchar <= '9') || (secondchar >= 'a' && secondchar <= 'f') || (secondchar >= 'a' && secondchar <= 'f'))) {	sb.append(@"\");	sb.append(firstchar);	sb.append(secondchar);	}	else {	
adutils hexstringtoldaphexstring invalid string 

========================= corefx sample_9030 =========================

public override void dispose() {	try {	if (!_disposed) {	
authzset dispose disposing 

public sidlist(unsafenativemethods.sid_and_attr[] groupsidandattrs) {	
authzset sidlist processing sids 

names[i] = (unsafenativemethods.lsa_translated_name) marshal.ptrtostructure(pcurrentname, typeof(unsafenativemethods.lsa_translated_name));	pcurrentname = new intptr(pcurrentname.toint64() + marshal.sizeof(typeof(unsafenativemethods.lsa_translated_name)));	}	int domaincount = marshal.readint32(pdomains);	domains = new unsafenativemethods.lsa_trust_information[domaincount];	intptr pcurrentdomain = marshal.readintptr(pdomains, marshal.sizeof(typeof(int32)));	for(int i=0; i < domaincount; i++) {	domains[i] =(unsafenativemethods.lsa_trust_information) marshal.ptrtostructure(pcurrentdomain, typeof(unsafenativemethods.lsa_trust_information));	pcurrentdomain = new intptr(pcurrentdomain.toint64() + marshal.sizeof(typeof(unsafenativemethods.lsa_trust_information)));	}	
authzset sidlist got groups in domains 

========================= corefx sample_9004 =========================

try {	checked {	d++;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

exception = false;	d = char.minvalue;	try {	char rchar = checked(d--);	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	checked {	ushort rez2 = (ushort)-d;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	checked {	int rez2 = d + d2;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	checked {	uint rez3 = d2 - d;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

checked {	d2 -= d;	exception = true;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	checked {	long rez3 = d2 * d;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

d = int.minvalue;	d2 = -1;	try {	long rez4 = checked(d / d2);	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	checked {	byte b = (byte)d;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	checked {	char b = (char)d;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	checked {	ushort b = (ushort)d;	}	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	d++;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

exception = true;	d = char.minvalue;	try {	char rchar = unchecked(d--);	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	ushort rez2 = (ushort)-d;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	int rez2 = d + d2;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	uint rez3 = d2 - d;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	d2 -= d;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	long rez3 = d2 * d;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

d = int.minvalue;	d2 = -1;	try {	long rez4 = unchecked(d / d2);	}	catch (system.overflowexception) {	exception = true;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	byte b = (byte)d;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	char b = (char)d;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

try {	unchecked {	ushort b = (ushort)d;	}	}	catch (system.overflowexception) {	exception = false;	}	finally {	if (exception) rez++;	
test failed 

public static int mainmethod() {	int ret = 0;	dynamic a = new test();	try {	var v0 = checked(a.x1 -= 1);	ret++;	}	catch (system.overflowexception) {	
byte 

var v0 = checked(a.x1 -= 1);	ret++;	}	catch (system.overflowexception) {	}	try {	var v1 = checked(a.x1 -= 1);	ret++;	}	catch (system.overflowexception) {	
sbyte 

var v1 = checked(a.x1 -= 1);	ret++;	}	catch (system.overflowexception) {	}	try {	var v2 = checked(a.y -= 1);	ret++;	}	catch (system.overflowexception) {	
ushort 

var v2 = checked(a.y -= 1);	ret++;	}	catch (system.overflowexception) {	}	try {	var v2 = checked(a.y1 += 1);	ret++;	}	catch (system.overflowexception) {	
short 

var v2 = checked(a.y1 += 1);	ret++;	}	catch (system.overflowexception) {	}	try {	var v3 = checked(a.z -= 1);	ret++;	}	catch (system.overflowexception) {	
uint 

var v3 = checked(a.z -= 1);	ret++;	}	catch (system.overflowexception) {	}	try {	var v4 = checked(a.q += 1);	ret++;	}	catch (system.overflowexception) {	
ulong max 

var v4 = checked(a.q += 1);	ret++;	}	catch (system.overflowexception) {	}	try {	var v5 = checked(a.c -= 1);	ret++;	}	catch (system.overflowexception) {	
long min 

========================= corefx sample_129 =========================

static gdip() {	debug.assert(s_inittoken == intptr.zero, "gdiplusinitialization: initialize should not be called more than once in the same domain!");	
initialize gdi 

private static void clearthreaddata() {	
releasing tls data 

private static void shutdown() {	
shutdown gdi 

private static void shutdown() {	debug.indent();	if (initialized) {	
not already shutdown 

private static void shutdown() {	debug.indent();	if (initialized) {	clearthreaddata();	
running garbage collector 

private static void shutdown() {	debug.indent();	if (initialized) {	clearthreaddata();	gc.collect();	gc.waitforpendingfinalizers();	gc.collect();	
instruct gdi to shutdown 

private static void onprocessexit(object sender, eventargs e) {	
process exited 

========================= corefx sample_10384 =========================

static globaldebug() {	globaldebug.s_debuglevel = globalconfig.debuglevel;	#if supportdebuglogfile string debuglogfile = globalconfig.debuglogfile;	if (debuglogfile != null) {	foreach (tracelistener listener in debug.listeners) {	if (listener is defaulttracelistener) ((defaulttracelistener)listener).logfilename = debuglogfile;	}	
principal api debug log appdomain with id utc 

========================= corefx sample_9024 =========================

public static void testcontinuewhenanyexception(task[] antecedents, bool futurefactory, bool continuationisfuture) {	bool antecedentsarefutures = (antecedents as task<int>[]) != null;	
test exceptions in taskfactory continuewhenany task task tresult tresult tresult 

========================= corefx sample_4009 =========================

public static void runblockedinjectiontest() {	
runblockedinjectiontest if it deadlocks it failed 

public static void runbuggyschedulertests() {	
runbuggyschedulertests 

public static void runbuggyschedulertests() {	buggytaskscheduler bts = new buggytaskscheduler();	task t1 = new task(delegate { });	task t2 = new task(delegate { });	
testing task start buggy scheduler 

assert.true(false, string.format("    > failed.  no exception thrown."));	}	catch (taskschedulerexception) {	}	catch (exception e) {	assert.true(false, string.format("    > failed. wrong exception thrown (expected taskschedulerexception): {0}", e));	}	if (t1.status != taskstatus.faulted) {	assert.true(false, string.format("    > failed. task ended up in wrong status (expected faulted): {0}", t1.status));	}	
waiting on faulted task there s a problem if we deadlock 

}	try {	t1.wait();	assert.true(false, string.format("    > failed.  no exception thrown from wait()."));	}	catch (aggregateexception ae) {	if (!(ae.innerexceptions[0] is taskschedulerexception)) {	assert.true(false, string.format("    > failed.  wrong inner exception thrown from wait(): {0}", ae.innerexceptions[0].gettype().name));	}	}	
testing task runsynchronously buggy scheduler 

t2.runsynchronously(bts);	assert.true(false, string.format("    > failed.  no exception thrown."));	}	catch (taskschedulerexception) { }	catch (exception e) {	assert.true(false, string.format("    > failed. wrong exception thrown (expected taskschedulerexception): {0}", e));	}	if (t2.status != taskstatus.faulted) {	assert.true(false, string.format("    > failed. task ended up in wrong status (expected faulted): {0}", t1.status));	}	
waiting on faulted task there s a problem if we deadlock 

}	try {	t2.wait();	assert.true(false, string.format("    > failed.  no exception thrown from wait()."));	}	catch (aggregateexception ae) {	if (!(ae.innerexceptions[0] is taskschedulerexception)) {	assert.true(false, string.format("    > failed.  wrong inner exception thrown from wait(): {0}", ae.innerexceptions[0].gettype().name));	}	}	
testing task factory startnew buggy scheduler 

}	}	try {	task t3 = task.factory.startnew(delegate { }, cancellationtoken.none, taskcreationoptions.none, bts);	assert.true(false, string.format("    > failed.  no exception thrown."));	}	catch (taskschedulerexception) { }	catch (exception e) {	assert.true(false, string.format("    > failed. wrong exception thrown (expected taskschedulerexception): {0}", e));	}	
testing task continuewith buggy scheduler 

task t3 = task.factory.startnew(delegate { }, cancellationtoken.none, taskcreationoptions.none, bts);	assert.true(false, string.format("    > failed.  no exception thrown."));	}	catch (taskschedulerexception) { }	catch (exception e) {	assert.true(false, string.format("    > failed. wrong exception thrown (expected taskschedulerexception): {0}", e));	}	task completedtask = task.factory.startnew(delegate { });	completedtask.wait();	task tc1 = completedtask.continuewith(delegate { }, cancellationtoken.none, taskcontinuationoptions.executesynchronously, bts);	
waiting on faulted task there s a problem if we deadlock 

}	catch (aggregateexception ae) {	if (!(ae.innerexceptions[0] is taskschedulerexception)) {	assert.true(false, string.format("    > failed.  wrong inner exception thrown from wait() (sync): {0}", ae.innerexceptions[0].gettype().name));	}	}	catch (exception e) {	assert.true(false, string.format("    > failed.  wrong exception thrown (sync): {0}", e));	}	task tc2 = completedtask.continuewith(delegate { }, cancellationtoken.none, taskcontinuationoptions.none, bts);	
waiting on faulted task there s a problem if we deadlock 

assert.true(false, string.format("    > failed.  no exception thrown (async)."));	}	catch (aggregateexception ae) {	if (!(ae.innerexceptions[0] is taskschedulerexception)) {	assert.true(false, string.format("    > failed.  wrong inner exception thrown from wait() (async): {0}", ae.innerexceptions[0].gettype().name));	}	}	catch (exception e) {	assert.true(false, string.format("    > failed.  wrong exception thrown (async): {0}", e));	}	
testing task wait task started on buggy scheduler 

========================= corefx sample_3999 =========================

private bool movenextprimarygroupdn() {	debug.assert(_primarygroupdn != null);	this.current = sdsutils.builddirectoryentry( buildpathfromdn(_primarygroupdn), _storectx.credentials, _storectx.authtypes);	_storectx.initializenewdirectoryoptions((directoryentry)this.current);	
addnlinkedattrset movenextmembersearcher returning primary group 

if (_membersearchersqueue.count == 0) {	return false;	}	else {	_currentmemberssearcher = _membersearchersqueue.dequeue();	_membersearchresults = _currentmemberssearcher.findall();	debug.assert(_membersearchresults != null);	_membersearchresultsenumerator = _membersearchresults.getenumerator();	}	}	
addnlinkedattrset movenextquerymember have a searcher 

private bool movenextmembersearcher() {	
addnlinkedattrset entering movenextmembersearcher 

private bool movenextmembersearcher() {	bool needtoretry = false;	bool f = false;	do {	f = getnextsearchresult();	needtoretry = false;	if (f) {	searchresult currentsr = (searchresult)_membersearchresultsenumerator.current;	string memberdn = (string)currentsr.properties["distinguishedname"][0];	
addnlinkedattrset movenextmembersearcher got a value from the enumerator 

private bool movenextmembersearcher() {	bool needtoretry = false;	bool f = false;	do {	f = getnextsearchresult();	needtoretry = false;	if (f) {	searchresult currentsr = (searchresult)_membersearchresultsenumerator.current;	string memberdn = (string)currentsr.properties["distinguishedname"][0];	if ((!adutils.isofobjectclass(currentsr, "group")) && (!adutils.isofobjectclass(currentsr, "user")) && (!adutils.isofobjectclass(currentsr, "foreignsecurityprincipal"))) {	
addnlinkedattrset movenextmembersearcher not a principal skipping 

do {	f = getnextsearchresult();	needtoretry = false;	if (f) {	searchresult currentsr = (searchresult)_membersearchresultsenumerator.current;	string memberdn = (string)currentsr.properties["distinguishedname"][0];	if ((!adutils.isofobjectclass(currentsr, "group")) && (!adutils.isofobjectclass(currentsr, "user")) && (!adutils.isofobjectclass(currentsr, "foreignsecurityprincipal"))) {	needtoretry = true;	}	else if (_recursive && adutils.isofobjectclass(currentsr, "group")) {	
addnlinkedattrset movenextmembersearcher adding to groupstovisit 

searchresult currentsr = (searchresult)_membersearchresultsenumerator.current;	string memberdn = (string)currentsr.properties["distinguishedname"][0];	if ((!adutils.isofobjectclass(currentsr, "group")) && (!adutils.isofobjectclass(currentsr, "user")) && (!adutils.isofobjectclass(currentsr, "foreignsecurityprincipal"))) {	needtoretry = true;	}	else if (_recursive && adutils.isofobjectclass(currentsr, "group")) {	if (!_groupsvisited.contains(memberdn) && !_groupstovisit.contains(memberdn)) _groupstovisit.add(memberdn);	needtoretry = true;	}	else if (_recursive && adutils.isofobjectclass(currentsr, "foreignsecurityprincipal")) {	
addnlinkedattrset movenextmembersearcher foreign principal adding to foreignmembers 

needtoretry = true;	}	else if (_recursive && adutils.isofobjectclass(currentsr, "foreignsecurityprincipal")) {	if (!_usersvisited.containskey(currentsr.properties["distinguishedname"][0].tostring())) {	_foreignmemberscurrentgroup.add(currentsr.getdirectoryentry());	_usersvisited.add(currentsr.properties["distinguishedname"][0].tostring(), true);	}	needtoretry = true;	}	else {	
addnlinkedattrset movenextmembersearcher using as current 

}	}	}	else {	if (_recursive) {	globaldebug.writelineif(globaldebug.info, "addnlinkedattrset", "movenextmembersearcher: recursive processing, groupstovisit={0}", _groupstovisit.count);	if (_groupstovisit.count > 0) {	string groupdn = _groupstovisit[0];	_groupstovisit.removeat(0);	_groupsvisited.add(groupdn);	
addnlinkedattrset movenextmembersearcher recursively processing 

private bool movenextmemberenum() {	
addnlinkedattrset entering movenextmemberenum 

bool disposememberde = false;	bool f;	do {	f = getnextenum();	needtoretry = false;	disposememberde = false;	if (f) {	directoryentry memberde = null;	try {	string memberdn = (string)_membersenum.current;	
addnlinkedattrset movenextmemberenum got a value from the enumerator 

needtoretry = false;	disposememberde = false;	if (f) {	directoryentry memberde = null;	try {	string memberdn = (string)_membersenum.current;	memberde = sdsutils.builddirectoryentry( buildpathfromdn(memberdn), _storectx.credentials, _storectx.authtypes);	_storectx.initializenewdirectoryoptions(memberde);	_storectx.loaddirectoryentryattributes(memberde);	if ((!adutils.isofobjectclass(memberde, "group")) && (!adutils.isofobjectclass(memberde, "user")) && (!adutils.isofobjectclass(memberde, "foreignsecurityprincipal"))) {	
addnlinkedattrset movenextmemberenum not a principal skipping 

try {	string memberdn = (string)_membersenum.current;	memberde = sdsutils.builddirectoryentry( buildpathfromdn(memberdn), _storectx.credentials, _storectx.authtypes);	_storectx.initializenewdirectoryoptions(memberde);	_storectx.loaddirectoryentryattributes(memberde);	if ((!adutils.isofobjectclass(memberde, "group")) && (!adutils.isofobjectclass(memberde, "user")) && (!adutils.isofobjectclass(memberde, "foreignsecurityprincipal"))) {	needtoretry = true;	disposememberde = true;	}	else if (_recursive && adutils.isofobjectclass(memberde, "group")) {	
addnlinkedattrset movenextmemberenum adding to groupstovisit 

if ((!adutils.isofobjectclass(memberde, "group")) && (!adutils.isofobjectclass(memberde, "user")) && (!adutils.isofobjectclass(memberde, "foreignsecurityprincipal"))) {	needtoretry = true;	disposememberde = true;	}	else if (_recursive && adutils.isofobjectclass(memberde, "group")) {	if (!_groupsvisited.contains(memberdn) && !_groupstovisit.contains(memberdn)) _groupstovisit.add(memberdn);	needtoretry = true;	disposememberde = true;	}	else if (_recursive && adutils.isofobjectclass(memberde, "foreignsecurityprincipal")) {	
addnlinkedattrset movenextmemberenum foreign principal adding to foreignmembers 

}	else if (_recursive && adutils.isofobjectclass(memberde, "foreignsecurityprincipal")) {	if (!_usersvisited.containskey(memberde.properties["distinguishedname"][0].tostring())) {	_foreignmemberscurrentgroup.add(memberde);	_usersvisited.add(memberde.properties["distinguishedname"][0].tostring(), true);	disposememberde = false;	}	needtoretry = true;	}	else {	
addnlinkedattrset movenextmemberenum using as current 

}	}	}	else {	if (_recursive) {	globaldebug.writelineif(globaldebug.info, "addnlinkedattrset", "movenextlocal: recursive processing, groupstovisit={0}", _groupstovisit.count);	if (_groupstovisit.count > 0) {	string groupdn = _groupstovisit[0];	_groupstovisit.removeat(0);	_groupsvisited.add(groupdn);	
addnlinkedattrset movenextmemberenum recursively processing 

private void translateforeignmembers() {	
addnlinkedattrset translateforeignmembers translating foreign members 

private bool movenextforeign(ref bool outerneedtoretry) {	outerneedtoretry = false;	bool needtoretry;	principal foreignprincipal;	
addnlinkedattrset entering movenextforeign 

_currentforeignprincipal = unknownprincipal;	_foreignmemberstoreturn.removeat(0);	return true;	}	_foreignmemberstoreturn.removeat(0);	needtoretry = true;	continue;	}	sidtype sidtype = utils.classifysid(foreignsid.psid);	if (sidtype == sidtype.realobjectfakedomain) {	
addnlinkedattrset movenextforeign builtin principal 

foreignstorectx = _storectx;	}	else {	contextoptions remoteoptions = defaultcontextoptions.addefaultcontextoption;	#if use_ctx_cache principalcontext remotectx = sdscache.domain.getcontext(foreignsid.sidissuername, _storectx.credentials, remoteoptions);	#else principalcontext remotectx = new principalcontext( contexttype.domain, foreignsid.sidissuername, null, (this.storectx.credentials != null ? this.storectx.credentials.username : null), (this.storectx.credentials != null ? storectx.storectx.credentials.password : null), remoteoptions);	#endif foreignstorectx = remotectx.queryctx;	}	foreignprincipal = foreignstorectx.findprincipalbyidentref( typeof(principal), urnscheme.sidscheme, (new securityidentifier(utils.convertnativesidtobytearray(_foreignmemberstoreturn[0].psid), 0)).tostring(), datetime.utcnow);	if (null == foreignprincipal) {	
addnlinkedattrset movenextforeign no matching principal 

else {	_expansionmode = expansionmode.asq;	return expandforeigngroupsearcher();	}	}	else {	return false;	}	}	if (foreignprincipal is groupprincipal) {	
addnlinkedattrset movenextforeign foreign member is a group 

return expandforeigngroupsearcher();	}	}	else {	return false;	}	}	if (foreignprincipal is groupprincipal) {	if (!foreignprincipal.fakeprincipal) {	string groupdn = (string)((directoryentry)foreignprincipal.underlyingobject).properties["distinguishedname"].value;	
addnlinkedattrset movenextforeign not a fake group adding to foreigngroups 

_foreigngroups.add((groupprincipal)foreignprincipal);	}	else {	foreignprincipal.dispose();	}	}	needtoretry = true;	continue;	}	else {	
addnlinkedattrset movenextforeign using as currentforeignde currentforeignprincipal 

private bool expandforeigngroupenumerator() {	debug.assert(_recursive == true);	
addnlinkedattrset expandforeigngroupenumerator there are foreigngroups 

debug.assert(_recursive == true);	groupprincipal foreigngroup = _foreigngroups[0];	_foreigngroups.removeat(0);	debug.assert(foreigngroup.context.queryctx is adstorectx);	debug.assert(foreigngroup.underlyingobject is directoryentry);	debug.assert(((directoryentry)foreigngroup.underlyingobject).path.startswith("ldap:", stringcomparison.ordinal));	_storectx = (adstorectx)foreigngroup.context.queryctx;	_membersqueue.enqueue(new rangeretriever((directoryentry)foreigngroup.underlyingobject, "member", true));	string groupdn = (string)((directoryentry)foreigngroup.underlyingobject).properties["distinguishedname"].value;	_groupsvisited.add(groupdn);	
addnlinkedattrset expandforeigngroupenumerator recursively processing 

private bool expandforeigngroupsearcher() {	debug.assert(_recursive == true);	
addnlinkedattrset expandforeigngroupsearcher there are foreigngroups 

debug.assert(((directoryentry)foreigngroup.underlyingobject).path.startswith("ldap:", stringcomparison.ordinal));	_storectx = (adstorectx)foreigngroup.context.queryctx;	directorysearcher ds = sdsutils.constructsearcher((directoryentry)foreigngroup.underlyingobject);	ds.filter = "(objectclass=*)";	ds.searchscope = searchscope.base;	ds.attributescopequery = "member";	ds.cacheresults = false;	_membersearchersqueue.enqueue(ds);	string groupdn = (string)((directoryentry)foreigngroup.underlyingobject).properties["distinguishedname"].value;	_groupsvisited.add(groupdn);	
addnlinkedattrset expandforeigngroupsearcher recursively processing 

private bool movenextqueryprimarygroupmember() {	bool f = false;	if (_primarygroupmemberssearcher != null) {	
addnlinkedattrset movenextquerymember have a searcher 

private bool movenextqueryprimarygroupmember() {	bool f = false;	if (_primarygroupmemberssearcher != null) {	if (_querymembersresults == null) {	
addnlinkedattrset movenextquerymember issuing query 

_querymembersresults = _primarygroupmemberssearcher.findall();	debug.assert(_querymembersresults != null);	_querymembersresultenumerator = _querymembersresults.getenumerator();	}	f = _querymembersresultenumerator.movenext();	if (f) {	this.current = (searchresult)_querymembersresultenumerator.current;	debug.assert(this.current != null);	_currentforeignde = null;	_currentforeignprincipal = null;	
addnlinkedattrset movenextquerymember got a result using as current 

public override void dispose() {	try {	if (!_disposed) {	
addnlinkedattrset dispose disposing 

public override void dispose() {	try {	if (!_disposed) {	if (_primarygroupmemberssearcher != null) {	
addnlinkedattrset dispose disposing primarygroupmemberssearcher 

public override void dispose() {	try {	if (!_disposed) {	if (_primarygroupmemberssearcher != null) {	_primarygroupmemberssearcher.dispose();	}	if (_querymembersresults != null) {	
addnlinkedattrset dispose disposing querymembersresults 

public override void dispose() {	try {	if (!_disposed) {	if (_primarygroupmemberssearcher != null) {	_primarygroupmemberssearcher.dispose();	}	if (_querymembersresults != null) {	_querymembersresults.dispose();	}	if (_currentmemberssearcher != null) {	
addnlinkedattrset dispose disposing memberssearcher 

if (_primarygroupmemberssearcher != null) {	_primarygroupmemberssearcher.dispose();	}	if (_querymembersresults != null) {	_querymembersresults.dispose();	}	if (_currentmemberssearcher != null) {	_currentmemberssearcher.dispose();	}	if (_membersearchresults != null) {	
addnlinkedattrset dispose disposing membersearchresults 

if (_querymembersresults != null) {	_querymembersresults.dispose();	}	if (_currentmemberssearcher != null) {	_currentmemberssearcher.dispose();	}	if (_membersearchresults != null) {	_membersearchresults.dispose();	}	if (_membersearchersqueue != null) {	
addnlinkedattrset dispose disposing membersearchersqueue 

_membersearchresults.dispose();	}	if (_membersearchersqueue != null) {	foreach (directorysearcher ds in _membersearchersqueue) {	ds.dispose();	}	_membersearchersqueue.clear();	}	idisposable disposablemembers = _members as idisposable;	if (disposablemembers != null) {	
addnlinkedattrset dispose disposing members enumerable 

ds.dispose();	}	_membersearchersqueue.clear();	}	idisposable disposablemembers = _members as idisposable;	if (disposablemembers != null) {	disposablemembers.dispose();	}	idisposable disposablemembersenum = _membersenum as idisposable;	if (disposablemembersenum != null) {	
addnlinkedattrset dispose disposing membersenum enumerator 

}	idisposable disposablemembers = _members as idisposable;	if (disposablemembers != null) {	disposablemembers.dispose();	}	idisposable disposablemembersenum = _membersenum as idisposable;	if (disposablemembersenum != null) {	disposablemembersenum.dispose();	}	if (_membersqueue != null) {	
addnlinkedattrset dispose disposing membersqueue 

========================= corefx sample_9041 =========================

public void isopen_default() {	using (serialport com1 = new serialport()) {	serialportproperties serportprop = new serialportproperties();	
verifying default isopen 

public void isopen_open() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying isopen after open has been called 

public void isopen_open_close() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying isopen after open and close have been called 

========================= corefx sample_673 =========================

#endif try {	var listenergenerators = new list<func<listener>>();	listenergenerators.add(() => eventlistener);	#if use_etw if(isprocesselevated) {	etwlistener = new etwlistener();	listenergenerators.add(() => etwlistener);	}	#endif foreach (func<listener> listenergenerator in listenergenerators) {	var events = new list<event>();	using (var listener = listenergenerator()) {	
testing listener 

========================= corefx sample_3094 =========================

public memorystream stringatbufferboundary() {	
memorystreamlength 

========================= corefx sample_4596 =========================

public virtual void dotest() {	if (this.attribute != null) {	
testcase 

if (var != null && cmodinfo.isvariationselected(var.desc)) {	const string indent = "\t";	try {	curvariation = var;	tagvariation_status ret = var.execute();	if (tagvariation_status.evariationstatuspassed == ret) {	testmodule.passcount++;	}	else if (tagvariation_status.evariationstatusfailed == ret) {	system.console.writeline(indent + var.desc);	
failed 

}	else {	testmodule.skipcount++;	}	}	catch (ctestskippedexception) {	testmodule.skipcount++;	}	catch (exception e) {	system.console.writeline(indent + var.desc);	
unexpected exception happened 

else {	testmodule.skipcount++;	}	}	catch (ctestskippedexception) {	testmodule.skipcount++;	}	catch (exception e) {	system.console.writeline(indent + var.desc);	system.console.writeline(e.stacktrace);	
failed 

if (!cmodinfo.isvariationselected(curvar.desc)) return;	const string indent = "\t";	try {	curvariation.attribute = curvar;	int ret = testmethod();	if (test_pass == ret) {	testmodule.passcount++;	}	else if (test_fail == ret) {	system.console.writeline(indent + curvar.desc);	
failed 

int ret = testmethod();	if (test_pass == ret) {	testmodule.passcount++;	}	else if (test_fail == ret) {	system.console.writeline(indent + curvar.desc);	testmodule.failcount++;	}	else {	system.console.writeline(indent + curvar.desc);	
skipped 

system.console.writeline(indent + curvar.desc);	testmodule.failcount++;	}	else {	system.console.writeline(indent + curvar.desc);	testmodule.skipcount++;	}	}	catch (ctestskippedexception tse) {	system.console.writeline(indent + curvar.desc);	
skipped msg 

system.console.writeline(indent + curvar.desc);	testmodule.skipcount++;	}	}	catch (ctestskippedexception tse) {	system.console.writeline(indent + curvar.desc);	testmodule.skipcount++;	}	catch (exception e) {	system.console.writeline(indent + curvar.desc);	
unexpected exception happened 

testmodule.skipcount++;	}	}	catch (ctestskippedexception tse) {	system.console.writeline(indent + curvar.desc);	testmodule.skipcount++;	}	catch (exception e) {	system.console.writeline(indent + curvar.desc);	system.console.writeline(e.stacktrace);	
failed 

========================= corefx sample_4607 =========================

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("test");	w.writestartattribute(null, "attr", null);	w.writestartattribute("attr");	}	catch (xmlexception) {	return;	}	}	
did not throw error for duplicate attrs 

xmlreader xr = null;	try {	w.writestartelement("root");	w.writeattributes(xr, false);	}	catch (argumentnullexception) {	testlog.compare(w.writestate, writestate.element, "writestate should be element");	return;	}	}	
did not throw exception 

xdocument doc = new xdocument();	xmlwriter w = createwriter(doc);	xmlreader xr = createreader(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "attributesgeneric") {	do { xr.read(); } while (xr.localname != "node");	break;	}	}	if (xr.nodetype != xmlnodetype.element) {	
reader not positioned element 

xmlwriter w = createwriter(doc);	xmlreader xr = createreader(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "attributesgeneric") {	do { xr.read(); } while (xr.localname != "node");	xr.movetoattribute(1);	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader not positioned on attribute 

while (xr.read()) {	if (xr.localname == "attributesgeneric") {	do { xr.read(); } while (xr.localname != "node");	xr.movetonextattribute();	xr.movetonextattribute();	xr.movetonextattribute();	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader not positioned on attribute 

break;	case "whitespace": strxml = "<root>			 </root>";	break;	}	xmlreader xr;	xr = createreader(new stringreader(strxml));	do { xr.read(); }	while ((xr.nodetype.tostring() != variation.param.tostring()) && (xr.readstate != readstate.endoffile));	if (xr.readstate == readstate.endoffile || xr.nodetype.tostring() != variation.param.tostring()) {	xr.dispose();	
reader not positioned on correct node 

break;	case "whitespace": strxml = "<root>			 </root>";	break;	}	xmlreader xr;	xr = createreader(new stringreader(strxml));	do { xr.read(); }	while ((xr.nodetype.tostring() != variation.param.tostring()) && (xr.readstate != readstate.endoffile));	if (xr.readstate == readstate.endoffile || xr.nodetype.tostring() != variation.param.tostring()) {	xr.dispose();	
readstate 

break;	case "whitespace": strxml = "<root>			 </root>";	break;	}	xmlreader xr;	xr = createreader(new stringreader(strxml));	do { xr.read(); }	while ((xr.nodetype.tostring() != variation.param.tostring()) && (xr.readstate != readstate.endoffile));	if (xr.readstate == readstate.endoffile || xr.nodetype.tostring() != variation.param.tostring()) {	xr.dispose();	
nodetype 

w.writeattributes(xr, false);	}	catch (xmlexception) {	testlog.compare(w.writestate, writestate.element, "writestate should be element");	return;	}	finally {	xr.dispose();	}	}	
did not throw exception 

public void writeattributes_12() {	xdocument doc = new xdocument();	xmlreader xr = createreader(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "onehundredattributes") {	xr.movetofirstattribute();	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

public void writeattributes_13() {	xdocument doc = new xdocument();	string strxml = "<e a=\"&gt;&lt;&quot;&apos;&amp;\" />";	xmlreader xr = createreader(new stringreader(strxml));	xr.read();	xr.movetofirstattribute();	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

public void writeattributes_14() {	xdocument doc = new xdocument();	string strxml = "<root attr='test' />";	xmlreader xr = createreader(new stringreader(strxml));	xr.read();	xr.movetofirstattribute();	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

w.writeendelement();	}	catch (exception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	finally {	xr.dispose();	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writenode(xr, false);	}	catch (argumentnullexception) {	testlog.compare(w.writestate, writestate.element, "writestate should be element");	return;	}	}	
did not throw exception 

xmlwriter w = createwriter(doc);	xmlreader xr = createreaderignorews(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "defattr") {	xr.read();	xr.movetofirstattribute();	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

xdocument doc = new xdocument();	xmlreader xr = createreaderignorews(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "middle") {	xr.read();	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.text) {	
reader positioned on 

public void writenode_xmlreader24() {	xdocument doc = new xdocument();	xmlreader xr = createreaderignorews(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "cdatanode") {	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.cdata) {	
reader positioned on 

public void writenode_xmlreader25() {	xdocument doc = new xdocument();	xmlreader xr = createreaderignorews(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "pinode") {	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.processinginstruction) {	
reader positioned on 

public void writenode_xmlreader26() {	xdocument doc = new xdocument();	xmlreader xr = createreaderignorews(path.combine(filepathutil.gettestdatapath(), path.combine("xmlwriter2", "xmlreader.xml")));	while (xr.read()) {	if (xr.localname == "commentnode") {	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.comment) {	
reader positioned on 

xdocument doc = new xdocument();	using (xmlwriter w = createwriter(doc)) {	try {	w.writefullendelement();	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writeendelement();	w.writefullendelement();	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeattributestring("xmlns", "x", null, "bar");	}	catch (xmlexception) {	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeendelement();	}	catch (xmlexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

xdocument doc = new xdocument();	using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("xml", "root", "blah");	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("xmlns", "localname", "uri:bogus");	w.writeendelement();	}	catch (exception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw error 

try {	w.writestartelement("root");	w.writeattributestring("xmlns", null, "test");	w.writeendelement();	}	catch (xmlexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("pre", "test", string.empty);	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "xml", null, "foo");	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writeattributestring("xml", "space", "foo", "default");	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writeattributestring("xml", "lang", "foo", "en");	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writeattributestring("xmlns", "foo", "bar", "");	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "xmlns", null, "test");	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

doc.add(xa);	xmlwriter w = doc.createwriter();	w.dispose();	try {	doc.save(new memorystream());	}	catch (argumentexception) {	checkclosedstate(w.writestate);	return;	}	
did not throw exception 

try {	w.writestartelement("root");	w.writeendelement();	w.writecdata("foo");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

doc.add(xa);	xmlwriter w = doc.createwriter();	w.dispose();	try {	doc.save(new memorystream());	}	catch (argumentexception) {	checkclosedstate(w.writestate);	return;	}	
did not throw error 

try {	w.writestartelement("root");	w.writeentityref(temp);	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw error 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writecharentity('\udd12');	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writecharentity('\ud812');	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\udd12', '\udd01');	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\u1025', '\ud900');	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\ud9a2', '\ude34');	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writeprocessinginstruction(null, "test");	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writeprocessinginstruction(string.empty, "test");	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writeprocessinginstruction("xml", "text");	w.writeendelement();	w.dispose();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writeprocessinginstruction("pi", "text");	w.writestartdocument(true);	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartdocument();	w.writeprocessinginstruction("xml", "version = \"1.0\"");	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writeprocessinginstruction("xml", "version = \"1.0\"");	w.writestartdocument();	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

doc.add(xa);	xmlwriter w = doc.createwriter();	w.dispose();	try {	doc.save(new memorystream());	}	catch (argumentexception) {	checkclosedstate(w.writestate);	return;	}	
did not throw exception 

if (variation.param.tostring() == "null") temp = null;	else temp = string.empty;	w.writenmtoken(temp);	w.writeendelement();	}	catch (argumentexception) {	checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writenmtoken(variation.param.tostring());	w.writeendelement();	}	catch (argumentexception) {	checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

if (variation.param.tostring() == "null") temp = null;	else temp = string.empty;	w.writename(temp);	w.writeendelement();	}	catch (argumentexception) {	checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writename(variation.param.tostring());	w.writeendelement();	}	catch (argumentexception) {	checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

if (variation.param.tostring() == "null") temp = null;	else temp = string.empty;	w.writequalifiedname(temp, "test");	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writequalifiedname("bar", "foo");	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writeattributestring("xmlns", "foo", null, "test");	w.writequalifiedname(variation.param.tostring(), "test");	w.writeendelement();	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writechars(null, 0, 0);	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

w.writestring("\ud812");	w.writeendelement();	w.dispose();	doc.save(new memorystream());	}	catch (argumentexception) {	checkclosedstate(w.writestate);	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writestring(invxml);	w.dispose();	doc.save(new memorystream());	}	catch (argumentexception) {	checkclosedstate(w.writestate);	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writestring(invxml);	w.dispose();	doc.save(new memorystream());	}	catch (argumentexception) {	checkclosedstate(w.writestate);	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writestring(invxml);	w.dispose();	doc.save(new memorystream());	}	catch (argumentexception) {	checkclosedstate(w.writestate);	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writewhitespace(((char)(int)variation.param).tostring());	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	string s = w.lookupprefix(null);	w.dispose();	}	catch (argumentexception) {	checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writestartelement("node", null);	w.writeattributestring("xml", "space", null, "reserve");	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
exception expected 

try {	w.writestartelement("root");	w.writeattributestring("xml", "space", null, "preserve");	w.writeattributestring("xml", "space", null, "default");	}	catch (xmlexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
exception expected 

public void xmllang_2() {	xdocument doc = new xdocument();	xmlwriter w = createwriter(doc);	w.writestartelement("root");	if (w.xmllang != null) {	w.dispose();	
default value if no xml lang attributes are currently on the stack should be null 

public void xmllang_2() {	xdocument doc = new xdocument();	xmlwriter w = createwriter(doc);	w.writestartelement("root");	if (w.xmllang != null) {	w.dispose();	
actual value 

try {	w.writestartelement("root");	w.writeattributestring("xml", "lang", null, "en-us");	w.writeattributestring("xml", "lang", null, "ja");	}	catch (xmlexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
exception expected 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writeraw(null, 0, 0);	}	catch (argumentnullexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writeraw("\ud812");	w.dispose();	doc.save(new memorystream());	}	catch (argumentexception) {	testlog.compare(w.writestate, writestate.closed, "writestate should be closed");	return;	}	}	
did not throw exception 

using (xmlwriter w = createwriter(doc)) {	try {	w.writestartelement("root");	w.writebase64(null, 0, 0);	}	catch (argumentnullexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

break;	case "ns": w.writestartattribute("xmlns", "foo", null);	break;	}	w.writebase64(buffer, 0, 5);	}	catch (invalidoperationexception) {	return;	}	}	
did not throw exception 

========================= corefx sample_11584 =========================

public void writewithoutopen() {	using (serialport com = new serialport()) {	
case writewithoutopen verifying write method throws system invalidoperationexception without a call to open 

public void writeafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
case writeafterfailedopen verifying write method throws exception with a failed call to open 

public void writeafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
case writeafterclose verifying write method throws exception after a call to close 

public void bytestowrite() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndstr asyncwriterndstr = new asyncwriterndstr(com, s_string_size_bytes_to_write);	var t = new task(asyncwriterndstr.writerndstr);	int numnewlinebytes;	
case bytestowrite verifying bytestowrite with one call to write 

public void bytestowritesuccessive() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndstr asyncwriterndstr = new asyncwriterndstr(com, s_string_size_bytes_to_write);	var t1 = new task(asyncwriterndstr.writerndstr);	var t2 = new task(asyncwriterndstr.writerndstr);	int numnewlinebytes;	
case bytestowritesuccessive verifying bytestowrite with successive calls to write 

========================= corefx sample_647 =========================

public void length_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying length property throws exception after open then close 

public void length_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying length property throws exception after open then basestream close 

public void length_afteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying length property throws exception after a call to open 

========================= corefx sample_587 =========================

private void workwithnolocalstate(int i, parallelloopstate state) {	
workwithnolocalstate int on index startindex real index 

private list<int> workwithlocalstate(int i, parallelloopstate state, list<int> threadlocalvalue) {	
workwithlocalstate int on index startindex real index 

private list<int> workwithlocalstate(int i, int index, parallelloopstate state, list<int> threadlocalvalue) {	
workwithlocalstate int index on index startindex real index 

private void workwithnolocalstate(long i, parallelloopstate state) {	
workwithnolocalstate long on index startindex real index 

private list<long> workwithlocalstate(long i, parallelloopstate state, list<long> threadlocalvalue) {	
workwithlocalstate long on index startindex real index 

private void stopactionhelper(long i, parallelloopstate state, bool catchexception) {	
calling stopaction on index startindex real index 

private void breakactionhelper(long i, parallelloopstate state, bool catchexception) {	
calling breakaction on index startindex real index 

private void exceptionalaction(long i, parallelloopstate state) {	
calling exceptionalaction on index startindex real index 

private void multipleexceptionaction(long i, parallelloopstate state) {	
calling on index startindex real index 

========================= corefx sample_1265 =========================

public void tracetest01() {	var texttl = new testtexttracelistener();	trace.listeners.add(texttl);	trace.indentlevel = 0;	
message start 

trace.indentlevel = 2;	trace.write("this message should be indented.");	trace.traceerror("this error not be indented.");	trace.traceerror("{0}", "this error is indented");	trace.tracewarning("this warning is indented");	trace.tracewarning("{0}", "this warning is also indented");	trace.traceinformation("this information in indented");	trace.traceinformation("{0}", "this information is also indented");	trace.indentsize = 0;	trace.indentlevel = 0;	
message end 

trace.listeners.add(texttl);	trace.indentlevel = 0;	trace.fail("");	texttl.flush();	var fail = texttl.output.trimend(newline.tochararray());	texttl = new testtexttracelistener();	trace.listeners.clear();	trace.listeners.add(texttl);	trace.indentlevel = 0;	trace.indentsize = 2;	
message start 

texttl = new testtexttracelistener();	trace.listeners.clear();	trace.listeners.add(texttl);	trace.indentlevel = 0;	trace.indentsize = 2;	trace.indent();	trace.indent();	trace.writeif(true, "this message should be indented.");	trace.writeif(false, "this message should be ignored.");	trace.indent();	
this should not be indented 

texttl = new testtexttracelistener();	trace.listeners.clear();	trace.listeners.add(texttl);	trace.indentlevel = 0;	trace.indentsize = 2;	trace.indent();	trace.indent();	trace.writeif(true, "this message should be indented.");	trace.writeif(false, "this message should be ignored.");	trace.indent();	
this message will be ignored 

trace.writeif(true, "this message should be indented.");	trace.writeif(false, "this message should be ignored.");	trace.indent();	trace.fail("this failure is reported", "with a detailed message");	trace.assert(false);	trace.assert(false, "this assert is reported");	trace.assert(true, "this assert is not reported");	trace.unindent();	trace.unindent();	trace.unindent();	
message end 

========================= corefx sample_1107 =========================

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void readafterserialstreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to basestream close 

public void parityerroronlastbyte() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var rndgen = new random(15);	var bytestowrite = new byte[numrndbytespairty];	var expectedbytes = new byte[numrndbytespairty];	var actualbytes = new byte[numrndbytespairty + 1];	iasyncresult readasyncresult;	
verifying default parityreplace byte with a parity errro on the last byte 

public void verifybytestoread(int numbytesread, encoding encoding) {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var rndgen = new random(-55);	var bytestowrite = new byte[numrndbytestoread];	for (var i = 0; i < bytestowrite.length; i++) {	var randbyte = (byte)rndgen.next(0, 256);	bytestowrite[i] = randbyte;	}	
verifying bytestoread with a buffer of 

========================= corefx sample_597 =========================

private delegate void writemethoddelegate(stream stream);	#region test cases [conditionalfact(nameof(hasoneserialport))]	public void writetimeout_defaultvalue() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream stream = com.basestream;	
verifying the default value of writetimeout 

public void writetimeout_afterclose() {	
verifying setting writetimeout after the serialport was closed 

public void writetimeout_int32minvalue() {	
verifying minvalue writetimeout 

public void writetimeout_neg2() {	
verifying writetimeout 

public void writetimeout_zero() {	
verifying writetimeout 

public void writetimeout_default_write_byte_int_int() {	
verifying default writetimeout with write byte buffer int offset int count 

public void writetimeout_default_writebyte() {	
verifying default writetimeout with writebyte 

public void writetimeout_infinite_write_byte_int_int() {	
verifying infinite writetimeout with write byte buffer int offset int count 

public void writetimeout_infinite_writebyte() {	
verifying infinite writetimeout with writebyte 

public void writetimeout_int32maxvalue_write_byte_int_int() {	
verifying maxvalue writetimeout with write byte buffer int offset int count 

public void writetimeout_int32maxvalue_writebyte() {	
verifying maxvalue writetimeout with writebyte 

public void writetimeout_750_write_byte_int_int() {	
verifying writetimeout with write byte buffer int offset int count 

public void writetimeout_750_writebyte() {	
verifying writetimeout with writebyte 

public void writetimeout_0_write_byte_int_int() {	
verifying writetimeout with write byte buffer int offset int count 

public void writetimeout_0_writebyte() {	
verifying writetimeout with writebyte 

public void writetimeout_largewrite() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	com.baudrate = largewrite_baudrate;	com.handshake = handshake.requesttosend;	stream stream = com.basestream;	stream.writetimeout = largewrite_timeout;	
verifying writetimeout with write byte int int and writing bytes 

private void verifydefaulttimeout(writemethoddelegate writemethod) {	using (serialport com1 = tcsupport.initfirstserialport()) {	
serial port being used 

========================= corefx sample_606 =========================

public void outbufferfilled_discard_once() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying discard method after write buffer has been filled 

public void outbufferfilled_discard_multiple() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying call discard method several times after output buffer has been filled 

public void outbufferfilled_discard_cycle() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying call discard method after input buffer has been filled discarded and filled again 

public void inandoutbufferfilled_discard() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	
verifying discard method after input buffer has been filled 

========================= corefx sample_657 =========================

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writenode(xr, false);	}	catch (argumentnullexception) {	cerror.compare(w.writestate, writestate.element, "writestate should be element");	return;	}	}	
did not throw exception 

using (xmlwriter w = utils.createwriter()) {	using (xmlreader xr = createreaderignorews("xmlreader.xml")) {	while (xr.read()) {	if (xr.localname == "defattr") {	xr.read();	xr.movetofirstattribute();	break;	}	}	if (xr.nodetype != xmlnodetype.attribute) {	
reader positioned on 

public void writenode_xmlreader23(xmlwriterutils utils) {	xmlreader xr = createreaderignorews("xmlreader.xml");	while (xr.read()) {	if (xr.localname == "middle") {	xr.read();	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.text) {	
reader positioned on 

public void writenode_xmlreader24(xmlwriterutils utils) {	if (isxpathdatamodelreader()) {	
xpath data model does not have cdata node type so can not be positioned on cdata 

return;	}	xmlreader xr = createreaderignorews("xmlreader.xml");	while (xr.read()) {	if (xr.localname == "cdatanode") {	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.cdata) {	
reader positioned on 

public void writenode_xmlreader25(xmlwriterutils utils) {	xmlreader xr = createreaderignorews("xmlreader.xml");	while (xr.read()) {	if (xr.localname == "pinode") {	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.processinginstruction) {	
reader positioned on 

public void writenode_xmlreader26(xmlwriterutils utils) {	xmlreader xr = createreaderignorews("xmlreader.xml");	while (xr.read()) {	if (xr.localname == "commentnode") {	xr.read();	break;	}	}	if (xr.nodetype != xmlnodetype.comment) {	
reader positioned on 

public void writenode_xmlreader28(xmlwriterutils utils) {	string strxml = "<?xml version=\"1.0\" standalone=\"yes\"?><root />";	xmlreader xr = createreader(new stringreader(strxml));	xr.read();	if (xr.nodetype != xmlnodetype.xmldeclaration) {	
reader positioned on 

========================= corefx sample_12458 =========================

private void onsend(iasyncresult result) {	serversocketstate sendstate = (serversocketstate)result.asyncstate;	try {	int bytessent = sendstate.socket.endsend(result);	if (bytessent != sendstate.transferbuffer.length) {	
apm onsend bytes expecting bytes 

========================= corefx sample_4435 =========================

public void inbufferfilled_discard_once() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	
verifying discard method after input buffer has been filled 

public void inbufferfilled_discard_multiple() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	
verifying call discard method several times after input buffer has been filled 

public void inbufferfilled_discard_multiple() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	com1.open();	com2.open();	com2.write(default_string);	tcsupport.waitforreadbuffertoload(com1, default_string.length);	verifydiscard(com1);	verifydiscard(com1);	verifydiscard(com1);	{	
err verifying call discard method several times after input buffer has been filled failed 

public void inbufferfilled_discard_cycle() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	
verifying call discard method after input buffer has been filled discarded and filled again 

public void inandoutbufferfilled_discard() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	int origbytestowrite;	
verifying discard method after input buffer has been filled 

========================= corefx sample_663 =========================

public void discardwithoutopen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying discard method throws exception without a call to open 

public void discardafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read discard throws exception with a failed call to open 

public void discardafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying discard method throws exception after a call to cloes 

public void discardafteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying discard method does not throw an exception after a call to open 

========================= corefx sample_632 =========================

public override void dispose() {	try {	if (!_disposed) {	
adentriesset dispose disposing 

========================= corefx sample_9034 =========================

public int v() {	string type = curvariation.params[0].tostring();	
test type 

public int v() {	string type = curvariation.params[0].tostring();	reloadsource(new stringreader(_xmlstr));	datareader.positiononelement("root");	switch (type) {	case "nns": datareader.readtodescendant("elem");	if (datareader.hasattributes) {	
positioned on wrong element 

if (datareader.hasattributes) {	cerror.writeignore(datareader.readinnerxml() + "\n");	return test_fail;	}	while (datareader.read()) ;	datareader.close();	return test_pass;	case "dns": datareader.readtodescendant("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns") == null) {	
positioned on wrong element not on dns 

if (datareader.getattribute("xmlns") == null) {	return test_fail;	}	}	while (datareader.read()) ;	datareader.close();	return test_pass;	case "ns": datareader.readtodescendant("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on ns 

do {	mnw.putpattern("e/");	count++;	}	while (mnw.getnodes().length < 4096);	mnw.puttext("<a/>");	mnw.finish();	cerror.writeignore(mnw.getnodes() + "\n");	reloadsource(new stringreader(mnw.getnodes()));	datareader.positiononelement("element_1");	
reading to a 

mnw.putpattern("x");	int count = 0;	do {	mnw.putpattern("e/");	count++;	} while (count < 65536);	mnw.puttext("<a/>");	mnw.finish();	reloadsource(new stringreader(mnw.getnodes()));	datareader.positiononelement("element_1");	
reading to a 

public int v3() {	string type = curvariation.params[0].tostring();	
test type 

public int v3() {	string type = curvariation.params[0].tostring();	reloadsource(new stringreader(_xmlstr));	datareader.positiononelement("root");	switch (type) {	case "nns": datareader.readtodescendant("elem");	int depth = datareader.depth;	if (datareader.hasattributes) {	
positioned on wrong element 

return test_fail;	}	cerror.compare(datareader.readtodescendant("elem"), false, "there are no more descendants");	cerror.compare(datareader.nodetype, xmlnodetype.endelement, "wrong node type");	while (datareader.read()) ;	datareader.close();	return test_pass;	case "dns": datareader.readtodescendant("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns") == null) {	
positioned on wrong element not on dns 

}	}	cerror.compare(datareader.readtodescendant("elem", "elem"), false, "there are no more descendants");	cerror.compare(datareader.nodetype, xmlnodetype.endelement, "wrong node type");	while (datareader.read()) ;	datareader.close();	return test_pass;	case "ns": datareader.readtodescendant("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on dns 

public int v15() {	reloadsource(new stringreader("<root><b/></root>"));	datareader.read();	if (isbinaryreader()) datareader.read();	try {	datareader.readtodescendant(null);	}	catch (argumentnullexception) {	
caught for single param 

if (isbinaryreader()) datareader.read();	try {	datareader.readtodescendant(null);	}	catch (argumentnullexception) {	}	try {	datareader.readtodescendant("b", null);	}	catch (argumentnullexception) {	
caught for single param 

public int v18() {	string type = curvariation.params[0].tostring();	
test type 

public int v18() {	string type = curvariation.params[0].tostring();	reloadsource(new stringreader(_xmlstr));	switch (type) {	case "nns": datareader.readtodescendant("elem");	if (datareader.hasattributes) {	
positioned on wrong element 

if (datareader.hasattributes) {	cerror.writeignore(datareader.readinnerxml() + "\n");	return test_fail;	}	while (datareader.read()) ;	datareader.close();	return test_pass;	case "dns": datareader.readtodescendant("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns") == null) {	
positioned on wrong element not on dns 

if (datareader.getattribute("xmlns") == null) {	return test_fail;	}	}	while (datareader.read()) ;	datareader.close();	return test_pass;	case "ns": datareader.readtodescendant("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on ns 

========================= corefx sample_12380 =========================

public static void libyatimezone() {	timezoneinfo tripoli;	try {	tripoli = timezoneinfo.findsystemtimezonebyid(s_strlibya);	}	catch (exception /* timezonenotfoundexception in netstandard1.7 test*/ ) {	
warning libya time zone is not exist in this machine 

========================= corefx sample_1719 =========================

break;	default: sb.append(@"\\");	sb.append(c.tostring());	break;	}	}	}	if (escapemode) {	sb.append(@"\\");	}	
samutils papiquerytoregexstring mapped to 

========================= corefx sample_9046 =========================

public sendpacketsasync(itestoutputhelper output) {	_log = testlogging.getinstance();	byte[] buffer = new byte[s_testfilesize];	for (int i = 0; i < s_testfilesize; i++) {	buffer[i] = (byte)(i % 255);	}	try {	
creating file with size 

byte[] buffer = new byte[s_testfilesize];	for (int i = 0; i < s_testfilesize; i++) {	buffer[i] = (byte)(i % 255);	}	try {	using (filestream fs = new filestream(testfilename, filemode.createnew)) {	fs.write(buffer, 0, buffer.length);	}	}	catch (ioexception) {	
payload file exists 

========================= corefx sample_8299 =========================

builder.append((char)ch);	}	string teststring = builder.tostring();	var data = new dictionary<string, string>();	data.add("key", teststring);	var content = new formurlencodedcontent(data);	stream stream = await content.readasstreamasync();	string result = new streamreader(stream).readtoend().tolowerinvariant();	string expectedresult = "key=%00%01%02%03%04%05%06%07%08%09%0a%0b%0c%0d%0e%0f%10%11%12%13%14%15%16%17%18" + "%19%1a%1b%1c%1d%1e%1f+!%22%23%24%25%26%27()*%2b%2c-.%2f0123456789%3a%3b%3c%3d%3e%3f%40abcdefghijklm" + "nopqrstuvwxyz%5b%5c%5d%5e_%60abcdefghijklmnopqrstuvwxyz%7b%7c%7d%7e%7f";	string knowndiscrepancies = "~!*()";	
expecting result 

builder.append((char)ch);	}	string teststring = builder.tostring();	var data = new dictionary<string, string>();	data.add("key", teststring);	var content = new formurlencodedcontent(data);	stream stream = await content.readasstreamasync();	string result = new streamreader(stream).readtoend().tolowerinvariant();	string expectedresult = "key=%00%01%02%03%04%05%06%07%08%09%0a%0b%0c%0d%0e%0f%10%11%12%13%14%15%16%17%18" + "%19%1a%1b%1c%1d%1e%1f+!%22%23%24%25%26%27()*%2b%2c-.%2f0123456789%3a%3b%3c%3d%3e%3f%40abcdefghijklm" + "nopqrstuvwxyz%5b%5c%5d%5e_%60abcdefghijklmnopqrstuvwxyz%7b%7c%7d%7e%7f";	string knowndiscrepancies = "~!*()";	
actual result 

========================= corefx sample_349 =========================

private static void dumpdecimalhelperparts(int index) {	sqldecimal sqldecimalvalue = 10;	console.writeline("private static readonly uint32[] {0} = {{", helpernames[index]);	for (int precision = 2; precision <= sqldecimal.maxprecision; precision++){	
if precision sqldecimal maxprecision 

}	sqldecimalvalue = sqldecimal.maxvalue;	int[] data = sqldecimalvalue.data;	uint32[] udata = { (uint32)data[0], (uint32)data[1], (uint32)data[2], (uint32)data[3]};	bool carry = true;	for (int i = 0; i < 4; i++){	if (carry){	carry = (++udata[i] == 0);	}	}	
console writeline 

debug.assert(_blen <= s_cnumemax, "m_blen <= x_cnumemax", "in assertvalid");	uint[] rgldata = new uint[4] { _data1, _data2, _data3, _data4 };	if (rgldata[_blen - 1] == 0) {	debug.assert(_blen == 1, "m_blen == 1", "in assertvalid");	}	for (int iuldata = _blen; iuldata < s_cnumemax; iuldata++) debug.assert(rgldata[iuldata] == 0, "rgldata[iuldata] == 0", "in assertvalid");	}	[system.diagnostics.conditional("debug")]	private void print() {	if (isnull) {	
numeric null 

if (rgldata[_blen - 1] == 0) {	debug.assert(_blen == 1, "m_blen == 1", "in assertvalid");	}	for (int iuldata = _blen; iuldata < s_cnumemax; iuldata++) debug.assert(rgldata[iuldata] == 0, "rgldata[iuldata] == 0", "in assertvalid");	}	[system.diagnostics.conditional("debug")]	private void print() {	if (isnull) {	return;	}	
numeric data 

private void print() {	if (isnull) {	return;	}	debug.writeline("\tlen = " + m_blen.tostring() + ", prec = " + m_bprec.tostring() + ", scale = " + m_bscale.tostring() + ", sign = " + ispositive.tostring());	}	[system.diagnostics.conditional("debug")]	private void print(string s) {	debug.writeline("*** " + s + " ***");	if (isnull) {	
numeric null 

return;	}	debug.writeline("\tlen = " + m_blen.tostring() + ", prec = " + m_bprec.tostring() + ", scale = " + m_bscale.tostring() + ", sign = " + ispositive.tostring());	}	[system.diagnostics.conditional("debug")]	private void print(string s) {	debug.writeline("*** " + s + " ***");	if (isnull) {	return;	}	
numeric data 

========================= corefx sample_3538 =========================

xmlreadersettings rs = (xmlreadersettings)options[readerfactory.ht_readersettings];	stream stream = (stream)options[readerfactory.ht_stream];	string filename = (string)options[readerfactory.ht_filename];	object readertype = options[readerfactory.ht_readertype];	object vt = options[readerfactory.ht_validationtype];	string fragment = (string)options[readerfactory.ht_fragment];	stringreader sr = (stringreader)options[readerfactory.ht_stringreader];	if (rs == null) rs = new xmlreadersettings();	rs.dtdprocessing = dtdprocessing.ignore;	if (sr != null) {	
stringreader 

object vt = options[readerfactory.ht_validationtype];	string fragment = (string)options[readerfactory.ht_fragment];	stringreader sr = (stringreader)options[readerfactory.ht_stringreader];	if (rs == null) rs = new xmlreadersettings();	rs.dtdprocessing = dtdprocessing.ignore;	if (sr != null) {	xmlreader reader = readerhelper.create(sr, rs, string.empty);	return reader;	}	if (stream != null) {	
stream 

rs.dtdprocessing = dtdprocessing.ignore;	if (sr != null) {	xmlreader reader = readerhelper.create(sr, rs, string.empty);	return reader;	}	if (stream != null) {	xmlreader reader = readerhelper.create(stream, rs, filename);	return reader;	}	if (fragment != null) {	
fragment 

xmlreader reader = readerhelper.create(stream, rs, filename);	return reader;	}	if (fragment != null) {	rs.conformancelevel = conformancelevel.fragment;	stringreader tr = new stringreader(fragment);	xmlreader reader = readerhelper.create(tr, rs, (string)null);	return reader;	}	if (filename != null) {	
filename 

========================= corefx sample_12608 =========================

xmlreader datareader = getreader(pbase64xml);	positiononelement(datareader, st_elem_name1);	datareader.read();	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
actual exception 

xmlreader datareader = getreader(pbase64xml);	positiononelement(datareader, st_elem_name1);	datareader.read();	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
expected exception 

public void testtextreadbase64_24() {	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('c', 5000);	try {	xmlreader datareader = getreaderstr(strxml);	positiononelement(datareader, "b");	datareader.read();	if (!datareader.canreadbinarycontent) return;	datareader.readcontentasbase64(buffer, 0, 5000);	
accepted incomplete element 

byte[] buffer = new byte[ibuffersize];	xmlreader datareader = getreader(pbase64xml);	positiononelement(datareader, st_elem_name1);	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
actual exception 

byte[] buffer = new byte[ibuffersize];	xmlreader datareader = getreader(pbase64xml);	positiononelement(datareader, st_elem_name1);	if (!datareader.canreadbinarycontent) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	bpassed = (e.gettype().tostring() == exceptiontype.tostring());	if (!bpassed) {	
expected exception 

public void testtextreadbase64_24() {	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('c', 5000);	try {	xmlreader datareader = getreaderstr(strxml);	positiononelement(datareader, "b");	if (!datareader.canreadbinarycontent) return;	datareader.readelementcontentasbase64(buffer, 0, 5000);	
accepted incomplete element 

========================= corefx sample_11570 =========================

public void verify() {	serialportproperties serportprop = new serialportproperties();	using (serialport com = new serialport()) {	serportprop.setallpropertiestodefaults();	
verifying properties is called 

========================= corefx sample_640 =========================

public bool movenext() {	
valuecollectionenumerator entering movenext 

public void reset() {	
valuecollectionenumerator entering reset 

public void dispose() {	
valuecollectionenumerator entering dispose 

========================= corefx sample_8982 =========================

public void writeafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to cloes 

public void writeafterbasestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to basestream close 

public void bytestowrite() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	var asyncwriterndbytearray = new asyncwriterndbytearray(com, s_byte_size_bytes_to_write);	var t = new task(asyncwriterndbytearray.writerndbytearray);	
verifying bytestowrite with one call to write 

public void bytestowritesuccessive() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	var asyncwriterndbytearray = new asyncwriterndbytearray(com, s_byte_size_bytes_to_write);	var t1 = new task(asyncwriterndbytearray.writerndbytearray);	var t2 = new task(asyncwriterndbytearray.writerndbytearray);	
verifying bytestowrite with successive calls to write 

========================= corefx sample_611 =========================

public void writewithoutopen() {	using (serialport com = new serialport()) {	
verifying write method throws exception without a call to open 

public void writeafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying write method throws exception with a failed call to open 

public void writeafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to cloes 

public void bytestowrite() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com, byte_size_bytes_to_write);	var t = new task(asyncwriterndbytearray.writerndbytearray);	
verifying bytestowrite with one call to write 

public void bytestowritesuccessive() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com, byte_size_bytes_to_write);	var t1 = new task(asyncwriterndbytearray.writerndbytearray);	var t2 = new task(asyncwriterndbytearray.writerndbytearray);	
verifying bytestowrite with successive calls to write 

========================= corefx sample_687 =========================

private void writebuffersize_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default writebuffersize before open 

private void writebuffersize_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	
verifying default writebuffersize after open 

using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	com1.open();	serportprop = new serialportproperties();	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	
verifying default writebuffersize after close 

private void verifywritebuffersizebeforeopen(int newwritebuffersize) {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying setting writebuffersize to 

serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	com2.readbuffersize = expectedwritebuffersize;	serportprop.setproperty("writebuffersize", expectedwritebuffersize);	com2.open();	int origbaudrate = com1.baudrate;	com2.baudrate = 115200;	com1.baudrate = 115200;	serportprop.setproperty("baudrate", 115200);	com1.write(xmitbytes, 0, xmitbytes.length);	tcsupport.waitforreadbuffertoload(com2, xmitbytes.length);	
verifying properties after changing writebuffersize 

========================= corefx sample_625 =========================

public void readwithoutopen() {	using (serialport com = new serialport()) {	
verifying read method throws exception without a call to open 

public void readafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read method throws exception with a failed call to open 

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void parityerroronlastbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(15);	byte[] bytestowrite = new byte[numrndbytespairty];	char[] expectedchars = new char[numrndbytespairty];	char[] actualchars = new char[numrndbytespairty + 1];	
verifying default parityreplace byte with a parity errro on the last byte 

using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(-55);	byte[] bytestowrite = new byte[numrndbytestoread];	char[] expectedchars;	asciiencoding encoding = new asciiencoding();	for (int i = 0; i < bytestowrite.length; i++) {	byte randbyte = (byte)rndgen.next(0, 256);	bytestowrite[i] = randbyte;	}	expectedchars = encoding.getchars(bytestowrite, 0, bytestowrite.length);	
verifying bytestoread with a buffer of 

========================= corefx sample_674 =========================

private static void main(string[] args) {	
composition throughput benchmarks 

private static void runsuite(suite suite) {	
operations 

========================= corefx sample_724 =========================

public void verify() {	serialportproperties serportprop = new serialportproperties();	container container = new container();	using (serialport com = new serialport(container)) {	assert.equal(1, container.components.count);	assert.equal(com, container.components[0]);	serportprop.setallpropertiestodefaults();	
verifying properties is called 

========================= corefx sample_664 =========================

private void printtableorview(dataview dv, string label) {	console.writeline("\n" + label);	
sort key 

public void defaultcolumnnameaddlistchangedtest() {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	_eventwriter = new stringwriter();	datatable dt = new datatable("table");	complexeventsequence1view dv = new complexeventsequence1view(dt, _eventwriter);	dt.columns.add();	
default named column added 

public void defaultcolumnnameaddlistchangedtest() {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	_eventwriter = new stringwriter();	datatable dt = new datatable("table");	complexeventsequence1view dv = new complexeventsequence1view(dt, _eventwriter);	dt.columns.add();	dt.columns.add("non-defaultnamedcolumn");	
non default named column added 

public void defaultcolumnnameaddlistchangedtest() {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	_eventwriter = new stringwriter();	datatable dt = new datatable("table");	complexeventsequence1view dv = new complexeventsequence1view(dt, _eventwriter);	dt.columns.add();	dt.columns.add("non-defaultnamedcolumn");	datacolumn c = dt.columns.add();	
another default named column added 

public void defaultcolumnnameaddlistchangedtest() {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	_eventwriter = new stringwriter();	datatable dt = new datatable("table");	complexeventsequence1view dv = new complexeventsequence1view(dt, _eventwriter);	dt.columns.add();	dt.columns.add("non-defaultnamedcolumn");	datacolumn c = dt.columns.add();	dt.columns.add("column3");	
add a column with the same name as the default columnnames 

public void defaultcolumnnameaddlistchangedtest() {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	_eventwriter = new stringwriter();	datatable dt = new datatable("table");	complexeventsequence1view dv = new complexeventsequence1view(dt, _eventwriter);	dt.columns.add();	dt.columns.add("non-defaultnamedcolumn");	datacolumn c = dt.columns.add();	dt.columns.add("column3");	dt.columns.add((string)null);	
add a column with a null name 

string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	_eventwriter = new stringwriter();	datatable dt = new datatable("table");	complexeventsequence1view dv = new complexeventsequence1view(dt, _eventwriter);	dt.columns.add();	dt.columns.add("non-defaultnamedcolumn");	datacolumn c = dt.columns.add();	dt.columns.add("column3");	dt.columns.add((string)null);	dt.columns.add("");	
add a column with an empty name 

public complexeventsequence1view(datatable dt, textwriter w) : base() {	_w = w;	
setting table 

public complexeventsequence1view(datatable dt, textwriter w) : base() {	_w = w;	table = dt;	
table was set 

========================= corefx sample_3343 =========================

public void stopbits_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default stopbits 

public void stopbits_1_beforeopen() {	
verifying stopbits before open 

public void stopbits_2_beforeopen() {	
verifying stopbits before open 

public void stopbits_1_afteropen() {	
verifying stopbits after open 

public void stopbits_2_afteropen() {	
verifying stopbits after open 

public void stopbits_int32minvalue() {	
verifying minvalue stopbits 

public void stopbits_neg1() {	
verifying stopbits 

public void stopbits_0() {	
verifying stopbits 

public void stopbits_4() {	
verifying stopbits 

public void stopbits_int32maxvalue() {	
verifying maxvalue stopbits 

========================= corefx sample_635 =========================

public void callback() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	callbackhandler callbackhandler = new callbackhandler();	
verifying beginwrite with a callback specified 

public void callback_state() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	callbackhandler callbackhandler = new callbackhandler();	
verifying beginwrite with a callback and state specified 

public void inbreak() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying beginwrite throws invalidoperationexception while in a break 

public void callback(iasyncresult writeaysncresult) {	
about to enter callback lock already entered 

public void callback(iasyncresult writeaysncresult) {	lock (this) {	
inside callback lock 

========================= corefx sample_590 =========================

public void writeafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to cloes 

public void writeafterbasestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to basestream close 

public void bytestowrite() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying bytestowrite with one call to write 

public void bytestowritesuccessive() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying bytestowrite with successive calls to write 

========================= corefx sample_601 =========================

public void greedyread() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	random rndgen = new random(-55);	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.surrogates);	byte[] bytexmitbuffer = new byte[1024];	char utf32char = (char)8169;	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	int numcharsread;	
verifying that read char int int will read everything from internal buffer and drivers buffer 

public void read_datareceivedbeforetimeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	char[] charrcvbuffer = new char[charxmitbuffer.length];	asyncread asyncread = new asyncread(com1, charrcvbuffer, 0, charrcvbuffer.length);	var asyncreadtask = new task(asyncread.read);	
verifying that read char int int will read characters that have been received after the call to read was made 

public void read_resizebuffer() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(1023, tcsupport.characteroptions.ascii);	int readresult;	
verifying that read char int int will compact data in the buffer 

public void read_timeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	byte[] bytexmitbuffer = new utf32encoding().getbytes(charxmitbuffer);	char[] charrcvbuffer = new char[charxmitbuffer.length];	int result;	
verifying that read char int int works appropriately after timeoutexception has been thrown 

public void read_partial() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char utf32char = (char)0x254b;	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	char[] charrcvbuffer = new char[3];	int result;	
verifying that read char int int works when reading partial characters 

public void read_surrogateboundary() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = new char[32];	int result;	
verifying that read char int int works with reading surrogate characters 

try {	charsread = com1.read(rcvbuffer, offset, count);	}	catch (timeoutexception) {	break;	}	int bytesread = com1.encoding.getbytecount(rcvbuffer, offset, charsread);	totalbytesread += bytesread;	if (expectedchars.length < totalcharsread + charsread) {	debug.writeline("count={0}, charsread={1} expectedchars.length={2}, totalcharsread={3}", count, charsread, expectedchars.length, totalcharsread);	
rcvbuffer 

charsread = com1.read(rcvbuffer, offset, count);	}	catch (timeoutexception) {	break;	}	int bytesread = com1.encoding.getbytecount(rcvbuffer, offset, charsread);	totalbytesread += bytesread;	if (expectedchars.length < totalcharsread + charsread) {	debug.writeline("count={0}, charsread={1} expectedchars.length={2}, totalcharsread={3}", count, charsread, expectedchars.length, totalcharsread);	tcsupport.printchars(rcvbuffer);	
expectedchars 

int bytesread = com1.encoding.getbytecount(rcvbuffer, offset, charsread);	totalbytesread += bytesread;	if (expectedchars.length < totalcharsread + charsread) {	debug.writeline("count={0}, charsread={1} expectedchars.length={2}, totalcharsread={3}", count, charsread, expectedchars.length, totalcharsread);	tcsupport.printchars(rcvbuffer);	tcsupport.printchars(expectedchars);	fail("error!!!: we have received more characters then were sent");	}	if (count != charsread && (count < charsread || ((expectedchars.length - totalcharsread) != charsread && !tcsupport.issurrogate(expectedchars[totalcharsread + charsread])))) {	debug.writeline("count={0}, charsread={1} expectedchars.length={2}, totalcharsread={3}", count, charsread, expectedchars.length, totalcharsread);	
rcvbuffer 

totalbytesread += bytesread;	if (expectedchars.length < totalcharsread + charsread) {	debug.writeline("count={0}, charsread={1} expectedchars.length={2}, totalcharsread={3}", count, charsread, expectedchars.length, totalcharsread);	tcsupport.printchars(rcvbuffer);	tcsupport.printchars(expectedchars);	fail("error!!!: we have received more characters then were sent");	}	if (count != charsread && (count < charsread || ((expectedchars.length - totalcharsread) != charsread && !tcsupport.issurrogate(expectedchars[totalcharsread + charsread])))) {	debug.writeline("count={0}, charsread={1} expectedchars.length={2}, totalcharsread={3}", count, charsread, expectedchars.length, totalcharsread);	tcsupport.printchars(rcvbuffer);	
expectedchars 

private void verifybytesfollowedbychars(encoding encoding) {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] xmitcharbuffer = tcsupport.getrandomchars(numrndbytestoread, tcsupport.characteroptions.surrogates);	char[] rcvcharbuffer = new char[xmitcharbuffer.length];	byte[] xmitbytebuffer = new byte[numrndbytestoread];	byte[] rcvbytebuffer = new byte[xmitbytebuffer.length];	random rndgen = new random(-55);	int numread;	
verifying read method does not alter stream of bytes after chars have been read with 

fail("error!!!: expected to read {0} bytes actually read {1}", xmitbytebuffer.length, numread);	}	for (int i = 0; i < xmitbytebuffer.length; i++) {	if (xmitbytebuffer[i] != rcvbytebuffer[i]) {	fail("error!!!: expected to read {0}  actual read  {1} at {2}", (int)xmitbytebuffer[i], (int)rcvbytebuffer[i], i);	}	}	assert.equal(0, com1.bytestoread);	if(!retvalue) {	for(int i=0; i<xmitcharbuffer.length; ++i) {	
char 

========================= corefx sample_650 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	
error 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	errorcount++;	errorinnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

========================= corefx sample_12498 =========================

++_picount;	}	if (xmlnodetype.significantwhitespace == reader.nodetype) {	++_wscount;	}	if (xmlnodetype.comment == reader.nodetype) {	++_commentcount;	}	}	if (pi && _picount > 0) {	
processinginstruction found 

if (xmlnodetype.comment == reader.nodetype) {	++_commentcount;	}	}	if (pi && _picount > 0) {	cerror.writelineignore(reader.name);	cerror.writelineignore(">" + reader.value + "<");	return false;	}	if (comm && _commentcount > 0) {	
comment found 

cerror.writelineignore(reader.name);	cerror.writelineignore(">" + reader.value + "<");	return false;	}	if (comm && _commentcount > 0) {	cerror.writelineignore(reader.name);	cerror.writelineignore(">" + reader.value + "<");	return false;	}	if (ws && _wscount > 0) {	
significant whitespace found 

========================= corefx sample_12589 =========================

public reflectpropertydescriptor(type componentclass, string name, type type, attribute[] attributes) : base(name, attributes) {	
creating reflectpropertydescriptor for componentclass fullname name 

public override object getvalue(object component) {	
name getvalue component gettype name 

public override object getvalue(object component) {	if (isextender) {	
name returning null 

if (name == null) {	name = component.gettype().fullname;	}	if (t is targetinvocationexception) {	t = t.innerexception;	}	string message = t.message ?? t.gettype().name;	throw new targetinvocationexception(string.format(sr.errorpropertyaccessorexception, name, name, message), t);	}	}	
returning null 

public override void setvalue(object component, object value) {	
name setvalue component gettype name value gettype name 

========================= corefx sample_7061 =========================

static internal void insertprincipal( principal p, storectx storectx, groupmembershipupdater updategroupmembership, netcred credentials, authenticationtypes authtypes, bool needtosetpassword) {	
sdsutils entering insertprincipal 

static internal void insertprincipal( principal p, storectx storectx, groupmembershipupdater updategroupmembership, netcred credentials, authenticationtypes authtypes, bool needtosetpassword) {	debug.assert(storectx != null);	debug.assert(storectx is adstorectx || storectx is samstorectx);	debug.assert(p != null);	if ((!(p is userprincipal)) && (!(p is groupprincipal)) && (!(p is authenticableprincipal)) && (!(p is computerprincipal))) {	
sdsutils insertprincipal bad principal type 

static internal void insertprincipal( principal p, storectx storectx, groupmembershipupdater updategroupmembership, netcred credentials, authenticationtypes authtypes, bool needtosetpassword) {	debug.assert(storectx != null);	debug.assert(storectx is adstorectx || storectx is samstorectx);	debug.assert(p != null);	if ((!(p is userprincipal)) && (!(p is groupprincipal)) && (!(p is authenticableprincipal)) && (!(p is computerprincipal))) {	throw new invalidoperationexception( string.format(cultureinfo.currentculture, sr.storectxunsupportedprincipaltypeforsave, p.gettype().tostring()));	}	sdsutils.applychangestodirectory( p, storectx, updategroupmembership, credentials, authtypes );	if (needtosetpassword && p.getchangestatusforproperty(propertynames.pwdinfopassword)) {	
sdsutils insertprincipal setting password 

if (needtosetpassword && p.getchangestatusforproperty(propertynames.pwdinfopassword)) {	debug.assert(p is authenticableprincipal);	string password = (string)p.getvalueforproperty(propertynames.pwdinfopassword);	debug.assert(password != null);	storectx.setpassword((authenticableprincipal)p, password);	}	if (p.getchangestatusforproperty(propertynames.pwdinfoexpireimmediately)) {	debug.assert(p is authenticableprincipal);	bool expireimmediately = (bool)p.getvalueforproperty(propertynames.pwdinfoexpireimmediately);	if (expireimmediately) {	
sdsutils insertprincipal setting pwd expired 

static internal void applychangestodirectory( principal p, storectx storectx, groupmembershipupdater updategroupmembership, netcred credentials, authenticationtypes authtypes) {	
sdsutils entering applychangestodirectory 

debug.assert(storectx != null);	debug.assert(storectx is adstorectx || storectx is samstorectx || storectx is adamstorectx);	debug.assert(p != null);	debug.assert(updategroupmembership != null);	directoryentry de = (directoryentry)storectx.pushchangestonative(p);	debug.assert(de == p.underlyingobject);	try {	de.commitchanges();	}	catch (system.runtime.interopservices.comexception e) {	
sdsutils applychangestodirectory caught comexception with message 

debug.assert(updategroupmembership != null);	directoryentry de = (directoryentry)storectx.pushchangestonative(p);	debug.assert(de == p.underlyingobject);	try {	de.commitchanges();	}	catch (system.runtime.interopservices.comexception e) {	throw (exceptionhelper.getexceptionfromcomexception(e));	}	if ((p is groupprincipal) && (p.getchangestatusforproperty(propertynames.groupmembers))) {	
sdsutils applychangestodirectory updating group membership 

static internal void setpassword(directoryentry de, string newpassword) {	debug.assert(newpassword != null);	debug.assert(de != null);	try {	de.invoke("setpassword", new object[] { newpassword });	}	catch (system.reflection.targetinvocationexception e) {	
sdsutils setpassword caught targetinvocationexception with message 

static internal void changepassword(directoryentry de, string oldpassword, string newpassword) {	debug.assert(newpassword != null);	debug.assert(oldpassword != null);	debug.assert(de != null);	try {	de.invoke("changepassword", new object[] { oldpassword, newpassword });	}	catch (system.reflection.targetinvocationexception e) {	
sdsutils changepassword caught targetinvocationexception with message 

static internal directoryentry builddirectoryentry(string path, netcred credentials, authenticationtypes authtypes) {	directoryentry de = new directoryentry(path, credentials != null ? credentials.username : null, credentials != null ? credentials.password : null, authtypes);	
sdsutils builddirectoryentry built de for 

static internal directoryentry builddirectoryentry(netcred credentials, authenticationtypes authtypes) {	directoryentry de = new directoryentry();	de.username = credentials != null ? credentials.username : null;	de.password = credentials != null ? credentials.password : null;	de.authenticationtype = authtypes;	
sdsutils builddirectoryentry built de 

static internal void writeattribute(string depath, string attribute, int value, netcred credentials, authenticationtypes authtypes) {	
sdsutils writeattribute writing to on 

debug.assert(attribute != null && attribute.length > 0);	directoryentry copyofde = null;	try {	copyofde = sdsutils.builddirectoryentry(depath, credentials, authtypes);	debug.assert(copyofde != null);	copyofde.refreshcache(new string[] { attribute });	copyofde.properties[attribute].value = value;	copyofde.commitchanges();	}	catch (system.runtime.interopservices.comexception e) {	
sdsutils writeattribute caught exception with message writing to on 

========================= corefx sample_9033 =========================

public static void readline(bool consolein) {	string expectedline = $"this is a test of console.{(consolein ? "in." : "")}readline.";	
please type the sentence without the quotes 

public static void inpeek() {	
please type without the quotes you shouldn t see it as you type 

public static void readkey() {	
please type without the quotes you shouldn t see it as you type 

public static void keyavailable() {	
wait a few seconds then press any key 

public static void keyavailable() {	while (console.keyavailable) {	console.readkey();	}	while (!console.keyavailable) {	task.delay(500).wait();	
waiting 

public static void cursorpositionandarrowkeys() {	
use the up down left and right arrow keys to move around when done press enter 

========================= corefx sample_4348 =========================

private void elementidentityconstraints() {	for (int i = _startidconstraint; i < _validationstack.length; i++) {	if (((validationstate)(_validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[i]).constr;	for (int j = 0; j < constraints.length; ++j) {	if (constraints[j].axisselector.movetostartelement(reader.localname, reader.namespaceuri)) {	
selector match 

private void elementidentityconstraints() {	for (int i = _startidconstraint; i < _validationstack.length; i++) {	if (((validationstate)(_validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[i]).constr;	for (int j = 0; j < constraints.length; ++j) {	if (constraints[j].axisselector.movetostartelement(reader.localname, reader.namespaceuri)) {	
name uri 

continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[i]).constr;	for (int j = 0; j < constraints.length; ++j) {	if (constraints[j].axisselector.movetostartelement(reader.localname, reader.namespaceuri)) {	constraints[j].axisselector.pushks(positioninfo.linenumber, positioninfo.lineposition);	}	for (int k = 0; k < constraints[j].axisfields.count; ++k) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[j].axisfields[k];	if (laxis.movetostartelement(reader.localname, reader.namespaceuri)) {	
element field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, schemaattdef attdef) {	for (int ci = _startidconstraint; ci < _validationstack.length; ci++) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, schemaattdef attdef) {	for (int ci = _startidconstraint; ci < _validationstack.length; ci++) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field filling value 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, schemaattdef attdef) {	for (int ci = _startidconstraint; ci < _validationstack.length; ci++) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
name uri value 

private void endelementidentityconstraints() {	for (int ci = _validationstack.length - 1; ci >= _startidconstraint; ci--) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
element field filling value 

private void endelementidentityconstraints() {	for (int ci = _validationstack.length - 1; ci >= _startidconstraint; ci--) {	if (((validationstate)(_validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)_validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
name uri value 

========================= corefx sample_13049 =========================

testserviceinstaller.displayname = args[1];	if (args[2] == "create") {	testserviceinstaller.install();	return 0;	}	else if (args[2] == "delete") {	testserviceinstaller.removeservice();	return 0;	}	else {	
eroor invalid service verb only suppot create or delete 

return 0;	}	else if (args[2] == "delete") {	testserviceinstaller.removeservice();	return 0;	}	else {	return 2;	}	}	
usage servicename displayname create delete 

========================= corefx sample_2891 =========================

ityperesolutionservice resolver = (ityperesolutionservice)context.getservice(typeof(ityperesolutionservice));	if (resolver != null) {	modulepath = resolver.getpathofassembly(type.assembly.getname());	}	}	if (modulepath == null) {	modulepath = type.module.fullyqualifiedname;	}	string moduledir = path.getdirectoryname(modulepath);	string licensefile = moduledir + "\\" + type.fullname + ".lic";	
looking for license in licensefile 

========================= corefx sample_7055 =========================

public static datacolumn getdatacolumnbyschemaaction(string sourcecolumn, string datasetcolumn, datatable datatable, type datatype, missingschemaaction schemaaction) {	if (null == datatable) {	throw adp.argumentnull(nameof(datatable));	}	if (string.isnullorempty(datasetcolumn)) {	#if debug if (adapterswitches.dataschema.tracewarning) {	
explicit filtering of sourcecolumn sourcecolumn 

#endif return null;	}	datacolumncollection columns = datatable.columns;	debug.assert(null != columns, "getdatacolumnbyschemaaction: unexpected null datacolumncollection");	int index = columns.indexof(datasetcolumn);	if ((0 <= index) && (index < columns.count)) {	datacolumn datacolumn = columns[index];	debug.assert(null != datacolumn, "getdatacolumnbyschemaaction: unexpected null datacolumn");	if (!string.isnullorempty(datacolumn.expression)) {	#if debug if (adapterswitches.dataschema.traceerror) {	
schema mismatch on datacolumn datasetcolumn which is a computed column 

if ((0 <= index) && (index < columns.count)) {	datacolumn datacolumn = columns[index];	debug.assert(null != datacolumn, "getdatacolumnbyschemaaction: unexpected null datacolumn");	if (!string.isnullorempty(datacolumn.expression)) {	#if debug if (adapterswitches.dataschema.traceerror) {	}	#endif throw adp.columnschemaexpression(sourcecolumn, datasetcolumn);	}	if ((null == datatype) || (datatype.isarray == datacolumn.datatype.isarray)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
schema match on datacolumn datasetcolumn 

========================= corefx sample_3559 =========================

public samstorectx(directoryentry ctxbase, bool ownctxbase, string username, string password, contextoptions options) {	debug.assert(ctxbase != null);	
samstorectx constructing samstorectx for 

private void loadcomputerinfo() {	
samstorectx loadcomputerinfo 

========================= corefx sample_9042 =========================

public void tempfiles3() {	try {	string xsl = "<root xmlns:ns=\"testing\">" + "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http: + "<xsl:template match=\"/\">" + "<xsl:value-of select=\"ns:test\" />" + "</xsl:template>" + "</xsl:stylesheet>" + "</root>";	xmlreader r = xmlreader.create(new stringreader(xsl));	while (r.nodetype != xmlnodetype.element || r.localname != "stylesheet") {	if (!r.read()) {	
there is no stylesheet element in the file 

xmlreader r = xmlreader.create(new stringreader(xsl));	while (r.nodetype != xmlnodetype.element || r.localname != "stylesheet") {	if (!r.read()) {	assert.true(false);	}	}	xslcompiledtransform t = new xslcompiledtransform();	t.load(r);	}	catch (xsltexception exception) {	
the following exception should not have been thrown 

public void tempfiles4() {	try {	xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("bug482971.xsl"));	xslt.transform(fullfilepath("bug482971.xml"), "out.txt");	}	catch (exception exception) {	
no exception should not have been thrown 

========================= corefx sample_12638 =========================

breturn = diff.compare(xrexpected, xractual);	}	catch (exception e) {	cerror.writeline(e);	}	finally {	xractual.dispose();	xrexpected.dispose();	}	if (!breturn) {	
mismatch in xmldiff 

breturn = diff.compare(xrexpected, xractual);	}	catch (exception e) {	cerror.writeline(e);	}	finally {	xractual.dispose();	xrexpected.dispose();	}	if (!breturn) {	
actual o p 

public bool comparestring(string strexpected) {	string stractual = this.getstring();	if (strexpected != stractual) {	int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i;	for (i = 0; i < minlen; i++) {	if (strexpected[i] != stractual[i]) {	
position 

public bool comparestring(string strexpected) {	string stractual = this.getstring();	if (strexpected != stractual) {	int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i;	for (i = 0; i < minlen; i++) {	if (strexpected[i] != stractual[i]) {	
expected char 

public bool comparestring(string strexpected) {	string stractual = this.getstring();	if (strexpected != stractual) {	int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i;	for (i = 0; i < minlen; i++) {	if (strexpected[i] != stractual[i]) {	
actual char 

int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i;	for (i = 0; i < minlen; i++) {	if (strexpected[i] != stractual[i]) {	break;	}	}	if (i == minlen) {	
expected length actual length 

int minlen = (explen < actlen ? explen : actlen);	int i;	for (i = 0; i < minlen; i++) {	if (strexpected[i] != stractual[i]) {	break;	}	}	if (i == minlen) {	return false;	}	
expected string 

int minlen = (explen < actlen ? explen : actlen);	int i;	for (i = 0; i < minlen; i++) {	if (strexpected[i] != stractual[i]) {	break;	}	}	if (i == minlen) {	return false;	}	
actual string 

mydict<string, object> autoids = new mydict<string, object>();	list<string> attnames = new list<string>();	list<string> attscopes = new list<string>();	string stractual = this.getstring();	int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i, j = 0;	for (i = 0; i < actlen; i++) {	if (j >= explen) {	
output longer than expected 

mydict<string, object> autoids = new mydict<string, object>();	list<string> attnames = new list<string>();	list<string> attscopes = new list<string>();	string stractual = this.getstring();	int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i, j = 0;	for (i = 0; i < actlen; i++) {	if (j >= explen) {	
actual string 

int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i, j = 0;	for (i = 0; i < actlen; i++) {	if (j >= explen) {	return false;	}	if (strexpected[j] != stractual[i]) {	if (strexpected[j] != prefix_char) {	
position 

int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i, j = 0;	for (i = 0; i < actlen; i++) {	if (j >= explen) {	return false;	}	if (strexpected[j] != stractual[i]) {	if (strexpected[j] != prefix_char) {	
expected char 

int explen = (strexpected == null ? 0 : strexpected.length);	int actlen = (stractual == null ? 0 : stractual.length);	int minlen = (explen < actlen ? explen : actlen);	int i, j = 0;	for (i = 0; i < actlen; i++) {	if (j >= explen) {	return false;	}	if (strexpected[j] != stractual[i]) {	if (strexpected[j] != prefix_char) {	
actual char 

while (strexpected[j] != ' ') {	expname += strexpected[j++];	}	j++;	while (strexpected[j] != prefix_char) {	scope += strexpected[j++];	}	if (autogenerated) {	if (autoids.containskey(expname)) {	if ((string)autoids[expname] != actname) {	
invalid prefix 

if ((string)autoids[expname] != actname) {	return false;	}	}	else {	autoids.add(expname, actname);	}	}	else {	if (expname != actname) {	
invalid prefix 

}	}	else {	if (expname != actname) {	return false;	}	}	for (int k = 0; k < attnames.count; k++) {	if ((string)attnames[k] == actname) {	for (int m = 0; m < ((string)attscopes[k]).length; m++) for (int n = 0; n < scope.length; n++) if (((string)attscopes[k])[m] == scope[n]) {	
invalid prefix 

return false;	}	}	}	attnames.add(actname);	attscopes.add(scope);	}	j++;	}	if (j != explen) {	
output shorter than expected 

return false;	}	}	}	attnames.add(actname);	attscopes.add(scope);	}	j++;	}	if (j != explen) {	
actual string 

========================= corefx sample_4595 =========================

public void opendevices01() {	dosdevices dosdevices = new dosdevices();	regex comportnameregex = new regex(@"com\d{1,3}", regexoptions.ignorecase);	foreach (keyvaluepair<string, string> keyvaluepair in dosdevices) {	if (!string.isnullorempty(keyvaluepair.key) && !comportnameregex.ismatch(keyvaluepair.key)) {	using (serialport com1 = new serialport(keyvaluepair.key)) {	
checking exception thrown with key keyvaluepair key 

dosdevices dosdevices = new dosdevices();	regex comportnameregex = new regex(@"com\d{1,3}", regexoptions.ignorecase);	foreach (keyvaluepair<string, string> keyvaluepair in dosdevices) {	if (!string.isnullorempty(keyvaluepair.key) && !comportnameregex.ismatch(keyvaluepair.key)) {	using (serialport com1 = new serialport(keyvaluepair.key)) {	assert.throwsany<exception>(() => com1.open());	}	}	if (!string.isnullorempty(keyvaluepair.value) && !comportnameregex.ismatch(keyvaluepair.key)) {	using (serialport com1 = new serialport(keyvaluepair.value)) {	
checking exception thrown with value keyvaluepair value 

========================= corefx sample_683 =========================

private delegate int writemethoddelegate(serialport com, int buffersize);	#region test cases [conditionalfact(nameof(hasoneserialport))]	public void bytestowrite_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default bytestowrite 

public void bytestowrite_write_byte_int_int() {	
verifying bytestowrite with write byte buffer int offset int count 

public void bytestowrite_write_char_int_int() {	
verifying bytestowrite with write char buffer int offset int count 

public void bytestowrite_write_str() {	
verifying bytestowrite with writechar 

========================= corefx sample_670 =========================

public void receivedbytesthreshold_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	receivedeventhandler rcveventhandler = new receivedeventhandler(com1);	serialportproperties serportprop = new serialportproperties();	com1.open();	com2.open();	com1.datareceived += rcveventhandler.handleevent;	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying default receivedbytesthreshold 

serialportproperties serportprop = new serialportproperties();	random rndgen = new random(-55);	int receivedbytesthreshold = rndgen.next(min_rnd_threshold, max_rnd_threshold);	com1.receivedbytesthreshold = receivedbytesthreshold;	com1.open();	com2.open();	com1.datareceived += rcveventhandler.handleevent;	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("receivedbytesthreshold", receivedbytesthreshold);	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying writing exactly the number of bytes of receivedbytesthreshold 

serialportproperties serportprop = new serialportproperties();	random rndgen = new random(-55);	int receivedbytesthreshold = rndgen.next(min_rnd_threshold, max_rnd_threshold);	com1.receivedbytesthreshold = receivedbytesthreshold;	com1.open();	com2.open();	com1.datareceived += rcveventhandler.handleevent;	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("receivedbytesthreshold", receivedbytesthreshold);	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying writing the number of bytes of receivedbytesthreshold after several write calls 

serialportproperties serportprop = new serialportproperties();	random rndgen = new random(-55);	int receivedbytesthreshold = rndgen.next(min_rnd_threshold, max_rnd_threshold);	com1.receivedbytesthreshold = receivedbytesthreshold + 1;	com1.open();	com2.open();	com1.datareceived += rcveventhandler.handleevent;	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("receivedbytesthreshold", receivedbytesthreshold);	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying writing less then number of bytes of receivedbytesthreshold then setting receivedbytesthreshold to the number of bytes written 

serialportproperties serportprop = new serialportproperties();	random rndgen = new random(-55);	int receivedbytesthreshold = rndgen.next(min_rnd_threshold, max_rnd_threshold);	com1.receivedbytesthreshold = receivedbytesthreshold + 1;	com1.open();	com2.open();	com1.datareceived += rcveventhandler.handleevent;	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("receivedbytesthreshold", receivedbytesthreshold - 1);	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying writing less then number of bytes of receivedbytesthreshold then setting receivedbytesthreshold to less then the number of bytes written 

serialportproperties serportprop = new serialportproperties();	random rndgen = new random(-55);	int receivedbytesthreshold = rndgen.next(min_rnd_threshold, max_rnd_threshold);	com1.receivedbytesthreshold = receivedbytesthreshold + 1;	com1.open();	com2.open();	com1.datareceived += rcveventhandler.handleevent;	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("receivedbytesthreshold", 1);	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying writing less then number of bytes of receivedbytesthreshold then setting receivedbytesthreshold to 

public void receivedbytesthreshold_int32minvalue() {	
verifying minvalue receivedbytesthreshold 

public void receivedbytesthreshold_neg1() {	
verifying receivedbytesthreshold 

public void receivedbytesthreshold_0() {	
verifying receivedbytesthreshold 

========================= corefx sample_621 =========================

public static bool equalall<t1, t2>(this ienumerable<t1> first, ienumerable<t2> second, iequalitycomparer<t2> comparer) where t1 : expectedvalue {	using (ienumerator<t1> e1 = first.getenumerator()) using (ienumerator<t2> e2 = second.getenumerator()) {	while (e1.movenext()) {	if (e2.movenext()) {	if (e1.current.isoriginalnode) {	if (e1.current.data is xtext && !(e1.current.data is xcdata)) if (!object.referenceequals(e1.current.originalreference, e2.current)) {	
xtext reference comparison 

while (e1.movenext()) {	if (e2.movenext()) {	if (e1.current.isoriginalnode) {	if (e1.current.data is xtext && !(e1.current.data is xcdata)) if (!object.referenceequals(e1.current.originalreference, e2.current)) {	return false;	}	else {	continue;	}	if (!e1.current.data.equals(e2.current)) {	
reference comparison 

}	else {	continue;	}	if (!e1.current.data.equals(e2.current)) {	return false;	}	}	else {	if (!comparer.equals((t2)e1.current.data, e2.current)) {	
comparer comparison 

return false;	}	}	else {	if (!comparer.equals((t2)e1.current.data, e2.current)) {	return false;	}	}	}	else {	
no match in actual values 

if (!comparer.equals((t2)e1.current.data, e2.current)) {	return false;	}	}	}	else {	return false;	}	}	if (e2.movenext()) {	
outstanding actual value 

public static bool equalallattributes<t1, t2>(this ienumerable<t1> first, ienumerable<t2> second, iequalitycomparer<t2> comparer) where t1 : expectedvalue where t2 : xattribute {	if (first.isempty() && (second == null || second.isempty())) return true;	if (first.isempty()) {	
expected values empty 

public static bool equalallattributes<t1, t2>(this ienumerable<t1> first, ienumerable<t2> second, iequalitycomparer<t2> comparer) where t1 : expectedvalue where t2 : xattribute {	if (first.isempty() && (second == null || second.isempty())) return true;	if (first.isempty()) {	return false;	}	if (second == null || second.isempty()) {	
attributes empty 

public static bool equalsallattributes<t1>(this ienumerable<t1> first, ienumerable<t1> second, iequalitycomparer<t1> comparer) where t1 : xattribute {	if (first.isempty() && (second == null || second.isempty())) return true;	if (first.isempty()) {	
expected attributes empty 

public static bool equalsallattributes<t1>(this ienumerable<t1> first, ienumerable<t1> second, iequalitycomparer<t1> comparer) where t1 : xattribute {	if (first.isempty() && (second == null || second.isempty())) return true;	if (first.isempty()) {	return false;	}	if (second == null || second.isempty()) {	
actual attributes empty 

========================= corefx sample_11673 =========================

public void setpassword(string newpassword) {	if (newpassword == null) throw new argumentnullexception("newpassword");	if (_owningprincipal.unpersisted) {	
passwordinfo setpassword saving until persisted 

public void setpassword(string newpassword) {	if (newpassword == null) throw new argumentnullexception("newpassword");	if (_owningprincipal.unpersisted) {	_storednewpassword = newpassword;	}	else {	
passwordinfo setpassword sending request 

public void changepassword(string oldpassword, string newpassword) {	if (oldpassword == null) throw new argumentnullexception("oldpassword");	if (newpassword == null) throw new argumentnullexception("newpassword");	if (_owningprincipal.unpersisted) throw new invalidoperationexception(sr.passwordinfochangepwdonunpersistedprinc);	
passwordinfo changepassword sending request 

public void expirepasswordnow() {	if (_owningprincipal.unpersisted) {	
passwordinfo expirepasswordnow saving until persisted 

public void expirepasswordnow() {	if (_owningprincipal.unpersisted) {	_expirepasswordimmediately = true;	}	else {	
passwordinfo expirepasswordnow sending request 

public void refreshexpiredpassword() {	if (_owningprincipal.unpersisted) {	
passwordinfo refreshexpiredpassword saving until persisted 

public void refreshexpiredpassword() {	if (_owningprincipal.unpersisted) {	_expirepasswordimmediately = false;	}	else {	
passwordinfo refreshexpiredpassword sending request 

========================= corefx sample_8975 =========================

public void readbuffersize_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default readbuffersize before open 

public void readbuffersize_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	
verifying default readbuffersize after open 

using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	com1.open();	serportprop = new serialportproperties();	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	
verifying default readbuffersize after close 

int origbaudrate = com1.baudrate;	com2.baudrate = 115200;	com1.baudrate = 115200;	for (int j = 0; j < 1; j++) {	com2.write(xmitbytes, 0, xmitbytes.length);	com2.write(xmitbytes, xmitbytes.length / 2, xmitbytes.length / 2);	tcsupport.waitforreadbuffertoload(com1, newbytestoread);	thread.sleep(250);	serportprop.setproperty("bytestoread", newbytestoread);	serportprop.setproperty("baudrate", 115200);	
verifying properties after bytes have been written 

for (int j = 0; j < 1; j++) {	com2.write(xmitbytes, 0, xmitbytes.length);	com2.write(xmitbytes, xmitbytes.length / 2, xmitbytes.length / 2);	tcsupport.waitforreadbuffertoload(com1, newbytestoread);	thread.sleep(250);	serportprop.setproperty("bytestoread", newbytestoread);	serportprop.setproperty("baudrate", 115200);	serportprop.verifypropertiesandprint(com1);	com1.read(rcvbytes, 0, newbytestoread);	assert.equal(xmitbytes.take(newreadbuffersize), rcvbytes.take(newreadbuffersize));	
verifying properties after bytes have been read 

serportprop.verifypropertiesandprint(com1);	com1.read(rcvbytes, 0, newbytestoread);	assert.equal(xmitbytes.take(newreadbuffersize), rcvbytes.take(newreadbuffersize));	serportprop.setproperty("bytestoread", 0);	serportprop.verifypropertiesandprint(com1);	}	com2.write(xmitbytes, 0, xmitbytes.length);	com2.write(xmitbytes, xmitbytes.length / 2, xmitbytes.length / 2);	tcsupport.waitforreadbuffertoload(com1, newbytestoread);	serportprop.setproperty("bytestoread", newbytestoread);	
verifying properties after writing bytes 

========================= corefx sample_644 =========================

public void writewithoutopen() {	using (serialport com = new serialport()) {	
verifying write method throws exception without a call to open 

public void writeafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying write method throws exception with a failed call to open 

public void writeafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to cloes 

public void bytestowrite() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndchararray asyncwriterndchararray = new asyncwriterndchararray(com, char_size_bytes_to_write);	var t = new task(asyncwriterndchararray.writerndchararray);	
verifying bytestowrite with one call to write 

public void bytestowritesuccessive() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndchararray asyncwriterndchararray = new asyncwriterndchararray(com, char_size_bytes_to_write);	var t1 = new task(asyncwriterndchararray.writerndchararray);	var t2 = new task(asyncwriterndchararray.writerndchararray);	
verifying bytestowrite with successive calls to write 

========================= corefx sample_654 =========================

public void setlength_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying setlength property throws exception after open then close 

public void setlength_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying setlength property throws exception after open then basestream close 

public void setlength_afteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying setlength method throws exception after a call to open 

public void setlength_badvalue() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying setlength method throws exception with a bad value after a call to open 

========================= corefx sample_594 =========================

public override testresult execute() {	testitems children = children;	if (children != null && children.count > 0) {	foreach (object child in children) {	testcase tc = child as testcase;	if (tc != null) {	if (testinput.istestcaseselected(tc.name)) {	
testcase 

foreach (object child in children) {	testcase tc = child as testcase;	if (tc != null) {	if (testinput.istestcaseselected(tc.name)) {	tc.init();	tc.execute();	}	}	}	}	
pass fail skip 

========================= corefx sample_11657 =========================

public void dump() {	int i;	
direction right to left left to right 

public void dump() {	int i;	debug.writeline("firstchars: " + (fcprefix == null ? "n/a" : regexcharclass.setdescription(fcprefix.getvalueordefault().prefix)));	debug.writeline("prefix:     " + (bmprefix == null ? "n/a" : regex.escape(bmprefix.tostring())));	
anchors 

public void dump() {	int i;	debug.writeline("firstchars: " + (fcprefix == null ? "n/a" : regexcharclass.setdescription(fcprefix.getvalueordefault().prefix)));	debug.writeline("prefix:     " + (bmprefix == null ? "n/a" : regex.escape(bmprefix.tostring())));	debug.writeline("");	if (bmprefix != null) {	
boyermoore 

========================= corefx sample_3151 =========================

string type = variation.params[0].tostring();	xmlreader datareader = getreader(new stringreader(_xmlstr));	positiononelement(datareader, "root");	switch (type) {	case "nns": datareader.readtodescendant("elem");	datareader.readtonextsibling("elem");	if (datareader.hasattributes) {	testlog.compare(datareader.getattribute("att"), "1", "not the expected attribute");	}	else {	
positioned on wrong element 

else {	throw new testexception(testresult.failed, "");	}	while (datareader.read()) ;	datareader.dispose();	return;	case "dns": datareader.readtodescendant("elem", "elem");	datareader.readtonextsibling("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("att") == null) {	
positioned on wrong element not on dns 

datareader.dispose();	return;	case "dns": datareader.readtodescendant("elem", "elem");	datareader.readtonextsibling("elem", "elem");	if (datareader.hasattributes) {	if (datareader.getattribute("att") == null) {	throw new testexception(testresult.failed, "");	}	}	else {	
positioned on wrong element 

else {	throw new testexception(testresult.failed, "");	}	while (datareader.read()) ;	datareader.dispose();	return;	case "ns": datareader.readtodescendant("e:elem");	datareader.readtonextsibling("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	
positioned on wrong element not on dns 

datareader.dispose();	return;	case "ns": datareader.readtodescendant("e:elem");	datareader.readtonextsibling("e:elem");	if (datareader.hasattributes) {	if (datareader.getattribute("xmlns:e") == null) {	throw new testexception(testresult.failed, "");	}	}	else {	
positioned on wrong element 

========================= corefx sample_11564 =========================

protected override void oneventcommand(eventcommandeventargs command) {	
eventsourcetest got command 

========================= corefx sample_3100 =========================

public void readwithoutopen() {	using (serialport com = new serialport()) {	
verifying read method throws exception without a call to open 

public void readafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read method throws exception with a failed call to open 

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void parityerroronlastbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(15);	byte[] bytestowrite = new byte[numrndbytespairty];	byte[] expectedbytes = new byte[numrndbytespairty];	byte[] actualbytes = new byte[numrndbytespairty + 1];	int waittime;	
verifying default parityreplace byte with a parity errro on the last byte 

private void verifybytestoread(int numbytesread, encoding encoding) {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(-55);	byte[] bytestowrite = new byte[numrndbytestoread];	for (int i = 0; i < bytestowrite.length; i++) {	bytestowrite[i] = (byte)rndgen.next(0, 256);	}	
verifying bytestoread with a buffer of 

========================= corefx sample_631 =========================

private static void validatemanifest(string baseline, string manifest) {	
baseline 

private static void validatemanifest(string baseline, string manifest) {	
test 

private static void validatemanifest(string baseline, string manifest) {	var baselineorig = path.getfullpath(baseline);	baselineorig = baselineorig.replace(@"\bin\debug\", @"\");	baselineorig = baselineorig.replace(@"\bin\release\", @"\");	
to compare windiff 

private static void validatemanifest(string baseline, string manifest) {	var baselineorig = path.getfullpath(baseline);	baselineorig = baselineorig.replace(@"\bin\debug\", @"\");	baselineorig = baselineorig.replace(@"\bin\release\", @"\");	
to update copy 

========================= corefx sample_3087 =========================

public static int errorprocessbody() {	
started error stream 

public static int errorprocessbody() {	
closed error stream 

public static int streambody() {	
started 

public static int streambody() {	
closed 

public static int write144lines() {	for (int i = 0; i < 144; i++) {	
this is line 

========================= corefx sample_3928 =========================

public bool movenext() {	
principalcollectionenumerator entering movenext 

public bool movenext() {	checkdisposed();	checkchanged();	if (_endreached) {	
principalcollectionenumerator movenext endreached 

public bool movenext() {	checkdisposed();	checkchanged();	if (_endreached) {	return false;	}	lock (_resultset) {	if (_currentmode == currentenumeratormode.none) {	_resultset.reset();	if (!_membercollection.cleared && !_membercollection.clearcompleted) {	
principalcollectionenumerator movenext none mode starting with existing values 

return false;	}	lock (_resultset) {	if (_currentmode == currentenumeratormode.none) {	_resultset.reset();	if (!_membercollection.cleared && !_membercollection.clearcompleted) {	_currentmode = currentenumeratormode.resultset;	_enumerator = null;	}	else {	
principalcollectionenumerator movenext none mode skipping existing values 

_currentmode = currentenumeratormode.resultset;	_enumerator = null;	}	else {	_currentmode = currentenumeratormode.insertedvaluescompleted;	_enumerator = (ienumerator<principal>)_insertedvaluescompleted.getenumerator();	}	}	debug.assert(_resultset != null);	if (_currentmode == currentenumeratormode.resultset) {	
principalcollectionenumerator movenext resultset mode 

}	}	debug.assert(_resultset != null);	if (_currentmode == currentenumeratormode.resultset) {	bool needtorepeat = false;	do {	bool f = _resultset.movenext();	if (f) {	principal principal = (principal)_resultset.currentasprincipal;	if (_removedvaluescompleted.contains(principal) || _removedvaluespending.contains(principal)) {	
principalcollectionenumerator movenext resultset mode found remove skipping 

bool needtorepeat = false;	do {	bool f = _resultset.movenext();	if (f) {	principal principal = (principal)_resultset.currentasprincipal;	if (_removedvaluescompleted.contains(principal) || _removedvaluespending.contains(principal)) {	needtorepeat = true;	continue;	}	else if (_insertedvaluescompleted.contains(principal) || _insertedvaluespending.contains(principal)) {	
principalcollectionenumerator movenext resultset mode found insert skipping 

needtorepeat = true;	continue;	}	else {	needtorepeat = false;	_current = principal;	return true;	}	}	else {	
principalcollectionenumerator movenext resultset mode moving to insvaluescomp mode 

}	else {	_currentmode = currentenumeratormode.insertedvaluescompleted;	_enumerator = (ienumerator<principal>)_insertedvaluescompleted.getenumerator();	needtorepeat = false;	}	}	while (needtorepeat);	}	if (_currentmode == currentenumeratormode.insertedvaluescompleted) {	
principalcollectionenumerator movenext insvaluescomp mode 

}	while (needtorepeat);	}	if (_currentmode == currentenumeratormode.insertedvaluescompleted) {	bool f = _enumerator.movenext();	if (f) {	_current = _enumerator.current;	return true;	}	else {	
principalcollectionenumerator movenext insvaluescomp mode moving to insvaluespend mode 

if (f) {	_current = _enumerator.current;	return true;	}	else {	_currentmode = currentenumeratormode.insertedvaluespending;	_enumerator = (ienumerator<principal>)_insertedvaluespending.getenumerator();	}	}	if (_currentmode == currentenumeratormode.insertedvaluespending) {	
principalcollectionenumerator movenext insvaluespend mode 

_enumerator = (ienumerator<principal>)_insertedvaluespending.getenumerator();	}	}	if (_currentmode == currentenumeratormode.insertedvaluespending) {	bool f = _enumerator.movenext();	if (f) {	_current = _enumerator.current;	return true;	}	else {	
principalcollectionenumerator movenext insvaluespend mode nothing left 

public void reset() {	
principalcollectionenumerator reset 

private void checkdisposed() {	if (_disposed) {	
principalcollectionenumerator checkdisposed accessing disposed object 

========================= corefx sample_9003 =========================

protected override void setauthprincipalenablestatus(authenticableprincipal ap, bool enable) {	debug.assert(ap.fakeprincipal == false);	bool acctdisabled;	directoryentry de = (directoryentry)ap.underlyingobject;	if (de.properties["msds-useraccountdisabled"].count > 0) {	debug.assert(de.properties["msds-useraccountdisabled"].count == 1);	acctdisabled = (bool)de.properties["msds-useraccountdisabled"][0];	}	else {	
adamstorectx setauthprincipalenablestatus can t read useraccountcontrol 

private void setuppasswordmodification(authenticableprincipal p) {	directoryentry de = (directoryentry)p.underlyingobject;	if (((this.contextoptions & contextoptions.signing) != 0) && ((this.contextoptions & contextoptions.sealing) != 0)) {	try {	de.invoke("setoption", new object[]{unsafenativemethods.ads_option_enum.ads_option_password_method, unsafenativemethods.ads_password_encoding_enum.ads_password_encode_clear});	de.options.passwordport = p.context.serverinformation.portldap;	}	catch (system.reflection.targetinvocationexception e) {	
adamstorectx setuppasswordmodification caught targetinvocationexception with message 

private list<string> populatauxobjectlist(string auxclassname) {	string schemanamingcontext;	
adamstorectx populatauxobjectlist building object list 

private list<string> populatauxobjectlist(string auxclassname) {	string schemanamingcontext;	try {	using (directoryentry deroot = new directoryentry("ldap: {	if (deroot.properties["schemanamingcontext"].count == 0) {	
adamstorectx populatauxobjectlist unable to read schemanamingcontrext from 

schemanamingcontext = (string)deroot.properties["schemanamingcontext"].value;	}	using (directoryentry descn = new directoryentry("ldap: {	using (directorysearcher dirsearcher = new directorysearcher(descn)) {	dirsearcher.filter = "(&(objectclass=classschema)(systemauxiliaryclass=" + auxclassname + "))";	dirsearcher.propertiestoload.add("ldapdisplayname");	list<string> objectclasses = new list<string>();	using (searchresultcollection searchrescollection = dirsearcher.findall()) {	foreach (searchresult res in searchrescollection) {	if (null == res.properties["ldapdisplayname"]) {	
adamstorectx populatauxobjectlist unable to read ldapdisplayname from 

using (directorysearcher dirsearcher = new directorysearcher(descn)) {	dirsearcher.filter = "(&(objectclass=classschema)(systemauxiliaryclass=" + auxclassname + "))";	dirsearcher.propertiestoload.add("ldapdisplayname");	list<string> objectclasses = new list<string>();	using (searchresultcollection searchrescollection = dirsearcher.findall()) {	foreach (searchresult res in searchrescollection) {	if (null == res.properties["ldapdisplayname"]) {	throw new principaloperationexception(sr.adamstoreunabletopopulateschemalist);	}	objectclasses.add(res.properties["ldapdisplayname"][0].tostring());	
adamstorectx populatauxobjectlist adding ldapdisplayname 

list<string> objectclasses = new list<string>();	using (searchresultcollection searchrescollection = dirsearcher.findall()) {	foreach (searchresult res in searchrescollection) {	if (null == res.properties["ldapdisplayname"]) {	throw new principaloperationexception(sr.adamstoreunabletopopulateschemalist);	}	objectclasses.add(res.properties["ldapdisplayname"][0].tostring());	}	}	objectclasses.add(auxclassname);	
adamstorectx populatauxobjectlist adding 

}	objectclasses.add(res.properties["ldapdisplayname"][0].tostring());	}	}	objectclasses.add(auxclassname);	return objectclasses;	}	}	}	catch (system.runtime.interopservices.comexception e) {	
adamstorectx populatauxobjectlist com exception 

========================= corefx sample_9037 =========================

static processinfo[] getprocessinfos(performancecounterlib library, int processindex, int threadindex, byte[] data) {	
getprocessinfos 

for (int j = 0; j < type.numinstances; j++) {	marshal.ptrtostructure(instanceptr, instance);	intptr nameptr = (intptr)((long)instanceptr + instance.nameoffset);	string instancename = marshal.ptrtostringuni(nameptr);	if (instancename.equals("_total")) continue;	intptr counterblockptr = (intptr)((long)instanceptr + instance.bytelength);	marshal.ptrtostructure(counterblockptr, counterblock);	if (type.objectnametitleindex == processindex) {	processinfo processinfo = getprocessinfo(type, (intptr)((long)instanceptr + instance.bytelength), counters);	if (processinfo.processid == 0 && string.compare(instancename, "idle", stringcomparison.ordinalignorecase) != 0) {	
getprocessinfos found a non idle process with id ignoring 

string instancename = marshal.ptrtostringuni(nameptr);	if (instancename.equals("_total")) continue;	intptr counterblockptr = (intptr)((long)instanceptr + instance.bytelength);	marshal.ptrtostructure(counterblockptr, counterblock);	if (type.objectnametitleindex == processindex) {	processinfo processinfo = getprocessinfo(type, (intptr)((long)instanceptr + instance.bytelength), counters);	if (processinfo.processid == 0 && string.compare(instancename, "idle", stringcomparison.ordinalignorecase) != 0) {	#endif }	else {	if (processinfos.containskey(processinfo.processid)) {	
getprocessinfos found a duplicate process id 

========================= corefx sample_3968 =========================

public static int main(string[] args) {	try {	using (xunitperformanceharness harness = new xunitperformanceharness(args)) {	foreach(var testname in gettestassemblies()) {	harness.runbenchmarks(gettestassembly(testname));	}	}	return 0;	}	catch (exception ex) {	
error benchmark execution failed 

public static int main(string[] args) {	try {	using (xunitperformanceharness harness = new xunitperformanceharness(args)) {	foreach(var testname in gettestassemblies()) {	harness.runbenchmarks(gettestassembly(testname));	}	}	return 0;	}	catch (exception ex) {	
ex tostring 

========================= corefx sample_4654 =========================

public void getparam1() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam2() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(null, szempty);	if (retobj != null) {	
did not return null for null param name 

public void getparam3() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(szempty, szempty);	if (retobj != null) {	
did not return null for empty string param name 

public void getparam4() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam("randomname", szempty);	if (retobj != null) {	
did not return null for non existent parameter name 

public void getparam5() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(szinvalid, szempty);	if (retobj != null) {	
did not return null for an invalid param name 

public void getparam6() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam(szlongstring, szempty, "test6");	retobj = m_xsltarg.getparam(szlongstring, szempty);	
added value retrieved value 

public void getparam7() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam("myarg1", null);	if (retobj != null) {	
did not return null for null namespace system xml tests 

public void getparam8() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test8");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam9() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test9");	retobj = m_xsltarg.getparam("myarg1", "http: if (retobj != null) {	
did not retrieve a null value for non existent uri 

public void getparam9() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test9");	retobj = m_xsltarg.getparam("myarg1", "http: if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", "http: retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
did not retrieve a null value for non existent uri 

m_xsltarg.addparam("myarg1", szempty, "test9");	retobj = m_xsltarg.getparam("myarg1", "http: if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", "http: retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
did not retrieve a null value for non existent uri 

public void getparam10() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szlongns, "test10");	retobj = m_xsltarg.getparam("myarg1", szlongns);	
added value retrieved value 

public void getparam12() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam12() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "0.00") {	
failed to add get a value for of type string 

public void getparam12() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "0.00") {	
retrieved 

m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	assert.equal(retobj.gettype(), i.gettype());	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	
added value retrieved value 

assert.true(false);	}	int i = 8;	m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	assert.equal(retobj.gettype(), i.gettype());	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	
failed to add get a value for of type boolean 

assert.true(false);	}	int i = 8;	m_xsltarg.addparam("myarg2", szempty, i);	retobj = m_xsltarg.getparam("myarg2", szempty);	assert.equal(retobj.gettype(), i.gettype());	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	
retrieved 

assert.equal(retobj.gettype(), i.gettype());	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	
added value retrieved value 

boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	
failed to add get a value for of type boolean 

boolean bf = (1 == 0);	m_xsltarg.addparam("myarg3", szempty, bf);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	
retrieved 

boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	assert.true(false);	}	xpathdocument xd = new xpathdocument(fullfilepath("fish.xml"));	m_xsltarg.addparam("myarg5", szempty, ((ixpathnavigable)xd).createnavigator());	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj == null) {	
failed to add get a value of type xpathnavigator 

boolean bt = (1 == 1);	m_xsltarg.addparam("myarg4", szempty, bt);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!bt.equals(retobj)) {	assert.true(false);	}	xpathdocument xd = new xpathdocument(fullfilepath("fish.xml"));	m_xsltarg.addparam("myarg5", szempty, ((ixpathnavigable)xd).createnavigator());	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj == null) {	
retrieved 

public void getparam14() {	int i = 1;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test" + str);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != "test" + str) {	
error processing test for whitespace arg in first set 

retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != "test" + str) {	assert.true(false);	}	i++;	}	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test");	retobj = m_xsltarg.getparam("myarg" + str, szempty);	if (retobj != null) {	
error processing test for whitespace arg in second set returned object is not null 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	
failed after retrieving times 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	
added value retrieved value 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	assert.true(false);	}	}	
retrievied times 

public void getparam16() {	m_xsltarg = new xsltargumentlist();	int i = 0;	m_xsltarg.addparam("myarg1", szempty, "test16");	for (i = 0; i < 200; i++) {	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test16") {	assert.true(false);	}	}	
added value retrieved value 

public void getparam17() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test17");	retobj = m_xsltarg.getparam("myarg3", szdefaultns);	if (retobj != null) {	
return a non null value when retrieving param with namespace 

public void getparam18() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void getparam18() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	m_xsltarg.addparam("myarg1", "http: retobj = m_xsltarg.getparam("myarg1", "http: _output.writeline("added value:{0}\nretrieved value: {1}", "test2", retobj);	if (retobj.tostring() != "test2") assert.true(false);	retobj = m_xsltarg.getparam("myarg1", szempty);	
retrieve original value actual retrieved value 

public void getparam19() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getparam(null, null);	if (retobj != null) {	
did not return null for null parameter name 

double d1 = double.positiveinfinity;	double d2 = double.negativeinfinity;	double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

double d2 = double.negativeinfinity;	double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	
failed to add get a value for 

double d2 = double.negativeinfinity;	double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	
retrieved 

double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	
failed to add get a value for 

double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	
retrieved 

if (!double.ispositiveinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	
retrieved 

if (!double.isnegativeinfinity((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	
retrieved 

if (!double.isnan((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	
retrieved 

if (!d4.equals((double)retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	
retrieved 

if (!d5.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	retobj = m_xsltarg.getparam("myarg7", szempty);	
added value retrieved value 

assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (!d7.equals(retobj)) {	
failed to add get a value for 

assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (!d6.equals(retobj)) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (!d7.equals(retobj)) {	
retrieved 

public void getparam20() {	m_xsltarg = new xsltargumentlist();	int i = 10;	
adding integer parameter of value 

public void getparam20() {	m_xsltarg = new xsltargumentlist();	int i = 10;	m_xsltarg.addparam("intarg", "", i);	type exp = i.gettype();	type act = m_xsltarg.getparam("intarg", "").gettype();	
added type 

public void getparam20() {	m_xsltarg = new xsltargumentlist();	int i = 10;	m_xsltarg.addparam("intarg", "", i);	type exp = i.gettype();	type act = m_xsltarg.getparam("intarg", "").gettype();	
returned type 

public void getextobject1(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(1, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	retobj = m_xsltarg.getextensionobject(szdefaultns);	
retrieved value 

public void getextobject1(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(1, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	retobj = m_xsltarg.getextensionobject(szdefaultns);	if (((myobject)retobj).myvalue() != obj.myvalue()) {	
set and retrieved value appear to be different 

public void getextobject2() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.getextensionobject(null);	}	catch (system.argumentnullexception) {	return;	}	
argumentnullexception not thrown for null namespace system xml tests 

public void getextobject4(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getextensionobject(szdefaultns);	if (retobj != null) {	
did not return a null value for a non existent uri 

retobj = m_xsltarg.getextensionobject(szdefaultns);	if (retobj != null) {	assert.true(false);	}	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw exception for an invalid transform 

public void getextobject5(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	m_xsltarg = new xsltargumentlist();	myobject obj = new myobject(5, _output);	m_xsltarg.addextensionobject(szlongns, obj);	retobj = m_xsltarg.getextensionobject(szlongns);	if (((myobject)retobj).myvalue() != obj.myvalue()) {	
set and retrieved value appear to be different 

public void getextobject7() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	
added value retrieved value 

public void getextobject7() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	
failed to add get a value for of type string 

public void getextobject7() {	m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	
retrieved 

m_xsltarg = new xsltargumentlist();	string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	
added value retrieved value 

string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	
failed to add get a value for with conversion from int to double 

string obj = "0.00";	m_xsltarg.addextensionobject("myarg1", obj);	retobj = m_xsltarg.getextensionobject("myarg1");	if (retobj.tostring() != "0.00") {	assert.true(false);	}	int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	
retrieved 

int i = 8;	m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	assert.true(false);	}	if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	
added value retrieved value 

m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	assert.true(false);	}	if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	
failed to add get a value for of type boolean 

m_xsltarg.addextensionobject("myarg2", i);	retobj = m_xsltarg.getextensionobject("myarg2");	if (!i.equals(retobj)) {	assert.true(false);	}	if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	
retrieved 

if (i != (int)retobj) assert.true(false);	boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	
added value retrieved value 

boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	if (!bt.equals(retobj)) {	
failed to add get a value for of type boolean 

boolean bf = (1 == 0);	m_xsltarg.addextensionobject("myarg3", bf);	retobj = m_xsltarg.getextensionobject("myarg3");	if (!bf.equals(retobj)) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addextensionobject("myarg4", bt);	retobj = m_xsltarg.getextensionobject("myarg4");	if (!bt.equals(retobj)) {	
retrieved 

public void getextobject8(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(8, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject("urn:my-object", obj);	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (((myobject)retobj).myvalue() != obj.myvalue()) {	
set and retrieved value appear to be different 

public void getextobject8(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(8, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject("urn:my-object", obj);	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (((myobject)retobj).myvalue() != obj.myvalue()) {	assert.true(false);	}	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (retobj != null) {	
set and retrieved value appear to be different for urn my object 

retobj = m_xsltarg.getextensionobject("urn:my-object");	if (((myobject)retobj).myvalue() != obj.myvalue()) {	assert.true(false);	}	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (retobj != null) {	assert.true(false);	}	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (retobj != null) {	
set and retrieved value appear to be different for urn my object 

retobj = m_xsltarg.getextensionobject("urn:my-object");	if (retobj != null) {	assert.true(false);	}	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (retobj != null) {	assert.true(false);	}	retobj = m_xsltarg.getextensionobject("urn-my:object");	if (retobj != null) {	
set and retrieved value appear to be different for urn my object 

public void getextobject9(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	int i = 1;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	myobject obj = new myobject(i, _output);	m_xsltarg.addextensionobject(szdefaultns + str, obj);	retobj = m_xsltarg.getextensionobject(szdefaultns + str);	if (((myobject)retobj).myvalue() != i) {	
error processing test for whitespace arg 

assert.true(false);	}	i++;	}	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception system xml xsl xsltexception 

public void getextobject10(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(10, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	m_xsltarg.removeextensionobject(szdefaultns);	retobj = m_xsltarg.getextensionobject(szdefaultns);	if (retobj != null) {	
did not retrieve a null value for a non existent object returned 

retobj = m_xsltarg.getextensionobject(szdefaultns);	if (retobj != null) {	assert.true(false);	}	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception system xml xsl xsltexception 

public void getextobject11(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(11, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	for (int i = 0; i < 500; i++) {	retobj = m_xsltarg.getextensionobject(szdefaultns);	if (((myobject)retobj).myvalue() != obj.myvalue()) {	
set and retrieved value appear to be different after i tries 

public void getextobject12() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.getextensionobject(szdefaultns);	if (retobj != null) {	
did not retrieve null value when using namespace 

public void addparam1(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam2() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam(null, szempty, "test1");	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for adding null param 

public void addparam3() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam(szempty, szempty, "test1");	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for param name empty string 

public void addparam4(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam(szlongstring, szempty, "test1");	retobj = m_xsltarg.getparam(szlongstring, szempty);	
added value retrieved value 

public void addparam5() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam(szinvalid, szempty, "test1");	}	catch (system.xml.xmlexception) {	return;	}	
system xml xmlexception not thrown for invalid param name 

public void addparam6() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam("myarg1", null, "test1");	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for null namespace system xml tests 

public void addparam7(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test7");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam8(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szlongns, "test8");	retobj = m_xsltarg.getparam("myarg1", szlongns);	
added value retrieved value 

public void addparam11() {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	try {	m_xsltarg.addparam("myarg1", szempty, "test1");	}	catch (system.argumentexception) {	return;	}	
did not throw system argumentexception for adding a param that already exists 

public void addparam12(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam12(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", "http: retobj = m_xsltarg.getparam("myarg1", "http: _output.writeline("added value:{0}\nretrieved value: {1}", "test2", retobj);	if (retobj.tostring() != "test2") assert.true(false);	retobj = m_xsltarg.getparam("myarg1", szempty);	
retrieve original value actual retrieved value 

public void addparam13(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam13(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

public void addparam13(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != "test2") assert.true(false);	retobj = m_xsltarg.getparam("myarg1", szempty);	
retrieve original value actual retrieved value 

public void addparam14(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

public void addparam14(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", szempty, "test2");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", szempty, "test2");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	
added value retrieved value 

retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg1", szempty, "test2");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg2", szempty, "test2");	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg3", szempty, "test3");	retobj = m_xsltarg.getparam("myarg3", szempty);	
added value retrieved value 

public void addparam15() {	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addparam("myarg1", szempty, null);	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not thrown for null object 

public void addparam16(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	string obj = "test";	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg2", szempty, obj + i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != ("test" + i)) {	
failed to add remove iteration 

retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != ("test" + i)) {	assert.true(false);	}	m_xsltarg.removeparam("myarg2", szempty);	}	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg" + i, szempty, obj + i);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != (obj + i)) {	
failed in part to add remove iteration 

public void addparam17(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	int i = 1;	int errcount = 0;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	try {	m_xsltarg.addparam("myarg" + i, szempty, "test" + str);	}	catch (system.xml.xmlexception) {	
improperly reported an exception for a whitespace value 

m_xsltarg.addparam("myarg" + str, szempty, "test");	}	catch (system.xml.xmlexception) {	errcount++;	}	finally {	errcount--;	}	}	if (errcount != 0) {	
at least one whitespace test failed 

public void addparam19(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	string obj = "test";	for (int i = 0; i < 300; i++) {	m_xsltarg.addparam("myarg" + i, szempty, obj + "1");	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != ("test" + "1")) {	
failed to add myarg 

public void addparam20(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", "urn:" + szxslns, "test1");	retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	
added value retrieved value 

public void addparam20(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", "urn:" + szxslns, "test1");	retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", "urn:tmp", "test2");	retobj = m_xsltarg.getparam("myarg2", "urn:tmp");	
added value retrieved value 

string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", "urn:" + szxslns, "test1");	retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", "urn:tmp", "test2");	retobj = m_xsltarg.getparam("myarg2", "urn:tmp");	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg3", "urn:my-object", "test3");	retobj = m_xsltarg.getparam("myarg3", "urn:my-object");	
added value retrieved value 

retobj = m_xsltarg.getparam("myarg1", "urn:" + szxslns);	if (retobj.tostring() != "test1") assert.true(false);	m_xsltarg.addparam("myarg2", "urn:tmp", "test2");	retobj = m_xsltarg.getparam("myarg2", "urn:tmp");	if (retobj.tostring() != "test2") assert.true(false);	m_xsltarg.addparam("myarg3", "urn:my-object", "test3");	retobj = m_xsltarg.getparam("myarg3", "urn:my-object");	if (retobj.tostring() != "test3") assert.true(false);	m_xsltarg.addparam("myarg4", "urn:my-object", "test4");	retobj = m_xsltarg.getparam("myarg4", "urn:my-object");	
added value retrieved value 

public void addextobject2() {	myobject obj = new myobject(2, _output);	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addextensionobject(null, obj);	}	catch (system.argumentnullexception) {	return;	}	
system argumentnullexception not generated for null namespace system xml tests 

myobject obj1 = new myobject(1, _output);	myobject obj2 = new myobject(2, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj1);	try {	m_xsltarg.addextensionobject(szdefaultns, obj2);	}	catch (system.argumentexception) {	return;	}	
did not launch exception system argumentexception for an item already added 

public void addextobject8(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(1, _output);	m_xsltarg = new xsltargumentlist();	string baseline = path.combine("baseline", (string)param);	m_xsltarg.addextensionobject("urn:my-object", obj);	retobj = m_xsltarg.getextensionobject("urn:my-object");	if (((myobject)retobj).myvalue() != obj.myvalue()) {	
set and retrieved value appear to be different 

public void addextobject9() {	myobject obj = new myobject(9, _output);	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.addextensionobject(szdefaultns, null);	}	catch (system.argumentnullexception) {	return;	}	
did not launch exception system argumentnullexception for adding a null valued item 

myobject obj = new myobject(i, _output);	m_xsltarg.addextensionobject(szdefaultns + str, obj);	i++;	}	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype, true);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

public void addextobject13() {	myobject obj = new myobject(13, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	try {	m_xsltarg.addextensionobject(szdefaultns, obj);	}	catch (system.argumentexception) {	return;	}	
did not exception for adding an extension object that already exists 

public void addextobject15(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(15, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szsimple, obj);	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype, true);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

m_xsltarg = new xsltargumentlist();	double d = 1;	int i = 1;	m_xsltarg.addextensionobject("urn:myspace", d);	try {	m_xsltarg.addextensionobject("urn:myspace", i);	}	catch (system.argumentexception) {	return;	}	
exception not thrown for uri namespace system xml tests in use 

m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	if ((loadxsl("myobject_notfoundns.xsl", xslinputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", outputtype, navtype, true);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for ns not found 

m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	if ((loadxsl("myobject_notfound.xsl", xslinputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", outputtype, navtype, true);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for method not found 

public void removeparam1(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	
value of removed object is not null 

public void removeparam1(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	
added value retrieved value 

m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, "test2");	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg1", szempty, "test1");	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj.tostring() != "test1") {	
value of removed object is not as expected 

public void removeparam2() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.removeparam(null, szempty);	if (retobj != null) {	
did not return null for null parameter name 

public void removeparam7() {	m_xsltarg = new xsltargumentlist();	retobj = m_xsltarg.removeparam("myarg1", null);	if (retobj != null) {	
did not return null for null uri namespace 

double d3 = double.nan;	double d4 = 2.000001;	double d5 = 0.00;	double d6 = double.maxvalue;	double d7 = double.minvalue;	m_xsltarg = new xsltargumentlist();	m_xsltarg.addparam("myarg1", szempty, d1);	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg1", szempty, d1);	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, d2);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, d2);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg3", szempty, d3);	m_xsltarg.removeparam("myarg3", szempty);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg3", szempty, d3);	m_xsltarg.removeparam("myarg3", szempty);	retobj = m_xsltarg.getparam("myarg3", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg4", szempty, d4);	m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg4", szempty, d4);	m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg5", szempty, d5);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg5", szempty, d5);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg6", szempty, d6);	m_xsltarg.removeparam("myarg6", szempty);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg6", szempty, d6);	m_xsltarg.removeparam("myarg6", szempty);	retobj = m_xsltarg.getparam("myarg6", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg7", szempty, d7);	m_xsltarg.removeparam("myarg7", szempty);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg7", szempty);	retobj = m_xsltarg.getparam("myarg7", szempty);	if (retobj != null) {	assert.true(false);	}	string obj = "0.00";	m_xsltarg.addparam("myarg1", szempty, obj);	m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg1", szempty);	retobj = m_xsltarg.getparam("myarg1", szempty);	if (retobj != null) {	assert.true(false);	}	int i = 2;	m_xsltarg.addparam("myarg2", szempty, i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	boolean bf = (1 == 0);	m_xsltarg.addparam("myarg4", szempty, bf);	m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.removeparam("myarg4", szempty);	retobj = m_xsltarg.getparam("myarg4", szempty);	if (retobj != null) {	assert.true(false);	}	boolean bt = (1 == 1);	m_xsltarg.addparam("myarg5", szempty, bt);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg5", szempty, bt);	m_xsltarg.removeparam("myarg5", szempty);	retobj = m_xsltarg.getparam("myarg5", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (int16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (int16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (uint16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (uint16)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (int32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (int32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (uint32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (uint32)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (int64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (int64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (uint64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (uint64)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (single)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

m_xsltarg.addparam("myarg2", szempty, (single)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	assert.true(false);	}	m_xsltarg.addparam("myarg2", szempty, (decimal)i);	m_xsltarg.removeparam("myarg2", szempty);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj != null) {	
failed to remove 

public void removeparam13(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	int i = 1;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test" + str);	m_xsltarg.removeparam("myarg" + i, szempty);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj != null) {	
error removing case from this test 

assert.true(false);	}	i++;	}	i = 1;	foreach (string str in szwhitespace) {	m_xsltarg.addparam("myarg" + i, szempty, "test");	m_xsltarg.removeparam("myarg" + str, szempty);	retobj = m_xsltarg.getparam("myarg" + str, szempty);	if (retobj != null) {	
error removing case in the second batch from this test 

myobject obj = new myobject(1, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	m_xsltarg.removeextensionobject(szdefaultns);	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype, true);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

public void removeextobj2() {	myobject obj = new myobject(2, _output);	m_xsltarg = new xsltargumentlist();	try {	m_xsltarg.removeextensionobject(null);	}	catch (system.argumentnullexception) {	return;	}	
exception not generated for null parameter name 

m_xsltarg = new xsltargumentlist();	myobject obj = new myobject(5, _output);	m_xsltarg.addextensionobject("urn:" + szlongns, obj);	m_xsltarg.removeextensionobject("urn:" + szlongns);	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype, true);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not throw expected exception 

public void removeextobj8(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	int i = 1;	m_xsltarg = new xsltargumentlist();	foreach (string str in szwhitespace) {	myobject obj = new myobject(i, _output);	m_xsltarg.addextensionobject(szdefaultns + str, obj);	m_xsltarg.removeextensionobject(szdefaultns + str);	retobj = m_xsltarg.getextensionobject(szdefaultns + str);	if (retobj != null) {	
error deleting case for whitespace arg 

assert.true(false);	}	i++;	}	try {	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) transform_arglist("fruits.xml", outputtype, navtype, true);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
did not exception for object that could not be executed 

public void clear4(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	myobject obj = new myobject(26, _output);	m_xsltarg = new xsltargumentlist();	m_xsltarg.addextensionobject(szdefaultns, obj);	m_xsltarg.clear();	retobj = m_xsltarg.getextensionobject(szdefaultns);	if (retobj != null) {	
did not appear to clear an extension object 

assert.true(false);	}	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", outputtype, navtype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for ns not found 

public void clear5(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	m_xsltarg = new xsltargumentlist();	string obj = "test";	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg2", szempty, obj + i);	retobj = m_xsltarg.getparam("myarg2", szempty);	if (retobj.tostring() != (obj + i)) {	
failed to add remove iteration 

if (retobj.tostring() != (obj + i)) {	_output.writeline("{0} : {1}", retobj, obj + i);	assert.true(false);	}	m_xsltarg.clear();	}	for (int i = 0; i < 200; i++) {	m_xsltarg.addparam("myarg" + i, szempty, obj + i);	retobj = m_xsltarg.getparam("myarg" + i, szempty);	if (retobj.tostring() != (obj + i)) {	
failed in part to add remove iteration 

m_xsltarg.removeextensionobject(szdefaultns);	m_xsltarg.clear();	if ((loadxsl("myobjectdef.xsl", xslinputtype, readertype) == 1)) {	try {	transform_arglist("fruits.xml", outputtype, navtype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	}	
exception not thrown for ns not found 

private void arglist_xsltmessageencountered(object sender, xsltmessageencounteredeventargs e) {	eventraised = true;	
onmessageevent raised 

if (file.exists(outfile)) file.delete(outfile);	xpathdocument doc = new xpathdocument(sourcefile);	xpathnavigator nav = doc.createnavigator();	streamwriter sw = new streamwriter(new memorystream());	xmlwriter xw = new xmltextwriter(sw);	_output.writeline(xslfile);	xslt.load(xslfile);	if (xslmessageterminate == "yes") {	try {	xslt.transform(nav, arglist, xw);	
xsltexception not raised 

streamwriter sw = new streamwriter(new memorystream());	xmlwriter xw = new xmltextwriter(sw);	_output.writeline(xslfile);	xslt.load(xslfile);	if (xslmessageterminate == "yes") {	try {	xslt.transform(nav, arglist, xw);	assert.true(false);	}	catch (xsltexception e) {	
raised 

}	else {	xslt.transform(nav, arglist, xw);	}	if (eventraised) {	verifyresult(baseline, outfile);	return;	}	else {	if (eventhandlerexists == "yes") {	
onmessageevent not raised 

========================= corefx sample_12639 =========================

public void readwithoutopen() {	using (serialport com = new serialport()) {	
verifying read method throws exception without a call to open 

public void readafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read method throws exception with a failed call to open 

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void parityerroronlastbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(15);	byte[] bytestowrite = new byte[numrndbyte];	byte[] expectedbytes = new byte[numrndbyte];	byte[] actualbytes = new byte[numrndbyte + 1];	int actualbyteindex = 0;	
verifying default parityreplace byte with a parity error on the last byte 

========================= corefx sample_682 =========================

public override void dispose() {	if(_disposed) {	return;	}	_disposed = true;	_session.flush();	thread.sleep(1010);	_session.dispose();	if (_datafilename != null) {	using (var traceeventsource = new etwtraceeventsource(_datafilename)) {	
processing data file 

}	_disposed = true;	_session.flush();	thread.sleep(1010);	_session.dispose();	if (_datafilename != null) {	using (var traceeventsource = new etwtraceeventsource(_datafilename)) {	traceeventsource.dynamic.all += oneventhelper;	traceeventsource.unhandledevents += oneventhelper;	traceeventsource.process();	
done processing data file 

public override void dispose() {	if (_disposed) {	return;	}	_disposed = true;	
disposing listener 

========================= corefx sample_3096 =========================

public void basestream_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default basestream 

public void basestream_open() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying basestream after open has been called 

public void basestream_open_close() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying basestream after open and close have been called 

public void basestream_open_basestreamclose() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying basestream after open and basestream close have been called 

========================= corefx sample_671 =========================

case xmlnodetype.documenttype: if (prxmlreader.movetofirstattribute()) {	do {	cxmlattribute rnewattribute = new cxmlattribute(prxmlreader);	rnewnode.addattribute(rnewattribute);	cxmlnode rvaluenode = new cxmlnode(prxmlreader);	rvaluenode._strvalue = prxmlreader.value;	rnewattribute.insertnode(rvaluenode);	} while (prxmlreader.movetonextattribute());	}	break;	
unhandled type in process 

========================= corefx sample_11672 =========================

public bool movenext() {	
trackedcollectionenumerator entering movenext 

public bool movenext() {	checkdisposed();	checkchanged();	if (_endreached) {	
trackedcollectionenumerator movenext endreached 

public bool movenext() {	checkdisposed();	checkchanged();	if (_endreached) {	return false;	}	if (_enumerator == null) {	
trackedcollectionenumerator movenext at beginning 

return false;	}	if (_enumerator == null) {	_enumerator = ((ienumerable)_combinedvalues).getenumerator();	debug.assert(_enumerator != null);	}	bool gotnextvalue = _enumerator.movenext();	if (gotnextvalue) {	trackedcollection<t>.valueel el = (trackedcollection<t>.valueel)_enumerator.current;	if (el.isinserted) {	
trackedcollectionenumerator movenext current is inserted 

debug.assert(_enumerator != null);	}	bool gotnextvalue = _enumerator.movenext();	if (gotnextvalue) {	trackedcollection<t>.valueel el = (trackedcollection<t>.valueel)_enumerator.current;	if (el.isinserted) {	_current = el.insertedvalue;	}	else {	_current = el.originalvalue.right;	
trackedcollectionenumerator movenext current is original 

if (gotnextvalue) {	trackedcollection<t>.valueel el = (trackedcollection<t>.valueel)_enumerator.current;	if (el.isinserted) {	_current = el.insertedvalue;	}	else {	_current = el.originalvalue.right;	}	}	else {	
trackedcollectionenumerator movenext nothing more to enumerate 

public void reset() {	
trackedcollectionenumerator reset 

private void checkdisposed() {	if (_disposed) {	
trackedcollectionenumerator checkdisposed accessing disposed object 

========================= corefx sample_8974 =========================

public long runclient( socketimplementationtype testtype, endpoint endpoint, int iterations, int buffersize, int socketinstances) {	
implementation type buffer size iterations init ms connect ms sendrecv ms close ms total time 

========================= corefx sample_4442 =========================

public bool isaccountlockedout() {	if (!_owningprincipal.unpersisted) {	
accountinfo isaccountlockedout sending lockout query 

public void unlockaccount() {	if (!_owningprincipal.unpersisted) {	
accountinfo unlockaccount sending unlock request 

========================= corefx sample_8987 =========================

xelement d = new xelement("a");	using (xmlwriter w = d.createwriter()) {	try {	w.writedoctype("root", "publicid", "sysid", "<!entity e 'abc'>");	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

xelement d = new xelement("a");	using (xmlwriter w = d.createwriter()) {	try {	w.writestartdocument();	}	catch (invalidoperationexception) {	testlog.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

========================= corefx sample_11586 =========================

public static void wipestores() {	foreach (string root in s_roots) {	try {	if (directory.exists(root)) {	directory.delete(root, recursive: true);	}	}	catch (exception e) {	
failed to wipe stores e message 

========================= corefx sample_6456 =========================

public void asciiencoding() {	
verifying read with bytes encoded with asciiencoding 

public void utf8encoding() {	
verifying read with bytes encoded with 

public void utf32encoding() {	
verifying read with bytes encoded with 

public void readtimeout_zero_resizebuffer() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	byte[] bytexmitbuffer = new byte[1024];	char utf32char = 'a';	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	char[] charxmitbuffer = tcsupport.getrandomchars(16, false);	char[] expectedchars = new char[charxmitbuffer.length + 1];	
verifying read method with zero timeout that resizes serialport s buffer 

public void readtimeout_nonzero_resizebuffer() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	byte[] bytexmitbuffer = new byte[1024];	char utf32char = 'a';	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	char[] charxmitbuffer = tcsupport.getrandomchars(16, false);	char[] expectedchars = new char[charxmitbuffer.length + 1];	
verifying read method with non zero timeout that resizes serialport s buffer 

public void greedyread() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	byte[] bytexmitbuffer = new byte[1024];	char utf32char = tcsupport.generaterandomcharnonsurrogate();	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	int charread;	
verifying that readchar will read everything from internal buffer and drivers buffer 

public void largeinputbuffer() {	
verifying read with large input buffer 

public void readtimeout_zero_bytes() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char utf32char = (char)0x254b;	byte[] utf32charbytes = encoding.utf32.getbytes(new[] { utf32char });	int readchar;	
verifying read method with zero timeout that resizes serialport s buffer 

public void read_datareceivedbeforetimeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	char[] charrcvbuffer = new char[charxmitbuffer.length];	asyncread asyncread = new asyncread(com1);	var asyncreadtask = new task(asyncread.read);	
verifying that readchar will read characters that have been received after the call to read was made 

public void read_timeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] charxmitbuffer = tcsupport.getrandomchars(512, tcsupport.characteroptions.none);	byte[] bytexmitbuffer = new utf32encoding().getbytes(charxmitbuffer);	char[] charrcvbuffer = new char[charxmitbuffer.length];	int result;	
verifying that read char int int works appropriately after timeoutexception has been thrown 

public void read_surrogate() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	char[] surrogatechars = { (char)0xdb26, (char)0xdc49 };	char[] additionalchars = tcsupport.getrandomchars(32, tcsupport.characteroptions.none);	char[] charrcvbuffer = new char[2];	
verifying that readchar works correctly when trying to read surrogate characters 

========================= corefx sample_645 =========================

public void readwithoutopen() {	using (serialport com = new serialport()) {	
verifying read method throws exception without a call to open 

public void readafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read method throws exception with a failed call to open 

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void parityerroronlastbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(15);	byte[] bytestowrite = new byte[numrndchar];	char[] expectedchars = new char[numrndchar];	char[] actualchars = new char[numrndchar + 1];	int actualcharindex = 0;	
verifying default parityreplace byte with a parity errro on the last byte 

========================= corefx sample_655 =========================

public void writeafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to cloes 

public void writeafterserialstreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write method throws exception after a call to basestream close 

public void bytestowrite() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var elapsedtime = 0;	
verifying bytestowrite with one call to write 

public void bytestowritesuccessive() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var elapsedtime = 0;	
verifying bytestowrite with successive calls to write 

========================= corefx sample_595 =========================

public void flush_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying flush throws exception after open then close 

public void flush_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying flush throws exception after open then basestream close 

public void inbufferfilled_flush_once() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	byte[] xmitbytes = new byte[default_buffer_size];	
verifying flush method after input buffer has been filled 

public void inbufferfilled_flush_multiple() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	byte[] xmitbytes = new byte[default_buffer_size];	
verifying call flush method several times after input buffer has been filled 

public void inbufferfilled_flush_cycle() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	byte[] xmitbytes = new byte[default_buffer_size];	
verifying call flush method after input buffer has been filled discarded and filled again 

public void outbufferfilled_flush_once() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com1, default_buffer_size);	var t = new task(asyncwriterndbytearray.writerndbytearray);	
verifying flush method after output buffer has been filled 

public void outbufferfilled_flush_multiple() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com1, default_buffer_size);	var t = new task(asyncwriterndbytearray.writerndbytearray);	
verifying call flush method several times after output buffer has been filled 

public void outbufferfilled_flush_cycle() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com1, default_buffer_size);	var t1 = new task(asyncwriterndbytearray.writerndbytearray);	var t2 = new task(asyncwriterndbytearray.writerndbytearray);	int elapsedtime;	
verifying call flush method after output buffer has been filled discarded and filled again 

public void inoutbufferfilled_flush_once() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com1, default_buffer_size);	var t = new task(asyncwriterndbytearray.writerndbytearray);	byte[] xmitbytes = new byte[default_buffer_size];	
verifying flush method after input and output buffer has been filled 

public void inoutbufferfilled_flush_multiple() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com1, default_buffer_size);	var t = new task(asyncwriterndbytearray.writerndbytearray);	int elapsedtime = 0;	byte[] xmitbytes = new byte[default_buffer_size];	
verifying call flush method several times after input and output buffer has been filled 

public void inoutbufferfilled_flush_cycle() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	asyncwriterndbytearray asyncwriterndbytearray = new asyncwriterndbytearray(com1, default_buffer_size);	var t1 = new task(asyncwriterndbytearray.writerndbytearray);	var t2 = new task(asyncwriterndbytearray.writerndbytearray);	byte[] xmitbytes = new byte[default_buffer_size];	
verifying call flush method after input and output buffer has been filled discarded and filled again 

========================= corefx sample_604 =========================

public bool movenext() {	globaldebug.writelineif(globaldebug.info, "findresultenumerator", "entering movenext, t={0}", typeof(t));	checkdisposed();	if (_endreached) {	
findresultenumerator movenext end previously reached 

public bool movenext() {	globaldebug.writelineif(globaldebug.info, "findresultenumerator", "entering movenext, t={0}", typeof(t));	checkdisposed();	if (_endreached) {	return false;	}	if (_resultset == null) {	
findresultenumerator movenext no resultset 

checkdisposed();	if (_endreached) {	return false;	}	if (_resultset == null) {	return false;	}	bool f;	lock (_resultset) {	if (_beforestart == true) {	
findresultenumerator movenext moving to first resultset 

lock (_resultset) {	if (_beforestart == true) {	_beforestart = false;	_resultset.reset();	}	f = _resultset.movenext();	}	if (!f) {	_endreached = true;	}	
findresultenumerator movenext returning 

public void reset() {	
findresultenumerator entering reset 

public void dispose() {	
findresultenumerator dispose disposing 

private void checkdisposed() {	if (_disposed) {	
findresultenumerator checkdisposed accessing disposed object 

========================= corefx sample_8997 =========================

private static void checkcupsinstalled() {	try {	libcupsnative.cupsgetdefault();	}	catch (dllnotfoundexception) {	
libcups not found to have printing support you need cups installed 

private static void checkcupsinstalled() {	try {	libcupsnative.cupsgetdefault();	}	catch (dllnotfoundexception) {	
libcups not found to have printing support you need cups installed 

private static intptr openprinter(string printer) {	try {	intptr ptr = libcupsnative.cupsgetppd(printer);	string ppd_filename = marshal.ptrtostringansi(ptr);	intptr ppd_handle = libcupsnative.ppdopenfile(ppd_filename);	return ppd_handle;	}	catch (exception) {	
there was an error opening the printer please check your cups installation 

private static intptr openprinter(string printer) {	try {	intptr ptr = libcupsnative.cupsgetppd(printer);	string ppd_filename = marshal.ptrtostringansi(ptr);	intptr ppd_handle = libcupsnative.ppdopenfile(ppd_filename);	return ppd_handle;	}	catch (exception) {	
there was an error opening the printer please check your cups installation 

private static void loadoptionlist(intptr ppd, string option_name, namevaluecollection list, out string defoption) {	intptr ptr = intptr.zero;	ppd_option ppd_option;	ppd_choice choice;	int choice_size = marshal.sizeof(typeof(ppd_choice));	defoption = null;	ptr = libcupsnative.ppdfindoption(ppd, option_name);	if (ptr != intptr.zero) {	ppd_option = (ppd_option)marshal.ptrtostructure(ptr, typeof(ppd_option));	
option key def text 

int choice_size = marshal.sizeof(typeof(ppd_choice));	defoption = null;	ptr = libcupsnative.ppdfindoption(ppd, option_name);	if (ptr != intptr.zero) {	ppd_option = (ppd_option)marshal.ptrtostructure(ptr, typeof(ppd_option));	#endif defoption = ppd_option.defchoice;	ptr = ppd_option.choices;	for (int c = 0; c < ppd_option.num_choices; c++) {	choice = (ppd_choice)marshal.ptrtostructure(ptr, typeof(ppd_choice));	list.add(choice.choice, choice.text);	
choice text 

========================= corefx sample_10489 =========================

private static int main(string[] args) {	if (args.length < 4) {	
usage assemblyname typename methodname exceptionfile additionalargs 

========================= corefx sample_4621 =========================

public void readtimeout_default_read_byte_int_int() {	
verifying default readtimeout with read byte buffer int offset int count 

public void readtimeout_default_read_char_int_int() {	
verifying default readtimeout with read char buffer int offset int count 

public void readtimeout_default_readbyte() {	
verifying default readtimeout with readbyte 

public void readtimeout_default_readline() {	
verifying default readtimeout with readline 

public void readtimeout_default_readto() {	
verifying default readtimeout with readto 

public void readtimeout_infinite_read_byte_int_int() {	
verifying infinite readtimeout with read byte buffer int offset int count 

public void readtimeout_infinite_read_char_int_int() {	
verifying infinite readtimeout with read char buffer int offset int count 

public void readtimeout_infinite_readbyte() {	
verifying infinite readtimeout with readbyte 

public void readtimeout_infinite_readline() {	
verifying infinite readtimeout with readline 

public void readtimeout_infinite_readto() {	
verifying infinite readtimeout with readto 

public void readtimeout_0_readbyte_beforeopen() {	
verifying zero readtimeout before open with readbyte 

public void readtimeout_0_readline_beforeopen() {	
verifying zero readtimeout before open with readline 

public void readtimeout_0_readto_beforeopen() {	
verifying zero readtimeout before open with readto 

public void readtimeout_0_readbyte_afteropen() {	
verifying zero readtimeout after open with readbyte 

public void readtimeout_0_readline_afteropen() {	
verifying zero readtimeout after open with readline 

public void readtimeout_0_readto_afteropen() {	
verifying zero readtimeout after open with readto 

public void readtimeout_int32minvalue() {	
verifying minvalue readtimeout 

public void readtimeout_neg2() {	
verifying readtimeout 

========================= corefx sample_630 =========================

public static sockettestclient sockettestclientfactory( itestoutputhelper log, socketimplementationtype type, endpoint endpoint, int iterations, string message, stopwatch timeprogramstart) {	switch (type) {	case socketimplementationtype.apm: var socketapm = new sockettestclientapm(log, endpoint, iterations, message, timeprogramstart);	
sockettestclientapm 

public static sockettestclient sockettestclientfactory( itestoutputhelper log, socketimplementationtype type, endpoint endpoint, int iterations, string message, stopwatch timeprogramstart) {	switch (type) {	case socketimplementationtype.apm: var socketapm = new sockettestclientapm(log, endpoint, iterations, message, timeprogramstart);	return socketapm;	case socketimplementationtype.async: var socketasync = new sockettestclientasync(log, endpoint, iterations, message, timeprogramstart);	
sockettestclientasync 

public abstract bool receive(out int bytestransferred, out socketerror socketerror, action<int, socketerror> onsendcallback);	private async task doreceive() {	int total_bytes_received = 0;	while (total_bytes_received < _current_bytes) {	int receivedbytes = await receivehelper();	if (receivedbytes == 0) {	
socket unexpectedly closed 

if (receivedbytes == 0) {	throw new exception("socket unexpectedly closed");	}	total_bytes_received += receivedbytes;	assert.true(total_bytes_received <= _current_bytes);	_recvbufferindex += receivedbytes;	assert.true(_recvbufferindex <= _bufferlen);	if (_recvbufferindex == _bufferlen) {	_recvbufferindex = 0;	if (!sockettestmemcmp.compare(_sendbuffer, _recvbuffer)) {	
received different data from echo server 

========================= corefx sample_4437 =========================

private void test_badtypes_manifest(eventsource source) {	try {	using (var listener = new eventlistenerlistener()) {	var events = new list<event>();	
adding delegate to onevent 

private void test_bad_eventsource_startup(bool onstartup, listener listener, eventsourcesettings settings) {	var eventsourcename = typeof(badeventsource_mismatchedids).name;	
test badeventsource startup onstartup listener settings 

public void test_bad_writerelatedid_parametername() {	
test disabled because the fix it tests is not in coreclr yet 

========================= corefx sample_3086 =========================

public void newline_default() {	using (serialport com1 = new serialport()) {	serialportproperties serportprop = new serialportproperties();	
verifying default newline 

public void newline_null() {	
verifying null newline 

public void newline_empty_string() {	
verifying empty string newline 

========================= corefx sample_661 =========================

public void asciiencoding() {	
verifying read with bytes encoded with asciiencoding 

public void utf8encoding() {	
verifying read with bytes encoded with 

public void utf32encoding() {	
verifying read with bytes encoded with 

public void read_datareceivedbeforetimeout() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	byte[] bytexmitbuffer = tcsupport.getrandombytes(512);	byte[] bytercvbuffer = new byte[bytexmitbuffer.length];	asyncread asyncread = new asyncread(com1);	var asyncreadtask = new task(asyncread.read);	
verifying that readbyte will read bytes that have been received after the call to read was made 

========================= corefx sample_692 =========================

public static bool compare(object actual, object expected, string message) {	if (internalequals(actual, expected)) return true;	
error 

public static bool compare(object actual, object expected, string message) {	if (internalequals(actual, expected)) return true;	
expected 

public static bool compare(object actual, object expected, string message) {	if (internalequals(actual, expected)) return true;	
actual 

public static bool log(object actual, object expected, string source, string message, string details, tagerrorlevel eerrorlevel) {	tagerrorlevel rsavedlevel = errorlevel;	errorlevel = eerrorlevel;	try {	if (testconsole != null) {	testconsole.log(common.format(actual), common.format(expected), source, message, details, tagconsoleflags.console_text, "fake_filename", 999 );	}	else if (error != null) {	
message 

public static bool log(object actual, object expected, string source, string message, string details, tagerrorlevel eerrorlevel) {	tagerrorlevel rsavedlevel = errorlevel;	errorlevel = eerrorlevel;	try {	if (testconsole != null) {	testconsole.log(common.format(actual), common.format(expected), source, message, details, tagconsoleflags.console_text, "fake_filename", 999 );	}	else if (error != null) {	
source 

public static bool log(object actual, object expected, string source, string message, string details, tagerrorlevel eerrorlevel) {	tagerrorlevel rsavedlevel = errorlevel;	errorlevel = eerrorlevel;	try {	if (testconsole != null) {	testconsole.log(common.format(actual), common.format(expected), source, message, details, tagconsoleflags.console_text, "fake_filename", 999 );	}	else if (error != null) {	
expected 

public static bool log(object actual, object expected, string source, string message, string details, tagerrorlevel eerrorlevel) {	tagerrorlevel rsavedlevel = errorlevel;	errorlevel = eerrorlevel;	try {	if (testconsole != null) {	testconsole.log(common.format(actual), common.format(expected), source, message, details, tagconsoleflags.console_text, "fake_filename", 999 );	}	else if (error != null) {	
received 

public static bool log(object actual, object expected, string source, string message, string details, tagerrorlevel eerrorlevel) {	tagerrorlevel rsavedlevel = errorlevel;	errorlevel = eerrorlevel;	try {	if (testconsole != null) {	testconsole.log(common.format(actual), common.format(expected), source, message, details, tagconsoleflags.console_text, "fake_filename", 999 );	}	else if (error != null) {	
details 

========================= corefx sample_4615 =========================

public int loadxsl(string _strxslfile, inputtype inputtype, readertype readertype) {	_strxslfile = fullfilepath(_strxslfile);	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 switch (inputtype) {	
loading style sheet as uri 

public int loadxsl(string _strxslfile, inputtype inputtype, readertype readertype) {	_strxslfile = fullfilepath(_strxslfile);	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 switch (inputtype) {	xslt.load(_strxslfile);	break;	case inputtype.reader: switch (readertype) {	case readertype.xmltextreader: xmltextreader trtemp = new xmltextreader(_strxslfile);	try {	
loading style sheet as xmltextreader 

throw (ex);	}	finally {	if (trtemp != null) trtemp.dispose();	}	break;	case readertype.xmlnodereader: xmldocument doctemp = new xmldocument();	doctemp.load(_strxslfile);	xmlnodereader nrtemp = new xmlnodereader(doctemp);	try {	
loading style sheet as xmlnodereader 

throw (ex);	}	finally {	if (nrtemp != null) nrtemp.dispose();	}	break;	case readertype.xmlvalidatingreader: default: #pragma warning disable 0618 xmlvalidatingreader vrtemp = new xmlvalidatingreader(new xmltextreader(_strxslfile));	#pragma warning restore 0618 vrtemp.validationtype = validationtype.none;	vrtemp.entityhandling = entityhandling.expandentities;	try {	
loading style sheet as xmlvalidatingreader 

finally {	if (vrtemp != null) vrtemp.dispose();	}	break;	}	break;	case inputtype.navigator: #pragma warning disable 0618 xmlvalidatingreader xrload = new xmlvalidatingreader(new xmltextreader(_strxslfile));	#pragma warning restore 0618 xrload.validationtype = validationtype.none;	xpathdocument xdtemp = new xpathdocument(xrload, xmlspace.preserve);	xrload.dispose();	
loading style sheet as navigator 

public int loadxsl_resolver(string _strxslfile, xmlresolver xr, inputtype inputtype, readertype readertype) {	_strxslfile = fullfilepath(_strxslfile);	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 switch (inputtype) {	
loading style sheet as uri 

public int loadxsl_resolver(string _strxslfile, xmlresolver xr, inputtype inputtype, readertype readertype) {	_strxslfile = fullfilepath(_strxslfile);	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 switch (inputtype) {	xslt.load(_strxslfile, xr);	break;	case inputtype.reader: switch (readertype) {	case readertype.xmltextreader: xmltextreader trtemp = new xmltextreader(_strxslfile);	try {	
loading style sheet as xmltextreader 

throw (ex);	}	finally {	if (trtemp != null) trtemp.dispose();	}	break;	case readertype.xmlnodereader: xmldocument doctemp = new xmldocument();	doctemp.load(_strxslfile);	xmlnodereader nrtemp = new xmlnodereader(doctemp);	try {	
loading style sheet as xmlnodereader 

throw (ex);	}	finally {	if (nrtemp != null) nrtemp.dispose();	}	break;	case readertype.xmlvalidatingreader: default: #pragma warning disable 0618 xmlvalidatingreader vrtemp = new xmlvalidatingreader(new xmltextreader(_strxslfile));	#pragma warning restore 0618 vrtemp.validationtype = validationtype.none;	vrtemp.entityhandling = entityhandling.expandentities;	try {	
loading style sheet as xmlvalidatingreader 

}	finally {	if (vrtemp != null) vrtemp.dispose();	}	break;	}	break;	case inputtype.navigator: #pragma warning disable 0618 xmlvalidatingreader xrload = new xmlvalidatingreader(new xmltextreader(_strxslfile));	#pragma warning restore 0618 xpathdocument xdtemp = new xpathdocument(xrload, xmlspace.preserve);	xrload.dispose();	
loading style sheet as navigator 

public void verifyresult(string expectedvalue) {	lock(s_outfilememorylock) {	xmldiff.xmldiff xmldiff = new xmldiff.xmldiff();	xmldiff.option = xmldiffoption.infosetcomparison | xmldiffoption.ignoreemptyelement | xmldiffoption.normalizenewline;	string actualvalue = file.readalltext(_stroutfile);	
expected 

public void verifyresult(string expectedvalue) {	lock(s_outfilememorylock) {	xmldiff.xmldiff xmldiff = new xmldiff.xmldiff();	xmldiff.option = xmldiffoption.infosetcomparison | xmldiffoption.ignoreemptyelement | xmldiffoption.normalizenewline;	string actualvalue = file.readalltext(_stroutfile);	
actual 

public int transform(string szxmlfile, bool errorcase, transformtype transformtype, doctype doctype) {	lock (s_outfilememorylock) {	szxmlfile = fullfilepath(szxmlfile);	
loading xml 

public int transform(string szxmlfile, bool errorcase, transformtype transformtype, doctype doctype) {	lock (s_outfilememorylock) {	szxmlfile = fullfilepath(szxmlfile);	ixpathnavigable xd = loadxml(szxmlfile, doctype);	
executing transform 

public int transform_arglist(string szxmlfile, bool errorcase, transformtype transformtype, doctype doctype) {	lock (s_outfilememorylock) {	szxmlfile = fullfilepath(szxmlfile);	
loading xml 

public int transform_arglist(string szxmlfile, bool errorcase, transformtype transformtype, doctype doctype) {	lock (s_outfilememorylock) {	szxmlfile = fullfilepath(szxmlfile);	ixpathnavigable xd = loadxml(szxmlfile, doctype);	
executing transform 

public int transformresolver(string szxmlfile, xmlresolver xr, bool errorcase, transformtype transformtype, doctype doctype) {	lock (s_outfilememorylock) {	szxmlfile = fullfilepath(szxmlfile);	
loading xml 

public int transformresolver(string szxmlfile, xmlresolver xr, bool errorcase, transformtype transformtype, doctype doctype) {	lock (s_outfilememorylock) {	szxmlfile = fullfilepath(szxmlfile);	ixpathnavigable xd = loadxml(szxmlfile, doctype);	
executing transform 

========================= corefx sample_12629 =========================

public void testusercredentialspropertiesonwindows() {	string username = "test", password = "password123!!";	try {	interop.netuseradd(username, password);	}	catch (exception exc) {	
testusercredentialspropertiesonwindows netuseradd failed 

========================= corefx sample_3929 =========================

datacolumn = _tablemapping.getdatacolumn(_fieldnames[sortedindex], fieldtype, _datatable, mappingaction, schemaaction);	}	string basetable = /*schemarow.baseservername+schemarow.basecatalogname+schemarow.baseschemaname+*/ schemarow.basetablename;	if (null == datacolumn) {	if (null == columnindexmap) {	columnindexmap = createindexmap(schemarows.length, unsortedindex);	}	columnindexmap[unsortedindex] = -1;	if (schemarow.iskey) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema partial primary key detected 

}	additemtoallowrollback(ref addeditems, datacolumn);	columncollection.add(datacolumn);	}	if (addprimarykeys && schemarow.iskey) {	if (keys == null) {	keys = new datacolumn[schemarows.length];	}	keys[keycount++] = datacolumn;	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema building list of primarykey uniqueconstraint 

}	if (addprimarykeys && schemarow.iskey) {	if (keys == null) {	keys = new datacolumn[schemarows.length];	}	keys[keycount++] = datacolumn;	#if debug if (adapterswitches.dataschema.traceverbose) {	}	#endif if (isprimary && datacolumn.allowdbnull) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema changing primarykey into uniquecontraint 

if ((null != _dataset) && null == _datatable.dataset) {	additemtoallowrollback(ref addeditems, _datatable);	_dataset.tables.add(_datatable);	}	if (addprimarykeys && (null != keys)) {	if (keycount < keys.length) {	keys = resizecolumnarray(keys, keycount);	}	if (isprimary) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema set primarykey 

}	#endif _datatable.primarykey = keys;	}	else {	uniqueconstraint unique = new uniqueconstraint("", keys);	constraintcollection constraints = _datatable.constraints;	int constraintcount = constraints.count;	for (int i = 0; i < constraintcount; ++i) {	if (unique.equals(constraints[i])) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema duplicate contraint detected 

for (int i = 0; i < constraintcount; ++i) {	if (unique.equals(constraints[i])) {	#if debug if (adapterswitches.dataschema.traceverbose) {	}	#endif unique = null;	break;	}	}	if (null != unique) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema adding new uniqueconstraint 

========================= corefx sample_3548 =========================

public void notreadydriveaspath_throwsdirectorynotfoundexception() {	var drive = ioservices.getnotreadydrive();	if (drive == null) {	
skipping test unable to find a not ready drive such as cd rom with no disc inserted 

public void subdirectoryonnotreadydriveaspath_throwsioexception() {	var drive = ioservices.getnotreadydrive();	if (drive == null) {	
skipping test unable to find a not ready drive such as cd rom with no disc inserted 

========================= corefx sample_228 =========================

}	else {	username = utils.getnt4username();	}	globaldebug.writelineif( globaldebug.info, "sdscache", "getcontext: looking for context for server {0}, user {1}, explicitcreds={2}, options={3}", name, username, explicitcreds.tostring(), contextoptions.tostring());	if (!_issam) {	int flags = unchecked((int)(0x40000000 | 0x00000010 | 0x00000100));	unsafenativemethods.domaincontrollerinfo info = utils.getdcname(null, contextname, null, flags);	contextname = info.domainname;	}	
sdscache getcontext final contextname is 

if (!_issam) {	int flags = unchecked((int)(0x40000000 | 0x00000010 | 0x00000100));	unsafenativemethods.domaincontrollerinfo info = utils.getdcname(null, contextname, null, flags);	contextname = info.domainname;	}	manualresetevent contextreadyevent = null;	while (true) {	hashtable credtable = null;	principalcontext ctx = null;	if (contextreadyevent != null) {	
sdscache getcontext waiting 

while (true) {	hashtable credtable = null;	principalcontext ctx = null;	if (contextreadyevent != null) {	contextreadyevent.waitone();	}	contextreadyevent = null;	lock (_tablelock) {	credholder credholder = (credholder)_table[contextname];	if (credholder != null) {	
sdscache getcontext found a credholder for 

contextreadyevent.waitone();	}	contextreadyevent = null;	lock (_tablelock) {	credholder credholder = (credholder)_table[contextname];	if (credholder != null) {	credtable = (explicitcreds ? credholder.explicitcreds : credholder.defaultcreds);	debug.assert(credtable != null);	object o = credtable[username];	if (o is placeholder) {	
sdscache getcontext credholder for has a placeholder 

if (credholder != null) {	credtable = (explicitcreds ? credholder.explicitcreds : credholder.defaultcreds);	debug.assert(credtable != null);	object o = credtable[username];	if (o is placeholder) {	contextreadyevent = ((placeholder)o).contextreadyevent;	continue;	}	weakreference reftocontext = o as weakreference;	if (reftocontext != null) {	
sdscache getcontext reftocontext is non null 

debug.assert(credtable != null);	object o = credtable[username];	if (o is placeholder) {	contextreadyevent = ((placeholder)o).contextreadyevent;	continue;	}	weakreference reftocontext = o as weakreference;	if (reftocontext != null) {	ctx = (principalcontext)reftocontext.target;	if (ctx != null && ctx.disposed == false) {	
sdscache getcontext using found reftocontext 

contextreadyevent = ((placeholder)o).contextreadyevent;	continue;	}	weakreference reftocontext = o as weakreference;	if (reftocontext != null) {	ctx = (principalcontext)reftocontext.target;	if (ctx != null && ctx.disposed == false) {	return ctx;	}	else {	
sdscache getcontext reftocontext is gced disposed removing 

========================= corefx sample_9036 =========================

return;	}	try {	bindingflags bindingflags = bindingflags.nonpublic | bindingflags.getfield | bindingflags.static | bindingflags.instance;	fieldinfo allocsitefld = obj.gettype().getfield("allocationsite", bindingflags);	string allocationsite = allocsitefld != null ? allocsitefld.getvalue( obj ).tostring() : "<allocation site unavailable>";	if( allocationsite.contains("windowsgraphicscachemanager") ) {	return;	}	debug.fail("object disposed through finalization - it should be explicitly disposed.");	
allocation stack 

bindingflags bindingflags = bindingflags.nonpublic | bindingflags.getfield | bindingflags.static | bindingflags.instance;	fieldinfo allocsitefld = obj.gettype().getfield("allocationsite", bindingflags);	string allocationsite = allocsitefld != null ? allocsitefld.getvalue( obj ).tostring() : "<allocation site unavailable>";	if( allocationsite.contains("windowsgraphicscachemanager") ) {	return;	}	debug.fail("object disposed through finalization - it should be explicitly disposed.");	}	catch(exception ex) {	try {	
exception thrown while trying to get allocation stack 

========================= corefx sample_10345 =========================

public principalcontext( contexttype contexttype, string name, string container, contextoptions options, string username, string password) {	
principalcontext entering ctor 

private void initialize() {	if (!_initialized) {	lock (_initializationlock) {	if (_initialized) return;	
principalcontext initializing context 

private void doapplicationdirectoryinit() {	
principalcontext entering doapplicationdirecotryinit 

private void doapplicationdirectoryinit() {	debug.assert(_contexttype == contexttype.applicationdirectory);	if (_container == null) {	
principalcontext doapplicationdirecotryinit using no container path 

private void doapplicationdirectoryinit() {	debug.assert(_contexttype == contexttype.applicationdirectory);	if (_container == null) {	doldapdirectoryinitnocontainer();	}	else {	
principalcontext doapplicationdirecotryinit using container path 

private void domachineinit() {	
principalcontext entering domachineinit 

private void domachineinit() {	debug.assert(_contexttype == contexttype.machine);	debug.assert(_container == null);	directoryentry de = null;	try {	string hostname = _name;	if (hostname == null) hostname = utils.getcomputerflatname();	
principalcontext domachineinit hostname is 

private void domachineinit() {	debug.assert(_contexttype == contexttype.machine);	debug.assert(_container == null);	directoryentry de = null;	try {	string hostname = _name;	if (hostname == null) hostname = utils.getcomputerflatname();	authenticationtypes authtypes = sdsutils.mapoptionstoauthtypes(_options);	
principalcontext domachineinit authtypes is 

de = new directoryentry("winnt: de.refreshcache();	storectx storectx = createcontextfromdirectoryentry(de);	_queryctx = storectx;	_userctx = storectx;	_groupctx = storectx;	_computerctx = storectx;	_connectedserver = hostname;	de = null;	}	catch (exception e) {	
principalcontext domachineinit caught exception of type and message 

private void dodomaininit() {	
principalcontext entering dodomaininit 

private void dodomaininit() {	debug.assert(_contexttype == contexttype.domain);	if (_container == null) {	
principalcontext dodomaininit using no container path 

private void dodomaininit() {	debug.assert(_contexttype == contexttype.domain);	if (_container == null) {	doldapdirectoryinitnocontainer();	return;	}	else {	
principalcontext dodomaininit using container path 

string servername = "";	if (_name != null) {	if (_contexttype == contexttype.applicationdirectory) {	servername = _serverproperties.dnshostname + ":" + ((contextoptions.securesocketlayer & _options) > 0 ? _serverproperties.portssl : _serverproperties.portldap);	}	else {	servername = _name;	}	servername += "/";	}	
principalcontext doldapdirectoryinit servername is 

if (_name != null) {	if (_contexttype == contexttype.applicationdirectory) {	servername = _serverproperties.dnshostname + ":" + ((contextoptions.securesocketlayer & _options) > 0 ? _serverproperties.portssl : _serverproperties.portldap);	}	else {	servername = _name;	}	servername += "/";	}	authenticationtypes authtypes = sdsutils.mapoptionstoauthtypes(_options);	
principalcontext doldapdirectoryinit authtypes is 

_userctx = storectx;	_groupctx = storectx;	_computerctx = storectx;	_connectedserver = adutils.getservername(de);	de = null;	}	catch (system.runtime.interopservices.comexception e) {	throw exceptionhelper.getexceptionfromcomexception(e);	}	catch (exception e) {	
principalcontext doldapdirectoryinit caught exception of type and message 

private void doldapdirectoryinitnocontainer() {	byte[] users_container_guid = new byte[] { 0xa9, 0xd1, 0xca, 0x15, 0x76, 0x88, 0x11, 0xd1, 0xad, 0xed, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xcd };	byte[] computers_container_guid = new byte[] { 0xaa, 0x31, 0x28, 0x25, 0x76, 0x88, 0x11, 0xd1, 0xad, 0xed, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xcd };	directoryentry deusergrouporg = null;	directoryentry decomputer = null;	directoryentry debase = null;	adstorectx storectxusergrouporg = null;	adstorectx storectxcomputer = null;	adstorectx storectxbase = null;	
principalcontext entering doldapdirectoryinitnocontainer 

directoryentry debase = null;	adstorectx storectxusergrouporg = null;	adstorectx storectxcomputer = null;	adstorectx storectxbase = null;	directoryentry derootdse = null;	string adspathbase;	string servername = "";	if (_name != null) {	servername = _name + "/";	}	
principalcontext doldapdirectoryinitnocontainer servername is 

adstorectx storectxusergrouporg = null;	adstorectx storectxcomputer = null;	adstorectx storectxbase = null;	directoryentry derootdse = null;	string adspathbase;	string servername = "";	if (_name != null) {	servername = _name + "/";	}	authenticationtypes authtypes = sdsutils.mapoptionstoauthtypes(_options);	
principalcontext doldapdirectoryinitnocontainer authtypes is 

directoryentry derootdse = null;	string adspathbase;	string servername = "";	if (_name != null) {	servername = _name + "/";	}	authenticationtypes authtypes = sdsutils.mapoptionstoauthtypes(_options);	try {	derootdse = new directoryentry("ldap: string domainnc = (string)derootdse.properties["defaultnamingcontext"][0];	adspathbase = "ldap: globaldebug.writelineif(globaldebug.info, "principalcontext", "doldapdirectoryinitnocontainer: domainnc is " + domainnc);	
principalcontext doldapdirectoryinitnocontainer adspathbase is 

_userctx = userstore;	_groupctx = userstore;	deusergrouporg = null;	_computerctx = createcontextfromdirectoryentry(decomputer);	decomputer = null;	_queryctx = createcontextfromdirectoryentry(debase);	_connectedserver = adutils.getservername(debase);	debase = null;	}	catch (exception e) {	
principalcontext doldapdirectoryinitnocontainer caught exception of type and message 

public void dispose() {	if (!_disposed) {	
principalcontext dispose disposing 

private storectx createcontextfromdirectoryentry(directoryentry entry) {	storectx storectx;	debug.assert(entry != null);	
principalcontext createcontextfromdirectoryentry path is 

========================= corefx sample_9016 =========================

public datatable getdatatablebyschemaaction(dataset dataset, missingschemaaction schemaaction) {	if (null == dataset) {	throw adp.argumentnull(nameof(dataset));	}	string datasettable = datasettable;	if (string.isnullorempty(datasettable)) {	#if debug if (adapterswitches.dataschema.tracewarning) {	
explicit filtering of sourcetable sourcetable 

string datasettable = datasettable;	if (string.isnullorempty(datasettable)) {	#if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	}	datatablecollection tables = dataset.tables;	int index = tables.indexof(datasettable);	if ((0 <= index) && (index < tables.count)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
schema match on datatable datasettable 

}	datatablecollection tables = dataset.tables;	int index = tables.indexof(datasettable);	if ((0 <= index) && (index < tables.count)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return tables[index];	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	
schema add of datatable datasettable 

if ((0 <= index) && (index < tables.count)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return tables[index];	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatable(datasettable);	case missingschemaaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
schema filter of datatable datasettable 

#endif return tables[index];	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatable(datasettable);	case missingschemaaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingschemaaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
schema error on datatable datasettable 

========================= corefx sample_3568 =========================

public void asciiencoding() {	
verifying write method with asciiencoding 

public void utf8encoding() {	
verifying write method with 

public void utf32encoding() {	
verifying write method with 

public void unicodeencoding() {	
verifying write method with unicodeencoding 

public void nullstring() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write with a null string 

public void emptystring() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying write with an empty string 

public void string_null_char() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying write with an string containing only the null character 

public void largestring() {	
verifying write method with a large string size 

========================= corefx sample_641 =========================

public void position_open_close() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.close();	
verifying position property throws exception after open then close 

public void position_open_basestreamclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream serialstream = com.basestream;	com.basestream.close();	
verifying position property throws exception after open then basestream close 

public void position_afteropen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying position property throws exception after a call to open 

public void position_badvalue() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	
verifying position property throws exception with a bad value after a call to open 

========================= corefx sample_610 =========================

private void asciiencoding() {	
verifying write method with asciiencoding 

private void utf8encoding() {	
verifying write method with 

private void utf32encoding() {	
verifying write method with 

private void unicodeencoding() {	
verifying write method with unicodeencoding 

private void nullstring() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying write with a null string 

private void emptystring() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying write with an empty string 

private void string_null_char() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	
verifying write with an string containing only the null character 

private void largestring() {	
verifying write method with a large string size 

private void strcontains_newline_rnd() {	using (serialport com1 = tcsupport.initfirstserialport()) using (serialport com2 = tcsupport.initsecondserialport(com1)) {	random rndgen = new random(-55);	stringbuilder strbldrtowrite = tcsupport.getrandomstringbuilder(newline_testing_string_size, tcsupport.characteroptions.none);	string newline = genrandomnewline(true);	
verifying write method with a random newline string and writing a string that contains the newline 

========================= corefx sample_686 =========================

public void readwithoutopen() {	using (serialport com = new serialport()) {	
verifying read method throws exception without a call to open 

public void readafterfailedopen() {	using (serialport com = new serialport("bad_port_name")) {	
verifying read method throws exception with a failed call to open 

public void readafterclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying read method throws exception after a call to cloes 

public void parityerroronlastbyte() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	random rndgen = new random(15);	byte[] bytestowrite = new byte[numrndchar];	char[] expectedchars = new char[numrndchar];	
verifying default parityreplace byte with a parity errro on the last byte 

========================= corefx sample_675 =========================

public void portname_rnd() {	random rndgen = new random();	stringbuilder rndstrbuf = new stringbuilder();	for (int i = 0; i < rndportnamesize; i++) {	rndstrbuf.append((char)rndgen.next(0, ushort.maxvalue));	}	
verifying setting portname to a random string 

serportprop.setallpropertiestoopendefaults();	}	if (throwat.open == throwat) serportprop.setproperty("portname", portname);	else serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	try {	com.portname = portname;	if (throwat.open == throwat) com.open();	if (null != expectedexceptions && 0 < expectedexceptions.length) {	fail("error!!! expected open() to throw ");	for (int i = 0; i < expectedexceptions.length; ++i) console.write(expectedexceptions[i] + " ");	
and nothing was thrown 

else {	bool exceptionfound = false;	type actualexceptiontype = e.gettype();	for (int i = 0; i < expectedexceptions.length; ++i) {	if (actualexceptiontype == expectedexceptions[i]) {	exceptionfound = true;	break;	}	}	if (exceptionfound) {	
caught expected exception 

if (actualexceptiontype == expectedexceptions[i]) {	exceptionfound = true;	break;	}	}	if (exceptionfound) {	}	else {	fail("error!!! expected open() throw ");	for (int i = 0; i < expectedexceptions.length; ++i) console.write(expectedexceptions[i] + " ");	
and the following was thrown 

========================= corefx sample_665 =========================

public void test_eventsource_lowtrust() {	testutilities.checknoeventsourcesrunning("start");	
running array createinstance in low trust 

public void test_eventsource_lowtrust() {	testutilities.checknoeventsourcesrunning("start");	runlowtrusttest();	
success 

var info = new appdomainsetup { applicationbase = appdomain.currentdomain.basedirectory };	info.applicationtrust = new applicationtrust(permissionset, fullytrustedassemblies);	var appdomain = appdomain.createdomain( "partial trust", evidence, info);	try {	var tester = (lttadeventsourcetester)appdomain .createinstanceandunwrap( typeof(lttadeventsourcetester).assembly.getname().name, typeof(lttadeventsourcetester).fullname);	tester.iseventsourceassmfullytrusted = fullytrusteventsource;	tester.dostuff(1);	tester.dostuff(2);	tester.dostuff(3);	assert.istrue(tester.isstatevalid, "eventsource constructionexception as expected");	
success 

protected override void oneventwritten(eventwritteneventargs eventdata) {	if (true) {	
event received 

========================= corefx sample_3082 =========================

private intptr createbroadcastwindow() {	interop.user32.wndclass_i wndclassi = new interop.user32.wndclass_i();	intptr hinstance = interop.kernel32.getmodulehandle(null);	if (!interop.user32.getclassinfow(hinstance, wndclass.lpszclassname, wndclassi)) {	if (interop.user32.registerclassw(wndclass) == 0) {	_windowproc = null;	
unable to register broadcast window class 

========================= corefx sample_1216 =========================

public void cdholding_default() {	using (serialport com1 = new serialport()) {	serialportproperties serportprop = new serialportproperties();	
verifying default cdholding before open 

public void cdholding_default_afteropen() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default cdholding after open 

public void cdholding_default_afterclose() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default cdholding after close 

========================= corefx sample_634 =========================

private void backtrack() {	int newpos = runtrack[runtrackpos++];	#if debug if (runmatch.debug) {	
backtracking to code position 

private void backtrack() {	int newpos = runtrack[runtrackpos++];	#if debug if (runmatch.debug) {	
backtracking to code position 

========================= corefx sample_3160 =========================

public void m() {	
c a b c d cs 

public void m() {	
c a b c d cs 

public void m() {	
c a b c d cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c a b c d x cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c a b c x cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c a b x cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c a b cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c a b c cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c a b x cs 

public void m() {	#line 40 console.writeline(4);	#line hidden console.writeline();	
c a b x cs 

========================= corefx sample_8597 =========================

public void endreadafterclose() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	
verifying endread method throws exception after a call to cloes 

public void endreadafterserialstreamclose() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	
verifying endread method throws exception after a call to basestream close 

public void asyncresult_null() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying endread with null asyncresult 

public void asyncresult_writeresult() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	
verifying endread with asyncresult returned from write 

public void asyncresult_multiplesameresult() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var numbytestoread = 8;	
verifying calling endread twice with the same asyncresult 

public void asyncresult_multipleinorder() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	int endreadreturnvalue;	int numbytestoread1 = 8, numbytestoread2 = 16, numbytestoread3 = 10;	int totalbytestoread = numbytestoread1 + numbytestoread2 + numbytestoread3;	
verifying endread with multiple calls to beginread 

public void asyncresult_multipleoutoforder() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	int endreadreturnvalue;	int numbytestoread1 = 8, numbytestoread2 = 16, numbytestoread3 = 10;	int totalbytestoread = numbytestoread1 + numbytestoread2 + numbytestoread3;	
verifying calling endread with different asyncresults out of order returned from beginread 

========================= corefx sample_600 =========================

private delegate void readmethoddelegate(stream stream);	#region test cases [conditionalfact(nameof(hasoneserialport))]	public void readtimeout_defaultvalue() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	com.open();	stream stream = com.basestream;	
verifying the default value of readtimeout 

public void readtimeout_afterclose() {	
verifying setting readtimeout after the serialport was closed 

public void readtimeout_int32minvalue() {	
verifying minvalue readtimeout 

public void readtimeout_neg2() {	
verifying readtimeout 

public void readtimeout_default_read_byte_int_int() {	
verifying default readtimeout with read byte buffer int offset int count 

public void readtimeout_default_readbyte() {	
verifying default readtimeout with readbyte 

public void readtimeout_infinite_read_byte_int_int() {	
verifying infinite readtimeout with read byte buffer int offset int count 

public void readtimeout_infinite_readbyte() {	
verifying infinite readtimeout with readbyte 

public void readtimeout_int32maxvalue_read_byte_int_int() {	
verifying maxvalue readtimeout with read byte buffer int offset int count 

public void readtimeout_int32maxvalue_readbyte() {	
verifying maxvalue readtimeout with readbyte 

public void readtimeout_750_read_byte_int_int() {	
verifying readtimeout with read byte buffer int offset int count 

public void readtimeout_750_readbyte() {	
verifying readtimeout with readbyte 

public void readtimeout_0_read_byte_int_int() {	
verifying readtimeout with read byte buffer int offset int count 

public void readtimeout_0_readbyte() {	
verifying readtimeout with readbyte 

public void readtimeout_0_1byteavailable_read_byte_int_int() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	var rcvbytes = new byte[128];	int bytesread;	
verifying readtimeout with read byte buffer int offset int count and one byte available 

public void readtimeout_0_1byteavailable_readbyte() {	using (var com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (var com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	int byteread;	
verifying readtimeout with readbyte and one byte available 

========================= corefx sample_591 =========================

public void closewithoutopen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
calling close without first calling open 

public void openclose() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
calling close after calling open 

public void openfillbuffersclose() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.secondavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
calling open fill both transmit and receive buffers call close 

serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	com1.handshake = handshake.requesttosend;	com1.open();	com2.open();	com1.basestream.beginwrite(new byte[s_numwritebytes], 0, s_numwritebytes, null, null);	com2.write(new byte[numreadbytes], 0, numreadbytes);	thread.sleep(500);	serportprop.setproperty("handshake", handshake.requesttosend);	serportprop.setproperty("bytestowrite", s_numwritebytes - tcsupport.hardwaretransmitbuffersize);	serportprop.setproperty("bytestoread", numreadbytes);	
verifying properties after port is open and buffers have been filled 

com2.write(new byte[numreadbytes], 0, numreadbytes);	thread.sleep(500);	serportprop.setproperty("handshake", handshake.requesttosend);	serportprop.setproperty("bytestowrite", s_numwritebytes - tcsupport.hardwaretransmitbuffersize);	serportprop.setproperty("bytestoread", numreadbytes);	serportprop.verifypropertiesandprint(com1);	com1.handshake = handshake.none;	com1.close();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying properties after port has been closed 

serportprop.setproperty("bytestoread", numreadbytes);	serportprop.verifypropertiesandprint(com1);	com1.handshake = handshake.none;	com1.close();	serportprop.setallpropertiestodefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	serportprop.verifypropertiesandprint(com1);	com1.open();	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying properties after port has been opened again 

public void openclosenewinstanceopen() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
calling close after calling open then create a new instance of serialport and call open again 

========================= corefx sample_651 =========================

}	else if (op.equals("corruption")) {	sncalc.push(-33);	mycalc.push(-555);	}	else if (biginteger.tryparse(op, out snnum1)) {	sncalc.push(snnum1);	mycalc.push(snnum1);	}	else {	
failed to parse string 

========================= corefx sample_8931 =========================

public void waitforpeerprocess() {	process child1 = createprocesslong();	child1.start();	process child2 = createprocess(peerid => {	process peer = process.getprocessbyid(int.parse(peerid));	
signal 

========================= corefx sample_3919 =========================

public adstorectx(directoryentry ctxbase, bool ownctxbase, string username, string password, contextoptions options) {	
adstorectx constructing adstorectx for 

protected bool iscontainer(directoryentry de) {	using (directoryentry schemade = de.schemaentry) {	if (schemade.properties["possibleinferiors"].count == 0) {	
adstorectx iscontainer not a container 

private void enableprincipalifnecessary(principal p) {	if (p.getchangestatusforproperty(propertynames.authenticableprincipalenabled)) {	
adstorectx enableprincipalifnecessary enabling principal 

private void setpasswordsecurityifneccessary(principal p) {	if (p.getchangestatusforproperty(propertynames.pwdinfocannotchangepassword)) {	
adstorectx enableprincipalifnecessary enabling principal 

bool denyworldfound;	bool allowselffound;	bool allowworldfound;	scanaclforchangepasswordright(adssecurity, out denyselffound, out denyworldfound, out allowselffound, out allowworldfound);	activedirectoryaccessrule denyselface = new extendedrightaccessrule( new maclprinc.securityidentifier(selfsddl), accesscontroltype.deny, s_changepasswordguid);	activedirectoryaccessrule denyworldace = new extendedrightaccessrule( new maclprinc.securityidentifier(worldsddl), accesscontroltype.deny, s_changepasswordguid);	activedirectoryaccessrule allowselface = new extendedrightaccessrule( new maclprinc.securityidentifier(selfsddl), accesscontroltype.allow, s_changepasswordguid);	activedirectoryaccessrule allowworldace = new extendedrightaccessrule( new maclprinc.securityidentifier(worldsddl), accesscontroltype.allow, s_changepasswordguid);	if (usercannotchangepassword) {	if (!denyselffound) {	
adstorectx cannotchangepwdtoldapconverter add deny self 

scanaclforchangepasswordright(adssecurity, out denyselffound, out denyworldfound, out allowselffound, out allowworldfound);	activedirectoryaccessrule denyselface = new extendedrightaccessrule( new maclprinc.securityidentifier(selfsddl), accesscontroltype.deny, s_changepasswordguid);	activedirectoryaccessrule denyworldace = new extendedrightaccessrule( new maclprinc.securityidentifier(worldsddl), accesscontroltype.deny, s_changepasswordguid);	activedirectoryaccessrule allowselface = new extendedrightaccessrule( new maclprinc.securityidentifier(selfsddl), accesscontroltype.allow, s_changepasswordguid);	activedirectoryaccessrule allowworldace = new extendedrightaccessrule( new maclprinc.securityidentifier(worldsddl), accesscontroltype.allow, s_changepasswordguid);	if (usercannotchangepassword) {	if (!denyselffound) {	adssecurity.addaccessrule(denyselface);	}	if (!denyworldfound) {	
adstorectx cannotchangepwdtoldapconverter add deny world 

activedirectoryaccessrule allowselface = new extendedrightaccessrule( new maclprinc.securityidentifier(selfsddl), accesscontroltype.allow, s_changepasswordguid);	activedirectoryaccessrule allowworldace = new extendedrightaccessrule( new maclprinc.securityidentifier(worldsddl), accesscontroltype.allow, s_changepasswordguid);	if (usercannotchangepassword) {	if (!denyselffound) {	adssecurity.addaccessrule(denyselface);	}	if (!denyworldfound) {	adssecurity.addaccessrule(denyworldace);	}	if (allowselffound) {	
adstorectx cannotchangepwdtoldapconverter remove allow self 

if (!denyselffound) {	adssecurity.addaccessrule(denyselface);	}	if (!denyworldfound) {	adssecurity.addaccessrule(denyworldace);	}	if (allowselffound) {	adssecurity.removeaccessrulespecific(allowselface);	}	if (allowworldfound) {	
adstorectx cannotchangepwdtoldapconverter remove allow world 

}	if (allowselffound) {	adssecurity.removeaccessrulespecific(allowselface);	}	if (allowworldfound) {	adssecurity.removeaccessrulespecific(allowworldace);	}	}	else {	if (denyselffound) {	
adstorectx cannotchangepwdtoldapconverter remove deny self 

}	if (allowworldfound) {	adssecurity.removeaccessrulespecific(allowworldace);	}	}	else {	if (denyselffound) {	adssecurity.removeaccessrulespecific(denyselface);	}	if (denyworldfound) {	
adstorectx cannotchangepwdtoldapconverter remove deny world 

}	}	else {	if (denyselffound) {	adssecurity.removeaccessrulespecific(denyselface);	}	if (denyworldfound) {	adssecurity.removeaccessrulespecific(denyworldace);	}	if (!allowselffound) {	
adstorectx cannotchangepwdtoldapconverter add allow self 

if (denyselffound) {	adssecurity.removeaccessrulespecific(denyselface);	}	if (denyworldfound) {	adssecurity.removeaccessrulespecific(denyworldace);	}	if (!allowselffound) {	adssecurity.addaccessrule(allowselface);	}	if (!allowworldfound) {	
adstorectx cannotchangepwdtoldapconverter add allow world 

protected virtual void setauthprincipalenablestatus(authenticableprincipal ap, bool enable) {	try {	debug.assert(ap.fakeprincipal == false);	int uacvalue;	directoryentry de = (directoryentry)ap.underlyingobject;	if (de.properties["useraccountcontrol"].count > 0) {	debug.assert(de.properties["useraccountcontrol"].count == 1);	uacvalue = (int)de.properties["useraccountcontrol"][0];	}	else {	
adstorectx setauthprincipalenablestatus can t read useraccountcontrol 

ldapfilter.append("=*)");	break;	case matchtype.lessthan: goto case matchtype.greaterthan;	default: debug.fail("adstorectx.findbydate: fell off end looking for " + matchtype.tostring());	break;	}	ldapfilter.append(")");	}	ldapfilter.append("))");	ds.filter = ldapfilter.tostring();	
adstorectx findbydate using ldap filter 

}	debug.assert(g.underlyingobject != null);	directoryentry groupde = (directoryentry)g.underlyingobject;	directorysearcher ds = null;	try {	if (groupde.properties["objectsid"].count > 0) {	debug.assert(groupde.properties["objectsid"].count == 1);	byte[] groupsid = (byte[])groupde.properties["objectsid"][0];	ds = getdirectorysearcherfromgroupid(groupsid);	ds.sizelimit = 1;	
adstorectx ismemberofinstore using ldap filter 

directoryentry groupde = (directoryentry)g.underlyingobject;	directorysearcher ds = null;	try {	if (groupde.properties["objectsid"].count > 0) {	debug.assert(groupde.properties["objectsid"].count == 1);	byte[] groupsid = (byte[])groupde.properties["objectsid"][0];	ds = getdirectorysearcherfromgroupid(groupsid);	ds.sizelimit = 1;	searchresult sr = ds.findone();	if (sr != null) {	
adstorectx ismemberofinstore found member can t clear 

debug.assert(groupde.properties["objectsid"].count == 1);	byte[] groupsid = (byte[])groupde.properties["objectsid"][0];	ds = getdirectorysearcherfromgroupid(groupsid);	ds.sizelimit = 1;	searchresult sr = ds.findone();	if (sr != null) {	explanationforfailure = sr.adstorectxcantcleargroup;	return false;	}	else {	
adstorectx ismemberofinstore no member can clear 

searchresult sr = ds.findone();	if (sr != null) {	explanationforfailure = sr.adstorectxcantcleargroup;	return false;	}	else {	return true;	}	}	else {	
adstorectx ismemberofinstore can t search assume can clear 

========================= corefx sample_9032 =========================

public void onothernodesattrs() {	string filename = path.combine(s_mypath, "attributes.xml");	
loading 

========================= corefx sample_11589 =========================

private bool test01() {	bool ret = true;	dynamic[] dary = new dynamic[]	{	100, 200, 300 }	;	dary[0]++;	ret &= 101 == dary[0];	dary[1]--;	ret &= 199 == dary[1];	
fail 

========================= corefx sample_13 =========================

public void save() {	
principal entering save 

public void save() {	checkdisposedordeleted();	checkfakeprincipal();	if (_ctx == null) {	debug.assert(this.unpersisted == true);	throw new invalidoperationexception(sr.principalmustsetcontextforsave);	}	storectx storectxtouse = getstorectxtouse();	debug.assert(storectxtouse != null);	if (this.unpersisted) {	
principal save inserting principal of type using 

throw new invalidoperationexception(sr.principalmustsetcontextforsave);	}	storectx storectxtouse = getstorectxtouse();	debug.assert(storectxtouse != null);	if (this.unpersisted) {	debug.assert(storectxtouse == _ctx.contextfortype(this.gettype()));	storectxtouse.insert(this);	this.unpersisted = false;	}	else {	
principal save updating principal of type using 

public void save(principalcontext context) {	
principal entering save context 

if (context.contexttype != _ctx.contexttype) {	debug.assert(this.unpersisted == true);	throw new invalidoperationexception(sr.savetomusthavesamecontexttype);	}	storectx originalstorectx = getstorectxtouse();	_ctx = context;	storectx newstorectx = getstorectxtouse();	debug.assert(newstorectx != null);	debug.assert(originalstorectx != null);	if (this.unpersisted) {	
principal save context inserting new principal of type using 

_ctx = context;	storectx newstorectx = getstorectxtouse();	debug.assert(newstorectx != null);	debug.assert(originalstorectx != null);	if (this.unpersisted) {	debug.assert(newstorectx == _ctx.contextfortype(this.gettype()));	newstorectx.insert(this);	this.unpersisted = false;	}	else {	
principal save context moving principal of type using 

previousname = _name;	this.name = newname;	}	newstorectx.move(originalstorectx, this);	try {	this.unpersisted = false;	newstorectx.update(this);	}	catch (system.systemexception e) {	try {	
principal save context update failed attempting to move back exception 

}	newstorectx.move(originalstorectx, this);	try {	this.unpersisted = false;	newstorectx.update(this);	}	catch (system.systemexception e) {	try {	if (namemodified) this.name = previousname;	originalstorectx.move(newstorectx, this);	
principal move back succeeded 

try {	this.unpersisted = false;	newstorectx.update(this);	}	catch (system.systemexception e) {	try {	if (namemodified) this.name = previousname;	originalstorectx.move(newstorectx, this);	}	catch (system.systemexception deletefail) {	
principal save context move back failed 

public void delete() {	
principal entering delete 

public bool ismemberof(principalcontext context, identitytype identitytype, string identityvalue) {	checkdisposedordeleted();	if (context == null) throw new argumentnullexception("context");	if (identityvalue == null) throw new argumentnullexception("identityvalue");	groupprincipal g = groupprincipal.findbyidentity(context, identitytype, identityvalue);	if (g != null) {	return ismemberof(g);	}	else {	
principal ismemberof urn urn no matching principal 

public virtual void dispose() {	if (!_disposed) {	
principal dispose disposing 

public virtual void dispose() {	if (!_disposed) {	if ((this.underlyingobject != null) && (this.underlyingobject is idisposable)) {	
principal dispose disposing underlying object 

public virtual void dispose() {	if (!_disposed) {	if ((this.underlyingobject != null) && (this.underlyingobject is idisposable)) {	((idisposable)this.underlyingobject).dispose();	}	if ((this.underlyingsearchobject != null) && (this.underlyingsearchobject is idisposable)) {	
principal dispose disposing underlying search object 

protected void checkdisposedordeleted() {	if (_disposed) {	
principal checkdisposedordeleted accessing disposed object 

protected void checkdisposedordeleted() {	if (_disposed) {	throw new objectdisposedexception(this.gettype().tostring());	}	if (_isdeleted) {	
principal checkdisposedordeleted accessing deleted object 

private static principal findbyidentitywithtypehelper(principalcontext context, type principaltype, nullable<identitytype> identitytype, string identityvalue, datetime refdate) {	principal p = context.queryctx.findprincipalbyidentref(principaltype, (identitytype == null) ? null : (string)identmap.stringmap[(int)identitytype, 1], identityvalue, refdate);	if (p != null) {	return p;	}	else {	
principal findbyidentitywithtypehelper no match 

private resultset getgroupshelper() {	checkdisposedordeleted();	if (this.unpersisted) {	
principal getgroupshelper returning empty set 

private resultset getgroupshelper() {	checkdisposedordeleted();	if (this.unpersisted) {	return new emptyset();	}	storectx storectx = getstorectxtouse();	debug.assert(storectx != null);	
principal getgroupshelper querying 

========================= corefx sample_8988 =========================

filteredassert? foundassert = findassertinlist(message);	if (!foundassert.hasvalue) {	base.fail(message, detailmessage);	}	else {	var assert = foundassert.value;	if (assert.handler == handlingoption.coverttoexception) {	throw new failedassertexception(message, assert.bugnumber);	}	else if (assert.handler == handlingoption.writetoconsole) {	
hit known assert bug 

========================= corefx sample_10944 =========================

if (!baselinexelement.name.equals(actualxelement.name)) {	int deskidx, coreclridx;	if (-1 != (deskidx = baselinexelement.name.localname.indexof("zbp0wey4"))) {	if (-1 != (coreclridx = actualxelement.name.localname.indexof("rkuxkxcq"))) {	if (0 == string.compare(baselinexelement.name.localname.substring(0, deskidx), actualxelement.name.localname.substring(0, coreclridx))) {	if (baselinexelement.name.namespace.equals(actualxelement.name.namespace)) return true;	}	}	}	string message = string.format("namespace difference \n[expected]:{0}\n[actual  ]:{1}\n padding expected elements is {2}", baselinexelement.name.namespace, actualxelement.name.namespace, actualxelement.name.localname );	
either padding is different or namespace is not matching 

if (baselinexelement.name.namespace.equals(actualxelement.name.namespace)) return true;	}	}	}	string message = string.format("namespace difference \n[expected]:{0}\n[actual  ]:{1}\n padding expected elements is {2}", baselinexelement.name.namespace, actualxelement.name.namespace, actualxelement.name.localname );	return false;	}	xattribute[] deskatrs = baselinexelement.attributes().orderby(m => m.value).toarray();	xattribute[] coreclratrs = actualxelement.attributes().orderby(m => m.value).toarray();	if (deskatrs.length != coreclratrs.length) {	
number of attributes differ expected number of attributes are actual number of attributes are 

string message = string.format("namespace difference \n[expected]:{0}\n[actual  ]:{1}\n padding expected elements is {2}", baselinexelement.name.namespace, actualxelement.name.namespace, actualxelement.name.localname );	return false;	}	xattribute[] deskatrs = baselinexelement.attributes().orderby(m => m.value).toarray();	xattribute[] coreclratrs = actualxelement.attributes().orderby(m => m.value).toarray();	if (deskatrs.length != coreclratrs.length) {	return false;	}	for (int i = 0; i < deskatrs.length; i++) {	if (deskatrs[i].isnamespacedeclaration != coreclratrs[i].isnamespacedeclaration) {	
either expected attribute is not namespace declaration or actual attribute 

xattribute[] coreclratrs = actualxelement.attributes().orderby(m => m.value).toarray();	if (deskatrs.length != coreclratrs.length) {	return false;	}	for (int i = 0; i < deskatrs.length; i++) {	if (deskatrs[i].isnamespacedeclaration != coreclratrs[i].isnamespacedeclaration) {	return false;	}	if (deskatrs[i].isnamespacedeclaration) {	if (0 != string.compare(deskatrs[i].name.namespacename, coreclratrs[i].name.namespacename)) {	
namespaces are different expected namespace doesn t match with actual namespace 

}	for (int i = 0; i < deskatrs.length; i++) {	if (deskatrs[i].isnamespacedeclaration != coreclratrs[i].isnamespacedeclaration) {	return false;	}	if (deskatrs[i].isnamespacedeclaration) {	if (0 != string.compare(deskatrs[i].name.namespacename, coreclratrs[i].name.namespacename)) {	return false;	}	if (0 != string.compare(deskatrs[i].value, coreclratrs[i].value)) {	
attribute values are different expected attribute values doesn t match with actual attribute value 

return false;	}	if (0 != string.compare(deskatrs[i].value, coreclratrs[i].value)) {	return false;	}	s_prefixtonamespacedesk[deskatrs[i].name.localname] = deskatrs[i].value;	s_prefixtonamespacecoreclr[coreclratrs[i].name.localname] = coreclratrs[i].value;	}	else {	if (!deskatrs[i].name.equals(coreclratrs[i].name)) {	
attribute names are different expected name is but actual name is 

else {	if (!deskatrs[i].name.equals(coreclratrs[i].name)) {	return false;	}	string deskprefix, coreclrprefix;	if (isprefixedattributevalue(deskatrs[i].value, out deskprefix)) {	if (isprefixedattributevalue(coreclratrs[i].value, out coreclrprefix)) {	xnamespace deskns = baselinexelement.getnamespaceofprefix(deskprefix);	xnamespace coreclrns = actualxelement.getnamespaceofprefix(coreclrprefix);	if (!deskns.equals(coreclrns)) {	
xml namespace of attribute is different expected is but actual is 

if (isprefixedattributevalue(coreclratrs[i].value, out coreclrprefix)) {	xnamespace deskns = baselinexelement.getnamespaceofprefix(deskprefix);	xnamespace coreclrns = actualxelement.getnamespaceofprefix(coreclrprefix);	if (!deskns.equals(coreclrns)) {	return false;	}	s_prefixtonamespacedesk[deskprefix] = deskns.namespacename;	s_prefixtonamespacecoreclr[coreclrprefix] = coreclrns.namespacename;	}	else {	
either expected or actual attribute value doesn t have prefix 

if (isprefixedattributevalue(coreclrelemvalue, out coreclrprefix)) {	string deskns, coreclrns;	if (s_prefixtonamespacedesk.trygetvalue(deskprefix, out deskns)) {	if (s_prefixtonamespacecoreclr.trygetvalue(coreclrprefix, out coreclrns)) {	if (deskns.equals(coreclrns)) {	if (0 == string.compare(deskelemvalue.substring(deskprefix.length), coreclrelemvalue.substring(coreclrprefix.length))) return true;	}	}	}	}	
attribute value has empty prefix value before 

if (s_prefixtonamespacedesk.trygetvalue(deskprefix, out deskns)) {	if (s_prefixtonamespacecoreclr.trygetvalue(coreclrprefix, out coreclrns)) {	if (deskns.equals(coreclrns)) {	if (0 == string.compare(deskelemvalue.substring(deskprefix.length), coreclrelemvalue.substring(coreclrprefix.length))) return true;	}	}	}	}	return false;	}	
attribute value has empty prefix value before 

private static bool isprefixedattributevalue(string atrvalue, out string localprefix) {	int prefixindex = atrvalue.indexof(":");	if (prefixindex != -1) {	localprefix = atrvalue.substring(0, prefixindex);	return true;	}	else {	localprefix = string.empty;	}	
given attribute value does not have any prefix value before 

========================= corefx sample_4539 =========================

private static void checkfordeadlocks(object state) {	if (s_isenabled) {	long now = datetime.utcnow.ticks;	foreach (var threadduepair in s_threadduetimes) {	if (!threadduepair.value.disableabort && now > threadduepair.value.duetime) {	thread t = threadduepair.key;	
deadlock detected on thread with managed thread id 

========================= corefx sample_10983 =========================

private void verifyoutput(string expected) {	string actual = _strwriter.tostring();	if (actual != expected) {	
expected 

private void verifyoutput(string expected) {	string actual = _strwriter.tostring();	if (actual != expected) {	
actual 

public void ns_handling_19a(xmlwriterutils utils, namespacehandling nshandling, string prefix, string name, bool isattr) {	xmlwritersettings wsettings = new xmlwritersettings();	wsettings.namespacehandling = nshandling;	xmlwriter w = creatememwriter(utils, wsettings);	w.writestartelement("root");	try {	if (isattr) w.writeattributestring(prefix, name, null, null);	else w.writeelementstring(prefix, name, null, null);	cerror.compare(false, "error");	}	
state 

========================= corefx sample_12445 =========================

public void start() {	if (_listener != null) {	throw new invalidoperationexception("cannot restart server.");	}	_listener = new tcplistener(_options.address, _port);	_listener.start(_options.listenbacklog);	var ipendpoint = (ipendpoint)_listener.localendpoint;	_port = ipendpoint.port;	
server waiting for connections 

private async task<bool> processhttp(func<string, task<string>> httpconversation) {	while (true) {	var requestbuffer = new byte[2048];	int bytesread = await stream.readasync(requestbuffer, 0, requestbuffer.length).configureawait(false);	string requeststring = encoding.utf8.getstring(requestbuffer, 0, bytesread);	
server received bytes 

private async task<bool> processhttp(func<string, task<string>> httpconversation) {	while (true) {	var requestbuffer = new byte[2048];	int bytesread = await stream.readasync(requestbuffer, 0, requestbuffer.length).configureawait(false);	string requeststring = encoding.utf8.getstring(requestbuffer, 0, bytesread);	if (bytesread == 0) {	
server received eof 

var requestbuffer = new byte[2048];	int bytesread = await stream.readasync(requestbuffer, 0, requestbuffer.length).configureawait(false);	string requeststring = encoding.utf8.getstring(requestbuffer, 0, bytesread);	if (bytesread == 0) {	return false;	}	string responsestring = await httpconversation(requeststring).configureawait(false);	if (responsestring != null) {	byte[] responsebuffer = encoding.utf8.getbytes(responsestring);	await stream.writeasync(responsebuffer, 0, responsebuffer.length).configureawait(false);	
server replied with bytes 

========================= corefx sample_4428 =========================

gc.keepalive(o2);	latch l = new latch();	w = makeweakreference(() => new c(l));	gc.collect();	verifyisdead(w);	l = new latch();	w = makeweakreference(() => new resurrectingc(l), true);	gc.collect();	gc.waitforpendingfinalizers();	if (!l.finalizerran) {	
attempted gc but could not force test object to finalize test skipped 

}	else {	verifystillalive(w);	}	l = new latch();	w = makeweakreference(() => new c(l), true);	gc.collect();	gc.waitforpendingfinalizers();	gc.collect();	if (!l.finalizerran) {	
attempted gc but could not force test object to finalize test skipped 

gc.keepalive(o2);	latch l = new latch();	w = makeweakreferenceofobject(() => new c(l));	gc.collect();	verifyisdead(w);	l = new latch();	w = makeweakreferenceofobject(() => new resurrectingc(l), true);	gc.collect();	gc.waitforpendingfinalizers();	if (!l.finalizerran) {	
attempted gc but could not force test object to finalize test skipped 

}	else {	verifystillalive(w);	}	l = new latch();	w = makeweakreferenceofobject(() => new c(l), true);	gc.collect();	gc.waitforpendingfinalizers();	gc.collect();	if (!l.finalizerran) {	
attempted gc but could not force test object to finalize test skipped 

========================= corefx sample_1730 =========================

private void logverifyerrors(x509certificate2 cert, string testname) {	try {	using (var chain = new x509chain()) {	if (!chain.build(cert)) {	foreach (x509chainstatus chainstatus in chain.chainstatus) {	
verify error testname chainstatus status chainstatus statusinformation 

private void logverifyerrors(x509certificate2 cert, string testname) {	try {	using (var chain = new x509chain()) {	if (!chain.build(cert)) {	foreach (x509chainstatus chainstatus in chain.chainstatus) {	}	}	else {	
verify expected error received none testname 

using (var chain = new x509chain()) {	if (!chain.build(cert)) {	foreach (x509chainstatus chainstatus in chain.chainstatus) {	}	}	else {	}	}	}	catch (exception e) {	
verify exception testname e 

========================= corefx sample_12038 =========================

public static void waitall() {	
waitall testing cancellationtokentests waitall if join does not work then a deadlock will occur 

public static void deregisterfromwithinacallbackissafe_basictest() {	
cancellationtokentests deregisterfromwithinacallbackissafe basictest 

public static void deregisterfromwithinacallbackissafe_basictest() {	
this method should complete immediately delay to complete indicates a deadlock failure 

public static void deregisterfromwithinacallbackissafe_basictest() {	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken ct = cts.token;	cancellationtokenregistration ctr1 = ct.register(() => { });	ct.register(() => { ctr1.dispose(); });	cts.cancel();	
completed ok 

cancellationtokensource cts = new cancellationtokensource();	cts.dispose();	cts = new cancellationtokensource(-1);	cancellationtoken token = cts.token;	manualreseteventslim mres = new manualreseteventslim(false);	cancellationtokenregistration ctr = token.register(() => mres.set());	assert.false(token.iscancellationrequested, "cancellationtokensourcewithtimer:  cancellation signaled on infinite timeout (int)!");	cts.cancelafter(1000000);	assert.false(token.iscancellationrequested, "cancellationtokensourcewithtimer:  cancellation signaled on super-long timeout (int) !");	cts.cancelafter(1);	
cancellationtokensourcewithtimer about to wait on cancellation that should occur soon int if we hang something bad happened 

cts.dispose();	timespan prettylong = new timespan(1, 0, 0);	cts = new cancellationtokensource(prettylong);	token = cts.token;	mres = new manualreseteventslim(false);	ctr = token.register(() => mres.set());	assert.false(token.iscancellationrequested, "cancellationtokensourcewithtimer:  cancellation signaled on super-long timeout (timespan,1)!");	cts.cancelafter(prettylong);	assert.false(token.iscancellationrequested, "cancellationtokensourcewithtimer:  cancellation signaled on super-long timeout (timespan,2) !");	cts.cancelafter(new timespan(1000));	
cancellationtokensourcewithtimer about to wait on cancellation that should occur soon timespan if we hang something bad happened 

public static void bug720327_deregisterfromwithinacallbackissafe_synccontexttest() {	
cancellationtokentests deregisterfromwithinacallbackissafe synccontexttest 

public static void bug720327_deregisterfromwithinacallbackissafe_synccontexttest() {	
this method should complete immediately delay to complete indicates a deadlock failure 

cancellationtoken ct = cts.token;	cancellationtokenregistration ctr1 = ct.register(() => { });	cancellationtokenregistration ctr2 = ct.register(() => { });	cancellationtokenregistration ctr3 = ct.register(() => { });	cancellationtokenregistration ctr4 = ct.register(() => { });	ct.register(() => { ctr1.dispose(); }, true);	ct.register(() => { ctr2.dispose(); }, false);	ct.register(() => { ctr3.dispose(); }, true);	ct.register(() => { ctr4.dispose(); }, false);	cts.cancel();	
completed ok 

========================= corefx sample_3994 =========================

public void randomoperationstest() {	int operationcount = this.randomoperationscount;	var expected = new sorteddictionary<int, bool>();	var actual = immutablesorteddictionary<int, bool>.empty;	int seed = unchecked((int)datetime.now.ticks);	
using random seed 

while (expected.containskey(key));	}	value = random.next() % 2 == 0;	debug.writeline("setting \"{0}\"={1} to the set (overwrite={2}).", key, value, overwrite);	expected[key] = value;	actual = actual.setitem(key, value);	break;	case operation.remove: if (expected.count > 0) {	int position = random.next(expected.count);	key = expected.skip(position).first().key;	
removing element from the set 

for (int j = 0; j < timing.length; j++) {	sw.start();	for (int i = 0; i < 10000; i++) {	foreach (var entry in dictionary) {	}	}	timing[j] = sw.elapsed;	sw.reset();	}	string timingtext = string.join(environment.newline, timing);	
timing 

for (int j = 0; j < timing.length; j++) {	sw.start();	for (int i = 0; i < 10000; i++) {	foreach (var entry in dictionary) {	}	}	timing[j] = sw.elapsed;	sw.reset();	}	string timingtext = string.join(environment.newline, timing);	
timing empty 

========================= corefx sample_7319 =========================

if (urnscheme != null) {	if ((urnscheme == urnscheme.sidscheme) && (principaltype == typeof(principal) || principaltype == typeof(groupprincipal) || principaltype.issubclassof(typeof(groupprincipal)))) {	securityidentifier sid = new securityidentifier(urnvalue);	byte[] sidb = new byte[sid.binarylength];	sid.getbinaryform(sidb, 0);	if (sid == null) throw new argumentexception(sr.storectxsecurityidentityclaimbadformat);	intptr psid = intptr.zero;	try {	psid = utils.convertbytearraytointptr(sidb);	if (unsafenativemethods.isvalidsid(psid) && (utils.classifysid(psid) == sidtype.fakeobject)) {	
adstorectx findprincipalbyidentrefhelper fake principal sid scheme 

sidb = new byte[sid.binarylength];	sid.getbinaryform(sidb, 0);	}	catch (argumentexception) {	}	if (sidb != null) {	intptr psid = intptr.zero;	try {	psid = utils.convertbytearraytointptr(sidb);	if (unsafenativemethods.isvalidsid(psid) && (utils.classifysid(psid) == sidtype.fakeobject)) {	
adstorectx findprincipalbyidentrefhelper fake principal null scheme 

innerldapfilter.append("(|");	string filterval = null;	foreach (string urnschemetotry in urnschemestotry) {	if (buildldapfilterfromidentityclaim(urnvalue, urnschemetotry, ref filterval, usesidhistory, false)) if (null != filterval) innerldapfilter.append(filterval);	}	innerldapfilter.append(")");	ldapfilter.append(innerldapfilter.tostring());	}	ldapfilter.append(")");	ds.filter = ldapfilter.tostring();	
adstorectx findprincipalbyidentrefhelper using ldap filter 

}	innerldapfilter.append(")");	ldapfilter.append(innerldapfilter.tostring());	}	ldapfilter.append(")");	ds.filter = ldapfilter.tostring();	src = ds.findall();	debug.assert(src != null);	if (src == null) return null;	int count = src.count;	
adstorectx findprincipalbyidentrefhelper found matches 

protected static void lastlogonfromldapconverter(dspropertycollection properties, string suggestedadproperty, principal p, string propertyname) {	if (string.compare(suggestedadproperty, "lastlogon", stringcomparison.ordinalignorecase) == 0) {	if (properties["lastlogontimestamp"].count != 0) {	
adstorectx lastlogonfromldapconverter found lastlogontimestamp 

scanaclforchangepasswordright(adssecurity, out denyselffound, out denyworldfound, out allowselffound, out allowworldfound);	bool usercannotchangepassword;	if (denyselffound || denyworldfound) {	usercannotchangepassword = true;	}	else if ((!denyselffound && !denyworldfound) && (allowselffound || allowworldfound)) {	usercannotchangepassword = false;	}	else {	usercannotchangepassword = false;	
adstorectx cannotchangepwdfromldapconverter fallback assume user can change pwd 

protected static void extensioncachetoldapconverter(principal p, string propertyname, directoryentry de, string suggestedadproperty) {	extensioncache cachevalues = (extensioncache)p.getvalueforproperty(propertyname);	
adstorectx extensioncachetoldapconverter 

protected static void extensioncachetoldapconverter(principal p, string propertyname, directoryentry de, string suggestedadproperty) {	extensioncache cachevalues = (extensioncache)p.getvalueforproperty(propertyname);	foreach (keyvaluepair<string, extensioncachevalue> kvp in cachevalues.properties) {	if (!kvp.value.filter && null != kvp.value.value && kvp.value.value.length != 0) {	
adstorectx extensioncachetoldapconverter value type 

protected static void extensioncachetoldapconverter(principal p, string propertyname, directoryentry de, string suggestedadproperty) {	extensioncache cachevalues = (extensioncache)p.getvalueforproperty(propertyname);	foreach (keyvaluepair<string, extensioncachevalue> kvp in cachevalues.properties) {	if (!kvp.value.filter && null != kvp.value.value && kvp.value.value.length != 0) {	if ((kvp.value.value.length == 1 && kvp.value.value[0] is icollection) || (kvp.value.value.length > 1)) {	if (kvp.value.value.length > 1 && (kvp.value.value[0] is icollection)) throw new argumentexception(sr.invalidextensioncollectiontype);	
adstorectx extensioncachetoldapconverter value implements icollection 

icollection valuecollection;	if (kvp.value.value.length == 1 && kvp.value.value[0] is icollection && !(kvp.value.value[0] is byte[])) {	valuecollection = (icollection)kvp.value.value[0];	}	else {	valuecollection = (icollection)kvp.value.value;	}	foreach (object oval in valuecollection) {	if (null != oval) {	if ((oval is icollection || oval is ilist) && !(oval is byte[])) throw new argumentexception(sr.invalidextensioncollectiontype);	
adstorectx extensioncachetoldapconverter element value type 

icollection valuecollection;	if (kvp.value.value.length == 1 && kvp.value.value[0] is icollection && !(kvp.value.value[0] is byte[])) {	valuecollection = (icollection)kvp.value.value[0];	}	else {	valuecollection = (icollection)kvp.value.value;	}	foreach (object oval in valuecollection) {	if (null != oval) {	if ((oval is icollection || oval is ilist) && !(oval is byte[])) throw new argumentexception(sr.invalidextensioncollectiontype);	
adstorectx extensioncachetoldapconverter adding element 

else {	valuecollection = (icollection)kvp.value.value;	}	foreach (object oval in valuecollection) {	if (null != oval) {	if ((oval is icollection || oval is ilist) && !(oval is byte[])) throw new argumentexception(sr.invalidextensioncollectiontype);	}	if (p.unpersisted && null == oval) continue;	de.properties[kvp.key].add(oval);	}	
adstorectx extensioncachetoldapconverter collection complete 

}	foreach (object oval in valuecollection) {	if (null != oval) {	if ((oval is icollection || oval is ilist) && !(oval is byte[])) throw new argumentexception(sr.invalidextensioncollectiontype);	}	if (p.unpersisted && null == oval) continue;	de.properties[kvp.key].add(oval);	}	}	else {	
adstorectx extensioncachetoldapconverter adding 

protected static void updategroupmembership(principal group, directoryentry de, netcred credentials, authenticationtypes authtypes) {	debug.assert(group.fakeprincipal == false);	principalcollection members = (principalcollection)group.getvalueforproperty(propertynames.groupmembers);	directoryentry groupde = null;	try {	if (members.cleared) {	directoryentry copyofde = null;	try {	
adstorectx updategroupmembership clearing 

type membertype = member.gettype();	if ((membertype != typeof(userprincipal)) && (!membertype.issubclassof(typeof(userprincipal))) && (membertype != typeof(computerprincipal)) && (!membertype.issubclassof(typeof(computerprincipal))) && (membertype != typeof(groupprincipal)) && (!membertype.issubclassof(typeof(groupprincipal))) && (!membertype.issubclassof(typeof(authenticableprincipal)))) {	throw new invalidoperationexception( string.format(cultureinfo.currentculture, sr.storectxunsupportedprincipaltypeforgroupinsert, membertype.tostring()));	}	if (member.unpersisted) throw new invalidoperationexception(sr.storectxgrouphasunpersistedinsertedprincipal);	debug.assert(member.context != null);	if (member.contexttype == contexttype.machine) throw new invalidoperationexception(sr.adstorectxunsupportedprincipalcontextforgroupinsert);	}	foreach (principal member in insertedmembers) {	if (!member.fakeprincipal && adutils.areprincipalsinsameforest(group, member)) {	
adstorectx updategroupmembership add 

debug.assert(member.context != null);	if (member.contexttype == contexttype.machine) throw new invalidoperationexception(sr.adstorectxunsupportedprincipalcontextforgroupinsert);	}	foreach (principal member in insertedmembers) {	if (!member.fakeprincipal && adutils.areprincipalsinsameforest(group, member)) {	groupde.properties["member"].add(member.distinguishedname);	}	else {	string membersiddn = getsidpathfromprincipal(member);	if (membersiddn == null) throw new principaloperationexception(sr.adstorectxcouldntgetsidforgroupmember);	
adstorectx updategroupmembership add 

if (membersiddn == null) throw new principaloperationexception(sr.adstorectxcouldntgetsidforgroupmember);	groupde.properties["member"].add(membersiddn);	}	}	if (insertedmembers.count > 0) groupde.commitchanges();	foreach (principal member in removedmembers) {	debug.assert(member.unpersisted == false);	debug.assert(member.contexttype == contexttype.domain || member.contexttype == contexttype.applicationdirectory);	debug.assert(members.cleared == false);	if (!member.fakeprincipal && adutils.areprincipalsinsameforest(group, member)) {	
adstorectx updategroupmembership remove via dn 

foreach (principal member in removedmembers) {	debug.assert(member.unpersisted == false);	debug.assert(member.contexttype == contexttype.domain || member.contexttype == contexttype.applicationdirectory);	debug.assert(members.cleared == false);	if (!member.fakeprincipal && adutils.areprincipalsinsameforest(group, member)) {	groupde.properties["member"].remove(member.distinguishedname);	}	else {	string membersiddn = getsidpathfromprincipal(member);	if (membersiddn == null) throw new principaloperationexception(sr.adstorectxcouldntgetsidforgroupmember);	
adstorectx updategroupmembership remove via sid 

protected static string getsidpathfromprincipal(principal p) {	debug.assert(p.unpersisted == false);	if (p.fakeprincipal) {	securityidentifier sid = p.sid;	if (sid == null) {	
adstorectx getsidadspathfromprincipal no sid ic fake principal 

throw new invalidoperationexception(sr.storectxneedvaluesecurityidentityclaimtoquery);	}	return @"<sid=" + utils.securityidentifiertoldaphexbindingstring(sid) + ">";	}	else {	directoryentry de = (directoryentry)p.underlyingobject;	debug.assert(de != null);	if (!de.properties.contains("objectsid")) de.refreshcache(new string[] { "objectsid" });	byte[] sid = (byte[])de.properties["objectsid"].value;	if (sid == null) {	
adstorectx getsidadspathfromprincipal no sid 

========================= corefx sample_9029 =========================

public static void mount(string volumename, string mountpoint) {	if (volumename[volumename.length - 1] != path.directoryseparatorchar) volumename += path.directoryseparatorchar;	if (mountpoint[mountpoint.length - 1] != path.directoryseparatorchar) mountpoint += path.directoryseparatorchar;	
mounting volume at 

public static void mount(string volumename, string mountpoint) {	if (volumename[volumename.length - 1] != path.directoryseparatorchar) volumename += path.directoryseparatorchar;	if (mountpoint[mountpoint.length - 1] != path.directoryseparatorchar) mountpoint += path.directoryseparatorchar;	bool r;	stringbuilder sb = new stringbuilder(1024);	r = getvolumenameforvolumemountpoint(volumename, sb, sb.capacity);	if (!r) throw new exception(string.format("win32 error: {0}", marshal.getlastwin32error()));	string uniquename = sb.tostring();	
uniquename 

public static void unmount(string mountpoint) {	if (mountpoint[mountpoint.length - 1] != path.directoryseparatorchar) mountpoint += path.directoryseparatorchar;	
unmounting the volume at 

========================= corefx sample_295 =========================

public void reset() {	
rangeretriever reset 

public bool movenext() {	
rangeretriever entering movenext 

if (_endreached) return false;	if (_currentindex < innerlist.count) {	_currentresult = innerlist[_currentindex];	_currentindex++;	return true;	}	else if (_cachefilled) {	return false;	}	if (!_endreached && _currentenumerator == null) {	
rangeretriever movenext first time 

_currentresult = innerlist[_currentindex];	_currentindex++;	return true;	}	else if (_cachefilled) {	return false;	}	if (!_endreached && _currentenumerator == null) {	_currentenumerator = getnextchunk();	if (_currentenumerator == null) {	
rangeretriever movenext got null enumerator for first time 

}	}	if (_endreached) return false;	bool needtoretry;	bool f;	do {	needtoretry = false;	f = _currentenumerator.movenext();	if (f) {	_currentresult = _currentenumerator.current;	
rangeretriever movenext got a result 

if (_endreached) return false;	bool needtoretry;	bool f;	do {	needtoretry = false;	f = _currentenumerator.movenext();	if (f) {	_currentresult = _currentenumerator.current;	}	else {	
rangeretriever movenext retrieving next range 

bool f;	do {	needtoretry = false;	f = _currentenumerator.movenext();	if (f) {	_currentresult = _currentenumerator.current;	}	else {	_currentenumerator = getnextchunk();	if (_currentenumerator == null) {	
rangeretriever movenext end reached 

private ienumerator getnextchunk() {	string rangedattribute = string.format( cultureinfo.invariantculture, "{0};range={1}-*", _propertyname, _lowrange);	globaldebug.writelineif(globaldebug.info, "rangeretriever", "getnextchunk: rangedattribute={0}", rangedattribute);	try {	_de.refreshcache(new string[] { rangedattribute, _propertyname });	}	catch (system.runtime.interopservices.comexception e) {	if (e.errorcode == unchecked((int)0x80072020)) {	
rangeretriever getnextchunk no more results 

}	catch (system.runtime.interopservices.comexception e) {	if (e.errorcode == unchecked((int)0x80072020)) {	return null;	}	globaldebug.writelineif(globaldebug.error, "rangeretriever", "getnextchunk: caught comexception, errorcode={0}", e.errorcode);	throw;	}	propertyvaluecollection pvc = _de.properties[_propertyname];	if (pvc == null || pvc.count == 0) {	
rangeretriever getnextchunk empty property 

========================= corefx sample_9039 =========================

public bool checkandclearcredentials(itestoutputhelper output) {	if (!_successfulsetup) {	return false;	}	var startinfo = new processstartinfo(kdestroycmd);	startinfo.createnowindow = true;	startinfo.arguments = "-a";	using (process clearcreds = process.start(startinfo)) {	clearcreds.waitforexit();	
kdestroy returned 

public async task negotiatestream_streamtostream_kerberosauthentication_success() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream kerberosauthentication success 

public async task negotiatestream_streamtostream_authtohttptarget_success() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream authtohttptarget success 

public async task negotiatestream_streamtostream_kerberosauthwithoutrealm_success() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream kerberosauthwithoutrealm success 

public async task negotiatestream_streamtostream_kerberosauthdefaultcredentials_success() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream kerberosauthdefaultcredentials success 

public async task negotiatestream_echoserver_clientwriteread_successive_sync_success() {	if (!_iskrbavailable) {	
skipping negotiatestream echoserver clientwriteread successive sync success 

public async task negotiatestream_echoserver_clientwriteread_successive_async_success() {	if (!_iskrbavailable) {	
skipping negotiatestream echoserver clientwriteread successive async success 

public void negotiatestream_streamtostream_kerberosauthdefaultcredentialsnoseed_failure() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream kerberosauthdefaultcredentialsnoseed failure 

public void negotiatestream_streamtostream_kerberosauthinvaliduser_failure() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream kerberosauthinvaliduser failure 

public void negotiatestream_streamtostream_kerberosauthinvalidpassword_failure() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream kerberosauthinvalidpassword failure 

public void negotiatestream_streamtostream_kerberosauthinvalidtarget_failure() {	if (!_iskrbavailable) {	
skipping negotiatestream streamtostream kerberosauthinvalidtarget failure 

public async task negotiatestream_streamtostream_ntlmauthentication_validcredentials_success(networkcredential credential) {	if (!_isntlmavailable) {	
skipping negotiatestream streamtostream ntlmauthentication validcredentials success 

public async task negotiatestream_streamtostream_ntlmauthentication_fallback_success() {	if (!_isntlmavailable) {	
skipping negotiatestream streamtostream ntlmauthentication emptytarget kerberosuser fallback success 

public async task negotiatestream_streamtostream_ntlmauthentication_kerberoscreds_success() {	if (!_isntlmavailable) {	
skipping negotiatestream streamtostream ntlmauthentication kerberoscreds success 

public async task negotiatestream_echoserver_ntlm_clientwriteread_successive_sync_success() {	if (!_isntlmavailable) {	
skipping negotiatestream echoserver ntlm clientwriteread successive sync success 

public async task negotiatestream_echoserver_ntlm_clientwriteread_successive_async_success() {	if (!_isntlmavailable) {	
skipping negotiatestream echoserver ntlm clientwriteread successive async success 

public void negotiatestream_streamtostream_ntlmauthentication_ntlmuser_invalidcredentials_fail(networkcredential credential) {	if (!_isntlmavailable) {	
skipping negotiatestream streamtostream ntlmauthentication ntlmuser invalidcredentials fail 

========================= corefx sample_8126 =========================

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
stats for 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
bytesreceived 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
bytessent 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingpacketsdiscarded 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingpacketswitherrors 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingunknownprotocolpackets 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
nonunicastpacketsreceived 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
nonunicastpacketssent 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
outgoingpacketsdiscarded 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
outgoingpacketswitherrors 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
outputqueuelength 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
unicastpacketsreceived 

public void basictest_getipv4interfacestatistics_success() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
unicastpacketssent 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
stats for 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
bytesreceived 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
bytessent 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingpacketsdiscarded 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingpacketswitherrors 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	
nonunicastpacketsreceived 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
outgoingpacketsdiscarded 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
outgoingpacketswitherrors 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
outputqueuelength 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
unicastpacketsreceived 

public void basictest_getipv4interfacestatistics_success_linux() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.incomingunknownprotocolpackets);	assert.throws<platformnotsupportedexception>(() => stats.nonunicastpacketssent);	
unicastpacketssent 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
stats for 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
bytesreceived 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
bytessent 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingpacketsdiscarded 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingpacketswitherrors 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
incomingunknownprotocolpackets 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
nonunicastpacketsreceived 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	
nonunicastpacketssent 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
outgoingpacketswitherrors 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
outputqueuelength 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
unicastpacketsreceived 

public void basictest_getipv4interfacestatistics_success_osx() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipv4interfacestatistics stats = nic.getipv4statistics();	assert.throws<platformnotsupportedexception>(() => stats.outgoingpacketsdiscarded);	
unicastpacketssent 

========================= corefx sample_13370 =========================

public void processstart_useshellexecute_onlinux_throwsifnoprograminstalled() {	if (!s_allowedprogramstorun.any(program => isprograminstalled(program))) {	
none of the following programs were installed on this machine string join s allowedprogramstorun 

string filetoopen = gettestfilepath() + ".txt";	file.writealltext(filetoopen, $"{nameof(processstart_openfileonlinux_usesspecifiedprogram)}");	using (var px = process.start(programtoopenwith, filetoopen)) {	assert.equal(programtoopenwith, px.processname);	px.kill();	px.waitforexit();	assert.true(px.hasexited);	}	}	else {	
program specified to open file with programtoopenwith is not installed on this machine 

processstartinfo psi = new processstartinfo(programtoopenwith);	psi.argumentlist.add(filetoopen);	using (var px = process.start(psi)) {	assert.equal(programtoopenwith, px.processname);	px.kill();	px.waitforexit();	assert.true(px.hasexited);	}	}	else {	
program specified to open file with programtoopenwith is not installed on this machine 

public void processstart_openfileonosx_usesspecifiedprogram(string programtoopenwith) {	string filetoopen = gettestfilepath() + ".txt";	file.writealltext(filetoopen, $"{nameof(processstart_openfileonosx_usesspecifiedprogram)}");	using (var px = process.start(programtoopenwith, filetoopen)) {	
in osx nameof programtoopenwith is programtoopenwith while nameof px processname is px processname 

========================= corefx sample_3912 =========================

}	interop.advapi32.tokenprivileges tkp = new interop.advapi32.tokenprivileges();	tkp.luid = debugvalue;	tkp.attributes = attrib;	interop.advapi32.adjusttokenprivileges(htoken, false, tkp, 0, intptr.zero, intptr.zero);	if (marshal.getlastwin32error() != interop.errors.error_success) {	throw new win32exception();	}	}	finally {	
process closehandle processtoken 

private safeprocesshandle getprocesshandle(int access, bool throwifexited) {	#if feature_traceswitch debug.writelineif(_processtracing.traceverbose, "getprocesshandle(access = 0x" + access.tostring("x8", cultureinfo.invariantculture) + ", throwifexited = " + throwifexited + ")");	#if debug if (_processtracing.traceverbose) {	stackframe calledfrom = new stacktrace(true).getframe(0);	
called from line 

========================= corefx sample_3943 =========================

public static void runcontinuewithbase( taskcontinuationoptions options, action initran, func<task, task> continuationmaker, func<bool> ranvalue, bool taskisfuture) {	
continuewith after task finishes successfully 

task.wait();	initran();	bool cancel = false;	task cont = continuationmaker(task);	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	if (expect != ranvalue() || expect == cancel) {	assert.true(false, string.format("runcontinuewithbase: >> failed: continuation didn't run or get canceled when expected: ran = {0}, cancel = {1}", ranvalue(), cancel));	}	}	
continuewith before task finishes successfully 

public static void runcontinuewithbase_negativecases( taskcontinuationoptions options, action initran, func<task, task> continuationmaker, func<bool> ranvalue, bool taskisfuture) {	
continuewith after task finishes exceptionally 

catch (aggregateexception) { /*swallow(ouch)*/ }	initran();	bool cancel = false;	task cont = continuationmaker(task);	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	if (expect != ranvalue() || expect == cancel) {	assert.true(false, string.format("runcontinuewithbase: >> failed: continuation didn't run or get canceled when expected: ran = {0}, cancel = {1}", ranvalue(), cancel));	}	}	
continuewith before task finishes exceptionally 

task cont = continuationmaker(task);	mre.set();	try { task.wait(); }	catch (aggregateexception) { /*swallow(ouch)*/ }	try { cont.wait(); }	catch (aggregateexception ex) { if (ex.innerexceptions[0] is taskcanceledexception) cancel = true; }	if (expect != ranvalue() || expect == cancel) {	assert.true(false, string.format("runcontinuewithbase: >> failed: continuation didn't run or get canceled when expected: ran = {0}, cancel = {1}", ranvalue(), cancel));	}	}	
continuewith after task becomes aborted 

========================= corefx sample_4014 =========================

protected override xslflags visitcalltemplate(xslnode node) {	xslflags result = xslflags.none;	template target;	if (!_compiler.namedtemplates.trygetvalue(node.name, out target)) {	
unknown template error 

protected override xslflags visituseattributeset(xslnode node) {	attributeset attset;	if (!_compiler.attributesets.trygetvalue(node.name, out attset)) {	
unknown attribute set error 

_typedonor = null;	return (left & ~xslflags.typefilter) | xslflags.nodeset;	}	public virtual xslflags predicate(xslflags nodeset, xslflags predicate, bool isreversestep) {	_typedonor = null;	return (nodeset & ~xslflags.typefilter) | xslflags.nodeset | (predicate & xslflags.sideeffects);	}	public virtual xslflags variable(string prefix, string name) {	_typedonor = resolvevariable(prefix, name);	if (_typedonor == null) {	
unresolved variable error 

========================= corefx sample_13344 =========================

private static void verifykey_rsa(x509certificate2 cert, rsa rsa) {	rsaparameters rsaparameters = rsa.exportparameters(false);	byte[] expectedmodulus = ( "e8af5ca2200df8287cbc057b7fadeeeb76ac28533f3adb407db38e33e6573fa5" + "51153454a5cfb48ba93fa837e12d50ed35164eef4d7adb137688b02cf0595ca9" + "ebe1d72975e41b85279bf3f82d9e41362b0b40fbbe3bbab95c759316524bca33" + "c537b0f3eb7ea8f541155c08651d2137f02cba220b10b1109d772285847c4fb9" + "1b90b0f5a3fe8bf40c9a4ea0f5c90a21e2aae3013647fd2f826a8103f5a935dc" + "94579dfb4bd40e82db388f12fee3d67a748864e162c4252e2aae9d181f0e1eb6" + "c2af24b40e50bcde1c935c49a679b5b6dbcef9707b280184b82a29cfbfa90505" + "e1e00f714dfdad5c238329ebc7c54ac8e82784d37ec6430b950005b14f6571c5").hextobytearray();	byte[] expectedexponent = new byte[] { 0x01, 0x00, 0x01 };	byte[] originalmodulus = rsaparameters.modulus;	byte[] originalexponent = rsaparameters.exponent;	if (!expectedmodulus.sequenceequal(rsaparameters.modulus) || !expectedexponent.sequenceequal(rsaparameters.exponent)) {	
modulus or exponent not equal 

private static void verifykey_rsa(x509certificate2 cert, rsa rsa) {	rsaparameters rsaparameters = rsa.exportparameters(false);	byte[] expectedmodulus = ( "e8af5ca2200df8287cbc057b7fadeeeb76ac28533f3adb407db38e33e6573fa5" + "51153454a5cfb48ba93fa837e12d50ed35164eef4d7adb137688b02cf0595ca9" + "ebe1d72975e41b85279bf3f82d9e41362b0b40fbbe3bbab95c759316524bca33" + "c537b0f3eb7ea8f541155c08651d2137f02cba220b10b1109d772285847c4fb9" + "1b90b0f5a3fe8bf40c9a4ea0f5c90a21e2aae3013647fd2f826a8103f5a935dc" + "94579dfb4bd40e82db388f12fee3d67a748864e162c4252e2aae9d181f0e1eb6" + "c2af24b40e50bcde1c935c49a679b5b6dbcef9707b280184b82a29cfbfa90505" + "e1e00f714dfdad5c238329ebc7c54ac8e82784d37ec6430b950005b14f6571c5").hextobytearray();	byte[] expectedexponent = new byte[] { 0x01, 0x00, 0x01 };	byte[] originalmodulus = rsaparameters.modulus;	byte[] originalexponent = rsaparameters.exponent;	if (!expectedmodulus.sequenceequal(rsaparameters.modulus) || !expectedexponent.sequenceequal(rsaparameters.exponent)) {	rsaparameters = rsa.exportparameters(false);	if (!expectedmodulus.sequenceequal(rsaparameters.modulus) || !expectedexponent.sequenceequal(rsaparameters.exponent)) {	
second call to exportparameters did not produce valid data either 

byte[] originalmodulus = rsaparameters.modulus;	byte[] originalexponent = rsaparameters.exponent;	if (!expectedmodulus.sequenceequal(rsaparameters.modulus) || !expectedexponent.sequenceequal(rsaparameters.exponent)) {	rsaparameters = rsa.exportparameters(false);	if (!expectedmodulus.sequenceequal(rsaparameters.modulus) || !expectedexponent.sequenceequal(rsaparameters.exponent)) {	}	if (cert != null) {	rsa = cert.getrsapublickey();	rsaparameters = rsa.exportparameters(false);	if (!expectedmodulus.sequenceequal(rsaparameters.modulus) || !expectedexponent.sequenceequal(rsaparameters.exponent)) {	
new key handle exportparameters was not successful either 

========================= corefx sample_12028 =========================

if (paramvalue.gettype() == typeof(system.datetimeoffset)) {	system.datetimeoffset dt = (system.datetimeoffset)paramvalue;	value = dt.datetime.toshortdatestring() + " " + dt.datetime.timeofday + " " + dt.offset;	}	else if (paramvalue.gettype() == typeof(system.timespan)) {	value = ((system.timespan)paramvalue).tostring();	}	else {	value = ((system.datetime)paramvalue).toshortdatestring() + " " + ((system.datetime)paramvalue).timeofday;	}	
type value 

========================= corefx sample_11090 =========================

public void var1() {	try {	#pragma warning disable 0618 new xsltransform().load((ixpathnavigable)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var2() {	try {	#pragma warning disable 0618 new xsltransform().load((xmlreader)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var3() {	try {	#pragma warning disable 0618 new xsltransform().load((ixpathnavigable)null, (xmlresolver)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var4() {	try {	#pragma warning disable 0618 new xsltransform().load((xmlreader)null, (xmlresolver)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var5() {	{	#pragma warning disable 0618 new xsltransform().load((ixpathnavigable)null, (xmlresolver)null, (evidence)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var6() {	{	#pragma warning disable 0618 new xsltransform().load((xmlreader)null, (xmlresolver)null, (evidence)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var7() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var8() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null, (xmlresolver)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var9() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null, (textwriter)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var10() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null, (textwriter)null, (xmlresolver)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var11() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null, (stream)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var12() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null, (stream)null, (xmlresolver)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var13() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null, (xmlwriter)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var14() {	try {	#pragma warning disable 0618 new xsltransform().transform((ixpathnavigable)null, (xsltargumentlist)null, (xmlwriter)null, (xmlresolver)null);	#pragma warning restore 0618 }	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

if (loadxsl("xmlresolver_main.xsl", inputtype, readertype) == 1) {	xslt.xmlresolver = null;	if (transform("fruits.xml", transformtype, doctype) == 1) {	verifyresult(expected);	return;	}	else assert.true(false);	}	}	catch (exception e) {	
should not throw error loading stylesheet with include import when resolver property is set to null 

public void xmlresolver2(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result></result>";	if (loadxsl("xmlresolver_document_function.xsl", inputtype, readertype) == 1) {	xslt.xmlresolver = null;	if (transform("fruits.xml", transformtype, doctype) == 1) {	verifyresult(expected);	return;	}	}	else {	
problem loading stylesheet with document function and resolver set to null 

public void loadgeneric1(inputtype inputtype, readertype readertype) {	try {	loadxsl(null, inputtype, readertype);	}	catch (system.argumentexception) {	return;	}	
exception not generated for null parameter name 

try {	transform("fruits.xml", transformtype, doctype);	}	catch (system.invalidoperationexception e) {	checkexpectederror(e, "system.xml", "xslt_nostylesheetloaded", new string[] { "" });	return;	}	}	}	else {	
failed to load style sheet 

string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	try {	loadxsl("idontexist.xsl", inputtype, readertype);	}	catch (system.io.filenotfoundexception) {	if ((loadxsl("showparam.xsl", inputtype, readertype) == 1) && (transform("fruits.xml", transformtype, doctype) == 1)) {	verifyresult(expected);	return;	}	}	
exception not generated for non existent file name 

public void loadgeneric5(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	for (int i = 0; i < 100; i++) {	if (loadxsl("showparam.xsl", inputtype, readertype) != 1) {	
failed to load stylesheet showparam xsl on the attempt 

public void loadgeneric6(inputtype inputtype, readertype readertype) {	try {	loadxsl("idontexist.xsl", inputtype, readertype);	}	catch (system.io.filenotfoundexception) {	return;	}	
exception not generated for non existent file parameter name 

if (loadxsl("xmlresolver_main.xsl", inputtype, readertype) == 1) {	s2 = new filestream(fullfilepath("xmlresolver_sub.xsl"), filemode.open, fileaccess.read);	s2.dispose();	if (transform("fruits.xml", transformtype, doctype) == 1) {	verifyresult(expected);	s2 = new filestream(fullfilepath("xmlresolver_include.xsl"), filemode.open, fileaccess.read, fileshare.read);	s2.dispose();	return;	}	}	
appeared to not close file properly after loading 

public void loadgeneric11(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><book> name </book>";	if (doctype.tostring() == "datadocument") return;	else {	if (loadxsl("books_entity_ref.xsl", inputtype.reader, readertype) != 1) {	
failed to load stylesheet books entity ref xsl 

public void loadgeneric12(inputtype inputtype, readertype readertype) {	stream strmtemp;	try {	int i = loadxsl("xslt_error.xsl", inputtype, readertype);	}	catch (system.xml.xsl.xsltcompileexception) {	try {	strmtemp = new filestream(fullfilepath("xslt_error.xsl"), filemode.open, fileaccess.read);	}	catch (exception ex) {	
did not close stylesheet properly after load 

catch (system.xml.xsl.xsltcompileexception) {	try {	strmtemp = new filestream(fullfilepath("xslt_error.xsl"), filemode.open, fileaccess.read);	}	catch (exception ex) {	_output.writeline(ex.message);	assert.true(false);	}	return;	}	
did not throw compile exception for stylesheet 

public void loadgeneric1(inputtype inputtype, readertype readertype) {	try {	loadxsl_resolver(null, null, inputtype, readertype);	}	catch (system.argumentexception) {	return;	}	
did not throw an exception for null argument 

public void loadgeneric2(inputtype inputtype, readertype readertype) {	try {	loadxsl_resolver(null, new xmlurlresolver(), inputtype, readertype);	}	catch (system.argumentexception) {	return;	}	
did not throw an exception for null argument 

public void loadgeneric3(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	if (loadxsl_resolver("showparam.xsl", null, inputtype, readertype) == 1) {	if (transform("fruits.xml", transformtype, doctype) == 1) {	verifyresult(expected);	return;	}	else assert.true(false);	}	else {	
failed to load style sheet 

public void loadgeneric4(inputtype inputtype, readertype readertype) {	try {	loadxsl_resolver("xmlresolver_main.xsl", null, inputtype, readertype);	}	catch (system.xml.xsl.xsltcompileexception e) {	checkexpectederror(e.innerexception, "system.xml", "xml_nullresolver", new string[] { "" });	return;	}	
exception not thrown for null resolver 

public void loadgeneric9(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	using (new allowdefaultresolvercontext()) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result><fruit>apple</fruit><fruit>orange</fruit></result>";	if ((loadxsl_resolver("xmlresolver_main.xsl", getdefaultcredresolver(), inputtype, readertype) == 1)) {	if ((loadxsl("xmlresolver_main.xsl", inputtype, readertype) == 1) && (transform("fruits.xml", transformtype, doctype) == 1)) {	verifyresult(expected);	return;	}	}	else {	
failed to load 

public void loadgeneric10(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	for (int i = 0; i < 100; i++) {	if (loadxsl_resolver("showparam.xsl", null, inputtype, readertype) != 1) {	
failed to load stylesheet showparam xsl on the attempt 

public void loadgeneric11(inputtype inputtype, readertype readertype) {	try {	loadxsl_resolver("idontexist.xsl", null, inputtype, readertype);	}	catch (system.io.filenotfoundexception) {	return;	}	
exception not generated for non existent file parameter name 

}	catch (system.io.filenotfoundexception) {	try {	transform("fruits.xml", transformtype, doctype);	}	catch (system.invalidoperationexception e2) {	checkexpectederror(e2, "system.xml", "xslt_nostylesheetloaded", new string[] { "idontexist.xsl" });	return;	}	}	
exception not generated for non existent file parameter name 

try {	transform("fruits.xml", transformtype, doctype);	}	catch (system.invalidoperationexception e2) {	checkexpectederror(e2, "system.xml", "xslt_nostylesheetloaded", new string[] { "idontexist.xsl" });	return;	}	}	}	else {	
errors loading initial file 

public void loadurlresolver2(inputtype inputtype, readertype readertype) {	try {	loadxsl_resolver(("xmlresolver/xsltresolvertestmain.xsl"), null, inputtype, readertype);	}	catch (system.xml.xsl.xsltexception) {	return;	}	
should not have been able to retrieve and resolve style sheet with null resolver 

public void loadurlresolver3(inputtype inputtype, readertype readertype) {	try {	loadxsl_resolver(null, new xmlurlresolver(), inputtype, readertype);	}	catch (system.argumentexception) {	return;	}	
did not throw an exception for null argument 

public void loadurl1(readertype readertype) {	try {	loadxsl("idontexist.xsl", inputtype.uri, readertype);	}	catch (system.io.filenotfoundexception) {	return;	}	
exception not generated for non existent file parameter name 

public void loadurl2(readertype readertype) {	try {	loadxsl(szempty, inputtype.uri, readertype);	}	catch (system.argumentexception) {	return;	}	
exception not generated for an empty string filename 

public void loadurl3(readertype readertype) {	try {	loadxsl(".", inputtype.uri, readertype);	}	catch (system.unauthorizedaccessexception) {	return;	}	
exception not generated for non existent file parameter name 

public void loadurl(readertype readertype) {	try {	loadxsl("..", inputtype.uri, readertype);	}	catch (system.unauthorizedaccessexception) {	return;	}	
exception not generated for non existent file parameter name 

public void loadurl5(readertype readertype) {	try {	loadxsl("     ", inputtype.uri, readertype);	}	catch (system.argumentexception) {	return;	}	
exception not generated for non existent file parameter name 

public void loadnavigator1(transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 string _strxslfile = "showparam.xsl";	_strxslfile = fullfilepath(_strxslfile);	
compiling 

xrtemp.entityhandling = entityhandling.expandentities;	xrtemp.dispose();	try {	xslt.load(xrtemp);	}	catch (system.xml.xsl.xsltcompileexception e) {	if (platformdetection.isfullframework) checkexpectederror(e.innerexception, "system.data.sqlxml", "xslt_wrongstylesheetelement", new string[] { "" });	else checkexpectederror(e.innerexception, "system.xml", "xslt_wrongstylesheetelement", new string[] { "" });	return;	}	
no exception thrown for a loading a closed reader 

}	catch (exception ex) {	ftest_fail = true;	throw (ex);	}	finally {	if (!ftest_fail || (xrtemp.readstate != readstate.closed)) ftest_fail = false;	xrtemp.dispose();	}	if (ftest_fail) {	
appear to have accidently closed the reader 

}	catch (exception ex) {	ftest_fail = true;	throw (ex);	}	finally {	if (!ftest_fail && (!xrtemp.eof)) ftest_fail = false;	xrtemp.dispose();	}	if (ftest_fail) {	
reader does not appear to be at the end of file 

public void loadxmlreader6() {	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 xmltextreader xrtemp = null;	try {	xslt.load(xrtemp);	}	catch (system.argumentnullexception) {	return;	}	
failed to throw system argumentnullexception for null reader input 

public void transformgeneric3(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	for (int i = 0; i < 100; i++) {	if (transform("fruits.xml", transformtype, doctype) != 1) {	
test failed to transform after iterations 

public void transformgeneric4(transformtype transformtype, doctype doctype) {	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 try {	transform("fruits.xml", transformtype, doctype);	}	catch (system.invalidoperationexception e) {	checkexpectederror(e, "system.xml", "xslt_nostylesheetloaded", new string[] { "" });	return;	}	
exception not given for a transform that didn t have a load method instantiated 

public void transformgeneric5(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	filestream s2;	if ((loadxsl("showparam.xsl", inputtype, readertype) == 1) && (transform("fruits.xml", transformtype, doctype) == 1)) {	s2 = new filestream(fullfilepath("showparam.xsl"), filemode.open, fileaccess.read);	s2.dispose();	s2 = new filestream(fullfilepath("fruits.xml"), filemode.open, fileaccess.read);	s2.dispose();	return;	}	
encountered errors performing transform and could not verify if files were closed 

public void transformgeneric7(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	try {	loadxsl("forwardcomp2.xsl", inputtype, readertype);	transform("data.xml", true, transformtype, doctype);	}	catch (xsltexception) {	return;	}	
xsltexception xslt invalidxpath was expected 

public void xmlresolver2(inputtype inputtype, readertype readertype, transformtype transformtype, doctype doctype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result></result>";	if (loadxsl("xmlresolver_document_function.xsl", inputtype, readertype) == 1) {	if (transformresolver("fruits.xml", transformtype, doctype, null) == 1) {	verifyresult(expected);	return;	}	}	else {	
problem loading stylesheet 

public void transformstrstr2(inputtype inputtype, readertype readertype) {	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	try {	calltransform(xslt, null, _stroutfile);	}	catch (system.argumentexception) { return; }	}	
exception not generated for null input filename 

public void transformstrstr3(inputtype inputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	try {	xslt.transform(szfullfilename, null);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for null output filename 

public void transformstrstr4(inputtype inputtype, readertype readertype) {	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	try {	calltransform(xslt, "idontexist.xsl", _stroutfile);	}	catch (system.io.filenotfoundexception) {	return;	}	}	
exception not generated for invalid input file 

public void transformstrstr5(inputtype inputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	try {	xslt.transform(szfullfilename, szinvalid);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for invalid output destination 

public void transformstrstr6(inputtype inputtype, readertype readertype) {	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	try {	calltransform(xslt, szempty, _stroutfile);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for empty string input file 

public void transformstrstr7(inputtype inputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	try {	xslt.transform(szfullfilename, szempty);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for empty output file name 

public void transformstrstr8(inputtype inputtype, readertype readertype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result> 1.no value specified 2.no value specified 3.no value specified 4.no value specified 5.no value specified 6.no value specified</result>";	string szfullfilename = fullfilepath("fruits.xml");	for (int i = 0; i < 50; i++) {	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	calltransform(xslt, szfullfilename, _stroutfile);	try {	verifyresult(expected);	}	catch(exception) {	
failed to process load after calling times 

public void transformstrstr9() {	#pragma warning disable 0618 xslt = new xsltransform();	#pragma warning restore 0618 try {	calltransform(xslt, fullfilepath("fruits.xml"), _stroutfile);	}	catch (system.invalidoperationexception e) {	checkexpectederror(e, "system.xml", "xslt_nostylesheetloaded", new string[] { "" });	return;	}	
exception attempting a transform without loading an xsl file 

public void transformstrstr10(inputtype inputtype, readertype readertype) {	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	try {	xslt.transform(fullfilepath("fruits.xml"), "http: }	catch (system.exception e) {	_output.writeline(e.tostring());	return;	}	}	
exception not generated for invalid output destination 

icount++;	}	try {	calltransform(xslt, "\\\\", _stroutfile);	}	catch (system.exception) {	icount++;	}	}	if (icount.equals(3)) return;	
exception not generated for invalid input sources 

icount++;	}	try {	xslt.transform(szfullfilename, ".");	}	catch (system.exception) {	icount++;	}	}	if (icount.equals(2)) return;	
exception not generated for invalid ouput destinations 

public void transformstrstr12_win(inputtype inputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", inputtype, readertype) == 1) {	assert.throws<system.argumentexception>(() => xslt.transform(szfullfilename, "    "));	return;	}	
exception not generated for invalid ouput destination 

public void transformstrstrresolver2(inputtype inputtype, readertype readertype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result></result>";	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("xmlresolver_document_function.xsl", inputtype, readertype) == 1) {	calltransform(xslt, szfullfilename, _stroutfile, null);	verifyresult(expected);	return;	}	else {	
problem loading stylesheet 

========================= corefx sample_12626 =========================

}	wsettings.closeoutput = false;	xmlwriter w = writerhelper.create(writerstream, wsettings, overrideasync: true, async: utils.async);	try {	var beginning = writerstream.length;	w.writestartelement("root");	w.writestartelement("onechar");	w.writeattributestring("a", "myattribute");	w.writestring("a");	w.writeendelement();	
file size before flush 

xmlwriter w = writerhelper.create(writerstream, wsettings, overrideasync: true, async: utils.async);	try {	var beginning = writerstream.length;	w.writestartelement("root");	w.writestartelement("onechar");	w.writeattributestring("a", "myattribute");	w.writestring("a");	w.writeendelement();	cerror.compare(writerstream.length, beginning, "before flush");	w.flush();	
file size after flush 

w.writestring("a");	w.writeendelement();	cerror.compare(writerstream.length, beginning, "before flush");	w.flush();	cerror.compare(writerstream.length, expectedlength1, "after flush");	w.writestartelement("twochars");	w.writestring("ab");	w.writeendelement();	w.writeendelement();	w.dispose();	
file size after writer close 

cerror.compare(writerstream.length, beginning, "before flush");	w.flush();	cerror.compare(writerstream.length, expectedlength1, "after flush");	w.writestartelement("twochars");	w.writestring("ab");	w.writeendelement();	w.writeendelement();	w.dispose();	cerror.compare(writerstream.length, expectedlength2, "after writer.close");	writerstream.flush();	
file size after stream close 

========================= corefx sample_12455 =========================

public int transform(object args) {	for (int i = 1; i <= 100; i++) {	stringwriter sw = new stringwriter();	xsltsameinstance.transform(_xrdata, null, sw);	
transform thread iteration done with reader transform 

========================= corefx sample_12643 =========================

public static byte[] encode(string format, params object[] value) {	if (format == null) throw new argumentnullexception("format");	utf8encoding utf8encoder = new utf8encoding();	byte[] encodingresult = null;	if (value == null) value = array.empty<object>();	
begin encoding 

char fmt = format[formatcount];	if (fmt == '{' || fmt == '}' || fmt == '[' || fmt == ']' || fmt == 'n') {	error = wldap32.ber_printf_emptyarg(berelement, new string(fmt, 1));	}	else if (fmt == 't' || fmt == 'i' || fmt == 'e') {	if (valuecount >= value.length) {	debug.writeline("value argument is not valid, valuecount >= value.length\n");	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverternotmatch));	}	if (!(value[valuecount] is int)) {	
type should be int 

}	error = wldap32.ber_printf_int(berelement, new string(fmt, 1), (int)value[valuecount]);	valuecount++;	}	else if (fmt == 'b') {	if (valuecount >= value.length) {	debug.writeline("value argument is not valid, valuecount >= value.length\n");	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverternotmatch));	}	if (!(value[valuecount] is bool)) {	
type should be boolean 

}	error = wldap32.ber_printf_int(berelement, new string(fmt, 1), (bool)value[valuecount] ? 1 : 0);	valuecount++;	}	else if (fmt == 's') {	if (valuecount >= value.length) {	debug.writeline("value argument is not valid, valuecount >= value.length\n");	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverternotmatch));	}	if (value[valuecount] != null && !(value[valuecount] is string)) {	
type should be string but receiving value has type of 

}	error = encodingbytearrayhelper(berelement, tempvalue, 'o');	valuecount++;	}	else if (fmt == 'o' || fmt == 'x') {	if (valuecount >= value.length) {	debug.writeline("value argument is not valid, valuecount >= value.length\n");	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverternotmatch));	}	if (value[valuecount] != null && !(value[valuecount] is byte[])) {	
type should be byte but receiving value has type of 

byte[] tempvalue = (byte[])value[valuecount];	error = encodingbytearrayhelper(berelement, tempvalue, fmt);	valuecount++;	}	else if (fmt == 'v') {	if (valuecount >= value.length) {	debug.writeline("value argument is not valid, valuecount >= value.length\n");	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverternotmatch));	}	if (value[valuecount] != null && !(value[valuecount] is string[])) {	
type should be string but receiving value has type of 

}	error = encodingmultibytearrayhelper(berelement, tempvalues, 'v');	valuecount++;	}	else if (fmt == 'v') {	if (valuecount >= value.length) {	debug.writeline("value argument is not valid, valuecount >= value.length\n");	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverternotmatch));	}	if (value[valuecount] != null && !(value[valuecount] is byte[][])) {	
type should be byte but receiving value has type of 

}	if (value[valuecount] != null && !(value[valuecount] is byte[][])) {	debug.writeline(value[valuecount].gettype());	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverternotmatch));	}	byte[][] tempvalue = (byte[][])value[valuecount];	error = encodingmultibytearrayhelper(berelement, tempvalue, fmt);	valuecount++;	}	else {	
format string contains undefined character 

}	byte[][] tempvalue = (byte[][])value[valuecount];	error = encodingmultibytearrayhelper(berelement, tempvalue, fmt);	valuecount++;	}	else {	debug.writeline(new string(fmt, 1));	throw new argumentexception(string.format(cultureinfo.currentculture, sr.berconverterundefinechar));	}	if (error == -1) {	
ber printf failed 

}	if (error == -1) {	throw new berconversionexception();	}	}	berval binaryvalue = new berval();	intptr flattenptr = intptr.zero;	try {	error = wldap32.ber_flatten(berelement, ref flattenptr);	if (error == -1) {	
ber flatten failed 

byte[] bytearray = null;	error = wldap32.ber_scanf_ptr(berelement, new string(fmt, 1), ref result);	try {	if (error == 0) {	if (result != intptr.zero) {	marshal.ptrtostructure(result, binaryvalue);	bytearray = new byte[binaryvalue.bv_len];	marshal.copy(binaryvalue.bv_val, bytearray, 0, binaryvalue.bv_len);	}	}	
ber scanf for format character o failed 

binarylist.add(berarray);	i++;	tempptr = marshal.readintptr(ptrresult, i * intptr.size);	}	result = new byte[binarylist.count][];	for (int j = 0; j < binarylist.count; j++) {	result[j] = (byte[])binarylist[j];	}	}	}	
ber scanf for format character v failed 

========================= corefx sample_10717 =========================

xmlreadersettings rs = (xmlreadersettings)options[readerfactory.ht_readersettings];	stream stream = (stream)options[readerfactory.ht_stream];	string filename = (string)options[readerfactory.ht_filename];	object readertype = options[readerfactory.ht_readertype];	object vt = options[readerfactory.ht_validationtype];	string fragment = (string)options[readerfactory.ht_fragment];	stringreader sr = (stringreader)options[readerfactory.ht_stringreader];	if (rs == null) rs = new xmlreadersettings();	rs.dtdprocessing = dtdprocessing.ignore;	if (sr != null) {	
wrappedreader string 

string fragment = (string)options[readerfactory.ht_fragment];	stringreader sr = (stringreader)options[readerfactory.ht_stringreader];	if (rs == null) rs = new xmlreadersettings();	rs.dtdprocessing = dtdprocessing.ignore;	if (sr != null) {	xmlreader r = readerhelper.create(sr, rs, string.empty);	xmlreader wr = readerhelper.create(r, rs);	return wr;	}	if (stream != null) {	
wrappedreader stream 

xmlreader r = readerhelper.create(sr, rs, string.empty);	xmlreader wr = readerhelper.create(r, rs);	return wr;	}	if (stream != null) {	xmlreader r = readerhelper.create(stream, rs, filename);	xmlreader wr = readerhelper.create(r, rs);	return wr;	}	if (fragment != null) {	
wrappedreader fragment 

return wr;	}	if (fragment != null) {	rs.conformancelevel = conformancelevel.fragment;	stringreader tr = new stringreader(fragment);	xmlreader r = readerhelper.create(tr, rs, (string)null);	xmlreader wr = readerhelper.create(r, rs);	return wr;	}	if (filename != null) {	
wrappedreader filename 

========================= corefx sample_12612 =========================

public void dowork() {	
helloworld 

========================= corefx sample_9996 =========================

private void dispose(bool disposing) {	#if finalization_watch if (!disposing && nativepen != intptr.zero) {	
disposed through finalization 

========================= corefx sample_10424 =========================

public void var_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeenddocument();	}	catch (argumentexception e) {	
exception 

public void var_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeenddocument();	}	catch (argumentexception e) {	assert.true(false);	}	catch (invalidoperationexception e) {	
exception 

w.writeenddocument();	}	catch (argumentexception e) {	assert.true(false);	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void var_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeendelement();	w.writeendelement();	}	catch (invalidoperationexception e) {	
exception 

try {	w.writestartelement("root");	w.writeendelement();	w.writeendelement();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void var_6(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writefullendelement();	w.writefullendelement();	}	catch (invalidoperationexception e) {	
exception 

try {	w.writestartelement("root");	w.writefullendelement();	w.writefullendelement();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

========================= corefx sample_12461 =========================

assert.equal(s.contains(aschema), true);	assert.equal(s.contains(bschema), false);	assert.equal(s.iscompiled, false);	s.add(bschema);	assert.equal(s.count, expcount + 1);	assert.equal(s.contains(aschema), true);	assert.equal(s.contains(bschema), true);	assert.equal(s.iscompiled, false);	try {	s.compile();	
no exception thrown 

========================= corefx sample_12501 =========================

case "-duration": testmetrics.stressduration = int32.parse(args[++i]);	break;	case "-threads": testmetrics.stressthreads = int32.parse(args[++i]);	break;	case "-verify": s_mode = runmode.runverify;	break;	case "-debug": if (system.diagnostics.debugger.isattached) {	system.diagnostics.debugger.break();	}	else {	
current pid attach the debugger and press enter to continue the execution 

break;	case "-deadlockdetection": if (bool.parse(args[++i])) {	deadlockdetection.enable();	}	break;	default: s_mode = runmode.help;	break;	}	}	if (testfinder.assemblyname != null) {	
assembly found for the assembly name 

private static void printhelp() {	
stresstest exe a module name arguments 

private static void printhelp() {	console.writeline();	
a module name should specify path to the assembly containing the tests 

private static void printhelp() {	console.writeline();	console.writeline();	
supported options are 

private static void printhelp() {	console.writeline();	console.writeline();	console.writeline();	
all run all tests best for debugging not perf measurements 

private static void printhelp() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
verify run in functional verification mode 

private static void printhelp() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
duration n duration of the test in seconds 

private static void printhelp() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
threads n number of threads to use 

private static void printhelp() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
override name value override the value of a test property 

private static void printhelp() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
test name run specific test s using their name 

private static void printhelp() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
debug print process id in the beginning and wait for enter to give your time to attach the debugger 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
exceptionthreshold n an optional limit on exceptions which will be caught when reached test will halt 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
monitorenabled true or false to enable monitoring default is false 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
randomseed enables setting of the random number generator used internally this serves both the purpose 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
of helping to improve reproducibility and making it deterministic from chess s perspective 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
for a given schedule default is 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
filter run tests whose stress test attributes match the given filter filter is not applied if attribute 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline("                               does not implement itestattributefilter. example: -filter testtype=query,update;isservertest=true ");	console.writeline();	
printmethodname print tests title in console window 

console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline();	console.writeline("                               does not implement itestattributefilter. example: -filter testtype=query,update;isservertest=true ");	console.writeline();	console.writeline();	
deadlockdetection true or false to enable deadlock detection default is false 

========================= corefx sample_10987 =========================

public int read3() {	string strxml = "<root:  />";	try {	reloadsourcestr(strxml);	while (datareader.read()) ;	}	catch (xmlexception e) {	
line number 

public int read3() {	string strxml = "<root:  />";	try {	reloadsourcestr(strxml);	while (datareader.read()) ;	}	catch (xmlexception e) {	
line position 

public int read3() {	string strxml = "<root:  />";	try {	reloadsourcestr(strxml);	while (datareader.read()) ;	}	catch (xmlexception e) {	
message 

public int read3() {	string strxml = "<root:  />";	try {	reloadsourcestr(strxml);	while (datareader.read()) ;	}	catch (xmlexception e) {	
source 

public int read4() {	string filename = path.combine(testdata, "common", "bad.xml");	try {	reloadsource(filename);	while (datareader.read()) ;	
accepted invalid character 

public int read5() {	string strxml = "<!doctype root [<!element root any >]><!doctype root [	<!element root any >]><root/>";	try {	reloadsource(new stringreader(strxml));	datareader.read();	while (datareader.read()) ;	
accepted two doctype nodes 

public int read6() {	string strxml = "<!doctype root [<!element root any >]>\n<root>abcd<root/>";	try {	reloadsource(new stringreader(strxml));	while (datareader.read()) ;	
accepted xml without root end element 

public int read8() {	string filename = path.combine(testdata, "common", "bug_65660a.xml");	try {	reloadsource(filename);	while (datareader.read()) ;	
accepted invalid text declaration 

public int read8() {	string filename = path.combine(testdata, "common", "bug_65660a.xml");	try {	reloadsource(filename);	while (datareader.read()) ;	return test_fail;	}	catch (xmlexception e) {	
line number 

public int read8() {	string filename = path.combine(testdata, "common", "bug_65660a.xml");	try {	reloadsource(filename);	while (datareader.read()) ;	return test_fail;	}	catch (xmlexception e) {	
line position 

public int read8() {	string filename = path.combine(testdata, "common", "bug_65660a.xml");	try {	reloadsource(filename);	while (datareader.read()) ;	return test_fail;	}	catch (xmlexception e) {	
message 

public int read8() {	string filename = path.combine(testdata, "common", "bug_65660a.xml");	try {	reloadsource(filename);	while (datareader.read()) ;	return test_fail;	}	catch (xmlexception e) {	
source 

public int read11() {	string strxml = "<root xmlns:p=''/>";	try {	reloadsourcestr(strxml);	while (datareader.read()) ;	
accepted non wf document 

public int read16() {	string filename = path.combine(testdata, "common", "bug_62766.xml");	try {	reloadsource(filename);	while (datareader.read()) ;	if (isxmltextreader()) return test_pass;	else {	
accepted invalid entity 

private void testucs4encoding(string filename, string expencoding) {	
reading 

public int readempty() {	string xml = "<root/>";	reloadsourcestr(xml);	while (datareader.read()) {	if (datareader.nodetype == xmlnodetype.endelement) {	
endelement nodetype for empty element 

========================= corefx sample_12410 =========================

public void opentwice() {	using (serialport com = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	serportprop.setallpropertiestoopendefaults();	serportprop.setproperty("portname", tcsupport.localmachineserialinfo.firstavailableportname);	
verifying after calling open twice 

public void opentwoinstances() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) using (serialport com2 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop1 = new serialportproperties();	serialportproperties serportprop2 = new serialportproperties();	
verifying calling open on two instances of serialport 

========================= corefx sample_689 =========================

public int xmlexceptionandxmltextreaderlinenumbershouldbesameafterexceptionisthrown() {	string filename = path.combine(testdata, "common", "invalid-ucs4.xml");	if (!iscustomreader()) {	try {	reloadsource(filename);	while (datareader.read()) ;	return test_fail;	}	catch (xmlexception e) {	cerror.writeline(e.message);	
reader line exception line 

string filename = path.combine(testdata, "common", "invalid-ucs4.xml");	if (!iscustomreader()) {	try {	reloadsource(filename);	while (datareader.read()) ;	return test_fail;	}	catch (xmlexception e) {	cerror.writeline(e.message);	cerror.equals(datareader.linenumber, issubtreereader() ? 0 : e.linenumber, "reader line number and exception line number must be same");	
reader position exception position 

========================= corefx sample_12424 =========================

xmlreadersettings rs = (xmlreadersettings)options[readerfactory.ht_readersettings];	stream stream = (stream)options[readerfactory.ht_stream];	string filename = (string)options[readerfactory.ht_filename];	object readertype = options[readerfactory.ht_readertype];	object vt = options[readerfactory.ht_validationtype];	string fragment = (string)options[readerfactory.ht_fragment];	stringreader sr = (stringreader)options[readerfactory.ht_stringreader];	if (rs == null) rs = new xmlreadersettings();	rs.dtdprocessing = dtdprocessing.ignore;	if (sr != null) {	
subtreereader string 

rs.dtdprocessing = dtdprocessing.ignore;	if (sr != null) {	xmlreader r = readerhelper.create(sr, rs, string.empty);	while (r.read()) {	if (r.nodetype == xmlnodetype.element) break;	}	xmlreader wr = r.readsubtree();	return wr;	}	if (stream != null) {	
subtreereader stream 

}	if (stream != null) {	xmlreader r = readerhelper.create(stream, rs, filename);	while (r.read()) {	if (r.nodetype == xmlnodetype.element) break;	}	xmlreader wr = r.readsubtree();	return wr;	}	if (fragment != null) {	
subtreereader fragment 

rs.conformancelevel = conformancelevel.fragment;	stringreader tr = new stringreader(fragment);	xmlreader r = readerhelper.create(tr, rs, (string)null);	while (r.read()) {	if (r.nodetype == xmlnodetype.element) break;	}	xmlreader wr = r.readsubtree();	return wr;	}	if (filename != null) {	
subtreereader filename 

========================= corefx sample_12597 =========================

public static async task testecho( uri server, websocketmessagetype type, int timeoutmilliseconds, itestoutputhelper output) {	var cts = new cancellationtokensource(timeoutmilliseconds);	string message = "hello websockets!";	string closemessage = "good bye!";	var receivebuffer = new byte[100];	var receivesegment = new arraysegment<byte>(receivebuffer);	using (clientwebsocket cws = await getconnectedwebsocket(server, timeoutmilliseconds, output)) {	
testecho sendasync starting 

public static async task testecho( uri server, websocketmessagetype type, int timeoutmilliseconds, itestoutputhelper output) {	var cts = new cancellationtokensource(timeoutmilliseconds);	string message = "hello websockets!";	string closemessage = "good bye!";	var receivebuffer = new byte[100];	var receivesegment = new arraysegment<byte>(receivebuffer);	using (clientwebsocket cws = await getconnectedwebsocket(server, timeoutmilliseconds, output)) {	await cws.sendasync(websocketdata.getbufferfromtext(message), type, true, cts.token);	
testecho sendasync done 

public static async task testecho( uri server, websocketmessagetype type, int timeoutmilliseconds, itestoutputhelper output) {	var cts = new cancellationtokensource(timeoutmilliseconds);	string message = "hello websockets!";	string closemessage = "good bye!";	var receivebuffer = new byte[100];	var receivesegment = new arraysegment<byte>(receivebuffer);	using (clientwebsocket cws = await getconnectedwebsocket(server, timeoutmilliseconds, output)) {	await cws.sendasync(websocketdata.getbufferfromtext(message), type, true, cts.token);	assert.equal(websocketstate.open, cws.state);	
testecho receiveasync starting 

public static async task testecho( uri server, websocketmessagetype type, int timeoutmilliseconds, itestoutputhelper output) {	var cts = new cancellationtokensource(timeoutmilliseconds);	string message = "hello websockets!";	string closemessage = "good bye!";	var receivebuffer = new byte[100];	var receivesegment = new arraysegment<byte>(receivebuffer);	using (clientwebsocket cws = await getconnectedwebsocket(server, timeoutmilliseconds, output)) {	await cws.sendasync(websocketdata.getbufferfromtext(message), type, true, cts.token);	assert.equal(websocketstate.open, cws.state);	websocketreceiveresult recvret = await cws.receiveasync(receivesegment, cts.token);	
testecho receiveasync done 

assert.equal(websocketstate.open, cws.state);	websocketreceiveresult recvret = await cws.receiveasync(receivesegment, cts.token);	assert.equal(websocketstate.open, cws.state);	assert.equal(message.length, recvret.count);	assert.equal(type, recvret.messagetype);	assert.equal(true, recvret.endofmessage);	assert.equal(null, recvret.closestatus);	assert.equal(null, recvret.closestatusdescription);	var recvsegment = new arraysegment<byte>(receivesegment.array, receivesegment.offset, recvret.count);	assert.equal(message, websocketdata.gettextfrombuffer(recvsegment));	
testecho closeasync starting 

assert.equal(message.length, recvret.count);	assert.equal(type, recvret.messagetype);	assert.equal(true, recvret.endofmessage);	assert.equal(null, recvret.closestatus);	assert.equal(null, recvret.closestatusdescription);	var recvsegment = new arraysegment<byte>(receivesegment.array, receivesegment.offset, recvret.count);	assert.equal(message, websocketdata.gettextfrombuffer(recvsegment));	task taskclose = cws.closeasync(websocketclosestatus.normalclosure, closemessage, cts.token);	assert.true( (cws.state == websocketstate.open) || (cws.state == websocketstate.closesent) || (cws.state == websocketstate.closereceived) || (cws.state == websocketstate.closed), "state immediately after closeasync : " + cws.state);	await taskclose;	
testecho closeasync done 

public static task<clientwebsocket> getconnectedwebsocket( uri server, int timeoutmilliseconds, itestoutputhelper output, timespan keepaliveinterval = default, iwebproxy proxy = null) => retry(output, async () => {	var cws = new clientwebsocket();	if (proxy != null) {	cws.options.proxy = proxy;	}	if (keepaliveinterval.totalseconds > 0) {	cws.options.keepaliveinterval = keepaliveinterval;	}	using (var cts = new cancellationtokensource(timeoutmilliseconds)) {	
getconnectedwebsocket connectasync starting 

if (proxy != null) {	cws.options.proxy = proxy;	}	if (keepaliveinterval.totalseconds > 0) {	cws.options.keepaliveinterval = keepaliveinterval;	}	using (var cts = new cancellationtokensource(timeoutmilliseconds)) {	task taskconnect = cws.connectasync(server, cts.token);	assert.true( (cws.state == websocketstate.none) || (cws.state == websocketstate.connecting) || (cws.state == websocketstate.open) || (cws.state == websocketstate.aborted), "state immediately after connectasync incorrect: " + cws.state);	await taskconnect;	
getconnectedwebsocket connectasync done 

public static async task<t> retry<t>(itestoutputhelper output, func<task<t>> func) {	const int maxtries = 5;	int betweentrydelaymilliseconds = 1000;	for (int i = 1; ; i++) {	try {	return await func();	}	catch (websocketexception exc) {	
retry after attempt i failed with exc 

========================= corefx sample_3714 =========================

public void randomoperationstest() {	int operationcount = this.randomoperationscount;	var expected = new sortedset<int>();	var actual = immutablesortedset<int>.empty;	int seed = unchecked((int)datetime.now.ticks);	
using random seed 

public void randomoperationstest() {	int operationcount = this.randomoperationscount;	var expected = new sortedset<int>();	var actual = immutablesortedset<int>.empty;	int seed = unchecked((int)datetime.now.ticks);	var random = new random(seed);	for (int iop = 0; iop < operationcount; iop++) {	switch ((operation)random.next((int)operation.last)) {	case operation.add: int value = random.next();	
adding to the set 

int seed = unchecked((int)datetime.now.ticks);	var random = new random(seed);	for (int iop = 0; iop < operationcount; iop++) {	switch ((operation)random.next((int)operation.last)) {	case operation.add: int value = random.next();	expected.add(value);	actual = actual.add(value);	break;	case operation.union: int inputlength = random.next(100);	int[] values = enumerable.range(0, inputlength).select(i => random.next()).toarray();	
adding elements to the set 

actual = actual.add(value);	break;	case operation.union: int inputlength = random.next(100);	int[] values = enumerable.range(0, inputlength).select(i => random.next()).toarray();	expected.unionwith(values);	actual = actual.union(values);	break;	case operation.remove: if (expected.count > 0) {	int position = random.next(expected.count);	int element = expected.skip(position).first();	
removing element from the set 

actual = actual.union(values);	break;	case operation.remove: if (expected.count > 0) {	int position = random.next(expected.count);	int element = expected.skip(position).first();	assert.true(expected.remove(element));	actual = actual.remove(element);	}	break;	case operation.except: var elements = expected.where(el => random.next(2) == 0).toarray();	
removing elements from the set 

========================= corefx sample_7329 =========================

private static void verifycallstack( (string callermembername, string sourcefilepath, int sourcelinenumber) expectedstackframe, string reportedcallstack, int skipframes) {	
exceptiontests reported call stack 

========================= corefx sample_1734 =========================

private bool movenextlocal() {	bool needtoretry;	do {	needtoretry = false;	object[] nativemembers = new object[1];	bool f = _membersenumerator.movenext();	if (f) {	
sammembersset movenextlocal got a value from the enumerator 

adspath.append("winnt: adspath.append(_storectx.machineusersuppliedname);	adspath.append("/");	int celements = pathname.getnumelements();	debug.assert(celements >= 2);	for (int i = celements - 2; i >= 0; i--) {	adspath.append(pathname.getelement(i));	adspath.append("/");	}	adspath.remove(adspath.length - 1, 1);	de.path = adspath.tostring();	
sammembersset movenextlocal fake domain 

for (int i = celements - 2; i >= 0; i--) {	adspath.append(pathname.getelement(i));	adspath.append("/");	}	adspath.remove(adspath.length - 1, 1);	de.path = adspath.tostring();	}	else {	debug.assert(sidtype == sidtype.realobject);	de.path = nativemember.adspath;	
sammembersset movenextlocal real domain 

}	adspath.remove(adspath.length - 1, 1);	de.path = adspath.tostring();	}	else {	debug.assert(sidtype == sidtype.realobject);	de.path = nativemember.adspath;	}	if (islocalmember(sid)) {	if (!_recursive || !samutils.isofobjectclass(de, "group")) {	
sammembersset movenextlocal setting current to 

if (islocalmember(sid)) {	if (!_recursive || !samutils.isofobjectclass(de, "group")) {	_current = de;	_currentfakeprincipal = null;	_currentforeign = null;	if (_foreignresultset != null) _foreignresultset.dispose();	_foreignresultset = null;	return true;	}	else {	
sammembersset movenextlocal adding to groupstovisit 

_foreignresultset = null;	return true;	}	else {	if (!_groupsvisited.contains(de.path) && !_groupstovisit.contains(de.path)) _groupstovisit.add(de.path);	needtoretry = true;	continue;	}	}	else {	
sammembersset movenextlocal adding to foreignmembers 

_foreignmembers.add(de);	needtoretry = true;	continue;	}	}	else {	if (_recursive) {	globaldebug.writelineif(globaldebug.info, "sammembersset", "movenextlocal: recursive processing, groupstovisit={0}", _groupstovisit.count);	if (_groupstovisit.count > 0) {	string grouppath = _groupstovisit[0];	
sammembersset movenextlocal recursively processing 

bool needtoretry;	do {	needtoretry = false;	globaldebug.writelineif(globaldebug.info, "sammembersset", "movenextforeign: foreignmembers count={0}", _foreignmembers.count);	if (_foreignmembers.count > 0) {	directoryentry foreignde = _foreignmembers[0];	_foreignmembers.removeat(0);	globaldebug.writelineif(globaldebug.info, "sammembersset", "movenextforeign: foreignde={0}", foreignde.path);	principal foreignprincipal = _storectx.resolvecrossstorereftoprincipal(foreignde);	if (!_recursive || !(foreignprincipal is groupprincipal)) {	
sammembersset movenextforeign setting currentforeign to 

principal foreignprincipal = _storectx.resolvecrossstorereftoprincipal(foreignde);	if (!_recursive || !(foreignprincipal is groupprincipal)) {	_current = null;	_currentfakeprincipal = null;	_currentforeign = foreignprincipal;	if (_foreignresultset != null) _foreignresultset.dispose();	_foreignresultset = null;	return true;	}	else {	
sammembersset movenextforeign adding to foreigngroups 

globaldebug.writelineif(globaldebug.info, "sammembersset", "movenextforeign: getting foreignresultset (foreigngroups count={0})", _foreigngroups.count);	debug.assert(_recursive == true);	groupprincipal foreigngroup = _foreigngroups[0];	_foreigngroups.removeat(0);	_foreignresultset = foreigngroup.getstorectxtouse().getgroupmembership(foreigngroup, true);	}	if (_foreignresultset != null) {	debug.assert(_recursive == true);	bool f = _foreignresultset.movenext();	if (f) {	
sammembersset movenextforeign using foreignresultset 

if (_foreignresultset != null) {	debug.assert(_recursive == true);	bool f = _foreignresultset.movenext();	if (f) {	_current = null;	_currentfakeprincipal = null;	_currentforeign = null;	return true;	}	if (_foreigngroups.count > 0) {	
sammembersset movenextforeign ran out of members using next foreignresultset 

_currentforeign = null;	return true;	}	if (_foreigngroups.count > 0) {	_foreignresultset.dispose();	_foreignresultset = null;	debug.assert(_foreignmembers.count == 0);	needtoretry = true;	}	else {	
sammembersset movenextforeign ran out of members nothing more to do 

========================= corefx sample_9048 =========================

public void baz() {	
e baz 

========================= corefx sample_124 =========================

case 1: rdr.getdatetime(i);	break;	case 2: rdr.getdatetime(i);	break;	case 3: rdr.gettimespan(i);	break;	case 4: rdr.getdatetime(i);	break;	case 5: rdr.getdatetimeoffset(i);	break;	
received unknown column number during readerparametertest 

========================= corefx sample_11067 =========================

public override string getsavedlicensekey(type type, assembly resourceassembly) {	if (savedlicensekeys == null || savedlicensekeys[type.assemblyqualifiedname] == null) {	
savedlicensekey is null or doesn t contain our type 

public override string getsavedlicensekey(type type, assembly resourceassembly) {	if (savedlicensekeys == null || savedlicensekeys[type.assemblyqualifiedname] == null) {	if (savedlicensekeys == null) {	savedlicensekeys = new hashtable();	}	if (resourceassembly == null) {	resourceassembly = assembly.getentryassembly();	}	if (resourceassembly == null) {	
resourceassembly is null 

if (s == null) {	s = caseinsensitivemanifestresourcestreamlookup(asm, filename + ".licenses");	}	if (s != null) {	designtimelicensecontextserializer.deserialize(s, filename.toupper(cultureinfo.invariantculture), this);	break;	}	}	}	else if (!resourceassembly.isdynamic) {	
resourceassembly is not null 

}	if (resolvedname != null) {	s = resourceassembly.getmanifestresourcestream(resolvedname);	}	}	if (s != null) {	designtimelicensecontextserializer.deserialize(s, filename.toupper(cultureinfo.invariantculture), this);	}	}	}	
returning string savedlicensekeys type assemblyqualifiedname 

========================= corefx sample_7228 =========================

public async task clientdefaultencryption_serverrequireencryption_connectwithencryption() {	using (var serverrequireencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.requireencryption)) using (var client = new tcpclient()) {	await client.connectasync(serverrequireencryption.remoteendpoint.address, serverrequireencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

public async task clientdefaultencryption_serverallownoencryption_connectwithencryption() {	using (var serverallownoencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.allownoencryption)) using (var client = new tcpclient()) {	await client.connectasync(serverallownoencryption.remoteendpoint.address, serverallownoencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

========================= corefx sample_8116 =========================

public void notreadydriveaspath_returnsfalse() {	var drive = ioservices.getnotreadydrive();	if (drive == null) {	
skipping test unable to find a not ready drive such as cd rom with no disc inserted 

public void subdirectoryonnotreadydriveaspath_returnsfalse() {	var drive = ioservices.getnotreadydrive();	if (drive == null) {	
skipping test unable to find a not ready drive such as cd rom with no disc inserted 

========================= corefx sample_217 =========================

public static void runruntests() {	{	task tinner = null;	task t1 = task.run(() => {	tinner = new task(() => { }, taskcreationoptions.attachedtoparent);	});	
runruntests attachtoparentignored waiting on outer task if we hang that s a failure 

task t1 = task.run(() => {	tinner = new task(() => { }, taskcreationoptions.attachedtoparent);	});	t1.wait();	tinner.start();	tinner.wait();	task<int> f1 = task.run(() => {	tinner = new task(() => { }, taskcreationoptions.attachedtoparent);	return 42;	});	
runruntests attachtoparentignored waiting on outer task int if we hang that s a failure 

return 42;	});	f1.wait();	tinner.start();	tinner.wait();	task t2 = task.run(() => {	tinner = new task(() => { }, taskcreationoptions.attachedtoparent);	task returntask = task.factory.startnew(() => { });	return returntask;	});	
runruntests attachtoparentignored waiting on outer task unwrap style if we hang that s a failure 

});	t2.wait();	tinner.start();	tinner.wait();	task<int> finner = null;	task<int> f2 = task.run(() => {	finner = new task<int>(() => { return 42; }, taskcreationoptions.attachedtoparent);	task<int> returntask = task<int>.factory.startnew(() => 11);	return returntask;	});	
runruntests attachtoparentignored waiting on outer task int unwrap style if we hang that s a failure 

finner = new task<int>(() => { return 42; }, taskcreationoptions.attachedtoparent);	task<int> returntask = task<int>.factory.startnew(() => 11);	return returntask;	});	f2.wait();	finner.start();	finner.wait();	}	int count = 0;	task task1 = task.run(() => { count = 1; });	
runruntests waiting for a task if we hang something went wrong 

f2.wait();	finner.start();	finner.wait();	}	int count = 0;	task task1 = task.run(() => { count = 1; });	task1.wait();	assert.true(count == 1, "    > failed.  task completed but did not run.");	assert.true(task1.status == taskstatus.rantocompletion, "    > failed.  task did not end in rantocompletion state.");	task<int> future1 = task.run(() => { return 7; });	
runruntests basic w o ct waiting for a future if we hang something went wrong 

int count = 0;	task task1 = task.run(() => { count = 1; });	task1.wait();	assert.true(count == 1, "    > failed.  task completed but did not run.");	assert.true(task1.status == taskstatus.rantocompletion, "    > failed.  task did not end in rantocompletion state.");	task<int> future1 = task.run(() => { return 7; });	future1.wait();	assert.true(future1.result == 7, "    > failed.  future completed but did not run.");	assert.true(future1.status == taskstatus.rantocompletion, "    > failed.  future did not end in rantocompletion state.");	task1 = task.run(() => { return task.run(() => { count = 11; }); });	
runruntests basic w o ct waiting for a task unwrapped if we hang something went wrong 

assert.true(task1.status == taskstatus.rantocompletion, "    > failed.  task did not end in rantocompletion state.");	task<int> future1 = task.run(() => { return 7; });	future1.wait();	assert.true(future1.result == 7, "    > failed.  future completed but did not run.");	assert.true(future1.status == taskstatus.rantocompletion, "    > failed.  future did not end in rantocompletion state.");	task1 = task.run(() => { return task.run(() => { count = 11; }); });	task1.wait();	assert.true(count == 11, "    > failed.  task(unwrapped) completed but did not run.");	assert.true(task1.status == taskstatus.rantocompletion, "    > failed.  task(unwrapped) did not end in rantocompletion state.");	future1 = task.run(() => { return task.run(() => 17); });	
runruntests basic w o ct waiting for a future unwrapped if we hang something went wrong 

task1.wait();	assert.true(count == 11, "    > failed.  task(unwrapped) completed but did not run.");	assert.true(task1.status == taskstatus.rantocompletion, "    > failed.  task(unwrapped) did not end in rantocompletion state.");	future1 = task.run(() => { return task.run(() => 17); });	future1.wait();	assert.true(future1.result == 17, "    > failed.  future(unwrapped) completed but did not run.");	assert.true(future1.status == taskstatus.rantocompletion, "    > failed.  future(unwrapped) did not end in rantocompletion state.");	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken token = cts.token;	task task2 = task.run(() => { count = 21; }, token);	
runruntests waiting for a task w uncanceled token if we hang something went wrong 

future1.wait();	assert.true(future1.result == 17, "    > failed.  future(unwrapped) completed but did not run.");	assert.true(future1.status == taskstatus.rantocompletion, "    > failed.  future(unwrapped) did not end in rantocompletion state.");	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken token = cts.token;	task task2 = task.run(() => { count = 21; }, token);	task2.wait();	assert.true(count == 21, "    > failed.  task w/ uncanceled token completed but did not run.");	assert.true(task2.status == taskstatus.rantocompletion, "    > failed.  task w/ uncanceled token did not end in rantocompletion state.");	task<int> future2 = task.run(() => 27, token);	
runruntests waiting for a future w uncanceled token if we hang something went wrong 

cancellationtoken token = cts.token;	task task2 = task.run(() => { count = 21; }, token);	task2.wait();	assert.true(count == 21, "    > failed.  task w/ uncanceled token completed but did not run.");	assert.true(task2.status == taskstatus.rantocompletion, "    > failed.  task w/ uncanceled token did not end in rantocompletion state.");	task<int> future2 = task.run(() => 27, token);	future2.wait();	assert.true(future2.result == 27, "    > failed.  future w/ uncanceled token completed but did not run.");	assert.true(future2.status == taskstatus.rantocompletion, "    > failed.  future w/ uncanceled token did not end in rantocompletion state.");	task2 = task.run(() => { return task.run(() => { count = 31; }); }, token);	
runruntests waiting for a task unwrapped w uncanceled token if we hang something went wrong 

assert.true(task2.status == taskstatus.rantocompletion, "    > failed.  task w/ uncanceled token did not end in rantocompletion state.");	task<int> future2 = task.run(() => 27, token);	future2.wait();	assert.true(future2.result == 27, "    > failed.  future w/ uncanceled token completed but did not run.");	assert.true(future2.status == taskstatus.rantocompletion, "    > failed.  future w/ uncanceled token did not end in rantocompletion state.");	task2 = task.run(() => { return task.run(() => { count = 31; }); }, token);	task2.wait();	assert.true(count == 31, "    > failed.  task(unwrapped) w/ uncanceled token completed but did not run.");	assert.true(task2.status == taskstatus.rantocompletion, "    > failed.  task(unwrapped) w/ uncanceled token did not end in rantocompletion state.");	future2 = task.run(() => task.run(() => 37), token);	
runruntests waiting for a future unwrapped w uncanceled token if we hang something went wrong 

public static void runruntests_cancellation_negative() {	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken token = cts.token;	int count = 0;	cts.cancel();	task task3 = task.run(() => { count = 41; }, token);	
runruntests waiting for a task w canceled token if we hang something went wrong 

public static void runruntests_cancellation_negative() {	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken token = cts.token;	int count = 0;	cts.cancel();	task task3 = task.run(() => { count = 41; }, token);	assert.throws<aggregateexception>( () => { task3.wait(); });	assert.false(count == 41, "    > failed.  task w/ canceled token ran when it should not have.");	assert.true(task3.iscanceled, "    > failed.  task w/ canceled token should have ended in canceled state");	task future3 = task.run(() => { count = 47; return count; }, token);	
runruntests waiting for a future w canceled token if we hang something went wrong 

cts.cancel();	task task3 = task.run(() => { count = 41; }, token);	assert.throws<aggregateexception>( () => { task3.wait(); });	assert.false(count == 41, "    > failed.  task w/ canceled token ran when it should not have.");	assert.true(task3.iscanceled, "    > failed.  task w/ canceled token should have ended in canceled state");	task future3 = task.run(() => { count = 47; return count; }, token);	assert.throws<aggregateexception>( () => { future3.wait(); });	assert.false(count == 47, "    > failed.  future w/ canceled token ran when it should not have.");	assert.true(future3.iscanceled, "    > failed.  future w/ canceled token should have ended in canceled state");	task3 = task.run(() => { return task.run(() => { count = 51; }); }, token);	
runruntests waiting for a task unwrapped w canceled token if we hang something went wrong 

assert.true(task3.iscanceled, "    > failed.  task w/ canceled token should have ended in canceled state");	task future3 = task.run(() => { count = 47; return count; }, token);	assert.throws<aggregateexception>( () => { future3.wait(); });	assert.false(count == 47, "    > failed.  future w/ canceled token ran when it should not have.");	assert.true(future3.iscanceled, "    > failed.  future w/ canceled token should have ended in canceled state");	task3 = task.run(() => { return task.run(() => { count = 51; }); }, token);	assert.throws<aggregateexception>( () => { task3.wait(); });	assert.false(count == 51, "    > failed.  task(unwrapped) w/ canceled token ran when it should not have.");	assert.true(task3.iscanceled, "    > failed.  task(unwrapped) w/ canceled token should have ended in canceled state");	future3 = task.run(() => { return task.run(() => { count = 57; return count; }); }, token);	
runruntests waiting for a future unwrapped w canceled token if we hang something went wrong 

public static void rundelaytests() {	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken token = cts.token;	task task1 = task.delay(0);	task task2 = task.delay(new timespan(0));	task task3 = task.delay(0, token);	task task4 = task.delay(new timespan(0), token);	
rundelaytests waiting for delayed uncanceled tasks to complete if we hang something went wrong 

cancellationtokensource disposedcts = new cancellationtokensource();	cancellationtoken disposedtoken = disposedcts.token;	disposedcts.dispose();	assert.throws<argumentoutofrangeexception>( () => { task.delay(-2); });	assert.throws<argumentoutofrangeexception>( () => { task.delay(new timespan(1000, 0, 0, 0)); });	cancellationtokensource cts = new cancellationtokensource();	cancellationtoken token = cts.token;	cts.cancel();	task task5 = task.delay(0, token);	task task6 = task.delay(new timespan(0), token);	
rundelaytests waiting for delayed canceled tasks to complete if we hang something went wrong 

}	catch { }	assert.true(task5.status == taskstatus.canceled, "rundelaytests:    > failed.  expected delay(0,canceledtoken) to end up canceled");	assert.true(task6.status == taskstatus.canceled, "rundelaytests:    > failed.  expected delay(timespan(0),canceledtoken) to end up canceled");	cancellationtokensource cts2 = new cancellationtokensource();	task task8 = task.delay(-1, cts2.token);	task task9 = task.delay(new timespan(1, 0, 0, 0), cts2.token);	task.factory.startnew(() => {	cts2.cancel();	});	
rundelaytests waiting for infinite delayed eventually canceled tasks to complete if we hang something went wrong 

t4.start();	task i5 = null;	task t5 = t3.continuewith(_ => {	i5 = new task(() => { }, taskcreationoptions.attachedtoparent);	}, taskcontinuationoptions.denychildattach);	task i6 = null;	task t6 = t4.continuewith<int>(_ => {	i6 = new task(() => { }, taskcreationoptions.attachedtoparent);	return 42;	}, taskcontinuationoptions.denychildattach);	
rundenychildattachtests waiting on parents if we hang something went wrong 

========================= corefx sample_4010 =========================

try {	vd.m(dynpara, str);	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (errorverifier.verify(errormessageid.cantinfermethtypeargs, e.message, "s.m<t>(t, t)")) ret--;	}	dynpara = null;	int n = 0;	try {	vv.m(dynpara, n);	
no ex 

dynpara = null;	int n = 0;	try {	vv.m(dynpara, n);	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (errorverifier.verify(errormessageid.badargtypes, e.message, "s.m<int>(int, int)")) ret--;	}	try {	vd.m(n, dynpara);	
no ex 

try {	vd.m(n, dynpara);	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (errorverifier.verify(errormessageid.badargtypes, e.message, "s.m<int>(int, int)")) ret--;	}	dynpara = new test();	dynamic dynp2 = null;	try {	vv.m(dynpara, dynp2);	
no ex 

dynpara = new test();	dynamic dynp2 = null;	try {	vv.m(dynpara, dynp2);	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception e) {	if (errorverifier.verify(errormessageid.badargtypes, e.message, "s.m<test>(test, test)")) ret--;	}	try {	vd.m(dynpara, dynp2);	
no ex 

========================= corefx sample_110 =========================

if (datareader.nodetype != xmlnodetype.element) {	string nodetype = datareader.nodetype.tostring();	bool flag = true;	try {	datareader.readsubtree();	}	catch (invalidoperationexception) {	flag = false;	}	if (flag) {	
readsubtree doesn t throw invalidop exception on nodetype 

catch (invalidoperationexception) {	flag = false;	}	if (flag) {	return test_fail;	}	try {	datareader.read();	}	catch (xmlexception) {	
cannot read after an invalid operation exception 

if (datareader.hasattributes) {	bool flag = true;	datareader.movetofirstattribute();	try {	datareader.readsubtree();	}	catch (invalidoperationexception) {	flag = false;	}	if (flag) {	
readsubtree doesn t throw invalidop exception on attribute node type 

catch (invalidoperationexception) {	flag = false;	}	if (flag) {	return test_fail;	}	try {	datareader.read();	}	catch (xmlexception) {	
cannot read after an invalid operation exception 

public int xmlsubtreereaderdoesntduplicatelocalnames() {	dictionary<string, object> localnames = new dictionary<string, object>();	string xml = "<?xml version='1.0' encoding='utf-8'?>" + "<ixmlserializable z:clrtype='a' z:clrassembly='test, " + "version=0.0.0.0, culture=neutral, publickeytoken=null' " + "xmlns='http: "<writeattributestring p3:attributename3='attributevalue3' " + "abc:attributename='attributevalue' attributename2='attributevalue2' " + "xmlns:abc='mynamespace' xmlns:p3='mynamespace3' /></ixmlserializable>";	reloadsourcestr(xml);	datareader.movetocontent();	xmlreader reader = datareader.readsubtree();	reader.readtodescendant("writeattributestring");	while (reader.movetonextattribute()) {	if (localnames.containskey(reader.localname)) {	
duplicated localname 

========================= corefx sample_12389 =========================

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
supports 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
supports 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.throws<platformnotsupportedexception>(() => ipproperties.anycastaddresses);	assert.throws<platformnotsupportedexception>(() => ipproperties.dhcpserveraddresses);	try {	assert.notnull(ipproperties.dnsaddresses);	
dns addresses 

ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.throws<platformnotsupportedexception>(() => ipproperties.anycastaddresses);	assert.throws<platformnotsupportedexception>(() => ipproperties.dhcpserveraddresses);	try {	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	
dns suffix 

assert.throws<platformnotsupportedexception>(() => ipproperties.dhcpserveraddresses);	try {	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	}	catch (platformnotsupportedexception) { }	assert.notnull(ipproperties.gatewayaddresses);	
gateway addresses 

assert.notnull(ipproperties.dnssuffix);	}	catch (platformnotsupportedexception) { }	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.throws<platformnotsupportedexception>(() => ipproperties.isdnsenabled);	assert.throws<platformnotsupportedexception>(() => ipproperties.isdynamicdnsenabled);	assert.notnull(ipproperties.multicastaddresses);	
multicast addresses 

}	assert.throws<platformnotsupportedexception>(() => ipproperties.isdnsenabled);	assert.throws<platformnotsupportedexception>(() => ipproperties.isdynamicdnsenabled);	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	assert.throws<platformnotsupportedexception>(() => multi.isdnseligible);	assert.throws<platformnotsupportedexception>(() => multi.istransient);	}	assert.notnull(ipproperties.unicastaddresses);	
unicast addresses 

assert.throws<platformnotsupportedexception>(() => multi.istransient);	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.throws<platformnotsupportedexception>(() => uni.addresspreferredlifetime);	assert.throws<platformnotsupportedexception>(() => uni.addressvalidlifetime);	assert.throws<platformnotsupportedexception>(() => uni.dhcpleaselifetime);	assert.throws<platformnotsupportedexception>(() => uni.duplicateaddressdetectionstate);	assert.notnull(uni.ipv4mask);	
mask 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	
properties 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
index 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingactive);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingenabled);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isdhcpenabled);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isforwardingenabled);	
mtu 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	
properties 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	
is null 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	continue;	}	
index 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	continue;	}	
mtu 

public void ipv6scopeid_accessallvalues_success() {	assert.true(capability.ipv6support());	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

========================= corefx sample_13374 =========================

public void fullendelement_2(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writefullendelement();	}	catch (invalidoperationexception e) {	
exception 

public void fullendelement_2(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writefullendelement();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void fullendelement_3(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeendelement();	w.writefullendelement();	}	catch (invalidoperationexception e) {	
exception 

try {	w.writestartelement("root");	w.writeendelement();	w.writefullendelement();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void elemnamespace_1(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeattributestring("xmlns", "x", null, "bar");	}	catch (xmlexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeattributestring("xmlns", "x", null, "bar");	}	catch (xmlexception e) {	return;	}	}	
did not throw exception 

public void elemnamespace_2(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeendelement();	}	catch (xmlexception e) {	
exception 

w.writestartelement("root");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeattributestring("xmlns", "x", null, "foo");	w.writeendelement();	}	catch (xmlexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void elemnamespace_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("xml", "root", "blah");	}	catch (argumentexception e) {	
exception 

public void elemnamespace_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("xml", "root", "blah");	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void elemnamespace_9(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("xmlns", "localname", "uri:bogus");	w.writeendelement();	}	catch (exception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("xmlns", "localname", "uri:bogus");	w.writeendelement();	}	catch (exception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw error 

public void elemnamespace_17(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", null, "test");	w.writeendelement();	}	catch (xmlexception e) {	
exception 

try {	w.writestartelement("root");	w.writeattributestring("xmlns", null, "test");	w.writeendelement();	}	catch (xmlexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void elemnamespace_22(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("pre", "test", string.empty);	w.writeendelement();	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("pre", "test", string.empty);	w.writeendelement();	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attrnamespace_1(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "xml", null, "foo");	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xmlns", "xml", null, "foo");	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attrnamespace_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xml", "space", "foo", "default");	w.writeendelement();	}	catch (argumentexception e) {	
exception 

try {	w.writestartelement("root");	w.writeattributestring("xml", "space", "foo", "default");	w.writeendelement();	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void attrnamespace_6(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeattributestring("xml", "lang", "foo", "en");	w.writeendelement();	}	catch (argumentexception e) {	
exception 

try {	w.writestartelement("root");	w.writeattributestring("xml", "lang", "foo", "en");	w.writeendelement();	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writeattributestring("xmlns", "foo", "bar", "");	w.writeendelement();	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writeattributestring("xmlns", "xmlns", null, "test");	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void cdata_9(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writecdata("\ud812");	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writecdata("\ud812");	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

public void cdata_10(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeendelement();	w.writecdata("foo");	}	catch (invalidoperationexception e) {	
exception 

try {	w.writestartelement("root");	w.writeendelement();	w.writecdata("foo");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void comment_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writecomment("\ud812");	w.writeendelement();	}	catch (argumentexception e) {	
exception 

try {	w.writestartelement("root");	w.writecomment("\ud812");	w.writeendelement();	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw error 

default: temp = param;	break;	}	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeentityref(temp);	w.writeendelement();	}	catch (argumentexception e) {	
exception 

try {	w.writestartelement("root");	w.writeentityref(temp);	w.writeendelement();	}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	catch (nullreferenceexception e) {	
exception 

}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	catch (nullreferenceexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	}	
did not throw error 

public void charentity_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writecharentity('\udd12');	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writecharentity('\udd12');	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void charentity_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writecharentity('\ud812');	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writecharentity('\ud812');	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void surrogateentity_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\udd12', '\udd01');	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\udd12', '\udd01');	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void surrogateentity_6(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\u1025', '\ud900');	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\u1025', '\ud900');	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void surrogateentity_7(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\ud9a2', '\ude34');	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writesurrogatecharentity('\ud9a2', '\ude34');	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void pi_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeprocessinginstruction(null, "test");	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeprocessinginstruction(null, "test");	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	catch (nullreferenceexception e) {	
exception 

}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	catch (nullreferenceexception e) {	cerror.compare(w.writestate, writestate.element, "writestate should be element ");	return;	}	}	
did not throw exception 

public void pi_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeprocessinginstruction(string.empty, "test");	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeprocessinginstruction(string.empty, "test");	}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void pi_7(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeprocessinginstruction("xml", "text");	w.writeendelement();	w.dispose();	}	catch (argumentexception e) {	
exception 

w.writestartelement("root");	w.writeprocessinginstruction("xml", "text");	w.writeendelement();	w.dispose();	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void pi_8(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writeprocessinginstruction("pi", "text");	w.writestartdocument(true);	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writeprocessinginstruction("pi", "text");	w.writestartdocument(true);	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void pi_9(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeprocessinginstruction("xml", "version = \"1.0\"");	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeprocessinginstruction("xml", "version = \"1.0\"");	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void pi_10(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writeprocessinginstruction("xml", "version = \"1.0\"");	w.writestartdocument();	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writeprocessinginstruction("xml", "version = \"1.0\"");	w.writestartdocument();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void pi_13(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeprocessinginstruction("pi", "\ud812");	w.writeendelement();	}	catch (argumentexception e) {	
exception 

try {	w.writestartelement("root");	w.writeprocessinginstruction("pi", "\ud812");	w.writeendelement();	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

else temp = string.empty;	w.writenmtoken(temp);	w.writeendelement();	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	utils.checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

cerror.writelineignore(e.tostring());	utils.checkelementstate(w.writestate);	return;	}	catch (xmlexception e) {	cerror.writelineignore(e.tostring());	utils.checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

else temp = string.empty;	w.writename(temp);	w.writeendelement();	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	utils.checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

cerror.writelineignore(e.tostring());	utils.checkelementstate(w.writestate);	return;	}	catch (xmlexception e) {	cerror.writelineignore(e.tostring());	utils.checkelementstate(w.writestate);	return;	}	}	
did not throw exception 

cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	catch (nullreferenceexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

cerror.writelineignore(e.tostring());	if (utils.writertype == writertype.customwriter) {	cerror.compare(w.writestate, writestate.element, "writestate should be element");	}	else {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	}	return;	}	}	
did not throw exception 

w.writeattributestring("xmlns", "foo", null, "test");	w.writequalifiedname(param, "test");	w.writeendelement();	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void writechars_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writechars(null, 0, 0);	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writechars(null, 0, 0);	}	catch (argumentexception e) {	cerror.compare(w.writestate, writestate.error, writestate.element, "writestate should be error");	return;	}	}	
did not throw exception 

public void writestring_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestring("\ud812");	w.writeendelement();	}	catch (argumentexception e) {	
exception 

try {	w.writestartelement("root");	w.writestring("\ud812");	w.writeendelement();	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

public void writestring_14(xmlwriterutils utils) {	char[] invalidxml = { 'a', 'b', '\uda34' };	string invxml = new string(invalidxml);	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestring(invxml);	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestring(invxml);	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

public void writestring_15(xmlwriterutils utils) {	char[] invalidxml = { '\udf20', 'b', 'c' };	string invxml = new string(invalidxml);	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestring(invxml);	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestring(invxml);	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

public void writestring_16(xmlwriterutils utils) {	char[] invalidxml = { 'a', '\ude40', '\uda72', 'c' };	string invxml = new string(invalidxml);	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestring(invxml);	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestring(invxml);	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

public void whitespace_5(xmlwriterutils utils, string param) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writewhitespace(param);	}	catch (argumentexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writewhitespace(param);	}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.element : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

[theory]	[xmlwriterinlinedata]	public void lookupprefix_1(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	string s = w.lookupprefix(null);	w.dispose();	}	catch (argumentexception e) {	
exception 

try {	w.writestartelement("root");	string s = w.lookupprefix(null);	w.dispose();	}	catch (argumentexception e) {	utils.checkerrorstate(w.writestate);	return;	}	}	
did not throw exception 

w.writestartelement("root");	w.writestartelement("node", null);	w.writeattributestring("xml", "space", null, "reserve");	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
exception expected 

w.writestartelement("root");	w.writeattributestring("xml", "space", null, "preserve");	w.writeattributestring("xml", "space", null, "default");	}	catch (xmlexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
exception expected 

}	return;	}	[theory]	[xmlwriterinlinedata]	public void xmllang_2(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	w.writestartelement("root");	if (w.xmllang != null) {	w.dispose();	
default value if no xml lang attributes are currently on the stack should be null 

}	return;	}	[theory]	[xmlwriterinlinedata]	public void xmllang_2(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	w.writestartelement("root");	if (w.xmllang != null) {	w.dispose();	
actual value 

w.writestartelement("root");	w.writeattributestring("xml", "lang", null, "en-us");	w.writeattributestring("xml", "lang", null, "ja");	}	catch (xmlexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
exception expected 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writeraw(null, 0, 0);	}	catch (argumentnullexception) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

try {	w.writestartelement("root");	w.writeraw("\ud812");	}	catch (argumentexception e) {	cerror.writelineignore(e.tostring());	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writebase64(null, 0, 0);	}	catch (argumentnullexception) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

break;	case "ns": w.writestartattribute("xmlns", "foo", null);	break;	}	w.writebase64(buffer, 0, 5);	}	catch (invalidoperationexception) {	return;	}	}	
did not throw exception 

catch (argumentnullexception) {	if (utils.writertype == writertype.customwriter) {	cerror.compare(w.writestate, writestate.element, "writestate should be element");	}	else {	utils.checkerrorstate(w.writestate);	}	return;	}	}	
did not throw exception 

========================= corefx sample_12465 =========================

protected virtual void serialize(serializationinfo info, streamingcontext context) {	if (toolboxitempersist.traceverbose) {	
persisting 

protected virtual void serialize(serializationinfo info, streamingcontext context) {	if (toolboxitempersist.traceverbose) {	
display name 

========================= corefx sample_10471 =========================

public static bool comparesequences<t>(this ienumerable<t> actual, ienumerable<t> expected) {	using (var e1 = expected.getenumerator()) using (var e2 = actual.getenumerator()) {	while (e1.movenext()) {	if (!e2.movenext()) {	
partitioner returned fewer elements next element expected 

public static bool comparesequences<t>(this ienumerable<t> actual, ienumerable<t> expected) {	using (var e1 = expected.getenumerator()) using (var e2 = actual.getenumerator()) {	while (e1.movenext()) {	if (!e2.movenext()) {	return false;	}	if (!e1.current.equals(e2.current)) {	
mismatching elements expected actual 

using (var e1 = expected.getenumerator()) using (var e2 = actual.getenumerator()) {	while (e1.movenext()) {	if (!e2.movenext()) {	return false;	}	if (!e1.current.equals(e2.current)) {	return false;	}	}	if (e2.movenext()) {	
partitioner returned more elements next element returned by partitioner 

========================= corefx sample_10636 =========================

}	catch (filenotfoundexception e1) {	_output.writeline(e1.tostring());	}	catch (fileloadexception e2) {	_output.writeline(e2.tostring());	}	}	}	catch (exception e) {	
exception 

}	catch (filenotfoundexception e1) {	_output.writeline(e1.tostring());	}	catch (fileloadexception e2) {	_output.writeline(e2.tostring());	}	}	}	catch (exception e) {	
stack 

private void comparemessages() {	if (ignoremultipledots && _expectedmessage.endswith(".")) _expectedmessage = _expectedmessage.trimend(new char[] { '.' }) + ".";	_expectedmessage = regex.escape(_expectedmessage);	_expectedmessage = _expectedmessage.replace(escape_any, ".*");	_expectedmessage = _expectedmessage.replace(escape_number, @"\d*");	_expectedmessage = _expectedmessage.tolowerinvariant();	_actualmessage = _actualmessage.tolowerinvariant();	if (!platformdetection.isnetnative) {	if (regex.match(_actualmessage, _expectedmessage, regexoptions.singleline).tostring() != _actualmessage) {	_expectedmessage = regex.unescape(_expectedmessage);	
mismatch in error message 

========================= corefx sample_12622 =========================

public void executenonqueryerrortest() {	remoteinvoke(() => {	collectstatisticsdiagnostics(connectionstring => {	using (sqlconnection conn = new sqlconnection(connectionstring)) {	using (sqlcommand cmd = new sqlcommand()) {	cmd.connection = conn;	cmd.commandtext = "select 1 / 0;";	cmd.commandtimeout = 3;	conn.open();	
sqlclient diagnostictest executenonqueryerrortest connection open successful 

using (sqlconnection conn = new sqlconnection(connectionstring)) {	using (sqlcommand cmd = new sqlcommand()) {	cmd.connection = conn;	cmd.commandtext = "select 1 / 0;";	cmd.commandtimeout = 3;	conn.open();	try {	var output = cmd.executenonquery();	}	catch (exception e) {	
sqlclient diagnostictest executenonqueryerrortest 

using (sqlcommand cmd = new sqlcommand()) {	cmd.connection = conn;	cmd.commandtext = "select 1 / 0;";	cmd.commandtimeout = 3;	conn.open();	try {	var output = cmd.executenonquery();	}	catch (exception e) {	}	
sqlclient diagnostictest executenonqueryerrortest command executed 

cmd.connection = conn;	cmd.commandtext = "select 1 / 0;";	cmd.commandtimeout = 3;	conn.open();	try {	var output = cmd.executenonquery();	}	catch (exception e) {	}	}	
sqlclient diagnostictest executenonqueryerrortest command disposed 

cmd.commandtext = "select 1 / 0;";	cmd.commandtimeout = 3;	conn.open();	try {	var output = cmd.executenonquery();	}	catch (exception e) {	}	}	}	
sqlclient diagnostictest executenonqueryerrortest connection disposed 

public void connectionopentest() {	remoteinvoke(() => {	collectstatisticsdiagnostics(connectionstring => {	using (sqlconnection sqlconnection = new sqlconnection(connectionstring)) {	sqlconnection.open();	
sqlclient diagnosticstest connectionopentest connection opened 

public void connectionopentest() {	remoteinvoke(() => {	collectstatisticsdiagnostics(connectionstring => {	using (sqlconnection sqlconnection = new sqlconnection(connectionstring)) {	sqlconnection.open();	}	
sqlclient diagnosticstest connectionopentest connection should be disposed 

public void connectionopentest() {	remoteinvoke(() => {	collectstatisticsdiagnostics(connectionstring => {	using (sqlconnection sqlconnection = new sqlconnection(connectionstring)) {	sqlconnection.open();	}	}, true);	
sqlclient diagnosticstest connectionopentest done with diagnostics collection 

========================= corefx sample_10997 =========================

bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.base64_test);	datareader.positiononelement(st_elem_name1);	datareader.read();	if (checkcanreadbinarycontent()) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	
actual exception 

bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.base64_test);	datareader.positiononelement(st_elem_name1);	datareader.read();	if (checkcanreadbinarycontent()) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	
expected exception 

positiononnodetype(nt);	string name = datareader.name;	string value = datareader.value;	cerror.writeline("name=" + name);	cerror.writeline("value=" + value);	if (checkcanreadbinarycontent()) return;	byte[] buffer = new byte[1];	int nbytes = datareader.readcontentasbase64(buffer, 0, 1);	cerror.compare(nbytes, 0, "nbytes");	cerror.compare(datareader.verifynode(nt, name, value), "vn");	
succeeded 

public int testtextreadbase64_24() {	if (isroundtrippedreader()) return test_skipped;	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('c', 5000);	reloadsourcestr(strxml);	datareader.positiononelement("b");	datareader.read();	if (checkcanreadbinarycontent()) return test_pass;	try {	datareader.readcontentasbase64(buffer, 0, 5000);	
accepted incomplete element 

sw.write(base64str);	sw.write("</base64></root>");	}	filepathutil.addstream(filename, mems);	reloadsource(filename);	int size = (totalfilesize - 30);	int size64 = size * 3 / 4;	datareader.positiononelement("base64");	datareader.read();	if (checkcanreadbinarycontent()) return test_pass;	
method 

private bool verifyinvalidreadbase64(int ibuffersize, int iindex, int icount, type exceptiontype) {	bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.base64_test);	datareader.positiononelement(st_elem_name1);	if (checkcanreadbinarycontent()) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	
actual exception 

private bool verifyinvalidreadbase64(int ibuffersize, int iindex, int icount, type exceptiontype) {	bool bpassed = false;	byte[] buffer = new byte[ibuffersize];	reloadsource(ereader_type.base64_test);	datareader.positiononelement(st_elem_name1);	if (checkcanreadbinarycontent()) return true;	try {	datareader.readcontentasbase64(buffer, iindex, icount);	}	catch (exception e) {	
expected exception 

public int testtextreadbase64_24() {	if (isroundtrippedreader()) return test_skipped;	byte[] buffer = new byte[5000];	string strxml = "<b>" + new string('c', 5000);	reloadsourcestr(strxml);	datareader.positiononelement("b");	if (checkcanreadbinarycontent()) return test_pass;	try {	datareader.readelementcontentasbase64(buffer, 0, 5000);	
accepted incomplete element 

{	sw.write("<root><base64>");	sw.write(base64str);	sw.write("</base64></root>");	}	filepathutil.addstream(filename, mems);	reloadsource(filename);	int size = (totalfilesize - 30);	int size64 = size * 3 / 4;	datareader.positiononelement("base64");	
method 

stringbuilder output = new stringbuilder();	while (bytes != 0) {	byte[] bbb = new byte[1024];	bytes = datareader.readelementcontentasbase64(bbb, 0, bbb.length);	for (int i = 0; i < bytes; i++) {	cerror.write(bbb[i].tostring());	output.appendformat(bbb[i].tostring());	}	}	cerror.writeline();	
length of the output 

int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbase64(buffer, startpos, readsize);	cerror.equals(currentsize, 2, "size");	cerror.equals(buffer[0], (byte)215, "buffer1");	cerror.equals(buffer[1], (byte)109, "buffer2");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
linenumber 

int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbase64(buffer, startpos, readsize);	cerror.equals(currentsize, 2, "size");	cerror.equals(buffer[0], (byte)215, "buffer1");	cerror.equals(buffer[1], (byte)109, "buffer2");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
lineposition 

int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbase64(buffer, startpos, readsize);	cerror.equals(currentsize, 2, "size");	cerror.equals(buffer[0], (byte)215, "buffer1");	cerror.equals(buffer[1], (byte)109, "buffer2");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
linenumber 

int startpos = 0;	int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	currentsize = datareader.readcontentasbase64(buffer, startpos, readsize);	cerror.equals(currentsize, 2, "size");	cerror.equals(buffer[0], (byte)215, "buffer1");	cerror.equals(buffer[1], (byte)109, "buffer2");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
lineposition 

int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	cerror.equals(datareader.value.contains("123"), "value");	currentsize = datareader.readcontentasbase64(buffer, startpos, readsize);	cerror.equals(currentsize, 2, "size");	cerror.equals(buffer[0], (byte)215, "buffer1");	cerror.equals(buffer[1], (byte)109, "buffer2");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
linenumber 

int readsize = 3;	int currentsize = 0;	datareader.read();	while (datareader.read()) {	cerror.equals(datareader.value.contains("123"), "value");	currentsize = datareader.readcontentasbase64(buffer, startpos, readsize);	cerror.equals(currentsize, 2, "size");	cerror.equals(buffer[0], (byte)215, "buffer1");	cerror.equals(buffer[1], (byte)109, "buffer2");	if (!(isxpathnavigatorreader() || isxmlnodereader() || isxmlnodereaderdatadoc())) {	
lineposition 

========================= corefx sample_12400 =========================

break;	case "writebinhex": w.writebinhex(bytebuffer, iindex, icount);	break;	case "writechars": w.writechars(charbuffer, iindex, icount);	break;	default: cerror.compare(false, "unexpected method name " + methodname);	break;	}	}	catch (exception e) {	
exception 

break;	default: cerror.compare(false, "unexpected method name " + methodname);	break;	}	}	catch (exception e) {	if (exceptiontype.fullname.equals(e.gettype().fullname)) {	return;	}	else {	
did not throw exception of type 

========================= corefx sample_12451 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	}	else if (args.severity == xmlseveritytype.error) {	
error 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	}	else if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	errorcount++;	}	xmlschemaexception se = args.exception as xmlschemaexception;	
exception message 

if (args.severity == xmlseveritytype.warning) {	bwarningcallback = true;	warningcount++;	}	else if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	errorcount++;	}	xmlschemaexception se = args.exception as xmlschemaexception;	if (se.innerexception != null) {	
innerexception message 

bwarningcallback = true;	warningcount++;	}	else if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	errorcount++;	}	xmlschemaexception se = args.exception as xmlschemaexception;	if (se.innerexception != null) {	}	
inner exception is null 

========================= corefx sample_12511 =========================

}	}	}	bool[] matcheditems = new bool[schema.items.count];	int count = 0;	for (int i = 0; i < schema.items.count; i++) {	xmlschemaobject o = schema.items[i];	xmlschemaobject dest = find(o, originals);	if (dest != null) {	if (!cache.match(dest, o, _sharetypes)) {	
xmlserialization failed to merge plase compare hash 

========================= corefx sample_12983 =========================

public void v6() {	xmlschemaset sc = new xmlschemaset();	xmlschema schema2 = sc.add(null, testdata._xsdauthor);	sc.remove(schema2);	icollection col = sc.schemas("xsdauthor");	cerror.compare(col.count, 0, "count");	foreach (xmlschema schema in col) {	xmlschema a = schema;	
should never enter this loop 

========================= corefx sample_12500 =========================

public int testresolveentitynodetype_endentity() {	if (isxsltreader() || isxmltextreader() || isxmlnodereaderdatadoc() || iscorereader() || isxpathnavigatorreader()) return test_skipped;	reloadsource();	if (findnodetype(xmlnodetype.endentity) == test_pass) {	try {	cerror.writeline(datareader.nodetype);	datareader.resolveentity();	
resolveentity succeeded 

========================= corefx sample_12440 =========================

public static void runpartitionerstatictest_singlechunking() {	countdownevent cde = new countdownevent(2);	action[] actions = new action[256];	for (int i = 0; i < 252; i++) actions[i] = () => { };	actions[252] = () => { cde.wait(); };	actions[253] = () => { cde.signal(); };	actions[254] = () => { cde.wait(); };	actions[255] = () => { cde.signal(); };	
we ll hang here if enumerablepartitioneroptions nobuffering is not working properly 

private static void rangepartitionerchunktest(int from, int to, int rangesize) {	
rangepartitionchunktest int 

private static void rangepartitionerchunktest(long from, long to, long rangesize) {	
rangepartitionchunktest long 

private static void rangepartitionercoveragetest(int from, int to, int rangesize) {	
rangepartitioncoveragetest int 

private static void rangepartitionercoveragetest(long from, long to, long rangesize) {	
rangepartitioncoveragetest long 

========================= corefx sample_1259 =========================

public static ienumerable<testbase> gettests(assembly assembly) {	list<testbase> tests = new list<testbase>();	type[] typesinmodule = null;	try {	typesinmodule = assembly.gettypes();	}	catch (reflectiontypeloadexception ex) {	
reflectiontypeloadexception errors 

type[] typesinmodule = null;	try {	typesinmodule = assembly.gettypes();	}	catch (reflectiontypeloadexception ex) {	foreach (exception loadex in ex.loaderexceptions) {	console.writeline("\t" + loadex.message);	}	}	catch (exception ex) {	
error 

========================= corefx sample_10975 =========================

public void databits_default() {	using (serialport com1 = new serialport(tcsupport.localmachineserialinfo.firstavailableportname)) {	serialportproperties serportprop = new serialportproperties();	
verifying default databits 

public void databits_7_beforeopen() {	
verifying databits before open 

public void databits_8_beforeopen() {	
verifying databits before open 

public void databits_7_afteropen() {	
verifying databits after open 

public void databits_8_afteropen() {	
verifying databits after open 

public void databits_int32minvalue() {	
verifying minvalue databits 

public void databits_neg8() {	
verifying databits 

public void databits_neg1() {	
verifying databits 

public void databits_0() {	
verifying databits 

public void databits_1() {	
verifying databits 

public void databits_4() {	
verifying databits 

public void databits_9() {	
verifying databits 

public void databits_int32maxvalue() {	
verifying maxvalue databits 

========================= corefx sample_688 =========================

public void exporticompositionservicefromchildimportshouldshouldsucceed() {	var childcatalog = new typecatalog( typeof(classrequiresicompositionservice), typeof(classoptionallyimportsicompositionservice) );	var rootcatalog = new typecatalog( typeof(fromroot) );	var scope = rootcatalog.asscope(childcatalog.asscope());	var container = new compositioncontainer(scope, compositionoptions.exportcompositionservice);	var fromroot = container.getexportedvalue<fromroot>();	var requiredservice = fromroot.required.createexport();	
requiredservice 

public void exporticompositionservicefromchildimportshouldshouldsucceed() {	var childcatalog = new typecatalog( typeof(classrequiresicompositionservice), typeof(classoptionallyimportsicompositionservice) );	var rootcatalog = new typecatalog( typeof(fromroot) );	var scope = rootcatalog.asscope(childcatalog.asscope());	var container = new compositioncontainer(scope, compositionoptions.exportcompositionservice);	var fromroot = container.getexportedvalue<fromroot>();	var requiredservice = fromroot.required.createexport();	assert.notnull(requiredservice.value.compositionservice);	var optionalservice = fromroot.optional.createexport();	
optionalservice 

========================= corefx sample_9983 =========================

public async task closeasync_serverinitiatedclose_success(uri server) {	const string closewebsocketmetacommand = ".close";	using (clientwebsocket cws = await websockethelper.getconnectedwebsocket(server, timeoutmilliseconds, _output)) {	var cts = new cancellationtokensource(timeoutmilliseconds);	
sendasync starting 

public async task closeasync_serverinitiatedclose_success(uri server) {	const string closewebsocketmetacommand = ".close";	using (clientwebsocket cws = await websockethelper.getconnectedwebsocket(server, timeoutmilliseconds, _output)) {	var cts = new cancellationtokensource(timeoutmilliseconds);	await cws.sendasync( websocketdata.getbufferfromtext(closewebsocketmetacommand), websocketmessagetype.text, true, cts.token);	
sendasync done 

public async task closeasync_serverinitiatedclose_success(uri server) {	const string closewebsocketmetacommand = ".close";	using (clientwebsocket cws = await websockethelper.getconnectedwebsocket(server, timeoutmilliseconds, _output)) {	var cts = new cancellationtokensource(timeoutmilliseconds);	await cws.sendasync( websocketdata.getbufferfromtext(closewebsocketmetacommand), websocketmessagetype.text, true, cts.token);	var recvbuffer = new byte[256];	
receiveasync starting 

public async task closeasync_serverinitiatedclose_success(uri server) {	const string closewebsocketmetacommand = ".close";	using (clientwebsocket cws = await websockethelper.getconnectedwebsocket(server, timeoutmilliseconds, _output)) {	var cts = new cancellationtokensource(timeoutmilliseconds);	await cws.sendasync( websocketdata.getbufferfromtext(closewebsocketmetacommand), websocketmessagetype.text, true, cts.token);	var recvbuffer = new byte[256];	websocketreceiveresult recvresult = await cws.receiveasync(new arraysegment<byte>(recvbuffer), cts.token);	
receiveasync done 

using (clientwebsocket cws = await websockethelper.getconnectedwebsocket(server, timeoutmilliseconds, _output)) {	var cts = new cancellationtokensource(timeoutmilliseconds);	await cws.sendasync( websocketdata.getbufferfromtext(closewebsocketmetacommand), websocketmessagetype.text, true, cts.token);	var recvbuffer = new byte[256];	websocketreceiveresult recvresult = await cws.receiveasync(new arraysegment<byte>(recvbuffer), cts.token);	assert.equal(websocketclosestatus.normalclosure, recvresult.closestatus);	assert.equal(closewebsocketmetacommand, recvresult.closestatusdescription);	assert.equal(websocketstate.closereceived, cws.state);	assert.equal(websocketclosestatus.normalclosure, cws.closestatus);	assert.equal(closewebsocketmetacommand, cws.closestatusdescription);	
closeasync starting 

var cts = new cancellationtokensource(timeoutmilliseconds);	await cws.sendasync( websocketdata.getbufferfromtext(closewebsocketmetacommand), websocketmessagetype.text, true, cts.token);	var recvbuffer = new byte[256];	websocketreceiveresult recvresult = await cws.receiveasync(new arraysegment<byte>(recvbuffer), cts.token);	assert.equal(websocketclosestatus.normalclosure, recvresult.closestatus);	assert.equal(closewebsocketmetacommand, recvresult.closestatusdescription);	assert.equal(websocketstate.closereceived, cws.state);	assert.equal(websocketclosestatus.normalclosure, cws.closestatus);	assert.equal(closewebsocketmetacommand, cws.closestatusdescription);	await cws.closeasync(websocketclosestatus.invalidmessagetype, string.empty, cts.token);	
closeasync done 

========================= corefx sample_3721 =========================

assert.equal(typeof(taskcanceledexception), ae.innerexception.gettype());	assert.equal(taskstatus.canceled, asyncfuture.status);	task foo = task.factory.startnew(delegate {	task foo1 = task.factory.fromasync(fac.startwrite, fac.endwrite, (string)null, null, taskcreationoptions.attachedtoparent);	task foo2 = task.factory.fromasync(fac.startwrite, fac.endwrite, (string)null, 4, null, taskcreationoptions.attachedtoparent);	task foo3 = task.factory.fromasync(fac.startwrite, fac.endwrite, (string)null, 4, 4, null, taskcreationoptions.attachedtoparent);	task<string> foo4 = task<string>.factory.fromasync(fac.startread, fac.endread, -1, null, taskcreationoptions.attachedtoparent);	task<string> foo5 = task<string>.factory.fromasync(fac.startread, fac.endread, -1, (char[])null, null, taskcreationoptions.attachedtoparent);	task<string> foo6 = task<string>.factory.fromasync(fac.startread, fac.endread, -1, (char[])null, 200, null, taskcreationoptions.attachedtoparent);	});	
runapmfactorytests waiting on task w faulted fromasync calls if we hang there is a problem 

========================= corefx sample_4001 =========================

public static void run(string connectionstring) {	
starting outputparameter tests 

private static void invalidvalueinoutparam(string connectionstring) {	
test setting output sqlparameter to an invalid value 

private static void invalidvalueinoutparam(string connectionstring) {	using (var connection = new sqlconnection(connectionstring)) {	connection.open();	using (var command = new sqlcommand("set @decimal = 1.23", connection)) {	var decimalparam = new sqlparameter("decimal", new decimal(2.34)) { sqldbtype = sqldbtype.decimal, direction = parameterdirection.output, scale = 2, precision = 5 };	command.parameters.add(decimalparam);	decimalparam.value = "not a decimal";	command.executenonquery();	if (((decimal)decimalparam.value) != new decimal(1.23)) {	
fail value is incorrect 

connection.open();	using (var command = new sqlcommand("set @decimal = 1.23", connection)) {	var decimalparam = new sqlparameter("decimal", new decimal(2.34)) { sqldbtype = sqldbtype.decimal, direction = parameterdirection.output, scale = 2, precision = 5 };	command.parameters.add(decimalparam);	decimalparam.value = "not a decimal";	command.executenonquery();	if (((decimal)decimalparam.value) != new decimal(1.23)) {	}	}	}	
done 

========================= corefx sample_11085 =========================

public contentvalidator finish(bool usedfa) {	debug.assert(contenttype == xmlschemacontenttype.elementonly || contenttype == xmlschemacontenttype.mixed);	if (_contentnode == null) {	if (contenttype == xmlschemacontenttype.mixed) {	string ctype = isopen ? "any" : "textonly";	
contenttype 

public contentvalidator finish(bool usedfa) {	debug.assert(contenttype == xmlschemacontenttype.elementonly || contenttype == xmlschemacontenttype.mixed);	if (_contentnode == null) {	if (contenttype == xmlschemacontenttype.mixed) {	string ctype = isopen ? "any" : "textonly";	return isopen ? contentvalidator.any : contentvalidator.textonly;	}	else {	
content empty 

return isopen ? contentvalidator.any : contentvalidator.textonly;	}	else {	debug.assert(!isopen);	return contentvalidator.empty;	}	}	#if debug if (diagnosticsswitches.xmlschemacontentmodel.enabled) {	var bb = new stringbuilder();	_contentnode.dump(bb, _symbols, _positions);	
content 

_contentnode.dump(bb, _symbols, _positions);	}	#endif interiornode contentroot = new sequencenode();	contentroot.leftchild = _contentnode;	leafnode endmarker = new leafnode(_positions.add(_symbols.addname(xmlqualifiedname.empty, null), null));	contentroot.rightchild = endmarker;	_contentnode.expandtree(contentroot, _symbols, _positions);	#if debug if (diagnosticsswitches.xmlschemacontentmodel.enabled) {	var bb = new stringbuilder();	contentroot.leftchild.dump(bb, _symbols, _positions);	
expended 

#endif int symbolscount = _symbols.count;	int positionscount = _positions.count;	bitset firstpos = new bitset(positionscount);	bitset lastpos = new bitset(positionscount);	bitset[] followpos = new bitset[positionscount];	for (int i = 0; i < positionscount; i++) {	followpos[i] = new bitset(positionscount);	}	contentroot.constructpos(firstpos, lastpos, followpos);	#if debug if (diagnosticsswitches.xmlschemacontentmodel.enabled) {	
firstpos lastpos followpos 

========================= corefx sample_13072 =========================

private void print() {	
sqlstring 

========================= corefx sample_3542 =========================

public async task usedefaultcredentials_settofalseandserverneedsauth_statuscodeunauthorized(bool useproxy) {	httpclienthandler handler = createhttpclienthandler();	handler.useproxy = useproxy;	handler.usedefaultcredentials = false;	using (var client = new httpclient(handler)) {	uri uri = configuration.http.negotiateauthurifordefaultcreds(secure: false);	
uri 

public async task defaultheaders_setcredentials_clearedonredirect(int statuscode) {	httpclienthandler handler = createhttpclienthandler();	using (var client = new httpclient(handler)) {	string credentialstring = _credential.username + ":" + _credential.password;	client.defaultrequestheaders.authorization = new authenticationheadervalue("basic", credentialstring);	uri uri = configuration.http.redirecturifordestinationuri( secure: false, statuscode: statuscode, destinationuri: configuration.http.remoteechoserver, hops: 1);	
uri 

public async task getasync_allowautoredirectfalse_redirectfromhttptohttp_statuscoderedirect(int statuscode) {	httpclienthandler handler = createhttpclienthandler();	handler.allowautoredirect = false;	using (var client = new httpclient(handler)) {	uri uri = configuration.http.redirecturifordestinationuri( secure: false, statuscode: statuscode, destinationuri: configuration.http.remoteechoserver, hops: 1);	
uri 

public async task getasync_allowautoredirecttrue_redirectfromhttptohttp_statuscodeok(int statuscode) {	httpclienthandler handler = createhttpclienthandler();	handler.allowautoredirect = true;	using (var client = new httpclient(handler)) {	uri uri = configuration.http.redirecturifordestinationuri( secure: false, statuscode: statuscode, destinationuri: configuration.http.remoteechoserver, hops: 1);	
uri 

public async task getasync_allowautoredirecttrue_redirectfromhttptohttps_statuscodeok() {	httpclienthandler handler = createhttpclienthandler();	handler.allowautoredirect = true;	using (var client = new httpclient(handler)) {	uri uri = configuration.http.redirecturifordestinationuri( secure: false, statuscode: 302, destinationuri: configuration.http.secureremoteechoserver, hops: 1);	
uri 

public async task getasync_allowautoredirecttrue_redirectfromhttpstohttp_statuscoderedirect() {	httpclienthandler handler = createhttpclienthandler();	handler.allowautoredirect = true;	using (var client = new httpclient(handler)) {	uri uri = configuration.http.redirecturifordestinationuri( secure: true, statuscode: 302, destinationuri: configuration.http.remoteechoserver, hops: 1);	
uri 

public async task getasync_allowautoredirecttrue_redirecttouriwithparams_requestmsguriset() {	httpclienthandler handler = createhttpclienthandler();	handler.allowautoredirect = true;	uri targeturi = configuration.http.basicauthuriforcreds(secure: false, username: username, password: password);	using (var client = new httpclient(handler)) {	uri uri = configuration.http.redirecturifordestinationuri( secure: false, statuscode: 302, destinationuri: targeturi, hops: 1);	
uri 

public async task getasync_maxautomaticredirectionsnserverhops_throwsiftoomany(int maxhops, int hops) {	if (iswinhttphandler && !platformdetection.iswindows10version1703orgreater) {	
skipping test due to windows version prior to version 

public async task getasync_maxautomaticredirectionsnserverhops_throwsiftoomany(int maxhops, int hops) {	if (iswinhttphandler && !platformdetection.iswindows10version1703orgreater) {	return;	}	else if (platformdetection.isfullframework) {	
skipping test on net framework due to behavior difference 

public async task getasync_allowautoredirecttrue_redirectwithrelativelocation() {	httpclienthandler handler = createhttpclienthandler();	handler.allowautoredirect = true;	using (var client = new httpclient(handler)) {	uri uri = configuration.http.redirecturifordestinationuri( secure: false, statuscode: 302, destinationuri: configuration.http.remoteechoserver, hops: 1, relative: true);	
uri 

public async task sendasync_readfromslowstreamingserver_partialdatareturned() {	await loopbackserver.createserverasync(async (server, url) => {	using (httpclient client = createhttpclient()) {	task<httpresponsemessage> getresponse = client.getasync(url, httpcompletionoption.responseheadersread);	await server.acceptconnectionasync(async connection => {	await connection.readrequestheaderandsendcustomresponseasync( "http/1.1 200 ok\r\n" + $"date: {datetimeoffset.utcnow:r}\r\n" + "content-length: 16000\r\n" + "\r\n" + "less than 16000 bytes");	using (httpresponsemessage response = await getresponse) {	var buffer = new byte[8000];	using (stream clientstream = await response.content.readasstreamasync()) {	int bytesread = await clientstream.readasync(buffer, 0, buffer.length);	
bytes read from stream bytesread 

public async task sendasync_requestversion20_responseversion20ifhttp2supported(uri server) {	if (platformdetection.iswindows && !platformdetection.iswindows10version1703orgreater) {	
skipping test due to windows version prior to version 

========================= corefx sample_356 =========================

dcjs.writeobject(stream, obj);	stream.position = 0;	var serializedstr = new streamreader(stream).readtoend();	stream.position = 0;	var obj2 = (typewithdatetimestringproperty)dcjs.readobject(stream);	assert.strictequal(obj.datetimestring, obj2.datetimestring);	assert.strictequal(obj.currentdatetime, obj2.currentdatetime);	}	using (memorystream ms = new memorystream()) {	streamwriter sw = new streamwriter(ms);	
datetimestring 

========================= corefx sample_3863 =========================

private async task clientasyncsslhelper( encryptionpolicy encryptionpolicy, sslprotocols clientsslprotocols, sslprotocols serversslprotocols) {	
server client 

private async task clientasyncsslhelper( encryptionpolicy encryptionpolicy, sslprotocols clientsslprotocols, sslprotocols serversslprotocols) {	ipendpoint endpoint = new ipendpoint(ipaddress.ipv6loopback, 0);	using (var server = new dummytcpserver(endpoint, encryptionpolicy)) using (var client = new tcpclient(addressfamily.internetworkv6)) {	server.sslprotocols = serversslprotocols;	await client.connectasync(server.remoteendpoint.address, server.remoteendpoint.port);	using (sslstream sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null)) {	task clientauthtask = sslstream.authenticateasclientasync("localhost", null, clientsslprotocols, false);	await clientauthtask.timeoutafter(testconfiguration.passingtesttimeoutmilliseconds);	
client authenticated to server with encryption cipher bit strength 

========================= corefx sample_8146 =========================

if (servertotalbytesreceived < 5) {	return task.fromresult<string>(null);	}	else {	return task.fromresult(httpstestserver.options.defaultresponsestring);	}	});	string requesturistring = "https: tasks[1] = client.getstringasync(requesturistring);	await task.whenall(tasks).timeoutafter(15 * 1000);	if (serverauxrecorddetectedinconclusive) {	
test inconclusive the operating system preferred a non cbc or null cipher 

========================= corefx sample_391 =========================

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
supports 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
supports 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.throws<platformnotsupportedexception>(() => ipproperties.anycastaddresses);	assert.notnull(ipproperties.dhcpserveraddresses);	
dhcp server addresses 

public void ipinfotest_accessallproperties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	assert.notnull(ipproperties);	assert.throws<platformnotsupportedexception>(() => ipproperties.anycastaddresses);	assert.notnull(ipproperties.dhcpserveraddresses);	foreach (ipaddress dhcp in ipproperties.dhcpserveraddresses) {	_log.writeline("-- " + dhcp.tostring());	}	assert.notnull(ipproperties.dnsaddresses);	
dns addresses 

assert.throws<platformnotsupportedexception>(() => ipproperties.anycastaddresses);	assert.notnull(ipproperties.dhcpserveraddresses);	foreach (ipaddress dhcp in ipproperties.dhcpserveraddresses) {	_log.writeline("-- " + dhcp.tostring());	}	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	
dns suffix 

assert.notnull(ipproperties.dhcpserveraddresses);	foreach (ipaddress dhcp in ipproperties.dhcpserveraddresses) {	_log.writeline("-- " + dhcp.tostring());	}	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	
gateway addresses 

}	assert.notnull(ipproperties.dnsaddresses);	foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	
dns enabled 

foreach (ipaddress dns in ipproperties.dnsaddresses) {	_log.writeline("-- " + dns.tostring());	}	assert.notnull(ipproperties.dnssuffix);	assert.notnull(ipproperties.gatewayaddresses);	foreach (gatewayipaddressinformation gateway in ipproperties.gatewayaddresses) {	_log.writeline("-- " + gateway.address.tostring());	}	assert.throws<platformnotsupportedexception>(() => ipproperties.isdynamicdnsenabled);	assert.notnull(ipproperties.multicastaddresses);	
multicast addresses 

_log.writeline("-- " + gateway.address.tostring());	}	assert.throws<platformnotsupportedexception>(() => ipproperties.isdynamicdnsenabled);	assert.notnull(ipproperties.multicastaddresses);	foreach (ipaddressinformation multi in ipproperties.multicastaddresses) {	_log.writeline("-- " + multi.address.tostring());	assert.throws<platformnotsupportedexception>(() => multi.isdnseligible);	assert.throws<platformnotsupportedexception>(() => multi.istransient);	}	assert.notnull(ipproperties.unicastaddresses);	
unicast addresses 

assert.throws<platformnotsupportedexception>(() => multi.istransient);	}	assert.notnull(ipproperties.unicastaddresses);	foreach (unicastipaddressinformation uni in ipproperties.unicastaddresses) {	_log.writeline("-- " + uni.address.tostring());	assert.throws<platformnotsupportedexception>(() => uni.addresspreferredlifetime);	assert.throws<platformnotsupportedexception>(() => uni.addressvalidlifetime);	assert.throws<platformnotsupportedexception>(() => uni.dhcpleaselifetime);	assert.throws<platformnotsupportedexception>(() => uni.duplicateaddressdetectionstate);	assert.notnull(uni.ipv4mask);	
mask 

assert.throws<platformnotsupportedexception>(() => uni.dhcpleaselifetime);	assert.throws<platformnotsupportedexception>(() => uni.duplicateaddressdetectionstate);	assert.notnull(uni.ipv4mask);	assert.throws<platformnotsupportedexception>(() => uni.isdnseligible);	assert.throws<platformnotsupportedexception>(() => uni.istransient);	assert.throws<platformnotsupportedexception>(() => uni.prefixorigin);	assert.throws<platformnotsupportedexception>(() => uni.suffixorigin);	assert.throws<platformnotsupportedexception>(() => uni.prefixlength);	}	assert.notnull(ipproperties.winsserversaddresses);	
wins addresses 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	
properties 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	
index 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingactive);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingenabled);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isdhcpenabled);	
isforwardingenabled 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingactive);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingenabled);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isdhcpenabled);	
mtu 

public void ipinfotest_accessallipv4properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv4interfaceproperties ipv4properties = ipproperties.getipv4properties();	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingactive);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isautomaticprivateaddressingenabled);	assert.throws<platformnotsupportedexception>(() => ipv4properties.isdhcpenabled);	
useswins 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	
properties 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	
is null 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	continue;	}	
index 

public void ipinfotest_accessallipv6properties_noerrors() {	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	ipinterfaceproperties ipproperties = nic.getipproperties();	ipv6interfaceproperties ipv6properties = ipproperties.getipv6properties();	if (ipv6properties == null) {	continue;	}	
mtu 

public void ipv6scopeid_accessallvalues_success() {	assert.true(capability.ipv6support());	foreach (networkinterface nic in networkinterface.getallnetworkinterfaces()) {	
nic 

========================= corefx sample_13386 =========================

finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	else file.appendalltext(debugfilename, string.format("scenario 1 - vanilla - not run: different drive is mounted on the current drive {0}", environment.newline));	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

}	finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

}	finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

}	finally {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

if (!eval(!directory.exists(mounteddirname), "err_001yph! directory {0} still exist: {1}", mounteddirname, directory.exists(mounteddirname))) {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

string[] dirs = filemanager.getdirectories(1);	mounteddirname = path.getfullpath(dirs[0]);	if (eval(directory.getdirectories(mounteddirname).length == 0, "err_974tsg! the sub directory has directories: {0}", mounteddirname)) {	foreach (string file in directory.getfiles(mounteddirname)) file.delete(file);	if (eval(directory.getfiles(mounteddirname).length == 0, "err_13ref! the mounted directory has files: {0}", mounteddirname)) {	file.appendalltext(debugfilename, string.format("mounting on {0}{1}{2}", directory.getcurrentdirectory().substring(0, 2), mounteddirname, environment.newline));	mounthelper.mount(directory.getcurrentdirectory().substring(0, 2), mounteddirname);	directory.delete(dirname, true);	task.delay(300).wait();	eval(!directory.exists(dirname), "err_006jsf! directory {0} still exist: {1}", dirname, directory.exists(dirname));	
completed scenario 

if (!eval(!directory.exists(mounteddirname), "err_625ckx! directory {0} still exist: {1}", mounteddirname, directory.exists(mounteddirname))) {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

mounteddirname = path.getfullpath(dirs[0]);	if (dirs.length > 1) mounteddirname = path.getfullpath(dirs[1]);	if (eval(directory.getdirectories(mounteddirname).length == 0, "err_492qwl! the sub directory has directories: {0}", mounteddirname)) {	foreach (string file in directory.getfiles(mounteddirname)) file.delete(file);	if (eval(directory.getfiles(mounteddirname).length == 0, "err_904kij! the mounted directory has files: {0}", mounteddirname)) {	file.appendalltext(debugfilename, string.format("mounting on {0}{1}{2}", directory.getcurrentdirectory().substring(0, 2), mounteddirname, environment.newline));	mounthelper.mount(directory.getcurrentdirectory().substring(0, 2), mounteddirname);	directory.delete(dirname, true);	task.delay(300).wait();	eval(!directory.exists(dirname), "err_900edl! directory {0} still exist: {1}", dirname, directory.exists(dirname));	
completed scenario 

if (!eval(!directory.exists(mounteddirname), "err_462xtc! directory {0} still exist: {1}", mounteddirname, directory.exists(mounteddirname))) {	mounthelper.unmount(mounteddirname);	deletedir(mounteddirname, true);	}	}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	}	catch (exception ex) {	s_pass = false;	
err exception caught in scenario 

}	file.appendalltext(debugfilename, string.format("completed scenario {0}", environment.newline));	}	}	catch (exception ex) {	s_pass = false;	}	}	catch (exception ex) {	s_pass = false;	
err uncaught exception in runtest 

========================= corefx sample_222 =========================

private verbosetestlogging _log;	private tcplistener _listener;	private bool _usessl;	private sslprotocols _sslprotocols = sslprotocols.tls12 | sslprotocols.tls11 | sslprotocols.tls;	private encryptionpolicy _sslencryptionpolicy;	private ipendpoint _remoteendpoint;	private dummytcpserverreceivecallback _receivecallback;	private void startlistener(ipendpoint endpoint) {	_listener = new tcplistener(endpoint);	_listener.start(5);	
server listening 

if (disposing) {	_listener.stop();	}	}	protected virtual void onclientaccepted(tcpclient client) {	}	private void onauthenticate(task result, clientstate state) {	sslstream sslstream = (sslstream)state.stream;	try {	result.getawaiter().getresult();	
server authenticated to client with encryption cipher bit strength 

}	protected virtual void onclientaccepted(tcpclient client) {	}	private void onauthenticate(task result, clientstate state) {	sslstream sslstream = (sslstream)state.stream;	try {	result.getawaiter().getresult();	sslstream.beginread(state.receivebuffer, 0, state.receivebuffer.length, onreceive, state);	}	catch (authenticationexception authex) {	
server disconnecting from client during authentication no shared ssl tls algorithm 

private void onauthenticate(task result, clientstate state) {	sslstream sslstream = (sslstream)state.stream;	try {	result.getawaiter().getresult();	sslstream.beginread(state.receivebuffer, 0, state.receivebuffer.length, onreceive, state);	}	catch (authenticationexception authex) {	state.dispose();	}	catch (exception ex) {	
server disconnecting from client during authentication exception 

try {	client = result.result;	}	catch {	}	if (client != null) {	onclientaccepted(client);	clientstate state;	if (_usessl) {	state = new clientstate(client, _sslencryptionpolicy);	
server starting ssl authentication 

}	if (client != null) {	onclientaccepted(client);	clientstate state;	if (_usessl) {	state = new clientstate(client, _sslencryptionpolicy);	sslstream sslstream = null;	x509certificate2 certificate = configuration.certificates.getservercertificate();	try {	sslstream = (sslstream)state.stream;	
server attempting to open sslstream 

sslstream sslstream = null;	x509certificate2 certificate = configuration.certificates.getservercertificate();	try {	sslstream = (sslstream)state.stream;	sslstream.authenticateasserverasync(certificate, false, _sslprotocols, false).continuewith(t => {	certificate.dispose();	onauthenticate(t, state);	}, taskscheduler.default);	}	catch (exception ex) {	
server exception 

========================= corefx sample_8123 =========================

private void generategetserializer(hashtable serializers, xmlmapping[] xmlmappings) {	_writer.write("public override ");	_writer.write(typeof(system.xml.serialization.xmlserializer).fullname);	_writer.write(" getserializer(");	_writer.write(typeof(type).fullname);	
type 

if (!type.ispublic && !type.isnestedpublic) continue;	if (dynamicassemblies.istypedynamic(type)) continue;	if (type.isgenerictype || type.containsgenericparameters && dynamicassemblies.istypedynamic(type.getgenericarguments())) continue;	_writer.write("if (type == typeof(");	_writer.write(codeidentifier.getcsharpname(type));	_writer.write(")) return new ");	_writer.write((string)serializers[xmlmappings[i].key]);	_writer.writeline("();");	}	}	
return null 

========================= corefx sample_12914 =========================

_writer.write(" | ");	_writer.write(bindingflags);	_writer.write(".nonpublic");	}	_writer.write(", null, ");	_writer.write("new " + typeof(type).fullname + "[] { ");	for (int i = 0; i < paramtypes.length; i++) {	_writer.write(paramtypes[i]);	if (i < (paramtypes.length - 1)) _writer.write(", ");	}	
null 

_writer.write("static xsarrayinfo ");	_writer.write(itemvariable);	_writer.write("= new xsarrayinfo(");	_writer.write(getstringfortypeof(codeidentifier.getcsharpname(type), collectionusereflection));	_writer.write(".getproperty(");	writequotedcsharpstring(defaultindexer.name);	_writer.write(",");	_writer.write(getstringfortypeof(codeidentifier.getcsharpname(defaultindexer.propertytype), elementusereflection));	_writer.write(",new ");	_writer.write(typeof(type[]).fullname);	
typeof int 

private void generateinitcallbacksmethod() {	writer.writeline();	
protected override void initcallbacks 

private void writeendelement() {	
writeendelement 

private string generatememberselement(xmlmembersmapping xmlmembersmapping) {	elementaccessor element = xmlmembersmapping.accessor;	membersmapping mapping = (membersmapping)element.mapping;	bool haswrapperelement = mapping.haswrapperelement;	bool writeaccessors = mapping.writeaccessors;	bool isrpc = xmlmembersmapping.issoap && writeaccessors;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public void ");	writer.write(methodname);	
object p 

elementaccessor element = xmlmembersmapping.accessor;	membersmapping mapping = (membersmapping)element.mapping;	bool haswrapperelement = mapping.haswrapperelement;	bool writeaccessors = mapping.writeaccessors;	bool isrpc = xmlmembersmapping.issoap && writeaccessors;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public void ");	writer.write(methodname);	writer.indent++;	
writestartdocument 

membersmapping mapping = (membersmapping)element.mapping;	bool haswrapperelement = mapping.haswrapperelement;	bool writeaccessors = mapping.writeaccessors;	bool isrpc = xmlmembersmapping.issoap && writeaccessors;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public void ");	writer.write(methodname);	writer.indent++;	if (!mapping.issoap) {	
toplevelelement 

if (element.issoap) {	if (!haswrapperelement && !writeaccessors) {	writer.write("if (plength > ");	writer.write(mapping.members.length.tostring(cultureinfo.invariantculture));	writer.writeline(") {");	writer.indent++;	writeextramembers(mapping.members.length.tostring(cultureinfo.invariantculture), "plength");	writer.indent--;	writer.writeline("}");	}	
writereferencedelements 

private string generatetypeelement(xmltypemapping xmltypemapping) {	elementaccessor element = xmltypemapping.accessor;	typemapping mapping = element.mapping;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public void ");	writer.write(methodname);	
object o 

private string generatetypeelement(xmltypemapping xmltypemapping) {	elementaccessor element = xmltypemapping.accessor;	typemapping mapping = element.mapping;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public void ");	writer.write(methodname);	writer.indent++;	
writestartdocument 

writer.write("public void ");	writer.write(methodname);	writer.indent++;	writer.writeline("if (o == null) {");	writer.indent++;	if (element.isnullable) {	if (mapping.issoap) writeencodednulltag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	else writeliteralnulltag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	}	else writeemptytag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	
return 

writer.writeline("if (o == null) {");	writer.indent++;	if (element.isnullable) {	if (mapping.issoap) writeencodednulltag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	else writeliteralnulltag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	}	else writeemptytag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	writer.indent--;	writer.writeline("}");	if (!mapping.issoap && !mapping.typedesc.isvaluetype && !mapping.typedesc.type.isprimitive) {	
toplevelelement 

if (mapping.issoap) writeencodednulltag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	else writeliteralnulltag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	}	else writeemptytag(element.name, (element.form == xmlschemaform.qualified ? element.namespace : ""));	writer.indent--;	writer.writeline("}");	if (!mapping.issoap && !mapping.typedesc.isvaluetype && !mapping.typedesc.type.isprimitive) {	}	writemember("o", null, new elementaccessor[] { element }, null, null, mapping.typedesc, !element.issoap);	if (mapping.issoap) {	
writereferencedelements 

========================= corefx sample_12945 =========================

}	catch (filenotfoundexception e1) {	_output.writeline(e1.tostring());	}	catch (fileloadexception e2) {	_output.writeline(e2.tostring());	}	}	}	catch (exception e) {	
exception 

}	catch (filenotfoundexception e1) {	_output.writeline(e1.tostring());	}	catch (fileloadexception e2) {	_output.writeline(e2.tostring());	}	}	}	catch (exception e) {	
stack 

private void comparemessages() {	if (ignoremultipledots && _expectedmessage.endswith(".")) _expectedmessage = _expectedmessage.trimend(new char[] { '.' }) + ".";	_expectedmessage = regex.escape(_expectedmessage);	_expectedmessage = _expectedmessage.replace(escape_any, ".*");	_expectedmessage = _expectedmessage.replace(escape_number, @"\d*");	_expectedmessage = _expectedmessage.tolowerinvariant();	_actualmessage = _actualmessage.tolowerinvariant();	if (!platformdetection.isnetnative) {	if (regex.match(_actualmessage, _expectedmessage, regexoptions.singleline).tostring() != _actualmessage) {	_expectedmessage = regex.unescape(_expectedmessage);	
mismatch in error message 

========================= corefx sample_12524 =========================

public void state_1(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeentityref("ent");	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writeentityref("ent");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_2(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writeentityref("ent");	}	catch (invalidoperationexception e) {	
exception 

w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writeentityref("ent");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_3(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writecharentity('\ud23e');	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writecharentity('\ud23e');	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writecharentity('\ud23e');	}	catch (invalidoperationexception e) {	
exception 

w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writecharentity('\ud23e');	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_6(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception e) {	
exception 

w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writesurrogatecharentity('\udf41', '\ud920');	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_7(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartattribute("attr", "");	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartattribute("attr", "");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_8(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writestartattribute("attr", "");	}	catch (invalidoperationexception e) {	
exception 

w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writestartattribute("attr", "");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_9(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writecdata("invalid");	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writecdata("invalid");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_10(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writecdata("invalid");	}	catch (invalidoperationexception e) {	
exception 

w.writestartdocument();	w.writestartelement("root");	w.writeendelement();	w.writecdata("invalid");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_11(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartdocument();	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writestartdocument();	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void state_12(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writedoctype("test", null, null, "");	}	catch (invalidoperationexception e) {	
exception 

using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement("root");	w.writedoctype("test", null, null, "");	}	catch (invalidoperationexception e) {	cerror.compare(w.writestate, writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

========================= corefx sample_12464 =========================

public void createglobalfunctions_singleglobalmethod() {	modulebuilder module = helpers.dynamicmodule();	methodbuilder method = module.defineglobalmethod("testmethod", methodattributes.static | methodattributes.public, null, null);	ilgenerator ilgenerator = method.getilgenerator();	
hello world from global method 

public void createglobalfunctions_multipleglobalmethods() {	modulebuilder module = helpers.dynamicmodule();	methodbuilder method = module.defineglobalmethod("testmethod", methodattributes.static | methodattributes.public, null, null);	ilgenerator ilgenerator = method.getilgenerator();	
hello world from global method 

public void createglobalfunctions_multipleglobalmethods() {	modulebuilder module = helpers.dynamicmodule();	methodbuilder method = module.defineglobalmethod("testmethod", methodattributes.static | methodattributes.public, null, null);	ilgenerator ilgenerator = method.getilgenerator();	ilgenerator.emit(opcodes.ret);	method = module.defineglobalmethod("mymethod2", methodattributes.static | methodattributes.public, null, null);	ilgenerator = method.getilgenerator();	
hello world from global method again 

public void createglobalfunctions_calledmultipletimes_throwsinvalidoperationexception() {	modulebuilder module = helpers.dynamicmodule();	methodbuilder method = module.defineglobalmethod("testmethod", methodattributes.static | methodattributes.public, null, null);	ilgenerator ilgenerator = method.getilgenerator();	
hello world from global method 

========================= corefx sample_13588 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.error) {	
error 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	xmlschemaexception se = args.exception as xmlschemaexception;	errorlinenumbers[errorcount] = se.linenumber;	errorcount++;	
exception message 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	xmlschemaexception se = args.exception as xmlschemaexception;	errorlinenumbers[errorcount] = se.linenumber;	errorcount++;	if (se.innerexception != null) {	
innerexception message 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.error) {	berrorcallback = true;	xmlschemaexception se = args.exception as xmlschemaexception;	errorlinenumbers[errorcount] = se.linenumber;	errorcount++;	if (se.innerexception != null) {	}	
inner exception is null 

========================= corefx sample_12510 =========================

private void dumpmethodinfo(methodinfo mi) {	
method with the params found 

private void dumpmethodinfo(methodinfo mi) {	foreach (var pi in mi.getparameters()) {	
name type 

========================= corefx sample_11588 =========================

public void element_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement(string.empty);	}	catch (argumentexception e) {	
exception 

public void element_4(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement(string.empty);	}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.start : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

public void element_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement(null);	}	catch (argumentexception e) {	
exception 

public void element_5(xmlwriterutils utils) {	using (xmlwriter w = utils.createwriter()) {	try {	w.writestartelement(null);	}	catch (argumentexception e) {	cerror.compare(w.writestate, (utils.writertype == writertype.charcheckingwriter) ? writestate.start : writestate.error, "writestate should be error");	return;	}	}	
did not throw exception 

========================= corefx sample_12470 =========================

paralleloptions.cancellationtoken = cts.token;	counter = 0;	action a2 = delegate {	int incrementedvalue = interlocked.increment(ref counter);	if (incrementedvalue >= 1) cts.cancel();	};	for (int i = 0; i < numactions; i++) actions[i] = a2;	assert.throws<operationcanceledexception>(() => {	parallel.invoke(paralleloptions, actions);	});	
saw counter get incremented to with degrees of parallelism 

========================= corefx sample_1269 =========================

private static hostentry tryparseline(string line) {	line = line.trim();	if (line.startswith("#")) {	return null;	}	string[] items = line.split(s_whitespacechars, stringsplitoptions.removeemptyentries);	if (items.length == 0) {	return null;	}	if (items.length != 2) {	
wrong entry in the hosts file exactly two columns expected line 

string[] items = line.split(s_whitespacechars, stringsplitoptions.removeemptyentries);	if (items.length == 0) {	return null;	}	if (items.length != 2) {	return null;	}	string name = items[1];	ipaddress address;	if (!ipaddress.tryparse(items[0], out address)) {	
wrong entry in the hosts file cannot parse the ip address line 

}	string name = items[1];	ipaddress address;	if (!ipaddress.tryparse(items[0], out address)) {	return null;	}	try {	return new hostentry(name, address);	}	catch (argumentexception e) {	
wrong entry in the hosts file cannot create host entry 

========================= corefx sample_10945 =========================

public void indentchars_6(xmlwriterutils utils, string indentchars) {	xmlwritersettings wsettings = new xmlwritersettings();	wsettings.omitxmldeclaration = true;	wsettings.indent = true;	wsettings.indentchars = indentchars;	xmlwriter w = null;	try {	w = utils.createwriter(wsettings);	}	catch (argumentexception e) {	
exception 

========================= corefx sample_12444 =========================

public void var1() {	xslcompiledtransform xslt = new xslcompiledtransform();	try {	wload(xslt, (methodinfo)null, new byte[5], new type[5]);	}	catch (exception e) {	_output.writeline(e.tostring());	if (e is argumentnullexception || e.innerexception is argumentnullexception) return;	
did not throw argumentnullexception 

public void var2() {	xslcompiledtransform xslt = new xslcompiledtransform();	try {	wload(xslt, amethodinfo, null, new type[5]);	}	catch (exception e) {	_output.writeline(e.tostring());	if (e is argumentexception || e.innerexception is argumentexception) return;	
did not throw argumentnullexception 

public void var0() {	try {	new xslcompiledtransform().load((string)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var1() {	try {	new xslcompiledtransform().load((ixpathnavigable)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var2() {	try {	new xslcompiledtransform().load((xmlreader)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var3() {	try {	new xslcompiledtransform().load((ixpathnavigable)null, xsltsettings.trustedxslt, (xmlresolver)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var4() {	try {	new xslcompiledtransform().load((xmlreader)null, xsltsettings.trustedxslt, (xmlresolver)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var5() {	try {	new xslcompiledtransform().load((ixpathnavigable)null, xsltsettings.trustedxslt, (xmlresolver)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

public void var6() {	try {	new xslcompiledtransform().load((xmlreader)null, xsltsettings.trustedxslt, (xmlresolver)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	stringwriter sw = new stringwriter();	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, sw);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	stringwriter sw = new stringwriter();	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, sw);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

try {	xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, (textwriter)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

try {	xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, (textwriter)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

try {	xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, (stream)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

try {	xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, (stream)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

try {	xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, (xmlwriter)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

try {	xslcompiledtransform xslt = new xslcompiledtransform();	xslt.load(fullfilepath("identity.xsl"));	xslt.transform((ixpathnavigable)null, (xsltargumentlist)null, (xmlwriter)null);	}	catch (argumentnullexception) {	return;	}	catch (exception e) {	_output.writeline(e.tostring());	
did not throw argumentnullexception 

assert.true(false);	}	catch (xsltexception e1) {	_output.writeline(e1.message);	return;	}	catch (argumentnullexception e2) {	_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

public void xmlresolver2(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl("xmlresolver_main.xsl", xslinputtype, readertype, null);	
no exception was thrown 

assert.true(false);	}	catch (xsltexception e1) {	_output.writeline(e1.message);	return;	}	catch (argumentnullexception e2) {	_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

public void xmlresolver3(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	appcontext.setswitch("switch.system.xml.allowdefaultresolver", true);	string baseline = path.combine("baseline", (string)param);	if (loadxsl("xmlresolver_document_function.xsl", xslinputtype, readertype) == 1) {	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1) {	verifyresult(baseline, _stroutfile);	return;	}	}	else {	
problem loading stylesheet with document function and default resolver 

appcontext.setswitch("switch.system.xml.allowdefaultresolver", true);	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result>123</result>";	string filename = gettype().name + "_" + path.getrandomfilename();	string testfile = path.combine(path.gettemppath(), filename);	string xmlfile = fullfilepath(filename);	try {	file.copy(xmlfile, testfile, true);	}	catch (exception e) {	_output.writeline(e.tostring());	
could not copy file to local some other issues prevented this test from running 

file.setattributes(testfile, fileattributes.normal);	file.delete(testfile);	}	}	if (loadxsl("xmlresolver_document_function_absolute_uri.xsl", xslinputtype, readertype) == 1) {	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1) {	verifyresult(expected);	return;	}	else {	
failed to resolve document function with absolute uri 

if (loadxsl("xmlresolver_document_function_absolute_uri.xsl", xslinputtype, readertype) == 1) {	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1) {	verifyresult(expected);	return;	}	else {	assert.true(false);	}	}	else {	
failed to load style sheet 

public void loadgeneric1(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl(null, xslinputtype, readertype);	}	catch (system.argumentexception) {	return;	}	
exception not generated for null parameter name 

try {	transform((string) "fruits.xml", (outputtype) outputtype, navtype);	}	catch (system.invalidoperationexception e) {	checkexpectederror(e, "system.xml", "xslt_nostylesheetloaded", new string[] { "" });	return;	}	}	}	else {	
failed to load style sheet 

string baseline = path.combine("baseline", (string)param);	try {	loadxsl("idontexist.xsl", xslinputtype, readertype);	}	catch (system.io.filenotfoundexception) {	if ((loadxsl("showparam.xsl", xslinputtype, readertype) == 1) && (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1)) {	verifyresult(baseline, _stroutfile);	return;	}	}	
exception not generated for non existent file name 

public void loadgeneric5(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	for (int i = 0; i < 100; i++) {	if (loadxsl("showparam.xsl", xslinputtype, readertype) != 1) {	
failed to load stylesheet showparam xsl on the attempt 

public void loadgeneric6(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl("idontexist.xsl", xslinputtype, readertype);	}	catch (system.io.filenotfoundexception) {	return;	}	
exception not generated for non existent file parameter name 

if (loadxsl("xmlresolver_main.xsl", xslinputtype, readertype) == 1) {	s2 = new filestream(fullfilepath("xmlresolver_sub.xsl"), filemode.open, fileaccess.read);	s2.dispose();	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1) {	verifyresult(expected);	s2 = new filestream(fullfilepath("xmlresolver_include.xsl"), filemode.open, fileaccess.read, fileshare.read);	s2.dispose();	return;	}	}	
appeared to not close file properly after loading 

public void loadgeneric11(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	if (navtype.tostring() == "datadocument") return;	else {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><book> name </book>";	if (loadxsl("books_entity_ref.xsl", xslinputtype.reader, readertype, new xmlurlresolver()) != 1) {	
failed to load stylesheet books entity ref xsl 

public void loadgeneric12(xslinputtype xslinputtype, readertype readertype) {	stream strmtemp;	try {	int i = loadxsl("xslt_error.xsl", xslinputtype, readertype);	}	catch (xsltexception) {	try {	strmtemp = new filestream(fullfilepath("xslt_error.xsl"), filemode.open, fileaccess.read);	}	catch (exception ex) {	
did not close stylesheet properly after load 

catch (xsltexception) {	try {	strmtemp = new filestream(fullfilepath("xslt_error.xsl"), filemode.open, fileaccess.read);	}	catch (exception ex) {	_output.writeline(ex.message);	assert.true(false);	}	return;	}	
did not throw compile exception for stylesheet 

public void loadgeneric1(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl_resolver(null, xslinputtype, readertype, null);	}	catch (system.argumentnullexception e) {	_output.writeline(e.tostring());	return;	}	
passing null argument should have thrown argumentnullexception 

public void loadgeneric2(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl_resolver(null, xslinputtype, readertype, new xmlurlresolver());	}	catch (system.argumentnullexception e) {	_output.writeline(e.tostring());	return;	}	
passing null stylesheet should have thrown argumentnullexception 

try {	loadxsl_resolver("showparam.xsl", xslinputtype, readertype, null);	transform((string) "fruits.xml", (outputtype) outputtype, navtype);	verifyresult(baseline, _stroutfile);	return;	}	catch (argumentnullexception e) {	_output.writeline(e.tostring());	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

public void loadgeneric4(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl_resolver("xmlresolver_main.xsl", xslinputtype, readertype, null);	
no exception was thrown when a null resolver is passed 

assert.true(false);	}	catch (xsltexception e1) {	_output.writeline(e1.message);	return;	}	catch (argumentnullexception e2) {	_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

public void loadgeneric5(xslinputtype xslinputtype, readertype readertype) {	customnullresolver myresolver = new customnullresolver(_output);	try {	loadxsl_resolver("xmlresolver_main.xsl", xslinputtype, readertype, myresolver);	
no exception is thrown 

assert.true(false);	}	catch (xsltexception e1) {	_output.writeline(e1.message);	return;	}	catch (argumentnullexception e2) {	_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	assert.true(false);	}	}	catch (xmlexception e3) {	_output.writeline(e3.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
xmlexception is not supposed to be thrown for the input type 

try {	loadxsl_resolver("showparam.xsl", xslinputtype, readertype, myresolver);	transform((string) "fruits.xml", (outputtype) outputtype, navtype);	verifyresult(baseline, _stroutfile);	return;	}	catch (argumentnullexception e) {	_output.writeline(e.tostring());	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

_output.writeline(e.tostring());	if (xslinputtype == xslinputtype.uri) return;	else {	assert.true(false);	}	}	catch (xsltexception e3) {	_output.writeline(e3.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
xmlexception is not supposed to be thrown for the input type 

checkexpectederror(e1, "system.xml", "xslt_cannotloadstylesheet", new string[] { new uri(uri.urischemefile + uri.schemedelimiter + path.getfullpath(fullfilepath("xmlresolver_main.xsl"))).tostring(), "null" });	}	if (loadxsl("xmlresolver_main.xsl", xslinputtype, readertype) == 1) {	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1) {	verifyresult(expected);	return;	}	else assert.true(false);	}	else {	
failed to load stylesheet using default resolver 

checkexpectederror(e2, "system.xml", "xslt_cannotloadstylesheet", new string[] { new uri(uri.urischemefile + uri.schemedelimiter + path.getfullpath(fullfilepath("xmlresolver_main.xsl"))).tostring(), "null" });	}	if (loadxsl("xmlresolver_main.xsl", xslinputtype, readertype) == 1) {	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1) {	verifyresult(baseline, _stroutfile);	return;	}	else assert.true(false);	}	else {	
failed to load stylesheet using default resolver 

else assert.true(false);	}	else {	assert.true(false);	}	}	catch (xmlexception e3) {	_output.writeline(e3.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
xmlexception is not supposed to be thrown for the input type 

}	catch (xunit.sdk.trueexception) {	checkexpectederror(e1, "system.xml", "xslt_cannotloadstylesheet", new string[] { new uri(uri.urischemefile + uri.schemedelimiter + path.getfullpath(fullfilepath("xmlresolver_main.xsl"))).tostring(), "null" });	return;	}	}	catch (argumentnullexception e2) {	_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	assert.true(false);	}	}	catch (xmlexception e3) {	_output.writeline(e3.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
xmlexception is not supposed to be thrown for the input type 

assert.true(false);	}	}	catch (xmlexception e3) {	_output.writeline(e3.message);	if (xslinputtype == xslinputtype.uri) return;	else {	assert.true(false);	}	}	
no exception generated when loading with an invalid resolver after loading with valid resolver 

}	catch (xmlexception e3) {	_output.writeline(e3.message);	if (xslinputtype == xslinputtype.uri) return;	else {	assert.true(false);	}	}	assert.true(false);	}	
could not load style sheet with default resolver 

public void loadgeneric9(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result><fruit>apple</fruit><fruit>orange</fruit></result>";	if ((loadxsl_resolver("xmlresolver_main.xsl", xslinputtype, readertype, getdefaultcredresolver()) == 1)) {	if ((loadxsl("xmlresolver_main.xsl", xslinputtype, readertype) == 1) && (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1)) {	verifyresult(expected);	return;	}	}	else {	
failed to load 

public void loadgeneric11(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl_resolver("idontexist.xsl", xslinputtype, readertype, null);	
no exception was thrown 

assert.true(false);	}	catch (filenotfoundexception e1) {	_output.writeline(e1.message);	return;	}	catch (argumentnullexception e2) {	_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

public void loadurlresolver2(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl_resolver(path.combine("xmlresolver", "xmlresolvertestmain.xsl"), xslinputtype, readertype, null);	}	catch (xsltexception e) {	_output.writeline(e.tostring());	return;	}	
passing null resolver should have thrown xsltexception 

public void loadurlresolver3(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl_resolver(null, xslinputtype, readertype, new xmlurlresolver());	}	catch (argumentnullexception e) {	_output.writeline(e.tostring());	return;	}	
passing null stylesheet parameter should have thrown argumentnullexception 

public void loadurl1(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl("idontexist.xsl", xslinputtype.uri, readertype, new xmlurlresolver());	
no exception was thrown 

public void loadurl1(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl("idontexist.xsl", xslinputtype.uri, readertype, new xmlurlresolver());	assert.true(false);	}	catch (filenotfoundexception e1) {	_output.writeline(e1.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
filenotfoundexception is supposed to be thrown 

_output.writeline(e1.message);	if (xslinputtype == xslinputtype.uri) return;	else {	assert.true(false);	}	}	catch (argumentnullexception e2) {	_output.writeline(e2.message);	if (xslinputtype == xslinputtype.uri) return;	else {	
argumentnullexception is not supposed to be thrown for the input type 

public void loadurl2(readertype readertype) {	try {	loadxsl(szempty, xslinputtype.uri, readertype, new xmlurlresolver());	}	catch (system.argumentexception) {	return;	}	
exception not generated for an empty string filename 

public void loadurl3(readertype readertype) {	try {	loadxsl(".", xslinputtype.uri, readertype, new xmlurlresolver());	}	catch (system.unauthorizedaccessexception) {	return;	}	
exception not generated for non existent file parameter name 

public void loadurl(readertype readertype) {	try {	loadxsl("..", xslinputtype.uri, readertype, new xmlurlresolver());	}	catch (system.unauthorizedaccessexception) {	return;	}	
exception not generated for non existent file parameter name 

public void loadurl5(readertype readertype) {	try {	loadxsl("    ", xslinputtype.uri, readertype, new xmlurlresolver());	}	catch (system.argumentexception) {	return;	}	
exception not generated for non existent file parameter name 

public void loadnavigator1(object param, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	xslt = new xslcompiledtransform();	string _strxslfile = "showparam.xsl";	_strxslfile = fullfilepath(_strxslfile);	
compiling 

#pragma warning disable 0618 xrs.prohibitdtd = false;	#pragma warning restore 0618 xmlreader xrtemp = xmlreader.create(fullfilepath("showparam.xsl"), xrs);	xrtemp.dispose();	try {	xslt.load(xrtemp);	}	catch (system.xml.xsl.xsltexception e) {	checkexpectederror(e, "system.xml", "xslt_wrongstylesheetelement", new string[] { "" });	return;	}	
no exception thrown for a loading a closed reader 

}	catch (exception ex) {	ftest_fail = true;	throw (ex);	}	finally {	if (!ftest_fail || (xrtemp.readstate != readstate.closed)) ftest_fail = false;	xrtemp.dispose();	}	if (ftest_fail) {	
appear to have accidentally closed the reader 

}	catch (exception ex) {	ftest_fail = true;	throw (ex);	}	finally {	if (!ftest_fail && (!xrtemp.eof)) ftest_fail = false;	xrtemp.dispose();	}	if (ftest_fail) {	
reader does not appear to be at the end of file 

public void loadxmlreader6() {	xslt = new xslcompiledtransform();	xmltextreader xrtemp = null;	try {	xslt.load(xrtemp);	}	catch (system.argumentnullexception) {	return;	}	
failed to throw system argumentnullexception for null reader input 

public void transformgeneric3(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	string baseline = path.combine("baseline", (string)param);	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	for (int i = 0; i < 100; i++) {	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) != 1) {	
test failed to transform after iterations 

public void transformgeneric4(outputtype outputtype, navtype navtype) {	xslt = new xslcompiledtransform();	try {	transform((string) "fruits.xml", (outputtype) outputtype, navtype);	}	catch (system.invalidoperationexception e) {	checkexpectederror(e, "system.xml", "xslt_nostylesheetloaded", new string[] { "" });	return;	}	
exception not given for a transform that didn t have a load method instantiated 

public void transformgeneric5(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	filestream s2;	if ((loadxsl("showparam.xsl", xslinputtype, readertype) == 1) && (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1)) {	s2 = new filestream(fullfilepath("showparam.xsl"), filemode.open, fileaccess.read);	s2.dispose();	s2 = new filestream(fullfilepath("fruits.xml"), filemode.open, fileaccess.read);	s2.dispose();	return;	}	
encountered errors performing transform and could not verify if files were closed 

public void transformgeneric7(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	try {	loadxsl("forwardcomp.xsl", xslinputtype, readertype);	transform((string) "data.xml", (outputtype) outputtype, navtype);	}	catch (xsltexception e) {	checkexpectederror(e, "system.xml", "xpath_scientificnotation", new string[] { "" });	return;	}	
xsltexception xpath scientificnotation was expected 

public void transformgeneric9(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	try {	loadxsl("rootnodeatt.xsl", xslinputtype, readertype);	transform((string) "data.xml", (outputtype) outputtype, navtype);	}	catch (xsltexception e) {	checkexpectederror(e, "system.xml", "xmlil_badxmlstate", new string[] { "attribute", "root" });	return;	}	
xsltransformexception xmlil badxmlstate was expected 

public void transformgeneric11(xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	try {	loadxsl("bug369463.xsl", xslinputtype, readertype);	transform((string) "data.xml", (outputtype) outputtype, navtype);	}	catch (xsltexception e) {	checkexpectederror(e, "system.xml", "xpath_unexpectedtoken", new string[] { "+" });	return;	}	
xslexception xpath unexpectedtoken was expected 

public void xmlresolver2(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	appcontext.setswitch("switch.system.xml.allowdefaultresolver", true);	string baseline = path.combine("baseline", (string)param);	if (loadxsl("xmlresolver_document_function.xsl", xslinputtype, readertype) == 1) {	if (transformresolver("fruits.xml", outputtype, navtype, null) == 1) {	verifyresult(baseline, _stroutfile);	return;	}	}	else {	
problem loading stylesheet 

public void xmlresolver3(object param, xslinputtype xslinputtype, readertype readertype, outputtype outputtype, navtype navtype) {	appcontext.setswitch("switch.system.xml.allowdefaultresolver", true);	string baseline = path.combine("baseline", (string)param);	if (loadxsl("xmlresolver_document_function.xsl", xslinputtype, readertype) == 1) {	if (transform((string) "fruits.xml", (outputtype) outputtype, navtype) == 1) {	verifyresult(baseline, _stroutfile);	return;	}	}	else {	
problem loading stylesheet with document function and default resolver 

appcontext.setswitch("switch.system.xml.allowdefaultresolver", true);	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result>123</result>";	string filename = gettype().name + "_" + path.getrandomfilename();	string testfile = path.combine(path.gettemppath(), filename);	string xmlfile = fullfilepath(filename);	try {	file.copy(xmlfile, testfile, true);	}	catch (exception e) {	_output.writeline(e.tostring());	
could not copy file to local some other issues prevented this test from running 

file.setattributes(testfile, fileattributes.normal);	file.delete(testfile);	}	}	if (loadxsl("xmlresolver_document_function_absolute_uri.xsl", xslinputtype, readertype) == 1) {	if (transformresolver("fruits.xml", outputtype, navtype, new xmlurlresolver()) == 1) {	verifyresult(expected);	return;	}	else {	
failed to resolve document function with absolute uri 

if (loadxsl("xmlresolver_document_function_absolute_uri.xsl", xslinputtype, readertype) == 1) {	if (transformresolver("fruits.xml", outputtype, navtype, new xmlurlresolver()) == 1) {	verifyresult(expected);	return;	}	else {	assert.true(false);	}	}	else {	
failed to load style sheet 

public void transformstrstr2(xslinputtype xslinputtype, readertype readertype) {	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	try {	xslt.transform(null, _stroutfile);	}	catch (system.argumentexception) { return; }	}	
exception not generated for null input filename 

public void transformstrstr3(xslinputtype xslinputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	try {	xslt.transform(szfullfilename, (string)null);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for null output filename 

public void transformstrstr4(xslinputtype xslinputtype, readertype readertype) {	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	try {	xslt.transform("idontexist.xsl", _stroutfile);	}	catch (system.io.filenotfoundexception) {	return;	}	}	
exception not generated for invalid input file 

public void transformstrstr5(xslinputtype xslinputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	try {	xslt.transform(szfullfilename, szinvalid);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for invalid output destination 

public void transformstrstr6(xslinputtype xslinputtype, readertype readertype) {	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	try {	xslt.transform(szempty, _stroutfile);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for empty string input file 

public void transformstrstr7(xslinputtype xslinputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	try {	xslt.transform(szfullfilename, szempty);	}	catch (system.argumentexception) {	return;	}	}	
exception not generated for empty output file name 

public void transformstrstr9() {	xslt = new xslcompiledtransform();	setexpectederror("xslt_nostylesheetloaded");	try {	xslt.transform(fullfilepath("fruits.xml"), _stroutfile);	}	catch (system.invalidoperationexception e) {	checkexpectederror(e, "system.xml", "xslt_nostylesheetloaded", new string[] { "" });	return;	}	
exception attempting a transform without loading an xsl file 

public void transformstrstr10(xslinputtype xslinputtype, readertype readertype) {	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	try {	xslt.transform("fruits.xml", "http: }	catch (system.exception e) {	_output.writeline(e.tostring());	return;	}	}	
exception not generated for invalid output destination 

icount++;	}	try {	xslt.transform("\\\\", _stroutfile);	}	catch (system.exception) {	icount++;	}	}	if (icount.equals(3)) return;	
exception not generated for invalid input sources 

icount++;	}	try {	xslt.transform(szfullfilename, ".");	}	catch (system.exception) {	icount++;	}	}	if (icount.equals(2)) return;	
exception not generated for invalid ouput destinations 

public void transformstrstr12_win(xslinputtype xslinputtype, readertype readertype) {	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("showparam.xsl", xslinputtype, readertype) == 1) {	assert.throws<system.argumentexception>(() => xslt.transform(szfullfilename, "    "));	return;	}	
exception not generated for invalid ouput destinations 

public void transformstrstrresolver2(xslinputtype xslinputtype, readertype readertype) {	appcontext.setswitch("switch.system.xml.allowdefaultresolver", true);	string expected = @"<?xml version=""1.0"" encoding=""utf-8""?><result><elem>1</elem><elem>2</elem><elem>3</elem></result>";	string szfullfilename = fullfilepath("fruits.xml");	if (loadxsl("xmlresolver_document_function.xsl", xslinputtype, readertype) == 1) {	xslt.transform(szfullfilename, "out.xml");	verifyresult(expected);	}	else {	
problem loading stylesheet 

public void transformstrstrresolver3(object param, xslinputtype xslinputtype, readertype readertype) {	appcontext.setswitch("switch.system.xml.allowdefaultresolver", true);	string szfullfilename = fullfilepath("fruits.xml");	string baseline = path.combine("baseline", (string)param);	if (loadxsl("xmlresolver_document_function.xsl", xslinputtype, readertype) == 1) {	xslt.transform(szfullfilename, "out.xml");	verifyresult(baseline, _stroutfile);	return;	}	else {	
problem loading stylesheet with document function and default resolver 

public void validcases(object param0, object param1, object param2, object param3, object param4, object param5) {	string xslfile = fullfilepath(param0 as string);	string xmlfile = fullfilepath(param1 as string);	string baselinefile = path.combine("baseline", param2 as string);	bool expectedresult = (bool)param4;	bool actualresult = false;	xmlreader xmlreader = xmlreader.create(xmlfile);	ixpathnavigable navigator = null;	random randgenerator = new random(unchecked((int)datetime.now.ticks));	switch (randgenerator.next(2)) {	
using xmldocument createnavigator 

bool expectedresult = (bool)param4;	bool actualresult = false;	xmlreader xmlreader = xmlreader.create(xmlfile);	ixpathnavigable navigator = null;	random randgenerator = new random(unchecked((int)datetime.now.ticks));	switch (randgenerator.next(2)) {	xmldocument xmldoc = new xmldocument();	xmldoc.load(xmlfile);	navigator = xmldoc.createnavigator();	break;	
using xpathdocument createnavigator 

public void regressiontest3(xslinputtype xslinputtype, readertype readertype) {	try {	loadxsl("bug370868.xsl", xslinputtype, readertype);	}	catch (system.xml.xsl.xsltexception e) {	if (e.linenumber == 3 && e.lineposition == 2) return;	
linenumber and position were incorrect expected actual 

========================= corefx sample_12637 =========================

public static void indent_roundtripsandaffectsoutput(int indent) {	const string tabstring = "\t\t";	var sb = new stringbuilder();	var sw = new stringwriter(sb);	var itw = new indentedtextwriter(sw, tabstring);	itw.indent = indent;	assert.equal(indent >= 0 ? indent : 0, itw.indent);	
first 

public static void indent_roundtripsandaffectsoutput(int indent) {	const string tabstring = "\t\t";	var sb = new stringbuilder();	var sw = new stringwriter(sb);	var itw = new indentedtextwriter(sw, tabstring);	itw.indent = indent;	assert.equal(indent >= 0 ? indent : 0, itw.indent);	
second 

public static void indent_roundtripsandaffectsoutput(int indent) {	const string tabstring = "\t\t";	var sb = new stringbuilder();	var sw = new stringwriter(sb);	var itw = new indentedtextwriter(sw, tabstring);	itw.indent = indent;	assert.equal(indent >= 0 ? indent : 0, itw.indent);	
third 

public static void tabstring_usesprovidedstring(string tabstring) {	var sb = new stringbuilder();	var sw = new stringwriter(sb);	using (var itw = tabstring == null ? new indentedtextwriter(sw) : new indentedtextwriter(sw, tabstring)) {	itw.indent = 1;	if (tabstring == null) {	tabstring = indentedtextwriter.defaulttabstring;	}	itw.writeline();	
should be indented 

itw.writeline("{0} {1} {2}", 15, 16, 17);	itw.writeline("{0} {1} {2} {3}", 15, 16, 17, 18);	await itw.writeasync('a');	await itw.writeasync(new char[] { 'b', 'c' });	await itw.writeasync(new char[] { 'd', 'e' }, 0, 2);	await itw.writeasync("1");	await itw.writelineasync('a');	await itw.writelineasync(new char[] { 'b', 'c' });	await itw.writelineasync(new char[] { 'd', 'e' }, 0, 2);	await itw.writelineasync("1");	
notabs 

========================= corefx sample_2418 =========================

public static void taskwait_maxint32() {	task t = task.delay(1);	
wait with int maxvalue 

}	return "done";	}, j, cts[j].token). continuewith((task, o) => {	int d = (int)o;	interlocked.add(ref data, d);	}, j, cancellationtoken.none, taskcontinuationoptions.onlyoncanceled, taskscheduler.default).wait(int32.maxvalue - 1, cts2.token);	});	alltasks[i].start(scheduler.concurrentscheduler);	}	task.waitall(alltasks, int.maxvalue - 1, cancellationtoken.none);	
tasks ended result 

whenalltaskresult.add(task<int?>.factory.startnew((o) => { mre.waitone((int)o); return task.currentid; }, 10));	whenalltaskresult.add(task<int?>.factory.startnew((o) => { mre.waitone((int)o); return task.currentid; }, 10));	t1.wait(5, cts.token);	task.whenall(whenalltaskresult).continuewith((task) => { taskid12 = task.result[0]; taskid22 = task.result[1]; mre.set(); });	try {	t2.wait(cts.token);	}	catch (system.operationcanceledexception) { }	assert.notequal<int?>(taskid1, taskid2);	assert.notequal<int?>(taskid12, taskid22);	
waiting on continuation task that should move into the cancelled state 

task<int?> t11 = task.factory.startnew(() => { mre2.waitone(); return task.currentid; });	task<int?> t21 = task.factory.startnew(() => { mre2.waitone(); return task.currentid; });	task[] waitany = new task[] { t1, t2 };	int timeout = task.waitany(waitany, 1, cts.token);	task.factory.startnew(() => { task.delay(20); mre.set(); });	list<task> whenanytask = new list<task>(); whenanytask.add(t1); whenanytask.add(t2);	list<task<int?>> whenanytaskresult = new list<task<int?>>(); whenanytaskresult.add(t11); whenanytaskresult.add(t21);	int? taskid = 0;	task waitonit = task.whenany(whenanytaskresult).continuewith((task) => { taskid = task.result.result; });	task.whenany(whenanytask).continuewith((task) => { mre2.set(); });	
wait on the scenario to finish 

public static void cancellationtokenregitration() {	manualresetevent mre = new manualresetevent(false);	manualresetevent mre2 = new manualresetevent(false);	cancellationtokensource cts = new cancellationtokensource();	cts.token.register((o) => { mre.set(); }, 1, true);	cts.cancelafter(5);	
wait on the scenario to finish 

public static void taskawaiter() {	manualresetevent mre = new manualresetevent(false);	manualresetevent mre2 = new manualresetevent(false);	manualresetevent mre3 = new manualresetevent(false);	task t1 = task.factory.startnew(() => { mre.waitone(); });	task<int> t11 = task.factory.startnew(() => { mre.waitone(); return 1; });	t1.getawaiter().unsafeoncompleted(() => { mre2.set(); });	t11.getawaiter().unsafeoncompleted(() => { mre3.set(); });	mre.set();	
wait on the scenario to finish 

public static void taskconfigurableawaiter() {	manualresetevent mre = new manualresetevent(false);	manualresetevent mre2 = new manualresetevent(false);	manualresetevent mre3 = new manualresetevent(false);	task t1 = task.factory.startnew(() => { mre.waitone(); });	task<int> t11 = task.factory.startnew(() => { mre.waitone(); return 1; });	t1.configureawait(false).getawaiter().unsafeoncompleted(() => { mre2.set(); });	t11.configureawait(false).getawaiter().unsafeoncompleted(() => { mre3.set(); });	mre.set();	
wait on the scenario to finish 

public static void fromasync() {	task emptytask = new task(() => { });	manualresetevent mre1 = new manualresetevent(false);	manualresetevent mre2 = new manualresetevent(false);	task.factory.fromasync(emptytask, (iar) => { mre1.set(); }, taskcreationoptions.none, taskscheduler.current);	task<int>.factory.fromasync(emptytask, (iar) => { mre2.set(); return 1; }, taskcreationoptions.none, taskscheduler.current);	emptytask.start();	
wait on the scenario to finish 

========================= corefx sample_3995 =========================

public async task usecallback_notsecureconnection_callbacknotcalled() {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof usecallback notsecureconnection callbacknotcalled 

public async task usecallback_validcertificate_expectedvaluesduringcallback(uri url, bool checkrevocation) {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof usecallback validcertificate expectedvaluesduringcallback url checkrevocation 

public async task usecallback_callbackreturnsfailure_throwsexception() {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof usecallback callbackreturnsfailure throwsexception 

public async task usecallback_callbackthrowsexception_exceptionpropagatesasbaseexception() {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof usecallback callbackthrowsexception exceptionpropagatesasbaseexception 

public async task nocallback_revokedcertificate_revocationchecking_fails() {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof nocallback revokedcertificate revocationchecking fails 

private async task usecallback_badcertificate_expectedpolicyerrors_helper(string url, bool usesocketshttphandler, sslpolicyerrors expectederrors) {	if (!backendsupportscustomcertificatehandling) {	
skipping nameof usecallback badcertificate expectedpolicyerrors url expectederrors 

========================= corefx sample_376 =========================

private void dualmodeconnect_acceptasync_helper(ipaddress listenon, ipaddress connectto) {	using (socket serversocket = new socket(sockettype.stream, protocoltype.tcp)) {	int port = serversocket.bindtoanonymousport(listenon);	serversocket.listen(1);	socketasynceventargs args = new socketasynceventargs();	args.completed += asynccompleted;	manualresetevent waithandle = new manualresetevent(false);	args.usertoken = waithandle;	args.socketerror = socketerror.socketerror;	
socketasynceventargs with manual event 

private void accepted(object sender, socketasynceventargs e) {	eventwaithandle handle = (eventwaithandle)e.usertoken;	
accepted socketasynceventargs with manual event error 

private void connected(object sender, socketasynceventargs e) {	eventwaithandle handle = (eventwaithandle)e.usertoken;	
connected socketasynceventargs with manual event error 

private void received(object sender, socketasynceventargs e) {	eventwaithandle handle = (eventwaithandle)e.usertoken;	
received socketasynceventargs with manual event error 

protected void asynccompleted(object sender, socketasynceventargs e) {	eventwaithandle handle = (eventwaithandle)e.usertoken;	
asynccompleted socketasynceventargs with manual event error 

========================= corefx sample_8315 =========================

dynamic d = new target();	int x = 3;	bool ret = true;	try {	char s = d[x, x];	d[x, x] = 'a';	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	ret = errorverifier.verify(errormessageid.ambigcall, ex.message, "target.this[int, float]", "target.this[float, int]");	if (ret) return 0;	
unexpected error message 

int ret = 0;	bool b = true;	try {	d[x, x] = 'a';	ret = 1;	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	b = errorverifier.verify(errormessageid.ambigcall, ex.message, "target.this[int, object]", "target.this[object, int]");	if (!b) {	ret = 1;	
unexpected error message 

}	s = d[o, x];	if (s != 'b' || target.status != 5) ret = 1;	try {	d[x, x] = 'a';	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	b = errorverifier.verify(errormessageid.ambigcall, ex.message, "target.this[int, object]", "target.this[object, int]");	if (!b) {	ret = 1;	
unexpected error message 

========================= corefx sample_105 =========================

public void legacynestedtxscope() {	string txid1 = null;	string txid2 = null;	string txid3 = null;	string txid4 = null;	string txid5 = null;	string txid6 = null;	
running nestedscopetest 

public static void handleexception(bool exceptiondefaultorbeforeawait, bool exceptionafterawait, action action) {	bool hasexception = false;	setexceptioninjection(exceptiondefaultorbeforeawait, exceptionafterawait);	try {	action.invoke();	}	catch (exception ex) {	hasexception = true;	
exception 

========================= corefx sample_1566 =========================

public async task serverrequireencryption_clientrequireencryption_connectwithencryption() {	using (var serverrequireencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.requireencryption)) using (var client = new tcpclient()) {	await client.connectasync(serverrequireencryption.remoteendpoint.address, serverrequireencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null, encryptionpolicy.requireencryption)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

public async task serverrequireencryption_clientallownoencryption_connectwithencryption() {	using (var serverrequireencryption = new dummytcpserver( new ipendpoint(ipaddress.loopback, 0), encryptionpolicy.requireencryption)) using (var client = new tcpclient()) {	await client.connectasync(serverrequireencryption.remoteendpoint.address, serverrequireencryption.remoteendpoint.port);	using (var sslstream = new sslstream(client.getstream(), false, allowanyservercertificate, null, encryptionpolicy.allownoencryption)) {	await sslstream.authenticateasclientasync("localhost", null, sslprotocolsupport.defaultsslprotocols, false);	
client authenticated to server with encryption cipher bit strength 

========================= corefx sample_8127 =========================

public void randomoperationstest() {	int operationcount = this.randomoperationscount;	var expected = new list<int>();	var actual = immutablelist<int>.empty;	int seed = unchecked((int)datetime.now.ticks);	
using random seed 

public void randomoperationstest() {	int operationcount = this.randomoperationscount;	var expected = new list<int>();	var actual = immutablelist<int>.empty;	int seed = unchecked((int)datetime.now.ticks);	var random = new random(seed);	for (int iop = 0; iop < operationcount; iop++) {	switch ((operation)random.next((int)operation.last)) {	case operation.add: int value = random.next();	
adding to the list 

var random = new random(seed);	for (int iop = 0; iop < operationcount; iop++) {	switch ((operation)random.next((int)operation.last)) {	case operation.add: int value = random.next();	expected.add(value);	actual = actual.add(value);	verifybalanced(actual);	break;	case operation.addrange: int inputlength = random.next(100);	int[] values = enumerable.range(0, inputlength).select(i => random.next()).toarray();	
adding elements to the list 

verifybalanced(actual);	break;	case operation.addrange: int inputlength = random.next(100);	int[] values = enumerable.range(0, inputlength).select(i => random.next()).toarray();	expected.addrange(values);	actual = actual.addrange(values);	verifybalanced(actual);	break;	case operation.insert: int position = random.next(expected.count + 1);	value = random.next();	
adding to position in the list 

break;	case operation.insert: int position = random.next(expected.count + 1);	value = random.next();	expected.insert(position, value);	actual = actual.insert(position, value);	verifybalanced(actual);	break;	case operation.insertrange: inputlength = random.next(100);	values = enumerable.range(0, inputlength).select(i => random.next()).toarray();	position = random.next(expected.count + 1);	
adding elements to position in the list 

break;	case operation.insertrange: inputlength = random.next(100);	values = enumerable.range(0, inputlength).select(i => random.next()).toarray();	position = random.next(expected.count + 1);	expected.insertrange(position, values);	actual = actual.insertrange(position, values);	verifybalanced(actual);	break;	case operation.removeat: if (expected.count > 0) {	position = random.next(expected.count);	
removing element at position from the list 

break;	case operation.removeat: if (expected.count > 0) {	position = random.next(expected.count);	expected.removeat(position);	actual = actual.removeat(position);	verifybalanced(actual);	}	break;	case operation.removerange: position = random.next(expected.count);	inputlength = random.next(expected.count - position);	
removing elements starting at position from the list 

public void addrangebalancetest() {	int randseed = unchecked((int)datetime.now.ticks);	
random seed 

public void addrangebalancetest() {	int randseed = unchecked((int)datetime.now.ticks);	var random = new random(randseed);	int expectedtotalsize = 0;	var list = immutablelist<int>.empty;	for (int i = 0; i < 128; i++) {	int batchsize = random.next(32);	
adding elements to the list 

var random = new random(randseed);	int expectedtotalsize = 0;	var list = immutablelist<int>.empty;	for (int i = 0; i < 128; i++) {	int batchsize = random.next(32);	list = list.addrange(enumerable.range(expectedtotalsize + 1, batchsize));	verifybalanced(list);	expectedtotalsize += batchsize;	}	int largebatchsize = random.next(32768) + 32768;	
adding elements to the list 

public void insertrangerandombalancetest() {	int randseed = unchecked((int)datetime.now.ticks);	
random seed 

========================= corefx sample_7308 =========================

private void dispose(bool disposing) {	#if debug && finalization_watch if (!disposing && _nativegraphics != intptr.zero) {	
system drawing graphics 

private void dispose(bool disposing) {	#if debug && finalization_watch if (!disposing && _nativegraphics != intptr.zero) {	
system drawing graphics object disposed through finalization 

========================= corefx sample_10398 =========================

try {	sqlcommand command = new sqlcommand(generatecommandtext(), connection);	connection.open();	iasyncresult result = command.beginexecutenonquery();	while (!result.iscompleted) {	system.threading.thread.sleep(100);	}	assert.true(command.endexecutenonquery(result) > 0, "failed: beginexecutenonquery did not complete successfully.");	}	catch (sqlexception ex) {	
error 

iasyncresult result = command.beginexecutenonquery();	while (!result.iscompleted) {	system.threading.thread.sleep(100);	}	assert.true(command.endexecutenonquery(result) > 0, "failed: beginexecutenonquery did not complete successfully.");	}	catch (sqlexception ex) {	assert.null(ex);	}	catch (invalidoperationexception ex) {	
error 

}	assert.true(command.endexecutenonquery(result) > 0, "failed: beginexecutenonquery did not complete successfully.");	}	catch (sqlexception ex) {	assert.null(ex);	}	catch (invalidoperationexception ex) {	assert.null(ex);	}	catch (exception ex) {	
error 

========================= corefx sample_11062 =========================

private async task serverasyncsslhelper( sslprotocols clientsslprotocols, sslprotocols serversslprotocols, bool expectedtofail = false) {	
server client expectedtofail 

ipendpoint endpoint = new ipendpoint(ipaddress.ipv6loopback, 0);	var server = new tcplistener(endpoint);	server.start();	using (var clientconnection = new tcpclient(addressfamily.internetworkv6)) {	ipendpoint serverendpoint = (ipendpoint)server.localendpoint;	task clientconnect = clientconnection.connectasync(serverendpoint.address, serverendpoint.port);	task<tcpclient> serveraccept = server.accepttcpclientasync();	await task.whenall(new task[] { clientconnect, serveraccept }).timeoutafter( testconfiguration.passingtesttimeoutmilliseconds);	using (tcpclient serverconnection = await serveraccept) using (sslstream sslclientstream = new sslstream(clientconnection.getstream())) using (sslstream sslserverstream = new sslstream( serverconnection.getstream(), false, allowanyservercertificate)) {	string servername = _servercertificate.getnameinfo(x509nametype.simplename, false);	
serverasyncauthenticatetest authenticateasclientasync start 

var server = new tcplistener(endpoint);	server.start();	using (var clientconnection = new tcpclient(addressfamily.internetworkv6)) {	ipendpoint serverendpoint = (ipendpoint)server.localendpoint;	task clientconnect = clientconnection.connectasync(serverendpoint.address, serverendpoint.port);	task<tcpclient> serveraccept = server.accepttcpclientasync();	await task.whenall(new task[] { clientconnect, serveraccept }).timeoutafter( testconfiguration.passingtesttimeoutmilliseconds);	using (tcpclient serverconnection = await serveraccept) using (sslstream sslclientstream = new sslstream(clientconnection.getstream())) using (sslstream sslserverstream = new sslstream( serverconnection.getstream(), false, allowanyservercertificate)) {	string servername = _servercertificate.getnameinfo(x509nametype.simplename, false);	task clientauthentication = sslclientstream.authenticateasclientasync( servername, null, clientsslprotocols, false);	
serverasyncauthenticatetest authenticateasserverasync start 

ipendpoint serverendpoint = (ipendpoint)server.localendpoint;	task clientconnect = clientconnection.connectasync(serverendpoint.address, serverendpoint.port);	task<tcpclient> serveraccept = server.accepttcpclientasync();	await task.whenall(new task[] { clientconnect, serveraccept }).timeoutafter( testconfiguration.passingtesttimeoutmilliseconds);	using (tcpclient serverconnection = await serveraccept) using (sslstream sslclientstream = new sslstream(clientconnection.getstream())) using (sslstream sslserverstream = new sslstream( serverconnection.getstream(), false, allowanyservercertificate)) {	string servername = _servercertificate.getnameinfo(x509nametype.simplename, false);	task clientauthentication = sslclientstream.authenticateasclientasync( servername, null, clientsslprotocols, false);	task serverauthentication = sslserverstream.authenticateasserverasync( _servercertificate, true, serversslprotocols, false);	try {	await clientauthentication.timeoutafter(timeout);	
serverasyncauthenticatetest clientauthentication complete 

task<tcpclient> serveraccept = server.accepttcpclientasync();	await task.whenall(new task[] { clientconnect, serveraccept }).timeoutafter( testconfiguration.passingtesttimeoutmilliseconds);	using (tcpclient serverconnection = await serveraccept) using (sslstream sslclientstream = new sslstream(clientconnection.getstream())) using (sslstream sslserverstream = new sslstream( serverconnection.getstream(), false, allowanyservercertificate)) {	string servername = _servercertificate.getnameinfo(x509nametype.simplename, false);	task clientauthentication = sslclientstream.authenticateasclientasync( servername, null, clientsslprotocols, false);	task serverauthentication = sslserverstream.authenticateasserverasync( _servercertificate, true, serversslprotocols, false);	try {	await clientauthentication.timeoutafter(timeout);	}	catch (exception ex) {	
client exception 

using (tcpclient serverconnection = await serveraccept) using (sslstream sslclientstream = new sslstream(clientconnection.getstream())) using (sslstream sslserverstream = new sslstream( serverconnection.getstream(), false, allowanyservercertificate)) {	string servername = _servercertificate.getnameinfo(x509nametype.simplename, false);	task clientauthentication = sslclientstream.authenticateasclientasync( servername, null, clientsslprotocols, false);	task serverauthentication = sslserverstream.authenticateasserverasync( _servercertificate, true, serversslprotocols, false);	try {	await clientauthentication.timeoutafter(timeout);	}	catch (exception ex) {	}	await serverauthentication.timeoutafter(timeout);	
serverasyncauthenticatetest serverauthentication complete 

using (tcpclient serverconnection = await serveraccept) using (sslstream sslclientstream = new sslstream(clientconnection.getstream())) using (sslstream sslserverstream = new sslstream( serverconnection.getstream(), false, allowanyservercertificate)) {	string servername = _servercertificate.getnameinfo(x509nametype.simplename, false);	task clientauthentication = sslclientstream.authenticateasclientasync( servername, null, clientsslprotocols, false);	task serverauthentication = sslserverstream.authenticateasserverasync( _servercertificate, true, serversslprotocols, false);	try {	await clientauthentication.timeoutafter(timeout);	}	catch (exception ex) {	}	await serverauthentication.timeoutafter(timeout);	
server authenticated with encryption cipher bit strength 

========================= corefx sample_8142 =========================

public void methodbegin(methodbase methinfo, isourcelineinfo sourceinfo, bool initwriters) {	_methinfo = methinfo;	_ilgen = xmlilmodule.definemethodbody(methinfo);	_lastsourceinfo = null;	#if debug if (xmliltrace.isenabled) {	_numlocals = 0;	_symbols = new hashtable();	_lblnum = 0;	_sourcefile = null;	_writerdump = xmliltrace.gettracewriter("dump.il");	
method 

private void marksequencepoint(isourcelineinfo sourceinfo) {	debug.assert(_module.emitsymbols);	if (sourceinfo.isnosource && _lastsourceinfo != null && _lastsourceinfo.isnosource) {	return;	}	string sourcefile = getfilename(sourceinfo);	#if debug if (xmliltrace.isenabled) {	
else 

public void marklabel(label lbl) {	if (_lastsourceinfo != null && !_lastsourceinfo.isnosource) {	debugsequencepoint(sourcelineinfo.nosource);	}	
label 

public void emit(opcode opcode, label lblval) {	debug.assert(!opcode.equals(opcodes.br) && !opcode.equals(opcodes.br_s), "use emitunconditionalbranch and be careful not to emit unverifiable code.");	
label 

public void emitunconditionalbranch(opcode opcode, label lbltarget) {	if (!opcode.equals(opcodes.br) && !opcode.equals(opcodes.br_s)) {	debug.assert(opcode.equals(opcodes.brtrue) || opcode.equals(opcodes.brtrue_s) || opcode.equals(opcodes.brfalse) || opcode.equals(opcodes.brfalse_s));	emit(opcodes.ldc_i4_1);	}	
label 

========================= corefx sample_13254 =========================

bool valid = false;	for (int i = 0; i < retrylimit; i++) {	valid = onlinechain.build(cert);	if (valid) {	break;	}	for (int j = 0; j < onlinechain.chainelements.count; j++) {	x509chainelement chainelement = onlinechain.chainelements[j];	if (chainelement.chainelementstatus.length > 0) {	x509chainstatusflags allflags = chainelement.chainelementstatus.aggregate( x509chainstatusflags.noerror, (cur, status) => cur | status.status);	
nameof verifywithrevocation online attempt i errors at depth j allflags 

x509chainstatusflags allflags = chainelement.chainelementstatus.aggregate( x509chainstatusflags.noerror, (cur, status) => cur | status.status);	}	chainelement.certificate.dispose();	}	thread.sleep(1000);	}	if (testenvironmentconfiguration.runmanualtests) {	assert.true(valid, $"online chain built validly within {retrylimit} tries");	}	else if (!valid) {	
skip nameof verifywithrevocation chain failed to build within retrylimit tries 

========================= corefx sample_12029 =========================

public static void sendallsqltypesinsidevariant(string connstr) {	s_connstr = connstr;	console.writeline("");	
starting test sqlvariantparam 

sendvariant(new sqlguid(guid.newguid()), "system.data.sqltypes.sqlguid", "uniqueidentifier");	sendvariant(new sqlboolean(true), "system.data.sqltypes.sqlboolean", "bit");	sendvariant(new sqlboolean(1), "system.data.sqltypes.sqlboolean", "bit");	sendvariant(new sqlbyte(1), "system.data.sqltypes.sqlbyte", "tinyint");	sendvariant(new sqlint16(1), "system.data.sqltypes.sqlint16", "smallint");	sendvariant(new sqlint32(1), "system.data.sqltypes.sqlint32", "int");	sendvariant(new sqlint64(1), "system.data.sqltypes.sqlint64", "bigint");	sendvariant(new sqldecimal(1234.123m), "system.data.sqltypes.sqldecimal", "numeric");	sendvariant(new sqldatetime(datetime.now), "system.data.sqltypes.sqldatetime", "datetime");	sendvariant(new sqlmoney(123.123m), "system.data.sqltypes.sqlmoney", "money");	
end test sqlvariantparam 

private static void verifyreader(string tag, sqldatareader dr, string expectedtypename, string expectedbasetypename) {	dr.read();	string actualtypename = dr.getsqlvalue(0).gettype().tostring();	string actualbasetypename = dr.getstring(1);	console.writeline("{0,-40} -> {1}:{2}", tag, actualtypename, actualbasetypename);	if (!actualtypename.equals(expectedtypename)) {	
error expected type does not match actual type 

private static void verifyreader(string tag, sqldatareader dr, string expectedtypename, string expectedbasetypename) {	dr.read();	string actualtypename = dr.getsqlvalue(0).gettype().tostring();	string actualbasetypename = dr.getstring(1);	console.writeline("{0,-40} -> {1}:{2}", tag, actualtypename, actualbasetypename);	if (!actualtypename.equals(expectedtypename)) {	}	if (!actualbasetypename.equals(expectedbasetypename)) {	
error expected base type does not match actual base type 

========================= corefx sample_11091 =========================

public static void execpositivetest<t>(dynamic dobj, type exp_type, t exp_undervalue, string tip, func<dynamic, dynamic> test) where t : struct {	int flag = 1;	try {	dynamic dr = test(dobj);	if ((dr.gettype() == exp_type) && (((t)dr).equals(exp_undervalue))) {	flag = 0;	}	else {	
got invalid result when testing 

int flag = 1;	try {	dynamic dr = test(dobj);	if ((dr.gettype() == exp_type) && (((t)dr).equals(exp_undervalue))) {	flag = 0;	}	else {	}	}	catch (exception ex) {	
catch an unexpected exception when testing 

public static void execnegativetestwithbadops(dynamic dobj, string[] exp_msg, string tip, func<dynamic, dynamic> test) {	int flag = 1;	try {	dynamic dr = test(dobj);	
got invalid result when testing 

public static void execnegativetestwithbadops(dynamic dobj, string[] exp_msg, string tip, func<dynamic, dynamic> test) {	int flag = 1;	try {	dynamic dr = test(dobj);	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	if (errorverifier.verify(errormessageid.badbinaryops, ex.message, exp_msg)) {	flag = 0;	}	else {	
catch an unexpected runtimebinderexception when testing 

dynamic dr = test(dobj);	}	catch (microsoft.csharp.runtimebinder.runtimebinderexception ex) {	if (errorverifier.verify(errormessageid.badbinaryops, ex.message, exp_msg)) {	flag = 0;	}	else {	}	}	catch (exception ex) {	
catch an unexpected exception when testing 

========================= corefx sample_94 =========================

case xmlnodetype.documenttype: if (_rxmlreader.movetofirstattribute()) {	do {	cxmlattribute rnewattribute = new cxmlattribute(_rxmlreader);	rnewnode.addattribute(rnewattribute);	cxmlnode rvaluenode = new cxmlnode(_rxmlreader);	rvaluenode._strvalue = _rxmlreader.value;	rnewattribute.insertnode(rvaluenode);	} while (_rxmlreader.movetonextattribute());	}	break;	
unhandled type in process 

========================= corefx sample_12627 =========================

if (my_i < remainder) originalposition = localoffset + my_i * (quotient + 1);	else originalposition = localoffset + remainder * (quotient + 1) + (my_i - remainder) * quotient;	keysorderedacrosspartitions &= originalposition == value;	}	localoffset++;	}	}	);	}	task.waitall(threadarray);	
testpartitioningcore keys are not strictly ordered within each partition 

========================= corefx sample_10633 =========================

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	
warning 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	_warningcount++;	_warninginnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	_warningcount++;	_warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	
error 

public void validationcallback(object sender, validationeventargs args) {	if (args.severity == xmlseveritytype.warning) {	_warningcount++;	_warninginnerexceptionset = (args.exception.innerexception != null);	}	else if (args.severity == xmlseveritytype.error) {	_errorcount++;	_errorinnerexceptionset = (args.exception.innerexception != null);	
innerexceptionset 

========================= corefx sample_12514 =========================

if (var != null) {	const string indent = "\t";	try {	curvariation = var;	testresult ret = var.execute();	if (testresult.passed == ret) {	module.passcount++;	}	else if (testresult.failed == ret) {	system.console.writeline(indent + var.desc);	
failed 

testresult ret = var.execute();	if (testresult.passed == ret) {	module.passcount++;	}	else if (testresult.failed == ret) {	system.console.writeline(indent + var.desc);	module.failcount++;	}	else {	system.console.writeline(indent + var.desc);	
skipped 

else {	system.console.writeline(indent + var.desc);	module.skipcount++;	}	}	catch (testskippedexception tse) {	if (!string.isnullorwhitespace(var.desc)) {	system.console.writeline(indent + var.desc);	}	if (!string.isnullorwhitespace(tse.message)) {	
skipped msg 

if (!string.isnullorwhitespace(var.desc)) {	system.console.writeline(indent + var.desc);	}	if (!string.isnullorwhitespace(tse.message)) {	}	module.skipcount++;	}	catch (exception e) {	system.console.writeline(indent + var.desc);	system.console.writeline(e);	
failed 

========================= corefx sample_11658 =========================

do {	readlength = await tasktimeoutextensions.timeoutafter(stream.readasync(array, offset, remaining), timeoutmilliseconds);	if (readlength <= 0) {	break;	}	remaining -= readlength;	offset += readlength;	}	while (remaining > 0);	if (remaining != 0) {	
expected bytes but got 

do {	readlength = stream.read(array, offset, remaining);	if (readlength <= 0) {	break;	}	remaining -= readlength;	offset += readlength;	}	while (remaining > 0);	if (remaining != 0) {	
expected bytes but got 

========================= corefx sample_7724 =========================

using (memorystream ms = new memorystream()) {	using (xmlwriter w = creatememwriter(utils, ms, ws)) {	w.writeelementstring("elem", "text");	w.flush();	ms.position = 0;	using (streamreader reader = new streamreader(ms)) {	outputxml = reader.readtoend();	}	}	}	
actual 

ms.position = 0;	using (streamreader reader = new streamreader(ms)) {	outputxml = reader.readtoend();	}	}	}	cerror.compare(outputxml, "<elem>text</elem>", "wrong xml");	assert.true(false);	}	catch (exception e) {	
exception 

using (stream ms = new memorystream()) {	using (xmlwriter w = creatememwriter(utils, ms, ws)) {	w.writeelementstring("elem", "text");	w.flush();	ms.position = 0;	using (streamreader reader = new streamreader(ms)) {	outputxml = reader.readtoend();	}	}	}	
actual 

ms.position = 0;	using (streamreader reader = new streamreader(ms)) {	outputxml = reader.readtoend();	}	}	}	cerror.compare(outputxml, "<elem>text</elem>", "wrong xml");	assert.true(false);	}	catch (exception e) {	
exception 

using (xmlwriter w = creatememwriter(utils, bs, ws)) {	w.writeelementstring("elem", "text");	w.flush();	bs.position = 0;	using (streamreader reader = new streamreader(bs)) {	outputxml = reader.readtoend();	}	}	}	}	
actual 

using (streamreader reader = new streamreader(bs)) {	outputxml = reader.readtoend();	}	}	}	}	cerror.compare(outputxml, "<elem>text</elem>", "wrong xml");	assert.true(false);	}	catch (exception e) {	
exception 

using (xmlwriter w = creatememwriter(utils, bs, ws)) {	w.writeelementstring("elem", "text");	w.flush();	bs.position = 0;	using (streamreader reader = new streamreader(bs)) {	outputxml = reader.readtoend();	}	}	}	}	
actual 

using (streamreader reader = new streamreader(bs)) {	outputxml = reader.readtoend();	}	}	}	}	cerror.compare(outputxml, "<elem>text</elem>", "wrong xml");	assert.true(false);	}	catch (exception e) {	
exception 

w.flush();	ms.position = 0;	using (streamreader reader = new streamreader(ms)) {	reader.readtoend();	}	}	}	assert.true(false);	}	catch (exception e) {	
exception 

w.flush();	ms.position = 0;	using (streamreader reader = new streamreader(ms)) {	reader.readtoend();	}	}	}	assert.true(false);	}	catch (exception e) {	
exception 

w.flush();	ms.position = 0;	using (streamreader reader = new streamreader(ms)) {	reader.readtoend();	}	}	}	assert.true(false, "exception was not thrown");	}	catch (objectdisposedexception e) {	
exception 

========================= corefx sample_12460 =========================

