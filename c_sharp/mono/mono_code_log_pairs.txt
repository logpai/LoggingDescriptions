private void printversion () {	
mono assembly linker al exe version 

private void report (int errornum, string msg) {	
alink error a 

private void reportwarning (int errornum, string msg) {	
alink warning a 

========================= mono sample_1169 =========================

private void setupxim () {	xim = intptr.zero;	if (!xsupportslocale ()) {	
x does not support your locale 

private void setupxim () {	xim = intptr.zero;	if (!xsupportslocale ()) {	return;	}	if (!xsetlocalemodifiers (string.empty)) {	
could not set x locale modifiers 

e.keyevent.keycode = keyc;	if ((eventtovkey (e) & 0xff) != vkey) {	e.keyevent.keycode = 0;	}	}	}	if ((vkey >= (int) virtualkeys.vk_numpad0) && (vkey <= (int) virtualkeys.vk_numpad9)) e.keyevent.keycode = xkeysymtokeycode (display, vkey - (int) virtualkeys.vk_numpad0 + (int) keypadkeys.xk_kp_0);	if (vkey == (int) virtualkeys.vk_decimal) e.keyevent.keycode = xkeysymtokeycode (display, (int) keypadkeys.xk_kp_decimal);	if (vkey == (int) virtualkeys.vk_separator) e.keyevent.keycode = xkeysymtokeycode(display, (int) keypadkeys.xk_kp_separator);	if (e.keyevent.keycode == 0 && vkey != (int) virtualkeys.vk_noname) {	
unknown virtual key x 

}	if ((score > max_score) || ((score == max_score) && (seq > max_seq))) {	layout = current;	max_score = score;	max_seq = seq;	}	}	if (layout != null)  {	return layout;	} else {	
keyboard layout not recognized using default layout 

========================= mono sample_25574 =========================

webconfigurationmanager.init ();	settingsmappingmanager.init ();	runtime_section = (httpruntimesection) webconfigurationmanager.getsection ("system.web/httpruntime");	} catch (exception ex) {	initialexception = ex;	}	queue_manager = new queuemanager ();	if (queue_manager.hasexception) {	if (initialexception == null) initialexception = queue_manager.initialexception;	else {	
exception during queuemanager initialization 

if (queue_manager.hasexception) {	if (initialexception == null) initialexception = queue_manager.initialexception;	else {	console.error.writeline (queue_manager.initialexception);	}	}	trace_manager = new tracemanager ();	if (trace_manager.hasexception) {	if (initialexception == null) initialexception = trace_manager.initialexception;	else {	
exception during tracemanager initialization 

static void realprocessrequest (object o) {	if (domainunloading) {	
domain is unloading not processing the request 

========================= mono sample_20033 =========================

namespacetofilter = treenode.text;	}	itypeprovider typeprovider = this.typeprovider;	iextendeduiservice2 extendeduiservice = (iextendeduiservice2)this.serviceprovider.getservice(typeof(iextendeduiservice2));	foreach (type type in gettargetframeworktypes(typeprovider)) {	try {	object[] attributes = type.getcustomattributes(typeof(obsoleteattribute), false);	if ((attributes != null) && attributes.length > 0) continue;	}	catch (exception e) {	
count not retrieve attributes from type 

========================= mono sample_12880 =========================

static void systemdataparametercollreplace (string srcdir, string targetdir, string target, string resns, string ns, string parname) {	var t = file.readalltext (path.combine (srcdir, "dbparametercollectionhelper.cs"));	
creating 

static void main (string [] args) {	string bdir = args.length == 0 ? "../../../mcs" : args [0];	if (!directory.exists (path.combine(bdir, "class"))){	
the directory does not contain class at 

static void main (string [] args) {	string bdir = args.length == 0 ? "../../../mcs" : args [0];	if (!directory.exists (path.combine(bdir, "class"))){	environment.exit (1);	}	switch (args [1]){	case "core": filter (bdir + "/build/common/consts.cs.in", bdir + "/build/common/consts.cs", (i, o) => o.write (i.readtoend ().replace ("@mono_version@", "2.5.0")));	generatesystemdata (bdir);	break;	
unknonw option to prepare exe 

========================= mono sample_21 =========================

try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection sect = (appsettingssection)config.getsection("appsettings");	foreach (string key in sect.settings.allkeys) {	keyvalueconfigurationelement e = sect.settings[key];	console.writeline ("{0} = {1}", e.key, e.value);	}	console.writeline ("lockallattributesexcept = '{0}'", sect.lockallattributesexcept.attributelist);	}	catch (exception e) {	
exception raised 

========================= mono sample_29813 =========================

public bool publish(debugcontroller controller) {	
wde programpublisher publish 

if (ispublished) return false;	try {	this.controller = controller;	thread publisherthread = new thread(publisherthreadfunc);	publisherthread.setapartmentstate(apartmentstate.mta);	publisherthread.isbackground = true;	publisherthread.start();	publisherthread.join();	}	catch (exception e) {	
wde programpublisher publish exception 

private void publisherthreadfunc() {	try {	this.publisher = new wdeprogrampublisher() as iwdeprogrampublisher;	this.wdeprogramnodesingleton = new programnode(this.controller);	this.gchwdeprogramnode = gchandle.alloc(this.wdeprogramnodesingleton);	this.publisher.publish(this.wdeprogramnodesingleton);	this.ispublished = true;	}	catch (exception e) {	
wde programpublisher publisherthreadfunc exception 

public void unpublish() {	if (!ispublished) return;	
wde programpublisher unpublish 

public void unpublish() {	if (!ispublished) return;	try {	thread unpublisherthread = new thread(unpublishthreadfunc);	unpublisherthread.setapartmentstate(apartmentstate.mta);	unpublisherthread.isbackground = true;	unpublisherthread.start();	unpublisherthread.join();	}	catch (exception e) {	
wde programpublisher unpublish exception 

if (!ispublished) return;	try {	thread unpublisherthread = new thread(unpublishthreadfunc);	unpublisherthread.setapartmentstate(apartmentstate.mta);	unpublisherthread.isbackground = true;	unpublisherthread.start();	unpublisherthread.join();	}	catch (exception e) {	}	
wde programpublisher unpublish done 

private void unpublishthreadfunc() {	try {	this.publisher.unpublish(this.wdeprogramnodesingleton);	}	catch (exception e) {	
wde programpublisher unpublishthreadfunc catch exception 

========================= mono sample_10797 =========================

static void main () {	var workitems = new performancecounter ("mono threadpool", "work items added");	var t1 = datetime.now;	int n = 100 * 100 * 100;	for (var i = 0; i < n; i++) threadpool.queueuserworkitem (_ => {});	var t2 = datetime.now;	var d0 = t2 - t1;	var d1 = d0.totalmilliseconds;	
items in ms ms per queue 

========================= mono sample_27445 =========================

public override void replay (mergeinfo<tfunc, tabstractdomain> merge) {	if (!merge.iscommon (this.from)) return;	symvalue sv1 = merge.graph1.lookupwithoutmanifesting (this.from, this.function);	symvalue sv2 = merge.graph2.lookupwithoutmanifesting (this.from, this.function);	if (debugoptions.debug) {	
replay edge update 

if (!merge.iscommon (this.from)) return;	symvalue sv1 = merge.graph1.lookupwithoutmanifesting (this.from, this.function);	symvalue sv2 = merge.graph2.lookupwithoutmanifesting (this.from, this.function);	if (debugoptions.debug) {	}	if (sv1 == null) {	if (this.function.keepasbottomfield && merge.graph1.hasallbottomfields (this.from)) sv1 = merge.graph1.bottomplaceholder;	else {	if (sv2 == null || merge.widen || !this.function.manifestfield) return;	if (debugoptions.debug) {	
symgraph changed due to manifestation of a top edge in 

if (debugoptions.debug) {	}	merge.changed = true;	}	}	if (sv2 == null) {	if (this.function.keepasbottomfield && merge.graph2.hasallbottomfields (this.from)) sv2 = merge.graph2.bottomplaceholder;	else {	if (merge.widen || !this.function.manifestfield) return;	if (debugoptions.debug) {	
symgraph changed due to manifestation of due to missing target in 

========================= mono sample_29506 =========================

static void setupcustompeerresolverservicehost () {	string customport = environment.getenvironmentvariable ("mono_custompeerresolverservice_port");	if (customport == null || !int.tryparse (customport, out port)) port = 8931;	var t = new tcplistener (port);	try {	t.start ();	t.stop ();	} catch {	return;	}	
warning it is running peer resolver service locally this means the node registration is valid only within this application domain 

========================= mono sample_32369 =========================

public static int main() {	conditionalmethod ();	
succeeded 

========================= mono sample_2334 =========================

public static int main () {	if (negatefoonullable (null).value != 42) return 1;	if (negatefoo (new foo (2)).value != -2) return 2;	if (negatebarnullable (null) != null) return 3;	if (negatebar (new bar (2)).value.value != -2) return 4;	
ok 

========================= mono sample_2287 =========================

public void statementexpression_1 () {	
system console writeline 

public void usingalias () {	evaluator.run("using system;");	evaluator.run("using myconsole = system.console;");	
console writeline 

========================= mono sample_26888 =========================

c = p.openexeconfiguration (string.empty);	assert.areequal (path.combine (basedir, "t46.exe.config"), c.filepath, "#f1");	assert.areequal ("hello world!", c.appsettings.settings ["hithere"].value, "#f2");	f = foo.getremote (domain);	assert.areequal (path.combine (basedir, "t46.exe.config"), f.getfilepath (string.empty), "#g1");	assert.areequal ("hello world!", f.getsettingvalue (string.empty, "hithere"), "#g2");	f = new foo ();	c = f.openexeconfiguration (string.empty);	assert.areequal (path.combine (basedir, "t46.exe.config"), c.filepath, "#h1");	assert.areequal ("hello world!", c.appsettings.settings ["hithere"].value, "#h2");	
configuration ok 

========================= mono sample_29827 =========================

public docopy copyit;	public void leak(bool usearray, int max) { docopy one = null;	if(usearray) {	int[] work;	one = delegate { work = new int[max];	};	}	else {	one = delegate { int xans = (max + 1) * max / 2; };	}	
here goes 

public void leak(bool usearray, int max) { docopy one = null;	if(usearray) {	int[] work;	one = delegate { work = new int[max];	};	}	else {	one = delegate { int xans = (max + 1) * max / 2; };	}	one();	
made it 

========================= mono sample_2147 =========================

public new void mouseclick () {	
this should be printed 

========================= mono sample_2396 =========================

static void main(string[] args) {	if (args.length == 1) {	string arg = args[0];	int n = int.parse(arg);	point[] pts = new point[n];	for (int i = 0; i < n; i++) pts[i] = point.random(500, 500);	point[] chpts = convexhull.convexhull(pts);	
area is 

static void main(string[] args) {	if (args.length == 1) {	string arg = args[0];	int n = int.parse(arg);	point[] pts = new point[n];	for (int i = 0; i < n; i++) pts[i] = point.random(500, 500);	point[] chpts = convexhull.convexhull(pts);	print(chpts);	}	
usage gconvexhull pointcount 

========================= mono sample_30580 =========================

public static int main () {	var x = left () ?? right();	if (count != 1) return 1;	switch (left ()) {	case 0: return 2;	}	if (count != 2) return 3;	
ok 

========================= mono sample_1520 =========================

thread[] tarray = new thread [num_threads];	for (int i = 0; i < num_threads; i++) {	object lock_obj = new object ();	monitor.enter (lock_obj);	tarray [i] = new thread (new parameterizedthreadstart (threadfunc));	tarray [i].start (lock_obj);	}	barrier.signalandwait ();	for (int i = 0; i < num_threads; i++) tarray [i].abort ();	for (int i = 0; i < num_threads; i++) tarray [i].join ();	
aborted 

========================= mono sample_153 =========================

contenttype	contenttype	= (contenttype)type;	byte[] buffer = this.readrecordbuffer(type, record);	if (buffer == null) {	internalresult.setcomplete((byte[])null);	return;	}	if (contenttype == contenttype.alert && buffer.length == 2) {	}	else if ((this.context.read != null) && (this.context.read.cipher != null)) {	buffer = this.decryptrecordfragment (contenttype, buffer);	
decrypted record data 

int type = recordtypebuffer[0];	contenttype	contenttype	= (contenttype)type;	byte[] buffer = this.readrecordbuffer(type, record);	if (buffer == null) {	return null;	}	if (contenttype == contenttype.alert && buffer.length == 2) {	}	else if ((this.context.read != null) && (this.context.read.cipher != null)) {	buffer = this.decryptrecordfragment (contenttype, buffer);	
decrypted record data 

while (totalreceived != length) {	int justreceived = record.read(buffer, totalreceived, buffer.length - totalreceived);	if (0 == justreceived) {	throw new tlsexception(alertdescription.closenotify, "received 0 bytes from stream. it must be closed.");	}	totalreceived += justreceived;	}	if (protocol != this.context.protocol && this.context.protocolnegotiated) {	throw new tlsexception( alertdescription.protocolversion, "invalid protocol version on message received");	}	
record data 

public void sendalert(alert alert) {	alertlevel level;	alertdescription description;	bool close;	if (alert == null) {	
write alert null 

public void sendalert(alert alert) {	alertlevel level;	alertdescription description;	bool close;	if (alert == null) {	level = alertlevel.fatal;	description = alertdescription.internalerror;	close = true;	} else {	
write alert 

public void sendchangecipherspec() {	
write change cipher spec 

public void sendchangecipherspec(stream recordstream) {	
write change cipher spec 

public iasyncresult beginsendchangecipherspec(asynccallback callback, object state) {	
write change cipher spec 

public iasyncresult beginsendrecord(handshaketype handshaketype, asynccallback callback, object state) {	handshakemessage msg = this.getmessage(handshaketype);	msg.process();	
write handshake record 

}	fragment = new byte[fragmentlength];	buffer.blockcopy(recorddata, position, fragment, 0, fragmentlength);	if ((this.context.write != null) && (this.context.write.cipher != null)) {	fragment = this.encryptrecordfragment (contenttype, fragment);	}	record.write((byte)contenttype);	record.write(this.context.protocol);	record.write((short)fragment.length);	record.write(fragment);	
record data 

private byte[] encryptrecordfragment( contenttype	contenttype, byte[]		fragment) {	byte[] mac	= null;	if (this.context is clientcontext) {	mac = this.context.write.cipher.computeclientrecordmac(contenttype, fragment);	}	else {	mac = this.context.write.cipher.computeserverrecordmac (contenttype, fragment);	}	
record mac 

}	throw;	}	byte[] mac = null;	if (this.context is clientcontext) {	mac = this.context.read.cipher.computeserverrecordmac(contenttype, dcrfragment);	}	else {	mac = this.context.read.cipher.computeclientrecordmac (contenttype, dcrfragment);	}	
record mac 

========================= mono sample_20718 =========================

public static int main () {	methodinfo o = typeof (y).getmethod ("x.add_foo", bindingflags.nonpublic | bindingflags.instance);	if (o == null) return 1;	o = typeof (y).getmethod ("x.get_prop", bindingflags.nonpublic | bindingflags.instance);	if (o == null) return 2;	
ok 

========================= mono sample_2718 =========================

if ((i % 24) == 0){	console.write ("\n{0:x6}: ", i);	}	console.write ("{0:x2} ", d [i]);	sb.append (string.format ("{0:x2} ", d [i]));	}	if (s != null){	string result = sb.tostring ().trim ();	if (s.trim () != result){	console.writeline ();	
failure 

if ((i % 24) == 0){	console.write ("\n{0:x6}: ", i);	}	console.write ("{0:x2} ", d [i]);	sb.append (string.format ("{0:x2} ", d [i]));	}	if (s != null){	string result = sb.tostring ().trim ();	if (s.trim () != result){	console.writeline ();	
got 

if ((i % 24) == 0){	console.write ("\n{0:x6}: ", i);	}	console.write ("{0:x2} ", d [i]);	sb.append (string.format ("{0:x2} ", d [i]));	}	if (s != null){	string result = sb.tostring ().trim ();	if (s.trim () != result){	console.writeline ();	
expected 

dump (dataconverter.pack ("z8", "hello"), "68 65 6c 6c 6f 00 00 00 00");	dump (dataconverter.pack ("z6", "hello"), "68 00 65 00 6c 00 6c 00 6f 00 00 00 00 00");	dump (dataconverter.pack ("cccc", 65, 66, 67, 68), "41 42 43 44");	dump (dataconverter.pack ("4c", 65, 66, 67, 68, 69, 70),  "41 42 43 44");	dump (dataconverter.pack ("^iii", 0x1234abcd, 0x7fadb007), " 12 34 ab cd 7f ad b0 07 00 00 00 00");	dump (dataconverter.pack ("_s!i", 0x7b, 0x12345678), "7b 00 00 00 78 56 34 12");	byte [] b = dataconverter.pack ("4c", 1, 2, 3, 4);	foreach (object c in dataconverter.unpack ("4c", b, 0)){	console.writeline ("->{0} {1}", c, c.gettype ());	}	
tests failed passed 

dump (dataconverter.pack ("^iii", 0x1234abcd, 0x7fadb007), " 12 34 ab cd 7f ad b0 07 00 00 00 00");	dump (dataconverter.pack ("_s!i", 0x7b, 0x12345678), "7b 00 00 00 78 56 34 12");	byte [] b = dataconverter.pack ("4c", 1, 2, 3, 4);	foreach (object c in dataconverter.unpack ("4c", b, 0)){	console.writeline ("->{0} {1}", c, c.gettype ());	}	byte [] source = new byte [] { 1, 2, 3, 4 };	byte [] dest = new byte [4];	int l = dataconverter.int32frombe (source, 0);	if (l != 0x01020304){	
failure 

========================= mono sample_28097 =========================

public static void test (action<int> allocator) {	for (int i = 0; i < 1000; ++i) {	bool caught = false;	try {	allocator (i);	}	catch (outofmemoryexception) {	caught = true;	}	if (!caught) {	
wtf 

public static int main () {	
byte arrays 

public static int main () {	test (i => probearray (new byte [int.maxvalue - i]));	test (i => probearray (new byte [int.maxvalue - i * 100]));	
int arrays 

public static int main () {	test (i => probearray (new byte [int.maxvalue - i]));	test (i => probearray (new byte [int.maxvalue - i * 100]));	test (i => probearray (new int [int.maxvalue / 4 - i]));	test (i => probearray (new int [int.maxvalue / 4 - i * 100]));	
large int arrays 

public static int main () {	test (i => probearray (new byte [int.maxvalue - i]));	test (i => probearray (new byte [int.maxvalue - i * 100]));	test (i => probearray (new int [int.maxvalue / 4 - i]));	test (i => probearray (new int [int.maxvalue / 4 - i * 100]));	test (i => probearray (new int [int.maxvalue - i]));	test (i => probearray (new int [int.maxvalue - i * 100]));	
strings 

========================= mono sample_320 =========================

public static int main (string[] args) {	type program = typeof (program);	if (program.getcustomattributes (true).length != 0) return 1;	if (program.getconstructor (system.type.emptytypes).getcustomattributes (true).length != 0) return 2;	if (program.getproperty ("message").getsetmethod ().getcustomattributes (true).length != 0) return 3;	if (program.getmethod ("main").getcustomattributes (true).length != 0) return 4;	if (program.getmethod ("test2").getcustomattributes (true).length != 0) return 5;	type test2 = typeof (test2);	if (test2.getcustomattributes (true).length != 0) return 6;	
ok 

========================= mono sample_3815 =========================

public static void main () {	
compiler said value is 

public static void main () {	fieldinfo fi = typeof (dec).getfield ("minvalue");	decimal d = (decimal) fi.getvalue (fi);	
reflection said value is 

========================= mono sample_3487 =========================

public static int main () {	int x = 4;	try {	throw null;	} catch (nullreferenceexception) when (x > 0) {	
catch 

========================= mono sample_3716 =========================

console.outputencoding = encoding.getencoding("iso-8859-1");	scg.ienumerable<string> ss;	if (args.length == 1) ss = readfilewords(args[0]);	else ss = args;	timer t = new timer();	scg.ienumerable<scg.ienumerable<string>> classes = anagramclasses(ss);	int count = 0;	foreach (scg.ienumerable<string> anagramclass in classes) {	count++;	}	
anagram classes 

========================= mono sample_30573 =========================

public override int invoke (ienumerable<string> args) {	try {	var extra = options.parse (args);	if (showhelp) {	options.writeoptiondescriptions (commandset.out);	return 0;	}	if (string.isnullorempty (name)) {	console.error.writeline ("commands: missing required argument `--name=name`.");	
commands use commands help requires args for details 

try {	var extra = options.parse (args);	if (showhelp) {	options.writeoptiondescriptions (commandset.out);	return 0;	}	if (string.isnullorempty (name)) {	console.error.writeline ("commands: missing required argument `--name=name`.");	return 1;	}	
hello name 

========================= mono sample_32536 =========================

public static void main (string[] args) {	switch (1) {	default: switch (2) {	default: int flag = 1;	if (flag == 1) {	
this one is expected 

public static void main (string[] args) {	switch (1) {	default: switch (2) {	default: int flag = 1;	if (flag == 1) {	break;	}	else  goto lbl;	}	break;	
this should not appear since break was supposed to fire 

========================= mono sample_1545 =========================

public static int main () {	y y = new y ();	if (y.add (1, 1) != 2) return 1;	
parent interface implementation test passes 

========================= mono sample_3691 =========================

public delegate int foo (int i, int j);	private void thread_func () {	
inside the thread 

public void bar () {	foo my_func = new foo (func);	int result = my_func (2, 4);	
answer is 

static bool myfilter (memberinfo mi, object criteria) {	
you passed in 

public static int main () {	i.gettextfn _ = i.gettext;	
value 

public static int main () {	i.gettextfn _ = i.gettext;	x x = new x ();	thread thr = new thread (new threadstart (x.thread_func));	thr.start ();	
inside main 

public static int main () {	i.gettextfn _ = i.gettext;	x x = new x ();	thread thr = new thread (new threadstart (x.thread_func));	thr.start ();	thr.join ();	
hello 

i.gettextfn _ = i.gettext;	x x = new x ();	thread thr = new thread (new threadstart (x.thread_func));	thr.start ();	thr.join ();	x.bar ();	memberfilter filter = new memberfilter (myfilter);	type t = x.gettype ();	memberinfo [] mi = t.findmembers (membertypes.method, bindingflags.static | bindingflags.nonpublic, type.filtername, "myfilter");	console.writeline ("findmembers called, mi = " + mi);	
count 

x.bar ();	memberfilter filter = new memberfilter (myfilter);	type t = x.gettype ();	memberinfo [] mi = t.findmembers (membertypes.method, bindingflags.static | bindingflags.nonpublic, type.filtername, "myfilter");	console.writeline ("findmembers called, mi = " + mi);	if (!filter (mi [0], "myfilter")) return 1;	namespace.testdelegate td = new namespace.testdelegate (multiply_by_three);	if (td (8) != 24) return 30;	if (td.gettype ().fullname != "namespace.testdelegate") return 31;	if (_.gettype ().fullname != "i+gettextfn") return 32;	
test passes 

========================= mono sample_3411 =========================

csrinvisible = reader.get (terminfostrings.cursorinvisible);	if (term == "cygwin" || term == "linux" || (term != null && term.startswith ("xterm")) || term == "rxvt" || term == "dtterm") {	titleformat = "\x1b]0;{0}\x7";	} else if (term == "iris-ansi") {	titleformat = "\x1bp1.y{0}\x1b\\";	} else if (term == "sun-cmd") {	titleformat = "\x1b]l{0}\x1b\\";	}	cursoraddress = reader.get (terminfostrings.cursoraddress);	getcursorposition ();	
nogetposition left top 

public void writespecialkey (consolekeyinfo key) {	switch (key.key) {	case consolekey.backspace: if (cursorleft > 0) {	if (cursorleft <= rl_startx && cursortop == rl_starty) break;	cursorleft--;	setcursorposition (cursorleft, cursortop);	writeconsole (" ");	setcursorposition (cursorleft, cursortop);	}	
bs left top 

}	writeconsole ("\t");	break;	case consolekey.clear: writeconsole (clear);	cursorleft = 0;	cursortop = 0;	break;	case consolekey.enter: break;	default: break;	}	
left top 

========================= mono sample_28001 =========================

public override void help() {	console.writeline();	
nunit console inputfiles options 

public override void help() {	console.writeline();	console.writeline();	
runs a set of nunit tests from the console 

public override void help() {	console.writeline();	console.writeline();	console.writeline();	
you may specify one or more assemblies or a single 

public override void help() {	console.writeline();	console.writeline();	console.writeline();	
project file of type nunit 

public override void help() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	
options 

public override void help() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	base.help();	console.writeline();	
options that take values may use an equal sign a colon 

public override void help() {	console.writeline();	console.writeline();	console.writeline();	console.writeline();	base.help();	console.writeline();	
or a space to separate the option from its value 

========================= mono sample_32693 =========================

public static int main(string[] args) {	int num = 8;	if (args.length > 0) num = system.int32.parse (args [0]);	
ack 

========================= mono sample_194 =========================

public static int main() {	var constraints = typeof (gc<>).getgenericarguments ()[0].getgenericparameterconstraints ();	if (constraints.length != 1) return 1;	if (constraints [0] != typeof (c)) return 2;	
ok 

========================= mono sample_1676 =========================

private void clickhandler (object sender, eventargs e) {	if (!visible) {	return;	}	titlebutton button = (titlebutton) sender;	switch (button.caption) {	case captionbutton.close: form.close ();	break;	
help not implemented 

========================= mono sample_26282 =========================

static void main () {	
ok 

========================= mono sample_35222 =========================

public static int test () {	expression<func<t?, bool>> e = (t? o) => o == null;	if (!e.compile ().invoke (null)) return 1;	if (e.compile ().invoke (default (t))) return 2;	
ok 

========================= mono sample_3633 =========================

static public void main (string [] args) {	securityaction a = securityaction.demand;	switch (a) {	
ok 

========================= mono sample_1835 =========================

schemaelementdecl currentelementdecl = context.elementdecl;	string localname = context.localname;	string namespaceuri = context.namespace;	for (int i = this.startidconstraint; i < this.validationstack.length; i ++) {	if (((validationstate)(this.validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)this.validationstack[i]).constr;	for (int j = 0; j < constraintstructures.length; ++j) {	if (constraintstructures[j].axisselector.movetostartelement(localname, namespaceuri)) {	
selector match 

schemaelementdecl currentelementdecl = context.elementdecl;	string localname = context.localname;	string namespaceuri = context.namespace;	for (int i = this.startidconstraint; i < this.validationstack.length; i ++) {	if (((validationstate)(this.validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)this.validationstack[i]).constr;	for (int j = 0; j < constraintstructures.length; ++j) {	if (constraintstructures[j].axisselector.movetostartelement(localname, namespaceuri)) {	
name uri 

continue;	}	constraintstruct[] constraintstructures = ((validationstate)this.validationstack[i]).constr;	for (int j = 0; j < constraintstructures.length; ++j) {	if (constraintstructures[j].axisselector.movetostartelement(localname, namespaceuri)) {	constraintstructures[j].axisselector.pushks(positioninfo.linenumber, positioninfo.lineposition);	}	for (int k = 0; k < constraintstructures[j].axisfields.count; ++k) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[j].axisfields[k];	if (laxis.movetostartelement(localname, namespaceuri)) {	
element field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, xmlschemadatatype datatype) {	for (int ci = this.startidconstraint; ci < this.validationstack.length; ci ++) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraintstructures.length; ++i) {	for (int j = 0; j < constraintstructures[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, xmlschemadatatype datatype) {	for (int ci = this.startidconstraint; ci < this.validationstack.length; ci ++) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraintstructures.length; ++i) {	for (int j = 0; j < constraintstructures[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field filling value 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, xmlschemadatatype datatype) {	for (int ci = this.startidconstraint; ci < this.validationstack.length; ci ++) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraintstructures = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraintstructures.length; ++i) {	for (int j = 0; j < constraintstructures[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraintstructures[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
name uri value 

string namespaceuri = context.namespace;	for (int ci = this.validationstack.length - 1; ci >= this.startidconstraint; ci --) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
element field filling value 

string namespaceuri = context.namespace;	for (int ci = this.validationstack.length - 1; ci >= this.startidconstraint; ci --) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
name uri value 

========================= mono sample_11197 =========================

static void initialize () {	if (initialized) return;	try {	doinitialize ();	} catch (exception ex) {	
initialize threw exception 

========================= mono sample_24107 =========================

public static void main(string[] args) {	for (int i = 0; i < 50; ++i) {	spawnthread(i);	gc.collect();	gc.collect();	gc.collect();	gc.collect();	gc.waitforpendingfinalizers();	
loop i 

========================= mono sample_314 =========================

static int main (string[] args) {	if (args.length == 0) {	
usage mono exe filename 

static int main (string[] args) {	if (args.length == 0) {	return 2;	}	string filename = args [0];	x509certificate2 cert = new x509certificate2 (filename);	x509chain chain = x509chain.create ();	bool result = chain.build (cert);	
build 

static int main (string[] args) {	if (args.length == 0) {	return 2;	}	string filename = args [0];	x509certificate2 cert = new x509certificate2 (filename);	x509chain chain = x509chain.create ();	bool result = chain.build (cert);	console.writeline ();	
chainstatus 

console.writeline ();	if (chain.chainstatus.length > 0) {	foreach (x509chainstatus st in chain.chainstatus) {	console.writeline ("\t{0}", st.status);	}	} else {	console.writeline ("\t{0}", x509chainstatusflags.noerror);	}	console.writeline ();	int n = 1;	
chainelements 

if (chain.chainstatus.length > 0) {	foreach (x509chainstatus st in chain.chainstatus) {	console.writeline ("\t{0}", st.status);	}	} else {	console.writeline ("\t{0}", x509chainstatusflags.noerror);	}	console.writeline ();	int n = 1;	foreach (x509chainelement ce in chain.chainelements) {	
certificate 

if (chain.chainstatus.length > 0) {	foreach (x509chainstatus st in chain.chainstatus) {	console.writeline ("\t{0}", st.status);	}	} else {	console.writeline ("\t{0}", x509chainstatusflags.noerror);	}	console.writeline ();	int n = 1;	foreach (x509chainelement ce in chain.chainelements) {	
chainstatus 

========================= mono sample_23777 =========================

public void writeoptiondescriptions () {	var p = new optionset () {	"\n:category 1:", { "hidden",             "hidden option, invisible in help",     v => {}, true }, { "hidden2=",           "hidden option, invisible in help",     (k, v) => {}, true }, { "p|indicator-style=", "append / indicator to directories",    v => {} }, { "color:",             "controls color info",                  v => {} }, { "color2:",            "set {color}",                          v => {} }, { "rk=",                "required key/value option",            (k, v) => {} }, { "rk2=",               "required {{foo}} {0:key}/{1:value} option",    (k, v) => {} }, { "rk3=",               "required {{foo}} {}",    k => {} }, { "rk4=",               "required {{foo}} {0:val}",    k => {} }, { "ok:",                "optional key/value option",            (k, v) => {} }, { "long-desc", "this has a really\nlong, multi-line description that also\ntests\n" + "the-builtin-supercalifragilisticexpialidicious-break-on-hyphen.  " + "also, a list:\n" + "  item 1\n" + "  item 2", v => {} }, { "long-desc2", "iwantthisdescriptiontobreakinsideawordgeneratingautowordhyphenation. ", v => {} }, { "long-desc3", "onlyoneperiod.andnowhitespaceshouldbesupportedevenwithlongdescriptions", v => {} }, { "long-desc4", "lots of spaces in the middle 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 and more until the end.", v => {} }, { "long-desc5", "lots of spaces in the middle - . - . - . - . - . - . - . - and more until the end.", v => {} }, "", "==this is a really long category name which will involve line wrapping, just because...==", { "o|out=", "the {directory} to place the generated files and directories.\n\n" + "if not specified, defaults to\n`dirname file`/cache/`basename file .tree`.", v => {} }, "", "category 3:", { "h|?|help",           "show help text",                       v => {} }, { "version",            "output version information and exit",  v => {} }, { "<>", v => {} }, new testargumentsource (new[]{"@s1", "@s2"}, "read response file for more options"), };	stringwriter expected = new stringwriter ();	expected.writeline ("");	
category 

public void writeoptiondescriptions () {	var p = new optionset () {	"\n:category 1:", { "hidden",             "hidden option, invisible in help",     v => {}, true }, { "hidden2=",           "hidden option, invisible in help",     (k, v) => {}, true }, { "p|indicator-style=", "append / indicator to directories",    v => {} }, { "color:",             "controls color info",                  v => {} }, { "color2:",            "set {color}",                          v => {} }, { "rk=",                "required key/value option",            (k, v) => {} }, { "rk2=",               "required {{foo}} {0:key}/{1:value} option",    (k, v) => {} }, { "rk3=",               "required {{foo}} {}",    k => {} }, { "rk4=",               "required {{foo}} {0:val}",    k => {} }, { "ok:",                "optional key/value option",            (k, v) => {} }, { "long-desc", "this has a really\nlong, multi-line description that also\ntests\n" + "the-builtin-supercalifragilisticexpialidicious-break-on-hyphen.  " + "also, a list:\n" + "  item 1\n" + "  item 2", v => {} }, { "long-desc2", "iwantthisdescriptiontobreakinsideawordgeneratingautowordhyphenation. ", v => {} }, { "long-desc3", "onlyoneperiod.andnowhitespaceshouldbesupportedevenwithlongdescriptions", v => {} }, { "long-desc4", "lots of spaces in the middle 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 and more until the end.", v => {} }, { "long-desc5", "lots of spaces in the middle - . - . - . - . - . - . - . - and more until the end.", v => {} }, "", "==this is a really long category name which will involve line wrapping, just because...==", { "o|out=", "the {directory} to place the generated files and directories.\n\n" + "if not specified, defaults to\n`dirname file`/cache/`basename file .tree`.", v => {} }, "", "category 3:", { "h|?|help",           "show help text",                       v => {} }, { "version",            "output version information and exit",  v => {} }, { "<>", v => {} }, new testargumentsource (new[]{"@s1", "@s2"}, "read response file for more options"), };	stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	
append indicator to directories 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
long desc this has a really 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
long multi line description that also 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
tests 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
the builtin supercalifragilisticexpialidicious 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
break on hyphen also a list 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
item 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
item 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
long iwantthisdescriptiontobreakinsideawordgeneratingau 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
towordhyphenation 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
long onlyoneperiod 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
andnowhitespaceshouldbesupportedevenwithlongdesc 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
riptions 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
long lots of spaces in the middle 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
and more until the end 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
long lots of spaces in the middle 

stringwriter expected = new stringwriter ();	expected.writeline ("");	expected.writeline ("  -p, --indicator-style=value");	expected.writeline ("      --color[=value]        controls color info");	expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	
and more until the end 

expected.writeline ("      --color2[=color]       set color");	expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	expected.writeline ("");	expected.writeline ("==this is a really long category name which will involve line wrapping, just");	expected.writeline ("because...==");	expected.writeline ("  -o, --out=directory        the directory to place the generated files and");	
directories 

expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	expected.writeline ("");	expected.writeline ("==this is a really long category name which will involve line wrapping, just");	expected.writeline ("because...==");	expected.writeline ("  -o, --out=directory        the directory to place the generated files and");	expected.writeline ("                               ");	
if not specified defaults to 

expected.writeline ("      --rk=value1:value2     required key/value option");	expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	expected.writeline ("");	expected.writeline ("==this is a really long category name which will involve line wrapping, just");	expected.writeline ("because...==");	expected.writeline ("  -o, --out=directory        the directory to place the generated files and");	expected.writeline ("                               ");	
dirname file cache basename file tree 

expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	expected.writeline ("");	expected.writeline ("==this is a really long category name which will involve line wrapping, just");	expected.writeline ("because...==");	expected.writeline ("  -o, --out=directory        the directory to place the generated files and");	expected.writeline ("                               ");	expected.writeline ("");	
category 

expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	expected.writeline ("");	expected.writeline ("==this is a really long category name which will involve line wrapping, just");	expected.writeline ("because...==");	expected.writeline ("  -o, --out=directory        the directory to place the generated files and");	expected.writeline ("                               ");	expected.writeline ("");	
h help show help text 

expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	expected.writeline ("");	expected.writeline ("==this is a really long category name which will involve line wrapping, just");	expected.writeline ("because...==");	expected.writeline ("  -o, --out=directory        the directory to place the generated files and");	expected.writeline ("                               ");	expected.writeline ("");	
version output version information and exit 

expected.writeline ("      --rk2=key:value        required {foo} key/value option");	expected.writeline ("      --rk3=value            required {foo}");	expected.writeline ("      --rk4=val              required {foo} val");	expected.writeline ("      --ok[=value1:value2]   optional key/value option");	expected.writeline ("");	expected.writeline ("==this is a really long category name which will involve line wrapping, just");	expected.writeline ("because...==");	expected.writeline ("  -o, --out=directory        the directory to place the generated files and");	expected.writeline ("                               ");	expected.writeline ("");	
read response file for more options 

public void localization () {	var p = new optionset (f => "hello!") {	{ "n=", (int v) => { } }, };	utils.assertexception (typeof(optionexception), "hello!", p, v => { v.parse (_("-n=value")); });	stringwriter expected = new stringwriter ();	
nhello hello 

========================= mono sample_32543 =========================

decimal d = 0m;	if (!(get_non_null () is object)) return 1;	if (get_null () is object) return 2;	if (!(a is object)) return 3;	if (null is object) return 4;	o = a;	if (!(o is int)) return 5;	if (d is int) return 6;	object oi = 1;	if (!(oi is int)) return 7;	
is tests pass 

========================= mono sample_3831 =========================

public static void drawselectionframe(graphics graphics, bool active, rectangle outsiderect, rectangle insiderect, color backcolor) {	if (!dsfnotimpl) {	dsfnotimpl = true;	
not implemented drawselectionframe graphics graphics bool active rectangle outsiderect rectangle insiderect color backcolor 

========================= mono sample_26152 =========================

if (args.length == 2) ss = readfilewords(args[0], int.parse(args[1]));	else ss = args;	timer t = new timer();	scg.ienumerable<scg.ienumerable<string>> classes = anagramclasses(ss);	int count = 0;	foreach (scg.ienumerable<string> anagramclass in classes) {	count++;	foreach (string s in anagramclass) console.write(s + " ");	console.writeline();	}	
non trivial anagram classes 

========================= mono sample_30557 =========================

public static int[] throwanexception ()   {	int[] arr = new int [10];	int k = arr [11];	
test failed 

public static int main ( string[] args )   {	try {	int[] arr = throwanexception ();	
test failed really 

public static int main ( string[] args )   {	try {	int[] arr = throwanexception ();	return 1;	} catch (exception e) {	
test passed 

========================= mono sample_355 =========================

public void tracing () {	trace.indentlevel = 0;	trace.indentsize = 4;	string value = "entering main" + environment.newline + "exiting main" + environment.newline;	
entering main 

public void tracing () {	trace.indentlevel = 0;	trace.indentsize = 4;	string value = "entering main" + environment.newline + "exiting main" + environment.newline;	
exiting main 

public void indent () {	trace.indentlevel = 0;	trace.indentsize = 4;	string value = "list of errors:" + environment.newline + "    error 1: file not found" + environment.newline + "    error 2: directory not found" + environment.newline + "end of list of errors" + environment.newline;	
list of errors 

public void indent () {	trace.indentlevel = 0;	trace.indentsize = 4;	string value = "list of errors:" + environment.newline + "    error 1: file not found" + environment.newline + "    error 2: directory not found" + environment.newline + "end of list of errors" + environment.newline;	trace.indent ();	assert.areequal (1, trace.indentlevel);	
error file not found 

public void indent () {	trace.indentlevel = 0;	trace.indentsize = 4;	string value = "list of errors:" + environment.newline + "    error 1: file not found" + environment.newline + "    error 2: directory not found" + environment.newline + "end of list of errors" + environment.newline;	trace.indent ();	assert.areequal (1, trace.indentlevel);	
error directory not found 

public void indent () {	trace.indentlevel = 0;	trace.indentsize = 4;	string value = "list of errors:" + environment.newline + "    error 1: file not found" + environment.newline + "    error 2: directory not found" + environment.newline + "end of list of errors" + environment.newline;	trace.indent ();	assert.areequal (1, trace.indentlevel);	trace.unindent ();	assert.areequal (0, trace.indentlevel);	
end of list of errors 

public void testmultithreadmodify () {	multithreadmodify m = new multithreadmodify ();	thread t1 = new thread (new threadstart (m.write));	thread t2 = new thread (new threadstart (m.remove));	t1.start ();	t2.start ();	t1.join ();	t2.join ();	assert.istrue (m.exception == null, m.exception);	
tmtm listener was removed before iterations were completed 

========================= mono sample_23726 =========================

public void dispose () {	
dispose 

========================= mono sample_3763 =========================

}	if (s.hit != 0) return 1;	using (var s = new s ()) {	}	if (s.hit != 1) return 2;	c c = null;	genmethod (c);	using (s? a = nullable, b = nullable) {	}	if (s.hit != 1) return 3;	
ok 

========================= mono sample_1695 =========================

public static void resolvecallback(iasyncresult ar) {	
resolvecallback 

public static void resolvecallback(iasyncresult ar) {	stacktrace st = new stacktrace();	frame_count = st.framecount;	for(int i = 0; i < st.framecount; i++) {	stackframe sf = st.getframe(i);	
method 

public static void resolvecallback(iasyncresult ar) {	stacktrace st = new stacktrace();	frame_count = st.framecount;	for(int i = 0; i < st.framecount; i++) {	stackframe sf = st.getframe(i);	}	
resolvecallback complete 

========================= mono sample_177 =========================

v *= t.prop3 -= 15;	if (v != 1455) return 4;	dynamic dvalue = 3;	int[] iar = new [] { -14 };	iar [0] += dvalue;	if (iar [0] != -11) return 5;	dynamic dn = 1;	int?[] array = new int?[1];	array[0] = dn;	if (array [0] != 1) return 6;	
ok 

========================= mono sample_1996 =========================

static void main () {	bar (out p.x);	
got 

========================= mono sample_35041 =========================

public override void writepropertyafterset(codewriter writer, dblinq.schema.dbml.column property, generationcontext context) {	writer.writeline(writer.getstatement(writer.getmethodcallexpression(sendpropertychangedmethod, writer.getliteralvalue(property.member))));	
on changed 

========================= mono sample_25059 =========================

console.outputencoding = encoding.getencoding("iso-8859-1");	scg.ienumerable<string> ss;	if (args.length == 2) ss = readfilewords(args[0], int.parse(args[1]));	else ss = args;	timer t = new timer();	scg.ienumerable<scg.ienumerable<string>> classes = anagramclasses(ss);	int count = 0;	foreach (scg.ienumerable<string> anagramclass in classes) {	count++;	}	
non trivial anagram classes 

========================= mono sample_30563 =========================

public static void main () {	list_size = 1 << 15;	testtimeout timeout = testtimeout.start(timespan.fromseconds(testtimeout.isstresstest ? 60 : 5));	for (int it1 = 1; it1 <= 10; it1++, list_size <<= 1) {	pinlist list = makelist (list_size);	
long list constructed 

========================= mono sample_270 =========================

public static void dumpfeed(syndicationfeed f, string label) {	string path = path.combine("test", label);	f.lastupdatedtime = feedlib.fixedchangeddate;	using (xmltextwriter writer = new xmltextwriter(path + ".atom.xml", null)) {	
writing atom xml 

public static void dumpfeed(syndicationfeed f, string label) {	string path = path.combine("test", label);	f.lastupdatedtime = feedlib.fixedchangeddate;	using (xmltextwriter writer = new xmltextwriter(path + ".atom.xml", null)) {	writer.formatting = formatting.indented;	atom10serializer serializer = new atom10serializer();	serializer.writeto(writer, f);	}	using (xmltextwriter writer = new xmltextwriter(path + ".rss.xml", null)) {	
writing rss xml 

========================= mono sample_29318 =========================

public static int main () {	
we can now write to the console 

========================= mono sample_330 =========================

if (res [0].result != "firstsecond") return 5;	e = from data a in d1 join data b in d2 on a.key equals b.key select new { result = a.value + b.value };	res = e.tolist ();	if (res.count != 2) return 10;	if (res [0].result != "firstsecond") return 11;	if (res [1].result != "firstthird") return 12;	var e2 = from data a in d1 join b in d2 on a.key equals b.key group b by a.key;	var res2 = e2.tolist ();	if (res2.count != 1) return 20;	if (res2 [0].key != 1) return 21;	
ok 

========================= mono sample_3945 =========================

public void printstatistics() {	
containment checks set operations intersections unions differences 

public void printstatistics() {	
errors 

========================= mono sample_13294 =========================

public void unload() {	thread = new thread(new threadstart(unloadonthread));	thread.start();	if (!thread.join(20000)) {	
unable to unload appdomain 

public void unload() {	thread = new thread(new threadstart(unloadonthread));	thread.start();	if (!thread.join(20000)) {	
unload thread timed out 

private void unloadonthread() {	bool shadowcopy = domain.shadowcopyfiles;	string cachepath = domain.setupinformation.cachepath;	string domainname = domain.friendlyname;	try {	appdomain.unload(domain);	}	catch (exception ex) {	
unable to unload appdomain 

private static void deletecachedir( directoryinfo cachedir ) {	if(cachedir.exists) {	foreach( directoryinfo dirinfo in cachedir.getdirectories() ) deletecachedir( dirinfo );	foreach( fileinfo fileinfo in cachedir.getfiles() ) {	fileinfo.attributes = fileattributes.normal;	try {	fileinfo.delete();	}	catch( exception ex ) {	
error deleting 

fileinfo.delete();	}	catch( exception ex ) {	}	}	cachedir.attributes = fileattributes.normal;	try {	cachedir.delete();	}	catch( exception ex ) {	
error deleting 

========================= mono sample_32916 =========================

public static int main() {	tester tester = new tester();	string [] list = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l" };	int top = 0;	foreach (string s in tester){	if (s != list [top]){	
failure got expected 

tester tester = new tester();	string [] list = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l" };	int top = 0;	foreach (string s in tester){	if (s != list [top]){	return 1;	}	top++;	}	if (top != list.length){	
failure expected got 

string [] list = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l" };	int top = 0;	foreach (string s in tester){	if (s != list [top]){	return 1;	}	top++;	}	if (top != list.length){	}	
success 

========================= mono sample_3464 =========================

ms.position = 0;	soapmessage t = new soapmessage ();	sf.topobject = t;	t = (soapmessage) sf.deserialize (ms);	assert.isnotnull (t.headers[0].value, "#1");	assert.areequal (t.headers[0].value.gettype (), typeof(type[]), "#2");	type[] ts = (type[]) t.headers[0].value;	assert.areequal (2, ts.length, "#3");	assert.isnotnull (ts[0], "#4");	assert.isnotnull (ts[1], "#5");	
ppp 

========================= mono sample_30710 =========================

public static int main() {	doh doh;	doh3 doh2 = new doh3 ();	bool success = false;	doh.a1 = doh.a2 = doh.a3 = doh.a4 = 0;	doh.a = 1;	if (doh.a1 == 1 && doh.a2 == 0 && doh.a3 == 0 && doh.a4 == 0) {	
little endian 

public static int main() {	doh doh;	doh3 doh2 = new doh3 ();	bool success = false;	doh.a1 = doh.a2 = doh.a3 = doh.a4 = 0;	doh.a = 1;	if (doh.a1 == 1 && doh.a2 == 0 && doh.a3 == 0 && doh.a4 == 0) {	success = true;	} else if (doh.a1 == 0 && doh.a2 == 0 && doh.a3 == 0 && doh.a4 == 1) {	
big endian 

========================= mono sample_283 =========================

j = j + 1;	};	}	console.writeline ("i = {0}", i);	b ();	console.writeline ("i = {0}", i);	if (!t (i, 11)) return 1;	b ();	if (!t (i, 12)) return 2;	console.writeline ("i = {0}", i);	
test is ok 

========================= mono sample_2499 =========================

public static int main () {	var a = new wrap () {	numbers =  { 3, 9 }	};	if (a.numbers [1] != 9) return 1;	
ok 

========================= mono sample_3435 =========================

public void testnewline() {	stringwriter writer = new stringwriter();	writer.newline = "\n\r";	assert.areequal ("\n\r", writer.newline, "newline 1");	
first 

public void testnewline() {	stringwriter writer = new stringwriter();	writer.newline = "\n\r";	assert.areequal ("\n\r", writer.newline, "newline 1");	assert.areequal ("first\n\r", writer.tostring(), "newline 2");	writer.newline = "\n";	assert.areequal ("first\n\r", writer.tostring(), "newline 3");	
second 

========================= mono sample_27139 =========================

public static void help () {	
npdbtest options iterations 

public static void help () {	
where available options are 

public static void help () {	console.writeline ("\t--protocol=2\tuse v2 protocol (not ssl related)");	console.writeline ("\t--protocol=3\tuse v3 protocol (not ssl related)");	
ssl use ssl for communication 

public static void help () {	console.writeline ("\t--protocol=2\tuse v2 protocol (not ssl related)");	console.writeline ("\t--protocol=3\tuse v3 protocol (not ssl related)");	
nossl do not use ssl for communication 

public static void help () {	console.writeline ("\t--protocol=2\tuse v2 protocol (not ssl related)");	console.writeline ("\t--protocol=3\tuse v3 protocol (not ssl related)");	
v add verbosity can be used multiple times 

public static void help () {	console.writeline ("\t--protocol=2\tuse v2 protocol (not ssl related)");	console.writeline ("\t--protocol=3\tuse v3 protocol (not ssl related)");	
echo activate npgsql logging debug log leve 

public static bool connect (int protocol, bool ssl, int verbose) {	string cs = "server=127.0.0.1;port=5432;protocol={0};user id=npgsql_tests;password=npgsql_tests;database=npgsql_tests;ssl={1}";	cs = string.format (cs, protocol, ssl);	if ((verbose > 0) && !showcs) {	
connection string 

string cs = "server=127.0.0.1;port=5432;protocol={0};user id=npgsql_tests;password=npgsql_tests;database=npgsql_tests;ssl={1}";	cs = string.format (cs, protocol, ssl);	if ((verbose > 0) && !showcs) {	showcs = true;	}	npgsqlconnection m_conn = new npgsqlconnection (cs);	m_conn.open ();	if (m_conn.state != connectionstate.open) return false;	string query = "select * from wordlist";	npgsqlcommand cmd = new npgsqlcommand (query, m_conn);	
npgsqldatareader executereader 

if (m_conn.state != connectionstate.open) return false;	string query = "select * from wordlist";	npgsqlcommand cmd = new npgsqlcommand (query, m_conn);	npgsqldatareader rdr = cmd.executereader ();	int i=0;	while (rdr.read ()) {	i++;	if (verbose > 2) console.writeline (i);	}	rdr.close ();	
npgsqldatareader executereader 

bool ssl = true;	int verbose = 0;	int protocol = 3;	if (args.length > 0) {	foreach (string arg in args) {	switch (arg.tolower ()) {	case "--protocol=2": protocol = 2;	break;	case "--protocol=3": protocol = 3;	break;	
ssl tls you cannot select between ssl tls with this tool 

break;	case "--echo": npgsqleventlog.level = loglevel.debug;	npgsqleventlog.echomessages = true;	break;	case "--help": help ();	return 0;	default: try {	iter = convert.toint32 (arg);	}	catch {	
unknown option 

help ();	return 1;	}	break;	}	}	}	int i = 0;	try {	for (i = 1; i <= iter; i++) {	
connection 

return 1;	}	break;	}	}	}	int i = 0;	try {	for (i = 1; i <= iter; i++) {	if (!connect (protocol, ssl, verbose)) {	
connection failed at iteration 

for (i = 1; i <= iter; i++) {	if (!connect (protocol, ssl, verbose)) {	break;	}	}	i--;	err = 0;	}	catch (exception e) {	err = i;	
error at iteration 

break;	}	}	i--;	err = 0;	}	catch (exception e) {	err = i;	}	finally {	
connection established and closed ssl 

========================= mono sample_20588 =========================

public static void main() {	
start test 

public static void main() {	string connectionstring = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	pgsqlconnection con;	
creating connection 

public static void main() {	string connectionstring = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	pgsqlconnection con;	con = new pgsqlconnection(connectionstring);	
opening connection 

public static void main() {	string connectionstring = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	pgsqlconnection con;	con = new pgsqlconnection(connectionstring);	con.open();	string tablename = "pg_type";	string sql;	sql = "select * from pg_tables where tablename = :intablename";	
creating command 

public static void main() {	string connectionstring = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	pgsqlconnection con;	con = new pgsqlconnection(connectionstring);	con.open();	string tablename = "pg_type";	string sql;	sql = "select * from pg_tables where tablename = :intablename";	pgsqlcommand cmd = new pgsqlcommand(sql, con);	
create parameter 

string connectionstring = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	pgsqlconnection con;	con = new pgsqlconnection(connectionstring);	con.open();	string tablename = "pg_type";	string sql;	sql = "select * from pg_tables where tablename = :intablename";	pgsqlcommand cmd = new pgsqlcommand(sql, con);	pgsqlparameter parm = new pgsqlparameter("intablename", dbtype.string);	
set dbtype of parameter to string 

connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	pgsqlconnection con;	con = new pgsqlconnection(connectionstring);	con.open();	string tablename = "pg_type";	string sql;	sql = "select * from pg_tables where tablename = :intablename";	pgsqlcommand cmd = new pgsqlcommand(sql, con);	pgsqlparameter parm = new pgsqlparameter("intablename", dbtype.string);	parm.dbtype = dbtype.string;	
set direction of parameter to input 

pgsqlconnection con;	con = new pgsqlconnection(connectionstring);	con.open();	string tablename = "pg_type";	string sql;	sql = "select * from pg_tables where tablename = :intablename";	pgsqlcommand cmd = new pgsqlcommand(sql, con);	pgsqlparameter parm = new pgsqlparameter("intablename", dbtype.string);	parm.dbtype = dbtype.string;	parm.direction = parameterdirection.input;	
set value to the tablename string 

con = new pgsqlconnection(connectionstring);	con.open();	string tablename = "pg_type";	string sql;	sql = "select * from pg_tables where tablename = :intablename";	pgsqlcommand cmd = new pgsqlcommand(sql, con);	pgsqlparameter parm = new pgsqlparameter("intablename", dbtype.string);	parm.dbtype = dbtype.string;	parm.direction = parameterdirection.input;	parm.value = tablename;	
add parameter to parameters collection in the command 

string tablename = "pg_type";	string sql;	sql = "select * from pg_tables where tablename = :intablename";	pgsqlcommand cmd = new pgsqlcommand(sql, con);	pgsqlparameter parm = new pgsqlparameter("intablename", dbtype.string);	parm.dbtype = dbtype.string;	parm.direction = parameterdirection.input;	parm.value = tablename;	cmd.parameters.add(parm);	pgsqldatareader rdr;	
executereader 

string sql;	sql = "select * from pg_tables where tablename = :intablename";	pgsqlcommand cmd = new pgsqlcommand(sql, con);	pgsqlparameter parm = new pgsqlparameter("intablename", dbtype.string);	parm.dbtype = dbtype.string;	parm.direction = parameterdirection.input;	parm.value = tablename;	cmd.parameters.add(parm);	pgsqldatareader rdr;	rdr = cmd.executereader();	
and now we are going to our results 

parm.dbtype = dbtype.string;	parm.direction = parameterdirection.input;	parm.value = tablename;	cmd.parameters.add(parm);	pgsqldatareader rdr;	rdr = cmd.executereader();	int c;	int results = 0;	do {	results++;	
result set 

parm.direction = parameterdirection.input;	parm.value = tablename;	cmd.parameters.add(parm);	pgsqldatareader rdr;	rdr = cmd.executereader();	int c;	int results = 0;	do {	results++;	datatable dt = rdr.getschematable();	
total columns 

do {	results++;	datatable dt = rdr.getschematable();	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	console.writeline();	}	string output, metadatavalue, datavalue;	int nrows = 0;	while(rdr.read()) {	
row 

for(c = 0; c < rdr.fieldcount; c++) {	datarow dr = dt.rows[c];	metadatavalue = "    col " + c + ": " + dr["columnname"];	if(rdr.isdbnull(c) == true) datavalue = " is null";	else datavalue = ": " + rdr.getvalue(c);	output = metadatavalue + datavalue;	console.writeline(output);	}	nrows++;	}	
total rows 

datarow dr = dt.rows[c];	metadatavalue = "    col " + c + ": " + dr["columnname"];	if(rdr.isdbnull(c) == true) datavalue = " is null";	else datavalue = ": " + rdr.getvalue(c);	output = metadatavalue + datavalue;	console.writeline(output);	}	nrows++;	}	} while(rdr.nextresult());	
total result sets 

========================= mono sample_28409 =========================

public static int main () {	int total = 0;	foreach (int i in getit ()) {	
got 

========================= mono sample_2017 =========================

static void main(string[] args) {	try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	customsection sect = (customsection)config.getsection("customsection");	foreach (string key in sect.settings.allkeys) {	keyvalueconfigurationelement e = sect.settings[key];	console.writeline ("{0} = {1}", e.key, e.value);	}	}	catch (exception e) {	
exception raised 

========================= mono sample_29837 =========================

private bool validateparameters() {	if (projectdirectory == null || projectdirectory.trim().length == 0) {	
noprojecttype 

private bool validateparameters() {	if (projectdirectory == null || projectdirectory.trim().length == 0) {	return false;	}	if (projectextension == null || projectextension.trim().length == 0) {	
noprojecttype 

private bool validateparameters() {	if (projectdirectory == null || projectdirectory.trim().length == 0) {	return false;	}	if (projectextension == null || projectextension.trim().length == 0) {	return false;	}	if (string.compare(projectextension, ".csproj", stringcomparison.ordinalignorecase) != 0 && string.compare(projectextension, ".vbproj", stringcomparison.ordinalignorecase) != 0) {	
unsupportedprojecttype 

========================= mono sample_12946 =========================

public void constructionanddefaultattributes () {	string dtd = "<!doctype root [<!element root empty><!attlist root foo cdata 'def'>]>";	string xml = dtd + "<root />";	xmldocument doc = new xmldocument ();	doc.loadxml (xml);	console.writeline (doc.documentelement.attributes.count);	
root 

========================= mono sample_22361 =========================

public static int main () {	rect rect = new rect ();	rect.x += 20;	
should be 

========================= mono sample_2264 =========================

public void testcurrencymanagerbindings () {	dataset data_source = createrelateddatasetlarge ();	bindingcontext bc = new bindingcontext ();	currencymanager cm = bc [data_source] as currencymanager;	
cm properties 

public void testcurrencymanagerbindings () {	dataset data_source = createrelateddatasetlarge ();	bindingcontext bc = new bindingcontext ();	currencymanager cm = bc [data_source] as currencymanager;	foreach (propertydescriptor pd in cm.getitemproperties ()) debugwriteline (" + {0}", pd.name);	debugwriteline ();	
dataset 

public void testcurrencymanagerbindings () {	dataset data_source = createrelateddatasetlarge ();	bindingcontext bc = new bindingcontext ();	currencymanager cm = bc [data_source] as currencymanager;	foreach (propertydescriptor pd in cm.getitemproperties ()) debugwriteline (" + {0}", pd.name);	debugwriteline ();	debugwriteline ("cm = {0}", cm.gettype());	debugwriteline ("cm.count = {0}", cm.count);	cm.position = 0;	debugwriteline ("cm.current = {0}", cm.current);	
cm current properties 

currencymanager cm = bc [data_source] as currencymanager;	foreach (propertydescriptor pd in cm.getitemproperties ()) debugwriteline (" + {0}", pd.name);	debugwriteline ();	debugwriteline ("cm = {0}", cm.gettype());	debugwriteline ("cm.count = {0}", cm.count);	cm.position = 0;	debugwriteline ("cm.current = {0}", cm.current);	foreach (propertydescriptor pd in ((icustomtypedescriptor)cm.current).getproperties ()) debugwriteline (" + {0}", pd.name);	debugwriteline ();	cm = bc [data_source.tables["customers"]] as currencymanager;	
datatable 

debugwriteline ("cm.count = {0}", cm.count);	cm.position = 0;	debugwriteline ("cm.current = {0}", cm.current);	foreach (propertydescriptor pd in ((icustomtypedescriptor)cm.current).getproperties ()) debugwriteline (" + {0}", pd.name);	debugwriteline ();	cm = bc [data_source.tables["customers"]] as currencymanager;	debugwriteline ("cm = {0}", cm.gettype());	debugwriteline ("cm.count = {0}", cm.count);	cm.position = 0;	debugwriteline ("cm.current = {0}", cm.current);	
cm current properties 

foreach (propertydescriptor pd in ((icustomtypedescriptor)cm.current).getproperties ()) debugwriteline (" + {0}", pd.name);	debugwriteline ();	cm = bc [data_source.tables["customers"]] as currencymanager;	debugwriteline ("cm = {0}", cm.gettype());	debugwriteline ("cm.count = {0}", cm.count);	cm.position = 0;	debugwriteline ("cm.current = {0}", cm.current);	foreach (propertydescriptor pd in ((icustomtypedescriptor)cm.current).getproperties ()) debugwriteline (" + {0}", pd.name);	debugwriteline ();	dataviewmanager vm = new dataviewmanager (data_source);	
vm properties 

========================= mono sample_25501 =========================

public void stuff() {	string myldappath = "ldap: try {	mono.directory.ldap.ldap ld = new mono.directory.ldap.ldap (myldappath);	ldapmessage res, entry;	string[] attrs = { "+", null };	ld.search ("" /* root dse */, searchscope.base, "(objectclass=*)", attrs, false, timespan.fromseconds(10), 0 /* no size limit */, out res);	if (res == null) {	
the search failed 

public void stuff() {	string myldappath = "ldap: try {	mono.directory.ldap.ldap ld = new mono.directory.ldap.ldap (myldappath);	ldapmessage res, entry;	string[] attrs = { "+", null };	ld.search ("" /* root dse */, searchscope.base, "(objectclass=*)", attrs, false, timespan.fromseconds(10), 0 /* no size limit */, out res);	if (res == null) {	}	
there are entries 

mono.directory.ldap.ldap ld = new mono.directory.ldap.ldap (myldappath);	ldapmessage res, entry;	string[] attrs = { "+", null };	ld.search ("" /* root dse */, searchscope.base, "(objectclass=*)", attrs, false, timespan.fromseconds(10), 0 /* no size limit */, out res);	if (res == null) {	}	entry = res.firstentry();	if (entry == null) console.writeline ("null returned from res.firstentry");	string[] extensions = entry.getvalues ("supportedextension");	if (extensions != null) {	
supported extension 

string[] attrs = { "+", null };	ld.search ("" /* root dse */, searchscope.base, "(objectclass=*)", attrs, false, timespan.fromseconds(10), 0 /* no size limit */, out res);	if (res == null) {	}	entry = res.firstentry();	if (entry == null) console.writeline ("null returned from res.firstentry");	string[] extensions = entry.getvalues ("supportedextension");	if (extensions != null) {	}	else {	
null returned from entry getvalues 

}	entry = res.firstentry();	if (entry == null) console.writeline ("null returned from res.firstentry");	string[] extensions = entry.getvalues ("supportedextension");	if (extensions != null) {	}	else {	}	}	catch(exception e) {	
the path not found 

}	entry = res.firstentry();	if (entry == null) console.writeline ("null returned from res.firstentry");	string[] extensions = entry.getvalues ("supportedextension");	if (extensions != null) {	}	else {	}	}	catch(exception e) {	
exception 

========================= mono sample_21108 =========================

x x = new x();	x.m (10);	e ();	console.writeline ("j should be 11= {0}", j);	e ();	console.writeline ("j should be 11= {0}", j);	x.m (100);	e ();	console.writeline ("j should be 101= {0}", j);	if (j != 101) return 3;	
ok 

========================= mono sample_3388 =========================

exiter.client.exitprocess (0);	environment.exit (0);	}	string assemblyname = "system.servicemodel_test_net_3_0.dll";	assembly assem;	try {	system.io.fileinfo fi = new fileinfo (assembly.getentryassembly ().location);	assem = assembly.loadfrom (path.combine (fi.directory.fullname, assemblyname));	}	catch (exception e) {	
could not start server could not load 

try {	system.io.fileinfo fi = new fileinfo (assembly.getentryassembly ().location);	assem = assembly.loadfrom (path.combine (fi.directory.fullname, assemblyname));	}	catch (exception e) {	return;	}	monotests.features.configuration.onlyservers = true;	program p = new program ();	p.runallinits (assem);	
press any key to continue 

system.io.fileinfo fi = new fileinfo (assembly.getentryassembly ().location);	assem = assembly.loadfrom (path.combine (fi.directory.fullname, assemblyname));	}	catch (exception e) {	return;	}	monotests.features.configuration.onlyservers = true;	program p = new program ();	p.runallinits (assem);	console.readkey ();	
bye bye 

========================= mono sample_31306 =========================

protected internal override void render(htmltextwriter writer) {	if (_styles.any(s => !s.empty)) {	writer.addattribute(htmltextwriterattribute.type, "text/css");	writer.renderbegintag(htmltextwritertag.style);	
cdata 

========================= mono sample_7486 =========================

public override bool trygetmember (getmemberbinder binder, out object result) {	
get 

public override bool tryinvokemember (invokememberbinder binder, object[] args, out object result) {	
invoke 

public static int main () {	dynamic d = new myobject ();	var g = d.getme;	if (myobject.get != 1 && myobject.invoke != 0) return 1;	d.printf ("hello, world!");	if (myobject.get != 1 && myobject.invoke != 1) return 2;	
ok 

========================= mono sample_2163 =========================

renderbegincardtag(writer);	_writtenformvariables = true;	if (_formvariables == null) {	_formvariables = new listdictionary();	}	_formvariables[_postbackeventtargetvarname] = string.empty;	_formvariables[_postbackeventargumentvarname] = string.empty;	writer.write("<onevent type=\"onenterforward\"><refresh>");	rendersetformvariables(writer);	renderposturlformvariable(writer);	
refresh onevent 

_formvariables = new listdictionary();	}	_formvariables[_postbackeventtargetvarname] = string.empty;	_formvariables[_postbackeventargumentvarname] = string.empty;	writer.write("<onevent type=\"onenterforward\"><refresh>");	rendersetformvariables(writer);	renderposturlformvariable(writer);	writer.write("<onevent type=\"onenterbackward\"><refresh>");	rendersetformvariables(writer);	renderposturlformvariable(writer);	
refresh onevent 

protected virtual void renderbegincardtag(wmltextwriter writer) {	
card 

private void renderpostbackcard(wmltextwriter writer) {	if (!_writtenpostback) {	return;	}	writer.writebegintag("card");	writer.writeattribute("id", wmltextwriter.postbackwithvarscardid);	writer.writeline(">");	writer.write("<onevent type=\"onenterforward\">");	renderformpostingoaction(writer, null, _postbackeventargumentvarname, wmlpostfieldtype.variable, string.empty);	
onevent 

private void renderpostbackcard(wmltextwriter writer) {	if (!_writtenpostback) {	return;	}	writer.writebegintag("card");	writer.writeattribute("id", wmltextwriter.postbackwithvarscardid);	writer.writeline(">");	writer.write("<onevent type=\"onenterforward\">");	renderformpostingoaction(writer, null, _postbackeventargumentvarname, wmlpostfieldtype.variable, string.empty);	writer.writeline("<onevent type=\"onenterbackward\"><prev /></onevent>");	
card 

========================= mono sample_7746 =========================

public static void main () {	arraylist fields = new arraylist ();	field fb;	while (fields.count > 0) {	fb = (field) fields[0];	}	if (fb.name != "b") {	
shouldn t compile here 

========================= mono sample_34432 =========================

var parsed = from t in new[] { "2" } select int.parse (t);	if (parsed.first () != 2) return 1;	var s = new string[] { "x", "a" };	array.sort (s, (a, b) => string.compare (a, b));	if (s[0] != "a") return 10;	if (s[1] != "x") return 11;	func<int> i = () => prop;	if (i () != 4) return 20;	var em = new ienumerable[] { new int[] { 1 } }.select (l => l.cast<int> ()).first ().first ();	if (em != 1) return 30;	
ok 

========================= mono sample_2023 =========================

public static int main () {	int a;	int *b;	int **c;	a = 42;	b = &a;	c = &b;	console.writeline ("*c == b : {0}", *c == b);	console.writeline ("**c == a : {0}", **c == a);	if (*c == b && **c == a) {	
test passed 

int **c;	a = 42;	b = &a;	c = &b;	console.writeline ("*c == b : {0}", *c == b);	console.writeline ("**c == a : {0}", **c == a);	if (*c == b && **c == a) {	return 0;	}	else {	
test failed 

========================= mono sample_2190 =========================

public static void teststyles(streamwriter file, control control, string name) {	string[] results;	results = getstyles(control);	
test 

public static void teststyles(streamwriter file, control control, string name) {	string[] results;	results = getstyles(control);	
public void styletest 

file.writeline("\t\t{");	file.writeline("\t\t\tstring[] {0}_want = {{", name);	for (int i=0; i < results.length; i++) {	if ((i+1) != results.length) {	file.writeline("\t\t\t\t\"{0}\",", results[i]);	} else {	file.writeline("\t\t\t\t\"{0}\"", results[i]);	}	}	file.writeline("\t\t\t};\n");	
assert areequal want getstyles new 

========================= mono sample_25475 =========================

static private void help () {	
usage certificate crl certificate crl outputfile spc 

static int main (string[] args) {	int result = 1;	try {	header ();	result = process (args);	if (error == null) console.writeline ("success");	else {	
error 

int result = 1;	try {	header ();	result = process (args);	if (error == null) console.writeline ("success");	else {	help ();	}	}	catch (exception e) {	
error 

========================= mono sample_1179 =========================

public override message request (message req, timespan timeout) {	xmlwritersettings settings = new xmlwritersettings ();	settings.indent = true;	messagebuffer buf = req.createbufferedcopy (0x10000);	using (xmlwriter w = xmlwriter.create (console.error, settings)) {	buf.createmessage ().writemessage (w);	}	
debug request 

========================= mono sample_31295 =========================

public symvalue addjointedge (symvalue v1target, symvalue v2target, tfunc function, symvalue resultarg) {	symvalue result = lookupmapping (v1target, v2target);	bool newedge = false;	if (result == null) {	if (ismappingalreadyadded (v1target, v2target)) {	
symgraph changed due to pre existing mapping in of 

}	else if (this.result.lookupwithoutmanifesting (resultarg, function) == result) return null;	this.result[function, resultarg] = result;	tadomain val1 = graph1adomain (v1target);	tadomain val2 = graph2adomain (v2target);	bool weaker;	tadomain join = val1.join (val2, this.widen, out weaker);	this.result[result] = join;	if (weaker) {	if (debugoptions.debug) {	
symgraph changed due to join of abstract values of prev new join 

public symvalue addjointedge (symvalue v1target, symvalue v2target, tfunc function, symvalue[] resultargs) {	symvalue result = lookupmapping (v1target, v2target);	bool newedge = false;	if (result == null) {	if (ismappingalreadyadded (v1target, v2target)) {	
symgraph changed due to pre existing mapping in of 

addmapping (v1target, v2target, result);	}	else if (this.result.lookupwithoutmanifesting (resultargs, function) == result) return null;	this.result[resultargs, function] = result;	tadomain val1 = graph1adomain (v1target);	tadomain val2 = graph2adomain (v2target);	bool weaker;	tadomain joinvalue = val1.join (val2, this.widen, out weaker);	this.result[result] = joinvalue;	if (weaker) {	
symgraph changed due to join of abstract values of prev new join 

this.result[resultargs, function] = result;	tadomain val1 = graph1adomain (v1target);	tadomain val2 = graph2adomain (v2target);	bool weaker;	tadomain joinvalue = val1.join (val2, this.widen, out weaker);	this.result[result] = joinvalue;	if (weaker) {	changed = true;	}	if (debugoptions.debug) {	
addjointedge 

symvalue v1 = this.graph1.lookupwithoutmanifesting (sv1, function);	bool isplaceholder;	symvalue v2 = this.graph2.lookuporbottomplaceholder (sv2, function, out isplaceholder);	if (!isplaceholder || function.keepasbottomfield) {	symvalue r1 = addjointedge (v1, v2, function, r);	if (r1 != null) joinsymbolicvalue (v1, v2, r1);	}	}	}	} else if (!this.widen && this.graph1.hasallbottomfields (sv1)) {	
symgraph changed due to an all bottom field value in changing to non bottom 

if (r1 != null) joinsymbolicvalue (v1, v2, r1);	}	}	}	} else {	ienumerable<tfunc> functions;	if (this.widen) {	if (this.graph1.termmap.keys2count (sv1) <= this.graph2.termmap.keys2count (sv2)) functions = this.graph1.termmap.keys2 (sv1);	else {	functions = this.graph2.termmap.keys2 (sv2);	
symgraph changed because has fewer keys for than in 

ienumerable<tfunc> functions;	if (this.widen) {	if (this.graph1.termmap.keys2count (sv1) <= this.graph2.termmap.keys2count (sv2)) functions = this.graph1.termmap.keys2 (sv1);	else {	functions = this.graph2.termmap.keys2 (sv2);	changed = true;	}	} else {	if (this.graph1.termmap.keys2count (sv1) < this.graph2.termmap.keys2count (sv2)) {	functions = this.graph2.termmap.keys2 (sv2);	
symgraph changed because has fewer keys for than in 

if (this.graph1.termmap.keys2count (sv1) < this.graph2.termmap.keys2count (sv2)) {	functions = this.graph2.termmap.keys2 (sv2);	changed = true;	} else functions = this.graph1.termmap.keys2 (sv1);	}	foreach (tfunc function in functions) {	symvalue v1 = this.graph1.lookupwithoutmanifesting (sv1, function);	symvalue v2 = this.graph2.lookupwithoutmanifesting (sv2, function);	if (v1 == null) {	if (!this.widen && function.manifestfield) {	
symgraph changed due to manifestation of a top edge in 

}	foreach (tfunc function in functions) {	symvalue v1 = this.graph1.lookupwithoutmanifesting (sv1, function);	symvalue v2 = this.graph2.lookupwithoutmanifesting (sv2, function);	if (v1 == null) {	if (!this.widen && function.manifestfield) {	changed = true;	} else continue;	}	if (v2 == null && (this.widen || !function.manifestfield)) {	
symgraph changed due to absence of map in 

========================= mono sample_29502 =========================

public override bool execute () {	if (sourcefiles.length == 0) return true;	try {	list <itaskitem> temporarycopiedfiles = new list <itaskitem> ();	if (sourcefiles != null && destinationfiles != null && sourcefiles.length != destinationfiles.length) {	
number of source files is different than number of destination files 

public override bool execute () {	if (sourcefiles.length == 0) return true;	try {	list <itaskitem> temporarycopiedfiles = new list <itaskitem> ();	if (sourcefiles != null && destinationfiles != null && sourcefiles.length != destinationfiles.length) {	return false;	}	if (destinationfiles != null && destinationfolder != null) {	
you must specify only one attribute from destinationfiles and destinationfolder 

if (destinationfiles != null && destinationfolder != null) {	return false;	}	if (destinationfiles != null && destinationfiles.length > 0) {	for (int i = 0; i < sourcefiles.length; i ++) {	itaskitem sourceitem = sourcefiles [i];	itaskitem destinationitem = destinationfiles [i];	string sourcefile = sourceitem.getmetadata ("fullpath");	string destinationfile = destinationitem.getmetadata ("fullpath");	if (!file.exists (sourcefile)) {	
cannot copy to as the source file doesn t exist 

}	} else if (destinationfolder != null) {	list<itaskitem> temporarydestinationfiles = new list<itaskitem> ();	string destinationdirectory = destinationfolder.getmetadata ("fullpath");	bool directorycreated = createdirectoryifrequired (destinationdirectory);	foreach (itaskitem sourceitem in sourcefiles) {	string sourcefile = sourceitem.getmetadata ("fullpath");	string filename = sourceitem.getmetadata ("filename") + sourceitem.getmetadata ("extension");	string destinationfile = path.combine (destinationdirectory,filename);	if (!file.exists (sourcefile)) {	
cannot copy to as the source file doesn t exist 

string destinationfile = path.combine (destinationdirectory,filename);	if (!file.exists (sourcefile)) {	continue;	}	if (!skipunchangedfiles || directorycreated || hasfilechanged (sourcefile, destinationfile)) copyfilewithretries (sourcefile, destinationfile, false);	temporarycopiedfiles.add (new taskitem ( path.combine (destinationfolder.getmetadata ("identity"), filename), sourceitem.clonecustommetadata ()));	temporarydestinationfiles.add (new taskitem ( path.combine (destinationfolder.getmetadata ("identity"), filename), sourceitem.clonecustommetadata ()));	}	destinationfiles = temporarydestinationfiles.toarray ();	} else {	
you must specify destinationfolder or destinationfiles attribute 

========================= mono sample_22235 =========================

public static int main () {	foo (a : -9);	b b = new b ();	b [8] = 5;	if (b.index != 9) return 1;	
ok 

========================= mono sample_2221 =========================

public static int main (string[] args) {	sbyte1 s1;	s1.f1 = 1;	s1 = mono_return_sbyte1(s1, 9);	if (s1.f1 != 1+9) {	
got but expected 

s1.f1 = 1;	s1 = mono_return_sbyte1(s1, 9);	if (s1.f1 != 1+9) {	return 1;	}	sbyte2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_sbyte2(s2, 9);	if (s2.f1 != 1+9) {	
got but expected 

return 1;	}	sbyte2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_sbyte2(s2, 9);	if (s2.f1 != 1+9) {	return 1;	}	if (s2.f2 != 2+9) {	
got but expected 

}	if (s2.f2 != 2+9) {	return 2;	}	sbyte3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_sbyte3(s3, 9);	if (s3.f1 != 1+9) {	
got but expected 

}	sbyte3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_sbyte3(s3, 9);	if (s3.f1 != 1+9) {	return 1;	}	if (s3.f2 != 2+9) {	
got but expected 

s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_sbyte3(s3, 9);	if (s3.f1 != 1+9) {	return 1;	}	if (s3.f2 != 2+9) {	return 2;	}	if (s3.f3 != 3+9) {	
got but expected 

if (s3.f3 != 3+9) {	return 3;	}	sbyte4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_sbyte4(s4, 9);	if (s4.f1 != 1+9) {	
got but expected 

sbyte4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_sbyte4(s4, 9);	if (s4.f1 != 1+9) {	return 1;	}	if (s4.f2 != 2+9) {	
got but expected 

s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_sbyte4(s4, 9);	if (s4.f1 != 1+9) {	return 1;	}	if (s4.f2 != 2+9) {	return 2;	}	if (s4.f3 != 3+9) {	
got but expected 

if (s4.f1 != 1+9) {	return 1;	}	if (s4.f2 != 2+9) {	return 2;	}	if (s4.f3 != 3+9) {	return 3;	}	if (s4.f4 != 4+9) {	
got but expected 

return 4;	}	sbyte5 s5;	s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_sbyte5(s5, 9);	if (s5.f1 != 1+9) {	
got but expected 

s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_sbyte5(s5, 9);	if (s5.f1 != 1+9) {	return 1;	}	if (s5.f2 != 2+9) {	
got but expected 

s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_sbyte5(s5, 9);	if (s5.f1 != 1+9) {	return 1;	}	if (s5.f2 != 2+9) {	return 2;	}	if (s5.f3 != 3+9) {	
got but expected 

if (s5.f1 != 1+9) {	return 1;	}	if (s5.f2 != 2+9) {	return 2;	}	if (s5.f3 != 3+9) {	return 3;	}	if (s5.f4 != 4+9) {	
got but expected 

if (s5.f2 != 2+9) {	return 2;	}	if (s5.f3 != 3+9) {	return 3;	}	if (s5.f4 != 4+9) {	return 4;	}	if (s5.f5 != 5+9) {	
got but expected 

}	sbyte6 s6;	s6.f1 = 1;	s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_sbyte6(s6, 9);	if (s6.f1 != 1+9) {	
got but expected 

s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_sbyte6(s6, 9);	if (s6.f1 != 1+9) {	return 1;	}	if (s6.f2 != 2+9) {	
got but expected 

s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_sbyte6(s6, 9);	if (s6.f1 != 1+9) {	return 1;	}	if (s6.f2 != 2+9) {	return 2;	}	if (s6.f3 != 3+9) {	
got but expected 

if (s6.f1 != 1+9) {	return 1;	}	if (s6.f2 != 2+9) {	return 2;	}	if (s6.f3 != 3+9) {	return 3;	}	if (s6.f4 != 4+9) {	
got but expected 

if (s6.f2 != 2+9) {	return 2;	}	if (s6.f3 != 3+9) {	return 3;	}	if (s6.f4 != 4+9) {	return 4;	}	if (s6.f5 != 5+9) {	
got but expected 

if (s6.f3 != 3+9) {	return 3;	}	if (s6.f4 != 4+9) {	return 4;	}	if (s6.f5 != 5+9) {	return 5;	}	if (s6.f6 != 6+9) {	
got but expected 

sbyte7 s7;	s7.f1 = 1;	s7.f2 = 2;	s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_sbyte7(s7, 9);	if (s7.f1 != 1+9) {	
got but expected 

s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_sbyte7(s7, 9);	if (s7.f1 != 1+9) {	return 1;	}	if (s7.f2 != 2+9) {	
got but expected 

s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_sbyte7(s7, 9);	if (s7.f1 != 1+9) {	return 1;	}	if (s7.f2 != 2+9) {	return 2;	}	if (s7.f3 != 3+9) {	
got but expected 

if (s7.f1 != 1+9) {	return 1;	}	if (s7.f2 != 2+9) {	return 2;	}	if (s7.f3 != 3+9) {	return 3;	}	if (s7.f4 != 4+9) {	
got but expected 

if (s7.f2 != 2+9) {	return 2;	}	if (s7.f3 != 3+9) {	return 3;	}	if (s7.f4 != 4+9) {	return 4;	}	if (s7.f5 != 5+9) {	
got but expected 

if (s7.f3 != 3+9) {	return 3;	}	if (s7.f4 != 4+9) {	return 4;	}	if (s7.f5 != 5+9) {	return 5;	}	if (s7.f6 != 6+9) {	
got but expected 

if (s7.f4 != 4+9) {	return 4;	}	if (s7.f5 != 5+9) {	return 5;	}	if (s7.f6 != 6+9) {	return 6;	}	if (s7.f7 != 7+9) {	
got but expected 

s8.f1 = 1;	s8.f2 = 2;	s8.f3 = 3;	s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_sbyte8(s8, 9);	if (s8.f1 != 1+9) {	
got but expected 

s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_sbyte8(s8, 9);	if (s8.f1 != 1+9) {	return 1;	}	if (s8.f2 != 2+9) {	
got but expected 

s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_sbyte8(s8, 9);	if (s8.f1 != 1+9) {	return 1;	}	if (s8.f2 != 2+9) {	return 2;	}	if (s8.f3 != 3+9) {	
got but expected 

if (s8.f1 != 1+9) {	return 1;	}	if (s8.f2 != 2+9) {	return 2;	}	if (s8.f3 != 3+9) {	return 3;	}	if (s8.f4 != 4+9) {	
got but expected 

if (s8.f2 != 2+9) {	return 2;	}	if (s8.f3 != 3+9) {	return 3;	}	if (s8.f4 != 4+9) {	return 4;	}	if (s8.f5 != 5+9) {	
got but expected 

if (s8.f3 != 3+9) {	return 3;	}	if (s8.f4 != 4+9) {	return 4;	}	if (s8.f5 != 5+9) {	return 5;	}	if (s8.f6 != 6+9) {	
got but expected 

if (s8.f4 != 4+9) {	return 4;	}	if (s8.f5 != 5+9) {	return 5;	}	if (s8.f6 != 6+9) {	return 6;	}	if (s8.f7 != 7+9) {	
got but expected 

if (s8.f5 != 5+9) {	return 5;	}	if (s8.f6 != 6+9) {	return 6;	}	if (s8.f7 != 7+9) {	return 7;	}	if (s8.f8 != 8+9) {	
got but expected 

s9.f2 = 2;	s9.f3 = 3;	s9.f4 = 4;	s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_sbyte9(s9, 9);	if (s9.f1 != 1+9) {	
got but expected 

s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_sbyte9(s9, 9);	if (s9.f1 != 1+9) {	return 1;	}	if (s9.f2 != 2+9) {	
got but expected 

s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_sbyte9(s9, 9);	if (s9.f1 != 1+9) {	return 1;	}	if (s9.f2 != 2+9) {	return 2;	}	if (s9.f3 != 3+9) {	
got but expected 

if (s9.f1 != 1+9) {	return 1;	}	if (s9.f2 != 2+9) {	return 2;	}	if (s9.f3 != 3+9) {	return 3;	}	if (s9.f4 != 4+9) {	
got but expected 

if (s9.f2 != 2+9) {	return 2;	}	if (s9.f3 != 3+9) {	return 3;	}	if (s9.f4 != 4+9) {	return 4;	}	if (s9.f5 != 5+9) {	
got but expected 

if (s9.f3 != 3+9) {	return 3;	}	if (s9.f4 != 4+9) {	return 4;	}	if (s9.f5 != 5+9) {	return 5;	}	if (s9.f6 != 6+9) {	
got but expected 

if (s9.f4 != 4+9) {	return 4;	}	if (s9.f5 != 5+9) {	return 5;	}	if (s9.f6 != 6+9) {	return 6;	}	if (s9.f7 != 7+9) {	
got but expected 

if (s9.f5 != 5+9) {	return 5;	}	if (s9.f6 != 6+9) {	return 6;	}	if (s9.f7 != 7+9) {	return 7;	}	if (s9.f8 != 8+9) {	
got but expected 

if (s9.f6 != 6+9) {	return 6;	}	if (s9.f7 != 7+9) {	return 7;	}	if (s9.f8 != 8+9) {	return 8;	}	if (s9.f9 != 9+9) {	
got but expected 

s10.f3 = 3;	s10.f4 = 4;	s10.f5 = 5;	s10.f6 = 6;	s10.f7 = 7;	s10.f8 = 8;	s10.f9 = 9;	s10.f10 = 10;	s10 = mono_return_sbyte10(s10, 9);	if (s10.f1 != 1+9) {	
got but expected 

s10.f6 = 6;	s10.f7 = 7;	s10.f8 = 8;	s10.f9 = 9;	s10.f10 = 10;	s10 = mono_return_sbyte10(s10, 9);	if (s10.f1 != 1+9) {	return 1;	}	if (s10.f2 != 2+9) {	
got but expected 

s10.f9 = 9;	s10.f10 = 10;	s10 = mono_return_sbyte10(s10, 9);	if (s10.f1 != 1+9) {	return 1;	}	if (s10.f2 != 2+9) {	return 2;	}	if (s10.f3 != 3+9) {	
got but expected 

if (s10.f1 != 1+9) {	return 1;	}	if (s10.f2 != 2+9) {	return 2;	}	if (s10.f3 != 3+9) {	return 3;	}	if (s10.f4 != 4+9) {	
got but expected 

if (s10.f2 != 2+9) {	return 2;	}	if (s10.f3 != 3+9) {	return 3;	}	if (s10.f4 != 4+9) {	return 4;	}	if (s10.f5 != 5+9) {	
got but expected 

if (s10.f3 != 3+9) {	return 3;	}	if (s10.f4 != 4+9) {	return 4;	}	if (s10.f5 != 5+9) {	return 5;	}	if (s10.f6 != 6+9) {	
got but expected 

if (s10.f4 != 4+9) {	return 4;	}	if (s10.f5 != 5+9) {	return 5;	}	if (s10.f6 != 6+9) {	return 6;	}	if (s10.f7 != 7+9) {	
got but expected 

if (s10.f5 != 5+9) {	return 5;	}	if (s10.f6 != 6+9) {	return 6;	}	if (s10.f7 != 7+9) {	return 7;	}	if (s10.f8 != 8+9) {	
got but expected 

if (s10.f6 != 6+9) {	return 6;	}	if (s10.f7 != 7+9) {	return 7;	}	if (s10.f8 != 8+9) {	return 8;	}	if (s10.f9 != 9+9) {	
got but expected 

if (s10.f7 != 7+9) {	return 7;	}	if (s10.f8 != 8+9) {	return 8;	}	if (s10.f9 != 9+9) {	return 9;	}	if (s10.f10 != 10+9) {	
got but expected 

s11.f4 = 4;	s11.f5 = 5;	s11.f6 = 6;	s11.f7 = 7;	s11.f8 = 8;	s11.f9 = 9;	s11.f10 = 10;	s11.f11 = 11;	s11 = mono_return_sbyte11(s11, 9);	if (s11.f1 != 1+9) {	
got but expected 

s11.f7 = 7;	s11.f8 = 8;	s11.f9 = 9;	s11.f10 = 10;	s11.f11 = 11;	s11 = mono_return_sbyte11(s11, 9);	if (s11.f1 != 1+9) {	return 1;	}	if (s11.f2 != 2+9) {	
got but expected 

s11.f10 = 10;	s11.f11 = 11;	s11 = mono_return_sbyte11(s11, 9);	if (s11.f1 != 1+9) {	return 1;	}	if (s11.f2 != 2+9) {	return 2;	}	if (s11.f3 != 3+9) {	
got but expected 

if (s11.f1 != 1+9) {	return 1;	}	if (s11.f2 != 2+9) {	return 2;	}	if (s11.f3 != 3+9) {	return 3;	}	if (s11.f4 != 4+9) {	
got but expected 

if (s11.f2 != 2+9) {	return 2;	}	if (s11.f3 != 3+9) {	return 3;	}	if (s11.f4 != 4+9) {	return 4;	}	if (s11.f5 != 5+9) {	
got but expected 

if (s11.f3 != 3+9) {	return 3;	}	if (s11.f4 != 4+9) {	return 4;	}	if (s11.f5 != 5+9) {	return 5;	}	if (s11.f6 != 6+9) {	
got but expected 

if (s11.f4 != 4+9) {	return 4;	}	if (s11.f5 != 5+9) {	return 5;	}	if (s11.f6 != 6+9) {	return 6;	}	if (s11.f7 != 7+9) {	
got but expected 

if (s11.f5 != 5+9) {	return 5;	}	if (s11.f6 != 6+9) {	return 6;	}	if (s11.f7 != 7+9) {	return 7;	}	if (s11.f8 != 8+9) {	
got but expected 

if (s11.f6 != 6+9) {	return 6;	}	if (s11.f7 != 7+9) {	return 7;	}	if (s11.f8 != 8+9) {	return 8;	}	if (s11.f9 != 9+9) {	
got but expected 

if (s11.f7 != 7+9) {	return 7;	}	if (s11.f8 != 8+9) {	return 8;	}	if (s11.f9 != 9+9) {	return 9;	}	if (s11.f10 != 10+9) {	
got but expected 

if (s11.f8 != 8+9) {	return 8;	}	if (s11.f9 != 9+9) {	return 9;	}	if (s11.f10 != 10+9) {	return 10;	}	if (s11.f11 != 11+9) {	
got but expected 

s12.f5 = 5;	s12.f6 = 6;	s12.f7 = 7;	s12.f8 = 8;	s12.f9 = 9;	s12.f10 = 10;	s12.f11 = 11;	s12.f12 = 12;	s12 = mono_return_sbyte12(s12, 9);	if (s12.f1 != 1+9) {	
got but expected 

s12.f8 = 8;	s12.f9 = 9;	s12.f10 = 10;	s12.f11 = 11;	s12.f12 = 12;	s12 = mono_return_sbyte12(s12, 9);	if (s12.f1 != 1+9) {	return 1;	}	if (s12.f2 != 2+9) {	
got but expected 

s12.f11 = 11;	s12.f12 = 12;	s12 = mono_return_sbyte12(s12, 9);	if (s12.f1 != 1+9) {	return 1;	}	if (s12.f2 != 2+9) {	return 2;	}	if (s12.f3 != 3+9) {	
got but expected 

if (s12.f1 != 1+9) {	return 1;	}	if (s12.f2 != 2+9) {	return 2;	}	if (s12.f3 != 3+9) {	return 3;	}	if (s12.f4 != 4+9) {	
got but expected 

if (s12.f2 != 2+9) {	return 2;	}	if (s12.f3 != 3+9) {	return 3;	}	if (s12.f4 != 4+9) {	return 4;	}	if (s12.f5 != 5+9) {	
got but expected 

if (s12.f3 != 3+9) {	return 3;	}	if (s12.f4 != 4+9) {	return 4;	}	if (s12.f5 != 5+9) {	return 5;	}	if (s12.f6 != 6+9) {	
got but expected 

if (s12.f4 != 4+9) {	return 4;	}	if (s12.f5 != 5+9) {	return 5;	}	if (s12.f6 != 6+9) {	return 6;	}	if (s12.f7 != 7+9) {	
got but expected 

if (s12.f5 != 5+9) {	return 5;	}	if (s12.f6 != 6+9) {	return 6;	}	if (s12.f7 != 7+9) {	return 7;	}	if (s12.f8 != 8+9) {	
got but expected 

if (s12.f6 != 6+9) {	return 6;	}	if (s12.f7 != 7+9) {	return 7;	}	if (s12.f8 != 8+9) {	return 8;	}	if (s12.f9 != 9+9) {	
got but expected 

if (s12.f7 != 7+9) {	return 7;	}	if (s12.f8 != 8+9) {	return 8;	}	if (s12.f9 != 9+9) {	return 9;	}	if (s12.f10 != 10+9) {	
got but expected 

if (s12.f8 != 8+9) {	return 8;	}	if (s12.f9 != 9+9) {	return 9;	}	if (s12.f10 != 10+9) {	return 10;	}	if (s12.f11 != 11+9) {	
got but expected 

if (s12.f9 != 9+9) {	return 9;	}	if (s12.f10 != 10+9) {	return 10;	}	if (s12.f11 != 11+9) {	return 11;	}	if (s12.f12 != 12+9) {	
got but expected 

s13.f6 = 6;	s13.f7 = 7;	s13.f8 = 8;	s13.f9 = 9;	s13.f10 = 10;	s13.f11 = 11;	s13.f12 = 12;	s13.f13 = 13;	s13 = mono_return_sbyte13(s13, 9);	if (s13.f1 != 1+9) {	
got but expected 

s13.f9 = 9;	s13.f10 = 10;	s13.f11 = 11;	s13.f12 = 12;	s13.f13 = 13;	s13 = mono_return_sbyte13(s13, 9);	if (s13.f1 != 1+9) {	return 1;	}	if (s13.f2 != 2+9) {	
got but expected 

s13.f12 = 12;	s13.f13 = 13;	s13 = mono_return_sbyte13(s13, 9);	if (s13.f1 != 1+9) {	return 1;	}	if (s13.f2 != 2+9) {	return 2;	}	if (s13.f3 != 3+9) {	
got but expected 

if (s13.f1 != 1+9) {	return 1;	}	if (s13.f2 != 2+9) {	return 2;	}	if (s13.f3 != 3+9) {	return 3;	}	if (s13.f4 != 4+9) {	
got but expected 

if (s13.f2 != 2+9) {	return 2;	}	if (s13.f3 != 3+9) {	return 3;	}	if (s13.f4 != 4+9) {	return 4;	}	if (s13.f5 != 5+9) {	
got but expected 

if (s13.f3 != 3+9) {	return 3;	}	if (s13.f4 != 4+9) {	return 4;	}	if (s13.f5 != 5+9) {	return 5;	}	if (s13.f6 != 6+9) {	
got but expected 

if (s13.f4 != 4+9) {	return 4;	}	if (s13.f5 != 5+9) {	return 5;	}	if (s13.f6 != 6+9) {	return 6;	}	if (s13.f7 != 7+9) {	
got but expected 

if (s13.f5 != 5+9) {	return 5;	}	if (s13.f6 != 6+9) {	return 6;	}	if (s13.f7 != 7+9) {	return 7;	}	if (s13.f8 != 8+9) {	
got but expected 

if (s13.f6 != 6+9) {	return 6;	}	if (s13.f7 != 7+9) {	return 7;	}	if (s13.f8 != 8+9) {	return 8;	}	if (s13.f9 != 9+9) {	
got but expected 

if (s13.f7 != 7+9) {	return 7;	}	if (s13.f8 != 8+9) {	return 8;	}	if (s13.f9 != 9+9) {	return 9;	}	if (s13.f10 != 10+9) {	
got but expected 

if (s13.f8 != 8+9) {	return 8;	}	if (s13.f9 != 9+9) {	return 9;	}	if (s13.f10 != 10+9) {	return 10;	}	if (s13.f11 != 11+9) {	
got but expected 

if (s13.f9 != 9+9) {	return 9;	}	if (s13.f10 != 10+9) {	return 10;	}	if (s13.f11 != 11+9) {	return 11;	}	if (s13.f12 != 12+9) {	
got but expected 

if (s13.f10 != 10+9) {	return 10;	}	if (s13.f11 != 11+9) {	return 11;	}	if (s13.f12 != 12+9) {	return 12;	}	if (s13.f13 != 13+9) {	
got but expected 

s14.f7 = 7;	s14.f8 = 8;	s14.f9 = 9;	s14.f10 = 10;	s14.f11 = 11;	s14.f12 = 12;	s14.f13 = 13;	s14.f14 = 14;	s14 = mono_return_sbyte14(s14, 9);	if (s14.f1 != 1+9) {	
got but expected 

s14.f10 = 10;	s14.f11 = 11;	s14.f12 = 12;	s14.f13 = 13;	s14.f14 = 14;	s14 = mono_return_sbyte14(s14, 9);	if (s14.f1 != 1+9) {	return 1;	}	if (s14.f2 != 2+9) {	
got but expected 

s14.f13 = 13;	s14.f14 = 14;	s14 = mono_return_sbyte14(s14, 9);	if (s14.f1 != 1+9) {	return 1;	}	if (s14.f2 != 2+9) {	return 2;	}	if (s14.f3 != 3+9) {	
got but expected 

if (s14.f1 != 1+9) {	return 1;	}	if (s14.f2 != 2+9) {	return 2;	}	if (s14.f3 != 3+9) {	return 3;	}	if (s14.f4 != 4+9) {	
got but expected 

if (s14.f2 != 2+9) {	return 2;	}	if (s14.f3 != 3+9) {	return 3;	}	if (s14.f4 != 4+9) {	return 4;	}	if (s14.f5 != 5+9) {	
got but expected 

if (s14.f3 != 3+9) {	return 3;	}	if (s14.f4 != 4+9) {	return 4;	}	if (s14.f5 != 5+9) {	return 5;	}	if (s14.f6 != 6+9) {	
got but expected 

if (s14.f4 != 4+9) {	return 4;	}	if (s14.f5 != 5+9) {	return 5;	}	if (s14.f6 != 6+9) {	return 6;	}	if (s14.f7 != 7+9) {	
got but expected 

if (s14.f5 != 5+9) {	return 5;	}	if (s14.f6 != 6+9) {	return 6;	}	if (s14.f7 != 7+9) {	return 7;	}	if (s14.f8 != 8+9) {	
got but expected 

if (s14.f6 != 6+9) {	return 6;	}	if (s14.f7 != 7+9) {	return 7;	}	if (s14.f8 != 8+9) {	return 8;	}	if (s14.f9 != 9+9) {	
got but expected 

if (s14.f7 != 7+9) {	return 7;	}	if (s14.f8 != 8+9) {	return 8;	}	if (s14.f9 != 9+9) {	return 9;	}	if (s14.f10 != 10+9) {	
got but expected 

if (s14.f8 != 8+9) {	return 8;	}	if (s14.f9 != 9+9) {	return 9;	}	if (s14.f10 != 10+9) {	return 10;	}	if (s14.f11 != 11+9) {	
got but expected 

if (s14.f9 != 9+9) {	return 9;	}	if (s14.f10 != 10+9) {	return 10;	}	if (s14.f11 != 11+9) {	return 11;	}	if (s14.f12 != 12+9) {	
got but expected 

if (s14.f10 != 10+9) {	return 10;	}	if (s14.f11 != 11+9) {	return 11;	}	if (s14.f12 != 12+9) {	return 12;	}	if (s14.f13 != 13+9) {	
got but expected 

if (s14.f11 != 11+9) {	return 11;	}	if (s14.f12 != 12+9) {	return 12;	}	if (s14.f13 != 13+9) {	return 13;	}	if (s14.f14 != 14+9) {	
got but expected 

s15.f8 = 8;	s15.f9 = 9;	s15.f10 = 10;	s15.f11 = 11;	s15.f12 = 12;	s15.f13 = 13;	s15.f14 = 14;	s15.f15 = 15;	s15 = mono_return_sbyte15(s15, 9);	if (s15.f1 != 1+9) {	
got but expected 

s15.f11 = 11;	s15.f12 = 12;	s15.f13 = 13;	s15.f14 = 14;	s15.f15 = 15;	s15 = mono_return_sbyte15(s15, 9);	if (s15.f1 != 1+9) {	return 1;	}	if (s15.f2 != 2+9) {	
got but expected 

s15.f14 = 14;	s15.f15 = 15;	s15 = mono_return_sbyte15(s15, 9);	if (s15.f1 != 1+9) {	return 1;	}	if (s15.f2 != 2+9) {	return 2;	}	if (s15.f3 != 3+9) {	
got but expected 

if (s15.f1 != 1+9) {	return 1;	}	if (s15.f2 != 2+9) {	return 2;	}	if (s15.f3 != 3+9) {	return 3;	}	if (s15.f4 != 4+9) {	
got but expected 

if (s15.f2 != 2+9) {	return 2;	}	if (s15.f3 != 3+9) {	return 3;	}	if (s15.f4 != 4+9) {	return 4;	}	if (s15.f5 != 5+9) {	
got but expected 

if (s15.f3 != 3+9) {	return 3;	}	if (s15.f4 != 4+9) {	return 4;	}	if (s15.f5 != 5+9) {	return 5;	}	if (s15.f6 != 6+9) {	
got but expected 

if (s15.f4 != 4+9) {	return 4;	}	if (s15.f5 != 5+9) {	return 5;	}	if (s15.f6 != 6+9) {	return 6;	}	if (s15.f7 != 7+9) {	
got but expected 

if (s15.f5 != 5+9) {	return 5;	}	if (s15.f6 != 6+9) {	return 6;	}	if (s15.f7 != 7+9) {	return 7;	}	if (s15.f8 != 8+9) {	
got but expected 

if (s15.f6 != 6+9) {	return 6;	}	if (s15.f7 != 7+9) {	return 7;	}	if (s15.f8 != 8+9) {	return 8;	}	if (s15.f9 != 9+9) {	
got but expected 

if (s15.f7 != 7+9) {	return 7;	}	if (s15.f8 != 8+9) {	return 8;	}	if (s15.f9 != 9+9) {	return 9;	}	if (s15.f10 != 10+9) {	
got but expected 

if (s15.f8 != 8+9) {	return 8;	}	if (s15.f9 != 9+9) {	return 9;	}	if (s15.f10 != 10+9) {	return 10;	}	if (s15.f11 != 11+9) {	
got but expected 

if (s15.f9 != 9+9) {	return 9;	}	if (s15.f10 != 10+9) {	return 10;	}	if (s15.f11 != 11+9) {	return 11;	}	if (s15.f12 != 12+9) {	
got but expected 

if (s15.f10 != 10+9) {	return 10;	}	if (s15.f11 != 11+9) {	return 11;	}	if (s15.f12 != 12+9) {	return 12;	}	if (s15.f13 != 13+9) {	
got but expected 

if (s15.f11 != 11+9) {	return 11;	}	if (s15.f12 != 12+9) {	return 12;	}	if (s15.f13 != 13+9) {	return 13;	}	if (s15.f14 != 14+9) {	
got but expected 

if (s15.f12 != 12+9) {	return 12;	}	if (s15.f13 != 13+9) {	return 13;	}	if (s15.f14 != 14+9) {	return 14;	}	if (s15.f15 != 15+9) {	
got but expected 

s16.f9 = 9;	s16.f10 = 10;	s16.f11 = 11;	s16.f12 = 12;	s16.f13 = 13;	s16.f14 = 14;	s16.f15 = 15;	s16.f16 = 16;	s16 = mono_return_sbyte16(s16, 9);	if (s16.f1 != 1+9) {	
got but expected 

s16.f12 = 12;	s16.f13 = 13;	s16.f14 = 14;	s16.f15 = 15;	s16.f16 = 16;	s16 = mono_return_sbyte16(s16, 9);	if (s16.f1 != 1+9) {	return 1;	}	if (s16.f2 != 2+9) {	
got but expected 

s16.f15 = 15;	s16.f16 = 16;	s16 = mono_return_sbyte16(s16, 9);	if (s16.f1 != 1+9) {	return 1;	}	if (s16.f2 != 2+9) {	return 2;	}	if (s16.f3 != 3+9) {	
got but expected 

if (s16.f1 != 1+9) {	return 1;	}	if (s16.f2 != 2+9) {	return 2;	}	if (s16.f3 != 3+9) {	return 3;	}	if (s16.f4 != 4+9) {	
got but expected 

if (s16.f2 != 2+9) {	return 2;	}	if (s16.f3 != 3+9) {	return 3;	}	if (s16.f4 != 4+9) {	return 4;	}	if (s16.f5 != 5+9) {	
got but expected 

if (s16.f3 != 3+9) {	return 3;	}	if (s16.f4 != 4+9) {	return 4;	}	if (s16.f5 != 5+9) {	return 5;	}	if (s16.f6 != 6+9) {	
got but expected 

if (s16.f4 != 4+9) {	return 4;	}	if (s16.f5 != 5+9) {	return 5;	}	if (s16.f6 != 6+9) {	return 6;	}	if (s16.f7 != 7+9) {	
got but expected 

if (s16.f5 != 5+9) {	return 5;	}	if (s16.f6 != 6+9) {	return 6;	}	if (s16.f7 != 7+9) {	return 7;	}	if (s16.f8 != 8+9) {	
got but expected 

if (s16.f6 != 6+9) {	return 6;	}	if (s16.f7 != 7+9) {	return 7;	}	if (s16.f8 != 8+9) {	return 8;	}	if (s16.f9 != 9+9) {	
got but expected 

if (s16.f7 != 7+9) {	return 7;	}	if (s16.f8 != 8+9) {	return 8;	}	if (s16.f9 != 9+9) {	return 9;	}	if (s16.f10 != 10+9) {	
got but expected 

if (s16.f8 != 8+9) {	return 8;	}	if (s16.f9 != 9+9) {	return 9;	}	if (s16.f10 != 10+9) {	return 10;	}	if (s16.f11 != 11+9) {	
got but expected 

if (s16.f9 != 9+9) {	return 9;	}	if (s16.f10 != 10+9) {	return 10;	}	if (s16.f11 != 11+9) {	return 11;	}	if (s16.f12 != 12+9) {	
got but expected 

if (s16.f10 != 10+9) {	return 10;	}	if (s16.f11 != 11+9) {	return 11;	}	if (s16.f12 != 12+9) {	return 12;	}	if (s16.f13 != 13+9) {	
got but expected 

if (s16.f11 != 11+9) {	return 11;	}	if (s16.f12 != 12+9) {	return 12;	}	if (s16.f13 != 13+9) {	return 13;	}	if (s16.f14 != 14+9) {	
got but expected 

if (s16.f12 != 12+9) {	return 12;	}	if (s16.f13 != 13+9) {	return 13;	}	if (s16.f14 != 14+9) {	return 14;	}	if (s16.f15 != 15+9) {	
got but expected 

if (s16.f13 != 13+9) {	return 13;	}	if (s16.f14 != 14+9) {	return 14;	}	if (s16.f15 != 15+9) {	return 15;	}	if (s16.f16 != 16+9) {	
got but expected 

s17.f10 = 10;	s17.f11 = 11;	s17.f12 = 12;	s17.f13 = 13;	s17.f14 = 14;	s17.f15 = 15;	s17.f16 = 16;	s17.f17 = 17;	s17 = mono_return_sbyte17(s17, 9);	if (s17.f1 != 1+9) {	
got but expected 

s17.f13 = 13;	s17.f14 = 14;	s17.f15 = 15;	s17.f16 = 16;	s17.f17 = 17;	s17 = mono_return_sbyte17(s17, 9);	if (s17.f1 != 1+9) {	return 1;	}	if (s17.f2 != 2+9) {	
got but expected 

s17.f16 = 16;	s17.f17 = 17;	s17 = mono_return_sbyte17(s17, 9);	if (s17.f1 != 1+9) {	return 1;	}	if (s17.f2 != 2+9) {	return 2;	}	if (s17.f3 != 3+9) {	
got but expected 

if (s17.f1 != 1+9) {	return 1;	}	if (s17.f2 != 2+9) {	return 2;	}	if (s17.f3 != 3+9) {	return 3;	}	if (s17.f4 != 4+9) {	
got but expected 

if (s17.f2 != 2+9) {	return 2;	}	if (s17.f3 != 3+9) {	return 3;	}	if (s17.f4 != 4+9) {	return 4;	}	if (s17.f5 != 5+9) {	
got but expected 

if (s17.f3 != 3+9) {	return 3;	}	if (s17.f4 != 4+9) {	return 4;	}	if (s17.f5 != 5+9) {	return 5;	}	if (s17.f6 != 6+9) {	
got but expected 

if (s17.f4 != 4+9) {	return 4;	}	if (s17.f5 != 5+9) {	return 5;	}	if (s17.f6 != 6+9) {	return 6;	}	if (s17.f7 != 7+9) {	
got but expected 

if (s17.f5 != 5+9) {	return 5;	}	if (s17.f6 != 6+9) {	return 6;	}	if (s17.f7 != 7+9) {	return 7;	}	if (s17.f8 != 8+9) {	
got but expected 

if (s17.f6 != 6+9) {	return 6;	}	if (s17.f7 != 7+9) {	return 7;	}	if (s17.f8 != 8+9) {	return 8;	}	if (s17.f9 != 9+9) {	
got but expected 

if (s17.f7 != 7+9) {	return 7;	}	if (s17.f8 != 8+9) {	return 8;	}	if (s17.f9 != 9+9) {	return 9;	}	if (s17.f10 != 10+9) {	
got but expected 

if (s17.f8 != 8+9) {	return 8;	}	if (s17.f9 != 9+9) {	return 9;	}	if (s17.f10 != 10+9) {	return 10;	}	if (s17.f11 != 11+9) {	
got but expected 

if (s17.f9 != 9+9) {	return 9;	}	if (s17.f10 != 10+9) {	return 10;	}	if (s17.f11 != 11+9) {	return 11;	}	if (s17.f12 != 12+9) {	
got but expected 

if (s17.f10 != 10+9) {	return 10;	}	if (s17.f11 != 11+9) {	return 11;	}	if (s17.f12 != 12+9) {	return 12;	}	if (s17.f13 != 13+9) {	
got but expected 

if (s17.f11 != 11+9) {	return 11;	}	if (s17.f12 != 12+9) {	return 12;	}	if (s17.f13 != 13+9) {	return 13;	}	if (s17.f14 != 14+9) {	
got but expected 

if (s17.f12 != 12+9) {	return 12;	}	if (s17.f13 != 13+9) {	return 13;	}	if (s17.f14 != 14+9) {	return 14;	}	if (s17.f15 != 15+9) {	
got but expected 

if (s17.f13 != 13+9) {	return 13;	}	if (s17.f14 != 14+9) {	return 14;	}	if (s17.f15 != 15+9) {	return 15;	}	if (s17.f16 != 16+9) {	
got but expected 

if (s17.f14 != 14+9) {	return 14;	}	if (s17.f15 != 15+9) {	return 15;	}	if (s17.f16 != 16+9) {	return 16;	}	if (s17.f17 != 17+9) {	
got but expected 

sn16.f9 = 9;	sn16.f10 = 10;	sn16.f11 = 11;	sn16.f12 = 12;	sn16.f13 = 13;	sn16.f14 = 14;	sn16.f15 = 15;	sn16.nested2.f16 = 16;	sn16 = mono_return_sbyte16_nested(sn16, 9);	if (sn16.nested1.f1 != 1+9) {	
nested got but expected 

sn16.f12 = 12;	sn16.f13 = 13;	sn16.f14 = 14;	sn16.f15 = 15;	sn16.nested2.f16 = 16;	sn16 = mono_return_sbyte16_nested(sn16, 9);	if (sn16.nested1.f1 != 1+9) {	return 1;	}	if (sn16.f2 != 2+9) {	
nested got but expected 

sn16.f15 = 15;	sn16.nested2.f16 = 16;	sn16 = mono_return_sbyte16_nested(sn16, 9);	if (sn16.nested1.f1 != 1+9) {	return 1;	}	if (sn16.f2 != 2+9) {	return 2;	}	if (sn16.f3 != 3+9) {	
nested got but expected 

if (sn16.nested1.f1 != 1+9) {	return 1;	}	if (sn16.f2 != 2+9) {	return 2;	}	if (sn16.f3 != 3+9) {	return 3;	}	if (sn16.f4 != 4+9) {	
nested got but expected 

if (sn16.f2 != 2+9) {	return 2;	}	if (sn16.f3 != 3+9) {	return 3;	}	if (sn16.f4 != 4+9) {	return 4;	}	if (sn16.f5 != 5+9) {	
nested got but expected 

if (sn16.f3 != 3+9) {	return 3;	}	if (sn16.f4 != 4+9) {	return 4;	}	if (sn16.f5 != 5+9) {	return 5;	}	if (sn16.f6 != 6+9) {	
nested got but expected 

if (sn16.f4 != 4+9) {	return 4;	}	if (sn16.f5 != 5+9) {	return 5;	}	if (sn16.f6 != 6+9) {	return 6;	}	if (sn16.f7 != 7+9) {	
nested got but expected 

if (sn16.f5 != 5+9) {	return 5;	}	if (sn16.f6 != 6+9) {	return 6;	}	if (sn16.f7 != 7+9) {	return 7;	}	if (sn16.f8 != 8+9) {	
nested got but expected 

if (sn16.f6 != 6+9) {	return 6;	}	if (sn16.f7 != 7+9) {	return 7;	}	if (sn16.f8 != 8+9) {	return 8;	}	if (sn16.f9 != 9+9) {	
nested got but expected 

if (sn16.f7 != 7+9) {	return 7;	}	if (sn16.f8 != 8+9) {	return 8;	}	if (sn16.f9 != 9+9) {	return 9;	}	if (sn16.f10 != 10+9) {	
nested got but expected 

if (sn16.f8 != 8+9) {	return 8;	}	if (sn16.f9 != 9+9) {	return 9;	}	if (sn16.f10 != 10+9) {	return 10;	}	if (sn16.f11 != 11+9) {	
nested got but expected 

if (sn16.f9 != 9+9) {	return 9;	}	if (sn16.f10 != 10+9) {	return 10;	}	if (sn16.f11 != 11+9) {	return 11;	}	if (sn16.f12 != 12+9) {	
nested got but expected 

if (sn16.f10 != 10+9) {	return 10;	}	if (sn16.f11 != 11+9) {	return 11;	}	if (sn16.f12 != 12+9) {	return 12;	}	if (sn16.f13 != 13+9) {	
nested got but expected 

if (sn16.f11 != 11+9) {	return 11;	}	if (sn16.f12 != 12+9) {	return 12;	}	if (sn16.f13 != 13+9) {	return 13;	}	if (sn16.f14 != 14+9) {	
nested got but expected 

if (sn16.f12 != 12+9) {	return 12;	}	if (sn16.f13 != 13+9) {	return 13;	}	if (sn16.f14 != 14+9) {	return 14;	}	if (sn16.f15 != 15+9) {	
nested got but expected 

if (sn16.f13 != 13+9) {	return 13;	}	if (sn16.f14 != 14+9) {	return 14;	}	if (sn16.f15 != 15+9) {	return 15;	}	if (sn16.nested2.f16 != 16+9) {	
nested got but expected 

========================= mono sample_619 =========================

public static void encode (string dump_file, string data_name, string h_file) {	pagedtableencoder.idata data;	using (textreader r = new streamreader (dump_file)) data = parsedump (r);	pagedtableencoder pte = new pagedtableencoder (8, 8, 16, true, "disable_astral");	pte.process (data, "astral_index");	using (textwriter w = new streamwriter (h_file)) {	w.writeline ("/*");	
the tables below are automatically generated 

public static void encode (string dump_file, string data_name, string h_file) {	pagedtableencoder.idata data;	using (textreader r = new streamreader (dump_file)) data = parsedump (r);	pagedtableencoder pte = new pagedtableencoder (8, 8, 16, true, "disable_astral");	pte.process (data, "astral_index");	using (textwriter w = new streamwriter (h_file)) {	w.writeline ("/*");	
by create category table cs available in the mcs 

public static void encode (string dump_file, string data_name, string h_file) {	pagedtableencoder.idata data;	using (textreader r = new streamreader (dump_file)) data = parsedump (r);	pagedtableencoder pte = new pagedtableencoder (8, 8, 16, true, "disable_astral");	pte.process (data, "astral_index");	using (textwriter w = new streamwriter (h_file)) {	w.writeline ("/*");	
sources do not edit 

========================= mono sample_27871 =========================

static void docmethoddev () {	cmethoddevclass cmdev = new cmethoddevclass ();	error ("critical-derived object instantiated");	cmdev.method ();	
critical derived method called 

========================= mono sample_499 =========================

public void print (t t) {	
hello 

========================= mono sample_2283 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
ismachinelevel 

========================= mono sample_29823 =========================

public static bool testmove (byte dest, byte src, int len) {	byte[] array = new byte [totallength];	for (byte i = 0; i < totallength; ++i) array [i] = i;	buffer.blockcopy (array, src, array, dest, len);	for (byte i = 0; i < totallength; ++i) {	if (array [i] != expected (dest, src, len, i)) {	
when copying from to expected 

public static bool testmove (byte dest, byte src, int len) {	byte[] array = new byte [totallength];	for (byte i = 0; i < totallength; ++i) array [i] = i;	buffer.blockcopy (array, src, array, dest, len);	for (byte i = 0; i < totallength; ++i) {	if (array [i] != expected (dest, src, len, i)) {	for (byte j = 0; j < totallength; ++j) console.write ("" + expected (dest, src, len, j) + " ");	console.writeline ();	
got 

========================= mono sample_648 =========================

public static int main () {	eventhandlers handlers = new eventhandlers ();	handlers.handler = handlers.dosomethingeventhandler;	console.writeline ("is handlers.handler == handlers.dosomethingeventhandler (instance)?");	
expected true 

public static int main () {	eventhandlers handlers = new eventhandlers ();	handlers.handler = handlers.dosomethingeventhandler;	console.writeline ("is handlers.handler == handlers.dosomethingeventhandler (instance)?");	console.write ("actual:   ");	bool instanceequal = handlers.handler == handlers.dosomethingeventhandler;	console.writeline (instanceequal);	console.writeline ();	handlers.handler = eventhandlers.donothingeventhandler;	console.writeline ("is handlers.handler == eventhandlers.donothingeventhandler (static)?");	
expected true 

========================= mono sample_3039 =========================

public static int main () {	try {	throw new aexception ();	} catch (aexception e1) {	
a 

public static int main () {	try {	throw new aexception ();	} catch (aexception e1) {	try {	} catch (exception) {	}	return 0;	} catch (exception e) {	
e 

========================= mono sample_2184 =========================

public static void main (string[] args) {	
hello world 

========================= mono sample_22190 =========================

bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	assert.areequal (520, data.stride, "stride");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

========================= mono sample_21128 =========================

static void main(string[] args) {	try {	console.writeline ("1");	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	console.writeline ("2");	customsection sect = (customsection)config.getsection("customsection");	console.writeline ("longsetting = {0}", sect.longsetting);	}	catch (exception e) {	
exception raised 

========================= mono sample_29817 =========================

static bool tppump () {	if (tp_pump_count > 10) {	
pumped the tp test times and no progress o giving up 

========================= mono sample_25 =========================

static void main(string[] args) {	try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	customsection sect = (customsection)config.getsection("customsection");	console.writeline ("longsetting = {0}", sect.longsetting);	}	catch (configurationerrorsexception e) {	
configurationerrorsexception raised 

========================= mono sample_29846 =========================

public object afterreceiverequest (ref message request, iclientchannel channel, instancecontext instancecontext) {	
begin message received by host 

public object afterreceiverequest (ref message request, iclientchannel channel, instancecontext instancecontext) {	console.writeline (request);	
end message received by host 

public void beforesendreply (ref message reply, object correlationstate) {	
begin message reply from host 

public void beforesendreply (ref message reply, object correlationstate) {	console.writeline (reply);	
end message reply from host 

run (runserver, runclient);	}	public void checkwsdlimpl () {	string goldwsdl;	try {	assembly _assembly = assembly.getexecutingassembly ();	streamreader _stream = new streamreader (_assembly.getmanifestresourcestream ("monotests.system.servicemodel.test.featurebased.features.contracts." + typeof (tserver).name + ".xml"));	goldwsdl = _stream.readtoend ();	}	catch {	
couldn t test wsdl of server because gold wsdl is not embedded in test 

}	catch {	return;	}	string currentwsdl = "";	httpwebrequest myreq = (httpwebrequest) webrequest.create (getmexendpoint () + "?wsdl");	webresponse response = myreq.getresponse ();	stream receivestream = response.getresponsestream ();	encoding encode = global::system.text.encoding.getencoding ("utf-8");	streamreader readstream = new streamreader (receivestream, encode);	
response stream received 

========================= mono sample_31203 =========================

public static int main () {	if (a != 5 || b != 0) return 1;	if ((typeof (x2).attributes & typeattributes.beforefieldinit) == 0) return 2;	
ok 

========================= mono sample_1982 =========================

public override imessage invoke (imessage request) {	imethodcallmessage call = (imethodcallmessage)request;	
invoke 

public virtual mystruct add (int a, out int c, int b) {	
add 

public long nonvirtual_add (int a, int b) {	
nonvirtual add 

static int main () {	r1 myobj = new r1 ();	int res = 0;	myproxy real_proxy = new myproxy (myobj);	r1 o = (r1)real_proxy.gettransparentproxy ();	remotedelegate1 d1 = new remotedelegate1 (o.add);	iasyncresult ar = d1.begininvoke (2, out res, 3, null, null);	mystruct myres = d1.endinvoke (out res, ar);	
result 

========================= mono sample_163 =========================

static int f (int a) {	
test f from delegate 

static void async_callback (iasyncresult ar) {	asyncresult ares = (asyncresult)ar;	asynccallback ac = new asynccallback (async_callback);	
async callback 

========================= mono sample_3784 =========================

} else if (args [j] == "--exclude") {	exclude [args [j + 1]] = args [j + 1];	j += 2;	} else if (args [j] == "--exclude-test") {	exclude_test.add (args [j + 1]);	j += 2;	} else if (args [j] == "--run-only") {	run_only.add (args [j + 1]);	j += 2;	} else {	
unknown argument 

for (j = 0; j < exclude_test.count; j++) {	if (name.endswith (exclude_test [j])) {	skip = true;	break;	}	}	foreach (categoryattribute attr in attrs) {	if (exclude.containskey (attr.category)) skip = true;	}	if (skip) {	
skipping 

}	foreach (categoryattribute attr in attrs) {	if (exclude.containskey (attr.category)) skip = true;	}	if (skip) {	nskipped ++;	continue;	}	}	for (j = 5; j < name.length; ++j) if (!char.isdigit (name [j])) break;	
running 

}	for (j = 5; j < name.length; ++j) if (!char.isdigit (name [j])) break;	expected = int32.parse (name.substring (5, j - 5));	start = datetime.now;	result = (int)methods [i].invoke (null, null);	if (do_timings) {	end = datetime.now;	long tdiff = end.ticks - start.ticks;	int mdiff = (int)tdiff/10000;	tms += mdiff;	
took ms 

result = (int)methods [i].invoke (null, null);	if (do_timings) {	end = datetime.now;	long tdiff = end.ticks - start.ticks;	int mdiff = (int)tdiff/10000;	tms += mdiff;	}	ran++;	if (result != expected) {	failed++;	
failed got expected 

int mdiff = (int)tdiff/10000;	tms += mdiff;	}	ran++;	if (result != expected) {	failed++;	}	}	if (!quiet) {	if (do_timings) {	
total ms 

tms += mdiff;	}	ran++;	if (result != expected) {	failed++;	}	}	if (!quiet) {	if (do_timings) {	}	
regression tests ran skipped failed in 

tms += mdiff;	}	ran++;	if (result != expected) {	failed++;	}	}	if (!quiet) {	if (do_timings) {	}	
regression tests ran failed in 

========================= mono sample_132 =========================

myenum? res = e + b;	if (res != 0) return 1;	e = null;	b = 255;	res = e + b;	if (res != null) return 2;	myenum e2 = myenum.a;	byte b2 = 1;	myenum res2 = e2 + b2;	if (res2 != myenum.b) return 3;	
ok 

========================= mono sample_1401 =========================

static void main(string[] args) {	if (args.length < 2) {	
usage cachestress threads millis useabsolutetime 

threads = system.int32.parse(args[0]);	slidingwindow = system.int64.parse(args[1]);	useabsolutetime = (args.length > 2);	for (int i = 0; i < threads; i++) {	thread th = new thread(new threadstart(runcycle));	th.start();	}	int secs = 10;	for (int j = secs; ;j += secs) {	thread.sleep(1000 * secs);	
executed transactions in seconds 

try {	string key = "stam" + n;	object o2 = c.get(key);	if (o2 == null) {	if (useabsolutetime) c.insert(key, 1, null, datetime.now.addticks(slidingwindow), cache.noslidingexpiration);	else c.insert(key, 1, null, cache.noabsoluteexpiration, new timespan(slidingwindow));	}	n = (n * 2 + i) % modulo;	}	catch (exception e) {	
caught exception 

========================= mono sample_18911 =========================

public x () {	int x, y;	y = this.testme (out x).data;	
x is 

========================= mono sample_3965 =========================

public static int main () {	blah k = new blah ();	foo f = k;	object o = k;	
i am a foo 

========================= mono sample_4006 =========================

bool redirecterror = options.err != null && options.err != string.empty;	if ( redirecterror ) {	streamwriter errorstreamwriter = new streamwriter( options.err );	errorstreamwriter.autoflush = true;	errorwriter = errorstreamwriter;	}	testrunner testrunner = makerunnerfromcommandline( options );	try {	if (testrunner.test == null) {	testrunner.unload();	
unable to locate fixture 

}	testrunner testrunner = makerunnerfromcommandline( options );	try {	if (testrunner.test == null) {	testrunner.unload();	return fixture_not_found;	}	eventcollector collector = new eventcollector( options, outwriter, errorwriter );	testfilter testfilter = testfilter.empty;	if ( options.run != null && options.run != string.empty ) {	
selected test 

if (testrunner.test == null) {	testrunner.unload();	return fixture_not_found;	}	eventcollector collector = new eventcollector( options, outwriter, errorwriter );	testfilter testfilter = testfilter.empty;	if ( options.run != null && options.run != string.empty ) {	testfilter = new simplenamefilter( options.run );	}	if ( options.include != null && options.include != string.empty ) {	
included categories 

testfilter testfilter = testfilter.empty;	if ( options.run != null && options.run != string.empty ) {	testfilter = new simplenamefilter( options.run );	}	if ( options.include != null && options.include != string.empty ) {	testfilter includefilter = new categoryexpression( options.include ).filter;	if ( testfilter.isempty ) testfilter = includefilter;	else testfilter = new andfilter( testfilter, includefilter );	}	if ( options.exclude != null && options.exclude != string.empty ) {	
excluded categories 

string xmloutput = createxmloutput( result );	if (options.xmlconsole) {	console.writeline(xmloutput);	}	else {	try {	xmlresulttransform xform = new xmlresulttransform( transformreader );	xform.transform( new stringreader( xmloutput ), console.out );	}	catch( exception ex ) {	
error 

xmltextreader reader = null;	if(parser.transform == null || parser.transform == string.empty) {	assembly assembly = assembly.getassembly(typeof(xmlresultvisitor));	resourcemanager resourcemanager = new resourcemanager("nunit.util.transform",assembly);	string xmldata = (string)resourcemanager.getobject("summary.xslt");	reader = new xmltextreader(new stringreader(xmldata));	}	else {	fileinfo xsltinfo = new fileinfo(parser.transform);	if(!xsltinfo.exists) {	
transform file does not exist 

========================= mono sample_32697 =========================

d = false;	if (d && throw ()) return 3;	d = true;	if (d || throw ()) {	} else {	return 4;	}	dynamic a = new s ();	dynamic b = new s ();	var result = a && b;	
ok 

========================= mono sample_1971 =========================

public override bool check() {	bool retval = true;	if (underlyingsize > array.length) {	
underlyingsize array length 

public override bool check() {	bool retval = true;	if (underlyingsize > array.length) {	return false;	}	if (offset + size > underlyingsize) {	
offset size underlyingsize 

public override bool check() {	bool retval = true;	if (underlyingsize > array.length) {	return false;	}	if (offset + size > underlyingsize) {	return false;	}	if (offset < 0) {	
offset 

return false;	}	if (offset + size > underlyingsize) {	return false;	}	if (offset < 0) {	return false;	}	for (int i = 0; i < underlyingsize; i++) {	if ((object)(array[i]) == null) {	
bad element null at base index 

for (int i = underlyingsize, length = array.length; i < length; i++) {	if (!equals(array[i], default(t))) {	console.writeline("bad element: != default(t) at (base)index {0}", i);	retval = false;	}	}	{	hashedarraylist<t> u = underlying ?? this;	if (u.views != null) foreach (hashedarraylist<t> v in u.views) {	if (u.array != v.array) {	
view from of length has different base array than the underlying list 

}	}	}	#if hashindex if (underlyingsize != itemindex.count) {	console.writeline("size ({0})!= index.count ({1})", size, itemindex.count);	retval = false;	}	for (int i = 0; i < underlyingsize; i++) {	keyvaluepair<t, int> p = new keyvaluepair<t, int>(array[i]);	if (!itemindex.find(ref p)) {	
item at not in hashindex 

#if hashindex if (underlyingsize != itemindex.count) {	console.writeline("size ({0})!= index.count ({1})", size, itemindex.count);	retval = false;	}	for (int i = 0; i < underlyingsize; i++) {	keyvaluepair<t, int> p = new keyvaluepair<t, int>(array[i]);	if (!itemindex.find(ref p)) {	retval = false;	}	if (p.value != i) {	
item at has hashindex 

========================= mono sample_30543 =========================

public void gettingnonexisting() {	
r 

public void gettingnonexisting() {	
r 

========================= mono sample_30495 =========================

public static int main () {	int result = test (5);	if (result != 0) console.writeline ("error: {0}", result);	
ok 

========================= mono sample_3470 =========================

public static int main () {	try {	bool x = true;	try {	throw new applicationexception ();	} catch (nullreferenceexception) when (x) {	throw;	}	return 1;	} catch (applicationexception) {	
ok 

========================= mono sample_1464 =========================

public void stop () {	
ms 

========================= mono sample_19989 =========================

public static void usage (string error) {	
copyright c novell 

public static void usage (string error) {	if (error != null) {	
error 

public static void usage (string error) {	if (error != null) {	}	
usage input transform url element 

public static void usage (string error) {	if (error != null) {	}	
input xml document to canonalize 

public static void usage (string error) {	if (error != null) {	}	
transform url transformation algorithm url 

public static void usage (string error) {	if (error != null) {	}	
default is 

public static void usage (string error) {	if (error != null) {	}	
element partial from this element and childs 

========================= mono sample_30615 =========================

public void work () {	for (long i = 0; i < 30; ++i) console.writeline (fib (i).tostring ());	
exiting 

static int main () {	thread t = newthread ();	t.start ();	
started 

========================= mono sample_386 =========================

static void warnaboutsymbolwriter (string message) {	if (has_warned_about_symbolwriter) return;	has_warned_about_symbolwriter = true;	
warning 

========================= mono sample_28353 =========================

public static int test_1225_marshal_inout_array () {	int [] a1 = new int [50];	for (int i = 0; i < 50; i++) a1 [i] = i;	int res = mono_test_marshal_inout_array (a1);	for (int i = 0; i < 50; i++) if (a1 [i] != 50 - i) {	
x 

public static int test_0_marshal_out_array () {	int [] a1 = new int [50];	int res = mono_test_marshal_out_array (a1, 0);	for (int i = 0; i < 50; i++) if (a1 [i] != i) {	
x 

========================= mono sample_157 =========================

static void generate_receptors () {	foreach (string t in types){	w ("\tstatic void receive_" + t + " (" + t + " a)\n\t{\n");	w ("\t\tconsole.write (\"        \");\n");	
console writeline a 

========================= mono sample_1805 =========================

protected override void oninit (eventargs e) {	
page oninit 

========================= mono sample_18515 =========================

public static void main () {	var vtib = new vti_c<int> ();	var result = vtib.graf<int> ();	if (result) {	
it works 

========================= mono sample_324 =========================

public override object instantiate () {	
instantiating type 

public override object instantiate () {	
instantiating compound field 

public object instantiate () {	
instantiating field 

public object instantiate () {	
instantiating form window 

========================= mono sample_1854 =========================

if (b.q != 20) return 5;	if (b.q != 20) return 6;	c c = new c ();	c.r = 10;	c.q = 20;	c.p = 30;	if (c.r != 10) return 7;	if (c.rr != 10) return 8;	if (c.p != 30) return 9;	if (c.p != 30) return 10;	
test passes 

========================= mono sample_3811 =========================

public htmlwriter (textwriter writer, string tabstring) : base (writer, tabstring) {	full_trace = (environment.getenvironmentvariable ("htmlwriter_fulltrace") == "yes");	string file = environment.getenvironmentvariable ("htmlwriter_file");	console.writeline ("file: '{0}' (null? {1})", file, file == null);	if (file != null && file != "") {	output = new streamwriter (new filestream (file, filemode.openorcreate | filemode.append));	
sending log to 

public override void addattribute (htmltextwriterattribute key, string value, bool fencode) {	
addattribute 

public override void addattribute (string name, string value, bool fencode) {	
addattribute 

protected override void addattribute (string name, string value, htmltextwriterattribute key) {	
addattribute 

protected override void addstyleattribute (string name, string value, htmltextwriterstyle key) {	
addstyleattribute 

public override void close () {	
close 

protected override string encodeattributevalue (htmltextwriterattribute attrkey, string value) {	
encodeattributevalue 

protected override void filterattributes () {	
filterattributes 

public override void flush () {	
flush 

protected override htmltextwritertag gettagkey (string tagname) {	
gettagkey 

protected override string gettagname (htmltextwritertag tagkey) {	
gettagname 

protected override bool onattributerender (string name, string value, htmltextwriterattribute key) {	
onattributerender 

protected override bool onstyleattributerender (string name, string value, htmltextwriterstyle key) {	
onstyleattributerender 

protected override bool ontagrender (string name, htmltextwritertag key) {	
ontagrender 

protected override void outputtabs () {	
outputtabs 

protected override string renderaftercontent () {	
renderaftercontent 

protected override string renderaftertag () {	
renderaftertag 

protected override string renderbeforecontent () {	
renderbeforecontent 

protected override string renderbeforetag () {	
renderbeforetag 

public override void renderbegintag (string tagname) {	
renderbegintag 

public override void renderbegintag (htmltextwritertag tagkey) {	
renderbegintag 

public override void renderendtag () {	
renderendtag 

public override void writeattribute (string name, string value, bool fencode) {	
writeattribute 

public override void writebegintag (string tagname) {	
writebegintag 

public override void writeendtag (string tagname) {	
writeendtag 

public override void writefullbegintag (string tagname) {	
writefullbegintag 

public override void writestyleattribute (string name, string value, bool fencode) {	
writestyleattribute 

========================= mono sample_18414 =========================

public static int main () {	type t = typeof (foo);	foreach (memberinfo m in t.getmembers ()){	if (m.name == "main"){	methodinfo mb = (methodinfo) m;	icustomattributeprovider p = mb.returntypecustomattributes;	object [] ret_attrs = p.getcustomattributes (false);	if (ret_attrs.length != 1){	
got more than one return attribute 

type t = typeof (foo);	foreach (memberinfo m in t.getmembers ()){	if (m.name == "main"){	methodinfo mb = (methodinfo) m;	icustomattributeprovider p = mb.returntypecustomattributes;	object [] ret_attrs = p.getcustomattributes (false);	if (ret_attrs.length != 1){	return 1;	}	if (!(ret_attrs [0] is returnattribute)){	
dit not get a mineattribute 

icustomattributeprovider p = mb.returntypecustomattributes;	object [] ret_attrs = p.getcustomattributes (false);	if (ret_attrs.length != 1){	return 1;	}	if (!(ret_attrs [0] is returnattribute)){	return 2;	}	returnattribute ma = (returnattribute) ret_attrs [0];	if (ma.name != "bar"){	
the return attribute is not bar 

========================= mono sample_3493 =========================

private void checkparticlederivation(xmlschemacomplextype complextype) {	xmlschemacomplextype basetype = complextype.basexmlschematype as xmlschemacomplextype;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	if (!isvalidrestriction(complextype.contenttypeparticle, basetype.contenttypeparticle)) {	#if debug if(complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
invalid complextype content restriction 

private void checkparticlederivation(xmlschemacomplextype complextype) {	xmlschemacomplextype basetype = complextype.basexmlschematype as xmlschemacomplextype;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	if (!isvalidrestriction(complextype.contenttypeparticle, basetype.contenttypeparticle)) {	#if debug if(complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
base 

private void checkparticlederivation(xmlschemacomplextype complextype) {	xmlschemacomplextype basetype = complextype.basexmlschematype as xmlschemacomplextype;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	if (!isvalidrestriction(complextype.contenttypeparticle, basetype.contenttypeparticle)) {	#if debug if(complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
derived 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

foreach(xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

foreach(xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

foreach(xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

xmlschemaelement localelement = (xmlschemaelement)all.items[i];	if (!contentvalidator.addelement(localelement.qualifiedname, localelement, localelement.minoccurs == decimal.zero)) {	sendvalidationevent(res.sch_dupelement, localelement.qualifiedname.tostring(), localelement);	}	}	return contentvalidator;	}	else {	particlecontentvalidator contentvalidator = new particlecontentvalidator(complextype.contenttype);	#if debug string name = complextype.name != null ? complextype.name : string.empty;	
compilecomplexcontent 

========================= mono sample_11226 =========================

static void main (string[] args) {	var failcount = 0;	
correct case 

static void main (string[] args) {	var failcount = 0;	try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	
access friend internal method ok 

static void main (string[] args) {	var failcount = 0;	try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	
access friend internal method fail 

static void main (string[] args) {	var failcount = 0;	try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@private: false);	
access internal class private ctor ok 

var failcount = 0;	try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	
access internal class private ctor fail 

a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	
access internal class internal ctor ok 

failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	
access friend internal ctor fail 

var a = new correctcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var b = new correctcasefriendassembly.internalclass(@public: 'a');	
access internal class public ctor ok 

} catch (memberaccessexception) {	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var b = new correctcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	
access friend internal method ok 

try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var b = new correctcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	
access friend internal method with wrong case fail 

var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var b = new correctcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	}	
wrong case 

failcount += 1;	}	try {	var b = new correctcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@private: false);	
access internal class private ctor ok 

}	try {	var b = new correctcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	
access internal class private ctor fail 

b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	
access internal class internal ctor ok 

failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	
access friend internal ctor fail 

var a = new wrongcasefriendassembly.internalclass(@private: false);	} catch (memberaccessexception) {	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var b = new wrongcasefriendassembly.internalclass(@public: 'a');	
access internal class public ctor ok 

} catch (memberaccessexception) {	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var b = new wrongcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	
access friend internal method ok 

try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var b = new wrongcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	
access friend internal method fail 

failcount += 1;	}	try {	var b = new wrongcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	
access friend private static method ok 

}	try {	var b = new wrongcasefriendassembly.internalclass(@public: 'a');	b.internalmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	} catch (memberaccessexception) {	
access friend private static method fail 

} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	
access friend internal static method ok 

}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	
access friend internal static method fail 

} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.publicclass.internalstaticmethod();	
access public internal static method ok 

}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.publicclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	
access public internal static method fail 

wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.publicclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	if (system.diagnostics.debugger.isattached) console.readline();	
incorrect results 

========================= mono sample_225 =========================

private void thread_func() {	
in a thread 

public static int main () {	
hello world 

public static int main () {	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	
in the main line 

========================= mono sample_365 =========================

public static void a () {	
a 

========================= mono sample_4073 =========================

if (r2.result != 88) return 3;	mre.reset ();	mre_l.reset ();	action a = async () => await task.factory.startnew (() => {	if (!mre_l.waitone (3000)) throw new applicationexception ("4");	mre.set ();	}, cancellationtoken.none).configureawait (false);	a ();	mre_l.set ();	if (!mre.waitone (3000)) return 4;	
ok 

========================= mono sample_3582 =========================

expression<func<bool>> e = () => f > null;	if (e.compile ().invoke ()) return 1;	e = () => f < null;	if (e.compile ().invoke ()) return 2;	e = () => f == null;	if (e.compile ().invoke ()) return 3;	e = () => f != null;	if (!e.compile ().invoke ()) return 4;	expression<func<foo?>> e2 = () => f + null;	if (e2.compile ().invoke () != null) return 5;	
ok 

========================= mono sample_1716 =========================

protected internal override void render (htmltextwriter w) {	
mycontroladapter render 

protected override void renderbegintag (htmltextwriter w) {	
renderbegintag 

protected override void rendercontents (htmltextwriter w) {	
rendercontents 

protected override void renderendtag (htmltextwriter w) {	
renderendtag 

========================= mono sample_18727 =========================

protected virtual bool writedatacontextctor(codewriter writer, database schema, type contextbasetype, parameterdefinition[] parameters, string[] basecallparameternames, type[] basecallparametertypes, generationcontext context) {	if (contextbasetype != null) {	var ctor = contextbasetype.getconstructor(basecallparametertypes);	if (ctor == null) return false;	}	using (writer.writector(specificationdefinition.public, schema.class, parameters, basecallparameternames)) {	
oncreated 

protected virtual void writedatacontextextensibilitydeclarations(codewriter writer, database schema, generationcontext context) {	using (writer.writeregion("extensibility method definitions")) {	
partial void oncreated 

========================= mono sample_25069 =========================

s = (object)null + null;	if (s.length != 0) return 10;	s = null + (object)null;	if (s.length != 0) return 11;	s = (object)1 + null;	if (s != "1") return 12;	s = (string)null + (object)null;	if (s.length != 0) return 13;	s = (object)null + (string)null;	if (s.length != 0) return 14;	
test ok 

========================= mono sample_3520 =========================

public static void main(string[] args) {	int count = int.parse(args[0]);	{	console.write("good hash function: ");	timer t = new timer();	hashset<int> good = makerandom(count, new goodintegerequalitycomparer());	
sec items 

public static void main(string[] args) {	int count = int.parse(args[0]);	{	console.write("good hash function: ");	timer t = new timer();	hashset<int> good = makerandom(count, new goodintegerequalitycomparer());	isorteddictionary<int,int> bcd = good.bucketcostdistribution();	
bucket s with cost 

{	console.write("good hash function: ");	timer t = new timer();	hashset<int> good = makerandom(count, new goodintegerequalitycomparer());	isorteddictionary<int,int> bcd = good.bucketcostdistribution();	}	{	console.write("bad hash function:  ");	timer t = new timer();	hashset<int> bad = makerandom(count, new badintegerequalitycomparer());	
sec items 

console.write("good hash function: ");	timer t = new timer();	hashset<int> good = makerandom(count, new goodintegerequalitycomparer());	isorteddictionary<int,int> bcd = good.bucketcostdistribution();	}	{	console.write("bad hash function:  ");	timer t = new timer();	hashset<int> bad = makerandom(count, new badintegerequalitycomparer());	isorteddictionary<int,int> bcd = bad.bucketcostdistribution();	
bucket s with cost 

========================= mono sample_30553 =========================

public static int main() {	int test = 1;	int result = interlocked.increment(ref test);	if (result != 2) {	
incorrect increment result 

========================= mono sample_180 =========================

public void unsafe() {	bool bad = false;	for (int i = 0; i < 10; i++) {	system.threading.thread t1 = new system.threading.thread(new system.threading.threadstart(unsafe1));	system.threading.thread t2 = new system.threading.thread(new system.threading.threadstart(unsafe2));	t1.start();	t2.start();	t1.join();	t2.join();	if (bad = 2 * sz + 1 != tree.count) {	
unsafe bad at 

========================= mono sample_30502 =========================

public static int main () {	t t = new t ();	int result = test (t);	
result 

========================= mono sample_3975 =========================

keyboard = new x11keyboard(display, foster_hwnd.handle);	dnd = new x11dnd (display, keyboard);	errorexceptions = false;	errorhandler = new xerrorhandler (handleerror);	xlib.xseterrorhandler (errorhandler);	x11desktopcolors.initialize();	try {	xlib.xkbsetdetectableautorepeat (display, true, intptr.zero);	detectable_key_auto_repeat = true;	} catch {	
could not disable keyboard auto repeat will attempt to disable manually 

private int handleerror (intptr display, ref xerrorevent error_event) {	if (errorexceptions) throw new x11exception (error_event.display, error_event.resourceid, error_event.serial, error_event.error_code, error_event.request_code, error_event.minor_code);	
error encountered 

public bool systrayadd(intptr handle, string tip, icon icon, out tooltip tt) {	intptr systraymgrwindow;	xlib.xgrabserver (display);	systraymgrwindow = xlib.xgetselectionowner (display, atoms._net_system_tray_s);	xlib.xungrabserver (display);	if (systraymgrwindow != intptr.zero) {	xsizehints size_hints;	x11hwnd hwnd;	hwnd = (x11hwnd)hwnd.objectfromhandle(handle);	
adding systray whole x client x 

if (hwnd.queue.thread != thread.currentthread) {	asyncmethodresult	result;	asyncmethoddata		data;	result = new asyncmethodresult ();	data = new asyncmethoddata ();	data.handle = hwnd.handle;	data.method = new wndprocdelegate (nativewindow.wndproc);	data.args = new object[] { hwnd.handle, message, wparam, lparam };	data.result = result;	sendasyncmethod (data);	
sending message across 

shape = xplatuix11.stdcursortofontshape (id);	name = shape.tostring ().replace ("xc_", string.empty);	size = xplatuix11.xcursorgetdefaultsize (handle);	theme = xplatuix11.xcursorgettheme (handle);	intptr images_ptr = xplatuix11.xcursorlibraryloadimages (name, theme, size);	#if debug console.writeline ("definestdcursorbitmap, id={0}, #id={1}, name{2}, size={3}, theme: {4}, images_ptr={5}", id, (int) id, name, size, marshal.ptrtostringansi (theme), images_ptr);	#endif if (images_ptr == intptr.zero) {	return null;	}	xcursorimages images = (xcursorimages)marshal.ptrtostructure (images_ptr, typeof (xcursorimages));	
definestdcursorbitmap cursor has images 

bmp = new bitmap (image.width, image.height);	for (int w = 0; w < image.width; w++) {	for (int h = 0; h < image.height; h++) {	bmp.setpixel (w, h, color.fromargb (pixels [h * image.width + w]));	}	}	}	}	xplatuix11.xcursorimagesdestroy (images_ptr);	} catch (dllnotfoundexception ex) {	
could not load libxcursor 

private void accumulatedestroyedhandles (control c, arraylist list) {	if (c != null) {	control[] controls = c.controls.getallcontrols ();	if (c.ishandlecreated && !c.isdisposed) {	x11hwnd hwnd = (x11hwnd)hwnd.objectfromhandle(c.handle);	
adding to the list of zombie windows 

private void accumulatedestroyedhandles (control c, arraylist list) {	if (c != null) {	control[] controls = c.controls.getallcontrols ();	if (c.ishandlecreated && !c.isdisposed) {	x11hwnd hwnd = (x11hwnd)hwnd.objectfromhandle(c.handle);	
parent x window is x 

#endif break;	}	#if spew console.write ("-");	console.out.flush ();	#endif hwnd = (x11hwnd)hwnd.getobjectfromwindow (xevent.anyevent.window);	if (hwnd != null && hwnd.zombie && xevent.type == xeventname.expose) {	hwnd.pendingexpose = hwnd.pendingncexpose = false;	goto processnextmessage;	}	if (hwnd == null || hwnd.zombie) {	
getmessage got message for non existent or already destroyed window x 

keyboard.focusout(focuswindow.handle);	while (keyboard.resetkeystate(focuswindow.handle, ref msg)) sendmessage(focuswindow.handle, msg.message, msg.wparam, msg.lparam);	sendmessage(focuswindow.handle, msg.wm_killfocus, intptr.zero, intptr.zero);	goto processnextmessage;	case xeventname.expose: if (!hwnd.mapped) {	hwnd.pendingexpose = hwnd.pendingncexpose = false;	continue;	}	msg.hwnd = hwnd.handle;	if (client) {	
getmessage window x exposed area x 

switch (hwnd.border_style) {	case formborderstyle.fixed3d: g = graphics.fromhwnd(hwnd.wholewindow);	controlpaint.drawborder3d(g, new rectangle(0, 0, hwnd.width, hwnd.height), border3dstyle.sunken);	g.dispose();	break;	case formborderstyle.fixedsingle: g = graphics.fromhwnd(hwnd.wholewindow);	controlpaint.drawborder(g, new rectangle(0, 0, hwnd.width, hwnd.height), color.black, buttonborderstyle.solid);	g.dispose();	break;	}	
getmessage window x exposed non client area x 

region region = new region (rect);	intptr hrgn = region.gethrgn (null);	msg.message = msg.wm_ncpaint;	msg.wparam = hrgn == intptr.zero ? (intptr)1 : hrgn;	msg.refobject = region;	}	return true;	case xeventname.destroynotify: hwnd = (x11hwnd)hwnd.objectfromhandle(xevent.destroywindowevent.window);	if ((hwnd != null) && (hwnd.clientwindow == xevent.destroywindowevent.window)) {	cleanupcachedwindows (hwnd);	
received destroy notification for 

}	if (xevent.clientmessageevent.message_type == atoms.postatom) {	msg.hwnd = xevent.clientmessageevent.ptr1;	msg.message = (msg) xevent.clientmessageevent.ptr2.toint32 ();	msg.wparam = xevent.clientmessageevent.ptr3;	msg.lparam = xevent.clientmessageevent.ptr4;	if (msg.message == (msg)msg.wm_quit) return false;	else return true;	}	if (xevent.clientmessageevent.message_type == atoms._xembed) {	
got embed message x detail x 

========================= mono sample_26387 =========================

k = new blah (2) + new blah (3);	if (k.i != 5) return 1;	k = ~ new blah (5);	if (k.i != -6) return 1;	k = + new blah (4);	if (k.i != 4) return 1;	k = - new blah (21);	if (k.i != -21) return 1;	k = new blah (22) - new blah (21);	if (k.i != 1) return 1;	
returned true 

k = + new blah (4);	if (k.i != 4) return 1;	k = - new blah (21);	if (k.i != -21) return 1;	k = new blah (22) - new blah (21);	if (k.i != 1) return 1;	int number = k;	if (number != 1) return 1;	k++;	++k;	
k is definitely true 

l = new blah (10);	i = k / l;	if (i != 5) return 1;	i = k % l;	if (i != 0) return 1;	myboolean myb = new myboolean ();	if (!myb) return 10;	mytruefalse mf = new mytruefalse ();	int x = mf ? 1 : 2;	if (x != 1) return 11;	
test passed 

public static blah operator + (blah i, blah j) {	blah b = new blah (i.i + j.i);	
overload binary operator 

public static blah operator + (blah i) {	
overload unary operator 

public static blah operator - (blah i) {	
overloaded unary operator 

public static blah operator - (blah i, blah j) {	blah b = new blah (i.i - j.i);	
overloaded binary operator 

public static int operator * (blah i, blah j) {	
overloaded binary operator 

public static int operator / (blah i, blah j) {	
overloaded binary operator 

public static int operator % (blah i, blah j) {	
overloaded binary operator 

public static blah operator ~ (blah i) {	
overloaded operator 

public static bool operator ! (blah i) {	
overloaded operator 

public static blah operator ++ (blah i) {	blah b = new blah (i.i + 1);	
incrementing i 

public static blah operator -- (blah i) {	blah b = new blah (i.i - 1);	
decrementing i 

public static bool operator true (blah i) {	
overloaded true operator 

public static bool operator false (blah i) {	
overloaded false operator 

public static implicit operator int (blah i) {	
converting implicitly from blah int 

public static explicit operator double (blah i) {	
converting explicitly from blah double 

========================= mono sample_3736 =========================

public static void formatlist (this streamwriter sw, list <cacheitem> list) {	if (list == null || list.count == 0) {	
no cacheitems found 

public static void formatlist (this streamwriter sw, list <cacheitem> list) {	if (list == null || list.count == 0) {	return;	}	
each row contains testcacheitem fields one item per line in the following order 

public static void formatlist (this streamwriter sw, list <cacheitem> list) {	if (list == null || list.count == 0) {	return;	}	
key absoluteexpiration slidingexpiration priority lastchange expiresat disabled guid priorityqueueindex 

========================= mono sample_18420 =========================

public new void writebreak() {	
br 

========================= mono sample_6053 =========================

assert.areequal (0, bytes [3], "test#04");	stream.flush ();	stream2.read (bytes, 0, 5);	assert.areequal (1, bytes [0], "test#05");	assert.areequal (2, bytes [1], "test#06");	assert.areequal (3, bytes [2], "test#07");	assert.areequal (4, bytes [3], "test#08");	} finally {	if (stream != null) stream.close ();	if (stream2 != null) stream2.close ();	
p 

========================= mono sample_21986 =========================

int hash = doc.gethashcode ();	if (owner.documents.containskey (hash)) {	dom.document document = owner.documents[hash] as dom.document;	eventhandler eh1 = (eventhandler)(document.events[dom.document.loadstoppedevent]);	if (eh1 != null) eh1 (this, null);	}	}	calledloadstarted = false;	return;	}	
completed 

public bool onclientdomkeydown (keyinfo keyinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientdomkeydown");	
onclientdomkeydown 

public bool onclientdomkeyup (keyinfo keyinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientdomkeyup");	
onclientdomkeyup 

public bool onclientdomkeypress (keyinfo keyinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientdomkeypress");	
onclientdomkeypress 

public bool onclientmousedown (mouseinfo mouseinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientmousedown");	
onclientmousedown 

public bool onclientmouseup (mouseinfo mouseinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientmouseup");	
onclientmouseup 

public bool onclientmouseclick (mouseinfo mouseinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientmouseclick");	
onclientmouseclick 

public bool onclientmousedoubleclick (mouseinfo mouseinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientmousedoubleclick");	
onclientmousedoubleclick 

public bool onclientmouseover (mouseinfo mouseinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientmouseover");	
onclientmouseover 

public bool onclientmouseout (mouseinfo mouseinfo, modifierkeys modifiers, nsidomnode target) {	#if debug ongeneric ("onclientmouseout");	
onclientmouseout 

public bool onclientactivate () {	#if debug ongeneric ("onclientactivate");	
onclientactivate 

public bool onclientfocus () {	#if debug ongeneric ("onclientfocus");	
onclientfocus 

public bool onclientblur () {	#if debug ongeneric ("onclientblur");	
onclientblur 

public bool oncreatenewwindow () {	bool ret = false;	#if debug ongeneric ("oncreatenewwindow");	
oncreatenewwindow 

public void onalert (intptr title, intptr text) {	#if debug ongeneric ("onalert");	
onalert 

public bool onalertcheck (intptr title, intptr text, intptr chkmsg, ref bool chkstate) {	#if debug ongeneric ("onalertcheck");	
onalertcheck 

public bool onconfirm (intptr title, intptr text) {	#if debug ongeneric ("onconfirm");	
onconfirm 

public bool onconfirmcheck (intptr title, intptr text, intptr chkmsg, ref bool chkstate) {	#if debug ongeneric ("onconfirmcheck");	
onconfirmcheck 

public bool onconfirmex (intptr title, intptr text, dialogbuttonflags flags, intptr title0, intptr title1, intptr title2, intptr chkmsg, ref bool chkstate, out int32 retval) {	#if debug ongeneric ("onconfirmex");	
onconfirmex 

public bool onprompt (intptr title, intptr text, ref intptr retval) {	#if debug ongeneric ("onprompt");	
onprompt 

public bool onpromptusernameandpassword (intptr title, intptr text, intptr chkmsg, ref bool chkstate, out intptr username, out intptr password) {	#if debug ongeneric ("onpromptusernameandpassword");	
onpromptusernameandpassword 

public bool onpromptpassword (intptr title, intptr text, intptr chkmsg, ref bool chkstate, out intptr password) {	#if debug ongeneric ("onpromptpassword");	
onpromptpassword 

public bool onselect (intptr title, intptr text, uint count, intptr list, out int retval) {	#if debug ongeneric ("onselect");	
onselect 

public void onload () {	#if debug ongeneric ("onload");	
onload 

public void onunload () {	#if debug ongeneric ("onunload");	
onunload 

public void onshowcontextmenu (uint32 contextflags, [marshalas (unmanagedtype.interface)] nsidomevent eve, [marshalas (unmanagedtype.interface)] nsidomnode node) {	#if debug ongeneric ("onshowcontextmenu");	
onshowcontextmenu 

public void ongeneric (string type) {	
callback generic 

========================= mono sample_4234 =========================

int value = 0;	try {	for (int i = 0; i < 8; ++i) {	try {	try {	value += await yieldvalue (1);	console.writeline ("i = " + i);	if (i > 2) break;	if (i > 1) throw new applicationexception ();	} catch (applicationexception) {	
catch 

int value = 0;	try {	for (int i = 0; i < 8; ++i) {	try {	try {	value += await yieldvalue (1);	console.writeline ("i = " + i);	if (i < 2) continue;	if (i > 1) throw new applicationexception ();	} catch (applicationexception) {	
catch 

========================= mono sample_3454 =========================

if (t9 ()[0] != 4) return 9;	var t10 = arraymultimutate (new string[][] { new string[] { "a", "b", "c" }, new string[] { "1", "2", "3" }, new string[] { "a", "b", "c" } });	if (t10 ()[2][2] != null) return 10;	var array = new short[,] { { 10, 20 } };	var t10a = arraymultimutate (array);	if (t10a () != array[0, 0].gethashcode ()) return 100;	var t11 = typeof ("b");	if (t11 () != typeof (string)) return 11;	var t12 = nestedtypemutate<ulong> () ();	if (t12[0] != 0 || t12[1] != 0) return 12;	
ok 

========================= mono sample_2769 =========================

static bool isstatic (type t) {	type type = typeof (staticclass);	if (!type.isabstract || !type.issealed) {	
is not abstract sealed 

static bool isstatic (type t) {	type type = typeof (staticclass);	if (!type.isabstract || !type.issealed) {	return false;	}	if (type.getconstructors ().length > 0) {	
has constructor 

public static int main () {	if (!isstatic (typeof (staticclass))) return 1;	if (!isstatic (typeof (staticclass2))) return 2;	
ok 

========================= mono sample_1691 =========================

public static void main () {	try {	mysection ms = (mysection) configurationmanager.getsection ("mysection");	foreach (myelement e in ms.myelements) console.writeline (e.name);	} catch (configurationexception ex) {	
configuration error 

========================= mono sample_29807 =========================

static void test5 () {	int i = 8;	switch (10) {	case 5: if (i != 10) throw new applicationexception ();	console.writeline (5);	break;	case 10: i = 10;	console.writeline (10);	goto default;	
default 

========================= mono sample_2076 =========================

public static int main(string[] args) {	methodinfo dofoo = typeof(testclass).getmethod("dofoo");	if ((dofoo.getmethodimplementationflags() & methodimplattributes.preservesig) == 0) return 1;	dofoo = typeof(testclass).getproperty("foo").getgetmethod ();	if ((dofoo.getmethodimplementationflags() & methodimplattributes.preservesig) == 0) return 1;	dofoo = typeof(testclass).getevent("e").getaddmethod (true);	if ((dofoo.getmethodimplementationflags() & methodimplattributes.preservesig) == 0) return 1;	
has preservesig 

========================= mono sample_2254 =========================

public void readsubtreeemptyelementwithattribute () {	string xml = @"<root><x a='b'/></root>";	xmlreader r = xmlreader.create (new stringreader (xml));	r.read ();	r.read ();	xmlreader r2 = r.readsubtree ();	
x 

========================= mono sample_22351 =========================

public void methodpreprocesscontrolmessage () {	bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	
start 

public void methodpreprocesscontrolmessage () {	bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	
end 

public void methodpreprocesscontrolmessage () {	bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	
start 

bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	
end 

mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	
start 

message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	
end 

m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	
start 

m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	
end 

m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	
start 

m.lparam = intptr.zero;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	
end 

c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	
start 

assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	
end 

c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	
start 

assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	
end 

c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	
start 

assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	
end 

assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	
start 

m.msg = wm_char;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	
end 

c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	
start 

assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	
end 

c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	
start 

assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	
end 

c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	
start 

assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	
end 

m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	
start 

c.setstate (state.none);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a13");	
end 

assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a13");	c.setstate (state.processcmdkey);	
start 

c.setstate (state.isinputchar);	assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a14");	
end 

assert.areequal (preprocesscontrolstate.messageneeded, c.preprocesscontrolmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a14");	c.setstate (state.isinputkey);	
start 

c.setstate (state.processdialogchar);	assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a14");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a15");	
end 

assert.areequal (preprocesscontrolstate.messageprocessed, c.preprocesscontrolmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a14");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a15");	c.setstate (state.processdialogkey);	
start 

m.msg = wm_keyup;	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a14");	c.setstate (state.isinputkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a15");	c.setstate (state.processdialogkey);	assert.areequal (preprocesscontrolstate.messagenotneeded, c.preprocesscontrolmessage (ref m), "a16");	
end 

public void methodpreprocessmessage () {	bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	
start 

public void methodpreprocessmessage () {	bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	
end 

public void methodpreprocessmessage () {	bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	
start 

bool testing_callstack = false;	mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	
end 

mycontrol c = new mycontrol ();	message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	
start 

message m = new message ();	m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	
end 

m.hwnd = c.handle;	m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	
start 

m.msg = wm_keydown;	m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	
end 

m.wparam = (intptr)keys.down;	m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	
start 

m.lparam = intptr.zero;	assert.areequal (false, c.preprocessmessage (ref m), "a1");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (true, c.preprocessmessage (ref m), "a5");	
end 

c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (true, c.preprocessmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	
start 

assert.areequal (false, c.preprocessmessage (ref m), "a2");	c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (true, c.preprocessmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	
end 

c.setstate (state.processcmdkey);	assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (true, c.preprocessmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	
start 

assert.areequal (true, c.preprocessmessage (ref m), "a3");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (true, c.preprocessmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	
end 

c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (true, c.preprocessmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	
start 

assert.areequal (false, c.preprocessmessage (ref m), "a4");	c.setstate (state.processdialogkey);	assert.areequal (true, c.preprocessmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	
end 

assert.areequal (true, c.preprocessmessage (ref m), "a5");	m.msg = wm_char;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	
start 

m.msg = wm_char;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	
end 

c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	
start 

assert.areequal (false, c.preprocessmessage (ref m), "a6");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	
end 

c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	
start 

assert.areequal (false, c.preprocessmessage (ref m), "a7");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	
end 

c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	
start 

assert.areequal (true, c.preprocessmessage (ref m), "a8");	m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	
end 

m.msg = wm_syschar;	c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	
start 

c.setstate (state.none);	assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a13");	
end 

assert.areequal (false, c.preprocessmessage (ref m), "a9");	c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a13");	c.setstate (state.processcmdkey);	
start 

c.setstate (state.isinputchar);	assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (false, c.preprocessmessage (ref m), "a14");	
end 

assert.areequal (false, c.preprocessmessage (ref m), "a10");	c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (false, c.preprocessmessage (ref m), "a14");	c.setstate (state.isinputkey);	
start 

c.setstate (state.processdialogchar);	assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (false, c.preprocessmessage (ref m), "a14");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a15");	
end 

assert.areequal (true, c.preprocessmessage (ref m), "a11");	m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (false, c.preprocessmessage (ref m), "a14");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a15");	c.setstate (state.processdialogkey);	
start 

m.msg = wm_keyup;	assert.areequal (false, c.preprocessmessage (ref m), "a12");	c.setstate (state.onpreviewkeydown);	assert.areequal (false, c.preprocessmessage (ref m), "a13");	c.setstate (state.processcmdkey);	assert.areequal (false, c.preprocessmessage (ref m), "a14");	c.setstate (state.isinputkey);	assert.areequal (false, c.preprocessmessage (ref m), "a15");	c.setstate (state.processdialogkey);	assert.areequal (false, c.preprocessmessage (ref m), "a16");	
end 

protected override bool isinputchar (char charcode) {	if (testing_callstack) console.write ("isinputchar[");	if (current_state == state.isinputchar) {	
true 

void createcontrol () {	try {	f = new form ();	f.showintaskbar = false;	c = new control ();	f.controls.add (c);	console.writeline ("f.handle = {0}", f.handle);	console.writeline ("c.handle = {0}", c.handle);	control_context = new applicationcontext (f);	monitor.enter (m);	
pulsing 

f = new form ();	f.showintaskbar = false;	c = new control ();	f.controls.add (c);	console.writeline ("f.handle = {0}", f.handle);	console.writeline ("c.handle = {0}", c.handle);	control_context = new applicationcontext (f);	monitor.enter (m);	monitor.pulse (m);	monitor.exit (m);	
control thread running 

c = new control ();	f.controls.add (c);	console.writeline ("f.handle = {0}", f.handle);	console.writeline ("c.handle = {0}", c.handle);	control_context = new applicationcontext (f);	monitor.enter (m);	monitor.pulse (m);	monitor.exit (m);	application.run (control_context);	c.dispose ();	
dying 

console.writeline ("f.handle = {0}", f.handle);	console.writeline ("c.handle = {0}", c.handle);	control_context = new applicationcontext (f);	monitor.enter (m);	monitor.pulse (m);	monitor.exit (m);	application.run (control_context);	c.dispose ();	threaddied = true;	monitor.enter (m);	
pulsing again 

public void invoketest () {	m = new object ();	control_t = new thread(new threadstart(createcontrol));	monitor.enter (m);	control_t.start ();	
waiting on monitor 

public void invoketest () {	m = new object ();	control_t = new thread(new threadstart(createcontrol));	monitor.enter (m);	control_t.start ();	monitor.wait (m);	
making async call 

public void delegate_call () {	try {	delegatecalled = true;	f.dispose ();	
calling application exit 

========================= mono sample_25471 =========================

public static int main () {	guid id = guid.newguid ();	dc dc = new dc (id);	
id default 

public static int main () {	guid id = guid.newguid ();	dc dc = new dc (id);	if (dc.id.equals (default (guid))) return 1;	if (dc.m_id.equals (default (guid))) return 2;	
ok 

========================= mono sample_2205 =========================

public static int main() {	int state = 0;	try {	throwexception();	try {	
in try block 

} catch (exception e) {	state = 1;	console.writeline("------------------------");	console.writeline(e);	console.writeline("------------------------");	}	} catch {	state = 2;	}	if (state != 2) return 1;	
ok 

========================= mono sample_658 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
count 

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
appsettings count 

========================= mono sample_29833 =========================

public static void main(string[] args) {	
hello world 

========================= mono sample_34513 =========================

public void test () {	int a = 1;	for (int i = a; i < 10; i++){	int j = i;	t = delegate {	
before 

public static int main () {	s s = new s ();	s.test ();	s.t ();	if (s.f == 10) return 0;	
failed 

========================= mono sample_2293 =========================

nativemethods.postmessage(new handleref(this, mainwindowhandle), nativemethods.wm_close, intptr.zero, intptr.zero);	return true;	}	#endif void releaseprocesshandle(safeprocesshandle handle) {	if (handle == null) {	return;	}	if (haveprocesshandle && handle == m_processhandle) {	return;	}	
process closehandle process 

close();	}	this.disposed = true;	base.dispose(disposing);	}	}	public void close() {	if (associated) {	if (haveprocesshandle) {	stopwatchingforexit();	
process closehandle process in close 

}	nativemethods.tokenprivileges tkp = new nativemethods.tokenprivileges();	tkp.luid = debugvalue;	tkp.attributes = attrib;	nativemethods.adjusttokenprivileges(new handleref(null, htoken), false, tkp, 0, intptr.zero, intptr.zero);	if (marshal.getlastwin32error() != nativemethods.error_success) {	throw new win32exception();	}	}	finally {	
process closehandle processtoken 

#if !mono [resourceexposure(resourcescope.machine)]	[resourceconsumption(resourcescope.machine)]	public static process[] getprocesses(string machinename) {	bool isremotemachine = processmanager.isremotemachine(machinename);	processinfo[] processinfos = processmanager.getprocessinfos(machinename);	process[] processes = new process[processinfos.length];	for (int i = 0; i < processinfos.length; i++) {	processinfo processinfo = processinfos[i];	processes[i] = new process(machinename, isremotemachine, processinfo.processid, processinfo);	}	
process getprocesses 

if (this.synchronizingobject != null && this.synchronizingobject.invokerequired) this.synchronizingobject.begininvoke(exited, new object[]{this, eventargs.empty});	else exited(this, eventargs.empty);	}	}	[resourceexposure(resourcescope.none)]	[resourceconsumption(resourcescope.machine, resourcescope.machine)]	safeprocesshandle getprocesshandle(int access, bool throwifexited) {	debug.writelineif(processtracing.traceverbose, "getprocesshandle(access = 0x" + access.tostring("x8", cultureinfo.invariantculture) + ", throwifexited = " + throwifexited + ")");	#if debug if (processtracing.traceverbose) {	stackframe calledfrom = new stacktrace(true).getframe(0);	
called from line 

========================= mono sample_12463 =========================

public static void assert ( bool b, [callerfilepath] string sourcefile = null, [callerlinenumber] int linenumber = 0 ) {	assertcount++;	if (!b) {	
assert failed at sourcefile linenumber 

========================= mono sample_609 =========================

public static void worker () {	
domain start 

for (int i = 0; i < allocs; ++i) {	list.add (new object ());	list.add (new arraylist ());	list.add (new string ('x', 34));	int[] a = new int [5];	list.add (new weakreference (a));	if ((i % 1024) == 0) {	list.removerange (0, list.count / 2);	}	}	
domain end 

static void thread_start () {	
thread start 

static void thread_start () {	for (int i = 0; i < domains; ++i) {	appdomain appdomain = appdomain.createdomain("test-" + i);	appdomain.docallback (new crossappdomaindelegate (worker));	try {	appdomain.unload (appdomain);	} catch {	interlocked.increment (ref errors);	
error unloading test 

static void thread_start () {	for (int i = 0; i < domains; ++i) {	appdomain appdomain = appdomain.createdomain("test-" + i);	appdomain.docallback (new crossappdomaindelegate (worker));	try {	appdomain.unload (appdomain);	} catch {	interlocked.increment (ref errors);	}	}	
thread end 

========================= mono sample_598 =========================

static string searchtypes (string name, ref type retval, out int count) {	stringbuilder sb = new stringbuilder ();	type current = null;	count = 0;	string [] assemblies = getknownassemblynames ();	for (int i = 0; i < assemblies.length; i++) {	
loading 

}	process p = new process ();	p.startinfo.useshellexecute = false;	p.startinfo.redirectstandardoutput = true;	p.startinfo.filename = "gacutil";	p.startinfo.arguments = "-l";	try {	p.start ();	}	catch {	
warning gacutil could not be found 

static assembly getassembly (string assembly, bool exit) {	assembly a = null;	if (assembly.startswith ("~/")) assembly = path.combine (environment.getfolderpath (environment.specialfolder.personal), assembly.substring (2));	try {	if (file.exists (assembly)) a = universe.loadfile (assembly);	else a = loadfrommonopath (assembly);	} catch {	}	if (a == null && exit) {	
could not load 

static void printtypes (string assembly, bool show_private, bool filter_obsolete) {	assembly a = getassembly (assembly, true);	console.writeline ();	
assembly information 

console.writeline ();	foreach (string ai in a.tostring ().split (',')) console.writeline (ai.trim ());	console.writeline ();	type [] types = show_private ? a.gettypes () : a.getexportedtypes ();	array.sort (types, new typesorter ());	int obsolete_count = 0;	foreach (type t in types) {	if (filter_obsolete && t.isdefined (obsolete_attribute, false)) obsolete_count++;	else console.writeline (t.fullname);	}	
total types 

}	string message = null;	string tname = options.type;	type t = null;	int count;	if (options.search) {	string matches = searchtypes (tname, ref t, out count);	if (count == 0) goto notfound;	if (count == 1) goto found;	if (count > 1){	
found types that match 

goto found;	}	foreach (string ns in common_ns) {	t = a.gettype (ns + "." + tname, false, true);	if (t != null) {	message = string.format ("{0} is included in the {1} assembly.", t.fullname, t.assembly.getname ().name);	goto found;	}	}	} catch (exception e){	
failure 

if (t != null) {	message = string.format ("{0} is included in the {1} assembly.", t.fullname, t.assembly.getname ().name);	goto found;	}	}	} catch (exception e){	}	}	}	notfound: if (t == null) {	
could not find 

========================= mono sample_1289 =========================

public void at6_readblob() {	
from p in db othertypes orderby p datetime select p blob 

public void at6_readblob() {	alltypes db = createdb();	var result = from p in db.othertypes orderby p.datetime select p.blob;	foreach (var blob in result) {	
blob 

public void at6_readblob() {	alltypes db = createdb();	var result = from p in db.othertypes orderby p.datetime select p.blob;	foreach (var blob in result) {	}	
press enter to continue 

public void at7_readguidfromvarchar() {	
from p in db othertypes orderby p datetime select p blob 

public void at8_readguidfromvarbinary() {	
from p in db othertypes orderby p datetime select p blob 

public void test_unknown() {	alltypes db = createdb();	var result = from p in db.othertypes orderby p.datetime select p.blob;	foreach (var blob in result) {	
blob 

========================= mono sample_24638 =========================

if (!(a_string is iin<string>)) return 1;	if ((a_string is iin<object>)) return 2;	if (!(a_object is iin<string>)) return 3;	if (!(a_object is iin<object>)) return 4;	iout<string> b_string = new a<string> ();	iout<object> b_object = new a<object> ();	if (!(b_string is iout<string>)) return 10;	if (!(b_string is iout<object>)) return 11;	if (b_object is iout<string>) return 12;	if (!(b_object is iout<object>)) return 13;	
ok 

========================= mono sample_2331 =========================

foreach (itaskitem source in sources) {	string sourcefile = source.itemspec;	string outputfile = source.getmetadata ("autogen").equals ("true", stringcomparison.ordinalignorecase) ? source.itemspec.replace ('\\', '.').replace ('/', '.') : path.changeextension (sourcefile, "resources");	if (isresgenrequired (sourcefile, outputfile)) result &= compileresourcefile (sourcefile, outputfile);	itaskitem newitem = new taskitem (source);	newitem.itemspec = outputfile;	temporaryfileswritten.add (newitem);	}	} else {	if (sources.length != outputresources.length) {	
sources count is different than outputresources count 

itaskitem newitem = new taskitem (source);	newitem.itemspec = outputfile;	temporaryfileswritten.add (newitem);	}	} else {	if (sources.length != outputresources.length) {	return false;	}	for (int i = 0; i < sources.length; i ++) {	if (string.isnullorempty (outputresources [i].itemspec)) {	
filename of output can not be empty 

private bool compileresourcefile (string sname, string dname ) {	if (!file.exists (sname)) {	
resource file not found 

========================= mono sample_22265 =========================

static bool splitdriverandscriptarguments (ref string [] driver_args, out string [] script_args) {	int driver_args_count = 0;	int script_args_offset = 0;	string script_file = null;	while (driver_args_count < driver_args.length && script_args_offset == 0) {	switch (driver_args [driver_args_count]) {	case "--": script_args_offset = driver_args_count + 1;	break;	case "-s": if (driver_args_count + 1 >= driver_args.length) {	script_args = null;	
usage is s script file 

case agentstatus.stdout: string stdout = ns.getstring ();	console.writeline (stdout);	break;	case agentstatus.result_not_set: return null;	case agentstatus.result_set: string res = ns.getstring ();	console.writeline (res);	return null;	}	}	} catch (exception e){	
error evaluating expression exception 

case agentstatus.result_not_set: return null;	case agentstatus.result_set: string res = ns.getstring ();	console.writeline (res);	return null;	}	}	} catch (exception e){	}	return null;	}, (e) => {	
error communicating with server 

tcplistener interrupt_listener = new tcplistener (new ipendpoint (ipaddress.loopback, 0));	interrupt_listener.start ();	string agent_assembly = typeof (clientcsharpshell).assembly.location;	string agent_arg = string.format ("--agent:{0}:{1}" , ((ipendpoint)listener.server.localendpoint).port, ((ipendpoint)interrupt_listener.server.localendpoint).port);	var vm = new attach.virtualmachine (pid);	vm.attach (agent_assembly, agent_arg);	tcpclient client = listener.accepttcpclient ();	ns = client.getstream ();	tcpclient interrupt_client = interrupt_listener.accepttcpclient ();	interrupt_stream = interrupt_client.getstream ();	
connected 

public void run (object o) {	string arg = (string)o;	string ports = arg.substring (8);	int sp = ports.indexof (':');	int port = int32.parse (ports.substring (0, sp));	int interrupt_port = int32.parse (ports.substring (sp+1));	
csharp agent started connecting to localhost 

public void run (object o) {	string arg = (string)o;	string ports = arg.substring (8);	int sp = ports.indexof (':');	int port = int32.parse (ports.substring (0, sp));	int interrupt_port = int32.parse (ports.substring (sp+1));	tcpclient client = new tcpclient ("127.0.0.1", port);	tcpclient interrupt_client = new tcpclient ("127.0.0.1", interrupt_port);	
csharp agent connected 

try {	appdomain.currentdomain.assemblyload += assemblyloaded;	foreach (assembly a in appdomain.currentdomain.getassemblies ()) {	if (a.getname ().name != "mscorlib" && a.getname ().name != "system.core" && a.getname ().name != "system") evaluator.referenceassembly (a);	}	runrepl (s);	} finally {	appdomain.currentdomain.assemblyload -= assemblyloaded;	client.close ();	interrupt_client.close ();	
csharp agent disconnected 

========================= mono sample_1298 =========================

private static extern intptr getdefaultsignal ();	[dllimport (mph, callingconvention=callingconvention.cdecl, entrypoint="mono_posix_stdlib_sig_err")]	private static extern intptr geterrorsignal ();	[dllimport (mph, callingconvention=callingconvention.cdecl, entrypoint="mono_posix_stdlib_sig_ign")]	private static extern intptr getignoresignal ();	private static readonly intptr _sig_dfl = getdefaultsignal ();	private static readonly intptr _sig_err = geterrorsignal ();	private static readonly intptr _sig_ign = getignoresignal ();	private static void _errorhandler (int signum) {	
error handler invoked for signum don t do that 

private static void _defaulthandler (int signum) {	
default handler invoked for signum don t do that 

private static void _ignorehandler (int signum) {	
ignore handler invoked for signum don t do that 

========================= mono sample_22047 =========================

public void addbindingparameters (serviceendpoint endpoint, bindingparametercollection bindingparameters) {	
iendpointbehavior addbindingparameters 

public void applyclientbehavior (serviceendpoint endpoint, clientruntime clientruntime) {	
iendpointbehavior applyclientbehavior 

public void applydispatchbehavior (serviceendpoint endpoint, endpointdispatcher endpointdispatcher) {	
iendpointbehavior applydispatchbehavior 

public void validate (serviceendpoint endpoint) {	
iendpointbehavior validate 

public void addbindingparameters (contractdescription contractdescription, serviceendpoint endpoint, bindingparametercollection bindingparameters) {	
contract addbindingparameters 

public void applyclientbehavior (contractdescription contractdescription, serviceendpoint endpoint, clientruntime clientruntime) {	
contract applyclientbehavior 

public void applydispatchbehavior (contractdescription contractdescription, serviceendpoint endpoint, dispatchruntime dispatchruntime) {	
contract applydispatchbehavior 

public void validate (contractdescription contractdescription, serviceendpoint endpoint) {	
contract validate 

public void addbindingparameters (operationdescription operationdescription, bindingparametercollection bindingparameters) {	
ioperationbehavior addbindingparameters 

public void applyclientbehavior (operationdescription operationdescription, clientoperation clientoperation) {	
ioperationbehavior applyclientbehavior 

public void applydispatchbehavior (operationdescription operationdescription, dispatchoperation dispatchoperation) {	
ioperationbehavior applydispatchbehavior 

public void validate (operationdescription operationdescription) {	
ioperationbehavior validate 

========================= mono sample_31376 =========================

static bool check (int c, string s) {	if (msg (c) != s) {	
for expected got 

========================= mono sample_589 =========================

if (res.count != 1) return 1;	if (res [0].a != "<empty>") return 2;	if (res [0].b != "foo") return 3;	e = from a in d1 join datab b in d2 on a.key equals b.key into ab from x in ab.defaultifempty () select new { a = x == default (datab) ? "<empty>" : x.value, b = a.text };	foreach (var o in e) console.writeline (o);	res = e.tolist ();	if (res.count != 1) return 10;	if (res [0].a != "<empty>") return 11;	if (res [0].b != "foo") return 12;	var e2 = from a in d1 join a in d2 on a.key equals a.key into ab select a;	
ok 

========================= mono sample_2282 =========================

public static void main (string [] args) {	textwriter w = console.out;	w.newline = "\n";	
do not modify this file directly this file is automatically generated by exe the source for this generator should be in mono repository mcs class corlib mono globalization unicode directory ifndef unicode data h define unicode data h include glib h 

var ud = new unicodedata5_1_0 ();	var ucd = ud.parsefile (args [0]);	var ucg = new unicodedatacodegeneratorc5_1_0 (ud, w);	ucg.generatestructures ();	w.writeline ();	ucg.generateunicodecategorylistc (ucd);	w.writeline ();	ucg.generatesimplecasemappinglistc (ucd);	w.writeline ();	ucg.generatesimpletitlecasemappinglistc (ucd);	
endif 

public void generatestructures () {	w.writeline ("/* ======== structures ======== */");	
typedef struct 

public void generatestructures () {	w.writeline ("/* ======== structures ======== */");	guint32 codepoint;	guint32 upper;	guint32 title;	} simpletitlecasemapping;");	
typedef struct 

public void generatestructures () {	w.writeline ("/* ======== structures ======== */");	guint32 codepoint;	guint32 upper;	guint32 title;	} simpletitlecasemapping;");	guint32 start;	guint32 end;	} codepointrange;");	
typedef struct 

========================= mono sample_27870 =========================

static ienumerable getit (int [] args) {	foreach (int arg in args) {	
out 

static ienumerable getit (int [] args) {	foreach (int arg in args) {	a a = delegate {	
arg 

public static int main () {	int total = 0;	foreach (int i in getit (new int [] { 1, 2, 3})){	
got 

========================= mono sample_2053 =========================

var pendinglinefragmenterror = new stringbuilder ();	var environmentoverride = getandlogenvironmentvariables ();	try {	processwrapper pw = processservice.startprocess (pinfo, (_, msg) => processline (pendinglinefragmentoutput, msg, standardoutputloggingimportance), (_, msg) => processline (pendinglinefragmenterror, msg, standarderrorloggingimportance), null, environmentoverride);	pw.waitforoutput (timeout == int32.maxvalue ? int32.maxvalue : timeout);	processline (pendinglinefragmentoutput, standardoutputloggingimportance, true);	processline (pendinglinefragmenterror, standarderrorloggingimportance, true);	exitcode = pw.exitcode;	pw.dispose ();	} catch (system.componentmodel.win32exception e) {	
error executing tool 

========================= mono sample_26718 =========================

public static int main () {	foo foo = new foo ();	foo.p = 1;	if (!do (foo)) return 1;	
ok 

========================= mono sample_2185 =========================

static public void main (string [] args) {	securityaction a = securityaction.demand;	switch (a) {	
ok 

========================= mono sample_2094 =========================

bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	assert.areequal (864, data.stride, "stride");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	assert.areequal (300, data.stride, "stride");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	assert.areequal (864, data.stride, "stride");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

========================= mono sample_21129 =========================

public static void main () {	try {	mysection ms = (mysection) configurationmanager.getsection ("mysection");	foreach (myelement e in ms.myelements) console.writeline (e.name);	} catch (configurationexception ex) {	
error 

========================= mono sample_29847 =========================

[obsolete("this method has been deprecated.  please use system.diagnostics.eventlog.createeventsource(eventsourcecreationdata sourcedata) instead.  http: public static void createeventsource(string source, string logname, string machinename) {	createeventsource(new eventsourcecreationdata(source, logname, machinename));	}	[resourceexposure(resourcescope.none)]	[resourceconsumption(resourcescope.machine, resourcescope.machine)]	public static void createeventsource(eventsourcecreationdata sourcedata) {	if (sourcedata == null) throw new argumentnullexception("sourcedata");	string logname = sourcedata.logname;	string source = sourcedata.source;	string machinename = sourcedata.machinename;	
createeventsource checking arguments 

if (logname == null || logname.length==0) logname = "application";	if (!validlogname(logname, false)) throw new argumentexception(sr.getstring(sr.badlogname));	if (source == null || source.length==0) throw new argumentexception(sr.getstring(sr.missingparameter, "source"));	if (source.length + eventlogkey.length > 254) throw new argumentexception(sr.getstring(sr.parametertoolong, "source", 254 - eventlogkey.length));	eventlogpermission permission = new eventlogpermission(eventlogpermissionaccess.administer, machinename);	permission.demand();	mutex mutex = null;	runtimehelpers.prepareconstrainedregions();	try {	sharedutils.entermutex(eventlogmutexname, ref mutex);	
createeventsource calling sourceexists 

if (!validlogname(logname, false)) throw new argumentexception(sr.getstring(sr.badlogname));	if (source == null || source.length==0) throw new argumentexception(sr.getstring(sr.missingparameter, "source"));	if (source.length + eventlogkey.length > 254) throw new argumentexception(sr.getstring(sr.parametertoolong, "source", 254 - eventlogkey.length));	eventlogpermission permission = new eventlogpermission(eventlogpermissionaccess.administer, machinename);	permission.demand();	mutex mutex = null;	runtimehelpers.prepareconstrainedregions();	try {	sharedutils.entermutex(eventlogmutexname, ref mutex);	if (sourceexists(source, machinename, true)) {	
createeventsource sourceexists returned true 

eventlogpermission permission = new eventlogpermission(eventlogpermissionaccess.administer, machinename);	permission.demand();	mutex mutex = null;	runtimehelpers.prepareconstrainedregions();	try {	sharedutils.entermutex(eventlogmutexname, ref mutex);	if (sourceexists(source, machinename, true)) {	if (".".equals(machinename)) throw new argumentexception(sr.getstring(sr.localsourcealreadyexists, source));	else throw new argumentexception(sr.getstring(sr.sourcealreadyexists, source, machinename));	}	
createeventsource getting dllpath 

else throw new argumentexception(sr.getstring(sr.sourcealreadyexists, source, machinename));	}	permissionset permissionset = _unsafegetassertpermset();	permissionset.assert();	registrykey basekey = null;	registrykey eventkey = null;	registrykey logkey = null;	registrykey sourcelogkey = null;	registrykey sourcekey = null;	try {	
createeventsource getting local machine regkey 

========================= mono sample_12417 =========================

public static void main (string [] args) {	if (args.length == 0) {	
pass path to machine config 

========================= mono sample_31193 =========================

public basicmethoddriver (method method, ibasicanalysisdriver parent) {	this.method = method;	this.parent = parent;	rawlayer = codelayerfactory.create ( this.parent.subroutinefacade.getcontrolflowgraph (method).getdecoder (parent.metadataprovider), parent.metadataprovider, parent.contractprovider, dummy => "", dummy => "");	if (debugoptions.debug) {	
apc based cfg 

public basicmethoddriver (method method, ibasicanalysisdriver parent) {	this.method = method;	this.parent = parent;	rawlayer = codelayerfactory.create ( this.parent.subroutinefacade.getcontrolflowgraph (method).getdecoder (parent.metadataprovider), parent.metadataprovider, parent.contractprovider, dummy => "", dummy => "");	if (debugoptions.debug) {	rawlayer.ildecoder.contextprovider.methodcontext.cfg.print (console.out, rawlayer.printer, null, null);	}	stacklayer = codelayerfactory.create ( stackdepthfactory.create (rawlayer.ildecoder, rawlayer.metadataprovider), rawlayer.metadataprovider, rawlayer.contractprovider, (i => "s" + i.tostring ()), i => "s" + i.tostring () );	if (debugoptions.debug) {	
stack based cfg 

========================= mono sample_29595 =========================

static void f2 () {	try {	goto finallyexit;	} finally {	throw new applicationexception ();	}	
too late 

========================= mono sample_1680 =========================

public nulltransform (null algo, bool encryption, byte[] key, byte[] iv) : base (algo, encryption, iv) {	_block = 0;	_debug = (environment.getenvironmentvariable ("mono_debug") != null);	if (_debug) {	
mode encryption decryption 

public nulltransform (null algo, bool encryption, byte[] key, byte[] iv) : base (algo, encryption, iv) {	_block = 0;	_debug = (environment.getenvironmentvariable ("mono_debug") != null);	if (_debug) {	
key 

public nulltransform (null algo, bool encryption, byte[] key, byte[] iv) : base (algo, encryption, iv) {	_block = 0;	_debug = (environment.getenvironmentvariable ("mono_debug") != null);	if (_debug) {	
iv 

protected override void ecb (byte[] input, byte[] output) {	buffer.blockcopy (input, 0, output, 0, output.length);	if (_debug) {	
ecb on block 

========================= mono sample_20638 =========================

static bool buildx509chain (x509certificatecollection certs, x509chain chain, ref sslpolicyerrors errors, ref int status11) {	#if mobile return false;	#else if (is_macosx) return false;	var leaf = (x509certificate2)certs [0];	bool ok;	try {	ok = chain.build (leaf);	if (!ok) errors |= geterrorsfromchain (chain);	} catch (exception e) {	
error building certificate chain 

static bool buildx509chain (x509certificatecollection certs, x509chain chain, ref sslpolicyerrors errors, ref int status11) {	#if mobile return false;	#else if (is_macosx) return false;	var leaf = (x509certificate2)certs [0];	bool ok;	try {	ok = chain.build (leaf);	if (!ok) errors |= geterrorsfromchain (chain);	} catch (exception e) {	
please report this problem to the mono team 

} else if (eku != null) {	return eku.enhancedkeyusages ["1.3.6.1.5.5.7.3.1"] != null || eku.enhancedkeyusages ["2.16.840.1.113730.4.1"] != null;	}	x509extension ext = cert.extensions ["2.16.840.1.113730.1.1"];	if (ext != null) {	string text = ext.netscapecerttype (false);	return text.indexof ("ssl server authentication", stringcomparison.ordinal) != -1;	}	return true;	} catch (exception e) {	
error processing certificate 

} else if (eku != null) {	return eku.enhancedkeyusages ["1.3.6.1.5.5.7.3.1"] != null || eku.enhancedkeyusages ["2.16.840.1.113730.4.1"] != null;	}	x509extension ext = cert.extensions ["2.16.840.1.113730.1.1"];	if (ext != null) {	string text = ext.netscapecerttype (false);	return text.indexof ("ssl server authentication", stringcomparison.ordinal) != -1;	}	return true;	} catch (exception e) {	
please report this problem to the mono team 

subjectaltnameextension subjectaltname = new subjectaltnameextension (ext);	foreach (string dns in subjectaltname.dnsnames) {	if (match (targethost, dns)) return true;	}	foreach (string ip in subjectaltname.ipaddresses) {	if (ip == targethost) return true;	}	}	return checkdomainname (mcert.subjectname, targethost);	} catch (exception e) {	
error processing certificate 

subjectaltnameextension subjectaltname = new subjectaltnameextension (ext);	foreach (string dns in subjectaltname.dnsnames) {	if (match (targethost, dns)) return true;	}	foreach (string ip in subjectaltname.ipaddresses) {	if (ip == targethost) return true;	}	}	return checkdomainname (mcert.subjectname, targethost);	} catch (exception e) {	
please report this problem to the mono team 

========================= mono sample_24231 =========================

static int main (string [] args) {	if (typeof (int).gettype ().name != "runtimetype") {	
this must be run on the ms runtime 

static int main (string [] args) {	if (typeof (int).gettype ().name != "runtimetype") {	return 1;	}	string file = "";	destination_file = file;	if (destination_file == "") {	
you ll have to set the destination file see source for instructions 

generatetostring_bool_int_int_test ();	generatetostring_bool_test ();	generatetostring_int_int_test ();	generatetostringtest ();	generateverifychartest ();	generateverifyescapechartest ();	generateverifystring_string_int_maskedtextresulthinttest ();	generateverifystring_string_test ();	writefilefooter ();	}	
press any key to exit 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (c);	writeline (string.format ("result = mtp.add ('\\x{0:x4}');", (int)c) + (c != char.minvalue ? "/* " + c.tostring () + " */" : "/* null */"));	
assert areequal result 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (c, out testposition, out resulthint);	writeline (string.format ("result = mtp.add ('\\x{0:x4}', out testposition, out resulthint);", (int)c) + (c != char.minvalue ? "/* " + c.tostring () + " */" : "/* null */"));	
assert areequal result 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (c, out testposition, out resulthint);	writeline (string.format ("result = mtp.add ('\\x{0:x4}', out testposition, out resulthint);", (int)c) + (c != char.minvalue ? "/* " + c.tostring () + " */" : "/* null */"));	
assert areequal resulthint 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (c, out testposition, out resulthint);	writeline (string.format ("result = mtp.add ('\\x{0:x4}', out testposition, out resulthint);", (int)c) + (c != char.minvalue ? "/* " + c.tostring () + " */" : "/* null */"));	
assert areequal testposition 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (s);	writelinenonformat ("result = mtp.add (@\"" + s.replace ("\"", "\"\"") + "\");");	
assert areequal result 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (s, out testposition, out resulthint);	writelinenonformat ("result = mtp.add (@\"" + s.replace ("\"", "\"\"") + "\", out testposition, out resulthint);");	
assert areequal result 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (s, out testposition, out resulthint);	writelinenonformat ("result = mtp.add (@\"" + s.replace ("\"", "\"\"") + "\", out testposition, out resulthint);");	
assert areequal resulthint 

if (compare ("add", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	result = mtp.add (s, out testposition, out resulthint);	writelinenonformat ("result = mtp.add (@\"" + s.replace ("\"", "\"\"") + "\", out testposition, out resulthint);");	
assert areequal testposition 

if (compare ("clear", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	if (with_result) {	mtp.clear (out resulthint);	
mtp clear out resulthint 

if (compare ("clear", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	if (with_result) {	mtp.clear (out resulthint);	
assert areequal resulthint 

}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	if (with_result) {	mtp.clear (out resulthint);	} else {	mtp.clear ();	
mtp clear 

continue;	}	writeteststart ();	string new_statement = "mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");";	more_states = createstate (mtp, stateindex);	stateindex++;	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	string result = maskedtextprovidertest.join (mtp.editpositions, ";");	writeline ("");	writeline (new_statement);	
assert areequal result maskedtextprovidertest join mtp editpositions 

object [] arguments;	arguments = new object [] { i, value };	if (compare (methodname, mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp true false 

object [] arguments;	arguments = new object [] { i, k, value };	if (compare (methodname, mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp true false 

object [] arguments;	arguments = new object [] { chr, i };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp insertat 

object [] arguments;	arguments = new object [] { str, i };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp insertat 

object [] arguments;	arguments = new object [] { chr, i, int32_out, maskedtextresulthint_out };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp insertat out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { chr, i, int32_out, maskedtextresulthint_out };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

object [] arguments;	arguments = new object [] { chr, i, int32_out, maskedtextresulthint_out };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp insertat out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("insertat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { i };	if (compare ("isavailableposition", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp isavailableposition 

object [] arguments;	arguments = new object [] { i };	if (compare ("iseditposition", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp iseditposition 

}	bit_array.append (string.format ("(int) 0x{0:x8}", numbers [i]));	if (i != numbers.length - 1) bit_array.append (", ");	}	bit_array.appendline ("");	bit_array.appendline (tabs + "};");	bit_array.appendline (tabs + "};");	writelinenonformat (bit_array.tostring ());	writeline ("bitarray bits = new bitarray (answers);");	writeline ("for (int i = 0; i < (int) char.maxvalue; i++)");	
assert areequal bits get i maskedtextprovider isvalidinputchar char i i tostring 

}	bit_array.append (string.format ("(int) 0x{0:x8}", numbers [i]));	if (i != numbers.length - 1) bit_array.append (", ");	}	bit_array.appendline ("");	bit_array.appendline (tabs + "};");	bit_array.appendline (tabs + "};");	writelinenonformat (bit_array.tostring ());	writeline ("bitarray bits = new bitarray (answers);");	writeline ("for (int i = 0; i < (int) char.maxvalue; i++)");	
assert areequal bits get i maskedtextprovider isvalidmaskchar char i i tostring 

}	bit_array.append (string.format ("(int) 0x{0:x8}", numbers [i]));	if (i != numbers.length - 1) bit_array.append (", ");	}	bit_array.appendline ("");	bit_array.appendline (tabs + "};");	bit_array.appendline (tabs + "};");	writelinenonformat (bit_array.tostring ());	writeline ("bitarray bits = new bitarray (answers);");	writeline ("for (int i = 0; i < (int) char.maxvalue; i++)");	
assert areequal bits get i maskedtextprovider isvalidpasswordchar char i i tostring 

if (i >= mtp.length) break;	object [] arguments;	arguments = new object [] { i };	if (compare ("item", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp 

arguments = new object [] { };	if (compare ("remove", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	for (int i = -1; i < mask.length + 2; i++) {	
assert areequal mtp remove 

arguments = new object [] { int32_out, maskedtextresulthint_out };	if (compare ("remove", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	for (int i = -1; i < mask.length + 2; i++) {	
assert areequal mtp remove out out out maskedtextresulthint out 

arguments = new object [] { int32_out, maskedtextresulthint_out };	if (compare ("remove", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	for (int i = -1; i < mask.length + 2; i++) {	
assert areequal out 

arguments = new object [] { int32_out, maskedtextresulthint_out };	if (compare ("remove", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	for (int i = -1; i < mask.length + 2; i++) {	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { i };	if (compare ("removeat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp removeat 

object [] arguments;	arguments = new object [] { i, j };	if (compare ("removeat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp removeat 

arguments = new object [] { i, j, int32_out, maskedtextresulthint_out };	if (compare ("removeat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	dont_write = false;	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp removeat out out out maskedtextresulthint out 

arguments = new object [] { i, j, int32_out, maskedtextresulthint_out };	if (compare ("removeat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	dont_write = false;	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

arguments = new object [] { i, j, int32_out, maskedtextresulthint_out };	if (compare ("removeat", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	dont_write = false;	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp replace 

object [] arguments;	arguments = new object [] { str, i };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp replace 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp replace out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp replace out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

object [] arguments;	arguments = new object [] { str, i, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, j, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp replace out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, j, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

object [] arguments;	arguments = new object [] { str, i, j, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, j, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp replace out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, j, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

object [] arguments;	arguments = new object [] { str, i, j, int32_out, maskedtextresulthint_out };	if (compare ("replace", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str };	if (compare ("set", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp set 

object [] arguments;	arguments = new object [] { str, int32_out, maskedtextresulthint_out };	if (compare ("set", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp set out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, int32_out, maskedtextresulthint_out };	if (compare ("set", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

object [] arguments;	arguments = new object [] { str, int32_out, maskedtextresulthint_out };	if (compare ("set", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { };	if (compare ("todisplaystring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp todisplaystring 

object [] arguments;	arguments = new object [] { };	if (compare ("tostring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp tostring 

object [] arguments;	arguments = new object [] { value };	if (compare ("tostring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp tostring true false 

object [] arguments;	arguments = new object [] { value1, value2 };	if (compare ("tostring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp tostring true false true false 

object [] arguments;	arguments = new object [] { i, j };	if (compare ("tostring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp tostring 

object [] arguments;	arguments = new object [] { value1, i, j };	if (compare ("tostring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp tostring true false 

object [] arguments;	arguments = new object [] { value1, value2, i, j };	if (compare ("tostring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp tostring true false true false 

object [] arguments;	arguments = new object [] { value1, value2, value3, i, j };	if (compare ("tostring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp tostring true false true false true false 

object [] arguments;	arguments = new object [] { str, i, maskedtextresulthint_out };	if (compare ("verifychar", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp verifychar out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i, maskedtextresulthint_out };	if (compare ("verifychar", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, i };	if (compare ("verifyescapechar", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp verifyescapechar 

object [] arguments;	arguments = new object [] { str };	if (compare ("verifystring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp verifystring 

object [] arguments;	arguments = new object [] { str, int32_out, maskedtextresulthint_out };	if (compare ("verifystring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal mtp verifystring out out out maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, int32_out, maskedtextresulthint_out };	if (compare ("verifystring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal maskedtextresulthint out 

object [] arguments;	arguments = new object [] { str, int32_out, maskedtextresulthint_out };	if (compare ("verifystring", mask, ref stateindex, arguments, ref more_states)) {	continue;	}	writeteststart ();	mtp = new ms_system_componentmodel.maskedtextprovider (mask);	writeline ("mtp = new maskedtextprovider (@\"" + mask.replace ("\"", "\"\"") + "\");");	more_states = createstate (mtp, stateindex);	stateindex++;	
assert areequal out 

static void writetestheader (string testname, params string [] method_init) {	
testfixture 

static void writetestheader (string testname, params string [] method_init) {	
public class 

current_test_counter = 0;	total_skipped_counter += skipped_test_counter;	skipped_test_counter = 0;	current_test_name = testname;	current_test_method_init = method_init;	console.write ("writing " + testname + "... ");	}	static void writetestfooter () {	tab--;	writelinenonformat ("}");	
written tests and skipped tests 

static void writeteststart () {	current_test_counter++;	
test 

static void writeteststart () {	current_test_counter++;	
public void 

[testfixture]	public class maskedtextprovidergeneratedtests {	");	tab += 2;	}	static void writefilefooter () {	writelinenonformat ( }	}	");	tab -= 2;	
written tests in total and skipped tests 

========================= mono sample_23400 =========================

public delegate string tostr (string format, iformatprovider format_provider);	public class genericclass<t> where t : iformattable {	t field;	public genericclass (t t) {	this.field = t;	}	public void method () {	tostr str = new tostr (field.tostring);	
x 

========================= mono sample_1892 =========================

writer.write("<table columns=\"");	writer.write(fieldcount.tostring(cultureinfo.invariantculture));	writer.writeline("\">");	if (shouldrendertableheaders()) {	writer.write("<tr>");	foreach (int fieldindex in tablefieldindices) {	writer.write("<td>");	writer.rendertext(control.allfields[fieldindex].title);	writer.write("</td>");	}	
tr 

for (int field = 0; field < fieldcount; field++) {	writer.write("<td>");	if (field == 0 && itemrequireshyperlink) {	renderpostbackevent(writer, requiressecondscreen ? string.format(cultureinfo.invariantculture, _showmoreformatanchor, item.index) : item.index.tostring(cultureinfo.invariantculture), getdefaultlabel(golabel), false, item[tablefieldindices[0]], false, wmlpostfieldtype.raw);	}	else {	writer.rendertext(item[tablefieldindices[field]]);	}	writer.write("</td>");	}	
tr 

writer.write("<td>");	if (field == 0 && itemrequireshyperlink) {	renderpostbackevent(writer, requiressecondscreen ? string.format(cultureinfo.invariantculture, _showmoreformatanchor, item.index) : item.index.tostring(cultureinfo.invariantculture), getdefaultlabel(golabel), false, item[tablefieldindices[0]], false, wmlpostfieldtype.raw);	}	else {	writer.rendertext(item[tablefieldindices[field]]);	}	writer.write("</td>");	}	}	
table 

========================= mono sample_6042 =========================

protected override xslflags visitcalltemplate(xslnode node) {	xslflags result = xslflags.none;	template target;	if (!compiler.namedtemplates.trygetvalue(node.name, out target)) {	
unknown template error 

protected override xslflags visituseattributeset(xslnode node) {	attributeset attset;	if (!compiler.attributesets.trygetvalue(node.name, out attset)) {	
unknown attribute set error 

typedonor = null;	return (left & ~xslflags.typefilter) | xslflags.nodeset;	}	public virtual xslflags predicate(xslflags nodeset, xslflags predicate, bool isreversestep) {	typedonor = null;	return (nodeset & ~xslflags.typefilter) | xslflags.nodeset | (predicate & xslflags.sideeffects);	}	public virtual xslflags variable(string prefix, string name) {	typedonor = resolvevariable(prefix, name);	if (typedonor == null) {	
unresolved variable error 

========================= mono sample_6293 =========================

public static int main(string[] args) {	ntrace.info( "nunit-console.exe starting" );	consoleoptions options = new consoleoptions(args);	if(!options.nologo) writecopyright();	if(options.help) {	options.help();	return consoleui.ok;	}	if(options.noargs) {	
fatal error no inputs specified 

if(!options.nologo) writecopyright();	if(options.help) {	options.help();	return consoleui.ok;	}	if(options.noargs) {	options.help();	return consoleui.ok;	}	if(!options.validate()) {	
fatal error invalid argument 

servicemanager.services.initializeservices();	try {	consoleui consoleui = new consoleui();	return consoleui.execute( options );	}	catch( filenotfoundexception ex ) {	console.writeline( ex.message );	return consoleui.file_not_found;	}	catch( exception ex ) {	
unhandled exception 

}	catch( filenotfoundexception ex ) {	console.writeline( ex.message );	return consoleui.file_not_found;	}	catch( exception ex ) {	return consoleui.unexpected_error;	}	finally {	if(options.wait) {	
hit enter key to continue 

private static void writecopyright() {	assembly executingassembly = assembly.getexecutingassembly();	system.version version = executingassembly.getname().version;	string productname = "nunit";	string copyrighttext = "copyright (c) 2002-2007 charlie poole.\r\ncopyright (c) 2002-2004 james w. newkirk, michael c. two, alexei a. vorontsov.\r\ncopyright (c) 2000-2002 philip craig.\r\nall rights reserved.";	object[] objectattrs = executingassembly.getcustomattributes(typeof(assemblyproductattribute), false);	if ( objectattrs.length > 0 ) productname = ((assemblyproductattribute)objectattrs[0]).product;	objectattrs = executingassembly.getcustomattributes(typeof(assemblycopyrightattribute), false);	if ( objectattrs.length > 0 ) copyrighttext = ((assemblycopyrightattribute)objectattrs[0]).copyright;	
version 

assembly executingassembly = assembly.getexecutingassembly();	system.version version = executingassembly.getname().version;	string productname = "nunit";	string copyrighttext = "copyright (c) 2002-2007 charlie poole.\r\ncopyright (c) 2002-2004 james w. newkirk, michael c. two, alexei a. vorontsov.\r\ncopyright (c) 2000-2002 philip craig.\r\nall rights reserved.";	object[] objectattrs = executingassembly.getcustomattributes(typeof(assemblyproductattribute), false);	if ( objectattrs.length > 0 ) productname = ((assemblyproductattribute)objectattrs[0]).product;	objectattrs = executingassembly.getcustomattributes(typeof(assemblycopyrightattribute), false);	if ( objectattrs.length > 0 ) copyrighttext = ((assemblycopyrightattribute)objectattrs[0]).copyright;	console.writeline(copyrighttext);	console.writeline();	
runtime environment 

system.version version = executingassembly.getname().version;	string productname = "nunit";	string copyrighttext = "copyright (c) 2002-2007 charlie poole.\r\ncopyright (c) 2002-2004 james w. newkirk, michael c. two, alexei a. vorontsov.\r\ncopyright (c) 2000-2002 philip craig.\r\nall rights reserved.";	object[] objectattrs = executingassembly.getcustomattributes(typeof(assemblyproductattribute), false);	if ( objectattrs.length > 0 ) productname = ((assemblyproductattribute)objectattrs[0]).product;	objectattrs = executingassembly.getcustomattributes(typeof(assemblycopyrightattribute), false);	if ( objectattrs.length > 0 ) copyrighttext = ((assemblycopyrightattribute)objectattrs[0]).copyright;	console.writeline(copyrighttext);	console.writeline();	runtimeframework framework = runtimeframework.currentframework;	
os version 

system.version version = executingassembly.getname().version;	string productname = "nunit";	string copyrighttext = "copyright (c) 2002-2007 charlie poole.\r\ncopyright (c) 2002-2004 james w. newkirk, michael c. two, alexei a. vorontsov.\r\ncopyright (c) 2000-2002 philip craig.\r\nall rights reserved.";	object[] objectattrs = executingassembly.getcustomattributes(typeof(assemblyproductattribute), false);	if ( objectattrs.length > 0 ) productname = ((assemblyproductattribute)objectattrs[0]).product;	objectattrs = executingassembly.getcustomattributes(typeof(assemblycopyrightattribute), false);	if ( objectattrs.length > 0 ) copyrighttext = ((assemblycopyrightattribute)objectattrs[0]).copyright;	console.writeline(copyrighttext);	console.writeline();	runtimeframework framework = runtimeframework.currentframework;	
clr version 

========================= mono sample_32696 =========================

public static void main() {	
whoops 

========================= mono sample_33968 =========================

public static void main (string[] args) {	mycollection mycollection = new mycollection ();	foreach (mytype item in mycollection) {	
success 

========================= mono sample_1673 =========================

public virtual bool check() {	if (front < 0 || front >= array.length || back < 0 || back >= array.length || (front <= back && size != back - front) || (front > back && size != array.length + back - front)) {	
bad combination of front back size array length 

========================= mono sample_30542 =========================

public buildresult executebuild () {	buildresult result;	try {	if (affinity == nodeaffinity.outofproc) throw new notimplementedexception ();	result = build.internalexecute ();	} catch (exception ex) {	
uncaught build node exception occured 

========================= mono sample_22589 =========================

public static void main(string [] args) {	foreach (string arg in args) if (arg == "--decent-reader") usedecentreader = true;	try {	exc14n = (cryptoconfig.createfromname ("http: hmacmd5 = (cryptoconfig.createfromname ("hmacmd5") != null);	
merlin 

public static void main(string [] args) {	foreach (string arg in args) if (arg == "--decent-reader") usedecentreader = true;	try {	exc14n = (cryptoconfig.createfromname ("http: hmacmd5 = (cryptoconfig.createfromname ("hmacmd5") != null);	merlin ();	console.writeline ();	
phaos 

exc14n = (cryptoconfig.createfromname ("http: hmacmd5 = (cryptoconfig.createfromname ("hmacmd5") != null);	merlin ();	console.writeline ();	phaos ();	}	catch (exception ex) {	console.writeline (ex);	}	finally {	console.writeline ();	
total valid 

exc14n = (cryptoconfig.createfromname ("http: hmacmd5 = (cryptoconfig.createfromname ("hmacmd5") != null);	merlin ();	console.writeline ();	phaos ();	}	catch (exception ex) {	console.writeline (ex);	}	finally {	console.writeline ();	
total invalid 

exc14n = (cryptoconfig.createfromname ("http: hmacmd5 = (cryptoconfig.createfromname ("hmacmd5") != null);	merlin ();	console.writeline ();	phaos ();	}	catch (exception ex) {	console.writeline (ex);	}	finally {	console.writeline ();	
total error 

exc14n = (cryptoconfig.createfromname ("http: hmacmd5 = (cryptoconfig.createfromname ("hmacmd5") != null);	merlin ();	console.writeline ();	phaos ();	}	catch (exception ex) {	console.writeline (ex);	}	finally {	console.writeline ();	
total skip 

exc14n = (cryptoconfig.createfromname ("http: hmacmd5 = (cryptoconfig.createfromname ("hmacmd5") != null);	merlin ();	console.writeline ();	phaos ();	}	catch (exception ex) {	console.writeline (ex);	}	finally {	console.writeline ();	
finished 

xmlvalidatingreader xvr = new xmlvalidatingreader (xtr);	xtr.normalization = true;	doc.load (xvr);	try {	xmlnodelist nodelist = doc.getelementsbytagname ("signature", signedxml.xmldsignamespaceurl);	xmlelement signature = (xmlelement) nodelist [0];	signedxml s = new signedxml ();	s.loadxml (signature);	hmacsha1 mac = new hmacsha1 (key);	if (s.checksignature (mac)) {	
valid 

try {	xmlnodelist nodelist = doc.getelementsbytagname ("signature", signedxml.xmldsignamespaceurl);	xmlelement signature = (xmlelement) nodelist [0];	signedxml s = new signedxml ();	s.loadxml (signature);	hmacsha1 mac = new hmacsha1 (key);	if (s.checksignature (mac)) {	valid++;	}	else {	
invalid 

s.loadxml (signature);	hmacsha1 mac = new hmacsha1 (key);	if (s.checksignature (mac)) {	valid++;	}	else {	invalid++;	}	}	catch (exception ex) {	
exception 

xmlvalidatingreader xvr = new xmlvalidatingreader (xtr);	xtr.normalization = true;	doc.preservewhitespace = true;	doc.load (xvr);	try {	signedxml s = null;	if (filename.indexof ("enveloped") >= 0) s = new signedxml (doc);	else if (filename.indexof ("signature-big") >= 0) s = new signedxml (doc);	else s = new signedxml ();	xmlnodelist nodelist = doc.getelementsbytagname ("signature", "http: s.loadxml ((xmlelement) nodelist [0]);	
filename 

result = s.checksignature (mx.rsa);	}	else if (mx.dsa != null) {	result = s.checksignature (mx.dsa);	}	}	else {	result = s.checksignature ();	}	if (result) {	
valid 

result = s.checksignature (mx.dsa);	}	}	else {	result = s.checksignature ();	}	if (result) {	valid++;	}	else {	
invalid 

result = s.checksignature ();	}	if (result) {	valid++;	}	else {	invalid++;	}	}	catch (exception ex) {	
exception 

static void phaos () {	byte[] key = encoding.ascii.getbytes ("test");	directory.setcurrentdirectory ("phaos-xmldsig-three");	foreach (fileinfo fi in new directoryinfo (".").getfiles ("signature-*.xml")) {	if ((fi.name.indexof ("md5") >= 0) && (!hmacmd5)) {	
not run system security dll doesn t support hmac 

static void dumpsignedxml (signedxml s) {	
signedxml 

static void dumpsignature (signature s) {	
signature 

static void dumpsignature (signature s) {	
id 

static void dumpsignature (signature s) {	if (s.keyinfo != null) dumpkeyinfo (s.keyinfo);	
objectlist 

static void dumpsignature (signature s) {	if (s.keyinfo != null) dumpkeyinfo (s.keyinfo);	
signaturevalue 

static void dumpsignedinfo (signedinfo s) {	
signedinfo 

static void dumpsignedinfo (signedinfo s) {	
canonicalizationmethod 

static void dumpsignedinfo (signedinfo s) {	
id 

static void dumpsignedinfo (signedinfo s) {	
references 

static void dumpsignedinfo (signedinfo s) {	
signaturelength 

static void dumpsignedinfo (signedinfo s) {	
signaturemethod 

static void dumpkeyinfo (keyinfo ki) {	
keyinfo 

static void dumpkeyinfo (keyinfo ki) {	
id 

static void dumpkeyinfo (keyinfo ki) {	
count 

static void dumpkeyinfoclause (keyinfoclause kic) {	keyinfoname kn = kic as keyinfoname;	if (kn != null) {	
keyinfoname 

static void dumpkeyinfoclause (keyinfoclause kic) {	keyinfoname kn = kic as keyinfoname;	if (kn != null) {	
value 

static void dumpkeyinfoclause (keyinfoclause kic) {	keyinfoname kn = kic as keyinfoname;	if (kn != null) {	return;	}	keyinfox509data k509 = kic as keyinfox509data;	if (k509 != null) {	console.writeline ("*** keyinfox509data ***");	
certificates 

static void dumpkeyinfoclause (keyinfoclause kic) {	keyinfoname kn = kic as keyinfoname;	if (kn != null) {	return;	}	keyinfox509data k509 = kic as keyinfox509data;	if (k509 != null) {	console.writeline ("*** keyinfox509data ***");	
crl 

static void dumpkeyinfoclause (keyinfoclause kic) {	keyinfoname kn = kic as keyinfoname;	if (kn != null) {	return;	}	keyinfox509data k509 = kic as keyinfox509data;	if (k509 != null) {	console.writeline ("*** keyinfox509data ***");	
issuerserials 

static void dumpkeyinfoclause (keyinfoclause kic) {	keyinfoname kn = kic as keyinfoname;	if (kn != null) {	return;	}	keyinfox509data k509 = kic as keyinfox509data;	if (k509 != null) {	console.writeline ("*** keyinfox509data ***");	
subjectkeyids 

static void dumpkeyinfoclause (keyinfoclause kic) {	keyinfoname kn = kic as keyinfoname;	if (kn != null) {	return;	}	keyinfox509data k509 = kic as keyinfox509data;	if (k509 != null) {	console.writeline ("*** keyinfox509data ***");	
subjectnames 

========================= mono sample_30614 =========================

protected override void oninit (eventargs e) {	
parent oninit 

========================= mono sample_18514 =========================

}	if (enablehistory && !designmode && (ipage != null)) {	writer.addattribute(htmltextwriterattribute.type, "hidden");	writer.addattribute(htmltextwriterattribute.name, this.uniqueid);	writer.addattribute(htmltextwriterattribute.id, this.clientid);	writer.renderbegintag(htmltextwritertag.input);	writer.renderendtag();	javascriptserializer serializer = new javascriptserializer(new simpletyperesolver());	writer.write(clientscriptmanager.clientscriptstart);	if (isdebuggingenabled && (ajaxframeworkmode == ajaxframeworkmode.explicit)) {	
type checkdependency microsoftajaxhistory js scriptmanager enablehistory 

writer.write("sys.application.setserverid(");	writer.write(serializer.serialize(clientid));	writer.write(", ");	writer.write(serializer.serialize(uniqueid));	writer.writeline(");");	if ((_initialstate != null) && (_initialstate.count != 0)) {	writer.write("sys.application.setserverstate('");	writer.write(httputility.javascriptstringencode(getstatestring()));	writer.writeline("');");	}	
sys application enablehistoryinscriptmanager 

========================= mono sample_14991 =========================

public int test_function (int a, bool b) {	
test function called 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	
objref 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "corba: string uri;	corbachannel chnl = new corbachannel (8000);	channelservices.registerchannel (chnl);	
channel name 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "corba: string uri;	corbachannel chnl = new corbachannel (8000);	channelservices.registerchannel (chnl);	
channel priority 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "corba: string uri;	corbachannel chnl = new corbachannel (8000);	channelservices.registerchannel (chnl);	
uri 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "corba: string uri;	corbachannel chnl = new corbachannel (8000);	channelservices.registerchannel (chnl);	
uri 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "corba: string uri;	corbachannel chnl = new corbachannel (8000);	channelservices.registerchannel (chnl);	test tp = (test)remotingservices.connect (typeof (test), url);	int res = tp.test_function (4, true);	
result 

========================= mono sample_17869 =========================

public static void main(string[] args) {	
adding and removing without locking 

public static void main(string[] args) {	runtwothreads(delegate { addandremove(15000); });	
coll has items should be 

public static void main(string[] args) {	runtwothreads(delegate { addandremove(15000); });	coll = new arraylist<int>();	
adding and removing with locking 

public static void main(string[] args) {	runtwothreads(delegate { addandremove(15000); });	coll = new arraylist<int>();	runtwothreads(delegate { safeaddandremove(15000); });	
coll has items should be 

public static void main(string[] args) {	runtwothreads(delegate { addandremove(15000); });	coll = new arraylist<int>();	runtwothreads(delegate { safeaddandremove(15000); });	
moving items without locking 

public static void main(string[] args) {	runtwothreads(delegate { addandremove(15000); });	coll = new arraylist<int>();	runtwothreads(delegate { safeaddandremove(15000); });	arraylist<int> from, to;	from = new arraylist<int>();	to = new arraylist<int>();	for (int i=0; i<count; i++) from.add(i);	runtwothreads(delegate { while (!from.isempty) move(from, to); });	
coll has items should be 

public static void main(string[] args) {	runtwothreads(delegate { addandremove(15000); });	coll = new arraylist<int>();	runtwothreads(delegate { safeaddandremove(15000); });	arraylist<int> from, to;	from = new arraylist<int>();	to = new arraylist<int>();	for (int i=0; i<count; i++) from.add(i);	runtwothreads(delegate { while (!from.isempty) move(from, to); });	
moving items with locking 

runtwothreads(delegate { safeaddandremove(15000); });	arraylist<int> from, to;	from = new arraylist<int>();	to = new arraylist<int>();	for (int i=0; i<count; i++) from.add(i);	runtwothreads(delegate { while (!from.isempty) move(from, to); });	from = new arraylist<int>();	to = new arraylist<int>();	for (int i=0; i<count; i++) from.add(i);	runtwothreads(delegate { while (!from.isempty) safemove(from, to); });	
coll has items should be 

========================= mono sample_30576 =========================

static int main () {	string step = "abcde12345abcde12345abcde12345abcde12345";	string expected = directory.getcurrentdirectory();	string current = "";	directory.delete (step, true);*/ try {	for (int i = 0; i < 4000; ++i) {	current = directory.getcurrentdirectory ();	if (!current.equals (expected)) {	
expected dir but got 

current = directory.getcurrentdirectory ();	if (!current.equals (expected)) {	return 1;	}	console.writeline("i={0} dir={1}",i,directory.getcurrentdirectory().length);	directory.createdirectory (step);	directory.setcurrentdirectory (step);	expected += path.directoryseparatorchar + step;	}	} catch (pathtoolongexception) {	
ok got pathtoolongexception 

return 1;	}	console.writeline("i={0} dir={1}",i,directory.getcurrentdirectory().length);	directory.createdirectory (step);	directory.setcurrentdirectory (step);	expected += path.directoryseparatorchar + step;	}	} catch (pathtoolongexception) {	return 0;	}	
max path not reached 

========================= mono sample_374 =========================

"usage: bundling [options]+", "demo program to show the effects of bundling options and their values", "", "gcc-like options:", { "d:", "predefine a macro with an (optional) value.", (m, v) => {	if (m == null) throw new optionexception ("missing macro name for option -d.", "-d");	macros.add (m, v);	} }, { "d={-->}{=>}", "alternate macro syntax.", (m, v) => macros.add (m, v) }, { "o=", "specify the output file", v => output = v }, "", "tar-like options:", { "f=", "the input file",   v => input = v }, { "x",  "extract the file", v => extract = v != null }, { "c",  "create the file",  v => create = v != null }, { "t",  "list the file",    v => list = v != null }, "", "ls-like optional values:", { "color:", "control whether and when color is used", v => color = v }, "", "other:", { "h|help",  "show this message and exit", v => show_help = v != null }, { "<>", v => console.writeline ("def handler: color={0}; arg={1}", color, v)}, };	try {	p.parse (args);	}	catch (optionexception e) {	console.write ("bundling: ");	console.writeline (e.message);	
try greet help for more information 

}	catch (optionexception e) {	console.write ("bundling: ");	console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	
macros 

console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	foreach (var m in (from k in macros.keys orderby k select k)) {	console.writeline ("\t{0}={1}", m, macros [m] ?? "<null>");	}	
options 

console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	foreach (var m in (from k in macros.keys orderby k select k)) {	console.writeline ("\t{0}={1}", m, macros [m] ?? "<null>");	}	
input file 

console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	foreach (var m in (from k in macros.keys orderby k select k)) {	console.writeline ("\t{0}={1}", m, macros [m] ?? "<null>");	}	
ouptut file 

console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	foreach (var m in (from k in macros.keys orderby k select k)) {	console.writeline ("\t{0}={1}", m, macros [m] ?? "<null>");	}	
create 

console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	foreach (var m in (from k in macros.keys orderby k select k)) {	console.writeline ("\t{0}={1}", m, macros [m] ?? "<null>");	}	
extract 

console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	foreach (var m in (from k in macros.keys orderby k select k)) {	console.writeline ("\t{0}={1}", m, macros [m] ?? "<null>");	}	
list 

console.writeline (e.message);	return;	}	if (show_help) {	p.writeoptiondescriptions (console.out);	return;	}	foreach (var m in (from k in macros.keys orderby k select k)) {	console.writeline ("\t{0}={1}", m, macros [m] ?? "<null>");	}	
color null 

========================= mono sample_32533 =========================

public static int main () {	if (attribute.getcustomattributes (typeof (test)).length != 1) return 1;	if (attribute.getcustomattributes (typeof (test_2)).length != 1) return 1;	
ok 

========================= mono sample_3841 =========================

public static void main() {	thread thr=new thread(new threadstart(foo.thread));	thr.isbackground=true;	thr.start();	thread.sleep(600);	
aborting child thread 

public static void main() {	thread thr=new thread(new threadstart(foo.thread));	thr.isbackground=true;	thr.start();	thread.sleep(600);	thr.abort();	thread.sleep(600);	
main thread returns 

public static void thread() {	try {	
thread running 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

========================= mono sample_234 =========================

if ((int) info[0].defaultvalue != 1) return 2;	if (!info[0].isoptional) return 3;	info = typeof (c).getmethod ("testb").getparameters ();	if (info[0].defaultvalue.gettype () != typeof (long)) return 11;	if ((long) info[0].defaultvalue != 12) return 12;	if (!info[0].isoptional) return 13;	info = typeof (c).getmethod ("testc").getparameters ();	if (info[0].defaultvalue.gettype () != typeof (decimal)) return 21;	if ((decimal) info[0].defaultvalue != decimal.maxvalue) return 22;	if (!info[0].isoptional) return 23;	
ok 

========================= mono sample_1647 =========================

public static int main () {	int i = foo (null);	if (i == 1) {	
wrong method 

========================= mono sample_3653 =========================

if (t.exception != null) return 12;	bool faulted = false;	bool has_exception = false;	t = testexception().continuewith(l => {	faulted = l.isfaulted;	has_exception = l.exception != null;	}, taskcontinuationoptions.executesynchronously);	if (!faulted) return 21;	if (!has_exception) return 22;	if (t.exception != null) return 23;	
ok 

========================= mono sample_4033 =========================

subcommandstylenoitalic.font.italic = booleanoption.false;	writer.clearpendingbreak();	conditionalenterlayout(writer, style);	writer.writebegintag ("table");	conditionalrenderclassattribute(writer);	writer.write(">");	writer.write("<tr><td colspan=\"2\">");	conditionalenterstyle(writer, labelstyle);	writer.writeencodedtext (item[control.labelfieldindex]);	conditionalexitstyle(writer, labelstyle);	
td tr 

foreach (objectlistfield field in fields) {	if (field.visible) {	writer.write("<tr><td>");	conditionalenterstyle(writer, style);	writer.writeencodedtext (field.title);	conditionalexitstyle(writer, style);	writer.write("</td><td>");	conditionalenterstyle(writer, style);	writer.writeencodedtext (item [fields.indexof (field)]);	conditionalexitstyle(writer, style);	
td tr 

private void renderlistviewitem (xhtmlmobiletextwriter writer, objectlistitem item, int fieldcount, int[] fieldindices, bool itemrequiresmorebutton, bool itemrequireshyperlink) {	style style = style;	style subcommandstyle = control.commandstyle;	string accesskey = getcustomattributevalue(item, xhtmlconstants.accesskeycustomattribute);	string cssclass = getcustomattributevalue(item, xhtmlconstants.cssclasscustomattribute);	string subcommandclass = getcustomattributevalue(xhtmlconstants.csscommandclasscustomattribute);	if (subcommandclass == null || subcommandclass.length == 0) {	subcommandclass = cssclass;	}	
tr 

}	for (int field = 0; field < fieldcount; field++) {	writer.write("<td>");	if (field == 0 && itemrequireshyperlink) {	string eventargument = hasdefaultcommand() ? item.index.tostring(cultureinfo.invariantculture) : string.format(cultureinfo.invariantculture, showmoreformat, item.index.tostring(cultureinfo.invariantculture));	renderpostbackeventasanchor(writer, eventargument, item[fieldindices[0]], accesskey, style, cssclass);	}	else {	writer.writeencodedtext (item[fieldindices[field]]);	}	
td 

}	else {	writer.writeencodedtext (item[fieldindices[field]]);	}	}	if (itemrequiresmorebutton) {	writer.write("<td>");	string controlmt = control.moretext;	string moretext = (controlmt == null || controlmt.length == 0) ? getdefaultlabel(morelabel) : controlmt;	renderpostbackeventasanchor(writer, string.format(cultureinfo.invariantculture, showmoreformat, item.index), moretext, null /*accesskey*/, subcommandstyle, subcommandclass);	
td 

else {	writer.writeencodedtext (item[fieldindices[field]]);	}	}	if (itemrequiresmorebutton) {	writer.write("<td>");	string controlmt = control.moretext;	string moretext = (controlmt == null || controlmt.length == 0) ? getdefaultlabel(morelabel) : controlmt;	renderpostbackeventasanchor(writer, string.format(cultureinfo.invariantculture, showmoreformat, item.index), moretext, null /*accesskey*/, subcommandstyle, subcommandclass);	}	
tr 

private void renderlistviewtableheader (xhtmlmobiletextwriter writer, int fieldcount, int[] fieldindices, bool itemrequiresmorebutton){	string cssclass = getcustomattributevalue(xhtmlconstants.cssclasscustomattribute);	string labelclass = getcustomattributevalue(xhtmlconstants.csslabelclasscustomattribute);	if (labelclass == null || labelclass.length == 0) {	labelclass = cssclass;	}	
tr 

writer.writeattribute("class", labelclass, true);	}	writer.write(">");	style labelstyle = control.labelstyle;	conditionalenterstyle(writer, labelstyle);	writer.writeencodedtext(control.allfields[fieldindices[field]].title);	conditionalexitstyle(writer, labelstyle);	writer.write("</td>");	}	if (itemrequiresmorebutton) {	
td 

writer.write(">");	style labelstyle = control.labelstyle;	conditionalenterstyle(writer, labelstyle);	writer.writeencodedtext(control.allfields[fieldindices[field]].title);	conditionalexitstyle(writer, labelstyle);	writer.write("</td>");	}	if (itemrequiresmorebutton) {	}	writer.writeline();	
tr 

========================= mono sample_6076 =========================

var v2 = e2.compile ();	v2.invoke ()();	if (i != 18) return 4;	unsafe {	expression<func<unsafedelegate>> e3 = () => new unsafedelegate (foo);	if (e3.body.tostring () != "convert(int32* foo().createdelegate(unsafedelegate, null), unsafedelegate)") return 5;	var v3 = e3.compile ();	if (v3.invoke ()() != (int*)1) return 6;	}	if (new c ().testinstance () != 0) return 7;	
ok 

========================= mono sample_3482 =========================

protected virtual void overrideme () {	
overrideme 

protected override void overrideme () {	
overridden 

========================= mono sample_1905 =========================

static void usage (int exitcode, optionset options) {	
usage standalone runner options tests assembly 

static void usage (int exitcode, optionset options) {	if (options != null) {	console.writeline ();	
available options 

public static void die (string format, params object[] args) {	
standalone test failure in assembly 

public static void die (string format, params object[] args) {	console.writeline ();	if (args == null || args.length == 0) console.writeline ("error: " + format);	
error 

testsassembly = extra [0];	if (!file.exists (testsassembly)) die ("tests assembly '{0}' does not exist.", testsassembly);	assembly asm = assembly.loadfrom (testsassembly);	var tests = new list <standalonetest> ();	loadtestsfromassembly (asm, tests);	if (tests.count == 0) die ("no tests present in the '{0}' assembly. tests must be public types decorated with the testcase attribute and implementing the itestcase interface.", testsassembly);	applicationmanager appman = applicationmanager.getapplicationmanager ();	int runcounter = 0;	int failedcounter = 0;	var reports = new list <string> ();	
running tests 

========================= mono sample_18415 =========================

public fraction(int numerator, int denominator) {	
in fraction constructor int int 

public fraction(int wholenumber) {	
in fraction constructor int 

public static implicit operator fraction(int theint) {	
in implicit conversion to fraction 

public static explicit operator int(fraction thefraction) {	
in explicit conversion to int 

public override bool equals(object o) {	
in method equals 

public static fraction operator+(fraction lhs, fraction rhs) {	
in operator 

========================= mono sample_1746 =========================

} catch (applicationexception) {	console.writeline ("x1a");	counter = 1;	await task.delay (1);	console.writeline ("x2a");	counter = 3;	throw;	} catch {	counter = 9;	await task.delay (1);	
ga 

if (e.innerexception != ex) return 1;	}	if (counter != 3) return 2;	var ex2 = new notsupportedexception ();	try {	testrethrow (ex2).wait ();	} catch (aggregateexception e) {	if (e.innerexception != ex2) return 3;	}	if (counter != 9) return 4;	
ok 

========================= mono sample_1954 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	task t = test.invoke (new tester (), null) as task;	if (!task.waitall (new[] { t }, 1000)) {	
failed timeout 

if (!task.waitall (new[] { t }, 1000)) {	return false;	}	var tb = t as task<bool>;	if (tb != null) {	if (!tb.result) {	console.writeline ("failed (result={0})", tb.result);	return false;	}	}	
ok 

}	var tb = t as task<bool>;	if (tb != null) {	if (!tb.result) {	console.writeline ("failed (result={0})", tb.result);	return false;	}	}	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_1657 =========================

int res;	res = testnullable ();	if (res != 0) return 100 + res;	res = testarray ();	if (res != 0) return 200 + res;	res = testreferencetype ();	if (res != 0) return 300 + res;	ci ci = null;	res = testgeneric<ci> (ci);	if (res != 0) return 400 + res;	
ok 

========================= mono sample_3612 =========================

if (!(t && f == false)) error++;	else ok |= 16;	int i = 0;	w(3);	do {	i++;	} while (!(i > 5));	if (i != 6) error ++;	else ok |= 32;	w(100);	
value 

========================= mono sample_1717 =========================

public void close () {	
close 

public datatable getschematable () {	
getschematable 

public bool nextresult () {	
nextresult 

public bool read () {	
read 

public void dispose () {	
dispose 

========================= mono sample_18504 =========================

public static void main(string[] args) {	ilist<int> col1 = new linkedlist<int>(), col2 = new linkedlist<int>(), col3 = new linkedlist<int>();	col1.addall<int>(new int[] { 7, 9, 13 });	col2.addall<int>(new int[] { 7, 9, 13 });	col3.addall<int>(new int[] { 9, 7, 13 });	hashset<ilist<int>> hs1 = new hashset<ilist<int>>();	hs1.add(col1); hs1.add(col2); hs1.add(col3);	
is sane 

========================= mono sample_30566 =========================

static int main () {	
friendly name 

c1 a1 = new c1 ();	a1.e1.a = 3;	a1.e1.s1 = "ss";	newdomain.setdata ("test", a1);	c1 r1 = (c1)newdomain.getdata ("test");	if (r1.a != 1 || r1.b !=2) return 1;	if (r1.s1 != "test1") return 2;	if (r1.s2 != null) return 3;	if (r1.e1.a != 3) return 4;	if (r1.e1.s1 != "ss") return 5;	
test ok 

========================= mono sample_364 =========================

static int main () {	int res;	res = testarrayaccess ();	if (res != 0) return 10 + res;	res = testindexeraccess ();	if (res != 0) return 20 + res;	
ok 

========================= mono sample_3430 =========================

static void producesimpleheapwithlos () {	
running in 

static void crossdomaintest (string name, crossappdomaindelegate dele) {	testtimeout timeout = testtimeout.start (timespan.fromseconds(testtimeout.isstresstest ? 60 : 5));	
testing 

========================= mono sample_146 =========================

protected virtual void writeclassequalsandhash(codewriter writer, table table, generationcontext context) {	list<dblinq.schema.dbml.column> primarykeys = table.type.columns.where(c => c.isprimarykey).tolist();	if (primarykeys.count == 0) {	
warning table has no primary key multiple c objects will refer to the same row 

protected virtual void writeclassextensibilitydeclarations(codewriter writer, table table, generationcontext context) {	using (writer.writeregion("extensibility method definitions")) {	
partial void oncreated 

protected virtual void writeclassextensibilitydeclarations(codewriter writer, table table, generationcontext context) {	using (writer.writeregion("extensibility method definitions")) {	foreach (var c in table.type.columns) {	
partial void on changed 

protected virtual void writeclassextensibilitydeclarations(codewriter writer, table table, generationcontext context) {	using (writer.writeregion("extensibility method definitions")) {	foreach (var c in table.type.columns) {	
partial void on changing value 

writer.writeline(writer.getreturnstatement(storage));	}	using (writer.writepropertyset()) {	var entitymember = writer.getmemberexpression(parent.storage, "entity");	using (writer.writeif(writer.getdifferentexpression(writer.getpropertysetvalueexpression(), entitymember))) {	var otherassociation = schema.getreverseassociation(parent);	using (writer.writeif(writer.getdifferentexpression(entitymember, writer.getnullexpression()))) {	var previousentityrefname = "previous" + parent.type;	writer.writeline(writer.getstatement( writer.getvariabledeclarationinitialization(parent.type, previousentityrefname, entitymember) ));	writer.writeline(writer.getstatement( writer.getassignmentexpression(entitymember, writer.getnullexpression()) ));	
remove 

var entitymember = writer.getmemberexpression(parent.storage, "entity");	using (writer.writeif(writer.getdifferentexpression(writer.getpropertysetvalueexpression(), entitymember))) {	var otherassociation = schema.getreverseassociation(parent);	using (writer.writeif(writer.getdifferentexpression(entitymember, writer.getnullexpression()))) {	var previousentityrefname = "previous" + parent.type;	writer.writeline(writer.getstatement( writer.getvariabledeclarationinitialization(parent.type, previousentityrefname, entitymember) ));	writer.writeline(writer.getstatement( writer.getassignmentexpression(entitymember, writer.getnullexpression()) ));	}	writer.writeline(writer.getstatement( writer.getassignmentexpression(entitymember, writer.getpropertysetvalueexpression()) ));	writer.writerawif(writer.getdifferentexpression(writer.getpropertysetvalueexpression(), writer.getnullexpression()));	
add 

protected virtual void writeclassctor(codewriter writer, table table, database schema, generationcontext context) {	using (writer.writeregion("ctor")) using (writer.writector(specificationdefinition.public, table.type.name, new parameterdefinition[0], null)) {	foreach (var child in getclasschildren(table)) {	var entitysetmember = child.storage ?? child.member;	writer.writeline(writer.getstatement( writer.getassignmentexpression( entitysetmember, writer.getnewexpression(writer.getmethodcallexpression( writer.getgenericname(typeextensions.getshortname(typeof(entityset<>)), child.type), getchildattachmethodname(child), getchilddetachmethodname(child) )) ) ));	}	foreach (var parent in getclassparents(table)) {	var entityrefmember = parent.storage;	writer.writeline(writer.getstatement( writer.getassignmentexpression( entityrefmember, writer.getnewexpression(writer.getmethodcallexpression( writer.getgenericname(typeextensions.getshortname(typeof(entityref<>)), parent.type) )) ) ));	}	
oncreated 

========================= mono sample_25068 =========================

public static int main () {	if (ctx == null) return 1;	bool b = ctx != null;	if (!b) return 2;	if (s2 != null) return 3;	s3 = new s3 ();	decimal d = s3.value == null;	if (d != 1) return 4;	
ok 

========================= mono sample_3521 =========================

public static void main(string[] args) {	ilist<char> lst = new arraylist<char>();	lst.addall<char>(new char[] { 'a', 'b', 'c', 'd' });	ilist<char> v1 = lst.view(1, 1);	console.writeline("v1 = {0}", v1);	insertbeforefirst(v1, '<', 'b');	insertafterfirst(v1, '>', 'b');	console.writeline("v1 = {0}", v1);	char x;	
predecessor of b is 

public static void main(string[] args) {	ilist<char> lst = new arraylist<char>();	lst.addall<char>(new char[] { 'a', 'b', 'c', 'd' });	ilist<char> v1 = lst.view(1, 1);	console.writeline("v1 = {0}", v1);	insertbeforefirst(v1, '<', 'b');	insertafterfirst(v1, '>', 'b');	console.writeline("v1 = {0}", v1);	char x;	
successor of b is 

public static void main(string[] args) {	ilist<char> lst = new arraylist<char>();	lst.addall<char>(new char[] { 'a', 'b', 'c', 'd' });	ilist<char> v1 = lst.view(1, 1);	console.writeline("v1 = {0}", v1);	insertbeforefirst(v1, '<', 'b');	insertafterfirst(v1, '>', 'b');	console.writeline("v1 = {0}", v1);	char x;	
c has no predecessor 

public static void main(string[] args) {	ilist<char> lst = new arraylist<char>();	lst.addall<char>(new char[] { 'a', 'b', 'c', 'd' });	ilist<char> v1 = lst.view(1, 1);	console.writeline("v1 = {0}", v1);	insertbeforefirst(v1, '<', 'b');	insertafterfirst(v1, '>', 'b');	console.writeline("v1 = {0}", v1);	char x;	
a has no successor 

========================= mono sample_30552 =========================

}	for (i=2; i <= 8192; i++) {	if (flags[i] != 0) {	for (k=i+i; k <= 8192; k+=i) {	flags[k] = 0;	}	count++;	}	}	}	
count 

========================= mono sample_181 =========================

public static int test_0_valuetype_invokes () {	emptystruct es = default (emptystruct);	es.value = 100;	var ar1 = (actionref)delegate.createdelegate(typeof (actionref), typeof (emptystruct).getmethod("test"));	if (ar1 (ref es) != 110) {	
expected got 

public static int test_0_valuetype_invokes () {	emptystruct es = default (emptystruct);	es.value = 100;	var ar1 = (actionref)delegate.createdelegate(typeof (actionref), typeof (emptystruct).getmethod("test"));	if (ar1 (ref es) != 110) {	return 1;	}	var ar2 = (actionref2)delegate.createdelegate (typeof (actionref2), null, typeof (emptystruct).getmethod("test"));	try {	
must not return got 

if (ar1 (ref es) != 110) {	return 1;	}	var ar2 = (actionref2)delegate.createdelegate (typeof (actionref2), null, typeof (emptystruct).getmethod("test"));	try {	return 2;	} catch (nullreferenceexception) {	}	ar1 = (actionref) delegate.createdelegate(typeof (actionref), typeof (emptystruct).getmethod("test2"));	if (ar1 (ref es) != 120) {	
expected got 

try {	return 2;	} catch (nullreferenceexception) {	}	ar1 = (actionref) delegate.createdelegate(typeof (actionref), typeof (emptystruct).getmethod("test2"));	if (ar1 (ref es) != 120) {	return 3;	}	ar2 = (actionref2) delegate.createdelegate(typeof (actionref2), es, typeof (emptystruct).getmethod("test"));	if (ar2 () != 110) {	
expected got 

ar1 = (actionref) delegate.createdelegate(typeof (actionref), typeof (emptystruct).getmethod("test2"));	if (ar1 (ref es) != 120) {	return 3;	}	ar2 = (actionref2) delegate.createdelegate(typeof (actionref2), es, typeof (emptystruct).getmethod("test"));	if (ar2 () != 110) {	return 4;	}	try {	delegate.createdelegate(typeof (actionref2), new emptystruct (), typeof (emptystruct).getmethod("test2"));	
must fail 

ar2 = (actionref2) delegate.createdelegate(typeof (actionref2), es, typeof (emptystruct).getmethod("test"));	if (ar2 () != 110) {	return 4;	}	try {	delegate.createdelegate(typeof (actionref2), new emptystruct (), typeof (emptystruct).getmethod("test2"));	return 5;	} catch (argumentexception) {}	try {	delegate.createdelegate(typeof (actionref3), typeof (emptystruct).getmethod("test"));	
must fail 

========================= mono sample_210 =========================

static int xmoveresizewindow(intptr display, intptr window, int x, int y, int width, int height) {	
xmoveresizewindow 

========================= mono sample_26106 =========================

public void test () {	myobj = new myclass ();	var something = "key";	switch (something) {	case "key": myobj.firstevent += (sender, e) => {	
firstevent 

public void test () {	myobj = new myclass ();	var something = "key";	switch (something) {	case "key": myobj.firstevent += (sender, e) => {	};	break;	case "somethingelse": bool? woot = null;	myobj.secondevent += (sender, e) => {	
woot 

========================= mono sample_2989 =========================

t.start ();	t.join ();	do {	if (checkstuff ()) break;	gc.collect ();	gc.waitforpendingfinalizers ();	thread.sleep (10);	} while (cnt-- > 0);	gc.collect ();	gc.waitforpendingfinalizers ();	
done with finalizers 

========================= mono sample_301 =========================

public static int main () {	int x = ~b;	byte bb = 0xf;	if (~bb != x){	
x 

========================= mono sample_4017 =========================

public static extern int puts (string name);	delegate void simpledelegate ();	delegate string notsimpledelegate (int a);	delegate int anotherdelegate (string s);	delegate string stringdelegate ();	public int data;	static void f () {	
test f from delegate 

public virtual void vf () {	
test vf from delegate 

========================= mono sample_241 =========================

static void main (string[] args) {	if (args.length < 2) {	
usage cache pq test generator exe sequence directory data output directory 

static void main (string[] args) {	if (args.length < 2) {	console.writeline ();	environment.exit (1);	}	if (!directory.exists (args [0])) {	
sequence directory cannot be found 

========================= mono sample_18421 =========================

public static int operator + (blah i, blah j) {	
base class binary operator 

public static implicit operator int (blah i) {	
blah int 

public static implicit operator byte (blah i) {	
blah byte 

public static implicit operator short (blah i) {	
blah short 

public static int main () {	int number = new foo () + new foo () ;	console.writeline (number);	foo tmp = new foo ();	int k = tmp;	
convert from foo to float 

public static int main () {	int number = new foo () + new foo () ;	console.writeline (number);	foo tmp = new foo ();	int k = tmp;	float f = tmp;	
converted 

public static int main () {	int number = new foo () + new foo () ;	console.writeline (number);	foo tmp = new foo ();	int k = tmp;	float f = tmp;	if (f == 3) console.writeline ("best implicit conversion selected correctly.");	
f is 

========================= mono sample_3684 =========================

public static int main () {	int result = 0;	b b = new b ();	a a = b;	if (a.f () != 1) result |= 1 << 0;	if (b.f () != 3) result |= 1 << 1;	if (b.g () != 4) result |= 1 << 2;	if (a.g () != 4){	
oops 

========================= mono sample_1410 =========================

public static void main () {	double d = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000222;	
r 

========================= mono sample_2628 =========================

public static int main () {	type t = typeof (mainclass);	fieldinfo[] fia = t.getfields();	foreach (fieldinfo fi in fia) {	object[] ca = fi.getcustomattributes(typeof (somecustomattribute), false);	
field 

public static int main () {	type t = typeof (mainclass);	fieldinfo[] fia = t.getfields();	foreach (fieldinfo fi in fia) {	object[] ca = fi.getcustomattributes(typeof (somecustomattribute), false);	if (ca.length != 1) return 1;	}	
ok 

========================= mono sample_2768 =========================

private void debug (timespan ts) {	
days 

private void debug (timespan ts) {	
hours 

private void debug (timespan ts) {	
minutes 

private void debug (timespan ts) {	
seconds 

private void debug (timespan ts) {	
milliseconds 

private void debug (timespan ts) {	
ticks 

========================= mono sample_27299 =========================

public domain join (pair<apc, apc> edge, domain newstate, domain prevstate, out bool weaker, bool widen) {	if (debugoptions.debug) {	
opt join at 

public domain join (pair<apc, apc> edge, domain newstate, domain prevstate, out bool weaker, bool widen) {	if (debugoptions.debug) {	
existing state 

public domain join (pair<apc, apc> edge, domain newstate, domain prevstate, out bool weaker, bool widen) {	if (debugoptions.debug) {	prevstate.dump (console.out);	
new state 

public domain edgeconversion (apc @from, apc to, bool isjoinpoint, dummy data, domain state) {	if (isjoinpoint) {	this.renamepoints [from, to] = dummy.value;	if (!this.mergeinfocache.containskey (to)) this.mergeinfocache.add (to, null);	}	if (debugoptions.debug) {	
edge conversion on 

========================= mono sample_29527 =========================

propertylambda = expression.lambda(expression.invoke(propertylambda, nestedparams), invokeparameters);	}	else {	expression e = this.visit(assignment.expression);	e = expression.convert(e, typeof(object));	parameterexpression[] parameters = new parameterexpression[]	{	this.materializerexpression, entryparameterformembers, expectedparameterformembers, };	propertylambda = expression.lambda(e, parameters);	}	
compiling lambda for 

========================= mono sample_26759 =========================

public static void main () {	object o = new object ();	
hello there yak 

========================= mono sample_3139 =========================

a.legs= new legdto[] { new legdto() };	a.notes= new notedto[] { new notedto() };	a.payperiodevents= new payperiodeventdto[] { new payperiodeventdto() };	a.payrollcategories= new payrollcategorydto[] { new payrollcategorydto() };	a.payrolls= new payrolldto[] { new payrolldto() };	a.performances= new performancedto[] { new performancedto() };	a.positions= new positiondto[] { new positiondto() };	a.reglatoryoperationtypes= new reglatoryoperationtypedto[] { new reglatoryoperationtypedto() };	a.trips= new tripdto[] { new tripdto() };	a.usersettings= new usersettingdto[] { new usersettingdto() };	
size is 

a.legs= new legdto[] { new legdto() };	a.notes= new notedto[] { new notedto() };	a.payperiodevents= new payperiodeventdto[] { new payperiodeventdto() };	a.payrollcategories= new payrollcategorydto[] { new payrollcategorydto() };	a.payrolls= new payrolldto[] { new payrolldto() };	a.performances= new performancedto[] { new performancedto() };	a.positions= new positiondto[] { new positiondto() };	a.reglatoryoperationtypes= new reglatoryoperationtypedto[] { new reglatoryoperationtypedto() };	a.trips= new tripdto[] { new tripdto() };	a.usersettings= new usersettingdto[] { new usersettingdto() };	
size is 

========================= mono sample_21079 =========================

++id;	}	var e3 = from i1 in a1 from i2 in a2 select new { i1, i2 };	id = 0;	foreach (var item in e3) {	console.writeline (item);	if (item.i1 != id / 2) return 1;	if (id % 2 == 0) if (item.i2 != "10") return 2;	++id;	}	
ok 

========================= mono sample_3079 =========================

static public datacolumn getdatacolumn(datacolumnmappingcollection columnmappings, string sourcecolumn, type datatype, datatable datatable, missingmappingaction mappingaction, missingschemaaction schemaaction) {	if (null != columnmappings) {	int index = columnmappings.indexof(sourcecolumn);	if (-1 != index) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
mapping match on sourcecolumn sourcecolumn 

#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return columnmappings.items[index].getdatacolumnbyschemaaction(datatable, datatype, schemaaction);	}	}	if (adp.isempty(sourcecolumn)) {	throw adp.invalidsourcecolumn("sourcecolumn");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	
mapping passthrough of sourcecolumn sourcecolumn 

}	}	if (adp.isempty(sourcecolumn)) {	throw adp.invalidsourcecolumn("sourcecolumn");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return datacolumnmapping.getdatacolumnbyschemaaction(sourcecolumn, sourcecolumn, datatable, datatype, schemaaction);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
mapping filter of sourcecolumn sourcecolumn 

throw adp.invalidsourcecolumn("sourcecolumn");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return datacolumnmapping.getdatacolumnbyschemaaction(sourcecolumn, sourcecolumn, datatable, datatype, schemaaction);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingmappingaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
mapping error on sourcecolumn sourcecolumn 

static public datacolumnmapping getcolumnmappingbyschemaaction(datacolumnmappingcollection columnmappings, string sourcecolumn, missingmappingaction mappingaction) {	if (null != columnmappings) {	int index = columnmappings.indexof(sourcecolumn);	if (-1 != index) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
mapping match on sourcecolumn sourcecolumn 

#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return columnmappings.items[index];	}	}	if (adp.isempty(sourcecolumn)) {	throw adp.invalidsourcecolumn("sourcecolumn");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	
mapping passthrough of sourcecolumn sourcecolumn 

}	}	if (adp.isempty(sourcecolumn)) {	throw adp.invalidsourcecolumn("sourcecolumn");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datacolumnmapping(sourcecolumn, sourcecolumn);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
mapping filter of sourcecolumn sourcecolumn 

throw adp.invalidsourcecolumn("sourcecolumn");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datacolumnmapping(sourcecolumn, sourcecolumn);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingmappingaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
mapping error on sourcecolumn sourcecolumn 

========================= mono sample_14329 =========================

public static void main () {	
foo 

========================= mono sample_2043 =========================

static void main(string[] args) {	try {	system.configuration.configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	configurationsection connstrings = config.connectionstrings;	console.writeline ("connstrings[localsqlserver] = {0}", ((connectionstringssection)connstrings).connectionstrings["localsqlserver"]);	}	catch (exception e) {	
raised 

========================= mono sample_29832 =========================

public static int test_0_base () {	assembly ass = typeof (tests).assembly;	type a_type = ass.gettype ("a");	methodinfo a_method = a_type.getmethod ("tostring");	type d_type = ass.gettype ("d");	methodinfo d_method = d_type.getmethod ("test");	
test 

========================= mono sample_488 =========================

static void main () {	
hello 

========================= mono sample_34512 =========================

jointhread.start ();	const int makethreads = 10*1000;	for (int i = 0; i < makethreads; ++i) {	thread t = new thread (() => { thread.yield (); });	t.start ();	threads.add (t);	}	threads.add (null);	jointhread.join ();	joincount += makethreads;	
performed gcs created threads finished 

========================= mono sample_599 =========================

if (o != null) {	has_target++;	int val = (int)o;	if (val != i) console.writeline ("obj at {0} inconsistent: {1}", i, val);	} else {	if (t == gchandletype.normal || t == gchandletype.pinned) {	normal_reclaimed++;	}	}	}	
allocated has target normal reclaimed 

int i;	int freed = 0;	for (i = 0; i < count; ++i) {	if ((i % d) == 0) {	if (handle_array [i].isallocated) {	handle_array [i].free ();	freed++;	}	}	}	
freed 

int small_count = count / 2;	gchandle[] more = new gchandle [small_count];	int i;	for (i = 0; i < small_count; ++i) {	gchandletype t = (gchandletype) (i & 3);	more [i] = gchandle.alloc (i, t);	}	for (i = 0; i < small_count; ++i) {	more [i].free ();	}	
alloc many 

static void do_one () {	
start 

static void do_one () {	build_array ();	get_stats ();	gc.collect ();	
after collect 

static void do_one () {	build_array ();	get_stats ();	gc.collect ();	get_stats ();	free_some (10);	
after free 

static void do_one () {	build_array ();	get_stats ();	gc.collect ();	get_stats ();	free_some (10);	get_stats ();	free_some (4);	
after free 

static void do_one () {	build_array ();	get_stats ();	gc.collect ();	get_stats ();	free_some (10);	get_stats ();	free_some (4);	get_stats ();	gc.collect ();	
after collect 

get_stats ();	gc.collect ();	get_stats ();	free_some (10);	get_stats ();	free_some (4);	get_stats ();	gc.collect ();	get_stats ();	for (int i = 0; i < 10; ++i) alloc_many ();	
after alloc many 

get_stats ();	free_some (10);	get_stats ();	free_some (4);	get_stats ();	gc.collect ();	get_stats ();	for (int i = 0; i < 10; ++i) alloc_many ();	get_stats ();	free_some (1);	
after free all 

get_stats ();	free_some (4);	get_stats ();	gc.collect ();	get_stats ();	for (int i = 0; i < 10; ++i) alloc_many ();	get_stats ();	free_some (1);	get_stats ();	gc.collect ();	
after collect 

========================= mono sample_608 =========================

public static void main () {	
hi 

========================= mono sample_2012 =========================

public void openexeconfiguration1_userlevel_none () {	sysconfig config = configurationmanager.openexeconfiguration(configurationuserlevel.none);	
application config path 

public void openexeconfiguration1_userlevel_peruserroaming () {	sysconfig config = configurationmanager.openexeconfiguration(configurationuserlevel.peruserroaming);	
roaming user config path 

public void openexeconfiguration1_userlevel_peruserroamingandlocal () {	sysconfig config = configurationmanager.openexeconfiguration(configurationuserlevel.peruserroamingandlocal);	
local user config path 

public void mapped_userlevelnone () {	execonfigurationfilemap map = new execonfigurationfilemap ();	map.execonfigfilename = "execonfig";	sysconfig config = configurationmanager.openmappedexeconfiguration(map, configurationuserlevel.none);	
mapped application config path 

public void mapped_userlevelperroaming () {	execonfigurationfilemap map = new execonfigurationfilemap ();	map.execonfigfilename = "execonfig";	map.roaminguserconfigfilename = "roaminguser";	sysconfig config = configurationmanager.openmappedexeconfiguration(map, configurationuserlevel.peruserroaming);	
mapped roaming user config path 

public void mapped_userlevelperroamingandlocal () {	execonfigurationfilemap map = new execonfigurationfilemap ();	map.execonfigfilename = "execonfig";	map.roaminguserconfigfilename = "roaminguser";	map.localuserconfigfilename = "localuser";	sysconfig config = configurationmanager.openmappedexeconfiguration(map, configurationuserlevel.peruserroamingandlocal);	
mapped local user config path 

public void machineconfig () {	sysconfig config = configurationmanager.openmachineconfiguration ();	
machine config path 

public void mapped_machineconfig () {	configurationfilemap map = new configurationfilemap ();	map.machineconfigfilename = "machineconfig";	sysconfig config = configurationmanager.openmappedmachineconfiguration (map);	
mapped machine config path 

public void exepath_userlevelnone_null () {	#if false sysconfig config = configurationmanager.openexeconfiguration (null);	
null exe application config path 

public void mapped_execonfiguration_null () {	sysconfig config = configurationmanager.openmappedexeconfiguration(null, configurationuserlevel.none);	
null mapped application config path 

public void mapped_machineconfig_null () {	sysconfig config = configurationmanager.openmappedmachineconfiguration (null);	
null mapped machine config path 

========================= mono sample_29890 =========================

public static void main (string[] args) {	try {	compileuplevel cu = new compileuplevel ();	cu.run (args);	} catch (exception ex) {	
exception caught while generating uplevelhelper code 

========================= mono sample_1288 =========================

public void dump (textwriter tw) {	
bot 

public void dump (textwriter tw) {	
top 

========================= mono sample_29793 =========================

public void static main (string[] args) {	
hello 

========================= mono sample_34621 =========================

public static int main() {	try {	throw new exception("e is afraid to enter anonymous land");	} catch(exception e) {	anonhandler(delegate {	console.writeline(e.message);	res = e.message;	});	}	if (res == "e is afraid to enter anonymous land"){	
test passed 

throw new exception("e is afraid to enter anonymous land");	} catch(exception e) {	anonhandler(delegate {	console.writeline(e.message);	res = e.message;	});	}	if (res == "e is afraid to enter anonymous land"){	return 0;	}	
test failed 

========================= mono sample_2321 =========================

int n = 0;	for (int i = 0; i < log.count; i++) {	if ((string) log [i] == names [n]) {	n++;	if (n == names.length) return true;	}	}	if (n == names.length) {	return true;	} else {	
containseventsordered logged events didn t match correct events 

========================= mono sample_25504 =========================

static int main() {	if (foo (() => 1) != 2) return 1;	if (foo (() => (short) 1) != 1) return 2;	if (foo (() => (byte) 1) != 1) return 3;	
ok 

========================= mono sample_2172 =========================

public static void main (string[] args) {	bool trial;	string action = "add_trial";	switch (action) {	case "add_trial": trial = true;	goto case "add_to_project";	
add to project 

========================= mono sample_34472 =========================

public void add (msbuildgenerator.vscsproj vsproj) {	try {	libraries.add (vsproj);	} catch (exception ex) {	
error while adding library ex message 

private void writeprojectreference (streamwriter sln, string prefixguid, string library, string relativepath, string projectguid, string[] dependencyguids) {	library = library.replace("-net_4_x", "");	sln.writeline (project_start, prefixguid, library, relativepath, projectguid);	if (dependencyguids != null && dependencyguids.length > 0) {	sln.writeline ("\tprojectsection(projectdependencies) = postproject");	foreach (var guid in dependencyguids) sln.writeline ("\t\t{0} = {0}", guid);	
endprojectsection 

var unixprojfile = proj.csprojfilename.replace ("\\", "/");	var fullprojpath = path.getfullpath (unixprojfile).replace ("\\", "/");	var relativepath = msbuildgenerator.getrelativepath (slnfullpath, fullprojpath);	var dependencyguids = new string[0];	if (proj.prebuildevent.contains ("jay")) dependencyguids = new [] { jay_vcxproj_guid };	foreach (var fd in msbuildgenerator.fixed_dependencies) {	if (fullprojpath.endswith (fd.item1)) {	dependencyguids = dependencyguids.concat (fd.item2).toarray ();	}	}	
project fullprojpath has dependencyguids length dependencies string join dependencyguids 

public void write (string filename) {	var fullpath = path.getdirectoryname (filename) + "/";	using (var sln = new streamwriter (filename)) {	sln.writeline ();	sln.writeline (header);	writeprojectreference (sln, jay_sln_guid, "jay", "mcs/jay/jay.vcxproj", jay_vcxproj_guid, null);	foreach (var proj in libraries) {	writeprojectreference (sln, fullpath, proj);	}	
global 

writeprojectreference (sln, jay_sln_guid, "jay", "mcs/jay/jay.vcxproj", jay_vcxproj_guid, null);	foreach (var proj in libraries) {	writeprojectreference (sln, fullpath, proj);	}	sln.writeline ("\tglobalsection(solutionconfigurationplatforms) = presolution");	foreach (var profile in profiles) {	if (!observedprofiles.contains (profile)) continue;	sln.writeline ("\t\tdebug|{0} = debug|{0}", profile, profile);	sln.writeline ("\t\trelease|{0} = release|{0}", profile, profile);	}	
endglobalsection 

foreach (var profile in profiles) {	if (!observedprofiles.contains (profile)) continue;	sln.writeline ("\t\tdebug|{0} = debug|{0}", profile, profile);	sln.writeline ("\t\trelease|{0} = release|{0}", profile, profile);	}	sln.writeline ("\tglobalsection(projectconfigurationplatforms) = postsolution");	writeprojectconfigurationplatforms (sln, jay_vcxproj_guid, "win32");	foreach (var proj in libraries) {	writeprojectconfigurationplatforms (sln, proj.projectguid, "net_4_x");	}	
endglobalsection 

sln.writeline ("\t\tdebug|{0} = debug|{0}", profile, profile);	sln.writeline ("\t\trelease|{0} = release|{0}", profile, profile);	}	sln.writeline ("\tglobalsection(projectconfigurationplatforms) = postsolution");	writeprojectconfigurationplatforms (sln, jay_vcxproj_guid, "win32");	foreach (var proj in libraries) {	writeprojectconfigurationplatforms (sln, proj.projectguid, "net_4_x");	}	sln.writeline ("\tglobalsection(solutionproperties) = presolution");	sln.writeline ("\t\thidesolutionnode = false");	
endglobalsection 

sln.writeline ("\t\tdebug|{0} = debug|{0}", profile, profile);	sln.writeline ("\t\trelease|{0} = release|{0}", profile, profile);	}	sln.writeline ("\tglobalsection(projectconfigurationplatforms) = postsolution");	writeprojectconfigurationplatforms (sln, jay_vcxproj_guid, "win32");	foreach (var proj in libraries) {	writeprojectconfigurationplatforms (sln, proj.projectguid, "net_4_x");	}	sln.writeline ("\tglobalsection(solutionproperties) = presolution");	sln.writeline ("\t\thidesolutionnode = false");	
endglobal 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	
this command must be executed from mono msvc scripts 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
usage 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
genproj exe visual studio release output full solutions with tests 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
if output full solutions is false only the main system dll 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
assemblies and dependencies is included in the solution 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
example 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
genproj exe false false 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
genproj exe with no arguments is equivalent to genproj exe true false 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
genproj exe deps 

static void main (string [] args) {	if (!file.exists ("genproj.cs")) {	environment.exit (1);	}	if (args.length == 1 && args [0].tolower ().contains ("-h")) {	
generates a makefile dependency file from the projects input 

environment.exit (0);	}	var slnversion = (args.length > 0) ? args [0] : "2012";	bool fullsolutions = (args.length > 1) ? bool.parse (args [1]) : true;	bool withtests = (args.length > 2) ? bool.parse (args [2]) : false;	var makefiledeps =  (args.length > 0 && args [0] == "deps");	var sln_gen = new slngenerator (slnversion);	var four_five_sln_gen = new slngenerator (slnversion);	var projects = new dictionary<string,msbuildgenerator> ();	var duplicates = new list<string> ();	
foreach var project in getprojects withtests 

var makefiledeps =  (args.length > 0 && args [0] == "deps");	var sln_gen = new slngenerator (slnversion);	var four_five_sln_gen = new slngenerator (slnversion);	var projects = new dictionary<string,msbuildgenerator> ();	var duplicates = new list<string> ();	var library_output = project.element ("library_output").value;	var gen = new msbuildgenerator (project);	projects [library_output] = gen;	gen.eraseexisting ();	}	
foreach var project in getprojects withtests 

try {	string profilename;	var csproj = gen.generate (library_output, projects, out profilename);	var csprojfilename = csproj.csprojfilename;	if (!sln_gen.containsprojectidentifier (csproj.library)) {	sln_gen.add (csproj);	} else {	duplicates.add (csprojfilename);	}	if (profilename == null) {	
library output has no profile 

} else {	hashset<string> profilenames;	if (!slngenerator.profilesbyguid.trygetvalue (csproj.projectguid, out profilenames)) slngenerator.profilesbyguid[csproj.projectguid] = profilenames = new hashset<string>();	profilenames.add (profilename);	slngenerator.observedprofiles.add (profilename);	}	} catch (exception e) {	console.error.writeline (" }	}	foreach (var csprojfile in projects.values.select (x => x.getprojectfilename ()).distinct ()) {	
deduplicating 

fillsolution (four_five_sln_gen, msbuildgenerator.profile_4_x, projects.values, additionalfilter);	if (duplicates.count () > 0) {	var sb = new stringbuilder ();	sb.appendline (" foreach (var item in duplicates) {	sb.appendline ($" }	console.error.writeline (sb.tostring ());	}	writesolution (four_five_sln_gen, path.combine ("..", "..", makesolutionname (msbuildgenerator.profile_4_x)));	if (makefiledeps){	const string classdirprefix = "./../../";	
here 

static void writesolution (slngenerator sln_gen, string slnfilename) {	
sln gen write slnfilename 

========================= mono sample_20 =========================

protected abstract bool join (pair<apc, apc> edge, astate newstate, astate existingstate, out astate joinedstate, bool widen);	protected abstract bool requiresjoining (apc pc);	protected abstract bool hassinglesuccessor (apc pc, out apc next);	protected abstract bool isbottom (apc pc, astate state);	protected abstract astate transfer (apc pc, astate state);	protected abstract astate mutableversion (astate state, apc at);	protected abstract astate immutableversion (astate state, apc at);	public void printstatesatjoinpoints (textwriter tw) {	foreach (apc apc in this.joinstate.keys) {	string str = this.joinstate [apc].tostring ().replace (environment.newline, environment.newline + "   ");	
block pc 

========================= mono sample_29711 =========================

public static int main (string[] args) {	c test = new c();	test[333.333] = 444.444;	if (test[333.333] != 444.444) return 1;	test["a string"] = "another string";	if (test["a string"] != "another string") return 2;	test[111] = 222;	if (test[111] != 222) return 3;	
passes 

========================= mono sample_3008 =========================

static public datacolumn getdatacolumnbyschemaaction(string sourcecolumn, string datasetcolumn, datatable datatable, type datatype, missingschemaaction schemaaction) {	if (null == datatable) {	throw adp.argumentnull("datatable");	}	if (adp.isempty(datasetcolumn)) {	#if debug if (adapterswitches.dataschema.tracewarning) {	
explicit filtering of sourcecolumn sourcecolumn 

#endif return null;	}	datacolumncollection columns = datatable.columns;	debug.assert(null != columns, "getdatacolumnbyschemaaction: unexpected null datacolumncollection");	int index = columns.indexof(datasetcolumn);	if ((0 <= index) && (index < columns.count)) {	datacolumn datacolumn = columns[index];	debug.assert(null != datacolumn, "getdatacolumnbyschemaaction: unexpected null datacolumn");	if (!adp.isempty(datacolumn.expression)) {	#if debug if (adapterswitches.dataschema.traceerror) {	
schema mismatch on datacolumn datasetcolumn which is a computed column 

if ((0 <= index) && (index < columns.count)) {	datacolumn datacolumn = columns[index];	debug.assert(null != datacolumn, "getdatacolumnbyschemaaction: unexpected null datacolumn");	if (!adp.isempty(datacolumn.expression)) {	#if debug if (adapterswitches.dataschema.traceerror) {	}	#endif throw adp.columnschemaexpression(sourcecolumn, datasetcolumn);	}	if ((null == datatype) || (datatype.isarray == datacolumn.datatype.isarray)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
schema match on datacolumn datasetcolumn 

static internal datacolumn createdatacolumnbyschemaaction(string sourcecolumn, string datasetcolumn, datatable datatable, type datatype, missingschemaaction schemaaction) {	debug.assert(datatable != null, "should not call with a null datatable");	if (adp.isempty(datasetcolumn)) {	return null;	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	
schema add of datacolumn datasetcolumn 

static internal datacolumn createdatacolumnbyschemaaction(string sourcecolumn, string datasetcolumn, datatable datatable, type datatype, missingschemaaction schemaaction) {	debug.assert(datatable != null, "should not call with a null datatable");	if (adp.isempty(datasetcolumn)) {	return null;	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datacolumn(datasetcolumn, datatype);	case missingschemaaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
schema filter of datacolumn datasetcolumn 

return null;	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datacolumn(datasetcolumn, datatype);	case missingschemaaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingschemaaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
schema error on datacolumn datasetcolumn 

========================= mono sample_14309 =========================

using (bitmap bmp = new bitmap (sinfile)) {	bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	assert.areequal (520, data.stride, "stride");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

========================= mono sample_21119 =========================

public static void main(string[] args) {	if (new a().x) {	
this should not compile 

========================= mono sample_34967 =========================

public abstract void foo<u> (u x) where u : t1, t2;	}	class c : b<s<object>, s<dynamic>> {	public override void foo<u> (u x) {	}	public static int main () {	var m = typeof (c).getmethod ("foo");	var ta = m.getgenericarguments ()[0].getgenericparameterconstraints ();	if (ta.length != 1) return 1;	
ok 

========================= mono sample_2335 =========================

static void foo_static (long l) {	
got static long 

========================= mono sample_2117 =========================

try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection sect = (appsettingssection)config.getsection("appsettings");	foreach (string key in sect.settings.allkeys) {	keyvalueconfigurationelement e = sect.settings[key];	console.writeline ("{0} = {1}", e.key, e.value);	}	console.writeline ("lockallelementsexcept = '{0}'", sect.lockallelementsexcept.attributelist);	}	catch (exception e) {	
exception raised 

========================= mono sample_29826 =========================

public static int main() {	methodinfo mi = typeof (test).getmethod ("set_prop");	if (mi.getparameters ().length != 1) return 1;	if ((mi.getparameters ()[0].name) != "value") return 2;	
ok 

========================= mono sample_2057 =========================

foreach (createcollectioninfo c in createmethods.values) {	writecreatecollectionmethod(c);	}	writer.writeline();	foreach (string idname in idnames.values) {	writer.write("string ");	writer.write(idname);	writer.writeline(";");	}	writer.writeline();	
protected override void initids 

void writeisstarttag(string name, string ns) {	writer.write("if (reader.isstartelement(");	writeid(name);	writer.write(", ");	writeid(ns);	writer.writeline(")) {");	writer.indent++;	}	void writeunknownnode(string func, string node, elementaccessor e, bool anyifs) {	if (anyifs) {	
else 

reflectionawarecodegen.writequotedcsharpstring(writer, expectedelement);	}	writer.writeline(");");	if (anyifs) {	writer.indent--;	writer.writeline("}");	}	}	void generateinitcallbacksmethod() {	writer.writeline();	
protected override void initcallbacks 

}	}	writer.indent--;	writer.writeline("}");	if (needdummyarraymethod) {	writer.writeline();	writer.write("object ");	writer.write(dummyarraymethodname);	writer.writeline("() {");	writer.indent++;	
writer writeline 

}	}	writer.indent--;	writer.writeline("}");	if (needdummyarraymethod) {	writer.writeline();	writer.write("object ");	writer.write(dummyarraymethodname);	writer.writeline("() {");	writer.indent++;	
return null 

string generateliteralmemberselement(xmlmembersmapping xmlmembersmapping) {	elementaccessor element = xmlmembersmapping.accessor;	membermapping[] mappings = ((membersmapping)element.mapping).members;	bool haswrapperelement = ((membersmapping)element.mapping).haswrapperelement;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public object[] ");	writer.write(methodname);	writer.writeline("() {");	writer.indent++;	
reader movetocontent 

}	member[] members = (member[]) memberslist.toarray(typeof(member));	member[] textorarraymembers = (member[]) textorarraymemberslist.toarray(typeof(member));	if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	writeparamsread(mappings.length);	if (attributememberslist.count > 0) {	member[] attributemembers = (member[]) attributememberslist.toarray(typeof(member));	writememberbegin(attributemembers);	writeattributes(attributemembers, anyattribute, "unknownnode", "(object)p");	writememberend(attributemembers);	
reader movetoelement 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	writeparamsread(mappings.length);	if (attributememberslist.count > 0) {	member[] attributemembers = (member[]) attributememberslist.toarray(typeof(member));	writememberbegin(attributemembers);	writeattributes(attributemembers, anyattribute, "unknownnode", "(object)p");	writememberend(attributemembers);	}	writememberbegin(textorarraymembers);	if (haswrapperelement) {	
if reader isemptyelement reader skip reader movetocontent continue 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	writeparamsread(mappings.length);	if (attributememberslist.count > 0) {	member[] attributemembers = (member[]) attributememberslist.toarray(typeof(member));	writememberbegin(attributemembers);	writeattributes(attributemembers, anyattribute, "unknownnode", "(object)p");	writememberend(attributemembers);	}	writememberbegin(textorarraymembers);	if (haswrapperelement) {	
reader readstartelement 

writememberbegin(textorarraymembers);	if (haswrapperelement) {	}	if (issequence(members)) {	writer.writeline("int state = 0;");	}	int loopindex = writewhilenotloopstart();	writer.indent++;	string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	
reader movetocontent 

if (issequence(members)) {	writer.writeline("int state = 0;");	}	int loopindex = writewhilenotloopstart();	writer.indent++;	string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	writewhileloopend(loopindex);	writememberend(textorarraymembers);	if (haswrapperelement) {	
readendelement 

int loopindex = writewhilenotloopstart();	writer.indent++;	string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	writewhileloopend(loopindex);	writememberend(textorarraymembers);	if (haswrapperelement) {	writer.indent--;	writer.writeline("}");	writeunknownnode("unknownnode", "null", element, true);	
reader movetocontent 

string unknownnode = "unknownnode((object)p, " + expectedelements(members) + ");";	writememberelements(members, unknownnode, unknownnode, anyelement, anytext, null);	writewhileloopend(loopindex);	writememberend(textorarraymembers);	if (haswrapperelement) {	writer.indent--;	writer.writeline("}");	writeunknownnode("unknownnode", "null", element, true);	writewhileloopend(wrapperloopindex);	}	
return p 

membersmapping membersmapping = (membersmapping)element.mapping;	membermapping[] mappings = membersmapping.members;	bool haswrapperelement = membersmapping.haswrapperelement;	bool writeaccessors = membersmapping.writeaccessors;	string methodname = nextmethodname(element.name);	writer.writeline();	writer.write("public object[] ");	writer.write(methodname);	writer.writeline("() {");	writer.indent++;	
reader movetocontent 

writer.indent++;	writer.write("object[] p = new object[");	writer.write(mappings.length.tostring(cultureinfo.invariantculture));	writer.writeline("];");	initializevaluetypes("p", mappings);	if (haswrapperelement) {	writereadnonroots();	if (membersmapping.validaterpcwrapperelement) {	writer.write("if (!");	writexmlnodeequal("reader", element.name, element.form == xmlschemaform.qualified ? element.namespace : "");	
throw createunknownnodeexception 

writer.write(mappings.length.tostring(cultureinfo.invariantculture));	writer.writeline("];");	initializevaluetypes("p", mappings);	if (haswrapperelement) {	writereadnonroots();	if (membersmapping.validaterpcwrapperelement) {	writer.write("if (!");	writexmlnodeequal("reader", element.name, element.form == xmlschemaform.qualified ? element.namespace : "");	}	writer.writeline("bool isemptywrapper = reader.isemptyelement;");	
reader readstartelement 

string fixupmethodname = "fixup_" + methodname;	bool anyfixups = writememberfixupbegin(members, fixupmethodname, "p");	if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	
reader movetocontent 

bool anyfixups = writememberfixupbegin(members, fixupmethodname, "p");	if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	writewhileloopend(loopindex);	
if isemptywrapper readendelement 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	writewhileloopend(loopindex);	if (checktypehrefsource != null) writehandlehreflist(members, checktypehrefsource);	
readreferencedelements 

if (members.length > 0 && members[0].mapping.isreturnvalue) writer.writeline("isreturnvalue = true;");	string checktypehrefsource = (!haswrapperelement && !writeaccessors) ? "hreflist" : null;	if (checktypehrefsource != null) writeinitchecktypehreflist(checktypehrefsource);	writeparamsread(mappings.length);	int loopindex = writewhilenotloopstart();	writer.indent++;	string unrecognizedelementsource = checktypehrefsource == null ? "unknownnode((object)p);" : "if (reader.getattribute(\"id\", null) != null) { readreferencedelement(); } else { unknownnode((object)p); }";	writememberelements(members, unrecognizedelementsource, "unknownnode((object)p);", null, null, checktypehrefsource);	writewhileloopend(loopindex);	if (checktypehrefsource != null) writehandlehreflist(members, checktypehrefsource);	
return p 

========================= mono sample_11100 =========================

control = null;	system.windows.forms.msg msg = new msg();	object queue_id = xplatui.startloop (thread.currentthread);	timer timer = new timer ();	timer.tick += new eventhandler (dndtickhandler);	timer.interval = 100;	int suc;	drag_data.state = dragstate.dragging;	suc = xplatuix11.xsetselectionowner (display, xdndselection, drag_data.window, intptr.zero);	if (suc == 0) {	
could not take ownership of xdndselection aborting drag 

intptr count;	intptr remaining;	intptr data = intptr.zero;	xplatuix11.xgetwindowproperty (display, handle, xdndaware, intptr.zero, new intptr(0x8000000), false, (intptr) atom.xa_atom, out actual, out format, out count, out remaining, ref data);	if (actual != (intptr) atom.xa_atom || format != 32 || count.toint32() == 0 || data == intptr.zero) {	if (data != intptr.zero) xplatuix11.xfree (data);	return false;	}	int version = marshal.readint32 (data, 0);	if (version < 3) {	
xdnd version too old 

========================= mono sample_26304 =========================

public static void main(string[] args) {	tree<int> t = maketree(1, 15);	act<int> act = delegate(int val) { console.write("{0} ", val); };	
depth first 

public static void main(string[] args) {	tree<int> t = maketree(1, 15);	act<int> act = delegate(int val) { console.write("{0} ", val); };	tree<int>.depthfirst(t, act);	
breadth first 

public static void main(string[] args) {	tree<int> t = maketree(1, 15);	act<int> act = delegate(int val) { console.write("{0} ", val); };	tree<int>.depthfirst(t, act);	tree<int>.breadthfirst(t, act);	
depth first 

public static void main(string[] args) {	tree<int> t = maketree(1, 15);	act<int> act = delegate(int val) { console.write("{0} ", val); };	tree<int>.depthfirst(t, act);	tree<int>.breadthfirst(t, act);	tree<int>.traverse(t, act, new arraylist<tree<int>>());	
breadth first 

========================= mono sample_30581 =========================

var t = new thread (() => {	refs = new lotsarefs();	refs.referee = new referee();	});	t.start ();	t.join ();	for (var i = 0; i < 100000000; ++i) {	var o = new object();	}	if (refs.referee.gettype() != typeof(referee)) {	
wrong type 

refs.referee = new referee();	});	t.start ();	t.join ();	for (var i = 0; i < 100000000; ++i) {	var o = new object();	}	if (refs.referee.gettype() != typeof(referee)) {	return 1;	}	
all good 

========================= mono sample_383 =========================

public static int main() {	intptr[] nati = new intptr [1];	nati [0] = test.nati;	
nati 

========================= mono sample_152 =========================

public virtual void addservice(type servicetype, object serviceinstance, bool promote) {	
adding service instance promoting 

public virtual void addservice(type servicetype, object serviceinstance, bool promote) {	if (promote) {	iservicecontainer container = container;	if (container != null) {	debug.indent();	
promoting to container 

public virtual void addservice(type servicetype, servicecreatorcallback callback, bool promote) {	
adding service callback promoting 

public virtual void addservice(type servicetype, servicecreatorcallback callback, bool promote) {	if (promote) {	iservicecontainer container = container;	if (container != null) {	debug.indent();	
promoting to container 

public virtual object getservice(type servicetype) {	object service = null;	
searching for service 

for (int idx = 0; idx < defaults.length; idx++) {	if (servicetype.isequivalentto(defaults[idx])) {	service = this;	break;	}	}	if (service == null) {	services.trygetvalue(servicetype, out service);	}	if (service is servicecreatorcallback) {	
encountered a callback invoking it 

}	}	if (service == null) {	services.trygetvalue(servicetype, out service);	}	if (service is servicecreatorcallback) {	service = ((servicecreatorcallback)service)(this, servicetype);	debug.writelineif(traceservice.traceverbose, "callback return object: " + (service == null ? "(null)" : service.tostring()));	if (service != null && !service.gettype().iscomobject && !servicetype.isassignablefrom(service.gettype())) {	debug.fail("object " + service.gettype().name + " was returned from a service creator callback but it does not implement the registered type of " + servicetype.name);	
object does not implement service interface 

if (service is servicecreatorcallback) {	service = ((servicecreatorcallback)service)(this, servicetype);	debug.writelineif(traceservice.traceverbose, "callback return object: " + (service == null ? "(null)" : service.tostring()));	if (service != null && !service.gettype().iscomobject && !servicetype.isassignablefrom(service.gettype())) {	debug.fail("object " + service.gettype().name + " was returned from a service creator callback but it does not implement the registered type of " + servicetype.name);	service = null;	}	services[servicetype] = service;	}	if (service == null && parentprovider != null) {	
service unresolved trying parent 

debug.fail("object " + service.gettype().name + " was returned from a service creator callback but it does not implement the registered type of " + servicetype.name);	service = null;	}	services[servicetype] = service;	}	if (service == null && parentprovider != null) {	service = parentprovider.getservice(servicetype);	}	#if debug if (traceservice.traceverbose && service == null) {	debug.writeline("******************************************");	
failed to resolve service 

debug.fail("object " + service.gettype().name + " was returned from a service creator callback but it does not implement the registered type of " + servicetype.name);	service = null;	}	services[servicetype] = service;	}	if (service == null && parentprovider != null) {	service = parentprovider.getservice(servicetype);	}	#if debug if (traceservice.traceverbose && service == null) {	debug.writeline("******************************************");	
at 

public virtual void removeservice(type servicetype, bool promote) {	
removing service promote 

public virtual void removeservice(type servicetype, bool promote) {	if (promote) {	iservicecontainer container = container;	if (container != null) {	debug.indent();	
invoking parent container 

========================= mono sample_12229 =========================

public static void main () {	methodsignature ms = new methodsignature ("hello", null, null);	
about to look for 

========================= mono sample_1430 =========================

t.start ();	}	int iterations = 0;	for (testtimeout timeout = testtimeout.start(timespan.fromseconds(testtimeout.isstresstest ? 120 : 5)); timeout.havetimeleft;) {	var ad = appdomain.createdomain ("domain_" + iterations);	ad.docallback (new crossappdomaindelegate (allocstuff));	appdomain.unload (ad);	console.write (".");	if ((++iterations) % 20 == 0) console.writeline ();	}	
done iterations iterations 

========================= mono sample_292 =========================

public static int main () {	int v = 1;	object foo = (v + a.a);	object foo2 = (1 + a.a);	if (foo.gettype ().tostring () != "x+a"){	
expression evaluator bug in e operator u x e y 

public static int main () {	int v = 1;	object foo = (v + a.a);	object foo2 = (1 + a.a);	if (foo.gettype ().tostring () != "x+a"){	return 1;	}	if (foo2.gettype ().tostring () != "x+a"){	
constant folder bug in e operator u x e y 

========================= mono sample_2488 =========================

public static int main() {	bool xx = flags.public != 0;	bool xx2 = 0 < flags.public;	if ((_enumflags & flags.removed) != 0) return 3;	if ((flags.public & 0).tostring () != "removed") return 1;	if ((0 & flags.public).tostring () != "removed") return 1;	
ok 

========================= mono sample_1851 =========================

public static extern void mono_safe_handle_ref (ref myhandle handle);	[dllimport ("libtest", entrypoint="mono_safe_handle_ref")]	public static extern void mono_safe_handle_ref2 (ref myhandlenoctor handle);	public static int test_0_safehandle_ref_noctor () {	myhandlenoctor m = new myhandlenoctor ((intptr) 0xdead);	try {	mono_safe_handle_ref2 (ref m);	} catch (missingmethodexception e){	
good got exception requried 

public static int test_0_safehandle_ref () {	myhandle m = new myhandle ((intptr) 0xdead);	mono_safe_handle_ref (ref m);	if (m.dangerousgethandle () != (intptr) 0x800d){	
test safehandle ref fail expected got x 

public static int test_0_safehandle_ref () {	myhandle m = new myhandle ((intptr) 0xdead);	mono_safe_handle_ref (ref m);	if (m.dangerousgethandle () != (intptr) 0x800d){	return 1;	}	
test safehandle ref pass 

public static extern safehandle mono_safe_handle_return_1 ();	[dllimport ("libtest", entrypoint="mono_safe_handle_return")]	public static extern myhandle mono_safe_handle_return ();	[dllimport ("libtest", entrypoint="mono_safe_handle_return")]	public static extern myhandlenoctor mono_safe_handle_return_2 ();	static structtest x = new structtest ();	public static int test_0_safehandle_return_noctor () {	try {	myhandlenoctor m = mono_safe_handle_return_2 ();	} catch (missingmethodexception e){	
good got exception required 

public static extern myhandle mono_safe_handle_return ();	[dllimport ("libtest", entrypoint="mono_safe_handle_return")]	public static extern myhandlenoctor mono_safe_handle_return_2 ();	static structtest x = new structtest ();	public static int test_0_safehandle_return_noctor () {	try {	myhandlenoctor m = mono_safe_handle_return_2 ();	} catch (missingmethodexception e){	return 0;	}	
failed expected an exception because there is no paramterless ctor 

public static int test_0_safehandle_return_exc () {	try {	safehandle x = mono_safe_handle_return_1 ();	} catch (marshaldirectiveexception){	
good got exception required 

public static int test_0_safehandle_return_exc () {	try {	safehandle x = mono_safe_handle_return_1 ();	} catch (marshaldirectiveexception){	return 0;	}	
error should have generated an exception since safehandle is abstract 

public static int test_0_safehandle_return () {	safehandle x = mono_safe_handle_return ();	
got the following handle 

static int error (string msg) {	
error 

========================= mono sample_321 =========================

public static int main () {	object o = foo (null);	if (o != null) return 1;	o = foog<bool> (null);	if (o != null) return 2;	
ok 

========================= mono sample_3657 =========================

public static int main () {	foo2 f = new foo2 ();	
pass test passes on mono 

========================= mono sample_1911 =========================

static int main () {	var t = new thread (setuplinks);	t.start ();	t.join ();	gc.collect ();	bridge a, b;	a = b = null;	
try get a 

static int main () {	var t = new thread (setuplinks);	t.start ();	t.join ();	gc.collect ();	bridge a, b;	a = b = null;	
try get b 

static int main () {	var t = new thread (setuplinks);	t.start ();	t.join ();	gc.collect ();	bridge a, b;	a = b = null;	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	
a test 

static int main () {	var t = new thread (setuplinks);	t.start ();	t.join ();	gc.collect ();	bridge a, b;	a = b = null;	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	
b test 

========================= mono sample_370 =========================

static bool test(node inst, string name) {	if(inst.getstat() == 42) {	
passed 

static bool test(node inst, string name) {	if(inst.getstat() == 42) {	return true;	} else {	
failed 

========================= mono sample_1703 =========================

static void printtype (typedefinition td, int indent) {	if (td.isnested && !string.isnullorempty (td.namespace)) throw new applicationexception ("broken nested type:");	
namespace name 

========================= mono sample_3606 =========================

var b = s2 >> 3;	if (b != 1250) return 2;	var b2 = s2 >> s2;	if (b2 != 0) return 3;	var b3 = s2 + 1;	if (b3 != 10001) return 4;	var s3 = new s3 ();	if ((s3 == null) != false) return 5;	if ((s3 != null) != true) return 6;	if (s3.counter != 2) return 7;	
ok 

========================= mono sample_3597 =========================

restrictionerrormsg = null;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	xmlschemaparticle derivedparticle = cannonicalizepointlessroot(complextype.contenttypeparticle);	xmlschemaparticle baseparticle = cannonicalizepointlessroot(basetype.contenttypeparticle);	if (!isvalidrestriction(derivedparticle, baseparticle)) {	#if debug if(complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
invalid complextype content restriction 

restrictionerrormsg = null;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	xmlschemaparticle derivedparticle = cannonicalizepointlessroot(complextype.contenttypeparticle);	xmlschemaparticle baseparticle = cannonicalizepointlessroot(basetype.contenttypeparticle);	if (!isvalidrestriction(derivedparticle, baseparticle)) {	#if debug if(complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
base 

restrictionerrormsg = null;	if (basetype != null && basetype != xmlschemacomplextype.anytype && complextype.derivedby == xmlschemaderivationmethod.restriction) {	xmlschemaparticle derivedparticle = cannonicalizepointlessroot(complextype.contenttypeparticle);	xmlschemaparticle baseparticle = cannonicalizepointlessroot(basetype.contenttypeparticle);	if (!isvalidrestriction(derivedparticle, baseparticle)) {	#if debug if(complextype.contenttypeparticle != null && basetype.contenttypeparticle != null) {	string position = string.empty;	if (complextype.sourceuri != null) {	position = " in " + complextype.sourceuri + "(" + complextype.linenumber + ", " + complextype.lineposition + ")";	}	
derived 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

xmlschemaattribute attribute = (xmlschemaattribute)derivedtype.attributeuses[attributebase.qualifiedname];	if (attribute == null) {	derivedtype.attributeuses.add(attributebase.qualifiedname, attributebase);	}	else {	if (attributebase.use == xmlschemause.prohibited && attribute.use != xmlschemause.prohibited) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

foreach(xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
invalid complextype attributes restriction 

foreach(xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
base 

foreach(xmlschemaattribute attribute in derivedtype.attributeuses.values) {	xmlschemaattribute attributebase = (xmlschemaattribute)basetype.attributeuses[attribute.qualifiedname];	if (attributebase != null) {	continue;	}	if (baseattributewildcard == null || !baseattributewildcard.allows(attribute.qualifiedname)) {	#if debug string position = string.empty;	if (derivedtype.sourceuri != null) {	position = " in " + derivedtype.sourceuri + "(" + derivedtype.linenumber + ", " + derivedtype.lineposition + ")";	}	
derived 

xmlschemaelement localelement = (xmlschemaelement)all.items[i];	if (!contentvalidator.addelement(localelement.qualifiedname, localelement, localelement.minoccurs == decimal.zero)) {	sendvalidationevent(res.sch_dupelement, localelement.qualifiedname.tostring(), localelement);	}	}	return contentvalidator;	}	else {	particlecontentvalidator contentvalidator = new particlecontentvalidator(complextype.contenttype, compilationsettings.enableupacheck);	#if debug string name = complextype.name != null ? complextype.name : string.empty;	
compilecomplexcontent 

========================= mono sample_11262 =========================

{ "h|?|help", "show this message and exit.", v => help = v != null }, { "v|verbose", "increase message verbosity.", v => { ++verbose; } }, { "n=", "must be an int", (int n) => { /* ignore */ } }, { "v|version", "output version information and exit.", v => version = v != null }, };	try {	p.parse (args);	}	catch (optionexception e) {	console.write ("localization: ");	console.writeline (e.message);	return;	}	if (help) p.writeoptiondescriptions (console.out);	
ndesk options localizer demo 

{ "h|?|help", "show this message and exit.", v => help = v != null }, { "v|verbose", "increase message verbosity.", v => { ++verbose; } }, { "n=", "must be an int", (int n) => { /* ignore */ } }, { "v|version", "output version information and exit.", v => version = v != null }, };	try {	p.parse (args);	}	catch (optionexception e) {	console.write ("localization: ");	console.writeline (e.message);	return;	}	if (help) p.writeoptiondescriptions (console.out);	
message level 

========================= mono sample_32537 =========================

public static int main () {	a a = new a ();	a.bar ();	if (a.x != 0) return 1;	if (a.s != "0") return 1;	
bar set s to 

========================= mono sample_3845 =========================

public static int main () {	int count = 0;	try {	foo ();	}	catch (stackoverflowexception) {	
stack overflow caught 

foo ();	}	catch (stackoverflowexception) {	count ++;	}	if (count != 1) return 1;	count = 0;	try {	recurse ();	} catch (exception ex) {	
handled 

if (count != 1) return 1;	count = 0;	try {	recurse ();	} catch (exception ex) {	count++;	}	try {	recurse ();	} catch (exception ex) {	
again 

========================= mono sample_230 =========================

else if (this.tarout != null) {	this.tarout.flush();	this.tarout.close();	}	}	public void listcontents() {	while (true) {	tarentry entry = this.tarin.getnextentry();	if (entry == null) {	if (this.debug) {	
read eof block 

break;	}	onprogressmessageevent(entry, null);	}	}	public void extractcontents(string destdir) {	while (true) {	tarentry entry = this.tarin.getnextentry();	if (entry == null) {	if (this.debug) {	
read eof block 

========================= mono sample_30836 =========================

public static int main () {	main_thread_id = thread.currentthread.managedthreadid;	
main start 

public static int main () {	main_thread_id = thread.currentthread.managedthreadid;	mre = new manualresetevent (false);	mre2 = new manualresetevent (false);	tcs = new taskcompletionsource<bool> ();	task.factory.startnew (new func<task> (executeasync), new cancellationtoken (), taskcreationoptions.longrunning, taskscheduler.default);	if (!mre.waitone (1000)) return 1;	thread.sleep (10);	
main set result 

main_thread_id = thread.currentthread.managedthreadid;	mre = new manualresetevent (false);	mre2 = new manualresetevent (false);	tcs = new taskcompletionsource<bool> ();	task.factory.startnew (new func<task> (executeasync), new cancellationtoken (), taskcreationoptions.longrunning, taskscheduler.default);	if (!mre.waitone (1000)) return 1;	thread.sleep (10);	synchronizationcontext.setsynchronizationcontext (new mycontext ());	tcs.setresult (true);	if (!mre2.waitone (1000)) return 2;	
ok 

static async task executeasync () {	var t = thread.currentthread;	
started 

static async task executeasync () {	var t = thread.currentthread;	mre.set ();	await tcs.task;	t = thread.currentthread;	
resumed 

========================= mono sample_1795 =========================

public void listallgroups_tostring () {	try {	
listing all groups 

========================= mono sample_21993 =========================

public static int main () {	int x = 1;	int y = 0;	d del = new d (m);	iasyncresult ar = del.begininvoke (x, out y, null, null);	if (del.endinvoke (out y, ar) != 2) return 1;	if (y != 3) return 2;	
test ok 

========================= mono sample_1896 =========================

static void expectedexception<t>(action action) where t: exception {	try {	action();	
expected exception 

========================= mono sample_166 =========================

rtf.defaultfont(this.font.name);	rtf_text_map = new rtf.textmap();	rtf.textmap.setupstandardtable(rtf_text_map.table);	document.suspendrecalc ();	try {	rtf.read();	flushtext(rtf, false);	}	catch (rtf.rtfexception e) {	#if debug throw e;	
rtf parsing failure 

========================= mono sample_26270 =========================

public static int main () {	var t1 = testnested_1 ();	if (!task.waitall (new[] { t1 }, 1000)) return 1;	if (t1.result != 0) return 2;	
ok 

========================= mono sample_3781 =========================

public static int main(string[] args) {	console.foregroundcolor = consolecolor.red;	
note nunit console shipped with mono is deprecated please use the nunit nuget package or some other form of acquiring nunit 

========================= mono sample_32692 =========================

public internalclass (char @public) {	
internalclass public 

public static void privatestaticmethod () {	
internalclass privatestaticmethod 

static void internalstaticmethod () {	
internalclass internalstaticmethod 

public static void publicstaticmethod () {	
publicstaticmethod 

public void publicmethod () {	
publicmethod 

static void internalstaticmethod () {	
publicclass internalstaticmethod 

========================= mono sample_195 =========================

static assembly myreflectionresolveeventhandler (object sender, resolveeventargs args) {	
load event for args name 

========================= mono sample_344 =========================

bool retval = true;	node[] nodes = new node[size + 2];	int i = 0;	node n = startsentinel;	while (n != null) {	nodes[i++] = n;	n = n.next;	}	foreach (hashedlinkedlist<t> view in views) {	if (!view.isvalid) {	
invalid view hash offset size 

while (n != null) {	nodes[i++] = n;	n = n.next;	}	foreach (hashedlinkedlist<t> view in views) {	if (!view.isvalid) {	retval = false;	continue;	}	if (view.offset > size || view.offset < 0) {	
bad view hash offset size offset underlying size 

}	foreach (hashedlinkedlist<t> view in views) {	if (!view.isvalid) {	retval = false;	continue;	}	if (view.offset > size || view.offset < 0) {	retval = false;	}	else if (view.startsentinel != nodes[view.offset]) {	
bad view hash offset size startsentinel should be 

retval = false;	continue;	}	if (view.offset > size || view.offset < 0) {	retval = false;	}	else if (view.startsentinel != nodes[view.offset]) {	retval = false;	}	if (view.offset + view.size > size || view.offset + view.size < 0) {	
bad view hash offset size end index underlying size 

if (view.offset > size || view.offset < 0) {	retval = false;	}	else if (view.startsentinel != nodes[view.offset]) {	retval = false;	}	if (view.offset + view.size > size || view.offset + view.size < 0) {	retval = false;	}	else if (view.endsentinel != nodes[view.offset + view.size + 1]) {	
bad view hash offset size endsentinel should be 

else if (view.startsentinel != nodes[view.offset]) {	retval = false;	}	if (view.offset + view.size > size || view.offset + view.size < 0) {	retval = false;	}	else if (view.endsentinel != nodes[view.offset + view.size + 1]) {	retval = false;	}	if (view.views != views) {	
bad view hash offset size wrong views list 

if (view.offset + view.size > size || view.offset + view.size < 0) {	retval = false;	}	else if (view.endsentinel != nodes[view.offset + view.size + 1]) {	retval = false;	}	if (view.views != views) {	retval = false;	}	if (view.underlying != this) {	
bad view hash offset size wrong underlying this 

if (startsentinel != null && startsentinel.next != endsentinel) {	console.writeline("size == 0 but startsentinel.next != endsentinel");	retval = false;	}	if (endsentinel != null && endsentinel.prev != startsentinel) {	console.writeline("size == 0 but endsentinel.prev != startsentinel");	retval = false;	}	}	if (startsentinel == null) {	
null startsentinel 

if (startsentinel == null) {	return retval;	}	int count = 0;	node node = startsentinel.next, prev = startsentinel;	#if hashindex int taggroupsize = 0, oldtaggroupsize = losize + 1, seentaggroups = 0;	taggroup oldtg = null;	if (underlying == null) {	taggroup tg = startsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.minvalue) {	
bad startsentinel tag group 

node node = startsentinel.next, prev = startsentinel;	#if hashindex int taggroupsize = 0, oldtaggroupsize = losize + 1, seentaggroups = 0;	taggroup oldtg = null;	if (underlying == null) {	taggroup tg = startsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.minvalue) {	retval = false;	}	tg = endsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.maxvalue) {	
bad endsentinel tag group 

retval = false;	}	tg = endsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.maxvalue) {	retval = false;	}	}	#endif while (node != endsentinel) {	count++;	if (node.prev != prev) {	
bad backpointer at node 

oldtg = node.taggroup;	taggroupsize = 1;	}	else {	taggroupsize++;	}	}	#endif prev = node;	node = node.next;	if (node == null) {	
null next pointer at node 

retval = checkviews() && retval;	#if hashindex if (!retval) return false;	if (underlying == null) {	if (size != dict.count) {	console.writeline("list.size ({0}) != dict.count ({1})", size, dict.count);	retval = false;	}	node n = startsentinel.next, n2;	while (n != endsentinel) {	if (!dict.find(n.item, out n2)) {	
item in list but not dict 

if (size != dict.count) {	console.writeline("list.size ({0}) != dict.count ({1})", size, dict.count);	retval = false;	}	node n = startsentinel.next, n2;	while (n != endsentinel) {	if (!dict.find(n.item, out n2)) {	retval = false;	}	else if (n != n2) {	
wrong node in dict for item 

========================= mono sample_30546 =========================

static void someendofprocessaction(object sender, eventargs args) {	threadpool.queueuserworkitem (new waitcallback (threadpoolcallback));	
pass 

static void someendofprocessaction(object sender, eventargs args) {	threadpool.queueuserworkitem (new waitcallback (threadpoolcallback));	
fail 

========================= mono sample_255 =========================

static byte [] faultresponse_qualified (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <soap:fault>" + "      <soap:faultcode>soap:server</soap:faultcode>" + "      <soap:faultstring>failure processing request.</soap:faultstring>" + "      <soap:faultactor>mono web service</soap:faultactor>" + "      <soap:detail>" + "        <se:systemerror xmlns:se=\"http: "          <se:code>5000</se:code>" + "          <se:description>invalid credentials.</se:description>" + "        </se:systemerror>" + "      </soap:detail>" + "    </soap:fault>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
http ok 

static byte [] faultresponse_qualified (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <soap:fault>" + "      <soap:faultcode>soap:server</soap:faultcode>" + "      <soap:faultstring>failure processing request.</soap:faultstring>" + "      <soap:faultactor>mono web service</soap:faultactor>" + "      <soap:detail>" + "        <se:systemerror xmlns:se=\"http: "          <se:code>5000</se:code>" + "          <se:description>invalid credentials.</se:description>" + "        </se:systemerror>" + "      </soap:detail>" + "    </soap:fault>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
content type text xml 

static byte [] faultresponse_qualified (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <soap:fault>" + "      <soap:faultcode>soap:server</soap:faultcode>" + "      <soap:faultstring>failure processing request.</soap:faultstring>" + "      <soap:faultactor>mono web service</soap:faultactor>" + "      <soap:detail>" + "        <se:systemerror xmlns:se=\"http: "          <se:code>5000</se:code>" + "          <se:description>invalid credentials.</se:description>" + "        </se:systemerror>" + "      </soap:detail>" + "    </soap:fault>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
content length 

static byte [] faultresponse_unqualified (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <soap:fault>" + "      <faultcode>soap:server</faultcode>" + "      <faultstring>failure processing request.</faultstring>" + "      <faultactor>mono web service</faultactor>" + "      <detail>" + "        <se:systemerror xmlns:se=\"http: "          <se:code>5000</se:code>" + "          <se:description>invalid credentials.</se:description>" + "        </se:systemerror>" + "      </detail>" + "    </soap:fault>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
http ok 

static byte [] faultresponse_unqualified (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <soap:fault>" + "      <faultcode>soap:server</faultcode>" + "      <faultstring>failure processing request.</faultstring>" + "      <faultactor>mono web service</faultactor>" + "      <detail>" + "        <se:systemerror xmlns:se=\"http: "          <se:code>5000</se:code>" + "          <se:description>invalid credentials.</se:description>" + "        </se:systemerror>" + "      </detail>" + "    </soap:fault>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
content type text xml 

static byte [] faultresponse_unqualified (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <soap:fault>" + "      <faultcode>soap:server</faultcode>" + "      <faultstring>failure processing request.</faultstring>" + "      <faultactor>mono web service</faultactor>" + "      <detail>" + "        <se:systemerror xmlns:se=\"http: "          <se:code>5000</se:code>" + "          <se:description>invalid credentials.</se:description>" + "        </se:systemerror>" + "      </detail>" + "    </soap:fault>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
content length 

static byte [] outparametersresponse (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <reqresponse2 xmlns=\"urn:foo\">" + "      <hits>erere</hits>" + "    </reqresponse2>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
http ok 

static byte [] outparametersresponse (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <reqresponse2 xmlns=\"urn:foo\">" + "      <hits>erere</hits>" + "    </reqresponse2>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
content type text xml 

static byte [] outparametersresponse (socket socket) {	string responsecontent = "<soap:envelope xmlns:soap=\"http: "  <soap:body>" + "    <reqresponse2 xmlns=\"urn:foo\">" + "      <hits>erere</hits>" + "    </reqresponse2>" + "  </soap:body>" + "</soap:envelope>";	stringwriter sw = new stringwriter ();	
content length 

========================= mono sample_24297 =========================

static void innerfunc () {	res = 2;	try {	res = 3;	} finally {	res = 4;	
eee 

static void innerfunc () {	res = 2;	try {	res = 3;	} finally {	res = 4;	while (!foo);	res = 5;	
in the finally block 

static int main () {	thread t = new thread (func);	t.start ();	thread.sleep (100);	t.abort ();	foo = true;	
what now 

========================= mono sample_245 =========================

public static int main () {	var r = testgeneral ();	if (r != 0) return r;	r = testspecific ();	if (r != 0) return 10 + r;	
ok 

========================= mono sample_1935 =========================

public static void main() {	thread thr=new thread(new threadstart(foo.thread));	thr.start();	thread.sleep(600);	
aborting child thread 

public static void main() {	thread thr=new thread(new threadstart(foo.thread));	thr.start();	thread.sleep(600);	thr.abort();	
main thread returns 

public static void thread() {	try {	
thread running 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

========================= mono sample_185 =========================

da = t.getmember ("iface")[0].getcustomattributes (ca, false)[0] as dynamicattribute;	if (da == null) return 46;	if (!da.transformflags.sequenceequal (new bool[] { false, false, true })) return 47;	da = t.getmember ("d2")[0].getcustomattributes (ca, false)[0] as dynamicattribute;	if (da == null) return 48;	if (!da.transformflags.sequenceequal (new bool[] { false, false, false, false, true })) return 49;	t = typeof (del);	if (t.getmember ("invoke")[0].getcustomattributes (ca, false).length != 0) return 100;	if (t.getmethod ("invoke").getparameters ()[0].getcustomattributes (ca, false).length != 1) return 101;	if (t.getmethod ("invoke").returnparameter.getcustomattributes (ca, false).length != 1) return 102;	
ok 

========================= mono sample_1964 =========================

protected override void processhandshakemessage(tlsstream handmsg) {	handshaketype		handshaketype	= (handshaketype)handmsg.readbyte();	handshakemessage	message			= null;	
processing handshake record 

========================= mono sample_31879 =========================

public static int main () {	if (switch_1 (null) != 4) return 1;	if (switch_1 ("x") != 5) return 2;	if (switch_1 (1) != 1) return 3;	if (switch_1 ((byte?) 1) != 1) return 5;	if (switch_2 (new c1 ()) != 3) return 10;	if (switch_2 (null) != 2) return 11;	
ok 

========================= mono sample_3511 =========================

static bool f () {	
f 

static bool t () {	
t 

}	if (t_count != 2) return 1;	if (f_count != -1) return 3;	f_count = 0;	if (t () && f ()) if (t_count != 3 && f_count == 1) return 2;	if (f () && f ()) return 3;	if (f_count != 2) return 4;	if (f () && t ()) return 5;	if (f_count != 3) return 6;	if (t_count != 3) return 7;	
or 

========================= mono sample_3680 =========================

break;	}	}	events.firetestloadfailed( testfilename, lastexception );	}	catch( exception exception ) {	lastexception = exception;	events.firetestloadfailed( testfilename, exception );	}	double loadtime = (double)(datetime.now.ticks - starttime) / (double)timespan.tickspersecond;	
testloader loaded in seconds 

========================= mono sample_32863 =========================

public static int main () {	int errors = 0;	type t = typeof (myunicode);	if ((t.attributes & typeattributes.stringformatmask) != typeattributes.unicodeclass){	
class myunicode does not have unicode bit set 

public static int main () {	int errors = 0;	type t = typeof (myunicode);	if ((t.attributes & typeattributes.stringformatmask) != typeattributes.unicodeclass){	errors += 1;	}	t = typeof (myauto);	if ((t.attributes & typeattributes.stringformatmask) != typeattributes.autoclass){	
class myauto does not have auto bit set 

type t = typeof (myunicode);	if ((t.attributes & typeattributes.stringformatmask) != typeattributes.unicodeclass){	errors += 1;	}	t = typeof (myauto);	if ((t.attributes & typeattributes.stringformatmask) != typeattributes.autoclass){	errors += 2;	}	t = typeof (myansi);	if ((t.attributes & typeattributes.stringformatmask) != typeattributes.ansiclass){	
class myunicode does not have ansi bit set 

========================= mono sample_1414 =========================

res2 = o2 is x { field is y { prop is 'g' } };	if (res2) return 5;	object o3 = new x () {	value = 5 };	if (o3 is x { value is 6 }) return 6;	if (!(o3 is x { value is 5 })) return 7;	object o4 = new x () {	nullablevalue = 4 };	bool res3 = o4 is x { nullablevalue is (byte) 4 };	if (!res3) return 8;	
ok 

========================= mono sample_3983 =========================

public override void writepropertybeforeset(codewriter writer, dblinq.schema.dbml.column property, generationcontext context) {	
on changing value 

========================= mono sample_25058 =========================

public static int main () {	var t2 = run (() => task<int>.factory.startnew (() => 5));	if (!t2.wait (1000)) {	console.writeline (t2.status);	return 1;	}	
ok 

========================= mono sample_3756 =========================

public my2attribute (string stuff, int blah) : base (stuff) {	
ctor with int val 

========================= mono sample_1713 =========================

protected override void renderendform() {	base.renderendform();	if (_requiresoptionsubmitcard) {	write("<card id=\"");	write(_postbackcardprefix);	write("0");	write(_optionsubmitcardindex++);	writeline("\">");	write("<onevent type=\"onenterforward\">");	rendergoaction(null, _postbackeventargumentvarname, wmlpostfieldtype.variable, true);	
onevent 

base.renderendform();	if (_requiresoptionsubmitcard) {	write("<card id=\"");	write(_postbackcardprefix);	write("0");	write(_optionsubmitcardindex++);	writeline("\">");	write("<onevent type=\"onenterforward\">");	rendergoaction(null, _postbackeventargumentvarname, wmlpostfieldtype.variable, true);	writeline("<onevent type=\"onenterbackward\"><prev /></onevent>");	
card 

========================= mono sample_6062 =========================

public static int main () {	constructorinfo mi = typeof(c).getconstructors ()[0];	methodbody mb = mi.getmethodbody();	if (mb.getilasbytearray ().length != 7) {	
optimization failed 

public static int main () {	constructorinfo mi = typeof(c).getconstructors ()[0];	methodbody mb = mi.getmethodbody();	if (mb.getilasbytearray ().length != 7) {	return 3;	}	bool b = default (datetime?) == default (datetime?);	if (!b) return 19;	
ok 

========================= mono sample_1901 =========================

if (value.tag == "value"){	loadkey (value);	}	}	}	}	} catch (unauthorizedaccessexception){	values.clear ();	throw new securityexception ("no access to the given key");	} catch (exception e){	
while loading registry key at 

string btime = null;	string line;	try {	using (streamreader stat_file = new streamreader ("/proc/stat", encoding.ascii)) {	while ((line = stat_file.readline ()) != null) if (line.startswith ("btime")) {	btime = line;	break;	}	}	} catch (exception e) {	
while reading system info 

static long getregisteredboottime (string path) {	if (!file.exists (path)) return -1;	string line = null;	try {	using (streamreader reader = new streamreader (path, encoding.ascii)) line = reader.readline ();	} catch (exception e) {	
while reading registry data at 

========================= mono sample_28086 =========================

public static int main () {	mydispose copy_a, copy_b, copy_c;	using (mydispose a = new mydispose (), b = new mydispose ()){	copy_a = a;	copy_b = b;	}	if (!copy_a.disposed) return 1;	if (!copy_b.disposed) return 2;	
nested using clause disposed 

if (!copy_a.disposed) return 1;	if (!copy_b.disposed) return 2;	copy_c = null;	try {	using (mydispose c = new mydispose ()){	copy_c = c;	throw new exception ();	}	} catch {}	if (!copy_c.disposed) return 3;	
disposal on finally block works 

copy_c = null;	try {	using (mydispose c = new mydispose ()){	copy_c = c;	throw new exception ();	}	} catch {}	if (!copy_c.disposed) return 3;	using (mydispose d = null){	}	
null test passed 

throw new exception ();	}	} catch {}	if (!copy_c.disposed) return 3;	using (mydispose d = null){	}	mydispose bb = new mydispose ();	using (bb){	}	if (bb.disposed == false) return 6;	
all tests pass 

========================= mono sample_3465 =========================

public static int main() {	expression<func<arraylist>> e1 = () => new arraylist { null, "hello", "world", 5 };	assertnodetype (e1, expressiontype.listinit);	var re1 = e1.compile ().invoke ();	assert (null, re1 [0]);	assert ("hello", re1 [1]);	assert ("world", re1 [2]);	assert (5, re1 [3]);	
ok 

========================= mono sample_1560 =========================

public static void runtest (string test) {	assembly asm = assembly.load (test);	try {	if (asm.entrypoint.getparameters ().length == 1) asm.entrypoint.invoke (null, new string[] { null });	else asm.entrypoint.invoke (null, null);	} catch (targetinvocationexception e) {	
catched oom 

========================= mono sample_142 =========================

static int help () {	
mono mget exe options url url 

static int help () {	
where options can be one or more of the following 

static int help () {	
no check certificate don t validate the server ssl tls certificate 

case "--secure-protocol=auto": servicepointmanager.securityprotocol = securityprotocoltype.ssl3 | securityprotocoltype.tls;	break;	case "--secure-protocol=sslv3": servicepointmanager.securityprotocol = securityprotocoltype.ssl3;	break;	case "--secure-protocol=tlsv1": servicepointmanager.securityprotocol = securityprotocoltype.tls;	break;	case "--secure-protocol=sslv2": console.writeline ("sslv2 isn't supported in the framework");	return help ();	case "--help": case "--?": return help ();	default: if (arg.startswith ("--")) {	
unknown option 

int status = 0;	foreach (string url in urls) {	string filename = path.getfilename (url);	if (filename.length == 0) filename = "default";	string savename = filename;	int n = 1;	while (file.exists (savename)) {	savename = string.concat (filename, ".", n.tostring ());	n++;	}	
get 

int status = 0;	foreach (string url in urls) {	string filename = path.getfilename (url);	if (filename.length == 0) filename = "default";	string savename = filename;	int n = 1;	while (file.exists (savename)) {	savename = string.concat (filename, ".", n.tostring ());	n++;	}	
saving to 

while (file.exists (savename)) {	savename = string.concat (filename, ".", n.tostring ());	n++;	}	long size = -1;	datetime start = datetime.utcnow;	try {	size = mget.get (url, savename);	}	catch (exception e) {	
transfer incomplete due to exception 

}	long size = -1;	datetime start = datetime.utcnow;	try {	size = mget.get (url, savename);	}	catch (exception e) {	status++;	}	finally {	
completed bytes in 

========================= mono sample_20589 =========================

public static int main(){	int i = 0;	try{	try {	throw new notimplementedexception();	}	finally {	i++;	
finally called 

int i = 0;	try{	try {	throw new notimplementedexception();	}	finally {	i++;	}	} catch(notimplementedexception){	i++;	
exception ignored 

========================= mono sample_393 =========================

public static void test() {	string connectionstring;	string sqlquery;	pgsqldataadapter adapter;	dataset dataset = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	sqlquery = "select * from pg_tables";	
new pgsqldataadapter 

public static void test() {	string connectionstring;	string sqlquery;	pgsqldataadapter adapter;	dataset dataset = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	sqlquery = "select * from pg_tables";	adapter = new pgsqldataadapter (sqlquery, connectionstring);	
new dataset 

public static void test() {	string connectionstring;	string sqlquery;	pgsqldataadapter adapter;	dataset dataset = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	sqlquery = "select * from pg_tables";	adapter = new pgsqldataadapter (sqlquery, connectionstring);	dataset = new dataset ();	try {	
fill 

pgsqldataadapter adapter;	dataset dataset = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	sqlquery = "select * from pg_tables";	adapter = new pgsqldataadapter (sqlquery, connectionstring);	dataset = new dataset ();	try {	adapter.fill (dataset);	}	catch (notimplementedexception e) {	
exception caught 

dataset dataset = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	sqlquery = "select * from pg_tables";	adapter = new pgsqldataadapter (sqlquery, connectionstring);	dataset = new dataset ();	try {	adapter.fill (dataset);	}	catch (notimplementedexception e) {	}	
get row 

connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	sqlquery = "select * from pg_tables";	adapter = new pgsqldataadapter (sqlquery, connectionstring);	dataset = new dataset ();	try {	adapter.fill (dataset);	}	catch (notimplementedexception e) {	}	if (dataset != null) {	
table tablename tablename 

connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	sqlquery = "select * from pg_tables";	adapter = new pgsqldataadapter (sqlquery, connectionstring);	dataset = new dataset ();	try {	adapter.fill (dataset);	}	catch (notimplementedexception e) {	}	if (dataset != null) {	
done 

========================= mono sample_28408 =========================

public override void renderbegintag (htmltextwriter w) {	
renderbegintag 

protected internal override void rendercontents (htmltextwriter w) {	
rendercontents 

public override void renderendtag (htmltextwriter w) {	
renderendtag 

========================= mono sample_19091 =========================

static void dump (int i, bool ignore) {	switch (char.getunicodecategory ((char) i)) {	case unicodecategory.privateuse: case unicodecategory.surrogate: return;	}	string s1 = "";	string s2 = new string ((char) i, 10);	int ret = cultureinfo.invariantculture.compareinfo.compare (s1, s2, compareoptions.ignorecase);	if ((ret == 0) == ignore) return;	
x o x 

========================= mono sample_27864 =========================

public void stuff() {	string myldappath = "ldap: string username = "cn=manager,dc=toshok,dc=org", passwd = "evotest";	try {	mono.directory.ldap.ldap ld = new mono.directory.ldap.ldap (myldappath);	ld.bindsimple (username, passwd);	
successfully bound at 

public void stuff() {	string myldappath = "ldap: string username = "cn=manager,dc=toshok,dc=org", passwd = "evotest";	try {	mono.directory.ldap.ldap ld = new mono.directory.ldap.ldap (myldappath);	ld.bindsimple (username, passwd);	}	catch(exception e) {	
the path not found 

public void stuff() {	string myldappath = "ldap: string username = "cn=manager,dc=toshok,dc=org", passwd = "evotest";	try {	mono.directory.ldap.ldap ld = new mono.directory.ldap.ldap (myldappath);	ld.bindsimple (username, passwd);	}	catch(exception e) {	
exception 

========================= mono sample_21109 =========================

public void testglobaldata () {	assemblybuilder ab = genassembly ();	string resfile = path.combine (tempdir, "res");	using (streamwriter sw = new streamwriter (resfile)) {	
foo 

public void resolvemembermethod () {	var assembly = genassembly ();	var module = assembly.definedynamicmodule ("foo.dll", "foo.dll");	var type = module.definetype ("foo");	var method = type.definemethod ("str", methodattributes.static, typeof (void), type.emptytypes);	var il = method.getilgenerator ();	
writeline 

public void resolvemembermethod () {	var assembly = genassembly ();	var module = assembly.definedynamicmodule ("foo.dll", "foo.dll");	var type = module.definetype ("foo");	var method = type.definemethod ("str", methodattributes.static, typeof (void), type.emptytypes);	var il = method.getilgenerator ();	il.emit (opcodes.ret);	type.createtype ();	var writeline = (methodinfo) module.resolvemember (0x0a000001);	assert.isnotnull (writeline);	
writeline 

========================= mono sample_27582 =========================

public static int main(string[] args) {	textui runner;	if (args [0].startswith ("tcp:")) {	var parts = args [0].split (':');	if (parts.length != 3) throw new exception ();	string host = parts [1];	string port = parts [2];	args = args.skip (1).toarray ();	
connecting to harness at host port 

========================= mono sample_30 =========================

protected void recreatehandle() {	if (!ishandlecreated) return;	
recreating control 

protected void recreatehandle() {	if (!ishandlecreated) return;	#endif setisrecreating ();	if (ishandlecreated) {	
handle is created destroying it 

protected void recreatehandle() {	if (!ishandlecreated) return;	#endif setisrecreating ();	if (ishandlecreated) {	#endif destroyhandle();	} else {	
handle is not created creating it 

private void wmdestroy (ref message m) {	onhandledestroyed(eventargs.empty);	xplatui.setallowdrop(window.handle, false);	#if debugrecreate intptr handle = window.handle;	#endif window.invalidatehandle();	is_created = false;	if (is_recreating) {	
creating handle for x 

========================= mono sample_25596 =========================

public void runtest (string test) {	console.write (test);	assembly a = assembly.loadfrom (test);	methodinfo mi = a.entrypoint;	if (mi == null) {	
failed no entry point found 

public void runtest (string test) {	console.write (test);	assembly a = assembly.loadfrom (test);	methodinfo mi = a.entrypoint;	if (mi == null) {	return;	}	try {	mi.invoke (null, null);	
failed silent success 

console.write (test);	assembly a = assembly.loadfrom (test);	methodinfo mi = a.entrypoint;	if (mi == null) {	return;	}	try {	mi.invoke (null, null);	}	catch (targetinvocationexception ex) {	
ok 

console.write (test);	assembly a = assembly.loadfrom (test);	methodinfo mi = a.entrypoint;	if (mi == null) {	return;	}	try {	mi.invoke (null, null);	}	catch (targetinvocationexception ex) {	
failed 

methodinfo mi = a.entrypoint;	if (mi == null) {	return;	}	try {	mi.invoke (null, null);	}	catch (targetinvocationexception ex) {	}	catch (exception ex) {	
failed 

public static void main (string[] args) {	if (args.length < 1) {	
usage testrunner file pattern 

========================= mono sample_778 =========================

try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection sect = (appsettingssection)config.getsection("appsettings");	foreach (string key in sect.settings.allkeys) {	keyvalueconfigurationelement e = sect.settings[key];	console.writeline ("{0} = {1}", e.key, e.value);	}	console.writeline ("lockallattributesexcept = '{0}'", sect.lockallattributesexcept.attributelist);	}	catch (exception e) {	
exception raised 

========================= mono sample_29853 =========================

public static void main () {	
the compiler should complain error trying to use this outside context 

public static void main () {	
trying to assign i to this x outside a method property or ctr 

========================= mono sample_34433 =========================

public static void main () {	
hello 

========================= mono sample_2251 =========================

public contentvalidator finish(bool usedfa) {	debug.assert(contenttype == xmlschemacontenttype.elementonly || contenttype == xmlschemacontenttype.mixed);	if (contentnode == null) {	if (contenttype == xmlschemacontenttype.mixed) {	string ctype = isopen ? "any" : "textonly";	
contenttype 

public contentvalidator finish(bool usedfa) {	debug.assert(contenttype == xmlschemacontenttype.elementonly || contenttype == xmlschemacontenttype.mixed);	if (contentnode == null) {	if (contenttype == xmlschemacontenttype.mixed) {	string ctype = isopen ? "any" : "textonly";	return isopen ? contentvalidator.any : contentvalidator.textonly;	}	else {	
content empty 

string ctype = isopen ? "any" : "textonly";	return isopen ? contentvalidator.any : contentvalidator.textonly;	}	else {	debug.assert(!isopen);	return contentvalidator.empty;	}	}	#if debug stringbuilder bb = new stringbuilder();	contentnode.dump(bb, symbols, positions);	
content 

}	#if debug stringbuilder bb = new stringbuilder();	contentnode.dump(bb, symbols, positions);	#endif interiornode contentroot = new sequencenode();	contentroot.leftchild = contentnode;	leafnode endmarker = new leafnode(positions.add(symbols.addname(xmlqualifiedname.empty, null), null));	contentroot.rightchild = endmarker;	contentnode.expandtree(contentroot, symbols, positions);	#if debug bb = new stringbuilder();	contentroot.leftchild.dump(bb, symbols, positions);	
expended 

contentroot.leftchild.dump(bb, symbols, positions);	#endif int symbolscount = symbols.count;	int positionscount = positions.count;	bitset firstpos = new bitset(positionscount);	bitset lastpos = new bitset(positionscount);	bitset[] followpos = new bitset[positionscount];	for (int i = 0; i < positionscount; i++) {	followpos[i] = new bitset(positionscount);	}	contentroot.constructpos(firstpos, lastpos, followpos);	
firstpos lastpos followpos 

========================= mono sample_11238 =========================

public new virtual void writebreak() {	if (usedivsforbreaks) {	if((string)device["usepoverdiv"] == "true") writeline("<br/>");	
div div 

public new virtual void writebreak() {	if (usedivsforbreaks) {	if((string)device["usepoverdiv"] == "true") writeline("<br/>");	}	else {	
br 

========================= mono sample_6079 =========================

public void dispose () {	
dispose 

========================= mono sample_1499 =========================

public static void main(string[] args) {	isorted<int> sorted = new treeset<int>();	sorted.addall(new int[] { 23, 29, 31, 37, 41, 43, 47, 53 });	console.writeline(sorted);	if (args.length == 1) {	int n = int.parse(args[0]);	int res;	
has predecessor 

public static void main(string[] args) {	isorted<int> sorted = new treeset<int>();	sorted.addall(new int[] { 23, 29, 31, 37, 41, 43, 47, 53 });	console.writeline(sorted);	if (args.length == 1) {	int n = int.parse(args[0]);	int res;	
has weak predecessor 

public static void main(string[] args) {	isorted<int> sorted = new treeset<int>();	sorted.addall(new int[] { 23, 29, 31, 37, 41, 43, 47, 53 });	console.writeline(sorted);	if (args.length == 1) {	int n = int.parse(args[0]);	int res;	
has successor 

public static void main(string[] args) {	isorted<int> sorted = new treeset<int>();	sorted.addall(new int[] { 23, 29, 31, 37, 41, 43, 47, 53 });	console.writeline(sorted);	if (args.length == 1) {	int n = int.parse(args[0]);	int res;	
has weak successor 

========================= mono sample_30579 =========================

public static extern void printf(string format, __arglist);	public static int main() {	if (typeof (program).getmethod ("printf").callingconvention != callingconventions.varargs) return 1;	
ok 

========================= mono sample_2592 =========================

public void write(byte b) {	
literal compression 

public void writelengthdistance(int length, int distance) {	
length distance compression 

========================= mono sample_12362 =========================

public static int main(string[] args) {	int pl = (int) environment.osversion.platform;	if ((pl != 4) && (pl != 6) && (pl != 128)) {	return 0;	}	try {	var name = "bug-17537-helper.exe";	
launching subprocess 

return 0;	}	try {	var name = "bug-17537-helper.exe";	var p = new process();	p.startinfo.filename = path.combine (appdomain.currentdomain.basedirectory + name);	p.startinfo.useshellexecute = false;	var result = p.start();	p.waitforexit(1000);	if (result) {	
subprocess started successfully 

try {	var name = "bug-17537-helper.exe";	var p = new process();	p.startinfo.filename = path.combine (appdomain.currentdomain.basedirectory + name);	p.startinfo.useshellexecute = false;	var result = p.start();	p.waitforexit(1000);	if (result) {	return 0;	} else {	
subprocess failure 

p.startinfo.useshellexecute = false;	var result = p.start();	p.waitforexit(1000);	if (result) {	return 0;	} else {	return 1;	}	}	catch (exception e) {	
subprocess exception 

========================= mono sample_388 =========================

public static int main () {	int a = 1;	if (a != 1) return 1;	console.writeline ("a is = " + a);	s b= delegate {	
on delegate 

public static int main () {	int a = 1;	if (a != 1) return 1;	console.writeline ("a is = " + a);	s b= delegate {	a = 2;	};	if (a != 1) return 2;	b();	if (a != 2) return 3;	
ok 

========================= mono sample_2900 =========================

public static int main () {	if (typeof (foo).isabstract || !typeof (foo).issealed) return 1;	
ok 

========================= mono sample_2840 =========================

public static void test_callback (object state) {	
test callback 

public static int main () {	int workerthreads;	int completionportthreads;	threadpool.getmaxthreads (out workerthreads, out completionportthreads);	
workerthreads completionportthreads 

public static int main () {	int workerthreads;	int completionportthreads;	threadpool.getmaxthreads (out workerthreads, out completionportthreads);	threadpool.getavailablethreads (out workerthreads, out completionportthreads);	
workerthreads completionportthreads 

threadpool.getavailablethreads (out workerthreads, out completionportthreads);	threadpool.queueuserworkitem (new waitcallback (test_callback), "test1");	threadpool.queueuserworkitem (new waitcallback (test_callback), "test2");	threadpool.queueuserworkitem (new waitcallback (test_callback), "test3");	threadpool.queueuserworkitem (new waitcallback (test_callback), "test4");	threadpool.queueuserworkitem (new waitcallback (test_callback), "test5");	threadpool.queueuserworkitem (new waitcallback (test_callback));	while (csum < 6) {	thread.sleep (100);	}	
csum 

========================= mono sample_159 =========================

public override object changetype(object value, type type, cultureinfo cultureinfo) {	variant myvalue = new variant(value);	if (cultureinfo == null) cultureinfo = cultureinfo.currentculture;	
in oleautbinder changetype converting variant of type to type 

public override object changetype(object value, type type, cultureinfo cultureinfo) {	variant myvalue = new variant(value);	if (cultureinfo == null) cultureinfo = cultureinfo.currentculture;	#endif if (type.isbyref) {	
stripping byref from the type to convert to 

public override object changetype(object value, type type, cultureinfo cultureinfo) {	variant myvalue = new variant(value);	if (cultureinfo == null) cultureinfo = cultureinfo.currentculture;	#endif if (type.isbyref) {	#endif type = type.getelementtype();	}	if (!type.isprimitive && type.isinstanceoftype(value)) {	
source variant can be assigned to destination type 

variant myvalue = new variant(value);	if (cultureinfo == null) cultureinfo = cultureinfo.currentculture;	#endif if (type.isbyref) {	#endif type = type.getelementtype();	}	if (!type.isprimitive && type.isinstanceoftype(value)) {	#endif return value;	}	type srctype = value.gettype();	if (type.isenum && srctype.isprimitive) {	
converting primitive to enum 

}	type srctype = value.gettype();	if (type.isenum && srctype.isprimitive) {	#endif return enum.parse(type, value.tostring());	}	#if !feature_coreclr if (srctype == typeof(dbnull)) {	if (type == typeof(dbnull)) return value;	if ((type.isclass && type != typeof(object)) || type.isinterface) return null;	}	#endif try {	
using oavariantlib changetype to do the conversion 

type srctype = value.gettype();	if (type.isenum && srctype.isprimitive) {	#endif return enum.parse(type, value.tostring());	}	#if !feature_coreclr if (srctype == typeof(dbnull)) {	if (type == typeof(dbnull)) return value;	if ((type.isclass && type != typeof(object)) || type.isinterface) return null;	}	#endif try {	#endif object retobj = oavariantlib.changetype(myvalue, type, oavariantlib.localbool, cultureinfo).toobject();	
object returned from changetype is of type 

========================= mono sample_9025 =========================

static geteffectiveprivilegesrequest() {	try {	ldapextendedresponse.register(replicationconstants.get_effective_privileges_res, system.type.gettype("novell.directory.ldap.extensions.geteffectiveprivilegesresponse"));	}	catch (system.exception e) {	
could not register extended response class not found 

========================= mono sample_20951 =========================

public static void main (string [] args) {	if (args.length == 0 || args.length > 3) {	
usage zipmark file iterations blocksize 

public static void main (string [] args) {	if (args.length == 0 || args.length > 3) {	return;	}	string filename = args [0];	fileinfo file = new fileinfo (filename);	if (!file.exists) {	
couldn t find file 

string filename = args [0];	fileinfo file = new fileinfo (filename);	if (!file.exists) {	return;	}	filestream fs = file.openread ();	byte [] raw = new byte [file.length];	int count = fs.read (raw, 0, (int)file.length);	fs.close ();	if (count != file.length) {	
couldn t read file 

bool empty = true;	for (int i = 0; i < freqs.length; i++) {	if (freqs[i] != 0) {	console.writeline("freqs["+i+"] == "+freqs[i]);	empty = false;	}	}	if (!empty) {	throw new exception();	}	
checkempty suceeded 

========================= mono sample_108 =========================

static int f (int a) {	
test f from delegate 

static void async_callback (iasyncresult ar) {	
async callback 

int fin = 0;	iasyncresult ar1 = d.begininvoke (1, ac, state1);	iasyncresult ar2 = d.begininvoke (2, ac, state2);	iasyncresult ar3 = d.begininvoke (3, ac, state3);	iasyncresult ar4 = d.begininvoke (4, ac, state4);	int res = d.endinvoke (ar1);	console.writeline ("result = " + res);	try {	d.endinvoke (ar1);	} catch (invalidoperationexception) {	
cant execute endinvoke twice ok 

========================= mono sample_299 =========================

public void foo () {	
foo 

========================= mono sample_2887 =========================

_debug = false;	try {	string debugstring = _store.readstring();	_debug = string.equals("***debug***", debugstring);	}	catch(ioexception) {	}	catch(outofmemoryexception) {	}	if (_debug) {	
resourcereader is looking at a debuggable resources file version 

========================= mono sample_9322 =========================

var r1 = d.foo (3);	if (r1 != 7) return 1;	d.foo (2);	d.foo = (action) (() => console.writeline ("action"));	d.foo ();	d.foo = (d) ((ref int l) => { l = 9; return 4; });	int ref_value = 3;	var r2 = d.foo (ref ref_value);	if (r2 != 4) return 2;	if (ref_value != 9) return 3;	
ok 

========================= mono sample_2825 =========================

public static void assemblefile (string file, string listing, string target, string output) {	if (quiet) return;	
assembling to 

========================= mono sample_36263 =========================

public static long? staticmethodtobeclosedovernull (object o, long? bar) {	
o 

public virtual void mymethod() {	
base method 

========================= mono sample_27286 =========================

public void dumpbuckets (dictionary<string, dictionary<string, builditemgroup>> buckets) {	foreach (keyvaluepair<string, dictionary<string, builditemgroup>> pair in buckets) {	
bucket 

========================= mono sample_29145 =========================

public void testdispatcheroponthread () {	thread t = new thread (new threadstart (thread));	dispatcher d = dispatcher.currentdispatcher;	t.start ();	op = dispatcher.currentdispatcher.begininvoke (dispatcherpriority.normal, (action) delegate {	
some methods 

public void testdispatcherorder () {	dispatcher d = dispatcher.currentdispatcher;	dispatcherframe frame = new dispatcherframe ();	bool fail = true;	int next = 1;	d.begininvoke (dispatcherpriority.normal, (action) delegate {	if (next != 3) throw new exception ("expected state 3, got " + next.tostring ());	next = 4;	
first 

dispatcherframe frame = new dispatcherframe ();	bool fail = true;	int next = 1;	d.begininvoke (dispatcherpriority.normal, (action) delegate {	if (next != 3) throw new exception ("expected state 3, got " + next.tostring ());	next = 4;	});	d.begininvoke (dispatcherpriority.normal, (action) delegate {	if (next != 4) throw new exception ("expected state 4, got " + next.tostring ());	next = 5;	
second 

if (next != 3) throw new exception ("expected state 3, got " + next.tostring ());	next = 4;	});	d.begininvoke (dispatcherpriority.normal, (action) delegate {	if (next != 4) throw new exception ("expected state 4, got " + next.tostring ());	next = 5;	});	d.begininvoke (dispatcherpriority.send, (action) delegate {	if (next != 1) throw new exception ("expected state 1, got " + next.tostring ());	next = 2;	
high priority 

d.begininvoke (dispatcherpriority.normal, (action) delegate {	if (next != 4) throw new exception ("expected state 4, got " + next.tostring ());	next = 5;	});	d.begininvoke (dispatcherpriority.send, (action) delegate {	if (next != 1) throw new exception ("expected state 1, got " + next.tostring ());	next = 2;	d.begininvoke (dispatcherpriority.send, (action) delegate {	if (next != 2) throw new exception ("expected state 2, got " + next.tostring ());	next = 3;	
inserted 

d.begininvoke (dispatcherpriority.send, (action) delegate {	if (next != 1) throw new exception ("expected state 1, got " + next.tostring ());	next = 2;	d.begininvoke (dispatcherpriority.send, (action) delegate {	if (next != 2) throw new exception ("expected state 2, got " + next.tostring ());	next = 3;	});	});	d.begininvoke (dispatcherpriority.systemidle, (action) delegate {	if (next != 6) throw new exception ("expected state 6, got " + next.tostring ());	
idle 

});	});	d.begininvoke (dispatcherpriority.systemidle, (action) delegate {	if (next != 6) throw new exception ("expected state 6, got " + next.tostring ());	frame.continue = false;	fail = false;	});	d.begininvoke (dispatcherpriority.normal, (action) delegate {	if (next != 5) throw new exception ("expected state 5, got " + next.tostring ());	next = 6;	
last normal 

========================= mono sample_21355 =========================

static void main(string[] args) {	try {	system.configuration.configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	configurationsection connstrings = config.connectionstrings;	console.writeline ("connstrings[localsqlserver] = {0}", ((connectionstringssection)connstrings).connectionstrings["localsqlserver"]);	connstrings.sectioninformation.protectsection (protectedconfiguration.defaultprovider);	connstrings.sectioninformation.forcesave = true;	config.saveas ("t26.exe.config", configurationsavemode.full);	if (connstrings.sectioninformation.isprotected == true) console.writeline ("section {0} is now protected by {1}", connstrings.sectioninformation.name, connstrings.sectioninformation.protectionprovider.name);	
section is not protected 

try {	system.configuration.configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	configurationsection connstrings = config.connectionstrings;	console.writeline ("connstrings[localsqlserver] = {0}", ((connectionstringssection)connstrings).connectionstrings["localsqlserver"]);	connstrings.sectioninformation.protectsection (protectedconfiguration.defaultprovider);	connstrings.sectioninformation.forcesave = true;	config.saveas ("t26.exe.config", configurationsavemode.full);	if (connstrings.sectioninformation.isprotected == true) console.writeline ("section {0} is now protected by {1}", connstrings.sectioninformation.name, connstrings.sectioninformation.protectionprovider.name);	}	catch (exception e) {	
raised 

========================= mono sample_29848 =========================

public void add (int x) {	
incorrect method called 

public void add (double x) {	
calling the derived class with double excellent 

========================= mono sample_3215 =========================

readparameters (args);	if (logo) writelogo ();	if (args.length == 0 || args[0] == "--help") {	writehelp ();	return;	}	if (url == null) throw new exception ("url to discover not provided");	prot.discoverany (url);	prot.resolveall ();	if (prot.references.count > 0) {	
disco found documents at the following urls 

prot.discoverany (url);	prot.resolveall ();	if (prot.references.count > 0) {	foreach (discoveryreference refe in prot.references.values) {	if (refe is contractreference) console.write ("- wsdl document at  ");	else if (refe is discoverydocumentreference) console.write ("- disco document at ");	else console.write ("- xml schema at    ");	console.writeline (refe.url);	}	}	
disco didn t find any document at the specified url 

foreach (discoveryreference refe in prot.references.values) {	if (refe is contractreference) console.write ("- wsdl document at  ");	else if (refe is discoverydocumentreference) console.write ("- disco document at ");	else console.write ("- xml schema at    ");	console.writeline (refe.url);	}	}	if (save) {	discoveryclientresultcollection col = prot.writeall (directory, "results.discomap");	console.writeline ();	
the following files hold the content found at the corresponding urls 

else if (refe is discoverydocumentreference) console.write ("- disco document at ");	else console.write ("- xml schema at    ");	console.writeline (refe.url);	}	}	if (save) {	discoveryclientresultcollection col = prot.writeall (directory, "results.discomap");	console.writeline ();	foreach (discoveryclientresult res in col) console.writeline ("- " + res.filename + " <- " + res.url);	console.writeline ();	
the file results discomap holds links to each of there files 

}	if (save) {	discoveryclientresultcollection col = prot.writeall (directory, "results.discomap");	console.writeline ();	foreach (discoveryclientresult res in col) console.writeline ("- " + res.filename + " <- " + res.url);	console.writeline ();	console.writeline ();	}	}	catch (exception ex) {	
error 

static void writelogo () {	
mono web service discovery tool 

static void writehelp () {	
usage disco options url 

static void writehelp () {	console.writeline ();	
options 

static void writehelp () {	console.writeline ();	
nologo supress the startup logo 

static void writehelp () {	console.writeline ();	
nosave do not save the discovered documents to disk 

static void writehelp () {	console.writeline ();	
the default is to save the documents 

static void writehelp () {	console.writeline ();	
o out directory the directory where to save the discovered documents 

static void writehelp () {	console.writeline ();	
by default documents are saved in the current 

static void writehelp () {	console.writeline ();	
directory 

static void writehelp () {	console.writeline ();	
u username username 

static void writehelp () {	console.writeline ();	
p password password 

static void writehelp () {	console.writeline ();	
d domain domain the credentials to use when connecting to the server 

static void writehelp () {	console.writeline ();	
proxy url the url of the proxy server to use for http requests 

static void writehelp () {	console.writeline ();	
proxyusername name 

static void writehelp () {	console.writeline ();	
proxypassword pwd 

static void writehelp () {	console.writeline ();	
proxydomin domain the credentials to use when connection to the proxy 

========================= mono sample_1190 =========================

public static void main () {	try {	configuration c = configurationmanager.openexeconfiguration ( configurationuserlevel.none);	applicationsettingsgroup g = c.sectiongroups ["applicationsettings"]	as applicationsettingsgroup;	configurationsection s = g.sections ["test.properties.settings"];	
requirepermission 

========================= mono sample_29819 =========================

public delegate int doit(int a, int b, int c, doit d);	internal class repro {	private int doitwrong(int a, int b, int c, doit d) {	
failed 

public delegate int doit(int a, int b, int c, doit d);	internal class repro {	private int doitwrong(int a, int b, int c, doit d) {	return -1;	}	private int doitright(int a, int b, int c, doit d) {	
pass 

public delegate int doit(int a, int b, int c, doit d);	internal class repro {	private int doitwrong(int a, int b, int c, doit d) {	return -1;	}	private int doitright(int a, int b, int c, doit d) {	return 100;	}	private int accomplice(int a, int b, int c, doit d) {	
accomplice 

========================= mono sample_732 =========================

public static int main () {	constructorinfo mi = typeof(t).getconstructors ()[0];	methodbody mb = mi.getmethodbody();	if (mb.getilasbytearray ().length > 90) {	
optimization failed 

========================= mono sample_2128 =========================

if (s != "{x+y}") return 10;	s = $"{ $"{ res }" }";	if (s != "5") return 11;	s = $" \u004d ";	if (s != " m ") return 12;	byte b = 3;	s = $"b = {(int)b}";	if (s != "b = 3") return 13;	s = $"{{fo!o = {res}}}";	if (s != "{fo!o = 5}") return 14;	
ok 

========================= mono sample_3126 =========================

public void dump (textwriter tw) {	this.egraph.dump (tw);	
unmodified locations 

public void dump (textwriter tw) {	this.egraph.dump (tw);	foreach (symvalue sv in this.unmodifiedsinceentry.elements) tw.write ("{0} ", sv);	tw.writeline ();	
unmodified locations for fields 

public void dump (textwriter tw) {	this.egraph.dump (tw);	foreach (symvalue sv in this.unmodifiedsinceentry.elements) tw.write ("{0} ", sv);	tw.writeline ();	foreach (symvalue sv in this.unmodifiedfieldssinceentry.elements) tw.write ("{0} ", sv);	tw.writeline ();	if (this.modifiedatcall != null) {	
modified locations at last call 

this.egraph.dump (tw);	foreach (symvalue sv in this.unmodifiedsinceentry.elements) tw.write ("{0} ", sv);	tw.writeline ();	foreach (symvalue sv in this.unmodifiedfieldssinceentry.elements) tw.write ("{0} ", sv);	tw.writeline ();	if (this.modifiedatcall != null) {	foreach (symvalue sv in this.modifiedatcall.elements) tw.write ("{0} ", sv);	tw.writeline ();	}	if (olddomain == null) return;	
has old domain 

foreach (symvalue sv in this.unmodifiedsinceentry.elements) tw.write ("{0} ", sv);	tw.writeline ();	foreach (symvalue sv in this.unmodifiedfieldssinceentry.elements) tw.write ("{0} ", sv);	tw.writeline ();	if (this.modifiedatcall != null) {	foreach (symvalue sv in this.modifiedatcall.elements) tw.write ("{0} ", sv);	tw.writeline ();	}	if (olddomain == null) return;	olddomain.egraph.dump (tw);	
end old domain 

bool unmodifiedsinceentrycontains = domain.unmodifiedsinceentry.containssafe (symvalue1);	bool modifiedatcallcontains = domain.modifiedatcall.containssafe (symvalue1);	if (unmodifiedsinceentrycontains) {	if (that.unmodifiedsinceentry.containssafe (symvalue2)) resultunmodifiedsinceentry = resultunmodifiedsinceentry.add (elem);	else if (that.unmodifiedfieldssinceentry.containssafe (symvalue2)) resultunmodifiedfieldssinceentry = resultunmodifiedfieldssinceentry.add (elem);	}	if (modifiedatcallcontains) resultmodifiedatcall = resultmodifiedatcall.add (elem);	}	if (that.unmodifiedsinceentry.count () > resultunmodifiedsinceentry.count ()) {	weaker = true;	
result changed due to fewer unmodified locations since entry 

if (that.unmodifiedsinceentry.containssafe (symvalue2)) resultunmodifiedsinceentry = resultunmodifiedsinceentry.add (elem);	else if (that.unmodifiedfieldssinceentry.containssafe (symvalue2)) resultunmodifiedfieldssinceentry = resultunmodifiedfieldssinceentry.add (elem);	}	if (modifiedatcallcontains) resultmodifiedatcall = resultmodifiedatcall.add (elem);	}	if (that.unmodifiedsinceentry.count () > resultunmodifiedsinceentry.count ()) {	weaker = true;	} else {	if (that.unmodifiedfieldssinceentry.count () > resultunmodifiedfieldssinceentry.count ()) {	weaker = true;	
result changed due to fewer unmodified locations for fields since entry 

========================= mono sample_29538 =========================

static int main (string [] args) {	int n = (args.length / 3);	if ((args.length > 0) && ((args.length % 3) != 0)) {	
usage mono hashwrap exe classname basename wraparound 

========================= mono sample_18230 =========================

static void f1 () {	v += 1;	
test 

static void f2 () {	v += 2;	
test 

static void f4 () {	v += 4;	
test 

static void f8 () {	v += 8;	
test 

========================= mono sample_450 =========================

static void main () {	tinyhost h = createhost ();	streamwriter w = new streamwriter ("page.aspx");	w.writeline (@"<%@ page language=""c#"" %>");	
console writeline hello 

========================= mono sample_541 =========================

static extern string mono_path_canonicalize (string input);	static void canonicalizeassert (string input, string expected) {	string actual = mono_path_canonicalize (input);	if (expected != actual) {	failure = true;	
error expected canonicalization of to be but it was 

========================= mono sample_706 =========================

const long l = -9223372036854775808;	const long l2 = -uint.maxvalue;	const e1 e = (e1)~e2.a;	unchecked {	if (-int.minvalue != int.minvalue) return 1;	}	int b = -lm;	if (b != -22) return 2;	uint ua = 2;	if (-ua != -2) return 3;	
ok 

========================= mono sample_3330 =========================

public static void test (int a, out float f) {	do {	if (a == 8) {	
hello 

========================= mono sample_35721 =========================

public static void main () {	bitmap bmp = new bitmap (600, 500);	graphics dc = graphics.fromimage (bmp);	rectanglef[] rects = dc.clip.getregionscans (new matrix());	for (int i = 0; i < rects.getlength(0); i++) console.writeline ("clip: " + rects[i].tostring());	
visibleclipbounds 

public static void main () {	bitmap bmp = new bitmap (600, 500);	graphics dc = graphics.fromimage (bmp);	rectanglef[] rects = dc.clip.getregionscans (new matrix());	for (int i = 0; i < rects.getlength(0); i++) console.writeline ("clip: " + rects[i].tostring());	
isvisible point 

public static void main () {	bitmap bmp = new bitmap (600, 500);	graphics dc = graphics.fromimage (bmp);	rectanglef[] rects = dc.clip.getregionscans (new matrix());	for (int i = 0; i < rects.getlength(0); i++) console.writeline ("clip: " + rects[i].tostring());	
isvisible point 

public static void main () {	bitmap bmp = new bitmap (600, 500);	graphics dc = graphics.fromimage (bmp);	rectanglef[] rects = dc.clip.getregionscans (new matrix());	for (int i = 0; i < rects.getlength(0); i++) console.writeline ("clip: " + rects[i].tostring());	
isvisible rectangle 

public static void main () {	bitmap bmp = new bitmap (600, 500);	graphics dc = graphics.fromimage (bmp);	rectanglef[] rects = dc.clip.getregionscans (new matrix());	for (int i = 0; i < rects.getlength(0); i++) console.writeline ("clip: " + rects[i].tostring());	
isvisible rectangle 

========================= mono sample_21330 =========================

{ "h|help", "show this help", v => showhelp = true }, { "d|diff=", "html diff file out output (omit for stdout)", v => diff = v }, { "i|ignore=", "ignore new, added, and removed members whose description matches a given c# regular expression (see below).", v => {	var r = new regex (v);	state.ignoreadded.add (r);	state.ignoreremoved.add (r);	state.ignorenew.add (r);	}	}, { "a|ignore-added=", "ignore added members whose description matches a given c# regular expression (see below).", v => state.ignoreadded.add (new regex (v)) }, { "r|ignore-removed=", "ignore removed members whose description matches a given c# regular expression (see below).", v => state.ignoreremoved.add (new regex (v)) }, { "n|ignore-new=", "ignore new namespaces and types whose description matches a given c# regular expression (see below).", v => state.ignorenew.add (new regex (v)) }, { "ignore-changes-parameter-names", "ignore changes to parameter names for identically prototyped methods.", v => state.ignoreparameternamechanges   = v != null }, { "ignore-changes-property-setters", "ignore adding setters to properties.", v => state.ignoreaddedpropertysetters = v != null }, { "ignore-changes-virtual", "ignore changing non-`virtual` to `virtual` or adding `override`.", v => state.ignorevirtualchanges = v != null }, { "c|colorize:", "colorize html output", v => state.colorize = string.isnullorempty (v) ? true : bool.parse (v) }, { "x|lax", "ignore duplicate xml entries", v => state.lax = true }, { "ignore-nonbreaking", "ignore all nonbreaking changes", v => state.ignorenonbreaking = true }, { "v|verbose:", "verbosity level; when set, will print debug messages", (int? v) => state.verbosity = v ?? (state.verbosity + 1)}, new responsefilesource (), };	try {	extra = options.parse (args);	} catch (optionexception e) {	
option error 

} catch (optionexception e) {	showhelp = true;	}	if (state.ignorenonbreaking) {	state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	
usage mono api html options reference xml assembly xml diff html 

showhelp = true;	}	if (state.ignorenonbreaking) {	state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	
available options 

if (state.ignorenonbreaking) {	state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	
ignoring members 

state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	
members that were added can be filtered out of the diff by using the 

state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	
i ignore added option the option takes a c regular expression 

state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	
to match against member descriptions for example to ignore the 

state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	
introduction of the interfaces inscopying and inscoding on types 

state.ignoreaddedpropertysetters = true;	state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	
pass the following to mono api html 

state.ignorevirtualchanges = true;	state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	console.writeline ();	
mono api html i inscopying i inscoding 

state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
the regular expressions will match any member description ending with 

state.ignorenew.add (new regex (".*"));	state.ignoreadded.add (new regex (".*"));	}	if (showhelp || extra == null || extra.count < 2 || extra.count > 3) {	console.writeline ();	options.writeoptiondescriptions (console.out);	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
inscopying or inscoding 

var ac = new assemblycomparer (input, output);	if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	
div 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
style scoped 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
obsolete color gray 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
added color green 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
removed inline text decoration line through 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
removed breaking inline color red 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
added breaking inline text decoration underline 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
nonbreaking color black 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
breaking color red 

if (diff != null) {	string diffhtml = string.empty;	using (var writer = new stringwriter ()) {	state.output = writer;	ac.compare ();	diffhtml = state.output.tostring ();	}	if (diffhtml.length > 0) {	using (var file = new streamwriter (diff)) {	if (state.colorize) {	
style 

var el = elements [i];	el.style.display = el.getattribute ('data-original-display');	}	var links = document.getelementsbyclassname ('hide-nonbreaking');	for (i = 0; i < links.length; i++) links [i].style.display = '';	links = document.getelementsbyclassname ('restore-nonbreaking');	for (i = 0; i < links.length; i++) links [i].style.display = 'none';	}	</script>");	if (ac.sourceassembly == ac.targetassembly) {	
dll 

el.style.display = el.getattribute ('data-original-display');	}	var links = document.getelementsbyclassname ('hide-nonbreaking');	for (i = 0; i < links.length; i++) links [i].style.display = '';	links = document.getelementsbyclassname ('restore-nonbreaking');	for (i = 0; i < links.length; i++) links [i].style.display = 'none';	}	</script>");	if (ac.sourceassembly == ac.targetassembly) {	} else {	
dll vs dll 

links = document.getelementsbyclassname ('restore-nonbreaking');	for (i = 0; i < links.length; i++) links [i].style.display = 'none';	}	</script>");	if (ac.sourceassembly == ac.targetassembly) {	} else {	}	if (!state.ignorenonbreaking) {	file.writeline ("<a href='javascript: hidenonbreakingchanges (); ' class='hide-nonbreaking'>hide non-breaking changes</a>");	file.writeline ("<a href='javascript: shownonbreakingchanges (); ' class='restore-nonbreaking' style='display: none;'>show non-breaking changes</a>");	
br 

for (i = 0; i < links.length; i++) links [i].style.display = 'none';	}	</script>");	if (ac.sourceassembly == ac.targetassembly) {	} else {	}	if (!state.ignorenonbreaking) {	file.writeline ("<a href='javascript: hidenonbreakingchanges (); ' class='hide-nonbreaking'>hide non-breaking changes</a>");	file.writeline ("<a href='javascript: shownonbreakingchanges (); ' class='restore-nonbreaking' style='display: none;'>show non-breaking changes</a>");	}	
div data is topmost 

}	</script>");	if (ac.sourceassembly == ac.targetassembly) {	} else {	}	if (!state.ignorenonbreaking) {	file.writeline ("<a href='javascript: hidenonbreakingchanges (); ' class='hide-nonbreaking'>hide non-breaking changes</a>");	file.writeline ("<a href='javascript: shownonbreakingchanges (); ' class='restore-nonbreaking' style='display: none;'>show non-breaking changes</a>");	}	file.write (diffhtml);	
div end topmost div 

}	</script>");	if (ac.sourceassembly == ac.targetassembly) {	} else {	}	if (!state.ignorenonbreaking) {	file.writeline ("<a href='javascript: hidenonbreakingchanges (); ' class='hide-nonbreaking'>hide non-breaking changes</a>");	file.writeline ("<a href='javascript: shownonbreakingchanges (); ' class='restore-nonbreaking' style='display: none;'>show non-breaking changes</a>");	}	file.write (diffhtml);	
div 

========================= mono sample_1324 =========================

public static int main () {	x x = new x();	x.m ();	e ();	console.writeline ("j should be 101= {0}", j);	if (j != 101) return 3;	
ok 

========================= mono sample_3221 =========================

static void main (string [] args) {	if (args.length != 1) usage ();	var asm = args [0];	if (!file.exists (asm)) usage ();	try {	converter.convert (asm);	} catch (filenotfoundexception ex) {	usage ();	} catch (portablepdbnotsupportedexception) {	
error a portable pdb can t be converted to mdb 

static void usage () {	
mono pdb to mdb debug symbol store converter 

static void usage () {	
usage assembly 

static void error (exception e) {	
fatal error 

========================= mono sample_1264 =========================

sqlcommand cmd = null;	string connectionstring = null;	string sql = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	try {	string maxstrvalue;	con = new sqlconnection(connectionstring);	con.open();	sql = 	"select count(*) " + "from sometable";	cmd = new sqlcommand(sql,con);	
executing 

string connectionstring = null;	string sql = null;	connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	try {	string maxstrvalue;	con = new sqlconnection(connectionstring);	con.open();	sql = 	"select count(*) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 rowcount = (int64) cmd.executescalar();	
row count 

connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	try {	string maxstrvalue;	con = new sqlconnection(connectionstring);	con.open();	sql = 	"select count(*) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 rowcount = (int64) cmd.executescalar();	sql = 	"select max(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	
executing 

try {	string maxstrvalue;	con = new sqlconnection(connectionstring);	con.open();	sql = 	"select count(*) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 rowcount = (int64) cmd.executescalar();	sql = 	"select max(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	string minvalue = (string) cmd.executescalar();	
max value 

con = new sqlconnection(connectionstring);	con.open();	sql = 	"select count(*) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 rowcount = (int64) cmd.executescalar();	sql = 	"select max(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	string minvalue = (string) cmd.executescalar();	sql = 	"select min(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	
executing 

con.open();	sql = 	"select count(*) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 rowcount = (int64) cmd.executescalar();	sql = 	"select max(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	string minvalue = (string) cmd.executescalar();	sql = 	"select min(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	maxstrvalue = (string) cmd.executescalar();	
max value 

cmd = new sqlcommand(sql,con);	int64 rowcount = (int64) cmd.executescalar();	sql = 	"select max(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	string minvalue = (string) cmd.executescalar();	sql = 	"select min(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	maxstrvalue = (string) cmd.executescalar();	sql = 	"select min(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	
executing 

int64 rowcount = (int64) cmd.executescalar();	sql = 	"select max(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	string minvalue = (string) cmd.executescalar();	sql = 	"select min(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	maxstrvalue = (string) cmd.executescalar();	sql = 	"select min(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int maxintvalue = (int) cmd.executescalar();	
max value 

cmd = new sqlcommand(sql,con);	string minvalue = (string) cmd.executescalar();	sql = 	"select min(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	maxstrvalue = (string) cmd.executescalar();	sql = 	"select min(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int maxintvalue = (int) cmd.executescalar();	sql = 	"select avg(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	
executing 

string minvalue = (string) cmd.executescalar();	sql = 	"select min(tdesc) " + "from sometable";	cmd = new sqlcommand(sql,con);	maxstrvalue = (string) cmd.executescalar();	sql = 	"select min(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int maxintvalue = (int) cmd.executescalar();	sql = 	"select avg(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	decimal avgdecvalue = (decimal) cmd.executescalar();	
max value 

cmd = new sqlcommand(sql,con);	maxstrvalue = (string) cmd.executescalar();	sql = 	"select min(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int maxintvalue = (int) cmd.executescalar();	sql = 	"select avg(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	decimal avgdecvalue = (decimal) cmd.executescalar();	sql = 	"select sum(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	
executing 

maxstrvalue = (string) cmd.executescalar();	sql = 	"select min(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int maxintvalue = (int) cmd.executescalar();	sql = 	"select avg(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	decimal avgdecvalue = (decimal) cmd.executescalar();	sql = 	"select sum(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 summed = (int64) cmd.executescalar();	
max value 

cmd = new sqlcommand(sql,con);	int maxintvalue = (int) cmd.executescalar();	sql = 	"select avg(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	decimal avgdecvalue = (decimal) cmd.executescalar();	sql = 	"select sum(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 summed = (int64) cmd.executescalar();	sql = 	"insert into sometable " + "(tid,tdesc,aint4,atimestamp) " + "values('qqq','www',234,null)";	cmd = new sqlcommand(sql,con);	
executing 

sql = 	"select avg(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	decimal avgdecvalue = (decimal) cmd.executescalar();	sql = 	"select sum(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 summed = (int64) cmd.executescalar();	sql = 	"insert into sometable " + "(tid,tdesc,aint4,atimestamp) " + "values('qqq','www',234,null)";	cmd = new sqlcommand(sql,con);	object objresult1 = cmd.executescalar();	if(objresult1 == null) console.writeline("result is null. (correct)");	
result is not null not correct 

decimal avgdecvalue = (decimal) cmd.executescalar();	sql = 	"select sum(aint4) " + "from sometable";	cmd = new sqlcommand(sql,con);	int64 summed = (int64) cmd.executescalar();	sql = 	"insert into sometable " + "(tid,tdesc,aint4,atimestamp) " + "values('qqq','www',234,null)";	cmd = new sqlcommand(sql,con);	object objresult1 = cmd.executescalar();	if(objresult1 == null) console.writeline("result is null. (correct)");	sql = 	"set datestyle to 'iso'";	cmd = new sqlcommand(sql,con);	
executing 

cmd = new sqlcommand(sql,con);	int64 summed = (int64) cmd.executescalar();	sql = 	"insert into sometable " + "(tid,tdesc,aint4,atimestamp) " + "values('qqq','www',234,null)";	cmd = new sqlcommand(sql,con);	object objresult1 = cmd.executescalar();	if(objresult1 == null) console.writeline("result is null. (correct)");	sql = 	"set datestyle to 'iso'";	cmd = new sqlcommand(sql,con);	object objresult2 = cmd.executescalar();	if(objresult2 == null) console.writeline("result is null. (correct)");	
result is not null not correct 

========================= mono sample_28413 =========================

public static void main() {	environment.exitcode = 1;	thread thr=new thread(new threadstart(foo.thread));	thr.start();	thread.sleep(1200);	
main thread returns 

public static void thread() {	
thread running 

public static void thread() {	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	
thread running 

========================= mono sample_586 =========================

static int main (string[] args) {	int res = 0;	foreach (string s in args) {	res += convert.toint32 (s);	}	
appdomain client exe sum 

========================= mono sample_575 =========================

image = resourceimageloader.get (fullname);	if (image != null){	respool.adduiimage (image, name, width);	return image;	}	}	image = resourceimageloader.get (name);	if (image == null) return null;	respool.adduiimage (image, name, 0);	if (image.width != width && width != 0){	
warning requesting icon that not been tuned 

========================= mono sample_25898 =========================

public override void cleanup () {	base.cleanup ();	stringbuilder aliases = new stringbuilder ();	var src_dir = path.combine ("projects", "monotouch");	string src_file = path.combine (src_dir, "tests.cs");	using (var file = new streamwriter (src_file, false)) {	foreach (var e in entries) {	
extern alias 

foreach (var e in entries) {	aliases.appendformat ("    <reference include=\"{0}\">", path.getfilenamewithoutextension (e.referencefile));	aliases.append (environment.newline);	aliases.appendformat ("      <aliases>{0}</aliases>", e.name);	aliases.append (environment.newline);	aliases.appendformat ("      <hintpath>..\\..\\{0}</hintpath>", path.getfilename (e.referencefile));	aliases.append (environment.newline);	aliases.appendline ("    </reference>");	}	file.writeline ();	
using nunit framework 

aliases.appendformat ("    <reference include=\"{0}\">", path.getfilenamewithoutextension (e.referencefile));	aliases.append (environment.newline);	aliases.appendformat ("      <aliases>{0}</aliases>", e.name);	aliases.append (environment.newline);	aliases.appendformat ("      <hintpath>..\\..\\{0}</hintpath>", path.getfilename (e.referencefile));	aliases.append (environment.newline);	aliases.appendline ("    </reference>");	}	file.writeline ();	file.writeline ();	
testfixture 

aliases.appendformat ("    <reference include=\"{0}\">", path.getfilenamewithoutextension (e.referencefile));	aliases.append (environment.newline);	aliases.appendformat ("      <aliases>{0}</aliases>", e.name);	aliases.append (environment.newline);	aliases.appendformat ("      <hintpath>..\\..\\{0}</hintpath>", path.getfilename (e.referencefile));	aliases.append (environment.newline);	aliases.appendline ("    </reference>");	}	file.writeline ();	file.writeline ();	
public class tests 

aliases.append (environment.newline);	aliases.appendformat ("      <aliases>{0}</aliases>", e.name);	aliases.append (environment.newline);	aliases.appendformat ("      <hintpath>..\\..\\{0}</hintpath>", path.getfilename (e.referencefile));	aliases.append (environment.newline);	aliases.appendline ("    </reference>");	}	file.writeline ();	file.writeline ();	foreach (var e in entries) {	
test 

aliases.append (environment.newline);	aliases.appendformat ("      <aliases>{0}</aliases>", e.name);	aliases.append (environment.newline);	aliases.appendformat ("      <hintpath>..\\..\\{0}</hintpath>", path.getfilename (e.referencefile));	aliases.append (environment.newline);	aliases.appendline ("    </reference>");	}	file.writeline ();	file.writeline ();	foreach (var e in entries) {	
public void testfile 

usage ();	return 0;	}	string compiler;	if (!getoption ("compiler", args, true, out compiler)) {	usage ();	return 1;	}	itester tester;	try {	
loading 

}	string compiler;	if (!getoption ("compiler", args, true, out compiler)) {	usage ();	return 1;	}	itester tester;	try {	tester = new reflectiontester (assembly.loadfile (compiler));	} catch (exception) {	
switching to command line mode compiler entry point was not found 

string compiler;	if (!getoption ("compiler", args, true, out compiler)) {	usage ();	return 1;	}	itester tester;	try {	tester = new reflectiontester (assembly.loadfile (compiler));	} catch (exception) {	if (!file.exists (compiler)) {	
error tested compiler was not found 

getoption ("il", args, false, out iltest);	checker = new positivechecker (tester, iltest);	positive = true;	if (iltest != null && getoption ("update-il", args, false, out temp)) {	((positivechecker) checker).updateverificationdatafile = true;	}	break;	case "nunit": positive = true;	checker = new nunitchecker (tester);	break;	
invalid mode argument 

case "v1": files.addrange (directory.getfiles (".", positive ? "test*.cs" : "cs*.cs"));	break;	case "v2": files.addrange (directory.getfiles (".", positive ? "gtest*.cs" : "gcs*.cs"));	goto case "v1";	case "v4": files.addrange (directory.getfiles (".", positive ? "dtest*.cs" : "dcs*.cs"));	goto case "v2";	default: files.addrange (directory.getfiles (".", test_pattern));	break;	}	if (files.count == 0) {	
no files matching found 

static bool getoption (string opt, string[] args, bool req_arg, out string value) {	opt = "-" + opt;	foreach (string a in args) {	if (a.startswith (opt)) {	int sep = a.indexof (':');	if (sep > 0) {	value = a.substring (sep + 1);	} else {	value = null;	if (req_arg) {	
missing argument in option 

static void usage () {	
mono compiler tester c novell inc compiler tester mode pos neg compiler file files file list options compiler file the file which will be used to compiler tests compiler options options add global compiler options il il file xml file with expected il details for each test issues file the list of expected failures log file writes any output also to the file help lists all options mode pos neg specifies compiler test mode safe execution runs compiled executables in separate app domain update il updates il file to match compiler output verbose prints more details during testing 

========================= mono sample_1297 =========================

public static int mm () {	object[] attrs = typeof (foo).getcustomattributes (typeof(mineattribute), true);	mineattribute ma = (mineattribute) attrs [0];	if (ma.types [0] != typeof (int)){	
failed 

public static int mm () {	object[] attrs = typeof (foo).getcustomattributes (typeof(mineattribute), true);	mineattribute ma = (mineattribute) attrs [0];	if (ma.types [0] != typeof (int)){	return 1;	}	if (ma.types [1] != typeof (string)){	
failed 

public static int mm () {	object[] attrs = typeof (foo).getcustomattributes (typeof(mineattribute), true);	mineattribute ma = (mineattribute) attrs [0];	if (ma.types [0] != typeof (int)){	return 1;	}	if (ma.types [1] != typeof (string)){	return 2;	}	if (ma.types [2] != typeof (object [])){	
failed 

mineattribute ma = (mineattribute) attrs [0];	if (ma.types [0] != typeof (int)){	return 1;	}	if (ma.types [1] != typeof (string)){	return 2;	}	if (ma.types [2] != typeof (object [])){	return 3;	}	
ok 

========================= mono sample_3003 =========================

static void function () {	
delegate method 

static void async_callback (iasyncresult ar) {	
async callback 

public static void main () {	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	d.endinvoke(ar1);	thread.sleep(1000);	
main returns 

========================= mono sample_524 =========================

public static void main(string[] args) {	parsecommandlineargs(args);	console.writeline();	
parsing mono s source code 

static void parsecommandlineargs(string[] args) {	var needsargs = string.isnullorwhitespace(compilationdatabasepath);	if (!needsargs) return;	if (args.length >= 1) compilationdatabasepath = path.getfullpath(args[0]);	else compilationdatabasepath = "compile_commands.json";	if (!file.exists(compilationdatabasepath)) {	
could not find json compilation database 

========================= mono sample_6 =========================

static void dogenericstuff () {	
doing generic stuff 

static void doothergenericstuff () {	
doing other generic stuff 

========================= mono sample_474 =========================

static void main (string[] args) {	if (args.length != 2) {	
expected usage 

static void main (string[] args) {	if (args.length != 2) {	
mono nunitreport exe input directory output file 

dictionary<string, failedtest> failed_tests = new dictionary<string,failedtest> ();	list<string> ignored_tests = new list<string> ();	int tests_passed = populatefailuretable (file, failed_tests, ignored_tests);	fail_total += failed_tests.count;	pass_total += tests_passed;	run_total += failed_tests.count + tests_passed;	if (failed_tests.count > 0) {	sw.writeline ("        <tr class='errorrow' onclick=\"toggle('el{0}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly);	sw.writeline (@"            <td><img src='media/fail.png' /></td>");	} else {	
tr 

int tests_passed = populatefailuretable (file, failed_tests, ignored_tests);	fail_total += failed_tests.count;	pass_total += tests_passed;	run_total += failed_tests.count + tests_passed;	if (failed_tests.count > 0) {	sw.writeline ("        <tr class='errorrow' onclick=\"toggle('el{0}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly);	sw.writeline (@"            <td><img src='media/fail.png' /></td>");	} else {	sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	
td td 

int tests_passed = populatefailuretable (file, failed_tests, ignored_tests);	fail_total += failed_tests.count;	pass_total += tests_passed;	run_total += failed_tests.count + tests_passed;	if (failed_tests.count > 0) {	sw.writeline ("        <tr class='errorrow' onclick=\"toggle('el{0}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly);	sw.writeline (@"            <td><img src='media/fail.png' /></td>");	} else {	sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	
td td 

int tests_passed = populatefailuretable (file, failed_tests, ignored_tests);	fail_total += failed_tests.count;	pass_total += tests_passed;	run_total += failed_tests.count + tests_passed;	if (failed_tests.count > 0) {	sw.writeline ("        <tr class='errorrow' onclick=\"toggle('el{0}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly);	sw.writeline (@"            <td><img src='media/fail.png' /></td>");	} else {	sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	
td td 

int tests_passed = populatefailuretable (file, failed_tests, ignored_tests);	fail_total += failed_tests.count;	pass_total += tests_passed;	run_total += failed_tests.count + tests_passed;	if (failed_tests.count > 0) {	sw.writeline ("        <tr class='errorrow' onclick=\"toggle('el{0}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly);	sw.writeline (@"            <td><img src='media/fail.png' /></td>");	} else {	sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	
td td 

int tests_passed = populatefailuretable (file, failed_tests, ignored_tests);	fail_total += failed_tests.count;	pass_total += tests_passed;	run_total += failed_tests.count + tests_passed;	if (failed_tests.count > 0) {	sw.writeline ("        <tr class='errorrow' onclick=\"toggle('el{0}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly);	sw.writeline (@"            <td><img src='media/fail.png' /></td>");	} else {	sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	
tr 

pass_total += tests_passed;	run_total += failed_tests.count + tests_passed;	if (failed_tests.count > 0) {	sw.writeline ("        <tr class='errorrow' onclick=\"toggle('el{0}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly);	sw.writeline (@"            <td><img src='media/fail.png' /></td>");	} else {	sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	
td td 

sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	
td td 

sw.writeline (@"            <td><img src='media/pass.png' /></td>");	}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	
tr 

}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	
td td 

}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	
td 

}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	
br 

}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	
br br strong stacktrace strong br br 

}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	
td 

}	if (failed_tests.count == 0) continue;	sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	
tr 

sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	test_num++;	}	
table 

sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	test_num++;	}	
td 

sw.writeline (@"        <tr id='el{0}' class='errorlist' style='display: none'>", assembly);	sw.writeline (@"            <td colspan='4'>");	sw.writeline (@"                <table cellpadding='2' cellspacing='0' width='100%'>");	int test_num = 0;	foreach (failedtest ft in failed_tests.values) {	sw.writeline ("                    <tr onclick=\"toggle('as{0}ed{1}')\" onmouseover='highlight(this)' onmouseout='unhighlight(this)'>", assembly, test_num);	sw.writeline (@"                        <td style='width: 17px'><img src='media/bullet.png' /></td>");	sw.writeline (@"                    <tr id='as{0}ed{1}' class='errordetail' style='display: none'>", assembly, test_num);	test_num++;	}	
tr 

public static void startreport (streamwriter sw) {	sw.writeline (@"<!doctype html public ""- sw.writeline (@"<html xmlns=""http: sw.writeline (@"<title>mono: class libraries nunit test results</title>");	sw.writeline (@"<link rel=""stylesheet"" type=""text/css"" href=""media/style.css"" />");	sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	
body 

public static void startreport (streamwriter sw) {	sw.writeline (@"<!doctype html public ""- sw.writeline (@"<html xmlns=""http: sw.writeline (@"<title>mono: class libraries nunit test results</title>");	sw.writeline (@"<link rel=""stylesheet"" type=""text/css"" href=""media/style.css"" />");	sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	
div 

public static void startreport (streamwriter sw) {	sw.writeline (@"<!doctype html public ""- sw.writeline (@"<html xmlns=""http: sw.writeline (@"<title>mono: class libraries nunit test results</title>");	sw.writeline (@"<link rel=""stylesheet"" type=""text/css"" href=""media/style.css"" />");	sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	
div 

public static void startreport (streamwriter sw) {	sw.writeline (@"<!doctype html public ""- sw.writeline (@"<html xmlns=""http: sw.writeline (@"<title>mono: class libraries nunit test results</title>");	sw.writeline (@"<link rel=""stylesheet"" type=""text/css"" href=""media/style.css"" />");	sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	
generated br 

public static void startreport (streamwriter sw) {	sw.writeline (@"<!doctype html public ""- sw.writeline (@"<html xmlns=""http: sw.writeline (@"<title>mono: class libraries nunit test results</title>");	sw.writeline (@"<link rel=""stylesheet"" type=""text/css"" href=""media/style.css"" />");	sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	
br br 

public static void startreport (streamwriter sw) {	sw.writeline (@"<!doctype html public ""- sw.writeline (@"<html xmlns=""http: sw.writeline (@"<title>mono: class libraries nunit test results</title>");	sw.writeline (@"<link rel=""stylesheet"" type=""text/css"" href=""media/style.css"" />");	sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	
click on failure row for more details br br 

sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	sw.writeline (@"        icons courtesy of <a href='http: sw.writeline (@"    </div>");	sw.writeline (@"    <table cellpadding='2' cellspacing='0' class='maintable'>");	sw.writeline (@"        <tr class='tableheader'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td tested assembly td 

sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	sw.writeline (@"        icons courtesy of <a href='http: sw.writeline (@"    </div>");	sw.writeline (@"    <table cellpadding='2' cellspacing='0' class='maintable'>");	sw.writeline (@"        <tr class='tableheader'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td failed td 

sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	sw.writeline (@"        icons courtesy of <a href='http: sw.writeline (@"    </div>");	sw.writeline (@"    <table cellpadding='2' cellspacing='0' class='maintable'>");	sw.writeline (@"        <tr class='tableheader'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td passed td 

sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	sw.writeline (@"        icons courtesy of <a href='http: sw.writeline (@"    </div>");	sw.writeline (@"    <table cellpadding='2' cellspacing='0' class='maintable'>");	sw.writeline (@"        <tr class='tableheader'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td run td 

sw.writeline (@"<script type=""text/ecmascript"" src=""media/scripts.js""></script></head>");	sw.writeline (@"    <div class='header'>");	sw.writeline (@"        <div class='headerimage'>");	sw.writeline (@"            <img src='media/rupert.png' width='48' height='48' />");	sw.writeline (@"        <div class='headertext'>class libraries nunit test results</div>");	sw.writeline (@"    <div class='legend'>");	sw.writeline (@"        icons courtesy of <a href='http: sw.writeline (@"    </div>");	sw.writeline (@"    <table cellpadding='2' cellspacing='0' class='maintable'>");	sw.writeline (@"        <tr class='tableheader'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
tr 

public static void writetotals (streamwriter sw, int failed, int passed, int run) {	sw.writeline (@"        <tr class='tabletotal'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td totals td 

public static void writetotals (streamwriter sw, int failed, int passed, int run) {	sw.writeline (@"        <tr class='tabletotal'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td td 

public static void writetotals (streamwriter sw, int failed, int passed, int run) {	sw.writeline (@"        <tr class='tabletotal'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td td 

public static void writetotals (streamwriter sw, int failed, int passed, int run) {	sw.writeline (@"        <tr class='tabletotal'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
td td 

public static void writetotals (streamwriter sw, int failed, int passed, int run) {	sw.writeline (@"        <tr class='tabletotal'>");	sw.writeline (@"            <td style='width: 17px'></td>");	
tr 

public static void finishreport (streamwriter sw) {	
table 

public static void finishreport (streamwriter sw) {	
body 

public static void finishreport (streamwriter sw) {	
html 

========================= mono sample_1287 =========================

static int main () {	assembly ass = assembly.loadfrom ("event-il.exe");	type t = ass.gettype ("t");	eventinfo ev = t.getevent ("mydo");	console.writeline (ev.getaddmethod ());	methodinfo[] others = ev.getothermethods ();	for (int i = 0; i < others.length; ++i) {	console.writeline (others [i]);	}	if (others.length != 1) return 1;	
now with non public too 

========================= mono sample_425 =========================

datavalue = obj.tostring ();	}	strhtml.append ("<td>");	strhtml.append (datavalue);	strhtml.append ("</td>");	}	strhtml.append ("\t\t</tr>");	outputfilestream.writeline (strhtml.tostring ());	strhtml = null;	}	
table body html 

datatable schematable = null;	int resultset = 0;	do {	resultset++;	outputline ("display the result set " + resultset);	schematable = reader.getschematable ();	if (reader.fieldcount > 0) {	outputqueryresult (reader, schematable);	}	else if (reader.recordsaffected >= 0) {	
sql command records affected 

do {	resultset++;	outputline ("display the result set " + resultset);	schematable = reader.getschematable ();	if (reader.fieldcount > 0) {	outputqueryresult (reader, schematable);	}	else if (reader.recordsaffected >= 0) {	}	else {	
sql command executed 

public void displaydatasimple (idatareader reader) {	int row = 0;	
reading data using simple reader 

public void displaydatasimple (idatareader reader) {	int row = 0;	while (reader.read ()){	row++;	
row 

public void displaydatasimple (idatareader reader) {	int row = 0;	while (reader.read ()){	row++;	for (int col = 0; col < reader.fieldcount; col++) {	int co = col + 1;	
field 

public void displaydatasimple (idatareader reader) {	int row = 0;	while (reader.read ()){	row++;	for (int col = 0; col < reader.fieldcount; col++) {	int co = col + 1;	string dname = (string) reader.getname (col);	if (dname == null) dname = "?column?";	if (dname.equals (string.empty)) dname = "?column?";	
name 

while (reader.read ()){	row++;	for (int col = 0; col < reader.fieldcount; col++) {	int co = col + 1;	string dname = (string) reader.getname (col);	if (dname == null) dname = "?column?";	if (dname.equals (string.empty)) dname = "?column?";	string dvalue = "";	if (reader.isdbnull (col)) dvalue = "(null)";	else dvalue = reader.getvalue (col).tostring ();	
value 

for (int col = 0; col < reader.fieldcount; col++) {	int co = col + 1;	string dname = (string) reader.getname (col);	if (dname == null) dname = "?column?";	if (dname.equals (string.empty)) dname = "?column?";	string dvalue = "";	if (reader.isdbnull (col)) dvalue = "(null)";	else dvalue = reader.getvalue (col).tostring ();	}	}	
rows retrieved 

public void outputqueryresult (idatareader dreader, datatable dtable) {	if (outputfilestream == null) {	displayresult (dreader, dtable);	}	else {	switch (outputfileformat) {	case fileformat.normal: displayresult (dreader, dtable);	break;	case fileformat.html: outputdatatohtmlfile (dreader, dtable);	break;	
error output data file format not supported 

public void buildparameters (idbcommand cmd) {	if (useparameters == true) {	parametersbuilder parmsbuilder = new parametersbuilder (cmd, bindvariablecharacter.colon);	
get parameters if any 

public void buildparameters (idbcommand cmd) {	if (useparameters == true) {	parametersbuilder parmsbuilder = new parametersbuilder (cmd, bindvariablecharacter.colon);	parmsbuilder.parseparameters ();	ilist parms = (ilist) cmd.parameters;	
print each parm 

idbcommand cmd = null;	int rowsaffected = -1;	cmd = conn.createcommand();	cmd.commandtype = commandtype.text;	cmd.commandtext = sql;	cmd.connection = conn;	buildparameters(cmd);	try {	rowsaffected = cmd.executenonquery ();	cmd = null;	
rows affected 

string msg = "";	idbcommand cmd = null;	string retrievedvalue = "";	cmd = conn.createcommand ();	cmd.commandtype = commandtype.text;	cmd.commandtext = sql;	cmd.connection = conn;	buildparameters(cmd);	try {	retrievedvalue = (string) cmd.executescalar ().tostring ();	
retrieved value 

public void executesqlxml(string sql, string[] parms) {	string filename = "";	if (parms.length != 2) {	
error wrong number of parameters 

public void executesqlxml(string sql, string[] parms) {	string filename = "";	if (parms.length != 2) {	return;	}	try {	filename = parms [1];	}	catch (exception e) {	
error unable to setup output results file 

cmd.commandtext = sql;	cmd.connection = conn;	buildparameters (cmd);	dataset dataset = new dataset ();	dbdataadapter adapter = createnewdataadapter (cmd, conn);	adapter.fill (dataset);	dataset.writexml (filename);	outputline ("data written to xml file: " + filename);	}	catch (exception exexml) {	
error execute sql xml failure 

}	else {	switch(provider) {	case "oledb": adapter = (dbdataadapter) new oledbdataadapter ();	break;	case "sqlclient": adapter = (dbdataadapter) new sqldataadapter ();	break;	case "loadextprovider": adapter = createexternaldataadapter (command, connection);	if (adapter == null) return null;	break;	
error data adapter not found in provider 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
type q to quit 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
listp or listproviders to get factory providers 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
cs or connectionstring to set the connectionstring 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
bcs to build connection string 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
p or provider to set the provider 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
oledb sqlclient mysql odbc 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
oracle postgresql sqlite sybase firebird 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
open to open the connection 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
close to close the connection 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
e to execute sql query select 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
exenonquery to execute an sql non query not a select 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
exescalar to execute sql to get a single row and single column 

outputline (@"                  oracle,postgresql,sqlite,sybase,tds)");	outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	
exexml filename to execute sql and save output to xml file 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
f filename to read a batch of sql commands from file 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
o filename to write result of commands executed to file 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
load filename to load from file sql commands into sql buffer 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
save filename to save sql commands from sql buffer to file 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
h to show help all commands 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
defaults to show default variables such as 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
provider and connectionstring 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
s true false to silent messages 

outputline (@"       \open to open the connection");	outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	
to reset or clear the query buffer 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
set name value to set an internal variable 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
unset name to remove an internal variable 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
variable name to display the value of an internal variable 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
loadextprovider assembly class to load the provider 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
use the complete name of its assembly and 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
its connection class 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
print show what s in the sql buffer now 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
useparameters true false to use parameters when executing sql 

outputline (@"       \close to close the connection");	outputline (@"       \e to execute sql query (select)");	outputline (@"       \h to show help (all commands).");	outputline (@"       \defaults to show default variables.");	outputline ("");	}	public void showhelp () {	console.writeline ("");	if (!waitforenterkey ()) return;	if (!waitforenterkey ()) return;	
usesimplereader true false to use simple reader when displaying results 

public bool waitforenterkey () {	console.write("waiting... press enter key to continue. ");	string entry = console.readline();	if (entry.toupper() == "q") return false;	return true;	}	public void showdefaults() {	console.writeline ();	if (provider.equals (string.empty) && factory == null) console.writeline ("provider is not set.");	else if(factory != null) {	
the default provider is 

string entry = console.readline();	if (entry.toupper() == "q") return false;	return true;	}	public void showdefaults() {	console.writeline ();	if (provider.equals (string.empty) && factory == null) console.writeline ("provider is not set.");	else if(factory != null) {	}	else {	
the default provider is 

if (entry.toupper() == "q") return false;	return true;	}	public void showdefaults() {	console.writeline ();	if (provider.equals (string.empty) && factory == null) console.writeline ("provider is not set.");	else if(factory != null) {	}	else {	if (provider.equals ("loadextprovider")) {	
assembly 

if (entry.toupper() == "q") return false;	return true;	}	public void showdefaults() {	console.writeline ();	if (provider.equals (string.empty) && factory == null) console.writeline ("provider is not set.");	else if(factory != null) {	}	else {	if (provider.equals ("loadextprovider")) {	
connection class 

public void showdefaults() {	console.writeline ();	if (provider.equals (string.empty) && factory == null) console.writeline ("provider is not set.");	else if(factory != null) {	}	else {	if (provider.equals ("loadextprovider")) {	}	}	console.writeline ();	
connectionstring is not set 

console.writeline ();	if (provider.equals (string.empty) && factory == null) console.writeline ("provider is not set.");	else if(factory != null) {	}	else {	if (provider.equals ("loadextprovider")) {	}	}	console.writeline ();	else {	
the default connectionstring is 

console.writeline ();	if (provider.equals (string.empty) && factory == null) console.writeline ("provider is not set.");	else if(factory != null) {	}	else {	if (provider.equals ("loadextprovider")) {	}	}	console.writeline ();	else {	
connectionstring 

}	}	console.writeline ();	else {	console.writeline ();	}	}	public void opendatasource () {	string msg = "";	if (factoryname.equals(string.empty) && provider.equals(string.empty)) {	
provider not set 

else {	console.writeline ();	}	}	public void opendatasource () {	string msg = "";	if (factoryname.equals(string.empty) && provider.equals(string.empty)) {	return;	}	if (isopen()) {	
error already connected 

try {	if (!factoryname.equals(string.empty)) conn = factory.createconnection();	else {	switch (provider) {	case "oledb": conn = new oledbconnection ();	break;	case "sqlclient": conn = new sqlconnection ();	break;	case "loadextprovider": if (loadexternalprovider () == false) return;	break;	
error bad argument or provider not supported 

}	conn = null;	}	}	public bool isopen () {	if (conn != null) if (conn.state.equals(connectionstate.open)) return true;	return false;	}	public void changeprovider (string[] parms) {	if (isopen()) {	
error already connected 

case "odbc": case "system.data.odbc": factoryname = "system.data.odbc";	break;	case "oledb": case "system.data.oledb": factoryname = "system.data.oledb";	break;	case "firebird": case "firebirdsql.data.firebird": factoryname = "firebirdsql.data.firebird";	break;	case "postgresql": case "npgsql": case "npgsql.data": factoryname = "npgsql.data";	break;	case "sqlclient": case "system.data.sqlclient": factoryname = "system.data.sqlclient";	break;	
error bad argument or provider not supported 

break;	case "postgresql": case "npgsql": case "npgsql.data": factoryname = "npgsql.data";	break;	case "sqlclient": case "system.data.sqlclient": factoryname = "system.data.sqlclient";	break;	return;	}	try {	factory = dbproviderfactories.getfactory(factoryname);	} catch(configurationexception) {	
error unable to load provider factory check your machine config to see if the provider is listed under section system data and dbproviderfactories and that your provider assembly is in the gac your provider may not support ado net factory and other features yet 

}	try {	factory = dbproviderfactories.getfactory(factoryname);	} catch(configurationexception) {	factoryname = null;	changeproviderbackwardscompat (parms);	return;	}	outputline ("the default provider is " + factoryname);	}	
error provider only has one parameter 

factory = dbproviderfactories.getfactory(factoryname);	} catch(configurationexception) {	factoryname = null;	changeproviderbackwardscompat (parms);	return;	}	outputline ("the default provider is " + factoryname);	}	}	public void changeproviderbackwardscompat (string[] parms) {	
setting provider using backwards compatibility mode 

setupexternalprovider (extp);	useparameters = false;	usesimplereader = false;	break;	case "postgresql": case "npgsql": extp = new string[3] {	"\\loadextprovider", "npgsql.npgsqlconnection"};	setupexternalprovider (extp);	useparameters = false;	usesimplereader = false;	break;	
error bad argument or provider not supported 

usesimplereader = false;	break;	break;	}	outputline ("the default provider is " + provider);	if (provider.equals ("loadextprovider")) {	outputline ("          assembly: " + providerassembly);	outputline ("  connection class: " + providerconnectionclass);	}	}	
error provider only has one parameter 

outputline ("  connection class: " + providerconnectionclass);	}	}	}	public void changeconnectionstring (string[] parms, string entry) {	if (parms.length >= 2) connectionstring = entry.substring (parms[0].length, entry.length - (parms[0].length + 1));	else connectionstring = "";	}	public void setupoutputresultsfile (string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

else connectionstring = "";	}	public void setupoutputresultsfile (string[] parms) {	if (parms.length != 2) {	return;	}	try {	outputfilestream = new streamwriter (parms[1]);	}	catch (exception e) {	
error unable to setup output results file 

}	try {	outputfilestream = new streamwriter (parms[1]);	}	catch (exception e) {	return;	}	}	public void setupinputcommandsfile (string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

}	}	public void setupinputcommandsfile (string[] parms) {	if (parms.length != 2) {	return;	}	try {	inputfilestream = new streamreader (parms[1]);	}	catch (exception e) {	
error unable to setup input commmands file 

}	try {	inputfilestream = new streamreader (parms[1]);	}	catch (exception e) {	return;	}	}	public void loadbufferfromfile (string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

buffer.append (nextline);	buffer.append ("\n");	}	sr.close ();	buff = buffer.tostring ();	build = null;	build = new stringbuilder ();	build.append(buff);	}	catch (exception e) {	
error unable to read file into sql buffer 

buff = buffer.tostring ();	build = null;	build = new stringbuilder ();	build.append(buff);	}	catch (exception e) {	}	}	public void savebuffertofile(string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

if (parms.length != 2) {	return;	}	string outfilename = parms[1];	try {	streamwriter sw = new streamwriter (outfilename);	sw.writeline (buff);	sw.close ();	}	catch (exception e) {	
error could not save sql buffer to file 

try {	streamwriter sw = new streamwriter (outfilename);	sw.writeline (buff);	sw.close ();	}	catch (exception e) {	}	}	public void setuseparameters (string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

catch (exception e) {	}	}	public void setuseparameters (string[] parms) {	if (parms.length != 2) {	return;	}	string parm = parms[1].toupper ();	if (parm.equals ("true")) useparameters = true;	else if (parm.equals ("false")) useparameters = false;	
error invalid parameter 

public void setuseparameters (string[] parms) {	if (parms.length != 2) {	return;	}	string parm = parms[1].toupper ();	if (parm.equals ("true")) useparameters = true;	else if (parm.equals ("false")) useparameters = false;	}	public void setusesimplereader (string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

if (parm.equals ("true")) useparameters = true;	else if (parm.equals ("false")) useparameters = false;	}	public void setusesimplereader (string[] parms) {	if (parms.length != 2) {	return;	}	string parm = parms[1].toupper ();	if (parm.equals ("true")) usesimplereader = true;	else if (parm.equals ("false")) usesimplereader = false;	
error invalid parameter 

public void setusesimplereader (string[] parms) {	if (parms.length != 2) {	return;	}	string parm = parms[1].toupper ();	if (parm.equals ("true")) usesimplereader = true;	else if (parm.equals ("false")) usesimplereader = false;	}	public void setupsilentmode (string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

if (parm.equals ("true")) usesimplereader = true;	else if (parm.equals ("false")) usesimplereader = false;	}	public void setupsilentmode (string[] parms) {	if (parms.length != 2) {	return;	}	string parm = parms[1].toupper ();	if (parm.equals ("true")) silent = true;	else if (parm.equals ("false")) silent = false;	
error invalid parameter 

public void setupsilentmode (string[] parms) {	if (parms.length != 2) {	return;	}	string parm = parms[1].toupper ();	if (parm.equals ("true")) silent = true;	else if (parm.equals ("false")) silent = false;	}	public void setinternalvariable(string[] parms) {	if (parms.length < 2) {	
error wrong number of parameters 

if (parms.length < 2) {	return;	}	string parm = parms[1];	stringbuilder ps = new stringbuilder ();	for (int i = 2; i < parms.length; i++) ps.append (parms[i]);	internalvariables[parm] = ps.tostring ();	}	public void unsetinternalvariable(string[] parms) {	if (parms.length != 2) {	
error wrong number of parameters 

internalvariables[parm] = ps.tostring ();	}	public void unsetinternalvariable(string[] parms) {	if (parms.length != 2) {	return;	}	string parm = parms[1];	try {	internalvariables.remove (parm);	} catch(exception e) {	
error internal variable does not exist 

}	string parm = parms[1];	try {	internalvariables.remove (parm);	} catch(exception e) {	}	}	public void showinternalvariable(string[] parms) {	string internalvariablevalue = "";	if (parms.length != 2) {	
error wrong number of parameters 

if (getinternalvariable(parm, out internalvariablevalue) == true) console.writeline ("internal variable - name: " + parm + "  value: " + internalvariablevalue);	}	public bool getinternalvariable(string name, out string svalue) {	svalue = "";	bool valuereturned = false;	try {	if (internalvariables.containskey (name) == true) {	svalue = (string) internalvariables[name];	valuereturned = true;	}	
error internal variable does not exist 

public bool getinternalvariable(string name, out string svalue) {	svalue = "";	bool valuereturned = false;	try {	if (internalvariables.containskey (name) == true) {	svalue = (string) internalvariables[name];	valuereturned = true;	}	}	catch(exception e) {	
error internal variable does not exist 

svalue = (string) internalvariables[name];	valuereturned = true;	}	}	catch(exception e) {	}	return valuereturned;	}	public void setupexternalprovider(string[] parms) {	if (parms.length != 3) {	
error wrong number of parameters 

case "\\q": case "\\quit": break;	case "\\clear": case "\\reset": case "\\r": build = null;	break;	case "\\set": setinternalvariable (parms);	break;	case "\\unset": unsetinternalvariable (parms);	break;	case "\\variable": showinternalvariable (parms);	break;	case "\\print": if (build == null) console.writeline ("sql buffer is empty.");	
sql bufer 

case "\\unset": unsetinternalvariable (parms);	break;	case "\\variable": showinternalvariable (parms);	break;	case "\\print": if (build == null) console.writeline ("sql buffer is empty.");	break;	case "\\useparameters": setuseparameters (parms);	break;	case "\\usesimplereader": setusesimplereader (parms);	break;	
error unknown user command 

break;	case "\\useparameters": setuseparameters (parms);	break;	case "\\usesimplereader": setusesimplereader (parms);	break;	break;	}	}	public void listproviders() {	datatable table = dbproviderfactories.getfactoryclasses();	
list of providers 

break;	case "\\usesimplereader": setusesimplereader (parms);	break;	break;	}	}	public void listproviders() {	datatable table = dbproviderfactories.getfactoryclasses();	for (int r = 0; r < table.rows.count; r++) {	console.writeline("---------------------");	
name 

break;	case "\\usesimplereader": setusesimplereader (parms);	break;	break;	}	}	public void listproviders() {	datatable table = dbproviderfactories.getfactoryclasses();	for (int r = 0; r < table.rows.count; r++) {	console.writeline("---------------------");	
description 

break;	case "\\usesimplereader": setusesimplereader (parms);	break;	break;	}	}	public void listproviders() {	datatable table = dbproviderfactories.getfactoryclasses();	for (int r = 0; r < table.rows.count; r++) {	console.writeline("---------------------");	
invariantname 

break;	case "\\usesimplereader": setusesimplereader (parms);	break;	break;	}	}	public void listproviders() {	datatable table = dbproviderfactories.getfactoryclasses();	for (int r = 0; r < table.rows.count; r++) {	console.writeline("---------------------");	
assemblyqualifiedname 

break;	break;	}	}	public void listproviders() {	datatable table = dbproviderfactories.getfactoryclasses();	for (int r = 0; r < table.rows.count; r++) {	console.writeline("---------------------");	}	console.writeline("---------------------");	
providers found 

inputfilename = args [a + 1];	inputfilestream = new streamreader (inputfilename);	}	break;	case "o": if (a + 1 >= args.length) console.writeline ("error: missing filename for -o switch");	else {	outputfilename = args [a + 1];	outputfilestream = new streamwriter (outputfilename);	}	break;	
error unknow switch 

entry = console.readline ();	}	else {	try {	entry = inputfilestream.readline ();	if (entry == null) {	outputline ("executing sql# commands from file done.");	}	}	catch (exception e) {	
error reading command from file 

entry = console.readline ();	}	return entry;	}	public string readconnectionoption(string option, string defaultval) {	console.error.write ("\nconnectionstring option: {0} [{1}] sql# ", option, defaultval);	return console.readline ();	}	public void buildconnectionstring () {	if (factory == null) {	
provider is not set 

}	dbconnectionstringbuilder sb = factory.createconnectionstringbuilder ();	if (!connectionstring.equals(string.empty)) sb.connectionstring = connectionstring;	bool found = false;	foreach (string key in sb.keys) {	if (key.toupper().equals("password") || key.toupper().equals("pwd")) {	string pwd = getpasswordfromconsole ();	try {	sb[key] = pwd;	} catch(exception e) {	
error unable to set key reason 

}	} else {	string defaultval = sb[key].tostring ();	string val = "";	val = readconnectionoption (key, defaultval);	if (val.toupper ().equals ("\\stop")) return;	if (val != "") {	try {	sb[key] = val;	} catch(exception e) {	
error unable to set key reason 

try {	sb[key] = val;	} catch(exception e) {	return;	}	}	}	found = true;	}	if (!found) {	
warning your provider does not subclass dbconnectionstringbuilder fully 

return;	}	}	}	found = true;	}	if (!found) {	return;	}	connectionstring = sb.connectionstring;	
connectionstring is set 

if (!found) {	return;	}	connectionstring = sb.connectionstring;	}	public void run (string[] args) {	dealwithargs (args);	string entry = "";	build = null;	if (silent == false) {	
welcome to sql the interactive sql command line client 

if (!found) {	return;	}	connectionstring = sb.connectionstring;	}	public void run (string[] args) {	dealwithargs (args);	string entry = "";	build = null;	if (silent == false) {	
for mono data see http startuphelp 

public void addparameter (string p) {	
add parameter 

========================= mono sample_1274 =========================

public static int test_short () {	int max = 32767;	int min = -32768;	int t1 = 0xffeedd;	short s1 = (short)t1;	int t2 = s1;	if ((uint)t2 != 0xffffeedd) return 1;	
x 

========================= mono sample_607 =========================

static string getfilepath () {	type type = typeof (environment);	methodinfo method = type.getmethod ("getmachineconfigpath", bindingflags.static | bindingflags.nonpublic);	if (method == null) {	
you need to run this under mono runtime 

static int main (string [] args) {	string path = getfilepath ();	if (path == null) return 1;	updater updater = new updater (path);	if (file.exists (path)) {	bool uptodate;	console.writeline (updater.getlocalmessage (out uptodate));	if (uptodate) return 0;	
warning your site may be blocked from updating if you abuse 

while (r != "yes") {	console.write ("do you want to update your file now? (yes/no) ");	r = console.readline ();	if (r == null) r = "no";	else r = r.toupper ();	if (r == "no") return 0;	}	}	try {	updater.update ();	
browscap ini file provided by gary j keith 

console.write ("do you want to update your file now? (yes/no) ");	r = console.readline ();	if (r == null) r = "no";	else r = r.toupper ();	if (r == "no") return 0;	}	}	try {	updater.update ();	} catch (exception e) {	
update failed 

console.write ("do you want to update your file now? (yes/no) ");	r = console.readline ();	if (r == null) r = "no";	else r = r.toupper ();	if (r == "no") return 0;	}	}	try {	updater.update ();	} catch (exception e) {	
reason 

httpwebrequest request = (httpwebrequest) webrequest.create (browscapurl);	request.useragent = useragent;	streamwriter writer = null;	streamreader reader = null;	console.write ("connecting...");	webresponse resp = request.getresponse ();	string tmppath = null;	try {	tmppath = path.gettempfilename ();	reader = new streamreader (resp.getresponsestream ());	
done 

request.useragent = useragent;	streamwriter writer = null;	streamreader reader = null;	console.write ("connecting...");	webresponse resp = request.getresponse ();	string tmppath = null;	try {	tmppath = path.gettempfilename ();	reader = new streamreader (resp.getresponsestream ());	writer = new streamwriter (file.openwrite (tmppath));	
downloading data to 

reader = new streamreader (resp.getresponsestream ());	writer = new streamwriter (file.openwrite (tmppath));	string str;	while ((str = reader.readline ()) != null) {	writer.writeline (str);	}	writer.close ();	writer = null;	reader.close ();	reader = null;	
removing old 

writer = new streamwriter (file.openwrite (tmppath));	string str;	while ((str = reader.readline ()) != null) {	writer.writeline (str);	}	writer.close ();	writer = null;	reader.close ();	reader = null;	file.delete (filename);	
copying to 

========================= mono sample_1225 =========================

gr.clear (color.white);	createimage (rotatefliptype.rotatenoneflipnone, 0, 0, "rotatenoneflipnone", bmp, gr);	createimage (rotatefliptype.rotate90flipnone, 150, 0, "rotate90flipnone", bmp, gr);	createimage (rotatefliptype.rotate180flipnone, 300, 0, "rotate180flipnone", bmp, gr);	createimage (rotatefliptype.rotate270flipnone, 450, 0, "rotate270flipnone", bmp, gr);	createimage (rotatefliptype.rotatenoneflipx, 0, 120, "rotatenoneflipx", bmp, gr);	createimage (rotatefliptype.rotate90flipx, 150, 120, "rotate90flipx", bmp, gr);	createimage (rotatefliptype.rotate180flipx, 300, 120, "rotate180flipx", bmp, gr);	createimage (rotatefliptype.rotate270flipx, 450, 120, "rotate270flipx", bmp, gr);	bmp.save(filename, imageformat.bmp);	
bitmap stored to 

========================= mono sample_21320 =========================

static int main () {	var c = new c ();	c.test1 ();	const c c2 = null;	var res = c2?.field;	if (res != null) return 1;	
ok 

========================= mono sample_1365 =========================

private static bool parseargumentvalue (string value) {	if ((value.length == 1)) {	switch (value [0]) {	case 't': return true;	case 'f': return false;	
invalid argument value 

private static bool parseargumentvalue (string value) {	if ((value.length == 1)) {	switch (value [0]) {	case 't': return true;	case 'f': return false;	throw new applicationexception ("invalid argument value " + value);	}	} else {	
invalid argument value 

public runningmode (string runningmode) {	string [] arguments = runningmode.split (',');	foreach (string argument in arguments) {	string [] components = argument.split (':');	if (components.length == 2) {	switch (components [0]) {	case "runtime": monoruntime = components [1];	break;	case "gtc": generatetestconfigurations = parseargumentvalue (components [1]);	break;	
invalid argument 

string [] components = argument.split (':');	if (components.length == 2) {	switch (components [0]) {	case "runtime": monoruntime = components [1];	break;	case "gtc": generatetestconfigurations = parseargumentvalue (components [1]);	break;	throw new applicationexception ("invalid argument " + argument);	}	} else {	
invalid argument 

public void printoutput () {	
output start 

public void printoutput () {	foreach (string outputline in output) {	console.writeline (outputline);	}	
output end 

private static bool parseargumentvalue (string value) {	if ((value.length == 1)) {	switch (value [0]) {	case 't': return true;	case 'f': return false;	
invalid argument value 

private static bool parseargumentvalue (string value) {	if ((value.length == 1)) {	switch (value [0]) {	case 't': return true;	case 'f': return false;	throw new applicationexception ("invalid argument value " + value);	}	} else {	
invalid argument value 

this.expectedresult = expectedresult;	string [] configurationflags = configuration.split (',');	foreach (string configurationflag in configurationflags) {	string [] components = configurationflag.split (':');	if (components.length == 2) {	switch (components [0]) {	case "use20": use20runtime = parseargumentvalue (components [1]);	break;	case "rcil": rootconfigurationislegacy = parseargumentvalue (components [1]);	break;	
invalid argument 

string [] components = configurationflag.split (':');	if (components.length == 2) {	switch (components [0]) {	case "use20": use20runtime = parseargumentvalue (components [1]);	break;	case "rcil": rootconfigurationislegacy = parseargumentvalue (components [1]);	break;	throw new applicationexception ("invalid argument " + components [0]);	}	} else {	
invalid argument 

if (components.length == 2) {	switch (components [0]) {	case "exitzero": exitcodeshouldbezero = parseargumentvalue (components [1]);	break;	case "cont": continuemarkerexpected = parseargumentvalue (components [1]);	break;	case "rdue": rootdomainunhandledexceptionmarkerexpected = parseargumentvalue (components [1]);	break;	case "ddue": differentdomainunhandledexceptionmarkerexpected = parseargumentvalue (components [1]);	break;	
invalid argument 

break;	case "cont": continuemarkerexpected = parseargumentvalue (components [1]);	break;	case "rdue": rootdomainunhandledexceptionmarkerexpected = parseargumentvalue (components [1]);	break;	case "ddue": differentdomainunhandledexceptionmarkerexpected = parseargumentvalue (components [1]);	break;	throw new applicationexception ("invalid argument " + components [0]);	}	} else {	
invalid argument 

public bool check (testresult testresult) {	if (exitzero && (testresult.exitcode != 0)) {	
test failed exit code is expected zero 

public bool check (testresult testresult) {	if (exitzero && (testresult.exitcode != 0)) {	return false;	}	if (!cont && testresult.cont) {	
test failed unexpected cont marker found 

public bool check (testresult testresult) {	if (exitzero && (testresult.exitcode != 0)) {	return false;	}	if (!cont && testresult.cont) {	return false;	}	if (cont && !testresult.cont) {	
test failed expected cont marker not found 

if (exitzero && (testresult.exitcode != 0)) {	return false;	}	if (!cont && testresult.cont) {	return false;	}	if (cont && !testresult.cont) {	return false;	}	if (!rdue && testresult.rdue) {	
test failed unexpected rdue marker found 

if (!cont && testresult.cont) {	return false;	}	if (cont && !testresult.cont) {	return false;	}	if (!rdue && testresult.rdue) {	return false;	}	if (rdue && !testresult.rdue) {	
test failed expected rdue marker not found 

if (cont && !testresult.cont) {	return false;	}	if (!rdue && testresult.rdue) {	return false;	}	if (rdue && !testresult.rdue) {	return false;	}	if (!ddue && testresult.ddue) {	
test failed unexpected marker found 

if (!rdue && testresult.rdue) {	return false;	}	if (rdue && !testresult.rdue) {	return false;	}	if (!ddue && testresult.ddue) {	return false;	}	if (ddue && !testresult.ddue) {	
test failed expected ddue marker not found 

program = program + "-legacy";	}	program = program + (description.use20 ? ".2.exe" : ".1.exe");	if (runningmode.usemonoruntime) {	p.startinfo.filename = runningmode.runtime;	p.startinfo.arguments = "--debug " + program + " " + description.arguments;	} else {	p.startinfo.filename = program;	p.startinfo.arguments = description.arguments;	}	
starting process 

public void print () {	
results of test 

public void print () {	
exit code is output is 

public void print () {	result.printoutput ();	
the following configuration would make the test pass 

public void print () {	result.printoutput ();	
new testdescription 

public bool process (runningmode runningmode) {	if (runningmode.gtc) {	
generating test configuration 

public bool process (runningmode runningmode) {	if (runningmode.gtc) {	print ();	return true;	} else {	
checking test result 

public bool process (runningmode runningmode) {	if (runningmode.gtc) {	print ();	return true;	} else {	bool checkresult = check ();	if (! checkresult) {	print ();	} else {	
test passed 

public static int main (string [] args) {	runningmode runningmode = (args.length > 0) ? new runningmode (args [0]) : new runningmode ("runtime:mono,gtc:f");	if (args.length > 1) {	
extra arguments unrecognized 

public static int main (string [] args) {	runningmode runningmode = (args.length > 0) ? new runningmode (args [0]) : new runningmode ("runtime:mono,gtc:f");	if (args.length > 1) {	return 1;	}	
starting test run usemonoruntime is gtc is 

========================= mono sample_440 =========================

public static extern int getversionex ([in, out] osversioninfo osvi);	[dllimport ("libtest")]	public static extern int buggetversionex (int a, int b, int c, int d, int e, int f, int g, int h, [in, out] osversioninfo osvi);	[dllimport ("libtest", entrypoint="mygetversionex")]	public static extern int getversionex2 (ref osversioninfo2 osvi);	}	public class test {	public static int main() {	
passing osversioninfo as class 

public static extern int getversionex2 (ref osversioninfo2 osvi);	}	public class test {	public static int main() {	osversioninfo osvi = new osversioninfo();	osvi.a = 1;	osvi.b = 2;	if (libwrap.getversionex (osvi) != 5) return 1;	if (osvi.a != 2) return 2;	if (osvi.b != 3) return 3;	
a 

public static extern int getversionex2 (ref osversioninfo2 osvi);	}	public class test {	public static int main() {	osversioninfo osvi = new osversioninfo();	osvi.a = 1;	osvi.b = 2;	if (libwrap.getversionex (osvi) != 5) return 1;	if (osvi.a != 2) return 2;	if (osvi.b != 3) return 3;	
b 

public static extern int getversionex2 (ref osversioninfo2 osvi);	}	public class test {	public static int main() {	osversioninfo osvi = new osversioninfo();	osvi.a = 1;	osvi.b = 2;	if (libwrap.getversionex (osvi) != 5) return 1;	if (osvi.a != 2) return 2;	if (osvi.b != 3) return 3;	
passing osversioninfo as struct 

osvi.b = 2;	if (libwrap.getversionex (osvi) != 5) return 1;	if (osvi.a != 2) return 2;	if (osvi.b != 3) return 3;	osversioninfo2 osvi2 = new osversioninfo2();	osvi2.a = 1;	osvi2.b = 2;	if (libwrap.getversionex2 (ref osvi2) != 5) return 4;	if (osvi2.a != 2) return 5;	if (osvi2.b != 3) return 6;	
a 

osvi.b = 2;	if (libwrap.getversionex (osvi) != 5) return 1;	if (osvi.a != 2) return 2;	if (osvi.b != 3) return 3;	osversioninfo2 osvi2 = new osversioninfo2();	osvi2.a = 1;	osvi2.b = 2;	if (libwrap.getversionex2 (ref osvi2) != 5) return 4;	if (osvi2.a != 2) return 5;	if (osvi2.b != 3) return 6;	
b 

osvi.b = 2;	if (libwrap.getversionex (osvi) != 5) return 1;	if (osvi.a != 2) return 2;	if (osvi.b != 3) return 3;	osversioninfo2 osvi2 = new osversioninfo2();	osvi2.a = 1;	osvi2.b = 2;	if (libwrap.getversionex2 (ref osvi2) != 5) return 4;	if (osvi2.a != 2) return 5;	if (osvi2.b != 3) return 6;	
testing with extra parameters at the beginning 

osvi2.b = 2;	if (libwrap.getversionex2 (ref osvi2) != 5) return 4;	if (osvi2.a != 2) return 5;	if (osvi2.b != 3) return 6;	osversioninfo osvi3 = new osversioninfo();	osvi3.a = 1;	osvi3.b = 2;	if (libwrap.buggetversionex (10, 10, 10, 10, 20, 20, 20, 20, osvi3) != 5) return 7;	if (osvi3.a != 2) return 8;	if (osvi3.b != 3) return 9;	
a 

osvi2.b = 2;	if (libwrap.getversionex2 (ref osvi2) != 5) return 4;	if (osvi2.a != 2) return 5;	if (osvi2.b != 3) return 6;	osversioninfo osvi3 = new osversioninfo();	osvi3.a = 1;	osvi3.b = 2;	if (libwrap.buggetversionex (10, 10, 10, 10, 20, 20, 20, 20, osvi3) != 5) return 7;	if (osvi3.a != 2) return 8;	if (osvi3.b != 3) return 9;	
b 

osvi2.b = 2;	if (libwrap.getversionex2 (ref osvi2) != 5) return 4;	if (osvi2.a != 2) return 5;	if (osvi2.b != 3) return 6;	osversioninfo osvi3 = new osversioninfo();	osvi3.a = 1;	osvi3.b = 2;	if (libwrap.buggetversionex (10, 10, 10, 10, 20, 20, 20, 20, osvi3) != 5) return 7;	if (osvi3.a != 2) return 8;	if (osvi3.b != 3) return 9;	
passing osversioninfo as struct 

========================= mono sample_500 =========================

static logger () {	var env = environment.getenvironmentvariable ("moon_wcf_trace") ?? environment.getenvironmentvariable ("mono_wcf_trace");	switch (env) {	case "stdout": log_writer = console.out;	break;	case "stderr": log_writer = console.error;	break;	#if !mobile default: try {	if (!string.isnullorempty (env)) log_writer = file.createtext (env);	} catch (exception ex) {	
warning wcf trace environment variable points to non creatable file name 

========================= mono sample_32196 =========================

static ienumerator getit (int [] args) {	foreach (int arg in args) {	
out 

static ienumerator getit (int [] args) {	foreach (int arg in args) {	a a = delegate {	
arg 

========================= mono sample_3254 =========================

public static int main () {	if (foo<bool> ()) return 1;	if (!foo<int> ()) return 2;	if (gen<object>.foo (null)) return 3;	if (!gen<program>.foo (new program ())) return 4;	
ok 

========================= mono sample_1351 =========================

static x509certificatecollection decodecollection () {	x509certificatecollection roots = new x509certificatecollection ();	stringbuilder sb = new stringbuilder ();	bool processing = false;	using (stream s = getfile ()) {	if (s == null) {	
couldn t retrieve the file using the supplied information 

static int process () {	x509certificatecollection roots = decodecollection ();	if (roots == null) {	return 1;	} else if (roots.count == 0) {	
no certificates were found 

static int process () {	x509certificatecollection roots = decodecollection ();	if (roots == null) {	return 1;	} else if (roots.count == 0) {	return 0;	}	if (userstore) {	
importing into legacy user store 

x509certificatecollection roots = decodecollection ();	if (roots == null) {	return 1;	} else if (roots.count == 0) {	return 0;	}	if (userstore) {	importtostore (roots, x509storemanager.currentuser.trustedroot);	if (mono.security.interface.monotlsproviderfactory.isprovidersupported ("btls")) {	writeline ("");	
importing into btls user store 

} else if (roots.count == 0) {	return 0;	}	if (userstore) {	importtostore (roots, x509storemanager.currentuser.trustedroot);	if (mono.security.interface.monotlsproviderfactory.isprovidersupported ("btls")) {	writeline ("");	importtostore (roots, x509storemanager.newcurrentuser.trustedroot);	}	} else {	
importing into legacy system store 

if (userstore) {	importtostore (roots, x509storemanager.currentuser.trustedroot);	if (mono.security.interface.monotlsproviderfactory.isprovidersupported ("btls")) {	writeline ("");	importtostore (roots, x509storemanager.newcurrentuser.trustedroot);	}	} else {	importtostore (roots, x509storemanager.localmachine.trustedroot);	if (mono.security.interface.monotlsproviderfactory.isprovidersupported ("btls")) {	writeline ("");	
importing into btls system store 

static void importtostore (x509certificatecollection roots, x509store store) {	x509certificatecollection trusted = store.certificates;	int additions = 0;	
i already trust your new list has 

static void importtostore (x509certificatecollection roots, x509store store) {	x509certificatecollection trusted = store.certificates;	int additions = 0;	foreach (x509certificate root in roots) {	if (!trusted.contains (root)) {	try {	store.import (root);	
certificate added 

static void importtostore (x509certificatecollection roots, x509store store) {	x509certificatecollection trusted = store.certificates;	int additions = 0;	foreach (x509certificate root in roots) {	if (!trusted.contains (root)) {	try {	store.import (root);	additions++;	} catch (exception e) {	
warning could not import 

foreach (x509certificate root in roots) {	if (!trusted.contains (root)) {	try {	store.import (root);	additions++;	} catch (exception e) {	writeline (e.tostring ());	}	}	}	
new root certificates were added to your trust store 

}	}	}	x509certificatecollection removed = new x509certificatecollection ();	foreach (x509certificate trust in trusted) {	if (!roots.contains (trust)) {	removed.add (trust);	}	}	if (removed.count > 0) {	
previously trusted certificates were removed 

}	x509certificatecollection removed = new x509certificatecollection ();	foreach (x509certificate trust in trusted) {	if (!roots.contains (trust)) {	removed.add (trust);	}	}	if (removed.count > 0) {	foreach (x509certificate old in removed) {	store.remove (old);	
certificate removed 

foreach (x509certificate trust in trusted) {	if (!roots.contains (trust)) {	removed.add (trust);	}	}	if (removed.count > 0) {	foreach (x509certificate old in removed) {	store.remove (old);	}	}	
import process completed 

static bool parseoptions (string[] args) {	if (args.length < 1) return false;	for (int i = 0; i < args.length - 1; i++) {	switch (args [i]) {	case "--quiet": quiet = true;	break;	case "--user": userstore = true;	break;	case "--btls": break;	
unknown option 

case "--quiet": quiet = true;	break;	case "--user": userstore = true;	break;	case "--btls": break;	return false;	}	}	inputfile = args [args.length - 1];	if (!file.exists (inputfile)) {	
unknown option or file not found 

static void help () {	
usage cert sync quiet user system ca bundle crt 

static void help () {	
where system ca bundle crt is in pem format 

if (!parseoptions (args)) {	header ();	help ();	return 1;	}	if (!quiet) {	header ();	}	return process ();	} catch (exception e) {	
error 

========================= mono sample_1180 =========================

static int parsetestname (string name) {	for (int i = 0; i < available_tests.length; ++i) {	if (available_tests[i].item2 == name) return i;	}	
invalid test name 

j += 2;	} else if ((args [j] == "--test") || (args [j] == "-t")) {	if (args [j + 1] == "static") testindex = -1;	else if (args [j + 1] == "tp") tploadgenerator = true;	else testindex = parsetestname (testname = args [j + 1]);	j += 2;	} else 	if ((args [j] == "--thread-count") || (args [j] == "-tc")) {	threadcount = int32.parse (args [j + 1]);	j += 2;	}else {	
unknown argument 

else testindex = parsetestname (testname = args [j + 1]);	j += 2;	} else 	if ((args [j] == "--thread-count") || (args [j] == "-tc")) {	threadcount = int32.parse (args [j + 1]);	j += 2;	}else {	return 1;	}	}	if (tploadgenerator) {	
tp window duration 

} else 	if ((args [j] == "--thread-count") || (args [j] == "-tc")) {	threadcount = int32.parse (args [j + 1]);	j += 2;	}else {	return 1;	}	}	if (tploadgenerator) {	dynamicloadgenerator (threadcount, timeinmillis);	} else {	
thread count duration test 

========================= mono sample_662 =========================

gr.rotatetransform (max_theta);	for ( int i = 0; i < lines; i++) {	gr.drawline (blackpen, -2.0f * width, 0.0f, 2.0f * width, 0.0f);	gr.rotatetransform (-theta);	}	gr.restore (oldstate);	pen redpen = new pen (color.red, 6f);	gr.drawline (redpen, width / 4f, 0f, width / 4f, height);	gr.drawline (redpen, 3f * width / 4f, 0f, 3f * width / 4f, height);	bmp.save ("hering.png", imageformat.png);	
output file hering png 

for ( int i = 0; i < lines; i++) {	gr.drawline (blackpen, -2.0f * width, 0.0f, 2.0f * width, 0.0f);	gr.rotatetransform (-theta);	}	gr.restore (oldstate);	pen redpen = new pen (color.red, 6f);	gr.drawline (redpen, width / 4f, 0f, width / 4f, height);	gr.drawline (redpen, 3f * width / 4f, 0f, 3f * width / 4f, height);	bmp.save ("hering.png", imageformat.png);	bmp.save ("hering.jpg", imageformat.jpeg);	
output file hering jpg 

gr.drawline (blackpen, -2.0f * width, 0.0f, 2.0f * width, 0.0f);	gr.rotatetransform (-theta);	}	gr.restore (oldstate);	pen redpen = new pen (color.red, 6f);	gr.drawline (redpen, width / 4f, 0f, width / 4f, height);	gr.drawline (redpen, 3f * width / 4f, 0f, 3f * width / 4f, height);	bmp.save ("hering.png", imageformat.png);	bmp.save ("hering.jpg", imageformat.jpeg);	bmp.save ("hering.bmp", imageformat.bmp);	
output file hering bmp 

========================= mono sample_21314 =========================

static int main () {	if ((int) (0.7f * 100.0f) != 69) return 1;	if ((double) (0.7f * 100.0f) != 69.9999988079071) return 2;	if (!foo (0.7f * 100.0f)) return 3;	a attr = (a)methodbase.getcurrentmethod ().getcustomattributes (false) [0];	if (attr.d != 69.9999988079071) return 4;	
ok 

========================= mono sample_2078 =========================

protected void setup () {	if (directory.exists (tempdir)) directory.delete (tempdir, true);	directory.createdirectory (tempdir);	for (int i = 1; i < 3; ++i) {	string resfile = path.combine (tempdir, "res" + i + ".txt");	using (streamwriter sw = new streamwriter (resfile)) {	
foo 

static void definedynamicassembly (appdomain domain) {	assemblyname assemblyname = new assemblyname ();	assemblyname.name = "mydynamicassembly";	assemblybuilder assemblybuilder = domain.definedynamicassembly (assemblyname, assemblybuilderaccess.run);	modulebuilder modulebuilder = assemblybuilder.definedynamicmodule ("mydynamicmodule");	typebuilder typebuilder = modulebuilder.definetype ("mydynamictype", typeattributes.public);	constructorbuilder constructorbuilder = typebuilder.defineconstructor (methodattributes.public, callingconventions.standard, null);	ilgenerator ilgenerator = constructorbuilder.getilgenerator ();	
mydynamictype instantiated 

========================= mono sample_27589 =========================

sb.append (line);	sb.append ("\r\n");	} if (line.length == 0) {	state = 1;	} else if (line.startswith ("expect:")) {	expect = line.substring (8);	}	}	stringwriter sw = new stringwriter ();	if (expect == "100-continue" && state != 2) {	
http continue 

sb = new stringbuilder ();	sr = new streamreader (ms, encoding.utf8);	line = sr.readline ();	while (line != null) {	sb.append (line);	sb.append ("\r\n");	line = sr.readline ();	}	}	sw = new stringwriter ();	
http ok 

sb = new stringbuilder ();	sr = new streamreader (ms, encoding.utf8);	line = sr.readline ();	while (line != null) {	sb.append (line);	sb.append ("\r\n");	line = sr.readline ();	}	}	sw = new stringwriter ();	
content type text xml 

sb = new stringbuilder ();	sr = new streamreader (ms, encoding.utf8);	line = sr.readline ();	while (line != null) {	sb.append (line);	sb.append ("\r\n");	line = sr.readline ();	}	}	sw = new stringwriter ();	
content length 

========================= mono sample_23300 =========================

if (sdk_path != null || runtime != null) error ("you can only specify one of --runtime, --sdk or --cross {sdk_path}/{runtime}");	custom_mode = false;	autodeps = true;	cross_target = args [++i];	break;	case "--library": if (i+1 == top){	help ();	return 1;	}	if (custom_mode){	
library can only be used with simple runtime cross mode 

break;	case "--fetch-target": if (i+1 == top){	help ();	return 1;	}	fetch_target = args [++i];	break;	case "--list-targets": commandlocaltargets ();	var wc = new webclient ();	var s = wc.downloadstring (new uri (target_server + "target-sdks.txt"));	
targets available for download with fetch target 

help ();	return 1;	}	config_file = args [++i];	break;	case "--machine-config": if (i+1 == top) {	help ();	return 1;	}	machine_config_file = args [++i];	
warning check that the machine config file you are bundling doesn t contain sensitive information specific to this machine 

return 1;	}	var env = args [++i];	p = env.indexof ('=');	if (p == -1) environment.add (env, "");	else environment.add (env.substring (0, p), env.substring (p+1));	break;	case "--bundled-header": bundled_header = true;	break;	case "--in-tree": if (i+1 == top) {	
usage in tree path to headers 

else environment.add (env.substring (0, p), env.substring (p+1));	break;	case "--bundled-header": bundled_header = true;	break;	case "--in-tree": if (i+1 == top) {	return 1;	}	in_tree = args [++i];	break;	case "--managed-linker": if (i+1 == top) {	
usage managed linker path to exe 

return 1;	}	in_tree = args [++i];	break;	case "--managed-linker": if (i+1 == top) {	return 1;	}	managed_linker_path = args [++i];	break;	case "--cil-strip": if (i+1 == top) {	
usage cil strip path to exe 

return 1;	}	managed_linker_path = args [++i];	break;	case "--cil-strip": if (i+1 == top) {	return 1;	}	cil_strip_path = args [++i];	break;	case "--aot-runtime": if (i+1 == top) {	
usage aot runtime path to runtime 

cil_strip_path = args [++i];	break;	case "--aot-runtime": if (i+1 == top) {	return 1;	}	aot_runtime = args [++i];	aot_compile = true;	static_link = true;	break;	case "--aot-dedup": if (i+1 == top) {	
usage aot dedup container dll 

return 1;	}	var rel_path = args [++i];	var asm = loadassembly (rel_path);	if (asm != null) aot_dedup_assembly = new uri(asm.codebase).localpath;	sources.add (rel_path);	aot_compile = true;	static_link = true;	break;	case "--aot-mode": if (i+1 == top) {	
need string of aot mode full llvmonly omit for normal aot 

if (asm != null) aot_dedup_assembly = new uri(asm.codebase).localpath;	sources.add (rel_path);	aot_compile = true;	static_link = true;	break;	case "--aot-mode": if (i+1 == top) {	return 1;	}	aot_mode = args [++i];	if (aot_mode != "full" && aot_mode != "llvmonly") {	
need string of aot mode full llvmonly omit for normal aot 

return 1;	}	aot_mode = args [++i];	if (aot_mode != "full" && aot_mode != "llvmonly") {	return 1;	}	aot_compile = true;	static_link = true;	break;	case "--aot-args": if (i+1 == top) {	
aot arguments are passed as a comma delimited list 

if (aot_mode != "full" && aot_mode != "llvmonly") {	return 1;	}	aot_compile = true;	static_link = true;	break;	case "--aot-args": if (i+1 == top) {	return 1;	}	if (args [i + 1].contains ("outfile")) {	
per aot output arguments ex outfile llvm outfile cannot be given 

}	if (!custom_mode){	if (runtime != null){	} else if (sdk_path != null) {	verifysdk (sdk_path);	} else if (cross_target == "default" || cross_target == null){	sdk_path = path.getfullpath (path.combine (process.getcurrentprocess().mainmodule.filename, "..", ".."));	verifysdk (sdk_path);	} else {	sdk_path = path.combine (targets_dir, cross_target);	
from 

}	}	if (fetch_target != null){	var directory = path.combine (targets_dir, fetch_target);	var zip_download = path.combine (directory, "sdk.zip");	directory.createdirectory (directory);	var wc = new webclient ();	var uri = new uri ($"{target_server}{fetch_target}");	try {	if (!quiet){	
downloading runtime uri to zip download 

directory.createdirectory (directory);	var wc = new webclient ();	var uri = new uri ($"{target_server}{fetch_target}");	try {	if (!quiet){	}	wc.downloadfile (uri, zip_download);	zipfile.extracttodirectory(zip_download, directory);	file.delete (zip_download);	} catch {	
failure to download the specified runtime from uri 

zipfile.extracttodirectory(zip_download, directory);	file.delete (zip_download);	} catch {	file.delete (zip_download);	return 1;	}	return 0;	}	if (!quiet) {	console.writeline (os_message);	
sources auto dependencies 

environment.exit (1);	}	list<string> assemblies = loadassemblies (sources);	loadlocalizedassemblies (assemblies);	list<string> files = new list<string> ();	foreach (string file in assemblies) if (!queueassembly (files, file)) return 1;	preprocessassemblies (assemblies, files);	if (aot_compile) aotcompile (files);	if (custom_mode) generatebundles (files);	else generatepackage (files);	
generated 

static void commandlocaltargets () {	string [] targets;	
available targets locally 

static void commandlocaltargets () {	string [] targets;	
default current system mono 

static void writesymbol (streamwriter sw, string name, long size) {	switch (style){	
linux globl section rodata type size 

static void writesymbol (streamwriter sw, string name, long size) {	switch (style){	break;	
osx section text text regular pure instructions globl data align 

static void writesymbol (streamwriter sw, string name, long size) {	switch (style){	break;	break;	case "windows": string mangled_symbol_name = "";	if (target64bitapplication()) mangled_symbol_name = name;	else mangled_symbol_name = "_" + name;	
globl section rdata align 

public int addfile (string fname) {	using (stream filestream = file.openread (fname)){	var ret = filestream.length;	
at x with input 

public void addstringpair (string entry, string key, string value) {	var kbytes = encoding.utf8.getbytes (key);	var vbytes = encoding.utf8.getbytes (value);	
adding to 

public void addstringpair (string entry, string key, string value) {	var kbytes = encoding.utf8.getbytes (key);	var vbytes = encoding.utf8.getbytes (value);	if (kbytes.length > 255){	
the key value can not exceed characters 

public void dump () {	if (quiet) return;	foreach (var floc in locations.keys){	
floc at locations floc x 

}	if (!file.exists (runtime)){	error ($"the specified runtime at {runtime} does not exist");	environment.exit (1);	}	if (ctor_func != null){	error ("--static-ctor not supported with package bundling, you must use native compilation for this");	return false;	}	var maker = new packagemaker (output);	
using runtime 

if (ctor_func != null){	error ("--static-ctor not supported with package bundling, you must use native compilation for this");	return false;	}	var maker = new packagemaker (output);	maker.addfile (runtime);	foreach (var url in files){	string fname = locatefile (new uri (url).localpath);	string aname = makebundle.getassemblyname (fname);	maker.add ("assembly:" + aname, fname);	
assembly 

return false;	}	var maker = new packagemaker (output);	maker.addfile (runtime);	foreach (var url in files){	string fname = locatefile (new uri (url).localpath);	string aname = makebundle.getassemblyname (fname);	maker.add ("assembly:" + aname, fname);	if (file.exists (fname + ".config")){	maker.add ("config:" + aname, fname + ".config");	
config config 

string fname = locatefile (new uri (url).localpath);	string aname = makebundle.getassemblyname (fname);	maker.add ("assembly:" + aname, fname);	if (file.exists (fname + ".config")){	maker.add ("config:" + aname, fname + ".config");	}	}	if (!maybeaddfile (maker, "systemconfig:", config_file) || !maybeaddfile (maker, "machineconfig:", machine_config_file)) return false;	if (config_dir != null){	maker.add ("config_dir:", config_dir);	
config dir 

if (!maybeaddfile (maker, "systemconfig:", config_file) || !maybeaddfile (maker, "machineconfig:", machine_config_file)) return false;	if (config_dir != null){	maker.add ("config_dir:", config_dir);	}	if (embedded_options != null) maker.addstring ("options:", embedded_options);	if (environment.count > 0){	foreach (var key in environment.keys) maker.addstringpair ("env:" + key, key, environment [key]);	}	if (libraries.count > 0){	foreach (var alias_and_path in libraries){	
library 

string temp_o = (style != "windows") ? "temp.o" : "temp.s.obj";	if (compile_only) temp_c = output;	if (object_out != null) temp_o = object_out;	try {	list<string> c_bundle_names = new list<string> ();	list<string[]> config_names = new list<string[]> ();	using (streamwriter ts = new streamwriter (file.create (temp_s))) {	using (streamwriter tc = new streamwriter (file.create (temp_c))) {	string prog = null;	if (bundled_header) {	
this source code was produced by mkbundle do not edit 

string temp_o = (style != "windows") ? "temp.o" : "temp.s.obj";	if (compile_only) temp_c = output;	if (object_out != null) temp_o = object_out;	try {	list<string> c_bundle_names = new list<string> ();	list<string[]> config_names = new list<string[]> ();	using (streamwriter ts = new streamwriter (file.create (temp_s))) {	using (streamwriter tc = new streamwriter (file.create (temp_c))) {	string prog = null;	if (bundled_header) {	
ifndef null define null void endif 

string temp_o = (style != "windows") ? "temp.o" : "temp.s.obj";	if (compile_only) temp_c = output;	if (object_out != null) temp_o = object_out;	try {	list<string> c_bundle_names = new list<string> ();	list<string[]> config_names = new list<string[]> ();	using (streamwriter ts = new streamwriter (file.create (temp_s))) {	using (streamwriter tc = new streamwriter (file.create (temp_c))) {	string prog = null;	if (bundled_header) {	
typedef struct 

using (streamwriter tc = new streamwriter (file.create (temp_c))) {	string prog = null;	if (bundled_header) {	const char *name;	const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	
define mono aot mode normal 

using (streamwriter tc = new streamwriter (file.create (temp_c))) {	string prog = null;	if (bundled_header) {	const char *name;	const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	
define mono aot mode full 

using (streamwriter tc = new streamwriter (file.create (temp_c))) {	string prog = null;	if (bundled_header) {	const char *name;	const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	
define mono aot mode llvmonly 

string prog = null;	if (bundled_header) {	const char *name;	const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	} else {	
include mono metadata mono config h 

string prog = null;	if (bundled_header) {	const char *name;	const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	} else {	
include mono metadata assembly h 

if (bundled_header) {	const char *name;	const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	} else {	if (in_tree != null) tc.writeline ("#include <mono/mini/jit.h>\n");	
include mono jit jit h 

const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	} else {	if (in_tree != null) tc.writeline ("#include <mono/mini/jit.h>\n");	}	if (compress) {	
typedef struct compressed data 

const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	} else {	if (in_tree != null) tc.writeline ("#include <mono/mini/jit.h>\n");	}	if (compress) {	
monobundledassembly assembly 

const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	} else {	if (in_tree != null) tc.writeline ("#include <mono/mini/jit.h>\n");	}	if (compress) {	
int compressed size 

const unsigned char *data;	const unsigned int size;	} monobundledassembly;	void          mono_register_bundled_assemblies (const monobundledassembly **assemblies);	void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);	");	} else {	if (in_tree != null) tc.writeline ("#include <mono/mini/jit.h>\n");	}	if (compress) {	
compressedassembly 

#else foreach (var url in files) body (url);	#endif byte [] buffer = new byte [8192];	var symbolescapere = new system.text.regularexpressions.regex ("[^\\w_]");	foreach (var url in files) {	string fname = locatefile (new uri (url).localpath);	string aname = makebundle.getassemblyname (fname);	string encoded = symbolescapere.replace (aname, "_");	if (prog == null) prog = aname;	var stream = streams [url];	var real_size = sizes [url];	
embedding 

foreach (var url in files) {	string fname = locatefile (new uri (url).localpath);	string aname = makebundle.getassemblyname (fname);	string encoded = symbolescapere.replace (aname, "_");	if (prog == null) prog = aname;	var stream = streams [url];	var real_size = sizes [url];	writesymbol (ts, "assembly_data_" + encoded, stream.length);	writebuffer (ts, stream, buffer);	if (compress) {	
extern const unsigned char assembly data 

string encoded = symbolescapere.replace (aname, "_");	if (prog == null) prog = aname;	var stream = streams [url];	var real_size = sizes [url];	writesymbol (ts, "assembly_data_" + encoded, stream.length);	writebuffer (ts, stream, buffer);	if (compress) {	tc.writeline ("static compressedassembly assembly_bundle_{0} = {{{{\"{1}\"," + " assembly_data_{0}, {2}}}, {3}}};", encoded, aname, real_size, stream.length);	if (!quiet) {	double ratio = ((double) stream.length * 100) / real_size;	
compression ratio 

var stream = streams [url];	var real_size = sizes [url];	writesymbol (ts, "assembly_data_" + encoded, stream.length);	writebuffer (ts, stream, buffer);	if (compress) {	tc.writeline ("static compressedassembly assembly_bundle_{0} = {{{{\"{1}\"," + " assembly_data_{0}, {2}}}, {3}}};", encoded, aname, real_size, stream.length);	if (!quiet) {	double ratio = ((double) stream.length * 100) / real_size;	}	} else {	
extern const unsigned char assembly data 

if (!quiet) {	double ratio = ((double) stream.length * 100) / real_size;	}	} else {	tc.writeline ("static const monobundledassembly assembly_bundle_{0} = {{\"{1}\", assembly_data_{0}, {2}}};", encoded, aname, real_size);	}	stream.close ();	c_bundle_names.add ("assembly_bundle_" + encoded);	try {	filestream cf = file.openread (fname + ".config");	
config from config 

if (!quiet) {	double ratio = ((double) stream.length * 100) / real_size;	}	} else {	tc.writeline ("static const monobundledassembly assembly_bundle_{0} = {{\"{1}\", assembly_data_{0}, {2}}};", encoded, aname, real_size);	}	stream.close ();	c_bundle_names.add ("assembly_bundle_" + encoded);	try {	filestream cf = file.openread (fname + ".config");	
extern const unsigned char assembly config 

}	}	if (config_file != null){	filestream conf;	try {	conf = file.openread (config_file);	} catch {	error ("failure to open {0}", config_file);	return;	}	
system config from 

}	}	if (config_file != null){	filestream conf;	try {	conf = file.openread (config_file);	} catch {	error ("failure to open {0}", config_file);	return;	}	
extern const char system config 

ts.writeline ();	}	if (machine_config_file != null){	filestream conf;	try {	conf = file.openread (machine_config_file);	} catch {	error ("failure to open {0}", machine_config_file);	return;	}	
machine config from 

ts.writeline ();	}	if (machine_config_file != null){	filestream conf;	try {	conf = file.openread (machine_config_file);	} catch {	error ("failure to open {0}", machine_config_file);	return;	}	
extern const char machine config 

writebuffer (ts, conf, buffer);	ts.write ("\t.byte 0\n");	ts.writeline ();	}	ts.close ();	if (compress) tc.writeline ("\nstatic const compressedassembly *compressed [] = {");	else tc.writeline ("\nstatic const monobundledassembly *bundled [] = {");	foreach (string c in c_bundle_names){	tc.writeline ("\t&{0},", c);	}	
null 

ts.write ("\t.byte 0\n");	ts.writeline ();	}	ts.close ();	if (compress) tc.writeline ("\nstatic const compressedassembly *compressed [] = {");	else tc.writeline ("\nstatic const monobundledassembly *bundled [] = {");	foreach (string c in c_bundle_names){	tc.writeline ("\t&{0},", c);	}	foreach (string asm in aot_names){	
extern const void mono aot module info 

ts.writeline ();	}	ts.close ();	if (compress) tc.writeline ("\nstatic const compressedassembly *compressed [] = {");	else tc.writeline ("\nstatic const monobundledassembly *bundled [] = {");	foreach (string c in c_bundle_names){	tc.writeline ("\t&{0},", c);	}	foreach (string asm in aot_names){	}	
static void install aot modules void 

}	ts.close ();	if (compress) tc.writeline ("\nstatic const compressedassembly *compressed [] = {");	else tc.writeline ("\nstatic const monobundledassembly *bundled [] = {");	foreach (string c in c_bundle_names){	tc.writeline ("\t&{0},", c);	}	foreach (string asm in aot_names){	}	foreach (string asm in aot_names){	
mono aot register module mono aot module info 

string enum_aot_mode;	switch (aot_mode) {	case "full": enum_aot_mode = "mono_aot_mode_full";	break;	case "llvmonly": enum_aot_mode = "mono_aot_mode_llvmonly";	break;	case "": enum_aot_mode = "mono_aot_mode_normal";	break;	default: throw new exception ("unsupported aot mode");	}	
mono jit set aot mode 

break;	case "llvmonly": enum_aot_mode = "mono_aot_mode_llvmonly";	break;	case "": enum_aot_mode = "mono_aot_mode_normal";	break;	default: throw new exception ("unsupported aot mode");	}	tc.writeline ("\n}\n");	tc.writeline ("static char *image_name = \"{0}\";", prog);	if (ctor_func != null) {	
extern void void 

break;	case "llvmonly": enum_aot_mode = "mono_aot_mode_llvmonly";	break;	case "": enum_aot_mode = "mono_aot_mode_normal";	break;	default: throw new exception ("unsupported aot mode");	}	tc.writeline ("\n}\n");	tc.writeline ("static char *image_name = \"{0}\";", prog);	if (ctor_func != null) {	
attribute constructor static void mono mkbundle ctor void 

break;	case "": enum_aot_mode = "mono_aot_mode_normal";	break;	default: throw new exception ("unsupported aot mode");	}	tc.writeline ("\n}\n");	tc.writeline ("static char *image_name = \"{0}\";", prog);	if (ctor_func != null) {	tc.writeline ("{{\n\t{0} ();\n}}", ctor_func);	}	
static void install dll config files void 

case "": enum_aot_mode = "mono_aot_mode_normal";	break;	default: throw new exception ("unsupported aot mode");	}	tc.writeline ("\n}\n");	tc.writeline ("static char *image_name = \"{0}\";", prog);	if (ctor_func != null) {	tc.writeline ("{{\n\t{0} ();\n}}", ctor_func);	}	foreach (string[] ass in config_names){	
mono register config for assembly assembly config 

if (!nomain && custom_main == null) {	stream template_main_stream = system.reflection.assembly.getassembly (typeof(makebundle)).getmanifestresourcestream ("template_main.c");	streamreader st = new streamreader (template_main_stream);	string maintemplate = st.readtoend ();	tc.write (maintemplate);	}	tc.close ();	string as_cmd = getassemblercommand (temp_s, temp_o);	execute(as_cmd);	if (compile_only) return;	
compiling 

smonolib = string.format ("{0}/mono/mini/.libs/libmonosgen-2.0.a", in_tree);	in_tree_include = string.format (" -i{0} ", in_tree);	}	cmd = string.format("{4} -o '{2}' -wall {7} `pkg-config --cflags mono-2` {9} {0} {3} " + "`pkg-config --libs-only-l mono-2` {5} {6} {8} " + "`pkg-config --libs-only-l mono-2 | sed -e \"s temp_c, temp_o, output, zlib, cc, smonolib, string.join (" ", aot_paths), objc, platform_libs, in_tree_include);	}	else {	cmd = string.format("{4} " + debugging + " -o '{2}' -wall {5} {0} `pkg-config --cflags --libs mono-2` {3} {1}", temp_c, temp_o, output, zlib, cc, objc);	}	execute (cmd);	}	
done 

foreach (string name in sources){	try {	assembly a = loadassemblyfile (name);	if (a == null){	error = true;	continue;	}	assemblies.add (a.codebase);	} catch (exception) {	if (skip_scan) {	
file will not be scanned 

foreach (string name in other) {	try {	assembly a = loadassembly (name);	if (a == null) {	error = "failed to load " + name;	continue;	}	assemblies.add (a.codebase);	} catch (exception) {	if (skip_scan) {	
file will not be scanned 

assemblies.add (a.codebase);	} catch (exception) {	if (skip_scan) {	assemblies.add (new uri (new fileinfo (name).fullname).tostring ());	} else {	throw;	}	}	}	if (error != null) {	
failure to load assemblies the following directories were searched for the assemblies 

} catch (exception) {	if (skip_scan) {	assemblies.add (new uri (new fileinfo (name).fullname).tostring ());	} else {	throw;	}	}	}	if (error != null) {	foreach (var path in link_paths){	
path 

assemblies.add (new uri (new fileinfo (name).fullname).tostring ());	} else {	throw;	}	}	}	if (error != null) {	foreach (var path in link_paths){	}	if (custom_mode){	
in custom mode you need to provide the directory to lookup assemblies from using l 

static readonly universe universe = new universe ();	static readonly dictionary<string, string> loaded_assemblies = new dictionary<string, string> ();	public static string getassemblyname (string path) {	string resourcepathseparator = style == "windows" ? "\\\\" : "/";	string name = path.getfilename (path);	if (name.endswith (".resources.dll", stringcomparison.ordinalignorecase)) {	string dir = path.getdirectoryname (path);	int idx = dir.lastindexof (path.directoryseparatorchar);	if (idx >= 0) {	name = dir.substring (idx + 1) + resourcepathseparator + name;	
storing satellite assembly path with name name 

static readonly universe universe = new universe ();	static readonly dictionary<string, string> loaded_assemblies = new dictionary<string, string> ();	public static string getassemblyname (string path) {	string resourcepathseparator = style == "windows" ? "\\\\" : "/";	string name = path.getfilename (path);	if (name.endswith (".resources.dll", stringcomparison.ordinalignorecase)) {	string dir = path.getdirectoryname (path);	int idx = dir.lastindexof (path.directoryseparatorchar);	if (idx >= 0) {	name = dir.substring (idx + 1) + resourcepathseparator + name;	
warning satellite assembly path doesn t have locale path prefix name conflicts possible 

if (!queueassembly (files, a.codebase)) return false;	}	} catch (exception) {	if (!skip_scan) throw;	}	return true;	}	static assembly loadassemblyfile (string assembly) {	assembly a = null;	try {	
attempting to load assembly 

}	} catch (exception) {	if (!skip_scan) throw;	}	return true;	}	static assembly loadassemblyfile (string assembly) {	assembly a = null;	try {	a = universe.loadfile (assembly);	
assembly loaded successfully 

error ($"cannot load assembly " + f.message);	} catch (argumentnullexception){	error( $"cannot load assembly (null argument)");	}	return a;	}	static assembly loadassembly (string assembly) {	string total_log = "";	foreach (string dir in link_paths){	string full_path = path.combine (dir, assembly);	
attempting to load assembly from 

string full_path = path.combine (dir, assembly);	if (!assembly.endswith (".dll") && !assembly.endswith (".exe")) full_path += ".dll";	try {	var a = universe.loadfile (full_path);	return a;	} catch (filenotfoundexception ff) {	total_log += ff.fusionlog;	continue;	}	}	
log 

var a = universe.loadfile (full_path);	return a;	} catch (filenotfoundexception ff) {	total_log += ff.fusionlog;	continue;	}	}	return null;	}	static void error (string msg, params object [] args) {	
error 

environment.exit (1);	}	var aot_mode_string = "";	if (aot_mode != null) aot_mode_string = "," + aot_mode;	var dedup_mode_string = "";	stringbuilder all_assemblies = null;	if (aot_dedup_assembly != null) {	dedup_mode_string = ",dedup-skip";	all_assemblies = new stringbuilder("");	}	
aoting files 

paths.append (new uri (file).localpath);	}	var cmd = string.format ("{0} {1} -b true -out {2} {3} -c link -p copy ", runtime, managed_linker_path, outdir, paths.tostring ());	execute (cmd);	}	static void preprocessassemblies (list <string> chosenfiles, list <string> files) {	if (aot_mode == "" || (cil_strip_path == null && managed_linker_path == null)) return;	var temp_dir_name = path.combine(directory.getcurrentdirectory(), "temp_assemblies");	aot_temp_dir = new directoryinfo (temp_dir_name);	if (aot_temp_dir.exists) {	
removing previous build cache at 

for (int i=0; i < files.count; i++) {	var in_name = new uri (files [i]).localpath;	var out_name = path.combine (temp_dir_name, path.getfilename (in_name));	file.copy (in_name, out_name);	files [i] = out_name;	if (in_name == aot_dedup_assembly) aot_dedup_assembly = out_name;	}	}	static void execute (string cmdline) {	if (isunix) {	
execute cmd 

error(string.format("[fail] {0}", ret));	}	return;	}	if (use_dos2unix == true) try {	var info = new processstartinfo ("dos2unix");	info.createnowindow = true;	info.redirectstandardinput = true;	info.useshellexecute = false;	var dos2unix = process.start (info);	
aaa 

var info = new processstartinfo ("dos2unix");	info.createnowindow = true;	info.redirectstandardinput = true;	info.useshellexecute = false;	var dos2unix = process.start (info);	dos2unix.standardinput.writeline ("\u0004");	dos2unix.standardinput.close ();	dos2unix.waitforexit ();	if (dos2unix.exitcode == 0) use_dos2unix = true;	} catch {	
warning not found 

string windowssdkheaderpath = path.combine (winkitincludedir, "um", "windows.h");	if (file.exists (windowssdkheaderpath)) windowssdks.add (new installedsdkinfo ("windowssdk", winkitrootversion, winkitrootdir, false));	string cruntimesdkheaderpath = path.combine (winkitincludedir, "ucrt", "stdlib.h");	if (file.exists (cruntimesdkheaderpath)) cruntimesdks.add (new installedsdkinfo ("cruntimesdk", winkitrootversion, winkitrootdir, false));	}	windowssdks = windowssdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	cruntimesdks = cruntimesdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	
windows sdk s 

if (file.exists (windowssdkheaderpath)) windowssdks.add (new installedsdkinfo ("windowssdk", winkitrootversion, winkitrootdir, false));	string cruntimesdkheaderpath = path.combine (winkitincludedir, "ucrt", "stdlib.h");	if (file.exists (cruntimesdkheaderpath)) cruntimesdks.add (new installedsdkinfo ("cruntimesdk", winkitrootversion, winkitrootdir, false));	}	windowssdks = windowssdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	cruntimesdks = cruntimesdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	foreach (var windowssdk in installedwindowssdks) {	
path 

if (file.exists (windowssdkheaderpath)) windowssdks.add (new installedsdkinfo ("windowssdk", winkitrootversion, winkitrootdir, false));	string cruntimesdkheaderpath = path.combine (winkitincludedir, "ucrt", "stdlib.h");	if (file.exists (cruntimesdkheaderpath)) cruntimesdks.add (new installedsdkinfo ("cruntimesdk", winkitrootversion, winkitrootdir, false));	}	windowssdks = windowssdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	cruntimesdks = cruntimesdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	foreach (var windowssdk in installedwindowssdks) {	
version 

windowssdks = windowssdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	cruntimesdks = cruntimesdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	foreach (var windowssdk in installedwindowssdks) {	}	console.writeline ("---------------");	}	if (!quiet && installedcruntimesdks != null) {	
c runtime sdk s 

cruntimesdks = cruntimesdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	foreach (var windowssdk in installedwindowssdks) {	}	console.writeline ("---------------");	}	if (!quiet && installedcruntimesdks != null) {	foreach (var cruntimesdk in installedcruntimesdks) {	
path 

cruntimesdks = cruntimesdks.orderbydescending (p => p.version.tostring (), new stringversioncomparer ()).tolist ();	installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	foreach (var windowssdk in installedwindowssdks) {	}	console.writeline ("---------------");	}	if (!quiet && installedcruntimesdks != null) {	foreach (var cruntimesdk in installedcruntimesdks) {	
version 

installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	foreach (var windowssdk in installedwindowssdks) {	}	console.writeline ("---------------");	}	if (!quiet && installedcruntimesdks != null) {	foreach (var cruntimesdk in installedcruntimesdks) {	if (cruntimesdk.parentsdk != null) {	
parent sdk path 

installedwindowssdks = windowssdks;	installedcruntimesdks = cruntimesdks;	if (!quiet && installedwindowssdks != null) {	foreach (var windowssdk in installedwindowssdks) {	}	console.writeline ("---------------");	}	if (!quiet && installedcruntimesdks != null) {	foreach (var cruntimesdk in installedcruntimesdks) {	if (cruntimesdk.parentsdk != null) {	
parent sdk version 

foreach (string lib in libpaths) librarianargs.add (string.format ("-l {0}", librarian.quotearg (lib)));	addmonolibraries (librarian, staticlinkmono, staticlinkcruntime, librarianargs);	librarianargs.add ("-o " + librarian.quotearg (output));	return;	}	static toolchainprogram getassemblercompiler () {	string assembler = getenv ("as", "");	if (assembler.length != 0) return new toolchainprogram ("as", assembler);	var vcclangassembler = visualstudiosdktoolchainhelper.getinstance ().getvcclangcompiler ();	if (vcclangassembler == null || vcclangassembler.path.length == 0) {	
warning couldn t find installed visual studio sdk clang with microsoft codegen fallback to mingw as exe and default environment 

return vcclangassembler;	}	static toolchainprogram getccompiler (bool staticlinkmono, bool staticlinkcruntime) {	toolchainprogram program = null;	string compiler = getenv ("cc", "");	if (compiler.length != 0) {	program = new toolchainprogram ("cc", compiler);	} else {	program = visualstudiosdktoolchainhelper.getinstance ().getvccompiler ();	if (program == null || program.path.length == 0) {	
warning couldn t find installed visual studio sdk fallback to cl exe and default environment 

if (compiler.length != 0) {	program = new toolchainprogram ("cc", compiler);	} else {	program = visualstudiosdktoolchainhelper.getinstance ().getvccompiler ();	if (program == null || program.path.length == 0) {	program = new toolchainprogram ("cl.exe", "cl.exe");	}	}	string monolibrarypath = getmonolibrarypath (program, staticlinkmono, staticlinkcruntime);	if (!file.exists (monolibrarypath) && program.isvstoolchain) {	
warning couldn t find installed matching mono library fallback to mingw gcc exe and default environment 

string monolibrarypath = getmonolibrarypath (program, staticlinkmono, staticlinkcruntime);	if (!file.exists (monolibrarypath) && program.isvstoolchain) {	string gcccompiler = target64bitapplication () ? "x86_64-w64-mingw32-gcc.exe" : "i686-w64-mingw32-gcc.exe";	program = new toolchainprogram (gcccompiler, gcccompiler);	}	return program;	}	static toolchainprogram getlibrarian () {	toolchainprogram vclibrarian = visualstudiosdktoolchainhelper.getinstance ().getvclibrarian ();	if (vclibrarian == null || vclibrarian.path.length == 0) {	
warning couldn t find installed visual studio sdk fallback to lib exe and default environment 

========================= mono sample_1300 =========================

if (i != 3) return 6;	i = 1;	if (test (b: i++, a: i++) != 13) return 7;	a a = new a ();	i = 5;	a [i:i++]++;	if (a.id != 1) return 8;	if (i != 6) return 9;	mypoint mp = new mypoint (y : -1, x : 5);	if (mp.y != -1) return 10;	
ok 

========================= mono sample_3345 =========================

b = b - 2;	if (b != (myenum)252) return 3;	me -= myenum.value_1;	b = (myenum)255;	b &= ~myenum.value_1;	if (b != (myenum)254) return 4;	var e = e.v;	checked {	var res = ~e;	}	
ok 

========================= mono sample_2029 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	var d = new dynamicobjectmock ();	test.invoke (new tester (), new[] { d, d });	if (d.hitcounter < 1) assert (true, false, "hitcounter");	
ok 

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	var d = new dynamicobjectmock ();	test.invoke (new tester (), new[] { d, d });	if (d.hitcounter < 1) assert (true, false, "hitcounter");	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 2 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_2864 =========================

public override void computemastersecret(byte[] premastersecret) {	tlsstream mastersecret = new tlsstream();	mastersecret.write(this.prf(premastersecret, "a", this.context.randomcs));	mastersecret.write(this.prf(premastersecret, "bb", this.context.randomcs));	mastersecret.write(this.prf(premastersecret, "ccc", this.context.randomcs));	this.context.mastersecret = mastersecret.toarray();	
mastersecret 

md5.initialize();	temp = md5.computehash(this.context.randomsc, 0, this.context.randomsc.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(temp, 0, this.context.serverwriteiv, 0, this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
keyblock 

md5.initialize();	temp = md5.computehash(this.context.randomsc, 0, this.context.randomsc.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(temp, 0, this.context.serverwriteiv, 0, this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
clientwritekey 

md5.initialize();	temp = md5.computehash(this.context.randomsc, 0, this.context.randomsc.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(temp, 0, this.context.serverwriteiv, 0, this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
clientwriteiv 

md5.initialize();	temp = md5.computehash(this.context.randomsc, 0, this.context.randomsc.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(temp, 0, this.context.serverwriteiv, 0, this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
clientwritemac 

md5.initialize();	temp = md5.computehash(this.context.randomsc, 0, this.context.randomsc.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(temp, 0, this.context.serverwriteiv, 0, this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
serverwritekey 

md5.initialize();	temp = md5.computehash(this.context.randomsc, 0, this.context.randomsc.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(temp, 0, this.context.serverwriteiv, 0, this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
serverwriteiv 

md5.initialize();	temp = md5.computehash(this.context.randomsc, 0, this.context.randomsc.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(temp, 0, this.context.serverwriteiv, 0, this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
serverwritemac 

========================= mono sample_31881 =========================

static void main () {	try {	
test 

========================= mono sample_33984 =========================

public static void main () {	
test x 

========================= mono sample_2767 =========================

public void updateattribute(string testdata) {	
got it 

========================= mono sample_29295 =========================

public void listallusers_tostring () {	try {	
listing all users 

========================= mono sample_21988 =========================

public override assembly loadassemblyfile (string filename, bool isimplicitreference) {	bool? has_extension = null;	foreach (var path in paths) {	var file = path.combine (path, filename);	
probing assembly location 

assemblycomparisonresult result;	if ((an.flags & assemblynameflags.publickey) == (loaded_name.flags & assemblynameflags.publickey) && (domain.compareassemblyidentity (an.fullname, false, loaded_name.fullname, false, out result))) {	switch (result) {	case assemblycomparisonresult.equivalentfxunified: case assemblycomparisonresult.equivalentunified: compiler.report.symbolrelatedtopreviouserror (entry.item2);	compiler.report.symbolrelatedtopreviouserror (filename);	compiler.report.error (1703, "an assembly `{0}' with the same identity has already been imported. consider removing one of the references", an.name);	return null;	}	}	}	
loading assembly 

return null;	}	}	}	var assembly = domain.loadassembly (module);	if (assembly != null) loaded_names.add (tuple.create (an, filename, assembly));	return assembly;	}	}	} catch (exception e) {	
exception during loading 

========================= mono sample_36391 =========================

options.add ("help", "", sethelp, hidden: true);	}	if (!options.contains ("?")) {	options.add ("?", "", sethelp, hidden: true);	}	var extra   = options.parse (arguments);	if (extra.count == 0) {	if (showhelp) {	return help.invoke (extra);	}	
use suite help for usage 

public override int invoke (ienumerable<string> arguments) {	var extra   = new list<string> (arguments ?? new string [0]);	var _       = commandset.options.messagelocalizer;	if (extra.count == 0) {	commandset.options.writeoptiondescriptions (commandset.out);	return 0;	}	var command = commandset.contains (extra [0]) ? commandset [extra [0]]	: null;	if (command == this || extra [0] == "--help") {	
usage commandset suite command options 

public override int invoke (ienumerable<string> arguments) {	var extra   = new list<string> (arguments ?? new string [0]);	var _       = commandset.options.messagelocalizer;	if (extra.count == 0) {	commandset.options.writeoptiondescriptions (commandset.out);	return 0;	}	var command = commandset.contains (extra [0]) ? commandset [extra [0]]	: null;	if (command == this || extra [0] == "--help") {	
use commandset suite help command for help on a specific command 

var extra   = new list<string> (arguments ?? new string [0]);	var _       = commandset.options.messagelocalizer;	if (extra.count == 0) {	commandset.options.writeoptiondescriptions (commandset.out);	return 0;	}	var command = commandset.contains (extra [0]) ? commandset [extra [0]]	: null;	if (command == this || extra [0] == "--help") {	commandset.out.writeline ();	
available commands 

========================= mono sample_32549 =========================

public static int main () {	out (out int o);	if (o != 3) return 1;	if (out (out int o1)) {	if (o1 != 3) return 2;	}	out (out var o3);	if (o3 != 3) return 4;	out2 (str: "b", v: out var o5);	if (o5 != 9) return 7;	
ok 

========================= mono sample_2545 =========================

public static int main () {	int result = test ();	if (result != 0) console.writeline ("error: {0}", result);	
ok 

========================= mono sample_2897 =========================

test.checkvalue (sb, new stringbuilder ("un"), 190);	stringbuilder sb2 = new stringbuilder ("prefix");	stringbuilder sb3 = server.run9_2 (sb2);	test.checkvalue (sb2, new stringbuilder ("prefix"), 192);	test.checkvalue (sb3, new stringbuilder ("prefix-middle"), 192);	stringbuilder sb4 = server.run9_3 (sb3);	test.checkvalue (sb3, new stringbuilder ("prefix-middle"), 193);	test.checkvalue (sb4, new stringbuilder ("prefix-middle-end"), 193);	}	catch (testexception ex) {	
test error 

test.checkvalue (sb2, new stringbuilder ("prefix"), 192);	test.checkvalue (sb3, new stringbuilder ("prefix-middle"), 192);	stringbuilder sb4 = server.run9_3 (sb3);	test.checkvalue (sb3, new stringbuilder ("prefix-middle"), 193);	test.checkvalue (sb4, new stringbuilder ("prefix-middle-end"), 193);	}	catch (testexception ex) {	return ex.code;	}	catch (exception ex) {	
test error 

========================= mono sample_289 =========================

public override void writeusingnamespace(string name) {	if (writtennamespaces.contains(name)) return;	writtennamespaces.add(name);	
using 

public override idisposable writenamespace(string name) {	
namespace 

public override idisposable writeregion(string name) {	
region 

public override idisposable writeregion(string name) {	writeline();	
endregion 

public override void writeautomaticpropertygetset() {	
get set 

public override idisposable writepropertyget() {	
get 

public override idisposable writepropertyset() {	
set 

public override void writepropertywithbackingfield(specificationdefinition specificationdefinition, string name, string propertytype, bool privatesetter) {	writefieldorproperty(specificationdefinition, name, propertytype);	
get set private 

public override idisposable writeif(string expression) {	
if 

public override void writerawif(string expression) {	
if 

public override void writerawif(string expression) {	writeline("{");	}	public override void writerawelse() {	writeline("}");	
else 

public override idisposable writeenum(specificationdefinition specificationdefinition, string name) {	
enum 

========================= mono sample_25067 =========================

static void validationcallback (object sender, validationeventargs e) {	
validation error 

========================= mono sample_29130 =========================

if (null < null) return 10;	if ((int?)null < null) return 11;	if (null <= null) return 12;	if ((int?)null <= null) return 13;	if ((null * null) != null) return 20;	if ((null / null) != null) return 21;	if ((null % null) != null) return 22;	if ((null - null) != null) return 22;	if ((null >> null) != null) return 23;	if ((null << null) != null) return 24;	
ok 

========================= mono sample_2941 =========================

public static void main (string[] args) {	servicepointmanager.certificatepolicy = new testcertificatepolicy ();	string postdata = "test=";	byte[] bytes = encoding.default.getbytes (postdata);	for (int i = 0; i < buffersize; i++) data[i] = 65;	int id = 1;	foreach (string url in args) {	
post at 

private static void responsecallback (iasyncresult result) {	state state = ((state) result.asyncstate);	httpwebresponse response = (httpwebresponse) state.request.endgetresponse (result);	stream stream = response.getresponsestream ();	streamreader sr = new streamreader (stream, encoding.utf8);	string received = sr.readtoend ();	if (data.length != received.length) {	
echo invalid length expected 

httpwebresponse response = (httpwebresponse) state.request.endgetresponse (result);	stream stream = response.getresponsestream ();	streamreader sr = new streamreader (stream, encoding.utf8);	string received = sr.readtoend ();	if (data.length != received.length) {	} else {	bool ok = true;	for (int i = 0; i < received.length; i++) {	if (received[i] != 'a') {	ok = false;	
echo error at position received 

string received = sr.readtoend ();	if (data.length != received.length) {	} else {	bool ok = true;	for (int i = 0; i < received.length; i++) {	if (received[i] != 'a') {	ok = false;	break;	}	}	
echo result ok length 

========================= mono sample_20582 =========================

values.add (exceptionpagetemplate.template_fullstacktracename, formatfullstacktrace ());	htmlizedexception htmlexception = ex as htmlizedexception;	if (htmlexception == null) filldefaulterrorvalues (true, true, ex, values);	else {	pagetype = exceptionpagetemplatetype.htmlized;	fillhtmlizederrorvalues (values, htmlexception, ref pagetype);	}	}	return template.render (values, pagetype);	} catch (exception ex) {	
an exception has occurred while generating httpexception page 

if (htmlexception == null) filldefaulterrorvalues (true, true, ex, values);	else {	pagetype = exceptionpagetemplatetype.htmlized;	fillhtmlizederrorvalues (values, htmlexception, ref pagetype);	}	}	return template.render (values, pagetype);	} catch (exception ex) {	console.error.writeline (ex);	console.error.writeline ();	
the actual exception which was being reported was 

public static httpexception createfromlasterror (string message) {	
createfromlasterror 

========================= mono sample_19997 =========================

public static void main () {	
hello 

========================= mono sample_2431 =========================

public void method (int i) {	throw new argumentnullexception ();	
once upon a time 

========================= mono sample_34020 =========================

public static void run() {	{	multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count is 

public static void run() {	{	multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count keys is 

public static void run() {	{	multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count is 

multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	
mdict count is 

mdict.add(20, "twenty");	console.writeline(mdict);	mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	
mdict count is 

mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	
mdict count is 

icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	
mdict count is 

icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	
mdict contains key 

mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	
mdict count is 

console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	zwei.remove("kaksi");	console.writeline(mdict);	
mdict count is 

console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	zwei.remove("kaksi");	console.writeline(mdict);	zwei.clear();	console.writeline(mdict);	
mdict count is 

public static void run() {	{	multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count is 

public static void run() {	{	multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count keys is 

public static void run() {	{	multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count is 

multihashdictionary<int,string> mdict = new multihashdictionary<int,string>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	
mdict count is 

mdict.add(20, "twenty");	console.writeline(mdict);	mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	
mdict count is 

mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	
mdict count is 

icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	
mdict count is 

icollection<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	
mdict contains key 

mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	
mdict count is 

console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	zwei.remove("kaksi");	console.writeline(mdict);	
mdict count is 

console.writeline(mdict);	icollection<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	zwei.remove("kaksi");	console.writeline(mdict);	zwei.clear();	console.writeline(mdict);	
mdict count is 

console.writeline("------------------------------");	}	{	multihashdictionary<int,string,hashset<string>> mdict = new multihashdictionary<int,string,hashset<string>>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count is 

console.writeline("------------------------------");	}	{	multihashdictionary<int,string,hashset<string>> mdict = new multihashdictionary<int,string,hashset<string>>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count keys is 

console.writeline("------------------------------");	}	{	multihashdictionary<int,string,hashset<string>> mdict = new multihashdictionary<int,string,hashset<string>>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	
mdict count is 

multihashdictionary<int,string,hashset<string>> mdict = new multihashdictionary<int,string,hashset<string>>();	mdict.add(2, "to");	mdict.add(2, "deux");	mdict.add(2, "two");	mdict.add(20, "tyve");	mdict.add(20, "twenty");	console.writeline(mdict);	mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	
mdict count is 

mdict.add(20, "twenty");	console.writeline(mdict);	mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	hashset<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	
mdict count is 

mdict.remove(20, "tyve");	mdict.remove(20, "twenty");	console.writeline(mdict);	hashset<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	
mdict count is 

hashset<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	hashset<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	
mdict count is 

hashset<string> zwei = new hashset<string>();	zwei.add("zwei");	mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	hashset<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	
mdict contains key 

mdict[2] = zwei;	mdict[-2] = zwei;	console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	hashset<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	
mdict count is 

console.writeline(mdict);	zwei.add("kaksi");	console.writeline(mdict);	hashset<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	zwei.remove("kaksi");	console.writeline(mdict);	
mdict count is 

console.writeline(mdict);	hashset<string> empty = new hashset<string>();	mdict[0] = empty;	console.writeline(mdict);	mdict.remove(-2);	console.writeline(mdict);	zwei.remove("kaksi");	console.writeline(mdict);	zwei.clear();	console.writeline(mdict);	
mdict count is 

========================= mono sample_30569 =========================

public virtual bool check() {	int count = 0;	#if linearprobing int lasthole = table.length - 1;	#if refbucket while (lasthole >= 0 && table[lasthole] != null) #else while (lasthole >= 0 && !isnull(table[lasthole].item)) #endif {	lasthole--;	count++;	}	if (lasthole < 0) {	
table is completely filled 

========================= mono sample_30538 =========================

static void main () {	
hola 

========================= mono sample_36154 =========================

public static int main (string[] args) {	location.inemacs = environment.getenvironmentvariable ("emacs") == "t";	commandlineparser cmd = new commandlineparser (console.out);	var settings = cmd.parsearguments (args);	if (settings == null) return 1;	if (cmd.hasbeenstopped) return 0;	driver d = new driver (new compilercontext (settings, new consolereportprinter ()));	if (d.compile () && d.report.errors == 0) {	if (d.report.warnings > 0) {	
compilation succeeded warning s 

var settings = cmd.parsearguments (args);	if (settings == null) return 1;	if (cmd.hasbeenstopped) return 0;	driver d = new driver (new compilercontext (settings, new consolereportprinter ()));	if (d.compile () && d.report.errors == 0) {	if (d.report.warnings > 0) {	}	environment.exit (0);	return 0;	}	
compilation failed error s warnings 

========================= mono sample_36385 =========================

cp.write (name + " [");	for (int n=0; n<parametertypes.length; n++) {	if (n > 0) cp.write (", ");	cp.write (parametertypes[n] + " arg" + n);	}	cp.write ("]");	}	cp.write (" {");	cp.endline ();	cp.indent ();	
get 

if (n > 0) cp.write (", ");	cp.write (parametertypes[n] + " arg" + n);	}	cp.write ("]");	}	cp.write (" {");	cp.endline ();	cp.indent ();	get_builder.printcode (cp);	cp.writelineunind ("}");	
set 

========================= mono sample_31674 =========================

console.write (n.prefix);	console.write (' ');	console.write (n.name);	console.write (' ');	console.write (n.localname);	console.write (' ');	console.write (n.namespaceuri);	console.write (' ');	console.write (n.value);	console.writeline (' ');	
attributes 

console.write (' ');	console.write (n.value);	console.writeline (' ');	console.write (n.attributes != null);	if (n.attributes != null) {	console.write (' ');	console.write (n.attributes.count);	console.write (' ');	for (int i = 0; i < n.attributes.count; i++) dumpdom (n.attributes [i]);	}	
attributes end 

console.write (' ');	console.write (n.value);	console.writeline (' ');	console.write (n.attributes != null);	if (n.attributes != null) {	console.write (' ');	console.write (n.attributes.count);	console.write (' ');	for (int i = 0; i < n.attributes.count; i++) dumpdom (n.attributes [i]);	}	
childnodes 

console.write (' ');	for (int i = 0; i < n.attributes.count; i++) dumpdom (n.attributes [i]);	}	console.write (n.childnodes != null);	if (n.childnodes != null) {	console.write (' ');	console.write (n.childnodes.count);	console.write (' ');	for (int i = 0; i < n.childnodes.count; i++) dumpdom (n.childnodes [i]);	}	
childnodes end 

========================= mono sample_22405 =========================

}	path.add(start);	ilist<v> view = path.view(0, 1);	while (adjacent.count > 0) {	v current = view[0];	if (debug) console.writeline("==> {0}", current);	while (adjacent.count > 0) {	if (debug) console.writeline(" => {0}, {1}", current, path.count);	v next = adjacent.removefirst();	view.add(next);	
edge 

}	path.add(start);	ilist<v> view = path.view(0, 1);	while (adjacent.count > 0) {	v current = view[0];	if (debug) console.writeline("==> {0}", current);	while (adjacent.count > 0) {	if (debug) console.writeline(" => {0}, {1}", current, path.count);	v next = adjacent.removefirst();	view.add(next);	
bad 

public void print(system.io.textwriter output) {	
graph has vertices edges components 

static void test1() {	igraph<int, int, int> g = new hashgraph<int, int, int>(new countweight<int>(), grid(3));	
edge count 

static void test1() {	igraph<int, int, int> g = new hashgraph<int, int, int>(new countweight<int>(), grid(3));	
bfs 

static void test1() {	igraph<int, int, int> g = new hashgraph<int, int, int>(new countweight<int>(), grid(3));	g.traversevertices(true, 1001, delegate(edge<int, int> e) { console.writeline(e); });	
dfs 

static void testcomp() {	igraph<string, int, int> g = new hashgraph<string, int, int>(new countweight<int>(), forest(2, 2));	
forest has vertices edges components 

static void testcomp() {	igraph<string, int, int> g = new hashgraph<string, int, int>(new countweight<int>(), forest(2, 2));	foreach (keyvaluepair<string, igraph<string, int, int>> comp in g.components()) {	
component of 

static void test3() {	hashgraph<int, int, int> g = new hashgraph<int, int, int>(new countweight<int>(), grid(5));	g.print(console.out);	console.writeline("========= pfs accum =========");	
edge at distance 

static void test3() {	hashgraph<int, int, int> g = new hashgraph<int, int, int>(new countweight<int>(), grid(5));	g.print(console.out);	console.writeline("========= pfs accum =========");	console.writeline("========= pfs not accum =========");	
edge at distance 

static void test4() {	igraph<string, int, int> g = new hashgraph<string, int, int>(new intweight(), snake(5));	
edge count 

static void test4() {	igraph<string, int, int> g = new hashgraph<string, int, int>(new intweight(), snake(5));	console.writeline("========= pfs =========");	
edge at distance 

static void test4() {	igraph<string, int, int> g = new hashgraph<string, int, int>(new intweight(), snake(5));	console.writeline("========= pfs =========");	console.writeline("========= mst =========");	string root;	igraph<string, int, int> mst = g.minimumspanningtree(out root);	mst.print(console.out);	
dfs 

static void test4() {	igraph<string, int, int> g = new hashgraph<string, int, int>(new intweight(), snake(5));	console.writeline("========= pfs =========");	console.writeline("========= mst =========");	string root;	igraph<string, int, int> mst = g.minimumspanningtree(out root);	mst.print(console.out);	mst.traversevertices(false, root, delegate(edge<string, int> e) { console.writeline(e); });	
atsp 

static void testpfs() {	igraph<string, double, double> g = new hashgraph<string, double, double>(new doubleweight(), wheel(false, 10));	g.print(console.out);	console.writeline("========= pfs non-accumulated weights (-> mst) =========");	
edge at distance 

static void testpfs() {	igraph<string, double, double> g = new hashgraph<string, double, double>(new doubleweight(), wheel(false, 10));	g.print(console.out);	console.writeline("========= pfs non-accumulated weights (-> mst) =========");	console.writeline("========= pfs accumulated weights (-> shortst paths from start) =========");	
edge at distance 

static void testtsp() {	igraph<string, double, double> g = new hashgraph<string, double, double>(new doubleweight(), wheel(true, 10));	console.writeline("========= mst =========");	string root;	igraph<string, double, double> mst = g.minimumspanningtree(out root);	
edge 

static void testtsp2() {	hashgraph<string, double, double> g = new hashgraph<string, double, double>(new doubleweight(), wheel(true, 20));	foreach (string s in g.approximatetsp2()) console.writeline("# " + s);	console.writeline("========= mst =========");	string root;	igraph<string, double, double> mst = g.minimumspanningtree(out root);	
edge 

if (leastindexreachable >= startind) console.writeline("articulation point: {0} (least index reachable via {3} is {1} >= this index {2})", e.start, leastindexreachable, startind, e);	if (leastindexreachablefrom[startind] > leastindexreachable) leastindexreachablefrom[startind] = leastindexreachable;	}	};	action<edge<string, int>> onnotfollowed = delegate(edge<string, int> e) {	int startind = index[e.start], endind = index[e.end];	if (leastindexreachablefrom[startind] > endind) leastindexreachablefrom[startind] = endind;	};	string root = "c";	g.depthfirstsearch(root, beforevertex, aftervertex, onfollow, onfollowed, onnotfollowed);	
edges 

static void main(string[] args) {	if (args.length != 1) {	
usage graph exe testno 

}	}	}	else {	string testmethodname = string.format("test{0}", args[0]);	system.reflection.methodinfo mi = typeof(test).getmethod(testmethodname, system.reflection.bindingflags.static | system.reflection.bindingflags.nonpublic);	if (mi == null) console.writeline("no such testmethod, {0}", testmethodname);	else {	object[] attrs = mi.getcustomattributes(typeof(exampledescriptionattribute), false);	console.writeline("============================== {0}() ==================================", testmethodname);	
description none 

========================= mono sample_30549 =========================

public errorcs0052 method () {	
the compile should advice the return type of this method is less accessible than the method 

========================= mono sample_36236 =========================

sel.multiple = true;	assert.areequal (true, sel.multiple, "multiple");	sel.selectedindex = 6;	assert.areequal (-1, sel.selectedindex, "selectedindex");	sel.size = 7;	assert.areequal (7, sel.size, "size");	sel.value = "*8*";	assert.areequal (string.empty, sel.value, "value");	assert.areequal (5, sel.attributes.count, "attributes.count");	foreach (string key in sel.attributes.keys) {	
attr key is 

sel.size = 7;	assert.areequal (7, sel.size, "size");	sel.value = "*8*";	assert.areequal (string.empty, sel.value, "value");	assert.areequal (5, sel.attributes.count, "attributes.count");	foreach (string key in sel.attributes.keys) {	}	statebag sb = sel.getviewstate ();	assert.areequal (5, sb.count, "viewstate count");	foreach (string key in sb.keys) {	
vs key is 

========================= mono sample_18589 =========================

public override int test () {	
b 

========================= mono sample_4038 =========================

errorlog.addentry(record);	ok = false;	}	if (memberpath.areallmembersnullable(childcolumns) == false && parentend.relationshipmultiplicity != relationshipmultiplicity.one) {	string message = system.data.entity.strings.viewgen_foreign_key_lowerbound_mustbeone(touserstring(), cell.cquery.extent.name, parentend.name);	errorlog.record record = new errorlog.record(true, viewgenerrorcode.foreignkeylowerboundmustbeone, message, cell, string.empty);	errorlog.addentry(record);	ok = false;	}	if (config.isnormaltracing && ok) {	
foreign key mapped to relationship 

========================= mono sample_13339 =========================

public bool execute () {	taskengine	taskengine;	logtaskstarted ();	itask task;	try {	task = initializetask ();	} catch (exception e) {	
error initializing task 

return false;	}	try {	taskengine = new taskengine (parenttarget.project, task, type);	taskengine.prepare (getparameters ());	var result = taskengine.execute ();	if (result) taskengine.publishoutput (taskelement, taskengine.valuefromexecution);	logtaskfinished (result);	return result;	} catch (exception e) {	
error executing task 

========================= mono sample_29097 =========================

public void buildstartedhandler (object sender, buildstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	writeline (string.empty);	
build started 

public void projectstartedhandler (projectstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	setcolor (eventcolor);	
project target s default 

public void projectfinishedhandler (projectfinishedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	if (indent == 1) indent --;	setcolor (eventcolor);	
done building project failed 

public void targetstartedhandler (targetstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.normal)) {	indent++;	setcolor (eventcolor);	writeline (string.empty);	
target 

public void targetfinishedhandler (targetfinishedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.detailed) || (!args.succeeded && isverbositygreaterorequal (loggerverbosity.normal))) {	setcolor (eventcolor);	
done building target in project failed 

public void taskstartedhandler (taskstartedeventargs args) {	if (isverbositygreaterorequal (loggerverbosity.detailed)) {	setcolor (eventcolor);	
task 

public void taskfinishedhandler (taskfinishedeventargs args) {	indent--;	if (isverbositygreaterorequal (loggerverbosity.detailed) || (!args.succeeded && isverbositygreaterorequal (loggerverbosity.normal))) {	setcolor (eventcolor);	
done executing task 

public void taskfinishedhandler (taskfinishedeventargs args) {	indent--;	if (isverbositygreaterorequal (loggerverbosity.detailed) || (!args.succeeded && isverbositygreaterorequal (loggerverbosity.normal))) {	setcolor (eventcolor);	
task execution failed 

========================= mono sample_29124 =========================

public int foo () {	
aa 

public int foo () {	
b 

========================= mono sample_2596 =========================

public static int main () {	arraylist a = new arraylist ();	for (int i = 0; i < 10; i++) a.add (i);	arraylist even = find (delegate (object arg) {	return ((((int) arg) % 2) == 0);	}, a);	
even numbers 

========================= mono sample_2844 =========================

static void main () {	
test 

========================= mono sample_33338 =========================

public static int test5 () {	int a;	try {	
try 

========================= mono sample_34558 =========================

public static int main() {	system.reflection.assembly asm = system.reflection.assembly.loadfrom("module-cctor.exe");	
assembly loaded 

public static int main() {	system.reflection.assembly asm = system.reflection.assembly.loadfrom("module-cctor.exe");	type type = asm.gettype("ns.testclass", true);	
got type ns testclass 

public static int main() {	system.reflection.assembly asm = system.reflection.assembly.loadfrom("module-cctor.exe");	type type = asm.gettype("ns.testclass", true);	system.reflection.fieldinfo field = type.getfield("testfield");	
about to get value of testfield 

public static int main() {	system.reflection.assembly asm = system.reflection.assembly.loadfrom("module-cctor.exe");	type type = asm.gettype("ns.testclass", true);	system.reflection.fieldinfo field = type.getfield("testfield");	
got field testfield 

public static int main() {	system.reflection.assembly asm = system.reflection.assembly.loadfrom("module-cctor.exe");	type type = asm.gettype("ns.testclass", true);	system.reflection.fieldinfo field = type.getfield("testfield");	int val = (int)field.getvalue(null);	
value of field 

========================= mono sample_582 =========================

static threadtrace() {	logfilename = environment.getenvironmentvariable("threadtrace");	if (logfilename == null) logfilename = "";	isenabled = logfilename.length > 0;	if (isenabled) {	slot = thread.allocatedataslot();	logs = new list<threadlog>();	nativemethods.queryperformancefrequency(out frequency);	
threadtrace enabled 

static void threadproc() {	while (!stoptracing) {	thread.sleep(20000);	writelogfile();	
threadtrace saved 

========================= mono sample_15308 =========================

static void worker () {	
thread start 

========================= mono sample_493 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
ismachinelevel 

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
file 

========================= mono sample_29829 =========================

public void stop (bool abort) {	list<ichannellistener> channelslist = registered_channels [channel_listener.uri];	channelslist.remove (channel_listener);	try {	foreach (var ctx in pending) ctx.abort ();	} catch (exception ex) {	
error during http channel listener shutdown 

========================= mono sample_32145 =========================

static public void createbitmap (string filename, imageformat imgfmt) {	bitmap	bmp = new bitmap (100, 100, pixelformat.format24bpprgb);	console.writeline ("bitmap created ok {0}", bmp != null);	if ( bmp != null) {	
bitmap pixelformat 

console.writeline ("graphics created ok {0}", gr != null);	if (gr != null) {	pen p = new pen (color.red, 2);	gr.drawline (p, 10.0f, 10.0f, 90.0f, 90.0f);	gr.drawrectangle (p, 10.0f, 10.0f, 80.0f, 80.0f);	p.dispose ();	}	bmp.save (filename, imgfmt);	gr.dispose ();	bmp.dispose ();	
bitmap stored to 

static public void paintonbitmap (string filename, string newname, imageformat imgfmt) {	bitmap	bmp = new bitmap (filename);	console.writeline ("bitmap read ok {0}", bmp != null);	if (bmp != null) {	
bitmap pixelformat 

console.writeline ("graphics created ok {0}", gr != null);	if (gr != null) {	pen p = new pen (color.blue, 2);	gr.drawline (p, 20.0f, 20.0f, 80.0f, 80.0f);	gr.drawrectangle (p, 20.0f, 20.0f, 60.0f, 60.0f);	p.dispose ();	}	bmp.save (newname, imgfmt);	gr.dispose ();	bmp.dispose ();	
modified bitmap stored to 

========================= mono sample_21334 =========================

count0 ++;	}	s.position = 0;	do {	buf = new byte [1];	ar = s.beginread (buf, 0, 1, ac, buf);	} while (s.endread (ar) == 1);	thread.sleep (100);	s.close ();	count0 ++;	
csum 

count0 ++;	}	s.position = 0;	do {	buf = new byte [1];	ar = s.beginread (buf, 0, 1, ac, buf);	} while (s.endread (ar) == 1);	thread.sleep (100);	s.close ();	count0 ++;	
count 

========================= mono sample_642 =========================

public int test (int x) {	
in 

public void run () {	try {	while (true) thread.sleep (100);	}	catch (threadabortexception ex) {	
thread aborted correctly 

public static void threadstart (object obj) {	irunnable runnable = (irunnable)obj;	try {	runnable.run ();	} catch (appdomainunloadedexception) {	
ok 

public static int test_0_unload_during_unload () {	appdomain domain = appdomain.createdomain ("test3");	object o = domain.createinstancefromandunwrap (typeof (tests).assembly.location, "slowfinalize");	unloadthread t = new unloadthread (domain);	new thread (new threadstart (t.run)).start ();	thread.sleep (100);	try {	appdomain.unload (domain);	}	catch (exception) {	
ok 

========================= mono sample_460 =========================

public static int main () {	x x = new x ();	((ia) x).draw ();	
ia 

public static int main () {	x x = new x ();	((ia) x).draw ();	
ib 

public static int main () {	x x = new x ();	((ia) x).draw ();	if (x.ib_called) return 1;	if (!x.ia_called) return 2;	x y = new x ();	((ib) y).draw ();	
ia 

public static int main () {	x x = new x ();	((ia) x).draw ();	if (x.ib_called) return 1;	if (!x.ia_called) return 2;	x y = new x ();	((ib) y).draw ();	
ib 

public static int main () {	x x = new x ();	((ia) x).draw ();	if (x.ib_called) return 1;	if (!x.ia_called) return 2;	x y = new x ();	((ib) y).draw ();	if (!y.ib_called) return 3;	if (y.ia_called) return 4;	
all tests pass 

========================= mono sample_1382 =========================

private void thread_func() {	localdatastoreslot namedslot=thread.getnameddataslot("data-slot");	
in a thread 

private void thread_func() {	localdatastoreslot namedslot=thread.getnameddataslot("data-slot");	thread thr=thread.currentthread;	
found thread 

private void thread_func() {	localdatastoreslot namedslot=thread.getnameddataslot("data-slot");	thread thr=thread.currentthread;	thr.name="wobble";	thread otherthr=thread.currentthread;	
other subthread is 

private void thread_func() {	localdatastoreslot namedslot=thread.getnameddataslot("data-slot");	thread thr=thread.currentthread;	thr.name="wobble";	thread otherthr=thread.currentthread;	thread.setdata(slot, thr);	thread storedthr=(thread)thread.getdata(slot);	
stored subthread is 

private void thread_func() {	localdatastoreslot namedslot=thread.getnameddataslot("data-slot");	thread thr=thread.currentthread;	thr.name="wobble";	thread otherthr=thread.currentthread;	thread.setdata(slot, thr);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, thr);	storedthr=(thread)thread.getdata(namedslot);	
stored subthread is 

private void thread_func() {	localdatastoreslot namedslot=thread.getnameddataslot("data-slot");	thread thr=thread.currentthread;	thr.name="wobble";	thread otherthr=thread.currentthread;	thread.setdata(slot, thr);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, thr);	storedthr=(thread)thread.getdata(namedslot);	
locking thr for 

thread thr=thread.currentthread;	thr.name="wobble";	thread otherthr=thread.currentthread;	thread.setdata(slot, thr);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, thr);	storedthr=(thread)thread.getdata(namedslot);	lock(thr) {	thread.sleep(1500);	}	
waiting for signal 

thread otherthr=thread.currentthread;	thread.setdata(slot, thr);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, thr);	storedthr=(thread)thread.getdata(namedslot);	lock(thr) {	thread.sleep(1500);	}	lock(thr) {	monitor.wait(thr);	
thread signalled 

thread.setdata(slot, thr);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, thr);	storedthr=(thread)thread.getdata(namedslot);	lock(thr) {	thread.sleep(1500);	}	lock(thr) {	monitor.wait(thr);	}	
sleeping for 

thread.setdata(namedslot, thr);	storedthr=(thread)thread.getdata(namedslot);	lock(thr) {	thread.sleep(1500);	}	lock(thr) {	monitor.wait(thr);	}	thread.sleep(10000);	thread storedthr2=(thread)thread.getdata(slot);	
stored subthread is still 

public static int main () {	
hello world 

public static int main () {	slot=thread.allocatedataslot();	localdatastoreslot namedslot=thread.allocatenameddataslot("data-slot");	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	thread.sleep(1000);	thread main=thread.currentthread;	main.name="wibble";	thread othermain=thread.currentthread;	
other name 

slot=thread.allocatedataslot();	localdatastoreslot namedslot=thread.allocatenameddataslot("data-slot");	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	thread.sleep(1000);	thread main=thread.currentthread;	main.name="wibble";	thread othermain=thread.currentthread;	thread.sleep(0);	
in the main line 

slot=thread.allocatedataslot();	localdatastoreslot namedslot=thread.allocatenameddataslot("data-slot");	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	thread.sleep(1000);	thread main=thread.currentthread;	main.name="wibble";	thread othermain=thread.currentthread;	thread.sleep(0);	
trying to enter lock 

localdatastoreslot namedslot=thread.allocatenameddataslot("data-slot");	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	thread.sleep(1000);	thread main=thread.currentthread;	main.name="wibble";	thread othermain=thread.currentthread;	thread.sleep(0);	if(monitor.tryenter(thr, 100)==true) {	
returned lock 

thread thr=new thread(new threadstart(test.thread_func));	thr.start();	thread.sleep(1000);	thread main=thread.currentthread;	main.name="wibble";	thread othermain=thread.currentthread;	thread.sleep(0);	if(monitor.tryenter(thr, 100)==true) {	monitor.exit(thr);	} else {	
didn t get lock 

thread main=thread.currentthread;	main.name="wibble";	thread othermain=thread.currentthread;	thread.sleep(0);	if(monitor.tryenter(thr, 100)==true) {	monitor.exit(thr);	} else {	}	thread.setdata(slot, main);	thread storedthr=(thread)thread.getdata(slot);	
stored subthread is 

thread othermain=thread.currentthread;	thread.sleep(0);	if(monitor.tryenter(thr, 100)==true) {	monitor.exit(thr);	} else {	}	thread.setdata(slot, main);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, main);	storedthr=(thread)thread.getdata(namedslot);	
stored subthread is 

thread.sleep(0);	if(monitor.tryenter(thr, 100)==true) {	monitor.exit(thr);	} else {	}	thread.setdata(slot, main);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, main);	storedthr=(thread)thread.getdata(namedslot);	if(thr.join(5000)) {	
joined thread 

if(monitor.tryenter(thr, 100)==true) {	monitor.exit(thr);	} else {	}	thread.setdata(slot, main);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, main);	storedthr=(thread)thread.getdata(namedslot);	if(thr.join(5000)) {	} else {	
didn t join thread 

}	thread.setdata(slot, main);	thread storedthr=(thread)thread.getdata(slot);	thread.setdata(namedslot, main);	storedthr=(thread)thread.getdata(namedslot);	if(thr.join(5000)) {	} else {	}	lock(thr) {	monitor.pulse(thr);	
signalled thread 

========================= mono sample_431 =========================

static public datatablemapping gettablemappingbyschemaaction(datatablemappingcollection tablemappings, string sourcetable, string datasettable, missingmappingaction mappingaction) {	if (null != tablemappings) {	int index = tablemappings.indexof(sourcetable);	if (-1 != index) {	#if debug if (adapterswitches.dataschema.tracewarning) {	
mapping match on sourcetable sourcetable 

#if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return tablemappings.items[index];	}	}	if (adp.isempty(sourcetable)) {	throw adp.invalidsourcetable("sourcetable");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	
mapping passthrough of sourcetable sourcetable datasettable 

}	}	if (adp.isempty(sourcetable)) {	throw adp.invalidsourcetable("sourcetable");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatablemapping(sourcetable, datasettable);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
mapping filter of sourcetable sourcetable 

throw adp.invalidsourcetable("sourcetable");	}	switch (mappingaction) {	case missingmappingaction.passthrough: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatablemapping(sourcetable, datasettable);	case missingmappingaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingmappingaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
mapping error on sourcetable sourcetable 

========================= mono sample_14306 =========================

public assembly handleresolveevent (object sender, resolveeventargs args) {	
handling load of 

========================= mono sample_571 =========================

static private bool drawimagecallback(intptr callbackdata) {	
drawimagecallback 

========================= mono sample_21300 =========================

private void myinstaller_committed(object sender, installeventargs e) {	console.writeline("");	
committed event occured 

public override void install (idictionary state) {	
installing 

========================= mono sample_1205 =========================

public static int main () {	if (3.foo ("a") != 30) return 1;	if (((byte)0).foo ()) return 2;	if (4.foo (false) != 20) return 3;	
ok 

========================= mono sample_3300 =========================

private static int main() {	new test().fibonacci(20, true);	console.writeline();	
passed 

========================= mono sample_736 =========================

public static void myhandler(object sender, unhandledexceptioneventargs args) {	
unhandledexceptioneventhandler called 

public static void main() {	
top level block 

public static void main() {	appdomain domain = appdomain.currentdomain;	domain.unhandledexception += new unhandledexceptioneventhandler(myhandler);	try {	
first try block 

public static void main() {	appdomain domain = appdomain.currentdomain;	domain.unhandledexception += new unhandledexceptioneventhandler(myhandler);	try {	try {	
second try block 

public static void main() {	appdomain domain = appdomain.currentdomain;	domain.unhandledexception += new unhandledexceptioneventhandler(myhandler);	try {	try {	throw new exception();	} finally {	
second finally block 

public static void main() {	appdomain domain = appdomain.currentdomain;	domain.unhandledexception += new unhandledexceptioneventhandler(myhandler);	try {	try {	throw new exception();	} finally {	}	} finally {	
first finally block 

public static void main() {	appdomain domain = appdomain.currentdomain;	domain.unhandledexception += new unhandledexceptioneventhandler(myhandler);	try {	try {	throw new exception();	} finally {	}	} finally {	}	
back to top level block 

========================= mono sample_627 =========================

datacolumn = _tablemapping.getdatacolumn(_fieldnames[sortedindex], fieldtype, _datatable, mappingaction, schemaaction);	}	string basetable = /*schemarow.baseservername+schemarow.basecatalogname+schemarow.baseschemaname+*/ schemarow.basetablename;	if (null == datacolumn) {	if (null == columnindexmap) {	columnindexmap = createindexmap(schemarows.length, unsortedindex);	}	columnindexmap[unsortedindex] = -1;	if (schemarow.iskey) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema partial primary key detected 

}	additemtoallowrollback(ref addeditems, datacolumn);	columncollection.add(datacolumn);	}	if (addprimarykeys && schemarow.iskey) {	if (keys == null) {	keys = new datacolumn[schemarows.length];	}	keys[keycount++] = datacolumn;	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema building list of primarykey uniqueconstraint 

}	if (addprimarykeys && schemarow.iskey) {	if (keys == null) {	keys = new datacolumn[schemarows.length];	}	keys[keycount++] = datacolumn;	#if debug if (adapterswitches.dataschema.traceverbose) {	}	#endif if (isprimary && datacolumn.allowdbnull) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema changing primarykey into uniquecontraint 

if ((null != _dataset) && null == _datatable.dataset) {	additemtoallowrollback(ref addeditems, _datatable);	_dataset.tables.add(_datatable);	}	if (addprimarykeys && (null != keys)) {	if (keycount < keys.length) {	keys = resizecolumnarray(keys, keycount);	}	if (isprimary) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema set primarykey 

}	#endif _datatable.primarykey = keys;	}	else {	uniqueconstraint unique = new uniqueconstraint("", keys);	constraintcollection constraints = _datatable.constraints;	int constraintcount = constraints.count;	for (int i = 0; i < constraintcount; ++i) {	if (unique.equals(constraints[i])) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema duplicate contraint detected 

for (int i = 0; i < constraintcount; ++i) {	if (unique.equals(constraints[i])) {	#if debug if (adapterswitches.dataschema.traceverbose) {	}	#endif unique = null;	break;	}	}	if (null != unique) {	#if debug if (adapterswitches.dataschema.traceverbose) {	
setupschema adding new uniqueconstraint 

========================= mono sample_14281 =========================

private static textwriter makedebugoutputtextwriter(string streamlabel) {	textwriter output = new __debugoutputtextwriter(streamlabel);	
output redirected to debugger from a bit bucket 

========================= mono sample_8947 =========================

public static void main() {	thread thr=new thread(new threadstart(foo.thread));	thr.start();	
main thread returns 

public static void thread() {	
thread running 

public static void thread() {	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.currentthread.isbackground = true;	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.currentthread.isbackground = true;	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.currentthread.isbackground = true;	thread.sleep(500);	thread.sleep(500);	
thread running 

========================= mono sample_545 =========================

static int main () {	
start 

static int main () {	var l = new object[40000];	try {	for (int i = 0; i < 40000; ++i) {	var foo = new byte[2000];	l[i] = foo;	}	
done 

var foo = new byte[2000];	l[i] = foo;	}	return 1;	} catch (exception e) {	for (int i = 0; i < 40000; i += 2) l[i] = null;	gc.collect ();	gc.collect ();	array.clear (l, 0, 40000);	l = null;	
oom done 

========================= mono sample_405 =========================

p1.direction = system.data.parameterdirection.output;	cmd.parameters.add(p1);	oraclestring os = new oraclestring();	try {	try {	cmd.commandtext = sql;	object obj1 = cmd.executescalar();	type tt2 = obj1.gettype();	}	catch (oracleexception ex) {	
failed 

try {	try {	cmd.commandtext = sql;	object obj1 = cmd.executescalar();	type tt2 = obj1.gettype();	}	catch (oracleexception ex) {	}	}	catch (exception ex) {	
failed 

========================= mono sample_24587 =========================

static void main () {	
hello 

========================= mono sample_35562 =========================

}	console.writeline("\";");	console.writeline();	string filename = ( args.length == 0 ) ? "xmlchartype.bin" : args[0];	console.write( "writing xmlchartype character properties to {0}...", filename );	filestream fs = new filestream( filename, filemode.create );	for ( int i = 0; i < charpropertiessize; i += 4096 ) {	fs.write( s_charproperties, i, 4096 );	}	fs.close();	
done 

string filename = ( args.length == 0 ) ? "xmlchartype.bin" : args[0];	console.write( "writing xmlchartype character properties to {0}...", filename );	filestream fs = new filestream( filename, filemode.create );	for ( int i = 0; i < charpropertiessize; i += 4096 ) {	fs.write( s_charproperties, i, 4096 );	}	fs.close();	}	catch ( exception e ) {	console.writeline();	
exception 

========================= mono sample_10869 =========================

public static byte[] getasbytes(this idatarecord datarecord, int index) {	if (datarecord.isdbnull(index)) return new byte[0];	object obj = datarecord.getvalue(index);	if (obj == null) return new byte[0];	byte[] bytes = obj as byte[];	if (bytes != null) return bytes;	
getbytes received unexpected type 

========================= mono sample_24707 =========================

public classb () {	
in b 

public classb () {	console.writeline (typeof (classb).assemblyqualifiedname);	var t = type.gettype ("b.classb, reflection-load-with-context-lib, version=0.0.0.0, culture=neutral, publickeytoken=null");	console.writeline (t);	t = type.gettype ("a.classa, reflection-load-with-context-second-lib, version=0.0.0.0, culture=neutral, publickeytoken=null");	
class a 

========================= mono sample_685 =========================

public void g09_unitpricegreaterthan10() {	northwind db = base.createdb();	var pricequery = from prod in db.products group prod by new {	criterion = prod.unitprice > 10 }	into grouping select grouping;	foreach (var prodobj in pricequery) {	if (prodobj.key.criterion == false) console.writeline("prices 10 or less:");	
prices greater than 

========================= mono sample_24647 =========================

static void test (string str) {	console.writeline("testing: '{0}', interned: {1}", str, string.isinterned(str) != null);	switch(str) {	
test passed 

========================= mono sample_444 =========================

static private void help () {	
usage certmgr action object type options store filename 

static private void help () {	
or certmgr list object type options store 

static private void help () {	
or certmgr del object type options store certhash 

static private void help () {	
or certmgr ssl options url 

static private void help () {	
or certmgr put object type options store certfile 

static private void help () {	
or certmgr importkey options store 

static private void help () {	console.writeline ();	
actions 

static private void help () {	console.writeline ();	
add add a certificate crl or ctl to specified store 

static private void help () {	console.writeline ();	
del remove a certificate crl or ctl to specified store 

static private void help () {	console.writeline ();	
put copy a certificate crl or ctl from a store to a file 

static private void help () {	console.writeline ();	
list list certificates crl or ctl in the specified store 

static private void help () {	console.writeline ();	
ssl download and add certificates from an ssl session 

static private void help () {	console.writeline ();	
importkey import privatekey to keypair store 

static private void help () {	console.writeline ();	
object types 

static private void help () {	console.writeline ();	
c add del put certificates 

static private void help () {	console.writeline ();	
crl add del put certificate revocation lists 

static private void help () {	console.writeline ();	
ctl add del put certificate trust lists unsupported 

static private void help () {	console.writeline ();	
other options 

static private void help () {	console.writeline ();	
m use the machine certificate store default to user 

static private void help () {	console.writeline ();	
v verbose mode display status for every steps 

static private void help () {	console.writeline ();	
p password password used to decrypt 

static private void help () {	console.writeline ();	
pem put certificate in base encoded format default der encoded 

static private void help () {	console.writeline ();	
h elp display this help message 

if (data != null) x509 = new x509certificate (data);	}	if (x509 != null) coll.add (x509);	break;	case ".p12": case ".pfx": pkcs12 p12 = password == null ? pkcs12.loadfromfile (filename) : pkcs12.loadfromfile (filename, password);	x509certificatecollection tmp = new x509certificatecollection (p12.certificates);	for (int i = 0; i != p12.keys.count; i++) {	x509certificate cert = p12.certificates[i];	rsacryptoserviceprovider pk = p12.keys[i] as rsacryptoserviceprovider;	if (pk == null || pk.publiconly) continue;	
found key for certificate 

x509certificatecollection tmp = new x509certificatecollection (p12.certificates);	for (int i = 0; i != p12.keys.count; i++) {	x509certificate cert = p12.certificates[i];	rsacryptoserviceprovider pk = p12.keys[i] as rsacryptoserviceprovider;	if (pk == null || pk.publiconly) continue;	tmp[0].rsa = pk;	}	coll.addrange(tmp);	p12 = null;	break;	
unknown file extension 

list.addrange (spc.crls);	spc = null;	break;	case ".crl": using (filestream fs = file.openread (filename)) {	byte[] data = new byte [fs.length];	fs.read (data, 0, data.length);	crl = new x509crl (data);	}	list.add (crl);	break;	
unknown file extension 

static void add (objecttype type, x509store store, string file, string password, bool verbose) {	switch (type) {	case objecttype.certificate: x509certificatecollection coll = loadcertificates (file, password, verbose);	foreach (x509certificate x509 in coll) {	store.import (x509);	}	
certificate s added to store 

switch (type) {	case objecttype.certificate: x509certificatecollection coll = loadcertificates (file, password, verbose);	foreach (x509certificate x509 in coll) {	store.import (x509);	}	break;	case objecttype.crl: arraylist list = loadcrls (file);	foreach (x509crl crl in list) {	store.import (crl);	}	
crl s added to store 

static void delete (objecttype type, x509store store, string hash, bool verbose) {	switch (type) {	case objecttype.certificate: foreach (x509certificate x509 in store.certificates) {	if (hash == cryptoconvert.tohex (x509.hash)) {	store.remove (x509);	
certificate removed from store 

case objecttype.certificate: foreach (x509certificate x509 in store.certificates) {	if (hash == cryptoconvert.tohex (x509.hash)) {	store.remove (x509);	return;	}	}	break;	case objecttype.crl: foreach (x509crl crl in store.crls) {	if (hash == cryptoconvert.tohex (crl.hash)) {	store.remove (crl);	
crl removed from store 

static void put (objecttype type, x509store store, string file, bool machine, bool pem, bool verbose) {	if (string.isnullorempty (file)) {	
error no filename provided to put the certificate 

return;	}	switch (type) {	case objecttype.certificate: for(int i = 0; i < store.certificates.count; i++) {	console.writeline ("==============certificate # {0} ==========", i + 1);	displaycertificate (store.certificates[i], machine, verbose);	}	int selection;	console.write("enter cert # from the above list to put-->");	if (!int.tryparse(console.readline(), out selection) || selection > store.certificates.count) {	
error invalid selection 

sscx.x509certificate2 cert = new sscx.x509certificate2 (store.certificates[selection-1].rawdata);	byte[] data = null;	if(pem) {	data = topem ("certificate", cert.export (sscx.x509contenttype.cert));	} else {	data = cert.export (sscx.x509contenttype.cert);	}	using (filestream fs = file.create (file)) {	fs.write(data, 0, data.length);	}	
certificate put to 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	
x v certificate self signed 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	
serial number 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	
issuer name 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	
subject name 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	
valid from 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	
valid until 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	
unique hash 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	if (verbose) {	
key algorithm 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	if (verbose) {	console.writeline ("  algorithm parameters: {0}", (x509.keyalgorithmparameters == null) ? "none" : cryptoconvert.tohex (x509.keyalgorithmparameters));	
public key 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	if (verbose) {	console.writeline ("  algorithm parameters: {0}", (x509.keyalgorithmparameters == null) ? "none" : cryptoconvert.tohex (x509.keyalgorithmparameters));	
signature algorithm 

static void displaycertificate (x509certificate x509, bool machine, bool verbose) {	if (verbose) {	console.writeline ("  algorithm parameters: {0}", (x509.keyalgorithmparameters == null) ? "none" : cryptoconvert.tohex (x509.keyalgorithmparameters));	console.writeline ("  algorithm parameters: {0}", (x509.signaturealgorithmparameters == null) ? "none" : cryptoconvert.tohex (x509.signaturealgorithmparameters));	
signature 

if (verbose) {	console.writeline ("  algorithm parameters: {0}", (x509.keyalgorithmparameters == null) ? "none" : cryptoconvert.tohex (x509.keyalgorithmparameters));	console.writeline ("  algorithm parameters: {0}", (x509.signaturealgorithmparameters == null) ? "none" : cryptoconvert.tohex (x509.signaturealgorithmparameters));	rsacryptoserviceprovider rsacsp = x509.rsa as rsacryptoserviceprovider;	rsamanaged rsamanaged = x509.rsa as rsamanaged;	console.writeline ("  private key:			{0}", ((rsacsp != null && !rsacsp.publiconly) || (rsamanaged != null && !rsamanaged.publiconly)));	cspparameters cspparams = new cspparameters ();	cspparams.keycontainername = cryptoconvert.tohex (x509.hash);	cspparams.flags = machine ? cspproviderflags.usemachinekeystore : 0;	keypairpersistence kpp = new keypairpersistence (cspparams);	
keypair key 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	
x v crl 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	
issuer name 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	
this update 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	
next update update overdue 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	
unique hash 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	if (verbose) {	
signature algorithm 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	if (verbose) {	
signature 

static void displaycrl (x509crl crl, bool machine, bool verbose) {	if (verbose) {	int n = 0;	foreach (x509crl.x509crlentry entry in crl.entries) {	
serial revoked on 

streamwriter sw = new streamwriter (ssl);	sw.writeline (environment.newline);	sw.flush ();	socket.poll (30000, selectmode.selectread);	}	finally {	socket.close ();	}	propertyinfo pi = typeof (sslstreambase).getproperty ("servercertificates", bindingflags.instance | bindingflags.nonpublic);	if (pi == null) {	
sorry but you need a newer version of mono security dll to use this feature 

static void ssl (string host, bool machine, bool verbose) {	if (verbose) {	
importing certificates from into the stores machine user 

catch {	failed = true;	}	if (selfsign) {	store = getstorefromname (x509stores.names.trustedroot, machine);	} else if (i == 0) {	store = getstorefromname (x509stores.names.otherpeople, machine);	} else {	store = getstorefromname (x509stores.names.intermediateca, machine);	}	
x certificate v self signed 

catch {	failed = true;	}	if (selfsign) {	store = getstorefromname (x509stores.names.trustedroot, machine);	} else if (i == 0) {	store = getstorefromname (x509stores.names.otherpeople, machine);	} else {	store = getstorefromname (x509stores.names.intermediateca, machine);	}	
issued from 

catch {	failed = true;	}	if (selfsign) {	store = getstorefromname (x509stores.names.trustedroot, machine);	} else if (i == 0) {	store = getstorefromname (x509stores.names.otherpeople, machine);	} else {	store = getstorefromname (x509stores.names.intermediateca, machine);	}	
issued to 

catch {	failed = true;	}	if (selfsign) {	store = getstorefromname (x509stores.names.trustedroot, machine);	} else if (i == 0) {	store = getstorefromname (x509stores.names.otherpeople, machine);	} else {	store = getstorefromname (x509stores.names.intermediateca, machine);	}	
valid from 

catch {	failed = true;	}	if (selfsign) {	store = getstorefromname (x509stores.names.trustedroot, machine);	} else if (i == 0) {	store = getstorefromname (x509stores.names.otherpeople, machine);	} else {	store = getstorefromname (x509stores.names.intermediateca, machine);	}	
valid until 

catch {	failed = true;	}	if (selfsign) {	store = getstorefromname (x509stores.names.trustedroot, machine);	} else if (i == 0) {	store = getstorefromname (x509stores.names.otherpeople, machine);	} else {	store = getstorefromname (x509stores.names.intermediateca, machine);	}	
warning certificate isn t current 

}	if ((i > 0) && !selfsign) {	x509certificate signer = coll [i-1];	bool signed = false;	try {	if (signer.rsa != null) {	signed = x509.verifysignature (signer.rsa);	} else if (signer.dsa != null) {	signed = x509.verifysignature (signer.dsa);	} else {	
warning couldn t not find who signed this certificate 

x509certificate signer = coll [i-1];	bool signed = false;	try {	if (signer.rsa != null) {	signed = x509.verifysignature (signer.rsa);	} else if (signer.dsa != null) {	signed = x509.verifysignature (signer.dsa);	} else {	signed = true;	}	
warning certificate signature is invalid 

signed = x509.verifysignature (signer.dsa);	} else {	signed = true;	}	}	catch {	failed = true;	}	}	if (failed) {	
error couldn t decode certificate properly 

signed = x509.verifysignature (signer.dsa);	} else {	signed = true;	}	}	catch {	failed = true;	}	}	if (failed) {	
try man certmgr for additional help or report to bugzilla novell com 

}	}	catch {	failed = true;	}	}	if (failed) {	break;	}	if (store.certificates.contains (x509)) {	
this certificate is already in the store 

}	if (store.certificates.contains (x509)) {	} else {	console.write ("import this certificate into the {0} store ?", store.name);	string answer = console.readline ().toupper ();	if ((answer == "yes") || (answer == "y")) {	store.import (x509);	n++;	} else {	if (verbose) {	
certificate not imported into store 

} else {	if (verbose) {	}	break;	}	}	}	}	console.writeline ();	if (n == 0) {	
no certificate were added to the stores 

rsacryptoserviceprovider pk = x509.rsa as rsacryptoserviceprovider;	if (pk == null || pk.publiconly) continue;	cspparameters csp = new cspparameters ();	csp.keycontainername = cryptoconvert.tohex (x509.hash);	csp.flags = machine ? cspproviderflags.usemachinekeystore : 0;	rsacryptoserviceprovider rsa = new rsacryptoserviceprovider (csp);	rsa.importparameters (pk.exportparameters (true));	rsa.persistkeyincsp = true;	count++;	}	
keys s imported to keypair persister localmachine currentuser 

}	}	x509store store = null;	string storename = null;	if (action != action.ssl) {	if ((action == action.none) || (type == objecttype.none)) {	help ();	return;	}	if (type == objecttype.ctl) {	
ctl are not supported 

if ((action == action.none) || (type == objecttype.none)) {	help ();	return;	}	if (type == objecttype.ctl) {	return;	}	storename = args [n++];	store = getstorefromname (storename, machine);	if (store == null) {	
invalid store 

if ((action == action.none) || (type == objecttype.none)) {	help ();	return;	}	if (type == objecttype.ctl) {	return;	}	storename = args [n++];	store = getstorefromname (storename, machine);	if (store == null) {	
valid stores are and 

case action.list: list (type, store, machine, file, verbose);	break;	case action.ssl: ssl (file, machine, verbose);	break;	case action.importkey: importkey (type, machine, file, password, verbose);	break;	default: throw new notsupportedexception (action.tostring ());	}	}	catch (unauthorizedaccessexception uae) {	
access to the certificate store has been denied machine user 

========================= mono sample_1177 =========================

public static int main (string[] args) {	try {	if (args.length != 1) {	
usage mono table to charset 

public static int main (string[] args) {	try {	if (args.length != 1) {	return 1;	}	string charset = args[0];	encoding encoding;	try {	encoding = encoding.getencoding(charset);	} catch (notsupportedexception e) {	
no converter for 

}	byte[] qmark = encoding.getbytes(new char[] { (char)0x003f });	for (int i = 0; i < 0x110000; i++) {	char[] inp = (i < 0x10000 ? new char[] { (char)i }	: new char[] { (char)(0xd800 + ((i - 0x10000) >> 10)), (char)(0xdc00 + ((i - 0x10000) & 0x3ff)) });	byte[] outp = encoding.getbytes(inp);	if (!(((outp.length >= qmark.length && outp[0] == qmark[0]	&& (qmark.length < 2 || outp[1] == qmark[1]) && (qmark.length < 3 || outp[2] == qmark[2]) && (qmark.length < 4 || outp[3] == qmark[3])) || (outp.length >= 1 && outp[0] == 0x3f)) && !(i == 0x003f))) {	console.out.write("0x");	for (int j = 0; j < outp.length; j++) console.out.write(tohexstring2(outp[j]));	
x 

========================= mono sample_30186 =========================

public static int main () {	int[] int_array = new int [] { 0, 1, 2, 3, 4 };	var e = from i in int_array group i by i;	int c = 0;	foreach (var ig in e) {	console.writeline (ig.key);	if (ig.key != c++) return c;	}	
ok 

========================= mono sample_3201 =========================

int i = binoper.indexof ('/');	if (i != -1) {	oper = binoper.substring (i+1);	bin = binoper.substring (0,i);	}	else oper = binoper;	consolesamplegenerator sg = new consolesamplegenerator (desccol, schemacol);	string req, resp;	sg.generatemessages (oper, bin, protocol, out req, out resp);	console.writeline ();	
sample request message 

bin = binoper.substring (0,i);	}	else oper = binoper;	consolesamplegenerator sg = new consolesamplegenerator (desccol, schemacol);	string req, resp;	sg.generatemessages (oper, bin, protocol, out req, out resp);	console.writeline ();	console.writeline ();	console.writeline (req);	console.writeline ();	
sample response message 

========================= mono sample_1304 =========================

public static void checkimporterrors (wsdlimporter importer, testlabel label) {	bool founderrors = false;	foreach (var error in importer.errors) {	
warning 

public static void checkimporterrors (wsdlimporter importer, testlabel label) {	bool founderrors = false;	foreach (var error in importer.errors) {	else {	
error 

public static void dump (policyassertioncollection assertions) {	
assertion 

========================= mono sample_31359 =========================

private static socket netsetup() {	socket s = new socket(addressfamily.internetwork, sockettype.stream, protocoltype.tcp);	s.bind(new ipendpoint(ipaddress.any, 8000));	
listening on 

static void getheaders(out string req, out string[] headers, string data, socket sock) {	int pos=data.indexof("\r\n");	while(pos==-1) {	
couldn t isolate request 

int pos=req.indexofany(new char[]{' '});	if(pos>=0) {	req=req.remove(pos, req.length-pos);	}	pos=req.lastindexof('.');	string filetype;	if (pos != -1) filetype = req.substring(pos);	else filetype = "";	string mime_type = (string) mime_types [filetype];	if (mime_type == null) mime_type = "text/plain";	
file is 

int pos=req.indexofany(new char[]{' '});	if(pos>=0) {	req=req.remove(pos, req.length-pos);	}	pos=req.lastindexof('.');	string filetype;	if (pos != -1) filetype = req.substring(pos);	else filetype = "";	string mime_type = (string) mime_types [filetype];	if (mime_type == null) mime_type = "text/plain";	
mime type is 

try {	filestream f=new filestream(req, filemode.open, fileaccess.read);	byte[] fbuf=new byte[256];	replyheaders(sock, 200, "ok", mime_type, null, f.length);	int count;	while((count=f.read(fbuf, 0, 256))>0) {	sock.send(fbuf, count, socketflags.none);	}	f.close();	} catch(filenotfoundexception) {	
file not found 

byte[] fbuf=new byte[256];	replyheaders(sock, 200, "ok", mime_type, null, f.length);	int count;	while((count=f.read(fbuf, 0, 256))>0) {	sock.send(fbuf, count, socketflags.none);	}	f.close();	} catch(filenotfoundexception) {	notfound(sock);	} catch(ioexception) {	
io error 

int pos=req.indexofany(new char[]{' '});	if(pos>=0) {	req=req.remove(pos, req.length-pos);	}	pos=req.lastindexof('.');	string filetype;	if (pos != -1) filetype=req.substring(pos);	else filetype = "";	string mime_type = (string) mime_types [filetype];	if (mime_type == null) mime_type = "text/plain";	
file is 

int pos=req.indexofany(new char[]{' '});	if(pos>=0) {	req=req.remove(pos, req.length-pos);	}	pos=req.lastindexof('.');	string filetype;	if (pos != -1) filetype=req.substring(pos);	else filetype = "";	string mime_type = (string) mime_types [filetype];	if (mime_type == null) mime_type = "text/plain";	
mime type is 

if (pos != -1) filetype=req.substring(pos);	else filetype = "";	string mime_type = (string) mime_types [filetype];	if (mime_type == null) mime_type = "text/plain";	try {	filestream f=new filestream(req, filemode.open, fileaccess.read);	byte[] fbuf=new byte[256];	replyheaders(sock, 200, "ok", mime_type, null, f.length);	f.close();	} catch(filenotfoundexception) {	
file not found 

string mime_type = (string) mime_types [filetype];	if (mime_type == null) mime_type = "text/plain";	try {	filestream f=new filestream(req, filemode.open, fileaccess.read);	byte[] fbuf=new byte[256];	replyheaders(sock, 200, "ok", mime_type, null, f.length);	f.close();	} catch(filenotfoundexception) {	notfound(sock);	} catch(ioexception) {	
io error 

}	socket s=netsetup();	while(true) {	socket newsock=s.accept();	string req=netread(newsock);	if(string.compare(req, 0, "get ", 0, 4)==0) {	get(newsock, req);	} else if(string.compare(req, 0, "head ", 0, 5)==0) {	head(newsock, req);	} else {	
unknown method 

========================= mono sample_666 =========================

public void runthread(iinstancetable instancetable) {	
wde debugcontrollerthread debugcontrollerthread 

public void stopthread() {	
wde debugcontrollerthread stopthread 

private void controllerthreadfunction(object instancetable) {	try {	
wde debugcontrollerthread controllerthreadfunction 

this.threadinitializedevent.set();	using (new debuggerthreadmarker()) {	while (this.runthread) {	try {	if (intptr.size == 8) {	thread.sleep(timeout.infinite);	}	else while (this.runthread);	}	catch (threadabortexception) {	
wde debugcontrollerthread expressionevaluationfunction threadabortexception 

try {	if (intptr.size == 8) {	thread.sleep(timeout.infinite);	}	else while (this.runthread);	}	catch (threadabortexception) {	throw;	}	catch {	
wde debugcontrollerthread expressionevaluationfunction other exception 

========================= mono sample_10789 =========================

public static int main (string[] args) {	var options = new cmdoptions ();	var p = new optionset () {	{ "o|out=", "specifies output file name", v => options.outputfile = v }, { "h|help",  "display available options", v => options.showhelp = v != null }, };	list<string> extra;	try {	extra = p.parse (args);	} catch (optionexception e) {	console.writeline (e.message);	
try help for more information 

static void showhelp (optionset p) {	
usage options input files 

static void showhelp (optionset p) {	
generates c file with string constants from resource file 

static void showhelp (optionset p) {	console.writeline ();	
options 

static void generatefile (list<tuple<string, string, string>> txtstrings, cmdoptions options) {	using (var str = options.outputfile == null ? console.out : new streamwriter (options.outputfile)) {	
str writeline str writeline 

static void generatefile (list<tuple<string, string, string>> txtstrings, cmdoptions options) {	using (var str = options.outputfile == null ? console.out : new streamwriter (options.outputfile)) {	
partial class sr 

static void generatefile (list<tuple<string, string, string>> txtstrings, cmdoptions options) {	using (var str = options.outputfile == null ? console.out : new streamwriter (options.outputfile)) {	str.writeline ("{");	var dict = new dictionary<string, string> ();	foreach (var entry in txtstrings) {	var value = tocsharpstring (entry.item2);	string found;	if (dict.trygetvalue (entry.item1, out found)) {	if (found == value) continue;	
else 

str.writeline ("{");	var dict = new dictionary<string, string> ();	foreach (var entry in txtstrings) {	var value = tocsharpstring (entry.item2);	string found;	if (dict.trygetvalue (entry.item1, out found)) {	if (found == value) continue;	dict.add (entry.item1, value);	}	str.write ($"\tpublic const string {entry.item1} = \"{value}\";");	
str writeline 

static bool loadstrings (list<tuple<string, string, string>> resourcesstrings, list<string> files) {	var keys = new dictionary<string, string> ();	foreach (var filename in files) {	if (!file.exists (filename)) {	
error reading resource file filename 

========================= mono sample_1215 =========================

static private void help () {	
usage caspol options arguments 

static void printglobalinfo () {	
security 

static void printglobalinfo () {	
execution check 

static void printglobalinfo () {	
policy changes confirmation 

static bool confirm () {	if (policychangesconfirmation) {	
warning this action will modify the specified security policy 

static bool confirm () {	if (policychangesconfirmation) {	
do you want to change the policy 

static bool confirm () {	if (policychangesconfirmation) {	string answer = console.readline ();	switch (answer.toupper ()) {	case "yes": case "y": return true;	
change aborted 

static securityelement loadxml (string filename) {	if (!file.exists (filename)) {	
couldn t not find 

static strongname getstrongname (string filename) {	try {	assemblyname an = assemblyname.getassemblyname (filename);	byte [] pk = an.getpublickey ();	return new strongname (new strongnamepublickeyblob (pk), an.name, an.version);	}	catch (filenotfoundexception) {	
couldn t find assembly 

static assembly getassembly (string filename) {	try {	assemblyname an = assemblyname.getassemblyname (filename);	return assembly.load (an);	}	catch (filenotfoundexception) {	
couldn t find assembly 

static bool savesettings () {	
todo where to save those settings 

static void listcodegroups () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
level 

static void listcodegroups () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
code groups 

static void listdescriptions () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
level 

static void listdescriptions () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
code groups 

static void listpermissionsets () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
level 

static void listpermissionsets () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
named permission sets 

static void listfulltrust () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
level 

static void listfulltrust () {	printglobalinfo ();	foreach (policylevel pl in levels) {	
full trust assemblies 

static void showresolvegroup (policylevel pl, evidence e) {	
level 

static void showresolvegroup (policylevel pl, evidence e) {	codegroup cg = pl.resolvematchingcodegroups (e);	
code groups 

static bool resolvepermissions (string assemblyname) {	evidence ev = getassemblyevidences (assemblyname);	if (ev == null) return false;	permissionset ps = null;	console.writeline ();	if (policyleveldefault)	{	ienumerator e = securitymanager.policyhierarchy ();	while (e.movenext ()) {	policylevel pl = (policylevel)e.current;	
resolving level 

console.writeline ();	if (policyleveldefault)	{	ienumerator e = securitymanager.policyhierarchy ();	while (e.movenext ()) {	policylevel pl = (policylevel)e.current;	if (ps == null) ps = pl.resolve (ev).permissionset;	else ps = ps.intersect (pl.resolve (ev).permissionset);	}	} else {	foreach (policylevel pl in levels) {	
resolving level 

}	if (ps == null) return false;	ienumerator ee = ev.gethostenumerator ();	while (ee.movenext ()) {	iidentitypermissionfactory ipf = (ee.current as iidentitypermissionfactory);	if (ipf != null) {	ipermission p = ipf.createidentitypermission (ev);	ps.addpermission (p);	}	}	
grant 

static bool changepermissionset (string[] args, ref int i) {	string xmlfile = args [++i];	permissionset ps = loadpermissions (xmlfile);	if (ps == null) return false;	bool confirmed = false;	string psname = args [++i];	foreach (policylevel pl in levels) {	if (pl.getnamedpermissionset (psname) == null) {	
couldn t find permission set in policy 

static bool removepermissionset (string psname) {	bool confirmed = false;	foreach (policylevel pl in levels) {	permissionset ps = pl.getnamedpermissionset (psname);	if (ps == null) {	
couldn t find permission set in policy 

static bool removepermissionset (string psname) {	bool confirmed = false;	foreach (policylevel pl in levels) {	permissionset ps = pl.getnamedpermissionset (psname);	if (ps == null) {	return false;	} else if (confirmed || confirm ()) {	confirmed = true;	pl.removenamedpermissionset (psname);	securitymanager.savepolicylevel (pl);	
permission set removed from policy 

if (name.length < 1) return null;	bool label = char.isdigit (name, 0);	for (int i=0; i < levels.count; i++) {	pl = (policylevel) levels [i];	parent = pl.rootcodegroup;	codegroup cg = null;	if (label) cg = findcodegroupbylabel (name, "1", ref parent);	else cg = findcodegroupbyname (name, ref parent);	if (cg != null) return cg;	}	
codegroup with was not found label name 

static imembershipcondition processstrongnamemembership (string[] args, ref int i) {	if (args [++i] != "-file") {	
missing file parameter 

static bool addcodegroup (string[] args, ref int i) {	string name = args [++i];	policylevel pl = null;	codegroup parent = null;	codegroup cg = findcodegroup (name, ref parent, ref pl);	if ((pl == null) || (parent == null) || (cg == null)) return false;	unioncodegroup child = new unioncodegroup ( new allmembershipcondition (), new policystatement (new permissionset (permissionstate.unrestricted)));	if (!processcodegroup (child, args, ref i)) return false;	cg.addchild (child);	securitymanager.savepolicylevel (pl);	
codegroup added in policy level 

static bool changecodegroup (string[] args, ref int i) {	string name = args [++i];	policylevel pl = null;	codegroup parent = null;	codegroup cg = findcodegroup (name, ref parent, ref pl);	if ((pl == null) || (parent == null) || (cg == null)) return false;	if (!processcodegroup (cg, args, ref i)) return false;	securitymanager.savepolicylevel (pl);	
codegroup modified in policy level 

static bool removecodegroup (string name) {	policylevel pl = null;	codegroup parent = null;	codegroup cg = findcodegroup (name, ref parent, ref pl);	if ((pl == null) || (parent == null) || (cg == null)) return false;	if (!confirm ()) return false;	parent.removechild (cg);	securitymanager.savepolicylevel (pl);	
codegroup removed from policy level 

static bool reset () {	
resetting 

case "-rs": case "-reset": if (!reset ()) return false;	break;	case "-s": case "-security": if (!security (args [++i])) return false;	break;	case "-e": case "-execution": if (!execution (args [++i])) return false;	break;	case "-b": case "-buildcache": if (!buildcache ()) return false;	break;	case "-pp": case "-polchgprompt": if (!policychangeprompt (args [++i])) return false;	break;	
unknown argument 

help ();	return 0;	}	try {	setdefaultpolicylevel ();	for (int i=0; i < args.length; i++) {	if (!processinstruction (args, ref i)) return 1;	}	}	catch (exception e) {	
error 

try {	setdefaultpolicylevel ();	for (int i=0; i < args.length; i++) {	if (!processinstruction (args, ref i)) return 1;	}	}	catch (exception e) {	help ();	return 2;	}	
success 

========================= mono sample_1184 =========================

public static int main (string[] args) {	var options = new cmdoptions ();	var p = new optionset () {	{ "r|resourcestrings=", "file with string resource in key=value format", v => options.resourcesstrings.add (v) }, { "h|help",  "display available options", v => options.showhelp = v != null }, { "v|verbose",  "use verbose output", v => options.verbose = v != null }, { "ilreplace=", "file with il code to be used instead", v => options.ilfile = v }, };	list<string> extra;	try {	extra = p.parse (args);	}	catch (optionexception e) {	console.writeline (e.message);	
try cil stringreplacer help for more information 

static void showhelp (optionset p) {	
usage cil stringreplacer options assembly 

static void showhelp (optionset p) {	
rewrites all occurences of string keys with their values from string resource file 

static void showhelp (optionset p) {	console.writeline ();	
options 

method.body.variables.clear ();	foreach (var variable in newbody.variables) {	mbody.variables.add (variable);	}	}	foreach (var instr in method.body.instructions) {	if (instr.opcode != opcodes.ldstr) continue;	string value;	if (resourcesstrings.trygetvalue ((string)instr.operand, out value)) {	if (options.verbose) {	
replacing instr operand with value 

static bool loadgetresourcestrings (dictionary<string, string> resourcesstrings, cmdoptions options) {	foreach (var filename in options.resourcesstrings) {	if (!file.exists (filename)) {	
error reading resource file filename 

========================= mono sample_1283 =========================

public static void main(string[] args) {	
hello world 

========================= mono sample_1143 =========================

static async void test () {	
await 

========================= mono sample_34838 =========================

static void thread () {	tfailed = false;	if (var != 0) tfailed = true;	
start value 

static void thread () {	tfailed = false;	if (var != 0) tfailed = true;	for (int i = 0; i < 10; ++i) {	var += 10;	thread.sleep (5);	}	
end value 

static int main () {	bool failed = false;	var  = 10;	thread thr = new thread (new threadstart (thread));	thr.start ();	if (var != 10) failed = true;	var = 20;	
value in main thread 

static int main () {	bool failed = false;	var  = 10;	thread thr = new thread (new threadstart (thread));	thr.start ();	if (var != 10) failed = true;	var = 20;	thr.join ();	
value in main thread after join 

========================= mono sample_530 =========================

private void thread_func() {	
in a thread 

private void thread_func() {	for(int i=51200; i<102400; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.sleep(5000);	thread.setdata(slot[11111], 42);	thread.setdata(slot[76801], 42);	thread.sleep(20000);	
subthread done 

private void thread_func() {	for(int i=51200; i<102400; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.sleep(5000);	thread.setdata(slot[11111], 42);	thread.setdata(slot[76801], 42);	thread.sleep(20000);	
slot contains 

private void thread_func() {	for(int i=51200; i<102400; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.sleep(5000);	thread.setdata(slot[11111], 42);	thread.setdata(slot[76801], 42);	thread.sleep(20000);	
slot contains 

private void thread_func() {	for(int i=51200; i<102400; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.sleep(5000);	thread.setdata(slot[11111], 42);	thread.setdata(slot[76801], 42);	thread.sleep(20000);	
slot contains 

private void thread_func() {	for(int i=51200; i<102400; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.sleep(5000);	thread.setdata(slot[11111], 42);	thread.setdata(slot[76801], 42);	thread.sleep(20000);	
slot contains 

public static int main () {	
hello world 

test test=new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	for(int i=0; i<51200; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.setdata(slot[11111], 69);	thread.setdata(slot[26801], 69);	thread.sleep(10000);	
main thread done 

test test=new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	for(int i=0; i<51200; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.setdata(slot[11111], 69);	thread.setdata(slot[26801], 69);	thread.sleep(10000);	
slot contains 

test test=new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	for(int i=0; i<51200; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.setdata(slot[11111], 69);	thread.setdata(slot[26801], 69);	thread.sleep(10000);	
slot contains 

test test=new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	for(int i=0; i<51200; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.setdata(slot[11111], 69);	thread.setdata(slot[26801], 69);	thread.sleep(10000);	
slot contains 

test test=new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	for(int i=0; i<51200; i++) {	slot[i]=thread.allocatedataslot();	thread.setdata(slot[i], i);	}	thread.setdata(slot[11111], 69);	thread.setdata(slot[26801], 69);	thread.sleep(10000);	
slot contains 

========================= mono sample_470 =========================

public static int main (string[] args) {	var showhelp = false;	list<string> extra = null;	command cmd = null;	var loglevel = logger.level.warning;	var options = new optionset {	{ "h|help", "show this help", v => showhelp = true }, { "q", "quiet, warnings are not displayed", v => loglevel = logger.level.error }, { "v", "verbose, log debug messages", v => loglevel = logger.level.debug }, };	try {	extra = options.parse (args);	} catch (optionexception e) {	
option error 

} catch (optionexception e) {	showhelp = true;	}	if (extra.count > 0 && extra[0] == "store-symbols") cmd = new command (storesymbolsaction, 2);	if (cmd != null) {	extra.removeat (0);	} else {	cmd = new command (symbolicateaction, 2, 2);	}	if (showhelp || extra == null || extra.count < cmd.minargcount || extra.count > cmd.maxargcount) {	
usage symbolicate options msym dir input file 

} catch (optionexception e) {	showhelp = true;	}	if (extra.count > 0 && extra[0] == "store-symbols") cmd = new command (storesymbolsaction, 2);	if (cmd != null) {	extra.removeat (0);	} else {	cmd = new command (symbolicateaction, 2, 2);	}	if (showhelp || extra == null || extra.count < cmd.minargcount || extra.count > cmd.maxargcount) {	
symbolicate options store symbols msym dir dir 

showhelp = true;	}	if (extra.count > 0 && extra[0] == "store-symbols") cmd = new command (storesymbolsaction, 2);	if (cmd != null) {	extra.removeat (0);	} else {	cmd = new command (symbolicateaction, 2, 2);	}	if (showhelp || extra == null || extra.count < cmd.minargcount || extra.count > cmd.maxargcount) {	console.writeline ();	
available options 

========================= mono sample_1221 =========================

svcmapfile mapfile = loader.loadmapfile() as svcmapfile;	handleproxygenerationerrors(mapfile.loaderrors);	codedomprovider provider = system.codedom.compiler.codedomprovider.createprovider("c#");	vswcfservicecontractgenerator generator = vswcfservicecontractgenerator.generatecodeandconfiguration( mapfile, gettoolconfig(mapfile, mapfilepath), provider, generatednamespace, null, null, new importextensionserviceprovider(), new typeresolver(), framework_version_35, typeof (system.data.design.typeddatasetschemaimporterextensionfx35) );	string referencedisplayname = string.isnullorempty(generatednamespace) ? system.io.path.getfilename(mapfilepath) : generatednamespace;	verifygeneratedcodeandhandleerrors(referencedisplayname, mapfile, generator.targetcompileunit, generator.importerrors, generator.proxygenerationerrors);	#if debug #if false io.textwriter writer = new io.stringwriter();	codegeneratoroptions options = new codegeneratoroptions();	options.blanklinesbetweenmembers=true;	provider.generatecodefromcompileunit(generator.targetcompileunit, writer, options);	
generated proxy code 

========================= mono sample_15209 =========================

public override bool layout (object container, layouteventargs args) {	iarrangedcontainer panel = (iarrangedcontainer)container;	tablelayoutsettings settings = getlayoutsettings (panel);	
beginning layout on panel control count col row count x 

tablelayoutsettings settings = getlayoutsettings (panel);	#endif var actual_positions = calculatecontrolpositions (panel, math.max (settings.columncount, 1), math.max (settings.rowcount, 1));	int[] widths, heights;	calculatecolumnrowsizes (panel, actual_positions, out widths, out heights, panel.displayrectangle.size, false);	if (panel is tablelayoutpanel table_panel) {	table_panel.actual_positions = actual_positions;	table_panel.column_widths = widths;	table_panel.row_heights = heights;	}	layoutcontrols (panel, actual_positions, widths, heights);	
calculatedpositions 

#endif var actual_positions = calculatecontrolpositions (panel, math.max (settings.columncount, 1), math.max (settings.rowcount, 1));	int[] widths, heights;	calculatecolumnrowsizes (panel, actual_positions, out widths, out heights, panel.displayrectangle.size, false);	if (panel is tablelayoutpanel table_panel) {	table_panel.actual_positions = actual_positions;	table_panel.column_widths = widths;	table_panel.row_heights = heights;	}	layoutcontrols (panel, actual_positions, widths, heights);	outputcontrolgrid (actual_positions, widths, heights);	
finished layout on panel 

private void outputcontrolgrid (iarrangedelement[,] grid, int[] column_widths, int[] row_heights) {	
size x 

========================= mono sample_26404 =========================

public static void main (string [] args) {	if (args.length == 2) {	string [] tmp = new string [4];	tmp [0] = args [0] + "-utf8.txt";	tmp [1] = "65001";	tmp [2] = args [1];	tmp [3] = args [0] + "-" + args [1] + ".txt";	args = tmp;	}	if (args.length < 4) {	
pass input file input encoding output encoding output file 

s = sr.readtoend ();	}	using (streamwriter sw = new streamwriter (args [3], false, encoding.getencoding (int.parse (args [2])))) {	sw.write (s);	}	string s2;	using (streamreader sr = new streamreader (args [3], encoding.getencoding (int.parse (args [2])))) {	s2 = sr.readtoend ();	}	if (s != s2) {	
failure 

========================= mono sample_30281 =========================

static int f (int a) {	
test f from delegate 

static void async_callback (iasyncresult ar) {	asyncresult ares = (asyncresult)ar;	asynccallback ac = new asynccallback (async_callback);	
async callback 

========================= mono sample_483 =========================

public static int heusl (se x) {	
within 

public static void thrower () {	try {	throw new exception ();	} finally {	
before 

public static void thrower () {	try {	throw new exception ();	} finally {	heusl (new se ());	
after 

public static int main () {	try {	thrower ();	} catch {	
back 

========================= mono sample_592 =========================

public void test() {	
test 

========================= mono sample_3375 =========================

static void printtree (controlbuilder builder, int indent) {	if (builder == null) return;	string i = new string ('\t', indent);	console.write (i);	
b naming container id type parent 

static void printlocation (ilocation loc) {	
file name 

static void printlocation (ilocation loc) {	
begin line 

static void printlocation (ilocation loc) {	
end line 

static void printlocation (ilocation loc) {	
begin column 

static void printlocation (ilocation loc) {	
end column 

static void printlocation (ilocation loc) {	
plaintext 

========================= mono sample_20388 =========================

static void main (string[] args) {	if (args.length < 1) {	
usage mod exe url 

static void main (string[] args) {	if (args.length < 1) {	return;	}	bool index =  (args.length == 2);	roottree help_tree = roottree.loadtree ();	if (index){	
building index 

========================= mono sample_1330 =========================

certificates.add(new x509certificate(cert.rawdata));	}	}	tcpclient client = new tcpclient ();	client.connect (host, 4433);	sslclientstream ssl = new sslclientstream (client.getstream(), host, false, protocol, certificates);	ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	ssl.clientcertselectiondelegate += new certificateselectioncallback (clientcertificateselection);	ssl.privatekeycertselectiondelegate += new privatekeyselectioncallback (privatekeyselection);	streamwriter sw = new streamwriter (ssl, system.text.encoding.ascii);	
get clientcert aspx 

static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	
certificatevalidation 

static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	console.writeline (certificate.tostring (true));	
error s 

static x509certificate clientcertificateselection (x509certificatecollection clientcertificates, x509certificate servercertificate, string targethost, x509certificatecollection serverrequestedcertificates) {	
clientcertificateselection 

static x509certificate clientcertificateselection (x509certificatecollection clientcertificates, x509certificate servercertificate, string targethost, x509certificatecollection serverrequestedcertificates) {	
client certificates 

static x509certificate clientcertificateselection (x509certificatecollection clientcertificates, x509certificate servercertificate, string targethost, x509certificatecollection serverrequestedcertificates) {	int i = 1;	foreach (x509certificate client in clientcertificates) console.writeline ("#{0} - {1}", i++, client.tostring (true));	
host 

static asymmetricalgorithm privatekeyselection (x509certificate certificate, string targethost) {	
privatekeyselection 

static asymmetricalgorithm privatekeyselection (x509certificate certificate, string targethost) {	
host 

static asymmetricalgorithm privatekeyselection (x509certificate certificate, string targethost) {	console.writeline (certificate.tostring (true));	
privatekeyselection 

========================= mono sample_20586 =========================

methodcallmessagewrapper mcm = new methodcallmessagewrapper ((imethodcallmessage) msg);	mcm.uri = remotingservices.getobjecturi ((marshalbyrefobject) target);	marshalbyrefobject objrem = (marshalbyrefobject) activator.createinstance (getproxiedtype ());	remotingservices.executemessage ((marshalbyrefobject) objrem, (imethodcallmessage) msg);	imessage rtnmsg = null;	try {	rtnmsg = _sink.syncprocessmessage (msg);	} catch (exception e) {	console.writeline (e.message);	}	
rr 

========================= mono sample_17881 =========================

public override imessage invoke (imessage msg) {	
invoke 

========================= mono sample_28089 =========================

static void main () {	
text 

========================= mono sample_33437 =========================

public static int main () {	x [] x = { new x (40), f (10) };	if (x [0].value != 40) return 1;	if (x [1].value != 10) return 2;	
test ok 

========================= mono sample_2646 =========================

static void createexpectedresults(string baseurl) {	testscatalog tc = new testscatalog(_catalogfile, _runexcluded);	htmldiff wt = new htmldiff();	wt.testsbaseurl = baseurl;	wt.ignorelistfile = _ignorelistfile;	if ((_outputpath != "") && (!directory.exists(_outputpath))) {	directory.createdirectory(_outputpath);	}	
running expected results 

static void createexpectedresults(string baseurl) {	testscatalog tc = new testscatalog(_catalogfile, _runexcluded);	htmldiff wt = new htmldiff();	wt.testsbaseurl = baseurl;	wt.ignorelistfile = _ignorelistfile;	if ((_outputpath != "") && (!directory.exists(_outputpath))) {	directory.createdirectory(_outputpath);	}	foreach (testinfo ti in tc) {	
running 

========================= mono sample_19632 =========================

public int test_function (int a, bool b) {	
test function called 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	
objref 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "simple: string uri;	simplechannel chnl = new simplechannel (8000);	channelservices.registerchannel (chnl);	
channel name 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "simple: string uri;	simplechannel chnl = new simplechannel (8000);	channelservices.registerchannel (chnl);	
channel priority 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "simple: string uri;	simplechannel chnl = new simplechannel (8000);	channelservices.registerchannel (chnl);	
uri 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "simple: string uri;	simplechannel chnl = new simplechannel (8000);	channelservices.registerchannel (chnl);	
uri 

static int main () {	test t1 = new test ();	objref myref = remotingservices.marshal (t1, "/test");	string url = "simple: string uri;	simplechannel chnl = new simplechannel (8000);	channelservices.registerchannel (chnl);	test tp = (test)remotingservices.connect (typeof (test), url);	int res = tp.test_function (4, true);	
result 

========================= mono sample_17872 =========================

static void main () {	p.x += 10;	
got 

========================= mono sample_33704 =========================

}	if (s.hit != 0) return 1;	using (new c ()) {	}	var s = new s ();	using (s) {	}	if (s.hit != 1) return 2;	genmethod (s);	if (s.hit != 2) return 3;	
ok 

========================= mono sample_3619 =========================

public static int main () {	int v;	v = test_explicit ();	if (v != 0) return v;	v = test_implicit ();	if (v != 0) return 20 + v;	ulong l = 1;	if (l != 0l) ;	ulong myulog = 0l;	
tests pass 

========================= mono sample_2672 =========================

public static void main () {	ulong aa = 10;	ulong bb = 3;	
bug here 

========================= mono sample_33512 =========================

public void usedsize () {	isolatedstoragefile isf = isolatedstoragefile.getuserstoreforassembly ();	isolatedstoragefilestream isfs = isf.createfile ("file");	streamwriter writer = new streamwriter (isfs);	
hello mono 

========================= mono sample_27321 =========================

public static void main(string[] args) {	string[] cities = { "tokyo", "beijing", "hangzhou", "kyoto", "beijing", "copenhagen", "seattle" };	ilist<string> alst = new arraylist<string>();	alst.addall<string>(cities);	foreach (int i in mysort.getpermutation1(alst)) console.write("{0} ", i);	console.writeline();	ilist<string> llst = new linkedlist<string>();	llst.addall<string>(cities);	foreach (int i in mysort.getpermutation2(llst)) console.write("{0} ", i);	console.writeline();	
the rank of the cities 

========================= mono sample_30559 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	
ok 

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_2681 =========================

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(purchaseorder));	filestream fs=new filestream(filename, filemode.open);	purchaseorder po;	po=(purchaseorder)ser.deserialize(fs);	fs.close();	foreach(item item in po.itemsordered) {	
item 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(purchaseorder));	filestream fs=new filestream(filename, filemode.open);	purchaseorder po;	po=(purchaseorder)ser.deserialize(fs);	fs.close();	foreach(item item in po.itemsordered) {	
price 

========================= mono sample_22555 =========================

if ( param.typename == "decimal" || param.typename == "numeric") {	comm.append ((param.precision !=0 ) ? param.precision : precision);	comm.append (param.scale);	if (param.value != null && param.value != dbnull.value && ((decimal)param.value) != decimal.maxvalue && ((decimal)param.value) != decimal.minvalue && ((decimal)param.value) != long.maxvalue && ((decimal)param.value) != long.minvalue && ((decimal)param.value) != ulong.maxvalue && ((decimal)param.value) != ulong.minvalue) {	long expo = (long)new decimal (system.math.pow (10, (double)param.scale));	long pval = (long)(((decimal)param.value) * expo);	param.value = pval;	}	}	if (collation != null) {	
collation is not null 

if ( param.typename == "decimal" || param.typename == "numeric") {	comm.append ((param.precision !=0 ) ? param.precision : precision);	comm.append (param.scale);	if (param.value != null && param.value != dbnull.value && ((decimal)param.value) != decimal.maxvalue && ((decimal)param.value) != decimal.minvalue && ((decimal)param.value) != long.maxvalue && ((decimal)param.value) != long.minvalue && ((decimal)param.value) != ulong.maxvalue && ((decimal)param.value) != ulong.minvalue) {	long expo = (long)new decimal (system.math.pow (10, (double)param.scale));	long pval = (long)(((decimal)param.value) * expo);	param.value = pval;	}	}	if (collation != null) {	
column type 

if ( param.typename == "decimal" || param.typename == "numeric") {	comm.append ((param.precision !=0 ) ? param.precision : precision);	comm.append (param.scale);	if (param.value != null && param.value != dbnull.value && ((decimal)param.value) != decimal.maxvalue && ((decimal)param.value) != decimal.minvalue && ((decimal)param.value) != long.maxvalue && ((decimal)param.value) != long.minvalue && ((decimal)param.value) != ulong.maxvalue && ((decimal)param.value) != ulong.minvalue) {	long expo = (long)new decimal (system.math.pow (10, (double)param.scale));	long pval = (long)(((decimal)param.value) * expo);	param.value = pval;	}	}	if (collation != null) {	
collation bytes 

comm.append ((param.precision !=0 ) ? param.precision : precision);	comm.append (param.scale);	if (param.value != null && param.value != dbnull.value && ((decimal)param.value) != decimal.maxvalue && ((decimal)param.value) != decimal.minvalue && ((decimal)param.value) != long.maxvalue && ((decimal)param.value) != long.minvalue && ((decimal)param.value) != ulong.maxvalue && ((decimal)param.value) != ulong.minvalue) {	long expo = (long)new decimal (system.math.pow (10, (double)param.scale));	long pval = (long)(((decimal)param.value) * expo);	param.value = pval;	}	}	if (collation != null) {	} else {	
collation is null 

========================= mono sample_30448 =========================

xmldocument doc = new xmldocument ();	doc.nodeinserting += new xmlnodechangedeventhandler (oninserting);	doc.nodeinserted += new xmlnodechangedeventhandler (oninserted);	doc.nodechanging += new xmlnodechangedeventhandler (onchanging);	doc.nodechanged += new xmlnodechangedeventhandler (onchanged);	doc.noderemoving += new xmlnodechangedeventhandler (onremoving);	doc.noderemoved += new xmlnodechangedeventhandler (onremoved);	foreach (fileinfo fi in new directoryinfo (@"xml-test-suite/xmlconf/oasis").getfiles ("*.xml")) {	try {	if (fi.name.indexof ("fail") >= 0) continue;	
file 

public void oninserting (object o, xmlnodechangedeventargs e) {	
inserting into name value 

public void oninserted (object o, xmlnodechangedeventargs e) {	
inserted into name value 

public void onchanging (object o, xmlnodechangedeventargs e) {	
changing 

public void onchanged (object o, xmlnodechangedeventargs e) {	
changed 

public void onremoving (object o, xmlnodechangedeventargs e) {	
removing 

public void onremoved (object o, xmlnodechangedeventargs e) {	
removed 

========================= mono sample_22404 =========================

static void generate_receptors () {	foreach (string t in types){	w ("\tstatic void receive_" + t + " (" + t + " a)\n\t{\n");	w ("\t\tconsole.write (\"        \");\n");	
console writeline a 

static void generate_emision () {	foreach (string type in types){	w ("\tstatic void probe_" + type + "()\n\t{\n");	var (type, "zero", "0");	var (type, "min", type + ".minvalue");	var (type, "max", type + ".maxvalue");	wl ("");	
console writeline type 

static void generate_emision () {	foreach (string type in types){	w ("\tstatic void probe_" + type + "()\n\t{\n");	var (type, "zero", "0");	var (type, "min", type + ".minvalue");	var (type, "max", type + ".maxvalue");	wl ("");	foreach (string t in types){	
console writeline t type 

public static void main (string [] args) {	foreach (string arg in args){	if (arg == "-h" || arg == "--help"){	
h help shows help 

public static void main (string [] args) {	foreach (string arg in args){	if (arg == "-h" || arg == "--help"){	
c checked generate checked contexts 

========================= mono sample_2993 =========================

public override size getpreferredsize (size proposedsize) {	
hoyo 

========================= mono sample_25375 =========================

public void add(t x) {	
ok 

========================= mono sample_1739 =========================

private static void modifyinner() {	
anti pattern add to outer modify lose 

for (int i=0; i<100; i++) {	isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	
in outer 

for (int i=0; i<100; i++) {	isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	
in outer 

for (int i=0; i<100; i++) {	isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	inner1.add(13);	
equals 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	inner1.add(13);	
equals 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	inner1.add(13);	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	inner1.add(13);	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	inner1.add(13);	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	isequenced<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1);	inner1.add(13);	
outer count 

private static void dontmodifyinner() {	
make a snapshot and add it to outer 

for (int i=0; i<100; i++) {	isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	
in outer 

for (int i=0; i<100; i++) {	isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	
in outer 

for (int i=0; i<100; i++) {	isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	inner1.add(13);	
equals 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	inner1.add(13);	
equals 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	inner1.add(13);	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	inner1.add(13);	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	inner1.add(13);	
in outer 

isequenced<int> inner = new treeset<int>();	inner.add(i); inner.add(i+1);	outer.add(inner);	}	ipersistentsorted<int> inner1 = new treeset<int>(), inner2 = new treeset<int>(), inner3 = new treeset<int>();	inner1.addall<int>(new int[] { 2, 3, 5, 7, 11 });	inner2.addall(inner1); inner2.add(13);	inner3.addall(inner1);	outer.add(inner1.snapshot());	inner1.add(13);	
outer count 

========================= mono sample_30548 =========================

contenttype	contenttype	= (contenttype)type;	byte[] buffer = this.readrecordbuffer(type, record);	if (buffer == null) {	internalresult.setcomplete((byte[])null);	return;	}	if (contenttype == contenttype.alert && buffer.length == 2) {	}	else if ((this.context.read != null) && (this.context.read.cipher != null)) {	buffer = this.decryptrecordfragment (contenttype, buffer);	
decrypted record data 

while (totalreceived != length) {	int justreceived = record.read(buffer, totalreceived, buffer.length - totalreceived);	if (0 == justreceived) {	throw new tlsexception(alertdescription.closenotify, "received 0 bytes from stream. it must be closed.");	}	totalreceived += justreceived;	}	if (protocol != this.context.protocol && this.context.protocolnegotiated) {	throw new tlsexception( alertdescription.protocolversion, "invalid protocol version on message received");	}	
record data 

public void sendalert(alert alert) {	alertlevel level;	alertdescription description;	bool close;	if (alert == null) {	
write alert null 

public void sendalert(alert alert) {	alertlevel level;	alertdescription description;	bool close;	if (alert == null) {	level = alertlevel.fatal;	description = alertdescription.internalerror;	close = true;	} else {	
write alert 

public void sendchangecipherspec() {	
write change cipher spec 

public iasyncresult beginsendrecord(handshaketype handshaketype, asynccallback callback, object state) {	handshakemessage msg = this.getmessage(handshaketype);	msg.process();	
write handshake record 

}	fragment = new byte[fragmentlength];	buffer.blockcopy(recorddata, position, fragment, 0, fragmentlength);	if ((this.context.write != null) && (this.context.write.cipher != null)) {	fragment = this.encryptrecordfragment (contenttype, fragment);	}	record.write((byte)contenttype);	record.write(this.context.protocol);	record.write((short)fragment.length);	record.write(fragment);	
record data 

private byte[] encryptrecordfragment( contenttype	contenttype, byte[]		fragment) {	byte[] mac	= null;	if (this.context is clientcontext) {	mac = this.context.write.cipher.computeclientrecordmac(contenttype, fragment);	}	else {	mac = this.context.write.cipher.computeserverrecordmac (contenttype, fragment);	}	
record mac 

}	throw;	}	byte[] mac = null;	if (this.context is clientcontext) {	mac = this.context.read.cipher.computeserverrecordmac(contenttype, dcrfragment);	}	else {	mac = this.context.read.cipher.computeclientrecordmac (contenttype, dcrfragment);	}	
record mac 

========================= mono sample_31894 =========================

if (output.count != 2) return 1;	int[] results_a = new int[] { 0, 2, 4, 1, 3 };	int pos = 0;	foreach (igrouping<int, int> ig in e) {	console.writeline (ig.key);	foreach (int value in ig) {	console.writeline ("\t" + value);	if (value != results_a [pos++]) return 3;	}	}	
ok 

========================= mono sample_1989 =========================

int numtoread = this.entrysize;	longname = new stringbuilder();	while (numtoread > 0) {	int numread = this.read(namebuffer, 0, (numtoread > namebuffer.length ? namebuffer.length : numtoread));	if (numread == -1) {	throw new invalidheaderexception("failed to read long name entry");	}	longname.append(tarheader.parsename(namebuffer, 0, numread).tostring());	numtoread -= numread;	}	
tarinputstream long name is 

========================= mono sample_30838 =========================

font.family = (int)rtf.minor;	break;	}	case major.charattr: {	switch(rtf.minor) {	case minor.fontnum: {	font.num = rtf.param;	break;	}	default: {	
got unhandled control charattr minor 

}	case minor.fontcodepage: {	font.codepage = rtf.param;	break;	}	case minor.ftypenil: case minor.ftypetruetype: {	font.type = rtf.param;	break;	}	default: {	
got unhandled control fontattr minor 

font.type = rtf.param;	break;	}	default: {	#endif break;	}	}	break;	}	default: {	
readfonttbl unknown control token 

while ((rtf.rtf_class != tokenclass.eof) && (!rtf.checkcm(tokenclass.text, (major)';')) && (!rtf.checkcm(tokenclass.group, major.endgroup)) && (!rtf.checkcm(tokenclass.group, major.begingroup))) {	sb.append((char)rtf.major);	rtf.gettoken();	}	if (rtf.checkcm(tokenclass.group, major.endgroup)) {	rtf.ungettoken();	}	font.name = sb.tostring();	continue;	#if rtf_debug } else {	
readfonttbl unknown token 

while (rtf.rtf_class == tokenclass.text) {	if (rtf.major == (major)';') {	rtf.ungettoken();	break;	}	sb.append((char)rtf.major);	rtf.gettoken();	}	style.name = sb.tostring();	#if rtf_debug } else {	
readstylesheet ignored token 

========================= mono sample_25297 =========================

foreach (int actual in e) {	console.writeline (actual);	if (int_array [pos++] != actual) return pos;	}	e = from i in int_array select 19;	pos = 0;	foreach (int actual in e) {	console.writeline (actual);	if (actual != 19) return actual;	}	
ok 

========================= mono sample_2663 =========================

public delegate int delegateb (int i);	static delegatea dt;	static delegateb dt2;	public static int main () {	bool b = delegatemethod == dt;	if (b) return 1;	b = delegatemethod != dt;	if (!b) return 2;	b = dt2 == delegatemethod;	if (b) return 3;	
ok 

========================= mono sample_2475 =========================

static webconfigurationmanager () {	var section_cache_size = default_section_cache_size;	int section_cache_size_override;	bool size_overriden = false;	if (int.tryparse (environment.getenvironmentvariable (cache_size_overriding_key), out section_cache_size_override)) {	section_cache_size = section_cache_size_override;	size_overriden = true;	
webconfigurationmanager s lrucache size overriden to via 

========================= mono sample_20486 =========================

static void test(bool v3, string encoding) {	if (!v3) console.writeline("testing version 2" + (encoding != null ? " with " + encoding + " encoding" : ""));	
testing version 

param2.value = "using unnamed parameters";	dbcmd.parameters.add(param2);	idbdataparameter param3 = dbcmd.createparameter();	param3.dbtype = dbtype.datetime;	param3.value = datetime.parse("2006-05-11 11:45:00");	dbcmd.parameters.add(param3);	console.writeline("insert with unnamed parameters = 1, 5: " + dbcmd.executenonquery() + " , " + dbcmd.lastinsertrowid());	dbcmd.commandtext = "select * from mono_test";	sqlitedatareader reader;	reader = dbcmd.executereader();	
read and display data 

dbcmd.parameters.add(param3);	console.writeline("insert with unnamed parameters = 1, 5: " + dbcmd.executenonquery() + " , " + dbcmd.lastinsertrowid());	dbcmd.commandtext = "select * from mono_test";	sqlitedatareader reader;	reader = dbcmd.executereader();	while(reader.read()) for (int i = 0; i < reader.fieldcount; i++) console.writeline(" col {0}: {1} (type: {2}, data type: {3})", i, reader[i] == null ? "(null)" : reader[i].tostring(), reader[i] == null ? "(null)" : reader[i].gettype().fullname, reader.getdatatypename(i));	dbcmd.commandtext = "select ndesc from mono_test where nid=2";	console.writeline("read and display a scalar = 'two': " + dbcmd.executescalar());	dbcmd.commandtext = "select count(*) from mono_test";	console.writeline("read and display a non-column scalar = 3: " + dbcmd.executescalar());	
read and display data using dataadapter dataset 

datatable dt = new datatable();	adapter.fill(dt);	dataview dv = new dataview(dt);	foreach (datarowview myrow in dv) {	foreach (datacolumn mycolumn in myrow.row.table.columns) {	console.writeline(" " + myrow[mycolumn.columnname]);	}	}*/ try {	dbcmd.commandtext = "select ndesc invalid syntax from mono_test where nid=2";	dbcmd.executenonquery();	
should not reach here 

adapter.fill(dt);	dataview dv = new dataview(dt);	foreach (datarowview myrow in dv) {	foreach (datacolumn mycolumn in myrow.row.table.columns) {	console.writeline(" " + myrow[mycolumn.columnname]);	}	}*/ try {	dbcmd.commandtext = "select ndesc invalid syntax from mono_test where nid=2";	dbcmd.executenonquery();	} catch (exception e) {	
testing a syntax error 

foreach (datarowview myrow in dv) {	foreach (datacolumn mycolumn in myrow.row.table.columns) {	console.writeline(" " + myrow[mycolumn.columnname]);	}	}*/ try {	dbcmd.commandtext = "select ndesc invalid syntax from mono_test where nid=2";	dbcmd.executenonquery();	} catch (exception e) {	}	dbcmd.commandtext = "select 0/0 from mono_test where nid=2";	
should not reach here 

foreach (datacolumn mycolumn in myrow.row.table.columns) {	console.writeline(" " + myrow[mycolumn.columnname]);	}	}*/ try {	dbcmd.commandtext = "select ndesc invalid syntax from mono_test where nid=2";	dbcmd.executenonquery();	} catch (exception e) {	}	dbcmd.commandtext = "select 0/0 from mono_test where nid=2";	} catch (exception e) {	
testing an execution error 

========================= mono sample_5177 =========================

bfinal = input.getbits(1);	state = inflaterstate.readingbtype;	}	if( state == inflaterstate.readingbtype) {	if (!input.ensurebitsavailable(2)) {	state = inflaterstate.readingbtype;	return false;	}	blocktype = (blocktype)input.getbits(2);	if (blocktype == blocktype.dynamic) {	
decoding dynamic block compression 

if( state == inflaterstate.readingbtype) {	if (!input.ensurebitsavailable(2)) {	state = inflaterstate.readingbtype;	return false;	}	blocktype = (blocktype)input.getbits(2);	if (blocktype == blocktype.dynamic) {	state = inflaterstate.readingnumlitcodes;	}	else if (blocktype == blocktype.static) {	
decoding static block compression 

blocktype = (blocktype)input.getbits(2);	if (blocktype == blocktype.dynamic) {	state = inflaterstate.readingnumlitcodes;	}	else if (blocktype == blocktype.static) {	literallengthtree = huffmantree.staticliterallengthtree;	distancetree = huffmantree.staticdistancetree;	state = inflaterstate.decodetop;	}	else if (blocktype == blocktype.uncompressed) {	
decoding uncompressed block compression 

========================= mono sample_12367 =========================

public static int main () {	int total = 0;	foreach (int i in getit (new int [] { 1, 2, 3})){	
got 

public static int main () {	int total = 0;	foreach (int i in getit (new int [] { 1, 2, 3})){	total += i;	}	if (total != 6) return 1;	total = 0;	foreach (int i in getmulti (new int [,] { { 10, 20 }, { 30, 40}})){	
got 

========================= mono sample_2746 =========================

static void printiphostentry(iphostentry h) {	console.writeline("----------------------------------------------------");	
host name 

static void printiphostentry(iphostentry h) {	console.writeline("----------------------------------------------------");	console.writeline(h.hostname);	
ip addresses 

static void printiphostentry(iphostentry h) {	console.writeline("----------------------------------------------------");	console.writeline(h.hostname);	ipaddress[] list = h.addresslist;	for(int i = 0; i < list.length; ++i) console.writeline(list[i]);	
aliases 

========================= mono sample_23321 =========================

domain.executeassembly (path);	return runresult.valid;	} catch (invalidprogramexception) {	return runresult.invalid;	} catch (fileloadexception) {	return runresult.invalid;	} catch (verificationexception) {	return runresult.unverifiable;	} catch (typeinitializationexception ve) {	if (ve.innerexception is verificationexception) return runresult.unverifiable;	
warning test thrown exception 

return runresult.invalid;	} catch (missingmemberexception) {	return runresult.invalid;	} catch (memberaccessexception) {	return runresult.unverifiable;	} catch (typeloadexception) {	return runresult.invalid;	} catch (badimageformatexception) {	return runresult.invalid;	} catch (exception e) {	
warning test thrown exception 

static runresult decide (runresult ad, runresult rt, runresult pv, string testname) {	if (ad == runresult.valid) {	if (rt != runresult.valid) {	
warning test returned valid under ad but under runtime pv said using runtime choice 

if (ad == runresult.valid) {	if (rt != runresult.valid) {	return rt;	}	if (pv != runresult.valid) return runresult.strict;	return runresult.valid;	}	if (ad == runresult.unverifiable) {	if (pv == runresult.valid) console.writeline ("warning: test {0} returned unverifiable under ad but {1} under pv, using ad choice", testname, pv);	if (rt == runresult.invalid) {	
warning test returned unverifiable under ad but under runtime pv said using runtime choice 

if (rt == runresult.invalid) {	return rt;	}	return runresult.unverifiable;	}	if (ad == runresult.invalid) {	if (pv == runresult.valid) console.writeline ("warning: test {0} returned invalid under ad but {1} under pv, using ad choice", testname, pv);	if (rt == runresult.valid) return runresult.unverifiable;	return runresult.invalid;	}	
error test returned an unknown result under ad runtime said and pv fixme 

directoryinfo dir = new directoryinfo (dirname);	foreach (fileinfo file in dir.getfiles ()) {	try {	runresult rr = runresult.none;	if (file.name.startswith ("strict_")) rr = runresult.strict;	else if (file.name.startswith ("valid_")) rr = runresult.valid;	else if (file.name.startswith ("unverifiable_")) rr = runresult.unverifiable;	else if (file.name.startswith ("invalid_")) rr = runresult.invalid;	if (file.name.endswith (".exe") && rr != runresult.none) executetest (file.fullname, file.name, rr);	} catch (exception e) {	
warning test thrown exception 

========================= mono sample_752 =========================

public void hello (t t) {	
hello 

========================= mono sample_2288 =========================

public static int main (string[] args) {	int1 s1;	s1.f1 = 1;	s1 = mono_return_int1(s1, 906);	if (s1.f1 != 1+906) {	
got but expected 

s1.f1 = 1;	s1 = mono_return_int1(s1, 906);	if (s1.f1 != 1+906) {	return 1;	}	int2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_int2(s2, 906);	if (s2.f1 != 1+906) {	
got but expected 

return 1;	}	int2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_int2(s2, 906);	if (s2.f1 != 1+906) {	return 1;	}	if (s2.f2 != 2+906) {	
got but expected 

}	if (s2.f2 != 2+906) {	return 2;	}	int3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_int3(s3, 906);	if (s3.f1 != 1+906) {	
got but expected 

}	int3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_int3(s3, 906);	if (s3.f1 != 1+906) {	return 1;	}	if (s3.f2 != 2+906) {	
got but expected 

s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_int3(s3, 906);	if (s3.f1 != 1+906) {	return 1;	}	if (s3.f2 != 2+906) {	return 2;	}	if (s3.f3 != 3+906) {	
got but expected 

if (s3.f3 != 3+906) {	return 3;	}	int4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_int4(s4, 906);	if (s4.f1 != 1+906) {	
got but expected 

int4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_int4(s4, 906);	if (s4.f1 != 1+906) {	return 1;	}	if (s4.f2 != 2+906) {	
got but expected 

s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_int4(s4, 906);	if (s4.f1 != 1+906) {	return 1;	}	if (s4.f2 != 2+906) {	return 2;	}	if (s4.f3 != 3+906) {	
got but expected 

if (s4.f1 != 1+906) {	return 1;	}	if (s4.f2 != 2+906) {	return 2;	}	if (s4.f3 != 3+906) {	return 3;	}	if (s4.f4 != 4+906) {	
got but expected 

return 4;	}	int5 s5;	s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_int5(s5, 906);	if (s5.f1 != 1+906) {	
got but expected 

s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_int5(s5, 906);	if (s5.f1 != 1+906) {	return 1;	}	if (s5.f2 != 2+906) {	
got but expected 

s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_int5(s5, 906);	if (s5.f1 != 1+906) {	return 1;	}	if (s5.f2 != 2+906) {	return 2;	}	if (s5.f3 != 3+906) {	
got but expected 

if (s5.f1 != 1+906) {	return 1;	}	if (s5.f2 != 2+906) {	return 2;	}	if (s5.f3 != 3+906) {	return 3;	}	if (s5.f4 != 4+906) {	
got but expected 

if (s5.f2 != 2+906) {	return 2;	}	if (s5.f3 != 3+906) {	return 3;	}	if (s5.f4 != 4+906) {	return 4;	}	if (s5.f5 != 5+906) {	
got but expected 

if (s5.f5 != 5+906) {	return 5;	}	int4_nested sn4;	sn4.nested1.f1 = 1;	sn4.f2 = 2;	sn4.f3 = 3;	sn4.nested2.f4 = 4;	sn4 = mono_return_int4_nested(sn4, 906);	if (sn4.nested1.f1 != 1+906) {	
nested got but expected 

int4_nested sn4;	sn4.nested1.f1 = 1;	sn4.f2 = 2;	sn4.f3 = 3;	sn4.nested2.f4 = 4;	sn4 = mono_return_int4_nested(sn4, 906);	if (sn4.nested1.f1 != 1+906) {	return 1;	}	if (sn4.f2 != 2+906) {	
nested got but expected 

sn4.f3 = 3;	sn4.nested2.f4 = 4;	sn4 = mono_return_int4_nested(sn4, 906);	if (sn4.nested1.f1 != 1+906) {	return 1;	}	if (sn4.f2 != 2+906) {	return 2;	}	if (sn4.f3 != 3+906) {	
nested got but expected 

if (sn4.nested1.f1 != 1+906) {	return 1;	}	if (sn4.f2 != 2+906) {	return 2;	}	if (sn4.f3 != 3+906) {	return 3;	}	if (sn4.nested2.f4 != 4+906) {	
nested got but expected 

========================= mono sample_492 =========================

public static int main(string[] args) {	thread t = new thread (run);	t.start ();	t.join ();	if (fault) {	if (ex == null) {	
fault occured but no exception object available 

t.join ();	if (fault) {	if (ex == null) {	return 1;	} else {	bool is_stackoverlfow = ex is stackoverflowexception;	console.writeline ("fault occured: ex = " + is_stackoverlfow);	return is_stackoverlfow ? 0 : 3;	}	}	
no fault 

========================= mono sample_703 =========================

public static int main () {	enum e = foo.bar;	iconvertible convertible = (iconvertible) e;	icomparable comparable = (icomparable) e;	iformattable formattable = (iformattable) e;	
pass 

========================= mono sample_1370 =========================

public void lock (simlock lk, string frame) {	foreach (lockrecord lr in locks) {	
warning tried to acquire lock at while holding at 

public void lock (simlock lk, string frame) {	foreach (lockrecord lr in locks) {	
error tried to acquire lock at while holding at 

public void release (simlock lk, string frame) {	if (locks.count == 0) {	
error released lock at while holding no locks 

public void release (simlock lk, string frame) {	if (locks.count == 0) {	return;	}	lockrecord top = locks [locks.count - 1];	if (top.lk != lk && !(lk.isgloballock && holdcount (lk) > 1)) {	
warning released lock at out of order with at 

public void dump (symboltable table) {	
x x 

static void main (string[] args) {	symboltable syms;	if (args.length != 2) {	
usage locktracerdecoder exe path to mono path to locks pid 

========================= mono sample_800 =========================

public void linqtosqladvanced05() {	northwind db = createdb();	var con = new category() { categoryname = "new era", description= "(123)-456-7890" };	db.categories.insertonsubmit(con);	db.submitchanges();	console.writeline();	
the category of the new record is 

========================= mono sample_24681 =========================

public delegate void foodelegate();	public static readonly foodelegate _print = delegate() {	
delegate 

========================= mono sample_3275 =========================

var task20 = assembly.reflectiononlyload ("microsoft.build.tasks, version=2.0.0.0, culture=neutral, publickeytoken=b03f5f7f11d50a3a");	var task35 = assembly.reflectiononlyload ("microsoft.build.tasks.v3.5, version=3.5.0.0, culture=neutral, publickeytoken=b03f5f7f11d50a3a");	var engn20 = assembly.reflectiononlyload ("microsoft.build.engine, version=2.0.0.0, culture=neutral, publickeytoken=b03f5f7f11d50a3a");	var engn35 = assembly.reflectiononlyload ("microsoft.build.engine, version=3.5.0.0, culture=neutral, publickeytoken=b03f5f7f11d50a3a");	var frwk20 = assembly.reflectiononlyload ("microsoft.build.framework, version=2.0.0.0, culture=neutral, publickeytoken=b03f5f7f11d50a3a");	var frwk35 = assembly.reflectiononlyload ("microsoft.build.framework, version=3.5.0.0, culture=neutral, publickeytoken=b03f5f7f11d50a3a");	var mono_path = environment.getenvironmentvariable ("mono_path");	if (!string.isnullorempty (mono_path)) {	var xbuild = path.combine (new directoryinfo (mono_path).parent.fullname, "xbuild_14");	mono_path = xbuild + path.pathseparator + mono_path;	
setting mono assemblies path to 

========================= mono sample_643 =========================

public static void main () {	
captionfont 

public static void main () {	
defaultfont 

public static void main () {	
dialogfont 

public static void main () {	
icontitlefont 

public static void main () {	
menufont 

public static void main () {	
messageboxfont 

public static void main () {	
smallcaptionfont 

public static void main () {	
statusfont 

public static void main () {	font fnt = new font ("arial", 12);	
issystemfontname 

========================= mono sample_21335 =========================

connectionstringsettings cssc = ((connectionstringssection)connstrings).connectionstrings["localsqlserver"];	console.writeline ("connstrings[localsqlserver] = {0}", (cssc == null ? "null" : cssc.connectionstring));	connectionstringsettings cssc2 = ((connectionstringssection)connstrings).connectionstrings["accessfilename"];	console.writeline ("connstrings[accessfilename] = {0}", (cssc2 == null ? "null" : cssc2.connectionstring));	appsettingssection sect = (appsettingssection) config.appsettings;	console.writeline ("sect.settings[hithere] = {0}", (sect.settings ["hithere"] == null ? "null" : sect.settings ["hithere"].value.tostring ()));	rsaprotectedconfigurationprovider rsa = (rsaprotectedconfigurationprovider)protectedconfiguration.providers [protectedconfiguration.defaultprovider];	console.writeline ("rsa = {0}", (rsa == null ? "null" : rsa.tostring ()));	}	catch (exception e) {	
raised 

========================= mono sample_29828 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	
ok 

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_1383 =========================

public static void main(string[] args) {	for (int i = 0; i < mutexes.length; i++) {	mutexes [i] = new mutex();	}	thread thread1 = new thread(() => {	for (int i = 0; i < 1; i++) {	int idx = -1;	try {	idx = waithandle.waitany (mutexes);	
thread iter i with mutex idx 

}	thread thread1 = new thread(() => {	for (int i = 0; i < 1; i++) {	int idx = -1;	try {	idx = waithandle.waitany (mutexes);	} finally {	if (idx != -1) mutexes [idx].releasemutex();	}	}	
thread ended 

}	}	});	thread1.start();	thread1.join();	thread thread2 = new thread(() => {	for (int i = 0; i < 1000; i++) {	int idx = -1;	try {	idx = waithandle.waitany (mutexes);	
thread iter i with mutex idx 

thread1.join();	thread thread2 = new thread(() => {	for (int i = 0; i < 1000; i++) {	int idx = -1;	try {	idx = waithandle.waitany (mutexes);	} finally {	if (idx != -1) mutexes [idx].releasemutex();	}	}	
thread ended 

========================= mono sample_461 =========================

static private void dumpdecimalhelperparts(int index) {	sqldecimal sqldecimalvalue = 10;	console.writeline("static private readonly uint32[] {0} = {{", helpernames[index]);	for (int precision = 2; precision <= sqldecimal.maxprecision; precision++){	
if precision sqldecimal maxprecision 

}	sqldecimalvalue = sqldecimal.maxvalue;	int[] data = sqldecimalvalue.data;	uint32[] udata = { (uint32)data[0], (uint32)data[1], (uint32)data[2], (uint32)data[3]};	bool carry = true;	for (int i = 0; i < 4; i++){	if (carry){	carry = (++udata[i] == 0);	}	}	
console writeline 

sqldebug.check(m_blen <= x_cnumemax, "m_blen <= x_cnumemax", "in assertvalid");	uint[] rgldata = new uint[4] {m_data1, m_data2, m_data3, m_data4};	if (rgldata[m_blen-1] == 0) {	sqldebug.check(m_blen == 1, "m_blen == 1", "in assertvalid");	}	for (int iuldata = m_blen; iuldata < x_cnumemax; iuldata++) sqldebug.check(rgldata[iuldata] == 0, "rgldata[iuldata] == 0", "in assertvalid");	}	[system.diagnostics.conditional("debug")]	private void print() {	if (isnull) {	
numeric null 

if (rgldata[m_blen-1] == 0) {	sqldebug.check(m_blen == 1, "m_blen == 1", "in assertvalid");	}	for (int iuldata = m_blen; iuldata < x_cnumemax; iuldata++) sqldebug.check(rgldata[iuldata] == 0, "rgldata[iuldata] == 0", "in assertvalid");	}	[system.diagnostics.conditional("debug")]	private void print() {	if (isnull) {	return;	}	
numeric data 

private void print() {	if (isnull) {	return;	}	debug.writeline("\tlen = " + m_blen.tostring() + ", prec = " + m_bprec.tostring() + ", scale = " + m_bscale.tostring() + ", sign = " + ispositive.tostring());	}	[system.diagnostics.conditional("debug")]	private void print(string s) {	debug.writeline("*** " + s + " ***");	if (isnull) {	
numeric null 

return;	}	debug.writeline("\tlen = " + m_blen.tostring() + ", prec = " + m_bprec.tostring() + ", scale = " + m_bscale.tostring() + ", sign = " + ispositive.tostring());	}	[system.diagnostics.conditional("debug")]	private void print(string s) {	debug.writeline("*** " + s + " ***");	if (isnull) {	return;	}	
numeric data 

========================= mono sample_14216 =========================

console.write (".");	monitor.wait(count_lock);	}	}	foreach (var t in threads) {	t.join();	}	console.writeline ();	iterations += 1;	}	
done iterations iterations 

========================= mono sample_521 =========================

public static void main () {	
the compiler should complain error trying to use this outside context 

public static void main () {	
trying to assign i to this outside a method property or ctr 

========================= mono sample_35885 =========================

private void checklibrary (methodbase method, dllimportattribute attribute, assemblycheckinfo report) {	string library = attribute.value;	string entrypoint = attribute.entrypoint;	string type = method.declaringtype.fullname;	string mname = method.name;	string found = null;	string error = null;	
trying to load base library 

private static bool loadlibrary (string type, string member, string library, string symbol, assemblycheckinfo report, out string error) {	error = null;	intptr h = g_module_open (library, g_module_bind_lazy | g_module_bind_local);	try {	
trying library name 

intptr h = g_module_open (library, g_module_bind_lazy | g_module_bind_local);	try {	if (h != intptr.zero) {	string soname = marshal.ptrtostringansi (g_module_name (h));	trace.writeline ("able to load library " + library + "; soname=" + soname);	intptr ignore;	if (g_module_symbol (h, symbol, out ignore) == 0) report.errors.add (new messageinfo ( type, member, string.format ("library `{0}' is missing symbol `{1}'", library, symbol)));	return true;	}	error = marshal.ptrtostringansi (g_module_error ());	
error loading library 

========================= mono sample_1195 =========================

public static int main () {	int r;	a a = new a (1);	if (a.value != 500) return 1;	r = a.test (1);	if (r != 2) return 2;	r = a [0];	if (r != 2) return 3;	
ok 

========================= mono sample_3090 =========================

bitmap bmp_in = new bitmap (sin);	bitmap bmp_out = new bitmap (bmp_in.width, bmp_in.height, bmp_in.pixelformat);	graphics gr = graphics.fromimage (bmp_out);	imageattributes imageattr = new imageattributes ();	imageattr.setcolormatrix (colormatrix);	gr.drawimage (bmp_in, new rectangle (0, 0, bmp_out.width, bmp_out.height), 0,0, bmp_out.width, bmp_out.height, graphicsunit.pixel, imageattr);	imageattr.dispose ();	bmp_out.save (sout);	bmp_in.dispose ();	bmp_out.dispose ();	
saving image file 

public static void main(string[] args) {	color clr_src, clr_rslt;	
red 

new float[] 	{2,	0,	0, 	0, 	0}, new float[] 	{0,	1,	0, 	0, 	0}, new float[] 	{0,	0,	1, 	0, 	0}, new float[] 	{0,	0,	0, 	1, 	0}, new float[] 	{0.2f,	0,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 100, 20, 50);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	{	colormatrix colormatrix = new colormatrix (new float[][] {	new float[] 	{0.5f,	0,	0, 	0, 	0}, new float[] 	{0.5f,	1,	0, 	0, 	0}, new float[] 	{0,	0,	1, 	0, 	0}, new float[] 	{0,	0,	0, 	1, 	0}, new float[] 	{0.2f,	0,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 100, 20, 50);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	
green 

new float[] 	{1,	0,	0, 	0, 	0}, new float[] 	{0,	1,	0, 	0, 	0}, new float[] 	{0,	0,	1, 	0, 	0}, new float[] 	{0,	2,	0, 	1, 	0}, new float[] 	{0,	0.5f,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 100, 20, 50);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	{	colormatrix colormatrix = new colormatrix (new float[][] {	new float[] 	{1,	0,	0, 	0, 	0}, new float[] 	{0,	0,	0, 	0, 	0}, new float[] 	{0,	0,	1, 	0, 	0}, new float[] 	{0,	0.5f,	0, 	1, 	0}, new float[] 	{0,	0f,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 100, 20, 50);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	
blue 

new float[] 	{1,	0,	0, 	0, 	0}, new float[] 	{0,	1,	1, 	0, 	0}, new float[] 	{0,	0,	0, 	0, 	0}, new float[] 	{0,	0,	0, 	1, 	0}, new float[] 	{0,	0,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 100, 100, 25);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	{	colormatrix colormatrix = new colormatrix (new float[][] {	new float[] 	{1,	0,	0, 	0, 	0}, new float[] 	{0,	0,	0, 	0, 	0}, new float[] 	{0,	0,	1, 	0, 	0}, new float[] 	{0,	0.5f,	0, 	1, 	0}, new float[] 	{0,	0f,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 100, 20, 50);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	
all 

new float[] 	{1,	0,	0, 	0, 	0}, new float[] 	{0.5f,	1,	0, 	0, 	0}, new float[] 	{0,	0.1f,	1.5f, 	0, 	0}, new float[] 	{0.5f,	3,	0.5f, 	1, 	0}, new float[] 	{0,	0,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 10, 20, 25);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	{	colormatrix colormatrix = new colormatrix (new float[][] {	new float[] 	{1,	0,	0, 	0.5f, 	0}, new float[] 	{0,	1,	1, 	0, 	0}, new float[] 	{0,	0,	0.8f, 	0, 	0}, new float[] 	{0,	2,	0, 	1, 	0}, new float[] 	{0,	0,	0, 	0, 	0}, });	clr_src = color.fromargb (255, 100, 100, 25);	clr_rslt = processcolormatrix (clr_src, colormatrix);	}	
images 

========================= mono sample_21301 =========================

public static extern void stringparameterref([marshalas(unmanagedtype.lputf8str)]ref string s, int index);	public static bool teststringpassbyref(string orgstring, int index) {	string orgcopy = new string(orgstring.tochararray());	stringparameterref(ref orgstring, index);	if (orgstring != orgcopy) {	
teststringpassbyout string mismatch 

public static void utf8stringcallback(string nativestring, int index) {	if (string.compareordinal(nativestring, test.utf8strings[index]) != 0) {	
string do not match 

========================= mono sample_677 =========================

public static int main () {	long [,,] a1 = new long [2,3,2] {{{0,1}, {2,3}, {4,5}}, {{6,7}, {8,9}, {10,11}}};	long[] l = new long[] {	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, };	if (l [1] != 1) {	
incorrect at 

long[] l = new long[] {	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, };	if (l [1] != 1) {	return 1;	}	int v = 6;	int[] a2 = new int[] { 0, 1, 2, 3, 4, 5, v };	for (int i = 0; i < a2.length; ++i) {	if (a2 [i] != i) return 2;	}	
ok 

========================= mono sample_3172 =========================

public static int main() {	environment.exitcode = 2;	appdomain domain=appdomain.createdomain("other");	
about to execute 

public static int main() {	environment.exitcode = 2;	appdomain domain=appdomain.createdomain("other");	domain.executeassembly("main-exit.exe");	
execute returns 

public static int main() {	environment.exitcode = 2;	appdomain domain=appdomain.createdomain("other");	domain.executeassembly("main-exit.exe");	appdomain.unload(domain);	
finished 

========================= mono sample_404 =========================

using (bitmap bmp = new bitmap (sinfile)) {	bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 13) {	
assert areequal scan 

using (bitmap bmp = new bitmap (sinfile)) {	bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 13) {	
assert areequal scan 

using (bitmap bmp = new bitmap (sinfile)) {	bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 13) {	
assert areequal scan 

using (bitmap bmp = new bitmap (sinfile)) {	bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 97) {	
assert areequal scan 

using (bitmap bmp = new bitmap (sinfile)) {	bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 97) {	
assert areequal scan 

========================= mono sample_21123 =========================

public static void main() {	ifoo foo = null;	
got an ifoo 

public static void main() {	ifoo foo = null;	bar bar = null;	
got a bar 

========================= mono sample_3133 =========================

bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	assert.areequal (332, data.stride, "stride");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

========================= mono sample_21133 =========================

static private void help () {	
usage permview options assembly 

static private void help () {	
where options are 

static private void help () {	
output filename output information into specified file 

static private void help () {	
decl show declarative security attributes on classes and methods 

static private void help () {	
xml output in xml format 

static private void help () {	
help show help informations this text 

string optional = notspecified + environment.newline;	string refused = notspecified + environment.newline;	foreach (securitydeclaration decl in ad.securitydeclarations) {	switch (decl.action) {	case mono.cecil.securityaction.requestminimum: minimal = decl.topermissionset ().tostring ();	break;	case mono.cecil.securityaction.requestoptional: optional = decl.topermissionset ().tostring ();	break;	case mono.cecil.securityaction.requestrefuse: refused = decl.topermissionset ().tostring ();	break;	
invalid assembly level declaration 

case mono.cecil.securityaction.requestminimum: minimal = decl.topermissionset ().tostring ();	break;	case mono.cecil.securityaction.requestoptional: optional = decl.topermissionset ().tostring ();	break;	case mono.cecil.securityaction.requestrefuse: refused = decl.topermissionset ().tostring ();	break;	result = false;	break;	}	}	
minimal permission set 

break;	case mono.cecil.securityaction.requestoptional: optional = decl.topermissionset ().tostring ();	break;	case mono.cecil.securityaction.requestrefuse: refused = decl.topermissionset ().tostring ();	break;	result = false;	break;	}	}	tw.writeline (minimal);	
optional permission set 

case mono.cecil.securityaction.requestoptional: optional = decl.topermissionset ().tostring ();	break;	case mono.cecil.securityaction.requestrefuse: refused = decl.topermissionset ().tostring ();	break;	result = false;	break;	}	}	tw.writeline (minimal);	tw.writeline (optional);	
refused permission set 

static void showsecurity (textwriter tw, string header, ienumerable<securitydeclaration> declarations) {	foreach (securitydeclaration declsec in declarations) {	
permission set 

if (ad != null) {	bool complete = false;	if (declarative) {	complete = processassemblycomplete (tw, ad);	} else if (xmloutput) {	complete = processassemblyxml (tw, ad);	} else {	complete = processassemblyonly (tw, ad);	}	if (!complete) {	
couldn t reflect informations 

complete = processassemblycomplete (tw, ad);	} else if (xmloutput) {	complete = processassemblyxml (tw, ad);	} else {	complete = processassemblyonly (tw, ad);	}	if (!complete) {	return 1;	}	} else {	
couldn t load assembly 

if (!complete) {	return 1;	}	} else {	return 2;	}	}	tw.close ();	}	catch (exception e) {	
error 

========================= mono sample_1176 =========================

private void backtrack() {	int newpos = runtrack[runtrackpos++];	#if dbg if (runmatch.debug) {	
backtracking to code position 

private void backtrack() {	int newpos = runtrack[runtrackpos++];	#if dbg if (runmatch.debug) {	
backtracking to code position 

========================= mono sample_11786 =========================

public static int main (string[] args) {	try {	if (args.length != 1) {	
usage mono table from charset 

public static int main (string[] args) {	try {	if (args.length != 1) {	return 1;	}	string charset = args[0];	encoding encoding;	try {	encoding = encoding.getencoding(charset);	} catch (notsupportedexception e) {	
no converter for 

========================= mono sample_30187 =========================

public static int main () {	appdomain.currentdomain.assemblyresolve += new resolveeventhandler (myresolveeventhandler);	event_handler_count = 0;	try {	assembly a = assembly.loadfile (path.combine (directory.getcurrentdirectory (), "assemblyresolve_asm.dll"));	foreach (type t in a.gettypes ()) {	
pp 

public static int main () {	appdomain.currentdomain.assemblyresolve += new resolveeventhandler (myresolveeventhandler);	event_handler_count = 0;	try {	assembly a = assembly.loadfile (path.combine (directory.getcurrentdirectory (), "assemblyresolve_asm.dll"));	foreach (type t in a.gettypes ()) {	}	} catch (exception ex) {	
caught exception ex 

appdomain.currentdomain.assemblyresolve += new resolveeventhandler (myresolveeventhandler);	event_handler_count = 0;	try {	assembly a = assembly.loadfile (path.combine (directory.getcurrentdirectory (), "assemblyresolve_asm.dll"));	foreach (type t in a.gettypes ()) {	}	} catch (exception ex) {	return 1;	}	if (event_handler_count != expected_count) {	
expected myresolveeventhandler to be called expected count but was called event handler count 

static assembly myresolveeventhandler (object sender, resolveeventargs args) {	event_handler_count++;	
resolve assembly 

========================= mono sample_414 =========================

public static int main (string[] args) {	var options = new cmdoptions ();	var p = new optionset () {	{ "t|txt=", "file with string resource in key=value format", v => options.resourcesstrings.add (v) }, { "h|help",  "display available options", v => options.showhelp = v != null }, { "v|verbose",  "use verbose output", v => options.verbose = v != null }, { "ignore-semicolon", "reads lines starting with semicolon", v => options.ignoresemicolon = v != null }, };	list<string> extra;	try {	extra = p.parse (args);	}	catch (optionexception e) {	console.writeline (e.message);	
try help for more information 

static void showhelp (optionset p) {	
usage cil options output file 

static void showhelp (optionset p) {	
generates c file from reference source resource text file 

static void showhelp (optionset p) {	console.writeline ();	
options 

static void generatefile (string outputfile, list<tuple<string, string>> txtstrings, cmdoptions options) {	using (var str = new streamwriter (outputfile)) {	
str writeline str writeline 

static void generatefile (string outputfile, list<tuple<string, string>> txtstrings, cmdoptions options) {	using (var str = new streamwriter (outputfile)) {	
partial class sr 

static bool loadstrings (list<tuple<string, string>> resourcesstrings, cmdoptions options) {	var keys = new dictionary<string, string> ();	foreach (var filename in options.resourcesstrings) {	if (!file.exists (filename)) {	
error reading resource file filename 

========================= mono sample_1305 =========================

protected override void generateiterationstatement(codeiterationstatement e) {	generatestatement(e.initstatement);	output.write("do while ");	generateexpression(e.testexpression);	output.writeline("");	indent++;	generatevbstatements(e.statements);	generatestatement(e.incrementstatement);	indent--;	
loop 

protected override void generatemethodreturnstatement(codemethodreturnstatement e) {	if (e.expression != null) {	output.write("return ");	generateexpression(e.expression);	output.writeline("");	}	else {	
return 

protected override void generateconditionstatement(codeconditionstatement e) {	output.write("if ");	generateexpression(e.condition);	
then 

generatevbstatements(e.truestatements);	indent--;	codestatementcollection falsestatemetns = e.falsestatements;	if (falsestatemetns.count > 0) {	output.write("else");	output.writeline("");	indent++;	generatevbstatements(e.falsestatements);	indent--;	}	
end if 

protected override void generatetrycatchfinallystatement(codetrycatchfinallystatement e) {	
try 

output.write("catch ");	outputtypenamepair(current.catchexceptiontype, current.localname);	output.writeline("");	indent++;	generatevbstatements(current.statements);	indent--;	}	}	codestatementcollection finallystatements = e.finallystatements;	if (finallystatements.count > 0) {	
finally 

generatevbstatements(current.statements);	indent--;	}	}	codestatementcollection finallystatements = e.finallystatements;	if (finallystatements.count > 0) {	indent++;	generatevbstatements(finallystatements);	indent--;	}	
end try 

protected override void generatelinepragmaend(codelinepragma e) {	output.writeline("");	
end externalsource 

outputtype(e.privateimplementationtype);	output.write(".");	outputidentifier(methodname);	}	output.writeline("");	if (!iscurrentinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	generatevbstatements(e.statements);	indent--;	if (sub) {	
end sub 

outputidentifier(methodname);	}	output.writeline("");	if (!iscurrentinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	generatevbstatements(e.statements);	indent--;	if (sub) {	}	else {	
end function 

protected override void generateentrypointmethod(codeentrypointmethod e, codetypedeclaration c) {	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	
public shared sub main 

protected override void generateentrypointmethod(codeentrypointmethod e, codetypedeclaration c) {	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	indent++;	generatevbstatements(e.statements);	indent--;	
end sub 

else if (e.privateimplementationtype != null) {	output.write(" implements ");	outputtype(e.privateimplementationtype);	output.write(".");	outputidentifier(propname);	}	output.writeline("");	if (!c.isinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	if (e.hasget) {	
get 

}	output.writeline("");	if (!c.isinterface && (e.attributes & memberattributes.scopemask) != memberattributes.abstract) {	indent++;	if (e.hasget) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.getstatements);	e.name = propname;	indent--;	
end get 

indent++;	if (e.hasget) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.getstatements);	e.name = propname;	indent--;	}	}	if (e.hasset) {	
set 

generatevbstatements(e.getstatements);	e.name = propname;	indent--;	}	}	if (e.hasset) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.setstatements);	indent--;	
end set 

}	}	if (e.hasset) {	if (!iscurrentinterface) {	indent++;	generatevbstatements(e.setstatements);	indent--;	}	}	indent--;	
end property 

output.write(")");	output.writeline("");	}	else if (baseargs.count > 0) {	output.write("mybase.new(");	outputexpressionlist(baseargs);	output.write(")");	output.writeline("");	}	else if(iscurrentclass) {	
mybase new 

else if (baseargs.count > 0) {	output.write("mybase.new(");	outputexpressionlist(baseargs);	output.write(")");	output.writeline("");	}	else if(iscurrentclass) {	}	generatevbstatements(e.statements);	indent--;	
end sub 

protected override void generatetypeconstructor(codetypeconstructor e) {	if (!(iscurrentclass || iscurrentstruct)) return;	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	
shared sub new 

protected override void generatetypeconstructor(codetypeconstructor e) {	if (!(iscurrentclass || iscurrentstruct)) return;	if (e.customattributes.count > 0) {	outputattributes(e.customattributes, false);	}	indent++;	generatevbstatements(e.statements);	indent--;	
end sub 

output.writeline(system.environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line4));	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line5));	output.write("' </");	output.writeline(sr.getstring(sr.autogen_comment_line1));	output.writeline("'------------------------------------------------------------------------------");	output.writeline("");	
option strict off 

output.writeline(system.environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line4));	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line5));	output.write("' </");	output.writeline(sr.getstring(sr.autogen_comment_line1));	output.writeline("'------------------------------------------------------------------------------");	output.writeline("");	
option strict on 

output.writeline(system.environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line4));	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line5));	output.write("' </");	output.writeline(sr.getstring(sr.autogen_comment_line1));	output.writeline("'------------------------------------------------------------------------------");	output.writeline("");	
option explicit off 

output.writeline(system.environment.version.tostring());	output.writeline("'");	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line4));	output.write("'     ");	output.writeline(sr.getstring(sr.autogen_comment_line5));	output.write("' </");	output.writeline(sr.getstring(sr.autogen_comment_line1));	output.writeline("'------------------------------------------------------------------------------");	output.writeline("");	
option explicit on 

private void generatecoderegiondirective(coderegiondirective regiondirective) {	if (isgeneratingstatements()) {	return;	}	if (regiondirective.regionmode == coderegionmode.start) {	output.write("#region \"");	output.write(regiondirective.regiontext);	output.writeline("\"");	}	else if (regiondirective.regionmode == coderegionmode.end) {	
end region 

protected override void generatenamespaceend(codenamespace e) {	if (e.name != null && e.name.length > 0) {	indent--;	
end namespace 

========================= mono sample_11827 =========================

t = teststack_4 ();	if (!task.waitall (new[] { t }, 1000)) return 6;	if (t.result != 0) return 7;	var g = new g<sbyte> ();	t = g.teststack_1 (9);	if (!task.waitall (new[] { t }, 1000)) return 8;	if (t.result != 0) return 9;	t = teststack_5 ();	if (!task.waitall (new[] { t }, 1000)) return 10;	if (t.result != 0) return 11;	
ok 

========================= mono sample_1354 =========================

public static void main () {	string problems = "";	type t = typeof (test);	foreach (methodinfo m in t.getmethods (bindingflags.public | bindingflags.instance | bindingflags.declaredonly)) {	parameterinfo p = m.getparameters () [0];	
parameter attributes 

========================= mono sample_3080 =========================

static private void help () {	
usage makecert options certificate 

static private void help () {	
num certificate serial number 

static private void help () {	
n dn subject distinguished name 

static private void help () {	
in dn issuer distinguished name 

static private void help () {	
r create a self signed root certificate 

static private void help () {	
sv pkvfile private key file pvk for the subject created if missing 

static private void help () {	
iv pvkfile private key file pvk for the issuer 

static private void help () {	
ic certfile extract the issuer s name from the specified certificate 

static private void help () {	
help display this help message 

static private void help () {	
extended help for advanced options 

static private void extendedhelp () {	
usage makecert options certificate 

static private void extendedhelp () {	
a hash select hash algorithm only and default are supported 

static private void extendedhelp () {	
b date the date since when the certificate is valid notbefore 

static private void extendedhelp () {	
cy authority end basic constraints select authority or end entity certificate 

static private void extendedhelp () {	
e date the date until when the certificate is valid notafter 

static private void extendedhelp () {	
eku oid oid add some extended key usage oid to the certificate 

static private void extendedhelp () {	
h number add a path length restriction to the certificate chain 

static private void extendedhelp () {	
in name take the issuer s name from the specified parameter 

static private void extendedhelp () {	
m number certificate validity period in months 

static private void extendedhelp () {	
password create a new pkcs file with the specified password 

static private void extendedhelp () {	
help display basic message 

static int main (string[] args) {	if (args.length < 1) {	header ();	
error missing output filename 

try {	int i=0;	while (i < args.length) {	switch (args [i++]) {	case "-#": sn = bitconverter.getbytes (convert.toint32 (args [i++]));	break;	case "-n": subject = args [i++];	break;	case "-$": string usagerestriction = args [i++].tolower ();	switch (usagerestriction) {	
commercial individual warning unsupported deprecated certification extension keyusagerestriction not included 

int i=0;	while (i < args.length) {	switch (args [i++]) {	case "-#": sn = bitconverter.getbytes (convert.toint32 (args [i++]));	break;	case "-n": subject = args [i++];	break;	case "-$": string usagerestriction = args [i++].tolower ();	switch (usagerestriction) {	break;	
unsupported restriction 

switch (usagerestriction) {	break;	return -1;	}	break;	case "-a": switch (args [i++].tolower ()) {	case "sha512": hashname = "sha512";	break;	case "sha256": hashname = "sha256";	break;	
warning is not safe for this usage 

return -1;	}	break;	case "-a": switch (args [i++].tolower ()) {	case "sha512": hashname = "sha512";	break;	case "sha256": hashname = "sha256";	break;	hashname = "sha1";	break;	
warning is not safe for this usage 

break;	case "-a": switch (args [i++].tolower ()) {	case "sha512": hashname = "sha512";	break;	case "sha256": hashname = "sha256";	break;	hashname = "sha1";	break;	hashname = "md5";	break;	
unsupported hash algorithm 

}	break;	case "-b": notbefore = datetime.parse (args [i++] + " 23:59:59", cultureinfo.invariantculture);	break;	case "-cy": switch (args [i++].tolower ()) {	case "authority": if (bce == null) bce = new basicconstraintsextension ();	bce.certificateauthority = true;	break;	case "end": bce = null;	break;	
both error no more supported in x 

break;	case "-b": notbefore = datetime.parse (args [i++] + " 23:59:59", cultureinfo.invariantculture);	break;	case "-cy": switch (args [i++].tolower ()) {	case "authority": if (bce == null) bce = new basicconstraintsextension ();	bce.certificateauthority = true;	break;	case "end": bce = null;	break;	return -1;	
unsupported certificate type 

case "-cy": switch (args [i++].tolower ()) {	case "authority": if (bce == null) bce = new basicconstraintsextension ();	bce.certificateauthority = true;	break;	case "end": bce = null;	break;	return -1;	return -1;	}	break;	
d unsupported option 

}	break;	case "-ic": issuercertificate = loadcertificate (args [i++]);	issuer = issuercertificate.subjectname;	break;	case "-in": issuer = args [i++];	break;	case "-iv": privatekey pvk = privatekey.createfromfile (args [i++]);	issuerkey = pvk.rsa;	break;	
l unsupported option 

issuer = issuercertificate.subjectname;	break;	case "-in": issuer = args [i++];	break;	case "-iv": privatekey pvk = privatekey.createfromfile (args [i++]);	issuerkey = pvk.rsa;	break;	break;	case "-m": notafter = notbefore.addmonths (convert.toint32 (args [i++]));	break;	
nscp unsupported option 

break;	case "-iv": privatekey pvk = privatekey.createfromfile (args [i++]);	issuerkey = pvk.rsa;	break;	break;	case "-m": notafter = notbefore.addmonths (convert.toint32 (args [i++]));	break;	break;	case "-r": selfsigned = true;	break;	
sc unsupported option 

break;	}	break;	case "-ip": issuerparams.providername = args [i++];	break;	case "-ir": switch (args [i++].tolower ()) {	case "localmachine": issuerparams.flags = cspproviderflags.usemachinekeystore;	break;	case "currentuser": issuerparams.flags = cspproviderflags.usedefaultkeycontainer;	break;	
unknown key store for issuer 

case "-ip": issuerparams.providername = args [i++];	break;	case "-ir": switch (args [i++].tolower ()) {	case "localmachine": issuerparams.flags = cspproviderflags.usemachinekeystore;	break;	case "currentuser": issuerparams.flags = cspproviderflags.usedefaultkeycontainer;	break;	return -1;	}	break;	
is unsupported option 

break;	}	break;	case "-sp": subjectparams.providername = args [i++];	break;	case "-sr": switch (args [i++].tolower ()) {	case "localmachine": subjectparams.flags = cspproviderflags.usemachinekeystore;	break;	case "currentuser": subjectparams.flags = cspproviderflags.usedefaultkeycontainer;	break;	
unknown key store for subject 

case "-sp": subjectparams.providername = args [i++];	break;	case "-sr": switch (args [i++].tolower ()) {	case "localmachine": subjectparams.flags = cspproviderflags.usemachinekeystore;	break;	case "currentuser": subjectparams.flags = cspproviderflags.usedefaultkeycontainer;	break;	return -1;	}	break;	
ss unsupported option 

case "-sy": subjectparams.providertype = convert.toint32 (args [i++]);	break;	case "-p12": p12file = args [i++];	p12pwd = args [i++];	break;	case "-?": help ();	return 0;	case "-!": extendedhelp ();	return 0;	default: if (i != args.length) {	
error unknown parameter 

p12.password = p12pwd;	arraylist list = new arraylist ();	list.add (new byte [4] { 1, 0, 0, 0 });	hashtable attributes = new hashtable (1);	attributes.add (pkcs9.localkeyid, list);	p12.addcertificate (new x509certificate (rawcert), attributes);	if (issuercertificate != null) p12.addcertificate (issuercertificate);	p12.addpkcs8shroudedkeybag (subjectkey, attributes);	p12.savetofile (p12file);	}	
success 

hashtable attributes = new hashtable (1);	attributes.add (pkcs9.localkeyid, list);	p12.addcertificate (new x509certificate (rawcert), attributes);	if (issuercertificate != null) p12.addcertificate (issuercertificate);	p12.addpkcs8shroudedkeybag (subjectkey, attributes);	p12.savetofile (p12file);	}	return 0;	}	catch (exception e) {	
error 

========================= mono sample_1185 =========================

string showmsg = null;	var optionset = new optionset {	{ "help", "show this help.", v => showoptions = v != null }, { "debug", "use mdb or pdb debug information (default=true).", v => options.debug = v != null }, { "level=", "instrumentation level, 0 - 4 (default=4).", (int var) => options.level = var}, { "writepdbfile", "write mdb or pdb file (default=true).", v => options.writepdbfile = v != null }, { "rewrite", "rewrite the assembly (default=true).", v => options.rewrite = v != null }, { "assembly=", "assembly to rewrite.", v => options.assembly = v }, { "breakintodebugger|break", "break into debugger on contract failure.", v => options.breakintodebugger = v != null }, { "throwonfailure|throw", "throw contractexception on contract failure.", v => options.throwonfailure = v != null }, { "output|out=", "output filename of rewritten file.", v => options.outputfile = v }, };	try {	optionset.parse (args);	} catch (optionexception e) {	showoptions = true;	showmsg = e.message;	}	if (showoptions) {	
ccrewrite 

var optionset = new optionset {	{ "help", "show this help.", v => showoptions = v != null }, { "debug", "use mdb or pdb debug information (default=true).", v => options.debug = v != null }, { "level=", "instrumentation level, 0 - 4 (default=4).", (int var) => options.level = var}, { "writepdbfile", "write mdb or pdb file (default=true).", v => options.writepdbfile = v != null }, { "rewrite", "rewrite the assembly (default=true).", v => options.rewrite = v != null }, { "assembly=", "assembly to rewrite.", v => options.assembly = v }, { "breakintodebugger|break", "break into debugger on contract failure.", v => options.breakintodebugger = v != null }, { "throwonfailure|throw", "throw contractexception on contract failure.", v => options.throwonfailure = v != null }, { "output|out=", "output filename of rewritten file.", v => options.outputfile = v }, };	try {	optionset.parse (args);	} catch (optionexception e) {	showoptions = true;	showmsg = e.message;	}	if (showoptions) {	console.writeline ();	
options 

console.writeline ();	if (showmsg != null) {	console.writeline (showmsg);	console.writeline ();	}	return;	}	var results = rewriter.rewrite (options);	if (results.anyerrors) {	foreach (var error in results.errors) {	
error 

}	return;	}	var results = rewriter.rewrite (options);	if (results.anyerrors) {	foreach (var error in results.errors) {	}	}	if (results.anywarnings) {	foreach (var warning in results.warnings) {	
warning 

var results = rewriter.rewrite (options);	if (results.anyerrors) {	foreach (var error in results.errors) {	}	}	if (results.anywarnings) {	foreach (var warning in results.warnings) {	}	}	console.writeline ();	
done 

========================= mono sample_1214 =========================

public static int main() {	type t = typeof (system.console);	type[] p= {typeof(string)};	methodinfo m = t.getmethod ("writeline", p);	if (typeof(void) != m.returntype) {	
type mismatch 

========================= mono sample_667 =========================

public static int main ( string [] args) {	bookaboutmovie jurassicpark = new bookaboutmovie("jurassic park");	
book title 

public static int main ( string [] args) {	bookaboutmovie jurassicpark = new bookaboutmovie("jurassic park");	
book title 

========================= mono sample_3387 =========================

public void appendtext (string text) {	
datagrid debug 

========================= mono sample_1282 =========================

public static void dumpproperties(object value, textwriter writer, int indent) {	if (value == null) {	
null 

public static void dumpproperties(object value, textwriter writer, int indent) {	if (value == null) {	} else if (value is string) {	
string value replace 

public static void dumpproperties(object value, textwriter writer, int indent) {	if (value == null) {	} else if (value is string) {	} else if (value is byte[]) {	
byte 

dump((byte[]) value);	} else if (value is valuetype) {	writer.writeline(value);	} else if (value is idictionary) {	type t = value.gettype();	writer.writeline(t.fullname);	foreach (dictionaryentry entry in ((idictionary) value)) {	dumpkeyvalue((string) entry.key, entry.value, writer, indent);	}	} else if (value is ienumerable) {	
ienumerable 

========================= mono sample_18091 =========================

public static int main () {	test2 ();	test2 (1, 2, 3, 4, 5);	if (test () != 0) return 1;	
ok 

========================= mono sample_3156 =========================

static int main () {	
friendly name 

newdomain.setdata ("test_array", ta);	int [] ca = (int [])newdomain.getdata ("test_array");	if (ca [0] != 1 || ca [1] != 2 || ca [2] != 3) return 7;	mbrtest test = (mbrtest) newdomain.createinstanceandunwrap (typeof(mbrtest).assembly.fullname, typeof(mbrtest).fullname);	if (!remotingservices.istransparentproxy(test)) return 8;	if (test.int != 1) return 9;	if (test.str != "a") return 10;	if (test.bool != false) return 11;	ca = test.arr;	if (ca [0] != 1 || ca [1] != 2 || ca [2] != 3) return 12;	
test ok 

========================= mono sample_420 =========================

var timeout = (int) _timeout.totalmilliseconds;	if (environment.getenvironmentvariable ("mono_profiler_stress_timeout") is string envtimeout) timeout = (int) timespan.parse (envtimeout).totalmilliseconds;	string options = null;	if (environment.getenvironmentvariable ("mono_profiler_stress_options") is string envoptions) options = envoptions;	var suspend = false;	if (environment.getenvironmentvariable ("mono_profiler_stress_suspend") is string envsuspend) suspend = bool.parse (envsuspend);	var rand = new random (seed);	var cpus = environment.processorcount;	var sw = stopwatch.startnew ();	console.foregroundcolor = consolecolor.magenta;	
sw elapsed tostring g starting test session with seed seed 

if (heapshotfreq > 0) profoptions += $"heapshot={heapshotfreq}gc,";	profoptions += string.join (",", flags);	} else profoptions += options;	var info = new processstartinfo {	useshellexecute = false, workingdirectory = path.combine (testdir, bench.testdirectory), filename = monopath, arguments = $"--debug --profile=log:{profoptions} " + string.join (" ", bench.commandline), redirectstandardoutput = true, redirectstandarderror = true, };	info.environmentvariables.clear ();	info.environmentvariables.add ("mono_path", classdir);	if (suspend) info.environmentvariables.add ("mono_debug", "suspend-on-native-crash,suspend-on-unhandled");	var progress = $"({i + 1}/{benchmarks.length})";	console.foregroundcolor = consolecolor.blue;	
sw elapsed tostring g progress running bench name with profiler options profoptions 

}	} else result.exitcode = proc.exitcode;	result.stopwatch.stop ();	lock (result) {	result.standardoutput = stdout.tostring ();	result.standarderror = stderr.tostring ();	}	}	var resultstr = result.exitcode == null ? "timed out" : $"exited with code: {result.exitcode}";	console.foregroundcolor = result.exitcode != 0 ? consolecolor.red : consolecolor.green;	
sw elapsed tostring g progress bench name took result stopwatch elapsed tostring g and resultstr 

writer.writeendelement ();	writer.writeendelement ();	writer.writeendelement ();	writer.writeendelement ();	writer.writeendelement ();	writer.writeendelement ();	writer.writeenddocument ();	}	var failurestr = failures + timeouts != 0 ? $" ({failures} failures, {timeouts} timeouts)" : string.empty;	console.foregroundcolor = failures + timeouts != 0 ? consolecolor.red : consolecolor.green;	
sw elapsed tostring g finished with successes results count passing tests failurestr 

========================= mono sample_3 =========================

static int testptrarithmetic () {	char [] array = new char [10];	char *pb;	array [5] = 'j';	fixed (char *pa = array){	pb = pa + 1;	if (pa [5] != 'j') return 199;	
v 

if (pa [5] != 'j') return 199;	if ((pb - pa) != 1) return 200;	pb++;	if (pb == pa) return 201;	if (pb < pa) return 202;	if (pa > pb) return 203;	if (pa >= pb) return 204;	if (pb <= pa) return 205;	pb = pb - 2;	if (pb != pa){	
vv 

public static int main () {	int v;	if ((v = testdereference ()) != 0) return v;	if ((v = testptradd ()) != 0) return v;	if ((v = testptrassign ()) != 0) return v;	if ((v = testptrarithmetic ()) != 0) return v;	if ((v = testmultiple ()) != 0) return v;	
ok 

========================= mono sample_3325 =========================

public static void main (string[] argv) {	if (argv.length == 1) {	bitmap bmp = new bitmap (argv[0]);	
output file bmpsave bmp 

public static void main (string[] argv) {	if (argv.length == 1) {	bitmap bmp = new bitmap (argv[0]);	bmp.save ("bmpsave.bmp", imageformat.bmp);	}	else {	
usage bmpsave exe filename 

========================= mono sample_21325 =========================

public static void main() {	test a=new test();	lock(a) {	a.val=2;	}	
a is 

========================= mono sample_653 =========================

public static int main() {	if (!test_1 ()) return 1;	if (!test_2 ()) return 2;	if (!test_3 ()) return 3;	if (!test_4 ()) return 4;	if (!test_5 ()) return 5;	if (test_6 () != 1) return 6;	
ok 

========================= mono sample_2298 =========================

public static void main(string[] args) {	
note that null prints as blank or 

public static void main(string[] args) {	bool? b1 = null, b2 = false, b3 = true;	bool? b4 = b1^b2, b5 = b1&b2, b6 = b1|b2;	console.writeline("[{0}] [{1}] [{2}]", b4, b5, b6);	bool? b7 = b1^b3, b8 = b1&b3, b9 = b1|b3;	console.writeline("[{0}] [{1}] [{2}]", b7, b8, b9);	console.writeline(b1 != null ? "null is true" : "null is false");	console.writeline(b1 == null ? "!null is true" : "!null is false");	console.writeline();	bool?[] bvals = new bool?[] { null, false, true };	
x y x y x y x y 

bool? b4 = b1^b2, b5 = b1&b2, b6 = b1|b2;	console.writeline("[{0}] [{1}] [{2}]", b4, b5, b6);	bool? b7 = b1^b3, b8 = b1&b3, b9 = b1|b3;	console.writeline("[{0}] [{1}] [{2}]", b7, b8, b9);	console.writeline(b1 != null ? "null is true" : "null is false");	console.writeline(b1 == null ? "!null is true" : "!null is false");	console.writeline();	bool?[] bvals = new bool?[] { null, false, true };	foreach (bool? x in bvals) foreach (bool? y in bvals) console.writeline("{0,-6} {1,-6} {2,-6} {3,-6} {4,-6}", x, y, x&y, x|y, x^y);	console.writeline();	
x x 

========================= mono sample_3265 =========================

public void linqtosqlobject01() {	northwind db = createdb();	var custs = from c in db.customers where c.city == "marseille" select c;	foreach (var cust in custs) foreach (var ord in cust.orders) {	
customerid has an orderid 

public void linqtosqlobject02() {	northwind db = createdb();	var ds = new dataloadoptions();	ds.loadwith<customer>(p => p.orders);	db.loadoptions = ds;	var custs = from c in db.customers where c.city == "marseille" select c;	
customerid has an orderid 

public void linqtosqlobject03() {	northwind db = createdb();	var custs = from c in db.customers where c.city == "london" select c;	foreach (var cust in custs) foreach (var ord in cust.orders) foreach (var orderdetail in ord.orderdetails) {	
customerid has an orderid with productid that has name 

public void linqtosqlobject04() {	var db = createdb();	var ds = new dataloadoptions();	ds.loadwith<customer>(p => p.orders);	ds.loadwith<order>(p => p.orderdetails);	db.loadoptions = ds;	var custs = from c in db.customers where c.city == "london" select c;	foreach (var cust in custs) foreach (var ord in cust.orders) foreach (var orderdetail in ord.orderdetails) {	
customerid has an orderid with productid that has name 

public void linqtosqlobject05() {	var db = createdb();	var emps = from e in db.employees select e;	
employee reported to manager 

========================= mono sample_24691 =========================

public my2attribute (string stuff, int blah) : base (stuff) {	
ctor with int val 

========================= mono sample_602 =========================

lb = interlocked.increment (ref la);	if (la != 0x12345679) return 16;	if (lb != 0x12345679) return 16;	lb = interlocked.decrement (ref la);	if (la != 0x12345678) return 17;	if (lb != 0x12345678) return 18;	la = 1;	lb = interlocked.compareexchange (ref la, 2, 1);	if (la != 2) return 19;	if (lb != 1) return 20;	
done 

========================= mono sample_593 =========================

private testoledb () {	oledbcommand cmd;	m_cnc = new oledbconnection ("provider=postgresql;addr=127.0.0.1;database=rodrigo");	m_cnc.open ();	
connected to 

private testoledb () {	oledbcommand cmd;	m_cnc = new oledbconnection ("provider=postgresql;addr=127.0.0.1;database=rodrigo");	m_cnc.open ();	
data source 

private testoledb () {	oledbcommand cmd;	m_cnc = new oledbconnection ("provider=postgresql;addr=127.0.0.1;database=rodrigo");	m_cnc.open ();	
database 

private testoledb () {	oledbcommand cmd;	m_cnc = new oledbconnection ("provider=postgresql;addr=127.0.0.1;database=rodrigo");	m_cnc.open ();	
connection string 

private testoledb () {	oledbcommand cmd;	m_cnc = new oledbconnection ("provider=postgresql;addr=127.0.0.1;database=rodrigo");	m_cnc.open ();	
provider 

private testoledb () {	oledbcommand cmd;	m_cnc = new oledbconnection ("provider=postgresql;addr=127.0.0.1;database=rodrigo");	m_cnc.open ();	
server version 

private testoledb () {	oledbcommand cmd;	m_cnc = new oledbconnection ("provider=postgresql;addr=127.0.0.1;database=rodrigo");	m_cnc.open ();	
creating temporary table 

static void main (string[] args) {	try {	testoledb test = new testoledb ();	test.testdatareader ();	test.testtransaction ();	test.close ();	} catch (exception e) {	
an error has occured 

========================= mono sample_28406 =========================

protected override void sendcompletedevent (iasyncresult result) {	
send peek completed 

========================= mono sample_24551 =========================

ptr++;	}	if (cptr [l] != 10){	return 1;	}	if (cptr [ul] != 10) return 2;	if (cptr [b] != 10) return 3;	byte* bptr = (byte*) 5;	ushort us = 3;	byte* ret = (byte*) (bptr + us);	
ok 

========================= mono sample_2756 =========================

public override string getsavedlicensekey(type type, assembly resourceassembly) {	if (savedlicensekeys == null || savedlicensekeys[type.assemblyqualifiedname]==null) {	
savedlicensekey is null or doesnt contain our type 

public override string getsavedlicensekey(type type, assembly resourceassembly) {	if (savedlicensekeys == null || savedlicensekeys[type.assemblyqualifiedname]==null) {	if (savedlicensekeys == null) {	savedlicensekeys = new hashtable();	}	uri licensefile = null;	if (resourceassembly == null) {	
resourceassembly is null 

public override string getsavedlicensekey(type type, assembly resourceassembly) {	if (savedlicensekeys == null || savedlicensekeys[type.assemblyqualifiedname]==null) {	if (savedlicensekeys == null) {	savedlicensekeys = new hashtable();	}	uri licensefile = null;	if (resourceassembly == null) {	string rawfile = (string)appdomain.currentdomain.setupinformation.licensefile;	
rawfile 

#else codebase = appdomain.currentdomain.setupinformation.applicationbase;	#endif if (rawfile != null && codebase != null) {	licensefile = new uri(new uri(codebase), rawfile);	}	}	if (licensefile == null) {	if(resourceassembly == null) {	resourceassembly = assembly.getentryassembly();	}	if (resourceassembly == null) {	
resourceassembly is null 

if (s == null) {	s = caseinsensitivemanifestresourcestreamlookup(asm, filename + ".licenses");	}	if (s != null) {	designtimelicensecontextserializer.deserialize(s, filename.toupper(cultureinfo.invariantculture), this);	break;	}	}	}	else if(!resourceassembly.isdynamic) {	
resourceassembly is not null 

if (resolvedname != null) {	s = resourceassembly.getmanifestresourcestream(resolvedname);	}	}	if (s != null) {	designtimelicensecontextserializer.deserialize(s, filename.toupper(cultureinfo.invariantculture), this);	}	}	}	if (licensefile != null) {	
licensefile 

if (resolvedname != null) {	s = resourceassembly.getmanifestresourcestream(resolvedname);	}	}	if (s != null) {	designtimelicensecontextserializer.deserialize(s, filename.toupper(cultureinfo.invariantculture), this);	}	}	}	if (licensefile != null) {	
opening licenses file over uri 

if (licensefile != null) {	stream s = openread(licensefile);	if (s != null) {	string[] segments = licensefile.segments;	string licfilename = segments[segments.length - 1];	string key = licfilename.substring(0, licfilename.lastindexof("."));	designtimelicensecontextserializer.deserialize(s, key.toupper(cultureinfo.invariantculture), this);	}	}	}	
returning 

========================= mono sample_12237 =========================

private static bool verifyclientcertificate (x509certificate certificate, int[] certificateerrors) {	if (certificate != null) {	console.writeline (certificate.tostring (true));	} else {	
no client certificate provided 

private static bool verifyclientcertificate (x509certificate certificate, int[] certificateerrors) {	if (certificate != null) {	console.writeline (certificate.tostring (true));	} else {	}	
error 

========================= mono sample_20587 =========================

t = typeof (ss);	if ((t.attributes & typeattributes.beforefieldinit) == 0) return 2;	t = typeof (sss);	if ((t.attributes & typeattributes.beforefieldinit) != 0) return 3;	t = typeof (c);	if ((t.attributes & typeattributes.beforefieldinit) == 0) return 4;	t = typeof (cc);	if ((t.attributes & typeattributes.beforefieldinit) == 0) return 5;	t = typeof (ccc);	if ((t.attributes & typeattributes.beforefieldinit) != 0) return 6;	
ok 

========================= mono sample_2804 =========================

public void getassemblyname_assemblyfile_badimage () {	string file = path.combine (tempdir, "badimage.dll");	using (streamwriter sw = file.createtext (file)) {	
somegarbage 

========================= mono sample_27027 =========================

protected override iasyncresult onbeginfind (findrequestcontext findrequestcontext, asynccallback callback, object state) {	
onbeginfind 

protected override iasyncresult onbeginresolve (resolvecriteria resolvecriteria, asynccallback callback, object state) {	
onbeginresolve 

protected override void onendfind (iasyncresult result) {	
onendfind 

protected override endpointdiscoverymetadata onendresolve (iasyncresult result) {	
onendresolve 

========================= mono sample_32578 =========================

public static int main () {	type type = typeof (staticclass);	if (!type.isabstract || !type.issealed) {	
is not abstract sealed 

public static int main () {	type type = typeof (staticclass);	if (!type.isabstract || !type.issealed) {	return 1;	}	if (type.getconstructors ().length > 0) {	
has constructor 

========================= mono sample_3709 =========================

norm.processfile(new streamreader (args[1]), console.out);	}	else if (directory.exists (args[1])) {	if (args.length != 3) {	printusage();	return 1;	}	norm.processdirectory (args[1], args[2]);	}	else {	
path not found 

static void printusage () {	
usage xmlnorm flags inputfile 

static void printusage () {	
or xmlnorm flags inputdir outputdir 

static void printusage () {	
flags 

========================= mono sample_22420 =========================

public void dostuff () {	
stuff 

========================= mono sample_3649 =========================

request.useragent = "mozilla/4.0 (compatible; msie 6.0; windows nt 5.1; sv1; .net clr 1.1.4322)";	request.accept = "image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-shockwave-flash, */*";	httpwebresponse response = (httpwebresponse)request.getresponse();	stream responsestream = response.getresponsestream();	streamreader sr = new streamreader(responsestream);	string s = sr.readtoend();	sr.close();	return s;	}	catch(exception e) {	
cannot retrieve document from url 

for (int styleindex=0; styleindex<style.length; styleindex++) {	style[styleindex] = fixstylenamevalue(style[styleindex]);	}	array.sort(style);	n.attributes["style"].value = string.join(";", style);	}	}	tempdoc.save(sw);	}	catch (exception) {	
error parsing html response 

for (int styleindex=0; styleindex<style.length; styleindex++) {	style[styleindex] = fixstylenamevalue(style[styleindex]);	}	array.sort(style);	n.attributes["style"].value = string.join(";", style);	}	}	tempdoc.save(sw);	}	catch (exception) {	
test case aborted 

========================= mono sample_19633 =========================

ityperesolutionservice resolver = (ityperesolutionservice)context.getservice(typeof(ityperesolutionservice));	if (resolver != null) {	modulepath = resolver.getpathofassembly(type.assembly.getname());	}	}	if (modulepath == null) {	modulepath = type.module.fullyqualifiedname;	}	string moduledir = path.getdirectoryname(modulepath);	string licensefile = moduledir + "\\" + type.fullname + ".lic";	
looking for license in 

========================= mono sample_12015 =========================

static ldapbackuprequest() {	try {	ldapextendedresponse.register( backuprestoreconstants.nldap_ldap_backup_response, type.gettype("novell.directory.ldap.extensions.ldapbackupresponse"));	}	catch (typeloadexception e) {	
could not register extended response class not found 

========================= mono sample_20970 =========================

}	}	try {	xmldocument doc = new xmldocument ();	doc.load ("test/rnctest.xml");	int success = 0;	int failure = 0;	foreach (xmlelement el in doc.selectnodes ("/rnctestcases/testcase")) {	string id = el.getattribute ("id");	if (filter != null && id.indexof (filter) < 0) continue;	
testing 

if (filter != null && id.indexof (filter) < 0) continue;	bool isvalid = el.getattribute ("legal") == "true";	rncparser p = new rncparser (new nametable ());	try {	string s = new streamreader ("test" + path.directoryseparatorchar + el.getattribute ("path")).readtoend ();	p.parse (new stringreader (s));	if (isvalid) {	success++;	} else {	failure++;	
incorrectly valid 

p.parse (new stringreader (s));	if (isvalid) {	success++;	} else {	failure++;	}	} catch (exception ex) {	if (isvalid) {	if (stoponerror) throw;	failure++;	
incorrectly invalid 

}	} catch (exception ex) {	if (isvalid) {	if (stoponerror) throw;	failure++;	} else {	success++;	}	}	}	
total success 

}	} catch (exception ex) {	if (isvalid) {	if (stoponerror) throw;	failure++;	} else {	success++;	}	}	}	
total failure 

} catch (exception ex) {	if (isvalid) {	if (stoponerror) throw;	failure++;	} else {	success++;	}	}	}	} catch (exception ex) {	
unexpected exception 

========================= mono sample_22776 =========================

public static void main () {	string s = "";	if (s.gettype ().isnullable ()) {	
aaa 

========================= mono sample_2762 =========================

v = header[identification[i].name];	}	else if (string.compare(identification[i].group, "capability", true, system.globalization.cultureinfo.currentculture) == 0) {	v = result[identification[i].name];	}	if (v == null) {	v = string.empty;	}	match m = identification[i].getmatch(v);	if (identification[i].ismatchsuccessful(m) == false) {	
failed 

v = result[identification[i].name];	}	if (v == null) {	v = string.empty;	}	match m = identification[i].getmatch(v);	if (identification[i].ismatchsuccessful(m) == false) {	#endif return false;	}	else {	
passed 

========================= mono sample_20540 =========================

string f = "co\"a";	if (s != d) return 1;	if (e != f) return 2;	string g = "hello\nworld";	using (streamreader sr = new streamreader("test-74.cs")) {	int i = sr.read ();	if (sr.read () <= 13) g = g.replace ("\n", "\r\n");	}	string h = @"hello world";	if (g != h) return 3;	
ok 

========================= mono sample_1729 =========================

public reflectpropertydescriptor(type componentclass, string name, type type, attribute[] attributes) : base(name, attributes) {	
creating reflectpropertydescriptor for 

public override object getvalue(object component) {	#if debug if (propdescusageswitch.traceverbose) {	string compname = "(null)";	if (component != null) compname = component.tostring();	
getvalue 

public override object getvalue(object component) {	#if debug if (propdescusageswitch.traceverbose) {	string compname = "(null)";	if (component != null) compname = component.tostring();	}	#endif if (isextender) {	
returning null 

if (t is targetinvocationexception) {	t = t.innerexception;	}	string message = t.message;	if (message == null) {	message = t.gettype().name;	}	throw new targetinvocationexception(sr.getstring(sr.errorpropertyaccessorexception, name, name, message), t);	}	}	
returning null 

public override void setvalue(object component, object value) {	#if debug if (propdescusageswitch.traceverbose) {	string compname = "(null)";	string valname  = "(null)";	if (component != null) compname = component.tostring();	if (value != null) valname = value.tostring();	
setvalue 

========================= mono sample_12021 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	
ok 

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_2400 =========================

public bool checkdigest() {	byte[] computeddigest = computedigest();	bool result = cryptohelper.isequal(computeddigest, getdigestvalue());	
checking digest for reference result 

public bool checkdigest() {	byte[] computeddigest = computedigest();	bool result = cryptohelper.isequal(computeddigest, getdigestvalue());	
computed digest 

public bool checkdigest() {	byte[] computeddigest = computedigest();	bool result = cryptohelper.isequal(computeddigest, getdigestvalue());	
received digest 

========================= mono sample_5260 =========================

public static int main () {	for (int i = 0; i < 100; ++i) {	astruct a;	a = new astruct (5);	if (a.foo != null) return 1;	a.foo = i + 1;	}	
ok 

========================= mono sample_1778 =========================

protected internal override void render (htmltextwriter writer) {	if (cssstyles == null || cssstyles.count == 0) return;	writer.addattribute (htmltextwriterattribute.type, "text/css");	writer.renderbegintag (htmltextwritertag.style);	
cdata 

========================= mono sample_19904 =========================

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(employees));	filestream fs=new filestream(filename, filemode.open);	employees emps;	emps=(employees)ser.deserialize(fs);	fs.close();	
collection name 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(employees));	filestream fs=new filestream(filename, filemode.open);	employees emps;	emps=(employees)ser.deserialize(fs);	fs.close();	foreach(employee emp in emps) {	
employee name 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(employees));	filestream fs=new filestream(filename, filemode.open);	employees emps;	emps=(employees)ser.deserialize(fs);	fs.close();	foreach(employee emp in emps) {	
employee id 

========================= mono sample_22554 =========================

}	return h;	the pairs (-1657792980, -1570288808) and (1862883298, -272461342) gives the same unsequenced hashcode with this hashfunction. the pair was found with code like hashdictionary<int, int[]> set = new hashdictionary<int, int[]>();	random rnd = new c5random(12345);	while (true) {	int[] a = new int[2];	a[0] = rnd.next(); a[1] = rnd.next();	int h = unsequencedhashcode(a);	int[] b = a;	if (set.findoradd(h, ref b)) {	
code pair number matched other pair 

public virtual bool check() {	bool retval = true;	if (size > array.length) {	
bad size array length 

public virtual bool check() {	bool retval = true;	if (size > array.length) {	return false;	}	for (int i = 0; i < size; i++) {	if ((object)(array[i]) == null) {	
bad element null at index 

========================= mono sample_30529 =========================

public static void main (string [] args) {	if (args.length == 0) {	
usage xsdump masterlistname 

========================= mono sample_22434 =========================

if (renderingcompatibility >= versionutil.framework40) {	writer.write("<div class=\"" + hiddenclassname + "\">");	}	else {	writer.write("<div>");	}	}	clientscript.renderhiddenfields(writer);	renderviewstatefields(writer);	if (renderdivaroundhiddeninputs) {	
div 

writer.writeline(";");	}	else {	writer.write("var theform = document.forms['");	writer.write(formuniqueid);	writer.writeline("'];");	writer.write("if (!theform) {\r\n    theform = document.");	writer.write(formuniqueid);	writer.writeline(";\r\n}");	}	
function dopostback eventtarget eventargument 

========================= mono sample_7085 =========================

public static int main () {	string foo = "bar";	int baz = 42;	var v = new { foo, baz };	if (v.foo != "bar") return 1;	if (v.baz != 42) return 2;	if (!testa ("foo").equals (new { s = "foo" })) return 3;	
ok 

========================= mono sample_2560 =========================

console.outputencoding = encoding.getencoding("iso-8859-1");	scg.ienumerable<string> ss;	if (args.length == 2) ss = readfilewords(args[0], int.parse(args[1]));	else ss = args;	timer t = new timer();	scg.ienumerable<scg.ienumerable<string>> classes = anagramclasses(ss);	int count = 0;	foreach (scg.ienumerable<string> anagramclass in classes) {	count++;	}	
non trivial anagram classes 

========================= mono sample_30578 =========================

public void performancecountercategory_createcategory () {	
performancecountercategory createcategory 

countercreationdata averagecount64 = new countercreationdata ();	averagecount64.countertype = performancecountertype.averagecount64;	averagecount64.countername = name;	counterdatacollection.add (averagecount64);	countercreationdata averagecount64base = new countercreationdata ();	averagecount64base.countertype = performancecountertype.averagebase;	averagecount64base.countername = name + "base";	counterdatacollection.add (averagecount64base);	performancecountercategory.create (name + "category", "demonstrates usage of the averagecounter64 performance counter type.", performancecountercategorytype.singleinstance, counterdatacollection);	assert.true (performancecountercategory.exists (name + "category"));	
performancecountercategory createcategory end 

public void performancecounter_createcounter_count0 () {	
performancecounter createcounter start 

public void performancecounter_createcounter_count0 () {	assert.areequal (0, a.countersample.rawvalue);	a.countersample.increment ();	assert.areequal (1, a.countersample.rawvalue);	
performancecounter createcounter end 

public void performancecounter_instancenames () {	
performancecounter instancenames start 

public void performancecounter_instancenames () {	var names = a.pcc.getinstancenames ();	
performancecounter instancenames a name a pcc names names length 

public void performancecounter_instancenames () {	var names = a.pcc.getinstancenames ();	assert.that (new [] { a.basename, a.name }, is.equivalentto (names));	
performancecounter instancenames end 

public void performancecounter_counters () {	
performancecounter counters start 

new string [ ] { counters[0].categoryname, counters[0].countername, counters[0].instancename, counters[0].rawvalue.tostring () }, new string [ ] { counters[1].categoryname, counters[1].countername, counters[1].instancename, counters[1].rawvalue.tostring () }	}, is.equivalentto (new [ ] {	new string [ ] { a.category, a.basename, a.name, "0" }, new string [ ] { a.category, a.name,     a.name, "0" }	}));	int i = 0;	foreach (var b in counters) {	var category = b.categoryname;	var name = b.countername;	var instance = b.instancename;	var value = b.rawvalue;	
i i category category counter name instance instance value value 

var category = b.categoryname;	var name = b.countername;	var instance = b.instancename;	var value = b.rawvalue;	++i;	assert.true (name == a.name || name == a.basename);	assert.areequal (a.name, instance);	assert.areequal (a.category, category);	assert.areequal (0, value);	}	
performancecounter counters end 

========================= mono sample_23709 =========================

try {	registered = metamodel.getmodel (model.contexttype);	} catch (exception) {	}	try {	if (registered == null) m.registercontext (model, config);	} catch (invalidoperationexception ex) {	exception = ex;	}	if (exception != null) {	
registercontext exception 

}	try {	if (registered == null) {	if (config != null) m.registercontext (contexttype, config);	else m.registercontext (contexttype);	}	} catch (invalidoperationexception ex) {	exception = ex;	}	if (exception != null) {	
registercontext exception 

========================= mono sample_17764 =========================

public static void bar (this foo self) {	
bar 

========================= mono sample_1498 =========================

public static void rev<t> (list <t> y) {	
cons 

public static void rev<t> (list <t> y) {	
nil 

========================= mono sample_1709 =========================

datetime tim = datetime.now;	xmlmapping[] maps = batch.maps;	if (cp == null) {	cp = new compilerparameters();	cp.includedebuginformation = false;	cp.generateinmemory = true;	cp.tempfiles.keepfiles = !deletetempfiles;	}	string file = cp.tempfiles.addextension ("cs");	streamwriter sw = new streamwriter (file);	
generating 

cp.generateinmemory = true;	cp.tempfiles.keepfiles = !deletetempfiles;	}	string file = cp.tempfiles.addextension ("cs");	streamwriter sw = new streamwriter (file);	serializationcodegenerator gen = new serializationcodegenerator (maps);	try {	gen.generateserializers (sw);	}	catch (exception ex) {	
serializer could not be generated 

foreach (type rtype in gen.referencedtypes) {	string path = new uri (rtype.assembly.codebase).localpath;	if (!cp.referencedassemblies.contains (path)) cp.referencedassemblies.add (path);	}	if (!cp.referencedassemblies.contains ("system.dll")) cp.referencedassemblies.add ("system.dll");	if (!cp.referencedassemblies.contains ("system.xml")) cp.referencedassemblies.add ("system.xml");	if (!cp.referencedassemblies.contains ("system.data")) cp.referencedassemblies.add ("system.data");	if (!cp.referencedassemblies.contains ("system.web.services")) cp.referencedassemblies.add ("system.web.services");	compilerresults res = comp.compileassemblyfromfile (cp, file);	if (res.errors.haserrors || res.compiledassembly == null) {	
error while compiling generated serializer 

serializerdata sd = batch.datas [n];	lock (sd) {	sd.writertype = res.compiledassembly.gettype (gres.namespace + "." + gres.writerclassname);	sd.readertype = res.compiledassembly.gettype (gres.namespace + "." + gres.readerclassname);	sd.writermethod = sd.writertype.getmethod (gres.writemethodname);	sd.readermethod = sd.readertype.getmethod (gres.readmethodname);	sd.batch = null;	}	}	cp.tempfiles.delete ();	
generation finished ms 

========================= mono sample_22496 =========================

}	return defaultcertificatevalidationhandler(certificate, certificateerrors);	}	public bool defaultcertificatevalidationhandler( syscert.x509certificate certificate, int[]                   certificateerrors) {	bool retflag=false;	if (certificateerrors != null && certificateerrors.length > 0) {	if( certificateerrors.length==1 && certificateerrors[0] == -2146762481) {	retflag = true;	}	else {	
detected errors in the server certificate 

sslclientstream sslstream = new sslclientstream( nstream, host, false, mono.security.protocol.tls.securityprotocoltype.ssl3|mono.security.protocol.tls.securityprotocoltype.tls);	sslstream.servercertvalidationdelegate += new certificatevalidationcallback(servercertificatevalidation);*/ in_renamed = (system.io.stream) sslstream;	out_renamed = (system.io.stream) sslstream;*/ }	else{	socket = new system.net.sockets.tcpclient(host, port);	in_renamed = (system.io.stream) socket.getstream();	out_renamed = (system.io.stream) socket.getstream();	}	}	else {	
connect input out stream specified 

========================= mono sample_20901 =========================

static int test (int v) {	
value 

static int test (int v) {	switch (v){	case 1: case 2: return 1;	case 3: return 3;	case 4: return 5;	
default 

static bool bug_78860() {	string model = "tsp100";	
switch on 

public static int main () {	byte b;	for (b = 0; b < 255; b++){	if (s (b) != 255 - b){	
failed with 

public static int main () {	byte b;	for (b = 0; b < 255; b++){	if (s (b) != 255 - b){	return 1;	}	}	
batch 

if (tests2 ("a") != 3) return 71;	if (tests2 ("one") != 3) return 72;	if (tests2 ("two") != 3) return 73;	if (longstringswitch ("system.management") != 2) return 80;	if (longstringswitch (null) != 10) return 81;	if (longstringswitch (".") != 10) return 82;	if (!switchsinglesection ("file")) return 90;	if (switchsinglesection (null)) return 91;	if (switchsinglesection ("-=-")) return 92;	test_1597 ();	
all tests pass 

========================= mono sample_2841 =========================

public static int main () {	x x = new x();	x.m ();	e ();	console.writeline ("j should be 101= {0}", j);	if (j != 101) return 3;	
ok 

========================= mono sample_2653 =========================

static getreplicainforequest() {	try {	ldapextendedresponse.register(replicationconstants.get_replica_info_res, system.type.gettype("novell.directory.ldap.extensions.getreplicainforesponse"));	}	catch (system.exception e) {	
could not register extended response class not found 

========================= mono sample_20950 =========================

i = b.foo (i2: 3);	if (i != 4) return 2;	i = b["a"];	if (i != 10) return 3;	i = b["a", arg2: 20];	if (i != 21) return 4;	i = b.foo2 ();	if (i != 99) return 5;	i = b.foo2 (i : 8);	if (i != 77) return 6;	
ok 

========================= mono sample_4058 =========================

public static void d(int y) {	
hello 

========================= mono sample_2445 =========================

input = compile (input, out compiled);	if (input != null) return input;	if (compiled == null) return null;	object retval = typeof (quitvalue);	try {	invoke_thread = system.threading.thread.currentthread;	invoking = true;	compiled (ref retval);	#if mono_feature_thread_abort } catch (threadabortexception e){	thread.resetabort ();	
interrupted 

if (input != null) return input;	if (compiled == null) return null;	object retval = typeof (quitvalue);	try {	invoke_thread = system.threading.thread.currentthread;	invoking = true;	compiled (ref retval);	#if mono_feature_thread_abort } catch (threadabortexception e){	thread.resetabort ();	#else } catch (threadinterruptedexception e) {	
interrupted 

output.write (evaluator.getusing ());	output.flush ();	}	static public timespan time (action a) {	datetime start = datetime.now;	a ();	return datetime.now - start;	}	static public void loadpackage (string pkg) {	if (pkg == null){	
invalid package specified 

public void addtypecontainer (typecontainer current_container, typedefinition tc) {	if (current_container == tc){	
internal error inserting container into itself 

========================= mono sample_36380 =========================

static void main () {	try {	
test 

========================= mono sample_33556 =========================

public delegate void func<[doc] targ, [doc ("ret!")] tret> ();	class test {	public static int main () {	type[] targs = typeof (func<,>).getgenericarguments ();	if (targs[0].getcustomattributes (false).length != 1) return 1;	if (targs[1].getcustomattributes (false).length != 1) return 2;	
ok 

========================= mono sample_2667 =========================

private void error (string message) {	console.writeline (message + "\n");	
failure 

private void processfile (string file_path) {	if (!file.exists (file_path)) {	
file does not exist 

public void showtoken (object sender, newtokeneventargs args) {	
token 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
method defined 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
signature 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
name 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
return type 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
is in table 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
method atts 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
impl atts 

public void showmethoddef (object sender, methoddefinedeventargs args) {	
call conv 

public void showmethodref (object sender, methodreferencedeventargs args) {	
method referenced 

public void showmethodref (object sender, methodreferencedeventargs args) {	
signature 

public void showmethodref (object sender, methodreferencedeventargs args) {	
name 

public void showmethodref (object sender, methodreferencedeventargs args) {	
return type 

public void showmethodref (object sender, methodreferencedeventargs args) {	
is in table 

private void usage () {	
mono il assembler compiler ilasm options source files about about the mono il assembler compiler version print the version number of the compiler output file name specifies output file exe compile to executable dll compile to library debug include debug information key keyfile strongname using the specified key file key container strongname using the specified key container noautoinherit disable inheriting from system object by default options can be of the form option or option 

private void about () {	
for more information on mono visit the project web site http environment exit 

private void version () {	string version = system.reflection.assembly.getexecutingassembly ().getname ().version.tostring ();	
mono il assembler compiler version 

========================= mono sample_36262 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
ismachinelevel 

========================= mono sample_29849 =========================

public override void added (xelement target, bool wasparentadded) {	string name = target.attribute ("name").value;	var namespacedescription  = $"{name}: added namespace";	state.logdebugmessage ($"possible -n value: {namespacedescription}");	if (state.ignorenew.any (re => re.ismatch (namespacedescription))) return;	
start namespace div 

public override void added (xelement target, bool wasparentadded) {	string name = target.attribute ("name").value;	var namespacedescription  = $"{name}: added namespace";	state.logdebugmessage ($"possible -n value: {namespacedescription}");	if (state.ignorenew.any (re => re.ismatch (namespacedescription))) return;	
new namespace 

public override void added (xelement target, bool wasparentadded) {	string name = target.attribute ("name").value;	var namespacedescription  = $"{name}: added namespace";	state.logdebugmessage ($"possible -n value: {namespacedescription}");	if (state.ignorenew.any (re => re.ismatch (namespacedescription))) return;	output.writeline ();	foreach (var addedtype in target.element ("classes").elements ("class")) comparer.added (addedtype, true);	
div end namespace 

public override void modified (xelement source, xelement target, apichanges differences) {	var output = output;	state.output = new stringwriter ();	comparer.compare (source, target);	var s = output.tostring ();	state.output = output;	if (s.length > 0) {	var name = target.attribute ("name").value;	
start namespace div 

public override void modified (xelement source, xelement target, apichanges differences) {	var output = output;	state.output = new stringwriter ();	comparer.compare (source, target);	var s = output.tostring ();	state.output = output;	if (s.length > 0) {	var name = target.attribute ("name").value;	
namespace 

public override void modified (xelement source, xelement target, apichanges differences) {	var output = output;	state.output = new stringwriter ();	comparer.compare (source, target);	var s = output.tostring ();	state.output = output;	if (s.length > 0) {	var name = target.attribute ("name").value;	output.writeline (s);	
div end namespace 

public override void removed (xelement source) {	var name = source.attribute ("name").value;	var namespacedescription  = $"{name}: removed namespace";	state.logdebugmessage ($"possible -r value: {namespacedescription}");	if (state.ignoreremoved.any (re => re.ismatch (namespacedescription))) return;	
start namespace div 

public override void removed (xelement source) {	var name = source.attribute ("name").value;	var namespacedescription  = $"{name}: removed namespace";	state.logdebugmessage ($"possible -r value: {namespacedescription}");	if (state.ignoreremoved.any (re => re.ismatch (namespacedescription))) return;	
removed namespace 

public override void removed (xelement source) {	var name = source.attribute ("name").value;	var namespacedescription  = $"{name}: removed namespace";	state.logdebugmessage ($"possible -r value: {namespacedescription}");	if (state.ignoreremoved.any (re => re.ismatch (namespacedescription))) return;	output.writeline ();	foreach (var removedtype in source.element ("classes").elements ("class")) comparer.removed (removedtype);	
div end namespace 

========================= mono sample_1311 =========================

public void test(t param) {	
more 

public void test<t2>() {	
less 

========================= mono sample_762 =========================

static void main(string[] args) {	try {	system.configuration.configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	configurationsection connstrings = config.connectionstrings;	console.writeline ("connstrings[localsqlserver] = {0}", ((connectionstringssection)connstrings).connectionstrings["localsqlserver"]);	connstrings.sectioninformation.unprotectsection ();	connstrings.sectioninformation.forcesave = true;	config.saveas ("t27.exe.config", configurationsavemode.full);	if (connstrings.sectioninformation.isprotected == true) console.writeline ("section {0} is now protected by {1}", connstrings.sectioninformation.name, connstrings.sectioninformation.protectionprovider.name);	
section is not protected 

try {	system.configuration.configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	configurationsection connstrings = config.connectionstrings;	console.writeline ("connstrings[localsqlserver] = {0}", ((connectionstringssection)connstrings).connectionstrings["localsqlserver"]);	connstrings.sectioninformation.unprotectsection ();	connstrings.sectioninformation.forcesave = true;	config.saveas ("t27.exe.config", configurationsavemode.full);	if (connstrings.sectioninformation.isprotected == true) console.writeline ("section {0} is now protected by {1}", connstrings.sectioninformation.name, connstrings.sectioninformation.protectionprovider.name);	}	catch (exception e) {	
raised 

========================= mono sample_29818 =========================

private static bool testtrycatch(int recurselevel) {	if (recurselevel > 1) {	try {	if (s_globalflag = !s_globalflag) {	return testtrycatch(recurselevel - 2);	}	else {	int[] p = null;	p[0] = 0;	
shouldn t have reached here 

try {	bool runhandler = false;	try {	if (s_globalflag = !s_globalflag) {	return test(recurselevel - 2);	}	else {	runhandler = true;	int[] p = null;	p[0] = 0;	
shouldn t have reached here 

private static int main() {	try {	if (testtrycatch(15) || !testtrycatch(18)) {	
try catch test failed 

private static int main() {	try {	if (testtrycatch(15) || !testtrycatch(18)) {	return 1;	}	if (testtryfinally(19) || !testtryfinally(12)) {	
try finally test failed 

private static int main() {	try {	if (testtrycatch(15) || !testtrycatch(18)) {	return 1;	}	if (testtryfinally(19) || !testtryfinally(12)) {	return 2;	}	}	catch (exception) {	
failed w exception 

if (testtrycatch(15) || !testtrycatch(18)) {	return 1;	}	if (testtryfinally(19) || !testtryfinally(12)) {	return 2;	}	}	catch (exception) {	return -1;	}	
passed 

========================= mono sample_733 =========================

public static void main (string[] args) {	foreach (object at in args) {	
tipo attributo 

========================= mono sample_35476 =========================

var bridge = new bridge ();	list.add (bridge);	}	var r = new random (100);	for (int i = 0; i < obj_count; ++i) {	var n = list [i];	for (int j = 0; j < link_count; ++j) n.links.add (list [r.next (obj_count)]);	for (int j = 0; j < extras_count; ++j) n.links.add (j);	if (r.nextdouble () <= survival_rate) n.__test = 1;	}	
setup done 

var tail = new nonbridge ();	head.links.add (tail);	for (int i = 0; i < list_length; ++i) {	var obj = new nonbridge ();	tail.link = obj;	tail = obj;	}	var list = new list<bridge> ();	tail.link = list;	for (int i = 0; i < fan_out; ++i) list.add (new bridge ());	
linked fan done 

var obj = new nonbridge ();	obj.link = list;	list = obj;	}	var heads = new bridge [fan_out];	for (int i = 0; i < fan_out; ++i) {	var obj = new bridge ();	obj.links.add (list);	heads [i] = obj;	}	
inverse fan done 

heads [i].links.add (multiplexer);	multiplexer [i] = new bridge ();	}	} else {	for (int i = 0; i < fan_out; ++i) {	heads [i].links.add (multiplexer);	multiplexer [i] = multiplexer0 [i];	}	}	}	
double fan done 

static void runtest (threadstart setup) {	var t = new thread (setup);	t.start ();	t.join ();	for (int i = 0; i < 5; ++i) {	
gc 

static void runtest (threadstart setup) {	var t = new thread (setup);	t.start ();	t.join ();	for (int i = 0; i < 5; ++i) {	gc.collect ();	gc.waitforpendingfinalizers ();	}	
gcs done 

runtest (setuplinks);	runtest (setuplinkedfan);	runtest (setupinversefan);	runtest (setupdoublefan);	runtest (setupdeadlist);	runtest (setupselflinks);	runtest (spider);	for (int i = 0; i < 0; ++i) {	gc.collect ();	gc.waitforpendingfinalizers ();	
cleanup gc 

========================= mono sample_680 =========================

public static int main() {	try {	
in try 

public static int main() {	try {	throw new exception();	}	catch (exception e) {	
in catch 

public static int main() {	try {	throw new exception();	}	catch (exception e) {	return(0);	}	finally {	
in finally 

========================= mono sample_451 =========================

public static int main () {	var t = new tester ().lambda_1 ();	if (!task.waitall (new [] { t }, 1000)) return 1;	if (t.result != 0) return 2;	t = new tester ().lambda_2 ();	if (!task.waitall (new [] { t }, 1000)) return 3;	if (t.result != 0) return 4;	t = new tester ().lambda_3<ulong>();	if (!task.waitall (new [] { t }, 1000)) return 5;	if (t.result != 0) return 6;	
ok 

========================= mono sample_3127 =========================

static public void reporterror (int errornum, string msg) {	
msbuild error msbuild 

static public void reportwarning (int errornum, string msg) {	
msbuild warning msbuild 

static public void showusage () {	display (version);	
xbuild options project file 

========================= mono sample_1133 =========================

public static int main() {	stringbuilder b = new stringbuilder ();	b.append ('b');	b.append ('r');*/ b.append ("abr");	if (b.tostring() != "abr") {	
got 

public static int main() {	stringbuilder b = new stringbuilder ();	b.append ('b');	b.append ('r');*/ b.append ("abr");	if (b.tostring() != "abr") {	return 1;	}	b.append ('a');	b.append ("cadabra");	if (b.tostring() != "abracadabra") {	
got 

========================= mono sample_540 =========================

public static void mythreadstart() {	try {	
started 

========================= mono sample_400 =========================

public void mytest() {	
test 

========================= mono sample_34908 =========================

static void main (string[] args) {	if (args.length == 0 || args[0] == "--help") {	
mono xml serializer generator tool 

static void main (string[] args) {	if (args.length == 0 || args[0] == "--help") {	
usage genxs configfilename destinationpath 

console.writeline ();	return;	}	try {	type t = type.gettype ("system.xml.serialization.serializationcodegenerator, system.xml");	if (t == null) throw new exception ("this runtime does not support generation of serializers");	methodinfo met = t.getmethod ("generate", bindingflags.static | bindingflags.public | bindingflags.nonpublic);	met.invoke (null, new object[] {args[0], (args.length > 1) ? args[1] : null} );	}	catch (exception ex) {	
an error occurred while generating serializers 

========================= mono sample_804 =========================

private static int main(string[] args) {	for (int i = 0; i < num_iterations; i++) {	
next iter 

thread writer = new thread (uselockforwrite);	reader.start (barrier);	writer.start (barrier);	barrier.signalandwait ();	writer.abort();	reader.abort();	reader.join();	writer.join();	}	if (abort_count != (num_iterations * 2)) {	
only aborts 

========================= mono sample_707 =========================

static void main(string[] args) {	if (args.length >= 1) {	writestuffmode(args[0]);	return;	}	runstuffmode();	
success 

private static void writestuffmode(string counter) {	
run 

using (var p = newprocess(exe, exeargs)) {	p.outputdatareceived += (sender, args) => {	if (args.data != null) console.writeline(args.data);	};	p.errordatareceived += (sender, args) => {	if (args.data != null) console.error.writeline(args.data);	};	p.start();	p.beginoutputreadline();	p.beginerrorreadline();	
hello 

========================= mono sample_496 =========================

public bool test () {	
start value 

public bool test () {	if (t.var != 0) return true;	t.var = 100;	
end value 

static int main () {	bool failed = false;	var = 10;	cbo cbo = new cbo();	failed = cbo.test ();	if (var != 10) failed = true;	
value in main context 

========================= mono sample_647 =========================

}	if (generatortype == null) error (generatortypenotfound, typename);	}	if (generatortype != null) {	if (!generatortype.issubclassof (typeof (codedomprovider))) error (generatortypeisnotcodegenerator, typename);	try {	provider = (codedomprovider) activator.createinstance (generatortype, null);	} catch (exception ex) {	error (generatorthrewexception, generatortype.assemblyqualifiedname.tostring () + " --> " + ex.message);	}	
loaded custom generator type 

schemanames.addrange (unknownfiles);	if (generateclasses) generateclasses ();	else if (generatedataset) generatedataset ();	}	else if (inference) {	foreach (string xmlfile in inferencenames) {	string genfile = path.combine (outputdir, path.getfilenamewithoutextension (xmlfile) + ".xsd");	dataset ds = new dataset ();	ds.inferxmlschema (xmlfile, null);	ds.writexmlschema (genfile);	
written file 

if (tm != null) maps.add (tm);	}	foreach (xmltypemapping tm in maps) {	sx.exporttypemapping (tm);	}	icodegenerator gen = provider.creategenerator();	string genfile = path.combine (outputdir, targetfile);	streamwriter sw = new streamwriter(genfile, false);	gen.generatecodefromcompileunit (cunit, sw, new codegeneratoroptions());	sw.close();	
written file 

codecompileunit cunit = new codecompileunit ();	codenamespace codenamespace = new codenamespace (namesp);	cunit.namespaces.add (codenamespace);	codenamespace.comments.add (new codecommentstatement ("\nthis source code was auto-generated by monoxsd\n"));	icodegenerator gen = provider.creategenerator ();	typeddatasetgenerator.generate (dataset, codenamespace, gen);	string genfile = path.combine (outputdir, targetfile);	streamwriter sw = new streamwriter(genfile, false);	gen.generatecodefromcompileunit (cunit, sw, new codegeneratoroptions());	sw.close();	
written file 

========================= mono sample_1325 =========================

static void test(pgsqlconnection con, string sql, commandtype cmdtype, commandbehavior behavior, string testdesc) {	pgsqlcommand cmd = null;	pgsqldatareader rdr = null;	int c;	int results = 0;	
test 

static void test(pgsqlconnection con, string sql, commandtype cmdtype, commandbehavior behavior, string testdesc) {	pgsqlcommand cmd = null;	pgsqldatareader rdr = null;	int c;	int results = 0;	
begin sql 

static void test(pgsqlconnection con, string sql, commandtype cmdtype, commandbehavior behavior, string testdesc) {	pgsqlcommand cmd = null;	pgsqldatareader rdr = null;	int c;	int results = 0;	console.writeline(sql);	
end sql 

static void test(pgsqlconnection con, string sql, commandtype cmdtype, commandbehavior behavior, string testdesc) {	pgsqlcommand cmd = null;	pgsqldatareader rdr = null;	int c;	int results = 0;	console.writeline(sql);	cmd = new pgsqlcommand(sql, con);	cmd.commandtype = cmdtype;	
executereader 

static void test(pgsqlconnection con, string sql, commandtype cmdtype, commandbehavior behavior, string testdesc) {	pgsqlcommand cmd = null;	pgsqldatareader rdr = null;	int c;	int results = 0;	console.writeline(sql);	cmd = new pgsqlcommand(sql, con);	cmd.commandtype = cmdtype;	rdr = cmd.executereader(behavior);	if(rdr == null) {	
idatareader has a null reference 

console.writeline(sql);	cmd = new pgsqlcommand(sql, con);	cmd.commandtype = cmdtype;	rdr = cmd.executereader(behavior);	if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	
result is from a sql command insert update delete records affected 

rdr = cmd.executereader(behavior);	if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if (dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	
result is from a sql select query records affected 

if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if (dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	
result set 

if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if (dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	
total columns 

}	else if (dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	console.writeline();	}	int nrows = 0;	string output, metadatavalue, datavalue;	
gonna do a read now 

else if (dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	console.writeline();	}	int nrows = 0;	string output, metadatavalue, datavalue;	while(rdr.read()) {	
row 

for(c = 0; c < rdr.fieldcount; c++) {	datarow dr = dt.rows[c];	metadatavalue = "    col " + c + ": " + dr["columnname"];	if(rdr.isdbnull(c) == true) datavalue = " is null";	else datavalue = ": " + rdr.getvalue(c);	output = metadatavalue + datavalue;	console.writeline(output);	}	nrows++;	}	
total rows 

metadatavalue = "    col " + c + ": " + dr["columnname"];	if(rdr.isdbnull(c) == true) datavalue = " is null";	else datavalue = ": " + rdr.getvalue(c);	output = metadatavalue + datavalue;	console.writeline(output);	}	nrows++;	}	}	} while(rdr.nextresult());	
total result sets 

========================= mono sample_28412 =========================

public static extern int test_method_thunk (int test_id, intptr testmethodhandle, intptr createobjecthandle);	static void runtests(int series, type type) {	const string prefix = "test";	methodinfo createobjectmethod = type.getmethod ("createobject");	foreach (methodinfo mi in type.getmethods ()) {	string name = mi.name;	if (!name.startswith (prefix)) continue;	int id = convert.toint32 (name.substring (prefix.length));	int res = test_method_thunk (series + id, mi.methodhandle.value, createobjectmethod.methodhandle.value);	if (res != 0) {	
returned 

========================= mono sample_616 =========================

static async task<int> testfinallywithreturn (int value) {	fin = false;	try {	if (value > 4) return 5;	value += 10;	
try 

static async task<int> testfinallywithreturn (int value) {	fin = false;	try {	if (value > 4) return 5;	value += 10;	} finally {	fin = true;	
finally 

static async task<int> testfinallywithreturn (int value) {	fin = false;	try {	if (value > 4) return 5;	value += 10;	} finally {	fin = true;	value += await yieldvalue (100);	}	value += 1000;	
over 

static async task testfinallywithreturnnovalue (int value) {	fin = false;	try {	if (value > 4) return;	value += 10;	
try 

static async task testfinallywithreturnnovalue (int value) {	fin = false;	try {	if (value > 4) return;	value += 10;	} finally {	fin = true;	
finally 

static async task testfinallywithreturnnovalue (int value) {	fin = false;	try {	if (value > 4) return;	value += 10;	} finally {	fin = true;	value += await yieldvalue (100);	}	value += 1000;	
over 

static async task<int> testfinallywithgoto (int value) {	fin = false;	try {	if (value > 4) goto l;	value += 10;	
try 

static async task<int> testfinallywithgoto (int value) {	fin = false;	try {	if (value > 4) goto l;	value += 10;	} finally {	fin = true;	
finally 

static async task<int> testfinallywithgoto (int value) {	fin = false;	try {	if (value > 4) goto l;	value += 10;	} finally {	fin = true;	value += await yieldvalue (100);	}	value += 1000;	
over 

static async task<int> testfinallywithgotoandreturn (int value) {	fin = false;	try {	if (value > 4) goto l;	value += 10;	
try 

static async task<int> testfinallywithgotoandreturn (int value) {	fin = false;	try {	if (value > 4) goto l;	value += 10;	if (value > 12) return 9;	} finally {	fin = true;	
finally 

fin = false;	try {	if (value > 4) goto l;	value += 10;	if (value > 12) return 9;	} finally {	fin = true;	value += await yieldvalue (100);	}	value += 1000;	
over 

if (testfinallywithgoto (9).result != 109) return 7;	if (!fin) return 8;	if (testfinallywithgoto (1).result != 1111) return 9;	if (!fin) return 10;	if (testfinallywithgotoandreturn (9).result != 109) return 11;	if (!fin) return 12;	if (testfinallywithgotoandreturn (1).result != 1111) return 13;	if (!fin) return 14;	if (testfinallywithgotoandreturn (3).result != 9) return 15;	if (!fin) return 16;	
ok 

========================= mono sample_3360 =========================

private void cancel() {	safehandle handle = this._handle;	nativeoverlapped* overlapped = this._overlapped;	if (handle != null && !handle.isinvalid && overlapped != null) {	if (!unsafenativemethods.cancelioex(handle, overlapped)) {	int errorcode = marshal.getlastwin32error();	
cancelioex finished with error code 

========================= mono sample_6627 =========================

static void dumpstuff () {	
cwl under oom should not print 

static void dumpstuff () {	
cwl under oom should not print 

static int main () {	
start 

static int main () {	assembly corlib = typeof (object).assembly;	module module = corlib.getmodules ()[0];	var r = new random (123456);	var l = new list<object> ();	try {	for (int i = 0; i < 400000; ++i) {	var foo = new byte[r.next () % 4000];	l.add (foo);	}	
done 

try {	module.gettypes ();	return 3;	} catch (exception) {}	try {	corlib.gettypes ();	return 4;	} catch (exception) {}	l.clear ();	l = null;	
oom done 

========================= mono sample_434 =========================

public void x () {	this ["abc"] = delegate () {	++counter;	
a 

public static int main () {	c o = new c ();	o.x ();	
b 

public static int main () {	c o = new c ();	o.x ();	
abc 

========================= mono sample_3393 =========================

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
address 

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
connectionlimit 

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
connectionname 

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
currentconnections 

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
idlesince 

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
maxidletime 

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
protocolversion 

private void writeservicepoint (string label, servicepoint sp) {	console.writeline ("\n" + label);	
supportspipelining 

========================= mono sample_23296 =========================

static int async_func (int a) {	
async func from delegate 

static int async_func_throws (int a) {	
async func throws from delegate 

static void async_callback (iasyncresult ar) {	
async callback 

static int main () {	simpledelegate d = new simpledelegate (async_func_throws);	asynccallback ac = new asynccallback (async_callback);	string state1 = "state1";	iasyncresult ar1 = d.begininvoke (1, ac, state1);	while (cb_state == 0) thread.sleep (0);	try {	d.endinvoke (ar1);	
no exception 

static int main () {	simpledelegate d = new simpledelegate (async_func_throws);	asynccallback ac = new asynccallback (async_callback);	string state1 = "state1";	iasyncresult ar1 = d.begininvoke (1, ac, state1);	while (cb_state == 0) thread.sleep (0);	try {	d.endinvoke (ar1);	return 1;	} catch (asyncexception) {	
received exception ok 

asynccallback ac = new asynccallback (async_callback);	string state1 = "state1";	iasyncresult ar1 = d.begininvoke (1, ac, state1);	while (cb_state == 0) thread.sleep (0);	try {	d.endinvoke (ar1);	return 1;	} catch (asyncexception) {	return 0;	} catch (exception e) {	
wrong exception 

========================= mono sample_574 =========================

public static int main () {	if (a.f != 3) return 1;	if (b.f != 4) return 2;	
ok 

========================= mono sample_1387 =========================

public static int main () {	if (test_1 (5) != 0) return 1;	if (test_2 (6) != 0) return 2;	if (test_3 ("") != 0) return 3;	if (test_4 (null) != 0) return 4;	if (test_5 () != 0) return 5;	if (test_6 () != 1) return 6;	if (test_7 (false) != 1) return 7;	if (test_8 (typeof (bool)) != 0) return 8;	
ok 

========================= mono sample_3282 =========================

public void nullablefieldsshouldsupportnullvalue () {	string json = @"{""should_have_value"":null}";	var inputstream = new memorystream (encoding.utf8.getbytes (json));	datacontractjsonserializer serializer = new datacontractjsonserializer(typeof(datetest));	
serializer assembly 

========================= mono sample_21103 =========================

var l = xelement.load (new streamreader (nuspec.open ()));	var version = (from el in l.descendants() where el.name.localname == "version" select el.value).firstordefault ();	var prefixestocheckinorder = new string[] {	"lib/net4", "lib/netstandard1", "msbuildextensions/microsoft/microsoft.net.build.extensions/net4" };	ienumerable<ziparchiveentry> entries = null;	foreach (var prefix in prefixestocheckinorder) {	entries = zip.entries.where (e => e.fullname.startswith (prefix) && e.name.endswith (".dll") && badassembliestoenumtable.containskey (e.name));	if (entries.any ()) break;	}	if (!entries.any ()) {	
warning no relevant assemblies found for nukpkg nupkg 

public void parseassembly (byte[] data, string version, string name, string fullname, bool dump_asm, bool dump_ver, bool dump_guids_for_msbuild) {	var a = assembly.reflectiononlyload (data);	var m = a.getmodules ()[0];	var id = m.moduleversionid.tostring ().toupper ();	var hash_code = hash (id).tostring ("x");	var str = filetoenum (name);	string ver_str = version + " " + filetomoniker (fullname);	
ignored assembly hash code str 

public void parseassembly (byte[] data, string version, string name, string fullname, bool dump_asm, bool dump_ver, bool dump_guids_for_msbuild) {	var a = assembly.reflectiononlyload (data);	var m = a.getmodules ()[0];	var id = m.moduleversionid.tostring ().toupper ();	var hash_code = hash (id).tostring ("x");	var str = filetoenum (name);	string ver_str = version + " " + filetomoniker (fullname);	var ver = a.getname ().version;	if (dump_ver) {	
ignored asm ver str ver major ver minor ver build ver revision 

public void parseassembly (byte[] data, string version, string name, string fullname, bool dump_asm, bool dump_ver, bool dump_guids_for_msbuild) {	var a = assembly.reflectiononlyload (data);	var m = a.getmodules ()[0];	var id = m.moduleversionid.tostring ().toupper ();	var hash_code = hash (id).tostring ("x");	var str = filetoenum (name);	string ver_str = version + " " + filetomoniker (fullname);	var ver = a.getname ().version;	if (dump_ver) {	} else if (dump_guids_for_msbuild) {	
name id ver major ver minor ver build ver revision 

========================= mono sample_7 =========================

public pointf (float a, float b) {	fa = a;	fb = b;	
pointf created and 

public point (int a, int b) {	
initialized with and 

static bool method (pointf f) {	
method with pointf arg 

public static int main () {	int t = t ();	if (t != 0) console.writeline ("failed on test: " + t);	
succeed 

========================= mono sample_1397 =========================

public void hello () {	
hello world 

========================= mono sample_3012 =========================

public void test () {	
createdelegate success 

========================= mono sample_564 =========================

public static int test_0_abort_other_indirect () {	test test = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	test testhere = new test ();	if (!remotingservices.istransparentproxy (test)) {	
test is no proxy 

test testhere = new test ();	if (!remotingservices.istransparentproxy (test)) {	return 1;	}	try {	test.abortotherindirect (testhere);	} catch (threadabortexception e) {	object state = e.exceptionstate;	thread.resetabort ();	if ((justsomeclass)state != testhere.other) {	
other class not preserved in state 

public static int test_0_abort_string () {	test test = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	if (!remotingservices.istransparentproxy (test)) {	
test is no proxy 

public static int test_0_abort_string () {	test test = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	if (!remotingservices.istransparentproxy (test)) {	return 1;	}	try {	test.abortstring ();	
no abort 

return 1;	}	try {	test.abortstring ();	return 2;	} catch (threadabortexception e) {	object state;	state = e.exceptionstate;	thread.resetabort ();	if (state == null) {	
state is null 

test.abortstring ();	return 2;	} catch (threadabortexception e) {	object state;	state = e.exceptionstate;	thread.resetabort ();	if (state == null) {	return 3;	} else {	if (remotingservices.istransparentproxy (state)) {	
state is proxy 

object state;	state = e.exceptionstate;	thread.resetabort ();	if (state == null) {	return 3;	} else {	if (remotingservices.istransparentproxy (state)) {	return 4;	}	if (!((string)state).equals ("bla")) {	
state is wrong 

return 3;	} else {	if (remotingservices.istransparentproxy (state)) {	return 4;	}	if (!((string)state).equals ("bla")) {	return 5;	}	}	if (remotingservices.istransparentproxy (e)) {	
exception is proxy 

return 4;	}	if (!((string)state).equals ("bla")) {	return 5;	}	}	if (remotingservices.istransparentproxy (e)) {	return 6;	}	if (test.getstate () != null) {	
have state 

public static int test_0_abort_proxy () {	test test = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	if (!remotingservices.istransparentproxy (test)) {	
test is no proxy 

public static int test_0_abort_proxy () {	test test = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	if (!remotingservices.istransparentproxy (test)) {	return 1;	}	try {	test.abortproxy ();	
no abort 

return 1;	}	try {	test.abortproxy ();	return 2;	} catch (threadabortexception e) {	object state;	state = e.exceptionstate;	thread.resetabort ();	if (state == null) {	
state is null 

test.abortproxy ();	return 2;	} catch (threadabortexception e) {	object state;	state = e.exceptionstate;	thread.resetabort ();	if (state == null) {	return 3;	} else {	if (!remotingservices.istransparentproxy (state)) {	
state is not proxy 

object state;	state = e.exceptionstate;	thread.resetabort ();	if (state == null) {	return 3;	} else {	if (!remotingservices.istransparentproxy (state)) {	return 4;	}	if (((test)state).getint () != 123) {	
state doesn t work 

return 3;	} else {	if (!remotingservices.istransparentproxy (state)) {	return 4;	}	if (((test)state).getint () != 123) {	return 5;	}	}	if (remotingservices.istransparentproxy (e)) {	
exception is proxy 

public static int test_0_abort_other () {	test test = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	if (!remotingservices.istransparentproxy (test)) {	
test is no proxy 

public static int test_0_abort_other () {	test test = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	if (!remotingservices.istransparentproxy (test)) {	return 1;	}	try {	test.abortother ();	
no abort 

return 1;	}	try {	test.abortother ();	return 2;	} catch (threadabortexception e) {	object state = null;	bool stateexc = false;	try {	state = e.exceptionstate;	
have state 

} catch (threadabortexception e) {	object state = null;	bool stateexc = false;	try {	state = e.exceptionstate;	} catch (exception) {	stateexc = true;	quietly quits */ thread.resetabort ();	}	if (!stateexc) {	
no state exception 

try {	state = e.exceptionstate;	} catch (exception) {	stateexc = true;	quietly quits */ thread.resetabort ();	}	if (!stateexc) {	return 3;	}	if (remotingservices.istransparentproxy (e)) {	
exception is proxy 

========================= mono sample_597 =========================

static private bool drawimagecallback(intptr callbackdata) {	
drawimagecallback 

========================= mono sample_21321 =========================

static screen () {	try {	all_screens = xplatui.allscreens;	}	catch (exception e) {	
trying to get all screens 

========================= mono sample_25728 =========================

public static int main () {	var t = typeof (c<>);	if (t.getfields (bindingflags.public | bindingflags.nonpublic | bindingflags.instance | bindingflags.static).length != 1) return 1;	t = typeof (c2<>);	if (t.getfields (bindingflags.public | bindingflags.nonpublic | bindingflags.instance | bindingflags.static).length != 1) return 1;	t = typeof (n1);	if (t.getfields (bindingflags.public | bindingflags.nonpublic | bindingflags.instance | bindingflags.static).length != 0) return 1;	
ok 

========================= mono sample_3321 =========================

public static void main () {	try {	throw new exception ("stacktrace with 1 frame");	} catch (exception e) {	console.writeline (e);	
stacktrace 

public static void catch (action action) {	try {	action ();	} catch (exception e) {	console.writeline();	console.writeline (e);	
stacktrace 

public static void throwexception (string message, t arg) {	
generic to string 

========================= mono sample_1224 =========================

public override string tostring() {	using (stringwriter writer = new stringwriter(cultureinfo.invariantculture)) {	
securitytokenresolver 

========================= mono sample_16065 =========================

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
visual 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
visualid 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
screen 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
depth 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
klass 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
red mask x 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
green mask x 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
blue mask x 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
colormap size 

if (copypixeloperation != copypixeloperation.sourcecopy) throw new notimplementedexception ("operation not implemented under x11");	if (gdiplus.display == intptr.zero) {	gdiplus.display = gdiplus.xopendisplay (intptr.zero);	}	window = gdiplus.xrootwindow (gdiplus.display, 0);	defvisual = gdiplus.xdefaultvisual (gdiplus.display, 0);	xvisualinfo visual = new xvisualinfo ();	visual.visualid = gdiplus.xvisualidfromvisual(defvisual);	vptr = gdiplus.xgetvisualinfo (gdiplus.display, 0x1 /* visualidmask */, ref visual, ref nitems);	visual = (xvisualinfo) marshal.ptrtostructure(vptr, typeof (xvisualinfo));	
bits per rgb 

========================= mono sample_21261 =========================

public static int main() {	thread thr=new thread(new threadstart(foo.thread));	thr.start();	thread.sleep(1200);	
main thread returns 

public static void thread() {	
thread running 

public static void thread() {	thread.sleep(500);	
thread exiting 

========================= mono sample_486 =========================

public static void main (string[] args) {	int total = 0;	batchcompiler bc = newbatchcompiler ();	foreach (string src in directory.getfiles (".", "*.il")) {	if (bc.compile (src)) ++total;	bc = newbatchcompiler ();	}	
total compiled successfully 

public bool compile (string src) {	try {	mono.ilasm.driver.main (new string[] { src });	string binary = src.substring (0, src.length - 3) + ".exe";	return file.exists (binary);	} catch (exception e) {	
error compiling 

========================= mono sample_781 =========================

public static void ondisposed<t> (intptr obj, bool disposing) {	if (disposing && !enabled) throw new invalidoperationexception ();	if (environment.hasshutdownstarted) return;	if (!disposing) {	
is leaking programmer is missing a call to dispose 

public static void ondisposed<t> (intptr obj, bool disposing) {	if (disposing && !enabled) throw new invalidoperationexception ();	if (environment.hasshutdownstarted) return;	if (!disposing) {	if (enabled) {	string val;	if (traces.trygetvalue (obj, out val)) {	
allocated from 

public static void ondisposed<t> (intptr obj, bool disposing) {	if (disposing && !enabled) throw new invalidoperationexception ();	if (environment.hasshutdownstarted) return;	if (!disposing) {	if (enabled) {	string val;	if (traces.trygetvalue (obj, out val)) {	console.error.writeline (val);	}	} else {	
set mono cairo debug dispose to track allocation traces 

========================= mono sample_4757 =========================

}	#if dbg public bool debug {	get {	if (_regex == null) return false;	return _regex.debug;	}	}	internal virtual void dump() {	int i,j;	for (i = 0; i < _matchcount.length; i++) {	
capnum 

========================= mono sample_11782 =========================

static stream getfile () {	try {	if (inputfile != null) {	return file.openread (inputfile);	} else {	
downloading from 

static x509certificatecollection decodecollection () {	x509certificatecollection roots = new x509certificatecollection ();	stringbuilder sb = new stringbuilder ();	bool processing = false;	using (stream s = getfile ()) {	if (s == null) {	
couldn t retrieve the file using the supplied information 

static int process () {	servicepointmanager.servercertificatevalidationcallback = (sender, certificate, chain, sslpolicyerrors) => {	if (sslpolicyerrors != system.net.security.sslpolicyerrors.none) console.writeline ("warning: downloading the trusted certificate list couldn't be done securely (error: {0}), continuing anyway. if you're using mozroots to bootstrap mono's trust store on a clean system this might be ok, otherwise it could indicate a network intrusion. please ensure you're using a trusted network or move to cert-sync.", sslpolicyerrors);	return true;	};	x509certificatecollection roots = decodecollection ();	if (roots == null) {	return 1;	} else if (roots.count == 0) {	
no certificates were found 

};	x509certificatecollection roots = decodecollection ();	if (roots == null) {	return 1;	} else if (roots.count == 0) {	return 0;	}	if (pkcs7filename != null) {	softwarepublishercertificate pkcs7 = new softwarepublishercertificate ();	pkcs7.certificates.addrange (roots);	
saving root certificates into file 

if (pkcs7filename != null) {	softwarepublishercertificate pkcs7 = new softwarepublishercertificate ();	pkcs7.certificates.addrange (roots);	using (filestream fs = file.openwrite (pkcs7filename)) {	byte[] data = pkcs7.getbytes ();	fs.write (data, 0, data.length);	fs.close ();	}	}	if (import) {	
importing certificates into store machine user 

}	}	if (import) {	x509stores stores = (machine ? x509storemanager.localmachine : x509storemanager.currentuser);	x509certificatecollection trusted = stores.trustedroot.certificates;	int additions = 0;	foreach (x509certificate root in roots) {	if (!trusted.contains (root)) {	if (!confirmaddition || askconfirmation ("add", root)) {	stores.trustedroot.import (root);	
certificate added 

x509certificatecollection trusted = stores.trustedroot.certificates;	int additions = 0;	foreach (x509certificate root in roots) {	if (!trusted.contains (root)) {	if (!confirmaddition || askconfirmation ("add", root)) {	stores.trustedroot.import (root);	additions++;	}	}	}	
new root certificates were added to your trust store 

}	}	x509certificatecollection removed = new x509certificatecollection ();	foreach (x509certificate trust in trusted) {	if (!roots.contains (trust)) {	removed.add (trust);	}	}	if (removed.count > 0) {	if (confirmremoval) {	
previously trusted certificates were not part of the update 

}	x509certificatecollection removed = new x509certificatecollection ();	foreach (x509certificate trust in trusted) {	if (!roots.contains (trust)) {	removed.add (trust);	}	}	if (removed.count > 0) {	if (confirmremoval) {	} else {	
previously trusted certificates were removed 

removed.add (trust);	}	}	if (removed.count > 0) {	if (confirmremoval) {	} else {	}	foreach (x509certificate old in removed) {	if (!confirmremoval || askconfirmation ("remove", old)) {	stores.trustedroot.remove (old);	
certificate removed 

if (removed.count > 0) {	if (confirmremoval) {	} else {	}	foreach (x509certificate old in removed) {	if (!confirmremoval || askconfirmation ("remove", old)) {	stores.trustedroot.remove (old);	}	}	}	
import process completed 

static bool askconfirmation (string action, x509certificate certificate) {	console.writeline ();	
issuer 

static bool askconfirmation (string action, x509certificate certificate) {	console.writeline ();	
serial number 

static bool askconfirmation (string action, x509certificate certificate) {	console.writeline ();	
valid from to 

static bool askconfirmation (string action, x509certificate certificate) {	console.writeline ();	
thumbprint sha 

static bool askconfirmation (string action, x509certificate certificate) {	console.writeline ();	
thumbprint 

confirmremoval = true;	break;	case "--ask-add": confirmaddition = true;	confirmremoval = false;	break;	case "--ask-remove": confirmaddition = false;	confirmremoval = true;	break;	case "--quiet": quiet = true;	break;	
unknown option 

static void header () {	console.writeline (new assemblyinfo ().tostring ());	
warning mozroots is deprecated please move to cert sync instead 

static void help () {	
usage mozroots import machine sync ask ask add ask remove 

static void help () {	
where the basic options are 

static void help () {	
import import the certificates into the trust store 

static void help () {	
sync synchronize add remove the trust store with the certificates 

static void help () {	
ask always confirm before adding or removing trusted certificates 

static void help () {	
ask add always confirm before adding a new trusted certificate 

static void help () {	
ask remove always confirm before removing an existing trusted certificate 

static void help () {	
and the advanced options are 

static void help () {	
url url specify an alternative url for downloading the trusted 

static void help () {	
certificates mxr source format 

static void help () {	
file name do not download but use the specified file 

static void help () {	
name export the certificates into a pkcs file 

static void help () {	
machine import the certificate in the machine trust store 

static void help () {	
the default is to import into the user store 

static void help () {	
quiet limit console output to errors and confirmations messages 

header ();	help ();	return 1;	}	if (!quiet) {	header ();	}	return process ();	}	catch (exception e) {	
error 

========================= mono sample_1172 =========================

string config = null;	string mono_path = null;	string runtime_args = null;	string mono_gac_prefix = null;	var opt_sets = new list<string> ();	int i = 0;	while (i < args.length) {	if (args [i].startswith ("-")) {	if (args [i] == "-j") {	if (i + 1 >= args.length) {	
missing argument to j command line option 

if (args [i].startswith ("-")) {	if (args [i] == "-j") {	if (i + 1 >= args.length) {	return 1;	}	if (args [i + 1] == "a") concurrency = environment.processorcount;	else concurrency = int32.parse (args [i + 1]);	i += 2;	} else if (args [i] == "--timeout") {	if (i + 1 >= args.length) {	
missing argument to timeout command line option 

else concurrency = int32.parse (args [i + 1]);	i += 2;	} else if (args [i] == "--timeout") {	if (i + 1 >= args.length) {	return 1;	}	timeout = int32.parse (args [i + 1]);	i += 2;	} else if (args [i] == "--disabled") {	if (i + 1 >= args.length) {	
missing argument to disabled command line option 

timeout = int32.parse (args [i + 1]);	i += 2;	} else if (args [i] == "--disabled") {	if (i + 1 >= args.length) {	return 1;	}	disabled_tests = args [i + 1];	i += 2;	} else if (args [i] == "--runtime") {	if (i + 1 >= args.length) {	
missing argument to runtime command line option 

disabled_tests = args [i + 1];	i += 2;	} else if (args [i] == "--runtime") {	if (i + 1 >= args.length) {	return 1;	}	runtime = args [i + 1];	i += 2;	} else if (args [i] == "--runtime-args") {	if (i + 1 >= args.length) {	
missing argument to runtime args command line option 

runtime = args [i + 1];	i += 2;	} else if (args [i] == "--runtime-args") {	if (i + 1 >= args.length) {	return 1;	}	runtime_args = (runtime_args ?? "") + " " + args [i + 1];	i += 2;	} else if (args [i] == "--config") {	if (i + 1 >= args.length) {	
missing argument to config command line option 

runtime_args = (runtime_args ?? "") + " " + args [i + 1];	i += 2;	} else if (args [i] == "--config") {	if (i + 1 >= args.length) {	return 1;	}	config = args [i + 1];	i += 2;	} else if (args [i] == "--opt-sets") {	if (i + 1 >= args.length) {	
missing argument to opt sets command line option 

config = args [i + 1];	i += 2;	} else if (args [i] == "--opt-sets") {	if (i + 1 >= args.length) {	return 1;	}	foreach (var s in args [i + 1].split ()) opt_sets.add (s);	i += 2;	} else if (args [i] == "--expected-exit-code") {	if (i + 1 >= args.length) {	
missing argument to expected exit code command line option 

foreach (var s in args [i + 1].split ()) opt_sets.add (s);	i += 2;	} else if (args [i] == "--expected-exit-code") {	if (i + 1 >= args.length) {	return 1;	}	expectedexitcode = int32.parse (args [i + 1]);	i += 2;	} else if (args [i] == "--testsuite-name") {	if (i + 1 >= args.length) {	
missing argument to testsuite name command line option 

expectedexitcode = int32.parse (args [i + 1]);	i += 2;	} else if (args [i] == "--testsuite-name") {	if (i + 1 >= args.length) {	return 1;	}	testsuitename = args [i + 1];	i += 2;	} else if (args [i] == "--input-file") {	if (i + 1 >= args.length) {	
missing argument to input file command line option 

testsuitename = args [i + 1];	i += 2;	} else if (args [i] == "--input-file") {	if (i + 1 >= args.length) {	return 1;	}	inputfile = args [i + 1];	i += 2;	} else if (args [i] == "--mono-path") {	if (i + 1 >= args.length) {	
missing argument to mono path command line option 

inputfile = args [i + 1];	i += 2;	} else if (args [i] == "--mono-path") {	if (i + 1 >= args.length) {	return 1;	}	mono_path = args [i + 1].substring(0, args [i + 1].length);	i += 2;	} else if (args [i] == "--mono-gac-prefix") {	if (i + 1 >= args.length) {	
missing argument to mono gac prefix command line option 

if (i + 1 >= args.length) {	return 1;	}	mono_gac_prefix = args[i + 1];	i += 2;	} else if (args [i] == "--verbose") {	verbose = true;	i ++;	} else if (args [i] == "--repeat") {	if (i + 1 >= args.length) {	
missing argument to repeat command line option 

i += 2;	} else if (args [i] == "--verbose") {	verbose = true;	i ++;	} else if (args [i] == "--repeat") {	if (i + 1 >= args.length) {	return 1;	}	repeat = int32.parse (args [i + 1]);	if (repeat <= 1) {	
invalid argument to repeat command line option should be 

} else if (args [i] == "--repeat") {	if (i + 1 >= args.length) {	return 1;	}	repeat = int32.parse (args [i + 1]);	if (repeat <= 1) {	return 1;	}	i += 2;	} else {	
unknown command line option 

}	i += 2;	} else {	return 1;	}	} else {	break;	}	}	if (string.isnullorempty (testsuitename)) {	
missing the required testsuite name command line option 

if (!string.isnullorempty (inputfile)) {	foreach (string l in file.readalllines (inputfile)) {	for (int r = 0; r < repeat; ++r) tests.add (l);	}	} else {	for (int j = i; j < args.length; ++j) if (!disabled.containskey (args [j])) {	for (int r = 0; r < repeat; ++r) tests.add (args [j]);	}	}	if (!tests.any ()) {	
no tests selected exiting 

}	if (!tests.any ()) {	return 0;	}	var random = new random (0);	tests = tests.orderby (t => random.next ()).tolist ();	var passed = new list<processdata> ();	var failed = new list<processdata> ();	var timedout = new list<processdata> ();	object monitor = new object ();	
running tests 

writer.writeendelement ();	writer.writeendelement ();	writer.writeendelement ();	writer.writeenddocument ();	string babysitterxmllist = environment.getenvironmentvariable("mono_babysitter_nunit_xml_list_file");	if (!string.isnullorempty(babysitterxmllist)) {	try {	string fullxmlpath = path.getfullpath(xmlpath);	file.appendalltext(babysitterxmllist, fullxmlpath + environment.newline);	} catch (exception e) {	
attempted to record xml path to file but failed 

if (!string.isnullorempty(babysitterxmllist)) {	try {	string fullxmlpath = path.getfullpath(xmlpath);	file.appendalltext(babysitterxmllist, fullxmlpath + environment.newline);	} catch (exception e) {	}	}	}	if (verbose) {	console.writeline ();	
time 

try {	string fullxmlpath = path.getfullpath(xmlpath);	file.appendalltext(babysitterxmllist, fullxmlpath + environment.newline);	} catch (exception e) {	}	}	}	if (verbose) {	console.writeline ();	console.writeline ();	
test s passed 

try {	string fullxmlpath = path.getfullpath(xmlpath);	file.appendalltext(babysitterxmllist, fullxmlpath + environment.newline);	} catch (exception e) {	}	}	}	if (verbose) {	console.writeline ();	console.writeline ();	
test s failed 

try {	string fullxmlpath = path.getfullpath(xmlpath);	file.appendalltext(babysitterxmllist, fullxmlpath + environment.newline);	} catch (exception e) {	}	}	}	if (verbose) {	console.writeline ();	console.writeline ();	
test s timed out 

file.appendalltext(babysitterxmllist, fullxmlpath + environment.newline);	} catch (exception e) {	}	}	}	if (verbose) {	console.writeline ();	console.writeline ();	} else {	console.writeline ();	
test s passed test s did not pass 

}	}	if (verbose) {	console.writeline ();	console.writeline ();	} else {	console.writeline ();	}	if (nfailed > 0) {	console.writeline ();	
failed test s 

console.writeline ();	foreach (processdata pd in failed) {	console.writeline ();	console.writeline (pd.test);	dumpfile (pd.stdoutname, pd.stdout.tostring ());	dumpfile (pd.stderrname, pd.stderr.tostring ());	}	}	if (ntimedout > 0) {	console.writeline ();	
timed out test s 

static void trylldb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
process attach pid 

static void trylldb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
thread list 

static void trylldb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
thread backtrace all 

static void trylldb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
detach 

static void trylldb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
quit 

static void trygdb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
attach 

static void trygdb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
info threads 

static void trygdb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
thread apply all p mono print thread dump 

static void trygdb (int pid, processdata data) {	string filename = path.gettempfilename ();	using (streamwriter sw = new streamwriter (new filestream (filename, filemode.open, fileaccess.write))) {	
thread apply all backtrace 

========================= mono sample_690 =========================

assert.areequal (0, ex.line, "#7");	assert.isnotnull (ex.message, "#8");	configurationerrorsexception inner = ex.innerexception as configurationerrorsexception;	assert.areequal (typeof (configurationerrorsexception), inner.gettype (), "#9");	assert.areequal (appdomain.currentdomain.setupinformation.configurationfile, inner.filename, "#10");	assert.isnull (inner.innerexception, "#11");	assert.areequal (3, inner.line, "#12");	assert.isnotnull (inner.message, "#13");	assert.istrue (inner.message.indexof ("<location>") != -1, "#14:" + inner.message);	assert.istrue (inner.message.indexof ("<configuration>") != -1, "#15:" + inner.message);	
configuration exception thrown 

========================= mono sample_29808 =========================

checksize<emptyexplicitpackstruct>(1, ref exitcode);	checksize<emptyexplicitsize0struct>(1, ref exitcode);	checksize<emptyexplicitsize1struct>(1, ref exitcode);	checksize<testoffsets>(19, ref exitcode);	console.writeline("--");	var t = typeof(testoffsets);	var actualoffsets = ( from f in t.getfields() select (name: f.name, offset: marshal.offsetof(t, f.name).toint32()) ).tolist();	var expectedoffsets = new [] {	(name: "a", offset: 0), (name: "b", offset: 4), (name: "c", offset: 5), (name: "d", offset: 9), (name: "e", offset: 10), (name: "f", offset: 14), (name: "g", offset: 15) };	if (!actualoffsets.sequenceequal(expectedoffsets)) {	
field offset mismatch 

========================= mono sample_663 =========================

static void usage () {	
usage options dtdfile ns 

string ns = string.empty;	foreach (string arg in args) {	if (arg == "--help") {	usage ();	return 1;	}	if (arg == "--compact" || arg == "-c") compact = true;	else if (file == null) file = arg;	else if (ns != string.empty) {	usage ();	
extra command line argument 

========================= mono sample_1210 =========================

static void help (bool exit) {	
usage is httpcfg add port nn cert cert pvk pvk pwd password httpcfg del port nn httpcfg list 

static void processarguments (string [] args) {	for (int i = 0; i < args.length; i++){	string arg = args [i];	switch (arg){	case "-add": if (action != action.none) {	
error conflicting options 

static void processarguments (string [] args) {	for (int i = 0; i < args.length; i++){	string arg = args [i];	switch (arg){	case "-add": if (action != action.none) {	help (true);	}	action = action.add;	break;	case "-del": case "-delete": if (action != action.none) {	
error conflicting options 

help (true);	}	action = action.add;	break;	case "-del": case "-delete": if (action != action.none) {	help (true);	}	action = action.delete;	break;	case "-list": if (action != action.none) {	
error conflicting options 

help (true);	}	action = action.delete;	break;	case "-list": if (action != action.none) {	help (true);	}	action = action.list;	break;	case "-port": if (port != 0) {	
error more than one port specified 

help (true);	}	action = action.list;	break;	case "-port": if (port != 0) {	help (true);	}	try {	port = convert.touint16 (args [++i]);	} catch (indexoutofrangeexception) {	
error no port specified 

action = action.list;	break;	case "-port": if (port != 0) {	help (true);	}	try {	port = convert.touint16 (args [++i]);	} catch (indexoutofrangeexception) {	help (true);	} catch {	
error invalid port 

}	try {	port = convert.touint16 (args [++i]);	} catch (indexoutofrangeexception) {	help (true);	} catch {	help (true);	}	break;	case "-p12": if (p12file != null) {	
error more than one file specified 

} catch (indexoutofrangeexception) {	help (true);	} catch {	help (true);	}	break;	case "-p12": if (p12file != null) {	help (true);	}	if (pvkfile != null || certfile != null) {	
error use either or pvk and cert 

break;	case "-p12": if (p12file != null) {	help (true);	}	if (pvkfile != null || certfile != null) {	help (true);	}	p12file = args [++i];	break;	case "-pvk": if (pvkfile != null) {	
error more than one pvk file specified 

}	if (pvkfile != null || certfile != null) {	help (true);	}	p12file = args [++i];	break;	case "-pvk": if (pvkfile != null) {	help (true);	}	if (p12file != null) {	
error use either or pvk and cert 

break;	case "-pvk": if (pvkfile != null) {	help (true);	}	if (p12file != null) {	help (true);	}	pvkfile = args [++i];	break;	case "-cert": if (certfile != null) {	
error more than one cer file specified 

}	if (p12file != null) {	help (true);	}	pvkfile = args [++i];	break;	case "-cert": if (certfile != null) {	help (true);	}	if (p12file != null) {	
error use either or pvk and cert 

break;	case "-cert": if (certfile != null) {	help (true);	}	if (p12file != null) {	help (true);	}	certfile = args [++i];	break;	case "-pwd": if (passwd != null) {	
error more than one password specified 

if (p12file != null) {	help (true);	}	certfile = args [++i];	break;	case "-pwd": if (passwd != null) {	help (true);	}	passwd = args [++i];	break;	
error unknown argument 

case "-pwd": if (passwd != null) {	help (true);	}	passwd = args [++i];	break;	help (true);	break;	}	}	if (action == action.none) {	
error no action specified 

passwd = args [++i];	break;	help (true);	break;	}	}	if (action == action.none) {	help (true);	}	if ((pvkfile != null && certfile == null) || (pvkfile == null && certfile != null)) {	
error cert and pvk must be used 

break;	}	}	if (action == action.none) {	help (true);	}	if ((pvkfile != null && certfile == null) || (pvkfile == null && certfile != null)) {	help (true);	}	if (action != action.list && port == 0) {	
error port is missing or bogus 

if (action == action.none) {	help (true);	}	if ((pvkfile != null && certfile == null) || (pvkfile == null && certfile != null)) {	help (true);	}	if (action != action.list && port == 0) {	help (true);	}	if (action == action.delete && (pvkfile != null || certfile != null || p12file != null)) {	
error delete only expects a port option 

static void addp12 (string path, string filename, string password, ushort port) {	x509certificate2 x509 = null;	try {	x509 = new x509certificate2 (filename, password);	} catch (exception e) {	
error loading certificate 

static void addp12 (string path, string filename, string password, ushort port) {	x509certificate2 x509 = null;	try {	x509 = new x509certificate2 (filename, password);	} catch (exception e) {	help (true);	}	string target_cert = path.combine (path, string.format ("{0}.cer", port));	if (file.exists (target_cert)) {	
error there is already a certificate for that port 

x509 = new x509certificate2 (filename, password);	} catch (exception e) {	help (true);	}	string target_cert = path.combine (path, string.format ("{0}.cer", port));	if (file.exists (target_cert)) {	help (true);	}	string target_pvk = path.combine (path, string.format ("{0}.pvk", port));	if (file.exists (target_pvk)) {	
error there is already a certificate for that port 

static void addcertpvk (string path, string cert, string pvk, ushort port) {	try {	x509certificate2 x509 = new x509certificate2 (cert);	x509.privatekey = privatekey.createfromfile (pvk).rsa;	} catch (exception e) {	
error loading certificate or private key 

static void addcertpvk (string path, string cert, string pvk, ushort port) {	try {	x509certificate2 x509 = new x509certificate2 (cert);	x509.privatekey = privatekey.createfromfile (pvk).rsa;	} catch (exception e) {	help (true);	}	string target_cert = path.combine (path, string.format ("{0}.cer", port));	if (file.exists (target_cert)) {	
error there is already a certificate for that port 

x509.privatekey = privatekey.createfromfile (pvk).rsa;	} catch (exception e) {	help (true);	}	string target_cert = path.combine (path, string.format ("{0}.cer", port));	if (file.exists (target_cert)) {	help (true);	}	string target_pvk = path.combine (path, string.format ("{0}.pvk", port));	if (file.exists (target_pvk)) {	
error there is already a certificate for that port 

static void delete (string path, ushort port) {	string pattern = string.format ("{0}.*", port);	string [] files = directory.getfiles (path, pattern);	foreach (string f in files) {	try {	file.delete (f);	} catch (exception e) {	
error removing file 

static void list (string path) {	string [] files = directory.getfiles (path, "*");	foreach (string f in files) {	if (f.endswith (".cer")) {	x509certificate2 x509 = new x509certificate2 (f);	
port thumbprint 

static int main (string[] args) {	try {	processarguments (args);	} catch (indexoutofrangeexception) {	
error missing argument 

if (action == action.none) {	help (true);	}	string dirname = environment.getfolderpath (environment.specialfolder.applicationdata);	string path = path.combine (dirname, ".mono");	path = path.combine (path, "httplistener");	if (false == directory.exists (path)) {	try {	directory.createdirectory (path);	} catch (exception e) {	
error creating directory 

========================= mono sample_1181 =========================

string command_str = null;	string libdir;	string name, package, gacdir, root;	name = package = root = gacdir = null;	bool check_refs = false;	if (array.indexof (args, "/silent") > -1 || array.indexof (args, "-silent") > -1) silent = true;	for (int i=0; i<args.length; i++) {	if (isswitch (args [i])) {	if (args [i] == "-f" || args [i] == "/f") continue;	if (args [i] == "/r") {	
warning gacutil does not support traced references this option is being ignored 

continue;	}	if (command == command.unknown) {	command = getcommand (args [i]);	if (command != command.unknown) {	command_str = args [i];	continue;	}	}	if (i + 1 >= args.length) {	
option takes argument 

continue;	case "-gacdir": case "/gacdir": gacdir = args [++i];	continue;	case "/nologo": case "-nologo": continue;	}	}	if (name == null) name = args [i];	else name += args [i];	}	if (command == command.unknown && isswitch (args [0])) {	
unknown command 

}	string link_gacdir = gacdir;	string link_libdir = libdir;	if (root != null) {	libdir = path.combine (root, "mono");	gacdir = path.combine (libdir, "gac");	}	loadconfig (silent);	switch (command) {	case command.install: if (name == null) {	
option takes argument 

gacdir = path.combine (libdir, "gac");	}	loadconfig (silent);	switch (command) {	case command.install: if (name == null) {	return 1;	}	if (!install (check_refs, name, package, gacdir, link_gacdir, libdir, link_libdir)) return 1;	break;	case command.installfromlist: if (name == null) {	
option takes argument 

return 1;	}	if (!install (check_refs, name, package, gacdir, link_gacdir, libdir, link_libdir)) return 1;	break;	case command.installfromlist: if (name == null) {	return 1;	}	if (!installfromlist (check_refs, name, package, gacdir, link_gacdir, libdir, link_libdir)) return 1;	break;	case command.uninstall: if (name == null) {	
option takes argument 

return 1;	}	int uninstallcount = 0;	int uninstallfailures = 0;	uninstall (name, package, gacdir, libdir, false, ref uninstallcount, ref uninstallfailures);	writeline ("assemblies uninstalled = {0}", uninstallcount);	writeline ("failures = {0}", uninstallfailures);	if (uninstallfailures > 0) return 1;	break;	case command.uninstallfromlist: if (name == null) {	
option takes argument 

writeline ("assemblies uninstalled = {0}", uninstallcount);	writeline ("failures = {0}", uninstallfailures);	if (uninstallfailures > 0) return 1;	break;	case command.uninstallfromlist: if (name == null) {	return 1;	}	if (!uninstallfromlist (name, package, gacdir, libdir)) return 1;	break;	case command.uninstallspecific: if (name == null) {	
option takes argument 

private static bool install (bool check_refs, string name, string package, string gacdir, string link_gacdir, string libdir, string link_libdir) {	string failure_msg = "failure adding assembly {0} to the cache: ";	arraylist resources;	if (!file.exists (name)) {	
the system cannot find the file specified 

string failure_msg = "failure adding assembly {0} to the cache: ";	arraylist resources;	if (!file.exists (name)) {	return false;	}	assembly assembly = null;	assemblyname an = null;	try {	assembly = reflectiononlyloadfrom (name);	} catch {	
the file specified is not a valid assembly 

assembly assembly = null;	assemblyname an = null;	try {	assembly = reflectiononlyloadfrom (name);	} catch {	return false;	}	an = assembly.getname ();	switch (verifystrongname (an, name)) {	case verificationresult.strongnamed: case verificationresult.skipped: break;	
attempt to install an assembly without a strong name continuing anyway 

try {	assembly = reflectiononlyloadfrom (name);	} catch {	return false;	}	an = assembly.getname ();	switch (verifystrongname (an, name)) {	case verificationresult.strongnamed: case verificationresult.skipped: break;	if (!in_bootstrap) return false;	break;	
strong name cannot be verified for delay signed assembly continuing anyway 

if (!in_bootstrap) return false;	break;	if (!in_bootstrap) return false;	break;	}	resources = new arraylist ();	foreach (string res_name in assembly.getmanifestresourcenames ()) {	manifestresourceinfo res_info = assembly.getmanifestresourceinfo (res_name);	if ((res_info.resourcelocation & resourcelocation.embedded) == 0) {	if (!file.exists (res_info.filename)) {	
the system cannot find resource 

foreach (string res_name in assembly.getmanifestresourcenames ()) {	manifestresourceinfo res_info = assembly.getmanifestresourceinfo (res_name);	if ((res_info.resourcelocation & resourcelocation.embedded) == 0) {	if (!file.exists (res_info.filename)) {	return false;	}	resources.add (res_info);	}	}	if (check_refs && !checkreferencedassemblies (an)) {	
attempt to install an assembly that references non strong named assemblies with check refs enabled 

if (check_refs && !checkreferencedassemblies (an)) {	return false;	}	string [] siblings = { ".config", ".mdb" };	string version_token = an.version + "_" + an.cultureinfo.name.tolower (cultureinfo.invariantculture) + "_" + getstringtoken (an.getpublickeytoken ());	string full_path = path.combine (path.combine (gacdir, an.name), version_token);	string asmb_file = path.getfilename (name);	string asmb_path = path.combine (full_path, asmb_file);	string asmb_name = assembly.getname ().name;	if (path.getfilenamewithoutextension (asmb_file) != asmb_name) {	
the filename doesn t match the assembly name 

string asmb_name = assembly.getname ().name;	if (path.getfilenamewithoutextension (asmb_file) != asmb_name) {	return false;	}	try {	if (directory.exists (full_path)) {	directory.delete (full_path, true);	}	directory.createdirectory (full_path);	} catch {	
gac directories could not be created possibly permission issues 

copy (name_pdb, path.changeextension (asmb_path, ".pdb"), true);	}	foreach (string ext in siblings) {	string sibling = string.concat (name, ext);	if (file.exists (sibling)) copy (sibling, string.concat (asmb_path, ext), true);	}	foreach (manifestresourceinfo resource_info in resources) {	try {	copy (resource_info.filename, path.combine (full_path, path.getfilename (resource_info.filename)), true);	} catch {	
error could not install resource file 

environment.exit (1);	}	}	if (package != null) {	string ref_dir = path.combine (libdir, package);	string ref_path = path.combine (ref_dir, asmb_file);	if (file.exists (ref_path)) file.delete (ref_path);	try {	directory.createdirectory (ref_dir);	} catch {	
error could not create package dir file 

string sibling = string.concat (pkg_path, ext);	string sref = string.concat (ref_path, ext);	if (file.exists (sibling)) symlink (sibling, sref);	else {	try {	file.delete (sref);	} catch {	}	}	}	
package exported to 

if (file.exists (sibling)) symlink (sibling, sref);	else {	try {	file.delete (sref);	} catch {	}	}	}	} else {	copy (name, ref_path, true);	
package exported to 

try {	file.delete (sref);	} catch {	}	}	}	} else {	copy (name, ref_path, true);	}	}	
installed into the gac 

if (item == string.empty) continue;	string[] pieces = item.trim ().split (new char[] { '=' }, 2);	if(pieces.length == 1) asm_info ["assembly"] = pieces [0];	else asm_info [pieces[0].trim ().tolower (cultureinfo.invariantculture)] = pieces [1];	}	string assembly_name = (string) asm_info ["assembly"];	string asmdir = path.combine (gacdir, assembly_name);	if (!directory.exists (asmdir)) {	if (listmode) {	failures++;	
assembly 

string[] pieces = item.trim ().split (new char[] { '=' }, 2);	if(pieces.length == 1) asm_info ["assembly"] = pieces [0];	else asm_info [pieces[0].trim ().tolower (cultureinfo.invariantculture)] = pieces [1];	}	string assembly_name = (string) asm_info ["assembly"];	string asmdir = path.combine (gacdir, assembly_name);	if (!directory.exists (asmdir)) {	if (listmode) {	failures++;	}	
no assemblies found that match 

if (listmode) {	failures++;	}	return;	}	string searchstring = getsearchstring (asm_info);	string [] directories = directory.getdirectories (asmdir, searchstring);	if (directories.length == 0) {	if (listmode) {	failures++;	
assembly 

if (listmode) {	failures++;	}	return;	}	string searchstring = getsearchstring (asm_info);	string [] directories = directory.getdirectories (asmdir, searchstring);	if (directories.length == 0) {	if (listmode) {	failures++;	
no assemblies found that match 

for (int i = 0; i < directories.length; i++) {	if (listmode && i > 0) break;	string dir = directories [i];	string extension = null;	if (file.exists (path.combine (dir, assembly_name + ".dll"))) {	extension = ".dll";	} else if (file.exists (path.combine (dir, assembly_name + ".exe"))) {	extension = ".exe";	} else {	failures++;	
cannot find the assembly 

if (file.exists (path.combine (dir, assembly_name + ".dll"))) {	extension = ".dll";	} else if (file.exists (path.combine (dir, assembly_name + ".exe"))) {	extension = ".exe";	} else {	failures++;	continue;	}	string assembly_filename = assembly_name + extension;	assemblyname an = assemblyname.getassemblyname ( path.combine (dir, assembly_filename));	
assembly 

assemblyname an = assemblyname.getassemblyname ( path.combine (dir, assembly_filename));	directory.delete (dir, true);	if (package != null) {	string link_dir = path.combine (libdir, package);	string link = path.combine (link_dir, assembly_filename);	try {	file.delete (link);	} catch {	}	if (directory.getfiles (link_dir).length == 0) {	
cleaning package directory it is empty 

} catch {	}	if (directory.getfiles (link_dir).length == 0) {	try {	directory.delete (link_dir);	} catch {	}	}	}	uninstalled++;	
uninstalled 

if (directory.getfiles (link_dir).length == 0) {	try {	directory.delete (link_dir);	} catch {	}	}	}	uninstalled++;	}	if (directory.getdirectories (asmdir).length == 0) {	
cleaning assembly dir it is empty 

private static bool uninstallspecific (string name, string package, string gacdir, string libdir) {	string failure_msg = "failure to remove assembly from the cache: ";	if (!file.exists (name)) {	
the system cannot find the file specified 

private static bool uninstallspecific (string name, string package, string gacdir, string libdir) {	string failure_msg = "failure to remove assembly from the cache: ";	if (!file.exists (name)) {	return false;	}	assemblyname an = null;	try {	an = assemblyname.getassemblyname (name);	} catch {	
the file specified is not a valid assembly 

private static void list (string name, string gacdir) {	
the following assemblies are installed into the gac 

if (!directory.exists (asmdir)) {	writeline ("number of items = 0");	return;	}	string search = getsearchstring (asm_info);	string [] dir_list = directory.getdirectories (asmdir, search);	int count = 0;	foreach (string dir in dir_list) {	string asmb = path.combine (dir, (string) asm_info ["assembly"]) + ".dll";	if (file.exists (asmb)) {	
assembly 

if (file.length == 0) continue;	string assemblypath = path.combine (listdir, file);	if (!install (check_refs, assemblypath, package, gacdir, link_gacdir, libdir, link_libdir)) failed++;	processed++;	}	writeline ("assemblies processed = {0}", processed);	writeline ("assemblies installed = {0}", processed - failed);	writeline ("failures = {0}", failed);	return (failed == 0);	} catch (ioexception) {	
failed to open assemblies list file 

while ((line = s.readline ()) != null) {	string name = line.trim ();	if (name.length == 0) continue;	uninstall (line, package, gacdir, libdir, true, ref uninstalled, ref failed);	}	writeline ("assemblies processed = {0}", uninstalled+failed);	writeline ("assemblies uninstalled = {0}", uninstalled);	writeline ("failures = {0}", failed);	return (failed == 0);	} catch (ioexception) {	
failed to open assemblies list file 

private static bool checkreferencedassemblies (assemblyname an) {	try {	assembly a = reflectiononlyloadfrom (an.codebase);	assemblyname corlib = getcorlibname ();	foreach (assemblyname ref_an in a.getreferencedassemblies ()) {	if (ref_an.name == corlib.name) continue;	byte [] pt = ref_an.getpublickeytoken ();	if (pt == null || pt.length == 0) {	
assembly is not strong named 

static bool loadconfig (bool quiet) {	system.reflection.methodinfo config = typeof (system.environment).getmethod ("getmachineconfigpath", system.reflection.bindingflags.static | system.reflection.bindingflags.nonpublic);	if (config != null) {	string path = (string) config.invoke (null, null);	bool exist = file.exists (path);	
couldn t find machine config 

static bool loadconfig (bool quiet) {	system.reflection.methodinfo config = typeof (system.environment).getmethod ("getmachineconfigpath", system.reflection.bindingflags.static | system.reflection.bindingflags.nonpublic);	if (config != null) {	string path = (string) config.invoke (null, null);	bool exist = file.exists (path);	strongnamemanager.loadconfig (path);	return exist;	
couldn t resolve machine config location corlib issue 

public static extern int symlink (string oldpath, string newpath);	private static string getgacdir () {	system.reflection.propertyinfo gac = typeof (system.environment).getproperty ("gacpath", system.reflection.bindingflags.static|system.reflection.bindingflags.nonpublic);	if (gac == null) {	
error mono runtime not detected please use the mono runtime for gacutil exe 

private static string getlibdir () {	system.reflection.methodinfo libdir = typeof (system.environment).getmethod ("internalgetgacpath", system.reflection.bindingflags.static|system.reflection.bindingflags.nonpublic);	if (libdir == null) {	
error mono runtime not detected please use the mono runtime for gacutil exe 

private static void showhelp (bool detailed) {	
usage gacutil exe commands options 

private static void showhelp (bool detailed) {	
commands 

private static void showhelp (bool detailed) {	
i assembly path check refs package name root rootdir gacdir gacdir 

private static void showhelp (bool detailed) {	
installs an assembly into the global assembly cache 

private static void showhelp (bool detailed) {	if (detailed) {	
assembly path is the name of the file that contains the assembly manifest example i mydll dll 

private static void showhelp (bool detailed) {	if (detailed) {	}	writeline ();	
il assembly list file check refs package name root rootdir gacdir gacdir 

private static void showhelp (bool detailed) {	if (detailed) {	}	writeline ();	
installs one or more assemblies into the global assembly cache 

private static void showhelp (bool detailed) {	if (detailed) {	}	writeline ();	if (detailed) {	
assembly list file is the path to a test file containing a list of assembly file paths on separate lines example il assembly list txt assembly list txt contents dll dll 

private static void showhelp (bool detailed) {	if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	
u assembly display name package name root rootdir gacdir gacdir 

private static void showhelp (bool detailed) {	if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	
uninstalls an assembly from the global assembly cache 

if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	if (detailed) {	writeline ("\t<assembly_display_name> is the name of the assembly (partial or\n" + "\tfully qualified) to remove from the global assembly cache. if a \n" + "\tpartial name is specified all matching assemblies will be uninstalled.\n" + "\texample: -u mydll,version=1.2.1.0");	}	writeline ();	
ul assembly list file package name root rootdir gacdir gacdir 

if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	if (detailed) {	writeline ("\t<assembly_display_name> is the name of the assembly (partial or\n" + "\tfully qualified) to remove from the global assembly cache. if a \n" + "\tpartial name is specified all matching assemblies will be uninstalled.\n" + "\texample: -u mydll,version=1.2.1.0");	}	writeline ();	
uninstalls one or more assemblies from the global assembly cache 

}	writeline ();	if (detailed) {	writeline ("\t<assembly_display_name> is the name of the assembly (partial or\n" + "\tfully qualified) to remove from the global assembly cache. if a \n" + "\tpartial name is specified all matching assemblies will be uninstalled.\n" + "\texample: -u mydll,version=1.2.1.0");	}	writeline ();	if (detailed) {	writeline ("\t<assembly_list_file> is the path to a test file containing a list of\n" + "\tassembly names on separate lines.\n" + "\texample -ul assembly_list.txt\n" + "\t\tassembly_list.txt contents:\n" + "\t\tassembly1,version=1.0.0.0,culture=en,publickeytoken=0123456789abcdef\n" + "\t\tassembly2,version=2.0.0.0,culture=en,publickeytoken=0123456789abcdef");	}	writeline ();	
us assembly path package name root rootdir gacdir gacdir 

}	writeline ();	if (detailed) {	writeline ("\t<assembly_display_name> is the name of the assembly (partial or\n" + "\tfully qualified) to remove from the global assembly cache. if a \n" + "\tpartial name is specified all matching assemblies will be uninstalled.\n" + "\texample: -u mydll,version=1.2.1.0");	}	writeline ();	if (detailed) {	writeline ("\t<assembly_list_file> is the path to a test file containing a list of\n" + "\tassembly names on separate lines.\n" + "\texample -ul assembly_list.txt\n" + "\t\tassembly_list.txt contents:\n" + "\t\tassembly1,version=1.0.0.0,culture=en,publickeytoken=0123456789abcdef\n" + "\t\tassembly2,version=2.0.0.0,culture=en,publickeytoken=0123456789abcdef");	}	writeline ();	
uninstalls an assembly using the specifed assemblies full name 

writeline ();	if (detailed) {	writeline ("\t<assembly_display_name> is the name of the assembly (partial or\n" + "\tfully qualified) to remove from the global assembly cache. if a \n" + "\tpartial name is specified all matching assemblies will be uninstalled.\n" + "\texample: -u mydll,version=1.2.1.0");	}	writeline ();	if (detailed) {	writeline ("\t<assembly_list_file> is the path to a test file containing a list of\n" + "\tassembly names on separate lines.\n" + "\texample -ul assembly_list.txt\n" + "\t\tassembly_list.txt contents:\n" + "\t\tassembly1,version=1.0.0.0,culture=en,publickeytoken=0123456789abcdef\n" + "\t\tassembly2,version=2.0.0.0,culture=en,publickeytoken=0123456789abcdef");	}	writeline ();	if (detailed) {	
assembly path is the path to an assembly the full assembly name is retrieved from the specified assembly if there is an assembly in the gac with a matching name it is removed example us mydll dll 

writeline ("\t<assembly_display_name> is the name of the assembly (partial or\n" + "\tfully qualified) to remove from the global assembly cache. if a \n" + "\tpartial name is specified all matching assemblies will be uninstalled.\n" + "\texample: -u mydll,version=1.2.1.0");	}	writeline ();	if (detailed) {	writeline ("\t<assembly_list_file> is the path to a test file containing a list of\n" + "\tassembly names on separate lines.\n" + "\texample -ul assembly_list.txt\n" + "\t\tassembly_list.txt contents:\n" + "\t\tassembly1,version=1.0.0.0,culture=en,publickeytoken=0123456789abcdef\n" + "\t\tassembly2,version=2.0.0.0,culture=en,publickeytoken=0123456789abcdef");	}	writeline ();	if (detailed) {	}	writeline ();	
l assembly name root rootdir gacdir gacdir 

writeline ("\t<assembly_display_name> is the name of the assembly (partial or\n" + "\tfully qualified) to remove from the global assembly cache. if a \n" + "\tpartial name is specified all matching assemblies will be uninstalled.\n" + "\texample: -u mydll,version=1.2.1.0");	}	writeline ();	if (detailed) {	writeline ("\t<assembly_list_file> is the path to a test file containing a list of\n" + "\tassembly names on separate lines.\n" + "\texample -ul assembly_list.txt\n" + "\t\tassembly_list.txt contents:\n" + "\t\tassembly1,version=1.0.0.0,culture=en,publickeytoken=0123456789abcdef\n" + "\t\tassembly2,version=2.0.0.0,culture=en,publickeytoken=0123456789abcdef");	}	writeline ();	if (detailed) {	}	writeline ();	
lists the contents of the global assembly cache 

}	writeline ();	if (detailed) {	writeline ("\t<assembly_list_file> is the path to a test file containing a list of\n" + "\tassembly names on separate lines.\n" + "\texample -ul assembly_list.txt\n" + "\t\tassembly_list.txt contents:\n" + "\t\tassembly1,version=1.0.0.0,culture=en,publickeytoken=0123456789abcdef\n" + "\t\tassembly2,version=2.0.0.0,culture=en,publickeytoken=0123456789abcdef");	}	writeline ();	if (detailed) {	}	writeline ();	if (detailed) {	
when the assembly name parameter is specified only matching assemblies are listed 

writeline ("\t<assembly_list_file> is the path to a test file containing a list of\n" + "\tassembly names on separate lines.\n" + "\texample -ul assembly_list.txt\n" + "\t\tassembly_list.txt contents:\n" + "\t\tassembly1,version=1.0.0.0,culture=en,publickeytoken=0123456789abcdef\n" + "\t\tassembly2,version=2.0.0.0,culture=en,publickeytoken=0123456789abcdef");	}	writeline ();	if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	
displays a detailed help screen 

writeline ();	if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	
options 

writeline ();	if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	
package name 

writeline ();	if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	
used to create a directory in prefix lib mono with the name name and a symlink is created from name assembly name to the assembly on the gac this is used so developers can reference a set of libraries at once 

if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	
gacdir gacdir 

if (detailed) {	}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	
used to specify the gacs base directory once an assembly has been installed to a non standard gacdir the mono gac prefix environment variable must be used to access the assembly 

}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	
root rootdir 

}	writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	
used by developers integrating this with automake tools or packaging tools that require a prefix directory to be specified the root represents the component of a prefix typically prefix lib 

writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	
check refs 

writeline ();	if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	
used to ensure that the assembly being installed into the gac does not reference any non strong named assemblies assemblies being installed to the gac should not reference non strong named assemblies however the is an optional check 

if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	writeline ();	
ignored options 

if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	writeline ();	
f 

if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	writeline ();	
the mono gacutil ignores the f option to maintain commandline compatibility with 

if (detailed) {	}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	writeline ();	
other gacutils gacutil will always force the installation of a new assembly 

}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	writeline ();	writeline ();	
r reference scheme reference id description 

}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	writeline ();	writeline ();	
the mono gacutil has not implemented traced references and will emit a warning 

}	writeline ();	writeline ("-?");	writeline ();	if (!detailed) return;	writeline ();	writeline ();	writeline ();	writeline ();	writeline ();	
when this option is used 

========================= mono sample_1301 =========================

private void writeservicepoint (servicepoint sp) {	
address 

private void writeservicepoint (servicepoint sp) {	
connectionlimit 

private void writeservicepoint (servicepoint sp) {	
connectionname 

private void writeservicepoint (servicepoint sp) {	
currentconnections 

private void writeservicepoint (servicepoint sp) {	
idlesince 

private void writeservicepoint (servicepoint sp) {	
maxidletime 

private void writeservicepoint (servicepoint sp) {	
protocolversion 

private void writeservicepoint (servicepoint sp) {	
supportspipelining 

========================= mono sample_23301 =========================

static critical () {	program.mre1.set ();	program.mre2.waitone ();	try {	throw new exception ();	} catch (exception) {	
catched exception in cctor 

public static int main (string[] args) {	thread thread = new thread (dostuff);	thread.start ();	mre1.waitone ();	thread.abort ();	mre2.set ();	thread.join ();	if (!catched_exception) environment.exit (1);	if (!catched_abort) environment.exit (2);	
done all things good 

public static void dostuff () {	try {	new critical ();	} catch (threadabortexception) {	
catched thread abort 

========================= mono sample_632 =========================

public void basic () {	
aaa 

========================= mono sample_21344 =========================

public abstract void a ();	}	class y : x {	override public void a () {	
hello 

========================= mono sample_2737 =========================

a = (decimalconstantattribute) t.getfield ("constdecimal1").getcustomattributes (typeof (decimalconstantattribute), false)[0];	if (a.value != 314159265358979323846m) return 2;	if (constdecimal1 != (-1) * constdecimal2) return 3;	if (!(smallconstvalue < 1 && smallconstvalue > 0)) return 4;	decimal ld = long.maxvalue;	console.writeline (ld);	console.writeline (c.d);	console.writeline (decimal.one);	console.writeline (decimalvalue);	console.writeline (decimal.maxvalue);	
success 

========================= mono sample_2515 =========================

public static int main () {	der d = new der ();	if (d.message != "der") return 1;	basec b = new basec ();	if (b.message != "base") return 2;	derived dd = new derived ();	dd.thingy = 10;	if (dd.basethingy != 0) return 3;	
test ok 

========================= mono sample_2896 =========================

static int main () {	var t = new thread (createfirstbridge);	t.start ();	t.join ();	gc.collect ();	gc.waitforpendingfinalizers ();	
gc done 

t.start ();	t.join ();	gc.collect ();	gc.waitforpendingfinalizers ();	dumphandle (weak_track_handle, "weak-track1");	t = new thread (createsecondbridge);	t.start ();	t.join ();	gc.collect ();	gc.waitforpendingfinalizers ();	
gc done 

gc.collect ();	gc.waitforpendingfinalizers ();	dumphandle (weak_track_handle, "weak-track1");	t = new thread (createsecondbridge);	t.start ();	t.join ();	gc.collect ();	gc.waitforpendingfinalizers ();	dumphandle (weak_track_handle, "weak-track1");	dumphandle (weak_track_handle2, "weak-track2");	
done 

gc.waitforpendingfinalizers ();	dumphandle (weak_track_handle, "weak-track1");	t = new thread (createsecondbridge);	t.start ();	t.join ();	gc.collect ();	gc.waitforpendingfinalizers ();	dumphandle (weak_track_handle, "weak-track1");	dumphandle (weak_track_handle2, "weak-track2");	if ((intptr)weak_track_handle == (intptr)weak_track_handle2) {	
first handle got deallocated 

========================= mono sample_288 =========================

protected override void processhandshakemessage(tlsstream handmsg) {	handshaketype		handshaketype	= (handshaketype)handmsg.readbyte();	handshakemessage	message			= null;	
processing handshake record 

========================= mono sample_20703 =========================

static void main () {	bool ismono = type.gettype ("mono.runtime", false) != null;	
using system 

========================= mono sample_18668 =========================

static void help () {	
postecho url size web 

static void help () {	
default size is bytes 

static void help () {	
default mode is 

static void help () {	
a server side script must be installed to run postecho 

break;	default: size = int32.parse (args [i]);	break;	}	}	}	byte[] data = new byte[size];	for (int i = 0; i < size; i++) data[i] = 65;	string result = (ssl ? poststream (protocol, url, data) : postweb (url, data));	if (data.length != result.length) {	
invalid length expected 

}	}	byte[] data = new byte[size];	for (int i = 0; i < size; i++) data[i] = 65;	string result = (ssl ? poststream (protocol, url, data) : postweb (url, data));	if (data.length != result.length) {	return 1;	}	for (int i = 0; i < result.length; i++) {	if (result[i] != 'a') {	
error at position received 

for (int i = 0; i < size; i++) data[i] = 65;	string result = (ssl ? poststream (protocol, url, data) : postweb (url, data));	if (data.length != result.length) {	return 1;	}	for (int i = 0; i < result.length; i++) {	if (result[i] != 'a') {	return 1;	}	}	
result ok length 

break;	case -2146762495: message = "cert_e_expired 0x800b0101";	break;	case -2146762486: message = "cert_e_chaining 0x800b010a";	break;	case -2146762487: message = "cert_e_untrustedroot 0x800b0109";	break;	default: message = "unknown (try winerror.h)";	break;	}	
error 

private static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	if (certificateerrors.length > 0) {	console.writeline (certificate.tostring (true));	
valid from 

private static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	if (certificateerrors.length > 0) {	console.writeline (certificate.tostring (true));	
valid until 

public bool checkvalidationresult (servicepoint sp, x509certificate certificate, webrequest request, int error) {	if (error != 0) {	console.writeline (certificate.tostring (true));	
valid from 

public bool checkvalidationresult (servicepoint sp, x509certificate certificate, webrequest request, int error) {	if (error != 0) {	console.writeline (certificate.tostring (true));	
valid until 

========================= mono sample_20583 =========================

public void getversioninfo_textfile () {	string file = path.combine (tempdir, "lib.dll");	using (streamwriter sw = new streamwriter (file, false, encoding.utf8)) {	
whatever 

========================= mono sample_23719 =========================

public static void main(string[] args) {	ilist<char> lst = new linkedlist<char>();	lst.addall<char>(new char[] { 'a', 'b', 'c', 'd' });	ilist<char> a = lst.view(0, 2), b = lst.view(2, 0), c = lst.view(2, 1), d = lst.view(3, 1), e = lst.view(4, 0), f = lst.view(1, 2), g = lst.view(0, 4);	ilist<char>[] views = { a, b, c, d, e, f, g };	
abcdefg overlaps with 

public static void main(string[] args) {	ilist<char> lst = new linkedlist<char>();	lst.addall<char>(new char[] { 'a', 'b', 'c', 'd' });	ilist<char> a = lst.view(0, 2), b = lst.view(2, 0), c = lst.view(2, 1), d = lst.view(3, 1), e = lst.view(4, 0), f = lst.view(1, 2), g = lst.view(0, 4);	ilist<char>[] views = { a, b, c, d, e, f, g };	foreach (ilist<char> u in views) {	foreach (ilist<char> w in views) console.write(overlap(u, w) ? '+' : '-');	console.writeline();	}	
abcdefg overlap length 

foreach (ilist<char> w in views) console.write(overlap(u, w) ? '+' : '-');	console.writeline();	}	foreach (ilist<char> u in views) {	foreach (ilist<char> w in views) {	int len = overlaplength(u, w);	console.write(len >= 0 ? string.format("{0}", len) : " ");	}	console.writeline();	}	
abcdefg contained in 

========================= mono sample_30568 =========================

protected virtual string loadfile (string path) {	if (!file.exists (path)) {	
file not found required for exception template 

protected virtual string loadfile (string path) {	if (!file.exists (path)) {	return string.empty;	}	try {	return file.readalltext (path);	} catch (exception ex) {	
error reading file required for exception template exception has been thrown 

protected virtual string loadresource (string resourcename) {	string assemblyname = resourceassembly;	assembly asm;	if (string.isnullorempty (assemblyname)) asm = this.gettype ().assembly;	else {	try {	asm = assembly.load (assemblyname);	} catch (exception ex) {	
unable to load assembly needed to retrieve an exception template resource exception has been thrown 

try {	asm = assembly.load (assemblyname);	} catch (exception ex) {	if (runtimehelpers.debuggingenabled) console.error.writeline (ex.stacktrace);	return string.empty;	}	}	try {	stream st = asm.getmanifestresourcestream (resourcename);	if (st == null) {	
manifest resource required for exception template not found in assembly 

return string.empty;	}	}	try {	stream st = asm.getmanifestresourcestream (resourcename);	if (st == null) {	return string.empty;	}	using (streamreader sr = new streamreader (st)) return sr.readtoend ();	} catch (exception ex) {	
error reading manifest resource from assembly required for exception template exception has been thrown 

========================= mono sample_19965 =========================

public override void computemastersecret(byte[] premastersecret) {	this.context.mastersecret = new byte[premastersecret.length];	this.context.mastersecret = this.prf( premastersecret, "master secret", this.context.randomcs, 48);	
mastersecret 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
keyblock 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
clientwritekey 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
clientwriteiv 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
clientwritemac 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
serverwritekey 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
serverwriteiv 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
serverwritemac 

========================= mono sample_20720 =========================

public void readlineasync () {	memorystream ms = new memorystream ();	streamwriter sw = new streamwriter (ms, encoding.utf8);	
a 

public void readlineasync () {	memorystream ms = new memorystream ();	streamwriter sw = new streamwriter (ms, encoding.utf8);	
b 

========================= mono sample_27140 =========================

static ienumerator getit (int [] args) {	foreach (int arg in args) {	
out 

static ienumerator getit (int [] args) {	foreach (int arg in args) {	a a = delegate {	
arg 

static ienumerator getit (int [] args) {	foreach (int arg in args) {	a a = delegate {	
args 

========================= mono sample_2872 =========================

private void testmethod <t> (string param, tgenericdelegate<t> del) {	
testmethod t called with param calling a delegate 

private void adelegate <t> (string param) {	
adelegate t called with param 

========================= mono sample_1979 =========================

public override imessage invoke (imessage request) {	imethodcallmessage call = (imethodcallmessage)request;	
invoke 

public virtual mystruct add (int a, out int c, int b) {	
add 

public long nonvirtual_add (int a, int b) {	
nonvirtual add 

========================= mono sample_258 =========================

public void setcurrentnamespace (string ns) {	writer = namespaces [ns] as stringwriter;	if (writer == null) {	indent = 0;	writer = new stringwriter ();	namespaces [ns] = writer;	
namespace 

writeline (code);	}	public void writeline (string code) {	if (code != "")	writer.write (new string ('\t',indent));	writer.writeline (code);	}	public void write () {	if (filename == null) return;	filepath = path.combine (directory, filename);	streamwriter sw = new streamwriter (filepath);	
using system 

writeline (code);	}	public void writeline (string code) {	if (code != "")	writer.write (new string ('\t',indent));	writer.writeline (code);	}	public void write () {	if (filename == null) return;	filepath = path.combine (directory, filename);	streamwriter sw = new streamwriter (filepath);	
using system runtime remoting metadata 

========================= mono sample_17945 =========================

public void dumpreader (xmlreader xr, bool attvalue) {	
nodetype 

public void dumpreader (xmlreader xr, bool attvalue) {	
prefix 

public void dumpreader (xmlreader xr, bool attvalue) {	
name 

public void dumpreader (xmlreader xr, bool attvalue) {	
localname 

public void dumpreader (xmlreader xr, bool attvalue) {	
namespaceuri 

public void dumpreader (xmlreader xr, bool attvalue) {	
value 

public void dumpreader (xmlreader xr, bool attvalue) {	
depth 

public void dumpreader (xmlreader xr, bool attvalue) {	
isemptyelement 

public void dumpreader (xmlreader xr, bool attvalue) {	if (xr.nodetype == xmlnodetype.attribute) {	
attribute values 

public void dumpreader (xmlreader xr, bool attvalue) {	if (xr.nodetype == xmlnodetype.attribute) {	while (xr.readattributevalue ()) dumpreader (xr, true);	
attribute values end 

public void dumpreader (xmlreader xr, bool attvalue) {	if (xr.nodetype == xmlnodetype.attribute) {	while (xr.readattributevalue ()) dumpreader (xr, true);	} else if (!attvalue) {	
attributes 

if (xr.nodetype == xmlnodetype.attribute) {	while (xr.readattributevalue ()) dumpreader (xr, true);	} else if (!attvalue) {	console.write (xr.attributecount);	if (xr.movetofirstattribute ()) {	do {	dumpreader (xr, false);	} while (xr.movetonextattribute ());	xr.movetoelement ();	}	
attributes end 

========================= mono sample_22407 =========================

public static void main() {	dictionary<string, int> values = new dictionary<string, int>();	values["one"] = 1; values["two"] = 2;	foreach (string key in values.keys) {	
key 

========================= mono sample_1868 =========================

public static int main (string[] args) {	int c = 0;	try {	throw new exception("test exception");	}	catch (exception e) {	
exception 

public static int main (string[] args) {	int c = 0;	try {	throw new exception("test exception");	}	catch (exception e) {	}	finally {	
finally 

========================= mono sample_318 =========================

public static void main(string[] args) {	
note that null prints as blank or 

========================= mono sample_2693 =========================

public ienumerable foo (int a) {	try {	try {	yield return a;	} finally {	
hello world 

public ienumerable foo (int a) {	try {	try {	yield return a;	} finally {	}	
next block 

public ienumerable foo (int a) {	try {	try {	yield return a;	} finally {	}	try {	yield return a * a;	} finally {	
boston 

try {	try {	yield return a;	} finally {	}	try {	yield return a * a;	} finally {	}	} finally {	
outer finally 

try {	yield return a;	} finally {	}	try {	yield return a * a;	} finally {	}	} finally {	}	
outer block 

========================= mono sample_2906 =========================

public virtual servicetype getservice<servicetype> (params object[] args) where servicetype : class {	
asdafsdafs 

========================= mono sample_2745 =========================

static void assert (object[] attrs, bool expected_presence, int tc) {	if (attrs.length == 1 && expected_presence) return;	if (!expected_presence && attrs.length == 0) return;	
failed 

========================= mono sample_3478 =========================

public override void drawmanagedwindowdecorations (graphics dc, rectangle clip, internalwindowmanager wm) {	
drawmanagedwindowdecorations 

========================= mono sample_26189 =========================

public static int main () {	int result = test ();	#if debug if (result == 0) console.writeline ("ok");	
error 

========================= mono sample_2817 =========================

protected internal override void rendercontents (htmltextwriter writer) {	if (items.count == 0) return;	repeatinfo ri = new repeatinfo ();	ri.repeatcolumns = repeatcolumns;	ri.repeatdirection = repeatdirection;	ri.repeatlayout = repeatlayout;	ri.captionalign = captionalign;	ri.caption = caption;	ri.useaccessibleheader = useaccessibleheader;	
repeatcolumns 

protected internal override void rendercontents (htmltextwriter writer) {	if (items.count == 0) return;	repeatinfo ri = new repeatinfo ();	ri.repeatcolumns = repeatcolumns;	ri.repeatdirection = repeatdirection;	ri.repeatlayout = repeatlayout;	ri.captionalign = captionalign;	ri.caption = caption;	ri.useaccessibleheader = useaccessibleheader;	
repeatdirection 

protected internal override void rendercontents (htmltextwriter writer) {	if (items.count == 0) return;	repeatinfo ri = new repeatinfo ();	ri.repeatcolumns = repeatcolumns;	ri.repeatdirection = repeatdirection;	ri.repeatlayout = repeatlayout;	ri.captionalign = captionalign;	ri.caption = caption;	ri.useaccessibleheader = useaccessibleheader;	
repeatlayout 

protected internal override void rendercontents (htmltextwriter writer) {	if (items.count == 0) return;	repeatinfo ri = new repeatinfo ();	ri.repeatcolumns = repeatcolumns;	ri.repeatdirection = repeatdirection;	ri.repeatlayout = repeatlayout;	ri.captionalign = captionalign;	ri.caption = caption;	ri.useaccessibleheader = useaccessibleheader;	
outertableimplied 

repeatinfo ri = new repeatinfo ();	ri.repeatcolumns = repeatcolumns;	ri.repeatdirection = repeatdirection;	ri.repeatlayout = repeatlayout;	ri.captionalign = captionalign;	ri.caption = caption;	ri.useaccessibleheader = useaccessibleheader;	console.writeline ("irepeatinfouser.hasfooter {0}", (showfooter && (footertemplate != null)));	console.writeline ("irepeatinfouser.hasheader {0}", (showheader && (headertemplate != null)));	console.writeline ("irepeatinfouser.hasseparators {0}", (separatortemplate != null));	
irepeatinfouser repeateditemcount 

ri.repeatdirection = repeatdirection;	ri.repeatlayout = repeatlayout;	ri.captionalign = captionalign;	ri.caption = caption;	ri.useaccessibleheader = useaccessibleheader;	console.writeline ("irepeatinfouser.hasfooter {0}", (showfooter && (footertemplate != null)));	console.writeline ("irepeatinfouser.hasheader {0}", (showheader && (headertemplate != null)));	console.writeline ("irepeatinfouser.hasseparators {0}", (separatortemplate != null));	for (int i=0; i < items.count; i++) {	datalistitem dli = items [i];	
index type 

========================= mono sample_19923 =========================

public static void main () {	int x;	setinteger (out x);	
the compiler should say 

========================= mono sample_33844 =========================

x += 9;	if (x != 24) return 3;	byte c = 3;	byte d = 5;	x = d ^= c;	console.writeline (x);	short s = 5;	int i = 30000001;	s <<= i;	console.writeline (s);	
ok 

========================= mono sample_3819 =========================

public static idesigner createdesigner(icomponent component, type designerbasetype) {	type designertype = null;	idesigner designer = null;	
createdesigner 

if (designertype != null) {	break;	}	}	}	}	if (designertype != null) {	designer = (idesigner)activator.createinstance(designertype, bindingflags.instance | bindingflags.public | bindingflags.nonpublic | bindingflags.createinstance, null, null, null);	}	else {	
could not find designer for 

private icollection getextendedproperties(icomponent comp, iextenderprovider[] providers) {	type componenttype = comp.gettype();	
found providers 

type componenttype = comp.gettype();	ilist list = new arraylist();	for (int i = 0; i < providers.length; i++) {	if (!providers[i].canextend(comp)) {	continue;	}	iextenderprovider provider = providers[i];	type providertype = provider.gettype();	componententry providercompinfo = debugtypedescriptor.getentry(comp, providertype);	ilist providerwrappedextenders = providercompinfo.getwrappedextenders(provider);	
wrapped extenders 

private ilist getwrappedextenders(iextenderprovider provider) {	
getwrappedextenders 

throw new argumentexception(sr.getstring(sr.errorbadextendertype, providertype.name, componenttype.name), "provider");	}	bool sitedprovider = false;	if (provider is icomponent && ((icomponent)provider).site != null) {	sitedprovider = true;	}	ilist wrappedextenders = null;	lock(this) {	wrappedextenders = (ilist) wrappedextendertable[provider];	if (wrappedextenders == null) {	
entry not found in table creating 

}	bool sitedprovider = false;	if (provider is icomponent && ((icomponent)provider).site != null) {	sitedprovider = true;	}	ilist wrappedextenders = null;	lock(this) {	wrappedextenders = (ilist) wrappedextendertable[provider];	if (wrappedextenders == null) {	ilist extenders = getextenders();	
found extenders 

debugreflectpropertydescriptor ex = (debugreflectpropertydescriptor)extenders[i];	attribute[] attrs = null;	if (!sitedprovider) {	attrs = new attribute[] {designonlyattribute.yes};	}	wrappedextenders.add(new debugextendedpropertydescriptor(ex, ex.extendergetreceivertype(), provider, attrs));	}	wrappedextendertable[provider] = wrappedextenders;	}	else {	
entry found in table 

private void reflectgetcustomattributes(type classtoreflect, type metadatatype) {	attributecollection baseattributes = null;	hashtable           attrhash = new hashtable();	#if debug if (compdescrswitch.traceverbose) {	
retrieving metadata for 

private void reflectgetcustomattributes(type classtoreflect, type metadatatype) {	attributecollection baseattributes = null;	hashtable           attrhash = new hashtable();	#if debug if (compdescrswitch.traceverbose) {	
classtorefelct 

private void reflectgetcustomattributes(type classtoreflect, type metadatatype) {	attributecollection baseattributes = null;	hashtable           attrhash = new hashtable();	#if debug if (compdescrswitch.traceverbose) {	
metadatatype 

========================= mono sample_12006 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	task t = test.invoke (new tester (), null) as task;	if (!task.waitall (new[] { t }, 1000)) {	
failed timeout 

}	} else {	var tb = t as task<bool>;	if (tb != null) {	if (!tb.result) {	console.writeline ("failed (result={0})", tb.result);	return false;	}	}	}	
ok 

var tb = t as task<bool>;	if (tb != null) {	if (!tb.result) {	console.writeline ("failed (result={0})", tb.result);	return false;	}	}	}	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_3908 =========================

private static bool parseargumentvalue (string value) {	if ((value.length == 1)) {	switch (value [0]) {	case 't': return true;	case 'f': return false;	
invalid argument value 

private static bool parseargumentvalue (string value) {	if ((value.length == 1)) {	switch (value [0]) {	case 't': return true;	case 'f': return false;	throw new applicationexception ("invalid argument value " + value);	}	} else {	
invalid argument value 

case "da": usedifferentapplicationdomain = parseargumentvalue (components [1]);	break;	case "dcil": differentconfigurationislegacy = parseargumentvalue (components [1]);	break;	case "dtda": usedifferentthreadindifferentapplicationdomain = parseargumentvalue (components [1]);	break;	case "hra": addhandlertorootapplicationdomain = parseargumentvalue (components [1]);	break;	case "hda": addhandlertodifferentapplicationdomain = parseargumentvalue (components [1]);	break;	
invalid argument 

break;	case "dtda": usedifferentthreadindifferentapplicationdomain = parseargumentvalue (components [1]);	break;	case "hra": addhandlertorootapplicationdomain = parseargumentvalue (components [1]);	break;	case "hda": addhandlertodifferentapplicationdomain = parseargumentvalue (components [1]);	break;	throw new applicationexception ("invalid argument " + argument);	}	} else {	
invalid argument 

public void runtest () {	if (configuration.da) {	appdomain differentappdomain = creatediffrentappdomain ();	if (configuration.hda) {	differentappdomain.unhandledexception += new unhandledexceptioneventhandler (differentdomainunhandledexceptionhandler);	}	differentdomainactor dda = (differentdomainactor) differentappdomain.createinstanceandunwrap ( assembly.getentryassembly().fullname, typeof (differentdomainactor).fullname);	dda.act (configurationdescription);	} else {	if (configuration.dt) {	
throwing applicationexception in different thread 

if (configuration.da) {	appdomain differentappdomain = creatediffrentappdomain ();	if (configuration.hda) {	differentappdomain.unhandledexception += new unhandledexceptioneventhandler (differentdomainunhandledexceptionhandler);	}	differentdomainactor dda = (differentdomainactor) differentappdomain.createinstanceandunwrap ( assembly.getentryassembly().fullname, typeof (differentdomainactor).fullname);	dda.act (configurationdescription);	} else {	if (configuration.dt) {	} else {	
throwing applicationexception in main thread 

}	differentdomainactor dda = (differentdomainactor) differentappdomain.createinstanceandunwrap ( assembly.getentryassembly().fullname, typeof (differentdomainactor).fullname);	dda.act (configurationdescription);	} else {	if (configuration.dt) {	} else {	}	throw new applicationexception ("this exception is unhandled");	}	if (configuration.dt) {	
continuing in different thread after the exception was thrown 

static void main (string [] args) {	if (args.length != 1) {	
invalid arguments number of 

public void act () {	configuration.print ();	
running under version 

if (configuration.hra) {	appdomain.currentdomain.unhandledexception += new unhandledexceptioneventhandler (rootdomainunhandledexceptionhandler);	}	if (configuration.dt) {	thread thread = new thread (new threadstart (this.runtest));	thread.start ();	thread.join ();	} else {	runtest ();	}	
continuing in main thread after the exception was thrown 

if (configuration.hra) {	appdomain.currentdomain.unhandledexception += new unhandledexceptioneventhandler (rootdomainunhandledexceptionhandler);	}	if (configuration.dt) {	thread thread = new thread (new threadstart (this.runtest));	thread.start ();	thread.join ();	} else {	runtest ();	}	
continuing in root appdomain after the exception was thrown 

if (configuration.hra) {	appdomain.currentdomain.unhandledexception += new unhandledexceptioneventhandler (rootdomainunhandledexceptionhandler);	}	if (configuration.dt) {	thread thread = new thread (new threadstart (this.runtest));	thread.start ();	thread.join ();	} else {	runtest ();	}	
marker cont 

public static void printunhandledexception (string caller, object sender, unhandledexceptioneventargs e) {	exception ex = (exception)e.exceptionobject;	
running 

public static void printunhandledexception (string caller, object sender, unhandledexceptioneventargs e) {	exception ex = (exception)e.exceptionobject;	
handling exception type 

public static void printunhandledexception (string caller, object sender, unhandledexceptioneventargs e) {	exception ex = (exception)e.exceptionobject;	
message is 

public static void printunhandledexception (string caller, object sender, unhandledexceptioneventargs e) {	exception ex = (exception)e.exceptionobject;	
isterminating is set to 

public static void rootdomainunhandledexceptionhandler (object sender, unhandledexceptioneventargs e) {	
marker rdue 

public static void differentdomainunhandledexceptionhandler (object sender, unhandledexceptioneventargs e) {	
marker ddue 

public void runtest () {	if (configuration.dtda) {	
throwing applicationexception in new thread different appdomain 

public void runtest () {	if (configuration.dtda) {	} else if (configuration.dt) {	
throwing applicationexception in different thread different appdomain 

public void runtest () {	if (configuration.dtda) {	} else if (configuration.dt) {	} else {	
throwing applicationexception in main thread different appdomain 

========================= mono sample_433 =========================

public int instancetest () {	double index = 5;	
instance test 

public static int main () {	int result = test ();	
result 

========================= mono sample_3394 =========================

public static void main (string[] args) {	
starting cache testers 

public static void main (string[] args) {	
thread seed 

========================= mono sample_462 =========================

static int f (int a) {	
test f from delegate 

static void async_callback (iasyncresult ar) {	
async callback 

simpledelegate d = new simpledelegate (f);	asynccallback ac = new asynccallback (async_callback);	string state1 = "state1";	int res = 0;	iasyncresult ar1 = d.begininvoke (1, ac, state1);	ar1.asyncwaithandle.waitone ();	try {	res = d.endinvoke (ar1);	} catch (notimplementedexception) {	res = 1;	
received exception ok 

========================= mono sample_522 =========================

}	if (directory.exists (monodroiddir)) setupandroidtargets();	string maccoredir;	if (!directory.exists (maccoredir) && getparentsubdirectorypath ("maccore", out maccoredir)) {	maccoredir = path.combine (maccoredir);	}	if (directory.exists(maccoredir) || genios) setupiostargets();	foreach (var target in targets) {	if (abis.any() && !abis.any (target.triple.contains)) continue;	console.writeline();	
processing triple 

var options = new mono.options.optionset () {	{ "abi=", "abi triple to generate", v => abis.add(v) }, { "o|out=", "output directory", v => outputdir = v }, { "outfile=", "output directory", v => outputfile = v }, { "maccore=", "include directory", v => maccoredir = v }, { "monodroid=", "top monodroid directory", v => monodroiddir = v }, { "android-ndk=", "path to android ndk", v => androidndkpath = v }, { "targetdir=", "path to the directory containing the mono build", v =>targetdir = v }, { "mono=", "include directory", v => monodir = v }, { "gen-ios", "generate ios offsets", v => genios = v != null }, { "h|help",  "show this message and exit",  v => showhelp = v != null }, };	try {	options.parse (args);	}	catch (mono.options.optionexception e) {	console.writeline (e.message);	environment.exit(0);	}	if (showhelp) {	
options 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
ifndef used cross compiler offsets 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
ifdef 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
ifdef 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
ifndef have boehm gc 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
define has cross compiler offsets 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
if defined use cross compile offsets defined mono cross compile 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
if defined disable metadata offsets 

static void dump(astcontext ctx, parsertargetinfo targetinfo, target target) {	string targetfile;	if (!string.isnullorempty (outputfile)) {	targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	
define used cross compiler offsets 

targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	dumpaligns(writer, targetinfo);	dumpsizes(writer, targetinfo);	dumpmetadataoffsets(writer, ctx, target);	
endif dumpjitoffsets writer ctx 

targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	dumpaligns(writer, targetinfo);	dumpsizes(writer, targetinfo);	dumpmetadataoffsets(writer, ctx, target);	
endif writer writeline endif writer writeline endif 

targetfile = outputfile;	} else {	targetfile = target.triple;	if (!string.isnullorempty (outputdir)) targetfile = path.combine (outputdir, targetfile);	targetfile += ".h";	}	using (var writer = new streamwriter(targetfile)) {	dumpaligns(writer, targetinfo);	dumpsizes(writer, targetinfo);	dumpmetadataoffsets(writer, ctx, target);	
generated offsets file 

static void dumpaligns(textwriter writer, parsertargetinfo target) {	var aligns = new[]	{	new { name = "gint8", align = target.charalign}, new { name = "gint16", align = target.shortalign}, new { name = "gint32", align = target.intalign}, new { name = "gint64", align = gettypealign(target, target.int64type)}, new { name = "float", align = target.floatalign}, new { name = "double", align = target.doublealign}, new { name = "gpointer", align = gettypealign(target, target.intptrtype)}, };	
decl 

static void dumpsizes(textwriter writer, parsertargetinfo target) {	var sizes = new[]	{	new { name = "gint8", size = target.charwidth}, new { name = "gint16", size = target.shortwidth}, new { name = "gint32", size = target.intwidth}, new { name = "gint64", size = gettypesize(target, target.int64type)}, new { name = "float", size = target.floatwidth}, new { name = "double", size = target.doublewidth}, new { name = "gpointer", size = gettypesize(target, target.intptrtype)}, };	
decl 

static void dumpjitoffsets(textwriter writer, astcontext ctx) {	
ifndef disable jit offsets 

static void dumpjitoffsets(textwriter writer, astcontext ctx) {	
define used cross compiler offsets 

static void dumpjitoffsets(textwriter writer, astcontext ctx) {	var types = new[]	{	"monolmf", "monomethodruntimegenericcontext", "monojittlsdata", "monogsharedvtmethodruntimeinfo", "monocontinuation", "monocontext", "monodelegatetrampinfo", };	dumpclasses(writer, ctx, types);	var optionaltypes = new[]	{	"gsharedvtcallinfo", "seqpointinfo", "dyncallargs", "monolmftramp", "callcontext" };	dumpclasses(writer, ctx, optionaltypes, optional: true);	
endif 

static void dumpstruct(textwriter writer, class @class) {	var name = @class.name;	if (name.startswith ("_", stringcomparison.ordinal)) name = name.substring (1);	foreach (var field in @class.fields) {	if (field.isbitfield) continue;	if (name == "sgenthreadinfo" && field.name == "regs") continue;	var layout = @class.layout.fields.first(f => f.fieldptr == field.originalptr);	
decl 

========================= mono sample_19 =========================

protected override void onpaint (painteventargs pevent) {	
ourlabeltwoareas pevents pos size 

protected override void onpaint (painteventargs pevent) {	
ourlabeloverflows pevents pos size 

========================= mono sample_21336 =========================

static object selectaggregate (idbconnection cnc, string agg) {	idbcommand selectcommand = cnc.createcommand();	object data;	
aggregate 

static object selectaggregate (idbconnection cnc, string agg) {	idbcommand selectcommand = cnc.createcommand();	object data;	selectcommand.commandtype = commandtype.text;	selectcommand.commandtext = "select " + agg + "from mono_postgres_test";	data = selectcommand.executescalar ();	
agg result 

static void readresult(idatareader rdr, datatable dt) {	
total columns 

static void readresult(idatareader rdr, datatable dt) {	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	console.writeline();	}	int nrows = 0;	int c = 0;	string output, metadatavalue, datavalue;	
gonna do a read now 

static void readresult(idatareader rdr, datatable dt) {	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	console.writeline();	}	int nrows = 0;	int c = 0;	string output, metadatavalue, datavalue;	while(rdr.read()) {	
row 

for(c = 0; c < rdr.fieldcount; c++) {	datarow dr = dt.rows[c];	metadatavalue = "    col " + c + ": " + dr["columnname"];	if(rdr.isdbnull(c) == true) datavalue = " is null";	else datavalue = ": " + rdr.getvalue(c);	output = metadatavalue + datavalue;	console.writeline(output);	}	nrows++;	}	
total rows retrieved 

static void readdata(idatareader rdr) {	int results = 0;	if(rdr == null) {	
idatareader has a null reference 

static void readdata(idatareader rdr) {	int results = 0;	if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	
result is from a sql command insert update delete records affected 

int results = 0;	if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if(dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	
result is from a select sql query records affected 

if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if(dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	
result set 

do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if(dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	readresult(rdr, dt);	}	} while(rdr.nextresult());	
total result sets 

static void dopostgrestest (idbconnection cnc) {	idatareader reader;	object odatavalue;	
postgres provider specific tests 

static void dopostgrestest (idbconnection cnc) {	idatareader reader;	object odatavalue;	
drop table 

static void dopostgrestest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	
ok 

static void dopostgrestest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	
error don t worry about this one 

static void dopostgrestest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	
create table with all supported types 

static void dopostgrestest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	createtable (cnc);	
ok 

static void dopostgrestest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	createtable (cnc);	
insert values for all known types 

idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	
ok 

idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	
update values 

object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	
ok 

object odatavalue;	try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	
insert values for all known types 

try {	droptable (cnc);	}	catch (pgsqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	
ok 

}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	
select values from the database 

createtable (cnc);	insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	
call executereader with a sql command not insert update delete 

updatedata (cnc);	insertdata (cnc);	selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	
call executereader with a sql command is insert update delete 

selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	
calling stored procedure version 

selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
result 

selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
database server version 

selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
clean up 

selectaggregate (cnc, "min(text_value)");	selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
drop table 

selectaggregate (cnc, "max(int4_value)");	selectaggregate (cnc, "sum(int4_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	droptable (cnc);	
ok 

reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	droptable (cnc);	}	catch(exception e) {	
exception caught 

static void main(string[] args) {	
tests start 

static void main(string[] args) {	
creating pgsqlconnectioin 

static void main(string[] args) {	pgsqlconnection cnc = new pgsqlconnection ();	string connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	
setting connectionstring 

static void main(string[] args) {	pgsqlconnection cnc = new pgsqlconnection ();	string connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	cnc.connectionstring =  connectionstring;	
opening database connection 

static void main(string[] args) {	pgsqlconnection cnc = new pgsqlconnection ();	string connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	cnc.connectionstring =  connectionstring;	cnc.open();	
do tests 

static void main(string[] args) {	pgsqlconnection cnc = new pgsqlconnection ();	string connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	cnc.connectionstring =  connectionstring;	cnc.open();	dopostgrestest(cnc);	
close database connection 

static void main(string[] args) {	pgsqlconnection cnc = new pgsqlconnection ();	string connectionstring = "host=localhost;" + "dbname=test;" + "user=postgres";	cnc.connectionstring =  connectionstring;	cnc.open();	dopostgrestest(cnc);	cnc.close();	
tests done 

========================= mono sample_28415 =========================

var m = a.message;	var sb = new stringbuilder();	if (m != null) {	foreach (var ch in m) sb.appendformat("{0:x4} ", (uint)ch);	} else {	sb.append("null");	}	var expected = tup.item2;	var actual = sb.tostring().trim();	if (actual != expected) {	
attribute on type failed to decode 

var m = a.message;	var sb = new stringbuilder();	if (m != null) {	foreach (var ch in m) sb.appendformat("{0:x4} ", (uint)ch);	} else {	sb.append("null");	}	var expected = tup.item2;	var actual = sb.tostring().trim();	if (actual != expected) {	
expected but got 

========================= mono sample_516 =========================

public void dumpmessages () {	
msg 

========================= mono sample_22209 =========================

public static int main () {	object o = (((simpleattribute)typeof(blah2).getcustomattributes (typeof (simpleattribute), false)[0]).d);	if (o.tostring () != "system.double[]") return 1;	if (((double[])o)[0].gettype () != typeof (double)) return 2;	o = (((simpleattribute)typeof(blah3).getcustomattributes (typeof (simpleattribute), false)[0]).d);	if (o.tostring () != "system.double[]") return 3;	
ok 

========================= mono sample_3060 =========================

public static int main () {	appdomain.currentdomain.assemblyresolve += new resolveeventhandler (myresolveeventhandler);	try {	var a = assembly.load ("test");	foreach (type t in a.gettypes ()) {	
pp 

public static int main () {	appdomain.currentdomain.assemblyresolve += new resolveeventhandler (myresolveeventhandler);	try {	var a = assembly.load ("test");	foreach (type t in a.gettypes ()) {	}	} catch (exception ex) {	
caught exception 

========================= mono sample_456 =========================

public override bool execute () {	xmlinput xmlinput;	if (_query == null) throw new argumentnullexception ("query");	try {	xmlinput = new xmlinput (_xmlinputpath, _xmlcontent);	} catch (exception e) {	if (iscriticalexception (e)) {	throw;	}	
unable to load arguments for the xmlpeek task 

xpathdocument xpathdoc;	try {	using (xmlreader xr = xmlinput.createreader ()) {	xpathdoc = new xpathdocument (xr);	xr.close ();	}	} catch (exception e) {	if (iscriticalexception (e)) {	throw;	}	
input file cannot be opened 

xmlinput.closereader ();	}	xpathnavigator nav = xpathdoc.createnavigator ();	xpathexpression expr = null;	try {	expr = nav.compile (_query);	} catch (exception e) {	if (iscriticalexception (e)) {	throw;	}	
xpath query cannot be loaded 

}	return false;	}	xmlnamespacemanager xmlnamespacemanager = new xmlnamespacemanager (nav.nametable);	try {	loadnamespaces (ref xmlnamespacemanager, _namespaces);	} catch (exception e) {	if (iscriticalexception (e)) {	throw;	}	
unable to process the namespaces argument for the xmlpeek task 

loadnamespaces (ref xmlnamespacemanager, _namespaces);	} catch (exception e) {	if (iscriticalexception (e)) {	throw;	}	return false;	}	try {	expr.setcontext (xmlnamespacemanager);	} catch (xpathexception e) {	
unable to set xpath expression s context 

========================= mono sample_22258 =========================

protected void log(string text) {	_loggerbuffer = _loggerbuffer + "\n" + "ghtbase:logger - " + text;	
ghtbase logger 

========================= mono sample_28603 =========================

public override imessage invoke (imessage request) {	imethodcallmessage call = (imethodcallmessage)request;	
invoke 

public virtual mystruct add (int a, out int c, int b) {	
add 

public long nonvirtual_add (int a, int b) {	
nonvirtual add 

static int main () {	r1 myobj = new r1 ();	int res = 0;	long lres;	myproxy real_proxy = new myproxy (myobj);	r1 o = (r1)real_proxy.gettransparentproxy ();	if (remotingservices.istransparentproxy (null)) return 1;	if (!remotingservices.istransparentproxy (o)) return 2;	
xxxxxxxxxxxx 

static int main () {	r1 myobj = new r1 ();	int res = 0;	long lres;	myproxy real_proxy = new myproxy (myobj);	r1 o = (r1)real_proxy.gettransparentproxy ();	if (remotingservices.istransparentproxy (null)) return 1;	if (!remotingservices.istransparentproxy (o)) return 2;	if (o.gettype () != myobj.gettype ()) return 3;	mystruct myres = o.add (2, out res, 3);	
result 

if (!remotingservices.istransparentproxy (o)) return 2;	if (o.gettype () != myobj.gettype ()) return 3;	mystruct myres = o.add (2, out res, 3);	if (myres.a != 2) return 4;	if (myres.b != 3) return 5;	if (myres.c != 5) return 6;	if (res != 5) return 7;	r1 o2 = new r1 ();	lres = test_call (o2);	lres = test_call (o);	
result 

if (myres.a != 2) return 4;	if (myres.b != 3) return 5;	if (myres.c != 5) return 6;	if (res != 5) return 7;	r1 o2 = new r1 ();	lres = test_call (o2);	lres = test_call (o);	if (lres != 5) return 8;	lres = test_call (o);	o.test_field = 2;	
test field 

if (res != 5) return 7;	r1 o2 = new r1 ();	lres = test_call (o2);	lres = test_call (o);	if (lres != 5) return 8;	lres = test_call (o);	o.test_field = 2;	if (o.test_field != 2) return 9;	remotedelegate1 d1 = new remotedelegate1 (o.add);	mystruct myres2 = d1 (2, out res, 3);	
result 

========================= mono sample_625 =========================

public ienumerable get (int a) {	
sending 

public ienumerable get (int a) {	yield return a;	j = 10;	
sending 

}	if (total != 8) return 1;	total = 0;	foreach (int x in gets (3)){	total += x;	}	if (total != 7) return 2;	s s = new s();	total = 0;	foreach (int x in s.get (100)){	
got 

total = 0;	foreach (int x in s.get (100)){	total += x;	}	if (total != 110) return 3;	total = 0;	foreach (int x in s.gets (1)){	total += x;	}	if (total != 1101) return 4;	
ok 

========================= mono sample_3093 =========================

public static int test1() {	try {	return 8;	} catch (exception) {}	
shouldn t get here 

public static void main() {	test1 ();	test2 ();	try {	return;	} catch (exception) {}	
shouldn t get here 

========================= mono sample_3302 =========================

public void enqueue (xevent xevent) {	if (thread.currentthread != thread) {	
hwnd queue enqueue called from a different thread without locking 

public xevent dequeue () {	if (thread.currentthread != thread) {	
hwnd queue dequeue called from a different thread without locking 

public xevent peek() {	if (thread.currentthread != thread) {	
hwnd queue peek called from a different thread without locking 

========================= mono sample_25808 =========================

static void function () {	
delegate method 

static void async_callback (iasyncresult ar) {	
async callback 

public static void main () {	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	
waiting 

public static void main () {	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	
sleeping 

public static void main () {	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	thread.sleep(1000);	
endinvoke 

public static void main () {	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	thread.sleep(1000);	d.endinvoke(ar1);	
sleeping 

public static void main () {	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	thread.sleep(1000);	d.endinvoke(ar1);	thread.sleep(1000);	
main returns 

========================= mono sample_674 =========================

public static void dumpcodeinfo (imagecodecinfo codec) {	
clsid 

public static void dumpcodeinfo (imagecodecinfo codec) {	
formatid 

public static void dumpcodeinfo (imagecodecinfo codec) {	
codec 

public static void dumpcodeinfo (imagecodecinfo codec) {	
dllname 

public static void dumpcodeinfo (imagecodecinfo codec) {	
extension 

public static void dumpcodeinfo (imagecodecinfo codec) {	
format 

public static void dumpcodeinfo (imagecodecinfo codec) {	
mimetype 

public static void dumpcodeinfo (imagecodecinfo codec) {	
flags 

public static void dumpcodeinfo (imagecodecinfo codec) {	
version 

public static void main(string[] args) {	imagecodecinfo[] decoders =  imagecodecinfo.getimagedecoders();	imagecodecinfo[] encoders =  imagecodecinfo.getimageencoders();	
encoders 

public static void main(string[] args) {	imagecodecinfo[] decoders =  imagecodecinfo.getimagedecoders();	imagecodecinfo[] encoders =  imagecodecinfo.getimageencoders();	for (int i = 0; i < encoders.length; i++) {	dumpcodeinfo (encoders[i]);	console.writeline ("---");	}	
decoders 

========================= mono sample_21302 =========================

}	t1.join();	t2.join();	t3.join();	threadvalue = (s_threadsum[0] + s_threadsum[1] + s_threadsum[2]);	if (((long)54018518 * 3) != threadvalue) {	console.writeline("false: {0} != {1}", ((long)439201 * 3), threadvalue);	return 0;	}	else {	
pass 

========================= mono sample_734 =========================

long b = 2;	objectinfo aa = new objectinfo ();	aa.code = a;	objectinfo bb = new objectinfo ();	bb.code = b;	objects.add (aa);	objects.add (bb);	int r1 = objects[0].code.compareto (objects[1].code);	int r2 = a.compareto (b);	if (r1 != r2) {	
fail 

aa.code = a;	objectinfo bb = new objectinfo ();	bb.code = b;	objects.add (aa);	objects.add (bb);	int r1 = objects[0].code.compareto (objects[1].code);	int r2 = a.compareto (b);	if (r1 != r2) {	return 1;	}	
ok 

========================= mono sample_3312 =========================

var optionset = new optionset {	{"help", "show this help.", v => showoptions = v != null}, {"assembly=", "assembly to check.", v => options.assembly = v}, {"method=", "method name (if you want to check only it).", v => options.method = v}, {"debug=", "show debug information", v=> options.showdebug = v != null}	};	try {	optionset.parse (args);	} catch (optionexception e) {	showoptions = true;	showmsg = e.message;	}	if (showoptions) {	
cccheck 

{"help", "show this help.", v => showoptions = v != null}, {"assembly=", "assembly to check.", v => options.assembly = v}, {"method=", "method name (if you want to check only it).", v => options.method = v}, {"debug=", "show debug information", v=> options.showdebug = v != null}	};	try {	optionset.parse (args);	} catch (optionexception e) {	showoptions = true;	showmsg = e.message;	}	if (showoptions) {	console.writeline ();	
options 

console.writeline ();	if (showmsg != null) {	console.writeline (showmsg);	console.writeline ();	}	return;	}	checkresults results = checker.check (options);	console.writeline ();	if (results.anyerrors) {	
error 

console.writeline (showmsg);	console.writeline ();	}	return;	}	checkresults results = checker.check (options);	console.writeline ();	if (results.anyerrors) {	}	if (results.anywarnings) {	
warning 

}	checkresults results = checker.check (options);	console.writeline ();	if (results.anyerrors) {	}	if (results.anywarnings) {	}	if (results.results != null) {	foreach (var methodvalidationresults in results.results) {	string methodname = methodvalidationresults.key;	
method 

if (results.anywarnings) {	}	if (results.results != null) {	foreach (var methodvalidationresults in results.results) {	string methodname = methodvalidationresults.key;	foreach (string result in methodvalidationresults.value) console.writeline ("  " + result);	console.writeline ();	}	}	console.writeline ();	
done 

========================= mono sample_1217 =========================

private static byte[] timeouthandler (socket socket) {	socket.receive (new byte[4096]);	thread.sleep (three_seconds_in_milliseconds * 2);	var sw = new stringwriter ();	
http ok 

private static byte[] timeouthandler (socket socket) {	socket.receive (new byte[4096]);	thread.sleep (three_seconds_in_milliseconds * 2);	var sw = new stringwriter ();	
content type text plain 

private static byte[] timeouthandler (socket socket) {	socket.receive (new byte[4096]);	thread.sleep (three_seconds_in_milliseconds * 2);	var sw = new stringwriter ();	
content length 

}	}	ms.flush ();	ms.position = 0;	string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	stringwriter sw = new stringwriter ();	if (statusline.startswith ("post /original/")) {	
http found 

}	ms.flush ();	ms.position = 0;	string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	stringwriter sw = new stringwriter ();	if (statusline.startswith ("post /original/")) {	endpoint ep = socket.localendpoint;	
location http sw writeline 

ms.position = 0;	string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	stringwriter sw = new stringwriter ();	if (statusline.startswith ("post /original/")) {	endpoint ep = socket.localendpoint;	sw.flush ();	} else if (statusline.startswith ("get /moved/")) {	
http ok 

ms.position = 0;	string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	stringwriter sw = new stringwriter ();	if (statusline.startswith ("post /original/")) {	endpoint ep = socket.localendpoint;	sw.flush ();	} else if (statusline.startswith ("get /moved/")) {	
content type text plain 

ms.position = 0;	string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	stringwriter sw = new stringwriter ();	if (statusline.startswith ("post /original/")) {	endpoint ep = socket.localendpoint;	sw.flush ();	} else if (statusline.startswith ("get /moved/")) {	
content length 

}	stringwriter sw = new stringwriter ();	if (statusline.startswith ("post /original/")) {	endpoint ep = socket.localendpoint;	sw.flush ();	} else if (statusline.startswith ("get /moved/")) {	sw.writeline ();	sw.write ("looks ok");	sw.flush ();	} else {	
http too lazy 

int bytesreceived = socket.receive (buffer);	while (bytesreceived > 0) {	thread.sleep (200);	if (socket.available > 0) {	bytesreceived = socket.receive (buffer);	} else {	bytesreceived = 0;	}	}	stringwriter sw = new stringwriter ();	
http too lazy 

int bytesreceived = socket.receive (buffer);	while (bytesreceived > 0) {	thread.sleep (200);	if (socket.available > 0) {	bytesreceived = socket.receive (buffer);	} else {	bytesreceived = 0;	}	}	stringwriter sw = new stringwriter ();	
content length 

static byte [] nocontentlengthhandler (socket socket) {	stringwriter sw = new stringwriter ();	
http too lazy 

static byte [] notmodifiedsincehandler (socket socket) {	stringwriter sw = new stringwriter ();	
http not modified 

static byte [] notmodifiedsincehandler (socket socket) {	stringwriter sw = new stringwriter ();	
date fri feb gmt 

static byte [] notmodifiedsincehandler (socket socket) {	stringwriter sw = new stringwriter ();	
server apache debian php with suhosin patch mod ssl openssl 

static byte [] notmodifiedsincehandler (socket socket) {	stringwriter sw = new stringwriter ();	
not modified since sun feb gmt 

static byte [] notmodifiedsincehandler (socket socket) {	stringwriter sw = new stringwriter ();	
etag 

static byte [] notmodifiedsincehandler (socket socket) {	stringwriter sw = new stringwriter ();	
connection close 

string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	string verb = "default";	if (statusline != null) {	string [] parts = statusline.split (' ');	if (parts.length > 0) verb = parts [0];	}	stringwriter sw = new stringwriter ();	
http ok 

string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	string verb = "default";	if (statusline != null) {	string [] parts = statusline.split (' ');	if (parts.length > 0) verb = parts [0];	}	stringwriter sw = new stringwriter ();	
content type text plain 

string statusline = null;	using (streamreader sr = new streamreader (ms, encoding.utf8)) {	statusline = sr.readline ();	}	string verb = "default";	if (statusline != null) {	string [] parts = statusline.split (' ');	if (parts.length > 0) verb = parts [0];	}	stringwriter sw = new stringwriter ();	
content length 

statusline = l;	} else if (l.startswith ("authorization:")) {	have_auth = true;	} else if (l.startswith ("content-length:")) {	cl = int32.parse (l.substring ("content-length: ".length));	}	}	}	stringwriter sw = new stringwriter ();	if (!have_auth) {	
http invalid credentials 

statusline = l;	} else if (l.startswith ("authorization:")) {	have_auth = true;	} else if (l.startswith ("content-length:")) {	cl = int32.parse (l.substring ("content-length: ".length));	}	}	}	stringwriter sw = new stringwriter ();	if (!have_auth) {	
www authenticate basic yeah 

} else if (l.startswith ("content-length:")) {	cl = int32.parse (l.substring ("content-length: ".length));	}	}	}	stringwriter sw = new stringwriter ();	if (!have_auth) {	sw.writeline ();	sw.flush ();	} else if (cl > 0 && statusline.startswith ("post ")) {	
http ok 

} else if (l.startswith ("content-length:")) {	cl = int32.parse (l.substring ("content-length: ".length));	}	}	}	stringwriter sw = new stringwriter ();	if (!have_auth) {	sw.writeline ();	sw.flush ();	} else if (cl > 0 && statusline.startswith ("post ")) {	
content type text plain 

} else if (l.startswith ("content-length:")) {	cl = int32.parse (l.substring ("content-length: ".length));	}	}	}	stringwriter sw = new stringwriter ();	if (!have_auth) {	sw.writeline ();	sw.flush ();	} else if (cl > 0 && statusline.startswith ("post ")) {	
content length 

}	stringwriter sw = new stringwriter ();	if (!have_auth) {	sw.writeline ();	sw.flush ();	} else if (cl > 0 && statusline.startswith ("post ")) {	sw.writeline ();	sw.write ("looks ok");	sw.flush ();	} else {	
http test failed 

}	stringwriter sw = new stringwriter ();	if (!have_auth) {	sw.writeline ();	sw.flush ();	} else if (cl > 0 && statusline.startswith ("post ")) {	sw.writeline ();	sw.write ("looks ok");	sw.flush ();	} else {	
content length 

========================= mono sample_23306 =========================

public static int main () {	button b = new button ();	b.clicked += delegate {	
this worked 

========================= mono sample_3192 =========================

static void taskscheduler_unobservedtaskexception (object sender, unobservedtaskexceptioneventargs e) {	unobserved = true;	
unobserved 

========================= mono sample_3161 =========================

public static int test_0_load_reference_bytes () {	byte[] bs = file.readallbytes ("./testingreferenceassembly.dll");	try {	var a = assembly.load (bs);	} catch (badimageformatexception) {	return 0;	} catch (filenotfoundexception exn) {	
incorrect exn was 

========================= mono sample_417 =========================

public static void main(string[] args) {	var foo = new foo();	system.console.writeline(foo.bar());	
world 

public static void main(string[] args) {	var foo = new foo();	system.console.writeline(foo.bar());	var goo = new goo();	
hello 

public static void main(string[] args) {	var foo = new foo();	system.console.writeline(foo.bar());	var goo = new goo();	var foo2 = new foo2();	
hello 

========================= mono sample_786 =========================

public static void test_callback (object state) {	int workerthreads;	int completionportthreads;	threadpool.getavailablethreads (out workerthreads, out completionportthreads);	
test casllback ath 

public static int main () {	int workerthreads;	int completionportthreads;	int runs = 10;	threadpool.getmaxthreads (out workerthreads, out completionportthreads);	
workerthreads completionportthreads 

public static int main () {	int workerthreads;	int completionportthreads;	int runs = 10;	threadpool.getmaxthreads (out workerthreads, out completionportthreads);	threadpool.getavailablethreads (out workerthreads, out completionportthreads);	
workerthreads completionportthreads 

threadpool.queueuserworkitem (new waitcallback (test_callback), "test1 " + i);	threadpool.queueuserworkitem (new waitcallback (test_callback), "test2 " + i);	threadpool.queueuserworkitem (new waitcallback (test_callback), "test3 " + i);	threadpool.queueuserworkitem (new waitcallback (test_callback), "test4 " + i);	threadpool.queueuserworkitem (new waitcallback (test_callback), "test5 " + i);	do {	threadpool.getavailablethreads (out workerthreads, out completionportthreads);	if (workerthreads == 0) thread.sleep (100);	} while (workerthreads == 0);	threadpool.getavailablethreads (out workerthreads, out completionportthreads);	
workerthreads completionportthreads 

threadpool.queueuserworkitem (new waitcallback (test_callback), "test5 " + i);	do {	threadpool.getavailablethreads (out workerthreads, out completionportthreads);	if (workerthreads == 0) thread.sleep (100);	} while (workerthreads == 0);	threadpool.getavailablethreads (out workerthreads, out completionportthreads);	}	while (csum < (runs * 5)) {	thread.sleep (100);	}	
csum 

========================= mono sample_557 =========================

public datatable getdatatablebyschemaaction(dataset dataset, missingschemaaction schemaaction) {	if (null == dataset) {	throw adp.argumentnull("dataset");	}	string datasettable = datasettable;	if (adp.isempty(datasettable)) {	#if debug if (adapterswitches.dataschema.tracewarning) {	
explicit filtering of sourcetable sourcetable 

string datasettable = datasettable;	if (adp.isempty(datasettable)) {	#if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	}	datatablecollection tables = dataset.tables;	int index = tables.indexof(datasettable);	if ((0 <= index) && (index < tables.count)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	
schema match on datatable datasettable 

}	datatablecollection tables = dataset.tables;	int index = tables.indexof(datasettable);	if ((0 <= index) && (index < tables.count)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return tables[index];	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	
schema add of datatable datasettable 

if ((0 <= index) && (index < tables.count)) {	#if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return tables[index];	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatable(datasettable);	case missingschemaaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	
schema filter of datatable datasettable 

#endif return tables[index];	}	switch (schemaaction) {	case missingschemaaction.add: case missingschemaaction.addwithkey: #if debug if (adapterswitches.dataschema.traceinfo) {	}	#endif return new datatable(datasettable);	case missingschemaaction.ignore: #if debug if (adapterswitches.dataschema.tracewarning) {	}	#endif return null;	case missingschemaaction.error: #if debug if (adapterswitches.dataschema.traceerror) {	
schema error on datatable datasettable 

========================= mono sample_14320 =========================

static void test2(x x) {	
object 

static int main() {	try {	inner ();	} catch (typeloadexception e) {	
got correct exception 

========================= mono sample_446 =========================

public void assertareequal(string[] want, string[] got, string name) {	if (want.length == got.length) {	for (int i=0; i < want.length; i++) {	if (want[i] != got[i]) {	
expected got 

========================= mono sample_25479 =========================

public static void main(string[] args) {	
this works 

public static void main(string[] args) {	works w = new works(3.0);	w[0, 0] += 3.0;	
this breaks 

========================= mono sample_697 =========================

fieldinfo fi = typeof (test).getfield ("field");	if (fi.getcustomattributes (true).length != 0) return 1;	type[] t = fi.getrequiredcustommodifiers ();	if (t.length != 1) return 2;	if (t [0] != typeof (system.runtime.compilerservices.isvolatile)) return 3;	fi = typeof (gtest<>).getfield ("str");	if (fi.getcustomattributes (true).length != 0) return 10;	t = fi.getrequiredcustommodifiers ();	if (t.length != 1) return 11;	if (t [0] != typeof (system.runtime.compilerservices.isvolatile)) return 12;	
ok 

========================= mono sample_3070 =========================

static private void help () {	
usage setreg options feature true false 

static private void help () {	
feature 

static private void help () {	
trust the test root certificates ms and mono 

static private void help () {	
other features aren t currently supported 

static private void help () {	
other options 

static private void help () {	
q quit mode no display 

static private void help () {	
display this help message 

string msg = "false";	if (ms && mono) {	msg = "true";	}	else if (mono) {	msg = "only mono";	}	else if (ms) {	msg = "only ms";	}	
trusting test roots mono and microsoft 

static void main (string[] args) {	int n = args.length;	if (n < 2) {	header ();	
current configuration 

========================= mono sample_1175 =========================

public static void main(string[] args) {	
start testsqlconnection 

public static void main(string[] args) {	if (args.length != 6 && args.length != 7) {	
usage mono testsqlconnection exe client table column server database userid password client is one of the following sqlclient tdsclient or sybaseclient client is sqlclient no support for tdsclient nor sybaseclient table is the name of the database table to select from column is the name of the column in the table to select from server is the sql server to connect use one of the following forms hostname ex myhost hostname port ex myhost hostname instance ex myhost etsdk note only works with sqlclient database is the name of the database to use user id is the user s user id password is the user s password note if ommitted a blank password is used exampes ex sqlclient employee lname myhost pubs myuserid mypassword ex sqlclient employee lname myhost pubs myuserid mypassword ex sqlclient products productname myhost etsdk myuserid mypassword ex sqlclient employee lname myhost pubs myuserid ex tdsclient sometable somecolumn myhost test myuserid mypassword ex sybaseclient sometable somecolumn myhost test myuserid mypassword 

string client = args[0];	string tablename = args[1];	string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	
client 

string client = args[0];	string tablename = args[1];	string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	
table name 

string client = args[0];	string tablename = args[1];	string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	
column name 

string client = args[0];	string tablename = args[1];	string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	
server 

string client = args[0];	string tablename = args[1];	string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	
database 

string client = args[0];	string tablename = args[1];	string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	
user id 

string client = args[0];	string tablename = args[1];	string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	
password 

string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	sql = "select " + columnname + " from " + tablename;	constr = "server=" + server + ";" + "database=" + database + ";" + "user id=" + userid + ";" + "password=" + password + ";";	
connectionstring 

string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	sql = "select " + columnname + " from " + tablename;	constr = "server=" + server + ";" + "database=" + database + ";" + "user id=" + userid + ";" + "password=" + password + ";";	
sql 

string columnname = args[2];	string server = args[3];	string database = args[4];	string userid = args[5];	string password = "";	if (args.length == 7) password  = args[6];	string constr;	string sql;	sql = "select " + columnname + " from " + tablename;	constr = "server=" + server + ";" + "database=" + database + ";" + "user id=" + userid + ";" + "password=" + password + ";";	
creating connection 

sql = "select " + columnname + " from " + tablename;	constr = "server=" + server + ";" + "database=" + database + ";" + "user id=" + userid + ";" + "password=" + password + ";";	idbconnection con = null;	switch (client.toupper()) {	case "sqlclient": con = new sqlconnection();	break;	#if includesybaseandtdsclient case "tdsclient": con = new tdsconnection();	break;	case "sybaseclient": con = new sybaseconnection();	break;	
invalid client use sqlclient tdsclient or sybaseclient 

constr = "server=" + server + ";" + "database=" + database + ";" + "user id=" + userid + ";" + "password=" + password + ";";	idbconnection con = null;	switch (client.toupper()) {	case "sqlclient": con = new sqlconnection();	break;	#if includesybaseandtdsclient case "tdsclient": con = new tdsconnection();	break;	case "sybaseclient": con = new sybaseconnection();	break;	return;	
invalid client use sqlclient no support for tdsclient nor sybaseclient 

switch (client.toupper()) {	case "sqlclient": con = new sqlconnection();	break;	#if includesybaseandtdsclient case "tdsclient": con = new tdsconnection();	break;	case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	
set connection string 

case "sqlclient": con = new sqlconnection();	break;	#if includesybaseandtdsclient case "tdsclient": con = new tdsconnection();	break;	case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	
open connection 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
sqlexception caught 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
message 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
procedure 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
class 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
number 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
source 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
state 

case "sybaseclient": con = new sybaseconnection();	break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	
errors 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
sqlerror 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
message 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
line number 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
procedure 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
class 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
number 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
server 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
source 

break;	return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	
state 

return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	
stacktrace 

return;	return;	#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	
targetsite 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
innerexception 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
message 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
class 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
number 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
source 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
state 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
stacktrace 

#endif }	con.connectionstring = constr;	try {	con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	
targetsite 

con.open();	}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	}	return;	}	
creating command 

}	catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	}	return;	}	idbcommand cmd = con.createcommand();	
set sql 

catch(sqlexception se) {	foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	}	return;	}	idbcommand cmd = con.createcommand();	cmd.commandtext = sql;	
execute reader 

foreach(sqlerror error in se.errors) {	}	exception ie = se.innerexception;	if(ie != null) {	}	return;	}	idbcommand cmd = con.createcommand();	cmd.commandtext = sql;	idatareader reader = cmd.executereader();	
read first row 

}	exception ie = se.innerexception;	if(ie != null) {	}	return;	}	idbcommand cmd = con.createcommand();	cmd.commandtext = sql;	idatareader reader = cmd.executereader();	if(reader.read()) {	
value 

if(ie != null) {	}	return;	}	idbcommand cmd = con.createcommand();	cmd.commandtext = sql;	idatareader reader = cmd.executereader();	if(reader.read()) {	}	else {	
no data returned or either no permission to read data 

}	return;	}	idbcommand cmd = con.createcommand();	cmd.commandtext = sql;	idatareader reader = cmd.executereader();	if(reader.read()) {	}	else {	}	
clean up 

if(reader.read()) {	}	else {	}	reader.close();	reader = null;	cmd.dispose();	cmd = null;	con.close();	con = null;	
done 

========================= mono sample_28405 =========================

public static void method(int value) {	
method 

========================= mono sample_650 =========================

public void run () {	try {	parse ();	serialize ();	} catch (exception) {	
internal error at line 

private void serialize () {	console.writeline ("static readonly int [] collelem = new int [] {");	dumparray (collelem, collationelementtableutil.indexer.totalcount, true);	console.writeline ("};");	console.writeline ("static readonly sortkeyvalue [] keyvalues = new sortkeyvalue [] {");	for (int i = 0; i < keycount; i++) {	sortkeyvalue s = keyvalues [i];	
new sortkeyvalue true false 

while (reader.peek () != -1) {	string line = reader.readline ();	linecount++;	if (line.startswith ("@")) continue;	int idx = line.indexof ('#');	if (idx >= 0) line = line.substring (0, idx);	if (line.length == 0) continue;	int cp = int.parse (line.substring (0, 5), numberstyles.hexnumber);	int collelemidx = collationelementtableutil.indexer.toindex (cp);	if (collelemidx < 0) {	
warning handle character x in collation element table 

========================= mono sample_27869 =========================

private void thread_func() {	
thread in a thread 

private void thread_func() {	thread.sleep(10000);	
thread waiting for mon 

private void thread_func() {	thread.sleep(10000);	monitor.enter(mon);	monitor.pulse(mon);	
thread pulsed mon 

private void thread_func() {	thread.sleep(10000);	monitor.enter(mon);	monitor.pulse(mon);	monitor.exit(mon);	thread.sleep(10000);	monitor.enter(reply);	
thread got reply mutex 

private void thread_func() {	thread.sleep(10000);	monitor.enter(mon);	monitor.pulse(mon);	monitor.exit(mon);	thread.sleep(10000);	monitor.enter(reply);	monitor.pulse(reply);	
thread pulsed reply 

public static int main () {	
main hello world 

public static int main () {	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	
main mon lock 

public static int main () {	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	monitor.enter(mon);	
main mon lock 

public static int main () {	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	monitor.enter(mon);	
main waiting for mon 

public static int main () {	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	monitor.enter(mon);	monitor.wait(mon);	
main mon waited 

public static int main () {	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	monitor.enter(mon);	monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	
main reply locked 

public static int main () {	test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	monitor.enter(mon);	monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	
main reply locked 

test test = new test();	thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	monitor.enter(mon);	monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	
main reply locked 

thread thr=new thread(new threadstart(test.thread_func));	thr.start();	monitor.enter(mon);	monitor.enter(mon);	monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	
main reply locked 

thr.start();	monitor.enter(mon);	monitor.enter(mon);	monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	
main reply waited 

monitor.enter(mon);	monitor.enter(mon);	monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	
seeing how many locks we have 

monitor.enter(mon);	monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	
main exit reply 

monitor.wait(mon);	monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	
main exit reply 

monitor.exit(mon);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	
main exit reply 

monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	
main exit reply 

monitor.enter(reply);	monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	
main exit reply 

monitor.enter(reply);	monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	
main exit reply 

monitor.enter(reply);	monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	
main exit reply 

monitor.wait(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(reply);	monitor.exit(bogus);	
main exit bogus 

========================= mono sample_532 =========================

private void printtableorview (dataview dv, string label) {	console.writeline ("\n" + label);	
sort key 

public void complexeventsequence2 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. ---- onlistchanged reset,-1,-1 added tables to dataset ---- onlistchanged propertydescriptoradded,0,0 added relation 1 ---- onlistchanged propertydescriptoradded,0,0 added relation 2 ---- onlistchanged propertydescriptordeleted,0,0 removed relation 2 ";	eventwriter = new stringwriter ();	dataset ds = new dataset ();	datatable dt = new datatable ("table");	datatable dt2 = new datatable ("table2");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	
added 

public void complexeventsequence2 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. ---- onlistchanged reset,-1,-1 added tables to dataset ---- onlistchanged propertydescriptoradded,0,0 added relation 1 ---- onlistchanged propertydescriptoradded,0,0 added relation 2 ---- onlistchanged propertydescriptordeleted,0,0 removed relation 2 ";	eventwriter = new stringwriter ();	dataset ds = new dataset ();	datatable dt = new datatable ("table");	datatable dt2 = new datatable ("table2");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	
added 

public void complexeventsequence2 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. ---- onlistchanged reset,-1,-1 added tables to dataset ---- onlistchanged propertydescriptoradded,0,0 added relation 1 ---- onlistchanged propertydescriptoradded,0,0 added relation 2 ---- onlistchanged propertydescriptordeleted,0,0 removed relation 2 ";	eventwriter = new stringwriter ();	dataset ds = new dataset ();	datatable dt = new datatable ("table");	datatable dt2 = new datatable ("table2");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	
added 

datatable dt2 = new datatable ("table2");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt2.columns.add ("col1");	dt2.columns.add ("col2");	dt2.columns.add ("col3");	ds.tables.add (dt);	ds.tables.add (dt2);	
added tables to dataset 

complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt2.columns.add ("col1");	dt2.columns.add ("col2");	dt2.columns.add ("col3");	ds.tables.add (dt);	ds.tables.add (dt2);	ds.relations.add ("relation", dt.columns ["col1"], dt2.columns ["col1"]);	
added relation 

dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt2.columns.add ("col1");	dt2.columns.add ("col2");	dt2.columns.add ("col3");	ds.tables.add (dt);	ds.tables.add (dt2);	ds.relations.add ("relation", dt.columns ["col1"], dt2.columns ["col1"]);	datarelation dr = ds.relations.add ("relation2", dt2.columns ["col2"], dt.columns ["col2"]);	
added relation 

dt.columns.add ("col2");	dt.columns.add ("col3");	dt2.columns.add ("col1");	dt2.columns.add ("col2");	dt2.columns.add ("col3");	ds.tables.add (dt);	ds.tables.add (dt2);	ds.relations.add ("relation", dt.columns ["col1"], dt2.columns ["col1"]);	datarelation dr = ds.relations.add ("relation2", dt2.columns ["col2"], dt.columns ["col2"]);	ds.relations.remove (dr);	
removed relation 

public void complexeventsequence1 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. uniq added. ----- updateindex : true ---- onlistchanged reset,-1,-1 sort changed. ---- onlistchanged propertydescriptordeleted,0,0 col3 removed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowfilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,3,-1 addnew() invoked. 4 ---- onlistchanged itemdeleted,3,-1 ---- onlistchanged itemmoved,-2147483648,3 endedit() invoked. 3 ---- onlistchanged itemmoved,0,-2147483648 value changed to appear. 4 ---- onlistchanged itemmoved,3,0 value moved. 4 ---- onlistchanged itemmoved,1,3 value moved again. 4 ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table changed. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	
added 

public void complexeventsequence1 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. uniq added. ----- updateindex : true ---- onlistchanged reset,-1,-1 sort changed. ---- onlistchanged propertydescriptordeleted,0,0 col3 removed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowfilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,3,-1 addnew() invoked. 4 ---- onlistchanged itemdeleted,3,-1 ---- onlistchanged itemmoved,-2147483648,3 endedit() invoked. 3 ---- onlistchanged itemmoved,0,-2147483648 value changed to appear. 4 ---- onlistchanged itemmoved,3,0 value moved. 4 ---- onlistchanged itemmoved,1,3 value moved again. 4 ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table changed. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	
added 

public void complexeventsequence1 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. uniq added. ----- updateindex : true ---- onlistchanged reset,-1,-1 sort changed. ---- onlistchanged propertydescriptordeleted,0,0 col3 removed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowfilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,3,-1 addnew() invoked. 4 ---- onlistchanged itemdeleted,3,-1 ---- onlistchanged itemmoved,-2147483648,3 endedit() invoked. 3 ---- onlistchanged itemmoved,0,-2147483648 value changed to appear. 4 ---- onlistchanged itemmoved,3,0 value moved. 4 ---- onlistchanged itemmoved,1,3 value moved again. 4 ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table changed. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	
added 

public void complexeventsequence1 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. uniq added. ----- updateindex : true ---- onlistchanged reset,-1,-1 sort changed. ---- onlistchanged propertydescriptordeleted,0,0 col3 removed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowfilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,3,-1 addnew() invoked. 4 ---- onlistchanged itemdeleted,3,-1 ---- onlistchanged itemmoved,-2147483648,3 endedit() invoked. 3 ---- onlistchanged itemmoved,0,-2147483648 value changed to appear. 4 ---- onlistchanged itemmoved,3,0 value moved. 4 ---- onlistchanged itemmoved,1,3 value moved again. 4 ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table changed. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	
uniq added 

public void complexeventsequence1 () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. uniq added. ----- updateindex : true ---- onlistchanged reset,-1,-1 sort changed. ---- onlistchanged propertydescriptordeleted,0,0 col3 removed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowfilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,3,-1 addnew() invoked. 4 ---- onlistchanged itemdeleted,3,-1 ---- onlistchanged itemmoved,-2147483648,3 endedit() invoked. 3 ---- onlistchanged itemmoved,0,-2147483648 value changed to appear. 4 ---- onlistchanged itemmoved,3,0 value moved. 4 ---- onlistchanged itemmoved,1,3 value moved again. 4 ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table changed. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	
sort changed 

string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 col1 added. ---- onlistchanged propertydescriptoradded,0,0 col2 added. ---- onlistchanged propertydescriptoradded,0,0 col3 added. uniq added. ----- updateindex : true ---- onlistchanged reset,-1,-1 sort changed. ---- onlistchanged propertydescriptordeleted,0,0 col3 removed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowfilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ----- updateindex : true ---- onlistchanged reset,-1,-1 rowstatefilter changed. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,0,-1 added row to rows. ---- onlistchanged itemadded,3,-1 addnew() invoked. 4 ---- onlistchanged itemdeleted,3,-1 ---- onlistchanged itemmoved,-2147483648,3 endedit() invoked. 3 ---- onlistchanged itemmoved,0,-2147483648 value changed to appear. 4 ---- onlistchanged itemmoved,3,0 value moved. 4 ---- onlistchanged itemmoved,1,3 value moved again. 4 ---- onlistchanged propertydescriptorchanged,0,0 ----- updateindex : true ---- onlistchanged reset,-1,-1 table changed. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	
removed 

eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	dv.rowfilter = "col1 <> 0";	
rowfilter changed 

datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	dv.rowfilter = "col1 <> 0";	dv.rowstatefilter = dataviewrowstate.deleted;	
rowstatefilter changed 

complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	dv.rowfilter = "col1 <> 0";	dv.rowstatefilter = dataviewrowstate.deleted;	dv.rowstatefilter = dataviewrowstate.currentrows;	
rowstatefilter changed 

dt.columns.add ("col1");	dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	dv.rowfilter = "col1 <> 0";	dv.rowstatefilter = dataviewrowstate.deleted;	dv.rowstatefilter = dataviewrowstate.currentrows;	dt.rows.add (new object [] {1, 3});	
added row to rows 

dt.columns.add ("col2");	dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	dv.rowfilter = "col1 <> 0";	dv.rowstatefilter = dataviewrowstate.deleted;	dv.rowstatefilter = dataviewrowstate.currentrows;	dt.rows.add (new object [] {1, 3});	dt.rows.add (new object [] {2, 2});	
added row to rows 

dt.columns.add ("col3");	dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	dv.rowfilter = "col1 <> 0";	dv.rowstatefilter = dataviewrowstate.deleted;	dv.rowstatefilter = dataviewrowstate.currentrows;	dt.rows.add (new object [] {1, 3});	dt.rows.add (new object [] {2, 2});	dt.rows.add (new object [] {3, 1});	
added row to rows 

dt.constraints.add (new uniqueconstraint (dt.columns [0]));	dv.sort = "col2";	dt.columns.remove ("col3");	dv.rowfilter = "col1 <> 0";	dv.rowstatefilter = dataviewrowstate.deleted;	dv.rowstatefilter = dataviewrowstate.currentrows;	dt.rows.add (new object [] {1, 3});	dt.rows.add (new object [] {2, 2});	dt.rows.add (new object [] {3, 1});	datarowview drv = dv.addnew ();	
addnew invoked 

dv.rowfilter = "col1 <> 0";	dv.rowstatefilter = dataviewrowstate.deleted;	dv.rowstatefilter = dataviewrowstate.currentrows;	dt.rows.add (new object [] {1, 3});	dt.rows.add (new object [] {2, 2});	dt.rows.add (new object [] {3, 1});	datarowview drv = dv.addnew ();	eventwriter.writeline (dv.count);	drv [0] = 0;	drv.endedit ();	
endedit invoked 

dv.rowstatefilter = dataviewrowstate.currentrows;	dt.rows.add (new object [] {1, 3});	dt.rows.add (new object [] {2, 2});	dt.rows.add (new object [] {3, 1});	datarowview drv = dv.addnew ();	eventwriter.writeline (dv.count);	drv [0] = 0;	drv.endedit ();	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [0] = 4;	
value changed to appear 

dt.rows.add (new object [] {2, 2});	dt.rows.add (new object [] {3, 1});	datarowview drv = dv.addnew ();	eventwriter.writeline (dv.count);	drv [0] = 0;	drv.endedit ();	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [0] = 4;	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [1] = 4;	
value moved 

datarowview drv = dv.addnew ();	eventwriter.writeline (dv.count);	drv [0] = 0;	drv.endedit ();	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [0] = 4;	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [1] = 4;	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [1] = 1.5;	
value moved again 

drv [0] = 0;	drv.endedit ();	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [0] = 4;	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [1] = 4;	eventwriter.writeline (dv.count);	dt.rows [dt.rows.count - 1] [1] = 1.5;	eventwriter.writeline (dv.count);	dv.table = new datatable ("table2");	
table changed 

public void defaultcolumnnameaddlistchangedtest () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ();	
default named column added 

public void defaultcolumnnameaddlistchangedtest () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ();	dt.columns.add ("non-defaultnamedcolumn");	
non default named column added 

public void defaultcolumnnameaddlistchangedtest () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ();	dt.columns.add ("non-defaultnamedcolumn");	datacolumn c = dt.columns.add ();	
another default named column added 

public void defaultcolumnnameaddlistchangedtest () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ();	dt.columns.add ("non-defaultnamedcolumn");	datacolumn c = dt.columns.add ();	dt.columns.add ("column3");	
add a column with the same name as the default columnnames 

public void defaultcolumnnameaddlistchangedtest () {	string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ();	dt.columns.add ("non-defaultnamedcolumn");	datacolumn c = dt.columns.add ();	dt.columns.add ("column3");	dt.columns.add ((string)null);	
add a column with a null name 

string result = @"setting table... ---- onlistchanged propertydescriptorchanged,0,0 ---- onlistchanged reset,-1,-1 table was set. ---- onlistchanged propertydescriptoradded,0,0 default named column added. ---- onlistchanged propertydescriptoradded,0,0 non-default named column added. ---- onlistchanged propertydescriptoradded,0,0 another default named column added (column2). ---- onlistchanged propertydescriptoradded,0,0 add a column with the same name as the default columnnames. ---- onlistchanged propertydescriptoradded,0,0 add a column with a null name. ---- onlistchanged propertydescriptoradded,0,0 add a column with an empty name. ";	eventwriter = new stringwriter ();	datatable dt = new datatable ("table");	complexeventsequence1view dv = new complexeventsequence1view (dt, eventwriter);	dt.columns.add ();	dt.columns.add ("non-defaultnamedcolumn");	datacolumn c = dt.columns.add ();	dt.columns.add ("column3");	dt.columns.add ((string)null);	dt.columns.add ("");	
add a column with an empty name 

public complexeventsequence1view (datatable dt, textwriter w) : base () {	this.w = w;	
setting table 

public complexeventsequence1view (datatable dt, textwriter w) : base () {	this.w = w;	table = dt;	
table was set 

========================= mono sample_28975 =========================

methodinfo mymethodinfo = typeof(console).getmethod("writeline",new type[]{typeof(string)});	myilgenerator.emit(opcodes.call, mymethodinfo);	myilgenerator.emit(opcodes.ret);	type mytype = typeof(myattribute);	constructorinfo myconstructorinfo = mytype.getconstructor(new type[]{typeof(object)});	try {	customattributebuilder methodcabuilder = new customattributebuilder (myconstructorinfo, new object [] { typecode.double } );	myconstructor.setcustomattribute(methodcabuilder);	}	catch(argumentnullexception ex) {	
the following exception has occured 

myilgenerator.emit(opcodes.ret);	type mytype = typeof(myattribute);	constructorinfo myconstructorinfo = mytype.getconstructor(new type[]{typeof(object)});	try {	customattributebuilder methodcabuilder = new customattributebuilder (myconstructorinfo, new object [] { typecode.double } );	myconstructor.setcustomattribute(methodcabuilder);	}	catch(argumentnullexception ex) {	}	catch(exception ex) {	
the following exception has occured 

========================= mono sample_1390 =========================

public static void main() {	thread thr=new thread(new threadstart(foo.thread));	thr.isbackground=true;	thr.start();	thread.sleep(1200);	
main thread returns 

public static void thread() {	try {	
thread running 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

public static void thread() {	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

thread.resetabort();	} finally {	}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	
thread running 

}	try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	} catch(threadabortexception) {	thread.resetabort();	
abort reset 

try {	thread.sleep(500);	} catch(threadabortexception) {	thread.resetabort();	} finally {	}	try {	} catch(threadabortexception) {	thread.resetabort();	} finally {	
threadabortexception finally 

========================= mono sample_472 =========================

int verbose = 0;	foreach (string arg in args) {	if (arg == "-v") verbose = 1;	else name = arg;	}	type t = type.gettype (name);	array values = enum.getvalues (t);	string[] names = enum.getnames (t);	int i;	if (verbose != 0) {	
enum 

========================= mono sample_423 =========================

public static int main () {	foo (new d1 (delegate {	counter = 82;	
in 

========================= mono sample_3858 =========================

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	
writeline 

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	
using system xml 

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	
using system xml schema 

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	
using system xml serialization 

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	
using system text 

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	
using system collections 

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	
using system globalization 

public void generateserializers (textwriter writer) {	_writer = writer;	_results = new generationresult [_xmlmaps.length];	if (_config != null && _config.namespaceimports != null && _config.namespaceimports.length > 0) {	
using 

_result.mapping = _typemap;	arraylist maps = (arraylist) mapsbynamespace [_result.namespace];	if (maps == null) {	maps = new arraylist ();	mapsbynamespace [_result.namespace] = maps;	}	maps.add (_result);	}	foreach (dictionaryentry entry in mapsbynamespace) {	arraylist maps = (arraylist) entry.value;	
namespace 

public void generatecontract (arraylist generatedmaps) {	if (generatedmaps.count == 0) return;	generationresult main = (generationresult) generatedmaps[0];	string baseserializername = main.baseserializerclassname;	string access_mod = (_config == null || !_config.generateasinternal) ? "public" : "internal";	writeline ("");	
class system xml serialization xmlserializer 

public void generatecontract (arraylist generatedmaps) {	if (generatedmaps.count == 0) return;	generationresult main = (generationresult) generatedmaps[0];	string baseserializername = main.baseserializerclassname;	string access_mod = (_config == null || !_config.generateasinternal) ? "public" : "internal";	writeline ("");	writelineind ("{");	
protected override system xml serialization xmlserializationreader createreader 

public void generatecontract (arraylist generatedmaps) {	if (generatedmaps.count == 0) return;	generationresult main = (generationresult) generatedmaps[0];	string baseserializername = main.baseserializerclassname;	string access_mod = (_config == null || !_config.generateasinternal) ? "public" : "internal";	writeline ("");	writelineind ("{");	
return new 

public void generatecontract (arraylist generatedmaps) {	if (generatedmaps.count == 0) return;	generationresult main = (generationresult) generatedmaps[0];	string baseserializername = main.baseserializerclassname;	string access_mod = (_config == null || !_config.generateasinternal) ? "public" : "internal";	writeline ("");	writelineind ("{");	writelineuni ("}");	writeline ("");	
protected override system xml serialization xmlserializationwriter createwriter 

public void generatecontract (arraylist generatedmaps) {	if (generatedmaps.count == 0) return;	generationresult main = (generationresult) generatedmaps[0];	string baseserializername = main.baseserializerclassname;	string access_mod = (_config == null || !_config.generateasinternal) ? "public" : "internal";	writeline ("");	writelineind ("{");	writelineuni ("}");	writeline ("");	
return new 

if (generatedmaps.count == 0) return;	generationresult main = (generationresult) generatedmaps[0];	string baseserializername = main.baseserializerclassname;	string access_mod = (_config == null || !_config.generateasinternal) ? "public" : "internal";	writeline ("");	writelineind ("{");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writeline ("");	
public override bool candeserialize system xml xmlreader xmlreader 

if (generatedmaps.count == 0) return;	generationresult main = (generationresult) generatedmaps[0];	string baseserializername = main.baseserializerclassname;	string access_mod = (_config == null || !_config.generateasinternal) ? "public" : "internal";	writeline ("");	writelineind ("{");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writeline ("");	
return true 

writelineind ("{");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	foreach (generationresult res in generatedmaps) {	res.serializerclassname = getuniqueclassname (res.mapping.elementname + "serializer");	
sealed class 

writelineuni ("}");	writeline ("");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	foreach (generationresult res in generatedmaps) {	res.serializerclassname = getuniqueclassname (res.mapping.elementname + "serializer");	writelineind ("{");	
protected override void serialize object obj system xml serialization xmlserializationwriter writer 

writelineuni ("}");	writeline ("");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	foreach (generationresult res in generatedmaps) {	res.serializerclassname = getuniqueclassname (res.mapping.elementname + "serializer");	writelineind ("{");	
writer obj 

writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	foreach (generationresult res in generatedmaps) {	res.serializerclassname = getuniqueclassname (res.mapping.elementname + "serializer");	writelineind ("{");	writelineuni ("}");	writeline ("");	
protected override object deserialize system xml serialization xmlserializationreader reader 

writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	foreach (generationresult res in generatedmaps) {	res.serializerclassname = getuniqueclassname (res.mapping.elementname + "serializer");	writelineind ("{");	writelineuni ("}");	writeline ("");	
return reader 

writeline ("");	foreach (generationresult res in generatedmaps) {	res.serializerclassname = getuniqueclassname (res.mapping.elementname + "serializer");	writelineind ("{");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	}	
if target jvm 

writeline ("");	foreach (generationresult res in generatedmaps) {	res.serializerclassname = getuniqueclassname (res.mapping.elementname + "serializer");	writelineind ("{");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	}	
class system xml serialization xmlserializerimplementation 

writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	}	writelineind ("{");	writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	
public override system xml serialization xmlserializationreader reader 

writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	}	writelineind ("{");	writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	
get 

writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	}	writelineind ("{");	writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	
return new 

writeline ("");	}	writelineind ("{");	writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
public override system xml serialization xmlserializationwriter writer 

writeline ("");	}	writelineind ("{");	writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
get 

writeline ("");	}	writelineind ("{");	writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
return new 

writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
public override system collections hashtable readmethods 

writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
get 

writeline ("system.collections.hashtable readmethods = null;");	writeline ("system.collections.hashtable writemethods = null;");	writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
lock this 

writeline ("system.collections.hashtable typedserializers = null;");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (readmethods == null) {");	writeline ("readmethods = new system.collections.hashtable ();");	
readmethods add res mapping getkey res readmethodname 

writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (readmethods == null) {");	writeline ("readmethods = new system.collections.hashtable ();");	writelineuni ("}");	
return readmethods 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (readmethods == null) {");	writeline ("readmethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
public override system collections hashtable writemethods 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (readmethods == null) {");	writeline ("readmethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
get 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (readmethods == null) {");	writeline ("readmethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
lock this 

writeline ("");	writelineind ("if (readmethods == null) {");	writeline ("readmethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (writemethods == null) {");	writeline ("writemethods = new system.collections.hashtable ();");	
writemethods add res mapping getkey res writemethodname 

writelineind ("if (readmethods == null) {");	writeline ("readmethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (writemethods == null) {");	writeline ("writemethods = new system.collections.hashtable ();");	writelineuni ("}");	
return writemethods 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (writemethods == null) {");	writeline ("writemethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
public override system collections hashtable typedserializers 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (writemethods == null) {");	writeline ("writemethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
get 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (writemethods == null) {");	writeline ("writemethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
lock this 

writeline ("");	writelineind ("if (writemethods == null) {");	writeline ("writemethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (typedserializers == null) {");	writeline ("typedserializers = new system.collections.hashtable ();");	
typedserializers add res mapping getkey new 

writelineind ("if (writemethods == null) {");	writeline ("writemethods = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (typedserializers == null) {");	writeline ("typedserializers = new system.collections.hashtable ();");	writelineuni ("}");	
return typedserializers 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("if (typedserializers == null) {");	writeline ("typedserializers = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	
public override xmlserializer getserializer type type 

writelineuni ("}");	writeline ("");	writelineind ("if (typedserializers == null) {");	writeline ("typedserializers = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("{");	
switch type fullname 

writelineind ("if (typedserializers == null) {");	writeline ("typedserializers = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("{");	foreach (generationresult res in generatedmaps) {	if (res.mapping is xmltypemapping) {	
case xmltypemapping res mapping typedata csharpfullname 

writelineind ("if (typedserializers == null) {");	writeline ("typedserializers = new system.collections.hashtable ();");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("{");	foreach (generationresult res in generatedmaps) {	if (res.mapping is xmltypemapping) {	
return xmlserializer typedserializers res mapping getkey 

writelineuni ("}");	writelineuni ("}");	writeline ("");	writelineind ("{");	foreach (generationresult res in generatedmaps) {	if (res.mapping is xmltypemapping) {	writelineuni ("");	}	}	writeline ("}");	
return base getserializer type 

writeline ("");	writelineind ("{");	foreach (generationresult res in generatedmaps) {	if (res.mapping is xmltypemapping) {	writelineuni ("");	}	}	writeline ("}");	writelineuni ("}");	writeline ("");	
public override bool canserialize system type type 

if (res.mapping is xmltypemapping) {	writelineuni ("");	}	}	writeline ("}");	writelineuni ("}");	writeline ("");	foreach (generationresult res in generatedmaps) {	if (res.mapping is xmltypemapping) writeline ("if (type == typeof(" + (res.mapping as xmltypemapping).typedata.csharpfullname +  ")) return true;");	}	
return false 

}	writeline ("}");	writelineuni ("}");	writeline ("");	foreach (generationresult res in generatedmaps) {	if (res.mapping is xmltypemapping) writeline ("if (type == typeof(" + (res.mapping as xmltypemapping).typedata.csharpfullname +  ")) return true;");	}	writelineuni ("}");	writelineuni ("}");	writeline ("");	
endif 

public void generatewriter (string writerclassname, arraylist maps) {	_mapstogenerate = new arraylist ();	inithooks ();	if (_config == null || !_config.generateasinternal) writeline ("public class " + writerclassname + " : xmlserializationwriter");	
internal class xmlserializationwriter 

public void generatewriter (string writerclassname, arraylist maps) {	_mapstogenerate = new arraylist ();	inithooks ();	if (_config == null || !_config.generateasinternal) writeline ("public class " + writerclassname + " : xmlserializationwriter");	writelineind ("{");	writeline ("const string xmlnamespace = \"http: writeline ("static readonly system.reflection.methodinfo tobinhexstringmethod = typeof (xmlconvert).getmethod (\"tobinhexstring\", system.reflection.bindingflags.static | system.reflection.bindingflags.nonpublic, null, new type [] {typeof (byte [])}, null);");	
static string tobinhexstring byte input 

public void generatereader (string readerclassname, arraylist maps) {	if (_config == null || !_config.generateasinternal) writeline ("public class " + readerclassname + " : xmlserializationreader");	
internal class xmlserializationreader 

public void generatereader (string readerclassname, arraylist maps) {	if (_config == null || !_config.generateasinternal) writeline ("public class " + readerclassname + " : xmlserializationreader");	writelineind ("{");	writeline ("static readonly system.reflection.methodinfo frombinhexstringmethod = typeof (xmlconvert).getmethod (\"frombinhexstring\", system.reflection.bindingflags.static | system.reflection.bindingflags.nonpublic, null, new type [] {typeof (string)}, null);");	
static byte frombinhexstring string input 

}	writelineuni ("}");	writeline ("");	pophookcontext ();	}	void generatereadclassinstance (xmltypemapping typemap, string isnullable, string checktype) {	sethookvar ("$object", "ob");	if (!typemap.typedata.isvaluetype) {	writeline (typemap.typedata.csharpfullname + " ob = null;");	if (generatereadhook (hooktype.type, typemap.typedata.type)) {	
return ob 

pophookcontext ();	}	void generatereadclassinstance (xmltypemapping typemap, string isnullable, string checktype) {	sethookvar ("$object", "ob");	if (!typemap.typedata.isvaluetype) {	writeline (typemap.typedata.csharpfullname + " ob = null;");	if (generatereadhook (hooktype.type, typemap.typedata.type)) {	return;	}	if (_format == serializationformat.literal) {	
if readnull return null 

}	void generatereadclassinstance (xmltypemapping typemap, string isnullable, string checktype) {	sethookvar ("$object", "ob");	if (!typemap.typedata.isvaluetype) {	writeline (typemap.typedata.csharpfullname + " ob = null;");	if (generatereadhook (hooktype.type, typemap.typedata.type)) {	return;	}	if (_format == serializationformat.literal) {	writeline ("");	
if checktype 

if (!typemap.typedata.isvaluetype) {	writeline (typemap.typedata.csharpfullname + " ob = null;");	if (generatereadhook (hooktype.type, typemap.typedata.type)) {	return;	}	if (_format == serializationformat.literal) {	writeline ("");	writelineind ("{");	}	else {	
if readnull return null 

writeline ("");	writelineind ("{");	}	else {	writeline ("");	}	}	else {	writeline (typemap.typedata.csharpfullname + string.format (" ob = ({0}) activator.createinstance(typeof({0}), true);", typemap.typedata.csharpfullname));	if (generatereadhook (hooktype.type, typemap.typedata.type)) {	
return ob 

}	else {	writeline (typemap.typedata.csharpfullname + string.format (" ob = ({0}) activator.createinstance(typeof({0}), true);", typemap.typedata.csharpfullname));	if (generatereadhook (hooktype.type, typemap.typedata.type)) {	return;	}	}	writeline ("system.xml.xmlqualifiedname t = getxsitype();");	writeline ("if (t == null)");	if (typemap.typedata.type != typeof(object)) writeline ("{ }");	
return readtypedprimitive new system xml xmlqualifiedname system xml schema xmlschema namespace 

writeline (typemap.typedata.csharpfullname + string.format (" ob = ({0}) activator.createinstance(typeof({0}), true);", typemap.typedata.csharpfullname));	if (generatereadhook (hooktype.type, typemap.typedata.type)) {	return;	}	}	writeline ("system.xml.xmlqualifiedname t = getxsitype();");	writeline ("if (t == null)");	if (typemap.typedata.type != typeof(object)) writeline ("{ }");	foreach (xmltypemapping realmap in typemap.derivedtypes) {	writelineind ("else if (t.name == " + getliteral (realmap.xmltype) + " && t.namespace == " + getliteral (realmap.xmltypenamespace) + ")");	
return 

}	writeline ("system.xml.xmlqualifiedname t = getxsitype();");	writeline ("if (t == null)");	if (typemap.typedata.type != typeof(object)) writeline ("{ }");	foreach (xmltypemapping realmap in typemap.derivedtypes) {	writelineind ("else if (t.name == " + getliteral (realmap.xmltype) + " && t.namespace == " + getliteral (realmap.xmltypenamespace) + ")");	unindent ();	}	writeline ("else if (t.name != " + getliteral (typemap.xmltype) + " || t.namespace != " + getliteral (typemap.xmltypenamespace) + ")");	if (typemap.typedata.type == typeof(object)) writeline ("\treturn " + getcast (typemap.typedata, "readtypedprimitive (t)") + ";");	
throw createunknowntypeexception t 

foreach (xmltypemapping realmap in typemap.derivedtypes) {	writelineind ("else if (t.name == " + getliteral (realmap.xmltype) + " && t.namespace == " + getliteral (realmap.xmltypenamespace) + ")");	unindent ();	}	writeline ("else if (t.name != " + getliteral (typemap.xmltype) + " || t.namespace != " + getliteral (typemap.xmltypenamespace) + ")");	if (typemap.typedata.type == typeof(object)) writeline ("\treturn " + getcast (typemap.typedata, "readtypedprimitive (t)") + ";");	if (!typemap.typedata.isvaluetype) {	if (_format == serializationformat.literal) writelineuni ("}");	if (typemap.typedata.type.isabstract) {	generateendhook ();	
return ob 

if (!typemap.typedata.isvaluetype) {	if (_format == serializationformat.literal) writelineuni ("}");	if (typemap.typedata.type.isabstract) {	generateendhook ();	return;	}	writeline ("");	writeline (string.format ("ob = ({0}) activator.createinstance(typeof({0}), true);", typemap.typedata.csharpfullname));	}	writeline ("");	
reader movetoelement 

return;	}	writeline ("");	writeline (string.format ("ob = ({0}) activator.createinstance(typeof({0}), true);", typemap.typedata.csharpfullname));	}	writeline ("");	writeline ("");	generatereadmembers (typemap, (classmap)typemap.objectmap, "ob", false, false);	writeline ("");	generateendhook ();	
return ob 

========================= mono sample_22532 =========================

public static void usage (string message) {	
tlstest copyright c novell 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
usage 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
tlstest protocol class credentials x x time show url 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
protocol only applicable when using stream 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
any negotiate protocol default 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
ssl use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
use unsupported on mono 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
tls use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
class 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
stream directly use the sslclientstream default 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
web use the webrequest webresponse classes 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
credentials 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
basic username password domain basic authentication 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
digest username password domain digest authentication 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
options 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
x x client certificate multiple entries allowed 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
time show the time required for each page load 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
show show the web page content on screen 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
url one or more url to download 

datetime start = datetime.now;	try {	if (web) {	content = getwebpage (url);	}	else {	content = getstreampage (url);	}	}	catch (exception e) {	
failed 

}	}	catch (exception e) {	console.writeline (e.tostring ());	}	timespan ts = (datetime.now - start);	if ((show) && (content != null)) {	console.writeline ("{0}{1}{0}", environment.newline, content);	}	if (time) {	
time 

uri uri = new uri (url);	if (uri.scheme != uri.urischemehttps) throw new notsupportedexception ("stream only works with https protocol");	iphostentry host = dns.resolve (uri.host);	ipaddress ip = host.addresslist [0];	socket socket = new socket (ip.addressfamily, sockettype.stream, protocoltype.tcp);	socket.connect (new ipendpoint (ip, uri.port));	networkstream ns = new networkstream (socket, false);	sslclientstream ssl = new sslclientstream (ns, uri.host, false, protocol, certificates);	ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	streamwriter sw = new streamwriter (ssl);	
get http 

break;	case -2146762495: message = "cert_e_expired 0x800b0101";	break;	case -2146762486: message = "cert_e_chaining 0x800b010a";	break;	case -2146762487: message = "cert_e_untrustedroot 0x800b0109";	break;	default: message = "unknown (try winerror.h)";	break;	}	
error 

private static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	if (certificateerrors.length > 0) {	console.writeline (certificate.tostring (true));	
valid from 

private static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	if (certificateerrors.length > 0) {	console.writeline (certificate.tostring (true));	
valid until 

public bool checkvalidationresult (servicepoint sp, x509certificate certificate, webrequest request, int error) {	if (error != 0) {	console.writeline (certificate.tostring (true));	
valid from 

public bool checkvalidationresult (servicepoint sp, x509certificate certificate, webrequest request, int error) {	if (error != 0) {	console.writeline (certificate.tostring (true));	
valid until 

========================= mono sample_20577 =========================

}	if (key == null) return;	try {	using (registrykey rk = openregistrykey (key, true)) {	rk.setvalue ("autogenkey", buf, registryvaluekind.binary);	rk.setvalue ("autogenkeycreationtime", datetime.now.ticks, registryvaluekind.qword);	rk.setvalue ("autogenkeyformat", 2, registryvaluekind.dword);	rk.flush ();	}	} catch (exception ex) {	
info auto generated encryption keys not saved 

========================= mono sample_20526 =========================

static void main () {	
a b 

========================= mono sample_36032 =========================

static partitionentrycountrequest() {	try {	ldapextendedresponse.register(replicationconstants.naming_context_count_res, system.type.gettype("novell.directory.ldap.extensions.partitionentrycountresponse"));	}	catch (system.exception e) {	
could not register extended response class not found 

========================= mono sample_20947 =========================

public void throwunserializable () {	
throwing unserializable exception in appdomain 

public static int main () {	string original_domain = appdomain.currentdomain.friendlyname;	appdomain ad = appdomain.createdomain("subdomain");	try {	testoutput remoteoutput = (testoutput) ad.createinstanceandunwrap( typeof (testoutput).assembly.fullname, "testoutput");	remoteoutput.throwunserializable ();	} catch (serializationexception) {	
caught serialization exception 

public static int main () {	string original_domain = appdomain.currentdomain.friendlyname;	appdomain ad = appdomain.createdomain("subdomain");	try {	testoutput remoteoutput = (testoutput) ad.createinstanceandunwrap( typeof (testoutput).assembly.fullname, "testoutput");	remoteoutput.throwunserializable ();	} catch (serializationexception) {	} catch (exception) {	
caught other exception 

public static int main () {	string original_domain = appdomain.currentdomain.friendlyname;	appdomain ad = appdomain.createdomain("subdomain");	try {	testoutput remoteoutput = (testoutput) ad.createinstanceandunwrap( typeof (testoutput).assembly.fullname, "testoutput");	remoteoutput.throwunserializable ();	} catch (serializationexception) {	} catch (exception) {	environment.exit (1);	} finally {	
finally in domain 

try {	testoutput remoteoutput = (testoutput) ad.createinstanceandunwrap( typeof (testoutput).assembly.fullname, "testoutput");	remoteoutput.throwunserializable ();	} catch (serializationexception) {	} catch (exception) {	environment.exit (1);	} finally {	if (original_domain != appdomain.currentdomain.friendlyname) environment.exit (2);	appdomain.unload (ad);	}	
all ok 

========================= mono sample_308 =========================

public static void testmethod() {	
with priority 

public static void testmethod() {	thread.sleep(6000);	
with priority 

public static int test_0_main_thread_priority () {	
testing main thread s priority 

public static int test_0_main_thread_priority () {	if (thread.currentthread.managedthreadid != mainthreadid) {	
test main thread priority must be run on the main thread 

public static int test_0_main_thread_priority () {	if (thread.currentthread.managedthreadid != mainthreadid) {	return 1;	}	var before = thread.currentthread.priority;	
priority 

public static int test_0_main_thread_priority () {	if (thread.currentthread.managedthreadid != mainthreadid) {	return 1;	}	var before = thread.currentthread.priority;	if (before != threadpriority.normal) return 2;	
setting main thread s priority to abovenormal 

public static int test_0_main_thread_priority () {	if (thread.currentthread.managedthreadid != mainthreadid) {	return 1;	}	var before = thread.currentthread.priority;	if (before != threadpriority.normal) return 2;	thread.currentthread.priority = threadpriority.abovenormal;	var after = thread.currentthread.priority;	
priority 

public static int test_0_main_thread_priority () {	if (thread.currentthread.managedthreadid != mainthreadid) {	return 1;	}	var before = thread.currentthread.priority;	if (before != threadpriority.normal) return 2;	thread.currentthread.priority = threadpriority.abovenormal;	var after = thread.currentthread.priority;	if (after != threadpriority.abovenormal) return 3;	before = after;	
setting main thread s priority to belownormal 

return 1;	}	var before = thread.currentthread.priority;	if (before != threadpriority.normal) return 2;	thread.currentthread.priority = threadpriority.abovenormal;	var after = thread.currentthread.priority;	if (after != threadpriority.abovenormal) return 3;	before = after;	thread.currentthread.priority = threadpriority.belownormal;	after = thread.currentthread.priority;	
priority 

var before = thread.currentthread.priority;	if (before != threadpriority.normal) return 2;	thread.currentthread.priority = threadpriority.abovenormal;	var after = thread.currentthread.priority;	if (after != threadpriority.abovenormal) return 3;	before = after;	thread.currentthread.priority = threadpriority.belownormal;	after = thread.currentthread.priority;	if (after != threadpriority.belownormal) return 4;	before = after;	
setting main thread s priority to normal 

thread.currentthread.priority = threadpriority.abovenormal;	var after = thread.currentthread.priority;	if (after != threadpriority.abovenormal) return 3;	before = after;	thread.currentthread.priority = threadpriority.belownormal;	after = thread.currentthread.priority;	if (after != threadpriority.belownormal) return 4;	before = after;	thread.currentthread.priority = threadpriority.normal;	after = thread.currentthread.priority;	
priority 

public static int test_0_thread_priority () {	int res = 0;	thread me = thread.currentthread;	thread testthread = new thread(new threadstart(testmethod));	
starting test thread with priority to abovenormal 

public static int test_0_thread_priority () {	int res = 0;	thread me = thread.currentthread;	thread testthread = new thread(new threadstart(testmethod));	threadpriority before = testthread.priority;	testthread.priority = threadpriority.abovenormal;	testthread.name = "testmethod";	testthread.start();	threadpriority after = testthread.priority;	
priority 

threadpriority before = testthread.priority;	testthread.priority = threadpriority.abovenormal;	testthread.name = "testmethod";	testthread.start();	threadpriority after = testthread.priority;	if (before != threadpriority.normal) res = 1;	else if (after != threadpriority.abovenormal) res = 2;	else {	testthread.priority = threadpriority.normal;	after = testthread.priority;	
setting test thread priority to normal 

testthread.priority = threadpriority.abovenormal;	testthread.name = "testmethod";	testthread.start();	threadpriority after = testthread.priority;	if (before != threadpriority.normal) res = 1;	else if (after != threadpriority.abovenormal) res = 2;	else {	testthread.priority = threadpriority.normal;	after = testthread.priority;	thread.sleep(1000);	
priority 

testthread.start();	threadpriority after = testthread.priority;	if (before != threadpriority.normal) res = 1;	else if (after != threadpriority.abovenormal) res = 2;	else {	testthread.priority = threadpriority.normal;	after = testthread.priority;	thread.sleep(1000);	if (after != threadpriority.normal) res = 3;	else {	
setting test thread priority to abovenormal 

else {	testthread.priority = threadpriority.normal;	after = testthread.priority;	thread.sleep(1000);	if (after != threadpriority.normal) res = 3;	else {	before = after;	testthread.priority=threadpriority.abovenormal;	after = testthread.priority;	thread.sleep(1000);	
priority 

thread.sleep(1000);	if (after != threadpriority.normal) res = 3;	else {	before = after;	testthread.priority=threadpriority.abovenormal;	after = testthread.priority;	thread.sleep(1000);	if (after != threadpriority.abovenormal) res = 4;	else {	before = after;	
setting test thread priority to belownormal 

else {	before = after;	testthread.priority=threadpriority.abovenormal;	after = testthread.priority;	thread.sleep(1000);	if (after != threadpriority.abovenormal) res = 4;	else {	before = after;	testthread.priority=threadpriority.belownormal;	after = testthread.priority;	
priority 

thread.sleep(1000);	if (after != threadpriority.abovenormal) res = 4;	else {	before = after;	testthread.priority=threadpriority.belownormal;	after = testthread.priority;	thread.sleep(1000);	if (after != threadpriority.belownormal) res = 5;	else {	before = after;	
setting test thread priority back to normal 

else {	before = after;	testthread.priority=threadpriority.belownormal;	after = testthread.priority;	thread.sleep(1000);	if (after != threadpriority.belownormal) res = 5;	else {	before = after;	testthread.priority=threadpriority.normal;	after = testthread.priority;	
priority 

========================= mono sample_248 =========================

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(dataset));	filestream fs=new filestream(filename, filemode.open);	dataset ds;	ds=(dataset)ser.deserialize(fs);	fs.close();	
dataset name 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(dataset));	filestream fs=new filestream(filename, filemode.open);	dataset ds;	ds=(dataset)ser.deserialize(fs);	fs.close();	
dataset locale 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(dataset));	filestream fs=new filestream(filename, filemode.open);	dataset ds;	ds=(dataset)ser.deserialize(fs);	fs.close();	foreach(datatable t in ds.tables) {	
table name 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(dataset));	filestream fs=new filestream(filename, filemode.open);	dataset ds;	ds=(dataset)ser.deserialize(fs);	fs.close();	foreach(datatable t in ds.tables) {	
table locale 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(dataset));	filestream fs=new filestream(filename, filemode.open);	dataset ds;	ds=(dataset)ser.deserialize(fs);	fs.close();	foreach(datatable t in ds.tables) {	foreach(datacolumn c in t.columns) {	
column name 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(dataset));	filestream fs=new filestream(filename, filemode.open);	dataset ds;	ds=(dataset)ser.deserialize(fs);	fs.close();	foreach(datatable t in ds.tables) {	foreach(datacolumn c in t.columns) {	
null allowed 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(dataset));	filestream fs=new filestream(filename, filemode.open);	dataset ds;	ds=(dataset)ser.deserialize(fs);	fs.close();	foreach(datatable t in ds.tables) {	foreach(datacolumn c in t.columns) {	}	foreach(datarow r in t.rows) {	
row 

========================= mono sample_22557 =========================

int readed	= 0;	int length	= this.readint24();	while (readed < length) {	int certlength = readint24();	readed += 3;	if (certlength > 0) {	byte[] buffer = this.readbytes(certlength);	x509certificate certificate = new x509certificate(buffer);	certificates.add(certificate);	readed += certlength;	
server certificate 

========================= mono sample_31726 =========================

public static void main () {	
getrange 

========================= mono sample_2543 =========================

foreach (int actual in e) {	console.writeline (actual);	if (int_array [pos++] * 2 != actual) return pos;	}	e = from i in int_array let u = i * 2 let v = u * 3 where u != 0 select v;	pos = 1;	foreach (int actual in e) {	console.writeline (actual);	if (int_array [pos++] * 6 != actual) return pos;	}	
ok 

========================= mono sample_2891 =========================

static void showdebugmodemessage (string msg) {	if (suppressdebugmodemessages) return;	console.error.writeline ();	
debug mode message 

static void showdebugmodemessage (string msg) {	if (suppressdebugmodemessages) return;	console.error.writeline ();	console.error.writeline (msg);	
debug mode message 

========================= mono sample_20403 =========================

public static int main () {	console.writeline (m (1));	try {	console.writeline (m (null));	} catch (exception) {	
thrown 

========================= mono sample_1699 =========================

public static void main (string [] args) {	if (args.length > 0 && args [0] == "--skip-error") skip_error = true;	
started yyyy mm dd hh mm ss fff 

public static void main (string [] args) {	if (args.length > 0 && args [0] == "--skip-error") skip_error = true;	runtest ();	
finished yyyy mm dd hh mm ss fff 

static void runtest () {	foreach (directoryinfo di in new directoryinfo (@"relax-ng").getdirectories ()) {	xmltextreader xtr = null;	fileinfo fi = new fileinfo (di.fullname + "/i.rng");	if (fi.exists) {	xtr = new xmltextreader (fi.fullname);	try {	relaxngpattern.read (xtr).compile ();	
expected error 

fileinfo fi = new fileinfo (di.fullname + "/i.rng");	if (fi.exists) {	xtr = new xmltextreader (fi.fullname);	try {	relaxngpattern.read (xtr).compile ();	} catch (relaxngexception ex) {	} catch (xmlexception ex) {	} catch (argumentnullexception ex) {	} catch (uriformatexception ex) {	} catch (exception ex) {	
unexpected error type 

xtr.close ();	}	continue;	}	xtr = new xmltextreader (di.fullname + "/c.rng");	relaxngpattern p = null;	try {	p = relaxngpattern.read (xtr);	p.compile ();	} catch (exception ex) {	
invalidated grammar 

xtr.close ();	}	foreach (fileinfo inst in di.getfiles ("*.xml")) {	try {	relaxngvalidatingreader vr = new relaxngvalidatingreader (new xmltextreader (inst.fullname), p);	if (skip_error) vr.invalidnodefound += relaxngvalidatingreader.ignoreerror;	while (!vr.eof) vr.read ();	if (inst.name.indexof ("i.") >= 0 && !skip_error) console.writeline ("incorrectly validated instance: " + di.name + "/" + inst.name);	} catch (relaxngexception ex) {	string path = di.name + "/" + inst.name;	
failed to skip error 

}	foreach (fileinfo inst in di.getfiles ("*.xml")) {	try {	relaxngvalidatingreader vr = new relaxngvalidatingreader (new xmltextreader (inst.fullname), p);	if (skip_error) vr.invalidnodefound += relaxngvalidatingreader.ignoreerror;	while (!vr.eof) vr.read ();	if (inst.name.indexof ("i.") >= 0 && !skip_error) console.writeline ("incorrectly validated instance: " + di.name + "/" + inst.name);	} catch (relaxngexception ex) {	string path = di.name + "/" + inst.name;	if (inst.name.indexof ("i.") >= 0) continue;	
invalidated instance 

========================= mono sample_22775 =========================

public static int bar (int j, params int [] args) {	got = 2;	int total = 0;	foreach (int i in args){	
my argument 

if (got != 2) return 3;	int k = 10;	out (ref k);	if (k != 11) return 10;	int [] arr2 = new int [2] {1, 2};	if (addarray (arr2) != 3) return 11;	fancyint f_one = new fancyint (1);	fancyint f_two = new fancyint (2);	if (addfancy (f_one) != 1) return 12;	if (addfancy (f_one, f_two) != 3) return 13;	
test passes 

========================= mono sample_1559 =========================

public static int main () {	string [] s = typeof (c).assembly.getmanifestresourcenames ();	if (s [0] != "test") return 1;	if (typeof (c).assembly.getmanifestresourcestream ("test") == null) return 2;	
ok 

========================= mono sample_2730 =========================

public static idictionary<string, string> load(string filename, parameters parameters) {	if (!system.io.file.exists(filename)) throw new argumentexception("renames file missing:" + parameters.aliases);	
loading renames file 

========================= mono sample_25075 =========================

console.writeline (mb.getilasbytearray ().length);	if (mb.getilasbytearray ().length != 8) {	return 1;	}	mi = typeof (d).getconstructors (bindingflags.static | bindingflags.nonpublic) [0];	mb = mi.getmethodbody ();	console.writeline (mb.getilasbytearray ().length);	if (mb.getilasbytearray ().length != 12) {	return 2;	}	
ok 

========================= mono sample_2813 =========================

public void pollingloop () {	while (true) {	foreach (polledobject polledobject in _polledobjects) {	polledobject.poll ();	}	
waiting ms 

try {	uri uri = new uri (_url);	httpwebrequest httpwebrequest = (httpwebrequest) webrequest.create (uri);	webresponse httpwebresponse = httpwebrequest.getresponse ();	stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	
response for 

httpwebrequest httpwebrequest = (httpwebrequest) webrequest.create (uri);	webresponse httpwebresponse = httpwebrequest.getresponse ();	stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	}	catch (webexception e) {	
webexception raised in poll for 

httpwebrequest httpwebrequest = (httpwebrequest) webrequest.create (uri);	webresponse httpwebresponse = httpwebrequest.getresponse ();	stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	}	catch (webexception e) {	
source 

httpwebrequest httpwebrequest = (httpwebrequest) webrequest.create (uri);	webresponse httpwebresponse = httpwebrequest.getresponse ();	stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	}	catch (webexception e) {	
message 

httpwebrequest httpwebrequest = (httpwebrequest) webrequest.create (uri);	webresponse httpwebresponse = httpwebrequest.getresponse ();	stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	}	catch (webexception e) {	
status 

stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	}	catch (webexception e) {	}	catch (exception e) {	
exception raised in poll for 

stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	}	catch (webexception e) {	}	catch (exception e) {	
source 

stream responsestream = httpwebresponse.getresponsestream ();	streamreader responsestreamreader = new streamreader (responsestream);	string response = responsestreamreader.readline ();	responsestreamreader.close ();	responsestream.close ();	httpwebresponse.close ();	}	catch (webexception e) {	}	catch (exception e) {	
message 

========================= mono sample_20590 =========================

var rand = new random (0);	var buffs = new list<byte []> ();	for (int i = 0; i < 4096; i++){	a.dumpstats ();	var request = rand.next (1,1024*1024);	if ((i % 2) == 0) request = rand.next (1024, 4096);	var x = a.takebuffer (request);	if (x.length < request) throw new exception ();	console.writeline ("delta={2} requested {0} got={1} bytes ", request, x.length, x.length-request);	if ((i % 3) == 0){	
return 

========================= mono sample_31575 =========================

streamreader sr = new streamreader (s, encoding.utf8);	while (sr.peek () > 0) {	sr.readline ();	string uristring = sr.readline ();	textwriter sw = console.out;	sw.writeline ("-------------------------");	sw.writeline (uristring);	if (uristring == null || uristring.length == 0) break;	try {	uri uri = baseuri == null ? new uri (uristring) : new uri (baseuri, uristring);	
tostring 

sw.writeline ("-------------------------");	sw.writeline (uristring);	if (uristring == null || uristring.length == 0) break;	try {	uri uri = baseuri == null ? new uri (uristring) : new uri (baseuri, uristring);	sw.writeline (uri.absoluteuri);	sw.writeline (uri.scheme);	sw.writeline (uri.host);	sw.writeline (uri.localpath);	sw.writeline (uri.query);	
port 

uri uri = baseuri == null ? new uri (uristring) : new uri (baseuri, uristring);	sw.writeline (uri.absoluteuri);	sw.writeline (uri.scheme);	sw.writeline (uri.host);	sw.writeline (uri.localpath);	sw.writeline (uri.query);	sw.writeline (uri.isfile);	sw.writeline (uri.isunc);	sw.writeline (uri.isloopback);	sw.writeline (uri.userescaped);	
hostnametype 

sw.writeline (uri.absoluteuri);	sw.writeline (uri.scheme);	sw.writeline (uri.host);	sw.writeline (uri.localpath);	sw.writeline (uri.query);	sw.writeline (uri.isfile);	sw.writeline (uri.isunc);	sw.writeline (uri.isloopback);	sw.writeline (uri.userescaped);	sw.writeline (uri.absolutepath);	
pathandquery 

========================= mono sample_23468 =========================

static void function () {	
delegate method 

static void async_callback (iasyncresult ar) {	
async callback 

public static int main () {	environment.exitcode = 2;	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	thread.sleep(1000);	d.endinvoke(ar1);	thread.sleep(1000);	
main returns 

========================= mono sample_328 =========================

private ilasmtest() {}	public static int main (string [] args) {	if (args.length != 1) {	
usage ilasm filename 

========================= mono sample_36261 =========================

public static int main() {	var b = new b ();	if (b.foo (3).result != 4) return 1;	if (b.foo2 (5).result != 5) return 2;	
ok 

========================= mono sample_3559 =========================

public static int main () {	fillsingle ();	filldouble ();	fillobject ();	filldoubleobject ();	if (testsingle () != 0) return 1;	if (testdouble () != 0) return 2;	if (testobjectsingle () != 0) return 3;	if (testobjectdouble () != 0) return 4;	
test passes 

========================= mono sample_3969 =========================

assert.areequal (typeof (outer<double>.inner), res, "#5");	tname = "system.collections.generic.list`1[system.int32]";	res = type.gettype (tname, name => {	return assembly.load (name);	},(asm,name,ignore) => {	return asm == null ? type.gettype (name, false, ignore) : asm.gettype (name, false, ignore);	}, false, false);	assert.areequal (typeof (list<int>), res, "#6");	tname = typeof (foo<>).fullname + "[,][]";	res = type.gettype (tname, name => {	
resolve asm name 

public void dispose () {	
stream dispose 

========================= mono sample_27277 =========================

list.add ("two");	list.add ("three");	int count = 0;	foreach (string s in list){	if (s == "two"){	break;	}	count++;	}	if (count != 1) return 4;	
test passes 

========================= mono sample_3938 =========================

public static void print(xmltypemapping tm) {	
xmltypemapping 

public static void print(xmltypemapping tm) {	
elementname 

public static void print(xmltypemapping tm) {	
namespace 

public static void print(xmltypemapping tm) {	
typename 

public static void print(xmltypemapping tm) {	
fulltypename 

public static void print(xmlmembermapping mm) {	
xmlmembermapping 

public static void print(xmlmembermapping mm) {	
any 

public static void print(xmlmembermapping mm) {	
elementname 

public static void print(xmlmembermapping mm) {	
membername 

public static void print(xmlmembermapping mm) {	
namespace 

public static void print(xmlmembermapping mm) {	
typefullname 

public static void print(xmlmembermapping mm) {	
typename 

public static void print(xmlmembermapping mm) {	
typenamespace 

========================= mono sample_22452 =========================

if (mrp.cancasttocalled) return 299;	total += itf299.callme (299);	mrp.cancasttocalled = false;	i300 itf300 = (i300)o;	if (!mrp.cancasttocalled) return 300;	total += itf300.callme (300);	mrp.cancasttocalled = false;	itf300 = (i300)o;	if (mrp.cancasttocalled) return 300;	total += itf300.callme (300);	
finished 

========================= mono sample_543 =========================

static void async_callback (iasyncresult ar) {	
async callback in domain 

public int getint () {	
getint in 

public static int main (string [] args) {	appdomain domain = appdomain.createdomain ("newdomain");	int i;	for (i = 0; i < 200; ++i) {	domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	}	
unloading 

public static int main (string [] args) {	appdomain domain = appdomain.createdomain ("newdomain");	int i;	for (i = 0; i < 200; ++i) {	domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	}	appdomain.unload (domain);	
unloaded 

public static int main (string [] args) {	appdomain domain = appdomain.createdomain ("newdomain");	int i;	for (i = 0; i < 200; ++i) {	domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	}	appdomain.unload (domain);	gc.collect ();	gc.waitforpendingfinalizers ();	
done 

========================= mono sample_403 =========================

cmd.connection.open();	object obj = cmd.executescalar();	#endif string dbserver = environment.getenvironmentvariable("dblinqserver") ?? "localhost";	string connstr = string.format("server={0};user id={1}; password={2}; database={3}" , dbserver, "linquser", "linq2", "northwind");	northwind db = new northwind(new mysqlconnection(connstr));	#if use_stored_procs int is2;	object xx = db.sp_selorders("zz", out is2);	string reply0 = db.hello0();	string reply1 = db.hello1("pigafetta");	#endif #if use_alltypes #endif console.clear();	
from p in db products orderby p productname select p 

#endif string dbserver = environment.getenvironmentvariable("dblinqserver") ?? "localhost";	string connstr = string.format("server={0};user id={1}; password={2}; database={3}" , dbserver, "linquser", "linq2", "northwind");	northwind db = new northwind(new mysqlconnection(connstr));	#if use_stored_procs int is2;	object xx = db.sp_selorders("zz", out is2);	string reply0 = db.hello0();	string reply1 = db.hello1("pigafetta");	#endif #if use_alltypes #endif console.clear();	var q2 = from p in db.products orderby p.productname select p;	foreach (var v in q2) objectdumper.write(v);	
press enter to continue 

string reply0 = db.hello0();	string reply1 = db.hello1("pigafetta");	#endif #if use_alltypes #endif console.clear();	var q2 = from p in db.products orderby p.productname select p;	foreach (var v in q2) objectdumper.write(v);	console.readline();	console.clear();	console.writeline( "from p in db.products where p.productid == 7 select p;");	var q4 = from p in db.products where p.productid == 7 select p;	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.readline();	console.clear();	console.writeline( "from p in db.products where p.productid == 7 select p;");	var q4 = from p in db.products where p.productid == 7 select p;	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	console.writeline( "from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.readline();	console.clear();	console.writeline( "from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	console.writeline( "from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.writeline( "from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	console.writeline( "from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	
db orders 

var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	console.writeline( "from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

console.readline();	console.clear();	console.writeline( "from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	foreach (var v in db.orders) objectdumper.write(v);	console.readline();	console.clear();	
db orders remove db orders first 

var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	console.clear();	foreach (var v in db.orders) objectdumper.write(v);	console.readline();	console.clear();	db.orders.deleteonsubmit(db.orders.first());	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

========================= mono sample_24581 =========================

bitmapdata data = bmp.lockbits (new rectangle (0, 0, bmp.width, bmp.height), imagelockmode.readonly, pixelformat.format24bpprgb);	try {	assert.areequal (bmp.height, data.height, "height");	assert.areequal (bmp.width, data.width, "width");	assert.areequal (pixelformat.format24bpprgb, data.pixelformat, "pixelformat");	assert.areequal (520, data.stride, "stride");	int size = data.height * data.stride;	unsafe {	byte* scan = (byte*) data.scan0;	#if false for (int p = 0; p < size; p += 1009) {	
assert areequal scan 

========================= mono sample_21124 =========================

public static void check (long stack1, long stack2) {	++i;	if (stack1 != 0) return;	if (stack1 != stack2) {	
tailcall failure 

========================= mono sample_670 =========================

static void usage () {	
usage mono harness exe options app dir 

static void usage () {	
where options are 

static void usage () {	
run sim 

bundle_id = "";	bundle_dir = "";	logfile_name = "";	var p = new optionset () {	{ "start-sim", s => action = "start-sim" }, { "run-sim", s => action = "run-sim" }, { "run-dev", s => action = "run-dev" }, { "bundle-id=", s => bundle_id = s }, { "bundle-dir=", s => bundle_dir = s }, { "logfile=", s => logfile_name = s }, };	new_args = p.parse (args).toarray ();	if (action == "start-sim") {	startsim ();	} else if (action == "run-sim") {	if (bundle_id == "" || bundle_dir == "") {	
the bundle id and bundle dir arguments are mandatory 

new_args = p.parse (args).toarray ();	if (action == "start-sim") {	startsim ();	} else if (action == "run-sim") {	if (bundle_id == "" || bundle_dir == "") {	environment.exit (1);	}	runsim ();	} else if (action == "run-dev") {	if (bundle_dir == "") {	
the bundle dir argument is mandatory 

========================= mono sample_29 =========================

bool nologo = false;	bool help = false;	optionset p = new optionset() {	{"v|verbose", "verbose output", v => verbose = v!= null }, {"t|target=", "target assembly name", v => target = v }, {"c|complist=","licx file to compile", v => complist = v }, {"i|load=", "reference to load", v=> {if (v != null) references.add(v);}}, {"o|outdir=", "output directory for the .licenses file", v=> targetdir = v }, {"nologo", "do not display logo", v=> nologo = null != v }, {"h|?|help", "show help", v=>help = v != null }	};	list<string> extra;	try {	extra = p.parse(args);	}	catch(optionexception e) {	
lc 

bool nologo = false;	bool help = false;	optionset p = new optionset() {	{"v|verbose", "verbose output", v => verbose = v!= null }, {"t|target=", "target assembly name", v => target = v }, {"c|complist=","licx file to compile", v => complist = v }, {"i|load=", "reference to load", v=> {if (v != null) references.add(v);}}, {"o|outdir=", "output directory for the .licenses file", v=> targetdir = v }, {"nologo", "do not display logo", v=> nologo = null != v }, {"h|?|help", "show help", v=>help = v != null }	};	list<string> extra;	try {	extra = p.parse(args);	}	catch(optionexception e) {	
try lc help for more information 

{"v|verbose", "verbose output", v => verbose = v!= null }, {"t|target=", "target assembly name", v => target = v }, {"c|complist=","licx file to compile", v => complist = v }, {"i|load=", "reference to load", v=> {if (v != null) references.add(v);}}, {"o|outdir=", "output directory for the .licenses file", v=> targetdir = v }, {"nologo", "do not display logo", v=> nologo = null != v }, {"h|?|help", "show help", v=>help = v != null }	};	list<string> extra;	try {	extra = p.parse(args);	}	catch(optionexception e) {	return 1;	}	if (!nologo) {	
mono license compiler 

{"v|verbose", "verbose output", v => verbose = v!= null }, {"t|target=", "target assembly name", v => target = v }, {"c|complist=","licx file to compile", v => complist = v }, {"i|load=", "reference to load", v=> {if (v != null) references.add(v);}}, {"o|outdir=", "output directory for the .licenses file", v=> targetdir = v }, {"nologo", "do not display logo", v=> nologo = null != v }, {"h|?|help", "show help", v=>help = v != null }	};	list<string> extra;	try {	extra = p.parse(args);	}	catch(optionexception e) {	return 1;	}	if (!nologo) {	
copyright c by remobjects software 

try {	extra = p.parse(args);	}	catch(optionexception e) {	return 1;	}	if (!nologo) {	}	if (help) {	console.writeline();	
lc c filename t targetassembly i references v o nologo 

extra = p.parse(args);	}	catch(optionexception e) {	return 1;	}	if (!nologo) {	}	if (help) {	console.writeline();	console.writeline();	
options 

}	if (!nologo) {	}	if (help) {	console.writeline();	console.writeline();	p.writeoptiondescriptions(console.out);	return 1;	}	if (extra.count > 0) {	
unexpected arguments passed on cmd line 

if (help) {	console.writeline();	console.writeline();	p.writeoptiondescriptions(console.out);	return 1;	}	if (extra.count > 0) {	return 1;	}	if (target == null || complist == null){	
no target complist passed 

return 1;	}	if (extra.count > 0) {	return 1;	}	if (target == null || complist == null){	return 1;	}	try {	if (!file.exists(complist)) {	
could not find file 

}	if (target == null || complist == null){	return 1;	}	try {	if (!file.exists(complist)) {	return 1;	}	lclicensecontext ctx = new lclicensecontext();	ctx.licxfilename = complist;	
input file 

if (target == null || complist == null){	return 1;	}	try {	if (!file.exists(complist)) {	return 1;	}	lclicensecontext ctx = new lclicensecontext();	ctx.licxfilename = complist;	ctx.outputfilename = path.combine(targetdir ??".", target)+".licenses";	
output filename 

}	lclicensecontext ctx = new lclicensecontext();	ctx.licxfilename = complist;	ctx.outputfilename = path.combine(targetdir ??".", target)+".licenses";	appdomain.currentdomain.assemblyresolve += new resolveeventhandler(currentdomain_assemblyresolve);	privatepaths.add(".");	dictionary<string, assembly> loaded = new dictionary<string, assembly>();	foreach (string reference in references) {	string path = path.getdirectoryname(reference);	if (!privatepaths.contains(path)) {	
adding to private paths 

appdomain.currentdomain.assemblyresolve += new resolveeventhandler(currentdomain_assemblyresolve);	privatepaths.add(".");	dictionary<string, assembly> loaded = new dictionary<string, assembly>();	foreach (string reference in references) {	string path = path.getdirectoryname(reference);	if (!privatepaths.contains(path)) {	privatepaths.add(path);	}	assembly asm = assembly.loadfrom(reference);	loaded.add(asm.getname().name, asm);	
loaded assembly 

assembly asm = assembly.loadfrom(reference);	loaded.add(asm.getname().name, asm);	}	using (streamreader sr = new streamreader(complist)) {	int lineno = 0;	string line = "";	while (sr.peek() != -1) {	try {	line = sr.readline();	if (line == null || line == "" || line[0] == '#' ) continue;	
generating license for 

line = sr.readline();	if (line == null || line == "" || line[0] == '#' ) continue;	string[] sline = line.split(new char[] { ',' }, 2);	type stype = null;	if (sline.length == 1) {	stype = type.gettype(line, false, true);	if (stype == null) {	foreach (keyvaluepair<string, assembly> et in loaded) {	stype = et.value.gettype(sline[0], false, true);	if (stype != null) {	
found type in 

else {	if (sline[1].indexof(',') >= 0) {	stype = type.gettype(line, false, true);	}	else {	string s = sline[1].trim();	foreach (keyvaluepair<string, assembly> et in loaded) {	if (string.compare(et.key, s, true, cultureinfo.invariantculture) == 0) {	stype = et.value.gettype(sline[0], false, true);	if (stype != null) {	
found type in 

stype = et.value.gettype(sline[0], false, true);	if (stype != null) {	break;	}	}	}	if (stype == null) {	foreach (keyvaluepair<string, assembly> et in loaded) {	stype = et.value.gettype(sline[0], false, true);	if (stype != null) {	
found type in 

break;	}	}	}	}	}	if (stype == null) throw new exception("unable to find type: " + line);	licensemanager.createwithcontext(stype, ctx);	}	catch(exception e) {	
exception during compiling 

console.writeline(e.tostring());	}	}	}	using (filestream fs = new filestream(ctx.outputfilename, filemode.create)) {	try {	designtimelicensecontextserializer.serialize(fs, target.toupper(cultureinfo.invariantculture), ctx);	} catch {}	if (fs.length == 0) intserialize(fs, target.toupper(cultureinfo.invariantculture), ctx);	}	
saved to 

}	}	using (filestream fs = new filestream(ctx.outputfilename, filemode.create)) {	try {	designtimelicensecontextserializer.serialize(fs, target.toupper(cultureinfo.invariantculture), ctx);	} catch {}	if (fs.length == 0) intserialize(fs, target.toupper(cultureinfo.invariantculture), ctx);	}	return 0;	} catch(exception e){	
exception 

========================= mono sample_1192 =========================

public bool postest1() {	bool retval = true;	compareresult expectedvalue = compareresult.equal;	compareresult actualvalue;	testlibrary.testframework.beginscenario("postest1:get the property and verify its fields");	try {	opcode opcode = opcodes.tailcall;	actualvalue = compareopcode(opcode, "tail.", stackbehaviour.pop0, stackbehaviour.push0, operandtype.inlinenone, opcodetype.prefix, 2, (byte)0xfe, (byte)0x14, flowcontrol.meta);	if (expectedvalue != actualvalue) {	
errors accured in fields 

compareresult actualvalue;	testlibrary.testframework.beginscenario("postest1:get the property and verify its fields");	try {	opcode opcode = opcodes.tailcall;	actualvalue = compareopcode(opcode, "tail.", stackbehaviour.pop0, stackbehaviour.push0, operandtype.inlinenone, opcodetype.prefix, 2, (byte)0xfe, (byte)0x14, flowcontrol.meta);	if (expectedvalue != actualvalue) {	retval = false;	}	}	catch (exception e) {	
unexpected exception 

========================= mono sample_730 =========================

static int main () {	d d = false && new d (1);	console.writeline (d.arg);	if (d.arg != 100) return 1;	
ok 

========================= mono sample_3357 =========================

public void setup () {	int i = 0;	do {	tempdir = path.combine (basetempdir, (++i).tostring());	} while (directory.exists (tempdir));	directory.createdirectory (tempdir);	fname = path.combine (tempdir, "basic.txt");	using (streamwriter sw = new streamwriter (fname)) {	
hello 

public void setup () {	int i = 0;	do {	tempdir = path.combine (basetempdir, (++i).tostring());	} while (directory.exists (tempdir));	directory.createdirectory (tempdir);	fname = path.combine (tempdir, "basic.txt");	using (streamwriter sw = new streamwriter (fname)) {	
world 

public void doubleaccountinginoffsetcalculation () {	var memorymappedfile90 = memorymappedfile.createnew (mknamedmapping (), 4194304, memorymappedfileaccess.readwrite);	var stream = memorymappedfile90.createviewstream (4186112, 3222, memorymappedfileaccess.write);	using (var tw = new streamwriter(stream)) {	
hello world 

========================= mono sample_18290 =========================

public override void added (xelement target, bool wasparentadded) {	string name = target.attribute ("name").value;	var addeddescription  = $"{state.namespace}.{name}: added type";	state.logdebugmessage ($"possible -n value: {addeddescription}");	if (state.ignorenew.any (re => re.ismatch (addeddescription))) return;	
div start type 

public override void added (xelement target, bool wasparentadded) {	string name = target.attribute ("name").value;	var addeddescription  = $"{state.namespace}.{name}: added type";	state.logdebugmessage ($"possible -n value: {addeddescription}");	if (state.ignorenew.any (re => re.ismatch (addeddescription))) return;	
new type 

public override void added (xelement target, bool wasparentadded) {	string name = target.attribute ("name").value;	var addeddescription  = $"{state.namespace}.{name}: added type";	state.logdebugmessage ($"possible -n value: {addeddescription}");	if (state.ignorenew.any (re => re.ismatch (addeddescription))) return;	output.writeline ("<pre class='added' data-is-non-breaking>");	state.indent = 0;	addedinner (target);	
pre 

public override void added (xelement target, bool wasparentadded) {	string name = target.attribute ("name").value;	var addeddescription  = $"{state.namespace}.{name}: added type";	state.logdebugmessage ($"possible -n value: {addeddescription}");	if (state.ignorenew.any (re => re.ismatch (addeddescription))) return;	output.writeline ("<pre class='added' data-is-non-breaking>");	state.indent = 0;	addedinner (target);	
div end type 

public void addedinner (xelement target) {	setcontext (target);	
serializable serializable 

public void addedinner (xelement target) {	setcontext (target);	var type = target.attribute ("type").value;	if (type == "enum") {	var cattrs = target.element ("attributes");	if (cattrs != null) {	foreach (var ca in cattrs.elements ("attribute")) {	if (ca.getattribute ("name") == "system.flagsattribute") {	
flags 

if (i != null) {	var interfaces = new list<string> ();	foreach (var iface in i.elements ("interface")) interfaces.add (icomparer.getdescription (iface));	output.write ((baseclass == null) ? " : " : ", ");	output.write (string.join (", ", interfaces));	}	}	output.writeline (" {");	var t = target.element ("constructors");	if (t != null) {	
foreach var ctor in t elements constructor ccomparer added ctor true 

var t = target.element ("constructors");	if (t != null) {	}	t = target.element ("fields");	if (t != null) {	if (type != "enum") indent ().writeline ("\t else setcontext (target);	foreach (var field in t.elements ("field")) fcomparer.added (field, true);	}	t = target.element ("properties");	if (t != null) {	
foreach var property in t elements property pcomparer added property true 

t = target.element ("fields");	if (t != null) {	if (type != "enum") indent ().writeline ("\t else setcontext (target);	foreach (var field in t.elements ("field")) fcomparer.added (field, true);	}	t = target.element ("properties");	if (t != null) {	}	t = target.element ("events");	if (t != null) {	
foreach var evnt in t elements event ecomparer added evnt true 

foreach (var field in t.elements ("field")) fcomparer.added (field, true);	}	t = target.element ("properties");	if (t != null) {	}	t = target.element ("events");	if (t != null) {	}	t = target.element ("methods");	if (t != null) {	
foreach var method in t elements method mcomparer added method true 

public override void modified (xelement source, xelement target, apichanges diff) {	var output = output;	state.output = new stringwriter ();	var sb = source.getattribute ("base");	var tb = target.getattribute ("base");	var rm = $"{state.namespace}.{state.type}: modified base type: '{sb}' to '{tb}'";	state.logdebugmessage ($"possible -r value: {rm}");	if (sb != tb && !state.ignoreremoved.any (re => re.ismatch (rm)) && !(state.ignorenonbreaking && isbasechangecompatible (sb, tb))) {	output.write ("modified base type: ");	
state namespace state type 

var si = source.element ("classes");	if (si != null) {	var ti = target.element ("classes");	kcomparer = new nestedclasscomparer ();	kcomparer.compare (si.elements ("class"), ti == null ? null : ti.elements ("class"));	}	var s = (output as stringwriter).tostring ();	state.output = output;	if (s.length > 0) {	var tn = gettypename (target);	
start type div 

var si = source.element ("classes");	if (si != null) {	var ti = target.element ("classes");	kcomparer = new nestedclasscomparer ();	kcomparer.compare (si.elements ("class"), ti == null ? null : ti.elements ("class"));	}	var s = (output as stringwriter).tostring ();	state.output = output;	if (s.length > 0) {	var tn = gettypename (target);	
type changed 

if (si != null) {	var ti = target.element ("classes");	kcomparer = new nestedclasscomparer ();	kcomparer.compare (si.elements ("class"), ti == null ? null : ti.elements ("class"));	}	var s = (output as stringwriter).tostring ();	state.output = output;	if (s.length > 0) {	var tn = gettypename (target);	output.writeline (s);	
div end type 

========================= mono sample_1312 =========================

public static int main() {	
test 

========================= mono sample_1384 =========================

private static bool verifyclientcertificate (object sender, x509certificate certificate, x509chain chain, sslpolicyerrors certificateerrors) {	if (certificate != null) {	console.writeline (certificate.tostring (true));	} else {	
no client certificate provided 

private static bool verifyclientcertificate (object sender, x509certificate certificate, x509chain chain, sslpolicyerrors certificateerrors) {	if (certificate != null) {	console.writeline (certificate.tostring (true));	} else {	}	console.writeline (chain);	
error 

========================= mono sample_23295 =========================

public static void main (string [] args) {	if (args.length < 1) {	
usage filename 

========================= mono sample_1326 =========================

public void resolvepeers () {	bindingflags binding = bindingflags.declaredonly | bindingflags.instance | bindingflags.nonpublic | bindingflags.public;	foreach (peer peer in peers) {	if (peer.isopaque || peer.isvaluetype || peer.clrtype.basetype == null) continue;	peer.nearestbase = getpeer (peer.clrtype.basetype);	if (peer.nearestbase == null) {	
error cannot find an internal base type for 

========================= mono sample_807 =========================

public void linqtosqloptimistic01() {	northwind db=createdb();	
you 

public void linqtosqloptimistic01() {	northwind db=createdb();	var product = db.products.first(p=>p.productid = 1);	console.writeline("~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~");	console.writeline();	
other user 

northwind db=createdb();	var product = db.products.first(p=>p.productid = 1);	console.writeline("~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~");	console.writeline();	var otheruser_db = northwind(my.settings.northwindconnectionstring1) with {.log = db.log};	var otheruser_product = otheruser_db.products.first(p=>p.productid = 1);	otheruser_product.unitprice = 999.99d;	otheruser_product.unitsonorder = 10;	otheruser_db.submitchanges();	console.writeline("~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~");	
you continued 

========================= mono sample_24686 =========================

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

streamwriter sw = new streamwriter(st);	sw.write("<?xml version=\"1.0\" standalone=\"yes\"?><newdataset>");	sw.write("<table><employeeno>9</employeeno></table>");	sw.write("</newdataset>");	sw.flush();	st.position=0;	dataset ds = new dataset();	ds.readxml(st);	ds.tables[0].columns.add("valuelistvaluemember", typeof(object), "employeeno");	foreach( datarow row in ds.tables[0].rows ) {	
valuelistvaluemember 

========================= mono sample_28992 =========================

for (testtimeout timeout = testtimeout.start(timespan.fromseconds(testtimeout.isstresstest ? 120 : 5)); timeout.havetimeleft;) {	thread worker = new thread (new threadstart (() => {	hashset<string> hashset = new hashset<string> ();	for (int i = 0; i < 50000; ++i) {	hashset.add(string.concat (i, i));	if (i % 10 == 0) thread.yield ();	}	}));	worker.start ();	threads.add (worker);	
started thread running concurrently 

}));	worker.start ();	threads.add (worker);	}	threads.completeadding ();	}));	thread consumer = new thread (new threadstart(() => {	while (!threads.iscompleted) {	thread worker = threads.take ();	worker.join ();	
joined thread 

========================= mono sample_704 =========================

public static void printfontinfo (font f) {	
font size in pixels 

========================= mono sample_21332 =========================

public static void main () {	float width = 400.0f;	float height = 800.0f;	fontcollection ifc = new installedfontcollection ();	foreach (fontfamily ffm in ifc.families) {	console.writeline (ffm.name);	}	font f = new font ("arial",12);	
height 

foreach (fontfamily ffm in ifc.families) {	console.writeline (ffm.name);	}	font f = new font ("arial",12);	bitmap bmp = new bitmap ((int) width, (int) height);	graphics gr = graphics.fromimage (bmp);	gr.clear (color.white);	brush br = new solidbrush (color.black);	gr.drawstring ("the test string", f, br, 10, 10);	bmp.save ("font.png", imageformat.png);	
output file font png 

========================= mono sample_21322 =========================

public static void main () {	object o = "hello world";	
blah 

public static void main () {	object o = "hello world";	
blah 

public static void main () {	object o = "hello world";	
blah 

public static void main () {	object o = "hello world";	
blah 

========================= mono sample_3322 =========================

public void rewritemdbfile (string inputfile) {	
processing 

static void usage (optionset options) {	
usage mdbrebase options assembly to fix 

static void usage (optionset options) {	if (options != null) {	console.writeline ();	
available options 

========================= mono sample_817 =========================

static void appdomainmethod () {	
two 

static void appdomainmethod () {	var socket = new socket (addressfamily.internetwork, sockettype.stream, protocoltype.tcp);	ipendpoint ep = new ipendpoint(ipaddress.any, 0);	socket.bind (ep);	socket.listen (10);	socket.beginaccept ( delegate {	
delegate should not be called 

static int main () {	var da = appdomain.createdomain ("le domain");	da.docallback (delegate { appdomainmethod ();});	
unloading 

static int main () {	var da = appdomain.createdomain ("le domain");	da.docallback (delegate { appdomainmethod ();});	appdomain.unload (da);	
done 

========================= mono sample_594 =========================

protected override void onapply (dependencyproperty dp, type targettype) {	base.onapply (dp, targettype);	
issealed in onapply 

========================= mono sample_21373 =========================

public static int main () {	list<foo> test = new list<foo> () {	new foo { name="b", value1=37, value2=2 }, new foo { name="b", value1=37, value2=1 }	};	var result = from item in test orderby item.name, item.value1, item.value2 select item;	var r = result.tolist ();	foreach (foo item in r) console.writeline ("{0}, {1}, {2}", item.name, item.value1, item.value2);	if (r[0].value2 != 1 && r[1].value2 != 2) return 1;	
ok 

========================= mono sample_3233 =========================

public static int main () {	if (2.test () != 11) return 1;	if (1.test (b : 2) != 5) return 2;	if (foo ("n", a : 4) != "n") return 3;	if (foo (t : "x", a : 4) != "x") return 4;	lambda (a : (a) => 1);	int var = 8;	lambda (a : (a) => var);	
ok 

========================= mono sample_1336 =========================

public static int main () {	s s = new s ();	string sss = "a" + s.tostring ();	b b = new b ();	int res = b.foo (1);	if (res != 2) return res;	
ok 

========================= mono sample_3380 =========================

public static int main (string[] args) {	if (args.length < 1) {	
usage mdbdump assembly 

========================= mono sample_1285 =========================

public delegate object delobj (object g, int i);	public delegate object delstr (object g, int i);	public class main {	public static int work () {	gen<string> gs = new gen<string> ();	gen<object> go = new gen<object> ();	methodinfo miobj = typeof (gen<object>).getmethod ("newarr", bindingflags.public | bindingflags.instance);	methodinfo mistr = typeof (gen<string>).getmethod ("newarr", bindingflags.public | bindingflags.instance);	if (miobj == mistr) {	
methods equal 

gen<object> go = new gen<object> ();	methodinfo miobj = typeof (gen<object>).getmethod ("newarr", bindingflags.public | bindingflags.instance);	methodinfo mistr = typeof (gen<string>).getmethod ("newarr", bindingflags.public | bindingflags.instance);	if (miobj == mistr) {	return 1;	}	objarrdel oad = go.newobjdel ();	strarrdel sad = gs.newstrdel ();	strarrdel sad2 = (strarrdel)delegate.createdelegate (typeof (strarrdel), null, mistr);	if (oad.method != miobj) {	
wrong object method 

return 1;	}	objarrdel oad = go.newobjdel ();	strarrdel sad = gs.newstrdel ();	strarrdel sad2 = (strarrdel)delegate.createdelegate (typeof (strarrdel), null, mistr);	if (oad.method != miobj) {	if (oad.method == mistr) console.writeline ("object method is string");	return 1;	}	if (sad.method != mistr) {	
wrong string method 

strarrdel sad = gs.newstrdel ();	strarrdel sad2 = (strarrdel)delegate.createdelegate (typeof (strarrdel), null, mistr);	if (oad.method != miobj) {	if (oad.method == mistr) console.writeline ("object method is string");	return 1;	}	if (sad.method != mistr) {	if (sad.method == miobj) console.writeline ("string method is object");	else return 1;	} else {	
right string method 

if (oad.method != miobj) {	if (oad.method == mistr) console.writeline ("object method is string");	return 1;	}	if (sad.method != mistr) {	if (sad.method == miobj) console.writeline ("string method is object");	else return 1;	} else {	}	if (sad2.method != mistr) {	
wrong method 

}	if (sad.method != mistr) {	if (sad.method == miobj) console.writeline ("string method is object");	else return 1;	} else {	}	if (sad2.method != mistr) {	if (sad2.method == miobj) console.writeline ("string2 method is object");	return 1;	}	
calling object del 

if (sad.method != mistr) {	if (sad.method == miobj) console.writeline ("string method is object");	else return 1;	} else {	}	if (sad2.method != mistr) {	if (sad2.method == miobj) console.writeline ("string2 method is object");	return 1;	}	if (oad (go, 3).gettype () != typeof (object [])) {	
not object array 

else return 1;	} else {	}	if (sad2.method != mistr) {	if (sad2.method == miobj) console.writeline ("string2 method is object");	return 1;	}	if (oad (go, 3).gettype () != typeof (object [])) {	return 1;	}	
calling string del 

} else {	}	if (sad2.method != mistr) {	if (sad2.method == miobj) console.writeline ("string2 method is object");	return 1;	}	if (oad (go, 3).gettype () != typeof (object [])) {	return 1;	}	if (sad (gs, 3).gettype () != typeof (string [])) {	
not string array 

if (sad2.method != mistr) {	if (sad2.method == miobj) console.writeline ("string2 method is object");	return 1;	}	if (oad (go, 3).gettype () != typeof (object [])) {	return 1;	}	if (sad (gs, 3).gettype () != typeof (string [])) {	return 1;	}	
calling string 

if (sad2.method == miobj) console.writeline ("string2 method is object");	return 1;	}	if (oad (go, 3).gettype () != typeof (object [])) {	return 1;	}	if (sad (gs, 3).gettype () != typeof (string [])) {	return 1;	}	if (sad2 (gs, 3).gettype () != typeof (string [])) {	
not array 

return 1;	}	if (sad (gs, 3).gettype () != typeof (string [])) {	return 1;	}	if (sad2 (gs, 3).gettype () != typeof (string [])) {	return 1;	}	try {	strarrdel sad3 = (strarrdel)delegate.createdelegate (typeof (strarrdel), null, miobj);	
object method for string delegate 

} catch (argumentexception) {	}	delobj delobj = (delobj)delegate.createdelegate (typeof (delobj), null, miobj);	if (delobj (go, 3).gettype () != typeof (object [])) return 1;	delstr delstr = (delstr)delegate.createdelegate (typeof (delstr), null, mistr);	if (delstr (gs, 3).gettype () != typeof (string [])) return 1;	arrdel ad = go.newdel ();	if (ad (3).gettype () != typeof (object [])) return 1;	ad = gs.newdel ();	if (ad (3).gettype () != typeof (string [])) return 1;	
done 

========================= mono sample_536 =========================

public bool bisect () {	
running to gather methods 

public bool bisect () {	var stdout = run (null);	if (stdout == null) {	
error failed to execute without optimization 

if (stdout == null) {	environment.exit (1);	}	var regex = new regex ("converting[^\n]* method ([^\n]+)\n");	var matches = regex.matches (stdout);	var methods = new list<string> ();	foreach (match match in matches) {	var method = match.groups [1].value;	methods.add (method);	}	
bisecting methods 

if (stdout == null) {	environment.exit (1);	}	var regex = new regex ("converting[^\n]* method ([^\n]+)\n");	var matches = regex.matches (stdout);	var methods = new list<string> ();	foreach (match match in matches) {	var method = match.groups [1].value;	methods.add (method);	}	
running with all methods just to make sure 

}	var regex = new regex ("converting[^\n]* method ([^\n]+)\n");	var matches = regex.matches (stdout);	var methods = new list<string> ();	foreach (match match in matches) {	var method = match.groups [1].value;	methods.add (method);	}	var success = runwithmethods (methods);	if (success) {	
error ran successfully with all methods optimized nothing to bisect 

var matches = regex.matches (stdout);	var methods = new list<string> ();	foreach (match match in matches) {	var method = match.groups [1].value;	methods.add (method);	}	var success = runwithmethods (methods);	if (success) {	return false;	}	
crashed bisecting 

static void usageandexit (int exitcode) {	
usage crash bisector exe mono mono executable opt option name mono arg 

========================= mono sample_4 =========================

public void dispose () {	
dispose 

========================= mono sample_3100 =========================

public static int main () {	if (!foo (null)) return 1;	if (!foo (new int [0])) return 2;	if (!new demo().fixed ()) return 3;	
ok 

========================= mono sample_3291 =========================

static void main () {	while (true) {	try {	
trying 

========================= mono sample_35587 =========================

public static void main (string[] args) {	if (args.length != 2) {	
usage input assembly output assembly 

public static void main (string[] args) {	if (args.length != 2) {	environment.exit (1);	}	string infile = args [0];	string outfile = args [1];	if (infile == outfile) {	
input and output file names needs to be different 

========================= mono sample_1302 =========================

public static int main() {	int[] arr = {1};	type t = arr.gettype ();	
type is 

public static int main() {	int[] arr = {1};	type t = arr.gettype ();	
type is array 

========================= mono sample_631 =========================

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
noncecache 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
caching timespan 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
capacity 

========================= mono sample_16052 =========================

}	catch (exception) {	}	exception = false;	a  = -1e30f;	try {	uint b = (uint) a;	checked {	ui = (uint)a;	}	
no exception 

k = -1;	if (j * k != -32767) return 28;	}	checked {	long l;	long m;	long[][] cases = new long [][] {	new long [] {0, 0, 0}, new long [] {-5, 0, 0}, new long [] {3, -5, -15}, new long [] {3, 5, 15}, new long [] {-3, -5, 15}, new long [] {-3, 5, -15}, new long [] {-1, 2147483647, -2147483647}, new long [] {2147483647, -1, -2147483647}};	for (int j = 0; j < cases.length; ++j) if (cases [j][0] * cases [j][1] != cases [j][2]) return 29 + j;	}	
test ok 

========================= mono sample_660 =========================

static private void help () {	
usage signcode options filename 

static private void help () {	
spc spc software publisher certificate file 

static private void help () {	
v pvk private key file 

static private void help () {	
a hash algorithm default 

static private void help () {	
indivisual commercial signature type 

static private void help () {	
n description description for the signed file 

static private void help () {	
i url url for the signed file 

static private void help () {	
timestamp options 

static private void help () {	
t url timestamp service http url 

static private void help () {	
tr number of retries for timestamp 

static private void help () {	
tw delay between retries 

static private void help () {	
x only timestamp no signature 

static private void help () {	
csp options 

static private void help () {	
k name key container name 

static private void help () {	
p name provider name 

static private void help () {	
y provider type 

static private void help () {	
ky signature exchange key type 

static private void help () {	
r localmachine currentuser key location 

static private rsa getprivatekey (string keyfile, cspparameters csp) {	rsa rsa = null;	if (keyfile != null) {	if (!file.exists (keyfile)) {	
couldn t find file 

rsa rsa = null;	if (keyfile != null) {	if (!file.exists (keyfile)) {	return null;	}	try {	privatekey pvk = privatekey.createfromfile (keyfile);	rsa = pvk.rsa;	}	catch (cryptographicexception) {	
enter password for 

privatekey pvk = privatekey.createfromfile (keyfile);	rsa = pvk.rsa;	}	catch (cryptographicexception) {	string password = console.readline ();	try {	privatekey pvk = privatekey.createfromfile (keyfile, password);	rsa = pvk.rsa;	}	catch (cryptographicexception) {	
invalid password 

static private x509certificatecollection getcertificates (string spcfile) {	if (spcfile == null) {	
missing spc certificate file 

static private x509certificatecollection getcertificates (string spcfile) {	if (spcfile == null) {	return null;	}	if (!file.exists (spcfile)) {	
couldn t find file 

case "-v": pvkfilename = args [i++];	break;	case "-a": af.hash = args [i++];	break;	case "-$": string auth = args [i++].tolower ();	switch (auth) {	case "individual": af.authority = authority.individual;	break;	case "commercial": af.authority = authority.commercial;	break;	
unknown authority 

default: csp.keynumber = convert.toint32 (key);	break;	}	break;	case "-r": string location = args [i++];	switch (location) {	case "localmachine": csp.flags = cspproviderflags.usemachinekeystore;	break;	case "currentuser": csp.flags = cspproviderflags.usedefaultkeycontainer;	break;	
unknown location 

break;	case "-r": string location = args [i++];	switch (location) {	case "localmachine": csp.flags = cspproviderflags.usemachinekeystore;	break;	case "currentuser": csp.flags = cspproviderflags.usedefaultkeycontainer;	break;	return 1;	}	break;	
j jp unsupported option 

break;	return 1;	}	break;	return 1;	case "-?": help ();	return 0;	}	}	if (!file.exists (tbsfilename)) {	
couldn t find 

case "-?": help ();	return 0;	}	}	if (!file.exists (tbsfilename)) {	return 1;	}	if (sign) {	rsa rsa = getprivatekey (pvkfilename, csp);	if (rsa == null) {	
no private key available to sign the assembly 

return 1;	}	if (sign) {	rsa rsa = getprivatekey (pvkfilename, csp);	if (rsa == null) {	return 1;	}	af.rsa = rsa;	x509certificatecollection certs = getcertificates (spcfilename);	if ((certs == null) || (certs.count == 0)) {	
no certificates available to sign the assembly 

if (rsa == null) {	return 1;	}	af.rsa = rsa;	x509certificatecollection certs = getcertificates (spcfilename);	if ((certs == null) || (certs.count == 0)) {	return 1;	}	af.certificates.addrange (certs);	if (!af.sign (tbsfilename)) {	
couldn t sign file 

}	af.certificates.addrange (certs);	if (!af.sign (tbsfilename)) {	return 1;	}	} else if (af.timestampurl != null) {	bool ts = false;	for (int j = 0; j < timestampretry && !ts; j++) {	ts = af.timestamp (tbsfilename);	if (!ts && (j < timestampretry - 1)) {	
couldn t timestamp file will retry in ms 

}	} else if (af.timestampurl != null) {	bool ts = false;	for (int j = 0; j < timestampretry && !ts; j++) {	ts = af.timestamp (tbsfilename);	if (!ts && (j < timestampretry - 1)) {	thread.sleep (timestampdelay);	}	}	if (!ts) {	
couldn t timestamp file after retries 

thread.sleep (timestampdelay);	}	}	if (!ts) {	return 1;	}	} else {	help ();	return 1;	}	
success 

========================= mono sample_1182 =========================

static void monotest(oracleconnection con) {	
drop table mono oracle test 

static void monotest(oracleconnection con) {	try {	oraclecommand cmd2 = con.createcommand ();	cmd2.commandtext = "drop table mono_oracle_test";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand cmd = null;	
creating table mono oracle test 

cmd2.commandtext = "drop table mono_oracle_test";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand cmd = null;	cmd = new oraclecommand();	cmd.connection = con;	cmd.commandtext = "create table mono_oracle_test ( " + " varchar2_value varchar2(32),  " + " long_value long, " + " number_whole_value number(18), " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " char_value char(32), " + " clob_value clob, " + " blob_value blob, " + " clob_empty_value clob, " + " blob_empty_value blob, " + " varchar2_null_value varchar2(32),  " + " number_whole_null_value number(18), " + " number_scaled_null_value number(18,2), " + " number_integer_null_value integer, " + " float_null_value float, " + " date_null_value date, " + " char_null_value char(32), " + " clob_null_value clob, " + " blob_null_value blob " + ")";	cmd.executenonquery();	
begin trans for table mono oracle test 

cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand cmd = null;	cmd = new oraclecommand();	cmd.connection = con;	cmd.commandtext = "create table mono_oracle_test ( " + " varchar2_value varchar2(32),  " + " long_value long, " + " number_whole_value number(18), " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " char_value char(32), " + " clob_value clob, " + " blob_value blob, " + " clob_empty_value clob, " + " blob_empty_value blob, " + " varchar2_null_value varchar2(32),  " + " number_whole_null_value number(18), " + " number_scaled_null_value number(18,2), " + " number_integer_null_value integer, " + " float_null_value float, " + " date_null_value date, " + " char_null_value char(32), " + " clob_null_value clob, " + " blob_null_value blob " + ")";	cmd.executenonquery();	oracletransaction trans = con.begintransaction ();	
inserting value into mono oracle test 

cmd = new oraclecommand();	cmd.connection = con;	cmd.commandtext = "create table mono_oracle_test ( " + " varchar2_value varchar2(32),  " + " long_value long, " + " number_whole_value number(18), " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " char_value char(32), " + " clob_value clob, " + " blob_value blob, " + " clob_empty_value clob, " + " blob_empty_value blob, " + " varchar2_null_value varchar2(32),  " + " number_whole_null_value number(18), " + " number_scaled_null_value number(18,2), " + " number_integer_null_value integer, " + " float_null_value float, " + " date_null_value date, " + " char_null_value char(32), " + " clob_null_value clob, " + " blob_null_value blob " + ")";	cmd.executenonquery();	oracletransaction trans = con.begintransaction ();	cmd = new oraclecommand();	cmd.connection = con;	cmd.transaction = trans;	cmd.commandtext = "insert into mono_oracle_test " + " ( varchar2_value,  " + "  long_value, " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  char_value, " + "  clob_value, " + "  blob_value, " + "  clob_empty_value, " + "  blob_empty_value " + ") " + " values( " + "  'mono', " + "  'this is a long column', " + "  123, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  'us', " + "  empty_clob(), " + "  empty_blob()," + "  empty_clob(), " + "  empty_blob()" + ")";	cmd.executenonquery();	
select update clob columns on table mono oracle test 

oracletransaction trans = con.begintransaction ();	cmd = new oraclecommand();	cmd.connection = con;	cmd.transaction = trans;	cmd.commandtext = "insert into mono_oracle_test " + " ( varchar2_value,  " + "  long_value, " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  char_value, " + "  clob_value, " + "  blob_value, " + "  clob_empty_value, " + "  blob_empty_value " + ") " + " values( " + "  'mono', " + "  'this is a long column', " + "  123, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  'us', " + "  empty_clob(), " + "  empty_blob()," + "  empty_clob(), " + "  empty_blob()" + ")";	cmd.executenonquery();	oraclecommand select = con.createcommand ();	select.transaction = trans;	select.commandtext = "select clob_value, blob_value from mono_oracle_test for update";	oracledatareader reader = select.executereader ();	
error record not found 

oracletransaction trans = con.begintransaction ();	cmd = new oraclecommand();	cmd.connection = con;	cmd.transaction = trans;	cmd.commandtext = "insert into mono_oracle_test " + " ( varchar2_value,  " + "  long_value, " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  char_value, " + "  clob_value, " + "  blob_value, " + "  clob_empty_value, " + "  blob_empty_value " + ") " + " values( " + "  'mono', " + "  'this is a long column', " + "  123, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  'us', " + "  empty_clob(), " + "  empty_blob()," + "  empty_clob(), " + "  empty_blob()" + ")";	cmd.executenonquery();	oraclecommand select = con.createcommand ();	select.transaction = trans;	select.commandtext = "select clob_value, blob_value from mono_oracle_test for update";	oracledatareader reader = select.executereader ();	
update clob column on table mono oracle test 

oraclecommand select = con.createcommand ();	select.transaction = trans;	select.commandtext = "select clob_value, blob_value from mono_oracle_test for update";	oracledatareader reader = select.executereader ();	oraclelob clob = reader.getoraclelob (0);	byte[] bytes = null;	unicodeencoding encoding = new unicodeencoding ();	bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	
update blob column on table mono oracle test 

oraclelob clob = reader.getoraclelob (0);	byte[] bytes = null;	unicodeencoding encoding = new unicodeencoding ();	bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	
commit trans for table mono oracle test 

byte[] bytes = null;	unicodeencoding encoding = new unicodeencoding ();	bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	
read simple test for table mono oracle test 

unicodeencoding encoding = new unicodeencoding ();	bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	
executescalar tests 

bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	
string value 

bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	
read scalar number whole value 

clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	
value 

clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	
read scalar number scaled value 

clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	
decimal value 

clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	
read scalar date value 

oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	
datetime value 

oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	
read scalar clob value 

bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	
clob value 

bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	
read scalar blob value 

blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	
blob value 

blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	
executeoraclescalar tests 

blob.close ();	trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	
read oracle scalar value 

trans.commit ();	readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	readoraclescalar (con,"select max(varchar2_value) from mono_oracle_test");	
read oracle scalar number whole value 

readsimpletest(con, "select * from mono_oracle_test");	string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	readoraclescalar (con,"select max(varchar2_value) from mono_oracle_test");	readoraclescalar (con,"select max(number_whole_value) from mono_oracle_test");	
read oracle scalar number scaled value 

string varchar2_value = (string) readscalar (con,"select max(varchar2_value) from mono_oracle_test");	decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	readoraclescalar (con,"select max(varchar2_value) from mono_oracle_test");	readoraclescalar (con,"select max(number_whole_value) from mono_oracle_test");	readoraclescalar (con,"select number_scaled_value from mono_oracle_test");	
read oracle scalar date value 

decimal number_whole_value = (decimal) readscalar (con,"select max(number_whole_value) from mono_oracle_test");	decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	readoraclescalar (con,"select max(varchar2_value) from mono_oracle_test");	readoraclescalar (con,"select max(number_whole_value) from mono_oracle_test");	readoraclescalar (con,"select number_scaled_value from mono_oracle_test");	readoraclescalar (con,"select date_value from mono_oracle_test");	
read oracle scalar clob value 

decimal number_scaled_value = (decimal) readscalar (con,"select number_scaled_value from mono_oracle_test");	datetime date_value = (datetime) readscalar (con,"select date_value from mono_oracle_test");	string clob_value = (string) readscalar (con,"select clob_value from mono_oracle_test");	byte[] blob_value = (byte[]) readscalar (con,"select blob_value from mono_oracle_test");	string sblob_value = gethexstring (blob_value);	readoraclescalar (con,"select max(varchar2_value) from mono_oracle_test");	readoraclescalar (con,"select max(number_whole_value) from mono_oracle_test");	readoraclescalar (con,"select number_scaled_value from mono_oracle_test");	readoraclescalar (con,"select date_value from mono_oracle_test");	readoraclescalar (con,"select clob_value from mono_oracle_test");	
read oracle scalar blob value 

static object readscalar (oracleconnection con, string selectsql) {	oraclecommand cmd = null;	cmd = con.createcommand();	cmd.commandtext = selectsql;	object o = cmd.executescalar ();	string datatype = o.gettype ().tostring ();	
datatype 

static void readoraclescalar (oracleconnection con, string selectsql) {	oraclecommand cmd = null;	cmd = con.createcommand();	cmd.commandtext = selectsql;	object o = cmd.executeoraclescalar ();	string datatype = o.gettype ().tostring ();	
datatype 

static void readoraclescalar (oracleconnection con, string selectsql) {	oraclecommand cmd = null;	cmd = con.createcommand();	cmd.commandtext = selectsql;	object o = cmd.executeoraclescalar ();	string datatype = o.gettype ().tostring ();	if (datatype.equals("system.data.oracleclient.oraclelob")) o = ((oraclelob) o).value;	if (o.gettype ().tostring ().equals ("system.byte[]")) o = gethexstring ((byte[])o);	
value 

static void readsimpletest(oracleconnection con, string selectsql) {	oraclecommand cmd = null;	oracledatareader reader = null;	cmd = con.createcommand();	cmd.commandtext = selectsql;	reader = cmd.executereader();	
results 

static void readsimpletest(oracleconnection con, string selectsql) {	oraclecommand cmd = null;	oracledatareader reader = null;	cmd = con.createcommand();	cmd.commandtext = selectsql;	reader = cmd.executereader();	
schema 

static void readsimpletest(oracleconnection con, string selectsql) {	oraclecommand cmd = null;	oracledatareader reader = null;	cmd = con.createcommand();	cmd.commandtext = selectsql;	reader = cmd.executereader();	datatable table;	table = reader.getschematable();	for(int c = 0; c < reader.fieldcount; c++) {	
column 

datatable table;	table = reader.getschematable();	for(int c = 0; c < reader.fieldcount; c++) {	datarow row = table.rows[c];	string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	
columnname 

datatable table;	table = reader.getschematable();	for(int c = 0; c < reader.fieldcount; c++) {	datarow row = table.rows[c];	string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	
basecolumnname 

datatable table;	table = reader.getschematable();	for(int c = 0; c < reader.fieldcount; c++) {	datarow row = table.rows[c];	string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	
columnsize 

datatable table;	table = reader.getschematable();	for(int c = 0; c < reader.fieldcount; c++) {	datarow row = table.rows[c];	string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	
numericscale 

datatable table;	table = reader.getschematable();	for(int c = 0; c < reader.fieldcount; c++) {	datarow row = table.rows[c];	string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	
numericprecision 

datatable table;	table = reader.getschematable();	for(int c = 0; c < reader.fieldcount; c++) {	datarow row = table.rows[c];	string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	
datatype 

for(int c = 0; c < reader.fieldcount; c++) {	datarow row = table.rows[c];	string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	}	int r = 0;	
data 

string strcolumnname = row["columnname"].tostring();	string strbasecolumnname = row["basecolumnname"].tostring();	string strcolumnsize = row["columnsize"].tostring();	string strnumericscale = row["numericscale"].tostring();	string strnumericprecision = row["numericprecision"].tostring();	string strdatatype = row["datatype"].tostring();	}	int r = 0;	while (reader.read ()) {	r++;	
row 

break;	case "system.data.oracleclient.oracledatetime": oravalue = ((oracledatetime) ovalue).value;	break;	case "system.byte[]": oravalue = gethexstring((byte[])ovalue);	break;	case "system.decimal": decimal dec = reader.getdecimal (f);	oravalue = (object) dec;	try {	reader.getint16 (f);	} catch (notsupportedexception e) {	
expected exception caught for notsupportedexception 

try {	reader.getint16 (f);	} catch (notsupportedexception e) {	}	try {	long lng = reader.getint64 (f);	console.writeline("           getint64: " + lng.tostring ());	int n = reader.getint32 (f);	console.writeline("           getint32: " + n.tostring ());	float flt = reader.getfloat (f);	
getfloat 

reader.getint16 (f);	} catch (notsupportedexception e) {	}	try {	long lng = reader.getint64 (f);	console.writeline("           getint64: " + lng.tostring ());	int n = reader.getint32 (f);	console.writeline("           getint32: " + n.tostring ());	float flt = reader.getfloat (f);	double dbl = reader.getdouble (f);	
getdouble 

} catch (notsupportedexception e) {	}	try {	long lng = reader.getint64 (f);	console.writeline("           getint64: " + lng.tostring ());	int n = reader.getint32 (f);	console.writeline("           getint32: " + n.tostring ());	float flt = reader.getfloat (f);	double dbl = reader.getdouble (f);	} catch (overflowexception oe1) {	
overflow exception for numbers to big or too small 

break;	default: oravalue = ovalue.tostring ();	break;	}	soradatatype = oravalue.gettype ().tostring ();	if (soradatatype.equals ("system.byte[]")) svalue = gethexstring ((byte[]) oravalue);	else svalue = oravalue.tostring();	}	sfieldtype = reader.getfieldtype(f).tostring();	sdatatypename = reader.getdatatypename(f);	
field 

break;	default: oravalue = ovalue.tostring ();	break;	}	soradatatype = oravalue.gettype ().tostring ();	if (soradatatype.equals ("system.byte[]")) svalue = gethexstring ((byte[]) oravalue);	else svalue = oravalue.tostring();	}	sfieldtype = reader.getfieldtype(f).tostring();	sdatatypename = reader.getdatatypename(f);	
name 

break;	default: oravalue = ovalue.tostring ();	break;	}	soradatatype = oravalue.gettype ().tostring ();	if (soradatatype.equals ("system.byte[]")) svalue = gethexstring ((byte[]) oravalue);	else svalue = oravalue.tostring();	}	sfieldtype = reader.getfieldtype(f).tostring();	sdatatypename = reader.getdatatypename(f);	
value 

break;	default: oravalue = ovalue.tostring ();	break;	}	soradatatype = oravalue.gettype ().tostring ();	if (soradatatype.equals ("system.byte[]")) svalue = gethexstring ((byte[]) oravalue);	else svalue = oravalue.tostring();	}	sfieldtype = reader.getfieldtype(f).tostring();	sdatatypename = reader.getdatatypename(f);	
oracle data type 

break;	default: oravalue = ovalue.tostring ();	break;	}	soradatatype = oravalue.gettype ().tostring ();	if (soradatatype.equals ("system.byte[]")) svalue = gethexstring ((byte[]) oravalue);	else svalue = oravalue.tostring();	}	sfieldtype = reader.getfieldtype(f).tostring();	sdatatypename = reader.getdatatypename(f);	
data type 

break;	default: oravalue = ovalue.tostring ();	break;	}	soradatatype = oravalue.gettype ().tostring ();	if (soradatatype.equals ("system.byte[]")) svalue = gethexstring ((byte[]) oravalue);	else svalue = oravalue.tostring();	}	sfieldtype = reader.getfieldtype(f).tostring();	sdatatypename = reader.getdatatypename(f);	
field type 

break;	default: oravalue = ovalue.tostring ();	break;	}	soradatatype = oravalue.gettype ().tostring ();	if (soradatatype.equals ("system.byte[]")) svalue = gethexstring ((byte[]) oravalue);	else svalue = oravalue.tostring();	}	sfieldtype = reader.getfieldtype(f).tostring();	sdatatypename = reader.getdatatypename(f);	
data type name 

static void dataadaptertest (oracleconnection connection) {	
create select command 

static void dataadaptertest (oracleconnection connection) {	oraclecommand command = connection.createcommand ();	command.commandtext = "select * from scott.emp";	
create data adapter 

static void dataadaptertest (oracleconnection connection) {	oraclecommand command = connection.createcommand ();	command.commandtext = "select * from scott.emp";	oracledataadapter adapter = new oracledataadapter (command);	
create dataset 

static void dataadaptertest (oracleconnection connection) {	oraclecommand command = connection.createcommand ();	command.commandtext = "select * from scott.emp";	oracledataadapter adapter = new oracledataadapter (command);	dataset dataset = new dataset ("emp");	
fill dataset via data adapter 

static void dataadaptertest (oracleconnection connection) {	oraclecommand command = connection.createcommand ();	command.commandtext = "select * from scott.emp";	oracledataadapter adapter = new oracledataadapter (command);	dataset dataset = new dataset ("emp");	adapter.fill (dataset);	
get datatable 

static void dataadaptertest (oracleconnection connection) {	oraclecommand command = connection.createcommand ();	command.commandtext = "select * from scott.emp";	oracledataadapter adapter = new oracledataadapter (command);	dataset dataset = new dataset ("emp");	adapter.fill (dataset);	datatable table = dataset.tables [0];	
display each row 

static void dataadaptertest (oracleconnection connection) {	oraclecommand command = connection.createcommand ();	command.commandtext = "select * from scott.emp";	oracledataadapter adapter = new oracledataadapter (command);	dataset dataset = new dataset ("emp");	adapter.fill (dataset);	datatable table = dataset.tables [0];	int rowcount = 0;	foreach (datarow row in table.rows) {	
row 

public static void getmetadata (oracleconnection con, string sql) {	oraclecommand cmd = null;	oracledatareader rdr = null;	cmd = con.createcommand();	cmd.commandtext = sql;	
read schema with keyinfo 

oraclecommand cmd = null;	oracledatareader rdr = null;	cmd = con.createcommand();	cmd.commandtext = sql;	rdr = cmd.executereader(commandbehavior.keyinfo | commandbehavior.schemaonly);	datatable dt;	dt = rdr.getschematable();	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) {	console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	
type 

cmd.commandtext = sql;	rdr = cmd.executereader(commandbehavior.keyinfo | commandbehavior.schemaonly);	datatable dt;	dt = rdr.getschematable();	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) {	console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	}	console.writeline("");	}	
read schema with no keyinfo 

foreach (datacolumn schemacol in dt.columns) {	console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	}	console.writeline("");	}	rdr = cmd.executereader();	dt = rdr.getschematable();	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) {	console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	
type 

public static void dataadaptertest2_setup (oracleconnection con) {	
drop table mono adapter test 

public static void dataadaptertest2_setup (oracleconnection con) {	try {	oraclecommand cmd2 = con.createcommand ();	cmd2.commandtext = "drop table mono_adapter_test";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand cmd = null;	
creating table mono adapter test 

cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand cmd = null;	cmd = new oraclecommand ();	cmd.connection = con;	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18) primary key, " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " clob_value clob, " + " blob_value blob ) ";	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18) primary key, " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " char_value char(32), " + " clob_value clob, " + " blob_value blob ) ";	cmd.executenonquery();	
begin trans for table mono adapter test 

}	catch (oracleexception) {	}	oraclecommand cmd = null;	cmd = new oraclecommand ();	cmd.connection = con;	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18) primary key, " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " clob_value clob, " + " blob_value blob ) ";	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18) primary key, " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " char_value char(32), " + " clob_value clob, " + " blob_value blob ) ";	cmd.executenonquery();	oracletransaction trans = con.begintransaction ();	
inserting value into mono adapter test 

cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18) primary key, " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " clob_value clob, " + " blob_value blob ) ";	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18) primary key, " + " number_scaled_value number(18,2), " + " number_integer_value integer, " + " float_value float, " + " date_value date, " + " char_value char(32), " + " clob_value clob, " + " blob_value blob ) ";	cmd.executenonquery();	oracletransaction trans = con.begintransaction ();	cmd = new oraclecommand();	cmd.connection = con;	cmd.transaction = trans;	cmd.commandtext = "insert into mono_adapter_test " + " ( varchar2_value,  " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  clob_value, " + "  blob_value " + ") " + " values( " + "  'mono', " + "  11, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  empty_clob(), " + "  empty_blob() " + ")";	cmd.commandtext = "insert into mono_adapter_test " + " ( varchar2_value,  " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  char_value, " + "  clob_value, " + "  blob_value " + ") " + " values( " + "  'mono', " + "  11, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  'us', " + "  empty_clob(), " + "  empty_blob() " + ")";	cmd.executenonquery();	
select update clob columns on table mono adapter test 

cmd = new oraclecommand();	cmd.connection = con;	cmd.transaction = trans;	cmd.commandtext = "insert into mono_adapter_test " + " ( varchar2_value,  " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  clob_value, " + "  blob_value " + ") " + " values( " + "  'mono', " + "  11, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  empty_clob(), " + "  empty_blob() " + ")";	cmd.commandtext = "insert into mono_adapter_test " + " ( varchar2_value,  " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  char_value, " + "  clob_value, " + "  blob_value " + ") " + " values( " + "  'mono', " + "  11, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  'us', " + "  empty_clob(), " + "  empty_blob() " + ")";	cmd.executenonquery();	oraclecommand select = con.createcommand ();	select.transaction = trans;	select.commandtext = "select clob_value, blob_value from mono_adapter_test for update";	oracledatareader reader = select.executereader ();	
error record not found 

cmd = new oraclecommand();	cmd.connection = con;	cmd.transaction = trans;	cmd.commandtext = "insert into mono_adapter_test " + " ( varchar2_value,  " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  clob_value, " + "  blob_value " + ") " + " values( " + "  'mono', " + "  11, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  empty_clob(), " + "  empty_blob() " + ")";	cmd.commandtext = "insert into mono_adapter_test " + " ( varchar2_value,  " + "  number_whole_value, " + "  number_scaled_value, " + "  number_integer_value, " + "  float_value, " + "  date_value, " + "  char_value, " + "  clob_value, " + "  blob_value " + ") " + " values( " + "  'mono', " + "  11, " + "  456.78, " + "  8765, " + "  235.2, " + "  to_date( '2004-12-31', 'yyyy-mm-dd' ), " + "  'us', " + "  empty_clob(), " + "  empty_blob() " + ")";	cmd.executenonquery();	oraclecommand select = con.createcommand ();	select.transaction = trans;	select.commandtext = "select clob_value, blob_value from mono_adapter_test for update";	oracledatareader reader = select.executereader ();	
update clob column on table mono adapter test 

oraclecommand select = con.createcommand ();	select.transaction = trans;	select.commandtext = "select clob_value, blob_value from mono_adapter_test for update";	oracledatareader reader = select.executereader ();	oraclelob clob = reader.getoraclelob (0);	byte[] bytes = null;	unicodeencoding encoding = new unicodeencoding ();	bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	
update blob column on table mono adapter test 

oraclelob clob = reader.getoraclelob (0);	byte[] bytes = null;	unicodeencoding encoding = new unicodeencoding ();	bytes = encoding.getbytes ("mono is fun!");	clob.write (bytes, 0, bytes.length);	clob.close ();	oraclelob blob = reader.getoraclelob (1);	bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	
commit trans for table mono adapter test 

public static void dataadaptertest2_insert (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter insert =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	
create adapter 

public static void dataadaptertest2_insert (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter insert =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	da.selectcommand.transaction = transaction;	
create command builder 

public static void dataadaptertest2_insert (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter insert =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	da.selectcommand.transaction = transaction;	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	
create data set 

public static void dataadaptertest2_insert (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter insert =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	da.selectcommand.transaction = transaction;	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	
fill data set via adapter 

public static void dataadaptertest2_insert (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter insert =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	da.selectcommand.transaction = transaction;	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	
new row 

console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	da.selectcommand.transaction = transaction;	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	datarow myrow;	myrow = ds.tables["mono_adapter_test"].newrow();	byte[] bytes = new byte[] { 0x45,0x46,0x47,0x48,0x49,0x50 };	
set values in the new datarow 

da.fill(ds, "mono_adapter_test");	datarow myrow;	myrow = ds.tables["mono_adapter_test"].newrow();	byte[] bytes = new byte[] { 0x45,0x46,0x47,0x48,0x49,0x50 };	myrow["varchar2_value"] = "oracleclient";	myrow["number_whole_value"] = 22;	myrow["number_scaled_value"] = 12.34;	myrow["number_integer_value"] = 456;	myrow["float_value"] = 98.76;	myrow["date_value"] = new datetime(2001,07,09);	
fixme char value not working 

myrow = ds.tables["mono_adapter_test"].newrow();	byte[] bytes = new byte[] { 0x45,0x46,0x47,0x48,0x49,0x50 };	myrow["varchar2_value"] = "oracleclient";	myrow["number_whole_value"] = 22;	myrow["number_scaled_value"] = 12.34;	myrow["number_integer_value"] = 456;	myrow["float_value"] = 98.76;	myrow["date_value"] = new datetime(2001,07,09);	myrow["clob_value"] = "clobtest";	myrow["blob_value"] = bytes;	
add datarow to datatable 

byte[] bytes = new byte[] { 0x45,0x46,0x47,0x48,0x49,0x50 };	myrow["varchar2_value"] = "oracleclient";	myrow["number_whole_value"] = 22;	myrow["number_scaled_value"] = 12.34;	myrow["number_integer_value"] = 456;	myrow["float_value"] = 98.76;	myrow["date_value"] = new datetime(2001,07,09);	myrow["clob_value"] = "clobtest";	myrow["blob_value"] = bytes;	ds.tables["mono_adapter_test"].rows.add(myrow);	
da update ds 

public static void dataadaptertest2_update (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter update =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	
create adapter 

public static void dataadaptertest2_update (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter update =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oraclecommand selectcmd = con.createcommand ();	selectcmd.transaction = transaction;	selectcmd.commandtext = "select * from mono_adapter_test";	oracledataadapter da = new oracledataadapter(selectcmd);	
create command builder 

public static void dataadaptertest2_update (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter update =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oraclecommand selectcmd = con.createcommand ();	selectcmd.transaction = transaction;	selectcmd.commandtext = "select * from mono_adapter_test";	oracledataadapter da = new oracledataadapter(selectcmd);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	
create data set 

console.writeline("================================");	console.writeline("=== adapter update =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oraclecommand selectcmd = con.createcommand ();	selectcmd.transaction = transaction;	selectcmd.commandtext = "select * from mono_adapter_test";	oracledataadapter da = new oracledataadapter(selectcmd);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	
set missing schema action 

console.writeline("================================");	console.writeline("=== adapter update =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oraclecommand selectcmd = con.createcommand ();	selectcmd.transaction = transaction;	selectcmd.commandtext = "select * from mono_adapter_test";	oracledataadapter da = new oracledataadapter(selectcmd);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	
fill data set via adapter 

console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oraclecommand selectcmd = con.createcommand ();	selectcmd.transaction = transaction;	selectcmd.commandtext = "select * from mono_adapter_test";	oracledataadapter da = new oracledataadapter(selectcmd);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	datarow myrow;	
new row 

oracletransaction transaction = con.begintransaction ();	oraclecommand selectcmd = con.createcommand ();	selectcmd.transaction = transaction;	selectcmd.commandtext = "select * from mono_adapter_test";	oracledataadapter da = new oracledataadapter(selectcmd);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	datarow myrow;	myrow = ds.tables["mono_adapter_test"].rows[0];	
tables count 

selectcmd.commandtext = "select * from mono_adapter_test";	oracledataadapter da = new oracledataadapter(selectcmd);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	datarow myrow;	myrow = ds.tables["mono_adapter_test"].rows[0];	datatable table = ds.tables["mono_adapter_test"];	datarowcollection rows;	rows = table.rows;	
row count 

oraclecommandbuilder mycb = new oraclecommandbuilder(da);	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	datarow myrow;	myrow = ds.tables["mono_adapter_test"].rows[0];	datatable table = ds.tables["mono_adapter_test"];	datarowcollection rows;	rows = table.rows;	myrow = rows[0];	byte[] bytes = new byte[] { 0x62,0x63,0x64,0x65,0x66,0x67 };	
set values in the new datarow 

rows = table.rows;	myrow = rows[0];	byte[] bytes = new byte[] { 0x62,0x63,0x64,0x65,0x66,0x67 };	myrow["varchar2_value"] = "super power!";	myrow["number_scaled_value"] = 12.35;	myrow["number_integer_value"] = 457;	myrow["float_value"] = 198.76;	myrow["date_value"] = new datetime(2002,08,09);	myrow["clob_value"] = "this is a clob";	myrow["blob_value"] = bytes;	
da update ds 

public static void dataadaptertest2_delete (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	
create adapter 

public static void dataadaptertest2_delete (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	
create command builder 

public static void dataadaptertest2_delete (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	
set transr 

public static void dataadaptertest2_delete (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	da.selectcommand.transaction = transaction;	
create data set 

public static void dataadaptertest2_delete (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	da.selectcommand.transaction = transaction;	dataset ds = new dataset();	
fill data set via adapter 

public static void dataadaptertest2_delete (oracleconnection con) {	console.writeline("================================");	console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	da.selectcommand.transaction = transaction;	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	
delete row 

console.writeline("================================");	console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	da.selectcommand.transaction = transaction;	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	ds.tables["mono_adapter_test"].rows[0].delete();	
da update table 

console.writeline("=== adapter delete =============");	console.writeline("================================");	oracletransaction transaction = con.begintransaction ();	oracledataadapter da = new oracledataadapter("select * from mono_adapter_test", con);	oraclecommandbuilder mycb = new oraclecommandbuilder(da);	da.selectcommand.transaction = transaction;	dataset ds = new dataset();	da.fill(ds, "mono_adapter_test");	ds.tables["mono_adapter_test"].rows[0].delete();	da.update(ds, "mono_adapter_test");	
commit 

static void testnonqueryusingexecutereader(oracleconnection con) {	oracledatareader reader = null;	oracletransaction trans = null;	
drop table mono adapter test 

static void testnonqueryusingexecutereader(oracleconnection con) {	oracledatareader reader = null;	oracletransaction trans = null;	oraclecommand cmd = con.createcommand();	cmd.commandtext = "drop table mono_adapter_test";	trans = con.begintransaction();	cmd.transaction = trans;	try {	reader = cmd.executereader();	
rowsaffected before read 

static void testnonqueryusingexecutereader(oracleconnection con) {	oracledatareader reader = null;	oracletransaction trans = null;	oraclecommand cmd = con.createcommand();	cmd.commandtext = "drop table mono_adapter_test";	trans = con.begintransaction();	cmd.transaction = trans;	try {	reader = cmd.executereader();	reader.read();	
rowsaffected after read 

oracledatareader reader = null;	oracletransaction trans = null;	oraclecommand cmd = con.createcommand();	cmd.commandtext = "drop table mono_adapter_test";	trans = con.begintransaction();	cmd.transaction = trans;	try {	reader = cmd.executereader();	reader.read();	reader.close();	
rowsaffected after close 

cmd.commandtext = "drop table mono_adapter_test";	trans = con.begintransaction();	cmd.transaction = trans;	try {	reader = cmd.executereader();	reader.read();	reader.close();	trans.commit();	}	catch(oracleexception e) {	
oracleexception caught 

cmd.transaction = trans;	try {	reader = cmd.executereader();	reader.read();	reader.close();	trans.commit();	}	catch(oracleexception e) {	trans.commit();	}	
create table mono adapter test 

reader.close();	trans.commit();	}	catch(oracleexception e) {	trans.commit();	}	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18,0) primary key ) ";	trans = con.begintransaction();	cmd.transaction = trans;	reader = cmd.executereader();	
rowsaffected before read 

trans.commit();	}	catch(oracleexception e) {	trans.commit();	}	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18,0) primary key ) ";	trans = con.begintransaction();	cmd.transaction = trans;	reader = cmd.executereader();	reader.read();	
rowsaffected after read 

}	catch(oracleexception e) {	trans.commit();	}	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18,0) primary key ) ";	trans = con.begintransaction();	cmd.transaction = trans;	reader = cmd.executereader();	reader.read();	reader.close();	
rowsaffected after close 

catch(oracleexception e) {	trans.commit();	}	cmd.commandtext = "create table mono_adapter_test ( " + " varchar2_value varchar2(32),  " + " number_whole_value number(18,0) primary key ) ";	trans = con.begintransaction();	cmd.transaction = trans;	reader = cmd.executereader();	reader.read();	reader.close();	trans.commit();	
insert into table mono adapter test 

cmd2.commandtext = sql;	oracleparameter myparameter1 = new oracleparameter("p1", oracletype.varchar, 32);	myparameter1.direction = parameterdirection.input;	oracleparameter myparameter2 = new oracleparameter("p2", oracletype.number);	myparameter2.direction = parameterdirection.input;	myparameter2.value = 182;	myparameter1.value = "mono";	cmd2.parameters.add (myparameter1);	cmd2.parameters.add (myparameter2);	reader = cmd2.executereader();	
rowsaffected before read 

oracleparameter myparameter1 = new oracleparameter("p1", oracletype.varchar, 32);	myparameter1.direction = parameterdirection.input;	oracleparameter myparameter2 = new oracleparameter("p2", oracletype.number);	myparameter2.direction = parameterdirection.input;	myparameter2.value = 182;	myparameter1.value = "mono";	cmd2.parameters.add (myparameter1);	cmd2.parameters.add (myparameter2);	reader = cmd2.executereader();	reader.read();	
rowsaffected after read 

myparameter1.direction = parameterdirection.input;	oracleparameter myparameter2 = new oracleparameter("p2", oracletype.number);	myparameter2.direction = parameterdirection.input;	myparameter2.value = 182;	myparameter1.value = "mono";	cmd2.parameters.add (myparameter1);	cmd2.parameters.add (myparameter2);	reader = cmd2.executereader();	reader.read();	reader.close();	
rowsaffected after close 

myparameter1.direction = parameterdirection.input;	oracleparameter myparameter2 = new oracleparameter("p2", oracletype.number);	myparameter2.direction = parameterdirection.input;	myparameter2.value = 182;	myparameter1.value = "mono";	cmd2.parameters.add (myparameter1);	cmd2.parameters.add (myparameter2);	reader = cmd2.executereader();	reader.read();	reader.close();	
insert another record 

myparameter2.value = 182;	myparameter1.value = "mono";	cmd2.parameters.add (myparameter1);	cmd2.parameters.add (myparameter2);	reader = cmd2.executereader();	reader.read();	reader.close();	myparameter2.value = 183;	myparameter1.value = "oracle";	reader = cmd2.executereader();	
rowsaffected before read 

myparameter1.value = "mono";	cmd2.parameters.add (myparameter1);	cmd2.parameters.add (myparameter2);	reader = cmd2.executereader();	reader.read();	reader.close();	myparameter2.value = 183;	myparameter1.value = "oracle";	reader = cmd2.executereader();	reader.read();	
rowsaffected after read 

cmd2.parameters.add (myparameter1);	cmd2.parameters.add (myparameter2);	reader = cmd2.executereader();	reader.read();	reader.close();	myparameter2.value = 183;	myparameter1.value = "oracle";	reader = cmd2.executereader();	reader.read();	reader.close();	
rowsaffected after close 

static void rollbacktest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into scott.emp (empno, ename, job) values (8787, 't coleman', 'monoist')";	
inserting record 

oracletransaction transaction = connection.begintransaction ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into scott.emp (empno, ename, job) values (8787, 't coleman', 'monoist')";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.commandtext = "select count(*) from scott.emp where empno = 8787";	select.transaction = transaction;	oracledatareader reader = select.executereader ();	reader.read ();	
row count should be value is 

oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into scott.emp (empno, ename, job) values (8787, 't coleman', 'monoist')";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.commandtext = "select count(*) from scott.emp where empno = 8787";	select.transaction = transaction;	oracledatareader reader = select.executereader ();	reader.read ();	reader.close ();	
rolling back transaction 

select.commandtext = "select count(*) from scott.emp where empno = 8787";	select.transaction = transaction;	oracledatareader reader = select.executereader ();	reader.read ();	reader.close ();	transaction.rollback ();	select = connection.createcommand ();	select.commandtext = "select count(*) from scott.emp where empno = 8787";	reader = select.executereader ();	reader.read ();	
row count should be value is 

static void committest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into scott.emp (empno, ename, job) values (8787, 't coleman', 'monoist')";	
inserting record 

static void committest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into scott.emp (empno, ename, job) values (8787, 't coleman', 'monoist')";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.commandtext = "select count(*) from scott.emp where empno = 8787";	select.transaction = transaction;	
row count should be value is 

static void committest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into scott.emp (empno, ename, job) values (8787, 't coleman', 'monoist')";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.commandtext = "select count(*) from scott.emp where empno = 8787";	select.transaction = transaction;	
committing transaction 

oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into scott.emp (empno, ename, job) values (8787, 't coleman', 'monoist')";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.commandtext = "select count(*) from scott.emp where empno = 8787";	select.transaction = transaction;	transaction.commit ();	select = connection.createcommand ();	select.commandtext = "select count(*) from scott.emp where empno = 8787";	
row count should be value is 

public static void parametertest2 (oracleconnection connection) {	
setting nls date format 

public static void parametertest2 (oracleconnection connection) {	oraclecommand cmd2 = connection.createcommand();	cmd2.commandtext = "alter session set nls_date_format = 'yyyy-mm-dd hh24:mi:ss'";	cmd2.executenonquery ();	
drop table mono test 

public static void parametertest2 (oracleconnection connection) {	oraclecommand cmd2 = connection.createcommand();	cmd2.commandtext = "alter session set nls_date_format = 'yyyy-mm-dd hh24:mi:ss'";	cmd2.executenonquery ();	try {	cmd2.commandtext = "drop table mono_test_table7";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	
create table mono test 

cmd2.commandtext = "alter session set nls_date_format = 'yyyy-mm-dd hh24:mi:ss'";	cmd2.executenonquery ();	try {	cmd2.commandtext = "drop table mono_test_table7";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table7(" + " col1 varchar2(8) not null, " + " col2 varchar2(32), " + " col3 number(18,2), " + " col4 number(18,2), " + " col5 date not null, " + " col6 date, " + " col7 blob not null, " + " col8 blob, " + " col9 clob not null, " + " col10 clob " + ")";	cmd2.executenonquery ();	
commit 

try {	cmd2.commandtext = "drop table mono_test_table7";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table7(" + " col1 varchar2(8) not null, " + " col2 varchar2(32), " + " col3 number(18,2), " + " col4 number(18,2), " + " col5 date not null, " + " col6 date, " + " col7 blob not null, " + " col8 blob, " + " col9 clob not null, " + " col10 clob " + ")";	cmd2.executenonquery ();	cmd2.commandtext = "commit";	cmd2.executenonquery ();	
create insert command 

catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table7(" + " col1 varchar2(8) not null, " + " col2 varchar2(32), " + " col3 number(18,2), " + " col4 number(18,2), " + " col5 date not null, " + " col6 date, " + " col7 blob not null, " + " col8 blob, " + " col9 clob not null, " + " col10 clob " + ")";	cmd2.executenonquery ();	cmd2.commandtext = "commit";	cmd2.executenonquery ();	oracletransaction trans = connection.begintransaction ();	oraclecommand cmd = connection.createcommand ();	cmd.transaction = trans;	cmd.commandtext = "insert into mono_test_table7 " + "(col1,col2,col3,col4,col5,col6,col7,col8,col9,col10) " + "values(:p1,:p2,:p3,:p4,:p5,:p6,:p7,:p8,:p9,:p10)";	
add parameters 

oracleparameter parm6 = cmd.parameters.add (":p6", oracletype.datetime);	oracleparameter parm7 = cmd.parameters.add (":p7", oracletype.blob);	oracleparameter parm8 = cmd.parameters.add (":p8", oracletype.blob);	oracleparameter parm9 = cmd.parameters.add (":p9", oracletype.clob);	oracleparameter parm10 = cmd.parameters.add (":p10", oracletype.clob);	string s = "mono";	decimal d = 123456789012345.678m;	datetime dt = datetime.now;	string clob = "clob";	byte[] blob = new byte[] { 0x31, 0x32, 0x33, 0x34, 0x35 };	
set values 

parm1.value = s;	parm2.value = dbnull.value;	parm3.value = d;	parm4.value = dbnull.value;	parm5.value = dt;	parm6.value = dbnull.value;	parm7.value = blob;	parm8.value = dbnull.value;	parm9.value = clob;	parm10.value = dbnull.value;	
executenonquery 

public static void parametertest (oracleconnection connection) {	
setting nls date format 

public static void parametertest (oracleconnection connection) {	oraclecommand cmd2 = connection.createcommand();	cmd2.commandtext = "alter session set nls_date_format = 'yyyy-mm-dd hh24:mi:ss'";	cmd2.executenonquery ();	
drop table mono test 

public static void parametertest (oracleconnection connection) {	oraclecommand cmd2 = connection.createcommand();	cmd2.commandtext = "alter session set nls_date_format = 'yyyy-mm-dd hh24:mi:ss'";	cmd2.executenonquery ();	try {	cmd2.commandtext = "drop table mono_test_table7";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	
create table mono test 

cmd2.commandtext = "alter session set nls_date_format = 'yyyy-mm-dd hh24:mi:ss'";	cmd2.executenonquery ();	try {	cmd2.commandtext = "drop table mono_test_table7";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table7(" + " col1 varchar2(8) not null, " + " col2 varchar2(32), " + " col3 number(18,2) not null, " + " col4 number(18,2), " + " col5 date not null, " + " col6 date, " + " col7 blob not null, " + " col8 blob, " + " col9 clob not null, " + " col10 clob " + ")";	cmd2.executenonquery ();	
commit 

try {	cmd2.commandtext = "drop table mono_test_table7";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table7(" + " col1 varchar2(8) not null, " + " col2 varchar2(32), " + " col3 number(18,2) not null, " + " col4 number(18,2), " + " col5 date not null, " + " col6 date, " + " col7 blob not null, " + " col8 blob, " + " col9 clob not null, " + " col10 clob " + ")";	cmd2.executenonquery ();	cmd2.commandtext = "commit";	cmd2.executenonquery ();	
create insert command 

catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table7(" + " col1 varchar2(8) not null, " + " col2 varchar2(32), " + " col3 number(18,2) not null, " + " col4 number(18,2), " + " col5 date not null, " + " col6 date, " + " col7 blob not null, " + " col8 blob, " + " col9 clob not null, " + " col10 clob " + ")";	cmd2.executenonquery ();	cmd2.commandtext = "commit";	cmd2.executenonquery ();	oracletransaction trans = connection.begintransaction ();	oraclecommand cmd = connection.createcommand ();	cmd.transaction = trans;	cmd.commandtext = "insert into mono_test_table7 " + "(col1,col2,col3,col4,col5,col6,col7,col8,col9,col10) " + "values(:p1,:p2,:p3,:p4,:p5,:p6,:p7,:p8,:p9,:p10)";	
add parameters 

oracleparameter parm6 = cmd.parameters.add (":p6", oracletype.datetime);	oracleparameter parm7 = cmd.parameters.add (":p7", oracletype.blob);	oracleparameter parm8 = cmd.parameters.add (":p8", oracletype.blob);	oracleparameter parm9 = cmd.parameters.add (":p9", oracletype.clob);	oracleparameter parm10 = cmd.parameters.add (":p10", oracletype.clob);	string s = "mono";	decimal d = 123456789012345.678m;	datetime dt = datetime.now;	string clob = "clob";	byte[] blob = new byte[] { 0x31, 0x32, 0x33, 0x34, 0x35 };	
set values 

parm1.value = s;	parm2.value = dbnull.value;	parm3.value = d;	parm4.value = dbnull.value;	parm5.value = dt;	parm6.value = dbnull.value;	parm7.value = blob;	parm8.value = dbnull.value;	parm9.value = clob;	parm10.value = dbnull.value;	
executenonquery 

public static void clobtest (oracleconnection connection) {	
begin transaction 

public static void clobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	
drop table clobtest 

public static void clobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	try {	oraclecommand cmd2 = connection.createcommand ();	cmd2.transaction = transaction;	cmd2.commandtext = "drop table clobtest";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	
create table 

cmd2.transaction = transaction;	cmd2.commandtext = "drop table clobtest";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand create = connection.createcommand ();	create.transaction = transaction;	create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	
insert record 

create.transaction = transaction;	create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	
selecting a clob character value from clobtest 

create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	
error record not found 

create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	
testing oraclelob object 

create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	
length 

create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	
chunk size 

insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	
current position 

insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	
updating value to test me 

insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	value = encoding.getbytes ("test me!");	lob.write (value, 0, value.length);	
current position 

insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	value = encoding.getbytes ("test me!");	lob.write (value, 0, value.length);	
re read value 

oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	value = encoding.getbytes ("test me!");	lob.write (value, 0, value.length);	lob.seek (1, seekorigin.begin);	
current position 

select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	value = encoding.getbytes ("test me!");	lob.write (value, 0, value.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length * 2];	lob.read (value, 0, value.length);	
value 

select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	value = encoding.getbytes ("test me!");	lob.write (value, 0, value.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length * 2];	lob.read (value, 0, value.length);	
current position 

select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	value = encoding.getbytes ("test me!");	lob.write (value, 0, value.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length * 2];	lob.read (value, 0, value.length);	
close oraclelob 

oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	byte[] value = new byte [lob.length * 2];	value = encoding.getbytes ("test me!");	lob.write (value, 0, value.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length * 2];	lob.read (value, 0, value.length);	lob.close ();	
closing reader 

public static void blobtest (oracleconnection connection) {	
begin transaction 

public static void blobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	
drop table blobtest 

public static void blobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	try {	oraclecommand cmd2 = connection.createcommand ();	cmd2.transaction = transaction;	cmd2.commandtext = "drop table blobtest";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	
create table 

cmd2.transaction = transaction;	cmd2.commandtext = "drop table blobtest";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand create = connection.createcommand ();	create.transaction = transaction;	create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	
insert record 

create.transaction = transaction;	create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	
selecting a blob binary value from blobtest 

create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	
error record not found 

create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	
testing oraclelob object 

insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	byte[] value = null;	string bvalue = "";	
updating value 

byte[] value = null;	string bvalue = "";	byte[] bytes = new byte[6];	bytes[0] = 0x31;	bytes[1] = 0x32;	bytes[2] = 0x33;	bytes[3] = 0x34;	bytes[4] = 0x35;	bytes[5] = 0x36;	lob.write (bytes, 0, bytes.length);	
current position 

byte[] value = null;	string bvalue = "";	byte[] bytes = new byte[6];	bytes[0] = 0x31;	bytes[1] = 0x32;	bytes[2] = 0x33;	bytes[3] = 0x34;	bytes[4] = 0x35;	bytes[5] = 0x36;	lob.write (bytes, 0, bytes.length);	
re read value 

string bvalue = "";	byte[] bytes = new byte[6];	bytes[0] = 0x31;	bytes[1] = 0x32;	bytes[2] = 0x33;	bytes[3] = 0x34;	bytes[4] = 0x35;	bytes[5] = 0x36;	lob.write (bytes, 0, bytes.length);	lob.seek (1, seekorigin.begin);	
current position 

bytes[2] = 0x33;	bytes[3] = 0x34;	bytes[4] = 0x35;	bytes[5] = 0x36;	lob.write (bytes, 0, bytes.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length];	lob.read (value, 0, value.length);	bvalue = "";	if (value.gettype ().tostring ().equals ("system.byte[]")) bvalue = gethexstring (value);	
bytes 

bytes[2] = 0x33;	bytes[3] = 0x34;	bytes[4] = 0x35;	bytes[5] = 0x36;	lob.write (bytes, 0, bytes.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length];	lob.read (value, 0, value.length);	bvalue = "";	if (value.gettype ().tostring ().equals ("system.byte[]")) bvalue = gethexstring (value);	
current position 

bytes[2] = 0x33;	bytes[3] = 0x34;	bytes[4] = 0x35;	bytes[5] = 0x36;	lob.write (bytes, 0, bytes.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length];	lob.read (value, 0, value.length);	bvalue = "";	if (value.gettype ().tostring ().equals ("system.byte[]")) bvalue = gethexstring (value);	
close oraclelob 

bytes[3] = 0x34;	bytes[4] = 0x35;	bytes[5] = 0x36;	lob.write (bytes, 0, bytes.length);	lob.seek (1, seekorigin.begin);	value = new byte [lob.length];	lob.read (value, 0, value.length);	bvalue = "";	if (value.gettype ().tostring ().equals ("system.byte[]")) bvalue = gethexstring (value);	lob.close ();	
closing reader 

static void wait(string msg) {	console.writeline(msg);	
waiting press enter to continue 

static void storedproceduretest1 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand ();	
drop table mono test 

static void storedproceduretest1 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand ();	try {	cmd2.commandtext = "drop table mono_test_table1";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	
drop procedure sp 

cmd2.executenonquery ();	}	catch(oracleexception) {	}	try {	cmd2.commandtext = "drop procedure sp_test1";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	
create table mono test 

catch(oracleexception) {	}	try {	cmd2.commandtext = "drop procedure sp_test1";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table1 (" + " col1 varchar2(8), "+ " col2 varchar2(32))";	cmd2.executenonquery ();	
create stored procedure sp 

try {	cmd2.commandtext = "drop procedure sp_test1";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table1 (" + " col1 varchar2(8), "+ " col2 varchar2(32))";	cmd2.executenonquery ();	cmd2.commandtext = "create procedure sp_test1 " + " is " + " begin " + "	insert into mono_test_table1 (col1,col2) values ('aaa','bbbb');" + "	commit;" + " end;";	cmd2.executenonquery ();	
commit 

cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table1 (" + " col1 varchar2(8), "+ " col2 varchar2(32))";	cmd2.executenonquery ();	cmd2.commandtext = "create procedure sp_test1 " + " is " + " begin " + "	insert into mono_test_table1 (col1,col2) values ('aaa','bbbb');" + "	commit;" + " end;";	cmd2.executenonquery ();	cmd2.commandtext = "commit";	cmd2.executenonquery ();	
call stored procedure sp 

static void storedproceduretest2 (oracleconnection con) {	
drop table mono test 

static void storedproceduretest2 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand ();	try {	cmd2.commandtext = "drop table mono_test_table2";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	
drop procedure sp 

cmd2.executenonquery ();	}	catch(oracleexception) {	}	try {	cmd2.commandtext = "drop procedure sp_test2";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	
create table mono test 

catch(oracleexception) {	}	try {	cmd2.commandtext = "drop procedure sp_test2";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table2 (" + " col1 varchar2(8), "+ " col2 varchar2(32))";	cmd2.executenonquery ();	
create stored procedure sp 

try {	cmd2.commandtext = "drop procedure sp_test2";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table2 (" + " col1 varchar2(8), "+ " col2 varchar2(32))";	cmd2.executenonquery ();	cmd2.commandtext = "create procedure sp_test2(parm1 varchar2,parm2 varchar2) " + " is " + " begin " + "	insert into mono_test_table2 (col1,col2) values (parm1,parm2);" + "	commit;" + " end;";	cmd2.executenonquery ();	
commit 

cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table2 (" + " col1 varchar2(8), "+ " col2 varchar2(32))";	cmd2.executenonquery ();	cmd2.commandtext = "create procedure sp_test2(parm1 varchar2,parm2 varchar2) " + " is " + " begin " + "	insert into mono_test_table2 (col1,col2) values (parm1,parm2);" + "	commit;" + " end;";	cmd2.executenonquery ();	cmd2.commandtext = "commit";	cmd2.executenonquery ();	
call stored procedure sp with two parameters 

static void outparmtest1(oracleconnection con) {	
create stored function sp for testing input output inputoutput return parameters 

static void outparmtest1(oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm1(parm1 in varchar2, parm2 out varchar2, parm3 in out varchar2) return varchar2 " + "is " + "    returnvalue varchar2(32) := 'anywhere';" + "begin " + "   if parm1 is null then " + "        parm2 := 'parm1 is null'; " + "   else " + "	     parm2 := 'one' || parm1 || 'three'; " + "   end if; " + "   if parm3 is not null then " + "       parm3 := parm2 || parm3 || 'five'; " + "   else " + "       parm3 := 'parm3 in was null'; " + "   end if; " + "   if parm1 is not null then " + "       if parm1 = '999' then " + "          parm2 := null; " + "          parm3 := null; " + "          returnvalue := null; " + "       end if; " + "   end if; " + "   return returnvalue; " + "end;";	cmd2.executenonquery();	
commit 

static void outparmtest1(oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm1(parm1 in varchar2, parm2 out varchar2, parm3 in out varchar2) return varchar2 " + "is " + "    returnvalue varchar2(32) := 'anywhere';" + "begin " + "   if parm1 is null then " + "        parm2 := 'parm1 is null'; " + "   else " + "	     parm2 := 'one' || parm1 || 'three'; " + "   end if; " + "   if parm3 is not null then " + "       parm3 := parm2 || parm3 || 'five'; " + "   else " + "       parm3 := 'parm3 in was null'; " + "   end if; " + "   if parm1 is not null then " + "       if parm1 = '999' then " + "          parm2 := null; " + "          parm3 := null; " + "          returnvalue := null; " + "       end if; " + "   end if; " + "   return returnvalue; " + "end;";	cmd2.executenonquery();	cmd2.commandtext = "commit";	cmd2.executenonquery();	
call stored function sf with parameters 

myparameter4.size = 32;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value should be onetwothree 

myparameter4.size = 32;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value 

myparameter4.size = 32;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value should be onetwothreefourfive 

myparameter4.size = 32;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value 

myparameter4.size = 32;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value should be anywhere 

myparameter4.size = 32;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be is null 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be is nullhellofive 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be anywhere 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if( myparameter3.value == dbnull.value) inoutvalue = "value is dbnull.value";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value should be value is dbnull value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if( myparameter3.value == dbnull.value) inoutvalue = "value is dbnull.value";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if( myparameter3.value == dbnull.value) inoutvalue = "value is dbnull.value";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value should be value is dbnull value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if( myparameter3.value == dbnull.value) inoutvalue = "value is dbnull.value";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if( myparameter3.value == dbnull.value) inoutvalue = "value is dbnull.value";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value should be value is dbnull value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if( myparameter3.value == dbnull.value) inoutvalue = "value is dbnull.value";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be one three 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be in was null 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be anywhere 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

static void outparmtest2 (oracleconnection con) {	
create stored function sf to test number parameters 

static void outparmtest2 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm2(parm1 in number, parm2 out number, parm3 in out number) return number " + "is " + "   returnvalue number := 123.45; " + "begin " + "   if parm1 is null then " + "      parm2 := 18; " + "	   parm3 := parm3 + 8000; " + "      returnvalue := 78; " + "   elsif parm1 = 999 then " + "         parm2 := null;" + "         parm3 := null;" + "         returnvalue := null;" + "   elsif parm3 is null then " + "         parm2 := 0; " + "         parm3 := 1234567890123.12345678; " + "   else " + "	   parm2 := parm1 + 3; " + "      parm3 := parm3 + 70; " + "   end if;" + "   return returnvalue;" + "end;";	cmd2.executenonquery();	
commit 

static void outparmtest2 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm2(parm1 in number, parm2 out number, parm3 in out number) return number " + "is " + "   returnvalue number := 123.45; " + "begin " + "   if parm1 is null then " + "      parm2 := 18; " + "	   parm3 := parm3 + 8000; " + "      returnvalue := 78; " + "   elsif parm1 = 999 then " + "         parm2 := null;" + "         parm3 := null;" + "         returnvalue := null;" + "   elsif parm3 is null then " + "         parm2 := 0; " + "         parm3 := 1234567890123.12345678; " + "   else " + "	   parm2 := parm1 + 3; " + "      parm3 := parm3 + 70; " + "   end if;" + "   return returnvalue;" + "end;";	cmd2.executenonquery();	cmd2.commandtext = "commit";	cmd2.executenonquery();	
call stored function sp with parameters 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.number);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.number);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	
value 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.number);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.number);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	
value 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.number);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.number);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	
value 

decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = 23;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value should be 

decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = 23;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value 

decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = 23;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value should be 

decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = 23;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value 

decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = 23;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value should be 

decimal outvalue = (decimal)myparameter2.value;	decimal inoutvalue = (decimal)myparameter3.value;	decimal returnvalue = (decimal)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = 23;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value 

string sreturnvalue = "";	myparameter1.value = 999;	myparameter3.value = 66;	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) soutvalue = "dbnull.value";	else soutvalue = myparameter2.value.tostring();	if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	
value should be dbnull value 

string sreturnvalue = "";	myparameter1.value = 999;	myparameter3.value = 66;	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) soutvalue = "dbnull.value";	else soutvalue = myparameter2.value.tostring();	if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	
value 

string sreturnvalue = "";	myparameter1.value = 999;	myparameter3.value = 66;	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) soutvalue = "dbnull.value";	else soutvalue = myparameter2.value.tostring();	if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	
value should be dbnull value 

string sreturnvalue = "";	myparameter1.value = 999;	myparameter3.value = 66;	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) soutvalue = "dbnull.value";	else soutvalue = myparameter2.value.tostring();	if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	
value 

string sreturnvalue = "";	myparameter1.value = 999;	myparameter3.value = 66;	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) soutvalue = "dbnull.value";	else soutvalue = myparameter2.value.tostring();	if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	
value should be dbnull value 

string sreturnvalue = "";	myparameter1.value = 999;	myparameter3.value = 66;	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) soutvalue = "dbnull.value";	else soutvalue = myparameter2.value.tostring();	if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	
value 

else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	console.writeline();	myparameter1.value = 111;	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value should be as in digit zero 

else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	console.writeline();	myparameter1.value = 111;	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value 

else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	console.writeline();	myparameter1.value = 111;	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value should be 

else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	console.writeline();	myparameter1.value = 111;	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value 

else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	console.writeline();	myparameter1.value = 111;	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value should be 

else sinoutvalue = myparameter3.value.tostring();	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else sreturnvalue = myparameter4.value.tostring();	console.writeline();	myparameter1.value = 111;	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (decimal)myparameter2.value;	inoutvalue = (decimal)myparameter3.value;	returnvalue = (decimal)myparameter4.value;	
value 

static void outparmtest3 (oracleconnection con) {	
create stored function sf to test date parameters 

static void outparmtest3 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm3(parm1 in date, parm2 out date, parm3 in out date) return date " + "is " + "   returnvalue date := to_date('2001-07-01 15:32:52', 'yyyy-mm-dd hh24:mi:ss');" + "begin " + "   if parm1 is null then " + "      parm2 := to_date('1900-12-31', 'yyyy-mm-dd'); " + "      parm3 := to_date('1900-12-31', 'yyyy-mm-dd'); " + "   elsif parm1 = to_date('1979-11-25','yyyy-mm-dd') then " + "      parm2 := null;" + "      parm3 := null;" + "      returnvalue := null;"+ "   elsif parm3 is null then " + "      parm2 := to_date('2008-08-08', 'yyyy-mm-dd');" + "      parm3 := to_date('2000-01-01', 'yyyy-mm-dd');" + "   else " + "      -- add 3 days to date\n " + "	   parm2 := parm1 + 3; " + "      parm3 := parm3 + 5; " + "   end if; " + "   return returnvalue;" + "end;";	cmd2.executenonquery();	
commit 

static void outparmtest3 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm3(parm1 in date, parm2 out date, parm3 in out date) return date " + "is " + "   returnvalue date := to_date('2001-07-01 15:32:52', 'yyyy-mm-dd hh24:mi:ss');" + "begin " + "   if parm1 is null then " + "      parm2 := to_date('1900-12-31', 'yyyy-mm-dd'); " + "      parm3 := to_date('1900-12-31', 'yyyy-mm-dd'); " + "   elsif parm1 = to_date('1979-11-25','yyyy-mm-dd') then " + "      parm2 := null;" + "      parm3 := null;" + "      returnvalue := null;"+ "   elsif parm3 is null then " + "      parm2 := to_date('2008-08-08', 'yyyy-mm-dd');" + "      parm3 := to_date('2000-01-01', 'yyyy-mm-dd');" + "   else " + "      -- add 3 days to date\n " + "	   parm2 := parm1 + 3; " + "      parm3 := parm3 + 5; " + "   end if; " + "   return returnvalue;" + "end;";	cmd2.executenonquery();	cmd2.commandtext = "commit";	cmd2.executenonquery();	
call stored function sf with parameters 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.datetime);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.datetime);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.datetime);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.datetime);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.datetime);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.datetime);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value should be dbnull value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value should be dbnull value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value should be dbnull value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

static void outparmtest4(oracleconnection con) {	
create stored function sp for testing long varchar input output inputoutput return parameters 

static void outparmtest4(oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sp_outputparmtest4(parm1 in long, parm2 out long, parm3 in out long) return long " + "is " + "    returnvalue long := 'a very, very, very long value in a far away memory space.'; " + "begin " + "   if parm1 is null then " + "        parm2 := 'parm1 is null'; " + "        returnvalue := 'another one bytes the dust.'; " + "   else " + "	     parm2 := 'one' || parm1 || 'three'; " + "   end if; " + "   if parm3 is not null then " + "       parm3 := parm2 || parm3 || 'five'; " + "   else " + "       parm3 := 'parm3 in was null'; " + "   end if; " + "   if parm1 is not null then " + "       if parm1 = '999' then " + "          parm2 := null; " + "          parm3 := null; " + "          returnvalue := null; " + "       end if; " + "   end if; " + "   return returnvalue; " + "end;";	cmd2.executenonquery();	
commit 

static void outparmtest4(oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sp_outputparmtest4(parm1 in long, parm2 out long, parm3 in out long) return long " + "is " + "    returnvalue long := 'a very, very, very long value in a far away memory space.'; " + "begin " + "   if parm1 is null then " + "        parm2 := 'parm1 is null'; " + "        returnvalue := 'another one bytes the dust.'; " + "   else " + "	     parm2 := 'one' || parm1 || 'three'; " + "   end if; " + "   if parm3 is not null then " + "       parm3 := parm2 || parm3 || 'five'; " + "   else " + "       parm3 := 'parm3 in was null'; " + "   end if; " + "   if parm1 is not null then " + "       if parm1 = '999' then " + "          parm2 := null; " + "          parm3 := null; " + "          returnvalue := null; " + "       end if; " + "   end if; " + "   return returnvalue; " + "end;";	cmd2.executenonquery();	cmd2.commandtext = "commit";	cmd2.executenonquery();	
call stored procedure sp with parameters 

myparameter4.size = 1000;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value should be onetwothree 

myparameter4.size = 1000;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value 

myparameter4.size = 1000;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value should be onetwothreefourfive 

myparameter4.size = 1000;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value 

myparameter4.size = 1000;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value should be a very very very long value in a far away memory space 

myparameter4.size = 1000;	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	
value 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be is null 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be is nullhellofive 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be another one bytes the dust 

string outvalue = (string)myparameter2.value;	string inoutvalue = (string)myparameter3.value;	string returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = "hello";	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if (myparameter3.value == dbnull.value) inoutvalue = "value is dbnullvalue";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value should be value is dbnull value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if (myparameter3.value == dbnull.value) inoutvalue = "value is dbnullvalue";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if (myparameter3.value == dbnull.value) inoutvalue = "value is dbnullvalue";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value should be value is dbnull value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if (myparameter3.value == dbnull.value) inoutvalue = "value is dbnullvalue";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if (myparameter3.value == dbnull.value) inoutvalue = "value is dbnullvalue";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value should be value is dbnull value 

console.writeline();	myparameter1.value = "999";	myparameter3.value = "bye";	cmd3.executenonquery();	if (myparameter2.value == dbnull.value) outvalue = "value is dbnull.value";	else outvalue = (string)myparameter2.value;	if (myparameter3.value == dbnull.value) inoutvalue = "value is dbnullvalue";	else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	
value 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be one three 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be in was null 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value should be a very very very long value in a far away memory space 

else inoutvalue = (string)myparameter3.value;	if (myparameter4.value == dbnull.value) returnvalue = "value is dbnull.value";	else returnvalue = (string)myparameter4.value;	console.writeline();	myparameter1.value = "***";	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (string)myparameter2.value;	inoutvalue = (string)myparameter3.value;	returnvalue = (string)myparameter4.value;	
value 

static void outparmtest5(oracleconnection con) {	
create stored function sp for testing clob input output inputoutput return parameters 

static void outparmtest5(oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sp_outputparmtest5(parm1 in clob, parm2 out clob, parm3 in out clob) return clob " + " is " + "    returnvalue clob := 'clobber'; " + " begin " + "   if parm1 is null then " + "        parm2 := 'parm1 is null'; " + "   else " + "	     parm2 := 'one' || parm1 || 'three'; " + "   end if; " + "   if parm3 is not null then " + "       parm3 := parm2 || parm3 || 'five'; " + "   else " + "       parm3 := 'parm3 in was null'; " + "   end if; " + "   if parm1 is not null then " + "       if parm1 = '999' then " + "          parm2 := null; " + "          parm3 := null; " + "          returnvalue := null; " + "       elsif length(parm1) = 0 then " + "          parm2 := 'parm1 is zero length'; " + "          if length(parm3) = 0 then " + "              parm3 := 'parm3 is zero length';" + "          else " + "              parm3 := 'uh oh, parm3 is not zero length like we thought'; " + "          end if; " + "          returnvalue := 'parm1 is zero length'; " + "       elsif parm1 = '888' then " + "          parm2 := empty_clob(); " + "          parm3 := empty_clob(); " + "          returnvalue := empty_clob(); " + "       end if; " + "   end if; " + "   return returnvalue; " + "end;";	cmd2.executenonquery();	
commit 

static void outparmtest5(oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sp_outputparmtest5(parm1 in clob, parm2 out clob, parm3 in out clob) return clob " + " is " + "    returnvalue clob := 'clobber'; " + " begin " + "   if parm1 is null then " + "        parm2 := 'parm1 is null'; " + "   else " + "	     parm2 := 'one' || parm1 || 'three'; " + "   end if; " + "   if parm3 is not null then " + "       parm3 := parm2 || parm3 || 'five'; " + "   else " + "       parm3 := 'parm3 in was null'; " + "   end if; " + "   if parm1 is not null then " + "       if parm1 = '999' then " + "          parm2 := null; " + "          parm3 := null; " + "          returnvalue := null; " + "       elsif length(parm1) = 0 then " + "          parm2 := 'parm1 is zero length'; " + "          if length(parm3) = 0 then " + "              parm3 := 'parm3 is zero length';" + "          else " + "              parm3 := 'uh oh, parm3 is not zero length like we thought'; " + "          end if; " + "          returnvalue := 'parm1 is zero length'; " + "       elsif parm1 = '888' then " + "          parm2 := empty_clob(); " + "          parm3 := empty_clob(); " + "          returnvalue := empty_clob(); " + "       end if; " + "   end if; " + "   return returnvalue; " + "end;";	cmd2.executenonquery();	cmd2.commandtext = "commit";	cmd2.executenonquery();	
call stored procedure sp with parameters 

myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameterin3);	cmd3.parameters.add(myparameterout3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	
value should be onetwothree 

myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameterin3);	cmd3.parameters.add(myparameterout3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	
value 

myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameterin3);	cmd3.parameters.add(myparameterout3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	
value should be onetwothreeeverythingfive 

myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameterin3);	cmd3.parameters.add(myparameterout3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	
value 

myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameterin3);	cmd3.parameters.add(myparameterout3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	
value should be clobber 

myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameterin3);	cmd3.parameters.add(myparameterout3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	
value 

string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = dbnull.value;	myparameterin3.value = "hello";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be is null 

string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = dbnull.value;	myparameterin3.value = "hello";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = dbnull.value;	myparameterin3.value = "hello";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be is nullhellofive 

string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = dbnull.value;	myparameterin3.value = "hello";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = dbnull.value;	myparameterin3.value = "hello";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be clobber 

string outvalue = getoracleclobvalue(myparameter2);	string inoutvalue = getoracleclobvalue(myparameterout3);	string returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = dbnull.value;	myparameterin3.value = "hello";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "999";	myparameterin3.value = "bye";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be value is dbnull value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "999";	myparameterin3.value = "bye";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "999";	myparameterin3.value = "bye";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be value is dbnull value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "999";	myparameterin3.value = "bye";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "999";	myparameterin3.value = "bye";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be value is dbnull value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "999";	myparameterin3.value = "bye";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "***";	myparameterin3.value = dbnull.value;	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be one three 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "***";	myparameterin3.value = dbnull.value;	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "***";	myparameterin3.value = dbnull.value;	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be in was null 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "***";	myparameterin3.value = dbnull.value;	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "***";	myparameterin3.value = dbnull.value;	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be clobber 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "***";	myparameterin3.value = dbnull.value;	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = oraclelob.null;	myparameterin3.value = "bass";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be is null 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = oraclelob.null;	myparameterin3.value = "bass";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = oraclelob.null;	myparameterin3.value = "bass";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be is nullbassfive 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = oraclelob.null;	myparameterin3.value = "bass";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = oraclelob.null;	myparameterin3.value = "bass";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be clobber 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = oraclelob.null;	myparameterin3.value = "bass";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "888";	myparameterin3.value = "777";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be zero length 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "888";	myparameterin3.value = "777";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "888";	myparameterin3.value = "777";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be zero length 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "888";	myparameterin3.value = "777";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "888";	myparameterin3.value = "777";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value should be zero length 

outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	console.writeline();	myparameter1.value = "888";	myparameterin3.value = "777";	cmd3.executenonquery();	outvalue = getoracleclobvalue(myparameter2);	inoutvalue = getoracleclobvalue(myparameterout3);	returnvalue = getoracleclobvalue(myparameter4);	
value 

static void outparmtest6 (oracleconnection con) {	
create stored function sf to test date parameters 

static void outparmtest6 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm6(parm1 in timestamp, parm2 out timestamp, parm3 in out timestamp) return timestamp " + "is " + "   returnvalue timestamp := to_timestamp('2001-07-01 15:32:52', 'yyyy-mm-dd hh24:mi:ss');" + "begin " + "   if parm1 is null then " + "      parm2 := to_timestamp('1900-12-31', 'yyyy-mm-dd'); " + "      parm3 := to_timestamp('1900-12-31', 'yyyy-mm-dd'); " + "   elsif parm1 = to_timestamp('1979-11-25','yyyy-mm-dd') then " + "      parm2 := null;" + "      parm3 := null;" + "      returnvalue := null;"+ "   elsif parm3 is null then " + "      parm2 := to_timestamp('2008-08-08', 'yyyy-mm-dd');" + "      parm3 := to_timestamp('2000-01-01', 'yyyy-mm-dd');" + "   else " + "      -- add 3 days to date\n " + "	   parm2 := parm1 + 3; " + "      parm3 := parm3 + 5; " + "   end if; " + "   return returnvalue;" + "end;";	cmd2.executenonquery();	
commit 

static void outparmtest6 (oracleconnection con) {	oraclecommand cmd2 = con.createcommand();	cmd2.commandtext = "create or replace function sf_testoutparm6(parm1 in timestamp, parm2 out timestamp, parm3 in out timestamp) return timestamp " + "is " + "   returnvalue timestamp := to_timestamp('2001-07-01 15:32:52', 'yyyy-mm-dd hh24:mi:ss');" + "begin " + "   if parm1 is null then " + "      parm2 := to_timestamp('1900-12-31', 'yyyy-mm-dd'); " + "      parm3 := to_timestamp('1900-12-31', 'yyyy-mm-dd'); " + "   elsif parm1 = to_timestamp('1979-11-25','yyyy-mm-dd') then " + "      parm2 := null;" + "      parm3 := null;" + "      returnvalue := null;"+ "   elsif parm3 is null then " + "      parm2 := to_timestamp('2008-08-08', 'yyyy-mm-dd');" + "      parm3 := to_timestamp('2000-01-01', 'yyyy-mm-dd');" + "   else " + "      -- add 3 days to date\n " + "	   parm2 := parm1 + 3; " + "      parm3 := parm3 + 5; " + "   end if; " + "   return returnvalue;" + "end;";	cmd2.executenonquery();	cmd2.commandtext = "commit";	cmd2.executenonquery();	
call stored function sf with parameters 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.timestamp);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.timestamp);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.timestamp);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.timestamp);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.timestamp);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value should be 

oracleparameter myparameter4 = new oracleparameter("returnvalue", oracletype.timestamp);	myparameter4.direction = parameterdirection.returnvalue;	cmd3.parameters.add(myparameter1);	cmd3.parameters.add(myparameter2);	cmd3.parameters.add(myparameter3);	cmd3.parameters.add(myparameter4);	cmd3.executenonquery();	datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

datetime outvalue = (datetime)myparameter2.value;	datetime inoutvalue = (datetime)myparameter3.value;	datetime returnvalue = (datetime)myparameter4.value;	console.writeline();	myparameter1.value = dbnull.value;	myparameter3.value = new datetime(1980, 11, 22);	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value should be dbnull value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value should be dbnull value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value should be dbnull value 

if (myparameter3.value == dbnull.value) sinoutvalue = "dbnull.value";	else {	inoutvalue = (datetime)myparameter3.value;	sinoutvalue = inoutvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	if (myparameter4.value == dbnull.value) sreturnvalue = "dbnull.value";	else {	returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	
value 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value should be 

returnvalue = (datetime)myparameter4.value;	sreturnvalue = returnvalue.tostring("yyyy-mm-dd hh:mm:ss");	}	console.writeline();	myparameter1.value = new datetime(1976, 7, 4);	myparameter3.value = dbnull.value;	cmd3.executenonquery();	outvalue = (datetime)myparameter2.value;	inoutvalue = (datetime)myparameter3.value;	returnvalue = (datetime)myparameter4.value;	
value yyyy mm dd hh mm ss 

static void showconnectionproperties (oracleconnection con) {	try {	
serverversion 

static void showconnectionproperties (oracleconnection con) {	try {	} catch (system.invalidoperationexception ioe) {	
invalidoperationexception caught 

static void showconnectionproperties (oracleconnection con) {	try {	} catch (system.invalidoperationexception ioe) {	
message 

static void showconnectionproperties (oracleconnection con) {	try {	} catch (system.invalidoperationexception ioe) {	}	
datasource 

static void nullaggregatetest (oracleconnection con) {	
drop table mono test 

static void nullaggregatetest (oracleconnection con) {	oraclecommand cmd2 = con.createcommand ();	try {	cmd2.commandtext = "drop table mono_test_table3";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	
create table mono test 

static void nullaggregatetest (oracleconnection con) {	oraclecommand cmd2 = con.createcommand ();	try {	cmd2.commandtext = "drop table mono_test_table3";	cmd2.executenonquery ();	}	catch(oracleexception) {	}	cmd2.commandtext = "create table mono_test_table3 (" + " col1 varchar2(8), "+ " col2 varchar2(32))";	cmd2.executenonquery ();	
insert some rows into table mono test 

cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('1','one')";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('1','uno')";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','three')";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3', null)";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','few')";	cmd2.executenonquery ();	
executescalar 

cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('1','uno')";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','three')";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3', null)";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','few')";	cmd2.executenonquery ();	cmd2.commandtext = "select col1, count(col2) as max_col1 from mono_test_table3 group by col1";	oracledatareader reader = cmd2.executereader ();	
read 

cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','three')";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3', null)";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','few')";	cmd2.executenonquery ();	cmd2.commandtext = "select col1, count(col2) as max_col1 from mono_test_table3 group by col1";	oracledatareader reader = cmd2.executereader ();	while (reader.read ()) {	object obj0 = reader.getvalue (0);	
value 

cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3', null)";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','few')";	cmd2.executenonquery ();	cmd2.commandtext = "select col1, count(col2) as max_col1 from mono_test_table3 group by col1";	oracledatareader reader = cmd2.executereader ();	while (reader.read ()) {	object obj0 = reader.getvalue (0);	object obj1 = reader.getvalue (1);	
value 

cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3', null)";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','few')";	cmd2.executenonquery ();	cmd2.commandtext = "select col1, count(col2) as max_col1 from mono_test_table3 group by col1";	oracledatareader reader = cmd2.executereader ();	while (reader.read ()) {	object obj0 = reader.getvalue (0);	object obj1 = reader.getvalue (1);	
read 

cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3', null)";	cmd2.executenonquery ();	cmd2.commandtext = "insert into mono_test_table3 (col1, col2) values ('3','few')";	cmd2.executenonquery ();	cmd2.commandtext = "select col1, count(col2) as max_col1 from mono_test_table3 group by col1";	oracledatareader reader = cmd2.executereader ();	while (reader.read ()) {	object obj0 = reader.getvalue (0);	object obj1 = reader.getvalue (1);	}	
no more records 

static void oninfomessage (object sender, oracleinfomessageeventargs e) {	
infomessage message 

static void oninfomessage (object sender, oracleinfomessageeventargs e) {	
infomessage code 

static void oninfomessage (object sender, oracleinfomessageeventargs e) {	
infomessage source 

static void onstatechange (object sender, statechangeeventargs e) {	
statechange currentsate 

static void onstatechange (object sender, statechangeeventargs e) {	
statechange originalstate 

static void setuprefcursortests(oracleconnection con) {	
setup oracle package curspkg join 

static void setuprefcursortests(oracleconnection con) {	oraclecommand cmd = con.createcommand();	
create or replace package curspkg join 

static void setuprefcursortests(oracleconnection con) {	oraclecommand cmd = con.createcommand();	cmd.commandtext = "create or replace package curspkg_join as\n" + "type t_cursor is ref cursor;\n" + "procedure open_join_cursor1 (n_empno in number, io_cursor in out t_cursor);\n" + "end curspkg_join;";	cmd.executenonquery();	
create or replace package body curspkg join 

public static void refcursortest4(oracleconnection connection) {	
setup test package and data for 

public static void refcursortest4(oracleconnection connection) {	oraclecommand cmddrop = connection.createcommand();	cmddrop.commandtext = "drop table testtable";	try {	cmddrop.executenonquery();	}	catch(oracleexception e) {	
ignore this error 

cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3)\n" + "values(526, 'system.data.oracleclient', sysdate)";	cmd.executenonquery();	cmd.commandtext = "commit";	cmd.executenonquery();	cmd.commandtext = "create or replace package testtablepkg\n" + "as\n" + "	type t_cursor is ref cursor;\n" + "\n" + "	procedure getdata(tablecursor out t_cursor);\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.commandtext = "create or replace package body testtablepkg as\n" + "  procedure getdata(tablecursor out t_cursor)\n" + "  is\n" + "  begin\n" + "    open tablecursor for\n" + "    select *\n" + "    from testtable;\n" + "  end getdata;\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.dispose();	cmd = null;	
set up command and parameters to call stored proc 

cmd.executenonquery();	cmd.commandtext = "create or replace package body testtablepkg as\n" + "  procedure getdata(tablecursor out t_cursor)\n" + "  is\n" + "  begin\n" + "    open tablecursor for\n" + "    select *\n" + "    from testtable;\n" + "  end getdata;\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.dispose();	cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	
execute 

cmd.commandtext = "create or replace package body testtablepkg as\n" + "  procedure getdata(tablecursor out t_cursor)\n" + "  is\n" + "  begin\n" + "    open tablecursor for\n" + "    select *\n" + "    from testtable;\n" + "  end getdata;\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.dispose();	cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	
get oracledatareader for cursor output parameter 

cmd.executenonquery();	cmd.dispose();	cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	
read data 

cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	int r = 0;	while (reader.read()) {	
row 

command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	int r = 0;	while (reader.read()) {	for (int f = 0; f < reader.fieldcount; f ++) {	object val = reader.getvalue(f);	
field value 

command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	int r = 0;	while (reader.read()) {	for (int f = 0; f < reader.fieldcount; f ++) {	object val = reader.getvalue(f);	}	r ++;	}	
rows retrieved 

command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	int r = 0;	while (reader.read()) {	for (int f = 0; f < reader.fieldcount; f ++) {	object val = reader.getvalue(f);	}	r ++;	}	
clean up 

static void refcursortest1(oracleconnection con) {	
ref cursor test using begin end for proc begin 

static void refcursortest1(oracleconnection con) {	
create command 

static void refcursortest1(oracleconnection con) {	oraclecommand cmd = new oraclecommand();	cmd.connection = con;	cmd.commandtext = "begin\n" + "	curspkg_join.open_join_cursor1(:n_empno,:io_cursor);\n" + "end;";	
create parameters 

cmd.connection = con;	cmd.commandtext = "begin\n" + "	curspkg_join.open_join_cursor1(:n_empno,:io_cursor);\n" + "end;";	oracleparameter parm1 = new oracleparameter("n_empno", oracletype.number);	parm1.direction = parameterdirection.input;	parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	
execute non query 

cmd.commandtext = "begin\n" + "	curspkg_join.open_join_cursor1(:n_empno,:io_cursor);\n" + "end;";	oracleparameter parm1 = new oracleparameter("n_empno", oracletype.number);	parm1.direction = parameterdirection.input;	parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	cmd.executenonquery();	
get data reader ref cursor from out parameter 

parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	cmd.executenonquery();	reader = (oracledatareader) cmd.parameters["io_cursor"].value;	int x, count;	count = 0;	
get data from ref cursor 

oracledatareader reader;	cmd.executenonquery();	reader = (oracledatareader) cmd.parameters["io_cursor"].value;	int x, count;	count = 0;	while (reader.read()) {	for (x = 0; x < reader.fieldcount; x++) console.write(reader[x] + " ");	console.writeline();	count += 1;	}	
rows returned 

static void refcursortest2(oracleconnection con) {	
ref cursor test using call begin 

static void refcursortest2(oracleconnection con) {	
create command 

static void refcursortest2(oracleconnection con) {	oraclecommand cmd = new oraclecommand();	cmd.connection = con;	cmd.commandtext = "call curspkg_join.open_join_cursor1(:n_empno,:io_cursor)";	
create parameters 

cmd.connection = con;	cmd.commandtext = "call curspkg_join.open_join_cursor1(:n_empno,:io_cursor)";	oracleparameter parm1 = new oracleparameter("n_empno", oracletype.number);	parm1.direction = parameterdirection.input;	parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	
execute non query 

cmd.commandtext = "call curspkg_join.open_join_cursor1(:n_empno,:io_cursor)";	oracleparameter parm1 = new oracleparameter("n_empno", oracletype.number);	parm1.direction = parameterdirection.input;	parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	cmd.executenonquery();	
get data reader ref cursor from out parameter 

parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	cmd.executenonquery();	reader = (oracledatareader) cmd.parameters["io_cursor"].value;	int x, count;	count = 0;	
get data from ref cursor 

oracledatareader reader;	cmd.executenonquery();	reader = (oracledatareader) cmd.parameters["io_cursor"].value;	int x, count;	count = 0;	while (reader.read()) {	for (x = 0; x < reader.fieldcount; x++) console.write(reader[x] + " ");	console.writeline();	count += 1;	}	
rows returned 

static void refcursortest3(oracleconnection con) {	
ref cursor test commandtype storedprocedure begin 

static void refcursortest3(oracleconnection con) {	
create command 

static void refcursortest3(oracleconnection con) {	oraclecommand cmd = new oraclecommand();	cmd.connection = con;	cmd.commandtext = "curspkg_join.open_join_cursor1";	cmd.commandtype = commandtype.storedprocedure;	
create parameters 

cmd.commandtext = "curspkg_join.open_join_cursor1";	cmd.commandtype = commandtype.storedprocedure;	oracleparameter parm1 = new oracleparameter("n_empno", oracletype.number);	parm1.direction = parameterdirection.input;	parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	
execute non query 

cmd.commandtype = commandtype.storedprocedure;	oracleparameter parm1 = new oracleparameter("n_empno", oracletype.number);	parm1.direction = parameterdirection.input;	parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	cmd.executenonquery();	
get data reader ref cursor from out parameter 

parm1.value = 7902;	oracleparameter parm2 = new oracleparameter("io_cursor", oracletype.cursor);	parm2.direction = parameterdirection.output;	cmd.parameters.add(parm1);	cmd.parameters.add(parm2);	oracledatareader reader;	cmd.executenonquery();	reader = (oracledatareader) cmd.parameters["io_cursor"].value;	int x, count;	count = 0;	
get data from ref cursor 

oracledatareader reader;	cmd.executenonquery();	reader = (oracledatareader) cmd.parameters["io_cursor"].value;	int x, count;	count = 0;	while (reader.read()) {	for (x = 0; x < reader.fieldcount; x++) console.write(reader[x] + " ");	console.writeline();	count += 1;	}	
rows returned 

static void externalauthenticationtest () {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	
environment userdomainname and username 

static void externalauthenticationtest () {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	
open connection using external authentication 

static void externalauthenticationtest () {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	
user user 

if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	con.close();	}	catch (exception e) {	
exception caught 

if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	con.close();	}	catch (exception e) {	
probably not setup for external authentication 

public static void testpersistsucurityinfo1() {	console.writeline("\ntestpersistsucurityinfo1 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	
connectionstring before open 

public static void testpersistsucurityinfo1() {	console.writeline("\ntestpersistsucurityinfo1 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	
connectionstring after open 

public static void testpersistsucurityinfo1() {	console.writeline("\ntestpersistsucurityinfo1 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	con.close();	
connectionstring after close 

public static void testpersistsucurityinfo2() {	console.writeline("\ntestpersistsucurityinfo2 - persist security info=true");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=true");	
connectionstring before open 

public static void testpersistsucurityinfo2() {	console.writeline("\ntestpersistsucurityinfo2 - persist security info=true");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=true");	con.open();	
connectionstring after open 

public static void testpersistsucurityinfo2() {	console.writeline("\ntestpersistsucurityinfo2 - persist security info=true");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=true");	con.open();	con.close();	
connectionstring after close 

public static void testpersistsucurityinfo3() {	
use default for persist security info which is false 

public static void testpersistsucurityinfo3() {	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger");	
connectionstring before open 

public static void testpersistsucurityinfo3() {	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger");	con.open();	
connectionstring after open 

public static void testpersistsucurityinfo3() {	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger");	con.open();	con.close();	
connectionstring after close 

public static void testpersistsucurityinfo4() {	console.writeline("\ntestpersistsucurityinfo4 - persist security info=false with password at front");	oracleconnection con = new oracleconnection(";password=tiger;data source=palis;user id=scott;persist security info=false");	
connectionstring before open 

public static void testpersistsucurityinfo4() {	console.writeline("\ntestpersistsucurityinfo4 - persist security info=false with password at front");	oracleconnection con = new oracleconnection(";password=tiger;data source=palis;user id=scott;persist security info=false");	con.open();	
connectionstring after open 

public static void testpersistsucurityinfo4() {	console.writeline("\ntestpersistsucurityinfo4 - persist security info=false with password at front");	oracleconnection con = new oracleconnection(";password=tiger;data source=palis;user id=scott;persist security info=false");	con.open();	con.close();	
connectionstring after close 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	
connectionstring before open 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	
connectionstring after open 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	
connectionstate for con 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	
clone oracleconnection 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	oracleconnection con2 = (oracleconnection) ((icloneable) con).clone();	
connectionstate for 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	oracleconnection con2 = (oracleconnection) ((icloneable) con).clone();	
connectionstring before open 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	oracleconnection con2 = (oracleconnection) ((icloneable) con).clone();	con2.open();	
connectionstring after open 

public static void testpersistsucurityinfo5() {	console.writeline("\ntestpersistsucurityinfo5 - persist security info=false");	oracleconnection con = new oracleconnection("data source=palis;user id=scott;password=tiger;persist security info=false");	con.open();	oracleconnection con2 = (oracleconnection) ((icloneable) con).clone();	con2.open();	con2.close();	
connectionstring after close 

public static void testpersistsucurityinfo6() {	
external auth using persist security info 

public static void testpersistsucurityinfo6() {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	
environment userdomainname and username 

public static void testpersistsucurityinfo6() {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	
open connection using external authentication 

public static void testpersistsucurityinfo6() {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	
connectionstring before open 

public static void testpersistsucurityinfo6() {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	
user user 

public static void testpersistsucurityinfo6() {	string user = environment.username;	if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	con.close();	
connectionstring after close 

if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	con.close();	}	catch (exception e) {	
exception caught 

if (!environment.userdomainname.equals(string.empty)) user = environment.userdomainname + "\\" + environment.username;	oracleconnection con = new oracleconnection("data source=palis;integrated security=true");	try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	con.close();	}	catch (exception e) {	
probably not setup for external authentication this is fine 

try {	con.open();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "select user from dual";	oracledatareader reader = cmd.executereader();	con.close();	}	catch (exception e) {	}	con.dispose();	
connectionstring after dispose 

public static void connectionpoolingtest1 () {	
start connection pooling test 

public static void connectionpoolingtest1 () {	oracleconnection[] connections = null;	int maxcon = max_connections + 1;	int i = 0;	try {	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	
open connection 

oracleconnection[] connections = null;	int maxcon = max_connections + 1;	int i = 0;	try {	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	connections[i] = new oracleconnection(constr);	connections[i].open ();	}	} catch (invalidoperationexception e) {	
expected exception invalidoperationexception caught 

connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	connections[i] = new oracleconnection(constr);	connections[i].open ();	}	} catch (invalidoperationexception e) {	console.writeline(e);	}	for (i = 0; i < maxcon; i++) {	if (connections[i] != null) {	
close connection 

console.writeline(e);	}	for (i = 0; i < maxcon; i++) {	if (connections[i] != null) {	if (connections[i].state == connectionstate.open) connections[i].close ();	connections[i].dispose ();	connections[i] = null;	}	}	connections = null;	
done connection pooling test 

public static void connectionpoolingtest2 () {	
start connection pooling test 

public static void connectionpoolingtest2 () {	oracleconnection[] connections = null;	int maxcon = max_connections;	int i = 0;	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	
open connection 

public static void connectionpoolingtest2 () {	oracleconnection[] connections = null;	int maxcon = max_connections;	int i = 0;	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	connections[i] = new oracleconnection(constr);	connections[i].open ();	}	
start another thread 

oracleconnection[] connections = null;	int maxcon = max_connections;	int i = 0;	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	connections[i] = new oracleconnection(constr);	connections[i].open ();	}	t = new thread(new threadstart(anotherthreadproc));	t.start ();	
sleep 

int maxcon = max_connections;	int i = 0;	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	connections[i] = new oracleconnection(constr);	connections[i].open ();	}	t = new thread(new threadstart(anotherthreadproc));	t.start ();	thread.sleep(100);	
closing 

connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	connections[i] = new oracleconnection(constr);	connections[i].open ();	}	t = new thread(new threadstart(anotherthreadproc));	t.start ();	thread.sleep(100);	for (i = 0; i < maxcon; i++) {	if (connections[i] != null) {	
close connection 

private static void anotherthreadproc () {	
open connection via another thread 

private static void anotherthreadproc () {	oracleconnection[] connections = null;	int maxcon = max_connections;	int i = 0;	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	
open connection 

private static void anotherthreadproc () {	oracleconnection[] connections = null;	int maxcon = max_connections;	int i = 0;	connections = new oracleconnection[maxcon];	for (i = 0; i < maxcon; i++) {	connections[i] = new oracleconnection(constr);	connections[i].open ();	}	
done connection pooling test 

private static void setparameteroracletype (oracleconnection con) {	console.writeline();	oracleparameter p = con.createcommand().createparameter();	
p oracletype varchar 

private static void setparameteroracletype (oracleconnection con) {	console.writeline();	oracleparameter p = con.createcommand().createparameter();	p.oracletype = oracletype.clob;	
p oracletype clob 

private static void setparameteroracletype (oracleconnection con) {	console.writeline();	oracleparameter p = con.createcommand().createparameter();	p.oracletype = oracletype.clob;	p.value = "somestring";	
p oracletype clob 

private static void setparameteroracletype (oracleconnection con) {	console.writeline();	oracleparameter p = con.createcommand().createparameter();	p.oracletype = oracletype.clob;	p.value = "somestring";	console.writeline();	oracleparameter p2 = con.createcommand().createparameter();	
oracletype varchar 

private static void setparameteroracletype (oracleconnection con) {	console.writeline();	oracleparameter p = con.createcommand().createparameter();	p.oracletype = oracletype.clob;	p.value = "somestring";	console.writeline();	oracleparameter p2 = con.createcommand().createparameter();	p2.value = new byte[] { 0x01, 0x02, 0x03, 0x04 };	
oracletype varchar 

private static void setparameteroracletype (oracleconnection con) {	console.writeline();	oracleparameter p = con.createcommand().createparameter();	p.oracletype = oracletype.clob;	p.value = "somestring";	console.writeline();	oracleparameter p2 = con.createcommand().createparameter();	p2.value = new byte[] { 0x01, 0x02, 0x03, 0x04 };	p2.oracletype = oracletype.blob;	
oracletype blob 

console.writeline();	oracleparameter p = con.createcommand().createparameter();	p.oracletype = oracletype.clob;	p.value = "somestring";	console.writeline();	oracleparameter p2 = con.createcommand().createparameter();	p2.value = new byte[] { 0x01, 0x02, 0x03, 0x04 };	p2.oracletype = oracletype.blob;	console.writeline();	oracleparameter p3 = new oracleparameter("test", oracletype.clob);	
oracletype clob 

oracleparameter p = con.createcommand().createparameter();	p.oracletype = oracletype.clob;	p.value = "somestring";	console.writeline();	oracleparameter p2 = con.createcommand().createparameter();	p2.value = new byte[] { 0x01, 0x02, 0x03, 0x04 };	p2.oracletype = oracletype.blob;	console.writeline();	oracleparameter p3 = new oracleparameter("test", oracletype.clob);	p3.value = "blah";	
oracletype clob 

p.value = "somestring";	console.writeline();	oracleparameter p2 = con.createcommand().createparameter();	p2.value = new byte[] { 0x01, 0x02, 0x03, 0x04 };	p2.oracletype = oracletype.blob;	console.writeline();	oracleparameter p3 = new oracleparameter("test", oracletype.clob);	p3.value = "blah";	console.writeline();	oracleparameter p4 = new oracleparameter("test", "blah");	
oracletype varchar 

console.writeline();	oracleparameter p2 = con.createcommand().createparameter();	p2.value = new byte[] { 0x01, 0x02, 0x03, 0x04 };	p2.oracletype = oracletype.blob;	console.writeline();	oracleparameter p3 = new oracleparameter("test", oracletype.clob);	p3.value = "blah";	console.writeline();	oracleparameter p4 = new oracleparameter("test", "blah");	p4.oracletype = oracletype.clob;	
oracletype clob 

p2.value = new byte[] { 0x01, 0x02, 0x03, 0x04 };	p2.oracletype = oracletype.blob;	console.writeline();	oracleparameter p3 = new oracleparameter("test", oracletype.clob);	p3.value = "blah";	console.writeline();	oracleparameter p4 = new oracleparameter("test", "blah");	p4.oracletype = oracletype.clob;	console.writeline();	oracleparameter p5 = new oracleparameter ((string) null, new datetime (2005, 3, 8));	
oracletype datetime 

public static decimal insertblob(oracleconnection con) {	byte[] bytearray = new byte[2000];	byte j = 0;	for (int i = 0; i < bytearray.length; i++) {	bytearray[i] = j;	if (j > 255) j = 0;	j++;	}	
test blob data beginning 

oraclecommand cmd = new oraclecommand();	cmd.commandtext = sproc;	cmd.commandtype = commandtype.storedprocedure;	cmd.connection = con;	cmd.transaction = cmd.connection.begintransaction();	try {	oracleparameter p1 = new oracleparameter("i_sig_file", oracletype.blob);	p1.direction = parameterdirection.input;	oraclelob lob2 = getoraclelob(cmd.transaction, bytearray);	byte[] b2 = (byte[]) lob2.value;	
test blob data here 

oracleparameter p1 = new oracleparameter("i_sig_file", oracletype.blob);	p1.direction = parameterdirection.input;	oraclelob lob2 = getoraclelob(cmd.transaction, bytearray);	byte[] b2 = (byte[]) lob2.value;	p1.value = lob2.value;	cmd.parameters.add(p1);	cmd.executenonquery();	cmd.transaction.commit();	oraclecommand select = con.createcommand ();	select.commandtext = "select blob_column from blobtest2";	
selecting a blob binary value from 

p1.direction = parameterdirection.input;	oraclelob lob2 = getoraclelob(cmd.transaction, bytearray);	byte[] b2 = (byte[]) lob2.value;	p1.value = lob2.value;	cmd.parameters.add(p1);	cmd.executenonquery();	cmd.transaction.commit();	oraclecommand select = con.createcommand ();	select.commandtext = "select blob_column from blobtest2";	oracledatareader reader = select.executereader ();	
error record not found 

p1.direction = parameterdirection.input;	oraclelob lob2 = getoraclelob(cmd.transaction, bytearray);	byte[] b2 = (byte[]) lob2.value;	p1.value = lob2.value;	cmd.parameters.add(p1);	cmd.executenonquery();	cmd.transaction.commit();	oraclecommand select = con.createcommand ();	select.commandtext = "select blob_column from blobtest2";	oracledatareader reader = select.executereader ();	
testing oraclelob object 

p1.direction = parameterdirection.input;	oraclelob lob2 = getoraclelob(cmd.transaction, bytearray);	byte[] b2 = (byte[]) lob2.value;	p1.value = lob2.value;	cmd.parameters.add(p1);	cmd.executenonquery();	cmd.transaction.commit();	oraclecommand select = con.createcommand ();	select.commandtext = "select blob_column from blobtest2";	oracledatareader reader = select.executereader ();	
lob isnull 

cmd.transaction.commit();	oraclecommand select = con.createcommand ();	select.commandtext = "select blob_column from blobtest2";	oracledatareader reader = select.executereader ();	else {	oraclelob lob = reader.getoraclelob (0);	if (lob == oraclelob.null) console.writeline("lob is oraclelob.null");	else {	byte[] blob = (byte[]) lob.value;	string result = gethexstring(blob);	
blob result 

cmd.transaction.commit();	oraclecommand select = con.createcommand ();	select.commandtext = "select blob_column from blobtest2";	oracledatareader reader = select.executereader ();	else {	oraclelob lob = reader.getoraclelob (0);	if (lob == oraclelob.null) console.writeline("lob is oraclelob.null");	else {	byte[] blob = (byte[]) lob.value;	string result = gethexstring(blob);	
bytearray and blob are the same good 

cmd.transaction.commit();	oraclecommand select = con.createcommand ();	select.commandtext = "select blob_column from blobtest2";	oracledatareader reader = select.executereader ();	else {	oraclelob lob = reader.getoraclelob (0);	if (lob == oraclelob.null) console.writeline("lob is oraclelob.null");	else {	byte[] blob = (byte[]) lob.value;	string result = gethexstring(blob);	
bytearray and blob are not the same bad 

else {	oraclelob lob = reader.getoraclelob (0);	if (lob == oraclelob.null) console.writeline("lob is oraclelob.null");	else {	byte[] blob = (byte[]) lob.value;	string result = gethexstring(blob);	}	}	}	catch(exception ex) {	
i exploded 

static void setupmypackage(oracleconnection con) {	
setup oracle package curspkg join 

static void setupmypackage(oracleconnection con) {	
drop table 

static void setupmypackage(oracleconnection con) {	try {	oraclecommand cmd2 = con.createcommand ();	cmd2.commandtext = "drop table blobtest2";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	
create table 

cmd2.commandtext = "drop table blobtest2";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand create = con.createcommand ();	create.commandtext = "create table blobtest2 (blob_column blob)";	create.executenonquery ();	create.commandtext = "commit";	create.executenonquery();	
create or replace package mypackage 

catch (oracleexception) {	}	oraclecommand create = con.createcommand ();	create.commandtext = "create table blobtest2 (blob_column blob)";	create.executenonquery ();	create.commandtext = "commit";	create.executenonquery();	oraclecommand cmd = con.createcommand();	cmd.commandtext = "create or replace package mypackage as\n" + " procedure insertblob (i_sig_file blob);\n" + "end mypackage;";	cmd.executenonquery();	
create or replace package body mypackage 

static void main(string[] args) {	if(args.length != 3) {	
usage mono testoracleclient database userid password 

if(args.length != 3) {	return;	}	string connectionstring = string.format( "data source={0};" + "user id={1};" + "password={2}", args[0], args[1], args[2]);	constr = connectionstring;	oracleconnection con1 = new oracleconnection();	showconnectionproperties (con1);	con1.connectionstring = connectionstring;	con1.infomessage += new oracleinfomessageeventhandler (oninfomessage);	con1.statechange += new statechangeeventhandler (onstatechange);	
opening 

return;	}	string connectionstring = string.format( "data source={0};" + "user id={1};" + "password={2}", args[0], args[1], args[2]);	constr = connectionstring;	oracleconnection con1 = new oracleconnection();	showconnectionproperties (con1);	con1.connectionstring = connectionstring;	con1.infomessage += new oracleinfomessageeventhandler (oninfomessage);	con1.statechange += new statechangeeventhandler (onstatechange);	con1.open ();	
opened 

string connectionstring = string.format( "data source={0};" + "user id={1};" + "password={2}", args[0], args[1], args[2]);	constr = connectionstring;	oracleconnection con1 = new oracleconnection();	showconnectionproperties (con1);	con1.connectionstring = connectionstring;	con1.infomessage += new oracleinfomessageeventhandler (oninfomessage);	con1.statechange += new statechangeeventhandler (onstatechange);	con1.open ();	showconnectionproperties (con1);	insertblobtest (con1);	
mono oracle test begin 

constr = connectionstring;	oracleconnection con1 = new oracleconnection();	showconnectionproperties (con1);	con1.connectionstring = connectionstring;	con1.infomessage += new oracleinfomessageeventhandler (oninfomessage);	con1.statechange += new statechangeeventhandler (onstatechange);	con1.open ();	showconnectionproperties (con1);	insertblobtest (con1);	monotest (con1);	
mono oracle test end 

oracleconnection con1 = new oracleconnection();	showconnectionproperties (con1);	con1.connectionstring = connectionstring;	con1.infomessage += new oracleinfomessageeventhandler (oninfomessage);	con1.statechange += new statechangeeventhandler (onstatechange);	con1.open ();	showconnectionproperties (con1);	insertblobtest (con1);	monotest (con1);	wait ("");	
lob test begin 

con1.connectionstring = connectionstring;	con1.infomessage += new oracleinfomessageeventhandler (oninfomessage);	con1.statechange += new statechangeeventhandler (onstatechange);	con1.open ();	showconnectionproperties (con1);	insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	
lob test end 

con1.infomessage += new oracleinfomessageeventhandler (oninfomessage);	con1.statechange += new statechangeeventhandler (onstatechange);	con1.open ();	showconnectionproperties (con1);	insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	
read simple test begin scott emp 

con1.statechange += new statechangeeventhandler (onstatechange);	con1.open ();	showconnectionproperties (con1);	insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	
read simple test end scott emp 

con1.open ();	showconnectionproperties (con1);	insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	
dataadapter test begin 

showconnectionproperties (con1);	insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	
dataadapter test end 

insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	
dataadapter test begin 

insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	
dataadapter test fails 

insertblobtest (con1);	monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	
dataadapter test end 

monotest (con1);	wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	wait ("");	
rollback test begin 

wait ("");	clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	wait ("");	rollbacktest(con1);	
rollback test end 

clobtest (con1);	blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	wait ("");	rollbacktest(con1);	wait ("");	
commit test begin 

blobtest (con1);	wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	wait ("");	rollbacktest(con1);	wait ("");	committest(con1);	
commit test end 

wait ("");	readsimpletest(con1, "select e.*, e.rowid from scott.emp e");	wait ("");	dataadaptertest(con1);	wait ("");	wait ("");	rollbacktest(con1);	wait ("");	committest(con1);	wait ("");	
parameter test begin 

wait ("");	dataadaptertest(con1);	wait ("");	wait ("");	rollbacktest(con1);	wait ("");	committest(con1);	wait ("");	parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	
parameter test end 

dataadaptertest(con1);	wait ("");	wait ("");	rollbacktest(con1);	wait ("");	committest(con1);	wait ("");	parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	wait ("");	
stored proc test begin 

wait ("");	rollbacktest(con1);	wait ("");	committest(con1);	wait ("");	parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	
stored proc test end 

rollbacktest(con1);	wait ("");	committest(con1);	wait ("");	parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	
stored proc test begin 

committest(con1);	wait ("");	parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	
stored proc test end 

wait ("");	parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	
out parameter and pl sql block test begin 

parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	
out parameter and pl sql block test end 

parametertest(con1);	readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	
out parameter and pl sql block test begin 

readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	
out parameter and pl sql block test end 

readsimpletest(con1, "select * from mono_test_table7");	wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	
out parameter and pl sql block test begin 

wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	
out parameter and pl sql block test end 

wait ("");	storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	
out parameter and pl sql block test begin 

storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	
out parameter and pl sql block test end 

storedproceduretest1 (con1);	readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	
out parameter and pl sql block test begin 

readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	
out parameter and pl sql block test end 

readsimpletest(con1, "select * from mono_test_table1");	wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	
out parameter and pl sql block test begin 

wait ("");	storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	
out parameter and pl sql block test end 

storedproceduretest2 (con1);	readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	
test a non query using execute reader begin 

readsimpletest(con1, "select * from mono_test_table2");	setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	testnonqueryusingexecutereader (con1);	
test a non query using execute reader end 

setparameteroracletype (con1);	outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	testnonqueryusingexecutereader (con1);	wait ("");	
null aggregate warning begin test 

outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	testnonqueryusingexecutereader (con1);	wait ("");	nullaggregatetest (con1);	
null aggregate warning end test 

outparmtest1 (con1);	outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	testnonqueryusingexecutereader (con1);	wait ("");	nullaggregatetest (con1);	
ref cursor begin tests 

outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	testnonqueryusingexecutereader (con1);	wait ("");	nullaggregatetest (con1);	refcursortests (con1);	
ref cursor end tests 

outparmtest2 (con1);	outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	testnonqueryusingexecutereader (con1);	wait ("");	nullaggregatetest (con1);	refcursortests (con1);	
closing 

outparmtest3 (con1);	outparmtest4 (con1);	outparmtest5 (con1);	outparmtest6 (con1);	wait ("");	testnonqueryusingexecutereader (con1);	wait ("");	nullaggregatetest (con1);	refcursortests (con1);	con1.close ();	
closed 

refcursortests (con1);	con1.close ();	constr = constr + ";pooling=true;min pool size=4;max pool size=" + max_connections.tostring ();	connectionpoolingtest1 ();			connectionpoolingtest2 ();	testpersistsucurityinfo1();	testpersistsucurityinfo2();	testpersistsucurityinfo3();	testpersistsucurityinfo4();	testpersistsucurityinfo5();	testpersistsucurityinfo6();	
done 

========================= mono sample_4917 =========================

static private void help () {	
usage chktrust options filename 

static private void help () {	
q quiet mode no gui 

static private void help () {	
v verbose mode display status for every steps 

static private void help () {	
help display this help message 

static public int check (string filename, bool quiet, bool verbose) {	authenticodedeformatter a = new authenticodedeformatter (filename);	fs.write (a.signature, 0, a.signature.length);	fs.close ();*/ filename = path.getfilename (filename);	if (verbose) {	
verifying file for authenticode tm signatures 

static public int check (string filename, bool quiet, bool verbose) {	authenticodedeformatter a = new authenticodedeformatter (filename);	fs.write (a.signature, 0, a.signature.length);	fs.close ();*/ filename = path.getfilename (filename);	if (verbose) {	}	if (a.timestamp == datetime.minvalue) {	
warning is not timestamped 

static public int check (string filename, bool quiet, bool verbose) {	authenticodedeformatter a = new authenticodedeformatter (filename);	fs.write (a.signature, 0, a.signature.length);	fs.close ();*/ filename = path.getfilename (filename);	if (verbose) {	}	if (a.timestamp == datetime.minvalue) {	}	else if (verbose) {	
info was timestamped on 

break;	case 6: msg = "signature can't be traced back to a trusted root";	break;	case 7: msg = "couldn't find the certificate that signed the file";	break;	case 8: msg = "certificate is expired and no timestamp is present";	break;	default: msg = "unknown error";	break;	}	
error 

break;	case 7: msg = "couldn't find the certificate that signed the file";	break;	case 8: msg = "certificate is expired and no timestamp is present";	break;	default: msg = "unknown error";	break;	}	return 1;	}	
success signature is valid and can be traced back to a trusted root 

case "-h": case "-help": case "-?": case "/?": help = true;	break;	default: filename = args [i];	break;	}	}	if ((help) || (filename == null)) help ();	else return check (filename, quiet, verbose);	}	catch (cryptographicexception ce) {	
warning 

case "-h": case "-help": case "-?": case "/?": help = true;	break;	default: filename = args [i];	break;	}	}	if ((help) || (filename == null)) help ();	else return check (filename, quiet, verbose);	}	catch (cryptographicexception ce) {	
error trust evaluation is incomplete 

default: filename = args [i];	break;	}	}	if ((help) || (filename == null)) help ();	else return check (filename, quiet, verbose);	}	catch (cryptographicexception ce) {	}	catch (exception e) {	
error 

========================= mono sample_1171 =========================

public override imessage invoke (imessage request) {	imethodcallmessage call = (imethodcallmessage)request;	
invoke 

static int main(string[] args) {	
test 

static int main(string[] args) {	appdomain app2 = appdomain.createdomain("2");	if (!remotingservices.istransparentproxy(app2)) return 1;	objecthandle o = appdomain.currentdomain.createinstance(typeof(r1).assembly.fullname, typeof(r1).fullname);	r1 myobj = (r1) o.unwrap();	if (remotingservices.istransparentproxy(myobj)) {	
createinstance return tp for in our current domain 

static int main(string[] args) {	appdomain app2 = appdomain.createdomain("2");	if (!remotingservices.istransparentproxy(app2)) return 1;	objecthandle o = appdomain.currentdomain.createinstance(typeof(r1).assembly.fullname, typeof(r1).fullname);	r1 myobj = (r1) o.unwrap();	if (remotingservices.istransparentproxy(myobj)) {	return 2;	}	o = app2.createinstance(typeof(r1).assembly.fullname, typeof(r1).fullname);	
type 

appdomain app2 = appdomain.createdomain("2");	if (!remotingservices.istransparentproxy(app2)) return 1;	objecthandle o = appdomain.currentdomain.createinstance(typeof(r1).assembly.fullname, typeof(r1).fullname);	r1 myobj = (r1) o.unwrap();	if (remotingservices.istransparentproxy(myobj)) {	return 2;	}	o = app2.createinstance(typeof(r1).assembly.fullname, typeof(r1).fullname);	myobj = (r1) o.unwrap();	if (!remotingservices.istransparentproxy(myobj)) return 3;	
unwrapped type 

bserexc = true;	}	if (!bserexc) return 4;	o = app2.createinstance(typeof(r1).assembly.fullname, typeof(r1).fullname);	myobj = (r1) o.unwrap();	genericiface iface = (genericiface)myobj;	if (iface.foo <int> () != 0) return 5;	if (iface.foo <string> () != null) return 6;	if (typeof (r1) != myobj.gettype ()) return 7;	appdomain.unload (app2);	
test ok 

========================= mono sample_693 =========================

public static void threadmethod_waiter_1() {	
thread a started 

public static void threadmethod_waiter_1() {	
thread a i m before wait for event 

public static void threadmethod_waiter_1() {	e.waitone();	
thread a i m after wait for event 

public static void threadmethod_waiter_2() {	
thread b started 

public static void threadmethod_waiter_2() {	
thread b i m before wait for event 

public static void threadmethod_waiter_2() {	e.waitone();	
thread b i m after wait for event 

public static void threadmethod_blocker() {	
thread c started 

public static void threadmethod_blocker() {	
thread c sleeping for 

public static void threadmethod_blocker() {	thread.sleep(5000);	
thread c setting the event 

public static void threadmethod_blocker() {	thread.sleep(5000);	e.set();	
thread c finished 

public static void main() {	e = new manualresetevent(false);	
main creating first thread 

public static void main() {	e = new manualresetevent(false);	threadstart thread_1 = new threadstart(threadmethod_waiter_1);	threadstart thread_2 = new threadstart(threadmethod_waiter_2);	
main creating second thread 

threadstart thread_1 = new threadstart(threadmethod_waiter_1);	threadstart thread_2 = new threadstart(threadmethod_waiter_2);	threadstart thread_3 = new threadstart(threadmethod_blocker);	thread a = new thread(thread_1);	thread b = new thread(thread_2);	thread c = new thread(thread_3);	a.start();	b.start();	c.start();	thread.sleep(500);	
main finish 

========================= mono sample_502 =========================

for (int i = 0; i < args.length; i++) {	cmd.commandtext = system.io.file.readalltext(args[i]);	cnn.open();	cmd.executenonquery();	cnn.close();	}	cmd.dispose();	cnn.dispose();	}	#else if (args.length != 4) {	
usage dblinq mysql example exe server user password database 

for (int i = 0; i < args.length; i++) {	cmd.commandtext = system.io.file.readalltext(args[i]);	cnn.open();	cmd.executenonquery();	cnn.close();	}	cmd.dispose();	cnn.dispose();	}	#else if (args.length != 4) {	
debug arguments can be set on project properties in visual studio 

for (int i = 0; i < args.length; i++) {	cmd.commandtext = system.io.file.readalltext(args[i]);	cnn.open();	cmd.executenonquery();	cnn.close();	}	cmd.dispose();	cnn.dispose();	}	#else if (args.length != 4) {	
press enter to continue 

cmd.parameters.add("?s", "xx");	cmd.parameters[0].direction = parameterdirection.input;	cmd.connection.open();	object obj = cmd.executescalar();	#endif northwind db = new northwind(new xsqlconnection(connstr));	#if !sqlite && use_stored_procs int is2;	object xx = db.sp_selorders("zz", out is2);	string reply0 = db.hello0();	string reply1 = db.hello1("pigafetta");	#endif #if no console.clear();	
from at in db alltypes select at 

cmd.connection.open();	object obj = cmd.executescalar();	#endif northwind db = new northwind(new xsqlconnection(connstr));	#if !sqlite && use_stored_procs int is2;	object xx = db.sp_selorders("zz", out is2);	string reply0 = db.hello0();	string reply1 = db.hello1("pigafetta");	#endif #if no console.clear();	var q1 = from at in db.alltypes select at;	foreach (var v in q1) objectdumper.write(v);	
press enter to continue 

#endif northwind db = new northwind(new xsqlconnection(connstr));	#if !sqlite && use_stored_procs int is2;	object xx = db.sp_selorders("zz", out is2);	string reply0 = db.hello0();	string reply1 = db.hello1("pigafetta");	#endif #if no console.clear();	var q1 = from at in db.alltypes select at;	foreach (var v in q1) objectdumper.write(v);	console.readline();	#endif console.clear();	
from p in db products orderby p productname select p 

object xx = db.sp_selorders("zz", out is2);	string reply0 = db.hello0();	string reply1 = db.hello1("pigafetta");	#endif #if no console.clear();	var q1 = from at in db.alltypes select at;	foreach (var v in q1) objectdumper.write(v);	console.readline();	#endif console.clear();	var q2 = from p in db.products orderby p.productname select p;	foreach (var v in q2) objectdumper.write(v);	
press enter to continue 

foreach (var v in q1) objectdumper.write(v);	console.readline();	#endif console.clear();	var q2 = from p in db.products orderby p.productname select p;	foreach (var v in q2) objectdumper.write(v);	console.readline();	console.clear();	console.writeline("from p in db.products where p.productid == 7 select p;");	var q4 = from p in db.products where p.productid == 7 select p;	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.readline();	console.clear();	console.writeline("from p in db.products where p.productid == 7 select p;");	var q4 = from p in db.products where p.productid == 7 select p;	foreach (var v in q4) objectdumper.write(v);	console.readline();	#if !sqlite console.clear();	console.writeline("from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.readline();	#if !sqlite console.clear();	console.writeline("from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	#endif #if !sqlite console.clear();	console.writeline("from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.writeline("from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	#endif #if !sqlite console.clear();	console.writeline("from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	#endif console.clear();	
db orders 

var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	#endif #if !sqlite console.clear();	console.writeline("from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readline();	#endif console.clear();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

foreach (var v in db.orders) objectdumper.write(v);	console.readline();	#if !sqlite console.clear();	console.writeline("db.orders.add(new order { productid = 7, customerid = 1, orderdate = datetime.now });");	db.orders.add(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	console.writeline("db.orders.add(new order { productid = 2, customerid = 2, orderdate = datetime.now });");	db.orders.add(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

#if !sqlite console.clear();	console.writeline("db.orders.add(new order { productid = 7, customerid = 1, orderdate = datetime.now });");	db.orders.add(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	console.writeline("db.orders.add(new order { productid = 2, customerid = 2, orderdate = datetime.now });");	db.orders.add(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	console.readline();	#endif console.clear();	
db orders remove db orders first 

db.submitchanges();	console.writeline("db.orders.add(new order { productid = 2, customerid = 2, orderdate = datetime.now });");	db.orders.add(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	console.readline();	#endif console.clear();	db.orders.deleteonsubmit(db.orders.first());	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

========================= mono sample_24591 =========================

static int main (string[] args) {	int result = addabunchofints ( __arglist ( 2, 3, 4 ));	
answer 

========================= mono sample_553 =========================

public override t test<t> (t t) {	
base 

public override t test<t> (t t, ub u) {	
base 

========================= mono sample_2407 =========================

public static int main() {	module[] modulearray;	modulearray = assembly.getexecutingassembly().getmodules(false);	module mymodule = modulearray[0];	object[] attributes;	attributes = mymodule.getcustomattributes(typeof (debuggableattribute), false);	if (attributes[0] != null) {	
succeeded 

========================= mono sample_3979 =========================

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(xmlelement));	filestream fs=new filestream(filename, filemode.open);	xmlelement elem;	elem=(xmlelement)ser.deserialize(fs);	fs.close();	
node name 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(xmlelement));	filestream fs=new filestream(filename, filemode.open);	xmlelement elem;	elem=(xmlelement)ser.deserialize(fs);	fs.close();	
node ns 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(xmlelement));	filestream fs=new filestream(filename, filemode.open);	xmlelement elem;	elem=(xmlelement)ser.deserialize(fs);	fs.close();	
inner text 

========================= mono sample_22553 =========================

cp.write ("if (");	condition.printcode (cp);	cp.write (") {");	cp.endline ();	cp.indent ();	trueblock.printcode (cp);	cp.unindent ();	cp.beginline ().write ("}");	if (falseblock != null) {	cp.endline ();	
else 

========================= mono sample_31691 =========================

static getbinddnrequest() {	try {	ldapextendedresponse.register(replicationconstants.get_identity_name_res, system.type.gettype("novell.directory.ldap.extensions.getbinddnresponse"));	}	catch (system.exception e) {	
could not register extended response class not found 

========================= mono sample_20977 =========================

public static int main () {	int a = 1;	console.writeline ("a is = " + a);	int c = a;	console.writeline (c);	if (a != 1){	return 1;	}	s b = delegate {	if (a != 1) environment.exit (1);	
in delegate 

if (a != 1) environment.exit (1);	a = 2;	if (a != 2) environment.exit (2);	console.writeline ("inside = " + a);	a = 3;	console.writeline ("after = " + a);	};	if (a != 1) return 3;	b ();	if (a != 3) return 4;	
back got 

if (a != 1) environment.exit (1);	a = 2;	if (a != 2) environment.exit (2);	console.writeline ("inside = " + a);	a = 3;	console.writeline ("after = " + a);	};	if (a != 1) return 3;	b ();	if (a != 3) return 4;	
test is ok 

========================= mono sample_2674 =========================

public bool processevent (intptr callref, intptr eventref, intptr handle, uint kind, ref msg msg) {	uint klass = eventhandler.geteventclass (eventref);	bool result = true;	if (klass == eventhandler.keventclasstextinput) {	switch (kind) {	case keventtextinputunicodeforkeyevent: processtext (eventref, ref msg);	break;	
warning keyboardhandler processevent default handler for keventclasstextinput should not be reached 

} else if (klass == eventhandler.keventclasskeyboard) {	switch (kind) {	case keventrawkeydown: case keventrawkeyrepeat: msg.message = msg.wm_keydown;	processkeypress (eventref, ref msg);	break;	case keventrawkeyup: msg.message = msg.wm_keyup;	processkeypress (eventref, ref msg);	break;	case keventrawkeymodifierschanged: processmodifiers (eventref, ref msg);	break;	
warning keyboardhandler processevent default handler for keventclasskeyboard should not be reached 

processkeypress (eventref, ref msg);	break;	case keventrawkeyup: msg.message = msg.wm_keyup;	processkeypress (eventref, ref msg);	break;	case keventrawkeymodifierschanged: processmodifiers (eventref, ref msg);	break;	break;	}	} else {	
warning keyboardhandler processevent default handler for keventclasstextinput should not be reached 

========================= mono sample_25280 =========================

public void hello () {	
hello world 

========================= mono sample_34234 =========================

task[] tasks = new task [20];	for (int i = 0; i < tasks.length; i++) {	var assembly = assembly.getassembly(typeof(appdomainobject));	var name = "appdomainwithcall" + i;	tasks [i] = task.factory.startnew(() => appdomainwithremotingserialization(assembly, name));	}	try {	task.waitall (tasks);	} catch (aggregateexception e) {	success = false;	
e e innerexception 

========================= mono sample_27105 =========================

public virtual int f (x o) {	
in a for x 

public virtual int f (y o) {	
in a for y 

public override int f (x o) {	
in c for x 

public override int f (y o) {	
in c for y 

========================= mono sample_2765 =========================

public static int main () {	int[] int_array = new int [] { 0, 1 };	var e = from i in int_array where i > 0 select i into x select x + 99;	var l = e.tolist ();	if (l.count != 1) return 1;	if (l [0] != 100) return 2;	e = from int i in int_array select i + 3 into x where x == 3 select x + 5;	l = e.tolist ();	if (l.count != 1) return 1;	if (l [0] != 8) return 2;	
ok 

========================= mono sample_2462 =========================

public void stopbuffering () {	if (version.atleast (2, 34)) vm_stopbuffering ();	buffer_packets = false;	writepackets (buffered_packets);	if (enableconnectionlogging) {	
sent packets 

========================= mono sample_29250 =========================

for (int i = 1; i < 6; ++i) {	if (typeof (program).getmethod ("pf"+i).callingconvention != callingconventions.varargs) {	console.writeline ("pf{0} {1} != vararg", i, typeof (program).getmethod ("pf"+i).callingconvention);	return 1;	}	}	if (typeof (program).getmethod ("mixed1").callingconvention != callingconventions.standard) {	console.writeline ("mixed1 {0} != standard", typeof (program).getmethod ("mixed1").callingconvention);	return 1;	}	
ok 

========================= mono sample_229 =========================

public static int main (string[] args) {	foo f = new foo ();	methodinfo m = (methodinfo) (f.gettype ().findmembers (membertypes.all, bindingflags.public | bindingflags.static, type.filtername, "sum"))[0];	int[] numbers = new int[3]{4, 5, 6};	object[] parms = new object[1]{numbers};	int sum = (int)m.invoke (f, parms);	
sum is 

========================= mono sample_369 =========================

protected virtual void application_error (object sender, eventargs e) {	console.writeline (environment.stacktrace);	
handling apperror 

========================= mono sample_18509 =========================

private static void bccallback (iasyncresult asyncresult) {	socket sock = (socket)asyncresult.asyncstate;	try {	sock.endconnect (asyncresult);	} catch (exception e) {	
bccallback exception 

========================= mono sample_23538 =========================

public static int main () {	var m = typeof (c1).getmethod ("test");	var ta = m.getgenericarguments ()[0].getgenericparameterconstraints ();	if (ta.length != 2) return 1;	m = typeof (c2).getmethod ("test");	ta = m.getgenericarguments ()[0].getgenericparameterconstraints ();	if (ta.length != 1) return 2;	
ok 

========================= mono sample_1478 =========================

public static void main (string[] args) {	if (args.length == 0) {	
usage mono tlsaync exe url 

public static void main (string[] args) {	if (args.length == 0) {	return;	} else if (args.length > 64) {	
waithandle has a limit of handles so you cannot process urls 

public static void main (string[] args) {	if (args.length == 0) {	return;	} else if (args.length > 64) {	return;	}	alone = (args.length == 1);	servicepointmanager.certificatepolicy = new testcertificatepolicy ();	int id = 1;	foreach (string url in args) {	
get at 

if (length > 0) {	state.memory.write (state.buffer, 0, length);	state.stream.beginread (state.buffer, 0, state.buffer.length, new asynccallback (streamcallback), state);	} else {	state.stream.close ();	if (alone) {	state.memory.position = 0;	streamreader sr = new streamreader (state.memory, encoding.utf8);	console.writeline (sr.readtoend ());	}	
end 

========================= mono sample_20580 =========================

public static int main () {	type t = typeof (newslotvirtualfinal);	methodinfo mi = t.getmethod ("somemethod");	if (mi.attributes != (methodattributes.privatescope | methodattributes.public | methodattributes.final | methodattributes.virtual | methodattributes.hidebysig | methodattributes.vtablelayoutmask)) return 1;	mi = t.getmethod ("somemethod2");	if (mi.attributes != (methodattributes.privatescope | methodattributes.public | methodattributes.virtual | methodattributes.hidebysig | methodattributes.vtablelayoutmask)) return 2;	
ok 

========================= mono sample_2611 =========================

switch (type) {	case messagestatus.methodmessage: _sink.internalprocessmessage (this, _stream);	break;	case messagestatus.unknown: case messagestatus.cancelsignal: _stream.flush ();	end = true;	break;	}	}	}	#if debug catch (exception ex) {	
the exception was caught during tcpserverchannel processmessages 

========================= mono sample_17887 =========================

public static int main () {	if (attribute.getcustomattributes (typeof (class1)).length != 1) return 1;	if (attribute.getcustomattributes (typeof (class2)).length != 0) return 1;	if (attribute.getcustomattributes (typeof (class3)).length != 1) return 1;	
ok 

========================= mono sample_2491 =========================

protected override void writedatacontexttable(codewriter writer, dblinq.schema.dbml.table table) {	
public table get return gettable 

========================= mono sample_25065 =========================

public static int main () {	var x = test2 ();	if (x.count () != 0) return 1;	
ok 

========================= mono sample_2943 =========================

public virtual void setobject (string foo) {	
a setobject 

public override void setobject (string foo) {	
c setobject 

========================= mono sample_2952 =========================

public void gettingnonexisting() {	
r 

========================= mono sample_30498 =========================

public static void test(this int value) {	
not null 

========================= mono sample_2591 =========================

public void testglobaldata () {	string name = "moduletest-assembly";	string filename = name + ".dll";	assemblyname assemblyname = new assemblyname();	assemblyname.name = name;	assemblybuilder ab = thread.getdomain().definedynamicassembly( assemblyname, assemblybuilderaccess.runandsave, tempfolder);	string resfile = path.combine (tempfolder, "res");	using (streamwriter sw = new streamwriter (resfile)) {	
foo 

========================= mono sample_27060 =========================

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
tostring 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
absolutepath 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
absoluteuri 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
authority 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
fragment 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
host 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
hostnametype 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
isdefaultport 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
isfile 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
isloopback 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
isunc 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
localpath 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
pathandquery 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
port 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
query 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
scheme 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
userescaped 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
userinfo 

assert.areequal (test, uri.tostring (), "tostring/" + test);	}	}	[test]	public void unixlocalpath_wtf () {	string path = "file: uri fileuri = new uri( path );	assert.areequal ("/tmp/foo/bar", fileuri.absolutepath, path);	string path2 = "file: fileuri = new uri (path2);	assert.areequal ("file: }	public static void print (uri uri) {	
segments 

========================= mono sample_23469 =========================

public override void writebreak() {	
br 

========================= mono sample_7165 =========================

public static int m (params string[] args) {	
fail 

========================= mono sample_1808 =========================

static int f (int a) {	
test f from delegate 

static void async_callback (iasyncresult ar) {	
async callback 

int fin = 0;	iasyncresult ar1 = d.begininvoke (1, ac, state1);	iasyncresult ar2 = d.begininvoke (2, ac, state2);	iasyncresult ar3 = d.begininvoke (3, ac, state3);	iasyncresult ar4 = d.begininvoke (4, ac, state4);	int res = d.endinvoke (ar1);	console.writeline ("result = " + res);	try {	d.endinvoke (ar1);	} catch (invalidoperationexception) {	
cant execute endinvoke twice ok 

========================= mono sample_1859 =========================

static void main () {	while (true) {	try {	
trying 

========================= mono sample_36167 =========================

assertequals ("eval3 #4", databinder.eval (echo, "['test']"), "test");	assertequals ("eval3 #5", databinder.eval (echo, "['test\"]"), "'test\"");	assertequals ("eval3 #6", databinder.eval (echo, "[\"test']"), "\"test'");	}	#if !nunit void assert (string msg, bool result) {	if (!result) console.writeline (msg);	}	void assertequals (string msg, object expected, object real) {	if (expected == null && real == null) return;	if (expected != null && expected.equals (real)) return;	
expected got 

assertequals ("eval3 #6", databinder.eval (echo, "[\"test']"), "\"test'");	}	#if !nunit void assert (string msg, bool result) {	if (!result) console.writeline (msg);	}	void assertequals (string msg, object expected, object real) {	if (expected == null && real == null) return;	if (expected != null && expected.equals (real)) return;	}	void fail (string msg) {	
failed 

========================= mono sample_18409 =========================

public static int main () {	var v = new klass (new cint (3));	if (v.value == 1) return 1;	if (v.value != 3) return 2;	if (v.value == null) return 3;	var v2 = new klass (null);	if (v2.value != null) return 4;	
ok 

========================= mono sample_2774 =========================

static internal void writematch(int matchlen, int matchpos, outputbuffer output) {	debug.assert(matchlen >= fastencoderwindow.minmatch && matchlen <= fastencoderwindow.maxmatch, "illegal currentmatch length!");	
match compression 

static internal void writechar(byte b, outputbuffer output) {	
literal compression 

========================= mono sample_12355 =========================

static void main () {	dispatcher d = dispatcher.currentdispatcher;	action a = delegate {	object x = d;	d.invoke (dispatcherpriority.normal, new action (mine));	
task 

static void main () {	dispatcher d = dispatcher.currentdispatcher;	action a = delegate {	object x = d;	d.invoke (dispatcherpriority.normal, new action (mine));	};	d.begininvoke (dispatcherpriority.normal, (action) delegate {	
first 

static void main () {	dispatcher d = dispatcher.currentdispatcher;	action a = delegate {	object x = d;	d.invoke (dispatcherpriority.normal, new action (mine));	};	d.begininvoke (dispatcherpriority.normal, (action) delegate {	});	d.begininvoke (dispatcherpriority.normal, (action) delegate {	
second 

action a = delegate {	object x = d;	d.invoke (dispatcherpriority.normal, new action (mine));	};	d.begininvoke (dispatcherpriority.normal, (action) delegate {	});	d.begininvoke (dispatcherpriority.normal, (action) delegate {	d.invokeshutdown ();	});	d.begininvoke (dispatcherpriority.send, (action) delegate {	
high priority 

object x = d;	d.invoke (dispatcherpriority.normal, new action (mine));	};	d.begininvoke (dispatcherpriority.normal, (action) delegate {	});	d.begininvoke (dispatcherpriority.normal, (action) delegate {	d.invokeshutdown ();	});	d.begininvoke (dispatcherpriority.send, (action) delegate {	d.begininvoke (dispatcherpriority.send, (action) delegate {	
inserted 

d.begininvoke (dispatcherpriority.normal, (action) delegate {	});	d.begininvoke (dispatcherpriority.normal, (action) delegate {	d.invokeshutdown ();	});	d.begininvoke (dispatcherpriority.send, (action) delegate {	d.begininvoke (dispatcherpriority.send, (action) delegate {	});	});	d.begininvoke (dispatcherpriority.systemidle, (action) delegate {	
idle 

static void mine () {	
mine 

========================= mono sample_21449 =========================

static iasyncresult dobeginwrite(stream stream, manualresetevent mre, byte[] randombuffer) {	return stream.beginwrite (randombuffer, 0, randombuffer.length, ar => {	iasyncresult begin_write_recursive_ares;	try {	stream.endwrite (ar);	if (mre == null) return;	begin_write_recursive_ares = dobeginwrite (stream, null, randombuffer);	begin_write_recursive_ares.asyncwaithandle.waitone ();	mre.set ();	} catch (objectdisposedexception e) {	
stream was disposed 

========================= mono sample_27145 =========================

id = 0, numbers = { 5, 10 }, next = { id = 55 }	}, new wrap {	id = 1, numbers = { collection, }	}, new wrap {	id = 2, numbers = { }, }, null };	if (a.count != 4) return 5;	if ((int)a [0].numbers [1] != 10) return 6;	new list<int> { 1, 2, 3, 4 };	testlist (new list<int> { 1, 2, 3, 4 }, 4);	new list<int> { };	
ok 

========================= mono sample_2507 =========================

public bool selected;	public int row;	public int col;	public cellselection (int row, int col, bool selected) {	this.selected = selected;	this.row = row;	this.col = col;	}	}	static private void generate_case (stringbuilder result, datagridview dgv, string message, bool headers) {	
current length 

public bool selected;	public int row;	public int col;	public cellselection (int row, int col, bool selected) {	this.selected = selected;	this.row = row;	this.col = col;	}	}	static private void generate_case (stringbuilder result, datagridview dgv, string message, bool headers) {	
current length 

========================= mono sample_25373 =========================

if (desired_type.name.endswith("&")) {	string fullname1 = desired_type.assemblyqualifiedname;	string fullname2 = fullname1.replace("&", "");	desired_type = type.gettype(fullname2);	}	try {	object val2 = typeconvert.to(val, desired_type);	outparamvalues.add(val2);	}	catch (exception ex) {	
copyoutparams error failed on castvalue 

========================= mono sample_24611 =========================

static void main(string[] args) {	
program 

static void main(string[] args) {	var gr = new groupbox();	var item = new windowlesscontrol();	new alignpadlayoutpanel<windowlesscontrol>().insertcontrol(0, item);	item.setattachedproperty(editing_text, "label.text");	gr.insertcontrol(0, new windowlesscontrol());	var wc = new windowlesscontrol();	wc.setattachedproperty(editing_text, "label.text");	var str = wc.getattachedproperty(editing_text);	
done 

public void setattachedproperty<t>(attachedproperty<t> prop, t val) {	
setattachedproperty 

public void setattachedproperty<t>(attachedproperty<t> prop, t val) {	_attachedproperties[prop] = val;	
setattachedproperty 

public t getattachedproperty<t>(attachedproperty<t> prop) {	
get attachedproperty 

========================= mono sample_402 =========================

static private int main(string[] args) {	assembly assembly = assembly.getexecutingassembly ();	type type = assembly.gettype("monobug.program", true);	methodinfo info = type.getmethod("foo");	object[] attributes = info.getcustomattributes (false);	int found = 0;	foreach (object obj in attributes) {	
attribute of type found 

========================= mono sample_513 =========================

public void testa (object sender, eventargs e) {	
a test method 

public void testb (object sender, eventargs e) {	
b test method 

========================= mono sample_3125 =========================

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
derivedkeysecuritytoken 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
generation 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
offset 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
length 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
label 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
nonce 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
tokentoderivefrom 

========================= mono sample_16103 =========================

private static int main() {	bool allpassed = true;	bool passed;	console.write("    spantest: ");	passed = spantest.run();	
pass fail 

private static int main() {	bool allpassed = true;	bool passed;	console.write("    spantest: ");	passed = spantest.run();	allpassed &= passed;	console.write("    byrefliketest: ");	passed = byrefliketest.run();	
pass fail 

========================= mono sample_731 =========================

_stateobj._longlen = _snapshotlonglen;	_stateobj._longlenleft = _snapshotlonglenleft;	_stateobj._snapshotreplay = true;	_stateobj.assertvalidstate();	}	internal void preparereplay() {	resetsnapshotstate();	}	}	private void dumpbuffer() {	
dumping buffer 

}	internal void preparereplay() {	resetsnapshotstate();	}	}	private void dumpbuffer() {	console.writeline("_inbytesread = {0}", _inbytesread);	console.writeline("_inbytesused = {0}", _inbytesused);	int cc = 0;	int i;	
used buffer 

console.writeline();	cc = 0;	}	console.write("{0,-2:x2} ", _inbuff[i]);	cc++;	}	if (cc>0) {	console.writeline();	}	cc = 0;	
unused buffer 

========================= mono sample_14146 =========================

public static void main () {	int a = 1;	s b = delegate {	a = 2;	};	b ();	
back got 

========================= mono sample_3247 =========================

public static int main() {	bla<int> d = new bla<int>();	d.t = 99;	instance();	appdomain domain = appdomain.createdomain ("test");	try {	domain.executeassembly ("instance.exe");	} catch (exception e) {	
assembly has thrown 

methodbuilder main = m.definemethod("main", methodattributes.public | methodattributes.static );	{	ilgenerator il = main.getilgenerator();	il.emit(opcodes.call, typebuilder.getmethod (gobj, foo));	il.emit(opcodes.ret);	}	asmbuild.setentrypoint (main);	g.createtype();	m.createtype();	asmbuild.save("instance.exe");	
ok 

========================= mono sample_620 =========================

public virtual void beforeadding (ienumerable<xelement> list) {	first = true;	
div 

public virtual void beforeadding (ienumerable<xelement> list) {	first = true;	
p added p 

public virtual void beforeadding (ienumerable<xelement> list) {	first = true;	
pre 

public override void added (xelement target, bool wasparentadded) {	var o = getobsoletemessage (target);	if (!first && (o.length > 0)) output.writeline ();	indent ();	bool isinterfacebreakingchange = !wasparentadded && isininterface (target);	output.write ("\t<span class='added added-{0} {1}' {2}>", elementname, isinterfacebreakingchange ? "breaking" : string.empty, isinterfacebreakingchange ? "data-is-breaking" : "data-is-non-breaking");	output.write ("{0}{1}", o, getdescription (target));	
span 

public virtual void afteradding () {	
pre 

public virtual void afteradding () {	
div 

public virtual void beforeremoving (ienumerable<xelement> list) {	first = true;	
p removed p 

public virtual void beforeremoving (ienumerable<xelement> list) {	first = true;	
pre 

public override void removed (xelement source) {	var o = getobsoletemessage (source);	if (!first && (o.length > 0)) output.writeline ();	bool is_breaking = isbreakingremoval (source);	indent ();	output.write ("\t<span class='removed removed-{0} {2}' {1}>", elementname, is_breaking ? "data-is-breaking" : "data-is-non-breaking", is_breaking ? "breaking" : string.empty);	output.write ("{0}{1}", o, getdescription (source));	
span 

public virtual void afterremoving () {	
pre 

========================= mono sample_1313 =========================

public void linqtosqlconversion04() {	northwind db = createdb();	var q = from p in db.products where p.unitsinstock <= p.reorderlevel && !convert.toboolean(p.discontinued) select p;	var qdictionary = q.todictionary(p => p.productid);	assert.isfalse(qdictionary == null);	if (qdictionary.count == 0) assert.ignore("please check this test validity");	foreach (var key in qdictionary.keys) {	
key 

========================= mono sample_24674 =========================

public peerservicesettingsinfo getcustomservicesettings () {	
request getcustomservicesettings 

public void setcustomservicesettings (peerservicesettingsinfo info) {	
request setcustomservicesettings controlmeshshape refreshinterval cleanupinterval 

public refreshresponseinfo refresh (refreshinfo refreshinfo) {	var r = refreshinfo;	
request refresh mesh registraion 

public registerresponseinfo register (registerinfo registerinfo) {	var r = registerinfo;	
request register mesh client nodeaddress endpoint 

public resolveresponseinfo resolve (resolveinfo resolveinfo) {	var r = resolveinfo;	
request resolve mesh client maxaddresses 

public void unregister (unregisterinfo unregisterinfo) {	var u = unregisterinfo;	
request unregister mesh registration 

public registerresponseinfo update (updateinfo updateinfo) {	var u = updateinfo;	
request update mesh registration nodeaddress 

========================= mono sample_32360 =========================

public string[] getvalues (string target) {	throw new notimplementedexception ();	string[] ldap_values;	
calling ldap get values 

========================= mono sample_21111 =========================

foreach (mono.security.x509.x509certificate cert in p12.certificates) {	certificates.add(new x509certificate2(args [2], password));	break;	}	}	tcpclient client = new tcpclient ();	client.connect (host, 4433);	sslstream ssl = new sslstream (client.getstream(), false, new remotecertificatevalidationcallback (certificatevalidation), new localcertificateselectioncallback (clientcertificateselection));	ssl.authenticateasclient (host, certificates, protocol, false);	streamwriter sw = new streamwriter (ssl, system.text.encoding.ascii);	
get clientcert aspx 

static bool certificatevalidation (object sender, x509certificate certificate, x509chain chain, sslpolicyerrors certificateerrors) {	
certificatevalidation 

static bool certificatevalidation (object sender, x509certificate certificate, x509chain chain, sslpolicyerrors certificateerrors) {	console.writeline (certificate.tostring (true));	
chain 

static bool certificatevalidation (object sender, x509certificate certificate, x509chain chain, sslpolicyerrors certificateerrors) {	console.writeline (certificate.tostring (true));	console.writeline (chain);	
error s 

static x509certificate clientcertificateselection (object sender, string targethost, x509certificatecollection clientcertificates, x509certificate servercertificate, string [] acceptableissuers) {	
clientcertificateselection 

static x509certificate clientcertificateselection (object sender, string targethost, x509certificatecollection clientcertificates, x509certificate servercertificate, string [] acceptableissuers) {	
client certificates 

static x509certificate clientcertificateselection (object sender, string targethost, x509certificatecollection clientcertificates, x509certificate servercertificate, string [] acceptableissuers) {	int i = 1;	foreach (x509certificate client in clientcertificates) console.writeline ("#{0} - {1}", i++, client.tostring (true));	
host 

static asymmetricalgorithm privatekeyselection (x509certificate certificate, string targethost) {	
privatekeyselection 

static asymmetricalgorithm privatekeyselection (x509certificate certificate, string targethost) {	
host 

static asymmetricalgorithm privatekeyselection (x509certificate certificate, string targethost) {	console.writeline (certificate.tostring (true));	
privatekeyselection 

========================= mono sample_23294 =========================

public valueserializer getvalueserializerfor (propertydescriptor descriptor) {	
getvalueserializerfor 

public valueserializer getvalueserializerfor (type type) {	
getvalueserializerfor 

========================= mono sample_21391 =========================

try {	if (!r.endswith (".dll", stringcomparison.ordinalignorecase) || !r.endswith (".exe", stringcomparison.ordinalignorecase)) {	assembly = assembly.loadwithpartialname (r);	}	if (assembly != null) {	res.add (assembly.location);	continue;	}	} catch {	}	
assembly reference r could not be resolved 

========================= mono sample_22269 =========================

public void dohelp () {	showbanner ();	console.writeline ();	dousage ();	
options 

public void dohelp () {	showbanner ();	console.writeline ();	dousage ();	options.writeoptiondescriptions (console.out);	console.writeline ();	
metadatapath ws mex file path 

public void dohelp () {	showbanner ();	console.writeline ();	dousage ();	options.writeoptiondescriptions (console.out);	console.writeline ();	
metadataurl url to ws mex 

public void dohelp () {	showbanner ();	console.writeline ();	dousage ();	options.writeoptiondescriptions (console.out);	console.writeline ();	
assemblypath path to an assembly 

public void dousage () {	
usage svcutil options metadatapath metadataurl assemblypath 

public void showbanner () {	
mono service contract conversion tool copyright c novell inc 

========================= mono sample_1294 =========================

public static int main () {	int result = vararg.addabunchofints (__arglist ( 2, 3, 4 ));	
answer 

public static int main () {	int result = vararg.addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = vararg.addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	
answer 

public static int main () {	int result = vararg.addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = vararg.addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	vararg s = new vararg ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	
answer 

public static int main () {	int result = vararg.addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = vararg.addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	vararg s = new vararg ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	
answer 

int result = vararg.addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = vararg.addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	vararg s = new vararg ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	
answer 

result = vararg.addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	vararg s = new vararg ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	if (result != 14) return 5;	result = s.instvtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 )).res;	
answer 

vararg s = new vararg ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	if (result != 14) return 5;	result = s.instvtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 )).res;	if (result != 20) return 6;	result = vararg.vtaddabunchofints (__arglist ( 2, 3, 4, 5, 1 )).res;	
answer 

if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	if (result != 14) return 5;	result = s.instvtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 )).res;	if (result != 20) return 6;	result = vararg.vtaddabunchofints (__arglist ( 2, 3, 4, 5, 1 )).res;	if (result != 15) return 7;	result = vararg.vtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6, 1 )).res;	
answer 

========================= mono sample_3391 =========================

if (args.length >= 2 && args [1].startswith ("/o")) output_dir = args [1].substring (args [1].indexof (':') + 1);	if (args.length >= 3 && args [2].startswith ("/t")) lookup_type = args [2].substring (args [2].indexof (':') + 1);	monoxsd xsd = new monoxsd ();	try {	xsd.writeschema (input, lookup_type, output_dir);	} catch (argumentexception e) {	console.writeline (e.message + "\n");	environment.exit (0);	}	} else {	
not supported 

public void writeschema (string assembly, string lookup_type, string output_dir) {	assembly a;	try {	a = assembly.loadfrom (assembly);	} catch (exception e) {	
cannot use 

schema.items.add (schemaelement);	schema.items.add (schematype);	}	schema.elementformdefault = xmlschemaform.qualified;	schema.compile (new validationeventhandler (onschemavalidation));	string output = string.format ("schema{0}.xsd", filecount);	if (output_dir != null) output = path.combine (output_dir, output);	xmltextwriter writer = new xmltextwriter (output, encoding.utf8);	writer.formatting = formatting.indented;	schema.write (writer);	
writing 

========================= mono sample_1327 =========================

public delegate void mydelegate (int a);	public class x {	static event mydelegate e = x.test;	static int cc = 4;	static void test (int foo) {	x.cc = foo;	
ok 

========================= mono sample_3362 =========================

static int main () {	var dyn = definedynamicassembly (appdomain.currentdomain);	var core = triggerloadingsystemcore ();	var asm = appdomain.currentdomain.getassemblies ();	if (asm [0] != typeof (object).assembly) {	
first assembly must be mscorlib but it was 

static int main () {	var dyn = definedynamicassembly (appdomain.currentdomain);	var core = triggerloadingsystemcore ();	var asm = appdomain.currentdomain.getassemblies ();	if (asm [0] != typeof (object).assembly) {	return 1;	}	if (asm [1] != typeof (driver).assembly) {	
second assembly must be test assembly but it was 

var dyn = definedynamicassembly (appdomain.currentdomain);	var core = triggerloadingsystemcore ();	var asm = appdomain.currentdomain.getassemblies ();	if (asm [0] != typeof (object).assembly) {	return 1;	}	if (asm [1] != typeof (driver).assembly) {	return 2;	}	if (asm [2] != dyn) {	
third assembly must be sre but it was 

if (asm [0] != typeof (object).assembly) {	return 1;	}	if (asm [1] != typeof (driver).assembly) {	return 2;	}	if (asm [2] != dyn) {	return 3;	}	if (asm [3] != core) {	
last assembly must be system core but it was 

static assembly definedynamicassembly (appdomain domain) {	assemblyname assemblyname = new assemblyname ();	assemblyname.name = "mydynamicassembly";	assemblybuilder assemblybuilder = domain.definedynamicassembly (assemblyname, assemblybuilderaccess.run);	modulebuilder modulebuilder = assemblybuilder.definedynamicmodule ("mydynamicmodule");	typebuilder typebuilder = modulebuilder.definetype ("mydynamictype", typeattributes.public);	constructorbuilder constructorbuilder = typebuilder.defineconstructor (methodattributes.public, callingconventions.standard, null);	ilgenerator ilgenerator = constructorbuilder.getilgenerator ();	
mydynamictype instantiated 

========================= mono sample_494 =========================

public static void main (string[] args) {	string filename = "ictool-config.xml";	if (args.length == 1) {	filename = args[0];	}	else if (args.length > 1) {	
usage ictool exe config xml 

filename = args[0];	}	else if (args.length > 1) {	environment.exit (-1);	}	try {	stream config = file.openread (filename);	configure (config);	}	catch (exception e) {	
error could not read configuration file 

private static void emitprototypes () {	streamwriter methods_file = getoutputfile ("methods");	streamwriter map_file = getoutputfile ("map");	
include types 

private static void emitprototypes () {	streamwriter methods_file = getoutputfile ("methods");	streamwriter map_file = getoutputfile ("map");	
include methods 

int refs = 0;	if (arg_type.isbyref) {	arg_type = arg_type.getelementtype ();	++ refs;	}	peer arg_peer = peer_map.getpeer (arg_type);	if (!arg_peer.isvaluetype) ++ refs;	args.add (string.format ("{0}{1}", arg_peer.gettypedef (refs), param.name));	}	peer ret = peer_map.getpeer (method.returntype);	
static 

foreach (peer peer in peer_map.peers) {	dg.addnode (peer);	if (peer.nearestbase != null) dg.addedge (peer.nearestbase, peer);	foreach (peerfield field in peer.fields) {	if (field.peer.isvaluetype) dg.addedge (field.peer, peer);	}	}	foreach (peer peer in dg.topologicalsort ()) {	if (peer.isopaque) continue;	if (peer.isenum) {	
typedef 

foreach (peer peer in peer_map.peers) {	dg.addnode (peer);	if (peer.nearestbase != null) dg.addedge (peer.nearestbase, peer);	foreach (peerfield field in peer.fields) {	if (field.peer.isvaluetype) dg.addedge (field.peer, peer);	}	}	foreach (peer peer in dg.topologicalsort ()) {	if (peer.isopaque) continue;	if (peer.isenum) {	
enum 

if (peer.isopaque) continue;	if (peer.isenum) {	arraylist enum_lines = new arraylist ();	foreach (string name in peer.enumconstants.keys) {	enum_lines.add (string.format ("\t{0}_{1} = {2}", peer.name, name, peer.enumconstants[name]	));	}	file.writeline ("{0}\n}};\n", join (",\n", enum_lines));	}	else {	
typedef struct 

if (peer.isenum) {	arraylist enum_lines = new arraylist ();	foreach (string name in peer.enumconstants.keys) {	enum_lines.add (string.format ("\t{0}_{1} = {2}", peer.name, name, peer.enumconstants[name]	));	}	file.writeline ("{0}\n}};\n", join (",\n", enum_lines));	}	else {	if (peer.nearestbase != null) {	
base 

}	file.writeline ("{0}\n}};\n", join (",\n", enum_lines));	}	else {	if (peer.nearestbase != null) {	file.writeline ();	}	foreach (peerfield field in peer.fields) {	bool use_struct = true;	if (field.peer.isvaluetype || field.peer.isopaque) use_struct = false;	
struct 

private static void loadassemblies () {	types = new hashtable ();	foreach (string filename in assemblies) {	assembly assembly;	fileinfo info = null;	foreach (string path in assembly_paths) {	info = new fileinfo (path.combine (path, filename));	if (info.exists) break;	}	if (!info.exists) {	
error assembly not found 

try {	loaded_types = new arraylist (assembly.gettypes ());	}	catch (reflectiontypeloadexception e) {	loaded_types = new arraylist ();	foreach (type type in e.types) {	if (type != null) loaded_types.add (type);	}	foreach (exception f in e.loaderexceptions) {	if (f is typeloadexception) {	
warning could not be loaded from assembly 

========================= mono sample_806 =========================

public override object instantiate () {	
instantiating type 

public override object instantiate () {	
instantiating compound field 

public object instantiate () {	
instantiating field 

public object instantiate () {	
instantiating form window 

========================= mono sample_3273 =========================

public static void main(string[] args) {	imagecodecinfo info = null;	bitmap pages = null;	foreach(imagecodecinfo ice in imagecodecinfo.getimageencoders()) if(ice.mimetype=="image/tiff") info = ice;	if (info == null) {	
couldn t get codec for image tiff 

========================= mono sample_21333 =========================

public static void threadmethod_a() {	
thread a started 

public static void threadmethod_a() {	for (int i=0;i<10;i++) {	
thread a trying to lock mutex 

public static void threadmethod_a() {	for (int i=0;i<10;i++) {	m[i].waitone();	
thread a m locked 

public static void threadmethod_a() {	for (int i=0;i<10;i++) {	m[i].waitone();	
thread a now using mutex 

public static void threadmethod_a() {	for (int i=0;i<10;i++) {	m[i].waitone();	thread.sleep(2000);	m[i].releasemutex();	
thread a unlocked the mutex 

public static void threadmethod_a() {	for (int i=0;i<10;i++) {	m[i].waitone();	thread.sleep(2000);	m[i].releasemutex();	}	
thread a exiting 

public static void threadmethod_b() {	
thread b started 

public static void threadmethod_b() {	for (int h=0;h<10;h++) {	int i=5;	
thread b trying to lock mutex for time 

public static void threadmethod_b() {	for (int h=0;h<10;h++) {	int i=5;	m[i].waitone();	
thread b m locked recursively times 

public static void threadmethod_b() {	for (int h=0;h<10;h++) {	int i=5;	m[i].waitone();	thread.sleep(4500);	}	for (int h=0;h<10;h++) {	int i=5;	m[i].releasemutex();	
thread b unlocked the mutex for times 

public static void threadmethod_b() {	for (int h=0;h<10;h++) {	int i=5;	m[i].waitone();	thread.sleep(4500);	}	for (int h=0;h<10;h++) {	int i=5;	m[i].releasemutex();	}	
thread b finished 

public static void main() {	m = new mutex[10];	for (int i = 0 ; i<10 ; i++ ) m[i] = new mutex();	
main creating first thread 

public static void main() {	m = new mutex[10];	for (int i = 0 ; i<10 ; i++ ) m[i] = new mutex();	threadstart thread_1 = new threadstart(threadmethod_a);	
main creating second thread 

public static void main() {	m = new mutex[10];	for (int i = 0 ; i<10 ; i++ ) m[i] = new mutex();	threadstart thread_1 = new threadstart(threadmethod_a);	threadstart thread_2 = new threadstart(threadmethod_b);	thread a = new thread(thread_1);	thread b = new thread(thread_2);	a.start();	b.start();	thread.sleep(500);	
main test ended 

========================= mono sample_645 =========================

static void displaylist (string banner, string[] list) {	console.writeline (banner);	if (list == null || list.length == 0) {	
no data found 

string[] commandarguments = options.plainarguments;	if (commandarguments == null || commandarguments.length == 0) {	options.usagecommands ();	displaylist ("default config files:", config.defaultconfigfiles);	console.writeline ();	displaylist ("available features:", config.features);	return 1;	}	handlecommand commandhandler = findcommandhandler (commandarguments [0]);	if (commandhandler == null) {	
unknown command 

static int handleaddfeature (mconfigoptions options, configuration config) {	string[] commandarguments = options.plainarguments;	if (commandarguments.length < 2) {	
command requires at least one argument 

static int handleaddfeature (mconfigoptions options, configuration config) {	string[] commandarguments = options.plainarguments;	if (commandarguments.length < 2) {	return 1;	}	featuretarget target = options.target;	string featurename = commandarguments [1], configpath;	if (commandarguments.length > 2) configpath = commandarguments [2];	else {	switch (target) {	
no default config file for target any 

featuretarget target = options.target;	string featurename = commandarguments [1], configpath;	if (commandarguments.length > 2) configpath = commandarguments [2];	else {	switch (target) {	return 1;	case featuretarget.web: configpath = "web.config";	break;	case featuretarget.application: configpath = "application.exe.config";	break;	
unknown target 

static int handledefaultconfig (mconfigoptions options, configuration config) {	featuretarget target = options.target;	string[] commandarguments = options.plainarguments;	string configname, targetpath;	if (commandarguments.length < 2) {	switch (target) {	
no default config file for target any 

featuretarget target = options.target;	string[] commandarguments = options.plainarguments;	string configname, targetpath;	if (commandarguments.length < 2) {	switch (target) {	return 1;	case featuretarget.web: configname = "web.config";	break;	case featuretarget.application: configname = "application.exe.config";	break;	
unknown target 

========================= mono sample_1226 =========================

public int run (string[] args) {	parseargs (args);	if (!nologo) {	
mono xml serializer generator tool 

public int run (string[] args) {	parseargs (args);	if (!nologo) {	
mono version 

public int run (string[] args) {	parseargs (args);	if (!nologo) {	console.writeline ();	}	if (unknownarg != null) {	
unknown option 

public int run (string[] args) {	parseargs (args);	if (!nologo) {	console.writeline ();	}	if (unknownarg != null) {	console.writeline ();	return 1;	}	if (help) {	
usage sgen options 

}	if (unknownarg != null) {	console.writeline ();	return 1;	}	if (help) {	console.writeline ();	return 0;	}	if (assembly == null) {	
assembly name not provided 

}	assembly asm = null;	try {	asm = assembly.load (assembly);	}	catch {}	if (asm == null) {	try {	asm = assembly.loadfrom (assembly);	} catch {	
specified assembly cannot be loaded 

try {	asm = assembly.loadfrom (assembly);	} catch {	console.writeline ();	return 1;	}	}	arraylist usertypes = new arraylist ();	arraylist maps = new arraylist ();	xmlreflectionimporter imp = new xmlreflectionimporter ();	
generating serializer for the following types 

}	}	arraylist usertypes = new arraylist ();	arraylist maps = new arraylist ();	xmlreflectionimporter imp = new xmlreflectionimporter ();	if (types == null) {	type [] types;	try {	types = asm.gettypes ();	} catch (reflectiontypeloadexception tle){	
there was an error loading one or more of the types from the referenced assembly assembly 

console.writeline (le);	}	return 1;	}	foreach (type t in types){	try {	maps.add (imp.importtypemapping (t));	usertypes.add (t);	if (verbose) console.writeline( " - " + t );	} catch (invalidoperationexception ex) {	
warning 

return 1;	}	foreach (type t in types){	try {	maps.add (imp.importtypemapping (t));	usertypes.add (t);	if (verbose) console.writeline( " - " + t );	} catch (invalidoperationexception ex) {	} catch (notimplementedexception ex) {	if (verbose) {	
warning ignoring 

try {	maps.add (imp.importtypemapping (t));	usertypes.add (t);	if (verbose) console.writeline( " - " + t );	} catch (invalidoperationexception ex) {	} catch (notimplementedexception ex) {	if (verbose) {	console.writeline ("   " + ex.message);	}	} catch (notsupportedexception ex) {	
warning 

}	}	} else {	foreach (string type in types) {	try {	type t = asm.gettype (type);	maps.add (imp.importtypemapping (t));	usertypes.add (t);	if (verbose) console.writeline (" - " + t);	} catch (invalidoperationexception ex) {	
warning 

} else {	foreach (string type in types) {	try {	type t = asm.gettype (type);	maps.add (imp.importtypemapping (t));	usertypes.add (t);	if (verbose) console.writeline (" - " + t);	} catch (invalidoperationexception ex) {	} catch (notimplementedexception ex) {	if (verbose) {	
warning ignoring 

type t = asm.gettype (type);	maps.add (imp.importtypemapping (t));	usertypes.add (t);	if (verbose) console.writeline (" - " + t);	} catch (invalidoperationexception ex) {	} catch (notimplementedexception ex) {	if (verbose) {	console.writeline ("   " + ex.message);	}	} catch (notsupportedexception ex) {	
warning 

compilerparameters parameters = new compilerparameters ();	parameters.generateinmemory = false;	parameters.includedebuginformation = debug;	parameters.referencedassemblies.addrange ((string[])references.toarray(typeof(string)));	parameters.tempfiles = new tempfilecollection (environment.currentdirectory, keep);	parameters.compileroptions = compileroptions;	string file = path.getfilenamewithoutextension (asm.location) + ".xmlserializers.dll";	if (outdir == null) outdir = path.getdirectoryname (asm.location);	parameters.outputassembly = path.combine (outdir, file);	if (file.exists (parameters.outputassembly) && !force) {	
cannot generate assembly because it already exist use force option to overwrite the existing assembly 

parameters.compileroptions = compileroptions;	string file = path.getfilenamewithoutextension (asm.location) + ".xmlserializers.dll";	if (outdir == null) outdir = path.getdirectoryname (asm.location);	parameters.outputassembly = path.combine (outdir, file);	if (file.exists (parameters.outputassembly) && !force) {	console.writeline ();	return 1;	}	xmlserializer.generateserializer ( (type[]) usertypes.toarray (typeof(type)), (xmltypemapping[]) maps.toarray (typeof(xmltypemapping)), parameters);	if (!silent) {	
generated assembly 

========================= mono sample_816 =========================

for (int16 i = 0; i < testthreads.length; ++i) {	testthreads [i] = new thread ( () => {	_trigger.waitone();	for (int16 index = 0; index < 1000; ++index) {	var val = index.tostring();	gc.keepalive(val);	}	});	testthreads [i].start ();	}	
setting event 

========================= mono sample_604 =========================

protected virtual void applyconfiguration (string configurationname) {	if (configurationname == null) return;	#if mobile || xammac_4_5 try {	var cfg = new silverlightclientconfigloader ().load (xmlreader.create ("servicereferences.clientconfig"));	silverlightclientconfigloader.serviceendpointconfiguration se = null;	if (configurationname == "*") se = cfg.getserviceendpointconfiguration (endpoint.contract.name);	if (se == null) se = cfg.getserviceendpointconfiguration (configurationname);	if (se.binding != null && endpoint.binding == null) endpoint.binding = se.binding;	
warning configured binding not found in configuration 

protected virtual void applyconfiguration (string configurationname) {	if (configurationname == null) return;	#if mobile || xammac_4_5 try {	var cfg = new silverlightclientconfigloader ().load (xmlreader.create ("servicereferences.clientconfig"));	silverlightclientconfigloader.serviceendpointconfiguration se = null;	if (configurationname == "*") se = cfg.getserviceendpointconfiguration (endpoint.contract.name);	if (se == null) se = cfg.getserviceendpointconfiguration (configurationname);	if (se.binding != null && endpoint.binding == null) endpoint.binding = se.binding;	if (se.address != null && endpoint.address == null) endpoint.address = se.address;	
warning configured endpoint address not found in configuration 

protected virtual void applyconfiguration (string configurationname) {	if (configurationname == null) return;	#if mobile || xammac_4_5 try {	var cfg = new silverlightclientconfigloader ().load (xmlreader.create ("servicereferences.clientconfig"));	silverlightclientconfigloader.serviceendpointconfiguration se = null;	if (configurationname == "*") se = cfg.getserviceendpointconfiguration (endpoint.contract.name);	if (se == null) se = cfg.getserviceendpointconfiguration (configurationname);	if (se.binding != null && endpoint.binding == null) endpoint.binding = se.binding;	if (se.address != null && endpoint.address == null) endpoint.address = se.address;	} catch (exception) {	
warning failed to load endpoint configuration for 

========================= mono sample_32261 =========================

static void usage () {	
usage mono xmltool options 

========================= mono sample_1284 =========================

public void usage() {	
usage apigen exe options input spec xml output csharp file 

public void usage() {	
options include 

public void usage() {	
apiname identifier 

public void usage() {	
n name space prefix 

public void usage() {	
v majorversion minorversion 

public void usage() {	
the apiname option is required 

public void loadspec() {	
loading spec from 

public void parsespec() {	
parsing spec 

public void generateoutput() {	
generating code into 

========================= mono sample_18097 =========================

stoponfirstfailure = false;	list <itaskitem > outputitems = new list <itaskitem> ();	string currentdirectory = environment.currentdirectory;	hashtable outputs;	var global_properties = splitpropertiestodictionary ();	log.logmessage (messageimportance.low, "global properties:");	if (global_properties != null) foreach (keyvaluepair<string, string> pair in global_properties) log.logmessage (messageimportance.low, "\t{0} = {1}", pair.key, pair.value);	foreach (itaskitem project in projects) {	filename = project.getmetadata ("fullpath");	if (!file.exists (filename)) {	
could not find the project file 

continue;	}	directory.setcurrentdirectory (path.getdirectoryname (filename));	outputs = new hashtable ();	try {	string tv = toolsversion;	if (string.isnullorempty (tv)) tv = project.getmetadata ("toolsversion");	if (!string.isnullorempty (tv) && engine.globalengine.toolsets [tv] == null) throw new unknowntoolsversionexception (tv);	result = buildengine2.buildprojectfile (filename, targets, global_properties, outputs, tv);	} catch (invalidprojectfileexception e) {	
error building project 

========================= mono sample_22279 =========================

public void dispose () {	
dispbar dispose 

========================= mono sample_3150 =========================

protected void verifyendoftransmit (memorystream ms) {	if (ms.position == ms.length) return;	byte [] bytes = new byte [ms.length - ms.position];	ms.read (bytes, 0, bytes.length);	foreach (byte b in bytes) console.write ("{0:x02} ", b);	
total bytes remained 

========================= mono sample_32321 =========================

static int main () {	bindingflags flags = bindingflags.instance | bindingflags.public | bindingflags.invokemethod;	methodinfo mi = typeof (nullabletestclass).getmethod ("f");	nullabletestclass nullable = new nullabletestclass ();	simplestruct? test = new simplestruct (90, 90);	mi.invoke (nullable, flags, new passesstuffbinder (null), new object [] {null}, null);	if (nullable.hasvalue) {	
invoked nullabled with null arg but did not get a null in the method 

methodinfo mi = typeof (nullabletestclass).getmethod ("f");	nullabletestclass nullable = new nullabletestclass ();	simplestruct? test = new simplestruct (90, 90);	mi.invoke (nullable, flags, new passesstuffbinder (null), new object [] {null}, null);	if (nullable.hasvalue) {	return 1;	}	nullable = new nullabletestclass ();	mi.invoke (nullable, flags, new passesstuffbinder (new simplestruct (10, 20)), new object [] {200}, null);	if (!nullable.hasvalue || nullable.bval != 20) {	
invoked nullabled with boxed struct but did not get it 

return 1;	}	nullable = new nullabletestclass ();	mi.invoke (nullable, flags, new passesstuffbinder (new simplestruct (10, 20)), new object [] {200}, null);	if (!nullable.hasvalue || nullable.bval != 20) {	return 2;	}	nullable = new nullabletestclass ();	mi.invoke (nullable, flags, new passesstuffbinder (test), new object [] {200}, null);	if (!nullable.hasvalue || nullable.bval != 90) {	
invoked nullabled with nullable literal but did not get it 

}	nullable = new nullabletestclass ();	mi.invoke (nullable, flags, new passesstuffbinder (test), new object [] {200}, null);	if (!nullable.hasvalue || nullable.bval != 90) {	return 3;	}	mi = typeof (primitivetestclass).getmethod ("i4");	primitivetestclass prim = new primitivetestclass ();	mi.invoke (prim, flags, new passesstuffbinder ((byte)10), new object [] {88}, null);	if (prim.val != 10) {	
invoked primitive with byte it should be widened to int 

return 3;	}	mi = typeof (primitivetestclass).getmethod ("i4");	primitivetestclass prim = new primitivetestclass ();	mi.invoke (prim, flags, new passesstuffbinder ((byte)10), new object [] {88}, null);	if (prim.val != 10) {	return 4;	}	try {	mi.invoke (prim, flags, new passesstuffbinder (missing.value), new object [] {null}, null);	
invoked literal with reference value 

} catch (exception) {	}	try {	methodinfo method = typeof (driver).getmethod ("structtest");	methodinfo generic_method = method.makegenericmethod (typeof (int));	generic_method.invoke (null, new object [] { new genericstruct<int>() });	method = typeof (driver).getmethod ("referencetest");	generic_method = method.makegenericmethod (typeof (int));	generic_method.invoke (null, new object [] { new genericclass<int>() });	} catch (exception e) {	
calling with generic arg failed 

========================= mono sample_537 =========================

string path = string.empty;	try {	int length = filename_max + 1;	stringbuilder location = new stringbuilder(length);	int hr = msigetproductinfow(getsdkdir ? productsdkcode : productcode, installproperty_installlocation, location, ref length);	int error = marshal.getlastwin32error();	if (hr == 0) {	path = location.tostring();	}	else {	
error loading install directory 

string path = string.empty;	try {	int length = filename_max + 1;	stringbuilder location = new stringbuilder(length);	int hr = msigetproductinfow(productcode, installproperty_installlocation, location, ref length);	int error = marshal.getlastwin32error();	if (hr == 0) {	path = location.tostring();	}	else {	
error loading install directory 

========================= mono sample_17069 =========================

static void main () {	type type = typeof (brushes);	propertyinfo[] properties = type.getproperties ();	int count = 1;	foreach (propertyinfo property in properties) {	console.writeline("\n\t\t\tbr = brushes." + property.name + ";");	
assert istrue br is solidbrush p count 

static void main () {	type type = typeof (brushes);	propertyinfo[] properties = type.getproperties ();	int count = 1;	foreach (propertyinfo property in properties) {	console.writeline("\n\t\t\tbr = brushes." + property.name + ";");	console.writeline("\t\t\tsolid = (solidbrush) br;");	
assert areequal color solid color p count 

static void main () {	type type = typeof (brushes);	propertyinfo[] properties = type.getproperties ();	int count = 1;	foreach (propertyinfo property in properties) {	console.writeline("\n\t\t\tbr = brushes." + property.name + ";");	console.writeline("\t\t\tsolid = (solidbrush) br;");	if (property.name != "red") {	console.writeline("\t\t\tsolid.color = color.red;");	
assert areequal color red solid color p count 

static void main () {	type type = typeof (brushes);	propertyinfo[] properties = type.getproperties ();	int count = 1;	foreach (propertyinfo property in properties) {	console.writeline("\n\t\t\tbr = brushes." + property.name + ";");	console.writeline("\t\t\tsolid = (solidbrush) br;");	if (property.name != "red") {	console.writeline("\t\t\tsolid.color = color.red;");	
assert areequal color red brushes as solidbrush color p count 

type type = typeof (brushes);	propertyinfo[] properties = type.getproperties ();	int count = 1;	foreach (propertyinfo property in properties) {	console.writeline("\n\t\t\tbr = brushes." + property.name + ";");	console.writeline("\t\t\tsolid = (solidbrush) br;");	if (property.name != "red") {	console.writeline("\t\t\tsolid.color = color.red;");	} else {	console.writeline("\t\t\tsolid.color = color.white;");	
assert areequal color white solid color p count 

type type = typeof (brushes);	propertyinfo[] properties = type.getproperties ();	int count = 1;	foreach (propertyinfo property in properties) {	console.writeline("\n\t\t\tbr = brushes." + property.name + ";");	console.writeline("\t\t\tsolid = (solidbrush) br;");	if (property.name != "red") {	console.writeline("\t\t\tsolid.color = color.red;");	} else {	console.writeline("\t\t\tsolid.color = color.white;");	
assert areequal color white brushes as solidbrush color p count 

========================= mono sample_21197 =========================

public override string tostring() {	var sw = new stringwriter();	
nulls 

public override string tostring() {	var sw = new stringwriter();	sw.writeline("<");	this.nulls.dump (sw);	sw.writeline(">");	
non nulls 

========================= mono sample_29589 =========================

static void prints (string s, object x) {	
size of 

========================= mono sample_69 =========================

}	marshal.freehglobal (buf);	}	}	gdiplusstartupinput input = gdiplusstartupinput.makegdiplusstartupinput();	gdiplusstartupoutput output = gdiplusstartupoutput.makegdiplusstartupoutput();	try {	gdiplusstartup (ref gdiplustoken, ref input, ref output);	}	catch (typeinitializationexception) {	
error can not initialize gdi library please check http environment newline 

========================= mono sample_21257 =========================

public static void print (object obj) {	if (obj == null) console.writeline ("null");	
object 

========================= mono sample_3257 =========================

static void writeunhandledexception (appdomain appdomain, exception exception) {	
error in background work item 

========================= mono sample_18390 =========================

public static void main () {	generictype<bool> g = new generictype<bool> (true);	
true 

========================= mono sample_3086 =========================

static bool loadconfig (bool quiet) {	methodinfo config = typeof (system.environment).getmethod ("getmachineconfigpath", bindingflags.static|bindingflags.nonpublic);	if (config != null) {	string path = (string) config.invoke (null, null);	bool exist = file.exists (path);	
couldn t find machine config 

static bool loadconfig (bool quiet) {	methodinfo config = typeof (system.environment).getmethod ("getmachineconfigpath", bindingflags.static|bindingflags.nonpublic);	if (config != null) {	string path = (string) config.invoke (null, null);	bool exist = file.exists (path);	strongnamemanager.loadconfig (path);	return exist;	}	
couldn t resolve machine config location corlib issue 

static bool resign (string assemblyname, rsa key, bool quiet) {	assemblyname an = null;	try {	an = assemblyname.getassemblyname (assemblyname);	}	catch {	}	if (an == null) {	
unable to load assembly 

bool same = compare (sign.publickey, strongnamemanager.getmappedpublickey (token));	if (!same) {	same = compare (sign.publickey, an.getpublickey ());	if (!same) {	same = compare (sign.publickeytoken, token);	}	}	if (same) {	bool signed = sign.sign (assemblyname);	if (!quiet || !signed) {	
assembly signed couldn t sign the assembly 

if (!same) {	same = compare (sign.publickeytoken, token);	}	}	if (same) {	bool signed = sign.sign (assemblyname);	if (!quiet || !signed) {	}	return signed;	}	
couldn t sign the assembly with this key pair public key of assembly did not match signing public key 

static int verify (string assemblyname, bool forceverification, bool quiet) {	assemblyname an = null;	try {	an = assemblyname.getassemblyname (assemblyname);	}	catch {	}	if (an == null) {	
unable to load assembly 

}	catch {	}	if (an == null) {	return 2;	}	byte[] publickey = strongnamemanager.getmappedpublickey (an.getpublickeytoken ());	if ((publickey == null) || (publickey.length < 12)) {	publickey = an.getpublickey ();	if ((publickey == null) || (publickey.length < 12)) {	
is not a strongly named assembly 

if ((publickey == null) || (publickey.length < 12)) {	publickey = an.getpublickey ();	if ((publickey == null) || (publickey.length < 12)) {	return 2;	}	}	if (forceverification || strongnamemanager.mustverify (an)) {	rsa rsa = cryptoconvert.fromcapipublickeyblob (publickey, 12);	strongname sn = new strongname (rsa);	if (sn.verify (assemblyname)) {	
assembly is strongnamed 

return 2;	}	}	if (forceverification || strongnamemanager.mustverify (an)) {	rsa rsa = cryptoconvert.fromcapipublickeyblob (publickey, 12);	strongname sn = new strongname (rsa);	if (sn.verify (assemblyname)) {	return 0;	}	else {	
assembly is delay signed but not strongnamed 

rsa rsa = cryptoconvert.fromcapipublickeyblob (publickey, 12);	strongname sn = new strongname (rsa);	if (sn.verify (assemblyname)) {	return 0;	}	else {	return 1;	}	}	else {	
assembly is strongnamed verification skipped 

static void help (string details) {	
usage sn q quiet options parameters 

static void help (string details) {	
q quiet quiet mode minimal display 

static void help (string details) {	switch (details) {	
config configuration options 

static void help (string details) {	switch (details) {	
c provider change the default csp provider 

static void help (string details) {	switch (details) {	
m y n use a machine y key container or user key container n 

static void help (string details) {	switch (details) {	
vl list the verification options 

static void help (string details) {	switch (details) {	
vr assembly userlist exempt the specified assembly from verification for the user list 

static void help (string details) {	switch (details) {	
vu assembly remove exemption entry for the specified assembly 

static void help (string details) {	switch (details) {	
vx remove all exemptions entries 

static void help (string details) {	switch (details) {	
currently not implemented in the tool 

static void help (string details) {	switch (details) {	break;	
csp csp related options 

static void help (string details) {	switch (details) {	break;	
d container delete the specified key container 

static void help (string details) {	switch (details) {	break;	
i keypair snk container import the keypair from a snk file into a csp container 

static void help (string details) {	switch (details) {	break;	
pc container public key export the public key from a csp container to the specified file 

static void help (string details) {	switch (details) {	break;	break;	
convert convertion options 

static void help (string details) {	switch (details) {	break;	break;	
e assembly output pub export the assembly public key to the specified file 

static void help (string details) {	switch (details) {	break;	break;	
p keypair snk output pub export the public key from a snk file to the specified file 

static void help (string details) {	switch (details) {	break;	break;	
o input output txt convert the input file to a csv file using decimal 

static void help (string details) {	switch (details) {	break;	break;	
oh input output txt convert the input file to a csv file using hexadecimal 

static void help (string details) {	switch (details) {	break;	break;	break;	
sn strongname signing options 

static void help (string details) {	switch (details) {	break;	break;	break;	
d compare and without signatures 

static void help (string details) {	switch (details) {	break;	break;	break;	
k keypair snk create a new keypair in the specified file 

static void help (string details) {	switch (details) {	break;	break;	break;	
r assembly keypair snk resign the assembly with the specified strongname key file 

static void help (string details) {	switch (details) {	break;	break;	break;	
rc assembly container resign the assembly with the specified csp container 

static void help (string details) {	switch (details) {	break;	break;	break;	
t file show the public key token from the specified file 

static void help (string details) {	switch (details) {	break;	break;	break;	
tp file show the public key and pk token from the specified file 

static void help (string details) {	switch (details) {	break;	break;	break;	
t assembly show the public key token from the specified assembly 

static void help (string details) {	switch (details) {	break;	break;	break;	
tp assembly show the public key and pk token from the specified assembly 

static void help (string details) {	switch (details) {	break;	break;	break;	
v assembly verify the specified assembly signature 

static void help (string details) {	switch (details) {	break;	break;	break;	
vf assembly verify the specified assembly signature even if disabled 

static void help (string details) {	switch (details) {	break;	break;	break;	break;	
help options 

static void help (string details) {	switch (details) {	break;	break;	break;	break;	
h show this help screen about the tool 

static void help (string details) {	switch (details) {	break;	break;	break;	break;	
h config configuration options 

static void help (string details) {	switch (details) {	break;	break;	break;	break;	
h csp crypto service provider csp related options 

static void help (string details) {	switch (details) {	break;	break;	break;	break;	
h convert format convertion options 

static void help (string details) {	switch (details) {	break;	break;	break;	break;	
h sn strongname signing options 

assemblyname an = null;	rsacryptoserviceprovider rsa = null;	cspparameters csp = new cspparameters ();	csp.providername = defaultcsp;	switch (args [i++]) {	case "-c": defaultcsp = args [i];	return saveconfig ();	case "-d": csp.keycontainername = args [i];	rsa = new rsacryptoserviceprovider (csp);	rsa.persistkeyincsp = false;	
keypair in container has been deleted 

return saveconfig ();	case "-d": csp.keycontainername = args [i];	rsa = new rsacryptoserviceprovider (csp);	rsa.persistkeyincsp = false;	break;	case "-d": strongname a1 = new strongname ();	byte[] h1 = a1.hash (args [i++]);	strongname a2 = new strongname ();	byte[] h2 = a2.hash (args [i++]);	if (compare (h1, h2)) {	
both assembly are identical same digest for metadata 

case "-d": csp.keycontainername = args [i];	rsa = new rsacryptoserviceprovider (csp);	rsa.persistkeyincsp = false;	break;	case "-d": strongname a1 = new strongname ();	byte[] h1 = a1.hash (args [i++]);	strongname a2 = new strongname ();	byte[] h2 = a2.hash (args [i++]);	if (compare (h1, h2)) {	}	
assemblies are not identical different digest for metadata 

break;	case "-d": strongname a1 = new strongname ();	byte[] h1 = a1.hash (args [i++]);	strongname a2 = new strongname ();	byte[] h2 = a2.hash (args [i++]);	if (compare (h1, h2)) {	}	break;	case "-e": an = assemblyname.getassemblyname (args [i++]);	writetofile (args[i], an.getpublickey ());	
public key extracted to file 

if (i < args.length + 2) {	try {	size = int32.parse (args[i++]);	}	catch {	i--;	}	}	sn = new strongname (size);	writetofile (args[i], cryptoconvert.tocapikeyblob (sn.rsa, true));	
a new bits strong name keypair has been generated in file 

try {	size = int32.parse (args[i++]);	}	catch {	i--;	}	}	sn = new strongname (size);	writetofile (args[i], cryptoconvert.tocapikeyblob (sn.rsa, true));	break;	
m unimplemented option 

catch {	i--;	}	}	sn = new strongname (size);	writetofile (args[i], cryptoconvert.tocapikeyblob (sn.rsa, true));	break;	break;	case "-o": byte[] infiled = readfromfile (args [i++]);	writecsvtofile (args [i], infiled, "d");	
output csv file is decimal format 

}	sn = new strongname (size);	writetofile (args[i], cryptoconvert.tocapikeyblob (sn.rsa, true));	break;	break;	case "-o": byte[] infiled = readfromfile (args [i++]);	writecsvtofile (args [i], infiled, "d");	break;	case "-oh": byte[] infilex2 = readfromfile (args [i++]);	writecsvtofile (args [i], infilex2, "x2");	
output cvs file is hexadecimal format 

break;	break;	case "-o": byte[] infiled = readfromfile (args [i++]);	writecsvtofile (args [i], infiled, "d");	break;	case "-oh": byte[] infilex2 = readfromfile (args [i++]);	writecsvtofile (args [i], infilex2, "x2");	break;	case "-p": sn = new strongname (getkeyfromfile (args [i++]));	writetofile (args[i], sn.publickey);	
public key extracted to file 

case "-oh": byte[] infilex2 = readfromfile (args [i++]);	writecsvtofile (args [i], infilex2, "x2");	break;	case "-p": sn = new strongname (getkeyfromfile (args [i++]));	writetofile (args[i], sn.publickey);	break;	case "-pc": csp.keycontainername = args [i++];	rsa = new rsacryptoserviceprovider (csp);	sn = new strongname (rsa);	writetofile (args[i], sn.publickey);	
public key extracted to file 

break;	case "-r": string filename = args [i++];	if (! resign (filename, getkeyfromfile (args [i]), quiet)) return 1;	break;	case "-rc": filename = args [i++];	csp.keycontainername = args [i];	rsa = new rsacryptoserviceprovider (csp);	if (! resign (filename, rsa, quiet)) return 1;	break;	case "-t": sn = new strongname (readfromfile (args [i]));	
public key token 

if (! resign (filename, getkeyfromfile (args [i]), quiet)) return 1;	break;	case "-rc": filename = args [i++];	csp.keycontainername = args [i];	rsa = new rsacryptoserviceprovider (csp);	if (! resign (filename, rsa, quiet)) return 1;	break;	case "-t": sn = new strongname (readfromfile (args [i]));	break;	case "-tp": sn = new strongname (readfromfile (args [i]));	
public key 

if (! resign (filename, getkeyfromfile (args [i]), quiet)) return 1;	break;	case "-rc": filename = args [i++];	csp.keycontainername = args [i];	rsa = new rsacryptoserviceprovider (csp);	if (! resign (filename, rsa, quiet)) return 1;	break;	case "-t": sn = new strongname (readfromfile (args [i]));	break;	case "-tp": sn = new strongname (readfromfile (args [i]));	
public key token 

rsa = new rsacryptoserviceprovider (csp);	if (! resign (filename, rsa, quiet)) return 1;	break;	case "-t": sn = new strongname (readfromfile (args [i]));	break;	case "-tp": sn = new strongname (readfromfile (args [i]));	break;	case "-t": an = assemblyname.getassemblyname (args [i++]);	byte [] pkt = an.getpublickeytoken ();	if (pkt == null) {	
does not represent a strongly named assembly 

if (! resign (filename, rsa, quiet)) return 1;	break;	case "-t": sn = new strongname (readfromfile (args [i]));	break;	case "-tp": sn = new strongname (readfromfile (args [i]));	break;	case "-t": an = assemblyname.getassemblyname (args [i++]);	byte [] pkt = an.getpublickeytoken ();	if (pkt == null) {	} else {	
public key token 

break;	case "-t": an = assemblyname.getassemblyname (args [i++]);	byte [] pkt = an.getpublickeytoken ();	if (pkt == null) {	} else {	}	break;	case "-tp": an = assemblyname.getassemblyname (args [i++]);	byte [] token = an.getpublickeytoken ();	if (token == null) {	
does not represent a strongly named assembly 

case "-t": an = assemblyname.getassemblyname (args [i++]);	byte [] pkt = an.getpublickeytoken ();	if (pkt == null) {	} else {	}	break;	case "-tp": an = assemblyname.getassemblyname (args [i++]);	byte [] token = an.getpublickeytoken ();	if (token == null) {	} else {	
public key 

case "-t": an = assemblyname.getassemblyname (args [i++]);	byte [] pkt = an.getpublickeytoken ();	if (pkt == null) {	} else {	}	break;	case "-tp": an = assemblyname.getassemblyname (args [i++]);	byte [] token = an.getpublickeytoken ();	if (token == null) {	} else {	
public key token 

case "-tp": an = assemblyname.getassemblyname (args [i++]);	byte [] token = an.getpublickeytoken ();	if (token == null) {	} else {	}	break;	case "-v": filename = args [i++];	return verify (filename, false, quiet);	case "-vf": filename = args [i++];	return verify (filename, true, quiet);	
vl 

byte [] token = an.getpublickeytoken ();	if (token == null) {	} else {	}	break;	case "-v": filename = args [i++];	return verify (filename, false, quiet);	case "-vf": filename = args [i++];	return verify (filename, true, quiet);	break;	
vr unimplemented option 

if (token == null) {	} else {	}	break;	case "-v": filename = args [i++];	return verify (filename, false, quiet);	case "-vf": filename = args [i++];	return verify (filename, true, quiet);	break;	break;	
vu unimplemented option 

} else {	}	break;	case "-v": filename = args [i++];	return verify (filename, false, quiet);	case "-vf": filename = args [i++];	return verify (filename, true, quiet);	break;	break;	break;	
vx unimplemented option 

case "-v": filename = args [i++];	return verify (filename, false, quiet);	case "-vf": filename = args [i++];	return verify (filename, true, quiet);	break;	break;	break;	break;	case "-?": case "-h": help ((i < args.length) ? args [i] : null);	break;	
unknown option 

static int main (string[] args) {	try {	if (args.length < 1) {	header ();	help (null);	} else {	return process (args);	}	}	catch (indexoutofrangeexception) {	
error invalid number of parameters 

header ();	help (null);	} else {	return process (args);	}	}	catch (indexoutofrangeexception) {	help (null);	}	catch (cryptographicexception ce) {	
error 

} else {	return process (args);	}	}	catch (indexoutofrangeexception) {	help (null);	}	catch (cryptographicexception ce) {	}	catch (exception e) {	
error unknown error during processing 

========================= mono sample_1183 =========================

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
frompage 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
topage 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
maximumcopies 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
isdefaultprinter 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
supportscolor 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
maximumpage 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
minimumpage 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	
landscapeangle 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	for (int p = 0; p < ps.printerresolutions.count; p++) {	
printerresolutions 

public static void main (string[] args) {	printersettings.stringcollection col = system.drawing.printing.printersettings.installedprinters;	for (int i = 0; i < col.count; i++) {	console.writeline ("--- {0}", col[i]);	printersettings ps = new printersettings ();	ps.printername = col[i];	for (int p = 0; p < ps.printerresolutions.count; p++) {	}*/ for (int p = 0; p < ps.papersizes.count; p++) {	
papersize name kind width height 

========================= mono sample_21317 =========================

static void main () {	appdomain domain = appdomain.createdomain ("new-domain");	domain.docallback (run);	type sttype = typeof (something<string, string>);	other<string, string> st = (other<string, string>) domain.createinstanceandunwrap (sttype.assembly.fullname, sttype.fullname);	
in main int 

static void main () {	appdomain domain = appdomain.createdomain ("new-domain");	domain.docallback (run);	type sttype = typeof (something<string, string>);	other<string, string> st = (other<string, string>) domain.createinstanceandunwrap (sttype.assembly.fullname, sttype.fullname);	
in main types 

public static void dorun<t1, t2> (other<t1, t2> some) {	
domain 

public static void dorun<t1, t2> (other<t1, t2> some) {	console.writeline ("this is null: {0}", some.mappings == null);	
int 

public override string gettypenames<t3> () {	
gettypenames in 

========================= mono sample_443 =========================

static void do_hello (string hello) {	
hello 

========================= mono sample_2319 =========================

public static int test_0_atest () {	int[] ia = new int[32];	for (int i = 0; i <ia.length; i++) ia [i] = i*i;	for (int i = 0; i <ia.length; i++) if (ia [i] != i*i) return 1;	if (ia.rank != 1) return 2;	if (ia.getvalue (2) == null) return 3;	for (int i = 0; i <ia.length; i++) ia.setvalue (i*i*i, i);	for (int i = 0; i <ia.length; i++) if ((int)ia.getvalue (i) != i*i*i){	
crap 

========================= mono sample_503 =========================

static leaf () {	
static leaf constructor called in 

public leaf () {	
created leaf in 

========================= mono sample_692 =========================

public static void readblob (oracleconnection connection) {	if (file.exists(outfilename) == true) {	
filename already exists 

public static void readblob (oracleconnection connection) {	if (file.exists(outfilename) == true) {	return;	}	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select blob_column from blobtest";	oracledatareader reader2 = rcmd.executereader ();	
error record not found 

public static void readblob (oracleconnection connection) {	if (file.exists(outfilename) == true) {	return;	}	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select blob_column from blobtest";	oracledatareader reader2 = rcmd.executereader ();	
testing oraclelob object 

public static void readblob (oracleconnection connection) {	if (file.exists(outfilename) == true) {	return;	}	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select blob_column from blobtest";	oracledatareader reader2 = rcmd.executereader ();	oraclelob lob2 = reader2.getoraclelob (0);	
length 

public static void readblob (oracleconnection connection) {	if (file.exists(outfilename) == true) {	return;	}	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select blob_column from blobtest";	oracledatareader reader2 = rcmd.executereader ();	oraclelob lob2 = reader2.getoraclelob (0);	
chunk size 

public static void readblob (oracleconnection connection) {	if (file.exists(outfilename) == true) {	return;	}	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select blob_column from blobtest";	oracledatareader reader2 = rcmd.executereader ();	oraclelob lob2 = reader2.getoraclelob (0);	byte[] lobvalue = (byte[]) lob2.value;	if (bytearraycompare(bytes1, lobvalue) == true) console.writeline("bytes1 and bytes2 are equal: good");	
and are not equal bad 

public static void blobtest (oracleconnection connection) {	
begin transaction 

public static void blobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	
drop table blobtest 

public static void blobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	try {	oraclecommand cmd2 = connection.createcommand ();	cmd2.transaction = transaction;	cmd2.commandtext = "drop table blobtest";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	
create table 

cmd2.transaction = transaction;	cmd2.commandtext = "drop table blobtest";	cmd2.executenonquery ();	}	catch (oracleexception) {	}	oraclecommand create = connection.createcommand ();	create.transaction = transaction;	create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	
insert record 

create.transaction = transaction;	create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	
selecting a blob binary large object value from blobtest 

create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	
error record not found 

create.commandtext = "create table blobtest (blob_column blob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	
testing oraclelob object 

create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	
length 

create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	
chunk size 

oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into blobtest values (empty_blob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select blob_column from blobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	if (file.exists(infilename) == false) {	
filename does not exist 

oraclelob lob = reader.getoraclelob (0);	if (file.exists(infilename) == false) {	return;	}	filestream fs = new filestream(infilename, filemode.open, fileaccess.read);	binaryreader r = new binaryreader(fs);	byte[] bytes = null;	int bufferlen = 8192;	bytes = r.readbytes (bufferlen);	while(bytes.length > 0) {	
byte count 

bytes = r.readbytes (bufferlen);	while(bytes.length > 0) {	lob.write (bytes, 0, bytes.length);	bytes1 = bytearraycombine (bytes1, bytes);	if (bytes.length < bufferlen) break;	bytes = r.readbytes (bufferlen);	}	r.close();	fs.close ();	lob.close ();	
closing reader 

static bool bytearraycompare(byte[] ba1, byte[] ba2) {	if (ba1 == null && ba2 == null) return true;	if (ba1 == null) return false;	if (ba2 == null) return false;	if (ba1.length != ba2.length) return false;	for (int i = 0; i < ba1.length; i++) {	
i 

========================= mono sample_4916 =========================

static private void help () {	
usage secutil options filename 

static private void help () {	
secutil s assembly 

static private void help () {	
secutil strongname assembly 

static private void help () {	
show strongname informations about the assembly 

static private void help () {	
secutil x assembly 

static private void help () {	
secutil assembly 

static private void help () {	
show the authenticode certificate for the assembly 

static private void help () {	
secutil hex 

static private void help () {	
show data in hexadecimal 

static private void help () {	
secutil a 

static private void help () {	
secutil array 

static private void help () {	
show data in a decimal array default 

static private void help () {	
secutil v 

static private void help () {	
secutil vbmode 

static private void help () {	
show data in a visualbasic friendly format 

static private void help () {	
secutil c 

static private void help () {	
secutil cmode 

static private void help () {	
show data in a c c c friendly format default 

static private void help () {	
secutil h 

static private void help () {	
secutil help 

static private void help () {	
secutil 

static private void help () {	
secutil 

static private void help () {	
show help about this tool 

break;	}	}	if (help) help ();	if (sn) strongname (filename);	else if (cert) certificate (filename);	else help ();	console.writeline ((error == null) ? "success" : error);	}	catch (exception e) {	
error 

========================= mono sample_1170 =========================

string path = string.empty;	try {	int length = filename_max + 1;	stringbuilder location = new stringbuilder(length);	int hr = msigetproductinfow(getsdkdir ? productsdkcode : productcode, installproperty_installlocation, location, ref length);	int error = marshal.getlastwin32error();	if (hr == 0) {	path = location.tostring();	}	else {	
error loading install directory 

string path = string.empty;	try {	int length = filename_max + 1;	stringbuilder location = new stringbuilder(length);	int hr = msigetproductinfow(productcode, installproperty_installlocation, location, ref length);	int error = marshal.getlastwin32error();	if (hr == 0) {	path = location.tostring();	}	else {	
error loading install directory 

========================= mono sample_12769 =========================

switch (args [0]) {	case "big5": main (new string [] {	"cp950.txt", "big5.table", "a1", "43"});	return;	case "gb2312": main (new string [] {	"cp936.txt", "gb2312-new.table", "81", "5e"});	return;	}	}	if (args.length < 3) {	
dbcs table generator exe dbcs table generator exe dbcs table generator exe cpxxx txt xxx table from len 

========================= mono sample_30210 =========================

public static void main(string[] argv) {	
type of anonymous block 

========================= mono sample_35435 =========================

protected override tchannel onacceptchannel (timespan timeout) {	
namedpipechannellistener onacceptchannel 

protected override tchannel onacceptchannel (timespan timeout) {	if (active_server != null) {	try {	server_release_handle.waitone (timeout);	} catch (timeoutexception) {	return null;	}	}	
namedpipechannellistener onacceptchannel 

protected override tchannel onacceptchannel (timespan timeout) {	if (active_server != null) {	try {	server_release_handle.waitone (timeout);	} catch (timeoutexception) {	return null;	}	}	var server = new namedpipeserverstream (uri.localpath.substring (1).replace ('/', '\\'), pipedirection.inout);	active_server = server;	
namedpipechannellistener onacceptchannel 

========================= mono sample_31632 =========================

public override void update() {	base.update();	this.context.sessionid			= this.sessionid;	this.context.serverrandom		= this.random;	this.context.negotiating.cipher = this.ciphersuite;	this.context.compressionmethod	= this.compressionmethod;	this.context.protocolnegotiated	= true;	
selected cipher suite 

public override void update() {	base.update();	this.context.sessionid			= this.sessionid;	this.context.serverrandom		= this.random;	this.context.negotiating.cipher = this.ciphersuite;	this.context.compressionmethod	= this.compressionmethod;	this.context.protocolnegotiated	= true;	
client random 

public override void update() {	base.update();	this.context.sessionid			= this.sessionid;	this.context.serverrandom		= this.random;	this.context.negotiating.cipher = this.ciphersuite;	this.context.compressionmethod	= this.compressionmethod;	this.context.protocolnegotiated	= true;	
server random 

private void processprotocol(short protocol) {	securityprotocoltype serverprotocol = this.context.decodeprotocolcode(protocol);	if ((serverprotocol & this.context.securityprotocolflags) == serverprotocol || (this.context.securityprotocolflags & securityprotocoltype.default) == securityprotocoltype.default) {	this.context.securityprotocol = serverprotocol;	this.context.supportedciphers = ciphersuitefactory.getsupportedciphers (false, serverprotocol);	
selected protocol 

========================= mono sample_20686 =========================

public static int main () {	int v;	object o = null;	if (o == null || false) o = 1;	else o = 2;	
v 

int v;	object o = null;	if (o == null || false) o = 1;	else o = 2;	v = test_if ();	if (v != 0) return v;	v = test_inline ();	if (v != 0) return 30 + v;	v = test_while ();	if (v != 0) return 90 + v;	
test ok 

========================= mono sample_3838 =========================

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(xmlnode));	filestream fs=new filestream(filename, filemode.open);	xmlnode node;	node=(xmlnode)ser.deserialize(fs);	fs.close();	
node type 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(xmlnode));	filestream fs=new filestream(filename, filemode.open);	xmlnode node;	node=(xmlnode)ser.deserialize(fs);	fs.close();	
node name 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(xmlnode));	filestream fs=new filestream(filename, filemode.open);	xmlnode node;	node=(xmlnode)ser.deserialize(fs);	fs.close();	
node ns 

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(xmlnode));	filestream fs=new filestream(filename, filemode.open);	xmlnode node;	node=(xmlnode)ser.deserialize(fs);	fs.close();	
node inner text 

========================= mono sample_22552 =========================

public override void update() {	base.update();	this.context.sessionid			= this.sessionid;	this.context.serverrandom		= this.random;	this.context.negotiating.cipher = this.ciphersuite;	this.context.compressionmethod	= this.compressionmethod;	this.context.protocolnegotiated	= true;	
selected cipher suite 

public override void update() {	base.update();	this.context.sessionid			= this.sessionid;	this.context.serverrandom		= this.random;	this.context.negotiating.cipher = this.ciphersuite;	this.context.compressionmethod	= this.compressionmethod;	this.context.protocolnegotiated	= true;	
client random 

public override void update() {	base.update();	this.context.sessionid			= this.sessionid;	this.context.serverrandom		= this.random;	this.context.negotiating.cipher = this.ciphersuite;	this.context.compressionmethod	= this.compressionmethod;	this.context.protocolnegotiated	= true;	
server random 

private void processprotocol(short protocol) {	securityprotocoltype serverprotocol = this.context.decodeprotocolcode(protocol);	if ((serverprotocol & this.context.securityprotocolflags) == serverprotocol || (this.context.securityprotocolflags & securityprotocoltype.default) == securityprotocoltype.default) {	this.context.securityprotocol = serverprotocol;	this.context.supportedciphers.clear();	this.context.supportedciphers = null;	this.context.supportedciphers = ciphersuitefactory.getsupportedciphers(serverprotocol);	
selected protocol 

========================= mono sample_31723 =========================

public void bar() {	
bar 

public ilist<t> bar<t>() {	
bar t 

========================= mono sample_3688 =========================

public void createtext () {	string path = tempfolder + dsc + "fit.createtext.test";	deletefile (path);	try {	fileinfo info = new fileinfo (path);	assert.isfalse (info.exists, "#1");	streamwriter writer = info.createtext ();	
test 

========================= mono sample_27155 =========================

public void loadfrom_invalid_assembly () {	string tempfile = path.combine (tempfolder, path.getrandomfilename ());	using (streamwriter sw = file.createtext (tempfile)) {	
foo 

public void bug78468 () {	string assemblyfilenamea = path.combine (tempfolder, "bug78468a.dll");	string resourcefilename = path.combine (tempfolder, "readme.txt");	using (streamwriter sw = file.createtext (resourcefilename)) {	
foo 

========================= mono sample_27044 =========================

public static void main (string[] argv) {	
test 

public static void main (string[] argv) {	foreach (string arg in argv) {	
out 

public static void main (string[] argv) {	foreach (string arg in argv) {	a a = delegate {	
arg 

========================= mono sample_3548 =========================

public static int main () {	var t = new test ();	if (!t.foreachtest ()) return 1;	if (!t.foreachtest_2 ()) return 2;	if (!t.foreachtest_3 ()) return 3;	if (!t.usingtest ()) return 10;	
ok 

========================= mono sample_3799 =========================

public static void main(string[] args) {	const int iterations = 10000;	test test = new test ();	datetime start = datetime.now;	console.write ("calling test.donothing<program>() on an object reference...  ");	for (int i = 0; i < iterations; ++i) {	test.donothing<program> ();	}	datetime end = datetime.now;	timespan duration = end - start;	
took ms 

datetime end = datetime.now;	timespan duration = end - start;	itest testinterface = test;	start = datetime.now;	console.write ("calling test.donothing<program>() on an interface reference...  ");	for (int i = 0; i < iterations; ++i) {	testinterface.donothing<program> ();	}	end = datetime.now;	duration = end - start;	
took ms 

========================= mono sample_2463 =========================

public foo () {	
inside the foo constructor now 

public int bar (int i, int j) {	
the bar method 

public static int main () {	foo f = new foo ();	int j = f.bar (2, 3);	
blah foo bar returned 

========================= mono sample_1909 =========================

public static void run () {	try {	long (5);	
long 

public static void run () {	try {	long (5);	thread.sleep (10000);	}	catch (threadabortexception) {	thread.resetabort ();	
ok 

if (mrp.cancasttocalled) return 299;	total += itf299.callme (299);	mrp.cancasttocalled = false;	i300 itf300 = (i300)o;	if (!mrp.cancasttocalled) return 300;	total += itf300.callme (300);	mrp.cancasttocalled = false;	itf300 = (i300)o;	if (mrp.cancasttocalled) return 300;	total += itf300.callme (300);	
finished 

========================= mono sample_279 =========================

public static void staticexcept () {	try {	nongen.dothrow ();	}	catch (genexc<t>) {	
exception thrown and caught 

public static void printcar (t _car) {	
car cdr 

========================= mono sample_339 =========================

static void main () {	int[] integer_array = {0, 1};	
test for error the compiler should say wrong number of fields inside the indexer 

static void main () {	int[] integer_array = {0, 1};	
trying to access integer array in a one dimensional array 

========================= mono sample_34023 =========================

public static void main () {	
system string 

========================= mono sample_33703 =========================

public static void main ( ) {	errorcs3005 error = new errorcs3005 ();	
this should make the compiler to complain error number 

========================= mono sample_36066 =========================

static void function () {	
delegate method 

static void async_callback (iasyncresult ar) {	
async callback 

public static int main () {	environment.exitcode = 2;	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	d.endinvoke(ar1);	thread.sleep(1000);	
main returns 

========================= mono sample_368 =========================

if (b_int_field != 10) return 1;	if (base.b_int_field != 1) return 2;	if (base.b_string_field != "base") return 3;	if (b_string_field != "derived") return 4;	base.b_int_property = 4;	if (b_int_property != 10) return 5;	if (b_int_property != 10) return 6;	if (base.b_int_property != 4) return 7;	if (b_const_three != 4) return 8;	if (base.b_const_three != 3) return 9;	
all tests pass 

========================= mono sample_1539 =========================

static int test (type t, params type[] iface_types) {	hashtable ifaces = new hashtable ();	ifaces.add (ilist_type, state.missing);	ifaces.add (icollection_type, state.missing);	ifaces.add (ienumerable_type, state.missing);	ifaces.add (icloneable_type, state.missing);	ifaces.add (typeof (istructuralequatable), state.missing);	ifaces.add (typeof (istructuralcomparable), state.missing);	type array_type = t.makearraytype ();	if (debug) {	
checking 

ifaces.add (typeof (ireadonlylist<>).makegenerictype (gargs), state.missing);	#endif }	foreach (type iface in array_type.getinterfaces ()) {	if (ifaces.contains (iface)) ifaces [iface] = state.found;	else ifaces.add (iface, state.extra);	}	int errors = 0;	foreach (type iface in ifaces.keys) {	state state = (state) ifaces [iface];	if (state == state.found) {	
found 

foreach (type iface in array_type.getinterfaces ()) {	if (ifaces.contains (iface)) ifaces [iface] = state.found;	else ifaces.add (iface, state.extra);	}	int errors = 0;	foreach (type iface in ifaces.keys) {	state state = (state) ifaces [iface];	if (state == state.found) {	continue;	} else {	
error 

public static int main () {	int result = test ();	if (result == 0) console.writeline ("ok");	
error 

========================= mono sample_2853 =========================

public void replacetest () {	string tmp = path.combine (tmpfolder, "replacetest");	directory.createdirectory (tmp);	string origfile = path.combine (tmp, "origfile");	string replacefile = path.combine (tmp, "replacefile");	string backupfile = path.combine (tmp, "backupfile");	using (streamwriter sw = file.createtext (origfile)) {	
origfile 

public void replacetest () {	string tmp = path.combine (tmpfolder, "replacetest");	directory.createdirectory (tmp);	string origfile = path.combine (tmp, "origfile");	string replacefile = path.combine (tmp, "replacefile");	string backupfile = path.combine (tmp, "backupfile");	using (streamwriter sw = file.createtext (origfile)) {	}	using (streamwriter sw = file.createtext (replacefile)) {	
replacefile 

string tmp = path.combine (tmpfolder, "replacetest");	directory.createdirectory (tmp);	string origfile = path.combine (tmp, "origfile");	string replacefile = path.combine (tmp, "replacefile");	string backupfile = path.combine (tmp, "backupfile");	using (streamwriter sw = file.createtext (origfile)) {	}	using (streamwriter sw = file.createtext (replacefile)) {	}	using (streamwriter sw = file.createtext (backupfile)) {	
backupfile 

========================= mono sample_27130 =========================

public static int main () {	assembly a = assembly.getexecutingassembly ();	var an = a.getname ();	console.writeline (an.version);	if (a.getname ().version != new version (7, 0, 0, 0)) return 1;	if (an.hashalgorithm != assemblyhashalgorithm.md5) return 2;	console.writeline (an.flags);	if (an.flags != (assemblynameflags.publickey | assemblynameflags.enablejitcompileoptimizer | assemblynameflags.retargetable)) return 3;	
ok 

========================= mono sample_2802 =========================

private void writeusings(codewriter writer, generationcontext context) {	writer.writeusingnamespace("system");	writer.writeusingnamespace("system.data");	writer.writeusingnamespace("system.data.linq.mapping");	writer.writeusingnamespace("system.diagnostics");	writer.writeusingnamespace("system.reflection");	#if mono_strict writer.writeusingnamespace("system.data.linq");	
if mono strict 

private void writeusings(codewriter writer, generationcontext context) {	writer.writeusingnamespace("system");	writer.writeusingnamespace("system.data");	writer.writeusingnamespace("system.data.linq.mapping");	writer.writeusingnamespace("system.diagnostics");	writer.writeusingnamespace("system.reflection");	#if mono_strict writer.writeusingnamespace("system.data.linq");	writer.writeusingnamespace("system.data.linq");	
else writer writeusingnamespace linq 

private void writeusings(codewriter writer, generationcontext context) {	writer.writeusingnamespace("system");	writer.writeusingnamespace("system.data");	writer.writeusingnamespace("system.data.linq.mapping");	writer.writeusingnamespace("system.diagnostics");	writer.writeusingnamespace("system.reflection");	#if mono_strict writer.writeusingnamespace("system.data.linq");	writer.writeusingnamespace("system.data.linq");	writer.writeusingnamespace("dblinq.vendor");	
endif endif foreach var implementation in context implementations implementation writeheader writer context 

========================= mono sample_25064 =========================

public override string tostring() {	using (stringwriter writer = new stringwriter(cultureinfo.invariantculture)) {	
securitykeyidentifier 

========================= mono sample_5390 =========================

static getreplicationfilterrequest() {	try {	ldapextendedresponse.register(replicationconstants.get_replication_filter_res, system.type.gettype("novell.directory.ldap.extensions.getreplicationfilterresponse"));	}	catch (system.exception e) {	
could not register extended response class not found 

========================= mono sample_20962 =========================

public override void computemastersecret(byte[] premastersecret) {	this.context.mastersecret = new byte[premastersecret.length];	this.context.mastersecret = this.prf( premastersecret, "master secret", this.context.randomcs, 48);	
mastersecret 

this.context.clientwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, 0, this.context.clientwriteiv, 0, this.context.clientwriteiv.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, this.ivsize, this.context.serverwriteiv, 0, this.context.serverwriteiv.length);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
keyblock 

this.context.clientwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, 0, this.context.clientwriteiv, 0, this.context.clientwriteiv.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, this.ivsize, this.context.serverwriteiv, 0, this.context.serverwriteiv.length);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
clientwritekey 

this.context.clientwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, 0, this.context.clientwriteiv, 0, this.context.clientwriteiv.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, this.ivsize, this.context.serverwriteiv, 0, this.context.serverwriteiv.length);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
clientwriteiv 

this.context.clientwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, 0, this.context.clientwriteiv, 0, this.context.clientwriteiv.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, this.ivsize, this.context.serverwriteiv, 0, this.context.serverwriteiv.length);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
clientwritemac 

this.context.clientwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, 0, this.context.clientwriteiv, 0, this.context.clientwriteiv.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, this.ivsize, this.context.serverwriteiv, 0, this.context.serverwriteiv.length);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
serverwritekey 

this.context.clientwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, 0, this.context.clientwriteiv, 0, this.context.clientwriteiv.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, this.ivsize, this.context.serverwriteiv, 0, this.context.serverwriteiv.length);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
serverwriteiv 

this.context.clientwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, 0, this.context.clientwriteiv, 0, this.context.clientwriteiv.length);	this.context.serverwriteiv = new byte[this.ivsize];	buffer.blockcopy(ivblock, this.ivsize, this.context.serverwriteiv, 0, this.context.serverwriteiv.length);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	}	
serverwritemac 

========================= mono sample_31896 =========================

public override void foo () {	
hello world 

========================= mono sample_1688 =========================

static void encrypt () {	string ans = "green";	string key = "1e14fc86752772f5db58b99764d0168106d336563d77ccba";	string salt = "xxsrnq4n1jebmric/ty46g==";	byte[] key_bytes = getbytes (key, key.length);	byte[] ans_bytes = encoding.unicode.getbytes (ans);	byte[] salt_bytes = convert.frombase64string (salt);	byte[] buf = new byte[ans_bytes.length + salt_bytes.length];	array.copy (ans_bytes, 0, buf, salt_bytes.length, ans_bytes.length);	
before encryption 

========================= mono sample_18468 =========================

public static void main () {	int? dummy = null;	
hello 

========================= mono sample_2880 =========================

public static void main(string[] args) {	
calling printname 

public static void main(string[] args) {	mytestextended test = new mytestextended();	test.printname();	
out of printname 

========================= mono sample_34392 =========================

private static bool testmethod (out int test) {	try {	calldelegate (delegate {	return;	});	} catch (exception) {	
caught exception 

========================= mono sample_2412 =========================

static public void method (int nargs, string arg) {	int i;	
got single arg 

========================= mono sample_348 =========================

public static int main () {	del[] d = make2(10);	d[0](10);	if (v != 20) return 1;	d[1](11);	if (v != 31) return 2;	
ok 

========================= mono sample_1838 =========================

public static void main() {	
nodeinserted 

========================= mono sample_2692 =========================

methodinfo [] mi = typeof (d).getmethods (bindingflags.instance | bindingflags.nonpublic);	methodinfo m = null;	foreach (methodinfo j in mi){	if (j.name.indexof ("method") != -1){	m = j;	break;	}	}	if (m == null) return 1;	if (m.name != "a.b.method"){	
incorrect method name expecting got a b method 

========================= mono sample_1869 =========================

public static void main () {	
warning this test code is outdated use test system xml xmlconf exe instead 

public static void main () {	
started yyyy mm dd hh mm ss fff 

runinvalidtest ("xmltest", false);	runinvalidtest ("ibm", false);	runinvalidtest ("sun", true);	runvalidtest ("xmltest", false);	runvalidtest ("ibm", false);	runvalidtest ("sun", true);	runnotwellformedtest ("xmltest", false);	runnotwellformedtest ("ibm", false);	runnotwellformedtest ("sun", true);	runoasistest ();	
finished yyyy mm dd hh mm ss fff 

string basepath = @"xml-test-suite/xmlconf/" + subdir + @"/not-wf";	directoryinfo [] dirs = null;	if (issuntest) dirs =  new directoryinfo [] {new directoryinfo (basepath)};	else dirs = new directoryinfo (basepath).getdirectories ();	foreach (directoryinfo di in dirs) {	foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	while (!xtr.eof) xtr.read ();	
incorrectly wf 

if (issuntest) dirs =  new directoryinfo [] {new directoryinfo (basepath)};	else dirs = new directoryinfo (basepath).getdirectories ();	foreach (directoryinfo di in dirs) {	foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	while (!xtr.eof) xtr.read ();	} catch (xmlexception) {	} catch (exception ex) {	
unexpected error 

else dirs = new directoryinfo (basepath).getdirectories ();	foreach (directoryinfo di in dirs) {	foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	xtr.normalization = true;	xmlreader xr = new xmlvalidatingreader (xtr);	while (!xr.eof) xr.read ();	} catch (xmlexception ex) {	
incorrectly not wf 

foreach (directoryinfo di in dirs) {	foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	xtr.normalization = true;	xmlreader xr = new xmlvalidatingreader (xtr);	while (!xr.eof) xr.read ();	} catch (xmlexception ex) {	} catch (xmlschemaexception ex) {	
incorrectly invalid 

foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	xtr.normalization = true;	xmlreader xr = new xmlvalidatingreader (xtr);	while (!xr.eof) xr.read ();	} catch (xmlexception ex) {	} catch (xmlschemaexception ex) {	} catch (exception ex) {	
unexpected error 

if (issuntest) dirs =  new directoryinfo [] {new directoryinfo (basepath)};	else dirs = new directoryinfo (basepath).getdirectories ();	foreach (directoryinfo di in dirs) {	foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	xtr.normalization = true;	while (!xtr.eof) xtr.read ();	} catch (exception ex) {	
incorrectly not wf 

}	}	foreach (directoryinfo di in dirs) {	foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	xtr.normalization = true;	xmlvalidatingreader xr = new xmlvalidatingreader (xtr);	while (!xr.eof) xr.read ();	
incorrectly valid 

foreach (directoryinfo di in dirs) {	foreach (fileinfo fi in di.getfiles ("*.xml")) {	try {	xmltextreader xtr = new xmltextreader (fi.fullname);	xtr.namespaces = false;	xtr.normalization = true;	xmlvalidatingreader xr = new xmlvalidatingreader (xtr);	while (!xr.eof) xr.read ();	} catch (xmlschemaexception) {	} catch (exception ex) {	
unexpected error 

========================= mono sample_22406 =========================

static void metodo (exception e) {	if (e is notimplementedexception){	
ok 

static void metodo (exception e) {	if (e is notimplementedexception){	} else {	
fail 

========================= mono sample_2595 =========================

static void main () {	p.x = 10;	
got 

========================= mono sample_34184 =========================

public override t get<t>() {	t resp = base.get<t> ();	
t 

========================= mono sample_2655 =========================

public static void main () {	
foo 

========================= mono sample_33564 =========================

public static int main () {	int v;	
hello 

========================= mono sample_3958 =========================

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

private void checkrowversion(datarow dr) {	console.writeline("");	
has 

========================= mono sample_28636 =========================

public abstract t test<t> (t t, x x);	}	public class b : a<char> {	public override t test<t> (t t, char x) {	
b 

========================= mono sample_2228 =========================

t.start ();	}	for (int i = 0; i < 100; ++i) {	var ad = appdomain.createdomain ("domain_" + i);	ad.docallback (new crossappdomaindelegate (appdomainbackgroundnoise));	thread.sleep (10);	appdomain.unload (ad);	console.write (".");	if (i > 0 && i % 20 == 0) console.writeline ();	}	
done 

========================= mono sample_572 =========================

string expected = a.caught.stacktrace.tostring ();	for (int i = 0; i < 1000; ++i) {	thread t = new thread (delegate () {	tt ();	});	t.start ();	t.join ();	gc.collect ();	gc.waitforpendingfinalizers ();	if (a.caught.stacktrace != expected) {	
failed 

========================= mono sample_463 =========================

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
generic xml token 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
validfrom 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	
validto 

public override string tostring() {	stringwriter writer = new stringwriter(cultureinfo.invariantculture);	if (this.internaltokenreference != null) writer.writeline("   internaltokenreference: {0}", this.internaltokenreference);	if (this.externaltokenreference != null) writer.writeline("   externaltokenreference: {0}", this.externaltokenreference);	
token element 

========================= mono sample_5419 =========================

static void main (string [] args) {	thread.currentthread.currentuiculture = thread.currentthread.currentculture;	lib1.book book = new lib1.book ();	
book default name 

static void main (string [] args) {	thread.currentthread.currentuiculture = thread.currentthread.currentculture;	lib1.book book = new lib1.book ();	lib1.publisher publisher = new lib1.publisher ();	
publisher default name 

========================= mono sample_1150 =========================

public static int main () {	if ("hello" != a.hello.tostring ()) return 1;	
value is 

public static int main () {	if ("hello" != a.hello.tostring ()) return 1;	if (5.tostring () != "5") return 2;	y y = new y ();	if (y.value.tostring () != "3"){	string x = y.value.tostring ();	
got expected 

public static int main () {	if ("hello" != a.hello.tostring ()) return 1;	if (5.tostring () != "5") return 2;	y y = new y ();	if (y.value.tostring () != "3"){	string x = y.value.tostring ();	return 3;	}	
test ok 

========================= mono sample_3055 =========================

static void dostuff () {	
dostuff 

========================= mono sample_523 =========================

uni.buildtailoringtables (culture, t, ref contractions, ref level2maps);	unsafeflags = new byte [unsafeflaglength];	foreach (contraction c in contractions) {	if (c.source.length > 1) foreach (char ch in c.source) unsafeflags [(int) ch / 8 ]	|= (byte) (1 << ((int) ch & 7));	}	if (lcid != 127) foreach (contraction c in invariant.contractions) {	if (c.source.length > 1) foreach (char ch in c.source) unsafeflags [(int) ch / 8 ]	|= (byte) (1 << ((int) ch & 7));	}	
building table for contractions diacritical 

========================= mono sample_27878 =========================

reader = getreader (source, sname, usesourcepath);	dest = new filestream (dname, filemode.create, fileaccess.write);	writer = getwriter (dest, dname);	int rescount = 0;	foreach (dictionaryentry e in reader) {	rescount++;	object val = e.value;	if (val is string) writer.addresource ((string)e.key, (string)e.value);	else writer.addresource ((string)e.key, e.value);	}	
read in resources from 

writer = getwriter (dest, dname);	int rescount = 0;	foreach (dictionaryentry e in reader) {	rescount++;	object val = e.value;	if (val is string) writer.addresource ((string)e.key, (string)e.value);	else writer.addresource ((string)e.key, e.value);	}	reader.close ();	writer.close ();	
writing resource file done 

int rescount = 0;	foreach (dictionaryentry e in reader) {	rescount++;	object val = e.value;	if (val is string) writer.addresource ((string)e.key, (string)e.value);	else writer.addresource ((string)e.key, e.value);	}	reader.close ();	writer.close ();	} catch (exception e) {	
error 

object val = e.value;	if (val is string) writer.addresource ((string)e.key, (string)e.value);	else writer.addresource ((string)e.key, e.value);	}	reader.close ();	writer.close ();	} catch (exception e) {	exception inner = e.innerexception;	xmlexception xex = (inner as xmlexception);	if (xex != null) {	
position line column 

switch (args [i].tolower ()) {	case "-h": case "/h": case "-?": case "/?": usage ();	return 1;	case "/compile": case "-compile": if (inputfiles.count > 0) {	usage ();	return 1;	}	compilemultiple = true;	break;	case "/usesourcepath": case "-usesourcepath": if (compilemultiple) {	
resgen error invalid command line syntax switch bad value use resgen for usage information 

return 1;	}	resourceinfo resinf = new resourceinfo ();	if (compilemultiple) {	string [] pair = args [i].split (',');	switch (pair.length) {	case 1: resinf.inputfile = path.getfullpath (pair [0]);	resinf.outputfile = path.changeextension (resinf.inputfile, "resources");	break;	case 2: if (pair [1].length == 0) {	
error you must specify an input outfile file name like this 

return 1;	}	resourceinfo resinf = new resourceinfo ();	if (compilemultiple) {	string [] pair = args [i].split (',');	switch (pair.length) {	case 1: resinf.inputfile = path.getfullpath (pair [0]);	resinf.outputfile = path.changeextension (resinf.inputfile, "resources");	break;	case 2: if (pair [1].length == 0) {	
infile txt outfile resources 

return 1;	}	resourceinfo resinf = new resourceinfo ();	if (compilemultiple) {	string [] pair = args [i].split (',');	switch (pair.length) {	case 1: resinf.inputfile = path.getfullpath (pair [0]);	resinf.outputfile = path.changeextension (resinf.inputfile, "resources");	break;	case 2: if (pair [1].length == 0) {	
you passed in 

public void addresource (string name, string value) {	if (!headerwritten) {	headerwritten = true;	writeheader ();	}	
msgid 

public void addresource (string name, string value) {	if (!headerwritten) {	headerwritten = true;	writeheader ();	}	
msgstr 

========================= mono sample_802 =========================

public void test (t index) {	
test 

public void test (u index) {	
test 

========================= mono sample_35666 =========================

static void swap(ref weakreference refnmsp, object o) {	weakreference wref = refnmsp;	if (wref != null) {	
need this to make it pass 

========================= mono sample_490 =========================

public static int main (string[] args) {	float1 s1;	s1.f1 = 1;	s1 = mono_return_float1(s1, 906);	if (s1.f1 != 1+906) {	
got but expected 

s1.f1 = 1;	s1 = mono_return_float1(s1, 906);	if (s1.f1 != 1+906) {	return 1;	}	float2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_float2(s2, 906);	if (s2.f1 != 1+906) {	
got but expected 

return 1;	}	float2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_float2(s2, 906);	if (s2.f1 != 1+906) {	return 1;	}	if (s2.f2 != 2+906) {	
got but expected 

}	if (s2.f2 != 2+906) {	return 2;	}	float3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_float3(s3, 906);	if (s3.f1 != 1+906) {	
got but expected 

}	float3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_float3(s3, 906);	if (s3.f1 != 1+906) {	return 1;	}	if (s3.f2 != 2+906) {	
got but expected 

s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_float3(s3, 906);	if (s3.f1 != 1+906) {	return 1;	}	if (s3.f2 != 2+906) {	return 2;	}	if (s3.f3 != 3+906) {	
got but expected 

if (s3.f3 != 3+906) {	return 3;	}	float4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_float4(s4, 906);	if (s4.f1 != 1+906) {	
got but expected 

float4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_float4(s4, 906);	if (s4.f1 != 1+906) {	return 1;	}	if (s4.f2 != 2+906) {	
got but expected 

s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_float4(s4, 906);	if (s4.f1 != 1+906) {	return 1;	}	if (s4.f2 != 2+906) {	return 2;	}	if (s4.f3 != 3+906) {	
got but expected 

if (s4.f1 != 1+906) {	return 1;	}	if (s4.f2 != 2+906) {	return 2;	}	if (s4.f3 != 3+906) {	return 3;	}	if (s4.f4 != 4+906) {	
got but expected 

return 4;	}	float5 s5;	s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_float5(s5, 906);	if (s5.f1 != 1+906) {	
got but expected 

s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_float5(s5, 906);	if (s5.f1 != 1+906) {	return 1;	}	if (s5.f2 != 2+906) {	
got but expected 

s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_float5(s5, 906);	if (s5.f1 != 1+906) {	return 1;	}	if (s5.f2 != 2+906) {	return 2;	}	if (s5.f3 != 3+906) {	
got but expected 

if (s5.f1 != 1+906) {	return 1;	}	if (s5.f2 != 2+906) {	return 2;	}	if (s5.f3 != 3+906) {	return 3;	}	if (s5.f4 != 4+906) {	
got but expected 

if (s5.f2 != 2+906) {	return 2;	}	if (s5.f3 != 3+906) {	return 3;	}	if (s5.f4 != 4+906) {	return 4;	}	if (s5.f5 != 5+906) {	
got but expected 

}	float6 s6;	s6.f1 = 1;	s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_float6(s6, 906);	if (s6.f1 != 1+906) {	
got but expected 

s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_float6(s6, 906);	if (s6.f1 != 1+906) {	return 1;	}	if (s6.f2 != 2+906) {	
got but expected 

s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_float6(s6, 906);	if (s6.f1 != 1+906) {	return 1;	}	if (s6.f2 != 2+906) {	return 2;	}	if (s6.f3 != 3+906) {	
got but expected 

if (s6.f1 != 1+906) {	return 1;	}	if (s6.f2 != 2+906) {	return 2;	}	if (s6.f3 != 3+906) {	return 3;	}	if (s6.f4 != 4+906) {	
got but expected 

if (s6.f2 != 2+906) {	return 2;	}	if (s6.f3 != 3+906) {	return 3;	}	if (s6.f4 != 4+906) {	return 4;	}	if (s6.f5 != 5+906) {	
got but expected 

if (s6.f3 != 3+906) {	return 3;	}	if (s6.f4 != 4+906) {	return 4;	}	if (s6.f5 != 5+906) {	return 5;	}	if (s6.f6 != 6+906) {	
got but expected 

float7 s7;	s7.f1 = 1;	s7.f2 = 2;	s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_float7(s7, 906);	if (s7.f1 != 1+906) {	
got but expected 

s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_float7(s7, 906);	if (s7.f1 != 1+906) {	return 1;	}	if (s7.f2 != 2+906) {	
got but expected 

s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_float7(s7, 906);	if (s7.f1 != 1+906) {	return 1;	}	if (s7.f2 != 2+906) {	return 2;	}	if (s7.f3 != 3+906) {	
got but expected 

if (s7.f1 != 1+906) {	return 1;	}	if (s7.f2 != 2+906) {	return 2;	}	if (s7.f3 != 3+906) {	return 3;	}	if (s7.f4 != 4+906) {	
got but expected 

if (s7.f2 != 2+906) {	return 2;	}	if (s7.f3 != 3+906) {	return 3;	}	if (s7.f4 != 4+906) {	return 4;	}	if (s7.f5 != 5+906) {	
got but expected 

if (s7.f3 != 3+906) {	return 3;	}	if (s7.f4 != 4+906) {	return 4;	}	if (s7.f5 != 5+906) {	return 5;	}	if (s7.f6 != 6+906) {	
got but expected 

if (s7.f4 != 4+906) {	return 4;	}	if (s7.f5 != 5+906) {	return 5;	}	if (s7.f6 != 6+906) {	return 6;	}	if (s7.f7 != 7+906) {	
got but expected 

s8.f1 = 1;	s8.f2 = 2;	s8.f3 = 3;	s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_float8(s8, 906);	if (s8.f1 != 1+906) {	
got but expected 

s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_float8(s8, 906);	if (s8.f1 != 1+906) {	return 1;	}	if (s8.f2 != 2+906) {	
got but expected 

s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_float8(s8, 906);	if (s8.f1 != 1+906) {	return 1;	}	if (s8.f2 != 2+906) {	return 2;	}	if (s8.f3 != 3+906) {	
got but expected 

if (s8.f1 != 1+906) {	return 1;	}	if (s8.f2 != 2+906) {	return 2;	}	if (s8.f3 != 3+906) {	return 3;	}	if (s8.f4 != 4+906) {	
got but expected 

if (s8.f2 != 2+906) {	return 2;	}	if (s8.f3 != 3+906) {	return 3;	}	if (s8.f4 != 4+906) {	return 4;	}	if (s8.f5 != 5+906) {	
got but expected 

if (s8.f3 != 3+906) {	return 3;	}	if (s8.f4 != 4+906) {	return 4;	}	if (s8.f5 != 5+906) {	return 5;	}	if (s8.f6 != 6+906) {	
got but expected 

if (s8.f4 != 4+906) {	return 4;	}	if (s8.f5 != 5+906) {	return 5;	}	if (s8.f6 != 6+906) {	return 6;	}	if (s8.f7 != 7+906) {	
got but expected 

if (s8.f5 != 5+906) {	return 5;	}	if (s8.f6 != 6+906) {	return 6;	}	if (s8.f7 != 7+906) {	return 7;	}	if (s8.f8 != 8+906) {	
got but expected 

s9.f2 = 2;	s9.f3 = 3;	s9.f4 = 4;	s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_float9(s9, 906);	if (s9.f1 != 1+906) {	
got but expected 

s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_float9(s9, 906);	if (s9.f1 != 1+906) {	return 1;	}	if (s9.f2 != 2+906) {	
got but expected 

s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_float9(s9, 906);	if (s9.f1 != 1+906) {	return 1;	}	if (s9.f2 != 2+906) {	return 2;	}	if (s9.f3 != 3+906) {	
got but expected 

if (s9.f1 != 1+906) {	return 1;	}	if (s9.f2 != 2+906) {	return 2;	}	if (s9.f3 != 3+906) {	return 3;	}	if (s9.f4 != 4+906) {	
got but expected 

if (s9.f2 != 2+906) {	return 2;	}	if (s9.f3 != 3+906) {	return 3;	}	if (s9.f4 != 4+906) {	return 4;	}	if (s9.f5 != 5+906) {	
got but expected 

if (s9.f3 != 3+906) {	return 3;	}	if (s9.f4 != 4+906) {	return 4;	}	if (s9.f5 != 5+906) {	return 5;	}	if (s9.f6 != 6+906) {	
got but expected 

if (s9.f4 != 4+906) {	return 4;	}	if (s9.f5 != 5+906) {	return 5;	}	if (s9.f6 != 6+906) {	return 6;	}	if (s9.f7 != 7+906) {	
got but expected 

if (s9.f5 != 5+906) {	return 5;	}	if (s9.f6 != 6+906) {	return 6;	}	if (s9.f7 != 7+906) {	return 7;	}	if (s9.f8 != 8+906) {	
got but expected 

if (s9.f6 != 6+906) {	return 6;	}	if (s9.f7 != 7+906) {	return 7;	}	if (s9.f8 != 8+906) {	return 8;	}	if (s9.f9 != 9+906) {	
got but expected 

if (s9.f9 != 9+906) {	return 9;	}	float4_nested sn4;	sn4.nested1.f1 = 1;	sn4.f2 = 2;	sn4.f3 = 3;	sn4.nested2.f4 = 4;	sn4 = mono_return_float4_nested(sn4, 906);	if (sn4.nested1.f1 != 1+906) {	
nested got but expected 

float4_nested sn4;	sn4.nested1.f1 = 1;	sn4.f2 = 2;	sn4.f3 = 3;	sn4.nested2.f4 = 4;	sn4 = mono_return_float4_nested(sn4, 906);	if (sn4.nested1.f1 != 1+906) {	return 1;	}	if (sn4.f2 != 2+906) {	
nested got but expected 

sn4.f3 = 3;	sn4.nested2.f4 = 4;	sn4 = mono_return_float4_nested(sn4, 906);	if (sn4.nested1.f1 != 1+906) {	return 1;	}	if (sn4.f2 != 2+906) {	return 2;	}	if (sn4.f3 != 3+906) {	
nested got but expected 

if (sn4.nested1.f1 != 1+906) {	return 1;	}	if (sn4.f2 != 2+906) {	return 2;	}	if (sn4.f3 != 3+906) {	return 3;	}	if (sn4.nested2.f4 != 4+906) {	
nested got but expected 

========================= mono sample_701 =========================

public override bool tryreceiverequest (timespan timeout, out requestcontext context) {	try {	return tryreceiverequestcore (timeout, out context);	} catch (exception ex) {	
aspnetreplychannel caught an error 

========================= mono sample_32146 =========================

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
name lcid 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
displayname 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
englishname 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
nativename 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
threeletterisolanguagename 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
threeletterwindowslanguagename 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
twoletterisolanguagename 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	
calendar 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	
datetimeformat 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	
amdesignator 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	
calendarweekrule 

public static void main () {	var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	
dateseparator 

var all = cultureinfo.getcultures (culturetypes.specificcultures | culturetypes.neutralcultures).orderby (l => l.lcid);	console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	
firstdayofweek 

console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	
longdatepattern 

console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	
longtimepattern 

console.outputencoding = encoding.utf8;	var writer = console.out;	foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	
monthdaypattern 

foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	
nativecalendarname 

foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	
pmdesignator 

foreach (var c in all) {	if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	
shortdatepattern 

if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	
shorttimepattern 

if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	
timeseparator 

if (c.lcid == cultureinfo.invariantculture.lcid) continue;	var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	
yearmonthpattern 

var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	
textinfo 

var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	
ansicodepage 

var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	
ebcdiccodepage 

var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	
isrighttoleft 

var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	
listseparator 

var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	
maccodepage 

var df = c.datetimeformat;	dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	
oemcodepage 

dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	
numberformat 

dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	
currencydecimaldigits 

dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	
currencydecimalseparator 

dump (writer, df.abbreviateddaynames, "abbreviateddaynames");	dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	
currencygroupseparator 

dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	
currencynegativepattern 

dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	
currencypositivepattern 

dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	
currencysymbol 

dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	
digitsubstitution 

dump (writer, df.abbreviatedmonthgenitivenames, "abbreviatedmonthgenitivenames");	dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	
nansymbol 

dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	
negativeinfinitysymbol 

dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	
negativesign 

dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	
numberdecimaldigits 

dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	
numberdecimalseparator 

dump (writer, df.abbreviatedmonthnames, "abbreviatedmonthnames");	dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	
numbergroupseparator 

dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	
numbernegativepattern 

dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	
percentdecimaldigits 

dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	
percentdecimalseparator 

dump (writer, df.daynames, "daynames");	dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	
percentgroupseparator 

dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	
percentnegativepattern 

dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	
percentpositivepattern 

dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	
percentsymbol 

dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	
permillesymbol 

dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	
positiveinfinitysymbol 

dump (writer, df.getalldatetimepatterns (), "getalldatetimepatterns");	dump (writer, df.monthgenitivenames, "monthgenitivenames");	dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	
positivesign 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
regioninfo 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
currencyenglishname 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
currencynativename 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
currencysymbol 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
displayname 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
englishname 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
geoid 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
ismetric 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
isocurrencysymbol 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
name 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
nativename 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
threeletterisoregionname 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
threeletterwindowsregionname 

dump (writer, df.monthnames, "monthnames");	dump (writer, df.shortestdaynames, "shortestdaynames");	var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	
twoletterisoregionname 

var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	}	compareinfo ci = compareinfo.getcompareinfo (c.lcid);	
compareinfo 

var ti = c.textinfo;	var nf = c.numberformat;	dump (writer, nf.currencygroupsizes, "currencygroupsizes");	dump (writer, nf.nativedigits, "nativedigits");	dump (writer, nf.numbergroupsizes, "numbergroupsizes");	dump (writer, nf.percentgroupsizes, "percentgroupsizes");	if (!c.isneutralculture) {	var ri = new regioninfo (c.lcid);	}	compareinfo ci = compareinfo.getcompareinfo (c.lcid);	
name 

========================= mono sample_18 =========================

public override void beforeadding (ienumerable<xelement> list) {	first = true;	if (state.basetype == "system.enum") {	
div 

public override void beforeadding (ienumerable<xelement> list) {	first = true;	if (state.basetype == "system.enum") {	
p added value p s 

public override void beforeremoving (ienumerable<xelement> list) {	first = true;	if (state.basetype == "system.enum") {	
p removed value p s 

========================= mono sample_1323 =========================

return;	}	writer.writeline (resp);	writer.flush ();	str = reader.readline ();	if (str != "list") {	where = "list - '" + str + "'";	client.close ();	return;	}	
here comes the directory listing 

if (str != "list") {	where = "list - '" + str + "'";	client.close ();	return;	}	writer.flush ();	socket data_cnc = data.accept ();	byte [] dontcare = encoding.ascii.getbytes ("drwxr-xr-x    2 ftp      ftp          4096 oct 27 20:17 tests");	data_cnc.send (dontcare, 1, socketflags.none);	data_cnc.close ();	
directory send ok 

if (!doinitialdialog (writer, reader, "/home/someuser", "/home/someuser/")) {	client.close ();	return;	}	string str = reader.readline ();	if (str.trim () != "dele file.txt") {	where = "dele - " + str;	client.close ();	return;	}	
delete operation successful 

return;	}	writer.writeline (resp);	writer.flush ();	str = reader.readline ();	if (str != $"retr {filename}") {	where = $"retr - got: {str}, expected: retr {filename}";	client.close ();	return;	}	
opening binary mode data connection for blah n bytes 

if (str != $"retr {filename}") {	where = $"retr - got: {str}, expected: retr {filename}";	client.close ();	return;	}	writer.flush ();	socket data_cnc = data.accept ();	byte [] dontcare = new byte [1];	data_cnc.receive (dontcare, 1, socketflags.none);	data_cnc.close ();	
file send ok 

return;	}	writer.writeline (resp);	writer.flush ();	str = reader.readline ();	if (str != "stor file.txt") {	where = "stor - " + str;	client.close ();	return;	}	
ok to send data 

return;	}	writer.flush ();	socket data_cnc = data.accept ();	var datastr = new networkstream (data_cnc, false);	int ch;	while ((ch = datastr.readbyte ()) != -1){	result.add ((byte)ch);	}	data_cnc.close ();	
file received ok 

protected bool doinitialdialog (streamwriter writer, streamreader reader, string pwd, string cwd) {	string str = reader.readline ();	if (!str.startswith ("opts utf8 on")) {	where = "opts utf8 - " + str;	return false;	}	
always in mode 

where = "pwd - " + str;	return false;	}	writer.writeline ("257 \"{0}\"", pwd);	writer.flush ();	str = reader.readline ();	if (str != ("cwd " + cwd)) {	where = "cwd - " + str;	return false;	}	
directory changed 

if (str != ("cwd " + cwd)) {	where = "cwd - " + str;	return false;	}	writer.flush ();	str = reader.readline ();	if (str != ("type i")) {	where = "type - " + str;	return false;	}	
switching to binary mode 

protected bool endconversation (streamwriter writer, streamreader reader) {	string str = reader.readline ();	if (str != "quit") {	where = "quit";	return false;	}	
bye 

protected bool doanonymouslogin (streamwriter writer, streamreader reader) {	
welcome to the jungle 

protected bool doanonymouslogin (streamwriter writer, streamreader reader) {	writer.flush ();	string str = reader.readline ();	if (!str.startswith ("user ")) {	where = "user";	return false;	}	
say mellon 

if (!str.startswith ("user ")) {	where = "user";	return false;	}	writer.flush ();	str = reader.readline ();	if (!str.startswith ("pass ")) {	where = "pass";	return false;	}	
logged in 

========================= mono sample_23323 =========================

static object selectaggregate (idbconnection cnc, string agg) {	idbcommand selectcommand = cnc.createcommand();	object data;	
aggregate 

static object selectaggregate (idbconnection cnc, string agg) {	idbcommand selectcommand = cnc.createcommand();	object data;	selectcommand.commandtype = commandtype.text;	selectcommand.commandtext = "select " + agg + "from mono_sql_test";	data = selectcommand.executescalar ();	
agg result 

static void readresult(idatareader rdr, datatable dt) {	
total columns 

static void readresult(idatareader rdr, datatable dt) {	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	console.writeline();	}	int nrows = 0;	int c = 0;	string output, metadatavalue, datavalue;	
gonna do a read now 

static void readresult(idatareader rdr, datatable dt) {	foreach (datarow schemarow in dt.rows) {	foreach (datacolumn schemacol in dt.columns) console.writeline(schemacol.columnname + " = " + schemarow[schemacol]);	console.writeline();	}	int nrows = 0;	int c = 0;	string output, metadatavalue, datavalue;	while(rdr.read()) {	
row 

datarow dr = dt.rows[c];	metadatavalue = "    col " + c + ": " + dr["columnname"];	if (rdr.isdbnull(c) == true) datavalue = " is null";	else if ((type) dr["datatype"] == typeof (byte[])) datavalue = ": 0x" + bitconverter.tostring ((byte[]) rdr.getvalue (c)).replace ("-", "").tolower ();	else datavalue = ": " + rdr.getvalue(c);	output = metadatavalue + datavalue;	console.writeline(output);	}	nrows++;	}	
total rows retrieved 

static void readdata(idatareader rdr) {	int results = 0;	if(rdr == null) {	
idatareader has a null reference 

static void readdata(idatareader rdr) {	int results = 0;	if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	
result is from a sql command insert update delete records affected 

int results = 0;	if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if(dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	
result is from a select sql query records affected 

if(rdr == null) {	}	else {	do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if(dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	
result set 

do {	datatable dt = rdr.getschematable();	if(rdr.recordsaffected != -1) {	}	else if(dt == null) console.writeline("result is from a sql command not (insert,update,delete).   records affected: " + rdr.recordsaffected);	else {	results++;	readresult(rdr, dt);	}	} while(rdr.nextresult());	
total result sets 

static void dosqltest (idbconnection cnc) {	idatareader reader;	object odatavalue;	
sql provider specific tests 

static void dosqltest (idbconnection cnc) {	idatareader reader;	object odatavalue;	
drop table 

static void dosqltest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	
ok 

static void dosqltest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	
error don t worry about this one 

static void dosqltest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	
create table with all supported types 

static void dosqltest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	
ok 

static void dosqltest (idbconnection cnc) {	idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	
insert values for all known types 

idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	
ok 

idatareader reader;	object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	
update values 

object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	
ok 

object odatavalue;	try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	
insert values for all known types 

try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	
ok 

try {	droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	
insert values that require special coding 

droptable (cnc);	}	catch (sqlexception e) {	}	try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	insertedgecasedata (cnc);	
ok 

try {	createtable (cnc);	insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	insertedgecasedata (cnc);	selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	
select values from the database 

insertdata (cnc);	updatedata (cnc);	insertdata (cnc);	insertedgecasedata (cnc);	selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	
call executereader with a sql command not insert update delete 

insertdata (cnc);	insertedgecasedata (cnc);	selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	
call executereader with a sql command is insert update delete 

selectaggregate (cnc, "count(*)");	selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	
calling stored procedure sp server info 

selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
result 

selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
database server version 

selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
clean up 

selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
drop table 

selectaggregate (cnc, "min(varchar_value)");	selectaggregate (cnc, "max(int_value)");	selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	
ok 

selectaggregate (cnc, "sum(int_value)");	reader = selectdata (cnc);	readdata(reader);	reader = selectdatausingcommand(cnc);	readdata(reader);	reader = selectdatausinginsertcommand(cnc);	readdata(reader);	object obj = callstoredprocedure(cnc);	}	catch(exception e) {	
exception caught 

string connectionstring = "";	if(args.length == 3 || args.length == 4) {	if(args.length == 3) {	connectionstring = string.format( "server={0};" + "database={1};" + "user id={2};", args[0], args[1], args[2]);	}	else if(args.length == 4) {	connectionstring = string.format( "server={0};" + "database={1};" + "user id={2};" + "password={3}", args[0], args[1], args[2], args[3]);	}	}	else {	
usage mono sqltest exe sql server database user id password 

========================= mono sample_28414 =========================

public static void main (string[] args) {	
hello world 

========================= mono sample_1164 =========================

public int goo (bool hoo) {	bool local_hoo = hoo;	expression<func<bool>> a = () => hoo;	if (a.compile ()()) return 1;	if (true) {	expression<func<bool>> b = () => local_hoo;	if (b.compile ()()) return 2;	}	expression<func<int>> c = () => thismethod ();	if (c.compile ()() != 33) return 3;	
ok 

========================= mono sample_3061 =========================

private  void generatelinepragmaend(codelinepragma e) {	output.writeline();	
line default 

private  void generatelinepragmaend(codelinepragma e) {	output.writeline();	
line hidden 

outputparameters(e.parameters);	output.write("]");	}	else {	outputidentifier(e.name);	}	outputstartingbrace();	indent++;	if (e.hasget) {	if (iscurrentinterface || (e.attributes & memberattributes.scopemask) == memberattributes.abstract) {	
get 

private  void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	
output write 

private  void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	
output writeline sr getstring sr autogen comment 

private  void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.getstring(sr.autogen_comment_line3));	output.writeline(system.environment.version.tostring());	
output write 

private  void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.getstring(sr.autogen_comment_line3));	output.writeline(system.environment.version.tostring());	
output writeline sr getstring sr autogen comment 

private  void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.getstring(sr.autogen_comment_line3));	output.writeline(system.environment.version.tostring());	
output writeline sr getstring sr autogen comment 

private  void generatecompileunitstart(codecompileunit e) {	if (e.startdirectives.count > 0) {	generatedirectives(e.startdirectives);	}	output.write(" output.write(sr.getstring(sr.autogen_comment_line3));	output.writeline(system.environment.version.tostring());	
output writeline 

private void generatecoderegiondirective(coderegiondirective regiondirective) {	if (regiondirective.regionmode == coderegionmode.start) {	output.write("#region ");	output.writeline(regiondirective.regiontext);	}	else if (regiondirective.regionmode == coderegionmode.end) {	
endregion 

========================= mono sample_11794 =========================

static void main () {	
testing 

static void main () {	try {	s = new subclient ();	} catch {	
got it 

static void main () {	try {	s = new subclient ();	} catch {	}	
done 

========================= mono sample_517 =========================

private void print() {	
sqlstring 

========================= mono sample_14220 =========================

static int main () {	type t = typeof (t);	t obj = new t ();	methodbase m1;	
after ctor a is 

static int main () {	type t = typeof (t);	t obj = new t ();	methodbase m1;	
after ctor v is 

static int main () {	type t = typeof (t);	t obj = new t ();	methodbase m1;	obj.a = 2;	obj.v = 5;	
a is 

static int main () {	type t = typeof (t);	t obj = new t ();	methodbase m1;	obj.a = 2;	obj.v = 5;	
v is 

static int main () {	type t = typeof (t);	t obj = new t ();	methodbase m1;	obj.a = 2;	obj.v = 5;	m1 = t.getconstructor (type.emptytypes);	m1.invoke (obj, null);	
after reinit a is 

static int main () {	type t = typeof (t);	t obj = new t ();	methodbase m1;	obj.a = 2;	obj.v = 5;	m1 = t.getconstructor (type.emptytypes);	m1.invoke (obj, null);	
after reinit v is 

========================= mono sample_406 =========================

public override void modified (xelement source, xelement target, apichanges diff) {	sourceassembly = source.getattribute ("name");	targetassembly = target.getattribute ("name");	var sb = source.getattribute ("version");	var tb = target.getattribute ("version");	if (sb != tb) {	
assembly version changed vs 

========================= mono sample_1317 =========================

static void main(string[] args) {	string programfiles = environment.getfolderpath(environment.specialfolder.programfiles);	string databasepath = path.combine(programfiles, string connstr = string.format("server={0};database={1};user={2};password={3}", "localhost", databasepath, "sysdba", "masterkey");	northwind db = new northwind(new fbconnection(connstr));	var x = db.orderdetails.first();	objectdumper.write(x);	console.clear();	
from p in db products orderby p productname select p 

static void main(string[] args) {	string programfiles = environment.getfolderpath(environment.specialfolder.programfiles);	string databasepath = path.combine(programfiles, string connstr = string.format("server={0};database={1};user={2};password={3}", "localhost", databasepath, "sysdba", "masterkey");	northwind db = new northwind(new fbconnection(connstr));	var x = db.orderdetails.first();	objectdumper.write(x);	console.clear();	var q2 = from p in db.products orderby p.productname select p;	foreach (var v in q2) objectdumper.write(v);	
press enter to continue 

northwind db = new northwind(new fbconnection(connstr));	var x = db.orderdetails.first();	objectdumper.write(x);	console.clear();	var q2 = from p in db.products orderby p.productname select p;	foreach (var v in q2) objectdumper.write(v);	console.readkey();	console.clear();	var q3 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q3) objectdumper.write(v);	
press enter to continue 

foreach (var v in q2) objectdumper.write(v);	console.readkey();	console.clear();	var q3 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q3) objectdumper.write(v);	console.readkey();	console.clear();	console.writeline("from p in db.products where p.productid == 7 select p;");	var q4 = from p in db.products where p.productid == 7 select p;	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.readkey();	console.clear();	console.writeline("from p in db.products where p.productid == 7 select p;");	var q4 = from p in db.products where p.productid == 7 select p;	foreach (var v in q4) objectdumper.write(v);	console.readkey();	console.clear();	console.writeline("from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.readkey();	console.clear();	console.writeline("from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readkey();	console.clear();	console.writeline("from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	
press enter to continue 

console.writeline("from c in db.customers from o in c.orders where c.city == \"london\" select new { c, o };");	var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readkey();	console.clear();	console.writeline("from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readkey();	console.clear();	
db orders 

var q5 = from c in db.customers from o in c.orders where c.city == "london" select new { c, o };	foreach (var v in q4) objectdumper.write(v);	console.readkey();	console.clear();	console.writeline("from o in db.orders where o.customer.city == \"london\" select new { c = o.customer, o };");	var q6 = from o in db.orders where o.customer.city == "london" select new { c = o.customer, o };	foreach (var v in q4) objectdumper.write(v);	console.readkey();	console.clear();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

foreach (var v in db.orders) objectdumper.write(v);	console.readkey();	console.clear();	console.writeline("db.orders.add(new order { productid = 7, customerid = 1, orderdate = datetime.now });");	db.orders.insertonsubmit(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	console.writeline("db.orders.add(new order { productid = 2, customerid = 2, orderdate = datetime.now });");	db.orders.insertonsubmit(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

console.clear();	console.writeline("db.orders.add(new order { productid = 7, customerid = 1, orderdate = datetime.now });");	db.orders.insertonsubmit(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	console.writeline("db.orders.add(new order { productid = 2, customerid = 2, orderdate = datetime.now });");	db.orders.insertonsubmit(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	console.readkey();	console.clear();	
db orders remove db orders first 

console.writeline("db.orders.add(new order { productid = 2, customerid = 2, orderdate = datetime.now });");	db.orders.insertonsubmit(new order { employeeid = 1, customerid = "alfki", orderdate = datetime.now });	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	console.readkey();	console.clear();	var order = db.orders.first();	db.orders.deleteonsubmit(order);	db.submitchanges();	foreach (var v in db.orders) objectdumper.write(v);	
press enter to continue 

========================= mono sample_24577 =========================

static void showhelpforassembly (string assembly) {	
help for assembly not implemented 

static void showhelp () {	
installutil installs assemblies that use system configuration install 

static void showhelp () {	
usage is installutil commands 

static void call (installer instance, string method, object arg) {	
m 

========================= mono sample_1206 =========================

public static int main () {	string [] s = typeof (c).assembly.getmanifestresourcenames ();	if (s [0] != "test-465.cs") return 1;	if (typeof (c).assembly.getmanifestresourcestream ("test-465.cs") == null) return 2;	
ok 

========================= mono sample_3303 =========================

public void testgrandchild() {	
call from inside grandchild 

public static int main(string[] args) {	try {	callfrominsidegrandchild();	
test success 

public static int main(string[] args) {	try {	callfrominsidegrandchild();	return 100;	}	catch (exception ex) {	console.writeline(ex);	
test failed 

========================= mono sample_735 =========================

public static void test () {	
x 

========================= mono sample_725 =========================

public static void main (string [] args) {	try {	run (args);	} catch (exception ex) {	
error 

static void run (string [] args) {	if (args.length < 1) {	
usage mono exe instance xmlfile output xsdfile 

========================= mono sample_1216 =========================

static int main (string [] args) {	if (args.length != 2) {	
usage mono mono api diff exe assembly xml assembly xml 

static xmlassembly createxmlassembly (string file) {	xmldocument doc = new xmldocument ();	doc.load (file.openread (file));	xmlnode node = doc.selectsinglenode ("/assemblies/assembly");	xmlassembly result = new xmlassembly ();	try {	result.loaddata (node);	} catch (exception e) {	
error loading 

public override string tostring () {	stringwriter sw = new stringwriter ();	
present 

public override string tostring () {	stringwriter sw = new stringwriter ();	
presenttotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
missing 

public override string tostring () {	stringwriter sw = new stringwriter ();	
missingtotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
todo 

public override string tostring () {	stringwriter sw = new stringwriter ();	
todototal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
extra 

public override string tostring () {	stringwriter sw = new stringwriter ();	
extratotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
warning 

public override string tostring () {	stringwriter sw = new stringwriter ();	
warningtotal 

public override string tostring () {	stringwriter sw = new stringwriter ();	
errortotal 

if (node == null) throw new argumentnullexception ("node");	name = node.attributes ["name"].value;	version = node.attributes  ["version"].value;	xmlnode atts = node.firstchild;	attributes = new xmlattributes ();	if (atts.name == "attributes") {	attributes.loaddata (atts);	atts = atts.nextsibling;	}	if (atts == null || atts.name != "namespaces") {	
warning no namespaces found 

public override void loaddata (xmlnode node) {	if (node == null) throw new argumentnullexception ("node");	if (node.name != "namespace") throw new formatexception ("expecting <namespace>");	name = node.attributes  ["name"].value;	xmlnode classes = node.firstchild;	if (classes == null) {	
warning no classes for name 

if (child != null && child.name == "methods") {	methods = new xmlmethods ();	methods.loaddata (child);	child = child.nextsibling;	}	if (child != null && child.name == "generic-parameters") {	return;	}	if (child == null) return;	if (child.name != "classes") {	
name type 

========================= mono sample_1307 =========================

public virtual void onevent () {	
onevent error 

public override void onevent () {	
onevent 

public void onevent () {	
nonvirtualdelegate onevent 

========================= mono sample_634 =========================

public static void main (string [] args) {	if (args.length == 2) {	string [] tmp = new string [4];	tmp [0] = args [0] + "-utf8.txt";	tmp [1] = "65001";	tmp [2] = args [1];	tmp [3] = args [0] + "-" + args [1] + ".txt";	args = tmp;	}	if (args.length < 4) {	
pass input file input encoding output encoding output file 

s = sr.readtoend ();	}	using (streamwriter sw = new streamwriter (args [3], false, encoding.getencoding (int.parse (args [2])))) {	sw.write (s);	}	string s2;	using (streamreader sr = new streamreader (args [3], encoding.getencoding (int.parse (args [2])))) {	s2 = sr.readtoend ();	}	if (s != s2) {	
failure 

========================= mono sample_30214 =========================

public static void main (string [] args) {	if (args.length == 2) {	string [] tmp = new string [4];	tmp [0] = args [0] + "-utf8.txt";	tmp [1] = "65001";	tmp [2] = args [1];	tmp [3] = args [0] + "-" + args [1] + ".txt";	args = tmp;	}	if (args.length < 4) {	
pass input file input encoding output encoding output file 

s = sr.readtoend ();	}	using (streamwriter sw = new streamwriter (args [3], false, encoding.getencoding (args [2]))) {	sw.write (s);	}	string s2;	using (streamreader sr = new streamreader (args [3], encoding.getencoding (args [2]))) {	s2 = sr.readtoend ();	}	if (s != s2) {	
failure 

========================= mono sample_30185 =========================

static int main () {	parameterinfo [] pi = typeof (x).getmethod ("takesint").getparameters ();	
and 

========================= mono sample_416 =========================

private static void processfile(string file) {	string codetext;	using (var textstream = file.opentext(file)) {	codetext = textstream.readtoend();	}	if (istest(codetext)) {	
processing 

========================= mono sample_24605 =========================

static extern void mono_test_native_to_managed_exception_rethrow (action action);	[dllimport ("libc")]	static extern void _exit (int exitcode);	static int main (string[] args) {	appdomain.currentdomain.unhandledexception += (sender, exception_args) => {	customexception exc = exception_args.exceptionobject as customexception;	if (exc == null) {	
failed unknown exception exception args exceptionobject 

[dllimport ("libc")]	static extern void _exit (int exitcode);	static int main (string[] args) {	appdomain.currentdomain.unhandledexception += (sender, exception_args) => {	customexception exc = exception_args.exceptionobject as customexception;	if (exc == null) {	_exit (1);	}	console.writeline (exc.stacktrace);	if (string.isnullorempty (exc.stacktrace)) {	
failed stacktrace is null for unhandled exception 

static int main (string[] args) {	appdomain.currentdomain.unhandledexception += (sender, exception_args) => {	customexception exc = exception_args.exceptionobject as customexception;	if (exc == null) {	_exit (1);	}	console.writeline (exc.stacktrace);	if (string.isnullorempty (exc.stacktrace)) {	_exit (2);	} else {	
success stacktrace is not null for unhandled exception 

_exit (1);	}	console.writeline (exc.stacktrace);	if (string.isnullorempty (exc.stacktrace)) {	_exit (2);	} else {	_exit (0);	}	};	mono_test_native_to_managed_exception_rethrow (captureandthrow);	
should have exited in the unhandledexception event handler 

========================= mono sample_447 =========================

if (ipk < 0) {	writeerrorline("database connection '{0}' doesn't support querying primary key information.", db.gettype().name);	}	var columns = new list<idatatablecolumn>();	foreach (datarow c in dbcolumns.rows) {	var sqltype     = c[isqltype].tostring().trim();	var tablename   = unquotesqlname(getvalue<string>(c, itable, null));	var tableschema = unquotesqlname(getvalue<string>(c, ischema, null));	var columnname  = unquotesqlname(getvalue<string>(c, icolumn, null));	if (sqltype.length == 0) {	
warning the column could not be imported because the column s data type is empty 

========================= mono sample_24957 =========================

public static int main () {	value val;	arrowtype i = (arrowtype)val.val2;	if ((arrowtype)(enum)val.val != arrowtype.left) return 1;	
ok 

========================= mono sample_3131 =========================

public void addresource (string name, string value) {	if (!headerwritten) {	headerwritten = true;	writeheader ();	}	
msgid 

public void addresource (string name, string value) {	if (!headerwritten) {	headerwritten = true;	writeheader ();	}	
msgstr 

========================= mono sample_22189 =========================

static private void help () {	
usage crlupdate m v f 

static private void help () {	console.writeline ();	
m use the machine certificate store default to user 

static private void help () {	console.writeline ();	
v verbose mode display status for every steps 

static private void help () {	console.writeline ();	
f force download and replace existing crl 

static private void help () {	console.writeline ();	
display this help message 

static void download (string url, x509store store) {	
downloading 

static void download (string url, x509store store) {	webclient wc = new webclient ();	string error = "download";	try {	byte [] data = wc.downloaddata (url);	error = "decode";	x509crl crl = new x509crl (data);	error = "import";	
warning crl is not current 

static void download (string url, x509store store) {	webclient wc = new webclient ();	string error = "download";	try {	byte [] data = wc.downloaddata (url);	error = "decode";	x509crl crl = new x509crl (data);	error = "import";	if (verifycrl (crl)) store.import (crl);	
error could not validate crl 

webclient wc = new webclient ();	string error = "download";	try {	byte [] data = wc.downloaddata (url);	error = "decode";	x509crl crl = new x509crl (data);	error = "import";	if (verifycrl (crl)) store.import (crl);	}	catch (exception e) {	
error could not 

static void updatestore (x509store store) {	foreach (x509certificate cert in store.certificates) {	x509crl crl = force ? null : findcrl (cert, store);	if ((crl == null) || !crl.iscurrent) {	x509extension ext = cert.extensions ["2.5.29.31"];	if (ext == null) {	
warning no crl distribution point found for 

x509crl crl = force ? null : findcrl (cert, store);	if ((crl == null) || !crl.iscurrent) {	x509extension ext = cert.extensions ["2.5.29.31"];	if (ext == null) {	continue;	}	crldistributionpointsextension crldp = new crldistributionpointsextension (ext);	foreach (var dp in crldp.distributionpoints) {	string name = dp.name.trim ();	if (name.startswith ("url=")) download (name.substring (4), store);	
warning unsupported distribution point 

}	try {	x509stores stores = ((machine) ? x509storemanager.localmachine : x509storemanager.currentuser);	updatestore (stores.trustedroot);	updatestore (stores.intermediateca);	updatestore (stores.personal);	updatestore (stores.otherpeople);	return 0;	}	catch (exception e) {	
error unexpected exception 

========================= mono sample_1174 =========================

public midclass () {	
created mid in 

public void midmethod (object leaf) {	
called midmethod in 

public void midmethod (object leaf) {	var ad = appdomain.currentdomain;	
domain has loaded 

public void midmethod (object leaf) {	var ad = appdomain.currentdomain;	foreach (var assm in ad.getassemblies ()) {	console.writeline (" - {0}", assm);	
with location 

public void forceloadfrom (string assmpath) {	
loading from assmpath into appdomain currentdomain 

========================= mono sample_696 =========================

public static int main () {	appdomain.currentdomain.unhandledexception += (sender, args) => {	
caught 

========================= mono sample_600 =========================

public override imessage invoke (imessage request) {	imethodcallmessage call = (imethodcallmessage)request;	
invoke 

========================= mono sample_591 =========================

odbcconnection dbcon = new odbcconnection();	dbcon.connectionstring = "dsn=localserver;uid=sa;pwd=";	dbcon.open();	odbccommand dbcmd = new odbccommand();	dbcmd.connection = dbcon;	dbcmd.commandtype = commandtype.text;	dbcmd.commandtext = "select lname from employee";	odbcdatareader reader;	reader = (odbcdatareader) dbcmd.executereader();	while(reader.read()) {	
last name 

========================= mono sample_28404 =========================

static void usage () {	
usage is mono service d directory l lockfile n name m logname service exe 

========================= mono sample_1273 =========================

public void prettyprintshutdownreport() {	if (shutdownreport.count == 0) {	
no errors reported when closing connection 

public void prettyprintshutdownreport() {	if (shutdownreport.count == 0) {	} else {	
log of errors while closing connection 

========================= mono sample_18120 =========================

public static int main () {	int[] int_array = new int [] { 0, 1 };	ienumerable<int> e;	e = from int i in int_array where i > 0 select i;	if (e.tolist ()[0] != 1) return 1;	e = from int i in int_array where i == 0 select i + 1;	if (e.tolist ()[0] != 1) return 2;	
ok 

========================= mono sample_3236 =========================

public static void c(int i) {	
in c 

public static void c(int i) {	if (i==0) {	
in c 

========================= mono sample_740 =========================

if (assemblies.containskey (mvid)) return assemblies[mvid];	var mviddir = path.combine (msymdir, mvid);	if (!directory.exists (mviddir)) {	logger.logwarning ("mvid directory does not exist: {0}", mviddir);	return  null;	}	string assemblypath = null;	var exefiles = directory.getfiles (mviddir, "*.exe");	var dllfiles = directory.getfiles (mviddir, "*.dll");	if (exefiles.length + dllfiles.length != 1) {	
mvid directory should include one assembly 

private seqpointinfo getorcreateseqpointinfo (string aotid) {	if (seqpointinfos.containskey (aotid)) return seqpointinfos[aotid];	var aotiddir = path.combine (msymdir, aotid);	if (!directory.exists (aotiddir)) {	
aotid directory does not exist 

========================= mono sample_1222 =========================

public static int main () {	bar bar = new bar ();	if (bar.message != "bar") return 1;	foo foo = new foo ();	if (foo.message != "foo") return 2;	c c = new c ();	c.get_value ();	c.add_arg (false);	
test ok 

========================= mono sample_1362 =========================

listensocket.receive (new byte [0]);	listensocket.shutdown (socketshutdown.send);	listensocket.shutdown (socketshutdown.receive);	} catch {	}	} catch (socketexception ex) {	if (ex.errorcode != socket_closed && ex.errorcode != socket_invalid_args && !disposed) throw;	} catch (objectdisposedexception ex) {	if (!disposed) throw;	#if mobile } catch (invalidoperationexception ex) {	
socketresponder listen failed 

========================= mono sample_26895 =========================

static int main () {	int size = marshal.sizeof(typeof(teststructure));	
size of t 

static int main () {	int size = marshal.sizeof(typeof(teststructure));	if (size != 1032) return 1;	size = marshal.sizeof(typeof(teststructure2));	
size of 

========================= mono sample_480 =========================

static void main (string[] args) {	var failcount = 0;	
correct case 

static void main (string[] args) {	var failcount = 0;	try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	
access friend internal method ok 

static void main (string[] args) {	var failcount = 0;	try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	
access friend internal method fail 

static void main (string[] args) {	var failcount = 0;	try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	
access internal class internal ctor ok 

try {	var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	
access friend internal ctor fail 

var a = new correctcasefriendassembly.publicclass ();	a.internalmethod ();	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	
wrong case 

} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	
access internal class internal ctor ok 

}	try {	var a = new correctcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	
access friend internal ctor fail 

} catch (memberaccessexception) {	failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	
access friend private static method ok 

failcount += 1;	}	try {	var a = new wrongcasefriendassembly.internalclass(@internal: 0);	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	} catch (memberaccessexception) {	
access friend private static method fail 

} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	
access friend internal static method ok 

}	try {	wrongcasefriendassembly.internalclass.privatestaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	
access friend internal static method fail 

} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.publicclass.internalstaticmethod();	
access public internal static method ok 

}	try {	wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.publicclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	
access public internal static method fail 

wrongcasefriendassembly.internalclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	try {	wrongcasefriendassembly.publicclass.internalstaticmethod();	} catch (memberaccessexception) {	failcount += 1;	}	if (system.diagnostics.debugger.isattached) console.readline();	
incorrect results 

========================= mono sample_533 =========================

static void p (dt dt) {	
true 

static void p (df df) {	
false 

========================= mono sample_3105 =========================

bool ok = directory.exists(mysqlexampledir);	string args1 = string.format(" -provider=mysql -namespace:nwind -code:northwind_temp.cs -sprocs {0}/northwind_from_mysql.dbml" , mysqlexampledir);	processrunner p1 = new processrunner();	int sqlmetalexitcode = p1.run(sqlmetal, args1, 5000);	assert.istrue(sqlmetalexitcode == 0, "got sqlmetal.exe error exit code " + sqlmetalexitcode);	directory.setcurrentdirectory("..");	string dependencies = @"/r:bin\nunit.framework.dll /r:bin\dblinq.dll /r:bin\dblinq.mysql.dll /r:bin\mysql.data.dll";	string cscargs = @"/nologo /target:library /d:mysql /out:bin/sqlmetal_test.dll  bin/northwind_temp.cs  readtest.cs  writetest.cs  testbase.cs  " + dependencies;	processrunner p2 = new processrunner();	int cscexitcode = p2.run(cscexe, cscargs, 5000);	
csc exitcode output 

========================= mono sample_24660 =========================

public delegate int testdel (int a);	public static void main (string[] args) {	dictionary<string, testdel> dict = new dictionary<string, testdel> ();	dict["a"] = delegate (int b) {	return b;	};	
a 

========================= mono sample_3014 =========================

public bool loadexternalprovider (string strproviderassembly, string providerconnectionclass) {	try {	
loading external provider 

public bool loadexternalprovider (string strproviderassembly, string providerconnectionclass) {	try {	providerassembly = null;	providerassembly = assembly.load (strproviderassembly);	type typ = providerassembly.gettype (providerconnectionclass);	conn = (idbconnection) activator.createinstance (typ);	
external provider loaded 

datavalue = obj.tostring();	}	strhtml.append("\t\t\t<td>");	strhtml.append(datavalue);	strhtml.append("</td>\n");	}	strhtml.append("\t\t</tr>\n");	outputfilestream.writeline(strhtml.tostring());	strhtml = null;	}	
table body html 

========================= mono sample_1280 =========================

public virtual void mymethod () {	
this is me 

========================= mono sample_35897 =========================

public void setthread () {	
setting thread 

public void setstr (string s) {	
setting str 

public static int main (string [] args) {	appdomain domain = appdomain.createdomain ("newdomain");	test mytest = new test ();	test othertest = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	othertest.callsetthread (mytest);	if (mytest.thread.gettype () == thread.currentthread.gettype ()) console.writeline ("same type");	else {	
different type 

test mytest = new test ();	test othertest = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	othertest.callsetthread (mytest);	if (mytest.thread.gettype () == thread.currentthread.gettype ()) console.writeline ("same type");	else {	return 1;	}	appdomain.unload (domain);	gc.collect ();	gc.waitforpendingfinalizers ();	
thread 

test mytest = new test ();	test othertest = (test) domain.createinstanceandunwrap (typeof (test).assembly.fullname, typeof (test).fullname);	othertest.callsetthread (mytest);	if (mytest.thread.gettype () == thread.currentthread.gettype ()) console.writeline ("same type");	else {	return 1;	}	appdomain.unload (domain);	gc.collect ();	gc.waitforpendingfinalizers ();	
str 

========================= mono sample_422 =========================

public static int main () {	int result = test ();	
result 

========================= mono sample_3948 =========================

public void callcontextpropagation_taskcontinuation () {	string d1 = null;	string d2 = null;	
current thread 

========================= mono sample_27165 =========================

public override void computemastersecret(byte[] premastersecret) {	tlsstream mastersecret = new tlsstream();	mastersecret.write(this.prf(premastersecret, "a", this.context.randomcs));	mastersecret.write(this.prf(premastersecret, "bb", this.context.randomcs));	mastersecret.write(this.prf(premastersecret, "ccc", this.context.randomcs));	this.context.mastersecret = mastersecret.toarray();	
mastersecret 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
keyblock 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
clientwritekey 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
clientwriteiv 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
clientwritemac 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
serverwritekey 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
serverwriteiv 

this.context.clientwritekey = keyblock.readbytes(this.keymaterialsize);	this.context.serverwritekey = keyblock.readbytes(this.keymaterialsize);	if (this.ivsize != 0) {	this.context.clientwriteiv = keyblock.readbytes(this.ivsize);	this.context.serverwriteiv = keyblock.readbytes(this.ivsize);	}	else {	this.context.clientwriteiv = ciphersuite.emptyarray;	this.context.serverwriteiv = ciphersuite.emptyarray;	}	
serverwritemac 

========================= mono sample_20705 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	task t = test.invoke (new tester (), null) as task;	try {	if (!task.waitall (new[] { t }, 1000)) {	
failed timeout 

if (!task.waitall (new[] { t }, 1000)) {	return false;	}	} catch (aggregateexception) {	}	if (t.status != taskstatus.faulted) {	console.writeline ("failed (status={0})", t.status);	return false;	}	if (!(t.exception.innerexception is applicationexception)) {	
failed with wrong exception 

}	} catch (aggregateexception) {	}	if (t.status != taskstatus.faulted) {	console.writeline ("failed (status={0})", t.status);	return false;	}	if (!(t.exception.innerexception is applicationexception)) {	return false;	}	
ok 

}	if (t.status != taskstatus.faulted) {	console.writeline ("failed (status={0})", t.status);	return false;	}	if (!(t.exception.innerexception is applicationexception)) {	return false;	}	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_3438 =========================

try {	t.start ();	return 1;	} catch (invalidoperationexception) {	}	try {	t.runsynchronously ();	return 2;	} catch (invalidoperationexception) {	}	
ok 

========================= mono sample_3578 =========================

public static void usage (string message) {	
tlstest copyright c novell 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
usage 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
tlstest protocol class credentials x x time show url 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
protocol only applicable when using stream 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
any negotiate protocol default 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
ssl use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
tls use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
use 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
credentials 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
basic username password domain basic authentication 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
digest username password domain digest authentication 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
options 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
x x client certificate multiple entries allowed 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
time show the time required for each page load 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
show show the web page content on screen 

public static void usage (string message) {	if (message != null) {	console.writeline ("{0}{1}{0}", environment.newline, message);	}	
url one or more url to download 

}	int loop = 1;	if (readloop || writeloop) {	loop = int32.maxvalue;	}	if (urls.count == 0) {	usage ("no url were specified");	return;	}	for (int i = 0; i < loop; i++) {	
loop 

iphostentry host = dns.resolve (uri.host);	ipaddress ip = host.addresslist [0];	socket socket = new socket (ip.addressfamily, sockettype.stream, protocoltype.tcp);	socket.connect (new ipendpoint (ip, uri.port));	ns = new controllednetworkstream (socket, false);	ns.maximumread = (readloop) ? i : read;	ns.maximumwrite = (writeloop) ? i : write;	sslclientstream ssl = new sslclientstream (ns, uri.host, false, protocol);	ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	streamwriter sw = new streamwriter (ssl);	
get 

ns.maximumwrite = (writeloop) ? i : write;	sslclientstream ssl = new sslclientstream (ns, uri.host, false, protocol);	ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	streamwriter sw = new streamwriter (ssl);	sw.flush ();	streamreader sr = new streamreader (ssl, encoding.utf8);	content = sr.readtoend ();	}	catch (exception e) {	propertyinfo pi = e.gettype ().getproperty ("hresult", bindingflags.nonpublic | bindingflags.getproperty | bindingflags.instance);	
failed 

ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	streamwriter sw = new streamwriter (ssl);	sw.flush ();	streamreader sr = new streamreader (ssl, encoding.utf8);	content = sr.readtoend ();	}	catch (exception e) {	propertyinfo pi = e.gettype ().getproperty ("hresult", bindingflags.nonpublic | bindingflags.getproperty | bindingflags.instance);	console.writeline (e.tostring ());	if (ns != null) {	
bytes read 

ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	streamwriter sw = new streamwriter (ssl);	sw.flush ();	streamreader sr = new streamreader (ssl, encoding.utf8);	content = sr.readtoend ();	}	catch (exception e) {	propertyinfo pi = e.gettype ().getproperty ("hresult", bindingflags.nonpublic | bindingflags.getproperty | bindingflags.instance);	console.writeline (e.tostring ());	if (ns != null) {	
max read 

ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	streamwriter sw = new streamwriter (ssl);	sw.flush ();	streamreader sr = new streamreader (ssl, encoding.utf8);	content = sr.readtoend ();	}	catch (exception e) {	propertyinfo pi = e.gettype ().getproperty ("hresult", bindingflags.nonpublic | bindingflags.getproperty | bindingflags.instance);	console.writeline (e.tostring ());	if (ns != null) {	
bytes write 

ssl.servercertvalidationdelegate += new certificatevalidationcallback (certificatevalidation);	streamwriter sw = new streamwriter (ssl);	sw.flush ();	streamreader sr = new streamreader (ssl, encoding.utf8);	content = sr.readtoend ();	}	catch (exception e) {	propertyinfo pi = e.gettype ().getproperty ("hresult", bindingflags.nonpublic | bindingflags.getproperty | bindingflags.instance);	console.writeline (e.tostring ());	if (ns != null) {	
max write 

propertyinfo pi = e.gettype ().getproperty ("hresult", bindingflags.nonpublic | bindingflags.getproperty | bindingflags.instance);	console.writeline (e.tostring ());	if (ns != null) {	}	}	timespan ts = (datetime.now - start);	if ((show) && (content != null)) {	console.writeline ("{0}{1}{0}", environment.newline, content);	}	if (time) {	
time 

break;	case -2146762495: message = "cert_e_expired 0x800b0101";	break;	case -2146762486: message = "cert_e_chaining 0x800b010a";	break;	case -2146762487: message = "cert_e_untrustedroot 0x800b0109";	break;	default: message = "unknown (try winerror.h)";	break;	}	
error 

private static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	if (certificateerrors.length > 0) {	console.writeline (certificate.tostring (true));	
valid from 

private static bool certificatevalidation (x509certificate certificate, int[] certificateerrors) {	if (certificateerrors.length > 0) {	console.writeline (certificate.tostring (true));	
valid until 

========================= mono sample_20585 =========================

callseq.add ("<< creating two client items");	callseq.add (">> adding items");	list.add (item3);	list.add (item4);	callseq.add ("<< adding items");	callseq.add (">> processing items");	list.processitems ();	callseq.add ("<< processing items");	}	catch (exception ex) {	
err 

========================= mono sample_17882 =========================

private void read(string filename) {	xmlserializer ser=new xmlserializer(typeof(purchaseorder));	filestream fs=new filestream(filename, filemode.open);	purchaseorder po;	po=(purchaseorder)ser.deserialize(fs);	fs.close();	
name 

========================= mono sample_22556 =========================

public static void main (string[] args) {	using (var w = new streamwriter (console.openstandardoutput ())) {	
using system 

public static void main (string[] args) {	using (var w = new streamwriter (console.openstandardoutput ())) {	
using system reflection 

public static void main (string[] args) {	using (var w = new streamwriter (console.openstandardoutput ())) {	w.writeline ();	w.writeline ("public struct foostruct { public int i, j; public static bool operator == (foostruct f1, foostruct f2) { return f1.i == f2.i && f1.j == f2.j; } public static bool operator != (foostruct f1, foostruct f2) { return f1.i != f2.i || f1.j != f2.j; } public override bool equals (object obj) { return this == (foostruct)obj; } public override int gethashcode () { return 0; } }");	w.writeline ("public struct foostruct2 { public long i; public static bool operator == (foostruct2 f1, foostruct2 f2) { return f1.i == f2.i; } public static bool operator != (foostruct2 f1, foostruct2 f2) { return f1.i != f2.i; } public override bool equals (object obj) { return this == (foostruct2)obj; } public override int gethashcode () { return 0; } }");	w.writeline ("public struct foostruct3 { public bool i, j; public static bool operator == (foostruct3 f1, foostruct3 f2) { return f1.i == f2.i && f1.j == f2.j; } public static bool operator != (foostruct3 f1, foostruct3 f2) { return f1.i != f2.i || f1.j != f2.j; } public override bool equals (object obj) { return this == (foostruct3)obj; } public override int gethashcode () { return 0; } }");	
public class tests 

public static void main (string[] args) {	using (var w = new streamwriter (console.openstandardoutput ())) {	w.writeline ();	w.writeline ("public struct foostruct { public int i, j; public static bool operator == (foostruct f1, foostruct f2) { return f1.i == f2.i && f1.j == f2.j; } public static bool operator != (foostruct f1, foostruct f2) { return f1.i != f2.i || f1.j != f2.j; } public override bool equals (object obj) { return this == (foostruct)obj; } public override int gethashcode () { return 0; } }");	w.writeline ("public struct foostruct2 { public long i; public static bool operator == (foostruct2 f1, foostruct2 f2) { return f1.i == f2.i; } public static bool operator != (foostruct2 f1, foostruct2 f2) { return f1.i != f2.i; } public override bool equals (object obj) { return this == (foostruct2)obj; } public override int gethashcode () { return 0; } }");	w.writeline ("public struct foostruct3 { public bool i, j; public static bool operator == (foostruct3 f1, foostruct3 f2) { return f1.i == f2.i && f1.j == f2.j; } public static bool operator != (foostruct3 f1, foostruct3 f2) { return f1.i != f2.i || f1.j != f2.j; } public override bool equals (object obj) { return this == (foostruct3)obj; } public override int gethashcode () { return 0; } }");	
public static int main string args 

public static void main (string[] args) {	using (var w = new streamwriter (console.openstandardoutput ())) {	w.writeline ();	w.writeline ("public struct foostruct { public int i, j; public static bool operator == (foostruct f1, foostruct f2) { return f1.i == f2.i && f1.j == f2.j; } public static bool operator != (foostruct f1, foostruct f2) { return f1.i != f2.i || f1.j != f2.j; } public override bool equals (object obj) { return this == (foostruct)obj; } public override int gethashcode () { return 0; } }");	w.writeline ("public struct foostruct2 { public long i; public static bool operator == (foostruct2 f1, foostruct2 f2) { return f1.i == f2.i; } public static bool operator != (foostruct2 f1, foostruct2 f2) { return f1.i != f2.i; } public override bool equals (object obj) { return this == (foostruct2)obj; } public override int gethashcode () { return 0; } }");	w.writeline ("public struct foostruct3 { public bool i, j; public static bool operator == (foostruct3 f1, foostruct3 f2) { return f1.i == f2.i && f1.j == f2.j; } public static bool operator != (foostruct3 f1, foostruct3 f2) { return f1.i != f2.i || f1.j != f2.j; } public override bool equals (object obj) { return this == (foostruct3)obj; } public override int gethashcode () { return 0; } }");	
return testdriver runtests typeof tests args 

public static void gencase (streamwriter w, string rettype, string retval, string[] types, string[] values) {	testid_gen ++;	string callee_name = "meth_" + testid_gen;	
public static int test 

public static void gencase (streamwriter w, string rettype, string retval, string[] types, string[] values) {	testid_gen ++;	string callee_name = "meth_" + testid_gen;	w.write ("\t\t");	if (rettype != "void") w.write (rettype + " res = (" + rettype + ")");	w.write ("typeof (tests).getmethod (\"" + callee_name + "\").invoke (null, new object [] { ");	writelist (w, values);	w.writeline ("});");	if (rettype != "void") w.writeline ("\t\tif (res !=  " + retval + ") return 1;");	
return 

========================= mono sample_249 =========================

public void test(foo f) {	
bar test foo is tp 

public void test(foo f) {	
bar test foo is not a tp error 

public void test(foo f) {	
bar test foo f equals b failed error 

public void test(foo f) {	
bar test foo f equals f ok 

public static void main (string[] args) {	foo f = new foo();	bar b = new bar();	
b equals b failed error 

public static void main (string[] args) {	foo f = new foo();	bar b = new bar();	
b equals b ok 

public static void main (string[] args) {	foo f = new foo();	bar b = new bar();	
b is a tp 

public static void main (string[] args) {	foo f = new foo();	bar b = new bar();	
b is not a tp error 

public static void main (string[] args) {	foo f = new foo();	bar b = new bar();	b.test(f);	
f equals b failed error 

public static void main (string[] args) {	foo f = new foo();	bar b = new bar();	b.test(f);	
f equals f ok 

public static void main (string[] args) {	foo f = new foo();	bar b = new bar();	b.test(f);	
test end 

========================= mono sample_358 =========================

if (!contra (a_1, b_1)) return 2;	icovariant<string> a_2 = null;	icontravariant<object> b_2 = null;	icontravariant<string> c_2 = null;	if (!covcontcont (a_2, b_2, c_2)) return 3;	icontravariant<object> a_3 = null;	icovariant<string> b_3 = null;	icontravariant<string> c_3 = null;	icovariant<string> d_3 = null;	if (!contcovcontcov (a_3, b_3, c_3, d_3)) return 4;	
ok 

========================= mono sample_1968 =========================

public static int main () {	var c = new c();	var h = new g<string, c, int>(c);	var s = h.do ("abc");	var expected = typeof(string).name;	if (s == expected) return 0;	else {	
got expected 

========================= mono sample_218 =========================

public static int check (long stack1, long stack2) {	++i;	if (stack1 != 0) return 0;	int error = (stack1 != stack2) ? 1 : 0;	if (error == 0) return 0;	errors += 1;	
tailcall failure 

========================= mono sample_189 =========================

static void main () {	
hello 

========================= mono sample_36116 =========================

public static void del (a<int> a) {	
solved 

========================= mono sample_2110 =========================

try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection sect = (appsettingssection)config.getsection("appsettings");	foreach (string key in sect.settings.allkeys) {	keyvalueconfigurationelement e = sect.settings[key];	console.writeline ("{0} = {1}", e.key, e.value);	}	console.writeline ("lockattributes = '{0}'", sect.lockattributes.attributelist);	}	catch (exception e) {	
exception raised 

========================= mono sample_29821 =========================

public void enqueue (t context) {	
insert 

========================= mono sample_24548 =========================

private static void usage () {	
mono jscript compiler copyright c cesar lopez nataren copyright c novell inc http option 

private static void about () {	
the mono jscript compiler is copyright c cesar lopez nataren copyright c novell inc the compiler source code is released under the terms of both the mit and mpl the compiler was written by cesar lopez nataren 

if (!assembly.endswith (".dll") && !assembly.endswith (".exe")) full_path += ".dll";	try {	a = assembly.loadfrom (full_path);	addassembly (a);	return;	} catch (filenotfoundexception ff) {	total_log += ff.fusionlog;	continue;	}	}	
cannot find assembly 

try {	a = assembly.loadfrom (full_path);	addassembly (a);	return;	} catch (filenotfoundexception ff) {	total_log += ff.fusionlog;	continue;	}	}	} catch (badimageformatexception f) {	
cannot load assembly bad file format 

a = assembly.loadfrom (full_path);	addassembly (a);	return;	} catch (filenotfoundexception ff) {	total_log += ff.fusionlog;	continue;	}	}	} catch (badimageformatexception f) {	} catch (fileloadexception f){	
cannot load assembly 

addassembly (a);	return;	} catch (filenotfoundexception ff) {	total_log += ff.fusionlog;	continue;	}	}	} catch (badimageformatexception f) {	} catch (fileloadexception f){	} catch (argumentnullexception){	
cannot load assembly null argument 

static void version () {	string version = assembly.getexecutingassembly ().getname ().version.tostring ();	
mono jscript compiler version 

packages = string.join (" ", value.split (new char [] { ';', ',', '\n', '\r'}));	processstartinfo pi = new processstartinfo ();	pi.filename = "pkg-config";	pi.redirectstandardoutput = true;	pi.useshellexecute = false;	pi.arguments = "--libs " + packages;	process p = null;	try {	p = process.start (pi);	} catch (exception e) {	
couldn t run pkg config 

pi.redirectstandardoutput = true;	pi.useshellexecute = false;	pi.arguments = "--libs " + packages;	process p = null;	try {	p = process.start (pi);	} catch (exception e) {	environment.exit (1);	}	if (p.standardoutput == null){	
specified package did not return any information 

p = process.start (pi);	} catch (exception e) {	environment.exit (1);	}	if (p.standardoutput == null){	return true;	}	string pkgout = p.standardoutput.readtoend ();	p.waitforexit ();	if (p.exitcode != 0) {	
error running pkg config check the above output 

environment.exit (1);	}	if (pkgout != null){	string [] xargs = pkgout.trim (new char [] {' ', '\n', '\r', '\t'}). split (new char [] { ' ', '\t'});	args = addargs (args, xargs);	}	p.close ();	return true;	case "/r": case "/reference": {	if (value == ""){	
reference requires an argument 

if (value == ""){	environment.exit (1);	}	string [] refs = value.split (new char [] { ';', ',' });	foreach (string r in refs) references.add (r);	return true;	}	case "/lib": {	string [] libdirs;	if (value == ""){	
lib requires an argument 

foreach (string dir in libdirs) link_paths.add (dir);	return true;	}	case "/about": about ();	return true;	case "/nostdlib": case "/nostdlib+": stdlib = false;	return true;	case "/nostdlib-": stdlib = true;	return true;	case "/target": if (value.length == 0) {	
fatal error target type is invalid 

return true;	case "/nostdlib": case "/nostdlib+": stdlib = false;	return true;	case "/nostdlib-": stdlib = true;	return true;	case "/target": if (value.length == 0) {	environment.exit (1);	}	if (string.compare ("exe", value, true) == 0) {	} else if (string.compare ("library", value, true) != 0) {	
mjs currently does not support creating libraries 

return true;	case "/nostdlib-": stdlib = true;	return true;	case "/target": if (value.length == 0) {	environment.exit (1);	}	if (string.compare ("exe", value, true) == 0) {	} else if (string.compare ("library", value, true) != 0) {	environment.exit (1);	} else {	
fatal error target is invalid specify exe or library 

environment.exit (1);	}	if (string.compare ("exe", value, true) == 0) {	} else if (string.compare ("library", value, true) != 0) {	environment.exit (1);	} else {	environment.exit (1);	}	return true;	case "/warn": if (value.length == 0) {	
fatal error no warning level specified with option 

}	return true;	case "/warn": if (value.length == 0) {	environment.exit (1);	}	try {	warning_level = int.parse (value, cultureinfo.invariantculture);	} catch {	}	if (warning_level < 0 || warning_level > 4) {	
fatal error invalid warning level specified with option 

string path, pattern;	splitpathandpattern (spec, out path, out pattern);	if (pattern.indexof ('*') == -1){	processfile (spec);	return;	}	string [] files = null;	try {	files = directory.getfiles (path, pattern);	} catch (system.io.directorynotfoundexception) {	
source file could not be found 

if (pattern.indexof ('*') == -1){	processfile (spec);	return;	}	string [] files = null;	try {	files = directory.getfiles (path, pattern);	} catch (system.io.directorynotfoundexception) {	return;	} catch (system.io.ioexception){	
source file could not be found 

========================= mono sample_1328 =========================

public static void main () {	
hello 

========================= mono sample_579 =========================

static void writetofile (memorystream st) {	st.position = 0;	filestream fs = file.openwrite (path.gettempfilename ());	
writing to 

========================= mono sample_25985 =========================

public static int main() {	try {	try {	trivialmain();	}	finally {	
cleaning up 

public static int main() {	try {	try {	trivialmain();	}	finally {	}	}	catch(exception) {	
catch expected exception 

========================= mono sample_468 =========================

public static void testpairlog() {	log<pair<datetime,string>> log = new log<pair<datetime,string>>();	log.add(new pair<datetime,string>(datetime.now, "tea leaves"));	log.add(new pair<datetime,string>(datetime.now.addminutes(2), "hot water"));	log.add(new pair<datetime,string>(datetime.now.addminutes(7), "ready"));	pair<datetime,string>[] allmsgs = log.all;	
at 

========================= mono sample_2332 =========================

public void testit() {	object o = system.configuration.configurationmanager.getsection("testlib1");	list<system.xml.xmlnode> sectionlist = (list<system.xml.xmlnode>) o;	
count 

========================= mono sample_29844 =========================

public static void main()  {	testsimpleobject obj = new testsimpleobject();	
before serialization the object contains 

stream stream = file.open("data.xml", filemode.create);	binaryformatter formatter = new binaryformatter();	formatter.serialize(stream, obj);	stream.close();	obj = null;	stream = file.open("data.xml", filemode.open);	formatter = new binaryformatter();	obj = (testsimpleobject)formatter.deserialize(stream);	stream.close();	console.writeline("");	
after deserialization the object contains 

========================= mono sample_3219 =========================

mcs.waitforexit ();	} finally {	mcs.close ();	}	mcs_output_lines = mcs_output.split ( system.environment.newline.tochararray ());	foreach (string error_line in mcs_output_lines) {	compilererror error = createerrorfromstring (error_line);	if (null != error) error_list.add (error);	}	if (bug_report != null) {	
compiler output 

private static string[] createcsfiles (string[] source_text, string[] source_name) {	arraylist temp_file_list = new arraylist ();	for (int i=0; i<source_text.length; i++) {	string temp_path = path.gettempfilename ();	streamwriter writer = null;	try {	writer = new streamwriter (temp_path);	
line 

private static streamwriter createbugreport (string[] source_texts, string[] source_names, string path) {	streamwriter bug_report = null;	try {	bug_report = new streamwriter (path);	
c compiler defect report created 

private static streamwriter createbugreport (string[] source_texts, string[] source_names, string path) {	streamwriter bug_report = null;	try {	bug_report = new streamwriter (path);	for (int i=0; i<source_texts.length; i++) {	
source file 

========================= mono sample_22070 =========================

public static void main () {	int loop = 0;	goto a;	b: loop++;	return;	
hello 

========================= mono sample_3099 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
count 

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
appsettings count 

========================= mono sample_29815 =========================

public static void main() {	object[] attrs = typeof(test).getcustomattributes(typeof(testattribute), false);	foreach (testattribute attr in attrs) {	
testattribute 

========================= mono sample_2097 =========================

static void main () {	
some text 

========================= mono sample_2217 =========================

public void writeexceptions() {	console.writeline();	
unhandled exceptions 

public void suitestarted(testname testname) {	if ( level++ == 0 ) {	messages = new stringcollection();	testruncount = 0;	testignorecount = 0;	failurecount = 0;	
unit tests 

public void suitestarted(testname testname) {	if ( level++ == 0 ) {	messages = new stringcollection();	testruncount = 0;	testignorecount = 0;	failurecount = 0;	
running tests in 

public void suitefinished(testsuiteresult suiteresult) {	if ( --level == 0) {	trace.writeline( "############################################################################" );	if (messages.count == 0) {	
s u c c e s s 

public void suitefinished(testsuiteresult suiteresult) {	if ( --level == 0) {	trace.writeline( "############################################################################" );	if (messages.count == 0) {	}	else {	
f a i l u r e s 

if ( --level == 0) {	trace.writeline( "############################################################################" );	if (messages.count == 0) {	}	else {	foreach ( string s in messages ) {	trace.writeline(s);	}	}	trace.writeline( "############################################################################" );	
executed tests 

if ( --level == 0) {	trace.writeline( "############################################################################" );	if (messages.count == 0) {	}	else {	foreach ( string s in messages ) {	trace.writeline(s);	}	}	trace.writeline( "############################################################################" );	
ignored tests 

if ( --level == 0) {	trace.writeline( "############################################################################" );	if (messages.count == 0) {	}	else {	foreach ( string s in messages ) {	trace.writeline(s);	}	}	trace.writeline( "############################################################################" );	
failed tests 

if ( --level == 0) {	trace.writeline( "############################################################################" );	if (messages.count == 0) {	}	else {	foreach ( string s in messages ) {	trace.writeline(s);	}	}	trace.writeline( "############################################################################" );	
unhandled exceptions 

if ( --level == 0) {	trace.writeline( "############################################################################" );	if (messages.count == 0) {	}	else {	foreach ( string s in messages ) {	trace.writeline(s);	}	}	trace.writeline( "############################################################################" );	
total time seconds 

========================= mono sample_32695 =========================

public androidtzdata (params string[] paths) {	foreach (var path in paths) if (loaddata (path)) {	tzdatapath = path;	return;	}	
couldn t find any tzdata 

func<iandroidtimezonedb> c = () => getdefaulttimezonedb ();	bool dump_rules            = false;	mono.options.optionset p = null;	p = new mono.options.optionset () {	{ "i=", "timezone data {file} to parse and dump", v => dumptimezonefile (v, offset) }, { "o=", "write timezone data files to {path}", v => timezoneinfo.timezonedataexportpath = v }, { "t=", "create androidtzdata from {path}.", v => {	c = () => new androidtzdata (v);	} }, { "z=", "create zoneinfodb from {dir}.", v => {	c = () => new zoneinfodb (v);	} }, { "offset=", "show timezone info offset for datetime {offset}.", v => {	offset = datetime.parse (v);	
using datetime offset 

} }, { "z=", "create zoneinfodb from {dir}.", v => {	c = () => new zoneinfodb (v);	} }, { "offset=", "show timezone info offset for datetime {offset}.", v => {	offset = datetime.parse (v);	} }, { "r|dump-rules", "show timezone info offset for datetime {offset}.", v => dump_rules = v != null }, { "help", "show this message and exit", v => {	p.writeoptiondescriptions (console.out);	environment.exit (0);	} }, };	p.parse (args);	androidtimezones.db = c ();	
db type 

static void dumptimezonefile (string path, datetime? time) {	var buffer = file.readallbytes (path);	var zone = parsetzbuffer (path, buffer, buffer.length);	console.write ("rules for: {0}", path);	writezonerules (zone);	console.writeline ();	if (time.hasvalue) {	var offset = zone.getutcoffset (time.value);	var isdst  = zone.isdaylightsavingtime (time.value);	
date offset isdst 

var buffer = file.readallbytes (path);	var zone = parsetzbuffer (path, buffer, buffer.length);	console.write ("rules for: {0}", path);	writezonerules (zone);	console.writeline ();	if (time.hasvalue) {	var offset = zone.getutcoffset (time.value);	var isdst  = zone.isdaylightsavingtime (time.value);	}	if (zone.transitions != null) {	
transitions for 

var zone = parsetzbuffer (path, buffer, buffer.length);	console.write ("rules for: {0}", path);	writezonerules (zone);	console.writeline ();	if (time.hasvalue) {	var offset = zone.getutcoffset (time.value);	var isdst  = zone.isdaylightsavingtime (time.value);	}	if (zone.transitions != null) {	foreach (var transition in zone.transitions) {	
date 

========================= mono sample_28007 =========================

public static void main() {	thread thr=new thread(new threadstart(foo.thread));	thr.isbackground=true;	thr.start();	thread.sleep(1200);	
main thread returns 

public static void thread() {	
thread running 

public static void thread() {	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	
thread running 

========================= mono sample_192 =========================

c c = new c ();	a a = c;	b b = c;	if (c.var != 0) return 1;	a.x ();	if (c.var != 1) return 2;	b.x ();	if (c.var != 2) return 3;	c.x ();	if (c.var != 3) return 4;	
test passes 

========================= mono sample_3936 =========================

static int main () {	int res;	res = testproperty ();	if (res != 0) return 10 + res;	res = testfield ();	if (res != 0) return 20 + res;	
ok 

========================= mono sample_1833 =========================

try {	m1 = t.getmethod ("stuff", bindingflags.static|bindingflags.nonpublic);	} catch (ambiguousmatchexception) {	ok = true;	}	if (!ok) return 1;	m1 = t.getmethod ("stuff", bindingflags.static|bindingflags.nonpublic, null, char_types, null);	console.writeline ("m1: {0}", m1);	if (m1 == null) return 2;	object m1res = m1.invoke (null, char_args);	
invoke 

object m1res = m1.invoke (null, char_args);	if ((int)m1res != 1) return 3;	ok = false;	try {	m1res = m1.invoke (null, int_args);	} catch (argumentexception) {	ok = true;	}	if (!ok) return 4;	m2 = b.getmethod ("vmethod");	
declaring reflected 

========================= mono sample_343 =========================

public override bool check() {	bool retval = true;	if (size > array.length) {	
bad size array length 

public override bool check() {	bool retval = true;	if (size > array.length) {	return false;	}	for (int i = 0; i < size; i++) {	if ((object)(array[i]) == null) {	
bad element null at index 

public override bool check() {	bool retval = true;	if (size > array.length) {	return false;	}	for (int i = 0; i < size; i++) {	if ((object)(array[i]) == null) {	return false;	}	if (i > 0 && comparer.compare(array[i], array[i - 1]) <= 0) {	
inversion at index 

========================= mono sample_30541 =========================

public static int main (string [] args) {	
hello world 

========================= mono sample_1621 =========================

public void getpublicqueues () {	string qname1 = @".\admin-queue-3";	string qname2 = @".\admin-queue-4";	mqutil.getqueue (qname1);	mqutil.getqueue (qname2);	messagequeue[] mq = messagequeue.getpublicqueues ();	
number of queues 

========================= mono sample_32415 =========================

if (ld [0].name != "ab") return 11;	var de3 = from i in data where i.id == 10 orderby i.id descending, i.name ascending select i;	ld = new list<data> (de3);	if (ld [0].name != "bcd") return 12;	var de4 = from i in data where i.id == 20 orderby i.name group i by i.name;	var group_order = new list<igrouping<string, data>> (de4);	ld = new list<data>(group_order [0]);	if (ld [0].name != "ab") return 13;	ld = new list<data>(group_order [1]);	if (ld [0].name != "abcd") return 14;	
ok 

========================= mono sample_2508 =========================

public static void hola () {	
hola 

public static void ahoj () {	
ahoj 

static void x() {	
foo 

========================= mono sample_1403 =========================

r4 = o6 is myenum.v_4;	if (!r4) return 12;	constantpattern o7 = new constantpattern ();	if (!(o7 is constantpattern)) return 13;	if (!(o7 is object)) return 14;	object o8 = true;	if (o8 is false) return 15;	if (!(o8 is true)) return 16;	if (generic ("")) return 17;	if (!generic<delegate> (null)) return 18;	
ok 

========================= mono sample_3697 =========================

public static int main(string[] args) {	firstouter.firstinner.first v1 = new firstouter.firstinner.first();	firstouter.second v2 = new firstouter.second();	firstouter.secondinner.third v3 = new firstouter.secondinner.third();	firstouter.firstinner.fourth v4 = new firstouter.firstinner.fourth();	fifth v5 = new fifth();	
is 

public static int main(string[] args) {	firstouter.firstinner.first v1 = new firstouter.firstinner.first();	firstouter.second v2 = new firstouter.second();	firstouter.secondinner.third v3 = new firstouter.secondinner.third();	firstouter.firstinner.fourth v4 = new firstouter.firstinner.fourth();	fifth v5 = new fifth();	
is 

public static int main(string[] args) {	firstouter.firstinner.first v1 = new firstouter.firstinner.first();	firstouter.second v2 = new firstouter.second();	firstouter.secondinner.third v3 = new firstouter.secondinner.third();	firstouter.firstinner.fourth v4 = new firstouter.firstinner.fourth();	fifth v5 = new fifth();	
is 

public static int main(string[] args) {	firstouter.firstinner.first v1 = new firstouter.firstinner.first();	firstouter.second v2 = new firstouter.second();	firstouter.secondinner.third v3 = new firstouter.secondinner.third();	firstouter.firstinner.fourth v4 = new firstouter.firstinner.fourth();	fifth v5 = new fifth();	
is 

public static int main(string[] args) {	firstouter.firstinner.first v1 = new firstouter.firstinner.first();	firstouter.second v2 = new firstouter.second();	firstouter.secondinner.third v3 = new firstouter.secondinner.third();	firstouter.firstinner.fourth v4 = new firstouter.firstinner.fourth();	fifth v5 = new fifth();	
is 

========================= mono sample_3786 =========================

public static void main () {	float [] floats = new float[1];	floats[0] = 1.0f;	unsafe {	fixed (float *fp = &floats[0]) {	
foo 

========================= mono sample_33998 =========================

public override void initialize (string name, namevaluecollection values) {	
initialize 

========================= mono sample_23683 =========================

public static void main () {	
out 

public static void main () {	
error 

========================= mono sample_161 =========================

private void private () {	
private 

========================= mono sample_1980 =========================

static void main(string[] args) {	
this test should normally take less than a second 

========================= mono sample_23452 =========================

public static void main () {	goto end;	int a;	
unreachable 

public static void main () {	goto end;	int a;	
end 

========================= mono sample_1916 =========================

public printmodule () {	
instance created 

========================= mono sample_18517 =========================

static staticconstructor1 () {	try {	console.writeline ("staticconstructor1.staticconstructor1 (1)");	driver.mre1.set ();	var sw = stopwatch.startnew ();	thread.sleep (1000);	sw.stop ();	typeof (string).getmethods ();	if (sw.elapsedmilliseconds < 900) throw new exception ("bad abort broke our sleep");	
waited 

public static void init () {	
init 

static void isstaticconstructor1viable () {	new staticconstructor1 ();	
did it get to the end did it catch an exception 

static void test1 () {	
test 

static void test1 () {	driver.mre1.reset ();	driver.mre2.reset ();	thread thread = new thread (() => {	try {	staticconstructor1.init ();	} catch (exception e) {	
init caught exception 

} catch (exception e) {	if (!(e is threadabortexception)) throw;	}	});	thread.start ();	driver.mre1.waitone ();	thread.abort ();	thread.join ();	try {	isstaticconstructor1viable ();	
is viable 

} catch (exception e) {	if (!(e is threadabortexception)) throw;	}	});	thread.start ();	driver.mre1.waitone ();	thread.abort ();	thread.join ();	try {	isstaticconstructor1viable ();	
not viable 

public static void init () {	
init 

static void test2 () {	
test 

}	});	thread.start ();	driver.mre1.waitone ();	if (driver.mre2.waitone (500)) {	environment.exit (4);	}	thread.join ();	try {	isstaticconstructor2viable ();	
is viable 

thread.start ();	driver.mre1.waitone ();	if (driver.mre2.waitone (500)) {	environment.exit (4);	}	thread.join ();	try {	isstaticconstructor2viable ();	environment.exit (5);	} catch (typeinitializationexception e) {	
not viable 

public static void init () {	
init 

static void test3 () {	
test 

static void test3 () {	bool catched_abort = false;	driver.mre1.reset ();	driver.mre2.reset ();	thread thread = new thread (() => {	try {	staticconstructor3.init ();	
didn t throw 

static void test3 () {	bool catched_abort = false;	driver.mre1.reset ();	driver.mre2.reset ();	thread thread = new thread (() => {	try {	staticconstructor3.init ();	environment.exit (7);	} catch (threadabortexception e) {	
test aborted 

} catch (threadabortexception e) {	catched_abort = true;	}	});	thread.start ();	driver.mre1.waitone ();	thread.join ();	if (!catched_abort) environment.exit (8);	try {	isstaticconstructor3viable ();	
is viable 

}	});	thread.start ();	driver.mre1.waitone ();	thread.join ();	if (!catched_abort) environment.exit (8);	try {	isstaticconstructor3viable ();	environment.exit (9);	} catch (typeinitializationexception e) {	
not viable 

static staticconstructor4 () {	try {	console.writeline ("staticconstructor4.staticconstructor4 (1)");	driver.mre1.set ();	var sw = stopwatch.startnew ();	thread.sleep (1000);	sw.stop ();	typeof (string).getmethods ();	if (sw.elapsedmilliseconds < 900) throw new exception ("bad abort broke our sleep");	
waited 

public static void init () {	
init 

static void isstaticconstructor4viable () {	new staticconstructor4 ();	
did it get to the end did it catch an exception and end of the finally block 

static void test4 () {	
test 

static void test4 () {	driver.mre1.reset ();	driver.mre2.reset ();	thread thread = new thread (() => {	try {	try {	} finally {	staticconstructor4.init ();	
test after the cctor 

driver.mre1.reset ();	driver.mre2.reset ();	thread thread = new thread (() => {	try {	try {	} finally {	staticconstructor4.init ();	got_to_the_end_of_the_finally = true;	}	} catch (exception e) {	
init caught exception 

} catch (exception e) {	if (!(e is threadabortexception)) throw;	if (!got_to_the_end_of_the_finally) throw new exception ("test 4: did not get to the end of the cctor");	}	});	thread.start ();	driver.mre1.waitone ();	thread.abort ();	thread.join ();	if (!got_to_the_end_of_the_finally) {	
did not get to the end of test cctor 

});	thread.start ();	driver.mre1.waitone ();	thread.abort ();	thread.join ();	if (!got_to_the_end_of_the_finally) {	environment.exit (12);	}	try {	isstaticconstructor4viable ();	
is viable 

});	thread.start ();	driver.mre1.waitone ();	thread.abort ();	thread.join ();	if (!got_to_the_end_of_the_finally) {	environment.exit (12);	}	try {	isstaticconstructor4viable ();	
not viable 

static staticconstructor5 () {	driver.mre1.set ();	driver.mre2.waitone ();	try {	throw new exception ();	} catch (exception) {	
catched exception in cctor 

static void test5 () {	bool catched_abort = false;	driver.mre1.reset ();	driver.mre2.reset ();	thread thread = new thread (() => {	try {	new staticconstructor5 ();	} catch (threadabortexception) {	
catched thread abort 

static void isstaticconstructor6viable () {	
got to inner finally got to outer finally 

public static void test6 () {	thread thread = new thread (() => {	new staticconstructor6 ();	});	thread.start ();	driver.sema1.wait ();	thread.abort ();	thread.join ();	try {	isstaticconstructor6viable ();	
is viable 

thread thread = new thread (() => {	new staticconstructor6 ();	});	thread.start ();	driver.sema1.wait ();	thread.abort ();	thread.join ();	try {	isstaticconstructor6viable ();	} catch (typeinitializationexception e) {	
is not viable 

public static int main () {	test1 ();	test2 ();	test3 ();	test4 ();	test5 ();	test6 ();	
done all things good 

========================= mono sample_377 =========================

protected virtual void teardown () {	int c = application.openforms.count;	if (c > 0) {	
hey you created form s and you didn t dispose of them 

protected virtual void teardown () {	int c = application.openforms.count;	if (c > 0) {	
please modify your test to shut me up 

protected virtual void teardown () {	int c = application.openforms.count;	if (c > 0) {	
test 

public buttonwatcher (int[] watches) : base () {	this.watches = watches;	foreach (int i in this.watches) {	
listening to 

sorted [i++] = (string) entry.key;	}	array.sort (sorted);	string showname = objname;	for (int j = 0; j < sorted.length; j++) {	string name = sorted [j];	object value = values [name];	string message = prefix + showname + "." + name;	string tab = new string ('\t', tabs);	if (value == null) {	
assert isnull 

code = string.join (" | ", flags);	} else {	code = value.tostring ();	}	break;	case typecode.char: code = "'" + ((char) value).tostring () + "'"; break;	case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	
try 

} else {	code = value.tostring ();	}	break;	case typecode.char: code = "'" + ((char) value).tostring () + "'"; break;	case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	writer.writeline (tab + "\tobject zxf = {0}.{1};", showname, name);	
testhelper removewarning zxf 

} else {	code = value.tostring ();	}	break;	case typecode.char: code = "'" + ((char) value).tostring () + "'"; break;	case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	writer.writeline (tab + "\tobject zxf = {0}.{1};", showname, name);	
assert fail 

} else {	code = value.tostring ();	}	break;	case typecode.char: code = "'" + ((char) value).tostring () + "'"; break;	case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	writer.writeline (tab + "\tobject zxf = {0}.{1};", showname, name);	
catch ex 

} else {	code = value.tostring ();	}	break;	case typecode.char: code = "'" + ((char) value).tostring () + "'"; break;	case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	writer.writeline (tab + "\tobject zxf = {0}.{1};", showname, name);	
assert areequal ex message 

} else {	code = value.tostring ();	}	break;	case typecode.char: code = "'" + ((char) value).tostring () + "'"; break;	case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	writer.writeline (tab + "\tobject zxf = {0}.{1};", showname, name);	
catch exception ex 

} else {	code = value.tostring ();	}	break;	case typecode.char: code = "'" + ((char) value).tostring () + "'"; break;	case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	writer.writeline (tab + "\tobject zxf = {0}.{1};", showname, name);	
assert fail ex gettype fullname 

case typecode.datetime: code = "new system.datetime (" + ((datetime) value).ticks + ")"; break;	case typecode.dbnull: code = "system.dbnull.value" ; break;	case typecode.object: code = null;	if (value is exception) {	writer.writeline (tab + "\tobject zxf = {0}.{1};", showname, name);	writer.writeline (tab + "}");	} else {	if (maxrecursive > level) {	dumpobject (value, ((memberinfo)members [name]).declaringtype, showname + "." + name, writer, tabs, prefix, done, maxrecursive, level + 1);	} else {	
assert isnotnull 

if (maxrecursive > level) {	dumpobject (value, ((memberinfo)members [name]).declaringtype, showname + "." + name, writer, tabs, prefix, done, maxrecursive, level + 1);	} else {	}	}	break;	case typecode.string: code = "@\"" + ((string) value).replace ("\"", "\"\"") + "\""; break;	default: code = null; break;	}	if (code == null) continue;	
assert areequal 

========================= mono sample_25348 =========================

static void main () {	mystruct[] mystructarray = new mystruct[1];	
trying to construct an a 

static void main () {	mystruct[] mystructarray = new mystruct[1];	a a = new a (mystructarray);	
success 

========================= mono sample_35350 =========================

public static void run (servicebase [] services) {	int p = (int) environment.osversion.platform;	if (runservice != null) runservice (services);	else if (!(p == 4 || p == 128 || p == 6)) win32runservice (services);	
use mono service to start service processes 

========================= mono sample_4092 =========================

static int method1 (type t, int val) {	
you passed in 

static int method1 (type t, type[] types) {	
wrong method called 

static int method2 (type t, type [] types) {	
correct one this time 

========================= mono sample_1577 =========================

public static int main () {	
starting test 

public static int main () {	
domain name 

public static int main () {	
domain id 

========================= mono sample_295 =========================

public unsafe static int main () {	blittablestruct ss = new blittablestruct ();	int size = marshal.sizeof (typeof (blittablestruct));	
blittablestruct 

========================= mono sample_394 =========================

public static int main () {	x x = new x ();	x.p = 5;	int result = x.test ();	if (result != 0) console.writeline ("error: {0}", result);	
ok 

========================= mono sample_1957 =========================

int pagestart = control.firstvisibleitemindex;	int pagesize = control.visibleitemcount;	string listsuffix, itemprefix, itemsuffix;	listdecoration decoration = control.decoration;	bool insidestyle = true;	if (decoration != listdecoration.none || !device.tables) {	writer.enterstyle(style);	insidestyle = false;	}	switch (decoration) {	
ul 

}	switch (decoration) {	listsuffix = "</ul>";	itemprefix = "<li>";	itemsuffix = "</li>";	if (!device.rendersbreaksafterhtmllists) {	listsuffix += "<br>";	}	break;	case listdecoration.numbered: if (pagestart == 0) {	
ol 

itemprefix = "<li>";	itemsuffix = "</li>";	if (!device.rendersbreaksafterhtmllists) {	listsuffix += "<br>";	}	break;	default: if (device.tables) {	listsuffix = "</table>";	style.wrapping = wrapping.notset;	writer.enterlayout(style);	
table 

========================= mono sample_6034 =========================

static int main () {	var res = new c { a = { [1, 1] = 11, [0, 2] = 2} };	if (res.a [1, 1] != 11) return 1;	if (res.a [1, 2] != 0) return 2;	if (res.a [0, 2] != 2) return 3;	
ok 

========================= mono sample_3580 =========================

public static void sleeploop () {	for (int i = 0; i < 10; ++i) {	
step 

public static void sleeploop () {	for (int i = 0; i < 10; ++i) {	if (interruptrequested ()) break;	thread.sleep (100);	}	if (!interruptrequested ()) result |= 0x1;	try {	throwe ();	} catch (exception e) {	
caught from inside the prot block 

public static void cancelabort () {	object lk = new object ();	
step 

public static void cancelabort () {	object lk = new object ();	
step 

static void innerfromeh0 () {	thread = thread.currentthread;	methodinfo mi = typeof (driver).getmethod ("sleeploop");	try {	try {	throw new argumentexception ();	} finally {	handle.set ();	sleeploop ();	
done 

thread = thread.currentthread;	methodinfo mi = typeof (driver).getmethod ("sleeploop");	try {	try {	throw new argumentexception ();	} finally {	handle.set ();	sleeploop ();	finally_done = true;	}	
after finally 

try {	throw new argumentexception ();	} finally {	handle.set ();	sleeploop ();	finally_done = true;	}	result |= 0x10;	} catch (exception e) {	if (!(e is argumentexception)) result |= 0x4;	
caught a while on res 

static void guardfromeh0 () {	try {	innerfromeh0 ();	} catch (exception e) {	if (!(e is threadabortexception)) result |= 0x8;	
caught a while on res 

public static int test_0_abort_finally_after_throw () {	finally_done = false;	result = 0;	action ac = guardfromeh0;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	
aborting 

public static int test_0_abort_finally_after_throw () {	finally_done = false;	result = 0;	action ac = guardfromeh0;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	thread.abort ();	
aborted 

public static int test_0_abort_finally_after_throw () {	finally_done = false;	result = 0;	action ac = guardfromeh0;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	thread.abort ();	res.asyncwaithandle.waitone ();	
waited 

static void innerfromeh1 () {	thread = thread.currentthread;	methodinfo mi = typeof (driver).getmethod ("sleeploop");	try {	try {	throw new argumentexception ();	} finally {	handle.set ();	sleeploop ();	cancelabort ();	
done 

methodinfo mi = typeof (driver).getmethod ("sleeploop");	try {	try {	throw new argumentexception ();	} finally {	handle.set ();	sleeploop ();	cancelabort ();	finally_done = true;	}	
after finally 

throw new argumentexception ();	} finally {	handle.set ();	sleeploop ();	cancelabort ();	finally_done = true;	}	result |= 0x10;	} catch (exception e) {	if (!(e is argumentexception)) result |= 0x4;	
caught a while on res 

static void guardfromeh1 () {	try {	innerfromeh1 ();	} catch (exception e) {	result |= 0x8;	
caught a while on 

public static int test_0_abort_finally_and_cancel () {	finally_done = false;	result = 0;	action ac = guardfromeh1;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	
aborting 

public static int test_0_abort_finally_and_cancel () {	finally_done = false;	result = 0;	action ac = guardfromeh1;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	thread.abort ();	
aborted 

public static int test_0_abort_finally_and_cancel () {	finally_done = false;	result = 0;	action ac = guardfromeh1;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	thread.abort ();	res.asyncwaithandle.waitone ();	
waited 

static void innerfromeh () {	thread = thread.currentthread;	methodinfo mi = typeof (driver).getmethod ("sleeploop");	try {	try {	
try block 

static void innerfromeh () {	thread = thread.currentthread;	methodinfo mi = typeof (driver).getmethod ("sleeploop");	try {	try {	} finally {	handle.set ();	sleeploop ();	
done 

static void innerfromeh () {	thread = thread.currentthread;	methodinfo mi = typeof (driver).getmethod ("sleeploop");	try {	try {	} finally {	handle.set ();	sleeploop ();	finally_done = true;	}	
after finally 

try {	try {	} finally {	handle.set ();	sleeploop ();	finally_done = true;	}	result |= 0x10;	} catch (exception e) {	if (!(e is threadabortexception)) result |= 0x4;	
caught a while on res 

static void guardfromeh () {	try {	innerfromeh ();	} catch (exception e) {	if (!(e is threadabortexception)) result |= 0x8;	
caught a while on res 

public static int test_0_finally_after_try () {	appdomain.currentdomain.unhandledexception += (obj, sender) => {	
unhandled 

public static int test_0_finally_after_try () {	appdomain.currentdomain.unhandledexception += (obj, sender) => {	};	finally_done = false;	result = 0;	action ac = guardfromeh;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	
aborting 

public static int test_0_finally_after_try () {	appdomain.currentdomain.unhandledexception += (obj, sender) => {	};	finally_done = false;	result = 0;	action ac = guardfromeh;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	thread.abort ();	
aborted 

appdomain.currentdomain.unhandledexception += (obj, sender) => {	};	finally_done = false;	result = 0;	action ac = guardfromeh;	handle = new manualresetevent (false);	var res = ac.begininvoke (null, null);	handle.waitone ();	thread.abort ();	res.asyncwaithandle.waitone ();	
waited 

static int main (string[] args) {	appdomain.currentdomain.unhandledexception += (obj, sender) => {	
unhandled 

========================= mono sample_276 =========================

public announcementbounddiscoveryservice (announcementendpoint aendpoint) {	var ans = new announcementservice ();	ans.onlineannouncementreceived += registerendpoint;	ans.offlineannouncementreceived += unregisterendpoint;	ahost = new servicehost (ans);	ahost.addserviceendpoint (aendpoint);	ahost.open ();	
announcementservice channeldispatcher 

========================= mono sample_32571 =========================

public static int main () {	byte b = (byte) myenum.foo;	
foo has a value of 

i = (int) bar.b;	if (i != 2) return 1;	j = (int) bar.c;	if (j != 1) return 1;	j = (int) bar.d;	if (j != 30) return 1;	enum e = bar.d;	if (e.tostring () != "d") return 15;	if ((a.c - a.a) != 2) return 16;	if ((a.c - 1) != a.b) return 17;	
value 

i = (int) bar.b;	if (i != 2) return 1;	j = (int) bar.c;	if (j != 1) return 1;	j = (int) bar.d;	if (j != 30) return 1;	enum e = bar.d;	if (e.tostring () != "d") return 15;	if ((a.c - a.a) != 2) return 16;	if ((a.c - 1) != a.b) return 17;	
enum emission test okay 

========================= mono sample_1745 =========================

public static int main () {	int result = test (5);	if (result != 0) console.writeline ("error: {0}", result);	
ok 

========================= mono sample_3943 =========================

public bool mymethod () {	
base class method 

========================= mono sample_4020 =========================

public static int main () {	int [] a = new int [10];	int [] b = new int [2];	for (int i = 0; i < 10; i++) a [i] = 10 + i;	for (int j = 0; j < 2; j++) b [j] = 50 + j;	if (test_single (a) != 145) return 1;	if (test_single (b) != 101) return 2;	if (test_continue (a) != 131){	
expecting got 

int [] a = new int [10];	int [] b = new int [2];	for (int i = 0; i < 10; i++) a [i] = 10 + i;	for (int j = 0; j < 2; j++) b [j] = 50 + j;	if (test_single (a) != 145) return 1;	if (test_single (b) != 101) return 2;	if (test_continue (a) != 131){	return 3;	}	if (test_break (a) != 46){	
expecting got 

========================= mono sample_3547 =========================

public static int main () {	var r = test1 ();	if (!task.waitall (new [] { r }, 1000)) return 1;	
ok 

========================= mono sample_1502 =========================

public static void main () {	y y = new y ();	int result = y.hello ();	if (result == 2) console.writeline ("ok");	
not ok 

========================= mono sample_1693 =========================

public static int main(string[] args) {	foolist l = new foolist();	foo f1 = new foo("first");	foo f2 = new foo("second");	l.add(f1);	l.add(f2);	foreach (foo f in l) {	}	if (foolist.foo_current_called != true) return 1;	if (foolist.ienumerator_current_called != false) return 2;	
test passes 

========================= mono sample_3984 =========================

for (int t = 0; t < 4; ++t) {	if (array [t] != t) return 1;	if (a [t] != (t + 4)) return 1;	}	if (bar [2,1] != 20) return 1;	if (k [2] != 5) return 1;	if (m [1,1,1] != 9) return 1;	if (boo [0,1] != 11) return 1;	if (f_array [0] != 1.23f) return 1;	if (double_arr [1] != 90.1226) return 1;	
hello 

int [] x = new int [count];	for (int idx = 0; idx < count; idx++) x [idx] = idx + 1;	for (int idx = count; idx > 0; ){	idx--;	if (x [idx] != idx + 1) return 12;	}	intptr [] arr = { new system.intptr (1) };	if (arr [0] != (intptr) 1) return 13;	intptr [] arr_i = { system.intptr.zero };	if (arr_i [0] != system.intptr.zero) return 14;	
array initialization test okay 

========================= mono sample_1413 =========================

public void testservice () {	iodcodespostauxservice ser = new iodcodespostauxservice ();	string res = ser.getdepartmentforcode ("66");	
á 

public void testservice () {	iodcodespostauxservice ser = new iodcodespostauxservice ();	string res = ser.getdepartmentforcode ("66");	console.writeline (res);	
pyrénées orientales 

========================= mono sample_24280 =========================

public static void conditionalmethod() {	
succeeded 

========================= mono sample_3674 =========================

int readed	= 0;	int length	= this.readint24();	while (readed < length) {	int certlength = readint24();	readed += 3;	if (certlength > 0) {	byte[] buffer = this.readbytes(certlength);	x509certificate certificate = new x509certificate(buffer);	certificates.add(certificate);	readed += certlength;	
server certificate 

========================= mono sample_20689 =========================

da = t.getmember("t2")[0].getcustomattributes(ca, false)[0] as tupleelementnamesattribute;	if (da == null) return 42;	if (!da.transformnames.sequenceequal(new string[] { "a", "b" })) return 43;	da = t.getmember("d3")[0].getcustomattributes(ca, false)[0] as tupleelementnamesattribute;	if (da == null) return 50;	if (!da.transformnames.sequenceequal(new string[] { "x1", "x2", "a1", "a2", "aa1", "aa2", null, null, "b1", "b2", "cc1", "cc2", "dd1", "dd2" })) return 51;	t = typeof(del);	if (t.getmember("invoke")[0].getcustomattributes(ca, false).length != 0) return 100;	if (t.getmethod("invoke").getparameters()[0].getcustomattributes(ca, false).length != 1) return 101;	if (t.getmethod("invoke").returnparameter.getcustomattributes(ca, false).length != 1) return 102;	
ok 

========================= mono sample_2518 =========================

public static int main () {	blah k = new blah ();	float f = k;	if (f == 2){	
best implicit operator selected correctly 

public static implicit operator byte (blah i) {	
blah byte 

public static implicit operator short (blah i) {	
blah short 

public static implicit operator int (blah i) {	
blah int 

========================= mono sample_3837 =========================

static bool xx () {	++xx;	
xx 

static bool? yy () {	if (xx == 1) ++yy;	
yy 

========================= mono sample_1631 =========================

public virtual int onreloaded () {	
hit 

========================= mono sample_353 =========================

if (t5.result != 9) return 8;	var t6 = testcompositionpair_2 ();	if (!task.waitall (new[] { t6 }, 1000)) return 9;	if (t6.result != -1) return 10;	var t7 = testcompositionpair_3 ();	if (!task.waitall (new[] { t7 }, 1000)) return 11;	if (t7.result != -32) return 12;	var t8 = testcompositionpair_4 ();	if (!task.waitall (new[] { t8 }, 1000)) return 13;	if (t8.result != 14) return 14;	
ok 

========================= mono sample_1823 =========================

protected internal override void dump(textwriter tw, string prefix) {	tw.writeline(prefix + "<branch prefix={0} branchingbit={1}>", prefix, branchingbit);	left.dump(tw, prefix + "  ");	right.dump(tw, prefix + "  ");	
branch 

========================= mono sample_29575 =========================

public static void main (string[] args) {	string connectionstring = "data source=testdb;" + "user id=scott;" + "password=tiger;";	oracleconnection connection = null;	connection = new oracleconnection (connectionstring);	connection.open ();	
setup test package and data 

string connectionstring = "data source=testdb;" + "user id=scott;" + "password=tiger;";	oracleconnection connection = null;	connection = new oracleconnection (connectionstring);	connection.open ();	oraclecommand cmddrop = connection.createcommand();	cmddrop.commandtext = "drop table testtable";	try {	cmddrop.executenonquery();	}	catch(oracleexception e) {	
ignore this error 

connection.open ();	oraclecommand cmddrop = connection.createcommand();	cmddrop.commandtext = "drop table testtable";	try {	cmddrop.executenonquery();	}	catch(oracleexception e) {	}	cmddrop.dispose();	cmddrop = null;	
create table testtable 

try {	cmddrop.executenonquery();	}	catch(oracleexception e) {	}	cmddrop.dispose();	cmddrop = null;	oraclecommand cmd = connection.createcommand();	cmd.commandtext = "create table testtable (\n" + " col1 numeric(18,0),\n" + " col2 varchar(32),\n" + " col3 date, col4 blob)";	cmd.executenonquery();	
insert rows 

cmddrop = null;	oraclecommand cmd = connection.createcommand();	cmd.commandtext = "create table testtable (\n" + " col1 numeric(18,0),\n" + " col2 varchar(32),\n" + " col3 date, col4 blob)";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(45, 'mono', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(136, 'fun', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(526, 'system.data.oracleclient', sysdate, empty_blob())";	cmd.executenonquery();	
commit 

cmd.commandtext = "create table testtable (\n" + " col1 numeric(18,0),\n" + " col2 varchar(32),\n" + " col3 date, col4 blob)";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(45, 'mono', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(136, 'fun', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(526, 'system.data.oracleclient', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "commit";	cmd.executenonquery();	
update blob 

cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(136, 'fun', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(526, 'system.data.oracleclient', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "commit";	cmd.executenonquery();	oraclecommand select = connection.createcommand ();	select.transaction = connection.begintransaction();	select.commandtext = "select col1, col4 from testtable for update";	oracledatareader readerz = select.executereader ();	
error record not found 

cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(136, 'fun', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "insert into testtable\n" + "(col1, col2, col3, col4)\n" + "values(526, 'system.data.oracleclient', sysdate, empty_blob())";	cmd.executenonquery();	cmd.commandtext = "commit";	cmd.executenonquery();	oraclecommand select = connection.createcommand ();	select.transaction = connection.begintransaction();	select.commandtext = "select col1, col4 from testtable for update";	oracledatareader readerz = select.executereader ();	
update blob column on table testtable 

oraclelob blob = readerz.getoraclelob (1);	byte[] bytes = new byte[6] { 0x31, 0x32, 0x33, 0x34, 0x35, 0x036 };	blob.write (bytes, 0, bytes.length);	blob.close ();	readerz.close();	select.transaction.commit();	select.dispose();	select = null;	cmd.commandtext = "commit";	cmd.executenonquery();	
create package 

select.dispose();	select = null;	cmd.commandtext = "commit";	cmd.executenonquery();	cmd.commandtext = "create or replace package testtablepkg\n" + "as\n" + "	type t_cursor is ref cursor;\n" + "\n" + "	procedure getdata(tablecursor out t_cursor);\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.commandtext = "create or replace package body testtablepkg as\n" + "  procedure getdata(tablecursor out t_cursor)\n" + "  is\n" + "  begin\n" + "    open tablecursor for\n" + "    select *\n" + "    from testtable;\n" + "  end getdata;\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.dispose();	cmd = null;	
set up command and parameters to call stored proc 

cmd.executenonquery();	cmd.commandtext = "create or replace package body testtablepkg as\n" + "  procedure getdata(tablecursor out t_cursor)\n" + "  is\n" + "  begin\n" + "    open tablecursor for\n" + "    select *\n" + "    from testtable;\n" + "  end getdata;\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.dispose();	cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	
execute 

cmd.commandtext = "create or replace package body testtablepkg as\n" + "  procedure getdata(tablecursor out t_cursor)\n" + "  is\n" + "  begin\n" + "    open tablecursor for\n" + "    select *\n" + "    from testtable;\n" + "  end getdata;\n" + "end testtablepkg;";	cmd.executenonquery();	cmd.dispose();	cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	
get oracledatareader for cursor output parameter 

cmd.executenonquery();	cmd.dispose();	cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	
read data 

cmd = null;	oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	int r = 0;	while (reader.read()) {	
row 

oraclecommand command = new oraclecommand("testtablepkg.getdata", connection);	command.commandtype = commandtype.storedprocedure;	oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	int r = 0;	while (reader.read()) {	for (int f = 0; f < reader.fieldcount; f ++) {	
fieldtype 

oracleparameter parameter = new oracleparameter("tablecursor", oracletype.cursor);	parameter.direction = parameterdirection.output;	command.parameters.add(parameter);	command.executenonquery();	oracledatareader reader = (oracledatareader) parameter.value;	int r = 0;	while (reader.read()) {	for (int f = 0; f < reader.fieldcount; f ++) {	object val = "";	if (f==3) {	
blob 

int r = 0;	while (reader.read()) {	for (int f = 0; f < reader.fieldcount; f ++) {	object val = "";	if (f==3) {	val = reader.getvalue(f);	if (((byte[])val).length == 0) val = "empty blob (not null)";	else val = bitconverter.tostring((byte[])val);	}	else val = reader.getoraclevalue(f);	
field value 

object val = "";	if (f==3) {	val = reader.getvalue(f);	if (((byte[])val).length == 0) val = "empty blob (not null)";	else val = bitconverter.tostring((byte[])val);	}	else val = reader.getoraclevalue(f);	}	r ++;	}	
rows retrieved 

object val = "";	if (f==3) {	val = reader.getvalue(f);	if (((byte[])val).length == 0) val = "empty blob (not null)";	else val = bitconverter.tostring((byte[])val);	}	else val = reader.getoraclevalue(f);	}	r ++;	}	
clean up 

========================= mono sample_4919 =========================

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
entry 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide width 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide height 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide colorcount 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide reserved 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide planes 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide bitcount 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide bytesinres 

for (int i = 0; i < direntrycount; i++) {	icondirentry ide;	ide.width = reader.readbyte ();	ide.height = reader.readbyte ();	ide.colorcount = reader.readbyte ();	ide.reserved = reader.readbyte ();	ide.planes = reader.readuint16 ();	ide.bitcount = reader.readuint16 ();	ide.bytesinres = reader.readuint32 ();	ide.imageoffset = reader.readuint32 ();	
ide imageoffset 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
entry 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih bisize 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih biwidth 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih biheight 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih biplanes 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih bibitcount 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih bicompression 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih bisizeimage 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih bixpelspermeter 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih biypelspermeter 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih biclrused 

bih.biwidth = bihreader.readint32 ();	bih.biheight = bihreader.readint32 ();	bih.biplanes = bihreader.readuint16 ();	bih.bibitcount = bihreader.readuint16 ();	bih.bicompression = bihreader.readuint32 ();	bih.bisizeimage = bihreader.readuint32 ();	bih.bixpelspermeter = bihreader.readint32 ();	bih.biypelspermeter = bihreader.readint32 ();	bih.biclrused = bihreader.readuint32 ();	bih.biclrimportant = bihreader.readuint32 ();	
bih biclrimportant 

========================= mono sample_21258 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	
ok 

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	test.invoke (new tester (), null);	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_3258 =========================

public test () : this (add8(4), 6) {	string hostname = system.net.dns.gethostname ();	
hostname 

public test (int i, int j) {	
got 

========================= mono sample_33194 =========================

try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection sect = (appsettingssection)config.getsection("appsettings");	foreach (string key in sect.settings.allkeys) {	keyvalueconfigurationelement e = sect.settings[key];	console.writeline ("{0} = {1}", e.key, e.value);	}	console.writeline ("lockelements = '{0}'", sect.lockelements.attributelist);	}	catch (exception e) {	
exception raised 

========================= mono sample_29805 =========================

protected virtual string getexpectedresult (symmetricalgorithm algo, byte [] encrypteddata) {	int id = getid (algo);	string expected = bitconverter.tostring (encrypteddata);	
console writeline id expected 

========================= mono sample_27494 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	try {	appsettings.add ("fromtest", "valuehere");	}	catch {	
configurationmanager appsettings add resulted in exception 

========================= mono sample_29854 =========================

public void site_invalidchars () {	siteidentitypermission sip = new siteidentitypermission (permissionstate.none);	for (int i=0; i < 256; i++) {	try {	sip.site = string.empty + (char) i;	}	catch (argumentexception) {	
is bad 

========================= mono sample_27402 =========================

public static void threadstart1 () {	
started 

public static void threadstart1 () {	try {	try {	try {	lock (started) {	monitor.pulse (started);	}	int i = 0;	try {	while (true) {	
count 

lock (started) {	monitor.pulse (started);	}	int i = 0;	try {	while (true) {	thread.sleep (100);	}	}	catch (threadabortexception e) {	
cought exception level 

catch {}	try {	throw new dividebyzeroexception ();	}	catch (exception) {	}	result |= 32;	}	result = 255;	} catch (threadabortexception e) {	
cought exception level 

result |= 32;	}	result = 255;	} catch (threadabortexception e) {	console.writeline (e);	if ((string)e.exceptionstate == "statetest") result |= 1;	thread.resetabort ();	throw e;	}	} catch (threadabortexception e) {	
cought exception level 

console.writeline (e);	if ((string)e.exceptionstate == "statetest") result |= 1;	thread.resetabort ();	throw e;	}	} catch (threadabortexception e) {	console.writeline (e);	if (e.exceptionstate == null) result |= 2;	}	} catch (exception e) {	
cought exception level 

}	} catch (exception e) {	console.writeline (e.stacktrace);	result |= 4;	}	try {	thread.resetabort ();	} catch (system.threading.threadstateexception e) {	result |= 8;	}	
end 

t1 = new thread(new threadstart (tests.threadstart1));	t1.name = "thread 1";	thread.sleep (100);	t1.start();	monitor.wait (started);	}	thread.sleep (100);	t1.abort ("statetest");	t1.join ();	if (result != 59) {	
result 

thread.currentthread.abort ("test_0_thread_abort_water_mark");	} catch (threadabortexception e) {	hastry ();	thread.resetabort ();	failed = false;	} finally {	if (failed) {	thread.resetabort ();	throw new exception ("threw pending threadabort exception under stack threshold");	}	
working thread abort 

try {	try {	try {	thread.currentthread.abort ("testkeepabort");	} catch (threadabortexception ta_ex) {	throw new argumentnullexception("specificdummyexception");	}	} catch (argumentnullexception ex){	}	} catch (threadabortexception ex) {	
retained thread abort exception 

========================= mono sample_478 =========================

public void dump (textwriter tw) {	
top 

========================= mono sample_29790 =========================

wr.write ((int) 1);	wr.write ((int) -1);	byte [] arr = mr.toarray();	console.write ("array (should be: 1 1 0 0 0 ff ff ff ff): ");	for (int a = 0; a != arr.length; a++) console.write(arr[a].tostring("x") + " ");	console.writeline();	if (arr.length != 9) return 4;	if (arr[0] != 1) return 1;	if (arr[1] != 1 && arr[2] != 0 && arr[3] != 0 && arr[4] != 0) return 2;	if (arr[5] != 0xff && arr[6] != 0xff && arr[7] != 0xff && arr[8] != 0xff) return 3;	
test ok 

========================= mono sample_429 =========================

public static void main(string[] args) {	someenum someenum = someenum.dog;	
someenum result 

========================= mono sample_34892 =========================

position += readlength;	if (position == buffer.length) {	byte [] newbuffer = new byte [buffer.length * 2];	array.copy (buffer, 0, newbuffer, 0, buffer.length);	buffer = newbuffer;	}	}	} while(!lastline);	string line = encoding.getstring (buffer , 0 , position - 1);	lastresponse = smtpresponse.parse (line);	
smtp 

========================= mono sample_20151 =========================

static void main(string[] args) {	try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	customsection sect = (customsection)config.getsection("customsection");	foreach (string key in sect.settings.allkeys) {	keyvalueconfigurationelement e = sect.settings[key];	console.writeline ("{0} = {1}", e.key, e.value);	}	}	catch (exception e) {	
exception raised 

========================= mono sample_29831 =========================

static int main (string [] args) {	header ();	if (args.length == 0) usage ();	string file = args [0];	string output = args.length > 1 ? args [1] : file;	try {	assemblydefinition assembly = assemblyfactory.getassembly (file);	stripassembly (assembly, output);	if (file != output) console.writeline ("assembly {0} stripped out into {1}", file, output);	
assembly stripped 

header ();	if (args.length == 0) usage ();	string file = args [0];	string output = args.length > 1 ? args [1] : file;	try {	assemblydefinition assembly = assemblyfactory.getassembly (file);	stripassembly (assembly, output);	if (file != output) console.writeline ("assembly {0} stripped out into {1}", file, output);	return 0;	} catch (targetinvocationexception tie) {	
error 

if (args.length == 0) usage ();	string file = args [0];	string output = args.length > 1 ? args [1] : file;	try {	assemblydefinition assembly = assemblyfactory.getassembly (file);	stripassembly (assembly, output);	if (file != output) console.writeline ("assembly {0} stripped out into {1}", file, output);	return 0;	} catch (targetinvocationexception tie) {	} catch (exception e) {	
error 

static void header () {	
mono cil stripper 

static void usage () {	
usage mono cil strip file output 

========================= mono sample_819 =========================

schemastream = new memorystream ();	filestream fs = new filestream (inputschema, filemode.open, fileaccess.read);	byte[] buffer = new byte [1024*5];	int nr = 0;	while ((nr = fs.read (buffer, 0, buffer.length)) > 0) schemastream.write (buffer, 0, nr);	}	if (outputschema != null) {	if (schemastream == null) throw new exception ("no input schema or assembly has been specified");	schemastream.position = 0;	metadata.savestreamtofile (schemastream, outputschema);	
written file 

schemastream.position = 0;	if (outputcode) metadata.convertcodesourcestreamtoassemblyfile (writtenfiles, outputassembly, strongnamefile);	else {	metadata.convertschemastreamtocodesourcestream (wrappedproxy, outputdirectory, schemastream, writtenfiles, null, null);	metadata.convertcodesourcestreamtoassemblyfile (writtenfiles, outputassembly, strongnamefile);	foreach (string file in writtenfiles) file.delete (file);	writtenfiles.clear ();	}	writtenfiles.add (outputassembly);	}	
written file 

else {	metadata.convertschemastreamtocodesourcestream (wrappedproxy, outputdirectory, schemastream, writtenfiles, null, null);	metadata.convertcodesourcestreamtoassemblyfile (writtenfiles, outputassembly, strongnamefile);	foreach (string file in writtenfiles) file.delete (file);	writtenfiles.clear ();	}	writtenfiles.add (outputassembly);	}	}	catch (exception ex) {	
error 

static void writelogo () {	
mono soapsuds tool 

static void writehelp () {	
usage soapsuds inputs outputs options 

static void writehelp () {	console.writeline ();	
inputs 

static void writehelp () {	console.writeline ();	
url urltoschema url url from which to retrieve the schema 

static void writehelp () {	console.writeline ();	
types assembly serviceendpoint assembly 

static void writehelp () {	console.writeline ();	
list of types from which to generate 

static void writehelp () {	console.writeline ();	
a schema or proxy 

static void writehelp () {	console.writeline ();	
ia inputassemblyfile assembly assembly that contains the types to export 

static void writehelp () {	console.writeline ();	
is inputschemafile schemafile schema from which to generate proxy classes 

static void writehelp () {	console.writeline ();	console.writeline ();	
input options 

static void writehelp () {	console.writeline ();	console.writeline ();	
id inputdirectory directory directory where dlls are located 

static void writehelp () {	console.writeline ();	console.writeline ();	
se serviceendpoint url url of the service to be placed in the 

static void writehelp () {	console.writeline ();	console.writeline ();	
wsdl document 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	
outputs 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	
oa outputassemblyfile assembly generate an assembly 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	
os outputschemafile file generate a schema 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	
gc generatecode generate proxy source code 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
output options 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
od outputdirectory directory directory where output will be generated 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
pn proxynamespace namespace namespace of the generated proxy 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
nowp nowrappedproxy generate a wrapped proxy 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
wp wrappedproxy generate a wrapped proxy 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
sn strongnamefile snfile strong name file 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
general options 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
u username name user name for server authentication 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
p password pwd password for server authentication 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
d domain domain domain of the server 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
hpn httpproxyname name name of http proxy 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
hpp httpproxyport port port of http proxy 

static void writehelp () {	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	console.writeline ();	
nologo supress the startup logo 

========================= mono sample_1209 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
ismachinelevel 

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection appsettings = config.appsettings;	
file 

========================= mono sample_29840 =========================

public static void main (string [] args) {	if (args.length == 0) {	
pass path to web config 

========================= mono sample_31194 =========================

public void runheapandexpressionanalyses () {	if (this.heap_analysis != null) return;	this.heap_analysis = new heapanalysis.heapanalysis (stacklayer);	stacklayer.createforward (this.heap_analysis) (this.heap_analysis.initialvalue ());	valuelayer = codelayerfactory.create ( this.heap_analysis.getdecoder (stacklayer.ildecoder), stacklayer.metadataprovider, stacklayer.contractprovider, source => source.tostring (), dest => dest.tostring ());	var expressionanalysis = new expressionanalysisfacade<symbolicvalue, ivaluecontextprovider<symbolicvalue>, iimmutablemap<symbolicvalue, sequence<symbolicvalue>>> (valuelayer, this.heap_analysis.isunreachable);	valuelayer.createforward (expressionanalysis.createexpressionanalysis ()) (expressionanalysis.initialvalue (symbolicvalue.getuniquekey));	if (debugoptions.debug) {	
value based cfg 

valuelayer = codelayerfactory.create ( this.heap_analysis.getdecoder (stacklayer.ildecoder), stacklayer.metadataprovider, stacklayer.contractprovider, source => source.tostring (), dest => dest.tostring ());	var expressionanalysis = new expressionanalysisfacade<symbolicvalue, ivaluecontextprovider<symbolicvalue>, iimmutablemap<symbolicvalue, sequence<symbolicvalue>>> (valuelayer, this.heap_analysis.isunreachable);	valuelayer.createforward (expressionanalysis.createexpressionanalysis ()) (expressionanalysis.initialvalue (symbolicvalue.getuniquekey));	if (debugoptions.debug) {	valuelayer.ildecoder.contextprovider.methodcontext.cfg.print (console.out, valuelayer.printer, null, null);	}	iildecoder <apc, labeledsymbol<apc, symbolicvalue>, symbolicvalue, iexpressioncontextprovider<labeledsymbol<apc, symbolicvalue>, symbolicvalue>, iimmutablemap<symbolicvalue, sequence<symbolicvalue>>> decoder = expressionanalysis.getdecoder (valuelayer.ildecoder);	this.expr2string = expressionprinterfactory.printer (decoder.contextprovider, this);	expressionlayer = codelayerfactory.create (decoder, valuelayer.metadataprovider, valuelayer.contractprovider, this.expr2string, valuelayer.variabletostring);	if (debugoptions.debug) {	
expression based cfg 

========================= mono sample_29592 =========================

private void checkprofilechanges(object sender, elapsedeventargs e) {	dbcommand cmd = null;	dbdatareader reader = null;	try {	if ((null == profileupdated) && (null == profileremoved)) return;	
checking for updated profiles 

========================= mono sample_10834 =========================

public void processrequest(httpcontext context) {	tracemethod method = tracing.on ? new tracemethod(this, "processrequest") : null;	if (tracing.on) tracing.enter("ihttphandler.processrequest", method, tracing.details(context.request));	new permissionset(permissionstate.unrestricted).demand();	string physicalpath = context.request.physicalpath;	
discoveryrequesthandle handling 

dynamicdiscosearcher searcher;	uri searchstarturl = context.request.url;	string escapeduri = runtimeutils.escapeuri(searchstarturl);	string searchstarturldir = getdirpartofpath( escapeduri );	string strlocalpath = getdirpartofpath(searchstarturl.localpath);	if ( strlocalpath.length == 0 || compmodswitches.dynamicdiscoveryvirtualsearch.enabled ) {	discofilename = getfilepartofpath( escapeduri );	searcher = new dynamicvirtualdiscosearcher( discofiledirectory, excludelist, searchstarturldir);	}	else searcher = new dynamicphysicaldiscosearcher(discofiledirectory, excludelist, searchstarturldir);	
discoveryrequesthandler processrequest startdir discofilename 

========================= mono sample_12632 =========================

public static void main() {	
aaa 

public static void main() {	dns.gethostbyname("localhost");	
bbb 

========================= mono sample_549 =========================

public static int main () {	program p = new program ();	if (p.test_2 ()) return 1;	p._value = p.m;	if (!p.test_2 ()) return 2;	if (p.test_3 ()) return 3;	
ok 

========================= mono sample_2182 =========================

public override assemblynode visitassembly (assemblynode node) {	if (node == null) return null;	
extracting from 

private void extractcontractsinternal (method method, ref list<requires> preconditions, ref list<ensures> postconditions) {	if (method == null) return;	
method 

private void extractcontractsinternal (method method, ref list<requires> preconditions, ref list<ensures> postconditions) {	if (method == null) return;	block body = method.body;	if (body == null || body.statements == null || body.statements.count <= 0) return;	int lastblockcontainingcontract;	int laststatementcontainingcontract;	int begin = 0;	bool contractsfound = findlastblockwithcontracts (body.statements, begin, out lastblockcontainingcontract, out laststatementcontainingcontract);	if (!contractsfound) {	
no contracts found 

for (int lastblockindex = firstblockindex; lastblockindex < blockscount; ++lastblockindex) {	var block = (block) blocks [lastblockindex];	if (block == null) continue;	int cnt = block.statements == null ? 0 : block.statements.count;	for (int laststmtindex = 0; laststmtindex < cnt; ++laststmtindex) {	statement s = block.statements [laststmtindex];	if (s == null) continue;	method calledmethod = helpermethods.ismethodcall (s);	if (!this.contract_nodes.iscontractmethod (calledmethod)) continue;	if (wasendcontractblock) {	
contract call after prior contractblock 

========================= mono sample_29470 =========================

static void error (string method, string text) {	
assert failed 

assert.istrue ("h == null", h == null);	assert.isfalse ("h != null", h != null);	assert.istrue ("g == i", g == i);	assert.isfalse ("g != i", g != i);	assert.isfalse ("g == j", g == j);	assert.istrue ("g != j", g != j);	assert.isfalse ("h == i", h == i);	assert.istrue ("h != i", h != i);	assert.istrue ("h == j", h == j);	assert.isfalse ("h != j", h != j);	
errors 

========================= mono sample_2093 =========================

object o = a.createinstance ("system.exception");	if (o == null) return 1;	if (!(o is system.exception)) return 2;	object[] args = new object [2];	args [0] = 'x';	args [1] = 10;	o = activator.createinstance (typeof (system.string), args);	if (o == null) return 3;	if (!(o is system.string)) return 4;	if (!"xxxxxxxxxx".equals (o)) {	
got 

========================= mono sample_689 =========================

static int main() {	type gtd = typeof (a<>);	type oi = gtd.makegenerictype (gtd.getgenericarguments ());	if (oi != gtd) {	
fully open instantiation of static type not the same of the generic type definition 

type gtd = typeof (a<>);	type oi = gtd.makegenerictype (gtd.getgenericarguments ());	if (oi != gtd) {	return 1;	}	setup ();	typebuilder tb = module.definetype ("nullable`1", typeattributes.public);	type[] args = tb.definegenericparameters ("t");	type type = tb.makegenerictype (args);	if (type == tb) {	
fully open instantiation of typebuilder is the same of the typebuilder 

setup ();	typebuilder tb = module.definetype ("nullable`1", typeattributes.public);	type[] args = tb.definegenericparameters ("t");	type type = tb.makegenerictype (args);	if (type == tb) {	return 2;	}	type res = tb.createtype ();	type oires = res.makegenerictype (res.getgenericarguments ());	if (res != oires) {	
fully open instantiation not the same of the generic type definition for the typebuilder created type 

return 2;	}	type res = tb.createtype ();	type oires = res.makegenerictype (res.getgenericarguments ());	if (res != oires) {	return 3;	}	try {	oires.getconstructors ();	} catch (exception e) {	
fully open instantiation of the typebuilder created type must have getconstructors working 

========================= mono sample_458 =========================

public static ienumerable<object> tagserror () {	string tags;	tags = "";	runonthread (() => {	using (d u = new d (tags)) {	
no op 

public static void main () {	foreach (object bar in tagserror ()) {	
no op 

========================= mono sample_2242 =========================

public void namespaceselectwithnselasure () {	xmldocument doc = new xmldocument ();	doc.loadxml ("<root xmlns='urn:root' xmlns:hoge='urn:hoge'><foo xmlns='urn:foo'><bar xmlns=''><baz/></bar></foo></root>");	xmlnode n = doc.firstchild.firstchild.firstchild.firstchild;	xmlnodelist nl = n.selectnodes ("namespace::*");	assert.areequal ("hoge", nl [0].localname, "#1");	assert.areequal ("xml", nl [1].localname, "#2");	assert.areequal (2, nl.count, "#3");	n = doc.firstchild.firstchild;	nl = n.selectnodes ("namespace::*");	
at foo 

========================= mono sample_22347 =========================

private static void checkcupsinstalled () {	try {	cupsgetdefault ();	}	catch (dllnotfoundexception) {	
libcups not found to have printing support you need cups installed 

private intptr openprinter (string printer) {	try {	intptr ptr = cupsgetppd (printer);	string ppd_filename = marshal.ptrtostringansi (ptr);	intptr ppd_handle = ppdopenfile (ppd_filename);	return ppd_handle;	}	catch (exception) {	
there was an error opening the printer please check your cups installation 

private static void loadoptionlist (intptr ppd, string option_name, namevaluecollection list, out string defoption) {	intptr ptr = intptr.zero;	ppd_option ppd_option;	ppd_choice choice;	int choice_size = marshal.sizeof(typeof(ppd_choice));	defoption = null;	ptr = ppdfindoption (ppd, option_name);	if (ptr != intptr.zero) {	ppd_option = (ppd_option) marshal.ptrtostructure (ptr, typeof (ppd_option));	
option key def text 

int choice_size = marshal.sizeof(typeof(ppd_choice));	defoption = null;	ptr = ppdfindoption (ppd, option_name);	if (ptr != intptr.zero) {	ppd_option = (ppd_option) marshal.ptrtostructure (ptr, typeof (ppd_option));	#endif defoption = ppd_option.defchoice;	ptr = ppd_option.choices;	for (int c = 0; c < ppd_option.num_choices; c++) {	choice = (ppd_choice) marshal.ptrtostructure (ptr, typeof (ppd_choice));	list.add(choice.choice, choice.text);	
choice text 

========================= mono sample_21229 =========================

while (nativemethods.thread32next(handleref, thread));	}	for (int i = 0; i < threadinfos.count; i++) {	threadinfo threadinfo = (threadinfo)threadinfos[i];	processinfo processinfo = (processinfo)processinfos[threadinfo.processid];	if (processinfo != null) processinfo.threadinfolist.add(threadinfo);	}	}	finally {	if (bufferhandle.isallocated) bufferhandle.free();	
process closehandle snapshot handle 

moduleinfo.sizeofimage = module.modbasesize;	moduleinfo.id = module.th32moduleid;	moduleinfos.add(moduleinfo);	marshal.writeint32(bufferptr, buffersize);	}	while (nativemethods.module32next(handleref, bufferptr));	}	}	finally {	if (bufferhandle.isallocated) bufferhandle.free();	
process closehandle snapshot handle 

throw;	}	}	if( firstmoduleonly) { break; }	}	moduleinfo[] temp = new moduleinfo[moduleinfos.count];	moduleinfos.copyto(temp, 0);	return temp;	}	finally {	
process closehandle process 

static processinfo[] getprocessinfos(performancecounterlib library, int processindex, int threadindex, byte[] data) {	
getprocessinfos 

for (int j = 0; j < type.numinstances; j++) {	marshal.ptrtostructure(instanceptr, instance);	intptr nameptr = (intptr)((long)instanceptr + instance.nameoffset);	string instancename = marshal.ptrtostringuni(nameptr);	if (instancename.equals("_total")) continue;	intptr counterblockptr = (intptr)((long)instanceptr + instance.bytelength);	marshal.ptrtostructure(counterblockptr, counterblock);	if (type.objectnametitleindex == processindex) {	processinfo processinfo = getprocessinfo(type, (intptr)((long)instanceptr + instance.bytelength), counters);	if (processinfo.processid == 0 && string.compare(instancename, "idle", stringcomparison.ordinalignorecase) != 0) {	
getprocessinfos found a non idle process with id ignoring 

string instancename = marshal.ptrtostringuni(nameptr);	if (instancename.equals("_total")) continue;	intptr counterblockptr = (intptr)((long)instanceptr + instance.bytelength);	marshal.ptrtostructure(counterblockptr, counterblock);	if (type.objectnametitleindex == processindex) {	processinfo processinfo = getprocessinfo(type, (intptr)((long)instanceptr + instance.bytelength), counters);	if (processinfo.processid == 0 && string.compare(instancename, "idle", stringcomparison.ordinalignorecase) != 0) {	}	else {	if (processinfos[processinfo.processid] != null) {	
getprocessinfos found a duplicate process id 

========================= mono sample_12424 =========================

if (!foo<int>.test()) return 2;	if (foo<int?>.testb()) return 3;	int? i = 0;	if (!testa(i)) return 4;	int[] a = new int[0];	if (!testb(a)) return 5;	if (testc () != 3) return 6;	if (check1 (null)) return 7;	if (!check1 (e.item)) return 8;	if (check2<int> (e.item)) return 9;	
ok 

========================= mono sample_2285 =========================

foreach (protectedconfigurationprovider pc in protectedconfiguration.providers) {	console.writeline (pc.name);	if (pc is rsaprotectedconfigurationprovider) {	rsaprotectedconfigurationprovider rsa = (rsaprotectedconfigurationprovider)pc;	console.writeline ("keycontainername = {0}", rsa.keycontainername);	console.writeline ("usemachinecontainer = {0}", rsa.usemachinecontainer);	}	}	}	catch (exception e) {	
exception raised 

========================= mono sample_29825 =========================

public void collection_add_remove () {	
start test collection add remove 

========================= mono sample_31320 =========================

public string getstrings () {	
total string data size 

========================= mono sample_17 =========================

protected override void oninit (eventargs e) {	
child oninit 

========================= mono sample_18513 =========================

public static void main2 (string[] argv) {	
test 

========================= mono sample_3846 =========================

public debugreflectpropertydescriptor(type componentclass, string name, type type, attribute[] attributes) : base(name, attributes) {	
creating debugreflectpropertydescriptor for 

public override object getvalue(object component) {	#if debug if (propdescusageswitch.traceverbose) {	string compname = "(null)";	if (component != null) compname = component.tostring();	
getvalue 

public override object getvalue(object component) {	#if debug if (propdescusageswitch.traceverbose) {	string compname = "(null)";	if (component != null) compname = component.tostring();	}	#endif if (isextender) {	
returning null 

if (t is targetinvocationexception) {	t = t.innerexception;	}	string message = t.message;	if (message == null) {	message = t.gettype().name;	}	throw new targetinvocationexception(sr.getstring(sr.errorpropertyaccessorexception, name, name, message), t);	}	}	
returning null 

public override void setvalue(object component, object value) {	#if debug if (propdescusageswitch.traceverbose) {	string compname = "(null)";	string valname  = "(null)";	if (component != null) compname = component.tostring();	if (value != null) valname = value.tostring();	
setvalue 

========================= mono sample_12148 =========================

public static int test4 (int b, out float f) {	long a;	
hello world 

public static int test15 (int b, out float f) {	long a;	
hello world 

static int test27 () {	while (true) {	break;	
test 

public void test32 () {	while (true) {	system.threading.thread.sleep (1);	}	
hello 

========================= mono sample_1852 =========================

public static int main () {	
address is x 

public static int main () {	ipaddress testadd = ipaddress.parse ("127.0.0.1");	
address is x 

public static int main () {	ipaddress testadd = ipaddress.parse ("127.0.0.1");	if (testadd.address != 0x0100007f) return 1;	ipaddress hostadd = new ipaddress(0x0100007f);	
address is 

========================= mono sample_322 =========================

public static int main() {	object x = null;	int? y = x as int?;  /* causes cs0077 */ console.writeline("y: '{0}'", y);	
y hasvalue 

========================= mono sample_3654 =========================

public static int main () {	int result = test (5);	if (result != 0) console.writeline ("error: {0}", result);	
ok 

========================= mono sample_2478 =========================

public static int main () {	object o = 3;	bool r = o is system.string t1;	if (r) return 2;	if (o is string t2) return 3;	long? l = 5;	bool r3 = l is long t4;	if (!r3) return 8;	
ok 

========================= mono sample_1912 =========================

static int main () {	int res;	appdomainsetup setup = new appdomainsetup ();	setup.applicationbase = ".";	console.writeline (appdomain.currentdomain.friendlyname);	appdomain newdomain = appdomain.createdomain ("newdomain", null, setup);	string[] args = { "1", "2", "3"};	res = newdomain.executeassembly ("appdomain-client.exe", null, args);	if (res != arg_sum (args)) return 1;	
test ok 

========================= mono sample_262 =========================

public void unsafe() {	bool bad = false;	for (int i = 0; i < 10; i++) {	system.threading.thread t1 = new system.threading.thread(new system.threading.threadstart(unsafe1));	system.threading.thread t2 = new system.threading.thread(new system.threading.threadstart(unsafe2));	t1.start();	t2.start();	t1.join();	t2.join();	if (bad = 2 * sz + 1 != tree.count) {	
unsafe bad at 

========================= mono sample_30493 =========================

static int main () {	z z = new z ();	if (global != 1){	
error 

static int main () {	z z = new z ();	if (global != 1){	return 1;	}	
ok 

========================= mono sample_291 =========================

static task runasync () {	return task.factory.startnew (() => {	master_mre.waitone ();	
hello async 

========================= mono sample_1462 =========================

static int main() {	int ms, ms2, ms3;	unsafe {	ms = sizeof (mystruct);	ms2 = sizeof (mystruct2);	ms3 = sizeof (mystruct3);	}	
mystruct size 

static int main() {	int ms, ms2, ms3;	unsafe {	ms = sizeof (mystruct);	ms2 = sizeof (mystruct2);	ms3 = sizeof (mystruct3);	}	
size 

static int main() {	int ms, ms2, ms3;	unsafe {	ms = sizeof (mystruct);	ms2 = sizeof (mystruct2);	ms3 = sizeof (mystruct3);	}	
size 

========================= mono sample_380 =========================

public static void run() {	int d = 200;	int repeats = 2;	int lookups = 50000;	testlattice tl = null;	
testlattice run means over repeats 

========================= mono sample_30582 =========================

public static void main() {	imetadatadispenserex o = new imetadatadispenserex();	if (o.gettype () != typeof (cormetadatadispenserexclass)) return 1;	
ok 

========================= mono sample_3963 =========================

static extern void mono_test_native_to_managed_exception_rethrow (action action);	[dllimport ("libc")]	static extern void _exit (int exitcode);	static int main (string[] args) {	appdomain.currentdomain.unhandledexception += (sender, exception_args) => {	customexception exc = exception_args.exceptionobject as customexception;	if (exc == null) {	
failed unknown exception exception args exceptionobject 

[dllimport ("libc")]	static extern void _exit (int exitcode);	static int main (string[] args) {	appdomain.currentdomain.unhandledexception += (sender, exception_args) => {	customexception exc = exception_args.exceptionobject as customexception;	if (exc == null) {	_exit (1);	}	console.writeline (exc.stacktrace);	if (string.isnullorempty (exc.stacktrace)) {	
failed stacktrace is null for unhandled exception 

static int main (string[] args) {	appdomain.currentdomain.unhandledexception += (sender, exception_args) => {	customexception exc = exception_args.exceptionobject as customexception;	if (exc == null) {	_exit (1);	}	console.writeline (exc.stacktrace);	if (string.isnullorempty (exc.stacktrace)) {	_exit (2);	} else {	
success stacktrace is not null for unhandled exception 

_exit (1);	}	console.writeline (exc.stacktrace);	if (string.isnullorempty (exc.stacktrace)) {	_exit (2);	} else {	_exit (0);	}	};	mono_test_native_to_managed_exception_rethrow (plainthrow);	
should have exited in the unhandledexception event handler 

========================= mono sample_316 =========================

public delegate void eventhandler (int i, int j);	public class button {	private eventhandler click;	public event eventhandler click {	add    { click += value; }	remove { click -= value; }	}	public void onclick (int i, int j) {	if (click == null) {	
nothing to click 

public void button1_click (int i, int j) {	
was clicked 

public void button1_click (int i, int j) {	
answer 

public void foo_click (int i, int j) {	
foo was clicked 

public void foo_click (int i, int j) {	
answer 

public void disconnect () {	
disconnecting s handler 

public static int main () {	blah b = new blah ();	b.connect ();	b.button1.onclick (2, 3);	b.disconnect ();	
now calling onclick again 

public static int main () {	blah b = new blah ();	b.connect ();	b.button1.onclick (2, 3);	b.disconnect ();	b.button1.onclick (3, 7);	
events test passes 

========================= mono sample_3660 =========================

themeengine.current.colorcontrollight = color.fromargb (255, 227, 227, 227);	}	widget = gtk_menu_new ();	gtk_widget_ensure_style (widget);	style_ptr = gtk_widget_get_style (widget);	style = (gtkstylestruct) marshal.ptrtostructure (style_ptr, typeof (gtkstylestruct));	themeengine.current.colormenu = colorfromgdkcolor (style.bg [0]);	themeengine.current.colormenutext = colorfromgdkcolor (style.text [0]);	}	catch (dllnotfoundexception) {	
gtk not found missing ld library path to libgtk so using built in colorscheme 

widget = gtk_menu_new ();	gtk_widget_ensure_style (widget);	style_ptr = gtk_widget_get_style (widget);	style = (gtkstylestruct) marshal.ptrtostructure (style_ptr, typeof (gtkstylestruct));	themeengine.current.colormenu = colorfromgdkcolor (style.bg [0]);	themeengine.current.colormenutext = colorfromgdkcolor (style.text [0]);	}	catch (dllnotfoundexception) {	}	catch {	
gtk colorscheme read failure using built in colorscheme 

themeengine.current.colormenu = colorfromgdkcolor (style.bg [0]);	themeengine.current.colormenutext = colorfromgdkcolor (style.text [0]);	}	catch (dllnotfoundexception) {	}	catch {	}	break;	}	case desktop.kde: {	
kde colorscheme read failure using built in colorscheme 

========================= mono sample_26280 =========================

public static void main () {	int a = 1;	s b = delegate {	float f = 1;	console.writeline (a);	if (f == 2) return;	};	b ();	
back got 

========================= mono sample_1977 =========================

public static int test_0_setjmp_exn_handler () {	intptr res;	caller.setup ();	voidvoiddelegate f = new voidvoiddelegate (caller.m);	try {	mono_test_setjmp_and_call (f, out res);	} catch (specialexn) {	
should not have caught a specialexn 

public static int test_0_setjmp_exn_handler () {	intptr res;	caller.setup ();	voidvoiddelegate f = new voidvoiddelegate (caller.m);	try {	mono_test_setjmp_and_call (f, out res);	} catch (specialexn) {	return 1;	}	if (!caller.called) {	
delegate not even called 

voidvoiddelegate f = new voidvoiddelegate (caller.m);	try {	mono_test_setjmp_and_call (f, out res);	} catch (specialexn) {	return 1;	}	if (!caller.called) {	return 2;	}	if (!caller.finally_called) {	
finally not reached 

} catch (specialexn) {	return 1;	}	if (!caller.called) {	return 2;	}	if (!caller.finally_called) {	return 3;	}	if (res == intptr.zero) {	
res should be a gchandle was 

if (!caller.finally_called) {	return 3;	}	if (res == intptr.zero) {	return 4;	}	gchandle h = gchandle.fromintptr (res);	object o = h.target;	h.free ();	if (o == null) {	
gchandle target was null 

return 4;	}	gchandle h = gchandle.fromintptr (res);	object o = h.target;	h.free ();	if (o == null) {	return 5;	}	else if (o is specialexn) return 0;	else {	
o was not a specialexn it is 

========================= mono sample_196 =========================

public void setlevel(int lvl) {	goodlength = deflaterconstants.good_length[lvl];	max_lazy   = deflaterconstants.max_lazy[lvl];	nicelength = deflaterconstants.nice_length[lvl];	max_chain  = deflaterconstants.max_chain[lvl];	if (deflaterconstants.compr_func[lvl] != comprfunc) {	if (deflaterconstants.debugging) {	
change from to 

========================= mono sample_30405 =========================

public static int main () {	if (!test<s> ()) return 1;	
ok 

========================= mono sample_1837 =========================

bool retval = true;	node[] nodes = new node[size + 2];	int i = 0;	node n = startsentinel;	while (n != null) {	nodes[i++] = n;	n = n.next;	}	foreach (linkedlist<t> view in views) {	if (!view.isvalid) {	
invalid view hash offset size 

while (n != null) {	nodes[i++] = n;	n = n.next;	}	foreach (linkedlist<t> view in views) {	if (!view.isvalid) {	retval = false;	continue;	}	if (view.offset > size || view.offset < 0) {	
bad view hash offset size offset underlying size 

}	foreach (linkedlist<t> view in views) {	if (!view.isvalid) {	retval = false;	continue;	}	if (view.offset > size || view.offset < 0) {	retval = false;	}	else if (view.startsentinel != nodes[view.offset]) {	
bad view hash offset size startsentinel should be 

retval = false;	continue;	}	if (view.offset > size || view.offset < 0) {	retval = false;	}	else if (view.startsentinel != nodes[view.offset]) {	retval = false;	}	if (view.offset + view.size > size || view.offset + view.size < 0) {	
bad view hash offset size end index underlying size 

if (view.offset > size || view.offset < 0) {	retval = false;	}	else if (view.startsentinel != nodes[view.offset]) {	retval = false;	}	if (view.offset + view.size > size || view.offset + view.size < 0) {	retval = false;	}	else if (view.endsentinel != nodes[view.offset + view.size + 1]) {	
bad view hash offset size endsentinel should be 

else if (view.startsentinel != nodes[view.offset]) {	retval = false;	}	if (view.offset + view.size > size || view.offset + view.size < 0) {	retval = false;	}	else if (view.endsentinel != nodes[view.offset + view.size + 1]) {	retval = false;	}	if (view.views != views) {	
bad view hash offset size wrong views list 

if (view.offset + view.size > size || view.offset + view.size < 0) {	retval = false;	}	else if (view.endsentinel != nodes[view.offset + view.size + 1]) {	retval = false;	}	if (view.views != views) {	retval = false;	}	if (view.underlying != this) {	
bad view hash offset size wrong underlying this 

if (startsentinel != null && startsentinel.next != endsentinel) {	console.writeline("size == 0 but startsentinel.next != endsentinel");	retval = false;	}	if (endsentinel != null && endsentinel.prev != startsentinel) {	console.writeline("size == 0 but endsentinel.prev != startsentinel");	retval = false;	}	}	if (startsentinel == null) {	
null startsentinel 

if (startsentinel == null) {	return retval;	}	int count = 0;	node node = startsentinel.next, prev = startsentinel;	#if hashindex int taggroupsize = 0, oldtaggroupsize = losize + 1, seentaggroups = 0;	taggroup oldtg = null;	if (underlying == null) {	taggroup tg = startsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.minvalue) {	
bad startsentinel tag group 

node node = startsentinel.next, prev = startsentinel;	#if hashindex int taggroupsize = 0, oldtaggroupsize = losize + 1, seentaggroups = 0;	taggroup oldtg = null;	if (underlying == null) {	taggroup tg = startsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.minvalue) {	retval = false;	}	tg = endsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.maxvalue) {	
bad endsentinel tag group 

retval = false;	}	tg = endsentinel.taggroup;	if (tg.count != 0 || tg.first != null || tg.last != null || tg.tag != int.maxvalue) {	retval = false;	}	}	#endif while (node != endsentinel) {	count++;	if (node.prev != prev) {	
bad backpointer at node 

oldtg = node.taggroup;	taggroupsize = 1;	}	else {	taggroupsize++;	}	}	#endif prev = node;	node = node.next;	if (node == null) {	
null next pointer at node 

retval = checkviews() && retval;	#if hashindex if (!retval) return false;	if (underlying == null) {	if (size != dict.count) {	console.writeline("list.size ({0}) != dict.count ({1})", size, dict.count);	retval = false;	}	node n = startsentinel.next, n2;	while (n != endsentinel) {	if (!dict.find(n.item, out n2)) {	
item in list but not dict 

if (size != dict.count) {	console.writeline("list.size ({0}) != dict.count ({1})", size, dict.count);	retval = false;	}	node n = startsentinel.next, n2;	while (n != endsentinel) {	if (!dict.find(n.item, out n2)) {	retval = false;	}	else if (n != n2) {	
wrong node in dict for item 

========================= mono sample_30545 =========================

public a (int value) : base (1) {	
int 

public a (uint value) : base (2) {	
uint 

public b (long value) : base (3) {	
long 

public b (ulong value) : base (4) {	
ulong 

public c (short value) : base (5) {	
short 

public c (ushort value) : base (6) {	
ushort 

public d (sbyte value) : base (7) {	
sbyte 

public d (byte value) : base (8) {	
byte 

public e (long value) : base (9) {	
long 

public e (e e) : base (10) {	
e 

public f (int value) : base (11) {	
int 

public f (f f) : base (12) {	
f 

public static int main () {	int result = test ();	
result 

========================= mono sample_3683 =========================

public static int main () {	object a = new s ();	receiver (new s ());	s s = plain ();	object o = boxs ();	if (a == null) return 1;	if (receive == false) return 2;	if (create == false) return 3;	if (create_and_box == false) return 4;	
test pass 

========================= mono sample_1557 =========================

if (throwexception) throw new applicationexception ();	} catch (applicationexception ex) {	console.writeline ("x1a");	++counter;	await call ();	console.writeline ("x2a");	++counter;	} catch {	throw;	}	
end 

await call ();	console.writeline ("x2a");	++counter;	} catch {	console.writeline ("x1b");	counter += 4;	await call ();	console.writeline ("x2b");	counter += 7;	}	
end 

========================= mono sample_4041 =========================

string failuremessage;	string stacktrace = null;	if (_transform.succeeded) {	try {	using (streamreader sr = new streamreader (_transform.testcase.outfile)) failuremessage = compareresult (_transform.result, sr.readtoend ().replace ("\r\n", "\n"), _transform.testcase.compare);	}	catch {	if (_expectedexception!=null) failuremessage = null;	else {	console.writeline (_transform.testcase.outfile);	
error no reference result and no expected exception 

========================= mono sample_22419 =========================

public void printa(a a) { a.print(); ((b)a).print(); }	public void run() {	
running thread 

public void printa(a a) { a.print(); ((b)a).print(); }	public void run() {	b b = new b();	int32 a=0;	for(int i = 0; i < 1000000; i++) {	a = inc2(a);	if(i % 100000 == 0) printa(b);	}	
ending thread 

========================= mono sample_141 =========================

public static int main () {	if (test2.foo.f != 10) return 1;	if (test2.foo.f2 != 9) return 1;	if (test3.foo.f != 10) return 1;	if (test3.foo.f2 != 9) return 1;	
ok 

========================= mono sample_1532 =========================

static void main() {	c a = new c { value = 12 };	fieldinfo info = typeof(c).getfield("value");	typedreference reference = __makeref(a);	if (!(reference is typedreference reference0)) throw new exception("typedreference");	info.setvaluedirect(reference0, 34);	console.writeline($"a.value = {a.value}");	if (a.value != 34) throw new exception("setvaluedirect");	int z = 56;	if (copyrefint(ref z) != 56) throw new exception("ref z");	
ok 

========================= mono sample_281 =========================

case performancecountertype.countermultitimer: return ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp - oldsample.timestamp) * 100.0f/newsample.basevalue;	case performancecountertype.countermultitimer100ns: return ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp100nsec - oldsample.timestamp100nsec) * 100.0f/newsample.basevalue;	case performancecountertype.countermultitimerinverse: return (newsample.basevalue - ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp - oldsample.timestamp)) * 100.0f;	case performancecountertype.countermultitimer100nsinverse: return (newsample.basevalue - ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp100nsec - oldsample.timestamp100nsec)) * 100.0f;	case performancecountertype.countertimer: case performancecountertype.countpertimeinterval32: case performancecountertype.countpertimeinterval64: return ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp - oldsample.timestamp);	case performancecountertype.countertimerinverse: return (1.0f - ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp100nsec - oldsample.timestamp100nsec)) * 100.0f;	case performancecountertype.elapsedtime: return 0;	case performancecountertype.timer100ns: return ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp - oldsample.timestamp) * 100.0f;	case performancecountertype.timer100nsinverse: return (1f - ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp - oldsample.timestamp)) * 100.0f;	case performancecountertype.rateofcountspersecond32: case performancecountertype.rateofcountspersecond64: return ((float)(newsample.rawvalue - oldsample.rawvalue))/(float)(newsample.timestamp - oldsample.timestamp) * 10000000;	
counter type not handled 

========================= mono sample_24061 =========================

public void dispose () {	
foo 

========================= mono sample_1601 =========================

public override void writeentry (string [] replacementstrings, eventlogentrytype type, uint instanceid, short category, byte [] rawdata) {	lock (lockobject) {	string logdir = findlogstore (coreeventlog.log);	int index = getlatestindex () + 1;	string logpath = path.combine (logdir, index.tostring (cultureinfo.invariantculture) + ".log");	try {	using (textwriter w = file.createtext (logpath)) {	
instanceid 

public override void writeentry (string [] replacementstrings, eventlogentrytype type, uint instanceid, short category, byte [] rawdata) {	lock (lockobject) {	string logdir = findlogstore (coreeventlog.log);	int index = getlatestindex () + 1;	string logpath = path.combine (logdir, index.tostring (cultureinfo.invariantculture) + ".log");	try {	using (textwriter w = file.createtext (logpath)) {	
entrytype 

public override void writeentry (string [] replacementstrings, eventlogentrytype type, uint instanceid, short category, byte [] rawdata) {	lock (lockobject) {	string logdir = findlogstore (coreeventlog.log);	int index = getlatestindex () + 1;	string logpath = path.combine (logdir, index.tostring (cultureinfo.invariantculture) + ".log");	try {	using (textwriter w = file.createtext (logpath)) {	
source 

public override void writeentry (string [] replacementstrings, eventlogentrytype type, uint instanceid, short category, byte [] rawdata) {	lock (lockobject) {	string logdir = findlogstore (coreeventlog.log);	int index = getlatestindex () + 1;	string logpath = path.combine (logdir, index.tostring (cultureinfo.invariantculture) + ".log");	try {	using (textwriter w = file.createtext (logpath)) {	
category 

public override void writeentry (string [] replacementstrings, eventlogentrytype type, uint instanceid, short category, byte [] rawdata) {	lock (lockobject) {	string logdir = findlogstore (coreeventlog.log);	int index = getlatestindex () + 1;	string logpath = path.combine (logdir, index.tostring (cultureinfo.invariantculture) + ".log");	try {	using (textwriter w = file.createtext (logpath)) {	
timegenerated 

public override void writeentry (string [] replacementstrings, eventlogentrytype type, uint instanceid, short category, byte [] rawdata) {	lock (lockobject) {	string logdir = findlogstore (coreeventlog.log);	int index = getlatestindex () + 1;	string logpath = path.combine (logdir, index.tostring (cultureinfo.invariantculture) + ".log");	try {	using (textwriter w = file.createtext (logpath)) {	
replacementstrings 

========================= mono sample_24030 =========================

if ((s & e) != null) return 14;	if ((s & e) != null) return 15;	var res1 = (e?) 1 == null;	if (res1) return 16;	var res2 = null == (e?) 1;	if (res2) return 17;	var r1 = a_n & e.v;	if (r1 != null) return 18;	var r2 = e.v & a_n;	if (r2 != null) return 19;	
ok 

========================= mono sample_3755 =========================

if (t.result != 2) return 3;	func<task<int>> f = async () => {	var tr = await task.factory.startnew (() => 1).configureawait (false);	if (tr == 1) return 3;	return 1;	};	var t2 = f ();	if (!task.waitall (new[] { t2 }, 3000)) return 4;	if (t2.status != taskstatus.rantocompletion) return 5;	if (t2.result != 3) return 6;	
ok 

========================= mono sample_1650 =========================

public static int main () {	x x = new x ();	x.test (1);	if (x.sbyte_selected){	
failed sbyte selected on constant int argument 

public static int main () {	x x = new x ();	x.test (1);	if (x.sbyte_selected){	return 1;	} else {	
ok int selected for constant int 

x x = new x ();	x.test (1);	if (x.sbyte_selected){	return 1;	} else {	}	x y = new x ();	sbyte s = 10;	y.test (s);	if (y.sbyte_selected){	
ok sbyte selected for sbyte argument 

x.test (1);	if (x.sbyte_selected){	return 1;	} else {	}	x y = new x ();	sbyte s = 10;	y.test (s);	if (y.sbyte_selected){	} else {	
failed sbyte not selected for sbyte argument 

========================= mono sample_1953 =========================

public rid submit(ip ip, int time) {	int jobcount = userjobs.containscount(ip);	rid rid = new rid();	job job = new job(rid, ip, time + 60 * jobcount);	ipriorityqueuehandle<job> h = null;	jobqueue.add(ref h, job);	userjobs.add(ip);	jobs.add(rid, h);	
submitted 

public job executeone() {	if (!jobqueue.isempty) {	job job = jobqueue.deletemin();	userjobs.remove(job.ip);	jobs.remove(job.rid);	
executed 

public void cancel(rid rid) {	ipriorityqueuehandle<job> h;	if (jobs.remove(rid, out h)) {	job job = jobqueue.delete(h);	userjobs.remove(job.ip);	
cancelled 

========================= mono sample_30561 =========================

ig.emit (opcodes.callvirt, foo_mb);	ig.emit (opcodes.ret);	iface.createtype ();	parent.createtype ();	child.createtype ();	type t = main.createtype ();	methodinfo method = t.getmethod ("main");	method.invoke (null, null);	type oi = gtd.makegenerictype (gtd.getgenericarguments ());	if (oi != gtd) {	
fully open instantiation of static type not the same of the generic type definition 

method.invoke (null, null);	type oi = gtd.makegenerictype (gtd.getgenericarguments ());	if (oi != gtd) {	return 1;	}	setup ();	typebuilder tb = module.definetype ("nullable`1", typeattributes.public);	type[] args = tb.definegenericparameters ("t");	type type = tb.makegenerictype (args);	if (type == tb) {	
fully open instantiation of typebuilder is the same of the typebuilder 

setup ();	typebuilder tb = module.definetype ("nullable`1", typeattributes.public);	type[] args = tb.definegenericparameters ("t");	type type = tb.makegenerictype (args);	if (type == tb) {	return 2;	}	type res = tb.createtype ();	type oires = res.makegenerictype (res.getgenericarguments ());	if (res != oires) {	
fully open instantiation not the same of the generic type definition for the typebuilder created type 

return 2;	}	type res = tb.createtype ();	type oires = res.makegenerictype (res.getgenericarguments ());	if (res != oires) {	return 3;	}	try {	type.getconstructors ();	} catch (exception e) {	
fully open instantiation of typebuilder must have getconstructors working 

return 3;	}	try {	type.getconstructors ();	} catch (exception e) {	return 4;	}	try {	oires.getconstructors ();	} catch (exception e) {	
fully open instantiation of the typebuilder created type must have getconstructors working 

========================= mono sample_363 =========================

public static void main (string[] args) {	if (args.length == 0) {	
usage mono tlsmulti exe url 

public static void main (string[] args) {	if (args.length == 0) {	return;	} else if (args.length > 64) {	
waithandle has a limit of handles so you cannot process urls 

public static void main (string[] args) {	if (args.length == 0) {	return;	} else if (args.length > 64) {	return;	}	alone = (args.length == 1);	servicepointmanager.certificatepolicy = new testcertificatepolicy ();	int id = 1;	foreach (string url in args) {	
get at 

private static void responsecallback (iasyncresult result) {	state state = ((state) result.asyncstate);	
end 

========================= mono sample_20579 =========================

public static int main () {	
from to 

========================= mono sample_1481 =========================

public void dump (textwriter tw) {	
top 

========================= mono sample_29794 =========================

public iasyncresult begindisplayinitializationui (iclientchannel channel, asynccallback callback, object state) {	
begin 

public void enddisplayinitializationui (iasyncresult result) {	
end 

public void displayinitializationui () {	
core 

========================= mono sample_31392 =========================

activitydesignertheme designertheme = e.designertheme;	ambienttheme ambienttheme = e.ambienttheme;	this.rootdesignerlayout.location = this.location;	this.rootdesignerlayout.onlayoutposition(graphics, designertheme, ambienttheme);	if (!this.hasactivedesigner) relocatestates();	base.onlayoutposition(e);	if (!this.hasactivedesigner && this.needsautolayout) repositionstates();	if (isrootdesigner && invokingdesigner == null) recalculaterootdesignersize();	}	#if debug catch (exception exception) {	
unhandled exception in onlayoutposition 

size newsize = base.onlayoutsize(e);	graphics graphics = e.graphics;	activitydesignertheme designertheme = e.designertheme;	ambienttheme ambienttheme = e.ambienttheme;	refreshrootdesignerlayout();	this.rootdesignerlayout.onlayoutsize(graphics, designertheme, ambienttheme, newsize);	_minimumsize = this.rootdesignerlayout.minimumsize;	return this.rootdesignerlayout.size;	#if debug }	catch (exception exception) {	
unhandled exception in onlayoutsize 

protected override void onpaint(activitydesignerpainteventargs e) {	graphics graphics = e.graphics;	activitydesignertheme designertheme = e.designertheme;	ambienttheme ambienttheme = e.ambienttheme;	#if debug try {	#endif this.rootdesignerlayout.onpaint(graphics, designertheme, ambienttheme);	this.paintcontaineddesigners(e);	#if debug }	catch (exception exception) {	
unhandled exception in onpaint 

if (transitioninfo.eventhandler != null) statedesignerconnector.eventhandlername = transitioninfo.eventhandler.qualifiedname;	}	finally {	this.rootstatedesigner.addingsetstate = true;	}	}	}	}	}	#if debug catch (exception exception) {	
unhandled exception in updateconnectors 

========================= mono sample_17033 =========================

webrequest req = webrequest.create ("gziphttp: webresponse wr = req.getresponse ();	stream st = wr.getresponsestream ();	byte [] b = new byte [4096];	long total = 0;	int count;	while ((count = st.read (b, 0, 4096)) != 0) {	console.write (encoding.default.getstring (b, 0, count));	total += count;	}	st.close ();	
content encoding if empty not compressed content encoding 

static void main (string [] args) {	if (args.length != 1) {	
you should provide a http url without http return 

========================= mono sample_4838 =========================

assertnode (xr, 2, xmlnodetype.element, "", "resolve", peerns, string.empty, "#16");	assert.istrue (xr.movetoattribute ("xmlns"), "#16-2");	assertnode (xr, 3, xmlnodetype.attribute, "", "xmlns", xmlnsns, peerns, "#17");	assert.istrue (xr.read (), "#17-2");	assertnode (xr, 3, xmlnodetype.element, "", "clientid", peerns, string.empty, "#18");	while (!xr.eof) {	xr.read ();	console.writeline ("{0}: {1}:{2} {3} {4}", xr.nodetype, xr.prefix, xr.localname, xr.namespaceuri, xr.value);	for (int i = 0; i < xr.attributecount; i++) {	xr.movetoattribute (i);	
attribute 

========================= mono sample_31283 =========================

public static void listfonts() {	fontcollection ifc = new installedfontcollection();	foreach( fontfamily ffm in ifc.families) {	try {	font f = new font(ffm.name,12);	
family name 

public static void checkfontproperties() {	font f = new font("arial",12);	
font size 

public static void checkfontproperties() {	font f = new font("arial",12);	f = new font("verdana", 12);	
font size 

public static void checkfontproperties() {	font f = new font("arial",12);	f = new font("verdana", 12);	f = new font("courier new", 12);	
font size 

public static void main( ) {	
fonts 

public static void main( ) {	listfonts();	
propierties 

public static void main( ) {	listfonts();	checkfontproperties();	
draw 

public static void main( ) {	listfonts();	checkfontproperties();	float width = 800.0f;	float height = 650.0f;	string str = "";	font f1 = new font("arial",12);	font f2 = new font("verdana", 12, fontstyle.bold);	font f3 = new font("courier new", 12, fontstyle.italic);	font f4  = new font(fontfamily.genericsansserif, 19, fontstyle.regular, graphicsunit.millimeter);	
font size points 

listfonts();	checkfontproperties();	float width = 800.0f;	float height = 650.0f;	string str = "";	font f1 = new font("arial",12);	font f2 = new font("verdana", 12, fontstyle.bold);	font f3 = new font("courier new", 12, fontstyle.italic);	font f4  = new font(fontfamily.genericsansserif, 19, fontstyle.regular, graphicsunit.millimeter);	font f5  = new font(fontfamily.genericserif, 15, fontstyle.regular, graphicsunit.point);	
font size points 

checkfontproperties();	float width = 800.0f;	float height = 650.0f;	string str = "";	font f1 = new font("arial",12);	font f2 = new font("verdana", 12, fontstyle.bold);	font f3 = new font("courier new", 12, fontstyle.italic);	font f4  = new font(fontfamily.genericsansserif, 19, fontstyle.regular, graphicsunit.millimeter);	font f5  = new font(fontfamily.genericserif, 15, fontstyle.regular, graphicsunit.point);	font f6  = new font("arial", 40, fontstyle.regular, graphicsunit.pixel);	
font size points 

float width = 800.0f;	float height = 650.0f;	string str = "";	font f1 = new font("arial",12);	font f2 = new font("verdana", 12, fontstyle.bold);	font f3 = new font("courier new", 12, fontstyle.italic);	font f4  = new font(fontfamily.genericsansserif, 19, fontstyle.regular, graphicsunit.millimeter);	font f5  = new font(fontfamily.genericserif, 15, fontstyle.regular, graphicsunit.point);	font f6  = new font("arial", 40, fontstyle.regular, graphicsunit.pixel);	font f7  = new font("courier new", 19, fontstyle.regular, graphicsunit.world);	
font size points 

float height = 650.0f;	string str = "";	font f1 = new font("arial",12);	font f2 = new font("verdana", 12, fontstyle.bold);	font f3 = new font("courier new", 12, fontstyle.italic);	font f4  = new font(fontfamily.genericsansserif, 19, fontstyle.regular, graphicsunit.millimeter);	font f5  = new font(fontfamily.genericserif, 15, fontstyle.regular, graphicsunit.point);	font f6  = new font("arial", 40, fontstyle.regular, graphicsunit.pixel);	font f7  = new font("courier new", 19, fontstyle.regular, graphicsunit.world);	font f8  = new font("courier new", 19, fontstyle.bold |  fontstyle.underline, graphicsunit.world);	
font size points 

string str = "";	font f1 = new font("arial",12);	font f2 = new font("verdana", 12, fontstyle.bold);	font f3 = new font("courier new", 12, fontstyle.italic);	font f4  = new font(fontfamily.genericsansserif, 19, fontstyle.regular, graphicsunit.millimeter);	font f5  = new font(fontfamily.genericserif, 15, fontstyle.regular, graphicsunit.point);	font f6  = new font("arial", 40, fontstyle.regular, graphicsunit.pixel);	font f7  = new font("courier new", 19, fontstyle.regular, graphicsunit.world);	font f8  = new font("courier new", 19, fontstyle.bold |  fontstyle.underline, graphicsunit.world);	font f9  = new font("courier new", 19, fontstyle.bold |  fontstyle.underline|  fontstyle.italic, graphicsunit.world);	
font size points 

font f1 = new font("arial",12);	font f2 = new font("verdana", 12, fontstyle.bold);	font f3 = new font("courier new", 12, fontstyle.italic);	font f4  = new font(fontfamily.genericsansserif, 19, fontstyle.regular, graphicsunit.millimeter);	font f5  = new font(fontfamily.genericserif, 15, fontstyle.regular, graphicsunit.point);	font f6  = new font("arial", 40, fontstyle.regular, graphicsunit.pixel);	font f7  = new font("courier new", 19, fontstyle.regular, graphicsunit.world);	font f8  = new font("courier new", 19, fontstyle.bold |  fontstyle.underline, graphicsunit.world);	font f9  = new font("courier new", 19, fontstyle.bold |  fontstyle.underline|  fontstyle.italic, graphicsunit.world);	font f10  = new font(fontfamily.genericsansserif, 14, fontstyle.strikeout, graphicsunit.millimeter);	
font size points 

========================= mono sample_21328 =========================

static void main(string[] args) {	try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	appsettingssection sect = (appsettingssection)config.getsection("appsettings");	console.writeline (sect.sectioninformation.getrawxml ());	foreach (string key in sect.settings.allkeys) {	console.writeline ("settings[{0}] = {1}", sect.settings[key].key, sect.settings[key].value);	}	}	catch (exception e) {	
exception raised 

========================= mono sample_29835 =========================

private static void addlistenercomponent(eventloginternal component, string compmachinename, string complogname) {	lock (internalsyncobject) {	
eventlog addlistenercomponent 

private static void addlistenercomponent(eventloginternal component, string compmachinename, string complogname) {	lock (internalsyncobject) {	loglisteninginfo info = (loglisteninginfo) listenerinfos[complogname];	if (info != null) {	
eventlog addlistenercomponent listener already active 

private void close(string currentmachinename) {	eventlogpermission permission = new eventlogpermission(eventlogpermissionaccess.write, currentmachinename);	permission.demand();	
eventlog close 

eventlogpermission permission = new eventlogpermission(eventlogpermissionaccess.write, currentmachinename);	permission.demand();	if (readhandle != null) {	try {	readhandle.close();	}	catch (ioexception) {	throw sharedutils.createsafewin32exception();	}	readhandle = null;	
eventlog close closed read handle 

readhandle = null;	}	if (writehandle != null) {	try {	writehandle.close();	}	catch (ioexception) {	throw sharedutils.createsafewin32exception();	}	writehandle = null;	
eventlog close closed write handle 

private void completioncallback(object context)  {	if (boolflags[flag_disposed]) {	return;	}	
eventlog completionstatuschanged starting at 

private void completioncallback(object context)  {	if (boolflags[flag_disposed]) {	return;	}	lock (instancelockobject) {	if (boolflags[flag_notifying]) {	
eventlog completionstatuschanged aborting because we re already notifying 

boolflags[flag_notifying] = true;	}	int i = lastseencount;	try {	int oldest = oldestentrynumber;	int count = entrycount + oldest;	if (lastseencount < oldest || lastseencount > count) {	lastseencount = oldest;	i = lastseencount;	}	
eventlog completionstatuschanged oldestentrynumber is entrycount is 

eventlogentry entry = getentrywitholdest(i);	if (this.synchronizingobject != null && this.synchronizingobject.invokerequired) this.synchronizingobject.begininvoke(this.onentrywrittenhandler, new object[]{this, new entrywritteneventargs(entry)});	else onentrywrittenhandler(this, new entrywritteneventargs(entry));	i++;	}	oldest = oldestentrynumber;	count = entrycount + oldest;	}	}	catch (exception e) {	
eventlog completionstatuschanged caught exception notifying event handlers 

oldest = oldestentrynumber;	count = entrycount + oldest;	}	}	catch (exception e) {	}	try {	int newcount = entrycount + oldestentrynumber;	if (i > newcount) lastseencount = newcount;	else lastseencount = i;	
eventlog completionstatuschanged finishing at 

}	}	catch (exception e) {	}	try {	int newcount = entrycount + oldestentrynumber;	if (i > newcount) lastseencount = newcount;	else lastseencount = i;	}	catch (win32exception e) {	
eventlog completionstatuschanged caught exception updating last entry number 

else {	flags = nativemethods.backwards_read | nativemethods.seek_read;	boolflags[flag_forwards] = false;	}	cache = new byte[buf_size];	int bytesread;	int minbytesneeded;	bool success = unsafenativemethods.readeventlog(readhandle, flags, index, cache, cache.length, out bytesread, out minbytesneeded);	if (!success) {	int error = marshal.getlastwin32error();	
error from readeventlog is 

private void openforread(string currentmachinename) {	
eventlog openforread 

private void openforwrite(string currentmachinename) {	if (this.boolflags[flag_disposed]) throw new objectdisposedexception(gettype().name);	
eventlog openforwrite 

private void reset(string currentmachinename) {	
eventlog reset 

private static void removelistenercomponent(eventloginternal component, string complogname) {	lock (internalsyncobject) {	
eventlog removelistenercomponent 

private static void staticcompletioncallback(object context, bool wassignaled) {	loglisteninginfo info = (loglisteninginfo) context;	if (info == null) return;	eventloginternal[] interestedcomponents;	lock (internalsyncobject) {	interestedcomponents = (eventloginternal[])info.listeningcomponents.toarray(typeof(eventloginternal));	}	
eventlog staticcompletioncallback notifying components 

eventloginternal[] interestedcomponents;	lock (internalsyncobject) {	interestedcomponents = (eventloginternal[])info.listeningcomponents.toarray(typeof(eventloginternal));	}	for (int i = 0; i < interestedcomponents.length; i++) {	try {	if (interestedcomponents[i] != null) {	interestedcomponents[i].completioncallback(null);	}	} catch (objectdisposedexception) {	
eventlog staticcompletioncallback ignored an objectdisposedexception 

========================= mono sample_12465 =========================

public override void renderbegintag (htmltextwriter w) {	
renderbegintag 

protected internal override void rendercontents (htmltextwriter w) {	
rendercontents 

public override void renderendtag (htmltextwriter w) {	
renderendtag 

========================= mono sample_19092 =========================

public static void savemetadatatofile (string filename, metadataset metadata) {	if (file.exists (filename)) return;	using (var file = new streamwriter (filename, false)) {	var writer = new xmltextwriter (file);	writer.formatting = formatting.indented;	metadata.writeto (writer);	}	
exported 

========================= mono sample_31361 =========================

public static int main() {	testclass ts = new testclass ();	ts.conditionalmethod ();	
succeeded 

========================= mono sample_2155 =========================

protected internal override void render (htmltextwriter writer) {	if (supportspartialrendering) {	writer.writeline ("<script type=\"text/javascript\">");	
writer writeline uniqueid page form clientid 

protected internal override void render (htmltextwriter writer) {	if (supportspartialrendering) {	writer.writeline ("<script type=\"text/javascript\">");	
sys webforms pagerequestmanager getinstance get updatecontrols 

protected internal override void render (htmltextwriter writer) {	if (supportspartialrendering) {	writer.writeline ("<script type=\"text/javascript\">");	
sys webforms pagerequestmanager getinstance updatecontrols 

protected internal override void render (htmltextwriter writer) {	if (supportspartialrendering) {	writer.writeline ("<script type=\"text/javascript\">");	
writer writeline 

========================= mono sample_31126 =========================

private void intellisensetextbox_keydown(object sender, keyeventargs e) {	string currentvalue = this.text;	int selectionstart = this.selectionstart;	int selectionlength = this.selectionlength;	stringbuilder removedstring = new stringbuilder(currentvalue.substring(selectionstart, selectionlength));	stringbuilder projectedvalue = new stringbuilder(currentvalue.substring(0, selectionstart));	projectedvalue.append(currentvalue.substring(selectionstart + selectionlength));	
keycode keydata keyvalue 

========================= mono sample_17116 =========================

static int main() {	char[] chars = new char[]	{'0',  'f',  'f',  'x',   '1',  'n',   'a'};	bool[] results = new bool[]	{true, false, false, false, true, false, false};	for (int i = 0; i < chars.length; ++i) {	if (char.isnumber (chars [i]) != results [i]) {	
char failed 

========================= mono sample_508 =========================

if (new b () != "b-struct" || b.counter != 3) return 2;	if (new b () == null || b.counter != 4) {	}	if (new d () != new d () || d.counter != 2) return 10;	if (new d () != null || d.counter != 3) {	}	if (new a () != "a-class" || a.counter != 1) return 20;	if (new a () == null  || a.counter != 1) return 21;	if (new e () != new e ()  || e.counter != 2) return 31;	if (new f () == new f ()) return 40;	
ok 

========================= mono sample_2083 =========================

public static int main (string[] args) {	int c = 0;	try {	try {	c = 0;	}	catch (exception e) {	
exception 

public static int main (string[] args) {	int c = 0;	try {	try {	c = 0;	}	catch (exception e) {	}	finally {	
finally 

========================= mono sample_419 =========================

r = func (10);	console.writeline ("should be 11={0}", r);	if (r != 11) return 2;	nothing = (int x) => { y = x; };	nothing (10);	console.writeline ("should be 10={0}", y);	if (y != 10) return 3;	nothing = (int x) => { new x (x); };	nothing (314);	if (instantiated_value != 314) return 4;	
all tests pass 

========================= mono sample_2192 =========================

static void main () {	while (true) {	try {	
trying 

========================= mono sample_33072 =========================

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	
start returns 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	
process is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	
pid is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	
handle is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	
handlecount is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	
writing foo bar 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	
foo bar 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	
writing wibble wobble 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	
wibble wobble 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	system.threading.thread.sleep(1000);	
closing stdin 

process proc = new process();	bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	system.threading.thread.sleep(1000);	proc.standardinput.close();	
waiting for exit 

bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	system.threading.thread.sleep(1000);	proc.standardinput.close();	proc.waitforexit();	
wait returned 

bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	system.threading.thread.sleep(1000);	proc.standardinput.close();	proc.waitforexit();	
exit code is 

bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	system.threading.thread.sleep(1000);	proc.standardinput.close();	proc.waitforexit();	
process started at 

bool ret;	proc.startinfo.filename="wibble-redir";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	proc.startinfo.redirectstandardinput=true;	ret=proc.start();	system.threading.thread.sleep(1000);	system.threading.thread.sleep(1000);	proc.standardinput.close();	proc.waitforexit();	
process ended at 

========================= mono sample_559 =========================

public bool add (string name) {	assemblydefinition ass = loadassembly (name);	if (ass == null) {	
cannot load assembly file 

========================= mono sample_1308 =========================

static void main(string[] args) {	try {	_configuration cfg = configurationmanager.openexeconfiguration (configurationuserlevel.none);	compilationsection section = (compilationsection)cfg.getsection ("system.web/compilation");	section = (compilationsection)cfg.getsection ("system.web/compilation");	
there are assemblies listed in the section 

========================= mono sample_29850 =========================

onlyclients.setattributevalue ("key", "onlyclients");	appsettings.add (onlyclients);	}	else throw new exception ("too many onlyclients appsettings clauses");	if (mode == "client") onlyclients.setattributevalue("value","true");	else if (mode == "inproc") onlyclients.setattributevalue ("value", "false");	else {	throw new exception ("unrecognized mode: " + mode);	}	config.save (file,saveoptions.disableformatting);	
successfully switched to mode 

========================= mono sample_31355 =========================

public void definefilterbodywithtypenotnull () {	definebasicmethod ();	il_gen.beginexceptionblock ();	
in try 

public void definefilterbodywithtypenotnull () {	definebasicmethod ();	il_gen.beginexceptionblock ();	il_gen.beginexceptfilterblock ();	
in filter head 

public void definefilterbodywithtypenotnull () {	definebasicmethod ();	il_gen.beginexceptionblock ();	il_gen.beginexceptfilterblock ();	il_gen.begincatchblock (typeof (exception));	
in filter body 

========================= mono sample_27581 =========================

public static void main (string[] args) {	string filename = ((args.length > 0) ? args[0] : null);	if ((filename != null) && (file.exists (filename))) new gtkcertificateviewer (filename);	else {	header ();	
usage mono gcertview exe certificate cer 

========================= mono sample_1188 =========================

private void dumpmap (iimmutablemap<symbolicvalue, sequence<symbolicvalue>> sourcetargetmap) {	
source target assignment 

private void dumpexpressions (string header, exprdomain<symbolicvalue> state) {	console.writeline ("--- {0} ---", header);	foreach (symbolicvalue index in state.keys) {	flatdomain<expr<symbolicvalue>> domain = state [index];	if (domain.isnormal()) console.writeline ("{0} -> {1}", index, domain.value);	
top 

private void dumpexpressions (string header, exprdomain<symbolicvalue> state) {	console.writeline ("--- {0} ---", header);	foreach (symbolicvalue index in state.keys) {	flatdomain<expr<symbolicvalue>> domain = state [index];	if (domain.isnormal()) console.writeline ("{0} -> {1}", index, domain.value);	
bot 

========================= mono sample_29493 =========================

public static void runtests () {	string assembly = file.readalltext ($"{appdomain.currentdomain.basedirectory}/testassembly.txt");	
testing assembly 

========================= mono sample_33 =========================

public bool generate () {	if (opts.output == null){	opts.output = ".";	}	if (opts.assembly == null){	
error no assembly to macpack was specified 

usage ();	return false;	}	if (opts.appname == null){	string t = path.changeextension (opts.assembly, null);	int p = t.indexof (path.directoryseparatorchar);	if (p != -1) t = t.substring (p+1);	opts.appname = t;	}	if (directory.exists (path.combine (opts.output, string.format ("{0}.app", opts.appname)))) {	
error that application already exists please delete it first 

directory.createdirectory (path.combine (opts.output, string.format ("{0}.app/contents/resources", opts.appname)));	if (opts.resource != null) {	foreach (string res in opts.resource) {	try {	if (directory.exists (res)) {	copydirectory (res, path.combine (opts.output, string.format ("{0}.app/contents/resources/{1}", opts.appname, path.getfilename (res))));	} else {	file.copy (res, path.combine (opts.output, string.format ("{0}.app/contents/resources/{1}", opts.appname, path.getfilename (res))));	}	} catch  (exception e){	
error while processing details 

script = script.replace ("%x11_mode%", "1");	script = script.replace ("%mono_args%", "");	break;	}	data = encoding.ascii.getbytes (script);	writer.write (data, 0, data.length);	writer.close ();	try {	chmod (path.combine (opts.output, string.format ("{0}.app/contents/macos/{0}", opts.appname)), convert.touint32 ("755", 8));	} catch {	
warning it was not possible to set the executable permissions on the file app contents macos the bundle might not work 

static void usage () {	
usage is macpack options assembly n appname appname appname application name o output output output output directory a assembly assembly to pack i file icon file icon filename r additional files to bundle m winforms cocoa console the mode for the application 

case "-n": case "-appname": options.appname = value;	break;	case "-o": case "-output": options.output = value;	break;	case "-a": case "-assembly": options.assembly = value;	break;	case "-i": case "-icon": options.icon = value;	break;	case "-r": case "-resource": foreach (string ss in value.split (new char [] {','})) resources.add (ss);	break;	
about macpack by geoff norton 

break;	case "x11": options.mode = 3;	break;	case "console": options.mode = 0;	break;	case "cocoa": options.mode = 2;	break;	default: try {	options.mode = int32.parse (value);	} catch {	
could not recognize option as the mode 

========================= mono sample_1208 =========================

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
regex match timeout occurred 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
specified timeout 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
timeout check frequency 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
search pattern 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
input 

private void dochecktimeout() {	int currentmillis = environment.tickcount;	if (currentmillis < timeoutoccursat) return;	if (0 > timeoutoccursat && 0 < currentmillis) return;	#if dbg if (runregex.debug) {	debug.writeline("");	
about to throw regexmatchtimeoutexception 

========================= mono sample_11769 =========================

public object call(string typename, string methodname, object[] args) {	type type = this.assembly.gettype (typename);	if (type == null) {	
cannot get type 

public object call(string typename, string methodname, object[] args) {	type type = this.assembly.gettype (typename);	if (type == null) {	}	var method = type.getmethod (methodname, bindingflags.public | bindingflags.nonpublic | bindingflags.static);	if (method == null) {	
cannot get method 

========================= mono sample_29482 =========================

static int main(string[] args) {	string cmd = environment.getcommandlineargs () [0];	string tool = path.getfilename(cmd);	string profile = path.getdirectoryname(cmd);	int p = profile.lastindexof('\\');	if (p == -1) {	
could not find the profile name from this 

string cmd = environment.getcommandlineargs () [0];	string tool = path.getfilename(cmd);	string profile = path.getdirectoryname(cmd);	int p = profile.lastindexof('\\');	if (p == -1) {	return 1;	}	profile = profile.substring(p+1);	var root_mono = path.getfullpath(path.combine(path.getdirectoryname(cmd), "..\\..\\.."));	if (!file.exists(path.combine(root_mono, "mono\\mini\\mini.c"))) {	
my root is incorrect based on 

string cmd = environment.getcommandlineargs () [0];	string tool = path.getfilename(cmd);	string profile = path.getdirectoryname(cmd);	int p = profile.lastindexof('\\');	if (p == -1) {	return 1;	}	profile = profile.substring(p+1);	var root_mono = path.getfullpath(path.combine(path.getdirectoryname(cmd), "..\\..\\.."));	if (!file.exists(path.combine(root_mono, "mono\\mini\\mini.c"))) {	
must be in mono msvc scripts profile command exe 

if (p == -1) {	return 1;	}	profile = profile.substring(p+1);	var root_mono = path.getfullpath(path.combine(path.getdirectoryname(cmd), "..\\..\\.."));	if (!file.exists(path.combine(root_mono, "mono\\mini\\mini.c"))) {	return 1;	}	p = profile.lastindexof ('-');	if (p == -1){	
the directory holding this executable should be mpaths compiler instead it is 

case "net_1_1": compiler = root_mcs + "\\class\\lib\\net_1_1\\mcs.exe";	break;	case "net_2_0_bootstrap": compiler = root_mcs + "\\class\\lib\\net_2_0_bootstrap\\gmcs.exe";	break;	case "gmcs": case "mcs": compiler = root_mcs + "\\mcs\\gmcs.exe";	break;	case "moonlight_bootstrap": compiler = root_mcs + "\\class\\lib\\moonlight_bootstrap\\smcs.exe";	break;	case "moonlight_raw": compiler = root_mcs + "\\class\\lib\\moonlight_raw\\smcs.exe";	break;	
unknown compiler configuration 

break;	return 1;	}	var paths = profile.substring (0, p).split (new char [] { '-' });	stringbuilder sb = new stringbuilder ();	foreach (string dir in paths){	if (sb.length != 0) sb.append (";");	sb.append (root_mcs + "\\class\\lib\\" + dir);	}	environment.setenvironmentvariable ("mono_path", sb.tostring ());	
compiler 

break;	return 1;	}	var paths = profile.substring (0, p).split (new char [] { '-' });	stringbuilder sb = new stringbuilder ();	foreach (string dir in paths){	if (sb.length != 0) sb.append (";");	sb.append (root_mcs + "\\class\\lib\\" + dir);	}	environment.setenvironmentvariable ("mono_path", sb.tostring ());	
mono path 

sb.append (root_mcs + "\\class\\lib\\" + dir);	}	environment.setenvironmentvariable ("mono_path", sb.tostring ());	var pi = new processstartinfo() {	filename = mono_cmd, windowstyle = processwindowstyle.hidden, arguments = compiler + " " + string.join (" ", args), useshellexecute = false };	try {	var proc = process.start (pi);	proc.waitforexit ();	return proc.exitcode;	} catch (system.componentmodel.win32exception){	
chances are it did not find 

========================= mono sample_22 =========================

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	}	catch (configurationerrorsexception e) {	
configuration exception thrown 

static void main(string[] args) {	try {	namevaluecollection appsettings = configurationmanager.appsettings;	}	catch (configurationerrorsexception e) {	return;	}	
configuration exception not thrown 

========================= mono sample_29810 =========================

try {	configuration config = configurationmanager.openexeconfiguration (configurationuserlevel.none);	connectionstringssection sect = config.connectionstrings;	connectionstringsettingscollection connectionstrings = sect.connectionstrings;	connectionstrings.add (new connectionstringsettings ("fromtest", "connectionstringhere"));	foreach (connectionstringsettings cs in connectionstrings) {	console.writeline ("connectionstring[{0}] = `{1}',`{2}'", cs.name, cs.providername, cs.connectionstring);	}	}	catch (exception e) {	
raised 

========================= mono sample_29841 =========================

public void add (xelement source, xelement target, apichange change) {	if (!change.anychange) {	if (!change.hasignoredchanges) {	var isfield = source.name.localname == "field";	if (isfield) {	
comparison resulting in no changes src dst 

public void add (xelement source, xelement target, apichange change) {	if (!change.anychange) {	if (!change.hasignoredchanges) {	var isfield = source.name.localname == "field";	if (isfield) {	} else {	
comparison resulting in no changes src dst 

========================= mono sample_1319 =========================

private void thread_func() {	
in a thread 

private void thread_func() {	thread thr=thread.currentthread;	
locking thr for 

private void thread_func() {	thread thr=thread.currentthread;	lock(thr) {	
locked 

private void thread_func() {	thread thr=thread.currentthread;	lock(thr) {	thread.sleep(2000);	
slept for 

private void thread_func() {	thread thr=thread.currentthread;	lock(thr) {	thread.sleep(2000);	thread.sleep(15000);	}	
waiting for signal 

private void thread_func() {	thread thr=thread.currentthread;	lock(thr) {	thread.sleep(2000);	thread.sleep(15000);	}	lock(thr) {	
waiting 

private void thread_func() {	thread thr=thread.currentthread;	lock(thr) {	thread.sleep(2000);	thread.sleep(15000);	}	lock(thr) {	monitor.wait(thr);	
thread signalled 

private void thread_func() {	thread thr=thread.currentthread;	lock(thr) {	thread.sleep(2000);	thread.sleep(15000);	}	lock(thr) {	monitor.wait(thr);	}	
sleeping for 

private void thread_func() {	thread thr=thread.currentthread;	lock(thr) {	thread.sleep(2000);	thread.sleep(15000);	}	lock(thr) {	monitor.wait(thr);	}	thread.sleep(2000);	
leaving thread 

public static int main () {	
hello world 

public static int main () {	thread thr=new thread(new threadstart(new test().thread_func));	thr.start();	thread.sleep(1000);	
trying to enter lock 

public static int main () {	thread thr=new thread(new threadstart(new test().thread_func));	thr.start();	thread.sleep(1000);	if(monitor.tryenter(thr, 1000)==true) {	
returned lock 

public static int main () {	thread thr=new thread(new threadstart(new test().thread_func));	thr.start();	thread.sleep(1000);	if(monitor.tryenter(thr, 1000)==true) {	monitor.exit(thr);	} else {	
didn t get lock 

thread thr=new thread(new threadstart(new test().thread_func));	thr.start();	thread.sleep(1000);	if(monitor.tryenter(thr, 1000)==true) {	monitor.exit(thr);	} else {	}	thread.sleep(20000);	lock(thr) {	monitor.pulse(thr);	
signalled thread 

========================= mono sample_548 =========================

static void unloadhook (object obj, eventargs args) {	manualresetevent evt = new manualresetevent (false);	
on the unloadhook 

static void unloadhook (object obj, eventargs args) {	manualresetevent evt = new manualresetevent (false);	if (environment.hasshutdownstarted) throw new exception ("environment.hasshutdownstarted must not be true");	action<int> f = (int x) => {	evt.waitone (1000);	evt.set ();	};	f.begininvoke (1, null, null);	evt.waitone ();	
hook done 

static void otherdomain() {	appdomain app = appdomain.currentdomain;	
now i m on 

static int main () {	appdomain app = appdomain.createdomain ("foo");	
i m on 

========================= mono sample_408 =========================

public static void main(string[] args) {	
calling printname 

public static void main(string[] args) {	mytestextended test = new mytestextended();	test.printname();	
out of printname 

========================= mono sample_34603 =========================

static int test_0_root_keeps_child () {	
test root keeps child 

static int test_0_root_keeps_child () {	finalizerhelpers.performnopinaction (setuplinks);	gc.collect ();	gc.waitforpendingfinalizers ();	
try get a 

static int test_0_root_keeps_child () {	finalizerhelpers.performnopinaction (setuplinks);	gc.collect ();	gc.waitforpendingfinalizers ();	
try get b 

static int test_0_root_keeps_child () {	finalizerhelpers.performnopinaction (setuplinks);	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	
a test 

static int test_0_root_keeps_child () {	finalizerhelpers.performnopinaction (setuplinks);	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	
b test 

gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	a.link.clear ();	b.__test = toggleref.strong;	a = b = null;	gc.collect ();	gc.waitforpendingfinalizers ();	
try get a 

gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	a.link.clear ();	b.__test = toggleref.strong;	a = b = null;	gc.collect ();	gc.waitforpendingfinalizers ();	
try get b 

console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	a.link.clear ();	b.__test = toggleref.strong;	a = b = null;	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 2;	
a test 

console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 1;	a.link.clear ();	b.__test = toggleref.strong;	a = b = null;	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b == null) return 2;	
b test 

static int test_0_child_goes_away () {	
test child goes away 

static int test_0_child_goes_away () {	finalizerhelpers.performnopinaction (setuplinks2);	gc.collect ();	gc.waitforpendingfinalizers ();	
try get a 

static int test_0_child_goes_away () {	finalizerhelpers.performnopinaction (setuplinks2);	gc.collect ();	gc.waitforpendingfinalizers ();	
try get b 

static int test_0_child_goes_away () {	finalizerhelpers.performnopinaction (setuplinks2);	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b != null) return 1;	
a test 

static int test_0_cwt_keep_child_alive () {	
test cwt keep child alive 

static int test_0_cwt_keep_child_alive () {	finalizerhelpers.performnopinaction (setuplinks3);	gc.collect ();	gc.waitforpendingfinalizers ();	
try get a 

static int test_0_cwt_keep_child_alive () {	finalizerhelpers.performnopinaction (setuplinks3);	gc.collect ();	gc.waitforpendingfinalizers ();	
try get b 

static int test_0_cwt_keep_child_alive () {	finalizerhelpers.performnopinaction (setuplinks3);	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b != null) return 1;	
a test 

static int test_0_cwt_keep_child_alive () {	finalizerhelpers.performnopinaction (setuplinks3);	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b != null) return 1;	
try get a val 

static int test_0_cwt_keep_child_alive () {	finalizerhelpers.performnopinaction (setuplinks3);	gc.collect ();	gc.waitforpendingfinalizers ();	console.writeline ("a is null {0}", a == null);	console.writeline ("b is null {0}", b == null);	if (a == null || b != null) return 1;	
try get v val 

========================= mono sample_688 =========================

static unsafe int test (sbyte* x) {	if ((x + 1) < x) {	
ok 

static unsafe int test (sbyte* x) {	if ((x + 1) < x) {	return 0;	} else {	
bad 

========================= mono sample_2243 =========================

static void onfilechanged(object sender, filesystemeventargs args) {	if (httpruntime.domainunloading) return;	string name = args.name;	bool isconfig = false;	if (strutils.endswith (name, "onfig", true)) {	if (string.compare (path.getfilename (name), "web.config", true, helpers.invariantculture) != 0) return;	isconfig = true;	} else if (strutils.endswith (name, "lobal.asax", true) && string.compare (name, "global.asax", true, helpers.invariantculture) != 0) return;	
change 

========================= mono sample_20004 =========================

public static int main () {	methodinfo mi = typeof (c<>).getmethod ("foo");	object[] a = mi.getcustomattributes (false);	if (((testattribute)a[0]).type.tostring() != "c`1[system.string]") return 1;	
ok 

========================= mono sample_2284 =========================

gr.drawrectangle( new pen(color.blue), rect6);	solidbrush solid  =  new solidbrush(color.blue);	gr.drawstring("samples of text with different fonts and formatting", new font("verdana",16), new solidbrush(color.white), new rectangle (5,5,600,100), strfmttxt);	gr.fillellipse(solid, rect1);	gr.drawrectangle( new pen(color.green), rect2);	gr.drawrectangle( new pen(color.green), rect7);	str = "ara que tinc &vint anys, ara que encara tinc força,que no tinc l'ànima morta, i em sento bullir la sang. (" + f1.name + ")";	gr.drawstring( str,	f1, new solidbrush(color.white), rect1, strfmt1);	gr.drawstring(flagprocessing(strfmt1), fonttxt, brushtxt, calcrect(rect1), strfmttxt);	sz =  gr.measurestring (str, f1, new sizef (rect1.width, rect1.height), strfmt1, out chars, out lines);	
measurestring chars lines 

gr.drawrectangle( new pen(color.green), rect2);	gr.drawrectangle( new pen(color.green), rect7);	str = "ara que tinc &vint anys, ara que encara tinc força,que no tinc l'ànima morta, i em sento bullir la sang. (" + f1.name + ")";	gr.drawstring( str,	f1, new solidbrush(color.white), rect1, strfmt1);	gr.drawstring(flagprocessing(strfmt1), fonttxt, brushtxt, calcrect(rect1), strfmttxt);	sz =  gr.measurestring (str, f1, new sizef (rect1.width, rect1.height), strfmt1, out chars, out lines);	str = "ara que em sento capaç de cantar si un altre canta. avui que encara tinc veu i encara puc creure en déus (" + f2.name + ")";	gr.drawstring(str, f2, new solidbrush(color.red),rect2, strfmt2);	gr.drawstring(flagprocessing(strfmt2), fonttxt, brushtxt, calcrect(rect2), strfmttxt);	sz =  gr.measurestring (str, f2, new sizef (rect2.width, rect2.height), strfmt2, out chars, out lines);	
measurestring chars lines 

gr.drawstring(flagprocessing(strfmt1), fonttxt, brushtxt, calcrect(rect1), strfmttxt);	sz =  gr.measurestring (str, f1, new sizef (rect1.width, rect1.height), strfmt1, out chars, out lines);	str = "ara que em sento capaç de cantar si un altre canta. avui que encara tinc veu i encara puc creure en déus (" + f2.name + ")";	gr.drawstring(str, f2, new solidbrush(color.red),rect2, strfmt2);	gr.drawstring(flagprocessing(strfmt2), fonttxt, brushtxt, calcrect(rect2), strfmttxt);	sz =  gr.measurestring (str, f2, new sizef (rect2.width, rect2.height), strfmt2, out chars, out lines);	str = "vull cantar a les pedres, la terra, l'aigua, al blat i al camí, que vaig trepitjant. (" + f3.name + ")";	gr.drawstring(str,f3, new solidbrush(color.white), rect3, strfmt3);	gr.drawstring(flagprocessing(strfmt3), fonttxt, brushtxt, calcrect(rect3), strfmttxt);	sz =  gr.measurestring (str, f3, new sizef (rect3.width, rect3.height), strfmt3, out chars, out lines);	
measurestring chars lines 

gr.drawstring(flagprocessing(strfmt2), fonttxt, brushtxt, calcrect(rect2), strfmttxt);	sz =  gr.measurestring (str, f2, new sizef (rect2.width, rect2.height), strfmt2, out chars, out lines);	str = "vull cantar a les pedres, la terra, l'aigua, al blat i al camí, que vaig trepitjant. (" + f3.name + ")";	gr.drawstring(str,f3, new solidbrush(color.white), rect3, strfmt3);	gr.drawstring(flagprocessing(strfmt3), fonttxt, brushtxt, calcrect(rect3), strfmttxt);	sz =  gr.measurestring (str, f3, new sizef (rect3.width, rect3.height), strfmt3, out chars, out lines);	str = "a la nit, al cel i a aquet mar tan nostre i al vent que al matí ve a besar-me el rostre (" + f4.name + ")";	gr.drawstring(str, f4, new solidbrush(color.red),rect4, strfmt4);	gr.drawstring(flagprocessing(strfmt4), fonttxt, brushtxt, calcrect(rect4), strfmttxt);	sz =  gr.measurestring (str, f4, new sizef (rect4.width, rect4.height), strfmt4, out chars, out lines);	
measurestring chars lines 

gr.drawstring(flagprocessing(strfmt3), fonttxt, brushtxt, calcrect(rect3), strfmttxt);	sz =  gr.measurestring (str, f3, new sizef (rect3.width, rect3.height), strfmt3, out chars, out lines);	str = "a la nit, al cel i a aquet mar tan nostre i al vent que al matí ve a besar-me el rostre (" + f4.name + ")";	gr.drawstring(str, f4, new solidbrush(color.red),rect4, strfmt4);	gr.drawstring(flagprocessing(strfmt4), fonttxt, brushtxt, calcrect(rect4), strfmttxt);	sz =  gr.measurestring (str, f4, new sizef (rect4.width, rect4.height), strfmt4, out chars, out lines);	str = "vull cantar a les pedres, la terra, l'aigua, al blat i al camí, que vaig trepitjant. (" + f5.name + ")";	gr.drawstring(str, f5, new solidbrush(color.white), rect5, strfmt5);	gr.drawstring(flagprocessing(strfmt5), fonttxt, brushtxt, calcrect(rect5), strfmttxt);	sz =  gr.measurestring (str, f5, new sizef (rect5.width, rect5.height), strfmt5, out chars, out lines);	
measurestring chars lines 

gr.drawstring(flagprocessing(strfmt4), fonttxt, brushtxt, calcrect(rect4), strfmttxt);	sz =  gr.measurestring (str, f4, new sizef (rect4.width, rect4.height), strfmt4, out chars, out lines);	str = "vull cantar a les pedres, la terra, l'aigua, al blat i al camí, que vaig trepitjant. (" + f5.name + ")";	gr.drawstring(str, f5, new solidbrush(color.white), rect5, strfmt5);	gr.drawstring(flagprocessing(strfmt5), fonttxt, brushtxt, calcrect(rect5), strfmttxt);	sz =  gr.measurestring (str, f5, new sizef (rect5.width, rect5.height), strfmt5, out chars, out lines);	str = "ve a besar-me el rostre (" + f6.name + ")";	gr.drawstring(str, 	f6, new solidbrush(color.red),rect6, strfmt6);	gr.drawstring(flagprocessing(strfmt6), fonttxt, brushtxt, calcrect(rect6), strfmttxt);	sz =  gr.measurestring (str, f6, new sizef (rect6.width, rect6.height), strfmt6, out chars, out lines);	
measurestring chars lines 

gr.drawstring(flagprocessing(strfmt5), fonttxt, brushtxt, calcrect(rect5), strfmttxt);	sz =  gr.measurestring (str, f5, new sizef (rect5.width, rect5.height), strfmt5, out chars, out lines);	str = "ve a besar-me el rostre (" + f6.name + ")";	gr.drawstring(str, 	f6, new solidbrush(color.red),rect6, strfmt6);	gr.drawstring(flagprocessing(strfmt6), fonttxt, brushtxt, calcrect(rect6), strfmttxt);	sz =  gr.measurestring (str, f6, new sizef (rect6.width, rect6.height), strfmt6, out chars, out lines);	str = "vull plorar amb aquells que es troben tots sols, sense cap amor van passant pel món.. (" + f5.name + ")";	gr.drawstring(str, f5, new solidbrush(color.white), rect7, strfmt4);	gr.drawstring(flagprocessing(strfmt4), fonttxt, brushtxt, calcrect(rect7), strfmttxt);	sz =  gr.measurestring (str, f5, new sizef (rect7.width, rect7.height), strfmt5, out chars, out lines);	
measurestring chars lines 

========================= mono sample_21339 =========================

public symgraph<tfunc, tadomain> join (symgraph<tfunc, tadomain> that, out imergeinfo mergeinfo, bool widen) {	symgraph<tfunc, tadomain> egraph = this;	int updatesize;	symgraph<tfunc, tadomain> commontail = computecommontail (egraph, that, out updatesize);	bool hascommontail = commontail != null;	bool doingincrementaljoin = hascommontail & commontail != egraph.root_graph & !widen & doincrementaljoin;	if (debugoptions.debug) {	
symgraph widen join 

public symgraph<tfunc, tadomain> join (symgraph<tfunc, tadomain> that, out imergeinfo mergeinfo, bool widen) {	symgraph<tfunc, tadomain> egraph = this;	int updatesize;	symgraph<tfunc, tadomain> commontail = computecommontail (egraph, that, out updatesize);	bool hascommontail = commontail != null;	bool doingincrementaljoin = hascommontail & commontail != egraph.root_graph & !widen & doincrementaljoin;	if (debugoptions.debug) {	if (commontail != null) console.writeline ("last common symbol: {0}", commontail.lastsymbolid);	
doing incremental join full join 

} else {	result = new symgraph<tfunc, tadomain> (commontail);	mergestate = new mergeinfo<tfunc, tadomain> (result, egraph, that, widen);	mergestate.replayeliminations (commontail);	mergestate.addmapping (egraph.const_root, that.const_root, result.const_root);	mergestate.joinsymbolicvalue (egraph.const_root, that.const_root, result.const_root);	mergestate.commit ();	}	mergeinfo = mergestate;	if (debugoptions.debug) {	
result update size 

public void dump (textwriter tw) {	var set = new hashset<symvalue> ();	var worklist = new worklist<symvalue> ();	iimmutablemap<symvalue, int> triggers = immutableintkeymap<symvalue, int>.empty (symvalue.getuniquekey);	
egraphid 

public void dump (textwriter tw) {	var set = new hashset<symvalue> ();	var worklist = new worklist<symvalue> ();	iimmutablemap<symvalue, int> triggers = immutableintkeymap<symvalue, int>.empty (symvalue.getuniquekey);	
lastsymbolid 

foreach (symvalue target in multiedgemap [sv, edge].asenumerable ()) {	if (!updatetrigger (target, edge, ref triggers)) continue;	symgraphterm<tfunc> term = equalmultitermsmap [target];	if (term.args != null) {	tw.writeline ("{0}({1}) = {2}", term.function, term.args.tostring (", "), target);	worklist.add (target);	}	}	}	}	
abstract value map 

iimmutablemap<symvalue, symvalue> backwardmap = immutableintkeymap<symvalue, symvalue>.empty (symvalue.getuniquekey);	iimmutablemap<symvalue, sequence<symvalue>> forwardmap = immutableintkeymap<symvalue, sequence<symvalue>>.empty (symvalue.getuniquekey);	iimmutablemap<symvalue, int> triggers = immutableintkeymap<symvalue, int>.empty (symvalue.getuniquekey);	while (!worklist.isempty ()) {	equalitypair<tfunc, tadomain> equalitypair = worklist.pull ();	symvalue sv1 = equalitypair.sv1;	symvalue sv2 = equalitypair.sv2;	symvalue s;	if (visitedbefore (sv2, backwardmanifested, backwardmap, out s)) {	if (s != null && s == sv1) continue;	
lessequal fails due to pre existing relation 

backward = null;	return false;	}	if (sv1 != null) {	backwardmap = backwardmap.add (sv2, sv1);	forwardmap = forwardmap.add (sv1, forwardmap [sv1].cons (sv2));	} else backwardmanifested = backwardmanifested.add (sv2);	if (thisg.hasallbottomfields (sv1)) continue;	if (thatg.hasallbottomfields (sv2)) {	if (debugoptions.debug) {	
lessequal fails due to bottom field difference 

========================= mono sample_29505 =========================

assert.areequal ("tag", props[0].name, "4");	console.writeline (props[0].gettype());	console.writeline ("tag value = {0}", props[0].getvalue (col));	console.writeline ("tag converter = {0}", props[0].converter);	console.writeline ("tag localizable = {0}", props[0].islocalizable);	console.writeline ("tag readonly = {0}", props[0].isreadonly);	console.writeline ("tag type = {0}", props[0].propertytype);	console.writeline ("tag category = {0}", props[0].category);	console.writeline ("tag description = {0}", props[0].description);	console.writeline ("tag displaynem = {0}", props[0].displayname);	
tag has attributes 

assert.areequal ("text", props[1].name, "5");	console.writeline (props[1].gettype());	console.writeline ("text value = {0}", props[1].getvalue (col));	console.writeline ("text converter = {0}", props[1].converter);	console.writeline ("text localizable = {0}", props[1].islocalizable);	console.writeline ("text readonly = {0}", props[1].isreadonly);	console.writeline ("text type = {0}", props[1].propertytype);	console.writeline ("text category = {0}", props[1].category);	console.writeline ("text description = {0}", props[1].description);	console.writeline ("text displaynem = {0}", props[1].displayname);	
text has attributes 

console.writeline ("text category = {0}", props[1].category);	console.writeline ("text description = {0}", props[1].description);	console.writeline ("text displaynem = {0}", props[1].displayname);	assert.areequal ("(advanced)", props[2].name, "6");	console.writeline (props[2].gettype());	console.writeline ("advanced value = {0}", props[2].getvalue (col));	typeconverter propcvt = props[2].converter;	console.writeline ("advanced converter = {0}", propcvt.gettype());	console.writeline ("");	if (null == propcvt.getproperties(props[2].getvalue (col))) console.writeline ("null properties");	
properties 

console.writeline ("advanced converter = {0}", propcvt.gettype());	console.writeline ("");	if (null == propcvt.getproperties(props[2].getvalue (col))) console.writeline ("null properties");	console.writeline ("advanced converter = {0}/{1}/{2}", propcvt.getpropertiessupported (), propcvt.getstandardvaluessupported (), propcvt.getcreateinstancesupported ());	console.writeline ("advanced localizable = {0}", props[2].islocalizable);	console.writeline ("advanced readonly = {0}", props[2].isreadonly);	console.writeline ("advanced type = {0}", props[2].propertytype);	console.writeline ("advanced category = {0}", props[2].category);	console.writeline ("advanced description = {0}", props[2].description);	console.writeline ("advanced displaynem = {0}", props[2].displayname);	
advanced has attributes 

========================= mono sample_25403 =========================

public static void main (string[] args) {	compositepoker poker;	poker = new compositepoker ();	
databind 

public static void main (string[] args) {	compositepoker poker;	poker = new compositepoker ();	console.writeline ("--------");	try { poker.databind(); } catch (exception e) { console.writeline (e);}	poker = new compositepoker ();	
render 

public static void main (string[] args) {	compositepoker poker;	poker = new compositepoker ();	console.writeline ("--------");	try { poker.databind(); } catch (exception e) { console.writeline (e);}	poker = new compositepoker ();	console.writeline ("--------");	try { poker.databind(); } catch (exception e) { console.writeline (e);}	poker = new compositepoker ();	
controls 

console.writeline ("--------");	try { poker.databind(); } catch (exception e) { console.writeline (e);}	poker = new compositepoker ();	console.writeline ("--------");	try { poker.databind(); } catch (exception e) { console.writeline (e);}	poker = new compositepoker ();	console.writeline ("--------");	try { controlcollection c = poker.controls; } catch (exception e) { console.writeline (e);}	poker = new compositepoker ();	icompositecontroldesigneraccessor accessor = (icompositecontroldesigneraccessor)poker;	
recreatechildcontrols 

========================= mono sample_18512 =========================

if (b.teststring ("top") != "top") return 4;	if (b.testb () != null) return 5;	if (b.test<ushort> () != 0) return 6;	if (b.testdecimal (2) != decimal.minvalue) return 7;	if (b.testdecimal (2, 5) != 5) return 8;	if (b.testenum () != e.value) return 9;	b b = new b ();	b [1] = 3;	if (b [0] != 6) return 10;	b.testnew ();	
ok 

========================= mono sample_3907 =========================

public void testtostring() {	assert.areequal(mystring1, myuint16_1.tostring(), "a1");	assert.areequal(mystring2, myuint16_2.tostring(), "a2");	assert.areequal(mystring3, myuint16_3.tostring(), "a3");	for (int i=0; i < formats1.length; i++) {	
d 

========================= mono sample_27308 =========================

public void deserialization() {	global::system.runtime.serialization.iformatter fmtr = new global::system.runtime.serialization.formatters.binary.binaryformatter ();	global::system.io.memorystream src;	for (int i = 0; i < serializationcases.length; ++i) {	src = new global::system.io.memorystream ( bitconverter_bytearray_fromstring (serializationcases[i].resultbinarystring));	datetimeoffset result = (datetimeoffset)fmtr.deserialize (src);	
input o s 

public void deserialization() {	global::system.runtime.serialization.iformatter fmtr = new global::system.runtime.serialization.formatters.binary.binaryformatter ();	global::system.io.memorystream src;	for (int i = 0; i < serializationcases.length; ++i) {	src = new global::system.io.memorystream ( bitconverter_bytearray_fromstring (serializationcases[i].resultbinarystring));	datetimeoffset result = (datetimeoffset)fmtr.deserialize (src);	
result o s 

public void deserialization() {	global::system.runtime.serialization.iformatter fmtr = new global::system.runtime.serialization.formatters.binary.binaryformatter ();	global::system.io.memorystream src;	for (int i = 0; i < serializationcases.length; ++i) {	src = new global::system.io.memorystream ( bitconverter_bytearray_fromstring (serializationcases[i].resultbinarystring));	datetimeoffset result = (datetimeoffset)fmtr.deserialize (src);	console.writeline ("#{0} input.dt : {1}={1:r}={1:u}", i, serializationcases[i].input.datetime);	console.writeline ("#{0} result.dt: {1}={1:r}={1:u}", i, result.datetime);	
input dtk 

========================= mono sample_27248 =========================

int repeat = 1;	var p = new optionset () {	"usage: greet [options]+ message", "greet a list of individuals with an optional message.", "if no message is specified, a generic greeting is used.", "", "options:", { "n|name=", "the {name} of someone to greet.", v => names.add (v) }, { "r|repeat=", "the number of {times} to repeat the greeting.\n" + "this must be an integer.", (int v) => repeat = v }, { "v", "increase debug message verbosity", v => { if (v != null) ++verbosity; } }, { "h|help",  "show this message and exit", v => show_help = v != null }, };	list<string> extra;	try {	extra = p.parse (args);	}	catch (optionexception e) {	console.write ("greet: ");	console.writeline (e.message);	
try greet help for more information 

========================= mono sample_32535 =========================

static void function () {	
delegate method 

static void async_callback (iasyncresult ar) {	
async callback 

public static void main () {	foo_delegate d = new foo_delegate (function);	asynccallback ac = new asynccallback (async_callback);	iasyncresult ar1 = d.begininvoke (ac, "foo");	ar1.asyncwaithandle.waitone();	d.endinvoke(ar1);	thread.sleep(1000);	
main returns 

========================= mono sample_232 =========================

const string uia_winforms_method   = "initialize";	try {	type global_type = mwf_providers.gettype (uia_winforms_type, false);	if (global_type != null) {	init_method = global_type.getmethod (uia_winforms_method, bindingflags.static | bindingflags.public);	if (init_method != null) init_method.invoke (null, new object [] {});	else throw new exception (string.format ("method {0} not found in type {1}.", uia_winforms_method, uia_winforms_type));	}	else throw new exception (string.format ("type {0} not found in assembly {1}.", uia_winforms_type, uia_winforms_assembly));	} catch (exception ex) {	
error setting up uia 

bool is_child_of_main = false; ;	do {	if (current.parent == context.mainform) {	is_child_of_main = true;	break;	}	current = current.parent;	} while (current != null);	if (is_child_of_main) continue;	if (f.ishandlecreated && xplatui.isenabled (f.handle)) {	
disabling form 

private static void enableformsformodalloop (queue toplevels, applicationcontext context) {	while (toplevels.count > 0) {	
re enabling form form 

private static void enableformsformodalloop (queue toplevels, applicationcontext context) {	while (toplevels.count > 0) {	#endif form c = (form) toplevels.dequeue ();	if (c.ishandlecreated) {	xplatui.enablewindow (c.window.handle, true);	context.mainform = c;	}	}	
done with the re enable 

========================= mono sample_26124 =========================

public static int main () {	derived d = new derived ();	d.a ();	if (d.which == 1) return 1;	
test passes 

========================= mono sample_1853 =========================

static listreplicasrequest() {	try {	ldapextendedresponse.register(replicationconstants.list_replicas_res, system.type.gettype("novell.directory.ldap.extensions.listreplicasresponse"));	}	catch (system.exception e) {	
could not register extended response class not found 

========================= mono sample_20958 =========================

public static void main () {	a a = new a (8);	b b = new b (9);	b.setcount (10);	
b count should be 

public static void main () {	a a = new a (8);	b b = new b (9);	b.setcount (10);	
b should return 

public static void main () {	a a = new a (8);	b b = new b (9);	b.setcount (10);	
a message 

public static void main () {	a a = new a (8);	b b = new b (9);	b.setcount (10);	b.message = "";	
b messasge 

========================= mono sample_2818 =========================

public void methodbegin(methodbase methinfo, isourcelineinfo sourceinfo, bool initwriters) {	this.methinfo = methinfo;	this.ilgen = xmlilmodule.definemethodbody(methinfo);	this.lastsourceinfo = null;	#if debug if (xmliltrace.isenabled) {	this.numlocals = 0;	this.symbols = new hashtable();	this.lblnum = 0;	this.sourcefile = null;	this.writerdump = xmliltrace.gettracewriter("dump.il");	
method 

private void marksequencepoint(isourcelineinfo sourceinfo) {	debug.assert(this.module.emitsymbols);	if (sourceinfo.isnosource && this.lastsourceinfo != null && this.lastsourceinfo.isnosource) {	return;	}	string sourcefile = getfilename(sourceinfo);	#if debug if (xmliltrace.isenabled) {	
else 

public void marklabel(label lbl) {	if (this.lastsourceinfo != null && !this.lastsourceinfo.isnosource) {	debugsequencepoint(sourcelineinfo.nosource);	}	
label 

public void emit(opcode opcode, label lblval) {	debug.assert(!opcode.equals(opcodes.br) && !opcode.equals(opcodes.br_s), "use emitunconditionalbranch and be careful not to emit unverifiable code.");	
label 

public void emitunconditionalbranch(opcode opcode, label lbltarget) {	if (!opcode.equals(opcodes.br) && !opcode.equals(opcodes.br_s)) {	debug.assert(opcode.equals(opcodes.brtrue) || opcode.equals(opcodes.brtrue_s) || opcode.equals(opcodes.brfalse) || opcode.equals(opcodes.brfalse_s));	emit(opcodes.ldc_i4_1);	}	
label 

========================= mono sample_6203 =========================

protected override void insertitem (int index, baseitem item) {	base.insertitem (index, item);	
item inserted at index 

public baseitem () {	
constructed 

public void begininit () {	
isupportinitialize begininit 

public void endinit () {	
isupportinitialize endinit 

public static void setassociatedproperty (child child, string value) {	
parent setassociatedproperty 

========================= mono sample_30851 =========================

public void writegrammar (relaxnggrammar g) {	
grammar 

========================= mono sample_22799 =========================

public void enqueue (hwnd hwnd) {	if (hwnds.contains (hwnd)) {	
hwnds can only appear in the queue once 

public void enqueue (hwnd hwnd) {	if (hwnds.contains (hwnd)) {	console.writeline (environment.stacktrace);	
originally added here 

========================= mono sample_26390 =========================

public void dump () {	
chain x 

public void dump () {	for (int i = 0; i < count; i++) {	using (var cert = getcertificate (i)) {	
cert 

========================= mono sample_24104 =========================

public void showstats () {	if (timers == null) return;	dictionary<timertype, string> timer_names = new dictionary<timertype,string> {	{ timertype.parsetotal, "parsing source files" }, { timertype.assemblybuildersetup, "assembly builder setup" }, { timertype.createtypetotal, "compiled types created" }, { timertype.referencesloading, "referenced assemblies loading" }, { timertype.referencesimporting, "referenced assemblies importing" }, { timertype.predefinedtypesinit, "predefined types initialization" }, { timertype.moduledefinitiontotal, "module definition" }, { timertype.emittotal, "resolving and emitting members blocks" }, { timertype.closetypes, "module types closed" }, { timertype.resouces, "embedding resources" }, { timertype.outputsave, "writing output file" }, { timertype.debugsave, "writing debug symbols file" }, };	int counter = 0;	double percentage = (double) total.elapsedmilliseconds / 100;	long subtotal = total.elapsedmilliseconds;	foreach (var timer in timers) {	string msg = timer_names[(timertype) counter++];	var ms = timer == null ? 0 : timer.elapsedmilliseconds;	
ms 

dictionary<timertype, string> timer_names = new dictionary<timertype,string> {	{ timertype.parsetotal, "parsing source files" }, { timertype.assemblybuildersetup, "assembly builder setup" }, { timertype.createtypetotal, "compiled types created" }, { timertype.referencesloading, "referenced assemblies loading" }, { timertype.referencesimporting, "referenced assemblies importing" }, { timertype.predefinedtypesinit, "predefined types initialization" }, { timertype.moduledefinitiontotal, "module definition" }, { timertype.emittotal, "resolving and emitting members blocks" }, { timertype.closetypes, "module types closed" }, { timertype.resouces, "embedding resources" }, { timertype.outputsave, "writing output file" }, { timertype.debugsave, "writing debug symbols file" }, };	int counter = 0;	double percentage = (double) total.elapsedmilliseconds / 100;	long subtotal = total.elapsedmilliseconds;	foreach (var timer in timers) {	string msg = timer_names[(timertype) counter++];	var ms = timer == null ? 0 : timer.elapsedmilliseconds;	subtotal -= ms;	}	
ms other tasks 

{ timertype.parsetotal, "parsing source files" }, { timertype.assemblybuildersetup, "assembly builder setup" }, { timertype.createtypetotal, "compiled types created" }, { timertype.referencesloading, "referenced assemblies loading" }, { timertype.referencesimporting, "referenced assemblies importing" }, { timertype.predefinedtypesinit, "predefined types initialization" }, { timertype.moduledefinitiontotal, "module definition" }, { timertype.emittotal, "resolving and emitting members blocks" }, { timertype.closetypes, "module types closed" }, { timertype.resouces, "embedding resources" }, { timertype.outputsave, "writing output file" }, { timertype.debugsave, "writing debug symbols file" }, };	int counter = 0;	double percentage = (double) total.elapsedmilliseconds / 100;	long subtotal = total.elapsedmilliseconds;	foreach (var timer in timers) {	string msg = timer_names[(timertype) counter++];	var ms = timer == null ? 0 : timer.elapsedmilliseconds;	subtotal -= ms;	}	console.writeline ();	
total elapsed time 

========================= mono sample_36388 =========================

static httpmessagehandler getfallback (string message) {	
defaulting to system net http httpclienthandler 

========================= mono sample_4110 =========================

public p () {	
p 

========================= mono sample_197 =========================

public static int test_shift_2 () {	unchecked {	long c = (long)0x800000ff00000000;	long d = (long)0x8ef0abcd00000000;	long t;	int sa;	t = c>>4;	
x 

public static int test_shift_2 () {	unchecked {	long c = (long)0x800000ff00000000;	long d = (long)0x8ef0abcd00000000;	long t;	int sa;	t = c>>4;	if (t != (long)0xf800000ff0000000) return 1;	if ((t << 4) != c) return 1;	t = d>>40;	
x 

public static int test_shift_3 () {	checked {	ulong c = 0x800000ff00000000;	ulong d = 0x8ef0abcd00000000;	ulong t;	t = c >> 4;	
x 

public static int test_shift_3 () {	checked {	ulong c = 0x800000ff00000000;	ulong d = 0x8ef0abcd00000000;	ulong t;	t = c >> 4;	if (t != 0x0800000ff0000000) return 1;	if ((t << 4) != c) return 1;	t = d >> 40;	
x 

========================= mono sample_206 =========================

static void create_user (string username, string email, string password, string pwdquestion, string pwdanswer) {	membershipcreatestatus status;	membership.createuser (username, password, email, pwdquestion, pwdanswer, true, out status);	
create status 

static void dump_list (membershipusercollection users) {	
users 

static void dump_list (membershipusercollection users) {	foreach (membershipuser u in users) {	
lockedout notlockedout 

static void validate_user (string username, string password) {	
success 

static void validate_user (string username, string password) {	
failure 

static void unlock_user (string username) {	
success 

static void unlock_user (string username) {	
failure 

static void reset_password (string username, string pwdanswer) {	string newpassword = membership.provider.resetpassword (username, pwdanswer);	if (newpassword == null) console.writeline ("failure.");	
success new password is 

static void change_password (string username, string oldpwd, string newpwd) {	
success 

static void change_password (string username, string oldpwd, string newpwd) {	
failure 

static void change_question_answer (string username, string pwd, string question, string answer) {	
success 

static void change_question_answer (string username, string pwd, string question, string answer) {	
failure 

static void get_number_of_users_online () {	
number of online users 

static void get_password (string username, string answer) {	
password for user 

static void dump_user (string username) {	
info for user 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
comment 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
creation date 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
email 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
isapproved 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
isonline 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
last activity date 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
last login date 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
last password changed date 

static void dump_user (string username) {	membershipuser user = membership.getuser (username, false);	
last lockout date 

static void usage () {	
usage just look at test cs 

case "dumpuser": dump_user (args[1]);	break;	case "findusersbyemail": find_user_by_email (args[1]);	break;	case "findusersbyname": find_user_by_name (args[1]);	break;	case "getnumberofusersonline": get_number_of_users_online ();	break;	case "getpassword": get_password (args[1], args[2]);	break;	
unknown command 

========================= mono sample_18466 =========================

private xplatuix11gtk () {	
ctor 

xsendevent (displayhandle, xevent.selectionrequestevent.requestor, false, eventmask.noeventmask, ref sel_event);	break;	}	case xeventname.selectionnotify: {	if (clipboard.enumerating) {	clipboard.enumerating = false;	if (xevent.selectionevent.property != 0) {	xdeleteproperty (displayhandle, fosterparent, xevent.selectionevent.property);	if (!clipboard.formats.contains (xevent.selectionevent.property)) {	clipboard.formats.add (xevent.selectionevent.property);	
got supported clipboard atom format 

private int handleerror (intptr display, ref xerrorevent error_event) {	if (errorexceptions) {	throw new xexception (error_event.display, error_event.resourceid, error_event.serial, error_event.error_code, error_event.request_code, error_event.minor_code);	} else {	
error encountered 

========================= mono sample_26281 =========================

public w jump () {	
monkey from jumping 

========================= mono sample_1735 =========================

public static int main () {	bool one = false, two = false;	try {	try {	throw new exception ();	} catch (exception e) {	one = true;	
caught 

bool one = false, two = false;	try {	try {	throw new exception ();	} catch (exception e) {	one = true;	throw;	}	} catch {	two = true;	
again 

try {	throw new exception ();	} catch (exception e) {	one = true;	throw;	}	} catch {	two = true;	}	if (one && two){	
ok 

throw new exception ();	} catch (exception e) {	one = true;	throw;	}	} catch {	two = true;	}	if (one && two){	return 0;	
failed 

========================= mono sample_3630 =========================

public static int main () {	assembly thisasm = assembly.getexecutingassembly ();	assemblyname name = thisasm.getname (false);	if (name.flags != (assemblynameflags.enablejitcompileoptimizer | assemblynameflags.retargetable | assemblynameflags.publickey)) return 1;	byte[] key = name.getpublickey ();	if (key.length != 160) return 2;	if (key [56] != 170) return 3;	if (name.hashalgorithm != system.configuration.assemblies.assemblyhashalgorithm.sha1) return 4;	if (name.versioncompatibility != system.configuration.assemblies.assemblyversioncompatibility.samemachine) return 6;	
ok 

========================= mono sample_1797 =========================

public static void main (string[] args) {	if (args.length == 0) {	console.writeline ();	
usage wstest options 

public static void main (string[] args) {	if (args.length == 0) {	console.writeline ();	console.writeline ();	
options 

public static void main (string[] args) {	if (args.length == 0) {	console.writeline ();	console.writeline ();	
ur url update service references from disco or wsdl document 

public static void main (string[] args) {	if (args.length == 0) {	console.writeline ();	console.writeline ();	
dw download wsdl documents for registered services 

public static void main (string[] args) {	if (args.length == 0) {	console.writeline ();	console.writeline ();	
gp generate proxies 

public static void main (string[] args) {	if (args.length == 0) {	console.writeline ();	console.writeline ();	
gc url generate test client class 

else if (args[0] == "checkdiff") {	checkdiff (getarg (args,1));	}	else if (args[0] == "msfix") {	msfix (getarg (args,1));	}	else if (args[0] == "genfiles") {	generatefiles (getarg (args,1));	}	saveinfo ();	
please check error log at error log 

static void clean (hashtable clienthash, string path) {	if (path.getfilename (path) == "cvs") return;	string[] files = directory.getfiles (path);	foreach (string file in files) {	servicedata sd = clienthash [file] as servicedata;	if (sd != null) continue;	file.delete (file);	
deleted file 

foreach (string file in files) {	servicedata sd = clienthash [file] as servicedata;	if (sd != null) continue;	file.delete (file);	}	string [] dirs = directory.getdirectories (path);	foreach (string dir in dirs) clean (clienthash, dir);	int count = directory.getfiles (path).length + directory.getdirectories (path).length;	if (count == 0 && path != getclientpath () && path != getproxypath ()) {	directory.delete (path);	
deleted directory 

static void updatereferences (string url, string ignorefile) {	console.writeline ();	
updating service references 

discoveryclientprotocol client = new discoveryclientprotocol ();	client.discoverany (url);	arraylist list = new arraylist (client.references.values);	foreach (discoveryreference re in list) {	if (!(re is contractreference)) continue;	bool ignore = ignorelist.contains (re.url);	servicedata sd = findservice (re.url);	if (ignore) {	if (sd != null) {	removeservice (re.url);	
removed 

bool ignore = ignorelist.contains (re.url);	servicedata sd = findservice (re.url);	if (ignore) {	if (sd != null) {	removeservice (re.url);	}	continue;	}	if (sd == null) {	sd = createservicedata (re);	
added 

if (sd != null) {	removeservice (re.url);	}	continue;	}	if (sd == null) {	sd = createservicedata (re);	services.services.add (sd);	}	}	
done 

static void downloadwsdls (string host) {	console.writeline ();	
downloading wsdl documents 

static void downloadwsdls (string host) {	console.writeline ();	console.writeline ("---------------------------");	foreach (servicedata sd in services.services) {	if (host != null && host != new uri (sd.wsdl).host) continue;	if (!file.exists (getwsdlfile(sd))) resolve (sd);	}	
done 

static void resolve (servicedata sd) {	console.write ("resolving " + sd.wsdl + " ");	try {	discoveryclientprotocol contract = new discoveryclientprotocol ();	contract.discoverany (sd.wsdl);	if (sd.protocols == null || sd.protocols.length==0) retrieveservicedata (sd, contract);	string wsdlfile = getwsdlfile (sd);	createfolderforfile (wsdlfile);	servicedescription doc = (servicedescription) contract.documents [sd.wsdl];	doc.write (wsdlfile);	
ok 

discoveryclientprotocol contract = new discoveryclientprotocol ();	contract.discoverany (sd.wsdl);	if (sd.protocols == null || sd.protocols.length==0) retrieveservicedata (sd, contract);	string wsdlfile = getwsdlfile (sd);	createfolderforfile (wsdlfile);	servicedescription doc = (servicedescription) contract.documents [sd.wsdl];	doc.write (wsdlfile);	cleanfailures (sd);	}	catch (exception ex) {	
failed 

if (array.indexof(sd.protocols, "httppost") != -1) post++;	if (array.indexof(sd.protocols, "httpget") != -1) get++;	}	if (sd.clienttest) tests++;	string st = sd.servertype;	if (st == null) st = "unknown";	object on = servers [st];	if (on == null) servers [st] = 1;	else servers [st] = ((int)on)+1;	}	
total services 

if (array.indexof(sd.protocols, "httppost") != -1) post++;	if (array.indexof(sd.protocols, "httpget") != -1) get++;	}	if (sd.clienttest) tests++;	string st = sd.servertype;	if (st == null) st = "unknown";	object on = servers [st];	if (on == null) servers [st] = 1;	else servers [st] = ((int)on)+1;	}	
soap protocol 

if (array.indexof(sd.protocols, "httppost") != -1) post++;	if (array.indexof(sd.protocols, "httpget") != -1) get++;	}	if (sd.clienttest) tests++;	string st = sd.servertype;	if (st == null) st = "unknown";	object on = servers [st];	if (on == null) servers [st] = 1;	else servers [st] = ((int)on)+1;	}	
httppost protocol 

if (array.indexof(sd.protocols, "httppost") != -1) post++;	if (array.indexof(sd.protocols, "httpget") != -1) get++;	}	if (sd.clienttest) tests++;	string st = sd.servertype;	if (st == null) st = "unknown";	object on = servers [st];	if (on == null) servers [st] = 1;	else servers [st] = ((int)on)+1;	}	
httpget protocol 

if (array.indexof(sd.protocols, "httppost") != -1) post++;	if (array.indexof(sd.protocols, "httpget") != -1) get++;	}	if (sd.clienttest) tests++;	string st = sd.servertype;	if (st == null) st = "unknown";	object on = servers [st];	if (on == null) servers [st] = 1;	else servers [st] = ((int)on)+1;	}	
total proxies 

if (array.indexof(sd.protocols, "httppost") != -1) post++;	if (array.indexof(sd.protocols, "httpget") != -1) get++;	}	if (sd.clienttest) tests++;	string st = sd.servertype;	if (st == null) st = "unknown";	object on = servers [st];	if (on == null) servers [st] = 1;	else servers [st] = ((int)on)+1;	}	
nunit tests 

if (array.indexof(sd.protocols, "httpget") != -1) get++;	}	if (sd.clienttest) tests++;	string st = sd.servertype;	if (st == null) st = "unknown";	object on = servers [st];	if (on == null) servers [st] = 1;	else servers [st] = ((int)on)+1;	}	console.writeline ();	
server types 

static void buildproxies (string host) {	console.writeline ();	
generating proxies 

if (buildall) host = null;	arraylist proxies = new arraylist ();	foreach (servicedata fd in services.services) {	if (host != null && host != new uri (fd.wsdl).host) continue;	buildproxy (fd, buildall, proxies, ele);	}	streamwriter sw = new streamwriter (path.combine (basepath, "proxies.sources"));	foreach (string f in proxies) sw.writeline (f);	sw.close ();	doc.save ("proxy-gen-error.xml");	
done 

proc.startinfo.useshellexecute = false;	proc.startinfo.redirectstandardoutput = true;	proc.startinfo.redirectstandarderror = true;	proc.startinfo.filename = "wsdl";	proc.startinfo.arguments = "/out:" + pfile + " /nologo /namespace:" + ns + " /protocol:" + prot + " " + wsdl;	proc.start();	if (!proc.waitforexit (30000)) {	try {	proc.kill ();	} catch {}	
fail timeout 

proc.startinfo.arguments = "/out:" + pfile + " /nologo /namespace:" + ns + " /protocol:" + prot + " " + wsdl;	proc.start();	if (!proc.waitforexit (30000)) {	try {	proc.kill ();	} catch {}	if (file.exists (pfile)) file.delete (pfile);	writeerror (errdoc, ns, "errors found while generating " + prot + " proxy for wsdl: " + wsdl, "wsdl.exe timeout");	}	else if (proc.exitcode != 0) {	
fail 

string err = proc.standardoutput.readtoend ();	err += "\n" + proc.standarderror.readtoend ();	if (file.exists (pfile)) {	if (proc.exitcode == 1) {	string fn = fd.name + prot + "proxy.cs";	fn = path.combine (geterrorpath(), fn);	createfolderforfile (fn);	file.move (pfile, fn);	streamwriter sw = new streamwriter (fn, true);	sw.writeline ();	
sw writeline 

streamwriter sw = new streamwriter (fn, true);	sw.writeline ();	sw.close ();	}	else file.delete (pfile);	}	writeerror (errdoc, ns, "errors found while generating " + prot + " proxy for wsdl: " + wsdl, err);	}	else {	if (file.exists (pfile)) {	
ok 

}	else file.delete (pfile);	}	writeerror (errdoc, ns, "errors found while generating " + prot + " proxy for wsdl: " + wsdl, err);	}	else {	if (file.exists (pfile)) {	proxies.add (pfile);	}	else {	
fail 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	
sw writeline 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	
using system 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	
using nunit framework 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	
using 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	sw.writeline ();	
namespace 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	sw.writeline ();	sw.writeline ("{");	
public class webservicetest 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	sw.writeline ();	sw.writeline ("{");	sw.writeline ("\t{");	
test 

public static void buildclient (servicedata sd) {	string file = getclientfile (sd);	if (file.exists (file)) return;	createfolderforfile (file);	streamwriter sw = new streamwriter (file);	sw.writeline ();	sw.writeline ("{");	sw.writeline ("\t{");	
public void testservice 

createfolderforfile (file);	streamwriter sw = new streamwriter (file);	sw.writeline ();	sw.writeline ("{");	sw.writeline ("\t{");	sw.writeline ("\t\t{");	sw.writeline ("\t\t}");	sw.writeline ("\t}");	sw.writeline ("}");	sw.close ();	
written file 

foreach (servicedata sd in services.services) {	if (sd.protocols == null) continue;	foreach (string prot in sd.protocols) {	string ns = sd.namespace + "." + prot;	xmlelement elem = doc.selectsinglenode ("assemblies/assembly/namespaces/namespace[@name='" + ns + "']") as xmlelement;	if (elem == null) {	ign++;	continue;	}	if (!file.exists (getwsdlfile(sd))) {	
warning wsdl file not found 

if (errelem != null) {	writeresult (tsres, ns, false, sd.wsdl + "\n" + errelem.innertext);	}	else {	stringwriter str = new stringwriter ();	xsl.transform (elem, null, str, null);	writeresult (tsres, ns, false, sd.wsdl + "\n" + str.tostring ());	}	}	else {	
bonus class 

suc++;	writeresult (tsres, ns, true, sd.wsdl);	}	}	}	ts.setattribute ("success", (suc < tot).tostring());	res.setattribute ("total", tot.tostring());	res.setattribute ("failures", (tot-suc).tostring());	res.setattribute ("not-run", "0");	result.save ("wsdltestresult.xml");	
compared ignored sucess fail 

if (xtemp == null) throw new exception ("template " + tid + " not found");	string tempfile = xtemp.getattribute ("file");	streamreader sr = new streamreader (tempfile);	string template = sr.readtoend ();	sr.close ();	string content = replacevars (template, node);	content = replacevars (content, gvarset);	streamwriter sw = new streamwriter (file);	sw.write (content);	sw.close ();	
writen 

========================= mono sample_24266 =========================

static void dotest (smtpserver s, smtpclient c, mailmessage m) {	thread t = new thread (s.run);	t.start ();	c.send (m);	t.join ();	
message from 

static void dotest (smtpserver s, smtpclient c, mailmessage m) {	thread t = new thread (s.run);	t.start ();	c.send (m);	t.join ();	
message sender 

static void dotest (smtpserver s, smtpclient c, mailmessage m) {	thread t = new thread (s.run);	t.start ();	c.send (m);	t.join ();	
mail from 

static void dotest (smtpserver s, smtpclient c, mailmessage m) {	thread t = new thread (s.run);	t.start ();	c.send (m);	t.join ();	
rcpt to 

========================= mono sample_23787 =========================

} finally {	console.writeline ("f2");	try {	x += await yieldvalue (4);	console.writeline ("t3");	} finally {	console.writeline ("f3");	x += await yieldvalue (8);	}	}	
end 

} finally {	console.writeline ("f2");	try {	x += await yieldvalue (4);	console.writeline ("t3");	} finally {	console.writeline ("f3");	x += await yieldvalue (8);	}	}	
end 

} finally {	console.writeline ("f2");	try {	x += await yieldvalue (4);	console.writeline ("t3");	} finally {	console.writeline ("f3");	x += await yieldvalue (8);	}	}	
end l 

========================= mono sample_1507 =========================

hashset<iasyncresult> currentasyncresults = new hashset<iasyncresult>();	public virtual iasyncresult begintryreceiverequest (timespan timeout, asynccallback callback, object state) {	iasyncresult result = null;	if (try_recv_delegate == null) try_recv_delegate = new tryreceivedelegate (delegate (timespan tout, out requestcontext ctx) {	lock (async_result_lock) {	if (currentasyncresults.contains (result)) currentasyncthreads.add (thread.currentthread);	}	try {	return tryreceiverequest (tout, out ctx);	} catch (xmlexception ex) {	
xml exception dropped connection 

public virtual iasyncresult begintryreceiverequest (timespan timeout, asynccallback callback, object state) {	iasyncresult result = null;	if (try_recv_delegate == null) try_recv_delegate = new tryreceivedelegate (delegate (timespan tout, out requestcontext ctx) {	lock (async_result_lock) {	if (currentasyncresults.contains (result)) currentasyncthreads.add (thread.currentthread);	}	try {	return tryreceiverequest (tout, out ctx);	} catch (xmlexception ex) {	} catch (socketexception ex) {	
socket exception dropped connection 

iasyncresult result = null;	if (try_recv_delegate == null) try_recv_delegate = new tryreceivedelegate (delegate (timespan tout, out requestcontext ctx) {	lock (async_result_lock) {	if (currentasyncresults.contains (result)) currentasyncthreads.add (thread.currentthread);	}	try {	return tryreceiverequest (tout, out ctx);	} catch (xmlexception ex) {	} catch (socketexception ex) {	} catch (ioexception ex) {	
i o exception dropped connection 

========================= mono sample_31638 =========================

public void writedot(string filename) {	textwriter wr = new streamwriter(new filestream(filename, filemode.create, fileaccess.write));	
wr writeline digraph nfa 

public void writedot(string filename) {	textwriter wr = new streamwriter(new filestream(filename, filemode.create, fileaccess.write));	wr.writeline("size=\"11,8.25\";");	wr.writeline("rotate=90;");	wr.writeline("rankdir=lr;");	wr.writeline("start [style=invis];");	
start d 

public void writedot(string filename) {	textwriter wr = new streamwriter(new filestream(filename, filemode.create, fileaccess.write));	
wr writeline digraph dfa 

public void writedot(string filename) {	textwriter wr = new streamwriter(new filestream(filename, filemode.create, fileaccess.write));	wr.writeline("size=\"11,8.25\";");	wr.writeline("rotate=90;");	wr.writeline("rankdir=lr;");	wr.writeline("start [style=invis];");	
start d 

public static void buildandshow(string fileprefix, regex r) {	nfa nfa = r.mknfa(new nfa.namesource());	console.writeline(nfa);	
writing nfa graph to file 

public static void buildandshow(string fileprefix, regex r) {	nfa nfa = r.mknfa(new nfa.namesource());	console.writeline(nfa);	nfa.writedot(fileprefix + "nfa.dot");	console.writeline("---");	dfa dfa = nfa.todfa();	console.writeline(dfa);	
writing dfa graph to file 

========================= mono sample_30554 =========================

public static int main (string [] args) {	
hello world 

========================= mono sample_4040 =========================

private void elementidentityconstraints () {	for (int i = this.startidconstraint; i < this.validationstack.length; i ++) {	if (((validationstate)(this.validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[i]).constr;	for (int j = 0; j < constraints.length; ++j) {	if (constraints[j].axisselector.movetostartelement(reader.localname, reader.namespaceuri)) {	
selector match 

private void elementidentityconstraints () {	for (int i = this.startidconstraint; i < this.validationstack.length; i ++) {	if (((validationstate)(this.validationstack[i])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[i]).constr;	for (int j = 0; j < constraints.length; ++j) {	if (constraints[j].axisselector.movetostartelement(reader.localname, reader.namespaceuri)) {	
name uri 

continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[i]).constr;	for (int j = 0; j < constraints.length; ++j) {	if (constraints[j].axisselector.movetostartelement(reader.localname, reader.namespaceuri)) {	constraints[j].axisselector.pushks(positioninfo.linenumber, positioninfo.lineposition);	}	for (int k = 0; k < constraints[j].axisfields.count; ++k) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[j].axisfields[k];	if (laxis.movetostartelement(reader.localname, reader.namespaceuri)) {	
element field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, schemaattdef attdef) {	for (int ci = this.startidconstraint; ci < this.validationstack.length; ci ++) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field match 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, schemaattdef attdef) {	for (int ci = this.startidconstraint; ci < this.validationstack.length; ci ++) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
attribute field filling value 

private void attributeidentityconstraints(string name, string ns, object obj, string sobj, schemaattdef attdef) {	for (int ci = this.startidconstraint; ci < this.validationstack.length; ci ++) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.movetoattribute(name, ns)) {	
name uri value 

private void endelementidentityconstraints() {	for (int ci = this.validationstack.length - 1; ci >= this.startidconstraint; ci --) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
element field filling value 

private void endelementidentityconstraints() {	for (int ci = this.validationstack.length - 1; ci >= this.startidconstraint; ci --) {	if (((validationstate)(this.validationstack[ci])).constr == null) {	continue;	}	constraintstruct[] constraints = ((validationstate)this.validationstack[ci]).constr;	for (int i = 0; i < constraints.length; ++i) {	for (int j = 0; j < constraints[i].axisfields.count; ++j) {	locatedactiveaxis laxis = (locatedactiveaxis)constraints[i].axisfields[j];	if (laxis.ismatched) {	
name uri value 

========================= mono sample_11215 =========================

public void run_help () {	var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	
usage git version command args 

public void run_help () {	var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	
common options 

public void run_help () {	var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	
version show version info 

public void run_help () {	var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	
help show this message and exit 

public void run_help () {	var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
these are common git commands used in various situations 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
start a working area see also git help tutorial 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
clone clone a repository into a new directory 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
init create an empty git repository or reinitialize an 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
existing one 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
thisisaverylongcommandnameinordertoinducewrapping 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
create an empty git repository or reinitialize an 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
existing one let s make this really long to 

var o = new stringwriter ();	var e = new stringwriter ();	var showversion = false;	var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	
cause a line wrap shall we 

var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	
usage git command options 

var showhelp    = false;	var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	
use git help command for help on a specific command 

var git = new commandset ("git", output: o, error: e) {	"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	
available commands 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
clone clone a repository into a new directory 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
init create an empty git repository or reinitialize an 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
existing one 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
thisisaverylongcommandnameinordertoinducewrapping 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
create an empty git repository or reinitialize an 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
existing one let s make this really long to 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
cause a line wrap shall we 

"usage: git [--version] ... <command> [<args>]", "", "common options:", { "version", "show version info", v => showversion = v != null }, { "help", "show this message and exit", v => showhelp = v != null }, "", "these are common git commands used in various situations:", "", "start a working area (see also: git help tutorial)", new command ("clone", "clone a repository into a new directory"), new command ("init",  "create an empty git repository or reinitialize an existing one"), new command ("thisisaverylongcommandnameinordertoinducewrapping", "create an empty git repository or reinitialize an existing one. let's make this really long to cause a line wrap, shall we?"), };	var expectedhelp = new stringwriter ();	expectedhelp.writeline ("");	expectedhelp.writeline ("");	expectedhelp.writeline ("");	assert.areequal (0, git.run (new [] { "help" }));	assert.areequal (expectedhelp.tostring (), o.tostring ());	var expectedhelphelp    = new stringwriter ();	expectedhelphelp.writeline ();	expectedhelphelp.writeline ();	
help show this message and exit 

========================= mono sample_32540 =========================

protected void readpo(string filename) {	xmlserializer serializer=new xmlserializer(typeof(purchaseorder));	serializer.unknownnode+=new xmlnodeeventhandler(serializer_unknownnode);	serializer.unknownattribute+=new xmlattributeeventhandler(serializer_unknownattribute);	filestream fs=new filestream(filename, filemode.open);	purchaseorder po;	po=(purchaseorder)serializer.deserialize(fs);	fs.close();	
orderdate 

xmlserializer serializer=new xmlserializer(typeof(purchaseorder));	serializer.unknownnode+=new xmlnodeeventhandler(serializer_unknownnode);	serializer.unknownattribute+=new xmlattributeeventhandler(serializer_unknownattribute);	filestream fs=new filestream(filename, filemode.open);	purchaseorder po;	po=(purchaseorder)serializer.deserialize(fs);	fs.close();	address shipto=po.shipto;	readaddress(shipto, "ship to:");	ordereditem[] items=po.ordereditems;	
items to be shipped 

filestream fs=new filestream(filename, filemode.open);	purchaseorder po;	po=(purchaseorder)serializer.deserialize(fs);	fs.close();	address shipto=po.shipto;	readaddress(shipto, "ship to:");	ordereditem[] items=po.ordereditems;	foreach(ordereditem oi in items) {	console.writeline("\t"+ oi.itemname+"\t"+ oi.description+"\t"+ oi.unitprice+"\t"+ oi.quantity+"\t"+ oi.linetotal);	}	
subtotal shipping total 

protected void serializer_unknownnode(object sender, xmlnodeeventargs e) {	
unknown node 

========================= mono sample_22558 =========================

public static void dumpstats(textwriter output) {	if (totalevents == 0) return;	const double call_time = 0.0000051442355;	const double throw_time = 0.000025365656;	const double field_time = 0.0000018080093;	output.writeline();	
performance details 

public static void dumpstats(textwriter output) {	if (totalevents == 0) return;	const double call_time = 0.0000051442355;	const double throw_time = 0.000025365656;	const double field_time = 0.0000018080093;	output.writeline();	output.writeline();	foreach (keyvaluepair<categories, dictionary<string, int>> kvpcategories in _events) {	if (kvpcategories.value.count > 0) {	
category 

const double field_time = 0.0000018080093;	output.writeline();	output.writeline();	foreach (keyvaluepair<categories, dictionary<string, int>> kvpcategories in _events) {	if (kvpcategories.value.count > 0) {	dumphistogram(kvpcategories.value, output);	output.writeline();	}	}	output.writeline();	
performance summary 

knowntimes += kvp.value * field_time;	break;	case categories.methods: output.writeline("total calls = {0} (calltime = ~{1} secs)", kvp.value, kvp.value * call_time);	knowntimes += kvp.value * call_time;	break;	default: output.writeline("total {1} = {0}", kvp.value, kvp.key);	break;	}	}	output.writeline();	
total known times 

========================= mono sample_17659 =========================

public int test (int index) {	
test 

public int test (t index) {	
test 

========================= mono sample_1634 =========================

public static int main () {	m2 m2 = new m2();	try {	var dll = assembly.loadfile(@"test-multi-netmodule-3-dll2.dll");	var m3type = dll.gettype("m3");	var m3 = activator.createinstance(m3type);	var m3m1field = m3type.getfield("m1");	
assembly 

public static int main () {	m2 m2 = new m2();	try {	var dll = assembly.loadfile(@"test-multi-netmodule-3-dll2.dll");	var m3type = dll.gettype("m3");	var m3 = activator.createinstance(m3type);	var m3m1field = m3type.getfield("m1");	
assembly 

public static int main () {	m2 m2 = new m2();	try {	var dll = assembly.loadfile(@"test-multi-netmodule-3-dll2.dll");	var m3type = dll.gettype("m3");	var m3 = activator.createinstance(m3type);	var m3m1field = m3type.getfield("m1");	} catch (system.typeloadexception) {	return 0;	}	
assembly 

public static int main () {	m2 m2 = new m2();	try {	var dll = assembly.loadfile(@"test-multi-netmodule-3-dll2.dll");	var m3type = dll.gettype("m3");	var m3 = activator.createinstance(m3type);	var m3m1field = m3type.getfield("m1");	} catch (system.typeloadexception) {	return 0;	}	
assembly 

========================= mono sample_391 =========================

public static int main () {	mycar car1 = new mycar();	car1.stop();	idiagnostic car2 = new mycar();	car2.stop();	iautomobile car3 = new mycar();	car3.stop();	if (!car1.car_stop) return 1;	if (car1.diag_stop) return 2;	
ok 

========================= mono sample_3467 =========================

public static int main() {	environment.exitcode = 2;	thread thr=new thread(new threadstart(foo.thread));	thr.start();	thread.sleep(1200);	
main thread exiting 

public static void thread() {	
thread running 

public static void thread() {	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	
thread running 

public static void thread() {	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	thread.sleep(500);	
thread running 

========================= mono sample_280 =========================

s15 ="";	s15 = s0+s1+s2+s3+s4+s5+s6+s7+s8+s9+s10+s11+s12+s13+s14;	dump();	i0 =0;	while (i0++ < i2) {	generate();	dump();	}	end = datetime.now;	n2 = (end-start).totalmilliseconds;	
generations in milliseconds gen sec 

========================= mono sample_111 =========================

public static int test1 () {	blah f = new blah ();	mydelegate del = new mydelegate (f.foo);	mydelegate another = new mydelegate (del);	int number = del (2, 3);	int i = another (4, 6);	
delegate invocation of one returned 

public static int test1 () {	blah f = new blah ();	mydelegate del = new mydelegate (f.foo);	mydelegate another = new mydelegate (del);	int number = del (2, 3);	int i = another (4, 6);	
delegate invocation of the other returned 

public static int main () {	int v;	v = test1 ();	if (v != 0) return v;	v = test2 ();	if (v != 0) return v;	
all tests pass 

========================= mono sample_3527 =========================

if (c != 2) return 3;	if (d != 2) return 4;	if (e != 2) return 5;	if (f != 2) return 6;	if (g != 2) return 7;	if (h != 2) return 8;	if (i != 'b') return 9;	if (j != 2.0) return 10;	if (k != 2.0) return 11;	if (x == null) return 12;	
test passed 

========================= mono sample_1591 =========================

static void main () {	while (true) {	try {	
trying 

========================= mono sample_33618 =========================

public static void main (string [] args) {	
hello world 

========================= mono sample_1740 =========================

#else if (type.isenum) {	this.value = enum.parse(type, value, true);	} else if (type == typeof(timespan)) {	this.value = timespan.parse(value);	} else if (type.module == typeof(string).module) {	this.value = convert.changetype(value, type, cultureinfo.invariantculture);	}	#endif }	catch {	#if !silverlight debug.fail("default value attribute of type " + type.fullname + " threw converting from the string '" + value + "'.");	
default value attribute of type threw converting from the string 

========================= mono sample_12048 =========================

public static void threadmethod_waiter_1() {	
thread a started 

public static void threadmethod_waiter_1() {	
thread a i m before wait for event 

public static void threadmethod_waiter_1() {	e.waitone();	
thread a i m after wait for event 

public static void threadmethod_waiter_1() {	e.waitone();	
thread a i now set again the event to let other thread continue 

public static void threadmethod_waiter_2() {	
thread b started 

public static void threadmethod_waiter_2() {	
thread b i m before wait for event 

public static void threadmethod_waiter_2() {	e.waitone();	
thread b i m after wait for event 

public static void threadmethod_waiter_2() {	e.waitone();	
thread b i now set again the event to let other thread continue 

public static void threadmethod_blocker() {	
thread c started 

public static void threadmethod_blocker() {	
thread c sleeping for 

public static void threadmethod_blocker() {	thread.sleep(5000);	
thread c setting the event 

public static void threadmethod_blocker() {	thread.sleep(5000);	e.set();	
thread c finished 

public static void main() {	e = new autoresetevent(false);	
main creating first thread 

public static void main() {	e = new autoresetevent(false);	threadstart thread_1 = new threadstart(threadmethod_waiter_1);	threadstart thread_2 = new threadstart(threadmethod_waiter_2);	
main creating second thread 

threadstart thread_1 = new threadstart(threadmethod_waiter_1);	threadstart thread_2 = new threadstart(threadmethod_waiter_2);	threadstart thread_3 = new threadstart(threadmethod_blocker);	thread a = new thread(thread_1);	thread b = new thread(thread_2);	thread c = new thread(thread_3);	a.start();	b.start();	c.start();	thread.sleep(500);	
main finish 

========================= mono sample_222 =========================

if (buffer_time > 0) period_time = buffer_time / 4;	dir = 0;	snd_pcm_hw_params_set_period_time_near (handle, hw_param, ref period_time, ref dir);	dir = 0;	snd_pcm_hw_params_set_buffer_time_near (handle, hw_param, ref buffer_time, ref dir);	snd_pcm_hw_params_get_period_size (hw_param, ref period_size, ref dir);	chunk_size = period_size;	snd_pcm_hw_params_get_buffer_size (hw_param, ref buffer_size);	snd_pcm_hw_params (handle, hw_param);	} else {	
failed to alloc alsa hw param struct 

snd_pcm_hw_params (handle, hw_param);	} else {	}	alsa_err = snd_pcm_sw_params_malloc (ref sw_param);	if (alsa_err == 0) {	snd_pcm_sw_params_current (handle, sw_param);	snd_pcm_sw_params_set_avail_min(handle, sw_param, chunk_size);	snd_pcm_sw_params_set_start_threshold(handle, sw_param, buffer_size);	snd_pcm_sw_params(handle, sw_param);	} else {	
failed to alloc alsa sw param struct 

========================= mono sample_23952 =========================

public delegate void foo ();	public class test {	public static implicit operator foo (test test) {	
hello world 

}	public static ienumerable<test> operator + (test test, test foo) {	yield return test;	yield return foo;	}	public ienumerable<int> foo {	get {	yield return 3;	}	set {	
foo 

========================= mono sample_1651 =========================

public static int main () {	int arg;	byte b = 4;	var d = new derived (-5, ref b, out arg);	if (d.field != -5) return 1;	if (d.fieldref != 4) return 2;	
ok 

========================= mono sample_3614 =========================

public static void main (string[] args) {	if (args.length == 0) {	
usage mono tlssave exe url 

public static void main (string[] args) {	if (args.length == 0) {	return;	} else if (args.length > 64) {	
waithandle has a limit of handles so you cannot process urls 

public static void main (string[] args) {	if (args.length == 0) {	return;	} else if (args.length > 64) {	return;	}	servicepointmanager.certificatepolicy = new testcertificatepolicy ();	int id = 1;	foreach (string url in args) {	
get at 

private static void streamcallback (iasyncresult result) {	state state = ((state) result.asyncstate);	int length = state.stream.endread (result);	if (length > 0) {	state.file.write (state.buffer, 0, length);	state.stream.beginread (state.buffer, 0, state.buffer.length, new asynccallback (streamcallback), state);	} else {	state.stream.close ();	
end 

========================= mono sample_20578 =========================

public static int main (string[] args) {	int c = 0;	try {	c = 0;	}	catch (exception e) {	
exception 

public static int main (string[] args) {	int c = 0;	try {	c = 0;	}	catch (exception e) {	}	finally {	
finally 

========================= mono sample_362 =========================

public static void unindexedcollectionevents() {	icollection<int> coll = new arraylist<int>();	icollection<int> bag1 = new hashbag<int>();	bag1.addall(new int[] { 3, 2, 5, 5, 7, 7, 5, 3, 7, 7 });	coll.collectionchanged += delegate(object c)  {	
collection changed 

public static void unindexedcollectionevents() {	icollection<int> coll = new arraylist<int>();	icollection<int> bag1 = new hashbag<int>();	bag1.addall(new int[] { 3, 2, 5, 5, 7, 7, 5, 3, 7, 7 });	coll.collectionchanged += delegate(object c)  {	};	coll.collectioncleared += delegate(object c, clearedeventargs args) {	
collection cleared 

public static void unindexedcollectionevents() {	icollection<int> coll = new arraylist<int>();	icollection<int> bag1 = new hashbag<int>();	bag1.addall(new int[] { 3, 2, 5, 5, 7, 7, 5, 3, 7, 7 });	coll.collectionchanged += delegate(object c)  {	};	coll.collectioncleared += delegate(object c, clearedeventargs args) {	};	coll.itemsadded += delegate(object c, itemcounteventargs<int> args) {	
item added 

};	coll.itemsadded += delegate(object c, itemcounteventargs<int> args) {	};	additemsaddedcounter(coll);	additemsremovedcounter(coll);	coll.addall(bag1);	coll.removeall(new int[] { 2, 5, 6, 3, 7, 2 });	coll.clear();	icollection<int> bag2 = new hashbag<int>();	bag2.itemsadded += delegate(object c, itemcounteventargs<int> args) {	
copies of added 

additemsaddedcounter(coll);	additemsremovedcounter(coll);	coll.addall(bag1);	coll.removeall(new int[] { 2, 5, 6, 3, 7, 2 });	coll.clear();	icollection<int> bag2 = new hashbag<int>();	bag2.itemsadded += delegate(object c, itemcounteventargs<int> args) {	};	bag2.addall(bag1);	bag2.itemsremoved += delegate(object c, itemcounteventargs<int> args) {	
copies of removed 

private static void additemsaddedcounter<t>(icollection<t> coll) {	int addedcount = 0;	coll.itemsadded += delegate(object c, itemcounteventargs<t> args) {	addedcount += args.count;	};	coll.collectionchanged += delegate(object c) {	
items were added 

private static void additemsremovedcounter<t>(icollection<t> coll) {	int removedcount = 0;	coll.itemsremoved += delegate(object c, itemcounteventargs<t> args) {	removedcount += args.count;	};	coll.collectionchanged += delegate(object c) {	
items were removed 

public static void indexedcollectionevents() {	ilist<int> coll = new arraylist<int>();	icollection<int> bag = new hashbag<int>();	bag.addall(new int[] { 3, 2, 5, 5, 7, 7, 5, 3, 7, 7 });	coll.iteminserted += delegate(object c, itemateventargs<int> args)  {	
item inserted at 

public static void indexedcollectionevents() {	ilist<int> coll = new arraylist<int>();	icollection<int> bag = new hashbag<int>();	bag.addall(new int[] { 3, 2, 5, 5, 7, 7, 5, 3, 7, 7 });	coll.iteminserted += delegate(object c, itemateventargs<int> args)  {	};	coll.insertall(0, bag);	coll.itemremovedat += delegate(object c, itemateventargs<int> args)  {	
item removed at 

========================= mono sample_30560 =========================

errorclosed.set();	}	};	p.exited += (object sender, eventargs e) => {	exited.set ();	};	p.enableraisingevents = true;	p.start();	p.beginerrorreadline();	p.beginoutputreadline();	
started waiting for handles 

========================= mono sample_23711 =========================

static void main(string[] args) {	try {	compilationsection section = (compilationsection)configurationmanager.getsection ("system.web/compilation");	section = (compilationsection)configurationmanager.getsection ("system.web/compilation");	
there are assemblies listed in the section 

========================= mono sample_29834 =========================

a a = new a();	a.counter++;	if (a.counter != null) return 1;	++a.counter;	if (a.counter != null) return 2;	a.counter = 0;	a.counter++;	if (a.counter != 1) return 3;	++a.counter;	if (a.counter != 2) return 4;	
ok 

========================= mono sample_2294 =========================

public void receiverequest () {	replyhandler handler = delegate (message input) {	
processing a reply 

requestreceiver receiver = delegate () {	return mreq;	};	ichannellistener<ireplychannel> listener = createlistener (replyhandler, receiver);	listener.open ();	ireplychannel reply = listener.acceptchannel ();	reply.open ();	requestsender reqhandler = delegate (message input) {	try {	requestcontext ctx = reply.endreceiverequest (reply.beginreceiverequest (timespan.fromseconds (5), null, null));	
acquired requestcontext 

};	ichannellistener<ireplychannel> listener = createlistener (replyhandler, receiver);	listener.open ();	ireplychannel reply = listener.acceptchannel ();	reply.open ();	requestsender reqhandler = delegate (message input) {	try {	requestcontext ctx = reply.endreceiverequest (reply.beginreceiverequest (timespan.fromseconds (5), null, null));	ctx.reply (input);	} catch (exception ex) {	
error during processing a request in fullrequest 

} catch (exception ex) {	console.error.writeline (ex);	console.error.flush ();	throw;	}	return mreply;	};	custombinding b = createbinding (reqhandler);	irequestchannel ch = channelfactory<irequestchannel>.createchannel (b, address);	ch.open ();	
starting a request 

console.error.writeline (ex);	console.error.flush ();	throw;	}	return mreply;	};	custombinding b = createbinding (reqhandler);	irequestchannel ch = channelfactory<irequestchannel>.createchannel (b, address);	ch.open ();	iasyncresult async = ch.beginrequest (mreq, null, null);	
request started 

========================= mono sample_31271 =========================

}	helperindexes = codepointindexer.compressarray ( helperindexes, typeof (short), nutil.helper) as short [];	cout.writeline ("static const guint16 helperindex [] = {");	csout.writeline ("static short [] helperindexarr = new short [] {");	for (int i = 0; i < helperindexes.length; i++) {	short value = helperindexes [i];	if (value < 10) csout.write ("{0},", value);	else csout.write ("0x{0:x04},", value);	cout.write ("{0},", value);	if (i % 16 == 15) {	
cout writeline 

}	mapindexes = codepointindexer.compressarray (mapindexes, typeof (ushort), nutil.composite) as ushort [];	cout.writeline ("static const guint16 mapidxtocomposite [] = {");	csout.writeline ("static ushort [] mapidxtocompositearr = new ushort [] {");	for (int i = 0; i < mapindexes.length; i++) {	ushort value = (ushort) mapindexes [i];	if (value < 10) csout.write ("{0},", value);	else csout.write ("0x{0:x04},", value);	cout.write ("{0},", value);	if (i % 16 == 15) {	
cout writeline 

private void dumpmaparray (int [] array, int count, bool getcp) {	if (array.length < count) throw new argumentoutofrangeexception ("count");	for (int i = 0; i < count; i++) {	int value = array [i];	if (value < 10) csout.write ("{0}, ", value);	else csout.write ("0x{0:x}, ", value);	cout.write ("{0},", value);	if (i % 16 == 15) {	int l = getcp ? nutil.mapcp (i) : i;	
cout writeline 

private void dumpproparray (int [] array, int count, bool getcp) {	if (array.length < count) throw new argumentoutofrangeexception ("count");	for (int i = 0; i < count; i++) {	uint value = (uint) array [i];	if (value < 10) csout.write ("{0}, ", value);	else csout.write ("0x{0:x}, ", value);	cout.write ("{0},", value);	if (i % 16 == 15) {	int l = getcp ? nutil.propcp (i) : i;	
cout writeline 

byte [] ret = (byte []) codepointindexer.compressarray ( combining, typeof (byte), nutil.combining);	cout = new streamwriter ("normalization-tables.h", true);	cout.writeline ("static const guint8 combiningclass [] = {");	csout.writeline ("public static byte [] combiningclassarr = new byte [] {");	for (int i = 0; i < ret.length; i++) {	byte value = ret [i];	if (value < 10) csout.write ("{0},", value);	else csout.write ("0x{0:x02},", value);	cout.write ("{0},", value);	if (i % 16 == 15) {	
cout writeline 

========================= mono sample_27866 =========================

public override void renderbegintag (htmltextwriter w) {	
renderbegintag 

protected internal override void rendercontents (htmltextwriter w) {	
rendercontents 

public override void renderendtag (htmltextwriter w) {	
renderendtag 

========================= mono sample_19093 =========================

public override void print (textwriter tw, ilprinter<apc> printer, func<cfgblock, ienumerable<sequence<edge<cfgblock, edgetag>>>> contextlookup, sequence<edge<cfgblock, edgetag>> context, hashset<pair<subroutine, sequence<edge<cfgblock, edgetag>>>> printed) {	var element = new pair<subroutine, sequence<edge<cfgblock, edgetag>>> (this, context);	if (printed.contains (element)) return;	printed.add (element);	var subs = new hashset<subroutine> ();	var methodinfo = this as imethodinfo;	string method = (methodinfo != null) ? string.format ("({0})", this.subroutinefacade.metadataprovider.fullname (methodinfo.method)) : null;	
subroutine sr 

public override void print (textwriter tw, ilprinter<apc> printer, func<cfgblock, ienumerable<sequence<edge<cfgblock, edgetag>>>> contextlookup, sequence<edge<cfgblock, edgetag>> context, hashset<pair<subroutine, sequence<edge<cfgblock, edgetag>>>> printed) {	var element = new pair<subroutine, sequence<edge<cfgblock, edgetag>>> (this, context);	if (printed.contains (element)) return;	printed.add (element);	var subs = new hashset<subroutine> ();	var methodinfo = this as imethodinfo;	string method = (methodinfo != null) ? string.format ("({0})", this.subroutinefacade.metadataprovider.fullname (methodinfo.method)) : null;	tw.writeline ("-------------");	foreach (blockwithlabels<label> block in this.blocks) {	tw.write ("block {0} ({1})", block.index, block.reversepostorderindex);	
target of backedge 

public override void print (textwriter tw, ilprinter<apc> printer, func<cfgblock, ienumerable<sequence<edge<cfgblock, edgetag>>>> contextlookup, sequence<edge<cfgblock, edgetag>> context, hashset<pair<subroutine, sequence<edge<cfgblock, edgetag>>>> printed) {	var element = new pair<subroutine, sequence<edge<cfgblock, edgetag>>> (this, context);	if (printed.contains (element)) return;	printed.add (element);	var subs = new hashset<subroutine> ();	var methodinfo = this as imethodinfo;	string method = (methodinfo != null) ? string.format ("({0})", this.subroutinefacade.metadataprovider.fullname (methodinfo.method)) : null;	tw.writeline ("-------------");	foreach (blockwithlabels<label> block in this.blocks) {	tw.write ("block {0} ({1})", block.index, block.reversepostorderindex);	
join point 

var methodinfo = this as imethodinfo;	string method = (methodinfo != null) ? string.format ("({0})", this.subroutinefacade.metadataprovider.fullname (methodinfo.method)) : null;	tw.writeline ("-------------");	foreach (blockwithlabels<label> block in this.blocks) {	tw.write ("block {0} ({1})", block.index, block.reversepostorderindex);	else tw.writeline ();	tw.write ("  predecessors: ");	foreach (var edge in block.subroutine.predecessoredges [block]) tw.write ("({0}, {1}) ", edge.key, edge.value.index);	tw.writeline ();	printhandlers (tw, block);	
code 

========================= mono sample_29521 =========================

public static void writeobject (binarywriter w, object o, writercontext ctx) {	#if trace if (o != null) {	
writing type 

public static void writeobject (binarywriter w, object o, writercontext ctx) {	#if trace if (o != null) {	trace.indent ();	} else {	
writing null 

#if trace if (o != null) {	trace.indent ();	} else {	}	long pos = w.basestream.position;	#endif if (o == null) {	w.write ((byte) 0);	return;	}	type t = o.gettype ();	
looking up formatter for type 

trace.indent ();	} else {	}	long pos = w.basestream.position;	#endif if (o == null) {	w.write ((byte) 0);	return;	}	type t = o.gettype ();	#endif objectformatter fmt = writemap [t] as objectformatter;	
formatter from writemap 

typeconverter converter;	converter = typedescriptor.getconverter (o);	#if trace trace.writeline (string.format ("type converter: '{0}' (to string: {1}; from {2}: {3})", converter, converter != null ? converter.canconvertto (typeof (string)) : false, t, converter != null ? converter.canconvertfrom (t) : false));	#endif if (converter == null || converter.gettype () == typeof (typeconverter) || !converter.canconvertto (typeof (string)) || !converter.canconvertfrom (typeof (string))) fmt = binaryobjectformatter;	else {	typeconverterformatter.converter = converter;	fmt = typeconverterformatter;	}	}	}	
writing with formatter 

#if trace trace.writeline (string.format ("type converter: '{0}' (to string: {1}; from {2}: {3})", converter, converter != null ? converter.canconvertto (typeof (string)) : false, t, converter != null ? converter.canconvertfrom (t) : false));	#endif if (converter == null || converter.gettype () == typeof (typeconverter) || !converter.canconvertto (typeof (string)) || !converter.canconvertfrom (typeof (string))) fmt = binaryobjectformatter;	else {	typeconverterformatter.converter = converter;	fmt = typeconverterformatter;	}	}	}	#endif fmt.write (w, o, ctx);	#if trace trace.unindent ();	
wrote type bytes 

========================= mono sample_20253 =========================

public static int main () {	if (test<string> () () != typeof (string)) return 1;	if (test<int> () () != typeof (int)) return 2;	
ok 

========================= mono sample_2253 =========================

public static int test_0_marshal_handleref_argument () {	object o = new object ();	
before 

public static int test_0_marshal_handleref_argument () {	object o = new object ();	handleref s = new handleref (o, (intptr) 0xeadcafe);	if (mono_xr (s) != (0xeadcafe + 1234)) return 1;	
after 

========================= mono sample_418 =========================

public static int main (string[] args) {	int result = addabunchofints (__arglist ( 2, 3, 4 ));	
answer 

public static int main (string[] args) {	int result = addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	
answer 

public static int main (string[] args) {	int result = addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	class1 s = new class1 ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	
answer 

public static int main (string[] args) {	int result = addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	class1 s = new class1 ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	
answer 

int result = addabunchofints (__arglist ( 2, 3, 4 ));	if (result != 9) return 1;	result = addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	class1 s = new class1 ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	
answer 

result = addasecondbunchofints (16, __arglist ( 2, 3, 4 ));	if (result != 9) return 2;	class1 s = new class1 ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	if (result != 14) return 5;	result = s.instvtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 )).res;	
answer 

class1 s = new class1 ();	result = s.instaddabunchofints (__arglist ( 2, 3, 4, 5 ));	if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	if (result != 14) return 5;	result = s.instvtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 )).res;	if (result != 20) return 6;	result = vtaddabunchofints (__arglist ( 2, 3, 4, 5, 1 )).res;	
answer 

if (result != 14) return 3;	result = s.instaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 ));	if (result != 20) return 4;	result = s.instvtaddabunchofints (__arglist ( 2, 3, 4, 5 )).res;	if (result != 14) return 5;	result = s.instvtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6 )).res;	if (result != 20) return 6;	result = vtaddabunchofints (__arglist ( 2, 3, 4, 5, 1 )).res;	if (result != 15) return 7;	result = vtaddasecondbunchofints (16, __arglist ( 2, 3, 4, 5, 6, 1 )).res;	
answer 

========================= mono sample_2342 =========================

manifestresourcenames = new itaskitem [resourcefiles.length];	for (int i = 0; i < resourcefiles.length; i ++) {	itaskitem item = resourcefiles [i];	string filename = item.itemspec;	stream binarystream = null;	try {	string dependentuponfilename = item.getmetadata ("dependentupon");	if (!string.isnullorempty (dependentuponfilename)) {	dependentuponfilename = path.getfullpath (path.combine (path.getdirectoryname ( filename), dependentuponfilename));	if (!file.exists (dependentuponfilename)) {	
unable to create resource name for as dependent file was not found 

========================= mono sample_22247 =========================

while (pairsremaining.count > 0) {	currentpair = pairsremaining.dequeue();	activity activity1 = currentpair.key;	activity activity2 = currentpair.value;	visited.add(activity1);	sourcelocation sourcelocation;	if (trygetsourcelocation(activity2, path, checksum, out sourcelocation)) {	mapping.add(activity1, sourcelocation);	}	else if (!((activity2 is iexpressioncontainer) || (activity2 is ivalueserializableexpression))) {	
workflowdebugger does not have corresponding xaml node for 

else if (!((activity2 is iexpressioncontainer) || (activity2 is ivalueserializableexpression))) {	}	if (!((activity1 is iexpressioncontainer) || (activity2 is iexpressioncontainer) || (activity1 is ivalueserializableexpression) || (activity2 is ivalueserializableexpression))) {	ienumerator<activity> enumerator1 = workflowinspectionservices.getactivities(activity1).getenumerator();	ienumerator<activity> enumerator2 = workflowinspectionservices.getactivities(activity2).getenumerator();	bool hasnextitem1 = enumerator1.movenext();	bool hasnextitem2 = enumerator2.movenext();	while (hasnextitem1 && hasnextitem2) {	if (!visited.contains(enumerator1.current)) {	if (enumerator1.current.gettype() != enumerator2.current.gettype()) {	
unmatched type vs 

while (hasnextitem1 && hasnextitem2) {	if (!visited.contains(enumerator1.current)) {	if (enumerator1.current.gettype() != enumerator2.current.gettype()) {	}	pairsremaining.enqueue(new keyvaluepair<activity, activity>(enumerator1.current, enumerator2.current));	}	hasnextitem1 = enumerator1.movenext();	hasnextitem2 = enumerator2.movenext();	}	if (hasnextitem1 || hasnextitem2) {	
unmatched number of children 

========================= mono sample_10504 =========================

protected override void ongotfocus (eventargs e) {	
webbrowserbase ongotfocus 

protected override void onlostfocus (eventargs e) {	
webbrowserbase onlostfocus 

private void onwebhostfocus (object sender, eventargs e) {	
webbrowserbase onwebhostfocus 

========================= mono sample_25906 =========================

try {	console.writeline ("defaultprovider = {0}", protectedconfiguration.defaultprovider);	rsaprotectedconfigurationprovider rsa = (rsaprotectedconfigurationprovider)protectedconfiguration.providers [protectedconfiguration.defaultprovider];	console.writeline (rsa.name);	console.writeline ("cspprovidername = '{0}'", rsa.cspprovidername == null ? "(null)" : rsa.cspprovidername);	console.writeline ("keycontainername = '{0}'", rsa.keycontainername == null ? "(null)" : rsa.keycontainername);	console.writeline ("usemachinecontainer = '{0}'", rsa.usemachinecontainer);	console.writeline ("useoaep = '{0}'", rsa.useoaep);	}	catch (exception e) {	
exception raised 

========================= mono sample_29851 =========================

public delegate void foodelegate ();	public class x {	public static readonly foodelegate print = delegate {	
delegate 

========================= mono sample_2131 =========================

public static void testcolor (color color) {	
color 

========================= mono sample_25817 =========================

private static int dotest (string type, string expected, string actual, int failcode) {	if (!actual.equals (expected)) {	
bad expected was 

========================= mono sample_2071 =========================

public void trials () {	
trials 

========================= mono sample_23378 =========================

public static int main () {	if (values.count != 3) return 1;	
ok 

========================= mono sample_2051 =========================

foreach (protectedconfigurationprovider pc in protectedconfiguration.providers) {	console.writeline (pc.name);	if (pc is rsaprotectedconfigurationprovider) {	rsaprotectedconfigurationprovider rsa = (rsaprotectedconfigurationprovider)pc;	console.writeline ("keycontainername = {0}", rsa.keycontainername);	console.writeline ("usemachinecontainer = {0}", rsa.usemachinecontainer);	}	}	}	catch (typeloadexception e) {	
typeloadexception 

if (pc is rsaprotectedconfigurationprovider) {	rsaprotectedconfigurationprovider rsa = (rsaprotectedconfigurationprovider)pc;	console.writeline ("keycontainername = {0}", rsa.keycontainername);	console.writeline ("usemachinecontainer = {0}", rsa.usemachinecontainer);	}	}	}	catch (typeloadexception e) {	}	catch (exception e) {	
exception raised 

========================= mono sample_29820 =========================

public static void main (string[] args) {	if (args.length < 2) usage ();	app app = new app (args [0], args [1]);	try {	app.run ();	} catch (exception ex) {	
failed to install template in 

public static void main (string[] args) {	if (args.length < 2) usage ();	app app = new app (args [0], args [1]);	try {	app.run ();	} catch (exception ex) {	
exception 

static void usage () {	
usage installvst vstemplatefile destinationpath 

========================= mono sample_1329 =========================

static internal bitmap get (string name) {	stream stream = assembly.getmanifestresourcestream (name);	if (stream == null) {	
failed to read 

static internal icon geticon (string name) {	stream stream = assembly.getmanifestresourcestream (name);	if (stream == null) {	
failed to read 

========================= mono sample_25866 =========================

static void m (object sender, eventargs args) {	
hook invoked 

========================= mono sample_2222 =========================

public void resolveentityandbaseuri () {	string world = path.combine (path.gettemppath (), "world.txt");	string dtd = path.combine (path.gettemppath (), "doc.dtd");	try {	using (textwriter w = file.createtext (world)) {	
world 

public void resolveentityandbaseuri () {	string world = path.combine (path.gettemppath (), "world.txt");	string dtd = path.combine (path.gettemppath (), "doc.dtd");	try {	using (textwriter w = file.createtext (world)) {	}	using (textwriter w = file.createtext (dtd)) {	
dummy 

========================= mono sample_22376 =========================

static int main () {	blah a = new blah ("abc", 1);	blah b = new blah ("ab" + 'c', 1);	long start, end;	start = environment.tickcount;	start = environment.tickcount;	for (int i = 0; i < 1000000; i++) a.gethashcode ();	end = environment.tickcount;	
struct common gethashcode 

blah a = new blah ("abc", 1);	blah b = new blah ("ab" + 'c', 1);	long start, end;	start = environment.tickcount;	start = environment.tickcount;	for (int i = 0; i < 1000000; i++) a.gethashcode ();	end = environment.tickcount;	start = environment.tickcount;	for (int i = 0; i < 1000000; i++) a.equals (b);	end = environment.tickcount;	
struct common equals 

for (int i = 0; i < 1000000; i++) a.gethashcode ();	end = environment.tickcount;	start = environment.tickcount;	for (int i = 0; i < 1000000; i++) a.equals (b);	end = environment.tickcount;	blah2 a2 = new blah2 ("abc", 1);	blah2 b2 = new blah2 ("abc", 1);	start = environment.tickcount;	for (int i = 0; i < 1000000; i++) a2.gethashcode ();	end = environment.tickcount;	
struct specific gethashcode 

for (int i = 0; i < 1000000; i++) a.equals (b);	end = environment.tickcount;	blah2 a2 = new blah2 ("abc", 1);	blah2 b2 = new blah2 ("abc", 1);	start = environment.tickcount;	for (int i = 0; i < 1000000; i++) a2.gethashcode ();	end = environment.tickcount;	start = environment.tickcount;	for (int i = 0; i < 1000000; i++) a2.equals (b2);	end = environment.tickcount;	
struct specific equals 

========================= mono sample_77 =========================

public foo () {	my_a = totalinstances++;	
instance ctor 

public void dispose () {	
instance dispose 

========================= mono sample_3189 =========================

private void detach() {	
wde debugcontroller detach 

private void attachtimercallback(object state) {	
wde debugcontroller attachtimercallback 

private void ondomainunload(object sender, system.eventargs e) {	
wde debugcontroller ondomainunload 

foreach (workflowinstance instance in this.servicecontainer.getloadedworkflows()) {	workflowexecutor executor = instance.getworkflowresourceunsafe();	using (executor.executorlock.enter()) {	loadexistinginstance(instance, true);	}	}	this.eventconduitattached.set();	}	}	catch (exception e) {	
wde failure in debugcontroller attachtoconduit call stack 

private void start(object source, workflowruntimeeventargs e) {	
wde debugcontroller servicecontainerstarted 

private void stop(object source, workflowruntimeeventargs e) {	
wde debugcontroller servicecontainerstopped 

========================= mono sample_10790 =========================

public static int main () {	unsafe {	int* i;	int foo = 10;	void* bar;	i = &foo;	bar = i;	
address 

========================= mono sample_3249 =========================

switch (_checkstate) {	case checkstate.unchecked: e.newvalue = checkstate.unchecked;	changed = true;	break;	case checkstate.checked: e.newvalue = checkstate.checked;	changed = true;	break;	default: global::system.diagnostics.debug.assert(_checkstate == checkstate.indeterminate);	break;	}	
itemcheck item current new was is 

========================= mono sample_25522 =========================

if (~a3 != -2) return 12;	if (~a4 != 4294967289) return 13;	if (~a5 != -9) return 14;	if (~a6 != -3) return 15;	mydecimal d = new mydecimal ();	if (-d != -42) return 20;	e e = e.value;	if (~e != (e)4294967271) return 21;	uint dp = 0;	dp = +dp;	
ok 

========================= mono sample_2216 =========================

public override bool check() {	bool retval = true;	if (underlyingsize > array.length) {	
underlyingsize array length 

public override bool check() {	bool retval = true;	if (underlyingsize > array.length) {	return false;	}	if (offset + size > underlyingsize) {	
offset size underlyingsize 

public override bool check() {	bool retval = true;	if (underlyingsize > array.length) {	return false;	}	if (offset + size > underlyingsize) {	return false;	}	if (offset < 0) {	
offset 

return false;	}	if (offset + size > underlyingsize) {	return false;	}	if (offset < 0) {	return false;	}	for (int i = 0; i < underlyingsize; i++) {	if ((object)(array[i]) == null) {	
bad element null at base index 

for (int i = underlyingsize, length = array.length; i < length; i++) {	if (!equals(array[i], default(t))) {	console.writeline("bad element: != default(t) at (base)index {0}", i);	retval = false;	}	}	{	arraylist<t> u = underlying ?? this;	if (u.views != null) foreach (arraylist<t> v in u.views) {	if (u.array != v.array) {	
view from of length has different base array than the underlying list 

}	}	}	#if hashindex if (underlyingsize != itemindex.count) {	console.writeline("size ({0})!= index.count ({1})", size, itemindex.count);	retval = false;	}	for (int i = 0; i < underlyingsize; i++) {	keyvaluepair<t, int> p = new keyvaluepair<t, int>(array[i]);	if (!itemindex.find(ref p)) {	
item at not in hashindex 

#if hashindex if (underlyingsize != itemindex.count) {	console.writeline("size ({0})!= index.count ({1})", size, itemindex.count);	retval = false;	}	for (int i = 0; i < underlyingsize; i++) {	keyvaluepair<t, int> p = new keyvaluepair<t, int>(array[i]);	if (!itemindex.find(ref p)) {	retval = false;	}	if (p.value != i) {	
item at has hashindex 

========================= mono sample_30540 =========================

public static int main () {	int [][] i = new int [2][];	int [,][] j = new int [3,6][];	blah [] k = new blah [2];	blah [,][] l = new blah [3,4][];	uri [] uri = new uri [4];	
all arrays successfully created 

========================= mono sample_3634 =========================

static void main () {	t t = delegate {	goto l;	};	
hello 

========================= mono sample_34118 =========================

public delegate r function<t1, t2, r>(t1 arg1, t2 arg2);	public static int main () {	delegate [] e = new delegate [] {	new function<ilist,ilist,int> (f2), new function<ilist,object,int> (f2) };	if ((int)e [0].dynamicinvoke (null, null) != 1) return 1;	if ((int) e [1].dynamicinvoke (null, null) != 2) return 2;	
ok 

========================= mono sample_3966 =========================

private xplatuix11_new() {	refcount = 0;	messagequeues = hashtable.synchronized (new hashtable(7));	if (xlib.xinitthreads() == 0) {	
failed xinitthreads the event loop will not function properly 

========================= mono sample_26394 =========================

}	for (j = 5; j < name.length; ++j) if (!char.isdigit (name [j])) break;	expected = int32.parse (name.substring (5, j - 5));	start = datetime.now;	result = (int)methods [i].invoke (null, null);	if (do_timings) {	end = datetime.now;	long tdiff = end.ticks - start.ticks;	int mdiff = (int)tdiff/10000;	tms += mdiff;	
took ms 

result = (int)methods [i].invoke (null, null);	if (do_timings) {	end = datetime.now;	long tdiff = end.ticks - start.ticks;	int mdiff = (int)tdiff/10000;	tms += mdiff;	}	ran++;	if (result != expected) {	failed++;	
failed got expected 

long tdiff = end.ticks - start.ticks;	int mdiff = (int)tdiff/10000;	tms += mdiff;	}	ran++;	if (result != expected) {	failed++;	}	}	if (do_timings) {	
total ms 

int mdiff = (int)tdiff/10000;	tms += mdiff;	}	ran++;	if (result != expected) {	failed++;	}	}	if (do_timings) {	}	
regression tests ran failed in 

========================= mono sample_1542 =========================

private async task bar() {	
something await foo 

========================= mono sample_3447 =========================

public static int main () {	
from to 

========================= mono sample_3884 =========================

a = 2;	b = interlocked.decrement (ref a);	if (b != 1) return 7;	if (a != 1) return 8;	string s = inctest ();	if (s != "a1") return 9;	s = inctest ();	if (s != "a2") return 10;	thread.memorybarrier ();	interlocked_regalloc1 ();	
done 

========================= mono sample_160 =========================

const int foo = 10;	int j = blah.i;	if (j != 5) return 1;	if (foo != 10) return 1;	for (int i = 0; i < 5; ++i){	const int bar = 15;	console.writeline (bar);	console.writeline (foo);	}	if ((aaa + bbb) != 3) return 2;	
constant emission test okay 

========================= mono sample_3416 =========================

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	
start returns 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	
process is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	
pid is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	
handle is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	
handlecount is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	
waiting for exit 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	proc.waitforexit();	
wait returned 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	proc.waitforexit();	
exit code is 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	proc.waitforexit();	
process started at 

static void run() {	process proc = new process();	bool ret;	proc.startinfo.filename="wibble";	proc.startinfo.arguments="arg1    arg2\targ3 \"arg4a arg4b\"";	proc.startinfo.useshellexecute=false;	ret=proc.start();	proc.waitforexit();	
process ended at 

========================= mono sample_327 =========================

if (!b) return 41;	b = o is c1 (0);	if (b) return 5;	valuetype vt = new s ();	b = vt is s (null, 0);	if (b) return 6;	b = vt is s (8, 0);	if (b) return 7;	b = vt is s (8, 2);	if (!b) return 8;	
ok 

========================= mono sample_1585 =========================

public static void main (string[] argv) {	
test 

========================= mono sample_3711 =========================

public testtextwritertracelistener(textwriter textwriter): base(textwriter) {	
textwritertracelistener is instantiated 

========================= mono sample_23705 =========================

public static void main (string[] args) {	int low = 2000;	int high = 2000;	
using system 

public static void main (string[] args) {	int low = 2000;	int high = 2000;	console.writeline ();	for (int count = low; count <= high; ++count) {	
public interface iface 

public static void main (string[] args) {	int low = 2000;	int high = 2000;	console.writeline ();	for (int count = low; count <= high; ++count) {	for (int i = 0; i <= count; ++i) console.writeline ("    int method_" + i + " (int a, int b, int c, int d);");	console.writeline ("}");	
public class impl iface 

public static void main (string[] args) {	int low = 2000;	int high = 2000;	console.writeline ();	for (int count = low; count <= high; ++count) {	for (int i = 0; i <= count; ++i) console.writeline ("    int method_" + i + " (int a, int b, int c, int d);");	console.writeline ("}");	for (int i = 0; i <= count; ++i) console.writeline ("    public virtual int method_" + i + " (int a, int b, int c, int d) { return a - b - c -d + " + i + "; }");	console.writeline ("}");	}	
public class driver 

console.writeline ();	for (int count = low; count <= high; ++count) {	for (int i = 0; i <= count; ++i) console.writeline ("    int method_" + i + " (int a, int b, int c, int d);");	console.writeline ("}");	for (int i = 0; i <= count; ++i) console.writeline ("    public virtual int method_" + i + " (int a, int b, int c, int d) { return a - b - c -d + " + i + "; }");	console.writeline ("}");	}	console.writeline ("{");	for (int iface = low; iface <= high; ++iface) {	console.writeline ("	static iface_" + iface + " var_" + iface + " = new impl_" + iface + " ();");	
static int test 

for (int count = low; count <= high; ++count) {	for (int i = 0; i <= count; ++i) console.writeline ("    int method_" + i + " (int a, int b, int c, int d);");	console.writeline ("}");	for (int i = 0; i <= count; ++i) console.writeline ("    public virtual int method_" + i + " (int a, int b, int c, int d) { return a - b - c -d + " + i + "; }");	console.writeline ("}");	}	console.writeline ("{");	for (int iface = low; iface <= high; ++iface) {	console.writeline ("	static iface_" + iface + " var_" + iface + " = new impl_" + iface + " ();");	console.writeline ("        int res = 0;");	
int r 

console.writeline ("}");	for (int i = 0; i <= count; ++i) console.writeline ("    public virtual int method_" + i + " (int a, int b, int c, int d) { return a - b - c -d + " + i + "; }");	console.writeline ("}");	}	console.writeline ("{");	for (int iface = low; iface <= high; ++iface) {	console.writeline ("	static iface_" + iface + " var_" + iface + " = new impl_" + iface + " ();");	console.writeline ("        int res = 0;");	for (int i = 0; i < iface; ++i) {	console.writeline (string.format ("		if ((r = var_{0}.method_{1} (10,5,3,2)) != {1}) {{", iface, i));	
console writeline r 

}	console.writeline ("{");	for (int iface = low; iface <= high; ++iface) {	console.writeline ("	static iface_" + iface + " var_" + iface + " = new impl_" + iface + " ();");	console.writeline ("        int res = 0;");	for (int i = 0; i < iface; ++i) {	console.writeline (string.format ("		if ((r = var_{0}.method_{1} (10,5,3,2)) != {1}) {{", iface, i));	console.writeline ("    res = 1;");	console.writeline ("}");	}	
return res 

for (int iface = low; iface <= high; ++iface) {	console.writeline ("	static iface_" + iface + " var_" + iface + " = new impl_" + iface + " ();");	console.writeline ("        int res = 0;");	for (int i = 0; i < iface; ++i) {	console.writeline (string.format ("		if ((r = var_{0}.method_{1} (10,5,3,2)) != {1}) {{", iface, i));	console.writeline ("    res = 1;");	console.writeline ("}");	}	console.writeline ("}");	}	
public static int main 

console.writeline ("        int res = 0;");	for (int i = 0; i < iface; ++i) {	console.writeline (string.format ("		if ((r = var_{0}.method_{1} (10,5,3,2)) != {1}) {{", iface, i));	console.writeline ("    res = 1;");	console.writeline ("}");	}	console.writeline ("}");	}	console.writeline ("        int res = 0;");	for (int iface = low; iface <= high; ++iface) console.writeline (string.format ("        res |= test_{0} ();", iface));	
return res 

========================= mono sample_376 =========================

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	
node 

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	
urn urn 

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	
prefix prefix 

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	
name name 

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	
nodetype nodetype 

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	
axistype axistype 

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	
node 

public void printtree (streamwriter msw) {	for (int i = 0; i < faxisarray.count; ++i) {	forwardaxis axis = (forwardaxis)faxisarray[i];	msw.writeline("<tree isdss=\"{0}\" isattribute=\"{1}\">", axis.isdss, axis.isattribute);	doublelinkaxis printaxis = axis.topnode;	while ( printaxis != null ) {	printaxis = (doublelinkaxis) (printaxis.input);	}	
tree 

========================= mono sample_11264 =========================

public static int main () {	var t = type.gettype("mono.runtime");	if (t == null) return 1;	var setgcallowsynchronousmajor = (func<bool,bool>) delegate.createdelegate(typeof(func<bool,bool>), t, "setgcallowsynchronousmajor", ignorecase:false, throwonbindfailure:false);	if (setgcallowsynchronousmajor == null) return 1;	
could not disable synchronous major 

========================= mono sample_236 =========================

formadapter.rendercardtag(this, attributes);	if ((_formvariables != null && _formvariables.count > 0) && (!_providebackbutton || device.canrenderoneventandprevelementstogether)) {	_writtenformvariables = true;	write("<onevent type=\"onenterforward\"><refresh>");	foreach (dictionaryentry entry in _formvariables) {	writebegintag("setvar");	writeattribute("name", (string)entry.key);	writetextencodedattribute("value", (string)entry.value);	write(" />");	}	
refresh onevent 

private void renderpostbackcards() {	for (int i = 0; i < 2; i++) {	if (_writtenpostbacktype[i]) {	writebegintag("card");	writeattribute("id", i == 0 ? _postbackwithvarscardid : _postbackwithoutvarscardid);	writeline(">");	write("<onevent type=\"onenterforward\">");	rendergoaction(null, _postbackeventargumentvarname, wmlpostfieldtype.variable, i == 0);	
onevent 

private void renderpostbackcards() {	for (int i = 0; i < 2; i++) {	if (_writtenpostbacktype[i]) {	writebegintag("card");	writeattribute("id", i == 0 ? _postbackwithvarscardid : _postbackwithoutvarscardid);	writeline(">");	write("<onevent type=\"onenterforward\">");	rendergoaction(null, _postbackeventargumentvarname, wmlpostfieldtype.variable, i == 0);	writeline("<onevent type=\"onenterbackward\"><prev /></onevent>");	
card 

========================= mono sample_6025 =========================

public bool validate() {	if (!validatewarned) {	
containercontrol validate is not yet implemented 

========================= mono sample_26302 =========================

public void endelement () {	
dispatcher endelement depth 

public nvdlsection (nvdldispatcher dispatcher, nvdlsection parentstate) {	this.dispatcher = dispatcher;	this.ns = dispatcher.reader.namespaceuri;	if (parentstate == null) {	foreach (simpleaction a in findelementrule ( dispatcher.rules.startmode, dispatcher.reader).actions) ilist.add (getinterp (a, dispatcher));	} else {	foreach (nvdlinterpretation pi in parentstate.ilist) {	populateinterp (dispatcher, pi, parentstate);	}	}	
new section ns interp count loc 

private nvdlinterpretation createinterp (nvdldispatcher d, simplemode m, simpleaction a, nvdlinterpretation p) {	
new interp from action from mode 

private void populateinterp ( nvdldispatcher d, nvdlinterpretation i, nvdlsection parentstate) {	simplemode m = findcontextmode (i.action, parentstate);	simplerule rule = findelementrule (m, dispatcher.reader);	
populate interp from action whose mode is rule is whose actions are 

private void populateinterp ( nvdldispatcher d, nvdlinterpretation i, nvdlsection parentstate) {	simplemode m = findcontextmode (i.action, parentstate);	simplerule rule = findelementrule (m, dispatcher.reader);	foreach (simpleaction a in rule.actions) {	nvdlinterpretation cur = i;	for (;cur != null; cur = cur.parent) if (cur.createdmode == m && cur.action == a) {	
corresponding planelem already exists 

private simplemode findcontextmode (simpleaction a, nvdlsection parentstate) {	if (a.contexts != null) foreach (simplecontext ctx in a.contexts) foreach (simplepath path in ctx.path) if (matchpath (path, parentstate)) {	
matched context at 

private simplerule findelementrule (simplemode mode, xmlreader reader) {	simplerule any = null;	foreach (simplerule rule in mode.elementrules) {	if (rule.matchns (reader.namespaceuri)) {	if (!rule.isany) return rule;	else any = rule;	}	}	
anynamespace rule being applied 

public void endsection () {	
section endsection 

public void startelement () {	
section startelement 

public void endelement () {	
section endelement interp 

public abstract void whitespace ();	public abstract void validatestartelement ();	public abstract void validateendelement ();	public abstract void validatetext ();	public abstract void validatewhitespace ();	public abstract void endsection ();	}	internal class nvdlresultinterp : nvdlinterpretation {	nvdlresulttype type;	public nvdlresultinterp (nvdldispatcher dispatcher, simplemode createdmode, simpleresultaction resultaction, nvdlinterpretation parent) : base (dispatcher, createdmode, resultaction, parent) {	
new resultaction 

public override void endsection () {	if (type == nvdlresulttype.attachplaceholder && parent != null) parent.detachplaceholder ();	}	public override void attachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.attachplaceholder ();	}	public override void detachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.detachplaceholder ();	}	public override void startelement () {	
result startelement 

if (type == nvdlresulttype.attachplaceholder && parent != null) parent.detachplaceholder ();	}	public override void attachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.attachplaceholder ();	}	public override void detachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.detachplaceholder ();	}	public override void startelement () {	if (type != nvdlresulttype.unwrap) validatestartelement ();	
result 

public override void attachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.attachplaceholder ();	}	public override void detachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.detachplaceholder ();	}	public override void startelement () {	if (type != nvdlresulttype.unwrap) validatestartelement ();	}	public override void endelement () {	
result endelement 

if (type == nvdlresulttype.unwrap) parent.attachplaceholder ();	}	public override void detachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.detachplaceholder ();	}	public override void startelement () {	if (type != nvdlresulttype.unwrap) validatestartelement ();	}	public override void endelement () {	if (type != nvdlresulttype.unwrap) validateendelement ();	
result 

public override void detachplaceholder () {	if (type == nvdlresulttype.unwrap) parent.detachplaceholder ();	}	public override void startelement () {	if (type != nvdlresulttype.unwrap) validatestartelement ();	}	public override void endelement () {	if (type != nvdlresulttype.unwrap) validateendelement ();	}	public override void text () {	
result text 

if (type == nvdlresulttype.unwrap) parent.detachplaceholder ();	}	public override void startelement () {	if (type != nvdlresulttype.unwrap) validatestartelement ();	}	public override void endelement () {	if (type != nvdlresulttype.unwrap) validateendelement ();	}	public override void text () {	if (type != nvdlresulttype.unwrap) validatetext ();	
result 

public override void startelement () {	if (type != nvdlresulttype.unwrap) validatestartelement ();	}	public override void endelement () {	if (type != nvdlresulttype.unwrap) validateendelement ();	}	public override void text () {	if (type != nvdlresulttype.unwrap) validatetext ();	}	public override void whitespace () {	
result whitespace 

if (type != nvdlresulttype.unwrap) validatestartelement ();	}	public override void endelement () {	if (type != nvdlresulttype.unwrap) validateendelement ();	}	public override void text () {	if (type != nvdlresulttype.unwrap) validatetext ();	}	public override void whitespace () {	if (type != nvdlresulttype.unwrap) validatewhitespace ();	
result 

if (type != nvdlresulttype.unwrap) validateendelement ();	}	public override void text () {	if (type != nvdlresulttype.unwrap) validatetext ();	}	public override void whitespace () {	if (type != nvdlresulttype.unwrap) validatewhitespace ();	}	public override void validatestartelement () {	switch (type) {	
unwrapping startelement 

public override void validatestartelement () {	switch (type) {	goto case nvdlresulttype.attach;	case nvdlresulttype.attach: parent.validatestartelement ();	break;	case nvdlresulttype.attachplaceholder: break;	}	}	public override void validateendelement () {	switch (type) {	
unwrapping endelement 

public override void validateendelement () {	switch (type) {	goto case nvdlresulttype.attach;	case nvdlresulttype.attach: parent.validateendelement ();	break;	case nvdlresulttype.attachplaceholder: break;	}	}	public override void validatetext () {	switch (type) {	
unwrapping text 

public override void validatetext () {	switch (type) {	goto case nvdlresulttype.attach;	case nvdlresulttype.attach: parent.validatetext ();	break;	case nvdlresulttype.attachplaceholder: break;	}	}	public override void validatewhitespace () {	switch (type) {	
unwrapping whitespace 

public nvdlvalidateinterp (nvdldispatcher dispatcher, simplemode createdmode, simplevalidate validate, nvdlinterpretation parent) : base (dispatcher, createdmode, validate, parent) {	
new validate 

public override void startelement () {	
validate startelement emptyelement 

public override void endelement () {	
validate endelement 

public override void validatestartelement () {	
interp validatestartelement 

public override void validateendelement () {	
interp validateendelement 

public override void validatetext () {	
interp validatetext 

public override void validatewhitespace () {	
interp whitespace 

========================= mono sample_22808 =========================

public virtual bool namefirst (ometastream<char> inputstream, out object result) {	result = null;	
ok 

========================= mono sample_154 =========================

public void eventsandprocessingorder () {	var asm = assembly.getexecutingassembly ();	var context = new xamlschemacontext (new assembly [] { asm });	var output = xamarinbug3003.testcontext.writer;	output.writeline ();	var reader = new xamlxmlreader (xmlreader.create (new stringreader (xamarinbug3003.testcontext.xmlinput)), context);	var writersettings = new xamlobjectwritersettings ();	writersettings.afterbegininithandler = (sender, e) => {	
xamlobjectwritersettings afterbegininit 

public void eventsandprocessingorder () {	var asm = assembly.getexecutingassembly ();	var context = new xamlschemacontext (new assembly [] { asm });	var output = xamarinbug3003.testcontext.writer;	output.writeline ();	var reader = new xamlxmlreader (xmlreader.create (new stringreader (xamarinbug3003.testcontext.xmlinput)), context);	var writersettings = new xamlobjectwritersettings ();	writersettings.afterbegininithandler = (sender, e) => {	};	writersettings.afterendinithandler = (sender, e) => {	
xamlobjectwritersettings afterendinit 

var context = new xamlschemacontext (new assembly [] { asm });	var output = xamarinbug3003.testcontext.writer;	output.writeline ();	var reader = new xamlxmlreader (xmlreader.create (new stringreader (xamarinbug3003.testcontext.xmlinput)), context);	var writersettings = new xamlobjectwritersettings ();	writersettings.afterbegininithandler = (sender, e) => {	};	writersettings.afterendinithandler = (sender, e) => {	};	writersettings.beforepropertieshandler = (sender, e) => {	
xamlobjectwritersettings beforeproperties 

output.writeline ();	var reader = new xamlxmlreader (xmlreader.create (new stringreader (xamarinbug3003.testcontext.xmlinput)), context);	var writersettings = new xamlobjectwritersettings ();	writersettings.afterbegininithandler = (sender, e) => {	};	writersettings.afterendinithandler = (sender, e) => {	};	writersettings.beforepropertieshandler = (sender, e) => {	};	writersettings.afterpropertieshandler = (sender, e) => {	
xamlobjectwritersettings afterproperties 

var writersettings = new xamlobjectwritersettings ();	writersettings.afterbegininithandler = (sender, e) => {	};	writersettings.afterendinithandler = (sender, e) => {	};	writersettings.beforepropertieshandler = (sender, e) => {	};	writersettings.afterpropertieshandler = (sender, e) => {	};	writersettings.xamlsetvaluehandler = (sender, e) => {	
xamlobjectwritersettings xamlsetvalue member 

};	writersettings.beforepropertieshandler = (sender, e) => {	};	writersettings.afterpropertieshandler = (sender, e) => {	};	writersettings.xamlsetvaluehandler = (sender, e) => {	};	var writer = new xamlobjectwriter (context, writersettings);	xamlservices.transform (reader, writer);	var obj = writer.result as xamarinbug3003.parent;	
loaded 

========================= mono sample_30855 =========================

public void items () {	httpcontext c = cook (10);	
ttttttttttt 

========================= mono sample_18866 =========================

static void main () {	long start, end, new_val, perc;	start = environment.tickcount;	start = environment.tickcount;	use_new ();	end = environment.tickcount;	
new took 

long start, end, new_val, perc;	start = environment.tickcount;	start = environment.tickcount;	use_new ();	end = environment.tickcount;	new_val = end-start;	start = environment.tickcount;	use_clone ();	end = environment.tickcount;	perc = ((end-start-new_val) * 100) / new_val;	
clone took 

end = environment.tickcount;	new_val = end-start;	start = environment.tickcount;	use_clone ();	end = environment.tickcount;	perc = ((end-start-new_val) * 100) / new_val;	start = environment.tickcount;	use_activator ();	end = environment.tickcount;	perc = ((end-start-new_val) * 100) / new_val;	
activator took 

end = environment.tickcount;	perc = ((end-start-new_val) * 100) / new_val;	start = environment.tickcount;	use_activator ();	end = environment.tickcount;	perc = ((end-start-new_val) * 100) / new_val;	start = environment.tickcount;	use_ctor ();	end = environment.tickcount;	perc = ((end-start-new_val) * 100) / new_val;	
ctor took 

========================= mono sample_115 =========================

x509_ptr = x509.handle.stealhandle ();	return 1;	} else {	x509_ptr = intptr.zero;	return 0;	}	} finally {	if (name_handle != null) name_handle.dispose ();	}	} catch (exception ex) {	
lookup method get by subject ex 

========================= mono sample_24097 =========================

public static int main () {	if (new y ().getit () () == 1 && new y ().getit2 () () == 1) {	
good 

========================= mono sample_3523 =========================

public void dispose () {	
disposed 

public static async task test () {	using (var device_resource = new c ()) {	try {	
aa 

public static int main() {	test ().wait ();	if (passed != 1) return 1;	
passed 

========================= mono sample_3572 =========================

if (piprecision != null) {	prec = (int)convert.changetype(piprecision.getvalue(p, null), typeof(int), cultureinfo.invariantculture);	}	propertyinfo piscale = p.gettype().getproperty("scale");	if (piscale != null) {	scale = (int)convert.changetype(piscale.getvalue(p, null), typeof(int), cultureinfo.invariantculture);	}	var sp = p as system.data.sqlclient.sqlparameter;	writer.writeline("-- {0}: {1} {2} (size = {3}; prec = {4}; scale = {5}) [{6}]", p.parametername, p.direction, sp == null ? p.dbtype.tostring() : sp.sqldbtype.tostring(), p.size.tostring(system.globalization.cultureinfo.currentculture), prec, scale, sp == null ? p.value : sp.sqlvalue);	}	
context model build 

========================= mono sample_13013 =========================

static void main () {	var nullmoneyvalue = (moneyvalue?) null;	var moneyvalue = new moneyvalue (123);	var crashapplication = nullmoneyvalue < moneyvalue;	
all ok 

========================= mono sample_3750 =========================

public static void main () {	int i = 0;	
get i 

========================= mono sample_35341 =========================

public static int main (string[] args) {	double1 s1;	s1.f1 = 1;	s1 = mono_return_double1(s1, 9);	if (s1.f1 != 1+9) {	
got but expected 

s1.f1 = 1;	s1 = mono_return_double1(s1, 9);	if (s1.f1 != 1+9) {	return 1;	}	double2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_double2(s2, 9);	if (s2.f1 != 1+9) {	
got but expected 

return 1;	}	double2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_double2(s2, 9);	if (s2.f1 != 1+9) {	return 1;	}	if (s2.f2 != 2+9) {	
got but expected 

}	if (s2.f2 != 2+9) {	return 2;	}	double3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_double3(s3, 9);	if (s3.f1 != 1+9) {	
got but expected 

}	double3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_double3(s3, 9);	if (s3.f1 != 1+9) {	return 1;	}	if (s3.f2 != 2+9) {	
got but expected 

s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_double3(s3, 9);	if (s3.f1 != 1+9) {	return 1;	}	if (s3.f2 != 2+9) {	return 2;	}	if (s3.f3 != 3+9) {	
got but expected 

if (s3.f3 != 3+9) {	return 3;	}	double4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_double4(s4, 9);	if (s4.f1 != 1+9) {	
got but expected 

double4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_double4(s4, 9);	if (s4.f1 != 1+9) {	return 1;	}	if (s4.f2 != 2+9) {	
got but expected 

s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_double4(s4, 9);	if (s4.f1 != 1+9) {	return 1;	}	if (s4.f2 != 2+9) {	return 2;	}	if (s4.f3 != 3+9) {	
got but expected 

if (s4.f1 != 1+9) {	return 1;	}	if (s4.f2 != 2+9) {	return 2;	}	if (s4.f3 != 3+9) {	return 3;	}	if (s4.f4 != 4+9) {	
got but expected 

return 4;	}	double5 s5;	s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_double5(s5, 9);	if (s5.f1 != 1+9) {	
got but expected 

s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_double5(s5, 9);	if (s5.f1 != 1+9) {	return 1;	}	if (s5.f2 != 2+9) {	
got but expected 

s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_double5(s5, 9);	if (s5.f1 != 1+9) {	return 1;	}	if (s5.f2 != 2+9) {	return 2;	}	if (s5.f3 != 3+9) {	
got but expected 

if (s5.f1 != 1+9) {	return 1;	}	if (s5.f2 != 2+9) {	return 2;	}	if (s5.f3 != 3+9) {	return 3;	}	if (s5.f4 != 4+9) {	
got but expected 

if (s5.f2 != 2+9) {	return 2;	}	if (s5.f3 != 3+9) {	return 3;	}	if (s5.f4 != 4+9) {	return 4;	}	if (s5.f5 != 5+9) {	
got but expected 

}	double6 s6;	s6.f1 = 1;	s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_double6(s6, 9);	if (s6.f1 != 1+9) {	
got but expected 

s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_double6(s6, 9);	if (s6.f1 != 1+9) {	return 1;	}	if (s6.f2 != 2+9) {	
got but expected 

s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_double6(s6, 9);	if (s6.f1 != 1+9) {	return 1;	}	if (s6.f2 != 2+9) {	return 2;	}	if (s6.f3 != 3+9) {	
got but expected 

if (s6.f1 != 1+9) {	return 1;	}	if (s6.f2 != 2+9) {	return 2;	}	if (s6.f3 != 3+9) {	return 3;	}	if (s6.f4 != 4+9) {	
got but expected 

if (s6.f2 != 2+9) {	return 2;	}	if (s6.f3 != 3+9) {	return 3;	}	if (s6.f4 != 4+9) {	return 4;	}	if (s6.f5 != 5+9) {	
got but expected 

if (s6.f3 != 3+9) {	return 3;	}	if (s6.f4 != 4+9) {	return 4;	}	if (s6.f5 != 5+9) {	return 5;	}	if (s6.f6 != 6+9) {	
got but expected 

double7 s7;	s7.f1 = 1;	s7.f2 = 2;	s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_double7(s7, 9);	if (s7.f1 != 1+9) {	
got but expected 

s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_double7(s7, 9);	if (s7.f1 != 1+9) {	return 1;	}	if (s7.f2 != 2+9) {	
got but expected 

s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_double7(s7, 9);	if (s7.f1 != 1+9) {	return 1;	}	if (s7.f2 != 2+9) {	return 2;	}	if (s7.f3 != 3+9) {	
got but expected 

if (s7.f1 != 1+9) {	return 1;	}	if (s7.f2 != 2+9) {	return 2;	}	if (s7.f3 != 3+9) {	return 3;	}	if (s7.f4 != 4+9) {	
got but expected 

if (s7.f2 != 2+9) {	return 2;	}	if (s7.f3 != 3+9) {	return 3;	}	if (s7.f4 != 4+9) {	return 4;	}	if (s7.f5 != 5+9) {	
got but expected 

if (s7.f3 != 3+9) {	return 3;	}	if (s7.f4 != 4+9) {	return 4;	}	if (s7.f5 != 5+9) {	return 5;	}	if (s7.f6 != 6+9) {	
got but expected 

if (s7.f4 != 4+9) {	return 4;	}	if (s7.f5 != 5+9) {	return 5;	}	if (s7.f6 != 6+9) {	return 6;	}	if (s7.f7 != 7+9) {	
got but expected 

s8.f1 = 1;	s8.f2 = 2;	s8.f3 = 3;	s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_double8(s8, 9);	if (s8.f1 != 1+9) {	
got but expected 

s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_double8(s8, 9);	if (s8.f1 != 1+9) {	return 1;	}	if (s8.f2 != 2+9) {	
got but expected 

s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_double8(s8, 9);	if (s8.f1 != 1+9) {	return 1;	}	if (s8.f2 != 2+9) {	return 2;	}	if (s8.f3 != 3+9) {	
got but expected 

if (s8.f1 != 1+9) {	return 1;	}	if (s8.f2 != 2+9) {	return 2;	}	if (s8.f3 != 3+9) {	return 3;	}	if (s8.f4 != 4+9) {	
got but expected 

if (s8.f2 != 2+9) {	return 2;	}	if (s8.f3 != 3+9) {	return 3;	}	if (s8.f4 != 4+9) {	return 4;	}	if (s8.f5 != 5+9) {	
got but expected 

if (s8.f3 != 3+9) {	return 3;	}	if (s8.f4 != 4+9) {	return 4;	}	if (s8.f5 != 5+9) {	return 5;	}	if (s8.f6 != 6+9) {	
got but expected 

if (s8.f4 != 4+9) {	return 4;	}	if (s8.f5 != 5+9) {	return 5;	}	if (s8.f6 != 6+9) {	return 6;	}	if (s8.f7 != 7+9) {	
got but expected 

if (s8.f5 != 5+9) {	return 5;	}	if (s8.f6 != 6+9) {	return 6;	}	if (s8.f7 != 7+9) {	return 7;	}	if (s8.f8 != 8+9) {	
got but expected 

s9.f2 = 2;	s9.f3 = 3;	s9.f4 = 4;	s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_double9(s9, 9);	if (s9.f1 != 1+9) {	
got but expected 

s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_double9(s9, 9);	if (s9.f1 != 1+9) {	return 1;	}	if (s9.f2 != 2+9) {	
got but expected 

s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_double9(s9, 9);	if (s9.f1 != 1+9) {	return 1;	}	if (s9.f2 != 2+9) {	return 2;	}	if (s9.f3 != 3+9) {	
got but expected 

if (s9.f1 != 1+9) {	return 1;	}	if (s9.f2 != 2+9) {	return 2;	}	if (s9.f3 != 3+9) {	return 3;	}	if (s9.f4 != 4+9) {	
got but expected 

if (s9.f2 != 2+9) {	return 2;	}	if (s9.f3 != 3+9) {	return 3;	}	if (s9.f4 != 4+9) {	return 4;	}	if (s9.f5 != 5+9) {	
got but expected 

if (s9.f3 != 3+9) {	return 3;	}	if (s9.f4 != 4+9) {	return 4;	}	if (s9.f5 != 5+9) {	return 5;	}	if (s9.f6 != 6+9) {	
got but expected 

if (s9.f4 != 4+9) {	return 4;	}	if (s9.f5 != 5+9) {	return 5;	}	if (s9.f6 != 6+9) {	return 6;	}	if (s9.f7 != 7+9) {	
got but expected 

if (s9.f5 != 5+9) {	return 5;	}	if (s9.f6 != 6+9) {	return 6;	}	if (s9.f7 != 7+9) {	return 7;	}	if (s9.f8 != 8+9) {	
got but expected 

if (s9.f6 != 6+9) {	return 6;	}	if (s9.f7 != 7+9) {	return 7;	}	if (s9.f8 != 8+9) {	return 8;	}	if (s9.f9 != 9+9) {	
got but expected 

return 8;	}	if (s9.f9 != 9+9) {	return 9;	}	double2_nested sn2;	sn2.nested1.f1 = 1;	sn2.nested2.f2 = 2;	sn2 = mono_return_double2_nested(sn2, 9);	if (sn2.nested1.f1 != 1+9) {	
nested got but expected 

return 9;	}	double2_nested sn2;	sn2.nested1.f1 = 1;	sn2.nested2.f2 = 2;	sn2 = mono_return_double2_nested(sn2, 9);	if (sn2.nested1.f1 != 1+9) {	return 1;	}	if (sn2.nested2.f2 != 2+9) {	
nested got but expected 

}	if (sn2.nested2.f2 != 2+9) {	return 2;	}	unsafe {	double_array4 sa4;	sa4.f1[0] = 1;	sa4.f1[1] = 2;	sa4 = mono_return_double_array4(sa4, 9);	if (sa4.f1[0] != 1+9) {	
double got but expected 

}	unsafe {	double_array4 sa4;	sa4.f1[0] = 1;	sa4.f1[1] = 2;	sa4 = mono_return_double_array4(sa4, 9);	if (sa4.f1[0] != 1+9) {	return 1;	}	if (sa4.f1[1] != 2+9) {	
double got but expected 

sa4.f1[0] = 1;	sa4.f1[1] = 2;	sa4 = mono_return_double_array4(sa4, 9);	if (sa4.f1[0] != 1+9) {	return 1;	}	if (sa4.f1[1] != 2+9) {	return 2;	}	if (sa4.f1[2] != 3+9) {	
double got but expected 

if (sa4.f1[0] != 1+9) {	return 1;	}	if (sa4.f1[1] != 2+9) {	return 2;	}	if (sa4.f1[2] != 3+9) {	return 3;	}	if (sa4.f1[3] != 4+9) {	
double got but expected 

========================= mono sample_226 =========================

int[] ss = { 2, 3, 5, 7 };	treeset<int> inner = new treeset<int>();	outer.add(inner.snapshot());	foreach (int i in ss) {	inner.add(i);	outer.add(inner.snapshot());	}	foreach (isequenced<int> s in outer) {	int sum = 0;	s.apply(delegate(int x) { sum += x; });	
set has elements and sum 

icollection<icollection<char>> anagrams = new hashset<icollection<char>>();	int count = 0;	foreach (string word in words) {	if (word != "") {	count++;	hashbag<char> anagram = new hashbag<char>();	anagram.addall<char>(word.tochararray());	anagrams.add(anagram);	}	}	
found anagrams 

========================= mono sample_30564 =========================

public static void b () {	
b 

========================= mono sample_4070 =========================

public static int main (string[] args) {	short1 s1;	s1.f1 = 1;	s1 = mono_return_short1(s1, 90);	if (s1.f1 != 1+90) {	
got but expected 

s1.f1 = 1;	s1 = mono_return_short1(s1, 90);	if (s1.f1 != 1+90) {	return 1;	}	short2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_short2(s2, 90);	if (s2.f1 != 1+90) {	
got but expected 

return 1;	}	short2 s2;	s2.f1 = 1;	s2.f2 = 2;	s2 = mono_return_short2(s2, 90);	if (s2.f1 != 1+90) {	return 1;	}	if (s2.f2 != 2+90) {	
got but expected 

}	if (s2.f2 != 2+90) {	return 2;	}	short3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_short3(s3, 90);	if (s3.f1 != 1+90) {	
got but expected 

}	short3 s3;	s3.f1 = 1;	s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_short3(s3, 90);	if (s3.f1 != 1+90) {	return 1;	}	if (s3.f2 != 2+90) {	
got but expected 

s3.f2 = 2;	s3.f3 = 3;	s3 = mono_return_short3(s3, 90);	if (s3.f1 != 1+90) {	return 1;	}	if (s3.f2 != 2+90) {	return 2;	}	if (s3.f3 != 3+90) {	
got but expected 

if (s3.f3 != 3+90) {	return 3;	}	short4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_short4(s4, 90);	if (s4.f1 != 1+90) {	
got but expected 

short4 s4;	s4.f1 = 1;	s4.f2 = 2;	s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_short4(s4, 90);	if (s4.f1 != 1+90) {	return 1;	}	if (s4.f2 != 2+90) {	
got but expected 

s4.f3 = 3;	s4.f4 = 4;	s4 = mono_return_short4(s4, 90);	if (s4.f1 != 1+90) {	return 1;	}	if (s4.f2 != 2+90) {	return 2;	}	if (s4.f3 != 3+90) {	
got but expected 

if (s4.f1 != 1+90) {	return 1;	}	if (s4.f2 != 2+90) {	return 2;	}	if (s4.f3 != 3+90) {	return 3;	}	if (s4.f4 != 4+90) {	
got but expected 

return 4;	}	short5 s5;	s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_short5(s5, 90);	if (s5.f1 != 1+90) {	
got but expected 

s5.f1 = 1;	s5.f2 = 2;	s5.f3 = 3;	s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_short5(s5, 90);	if (s5.f1 != 1+90) {	return 1;	}	if (s5.f2 != 2+90) {	
got but expected 

s5.f4 = 4;	s5.f5 = 5;	s5 = mono_return_short5(s5, 90);	if (s5.f1 != 1+90) {	return 1;	}	if (s5.f2 != 2+90) {	return 2;	}	if (s5.f3 != 3+90) {	
got but expected 

if (s5.f1 != 1+90) {	return 1;	}	if (s5.f2 != 2+90) {	return 2;	}	if (s5.f3 != 3+90) {	return 3;	}	if (s5.f4 != 4+90) {	
got but expected 

if (s5.f2 != 2+90) {	return 2;	}	if (s5.f3 != 3+90) {	return 3;	}	if (s5.f4 != 4+90) {	return 4;	}	if (s5.f5 != 5+90) {	
got but expected 

}	short6 s6;	s6.f1 = 1;	s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_short6(s6, 90);	if (s6.f1 != 1+90) {	
got but expected 

s6.f2 = 2;	s6.f3 = 3;	s6.f4 = 4;	s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_short6(s6, 90);	if (s6.f1 != 1+90) {	return 1;	}	if (s6.f2 != 2+90) {	
got but expected 

s6.f5 = 5;	s6.f6 = 6;	s6 = mono_return_short6(s6, 90);	if (s6.f1 != 1+90) {	return 1;	}	if (s6.f2 != 2+90) {	return 2;	}	if (s6.f3 != 3+90) {	
got but expected 

if (s6.f1 != 1+90) {	return 1;	}	if (s6.f2 != 2+90) {	return 2;	}	if (s6.f3 != 3+90) {	return 3;	}	if (s6.f4 != 4+90) {	
got but expected 

if (s6.f2 != 2+90) {	return 2;	}	if (s6.f3 != 3+90) {	return 3;	}	if (s6.f4 != 4+90) {	return 4;	}	if (s6.f5 != 5+90) {	
got but expected 

if (s6.f3 != 3+90) {	return 3;	}	if (s6.f4 != 4+90) {	return 4;	}	if (s6.f5 != 5+90) {	return 5;	}	if (s6.f6 != 6+90) {	
got but expected 

short7 s7;	s7.f1 = 1;	s7.f2 = 2;	s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_short7(s7, 90);	if (s7.f1 != 1+90) {	
got but expected 

s7.f3 = 3;	s7.f4 = 4;	s7.f5 = 5;	s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_short7(s7, 90);	if (s7.f1 != 1+90) {	return 1;	}	if (s7.f2 != 2+90) {	
got but expected 

s7.f6 = 6;	s7.f7 = 7;	s7 = mono_return_short7(s7, 90);	if (s7.f1 != 1+90) {	return 1;	}	if (s7.f2 != 2+90) {	return 2;	}	if (s7.f3 != 3+90) {	
got but expected 

if (s7.f1 != 1+90) {	return 1;	}	if (s7.f2 != 2+90) {	return 2;	}	if (s7.f3 != 3+90) {	return 3;	}	if (s7.f4 != 4+90) {	
got but expected 

if (s7.f2 != 2+90) {	return 2;	}	if (s7.f3 != 3+90) {	return 3;	}	if (s7.f4 != 4+90) {	return 4;	}	if (s7.f5 != 5+90) {	
got but expected 

if (s7.f3 != 3+90) {	return 3;	}	if (s7.f4 != 4+90) {	return 4;	}	if (s7.f5 != 5+90) {	return 5;	}	if (s7.f6 != 6+90) {	
got but expected 

if (s7.f4 != 4+90) {	return 4;	}	if (s7.f5 != 5+90) {	return 5;	}	if (s7.f6 != 6+90) {	return 6;	}	if (s7.f7 != 7+90) {	
got but expected 

s8.f1 = 1;	s8.f2 = 2;	s8.f3 = 3;	s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_short8(s8, 90);	if (s8.f1 != 1+90) {	
got but expected 

s8.f4 = 4;	s8.f5 = 5;	s8.f6 = 6;	s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_short8(s8, 90);	if (s8.f1 != 1+90) {	return 1;	}	if (s8.f2 != 2+90) {	
got but expected 

s8.f7 = 7;	s8.f8 = 8;	s8 = mono_return_short8(s8, 90);	if (s8.f1 != 1+90) {	return 1;	}	if (s8.f2 != 2+90) {	return 2;	}	if (s8.f3 != 3+90) {	
got but expected 

if (s8.f1 != 1+90) {	return 1;	}	if (s8.f2 != 2+90) {	return 2;	}	if (s8.f3 != 3+90) {	return 3;	}	if (s8.f4 != 4+90) {	
got but expected 

if (s8.f2 != 2+90) {	return 2;	}	if (s8.f3 != 3+90) {	return 3;	}	if (s8.f4 != 4+90) {	return 4;	}	if (s8.f5 != 5+90) {	
got but expected 

if (s8.f3 != 3+90) {	return 3;	}	if (s8.f4 != 4+90) {	return 4;	}	if (s8.f5 != 5+90) {	return 5;	}	if (s8.f6 != 6+90) {	
got but expected 

if (s8.f4 != 4+90) {	return 4;	}	if (s8.f5 != 5+90) {	return 5;	}	if (s8.f6 != 6+90) {	return 6;	}	if (s8.f7 != 7+90) {	
got but expected 

if (s8.f5 != 5+90) {	return 5;	}	if (s8.f6 != 6+90) {	return 6;	}	if (s8.f7 != 7+90) {	return 7;	}	if (s8.f8 != 8+90) {	
got but expected 

s9.f2 = 2;	s9.f3 = 3;	s9.f4 = 4;	s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_short9(s9, 90);	if (s9.f1 != 1+90) {	
got but expected 

s9.f5 = 5;	s9.f6 = 6;	s9.f7 = 7;	s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_short9(s9, 90);	if (s9.f1 != 1+90) {	return 1;	}	if (s9.f2 != 2+90) {	
got but expected 

s9.f8 = 8;	s9.f9 = 9;	s9 = mono_return_short9(s9, 90);	if (s9.f1 != 1+90) {	return 1;	}	if (s9.f2 != 2+90) {	return 2;	}	if (s9.f3 != 3+90) {	
got but expected 

if (s9.f1 != 1+90) {	return 1;	}	if (s9.f2 != 2+90) {	return 2;	}	if (s9.f3 != 3+90) {	return 3;	}	if (s9.f4 != 4+90) {	
got but expected 

if (s9.f2 != 2+90) {	return 2;	}	if (s9.f3 != 3+90) {	return 3;	}	if (s9.f4 != 4+90) {	return 4;	}	if (s9.f5 != 5+90) {	
got but expected 

if (s9.f3 != 3+90) {	return 3;	}	if (s9.f4 != 4+90) {	return 4;	}	if (s9.f5 != 5+90) {	return 5;	}	if (s9.f6 != 6+90) {	
got but expected 

if (s9.f4 != 4+90) {	return 4;	}	if (s9.f5 != 5+90) {	return 5;	}	if (s9.f6 != 6+90) {	return 6;	}	if (s9.f7 != 7+90) {	
got but expected 

if (s9.f5 != 5+90) {	return 5;	}	if (s9.f6 != 6+90) {	return 6;	}	if (s9.f7 != 7+90) {	return 7;	}	if (s9.f8 != 8+90) {	
got but expected 

if (s9.f6 != 6+90) {	return 6;	}	if (s9.f7 != 7+90) {	return 7;	}	if (s9.f8 != 8+90) {	return 8;	}	if (s9.f9 != 9+90) {	
got but expected 

sn8.nested1.f1 = 1;	sn8.f2 = 2;	sn8.f3 = 3;	sn8.f4 = 4;	sn8.f5 = 5;	sn8.f6 = 6;	sn8.f7 = 7;	sn8.nested2.f8 = 8;	sn8 = mono_return_short8_nested(sn8, 90);	if (sn8.nested1.f1 != 1+90) {	
nested got but expected 

sn8.f4 = 4;	sn8.f5 = 5;	sn8.f6 = 6;	sn8.f7 = 7;	sn8.nested2.f8 = 8;	sn8 = mono_return_short8_nested(sn8, 90);	if (sn8.nested1.f1 != 1+90) {	return 1;	}	if (sn8.f2 != 2+90) {	
nested got but expected 

sn8.f7 = 7;	sn8.nested2.f8 = 8;	sn8 = mono_return_short8_nested(sn8, 90);	if (sn8.nested1.f1 != 1+90) {	return 1;	}	if (sn8.f2 != 2+90) {	return 2;	}	if (sn8.f3 != 3+90) {	
nested got but expected 

if (sn8.nested1.f1 != 1+90) {	return 1;	}	if (sn8.f2 != 2+90) {	return 2;	}	if (sn8.f3 != 3+90) {	return 3;	}	if (sn8.f4 != 4+90) {	
nested got but expected 

if (sn8.f2 != 2+90) {	return 2;	}	if (sn8.f3 != 3+90) {	return 3;	}	if (sn8.f4 != 4+90) {	return 4;	}	if (sn8.f5 != 5+90) {	
nested got but expected 

if (sn8.f3 != 3+90) {	return 3;	}	if (sn8.f4 != 4+90) {	return 4;	}	if (sn8.f5 != 5+90) {	return 5;	}	if (sn8.f6 != 6+90) {	
nested got but expected 

if (sn8.f4 != 4+90) {	return 4;	}	if (sn8.f5 != 5+90) {	return 5;	}	if (sn8.f6 != 6+90) {	return 6;	}	if (sn8.f7 != 7+90) {	
nested got but expected 

if (sn8.f5 != 5+90) {	return 5;	}	if (sn8.f6 != 6+90) {	return 6;	}	if (sn8.f7 != 7+90) {	return 7;	}	if (sn8.nested2.f8 != 8+90) {	
nested got but expected 

========================= mono sample_277 =========================

mpi = myself.getmethod ("mypublic", bf);	mpia = mpi.attributes & methodattributes.memberaccessmask;	if (mpia != methodattributes.public) return 3;	mpi = myself.getmethod ("myprivate", bf);	mpia = mpi.attributes & methodattributes.memberaccessmask;	if (mpia != methodattributes.private) return 4;	constructorinfo ci = typeof (abstract).getconstructor (bindingflags.public | bindingflags.nonpublic | bindingflags.instance, null, new type [0], new parametermodifier [0]);	if (!ci.isfamily) return 5;	ci = typeof (plain).getconstructor (bindingflags.public | bindingflags.nonpublic | bindingflags.instance, null, new type [0], new parametermodifier [0]);	if (!ci.ispublic) return 6;	
all tests pass 

========================= mono sample_3802 =========================

public static void main() {	
assemblyresolve 

========================= mono sample_3797 =========================

e.compile () ();	e = () => new node () { values = { } };	mie = (memberinitexpression) e.body;	if (mie.bindings[0].bindingtype != memberbindingtype.memberbinding) return 4;	e.compile () ();	e = () => new node() { parent = { name = "parent" }, values = { 4, 5, 7, 8 } };	mie = (memberinitexpression) e.body;	if (mie.bindings[0].bindingtype != memberbindingtype.memberbinding) return 5;	if (mie.bindings[1].bindingtype != memberbindingtype.listbinding) return 6;	e.compile () ();	
ok 

========================= mono sample_3686 =========================

static void main () {	console.writeline ("/*");	
don t edit this file 

static void main () {	console.writeline ("/*");	
this file was generated by gen cs use it instead 

static void main () {	console.writeline ("/*");	console.writeline ("*/");	foreach (var c in cookies) {	
static void 

static void main () {	console.writeline ("/*");	console.writeline ("*/");	foreach (var c in cookies) {	
wasm invoke c tolower void target func interpmethodarguments margs 

console.write ("func (");	for (int i = 1; i < c.length; ++i) {	char p = c [i];	if (i > 1) console.write (", ");	console.write (ctx.emit (p));	}	console.writeline (");");	if (c [0] != 'v') console.writeline ($"\t*({typetosigtype (c [0])}*)margs->retval = res;");	console.writeline ("\n}\n");	}	
static void icall trampoline dispatch const char cookie void target func interpmethodarguments margs 

}	console.writeline (");");	if (c [0] != 'v') console.writeline ($"\t*({typetosigtype (c [0])}*)margs->retval = res;");	console.writeline ("\n}\n");	}	console.writeline ("{");	for (int i = 0; i < cookies.length; ++i) {	var c = cookies [i];	console.write ("\t");	if (i > 0) console.write ("else ");	
if strcmp cookie 

}	console.writeline (");");	if (c [0] != 'v') console.writeline ($"\t*({typetosigtype (c [0])}*)margs->retval = res;");	console.writeline ("\n}\n");	}	console.writeline ("{");	for (int i = 0; i < cookies.length; ++i) {	var c = cookies [i];	console.write ("\t");	if (i > 0) console.write ("else ");	
wasm invoke c tolower target func margs 

console.writeline (");");	if (c [0] != 'v') console.writeline ($"\t*({typetosigtype (c [0])}*)margs->retval = res;");	console.writeline ("\n}\n");	}	console.writeline ("{");	for (int i = 0; i < cookies.length; ++i) {	var c = cookies [i];	console.write ("\t");	if (i > 0) console.write ("else ");	}	
else 

console.writeline (");");	if (c [0] != 'v') console.writeline ($"\t*({typetosigtype (c [0])}*)margs->retval = res;");	console.writeline ("\n}\n");	}	console.writeline ("{");	for (int i = 0; i < cookies.length; ++i) {	var c = cookies [i];	console.write ("\t");	if (i > 0) console.write ("else ");	}	
printf cookie 

console.writeline (");");	if (c [0] != 'v') console.writeline ($"\t*({typetosigtype (c [0])}*)margs->retval = res;");	console.writeline ("\n}\n");	}	console.writeline ("{");	for (int i = 0; i < cookies.length; ++i) {	var c = cookies [i];	console.write ("\t");	if (i > 0) console.write ("else ");	}	
g assert 

========================= mono sample_121 =========================

public static bool init (webbrowser control, platform platform) {	lock (initlock) {	if (!initialized) {	platform mozplatform;	try {	short version = gluezilla_init (platform, out mozplatform);	monomozdir = system.io.path.combine ( system.io.path.combine ( environment.getfolderpath (environment.specialfolder.localapplicationdata), ".mono"), "mozilla-" + version);	if (!system.io.directory.exists (monomozdir)) system.io.directory.createdirectory (monomozdir);	}	catch (dllnotfoundexception) {	
libgluezilla not found to have webbrowser support you need libgluezilla installed 

========================= mono sample_4237 =========================

try {	synchronizationcontext.setsynchronizationcontext (context);	var t = test ();	await_mre.set ();	if (!t.wait (3000)) return 3;	if (!mre.waitone (3000)) return 2;	} finally {	synchronizationcontext.setsynchronizationcontext (null);	}	if (context.started != 0 || context.completed != 0 || context.sendcounter != 0) return 1;	
ok 

========================= mono sample_3457 =========================

public static int main() {	fieldinfo fieldinfo = typeof(myclass).getfield("myconst", bindingflags.static | bindingflags.public);	accessibleattribute[] attributes = fieldinfo.getcustomattributes( typeof(accessibleattribute), true) as accessibleattribute[];	if (attributes != null) {	
succeeded 

========================= mono sample_1873 =========================

public static void main () {	
main 

========================= mono sample_33628 =========================

for (int field = 0; field < fieldcount; field++) {	writer.write("<td>");	writer.beginstylecontext();	writer.enterstyle(labelstyle);	writer.writetext(control.allfields[fieldindices[field]].title, true);	writer.exitstyle(labelstyle);	writer.endstylecontext();	writer.write("</td>");	}	if (itemrequiresmorebutton) {	
td 

writer.write("<td>");	writer.beginstylecontext();	writer.enterstyle(labelstyle);	writer.writetext(control.allfields[fieldindices[field]].title, true);	writer.exitstyle(labelstyle);	writer.endstylecontext();	writer.write("</td>");	}	if (itemrequiresmorebutton) {	}	
tr 

writer.writetext(control.allfields[fieldindices[field]].title, true);	writer.exitstyle(labelstyle);	writer.endstylecontext();	writer.write("</td>");	}	if (itemrequiresmorebutton) {	}	renderrule(writer, forecolor, fieldcount + 1);	for (int i = 0; i < pagesize; i++) {	objectlistitem item = items[pagestart + i];	
tr 

writer.exitstyle(style);	writer.endstylecontext();	}	else {	writer.beginstylecontext();	writer.enterstyle(style);	writer.writetext(item[fieldindices[field]], true);	writer.exitstyle(style);	writer.endstylecontext();	}	
td 

if (itemrequiresmorebutton) {	writer.write("<td align=right>");	writer.beginstylecontext();	writer.enterformat(subcommandstyle);	string moretext = control.moretext.length == 0 ? getdefaultlabel(morelabel) : control.moretext;	renderpostbackeventasanchor(writer, string.format(cultureinfo.invariantculture, showmoreformat, item.index), moretext, subcommandstyle);	writer.exitformat(subcommandstyle);	writer.endstylecontext();	writer.write("</td>\r\n");	}	
tr 

========================= mono sample_6050 =========================

public static int main(string[] args) {	
hello from bug helper 

========================= mono sample_243 =========================

public static void main(string[] args) {	arraylist<int> list = new arraylist<int>(), copy1, copy2;	list.addall(new int[] { 2, 3, 5, 7, 11, 13, 17, 19 });	copy1 = (arraylist<int>)list.clone();	copy2 = (arraylist<int>)list.clone();	const int n = 7;	
with replacement 

public static void main(string[] args) {	arraylist<int> list = new arraylist<int>(), copy1, copy2;	list.addall(new int[] { 2, 3, 5, 7, 11, 13, 17, 19 });	copy1 = (arraylist<int>)list.clone();	copy2 = (arraylist<int>)list.clone();	const int n = 7;	foreach (int x in randomwith(list, n)) console.write("{0} ", x);	
without replacement 

public static void main(string[] args) {	arraylist<int> list = new arraylist<int>(), copy1, copy2;	list.addall(new int[] { 2, 3, 5, 7, 11, 13, 17, 19 });	copy1 = (arraylist<int>)list.clone();	copy2 = (arraylist<int>)list.clone();	const int n = 7;	foreach (int x in randomwith(list, n)) console.write("{0} ", x);	foreach (int x in randomwithout1(copy1, n)) console.write("{0} ", x);	
without replacement 

========================= mono sample_30550 =========================

static bool runtest (methodinfo test) {	console.write ("running test {0, -25}", test.name);	try {	task t = test.invoke (new tester (), null) as task;	if (!task.waitall (new[] { t }, 1000)) {	
failed timeout 

}	} else {	var tb = t as task<bool>;	if (tb != null) {	if (!tb.result) {	console.writeline ("failed (result={0})", tb.result);	return false;	}	}	}	
ok 

var tb = t as task<bool>;	if (tb != null) {	if (!tb.result) {	console.writeline ("failed (result={0})", tb.result);	return false;	}	}	}	return true;	} catch (exception e) {	
failed 

public static int main () {	var tests = from test in typeof (tester).getmethods (bindingflags.instance | bindingflags.nonpublic | bindingflags.declaredonly) where test.getparameters ().length == 0 && !test.isdefined (typeof (compilergeneratedattribute), false) orderby test.name select runtest (test);	int failures = tests.count (a => !a);	
tests failed 

========================= mono sample_3624 =========================

static void emittargetmethod (typebuilder genericfoo) {	methodbuilder mb = genericfoo.definemethod ("targetmethod", methodattributes.public, typeof (void), new type[] {typeof (object) });	ilgenerator il = mb.getilgenerator ();	for (int i = 0; i < 20; ++i) il.emit (opcodes.nop);	il.emit (opcodes.ldtoken, genericargs [0]);	il.emit (opcodes.call, typeof (type).getmethod ("gettypefromhandle"));	
writeline 

========================= mono sample_212 =========================

protected internal override void dump(textwriter tw, string prefix) {	
empty 

========================= mono sample_29574 =========================

public static int main () {	object[] attrs = typeof(x).getcustomattributes(typeof (x),false);	if (attrs.length != 1) return 2;	x x = attrs [0] as x;	if (x.id != 55) return 2;	
ok 

========================= mono sample_2346 =========================

static void main () {	
debug mode 

static void main () {	
non debug mode 

========================= mono sample_33166 =========================

public static void readclob (oracleconnection connection) {	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select clob_column from clobtest";	oracledatareader reader2 = rcmd.executereader ();	
error record not found 

public static void readclob (oracleconnection connection) {	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select clob_column from clobtest";	oracledatareader reader2 = rcmd.executereader ();	
testing oraclelob object 

public static void readclob (oracleconnection connection) {	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select clob_column from clobtest";	oracledatareader reader2 = rcmd.executereader ();	oraclelob lob2 = reader2.getoraclelob (0);	
length 

public static void readclob (oracleconnection connection) {	oraclecommand rcmd = connection.createcommand ();	rcmd.commandtext = "select clob_column from clobtest";	oracledatareader reader2 = rcmd.executereader ();	oraclelob lob2 = reader2.getoraclelob (0);	
chunk size 

public static void clobtest (oracleconnection connection) {	
begin transaction 

public static void clobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	
drop table clobtest 

public static void clobtest (oracleconnection connection) {	oracletransaction transaction = connection.begintransaction ();	try {	oraclecommand cmd2 = connection.createcommand ();	cmd2.transaction = transaction;	cmd2.commandtext = "drop table clobtest";	cmd2.executenonquery ();	}	catch (oracleexception oe1) {	}	
create table 

cmd2.transaction = transaction;	cmd2.commandtext = "drop table clobtest";	cmd2.executenonquery ();	}	catch (oracleexception oe1) {	}	oraclecommand create = connection.createcommand ();	create.transaction = transaction;	create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	
insert record 

create.transaction = transaction;	create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	
selecting a clob character value from clobtest 

create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	
error record not found 

create.commandtext = "create table clobtest (clob_column clob)";	create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	
testing oraclelob object 

create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	
length 

create.executenonquery ();	oraclecommand insert = connection.createcommand ();	insert.transaction = transaction;	insert.commandtext = "insert into clobtest values (empty_clob())";	insert.executenonquery ();	oraclecommand select = connection.createcommand ();	select.transaction = transaction;	select.commandtext = "select clob_column from clobtest for update";	oracledatareader reader = select.executereader ();	oraclelob lob = reader.getoraclelob (0);	
chunk size 

oraclelob lob = reader.getoraclelob (0);	unicodeencoding encoding = new unicodeencoding ();	try {	using (streamreader sr = new streamreader(infilename)) {	string sbuff = sr.readtoend ();	byte[] evalue = encoding.getbytes (sbuff);	lob.write (evalue, 0, evalue.length);	}	}	catch (exception e) {	
the file could not be read 

using (streamreader sr = new streamreader(infilename)) {	string sbuff = sr.readtoend ();	byte[] evalue = encoding.getbytes (sbuff);	lob.write (evalue, 0, evalue.length);	}	}	catch (exception e) {	console.writeline(e.message);	}	lob.close ();	
closing reader 

========================= mono sample_4918 =========================

type[] ctorparams = new type[] { typeof (string),typeof (string) };	constructorinfo classctorinfo = typeof (customattribute).getconstructor (ctorparams);	customattributebuilder feildcabuilder = new customattributebuilder ( classctorinfo, new object [] { "one","two" }	), methodcabuilder = new customattributebuilder ( classctorinfo, new object [] { "hello","world" }	);	fieldbuilder fieldbuilder= typebuilder.definefield ("str", typeof (string), fieldattributes.public);	fieldbuilder.setcustomattribute (feildcabuilder);	methodbuilder methodbuilder= typebuilder.definemethod ("print", methodattributes.public, null, null);	methodbuilder.setcustomattribute (methodcabuilder);	ilgenerator methodil = methodbuilder.getilgenerator ();	
hello world 

========================= mono sample_27577 =========================

static int main2(string[] args) #else static int main(string[] args) #endif {	type type = null;	system.text.stringbuilder code = new stringbuilder ();	try {	if (args.length != 2 && args.length != 3) {	
must supply at least two arguments 

static int main2(string[] args) #else static int main(string[] args) #endif {	type type = null;	system.text.stringbuilder code = new stringbuilder ();	try {	if (args.length != 2 && args.length != 3) {	
type to log all to log all overrides and events for all types in system windows forms dll 

static int main2(string[] args) #else static int main(string[] args) #endif {	type type = null;	system.text.stringbuilder code = new stringbuilder ();	try {	if (args.length != 2 && args.length != 3) {	
what to log overrides events overridesevents 

static int main2(string[] args) #else static int main(string[] args) #endif {	type type = null;	system.text.stringbuilder code = new stringbuilder ();	try {	if (args.length != 2 && args.length != 3) {	
output filename 

========================= mono sample_25472 =========================

public static void main(string[] args) {	
ok 

========================= mono sample_2135 =========================

public int testme () {	c c = new c ();	
trying to set eventhandler directly should set directevent 

public int testme () {	c c = new c ();	c.member += new eventhandler (f);	if (c._member == null) return 0;	c._member = null;	
trying to set eventhandler through a interface should set a event 

public int testme () {	c c = new c ();	c.member += new eventhandler (f);	if (c._member == null) return 0;	c._member = null;	((a) c).member += new eventhandler (f);	if (c._amember == null) return 1;	c._amember = null;	
trying to set eventhandler through ba interface should set direct event 

public int testme () {	c c = new c ();	c.member += new eventhandler (f);	if (c._member == null) return 0;	c._member = null;	((a) c).member += new eventhandler (f);	if (c._amember == null) return 1;	c._amember = null;	((ba) c).member += new eventhandler (f);	if (c._member == null) return 2;	
ok 

========================= mono sample_2075 =========================

public static int main () {	int a = 0;	d d1 = delegate {	
first 

public static int main () {	int a = 0;	d d1 = delegate {	a = 1;	};	d d2 = delegate {	
second 

a = 1;	};	d d2 = delegate {	a = 2;	};	if (!t (a, 0)) return 1;	d1 ();	if (!t (a, 1)) return 2;	d2 ();	if (!t (a, 2)) return 3;	
test passes ok 

========================= mono sample_3088 =========================

public dummy entry (label pc, method method, textwriter data) {	
method entry 

public dummy assume (label pc, edgetag tag, source condition, textwriter data) {	
assume 

public dummy assert (label pc, edgetag tag, source condition, textwriter data) {	
assert 

public dummy branch (label pc, label target, bool leavesexceptionblock, textwriter data) {	
branch 

public dummy branchcond (label pc, label target, branchoperator bop, source value1, source value2, textwriter data) {	
br 

public dummy branchtrue (label pc, label target, source cond, textwriter data) {	
br true 

public dummy branchfalse (label pc, label target, source cond, textwriter data) {	
br false 

public dummy break (label pc, textwriter data) {	
break 

public dummy copyblock (label pc, source destaddress, source srcaddress, source len, textwriter data) {	
cpblk 

public dummy nop (label pc, textwriter data) {	
nop 

public dummy pop (label pc, source source, textwriter data) {	
pop 

public dummy return (label pc, source source, textwriter data) {	
ret 

public dummy storearg (label pc, parameter argument, source source, textwriter data) {	
starg 

public dummy storelocal (label pc, local local, source source, textwriter data) {	
stloc 

public dummy switch (label pc, typenode type, ienumerable<pair<object, label>> cases, source value, textwriter data) {	
switch 

public dummy copyobj (label pc, typenode type, source destptr, source sourceptr, textwriter data) {	
cpobj 

public dummy initobj (label pc, typenode type, source ptr, textwriter data) {	
initobj 

public dummy storefield (label pc, field field, source obj, source value, textwriter data) {	
stfld 

public dummy storestaticfield (label pc, field field, source value, textwriter data) {	
stsfld 

========================= mono sample_29616 =========================

protected virtual type mapdbtype(string columnname, idatatype datatype) {	if (datatype == null) throw new argumentnullexception("datatype");	if (datatype.managedtype != null) return type.gettype(datatype.managedtype, true);	string datatypel = datatype.sqltype.tolowerinvariant();	if (columnname != null && columnname.tolower().contains("guid")) {	bool correcttypeandlen = ((datatypel == "char" || datatypel == "varchar") && datatype.length == 36) || ((datatypel == "binary") && datatype.length == 16);	if (correcttypeandlen) {	
experimental support for guid 

========================= mono sample_24969 =========================

public override void replay (mergeinfo<tfunc, tabstractdomain> merge) {	if (!merge.iscommon (this.from)) return;	symvalue sv1 = merge.graph1.lookupwithoutmanifesting (this.from, this.function);	symvalue sv2 = merge.graph2.lookupwithoutmanifesting (this.from, this.function);	if (sv1 != null && sv2 != null) return;	if (sv1 != null) {	if (debugoptions.debug) {	
symgraph changed due to eliminateedgeupdate that is only in 

========================= mono sample_29511 =========================

if (scriptresourcename.endswith (".resources", runtimehelpers.stringcomparison)) {	scriptresourcename = scriptresourcename.substring (0, scriptresourcename.length - 10);	rset = new resourcemanager (scriptresourcename, assembly).getresourceset (threading.thread.currentthread.currentuiculture, true, true);	}	else throw;	}	if (rset == null) break;	writer.writeline ();	string ns = sra.typename;	int indx = ns.lastindexof ('.');	
type registernamespace 

========================= mono sample_31117 =========================

string config_str = xr.readstring ();	if (string.isnullorempty (config_str)) continue;	guid guid;	if (tryparseguid (guid_str, out guid)) guidtoconfigplatform [guid] = config_str;	if (!string.isnullorempty (abs_path)) {	abs_path = path.getfullpath (abs_path);	absolutepathtoconfigplatform [abs_path] = config_str;	}	}	} catch (xmlexception xe) {	
xmlexception while parsing solutionconfigurationcontents 

========================= mono sample_22277 =========================

static void printurls (rooturlscollection col) {	for (int i = 0; i < col.count; i++) {	configurationelement e = col [i];	urlconfigelement ue = e as urlconfigelement;	if (ue != null) {	
port 

static void printurls (urlscollection col) {	for (int i = 0; i < col.count; i++) {	configurationelement e = col [i];	urlconfigelement ue = e as urlconfigelement;	if (ue != null) {	
port 

static void printurls (groupelement col) {	
group name 

static void showurls () {	try {	urlssection myurlssection = configurationmanager.getsection ("myurls") as urlssection;	if (myurlssection == null) console.writeline ("failed to load urlssection.");	else {	
my urls 

static void main (string [] args) {	
current urls 

========================= mono sample_29830 =========================

